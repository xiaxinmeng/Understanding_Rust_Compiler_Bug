{"sha": "5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVlMzFlNTdkMmZlNzBhNzg0N2RhZTJhM2RmMGYxOWUzODc1ZmQ5Nw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-01-26T09:53:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-01-26T09:53:33Z"}, "message": "PR 69400: Invalid 128-bit modulus result\n\nAs described in the PR, wi::divmod_internal was sign- rather than\nzero-extending a modulus result in cases where the result has fewer\nHWIs than the precision and the upper bit of the upper HWI was set.\n\nThis patch tries to make things more robust by getting wi_pack\nto handle the canonicalisation step itself.\n\nTested on x86_64-linux-gnu.  I added tests to the wide-int\nplugin since that seemed more direct.\n\ngcc/\n\tPR tree-optimization/69400\n\t* wide-int.cc (wi_pack): Take the precision as argument and\n\tperform canonicalization here rather than in the callers.\n\tUse the main loop to handle all full-width HWIs.  Add a\n\tzero HWI if in_len isn't a full result.\n\t(wi::divmod_internal): Update accordingly.\n\t(wi::mul_internal): Likewise.  Simplify.\n\ngcc/testsuite/\n\tPR tree-optimization/69400\n\t* gcc.dg/plugin/wide-int_plugin.c (test_wide_int_mod_trunc): New\n\tfunction.\n\t(plugin_init): Call it.\n\t* gcc.dg/torture/pr69400.c: New test.\n\nFrom-SVN: r232817", "tree": {"sha": "fd774b686410ec17d1edca42822f9013a8f9d3e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd774b686410ec17d1edca42822f9013a8f9d3e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7ddfb31dfd323973d479e89a6a6e386b95d06de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ddfb31dfd323973d479e89a6a6e386b95d06de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ddfb31dfd323973d479e89a6a6e386b95d06de5"}], "stats": {"total": 120, "additions": 90, "deletions": 30}, "files": [{"sha": "7a4e57bddbd4006b2e7fc4a2fde6e8c10ce4e718", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "patch": "@@ -1,3 +1,13 @@\n+2016-01-26  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/69400\n+\t* wide-int.cc (wi_pack): Take the precision as argument and\n+\tperform canonicalization here rather than in the callers.\n+\tUse the main loop to handle all full-width HWIs.  Add a\n+\tzero HWI if in_len isn't a full result.\n+\t(wi::divmod_internal): Update accordingly.\n+\t(wi::mul_internal): Likewise.  Simplify.\n+\n 2016-01-25  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "ffb4314b9e6b92196217631d6f4f25b0b87c2ca9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "patch": "@@ -1,3 +1,11 @@\n+2016-01-26  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/69400\n+\t* gcc.dg/plugin/wide-int_plugin.c (test_wide_int_mod_trunc): New\n+\tfunction.\n+\t(plugin_init): Call it.\n+\t* gcc.dg/torture/pr69400.c: New test.\n+\n 2016-01-26  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/arm/pr68674.c: Check and use arm_fp effective target."}, {"sha": "eea56be5e7c2a3661786bd8dad3a474f09688538", "filename": "gcc/testsuite/gcc.dg/plugin/wide-int_plugin.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fwide-int_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fwide-int_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fwide-int_plugin.c?ref=5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "patch": "@@ -36,11 +36,44 @@ test_wide_int_round_sdiv (void)\n     abort ();\n }\n \n+static void\n+test_wide_int_mod_trunc (void)\n+{\n+  for (unsigned int i = 1; i < MAX_BITSIZE_MODE_ANY_INT; ++i)\n+    {\n+      if (wi::smod_trunc (wi::lshift (1, i + 1) - 3,\n+\t\t\t  wi::lshift (1, i) - 1)\n+\t  != wi::lshift (1, i) - 2)\n+\tabort ();\n+      for (unsigned int base = 32; base <= MAX_BITSIZE_MODE_ANY_INT; base *= 2)\n+\tfor (int bias = -1; bias <= 1; ++bias)\n+\t  {\n+\t    unsigned int precision = base + bias;\n+\t    if (i + 1 < precision && precision <= MAX_BITSIZE_MODE_ANY_INT)\n+\t      {\n+\t\twide_int one = wi::uhwi (1, precision);\n+\t\twide_int a = wi::lshift (one, i + 1) - 3;\n+\t\twide_int b = wi::lshift (one, i) - 1;\n+\t\twide_int c = wi::lshift (one, i) - 2;\n+\t\tif (wi::umod_trunc (a, b) != c)\n+\t\t  abort ();\n+\t\tif (wi::smod_trunc (a, b) != c)\n+\t\t  abort ();\n+\t\tif (wi::smod_trunc (-a, b) != -c)\n+\t\t  abort ();\n+\t\tif (wi::smod_trunc (a, -b) != c)\n+\t\t  abort ();\n+\t      }\n+\t  }\n+    }\n+}\n+\n int\n plugin_init (struct plugin_name_args *plugin_info,\n \t     struct plugin_gcc_version *version)\n {\n   test_double_int_round_udiv ();\n   test_wide_int_round_sdiv ();\n+  test_wide_int_mod_trunc ();\n   return 0;\n }"}, {"sha": "e0eb521244d0d7713cf3bd6365f6185a8587504b", "filename": "gcc/testsuite/gcc.dg/torture/pr69400.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69400.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69400.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr69400.c?ref=5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do run { target int128 } } */\n+\n+typedef unsigned __int128 u128;\n+\n+u128 __attribute__((noinline, noclone))\n+foo(void)\n+{\n+\tu128 u = -2;\n+\tu %= 0xffffffffffffffffllu;\n+\treturn u;\n+}\n+\n+int\n+main()\n+{\n+\tu128 x = foo();\n+\tif (x != 0xfffffffffffffffellu)\n+\t\t__builtin_abort();\n+\treturn 0;\n+}"}, {"sha": "195ac26fa561759f4edad0e9cc3f7cef53660475", "filename": "gcc/wide-int.cc", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Fwide-int.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ee31e57d2fe70a7847dae2a3df0f19e3875fd97/gcc%2Fwide-int.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.cc?ref=5ee31e57d2fe70a7847dae2a3df0f19e3875fd97", "patch": "@@ -1214,30 +1214,32 @@ wi_unpack (unsigned HOST_HALF_WIDE_INT *result, const HOST_WIDE_INT *input,\n     result[j++] = mask;\n }\n \n-/* The inverse of wi_unpack.  IN_LEN is the the number of input\n-   blocks.  The number of output blocks will be half this amount.  */\n-static void\n-wi_pack (unsigned HOST_WIDE_INT *result,\n+/* The inverse of wi_unpack.  IN_LEN is the number of input\n+   blocks and PRECISION is the precision of the result.  Return the\n+   number of blocks in the canonicalized result.  */\n+static unsigned int\n+wi_pack (HOST_WIDE_INT *result,\n \t const unsigned HOST_HALF_WIDE_INT *input,\n-\t unsigned int in_len)\n+\t unsigned int in_len, unsigned int precision)\n {\n   unsigned int i = 0;\n   unsigned int j = 0;\n+  unsigned int blocks_needed = BLOCKS_NEEDED (precision);\n \n-  while (i + 2 < in_len)\n+  while (i + 1 < in_len)\n     {\n-      result[j++] = (unsigned HOST_WIDE_INT)input[i]\n-\t| ((unsigned HOST_WIDE_INT)input[i + 1]\n-\t   << HOST_BITS_PER_HALF_WIDE_INT);\n+      result[j++] = ((unsigned HOST_WIDE_INT) input[i]\n+\t\t     | ((unsigned HOST_WIDE_INT) input[i + 1]\n+\t\t\t<< HOST_BITS_PER_HALF_WIDE_INT));\n       i += 2;\n     }\n \n   /* Handle the case where in_len is odd.   For this we zero extend.  */\n   if (in_len & 1)\n-    result[j++] = (unsigned HOST_WIDE_INT)input[i];\n-  else\n-    result[j++] = (unsigned HOST_WIDE_INT)input[i]\n-      | ((unsigned HOST_WIDE_INT)input[i + 1] << HOST_BITS_PER_HALF_WIDE_INT);\n+    result[j++] = (unsigned HOST_WIDE_INT) input[i];\n+  else if (j < blocks_needed)\n+    result[j++] = 0;\n+  return canonize (result, j, precision);\n }\n \n /* Multiply Op1 by Op2.  If HIGH is set, only the upper half of the\n@@ -1460,19 +1462,8 @@ wi::mul_internal (HOST_WIDE_INT *val, const HOST_WIDE_INT *op1val,\n \t  *overflow = true;\n     }\n \n-  if (high)\n-    {\n-      /* compute [prec] <- ([prec] * [prec]) >> [prec] */\n-      wi_pack ((unsigned HOST_WIDE_INT *) val,\n-\t       &r[half_blocks_needed], half_blocks_needed);\n-      return canonize (val, blocks_needed, prec);\n-    }\n-  else\n-    {\n-      /* compute [prec] <- ([prec] * [prec]) && ((1 << [prec]) - 1) */\n-      wi_pack ((unsigned HOST_WIDE_INT *) val, r, half_blocks_needed);\n-      return canonize (val, blocks_needed, prec);\n-    }\n+  int r_offset = high ? half_blocks_needed : 0;\n+  return wi_pack (val, &r[r_offset], half_blocks_needed, prec);\n }\n \n /* Compute the population count of X.  */\n@@ -1847,8 +1838,7 @@ wi::divmod_internal (HOST_WIDE_INT *quotient, unsigned int *remainder_len,\n   unsigned int quotient_len = 0;\n   if (quotient)\n     {\n-      wi_pack ((unsigned HOST_WIDE_INT *) quotient, b_quotient, m);\n-      quotient_len = canonize (quotient, (m + 1) / 2, dividend_prec);\n+      quotient_len = wi_pack (quotient, b_quotient, m, dividend_prec);\n       /* The quotient is neg if exactly one of the divisor or dividend is\n \t neg.  */\n       if (dividend_neg != divisor_neg)\n@@ -1859,8 +1849,7 @@ wi::divmod_internal (HOST_WIDE_INT *quotient, unsigned int *remainder_len,\n \n   if (remainder)\n     {\n-      wi_pack ((unsigned HOST_WIDE_INT *) remainder, b_remainder, n);\n-      *remainder_len = canonize (remainder, (n + 1) / 2, dividend_prec);\n+      *remainder_len = wi_pack (remainder, b_remainder, n, dividend_prec);\n       /* The remainder is always the same sign as the dividend.  */\n       if (dividend_neg)\n \t*remainder_len = wi::sub_large (remainder, zeros, 1, remainder,"}]}