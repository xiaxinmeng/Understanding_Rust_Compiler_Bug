{"sha": "69921f4a7ec081c5b37dae13e3372003e4efd49f", "node_id": "C_kwDOANBUbNoAKDY5OTIxZjRhN2VjMDgxYzViMzdkYWUxM2UzMzcyMDAzZTRlZmQ0OWY", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-03-16T17:31:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2022-03-16T20:52:32Z"}, "message": "libgo: update to final Go 1.18 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/393377", "tree": {"sha": "3c485503e44039e60d49bc2450e9a28153496706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c485503e44039e60d49bc2450e9a28153496706"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69921f4a7ec081c5b37dae13e3372003e4efd49f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69921f4a7ec081c5b37dae13e3372003e4efd49f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69921f4a7ec081c5b37dae13e3372003e4efd49f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69921f4a7ec081c5b37dae13e3372003e4efd49f/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fd6e36ea9aa8575841ff1da08b4aebc0298abe2"}], "stats": {"total": 2587, "additions": 1983, "deletions": 604}, "files": [{"sha": "afaccb0e9e6edbb85ebcc61e8bd586db5604c5bb", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -1,4 +1,4 @@\n-5042f7efbdb2d64537dfef53a19e96ee5ec4db2d\n+7f33baa09a8172bb2c5f1ca0435d9efe3e194c9b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "85536ade650215790507cb907a3d6c97c5a1fd41", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -1,4 +1,4 @@\n-cb5a598d7f2ebd276686403d141a97c026d33458\n+4aa1efed4853ea067d665a952eee77c52faac774\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "39560f0fcdd63e4bb8eead6a3f849e91636d31eb", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -1 +1 @@\n-go1.18rc1\n+go1.18"}, {"sha": "420529b1a96ac7e6fa86c8d59ccefed29ef25a2f", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -1356,14 +1356,20 @@\n //\n // Workspace maintenance\n //\n-// Go workspace provides access to operations on workspaces.\n+// Work provides access to operations on workspaces.\n //\n // Note that support for workspaces is built into many other commands, not\n // just 'go work'.\n //\n // See 'go help modules' for information about Go's module system of which\n // workspaces are a part.\n //\n+// See https://go.dev/ref/mod#workspaces for an in-depth reference on\n+// workspaces.\n+//\n+// See https://go.dev/doc/tutorial/workspaces for an introductory\n+// tutorial on workspaces.\n+//\n // A workspace is specified by a go.work file that specifies a set of\n // module directories with the \"use\" directive. These modules are used as\n // root modules by the go command for builds and related operations.  A\n@@ -1485,9 +1491,8 @@\n // \t\tVersion string\n // \t}\n //\n-// See the workspaces design proposal at\n-// https://go.googlesource.com/proposal/+/master/design/45713-workspace.md for\n-// more information.\n+// See the workspaces reference at https://go.dev/ref/mod#workspaces\n+// for more information.\n //\n //\n // Initialize workspace file\n@@ -1507,6 +1512,9 @@\n // Each argument path is added to a use directive in the go.work file. The\n // current go version will also be listed in the go.work file.\n //\n+// See the workspaces reference at https://go.dev/ref/mod#workspaces\n+// for more information.\n+//\n //\n // Sync workspace build list to modules\n //\n@@ -1530,12 +1538,15 @@\n // build list's version of each module is always the same or higher than\n // that in each workspace module.\n //\n+// See the workspaces reference at https://go.dev/ref/mod#workspaces\n+// for more information.\n+//\n //\n // Add modules to workspace file\n //\n // Usage:\n //\n-// \tgo work use [-r] [moddirs]\n+// \tgo work use [-r] moddirs\n //\n // Use provides a command-line interface for adding\n // directories, optionally recursively, to a go.work file.\n@@ -1549,6 +1560,9 @@\n // were specified as arguments: namely, use directives will be added for\n // directories that exist, and removed for directories that do not exist.\n //\n+// See the workspaces reference at https://go.dev/ref/mod#workspaces\n+// for more information.\n+//\n //\n // Compile and run Go program\n //"}, {"sha": "dfaf16def61f278a487239110237cbefe1bebb72", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -305,17 +305,46 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t//\n \t// (If the version is +incompatible, then the go.mod file must not exist:\n \t// +incompatible is not an ongoing opt-out from semantic import versioning.)\n-\tvar canUseIncompatible func() bool\n-\tcanUseIncompatible = func() bool {\n-\t\tvar ok bool\n-\t\tif r.codeDir == \"\" && r.pathMajor == \"\" {\n+\tincompatibleOk := map[string]bool{}\n+\tcanUseIncompatible := func(v string) bool {\n+\t\tif r.codeDir != \"\" || r.pathMajor != \"\" {\n+\t\t\t// A non-empty codeDir indicates a module within a subdirectory,\n+\t\t\t// which necessarily has a go.mod file indicating the module boundary.\n+\t\t\t// A non-empty pathMajor indicates a module path with a major-version\n+\t\t\t// suffix, which must match.\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tok, seen := incompatibleOk[\"\"]\n+\t\tif !seen {\n \t\t\t_, errGoMod := r.code.ReadFile(info.Name, \"go.mod\", codehost.MaxGoMod)\n-\t\t\tif errGoMod != nil {\n-\t\t\t\tok = true\n+\t\t\tok = (errGoMod != nil)\n+\t\t\tincompatibleOk[\"\"] = ok\n+\t\t}\n+\t\tif !ok {\n+\t\t\t// A go.mod file exists at the repo root.\n+\t\t\treturn false\n+\t\t}\n+\n+\t\t// Per https://go.dev/issue/51324, previous versions of the 'go' command\n+\t\t// didn't always check for go.mod files in subdirectories, so if the user\n+\t\t// requests a +incompatible version explicitly, we should continue to allow\n+\t\t// it. Otherwise, if vN/go.mod exists, expect that release tags for that\n+\t\t// major version are intended for the vN module.\n+\t\tif v != \"\" && !strings.HasSuffix(statVers, \"+incompatible\") {\n+\t\t\tmajor := semver.Major(v)\n+\t\t\tok, seen = incompatibleOk[major]\n+\t\t\tif !seen {\n+\t\t\t\t_, errGoModSub := r.code.ReadFile(info.Name, path.Join(major, \"go.mod\"), codehost.MaxGoMod)\n+\t\t\t\tok = (errGoModSub != nil)\n+\t\t\t\tincompatibleOk[major] = ok\n+\t\t\t}\n+\t\t\tif !ok {\n+\t\t\t\treturn false\n \t\t\t}\n \t\t}\n-\t\tcanUseIncompatible = func() bool { return ok }\n-\t\treturn ok\n+\n+\t\treturn true\n \t}\n \n \t// checkCanonical verifies that the canonical version v is compatible with the\n@@ -367,7 +396,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\tbase := strings.TrimSuffix(v, \"+incompatible\")\n \t\tvar errIncompatible error\n \t\tif !module.MatchPathMajor(base, r.pathMajor) {\n-\t\t\tif canUseIncompatible() {\n+\t\t\tif canUseIncompatible(base) {\n \t\t\t\tv = base + \"+incompatible\"\n \t\t\t} else {\n \t\t\t\tif r.pathMajor != \"\" {\n@@ -495,7 +524,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t// Save the highest non-retracted canonical tag for the revision.\n \t\t// If we don't find a better match, we'll use it as the canonical version.\n \t\tif tagIsCanonical && semver.Compare(highestCanonical, v) < 0 && !isRetracted(v) {\n-\t\t\tif module.MatchPathMajor(v, r.pathMajor) || canUseIncompatible() {\n+\t\t\tif module.MatchPathMajor(v, r.pathMajor) || canUseIncompatible(v) {\n \t\t\t\thighestCanonical = v\n \t\t\t}\n \t\t}\n@@ -513,12 +542,12 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t// retracted versions.\n \tallowedMajor := func(major string) func(v string) bool {\n \t\treturn func(v string) bool {\n-\t\t\treturn (major == \"\" || semver.Major(v) == major) && !isRetracted(v)\n+\t\t\treturn ((major == \"\" && canUseIncompatible(v)) || semver.Major(v) == major) && !isRetracted(v)\n \t\t}\n \t}\n \tif pseudoBase == \"\" {\n \t\tvar tag string\n-\t\tif r.pseudoMajor != \"\" || canUseIncompatible() {\n+\t\tif r.pseudoMajor != \"\" || canUseIncompatible(\"\") {\n \t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, allowedMajor(r.pseudoMajor))\n \t\t} else {\n \t\t\t// Allow either v1 or v0, but not incompatible higher versions."}, {"sha": "bb9268adb87c4cf1862056b30fd4f4659cacc1d2", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -458,6 +458,54 @@ var codeRepoTests = []codeRepoTest{\n \t\trev:  \"v3.0.0-devel\",\n \t\terr:  `resolves to version v0.1.1-0.20220203155313-d59622f6e4d7 (v3.0.0-devel is not a tag)`,\n \t},\n+\n+\t// If v2/go.mod exists, then we should prefer to match the \"v2\"\n+\t// pseudo-versions to the nested module, and resolve the module in the parent\n+\t// directory to only compatible versions.\n+\t//\n+\t// However (https://go.dev/issue/51324), previous versions of the 'go' command\n+\t// didn't always do so, so if the user explicitly requests a +incompatible\n+\t// version (as would be present in an existing go.mod file), we should\n+\t// continue to allow it.\n+\t{\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"vcs-test.golang.org/git/v2sub.git\",\n+\t\trev:     \"80beb17a1603\",\n+\t\tversion: \"v0.0.0-20220222205507-80beb17a1603\",\n+\t\tname:    \"80beb17a16036f17a5aedd1bb5bd6d407b3c6dc5\",\n+\t\tshort:   \"80beb17a1603\",\n+\t\ttime:    time.Date(2022, 2, 22, 20, 55, 7, 0, time.UTC),\n+\t},\n+\t{\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/git/v2sub.git\",\n+\t\trev:  \"v2.0.0\",\n+\t\terr:  `module contains a go.mod file, so module path must match major version (\"vcs-test.golang.org/git/v2sub.git/v2\")`,\n+\t},\n+\t{\n+\t\tvcs:  \"git\",\n+\t\tpath: \"vcs-test.golang.org/git/v2sub.git\",\n+\t\trev:  \"v2.0.1-0.20220222205507-80beb17a1603\",\n+\t\terr:  `module contains a go.mod file, so module path must match major version (\"vcs-test.golang.org/git/v2sub.git/v2\")`,\n+\t},\n+\t{\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"vcs-test.golang.org/git/v2sub.git\",\n+\t\trev:     \"v2.0.0+incompatible\",\n+\t\tversion: \"v2.0.0+incompatible\",\n+\t\tname:    \"5fcd3eaeeb391d399f562fd45a50dac9fc34ae8b\",\n+\t\tshort:   \"5fcd3eaeeb39\",\n+\t\ttime:    time.Date(2022, 2, 22, 20, 53, 33, 0, time.UTC),\n+\t},\n+\t{\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"vcs-test.golang.org/git/v2sub.git\",\n+\t\trev:     \"v2.0.1-0.20220222205507-80beb17a1603+incompatible\",\n+\t\tversion: \"v2.0.1-0.20220222205507-80beb17a1603+incompatible\",\n+\t\tname:    \"80beb17a16036f17a5aedd1bb5bd6d407b3c6dc5\",\n+\t\tshort:   \"80beb17a1603\",\n+\t\ttime:    time.Date(2022, 2, 22, 20, 55, 7, 0, time.UTC),\n+\t},\n }\n \n func TestCodeRepo(t *testing.T) {"}, {"sha": "f960edd251d90a11b925b5276a024fb179e9350e", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -288,6 +288,11 @@ func BinDir() string {\n // operate in workspace mode. It should not be called by other commands,\n // for example 'go mod tidy', that don't operate in workspace mode.\n func InitWorkfile() {\n+\tif RootMode == NoRoot {\n+\t\tworkFilePath = \"\"\n+\t\treturn\n+\t}\n+\n \tswitch gowork := cfg.Getenv(\"GOWORK\"); gowork {\n \tcase \"off\":\n \t\tworkFilePath = \"\""}, {"sha": "75c278a7dfdb5f39dc196f22dd14bf0b21d5c6c2", "filename": "libgo/go/cmd/go/internal/modload/modfile.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fmodfile.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -802,7 +802,7 @@ var latestVersionIgnoringRetractionsCache par.Cache // path \u2192 queryLatestVersi\n // an absolute path or a relative path starting with a '.' or '..'\n // path component.\n func ToDirectoryPath(path string) string {\n-\tif modfile.IsDirectoryPath(path) {\n+\tif path == \".\" || modfile.IsDirectoryPath(path) {\n \t\treturn path\n \t}\n \t// The path is not a relative path or an absolute path, so make it relative"}, {"sha": "312b49ef5dfa33828cf65c9ac373dfad88d86e8f", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -73,8 +73,6 @@ func printStderr(args ...any) (int, error) {\n }\n \n func runRun(ctx context.Context, cmd *base.Command, args []string) {\n-\tmodload.InitWorkfile()\n-\n \tif shouldUseOutsideModuleMode(args) {\n \t\t// Set global module flags for 'go run cmd@version'.\n \t\t// This must be done before modload.Init, but we need to call work.BuildInit\n@@ -84,7 +82,10 @@ func runRun(ctx context.Context, cmd *base.Command, args []string) {\n \t\tmodload.RootMode = modload.NoRoot\n \t\tmodload.AllowMissingModuleImports()\n \t\tmodload.Init()\n+\t} else {\n+\t\tmodload.InitWorkfile()\n \t}\n+\n \twork.BuildInit()\n \tvar b work.Builder\n \tb.Init()"}, {"sha": "2acabf7aafba5de9c33eb3469399afefd2595b22", "filename": "libgo/go/cmd/go/internal/vcs/vcs.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvcs%2Fvcs.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -312,7 +312,7 @@ func gitStatus(vcsGit *Cmd, rootDir string) (Status, error) {\n \t// uncommitted files and skip tagging revision / committime.\n \tvar rev string\n \tvar commitTime time.Time\n-\tout, err = vcsGit.runOutputVerboseOnly(rootDir, \"show -s --no-show-signature --format=%H:%ct\")\n+\tout, err = vcsGit.runOutputVerboseOnly(rootDir, \"-c log.showsignature=false show -s --format=%H:%ct\")\n \tif err != nil && !uncommitted {\n \t\treturn Status{}, err\n \t} else if err == nil {"}, {"sha": "1478c19389fa1f98ca834c9ff4ffe7abd0608801", "filename": "libgo/go/cmd/go/internal/workcmd/edit.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fedit.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -84,9 +84,8 @@ writing it back to go.mod. The JSON output corresponds to these Go types:\n \t\tVersion string\n \t}\n \n-See the workspaces design proposal at\n-https://go.googlesource.com/proposal/+/master/design/45713-workspace.md for\n-more information.\n+See the workspaces reference at https://go.dev/ref/mod#workspaces\n+for more information.\n `,\n }\n "}, {"sha": "c2513bac358479791d40b5f9753b793293b36dea", "filename": "libgo/go/cmd/go/internal/workcmd/init.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Finit.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -27,6 +27,8 @@ modules will be created.\n Each argument path is added to a use directive in the go.work file. The\n current go version will also be listed in the go.work file.\n \n+See the workspaces reference at https://go.dev/ref/mod#workspaces\n+for more information.\n `,\n \tRun: runInit,\n }"}, {"sha": "7712eb6b6b8920a58b2a602355c2a9ec6abf386e", "filename": "libgo/go/cmd/go/internal/workcmd/sync.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fsync.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -33,6 +33,9 @@ if the dependency module's version is not already the same as the build\n list's version. Note that Minimal Version Selection guarantees that the\n build list's version of each module is always the same or higher than\n that in each workspace module.\n+\n+See the workspaces reference at https://go.dev/ref/mod#workspaces\n+for more information.\n `,\n \tRun: runSync,\n }"}, {"sha": "e20041f79f1376d54be4f4ac369b108d893384e4", "filename": "libgo/go/cmd/go/internal/workcmd/use.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fuse.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -20,7 +20,7 @@ import (\n )\n \n var cmdUse = &base.Command{\n-\tUsageLine: \"go work use [-r] [moddirs]\",\n+\tUsageLine: \"go work use [-r] moddirs\",\n \tShort:     \"add modules to workspace file\",\n \tLong: `Use provides a command-line interface for adding\n directories, optionally recursively, to a go.work file.\n@@ -33,6 +33,9 @@ The -r flag searches recursively for modules in the argument\n directories, and the use command operates as if each of the directories\n were specified as arguments: namely, use directives will be added for\n directories that exist, and removed for directories that do not exist.\n+\n+See the workspaces reference at https://go.dev/ref/mod#workspaces\n+for more information.\n `,\n }\n \n@@ -101,6 +104,9 @@ func runUse(ctx context.Context, cmd *base.Command, args []string) {\n \t\tkeepDirs[absDir] = dir\n \t}\n \n+\tif len(args) == 0 {\n+\t\tbase.Fatalf(\"go: 'go work use' requires one or more directory arguments\")\n+\t}\n \tfor _, useDir := range args {\n \t\tif !*useR {\n \t\t\tlookDir(useDir)\n@@ -186,5 +192,5 @@ func pathRel(workDir, dir string) (abs, canonical string) {\n \n \t// Normalize relative paths to use slashes, so that checked-in go.work\n \t// files with relative paths within the repo are platform-independent.\n-\treturn abs, filepath.ToSlash(rel)\n+\treturn abs, modload.ToDirectoryPath(rel)\n }"}, {"sha": "39c81e8f5dc05366ab38ad15f3d7d9379be45ee8", "filename": "libgo/go/cmd/go/internal/workcmd/work.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fworkcmd%2Fwork.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -12,14 +12,20 @@ import (\n var CmdWork = &base.Command{\n \tUsageLine: \"go work\",\n \tShort:     \"workspace maintenance\",\n-\tLong: `Go workspace provides access to operations on workspaces.\n+\tLong: `Work provides access to operations on workspaces.\n \n Note that support for workspaces is built into many other commands, not\n just 'go work'.\n \n See 'go help modules' for information about Go's module system of which\n workspaces are a part.\n \n+See https://go.dev/ref/mod#workspaces for an in-depth reference on\n+workspaces.\n+\n+See https://go.dev/doc/tutorial/workspaces for an introductory\n+tutorial on workspaces.\n+\n A workspace is specified by a go.work file that specifies a set of\n module directories with the \"use\" directive. These modules are used as\n root modules by the go command for builds and related operations.  A"}, {"sha": "eb0f22d1c0780b1f0129af08111ae4efc8a446b8", "filename": "libgo/go/cmd/go/testdata/script/run_work_versioned.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Frun_work_versioned.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Frun_work_versioned.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Frun_work_versioned.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,16 @@\n+[short] skip\n+go run example.com/printversion@v0.1.0\n+stdout '^main is example.com/printversion v0.1.0$'\n+\n+-- go.work --\n+go 1.18\n+\n+use (\n+\t.\n+)\n+-- go.mod --\n+module example\n+\n+go 1.18\n+\n+require example.com/printversion v1.0.0"}, {"sha": "571bf752d000e24e0752549fe8b7792c6cfa3ccf", "filename": "libgo/go/cmd/go/testdata/script/test_fuzz_minimize_dirty_cov.txt", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_minimize_dirty_cov.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_minimize_dirty_cov.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_minimize_dirty_cov.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,84 @@\n+# Test that minimization doesn't use dirty coverage snapshots when it\n+# is unable to actually minimize the input. We do this by checking that\n+# a expected value appears in the cache. If a dirty coverage map is used\n+# (i.e. the coverage map generated during the last minimization step,\n+# rather than the map provided with the initial input) then this value\n+# is unlikely to appear in the cache, since the map generated during\n+# the last minimization step should not increase the coverage.\n+\n+[short] skip\n+[!fuzz-instrumented] skip\n+\n+env GOCACHE=$WORK/gocache\n+go test -fuzz=FuzzCovMin -fuzztime=25s -test.fuzzcachedir=$GOCACHE/fuzz\n+go run check_file/main.go $GOCACHE/fuzz/FuzzCovMin abcd\n+\n+-- go.mod --\n+module test\n+\n+-- covmin_test.go --\n+package covmin\n+\n+import \"testing\"\n+\n+func FuzzCovMin(f *testing.F) {\n+\tf.Fuzz(func(t *testing.T, data []byte) {\n+\t\tif len(data) >= 4 && data[0] == 'a' && data[1] == 'b' && data[2] == 'c' && data[3] == 'd' {\n+\t\t\treturn\n+\t\t}\n+\t})\n+}\n+\n+-- check_file/main.go --\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strconv\"\n+)\n+\n+func checkFile(name, expected string) (bool, error) {\n+\tdata, err := os.ReadFile(name)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tfor _, line := range bytes.Split(data, []byte(\"\\n\")) {\n+\t\tm := valRe.FindSubmatch(line)\n+\t\tif m == nil {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfmt.Println(strconv.Unquote(string(m[1])))\n+\t\tif s, err := strconv.Unquote(string(m[1])); err != nil {\n+\t\t\treturn false, err\n+\t\t} else if s == expected {\n+\t\t\treturn true, nil\n+\t\t}\n+\t}\n+\treturn false, nil\n+}\n+\n+var valRe = regexp.MustCompile(`^\\[\\]byte\\(([^)]+)\\)$`)\n+\n+func main() {\n+\tdir, expected := os.Args[1], os.Args[2]\n+\tents, err := os.ReadDir(dir)\n+\tif err != nil {\n+\t\tfmt.Fprintln(os.Stderr, err)\n+\t\tos.Exit(1)\n+\t}\n+\tfor _, ent := range ents {\n+\t\tname := filepath.Join(dir, ent.Name())\n+\t\tif good, err := checkFile(name, expected); err != nil {\n+\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\tos.Exit(1)\n+\t\t} else if good {\n+\t\t\tos.Exit(0)\n+\t\t}\n+\t}\n+\tfmt.Fprintln(os.Stderr, \"input over minimized\")\n+\tos.Exit(1)\n+}"}, {"sha": "a09e85b972f99ee25ae4576024a07e8c0a76fa64", "filename": "libgo/go/cmd/go/testdata/script/test_fuzz_minimize_interesting.txt", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_minimize_interesting.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_minimize_interesting.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_fuzz_minimize_interesting.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -127,19 +127,8 @@ func FuzzMinCache(f *testing.F) {\n \t\tif bytes.Equal(buf, seed) {\n \t\t\treturn\n \t\t}\n-\t\tif n := sum(buf); n < 0 {\n-\t\t\tt.Error(\"sum cannot be negative\")\n-\t\t}\n \t})\n }\n-\n-func sum(buf []byte) int {\n-\tn := 0\n-\tfor _, b := range buf {\n-\t\tn += int(b)\n-\t}\n-\treturn n\n-}\n -- check_testdata/check_testdata.go --\n //go:build ignore\n // +build ignore"}, {"sha": "44706870e22f22d9113c9ddb6a1e75754ace39db", "filename": "libgo/go/cmd/go/testdata/script/version_buildvcs_git.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion_buildvcs_git.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion_buildvcs_git.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion_buildvcs_git.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -111,7 +111,7 @@ rm $GOBIN/d$GOEXE\n go list -x ./...\n stdout -count=3 '^example.com'\n stderr -count=1 '^git status'\n-stderr -count=1 '^git show'\n+stderr -count=1 '^git -c log.showsignature=false show'\n \n -- $WORK/fakebin/git --\n #!/bin/sh"}, {"sha": "fa1558f9e690a1e8de55dcadead1e50c744527f2", "filename": "libgo/go/cmd/go/testdata/script/work.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -4,7 +4,7 @@ go env GOWORK\n ! stdout .\n \n go work init ./a ./b\n-cmp go.work go.work.want\n+cmpenv go.work go.work.want\n go env GOWORK\n stdout '^'$WORK'(\\\\|/)gopath(\\\\|/)src(\\\\|/)go.work$'\n \n@@ -69,7 +69,7 @@ use (\n   ../src/a\n )\n -- go.work.want --\n-go 1.18\n+go $goversion\n \n use (\n \t./a"}, {"sha": "278afb7f610dc0fb31dcef660dce71ff83878451", "filename": "libgo/go/cmd/go/testdata/script/work_edit.txt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_edit.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -1,10 +1,10 @@\n # Test editing go.work files.\n \n go work init m\n-cmp go.work go.work.want_initial\n+cmpenv go.work go.work.want_initial\n \n go work edit -use n\n-cmp go.work go.work.want_use_n\n+cmpenv go.work go.work.want_use_n\n \n go work edit -go 1.18\n cmp go.work go.work.want_go_118\n@@ -39,11 +39,11 @@ module m\n \n go 1.18\n -- go.work.want_initial --\n-go 1.18\n+go $goversion\n \n use ./m\n -- go.work.want_use_n --\n-go 1.18\n+go $goversion\n \n use (\n \t./m"}, {"sha": "e3977882a0a012d78c58e85898ee9a178a94ae3d", "filename": "libgo/go/cmd/go/testdata/script/work_init_path.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_init_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_init_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_init_path.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,17 @@\n+# Regression test for https://go.dev/issue/51448.\n+# 'go work init . foo/bar' should produce a go.work file\n+# with the same paths as 'go work init; go work use -r .'.\n+\n+go work init . foo/bar\n+mv go.work go.work.init\n+\n+go work init\n+go work use -r .\n+cmp go.work go.work.init\n+\n+-- go.mod --\n+module example\n+go 1.18\n+-- foo/bar/go.mod --\n+module example\n+go 1.18"}, {"sha": "12c8cecab74c7e245119ab9fda5a06d8568e93b0", "filename": "libgo/go/cmd/go/testdata/script/work_use.txt", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -14,16 +14,16 @@ use (\n go 1.18\n \n use (\n-\tfoo\n-\tfoo/bar/baz\n+\t./foo\n+\t./foo/bar/baz\n )\n -- go.want_work_other --\n go 1.18\n \n use (\n-\tfoo\n-\tfoo/bar/baz\n-\tother\n+\t./foo\n+\t./foo/bar/baz\n+\t./other\n )\n -- foo/go.mod --\n module foo"}, {"sha": "b379cbc09d982626cc70b0b1f48e02b60bc1c9d3", "filename": "libgo/go/cmd/go/testdata/script/work_use_deleted.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_deleted.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_deleted.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_deleted.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -6,13 +6,13 @@ go 1.18\n \n use (\n \t.\n-\tsub\n-\tsub/dir/deleted\n+\t./sub\n+\t./sub/dir/deleted\n )\n -- go.work.want --\n go 1.18\n \n-use sub/dir\n+use ./sub/dir\n -- sub/README.txt --\n A go.mod file has been deleted from this directory.\n In addition, the entire subdirectory sub/dir/deleted"}, {"sha": "8f210423ec2ad1f3fb579ccaaab23a90480a204a", "filename": "libgo/go/cmd/go/testdata/script/work_use_dot.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_dot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_dot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_dot.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -31,7 +31,7 @@ grep '^use [\"]?'$PWD'[\"]?$' ../../go.work\n # resulting workspace would contain a duplicate module.\n cp ../../go.work.orig ../../go.work\n ! go work use $PWD .\n-stderr '^go: already added \"bar/baz\" as \"'$PWD'\"$'\n+stderr '^go: already added \"\\./bar/baz\" as \"'$PWD'\"$'\n cmp ../../go.work ../../go.work.orig\n \n \n@@ -43,7 +43,7 @@ go 1.18\n -- go.work.rel --\n go 1.18\n \n-use bar/baz\n+use ./bar/baz\n -- bar/baz/go.mod --\n module example/bar/baz\n go 1.18"}, {"sha": "ca054344c638b89395eaf1a419e83f35cc816662", "filename": "libgo/go/cmd/go/testdata/script/work_use_noargs.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_noargs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_noargs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fwork_use_noargs.txt?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,11 @@\n+# For now, 'go work use' requires arguments.\n+# (Eventually, we may may it implicitly behave like 'go work use .'.\n+\n+! go work use\n+stderr '^go: ''go work use'' requires one or more directory arguments'\n+\n+! go work use -r\n+stderr '^go: ''go work use'' requires one or more directory arguments'\n+\n+-- go.work --\n+go 1.18"}, {"sha": "7792ac77f8a814da31bd820a108d7daca5a7ad85", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -512,7 +512,7 @@ func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo, startTemplat\n \t\t}\n \t\tfv := finfo.value(val, dontInitNilPointers)\n \n-\t\tif finfo.flags&fOmitEmpty != 0 && isEmptyValue(fv) {\n+\t\tif finfo.flags&fOmitEmpty != 0 && (!fv.IsValid() || isEmptyValue(fv)) {\n \t\t\tcontinue\n \t\t}\n "}, {"sha": "0b6965d554526e7576878893123108bc44fac0f4", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -2499,3 +2499,39 @@ func TestInvalidXMLName(t *testing.T) {\n \t\tt.Errorf(\"error %q does not contain %q\", err, want)\n \t}\n }\n+\n+// Issue 50164. Crash on zero value XML attribute.\n+type LayerOne struct {\n+\tXMLName Name `xml:\"l1\"`\n+\n+\tValue     *float64 `xml:\"value,omitempty\"`\n+\t*LayerTwo `xml:\",omitempty\"`\n+}\n+\n+type LayerTwo struct {\n+\tValueTwo *int `xml:\"value_two,attr,omitempty\"`\n+}\n+\n+func TestMarshalZeroValue(t *testing.T) {\n+\tproofXml := `<l1><value>1.2345</value></l1>`\n+\tvar l1 LayerOne\n+\terr := Unmarshal([]byte(proofXml), &l1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unmarshal XML error: %v\", err)\n+\t}\n+\twant := float64(1.2345)\n+\tgot := *l1.Value\n+\tif got != want {\n+\t\tt.Fatalf(\"unexpected unmarshal result, want %f but got %f\", want, got)\n+\t}\n+\n+\t// Marshal again (or Encode again)\n+\t// In issue 50164, here `Marshal(l1)` will panic because of the zero value of xml attribute ValueTwo `value_two`.\n+\tanotherXML, err := Marshal(l1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"marshal XML error: %v\", err)\n+\t}\n+\tif string(anotherXML) != proofXml {\n+\t\tt.Fatalf(\"unexpected unmarshal result, want %q but got %q\", proofXml, anotherXML)\n+\t}\n+}"}, {"sha": "bff1c09cc9714dd017356a91257d726cded21129", "filename": "libgo/go/go/internal/gcimporter/iimport.go", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fiimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fiimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgcimporter%2Fiimport.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -181,6 +181,15 @@ func iImportData(fset *token.FileSet, imports map[string]*types.Package, dataRea\n \t\tp.doDecl(localpkg, name)\n \t}\n \n+\t// SetConstraint can't be called if the constraint type is not yet complete.\n+\t// When type params are created in the 'P' case of (*importReader).obj(),\n+\t// the associated constraint type may not be complete due to recursion.\n+\t// Therefore, we defer calling SetConstraint there, and call it here instead\n+\t// after all types are complete.\n+\tfor _, d := range p.later {\n+\t\td.t.SetConstraint(d.constraint)\n+\t}\n+\n \tfor _, typ := range p.interfaceList {\n \t\ttyp.Complete()\n \t}\n@@ -195,6 +204,11 @@ func iImportData(fset *token.FileSet, imports map[string]*types.Package, dataRea\n \treturn localpkg, nil\n }\n \n+type setConstraintArgs struct {\n+\tt          *types.TypeParam\n+\tconstraint types.Type\n+}\n+\n type iimporter struct {\n \texportVersion int64\n \tipath         string\n@@ -211,6 +225,9 @@ type iimporter struct {\n \n \tfake          fakeFileSet\n \tinterfaceList []*types.Interface\n+\n+\t// Arguments for calls to SetConstraint that are deferred due to recursive types\n+\tlater []setConstraintArgs\n }\n \n func (p *iimporter) doDecl(pkg *types.Package, name string) {\n@@ -391,7 +408,11 @@ func (r *importReader) obj(name string) {\n \t\t\t}\n \t\t\tiface.MarkImplicit()\n \t\t}\n-\t\tt.SetConstraint(constraint)\n+\t\t// The constraint type may not be complete, if we\n+\t\t// are in the middle of a type recursion involving type\n+\t\t// constraints. So, we defer SetConstraint until we have\n+\t\t// completely set up all types in ImportData.\n+\t\tr.p.later = append(r.p.later, setConstraintArgs{t: t, constraint: constraint})\n \n \tcase 'V':\n \t\ttyp := r.typ()"}, {"sha": "9a09d58eb2c8d6ce2a1e7bc0c2b38015f9ea37fa", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -319,9 +319,17 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t}\n }\n \n-func (p *printer) parameters(fields *ast.FieldList, isTypeParam bool) {\n+type paramMode int\n+\n+const (\n+\tfuncParam paramMode = iota\n+\tfuncTParam\n+\ttypeTParam\n+)\n+\n+func (p *printer) parameters(fields *ast.FieldList, mode paramMode) {\n \topenTok, closeTok := token.LPAREN, token.RPAREN\n-\tif isTypeParam {\n+\tif mode != funcParam {\n \t\topenTok, closeTok = token.LBRACK, token.RBRACK\n \t}\n \tp.print(fields.Opening, openTok)\n@@ -373,7 +381,7 @@ func (p *printer) parameters(fields *ast.FieldList, isTypeParam bool) {\n \t\tif closing := p.lineFor(fields.Closing); 0 < prevLine && prevLine < closing {\n \t\t\tp.print(token.COMMA)\n \t\t\tp.linebreak(closing, 0, ignore, true)\n-\t\t} else if isTypeParam && fields.NumFields() == 1 {\n+\t\t} else if mode == typeTParam && fields.NumFields() == 1 {\n \t\t\t// Otherwise, if we are in a type parameter list that could be confused\n \t\t\t// with the constant array length expression [P*C], print a comma so that\n \t\t\t// parsing is unambiguous.\n@@ -411,10 +419,10 @@ func isTypeLit(x ast.Expr) bool {\n \n func (p *printer) signature(sig *ast.FuncType) {\n \tif sig.TypeParams != nil {\n-\t\tp.parameters(sig.TypeParams, true)\n+\t\tp.parameters(sig.TypeParams, funcTParam)\n \t}\n \tif sig.Params != nil {\n-\t\tp.parameters(sig.Params, false)\n+\t\tp.parameters(sig.Params, funcParam)\n \t} else {\n \t\tp.print(token.LPAREN, token.RPAREN)\n \t}\n@@ -428,7 +436,7 @@ func (p *printer) signature(sig *ast.FuncType) {\n \t\t\tp.expr(stripParensAlways(res.List[0].Type))\n \t\t\treturn\n \t\t}\n-\t\tp.parameters(res, false)\n+\t\tp.parameters(res, funcParam)\n \t}\n }\n \n@@ -1639,7 +1647,7 @@ func (p *printer) spec(spec ast.Spec, n int, doIndent bool) {\n \t\tp.setComment(s.Doc)\n \t\tp.expr(s.Name)\n \t\tif s.TypeParams != nil {\n-\t\t\tp.parameters(s.TypeParams, true)\n+\t\t\tp.parameters(s.TypeParams, typeTParam)\n \t\t}\n \t\tif n == 1 {\n \t\t\tp.print(blank)\n@@ -1829,7 +1837,7 @@ func (p *printer) funcDecl(d *ast.FuncDecl) {\n \t// FUNC is emitted).\n \tstartCol := p.out.Column - len(\"func \")\n \tif d.Recv != nil {\n-\t\tp.parameters(d.Recv, false) // method: print receiver\n+\t\tp.parameters(d.Recv, funcParam) // method: print receiver\n \t\tp.print(blank)\n \t}\n \tp.expr(d.Name)"}, {"sha": "c3a7df83725205afc4cec95cd73f57d477fbf981", "filename": "libgo/go/go/printer/testdata/generics.golden", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.golden?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -64,3 +64,29 @@ type _ [P*T - T]struct{}\n type _[\n \tP *T,\n ] struct{}\n+\n+// equivalent test cases for potentially ambiguous type parameter lists, except\n+// for function declarations there is no ambiguity (issue #51548)\n+func _[P *T]()\t\t{}\n+func _[P *T, _ any]()\t{}\n+func _[P *T]()\t\t{}\n+func _[P *T, _ any]()\t{}\n+func _[P T]()\t\t{}\n+func _[P T, _ any]()\t{}\n+\n+func _[P *struct{}]()\t{}\n+func _[P *struct{}]()\t{}\n+func _[P []int]()\t{}\n+\n+func _[P T]()\t{}\n+func _[P T]()\t{}\n+func _[P **T]()\t{}\n+func _[P *T]()\t{}\n+func _[P *T]()\t{}\n+func _[P **T]()\t{}\n+func _[P *T]()\t{}\n+\n+func _[\n+\tP *T,\n+]() {\n+}"}, {"sha": "66e1554f7ffb8359838be524849721a9b18c2e09", "filename": "libgo/go/go/printer/testdata/generics.input", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fgenerics.input?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -61,3 +61,28 @@ type _ [P * T - T]struct{}\n type _[\n \tP *T,\n ] struct{}\n+\n+// equivalent test cases for potentially ambiguous type parameter lists, except\n+// for function declarations there is no ambiguity (issue #51548)\n+func _[P *T,]() {}\n+func _[P *T, _ any]() {}\n+func _[P (*T),]() {}\n+func _[P (*T), _ any]() {}\n+func _[P (T),]() {}\n+func _[P (T), _ any]() {}\n+\n+func _[P *struct{}] () {}\n+func _[P (*struct{})] () {}\n+func _[P ([]int)] () {}\n+\n+func _ [P(T)]() {}\n+func _ [P((T))]() {}\n+func _ [P * *T]() {}\n+func _ [P * T]() {}\n+func _ [P(*T)]() {}\n+func _ [P(**T)]() {}\n+func _ [P * T]() {}\n+\n+func _[\n+\tP *T,\n+]() {}"}, {"sha": "248db1896b2dc0f916013ea7079e6c5a125fd35f", "filename": "libgo/go/go/types/api.go", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -201,12 +201,12 @@ type Info struct {\n \t// qualified identifiers are collected in the Uses map.\n \tTypes map[ast.Expr]TypeAndValue\n \n-\t// Instances maps identifiers denoting parameterized types or functions to\n-\t// their type arguments and instantiated type.\n+\t// Instances maps identifiers denoting generic types or functions to their\n+\t// type arguments and instantiated type.\n \t//\n \t// For example, Instances will map the identifier for 'T' in the type\n \t// instantiation T[int, string] to the type arguments [int, string] and\n-\t// resulting instantiated *Named type. Given a parameterized function\n+\t// resulting instantiated *Named type. Given a generic function\n \t// func F[A any](A), Instances will map the identifier for 'F' in the call\n \t// expression F(int(1)) to the inferred type arguments [int], and resulting\n \t// instantiated *Signature.\n@@ -419,8 +419,11 @@ func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, i\n }\n \n // AssertableTo reports whether a value of type V can be asserted to have type T.\n-// The behavior of AssertableTo is undefined if V is a generalized interface; i.e.,\n-// an interface that may only be used as a type constraint in Go code.\n+//\n+// The behavior of AssertableTo is undefined in two cases:\n+//  - if V is a generalized interface; i.e., an interface that may only be used\n+//    as a type constraint in Go code\n+//  - if T is an uninstantiated generic type\n func AssertableTo(V *Interface, T Type) bool {\n \t// Checker.newAssertableTo suppresses errors for invalid types, so we need special\n \t// handling here.\n@@ -430,20 +433,31 @@ func AssertableTo(V *Interface, T Type) bool {\n \treturn (*Checker)(nil).newAssertableTo(V, T) == nil\n }\n \n-// AssignableTo reports whether a value of type V is assignable to a variable of type T.\n+// AssignableTo reports whether a value of type V is assignable to a variable\n+// of type T.\n+//\n+// The behavior of AssignableTo is undefined if V or T is an uninstantiated\n+// generic type.\n func AssignableTo(V, T Type) bool {\n \tx := operand{mode: value, typ: V}\n \tok, _ := x.assignableTo(nil, T, nil) // check not needed for non-constant x\n \treturn ok\n }\n \n-// ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n+// ConvertibleTo reports whether a value of type V is convertible to a value of\n+// type T.\n+//\n+// The behavior of ConvertibleTo is undefined if V or T is an uninstantiated\n+// generic type.\n func ConvertibleTo(V, T Type) bool {\n \tx := operand{mode: value, typ: V}\n \treturn x.convertibleTo(nil, T, nil) // check not needed for non-constant x\n }\n \n // Implements reports whether type V implements interface T.\n+//\n+// The behavior of Implements is undefined if V is an uninstantiated generic\n+// type.\n func Implements(V Type, T *Interface) bool {\n \tif T.Empty() {\n \t\t// All types (even Typ[Invalid]) implement the empty interface."}, {"sha": "5003ce25f6a5346c5d1ef748fa528eb411c0ae00", "filename": "libgo/go/go/types/api_test.go", "status": "modified", "additions": 145, "deletions": 116, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fapi_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -16,6 +16,7 @@ import (\n \t\"internal/testenv\"\n \t\"reflect\"\n \t\"regexp\"\n+\t\"sort\"\n \t\"strings\"\n \t\"testing\"\n \n@@ -435,129 +436,146 @@ func TestTypesInfo(t *testing.T) {\n }\n \n func TestInstanceInfo(t *testing.T) {\n-\tvar tests = []struct {\n-\t\tsrc   string\n+\tconst lib = `package lib\n+\n+func F[P any](P) {}\n+\n+type T[P any] []P\n+`\n+\n+\ttype testInst struct {\n \t\tname  string\n \t\ttargs []string\n \t\ttyp   string\n+\t}\n+\n+\tvar tests = []struct {\n+\t\tsrc       string\n+\t\tinstances []testInst // recorded instances in source order\n \t}{\n \t\t{`package p0; func f[T any](T) {}; func _() { f(42) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`int`},\n-\t\t\t`func(int)`,\n+\t\t\t[]testInst{{`f`, []string{`int`}, `func(int)`}},\n \t\t},\n \t\t{`package p1; func f[T any](T) T { panic(0) }; func _() { f('@') }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`rune`},\n-\t\t\t`func(rune) rune`,\n+\t\t\t[]testInst{{`f`, []string{`rune`}, `func(rune) rune`}},\n \t\t},\n \t\t{`package p2; func f[T any](...T) T { panic(0) }; func _() { f(0i) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`complex128`},\n-\t\t\t`func(...complex128) complex128`,\n+\t\t\t[]testInst{{`f`, []string{`complex128`}, `func(...complex128) complex128`}},\n \t\t},\n \t\t{`package p3; func f[A, B, C any](A, *B, []C) {}; func _() { f(1.2, new(string), []byte{}) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`float64`, `string`, `byte`},\n-\t\t\t`func(float64, *string, []byte)`,\n+\t\t\t[]testInst{{`f`, []string{`float64`, `string`, `byte`}, `func(float64, *string, []byte)`}},\n \t\t},\n \t\t{`package p4; func f[A, B any](A, *B, ...[]B) {}; func _() { f(1.2, new(byte)) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`float64`, `byte`},\n-\t\t\t`func(float64, *byte, ...[]byte)`,\n+\t\t\t[]testInst{{`f`, []string{`float64`, `byte`}, `func(float64, *byte, ...[]byte)`}},\n \t\t},\n \n-\t\t{`package s1; func f[T any, P interface{~*T}](x T) {}; func _(x string) { f(x) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`string`, `*string`},\n-\t\t\t`func(x string)`,\n+\t\t{`package s1; func f[T any, P interface{*T}](x T) {}; func _(x string) { f(x) }`,\n+\t\t\t[]testInst{{`f`, []string{`string`, `*string`}, `func(x string)`}},\n \t\t},\n-\t\t{`package s2; func f[T any, P interface{~*T}](x []T) {}; func _(x []int) { f(x) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`int`, `*int`},\n-\t\t\t`func(x []int)`,\n+\t\t{`package s2; func f[T any, P interface{*T}](x []T) {}; func _(x []int) { f(x) }`,\n+\t\t\t[]testInst{{`f`, []string{`int`, `*int`}, `func(x []int)`}},\n \t\t},\n-\t\t{`package s3; type C[T any] interface{~chan<- T}; func f[T any, P C[T]](x []T) {}; func _(x []int) { f(x) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`int`, `chan<- int`},\n-\t\t\t`func(x []int)`,\n+\t\t{`package s3; type C[T any] interface{chan<- T}; func f[T any, P C[T]](x []T) {}; func _(x []int) { f(x) }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`C`, []string{`T`}, `interface{chan<- T}`},\n+\t\t\t\t{`f`, []string{`int`, `chan<- int`}, `func(x []int)`},\n+\t\t\t},\n \t\t},\n-\t\t{`package s4; type C[T any] interface{~chan<- T}; func f[T any, P C[T], Q C[[]*P]](x []T) {}; func _(x []int) { f(x) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`int`, `chan<- int`, `chan<- []*chan<- int`},\n-\t\t\t`func(x []int)`,\n+\t\t{`package s4; type C[T any] interface{chan<- T}; func f[T any, P C[T], Q C[[]*P]](x []T) {}; func _(x []int) { f(x) }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`C`, []string{`T`}, `interface{chan<- T}`},\n+\t\t\t\t{`C`, []string{`[]*P`}, `interface{chan<- []*P}`},\n+\t\t\t\t{`f`, []string{`int`, `chan<- int`, `chan<- []*chan<- int`}, `func(x []int)`},\n+\t\t\t},\n \t\t},\n \n-\t\t{`package t1; func f[T any, P interface{~*T}]() T { panic(0) }; func _() { _ = f[string] }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`string`, `*string`},\n-\t\t\t`func() string`,\n+\t\t{`package t1; func f[T any, P interface{*T}]() T { panic(0) }; func _() { _ = f[string] }`,\n+\t\t\t[]testInst{{`f`, []string{`string`, `*string`}, `func() string`}},\n \t\t},\n-\t\t{`package t2; func f[T any, P interface{~*T}]() T { panic(0) }; func _() { _ = (f[string]) }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`string`, `*string`},\n-\t\t\t`func() string`,\n+\t\t{`package t2; func f[T any, P interface{*T}]() T { panic(0) }; func _() { _ = (f[string]) }`,\n+\t\t\t[]testInst{{`f`, []string{`string`, `*string`}, `func() string`}},\n \t\t},\n-\t\t{`package t3; type C[T any] interface{~chan<- T}; func f[T any, P C[T]]() []T { return nil }; func _() { _ = f[int] }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`int`, `chan<- int`},\n-\t\t\t`func() []int`,\n+\t\t{`package t3; type C[T any] interface{chan<- T}; func f[T any, P C[T], Q C[[]*P]]() []T { return nil }; func _() { _ = f[int] }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`C`, []string{`T`}, `interface{chan<- T}`},\n+\t\t\t\t{`C`, []string{`[]*P`}, `interface{chan<- []*P}`},\n+\t\t\t\t{`f`, []string{`int`, `chan<- int`, `chan<- []*chan<- int`}, `func() []int`},\n+\t\t\t},\n \t\t},\n-\t\t{`package t4; type C[T any] interface{~chan<- T}; func f[T any, P C[T], Q C[[]*P]]() []T { return nil }; func _() { _ = f[int] }`,\n-\t\t\t`f`,\n-\t\t\t[]string{`int`, `chan<- int`, `chan<- []*chan<- int`},\n-\t\t\t`func() []int`,\n+\t\t{`package t4; type C[T any] interface{chan<- T}; func f[T any, P C[T], Q C[[]*P]]() []T { return nil }; func _() { _ = (f[int]) }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`C`, []string{`T`}, `interface{chan<- T}`},\n+\t\t\t\t{`C`, []string{`[]*P`}, `interface{chan<- []*P}`},\n+\t\t\t\t{`f`, []string{`int`, `chan<- int`, `chan<- []*chan<- int`}, `func() []int`},\n+\t\t\t},\n \t\t},\n \t\t{`package i0; import \"lib\"; func _() { lib.F(42) }`,\n-\t\t\t`F`,\n-\t\t\t[]string{`int`},\n-\t\t\t`func(int)`,\n+\t\t\t[]testInst{{`F`, []string{`int`}, `func(int)`}},\n \t\t},\n+\n+\t\t{`package duplfunc0; func f[T any](T) {}; func _() { f(42); f(\"foo\"); f[int](3) }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`f`, []string{`int`}, `func(int)`},\n+\t\t\t\t{`f`, []string{`string`}, `func(string)`},\n+\t\t\t\t{`f`, []string{`int`}, `func(int)`},\n+\t\t\t},\n+\t\t},\n+\t\t{`package duplfunc1; import \"lib\"; func _() { lib.F(42); lib.F(\"foo\"); lib.F(3) }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`F`, []string{`int`}, `func(int)`},\n+\t\t\t\t{`F`, []string{`string`}, `func(string)`},\n+\t\t\t\t{`F`, []string{`int`}, `func(int)`},\n+\t\t\t},\n+\t\t},\n+\n \t\t{`package type0; type T[P interface{~int}] struct{ x P }; var _ T[int]`,\n-\t\t\t`T`,\n-\t\t\t[]string{`int`},\n-\t\t\t`struct{x int}`,\n+\t\t\t[]testInst{{`T`, []string{`int`}, `struct{x int}`}},\n \t\t},\n \t\t{`package type1; type T[P interface{~int}] struct{ x P }; var _ (T[int])`,\n-\t\t\t`T`,\n-\t\t\t[]string{`int`},\n-\t\t\t`struct{x int}`,\n+\t\t\t[]testInst{{`T`, []string{`int`}, `struct{x int}`}},\n \t\t},\n \t\t{`package type2; type T[P interface{~int}] struct{ x P }; var _ T[(int)]`,\n-\t\t\t`T`,\n-\t\t\t[]string{`int`},\n-\t\t\t`struct{x int}`,\n+\t\t\t[]testInst{{`T`, []string{`int`}, `struct{x int}`}},\n \t\t},\n \t\t{`package type3; type T[P1 interface{~[]P2}, P2 any] struct{ x P1; y P2 }; var _ T[[]int, int]`,\n-\t\t\t`T`,\n-\t\t\t[]string{`[]int`, `int`},\n-\t\t\t`struct{x []int; y int}`,\n+\t\t\t[]testInst{{`T`, []string{`[]int`, `int`}, `struct{x []int; y int}`}},\n \t\t},\n \t\t{`package type4; import \"lib\"; var _ lib.T[int]`,\n-\t\t\t`T`,\n-\t\t\t[]string{`int`},\n-\t\t\t`[]int`,\n+\t\t\t[]testInst{{`T`, []string{`int`}, `[]int`}},\n+\t\t},\n+\n+\t\t{`package dupltype0; type T[P interface{~int}] struct{ x P }; var x T[int]; var y T[int]`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`T`, []string{`int`}, `struct{x int}`},\n+\t\t\t\t{`T`, []string{`int`}, `struct{x int}`},\n+\t\t\t},\n+\t\t},\n+\t\t{`package dupltype1; type T[P ~int] struct{ x P }; func (r *T[Q]) add(z T[Q]) { r.x += z.x }`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`T`, []string{`Q`}, `struct{x Q}`},\n+\t\t\t\t{`T`, []string{`Q`}, `struct{x Q}`},\n+\t\t\t},\n+\t\t},\n+\t\t{`package dupltype1; import \"lib\"; var x lib.T[int]; var y lib.T[int]; var z lib.T[string]`,\n+\t\t\t[]testInst{\n+\t\t\t\t{`T`, []string{`int`}, `[]int`},\n+\t\t\t\t{`T`, []string{`int`}, `[]int`},\n+\t\t\t\t{`T`, []string{`string`}, `[]string`},\n+\t\t\t},\n \t\t},\n \t}\n \n \tfor _, test := range tests {\n-\t\tconst lib = `package lib\n-\n-func F[P any](P) {}\n-\n-type T[P any] []P\n-`\n-\n \t\timports := make(testImporter)\n \t\tconf := Config{Importer: imports}\n-\t\tinstances := make(map[*ast.Ident]Instance)\n-\t\tuses := make(map[*ast.Ident]Object)\n+\t\tinstMap := make(map[*ast.Ident]Instance)\n+\t\tuseMap := make(map[*ast.Ident]Object)\n \t\tmakePkg := func(src string) *Package {\n \t\t\tf, err := parser.ParseFile(fset, \"p.go\", src, 0)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n-\t\t\tpkg, err := conf.Check(\"\", fset, []*ast.File{f}, &Info{Instances: instances, Uses: uses})\n+\t\t\tpkg, err := conf.Check(\"\", fset, []*ast.File{f}, &Info{Instances: instMap, Uses: useMap})\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n@@ -567,58 +585,69 @@ type T[P any] []P\n \t\tmakePkg(lib)\n \t\tpkg := makePkg(test.src)\n \n-\t\t// look for instance information\n-\t\tvar targs []Type\n-\t\tvar typ Type\n-\t\tfor ident, inst := range instances {\n-\t\t\tif ExprString(ident) == test.name {\n-\t\t\t\tfor i := 0; i < inst.TypeArgs.Len(); i++ {\n-\t\t\t\t\ttargs = append(targs, inst.TypeArgs.At(i))\n+\t\tt.Run(pkg.Name(), func(t *testing.T) {\n+\t\t\t// Sort instances in source order for stability.\n+\t\t\tinstances := sortedInstances(instMap)\n+\t\t\tif got, want := len(instances), len(test.instances); got != want {\n+\t\t\t\tt.Fatalf(\"got %d instances, want %d\", got, want)\n+\t\t\t}\n+\n+\t\t\t// Pairwise compare with the expected instances.\n+\t\t\tfor ii, inst := range instances {\n+\t\t\t\tvar targs []Type\n+\t\t\t\tfor i := 0; i < inst.Inst.TypeArgs.Len(); i++ {\n+\t\t\t\t\ttargs = append(targs, inst.Inst.TypeArgs.At(i))\n+\t\t\t\t}\n+\t\t\t\ttyp := inst.Inst.Type\n+\n+\t\t\t\ttestInst := test.instances[ii]\n+\t\t\t\tif got := inst.Ident.Name; got != testInst.name {\n+\t\t\t\t\tt.Fatalf(\"got name %s, want %s\", got, testInst.name)\n+\t\t\t\t}\n+\t\t\t\tif len(targs) != len(testInst.targs) {\n+\t\t\t\t\tt.Fatalf(\"got %d type arguments; want %d\", len(targs), len(testInst.targs))\n+\t\t\t\t}\n+\t\t\t\tfor i, targ := range targs {\n+\t\t\t\t\tif got := targ.String(); got != testInst.targs[i] {\n+\t\t\t\t\t\tt.Errorf(\"type argument %d: got %s; want %s\", i, got, testInst.targs[i])\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif got := typ.Underlying().String(); got != testInst.typ {\n+\t\t\t\t\tt.Errorf(\"package %s: got %s; want %s\", pkg.Name(), got, testInst.typ)\n \t\t\t\t}\n-\t\t\t\ttyp = inst.Type\n \n-\t\t\t\t// Check that we can find the corresponding parameterized type.\n-\t\t\t\tptype := uses[ident].Type()\n+\t\t\t\t// Verify the invariant that re-instantiating the corresponding generic\n+\t\t\t\t// type with TypeArgs results in an identical instance.\n+\t\t\t\tptype := useMap[inst.Ident].Type()\n \t\t\t\tlister, _ := ptype.(interface{ TypeParams() *TypeParamList })\n \t\t\t\tif lister == nil || lister.TypeParams().Len() == 0 {\n-\t\t\t\t\tt.Errorf(\"package %s: info.Types[%v] = %v, want parameterized type\", pkg.Name(), ident, ptype)\n-\t\t\t\t\tcontinue\n+\t\t\t\t\tt.Fatalf(\"info.Types[%v] = %v, want parameterized type\", inst.Ident, ptype)\n \t\t\t\t}\n-\n-\t\t\t\t// Verify the invariant that re-instantiating the generic type with\n-\t\t\t\t// TypeArgs results in an equivalent type.\n \t\t\t\tinst2, err := Instantiate(nil, ptype, targs, true)\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Errorf(\"Instantiate(%v, %v) failed: %v\", ptype, targs, err)\n \t\t\t\t}\n-\t\t\t\tif !Identical(inst.Type, inst2) {\n-\t\t\t\t\tt.Errorf(\"%v and %v are not identical\", inst.Type, inst2)\n+\t\t\t\tif !Identical(inst.Inst.Type, inst2) {\n+\t\t\t\t\tt.Errorf(\"%v and %v are not identical\", inst.Inst.Type, inst2)\n \t\t\t\t}\n-\t\t\t\tbreak\n \t\t\t}\n-\t\t}\n-\t\tif targs == nil {\n-\t\t\tt.Errorf(\"package %s: no instance information found for %s\", pkg.Name(), test.name)\n-\t\t\tcontinue\n-\t\t}\n+\t\t})\n+\t}\n+}\n \n-\t\t// check that type arguments are correct\n-\t\tif len(targs) != len(test.targs) {\n-\t\t\tt.Errorf(\"package %s: got %d type arguments; want %d\", pkg.Name(), len(targs), len(test.targs))\n-\t\t\tcontinue\n-\t\t}\n-\t\tfor i, targ := range targs {\n-\t\t\tif got := targ.String(); got != test.targs[i] {\n-\t\t\t\tt.Errorf(\"package %s, %d. type argument: got %s; want %s\", pkg.Name(), i, got, test.targs[i])\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n+type recordedInstance struct {\n+\tIdent *ast.Ident\n+\tInst  Instance\n+}\n \n-\t\t// check that the types match\n-\t\tif got := typ.Underlying().String(); got != test.typ {\n-\t\t\tt.Errorf(\"package %s: got %s; want %s\", pkg.Name(), got, test.typ)\n-\t\t}\n+func sortedInstances(m map[*ast.Ident]Instance) (instances []recordedInstance) {\n+\tfor id, inst := range m {\n+\t\tinstances = append(instances, recordedInstance{id, inst})\n \t}\n+\tsort.Slice(instances, func(i, j int) bool {\n+\t\treturn instances[i].Ident.Pos() < instances[j].Ident.Pos()\n+\t})\n+\treturn instances\n }\n \n func TestDefsInfo(t *testing.T) {\n@@ -1690,7 +1719,7 @@ func F(){\n \tvar F = /*F=func:12*/ F /*F=var:17*/ ; _ = F\n \n \tvar a []int\n-\tfor i, x := range /*i=undef*/ /*x=var:16*/ a /*i=var:20*/ /*x=var:20*/ { _ = i; _ = x }\n+\tfor i, x := range a /*i=undef*/ /*x=var:16*/ { _ = i; _ = x }\n \n \tvar i interface{}\n \tswitch y := i.(type) { /*y=undef*/"}, {"sha": "f5e22c2f675eef5c110d42fd3906e1fcf31ef460", "filename": "libgo/go/go/types/assignments.go", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fassignments.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -290,15 +290,14 @@ func (check *Checker) typesSummary(list []Type, variadic bool) string {\n \treturn \"(\" + strings.Join(res, \", \") + \")\"\n }\n \n-func (check *Checker) assignError(rhs []ast.Expr, nvars, nvals int) {\n-\tmeasure := func(x int, unit string) string {\n-\t\ts := fmt.Sprintf(\"%d %s\", x, unit)\n-\t\tif x != 1 {\n-\t\t\ts += \"s\"\n-\t\t}\n-\t\treturn s\n+func measure(x int, unit string) string {\n+\tif x != 1 {\n+\t\tunit += \"s\"\n \t}\n+\treturn fmt.Sprintf(\"%d %s\", x, unit)\n+}\n \n+func (check *Checker) assignError(rhs []ast.Expr, nvars, nvals int) {\n \tvars := measure(nvars, \"variable\")\n \tvals := measure(nvals, \"value\")\n \trhs0 := rhs[0]"}, {"sha": "5d1f60d43263b0a1440dd64147ff68e2e7875265", "filename": "libgo/go/go/types/call.go", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -429,7 +429,7 @@ var cgoPrefixes = [...]string{\n \t\"_Cmacro_\", // function to evaluate the expanded expression\n }\n \n-func (check *Checker) selector(x *operand, e *ast.SelectorExpr) {\n+func (check *Checker) selector(x *operand, e *ast.SelectorExpr, def *Named) {\n \t// these must be declared before the \"goto Error\" statements\n \tvar (\n \t\tobj      Object\n@@ -527,7 +527,18 @@ func (check *Checker) selector(x *operand, e *ast.SelectorExpr) {\n \t}\n \n \tcheck.exprOrType(x, e.X, false)\n-\tif x.mode == invalid {\n+\tswitch x.mode {\n+\tcase typexpr:\n+\t\t// don't crash for \"type T T.x\" (was issue #51509)\n+\t\tif def != nil && x.typ == def {\n+\t\t\tcheck.cycleError([]Object{def.obj})\n+\t\t\tgoto Error\n+\t\t}\n+\tcase builtin:\n+\t\t// types2 uses the position of '.' for the error\n+\t\tcheck.errorf(e.Sel, _UncalledBuiltin, \"cannot select on %s\", x)\n+\t\tgoto Error\n+\tcase invalid:\n \t\tgoto Error\n \t}\n "}, {"sha": "23136377c82dd36e59500f45c1f0c5c4db8305cf", "filename": "libgo/go/go/types/check.go", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcheck.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -133,7 +133,7 @@ type Checker struct {\n \tuntyped  map[ast.Expr]exprInfo // map of expressions without final type\n \tdelayed  []action              // stack of delayed action segments; segments are processed in FIFO order\n \tobjPath  []Object              // path of object dependencies during type inference (for cycle reporting)\n-\tdefTypes []*Named              // defined types created during type checking, for final validation.\n+\tcleaners []cleaner             // list of types that may need a final cleanup at the end of type-checking\n \n \t// environment within which the current object is type-checked (valid only\n \t// for the duration of type-checking a specific object)\n@@ -212,6 +212,16 @@ func (check *Checker) pop() Object {\n \treturn obj\n }\n \n+type cleaner interface {\n+\tcleanup()\n+}\n+\n+// needsCleanup records objects/types that implement the cleanup method\n+// which will be called at the end of type-checking.\n+func (check *Checker) needsCleanup(c cleaner) {\n+\tcheck.cleaners = append(check.cleaners, c)\n+}\n+\n // NewChecker returns a new Checker instance for a given package.\n // Package files may be added incrementally via checker.Files.\n func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker {\n@@ -255,6 +265,8 @@ func (check *Checker) initFiles(files []*ast.File) {\n \tcheck.methods = nil\n \tcheck.untyped = nil\n \tcheck.delayed = nil\n+\tcheck.objPath = nil\n+\tcheck.cleaners = nil\n \n \t// determine package name and collect valid files\n \tpkg := check.pkg\n@@ -304,22 +316,37 @@ func (check *Checker) checkFiles(files []*ast.File) (err error) {\n \n \tdefer check.handleBailout(&err)\n \n+\tprint := func(msg string) {\n+\t\tif trace {\n+\t\t\tfmt.Println()\n+\t\t\tfmt.Println(msg)\n+\t\t}\n+\t}\n+\n+\tprint(\"== initFiles ==\")\n \tcheck.initFiles(files)\n \n+\tprint(\"== collectObjects ==\")\n \tcheck.collectObjects()\n \n+\tprint(\"== packageObjects ==\")\n \tcheck.packageObjects()\n \n+\tprint(\"== processDelayed ==\")\n \tcheck.processDelayed(0) // incl. all functions\n \n-\tcheck.expandDefTypes()\n+\tprint(\"== cleanup ==\")\n+\tcheck.cleanup()\n \n+\tprint(\"== initOrder ==\")\n \tcheck.initOrder()\n \n \tif !check.conf.DisableUnusedImportCheck {\n+\t\tprint(\"== unusedImports ==\")\n \t\tcheck.unusedImports()\n \t}\n \n+\tprint(\"== recordUntyped ==\")\n \tcheck.recordUntyped()\n \n \tif check.firstErr == nil {\n@@ -337,7 +364,6 @@ func (check *Checker) checkFiles(files []*ast.File) (err error) {\n \tcheck.recvTParamMap = nil\n \tcheck.brokenAliases = nil\n \tcheck.unionTypeSets = nil\n-\tcheck.defTypes = nil\n \tcheck.ctxt = nil\n \n \t// TODO(rFindley) There's more memory we should release at this point.\n@@ -365,27 +391,13 @@ func (check *Checker) processDelayed(top int) {\n \tcheck.delayed = check.delayed[:top]\n }\n \n-func (check *Checker) expandDefTypes() {\n-\t// Ensure that every defined type created in the course of type-checking has\n-\t// either non-*Named underlying, or is unresolved.\n-\t//\n-\t// This guarantees that we don't leak any types whose underlying is *Named,\n-\t// because any unresolved instances will lazily compute their underlying by\n-\t// substituting in the underlying of their origin. The origin must have\n-\t// either been imported or type-checked and expanded here, and in either case\n-\t// its underlying will be fully expanded.\n-\tfor i := 0; i < len(check.defTypes); i++ {\n-\t\tn := check.defTypes[i]\n-\t\tswitch n.underlying.(type) {\n-\t\tcase nil:\n-\t\t\tif n.resolver == nil {\n-\t\t\t\tpanic(\"nil underlying\")\n-\t\t\t}\n-\t\tcase *Named:\n-\t\t\tn.under() // n.under may add entries to check.defTypes\n-\t\t}\n-\t\tn.check = nil\n+// cleanup runs cleanup for all collected cleaners.\n+func (check *Checker) cleanup() {\n+\t// Don't use a range clause since Named.cleanup may add more cleaners.\n+\tfor i := 0; i < len(check.cleaners); i++ {\n+\t\tcheck.cleaners[i].cleanup()\n \t}\n+\tcheck.cleaners = nil\n }\n \n func (check *Checker) record(x *operand) {"}, {"sha": "c5a69cddf48502b4e909e6ade91777e4507a8885", "filename": "libgo/go/go/types/conversions.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fconversions.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fconversions.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fconversions.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -48,11 +48,14 @@ func (check *Checker) conversion(x *operand, T Type) {\n \t\t// have specific types, constant x cannot be\n \t\t// converted.\n \t\tok = T.(*TypeParam).underIs(func(u Type) bool {\n-\t\t\t// t is nil if there are no specific type terms\n+\t\t\t// u is nil if there are no specific type terms\n \t\t\tif u == nil {\n \t\t\t\tcause = check.sprintf(\"%s does not contain specific types\", T)\n \t\t\t\treturn false\n \t\t\t}\n+\t\t\tif isString(x.typ) && isBytesOrRunes(u) {\n+\t\t\t\treturn true\n+\t\t\t}\n \t\t\tif !constConvertibleTo(u, nil) {\n \t\t\t\tcause = check.sprintf(\"cannot convert %s to %s (in %s)\", x, u, T)\n \t\t\t\treturn false"}, {"sha": "93a37d76ce0d78021708de8ae7806e41f205d85a", "filename": "libgo/go/go/types/decl.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fdecl.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -624,7 +624,6 @@ func (check *Checker) collectTypeParams(dst **TypeParamList, list *ast.FieldList\n \t}()\n \n \tindex := 0\n-\tvar bounds []Type\n \tfor _, f := range list.List {\n \t\tvar bound Type\n \t\t// NOTE: we may be able to assert that f.Type != nil here, but this is not\n@@ -642,7 +641,6 @@ func (check *Checker) collectTypeParams(dst **TypeParamList, list *ast.FieldList\n \t\t} else {\n \t\t\tbound = Typ[Invalid]\n \t\t}\n-\t\tbounds = append(bounds, bound)\n \t\tfor i := range f.Names {\n \t\t\ttparams[index+i].bound = bound\n \t\t}"}, {"sha": "64cf24c96a1545604a379819f10dc3422b46883f", "filename": "libgo/go/go/types/errorcodes.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ferrorcodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ferrorcodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ferrorcodes.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -1339,11 +1339,6 @@ const (\n \t//  func _() {\n \t//  \tf()\n \t//  }\n-\t//\n-\t// Example:\n-\t//   type N[P, Q any] struct{}\n-\t//\n-\t//   var _ N[int]\n \t_CannotInferTypeArgs\n \n \t// _InvalidTypeArg occurs when a type argument does not satisfy its"}, {"sha": "5700cbf79c72ad4dfea4556d0fe9058a92421960", "filename": "libgo/go/go/types/eval.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Feval.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Feval.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Feval.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -37,8 +37,8 @@ func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ Type\n \n // CheckExpr type checks the expression expr as if it had appeared at position\n // pos of package pkg. Type information about the expression is recorded in\n-// info. The expression may be an uninstantiated parameterized function or\n-// type.\n+// info. The expression may be an identifier denoting an uninstantiated generic\n+// function or type.\n //\n // If pkg == nil, the Universe scope is used and the provided\n // position pos is ignored. If pkg != nil, and pos is invalid,"}, {"sha": "e24bd60dc391a300885920770552ddcfb784db0a", "filename": "libgo/go/go/types/expr.go", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fexpr.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -859,7 +859,7 @@ func (check *Checker) incomparableCause(typ Type) string {\n \t}\n \t// see if we can extract a more specific error\n \tvar cause string\n-\tcomparable(typ, nil, func(format string, args ...interface{}) {\n+\tcomparable(typ, true, nil, func(format string, args ...interface{}) {\n \t\tcause = check.sprintf(format, args...)\n \t})\n \treturn cause\n@@ -1339,6 +1339,10 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\t\t// no composite literal type present - use hint (element type of enclosing type)\n \t\t\ttyp = hint\n \t\t\tbase, _ = deref(coreType(typ)) // *T implies &T{}\n+\t\t\tif base == nil {\n+\t\t\t\tcheck.errorf(e, _InvalidLit, \"invalid composite literal element type %s: no core type\", typ)\n+\t\t\t\tgoto Error\n+\t\t\t}\n \n \t\tdefault:\n \t\t\t// TODO(gri) provide better error messages depending on context\n@@ -1529,7 +1533,7 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\treturn kind\n \n \tcase *ast.SelectorExpr:\n-\t\tcheck.selector(x, e)\n+\t\tcheck.selector(x, e, nil)\n \n \tcase *ast.IndexExpr, *ast.IndexListExpr:\n \t\tix := typeparams.UnpackIndexExpr(e)\n@@ -1584,6 +1588,7 @@ func (check *Checker) exprInternal(x *operand, e ast.Expr, hint Type) exprKind {\n \t\tcase invalid:\n \t\t\tgoto Error\n \t\tcase typexpr:\n+\t\t\tcheck.validVarType(e.X, x.typ)\n \t\t\tx.typ = &Pointer{base: x.typ}\n \t\tdefault:\n \t\t\tvar base Type"}, {"sha": "33075edaf14c97d3a10cc0ec811496259eacef44", "filename": "libgo/go/go/types/index.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Findex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Findex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Findex.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -183,6 +183,7 @@ func (check *Checker) indexExpr(x *operand, e *typeparams.IndexExpr) (isFuncInst\n \t}\n \n \tif !valid {\n+\t\t// types2 uses the position of '[' for the error\n \t\tcheck.invalidOp(x, _NonIndexableOperand, \"cannot index %s\", x)\n \t\tx.mode = invalid\n \t\treturn false"}, {"sha": "6bed55c270f46b15359001437004266db2ec074c", "filename": "libgo/go/go/types/infer.go", "status": "modified", "additions": 108, "deletions": 20, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Finfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Finfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Finfer.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -487,21 +487,88 @@ func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []Type\n \t\t}\n \t}\n \n-\t// If a constraint has a core type, unify the corresponding type parameter with it.\n-\tfor _, tpar := range tparams {\n-\t\tif ctype := adjCoreType(tpar); ctype != nil {\n-\t\t\tif !u.unify(tpar, ctype) {\n-\t\t\t\t// TODO(gri) improve error message by providing the type arguments\n-\t\t\t\t//           which we know already\n-\t\t\t\tcheck.errorf(posn, _InvalidTypeArg, \"%s does not match %s\", tpar, ctype)\n-\t\t\t\treturn nil, 0\n+\t// Repeatedly apply constraint type inference as long as\n+\t// there are still unknown type arguments and progress is\n+\t// being made.\n+\t//\n+\t// This is an O(n^2) algorithm where n is the number of\n+\t// type parameters: if there is progress (and iteration\n+\t// continues), at least one type argument is inferred\n+\t// per iteration and we have a doubly nested loop.\n+\t// In practice this is not a problem because the number\n+\t// of type parameters tends to be very small (< 5 or so).\n+\t// (It should be possible for unification to efficiently\n+\t// signal newly inferred type arguments; then the loops\n+\t// here could handle the respective type parameters only,\n+\t// but that will come at a cost of extra complexity which\n+\t// may not be worth it.)\n+\tfor n := u.x.unknowns(); n > 0; {\n+\t\tnn := n\n+\n+\t\tfor i, tpar := range tparams {\n+\t\t\t// If there is a core term (i.e., a core type with tilde information)\n+\t\t\t// unify the type parameter with the core type.\n+\t\t\tif core, single := coreTerm(tpar); core != nil {\n+\t\t\t\t// A type parameter can be unified with its core type in two cases.\n+\t\t\t\ttx := u.x.at(i)\n+\t\t\t\tswitch {\n+\t\t\t\tcase tx != nil:\n+\t\t\t\t\t// The corresponding type argument tx is known.\n+\t\t\t\t\t// In this case, if the core type has a tilde, the type argument's underlying\n+\t\t\t\t\t// type must match the core type, otherwise the type argument and the core type\n+\t\t\t\t\t// must match.\n+\t\t\t\t\t// If tx is an external type parameter, don't consider its underlying type\n+\t\t\t\t\t// (which is an interface). Core type unification will attempt to unify against\n+\t\t\t\t\t// core.typ.\n+\t\t\t\t\t// Note also that even with inexact unification we cannot leave away the under\n+\t\t\t\t\t// call here because it's possible that both tx and core.typ are named types,\n+\t\t\t\t\t// with under(tx) being a (named) basic type matching core.typ. Such cases do\n+\t\t\t\t\t// not match with inexact unification.\n+\t\t\t\t\tif core.tilde && !isTypeParam(tx) {\n+\t\t\t\t\t\ttx = under(tx)\n+\t\t\t\t\t}\n+\t\t\t\t\tif !u.unify(tx, core.typ) {\n+\t\t\t\t\t\t// TODO(gri) improve error message by providing the type arguments\n+\t\t\t\t\t\t//           which we know already\n+\t\t\t\t\t\t// Don't use term.String() as it always qualifies types, even if they\n+\t\t\t\t\t\t// are in the current package.\n+\t\t\t\t\t\ttilde := \"\"\n+\t\t\t\t\t\tif core.tilde {\n+\t\t\t\t\t\t\ttilde = \"~\"\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tcheck.errorf(posn, _InvalidTypeArg, \"%s does not match %s%s\", tpar, tilde, core.typ)\n+\t\t\t\t\t\treturn nil, 0\n+\t\t\t\t\t}\n+\n+\t\t\t\tcase single && !core.tilde:\n+\t\t\t\t\t// The corresponding type argument tx is unknown and there's a single\n+\t\t\t\t\t// specific type and no tilde.\n+\t\t\t\t\t// In this case the type argument must be that single type; set it.\n+\t\t\t\t\tu.x.set(i, core.typ)\n+\n+\t\t\t\tdefault:\n+\t\t\t\t\t// Unification is not possible and no progress was made.\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\t// The number of known type arguments may have changed.\n+\t\t\t\tnn = u.x.unknowns()\n+\t\t\t\tif nn == 0 {\n+\t\t\t\t\tbreak // all type arguments are known\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n+\n+\t\tassert(nn <= n)\n+\t\tif nn == n {\n+\t\t\tbreak // no progress\n+\t\t}\n+\t\tn = nn\n \t}\n \n \t// u.x.types() now contains the incoming type arguments plus any additional type\n-\t// arguments which were inferred from core types. The newly inferred non-\n-\t// nil entries may still contain references to other type parameters.\n+\t// arguments which were inferred from core terms. The newly inferred non-nil\n+\t// entries may still contain references to other type parameters.\n \t// For instance, for [A any, B interface{ []C }, C interface{ *A }], if A == int\n \t// was given, unification produced the type list [int, []C, *A]. We eliminate the\n \t// remaining type parameters by substituting the type parameters in this type list\n@@ -590,17 +657,40 @@ func (check *Checker) inferB(posn positioner, tparams []*TypeParam, targs []Type\n \treturn\n }\n \n-func adjCoreType(tpar *TypeParam) Type {\n-\t// If the type parameter embeds a single, possibly named\n-\t// type, use that one instead of the core type (which is\n-\t// always the underlying type of that single type).\n-\tif single := tpar.singleType(); single != nil {\n+// If the type parameter has a single specific type S, coreTerm returns (S, true).\n+// Otherwise, if tpar has a core type T, it returns a term corresponding to that\n+// core type and false. In that case, if any term of tpar has a tilde, the core\n+// term has a tilde. In all other cases coreTerm returns (nil, false).\n+func coreTerm(tpar *TypeParam) (*term, bool) {\n+\tn := 0\n+\tvar single *term // valid if n == 1\n+\tvar tilde bool\n+\ttpar.is(func(t *term) bool {\n+\t\tif t == nil {\n+\t\t\tassert(n == 0)\n+\t\t\treturn false // no terms\n+\t\t}\n+\t\tn++\n+\t\tsingle = t\n+\t\tif t.tilde {\n+\t\t\ttilde = true\n+\t\t}\n+\t\treturn true\n+\t})\n+\tif n == 1 {\n \t\tif debug {\n-\t\t\tassert(under(single) == coreType(tpar))\n+\t\t\tassert(debug && under(single.typ) == coreType(tpar))\n \t\t}\n-\t\treturn single\n+\t\treturn single, true\n+\t}\n+\tif typ := coreType(tpar); typ != nil {\n+\t\t// A core type is always an underlying type.\n+\t\t// If any term of tpar has a tilde, we don't\n+\t\t// have a precise core type and we must return\n+\t\t// a tilde as well.\n+\t\treturn &term{tilde, typ}, false\n \t}\n-\treturn coreType(tpar)\n+\treturn nil, false\n }\n \n type cycleFinder struct {\n@@ -648,8 +738,6 @@ func (w *cycleFinder) typ(typ Type) {\n \t//      in signatures where they are handled explicitly.\n \n \tcase *Signature:\n-\t\t// There are no \"method types\" so we should never see a recv.\n-\t\tassert(t.recv == nil)\n \t\tif t.params != nil {\n \t\t\tw.varList(t.params.vars)\n \t\t}"}, {"sha": "a48174665739f8206504b17a8e93024c708be83e", "filename": "libgo/go/go/types/instantiate.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Finstantiate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Finstantiate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Finstantiate.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -15,10 +15,10 @@ import (\n \n // Instantiate instantiates the type orig with the given type arguments targs.\n // orig must be a *Named or a *Signature type. If there is no error, the\n-// resulting Type is a new, instantiated (not parameterized) type of the same\n-// kind (either a *Named or a *Signature). Methods attached to a *Named type\n-// are also instantiated, and associated with a new *Func that has the same\n-// position as the original method, but nil function scope.\n+// resulting Type is an instantiated type of the same kind (either a *Named or\n+// a *Signature). Methods attached to a *Named type are also instantiated, and\n+// associated with a new *Func that has the same position as the original\n+// method, but nil function scope.\n //\n // If ctxt is non-nil, it may be used to de-duplicate the instance against\n // previous instances with the same identity. As a special case, generic\n@@ -204,7 +204,7 @@ func (check *Checker) implements(V, T Type) error {\n \t// If T is comparable, V must be comparable.\n \t// Remember as a pending error and report only if we don't have a more specific error.\n \tvar pending error\n-\tif Ti.IsComparable() && ((Vi != nil && !Vi.IsComparable()) || (Vi == nil && !Comparable(V))) {\n+\tif Ti.IsComparable() && !comparable(V, false, nil, nil) {\n \t\tpending = errorf(\"%s does not implement comparable\", V)\n \t}\n "}, {"sha": "3db3580a91b5819844826aa392f2b0e2f3cbc9ca", "filename": "libgo/go/go/types/interface.go", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Finterface.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -56,7 +56,7 @@ func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface {\n \t}\n \n \t// set method receivers if necessary\n-\ttyp := new(Interface)\n+\ttyp := (*Checker)(nil).newInterface()\n \tfor _, m := range methods {\n \t\tif sig := m.typ.(*Signature); sig.recv == nil {\n \t\t\tsig.recv = NewVar(m.pos, m.pkg, \"\", typ)\n@@ -73,6 +73,15 @@ func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface {\n \treturn typ\n }\n \n+// check may be nil\n+func (check *Checker) newInterface() *Interface {\n+\ttyp := &Interface{check: check}\n+\tif check != nil {\n+\t\tcheck.needsCleanup(typ)\n+\t}\n+\treturn typ\n+}\n+\n // MarkImplicit marks the interface t as implicit, meaning this interface\n // corresponds to a constraint literal such as ~T or A|B without explicit\n // interface embedding. MarkImplicit should be called before any concurrent use\n@@ -141,6 +150,11 @@ func (t *Interface) String() string   { return TypeString(t, nil) }\n // ----------------------------------------------------------------------------\n // Implementation\n \n+func (t *Interface) cleanup() {\n+\tt.check = nil\n+\tt.embedPos = nil\n+}\n+\n func (check *Checker) interfaceType(ityp *Interface, iface *ast.InterfaceType, def *Named) {\n \taddEmbedded := func(pos token.Pos, typ Type) {\n \t\tityp.embeddeds = append(ityp.embeddeds, typ)\n@@ -210,16 +224,10 @@ func (check *Checker) interfaceType(ityp *Interface, iface *ast.InterfaceType, d\n \tsortMethods(ityp.methods)\n \t// (don't sort embeddeds: they must correspond to *embedPos entries)\n \n-\t// Compute type set with a non-nil *Checker as soon as possible\n-\t// to report any errors. Subsequent uses of type sets will use\n-\t// this computed type set and won't need to pass in a *Checker.\n-\t//\n-\t// Pin the checker to the interface type in the interim, in case the type set\n-\t// must be used before delayed funcs are processed (see issue #48234).\n-\t// TODO(rfindley): clean up use of *Checker with computeInterfaceTypeSet\n-\tityp.check = check\n+\t// Compute type set as soon as possible to report any errors.\n+\t// Subsequent uses of type sets will use this computed type\n+\t// set and won't need to pass in a *Checker.\n \tcheck.later(func() {\n \t\tcomputeInterfaceTypeSet(check, iface.Pos(), ityp)\n-\t\tityp.check = nil\n \t}).describef(iface, \"compute type set for %s\", ityp)\n }"}, {"sha": "335fada7b764957cdf310177b2adaca082e902dc", "filename": "libgo/go/go/types/lookup.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -70,7 +70,8 @@ func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (o\n \t// see if there is a matching field (but not a method, those need to be declared\n \t// explicitly in the constraint). If the constraint is a named pointer type (see\n \t// above), we are ok here because only fields are accepted as results.\n-\tif obj == nil && isTypeParam(T) {\n+\tconst enableTParamFieldLookup = false // see issue #51576\n+\tif enableTParamFieldLookup && obj == nil && isTypeParam(T) {\n \t\tif t := coreType(T); t != nil {\n \t\t\tobj, index, indirect = lookupFieldOrMethod(t, addressable, pkg, name, false)\n \t\t\tif _, ok := obj.(*Var); !ok {"}, {"sha": "876f7e8551fbf3e4e035b2ae3f3dc05364ace1f1", "filename": "libgo/go/go/types/named.go", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fnamed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fnamed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fnamed.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -72,26 +72,46 @@ func (check *Checker) newNamed(obj *TypeName, orig *Named, underlying Type, tpar\n \t}\n \t// Ensure that typ is always expanded and sanity-checked.\n \tif check != nil {\n-\t\tcheck.defTypes = append(check.defTypes, typ)\n+\t\tcheck.needsCleanup(typ)\n \t}\n \treturn typ\n }\n \n+func (t *Named) cleanup() {\n+\t// Ensure that every defined type created in the course of type-checking has\n+\t// either non-*Named underlying, or is unresolved.\n+\t//\n+\t// This guarantees that we don't leak any types whose underlying is *Named,\n+\t// because any unresolved instances will lazily compute their underlying by\n+\t// substituting in the underlying of their origin. The origin must have\n+\t// either been imported or type-checked and expanded here, and in either case\n+\t// its underlying will be fully expanded.\n+\tswitch t.underlying.(type) {\n+\tcase nil:\n+\t\tif t.resolver == nil {\n+\t\t\tpanic(\"nil underlying\")\n+\t\t}\n+\tcase *Named:\n+\t\tt.under() // t.under may add entries to check.cleaners\n+\t}\n+\tt.check = nil\n+}\n+\n // Obj returns the type name for the declaration defining the named type t. For\n-// instantiated types, this is the type name of the base type.\n+// instantiated types, this is same as the type name of the origin type.\n func (t *Named) Obj() *TypeName {\n \treturn t.orig.obj // for non-instances this is the same as t.obj\n }\n \n-// Origin returns the parameterized type from which the named type t is\n+// Origin returns the generic type from which the named type t is\n // instantiated. If t is not an instantiated type, the result is t.\n func (t *Named) Origin() *Named { return t.orig }\n \n // TODO(gri) Come up with a better representation and API to distinguish\n //           between parameterized instantiated and non-instantiated types.\n \n // TypeParams returns the type parameters of the named type t, or nil.\n-// The result is non-nil for an (originally) parameterized type even if it is instantiated.\n+// The result is non-nil for an (originally) generic type even if it is instantiated.\n func (t *Named) TypeParams() *TypeParamList { return t.resolve(nil).tparams }\n \n // SetTypeParams sets the type parameters of the named type t.\n@@ -104,7 +124,11 @@ func (t *Named) SetTypeParams(tparams []*TypeParam) {\n // TypeArgs returns the type arguments used to instantiate the named type t.\n func (t *Named) TypeArgs() *TypeList { return t.targs }\n \n-// NumMethods returns the number of explicit methods whose receiver is named type t.\n+// NumMethods returns the number of explicit methods defined for t.\n+//\n+// For an ordinary or instantiated type t, the receiver base type of these\n+// methods will be the named type t. For an uninstantiated generic type t, each\n+// method receiver will be instantiated with its receiver type parameters.\n func (t *Named) NumMethods() int { return t.resolve(nil).methods.Len() }\n \n // Method returns the i'th method of named type t for 0 <= i < t.NumMethods().\n@@ -362,11 +386,11 @@ func expandNamed(ctxt *Context, n *Named, instPos token.Pos) (tparams *TypeParam\n \t\t\t\t// that it wasn't substituted. In this case we need to create a new\n \t\t\t\t// *Interface before modifying receivers.\n \t\t\t\tif iface == n.orig.underlying {\n-\t\t\t\t\tiface = &Interface{\n-\t\t\t\t\t\tembeddeds: iface.embeddeds,\n-\t\t\t\t\t\tcomplete:  iface.complete,\n-\t\t\t\t\t\timplicit:  iface.implicit, // should be false but be conservative\n-\t\t\t\t\t}\n+\t\t\t\t\told := iface\n+\t\t\t\t\tiface = check.newInterface()\n+\t\t\t\t\tiface.embeddeds = old.embeddeds\n+\t\t\t\t\tiface.complete = old.complete\n+\t\t\t\t\tiface.implicit = old.implicit // should be false but be conservative\n \t\t\t\t\tunderlying = iface\n \t\t\t\t}\n \t\t\t\tiface.methods = methods"}, {"sha": "0360f27ee60dc10d2e63c6717afd793eeccd01e8", "filename": "libgo/go/go/types/predicates.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fpredicates.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -104,11 +104,12 @@ func isGeneric(t Type) bool {\n \n // Comparable reports whether values of type T are comparable.\n func Comparable(T Type) bool {\n-\treturn comparable(T, nil, nil)\n+\treturn comparable(T, true, nil, nil)\n }\n \n+// If dynamic is set, non-type parameter interfaces are always comparable.\n // If reportf != nil, it may be used to report why T is not comparable.\n-func comparable(T Type, seen map[Type]bool, reportf func(string, ...interface{})) bool {\n+func comparable(T Type, dynamic bool, seen map[Type]bool, reportf func(string, ...interface{})) bool {\n \tif seen[T] {\n \t\treturn true\n \t}\n@@ -126,7 +127,7 @@ func comparable(T Type, seen map[Type]bool, reportf func(string, ...interface{})\n \t\treturn true\n \tcase *Struct:\n \t\tfor _, f := range t.fields {\n-\t\t\tif !comparable(f.typ, seen, nil) {\n+\t\t\tif !comparable(f.typ, dynamic, seen, nil) {\n \t\t\t\tif reportf != nil {\n \t\t\t\t\treportf(\"struct containing %s cannot be compared\", f.typ)\n \t\t\t\t}\n@@ -135,15 +136,15 @@ func comparable(T Type, seen map[Type]bool, reportf func(string, ...interface{})\n \t\t}\n \t\treturn true\n \tcase *Array:\n-\t\tif !comparable(t.elem, seen, nil) {\n+\t\tif !comparable(t.elem, dynamic, seen, nil) {\n \t\t\tif reportf != nil {\n \t\t\t\treportf(\"%s cannot be compared\", t)\n \t\t\t}\n \t\t\treturn false\n \t\t}\n \t\treturn true\n \tcase *Interface:\n-\t\treturn !isTypeParam(T) || t.typeSet().IsComparable(seen)\n+\t\treturn dynamic && !isTypeParam(T) || t.typeSet().IsComparable(seen)\n \t}\n \treturn false\n }"}, {"sha": "a340ac701eaa53d535bcdb4dbd64b8793791efa0", "filename": "libgo/go/go/types/signature.go", "status": "modified", "additions": 78, "deletions": 66, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fsignature.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -112,7 +112,8 @@ func (check *Checker) funcType(sig *Signature, recvPar *ast.FieldList, ftyp *ast\n \t\t// - the receiver specification acts as local declaration for its type parameters, which may be blank\n \t\t_, rname, rparams := check.unpackRecv(recvPar.List[0].Type, true)\n \t\tif len(rparams) > 0 {\n-\t\t\tsig.rparams = bindTParams(check.declareTypeParams(nil, rparams))\n+\t\t\ttparams := check.declareTypeParams(nil, rparams)\n+\t\t\tsig.rparams = bindTParams(tparams)\n \t\t\t// Blank identifiers don't get declared, so naive type-checking of the\n \t\t\t// receiver type expression would fail in Checker.collectParams below,\n \t\t\t// when Checker.ident cannot resolve the _ to a type.\n@@ -122,11 +123,10 @@ func (check *Checker) funcType(sig *Signature, recvPar *ast.FieldList, ftyp *ast\n \t\t\t// lookup in the scope.\n \t\t\tfor i, p := range rparams {\n \t\t\t\tif p.Name == \"_\" {\n-\t\t\t\t\ttpar := sig.rparams.At(i)\n \t\t\t\t\tif check.recvTParamMap == nil {\n \t\t\t\t\t\tcheck.recvTParamMap = make(map[*ast.Ident]*TypeParam)\n \t\t\t\t\t}\n-\t\t\t\t\tcheck.recvTParamMap[p] = tpar\n+\t\t\t\t\tcheck.recvTParamMap[p] = tparams[i]\n \t\t\t\t}\n \t\t\t}\n \t\t\t// determine receiver type to get its type parameters\n@@ -142,22 +142,23 @@ func (check *Checker) funcType(sig *Signature, recvPar *ast.FieldList, ftyp *ast\n \t\t\t\t}\n \t\t\t}\n \t\t\t// provide type parameter bounds\n-\t\t\t// - only do this if we have the right number (otherwise an error is reported elsewhere)\n-\t\t\tif sig.RecvTypeParams().Len() == len(recvTParams) {\n-\t\t\t\t// We have a list of *TypeNames but we need a list of Types.\n-\t\t\t\tlist := make([]Type, sig.RecvTypeParams().Len())\n-\t\t\t\tfor i, t := range sig.RecvTypeParams().list() {\n-\t\t\t\t\tlist[i] = t\n-\t\t\t\t\tcheck.mono.recordCanon(t, recvTParams[i])\n-\t\t\t\t}\n-\t\t\t\tsmap := makeSubstMap(recvTParams, list)\n-\t\t\t\tfor i, tpar := range sig.RecvTypeParams().list() {\n-\t\t\t\t\tbound := recvTParams[i].bound\n-\t\t\t\t\t// bound is (possibly) parameterized in the context of the\n-\t\t\t\t\t// receiver type declaration. Substitute parameters for the\n-\t\t\t\t\t// current context.\n-\t\t\t\t\ttpar.bound = check.subst(tpar.obj.pos, bound, smap, nil)\n+\t\t\tif len(tparams) == len(recvTParams) {\n+\t\t\t\tsmap := makeRenameMap(recvTParams, tparams)\n+\t\t\t\tfor i, tpar := range tparams {\n+\t\t\t\t\trecvTPar := recvTParams[i]\n+\t\t\t\t\tcheck.mono.recordCanon(tpar, recvTPar)\n+\t\t\t\t\t// recvTPar.bound is (possibly) parameterized in the context of the\n+\t\t\t\t\t// receiver type declaration. Substitute parameters for the current\n+\t\t\t\t\t// context.\n+\t\t\t\t\ttpar.bound = check.subst(tpar.obj.pos, recvTPar.bound, smap, nil)\n \t\t\t\t}\n+\t\t\t} else if len(tparams) < len(recvTParams) {\n+\t\t\t\t// Reporting an error here is a stop-gap measure to avoid crashes in the\n+\t\t\t\t// compiler when a type parameter/argument cannot be inferred later. It\n+\t\t\t\t// may lead to follow-on errors (see issues #51339, #51343).\n+\t\t\t\t// TODO(gri) find a better solution\n+\t\t\t\tgot := measure(len(tparams), \"type parameter\")\n+\t\t\t\tcheck.errorf(recvPar, _BadRecv, \"got %s, but receiver base type declares %d\", got, len(recvTParams))\n \t\t\t}\n \t\t}\n \t}\n@@ -192,66 +193,77 @@ func (check *Checker) funcType(sig *Signature, recvPar *ast.FieldList, ftyp *ast\n \t\tswitch len(recvList) {\n \t\tcase 0:\n \t\t\t// error reported by resolver\n-\t\t\trecv = NewParam(0, nil, \"\", Typ[Invalid]) // ignore recv below\n+\t\t\trecv = NewParam(token.NoPos, nil, \"\", Typ[Invalid]) // ignore recv below\n \t\tdefault:\n \t\t\t// more than one receiver\n-\t\t\tcheck.error(recvList[len(recvList)-1], _BadRecv, \"method must have exactly one receiver\")\n+\t\t\tcheck.error(recvList[len(recvList)-1], _InvalidRecv, \"method must have exactly one receiver\")\n \t\t\tfallthrough // continue with first receiver\n \t\tcase 1:\n \t\t\trecv = recvList[0]\n \t\t}\n+\t\tsig.recv = recv\n \n-\t\t// TODO(gri) We should delay rtyp expansion to when we actually need the\n-\t\t//           receiver; thus all checks here should be delayed to later.\n-\t\trtyp, _ := deref(recv.typ)\n+\t\t// Delay validation of receiver type as it may cause premature expansion\n+\t\t// of types the receiver type is dependent on (see issues #51232, #51233).\n+\t\tcheck.later(func() {\n+\t\t\trtyp, _ := deref(recv.typ)\n \n-\t\t// spec: \"The receiver type must be of the form T or *T where T is a type name.\"\n-\t\t// (ignore invalid types - error was reported before)\n-\t\tif rtyp != Typ[Invalid] {\n-\t\t\tvar err string\n-\t\t\tswitch T := rtyp.(type) {\n-\t\t\tcase *Named:\n-\t\t\t\tT.resolve(check.bestContext(nil))\n-\t\t\t\t// The receiver type may be an instantiated type referred to\n-\t\t\t\t// by an alias (which cannot have receiver parameters for now).\n-\t\t\t\tif T.TypeArgs() != nil && sig.RecvTypeParams() == nil {\n-\t\t\t\t\tcheck.errorf(atPos(recv.pos), _InvalidRecv, \"cannot define methods on instantiated type %s\", recv.typ)\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\t// spec: \"The type denoted by T is called the receiver base type; it must not\n-\t\t\t\t// be a pointer or interface type and it must be declared in the same package\n-\t\t\t\t// as the method.\"\n-\t\t\t\tif T.obj.pkg != check.pkg {\n-\t\t\t\t\terr = \"type not defined in this package\"\n-\t\t\t\t} else {\n-\t\t\t\t\t// The underlying type of a receiver base type can be a type parameter;\n-\t\t\t\t\t// e.g. for methods with a generic receiver T[P] with type T[P any] P.\n-\t\t\t\t\tunderIs(T, func(u Type) bool {\n-\t\t\t\t\t\tswitch u := u.(type) {\n-\t\t\t\t\t\tcase *Basic:\n-\t\t\t\t\t\t\t// unsafe.Pointer is treated like a regular pointer\n-\t\t\t\t\t\t\tif u.kind == UnsafePointer {\n-\t\t\t\t\t\t\t\terr = \"unsafe.Pointer\"\n+\t\t\t// spec: \"The receiver type must be of the form T or *T where T is a type name.\"\n+\t\t\t// (ignore invalid types - error was reported before)\n+\t\t\tif rtyp != Typ[Invalid] {\n+\t\t\t\tvar err string\n+\t\t\t\tswitch T := rtyp.(type) {\n+\t\t\t\tcase *Named:\n+\t\t\t\t\tT.resolve(check.bestContext(nil))\n+\t\t\t\t\t// The receiver type may be an instantiated type referred to\n+\t\t\t\t\t// by an alias (which cannot have receiver parameters for now).\n+\t\t\t\t\tif T.TypeArgs() != nil && sig.RecvTypeParams() == nil {\n+\t\t\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"cannot define methods on instantiated type %s\", recv.typ)\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t\t// spec: \"The type denoted by T is called the receiver base type; it must not\n+\t\t\t\t\t// be a pointer or interface type and it must be declared in the same package\n+\t\t\t\t\t// as the method.\"\n+\t\t\t\t\tif T.obj.pkg != check.pkg {\n+\t\t\t\t\t\terr = \"type not defined in this package\"\n+\t\t\t\t\t\tif compilerErrorMessages {\n+\t\t\t\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"cannot define new methods on non-local type %s\", recv.typ)\n+\t\t\t\t\t\t\terr = \"\"\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// The underlying type of a receiver base type can be a type parameter;\n+\t\t\t\t\t\t// e.g. for methods with a generic receiver T[P] with type T[P any] P.\n+\t\t\t\t\t\t// TODO(gri) Such declarations are currently disallowed.\n+\t\t\t\t\t\t//           Revisit the need for underIs.\n+\t\t\t\t\t\tunderIs(T, func(u Type) bool {\n+\t\t\t\t\t\t\tswitch u := u.(type) {\n+\t\t\t\t\t\t\tcase *Basic:\n+\t\t\t\t\t\t\t\t// unsafe.Pointer is treated like a regular pointer\n+\t\t\t\t\t\t\t\tif u.kind == UnsafePointer {\n+\t\t\t\t\t\t\t\t\terr = \"unsafe.Pointer\"\n+\t\t\t\t\t\t\t\t\treturn false\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcase *Pointer, *Interface:\n+\t\t\t\t\t\t\t\terr = \"pointer or interface type\"\n \t\t\t\t\t\t\t\treturn false\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\tcase *Pointer, *Interface:\n-\t\t\t\t\t\t\terr = \"pointer or interface type\"\n-\t\t\t\t\t\t\treturn false\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn true\n-\t\t\t\t\t})\n+\t\t\t\t\t\t\treturn true\n+\t\t\t\t\t\t})\n+\t\t\t\t\t}\n+\t\t\t\tcase *Basic:\n+\t\t\t\t\terr = \"basic or unnamed type\"\n+\t\t\t\t\tif compilerErrorMessages {\n+\t\t\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"cannot define new methods on non-local type %s\", recv.typ)\n+\t\t\t\t\t\terr = \"\"\n+\t\t\t\t\t}\n+\t\t\t\tdefault:\n+\t\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"invalid receiver type %s\", recv.typ)\n+\t\t\t\t}\n+\t\t\t\tif err != \"\" {\n+\t\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"invalid receiver type %s (%s)\", recv.typ, err)\n \t\t\t\t}\n-\t\t\tcase *Basic:\n-\t\t\t\terr = \"basic or unnamed type\"\n-\t\t\tdefault:\n-\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"invalid receiver type %s\", recv.typ)\n-\t\t\t}\n-\t\t\tif err != \"\" {\n-\t\t\t\tcheck.errorf(recv, _InvalidRecv, \"invalid receiver type %s (%s)\", recv.typ, err)\n-\t\t\t\t// ok to continue\n \t\t\t}\n-\t\t}\n-\t\tsig.recv = recv\n+\t\t}).describef(recv, \"validate receiver %s\", recv)\n \t}\n \n \tsig.params = NewTuple(params...)"}, {"sha": "9ebfbb6d6370296a361a03e11311d46decdb2d66", "filename": "libgo/go/go/types/stmt.go", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fstmt.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -821,8 +821,6 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \n \tcase *ast.RangeStmt:\n \t\tinner |= breakOk | continueOk\n-\t\tcheck.openScope(s, \"for\")\n-\t\tdefer check.closeScope()\n \n \t\t// check expression to iterate over\n \t\tvar x operand\n@@ -857,6 +855,11 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\t\t}\n \t\t}\n \n+\t\t// Open the for-statement block scope now, after the range clause.\n+\t\t// Iteration variables declared with := need to go in this scope (was issue #51437).\n+\t\tcheck.openScope(s, \"range\")\n+\t\tdefer check.closeScope()\n+\n \t\t// check assignment to/declaration of iteration variables\n \t\t// (irregular assignment, cannot easily map to existing assignment checks)\n \n@@ -865,9 +868,7 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \t\trhs := [2]Type{key, val} // key, val may be nil\n \n \t\tif s.Tok == token.DEFINE {\n-\t\t\t// short variable declaration; variable scope starts after the range clause\n-\t\t\t// (the for loop opens a new scope, so variables on the lhs never redeclare\n-\t\t\t// previously declared variables)\n+\t\t\t// short variable declaration\n \t\t\tvar vars []*Var\n \t\t\tfor i, lhs := range lhs {\n \t\t\t\tif lhs == nil {\n@@ -904,12 +905,8 @@ func (check *Checker) stmt(ctxt stmtContext, s ast.Stmt) {\n \n \t\t\t// declare variables\n \t\t\tif len(vars) > 0 {\n-\t\t\t\tscopePos := s.X.End()\n+\t\t\t\tscopePos := s.Body.Pos()\n \t\t\t\tfor _, obj := range vars {\n-\t\t\t\t\t// spec: \"The scope of a constant or variable identifier declared inside\n-\t\t\t\t\t// a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl\n-\t\t\t\t\t// for short variable declarations) and ends at the end of the innermost\n-\t\t\t\t\t// containing block.\"\n \t\t\t\t\tcheck.declare(check.scope, nil /* recordDef already called */, obj, scopePos)\n \t\t\t\t}\n \t\t\t} else {"}, {"sha": "4b4a0f4ad670945acea046f3e8f2de1790b68891", "filename": "libgo/go/go/types/subst.go", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fsubst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fsubst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fsubst.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -160,7 +160,10 @@ func (subst *subster) typ(typ Type) Type {\n \t\tmethods, mcopied := subst.funcList(t.methods)\n \t\tembeddeds, ecopied := subst.typeList(t.embeddeds)\n \t\tif mcopied || ecopied {\n-\t\t\tiface := &Interface{embeddeds: embeddeds, implicit: t.implicit, complete: t.complete}\n+\t\t\tiface := subst.check.newInterface()\n+\t\t\tiface.embeddeds = embeddeds\n+\t\t\tiface.implicit = t.implicit\n+\t\t\tiface.complete = t.complete\n \t\t\t// If we've changed the interface type, we may need to replace its\n \t\t\t// receiver if the receiver type is the original interface. Receivers of\n \t\t\t// *Named type are replaced during named type expansion."}, {"sha": "94e49caee04a26ce0fd6b55ebce083fb42f62ecc", "filename": "libgo/go/go/types/termlist.go", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftermlist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftermlist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftermlist.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -92,15 +92,6 @@ func (xl termlist) norm() termlist {\n \treturn rl\n }\n \n-// If the type set represented by xl is specified by a single (non-\ud835\udce4) term,\n-// singleType returns that type. Otherwise it returns nil.\n-func (xl termlist) singleType() Type {\n-\tif nl := xl.norm(); len(nl) == 1 {\n-\t\treturn nl[0].typ // if nl.isAll() then typ is nil, which is ok\n-\t}\n-\treturn nil\n-}\n-\n // union returns the union xl \u222a yl.\n func (xl termlist) union(yl termlist) termlist {\n \treturn append(xl, yl...).norm()"}, {"sha": "f0d58ac1bcf9961cdfe24f2f3847ffaeee2187f0", "filename": "libgo/go/go/types/termlist_test.go", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftermlist_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftermlist_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftermlist_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -106,35 +106,6 @@ func TestTermlistNorm(t *testing.T) {\n \t}\n }\n \n-func TestTermlistSingleType(t *testing.T) {\n-\t// helper to deal with nil types\n-\ttstring := func(typ Type) string {\n-\t\tif typ == nil {\n-\t\t\treturn \"nil\"\n-\t\t}\n-\t\treturn typ.String()\n-\t}\n-\n-\tfor test, want := range map[string]string{\n-\t\t\"\u2205\":                 \"nil\",\n-\t\t\"\ud835\udce4\":                 \"nil\",\n-\t\t\"int\":               \"int\",\n-\t\t\"myInt\":             \"myInt\",\n-\t\t\"~int\":              \"int\",\n-\t\t\"~int \u222a string\":     \"nil\",\n-\t\t\"~int \u222a myInt\":      \"int\",\n-\t\t\"\u2205 \u222a int\":           \"int\",\n-\t\t\"\u2205 \u222a ~int\":          \"int\",\n-\t\t\"\u2205 \u222a ~int \u222a string\": \"nil\",\n-\t} {\n-\t\txl := maketl(test)\n-\t\tgot := tstring(xl.singleType())\n-\t\tif got != want {\n-\t\t\tt.Errorf(\"(%v).singleType() == %v; want %v\", test, got, want)\n-\t\t}\n-\t}\n-}\n-\n func TestTermlistUnion(t *testing.T) {\n \tfor _, test := range []struct {\n \t\txl, yl, want string"}, {"sha": "e59a544660d15cec583cddc556f56bf8f2156712", "filename": "libgo/go/go/types/testdata/examples/inference.go2", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Finference.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Finference.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Finference.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -78,7 +78,7 @@ func _() {\n \trelated1(si, \"foo\" /* ERROR cannot use \"foo\" */ )\n }\n \n-func related2[Elem any, Slice interface{~[]Elem}](e Elem, s Slice) {}\n+func related2[Elem any, Slice interface{[]Elem}](e Elem, s Slice) {}\n \n func _() {\n \t// related2 can be called with explicit instantiation.\n@@ -109,16 +109,8 @@ func _() {\n \trelated3[int, []int]()\n \trelated3[byte, List[byte]]()\n \n-\t// Alternatively, the 2nd type argument can be inferred\n-\t// from the first one through constraint type inference.\n-\trelated3[int]()\n-\n-\t// The inferred type is the core type of the Slice\n-\t// type parameter.\n-\tvar _ []int = related3[int]()\n-\n-\t// It is not the defined parameterized type List.\n-\ttype anotherList []float32\n-\tvar _ anotherList = related3[float32]() // valid\n-\tvar _ anotherList = related3 /* ERROR cannot use .* \\(value of type List\\[float32\\]\\) as anotherList */ [float32, List[float32]]()\n+\t// The 2nd type argument cannot be inferred from the first\n+\t// one because there's two possible choices: []Elem and\n+\t// List[Elem].\n+\trelated3 /* ERROR cannot infer Slice */ [int]()\n }"}, {"sha": "a46f789d602ce584f5ccd0b1b072d3b00321c8c1", "filename": "libgo/go/go/types/testdata/examples/methods.go2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Fmethods.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Fmethods.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Fexamples%2Fmethods.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -35,7 +35,7 @@ func (t T1[[ /* ERROR must be an identifier */ ]int]) m2() {}\n // style. In m3 below, int is the name of the local receiver type parameter\n // and it shadows the predeclared identifier int which then cannot be used\n // anymore as expected.\n-// This is no different from locally redelaring a predeclared identifier\n+// This is no different from locally re-declaring a predeclared identifier\n // and usually should be avoided. There are some notable exceptions; e.g.,\n // sometimes it makes sense to use the identifier \"copy\" which happens to\n // also be the name of a predeclared built-in function."}, {"sha": "4550dd732c149cc87d84b6cdb59c1343d6f90582", "filename": "libgo/go/go/types/testdata/fixedbugs/issue41124.go2", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue41124.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue41124.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue41124.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -47,7 +47,7 @@ type _ struct{\n }\n \n type _ struct{\n-\tI3 // ERROR interface is .* comparable\n+\tI3 // ERROR interface contains type constraints\n }\n \n // General composite types.\n@@ -59,19 +59,19 @@ type (\n \t_ []I1 // ERROR interface is .* comparable\n \t_ []I2 // ERROR interface contains type constraints\n \n-\t_ *I3 // ERROR interface is .* comparable\n+\t_ *I3 // ERROR interface contains type constraints\n \t_ map[I1 /* ERROR interface is .* comparable */ ]I2 // ERROR interface contains type constraints\n-\t_ chan I3 // ERROR interface is .* comparable\n+\t_ chan I3 // ERROR interface contains type constraints\n \t_ func(I1 /* ERROR interface is .* comparable */ )\n \t_ func() I2 // ERROR interface contains type constraints\n )\n \n // Other cases.\n \n-var _ = [...]I3 /* ERROR interface is .* comparable */ {}\n+var _ = [...]I3 /* ERROR interface contains type constraints */ {}\n \n func _(x interface{}) {\n-\t_ = x.(I3 /* ERROR interface is .* comparable */ )\n+\t_ = x.(I3 /* ERROR interface contains type constraints */ )\n }\n \n type T1[_ any] struct{}"}, {"sha": "01c9672745a600b10d78c9e110437a06460a7d16", "filename": "libgo/go/go/types/testdata/fixedbugs/issue45548.go2", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue45548.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue45548.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue45548.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -4,7 +4,7 @@\n \n package p\n \n-func f[F interface{~*Q}, G interface{~*R}, Q, R any](q Q, r R) {}\n+func f[F interface{*Q}, G interface{*R}, Q, R any](q Q, r R) {}\n \n func _() {\n \tf[*float64, *int](1, 2)"}, {"sha": "808b6471f6eb5f69ca314c0e3cc78fe8974830fe", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51229.go2", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51229.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51229.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51229.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,164 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+// Constraint type inference should be independent of the\n+// ordering of the type parameter declarations. Try all\n+// permutations in the test case below.\n+// Permutations produced by https://go.dev/play/p/PHcZNGJTEBZ.\n+\n+func f00[S1 ~[]E1, S2 ~[]E2, E1 ~byte, E2 ~byte](S1, S2) {}\n+func f01[S2 ~[]E2, S1 ~[]E1, E1 ~byte, E2 ~byte](S1, S2) {}\n+func f02[E1 ~byte, S1 ~[]E1, S2 ~[]E2, E2 ~byte](S1, S2) {}\n+func f03[S1 ~[]E1, E1 ~byte, S2 ~[]E2, E2 ~byte](S1, S2) {}\n+func f04[S2 ~[]E2, E1 ~byte, S1 ~[]E1, E2 ~byte](S1, S2) {}\n+func f05[E1 ~byte, S2 ~[]E2, S1 ~[]E1, E2 ~byte](S1, S2) {}\n+func f06[E2 ~byte, S2 ~[]E2, S1 ~[]E1, E1 ~byte](S1, S2) {}\n+func f07[S2 ~[]E2, E2 ~byte, S1 ~[]E1, E1 ~byte](S1, S2) {}\n+func f08[S1 ~[]E1, E2 ~byte, S2 ~[]E2, E1 ~byte](S1, S2) {}\n+func f09[E2 ~byte, S1 ~[]E1, S2 ~[]E2, E1 ~byte](S1, S2) {}\n+func f10[S2 ~[]E2, S1 ~[]E1, E2 ~byte, E1 ~byte](S1, S2) {}\n+func f11[S1 ~[]E1, S2 ~[]E2, E2 ~byte, E1 ~byte](S1, S2) {}\n+func f12[S1 ~[]E1, E1 ~byte, E2 ~byte, S2 ~[]E2](S1, S2) {}\n+func f13[E1 ~byte, S1 ~[]E1, E2 ~byte, S2 ~[]E2](S1, S2) {}\n+func f14[E2 ~byte, S1 ~[]E1, E1 ~byte, S2 ~[]E2](S1, S2) {}\n+func f15[S1 ~[]E1, E2 ~byte, E1 ~byte, S2 ~[]E2](S1, S2) {}\n+func f16[E1 ~byte, E2 ~byte, S1 ~[]E1, S2 ~[]E2](S1, S2) {}\n+func f17[E2 ~byte, E1 ~byte, S1 ~[]E1, S2 ~[]E2](S1, S2) {}\n+func f18[E2 ~byte, E1 ~byte, S2 ~[]E2, S1 ~[]E1](S1, S2) {}\n+func f19[E1 ~byte, E2 ~byte, S2 ~[]E2, S1 ~[]E1](S1, S2) {}\n+func f20[S2 ~[]E2, E2 ~byte, E1 ~byte, S1 ~[]E1](S1, S2) {}\n+func f21[E2 ~byte, S2 ~[]E2, E1 ~byte, S1 ~[]E1](S1, S2) {}\n+func f22[E1 ~byte, S2 ~[]E2, E2 ~byte, S1 ~[]E1](S1, S2) {}\n+func f23[S2 ~[]E2, E1 ~byte, E2 ~byte, S1 ~[]E1](S1, S2) {}\n+\n+type myByte byte\n+\n+func _(a []byte, b []myByte) {\n+\tf00(a, b)\n+\tf01(a, b)\n+\tf02(a, b)\n+\tf03(a, b)\n+\tf04(a, b)\n+\tf05(a, b)\n+\tf06(a, b)\n+\tf07(a, b)\n+\tf08(a, b)\n+\tf09(a, b)\n+\tf10(a, b)\n+\tf11(a, b)\n+\tf12(a, b)\n+\tf13(a, b)\n+\tf14(a, b)\n+\tf15(a, b)\n+\tf16(a, b)\n+\tf17(a, b)\n+\tf18(a, b)\n+\tf19(a, b)\n+\tf20(a, b)\n+\tf21(a, b)\n+\tf22(a, b)\n+\tf23(a, b)\n+}\n+\n+// Constraint type inference may have to iterate.\n+// Again, the order of the type parameters shouldn't matter.\n+\n+func g0[S ~[]E, M ~map[string]S, E any](m M) {}\n+func g1[M ~map[string]S, S ~[]E, E any](m M) {}\n+func g2[E any, S ~[]E, M ~map[string]S](m M) {}\n+func g3[S ~[]E, E any, M ~map[string]S](m M) {}\n+func g4[M ~map[string]S, E any, S ~[]E](m M) {}\n+func g5[E any, M ~map[string]S, S ~[]E](m M) {}\n+\n+func _(m map[string][]byte) {\n+\tg0(m)\n+\tg1(m)\n+\tg2(m)\n+\tg3(m)\n+\tg4(m)\n+\tg5(m)\n+}\n+\n+// Worst-case scenario.\n+// There are 10 unknown type parameters. In each iteration of\n+// constraint type inference we infer one more, from right to left.\n+// Each iteration looks repeatedly at all 11 type parameters,\n+// requiring a total of 10*11 = 110 iterations with the current\n+// implementation. Pathological case.\n+\n+func h[K any, J ~*K, I ~*J, H ~*I, G ~*H, F ~*G, E ~*F, D ~*E, C ~*D, B ~*C, A ~*B](x A) {}\n+\n+func _(x **********int) {\n+\th(x)\n+}\n+\n+// Examples with channel constraints and tilde.\n+\n+func ch1[P chan<- int]() (_ P)           { return } // core(P) == chan<- int   (single type, no tilde)\n+func ch2[P ~chan int]()                  { return } // core(P) == ~chan<- int  (tilde)\n+func ch3[P chan E, E any](E)             { return } // core(P) == chan<- E     (single type, no tilde)\n+func ch4[P chan E | ~chan<- E, E any](E) { return } // core(P) == ~chan<- E    (tilde)\n+func ch5[P chan int | chan<- int]()      { return } // core(P) == chan<- int   (not a single type)\n+\n+func _() {\n+\t// P can be inferred as there's a single specific type and no tilde.\n+\tvar _ chan int = ch1 /* ERROR cannot use ch1.*value of type chan<- int */ ()\n+\tvar _ chan<- int = ch1()\n+\n+\t// P cannot be inferred as there's a tilde.\n+\tch2 /* ERROR cannot infer P */ ()\n+\ttype myChan chan int\n+\tch2[myChan]()\n+\n+\t// P can be inferred as there's a single specific type and no tilde.\n+\tvar e int\n+\tch3(e)\n+\n+\t// P cannot be inferred as there's more than one specific type and a tilde.\n+\tch4 /* ERROR cannot infer P */ (e)\n+\t_ = ch4[chan int]\n+\n+\t// P cannot be inferred as there's more than one specific type.\n+\tch5 /* ERROR cannot infer P */ ()\n+\tch5[chan<- int]()\n+}\n+\n+// test case from issue\n+\n+func equal[M1 ~map[K1]V1, M2 ~map[K2]V2, K1, K2 ~uint32, V1, V2 ~string](m1 M1, m2 M2) bool {\n+\tif len(m1) != len(m2) {\n+\t\treturn false\n+\t}\n+\tfor k, v1 := range m1 {\n+\t\tif v2, ok := m2[K2(k)]; !ok || V2(v1) != v2 {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func equalFixed[K1, K2 ~uint32, V1, V2 ~string](m1 map[K1]V1, m2 map[K2]V2) bool {\n+\tif len(m1) != len(m2) {\n+\t\treturn false\n+\t}\n+\tfor k, v1 := range m1 {\n+\t\tif v2, ok := m2[K2(k)]; !ok || v1 != V1(v2) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+type (\n+\tsomeNumericID uint32\n+\tsomeStringID  string\n+)\n+\n+func _() {\n+\tfoo := map[uint32]string{10: \"bar\"}\n+\tbar := map[someNumericID]someStringID{10: \"bar\"}\n+\tequal(foo, bar)\n+}"}, {"sha": "3fa6a05732ac834481b12ce1bfb1f926d5213bc7", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51232.go2", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51232.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51232.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51232.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type RC[RG any] interface {\n+\t~[]RG\n+}\n+\n+type Fn[RCT RC[RG], RG any] func(RCT)\n+\n+type F[RCT RC[RG], RG any] interface {\n+\tFn() Fn /* ERROR got 1 arguments */ [RCT]\n+}\n+\n+type concreteF[RCT RC[RG], RG any] struct {\n+\tmakeFn func() Fn /* ERROR got 1 arguments */ [RCT]\n+}\n+\n+func (c *concreteF[RCT, RG]) Fn() Fn /* ERROR got 1 arguments */ [RCT] {\n+\treturn c.makeFn()\n+}\n+\n+func NewConcrete[RCT RC[RG], RG any](Rc RCT) F /* ERROR got 1 arguments */ [RCT] {\n+\t// TODO(rfindley): eliminate the duplicate error below.\n+\treturn & /* ERROR cannot use .* as F\\[RCT\\] */ concreteF /* ERROR got 1 arguments */ [RCT]{\n+\t\tmakeFn: nil,\n+\t}\n+}"}, {"sha": "9c15028c91d23efaf42aed0b0f2e47aa78728ff8", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51233.go2", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51233.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51233.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51233.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+// As of issue #51527, type-type inference has been disabled.\n+\n+type RC[RG any] interface {\n+\t~[]RG\n+}\n+\n+type Fn[RCT RC[RG], RG any] func(RCT)\n+\n+type FFn[RCT RC[RG], RG any] func() Fn /* ERROR got 1 arguments */ [RCT]\n+\n+type F[RCT RC[RG], RG any] interface {\n+\tFn() Fn /* ERROR got 1 arguments */ [RCT]\n+}\n+\n+type concreteF[RCT RC[RG], RG any] struct {\n+\tmakeFn FFn /* ERROR got 1 arguments */ [RCT]\n+}\n+\n+func (c *concreteF[RCT, RG]) Fn() Fn /* ERROR got 1 arguments */ [RCT] {\n+\treturn c.makeFn()\n+}"}, {"sha": "8a3eb3278de9b462534e9b82876bc3951b353c0f", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51257.go2", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51257.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51257.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51257.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+func f[_ comparable]() {}\n+\n+type S1 struct{ x int }\n+type S2 struct{ x any }\n+type S3 struct{ x [10]interface{ m() } }\n+\n+func _[P1 comparable, P2 S2]() {\n+\t_ = f[S1]\n+\t_ = f[S2 /* ERROR S2 does not implement comparable */ ]\n+\t_ = f[S3 /* ERROR S3 does not implement comparable */ ]\n+\n+\ttype L1 struct { x P1 }\n+\ttype L2 struct { x P2 }\n+\t_ = f[L1]\n+\t_ = f[L2 /* ERROR L2 does not implement comparable */ ]\n+}\n+\n+\n+// example from issue\n+\n+type Set[T comparable] map[T]struct{}\n+\n+func NewSetFromSlice[T comparable](items []T) *Set[T] {\n+\ts := Set[T]{}\n+\n+\tfor _, item := range items {\n+\t\ts[item] = struct{}{}\n+\t}\n+\n+\treturn &s\n+}\n+\n+type T struct{ x any }\n+\n+func main() {\n+\tNewSetFromSlice /* ERROR T does not implement comparable */ ([]T{\n+\t\t{\"foo\"},\n+\t\t{5},\n+\t})\n+}"}, {"sha": "0b5a1af0825d557428b34136a677e3f0a698c605", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51335.go2", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51335.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51335.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51335.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type S1 struct{}\n+type S2 struct{}\n+\n+func _[P *S1|*S2]() {\n+\t_= []P{{ /* ERROR invalid composite literal element type P: no core type */ }}\n+}\n+\n+func _[P *S1|S1]() {\n+\t_= []P{{ /* ERROR invalid composite literal element type P: no core type */ }}\n+}"}, {"sha": "38f86109e364001f96cd693da4907a482db78ace", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51339.go2", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51339.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51339.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51339.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file is tested when running \"go test -run Manual\"\n+// without source arguments. Use for one-off debugging.\n+\n+package p\n+\n+type T[P any, B *P] struct{}\n+\n+func (T /* ERROR cannot use generic type */ ) m0() {}\n+\n+// TODO(rfindley): eliminate the duplicate errors here.\n+func (/* ERROR got 1 type parameter, but receiver base type declares 2 */ T /* ERROR got 1 arguments but 2 type parameters */ [_]) m1() {}\n+func (T[_, _]) m2() {}\n+// TODO(gri) this error is unfortunate (issue #51343)\n+func (T /* ERROR got 3 arguments but 2 type parameters */ [_, _, _]) m3() {}"}, {"sha": "fe3de04dbfd346adb60957b151b32951a784687d", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51360.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51360.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51360.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51360.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+func _() {\n+\tlen.Println /* ERROR cannot select on len */\n+\tlen.Println /* ERROR cannot select on len */ ()\n+\t_ = len.Println /* ERROR cannot select on len */\n+\t_ = len /* ERROR cannot index len */ [0]\n+\t_ = *len /* ERROR cannot indirect len */\n+}"}, {"sha": "d51607b7abb5fc2f67045e5618a42020bc250293", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51376.go2", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51376.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51376.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51376.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type Map map[string]int\n+\n+func f[M ~map[K]V, K comparable, V any](M) {}\n+func g[M map[K]V, K comparable, V any](M) {}\n+\n+func _[M1 ~map[K]V, M2 map[K]V, K comparable, V any]() {\n+        var m1 M1\n+        f(m1)\n+        g /* ERROR M1 does not implement map\\[K\\]V */ (m1) // M1 has tilde\n+\n+        var m2 M2\n+        f(m2)\n+        g(m2) // M1 does not have tilde\n+\n+        var m3 Map\n+        f(m3)\n+        g /* ERROR Map does not implement map\\[string\\]int */ (m3) // M in g does not have tilde\n+}"}, {"sha": "ef6223927a21f41c6ba52cfc649574cec11e4500", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51386.go2", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51386.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51386.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51386.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type myString string\n+\n+func _[P ~string | ~[]byte | ~[]rune]() {\n+\t_ = P(\"\")\n+\tconst s myString = \"\"\n+\t_ = P(s)\n+}\n+\n+func _[P myString]() {\n+\t_ = P(\"\")\n+}"}, {"sha": "376261516eec92a8fb40d1f7d0ffbc552df55ef8", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51437.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51437.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51437.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51437.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type T struct{}\n+\n+func (T) m() []int { return nil }\n+\n+func f(x T) {\n+\tfor _, x := range func() []int {\n+\t\treturn x.m() // x declared in parameter list of f\n+\t}() {\n+\t\t_ = x // x declared by range clause\n+\t}\n+}"}, {"sha": "3126770829081668277268c27a974f306af1e59f", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51472.go2", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51472.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51472.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51472.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+func _[T comparable](x T) {\n+        _ = x == x\n+}\n+\n+func _[T interface{interface{comparable}}](x T) {\n+        _ = x == x\n+}\n+\n+func _[T interface{comparable; interface{comparable}}](x T) {\n+        _ = x == x\n+}\n+\n+func _[T interface{comparable; ~int}](x T) {\n+        _ = x == x\n+}\n+\n+func _[T interface{comparable; ~[]byte}](x T) {\n+        _ = x /* ERROR cannot compare */ == x\n+}\n+\n+// TODO(gri) The error message here should be better. See issue #51525.\n+func _[T interface{comparable; ~int; ~string}](x T) {\n+        _ = x /* ERROR cannot compare */ == x\n+}\n+\n+// TODO(gri) The error message here should be better. See issue #51525.\n+func _[T interface{~int; ~string}](x T) {\n+        _ = x /* ERROR cannot compare */ == x\n+}\n+\n+func _[T interface{comparable; interface{~int}; interface{int|float64}}](x T) {\n+        _ = x == x\n+}\n+\n+func _[T interface{interface{comparable; ~int}; interface{~float64; comparable; m()}}](x T) {\n+        _ = x /* ERROR cannot compare */ == x\n+}\n+\n+// test case from issue\n+\n+func f[T interface{comparable; []byte|string}](x T) {\n+        _ = x == x\n+}\n+\n+func _(s []byte) {\n+\tf /* ERROR \\[\\]byte does not implement interface{comparable; \\[\\]byte\\|string} */ (s)\n+        _ = f[[ /* ERROR does not implement */ ]byte]\n+}"}, {"sha": "5ae47176d07e2f91cc1ba49a16242e2709f3bbe7", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51509.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51509.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+type T /* ERROR illegal cycle */ T.x"}, {"sha": "5c204bae2097f4de1b468b411b485631739caa62", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51578.go2", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51578.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51578.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51578.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+var _ = (*interface /* ERROR interface contains type constraints */ {int})(nil)\n+\n+// abbreviated test case from issue\n+\n+type TypeSet interface{ int | string }\n+\n+func _() {\n+\tf((*TypeSet /* ERROR interface contains type constraints */)(nil))\n+}\n+\n+func f(any) {}\n\\ No newline at end of file"}, {"sha": "e06c39fac0829deffb10af25d490e2d26c3f2143", "filename": "libgo/go/go/types/testdata/fixedbugs/issue51593.go2", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51593.go2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51593.go2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftestdata%2Ffixedbugs%2Fissue51593.go2?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2022 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package p\n+\n+func f[P interface{ m(R) }, R any]() {}\n+\n+type T = interface { m(int) }\n+\n+func _() {\n+\t_ = f /* ERROR cannot infer R */ [T] // don't crash in type inference\n+}"}, {"sha": "130637530bb603a83b056b8ee47846b65151932e", "filename": "libgo/go/go/types/type.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftype.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -7,9 +7,7 @@ package types\n // A Type represents a type of Go.\n // All types implement the Type interface.\n type Type interface {\n-\t// Underlying returns the underlying type of a type\n-\t// w/o following forwarding chains. Only used by\n-\t// client packages.\n+\t// Underlying returns the underlying type of a type.\n \tUnderlying() Type\n \n \t// String returns a string representation of a type."}, {"sha": "40d96ac9470ab7c6f3d47f97f1ecd9f641a16318", "filename": "libgo/go/go/types/typeparam.go", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeparam.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeparam.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeparam.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -30,11 +30,13 @@ type TypeParam struct {\n // or Signature type by calling SetTypeParams. Setting a type parameter on more\n // than one type will result in a panic.\n //\n-// The constraint argument can be nil, and set later via SetConstraint.\n+// The constraint argument can be nil, and set later via SetConstraint. If the\n+// constraint is non-nil, it must be fully defined.\n func NewTypeParam(obj *TypeName, constraint Type) *TypeParam {\n \treturn (*Checker)(nil).newTypeParam(obj, constraint)\n }\n \n+// check may be nil\n func (check *Checker) newTypeParam(obj *TypeName, constraint Type) *TypeParam {\n \t// Always increment lastID, even if it is not used.\n \tid := nextID()\n@@ -49,9 +51,7 @@ func (check *Checker) newTypeParam(obj *TypeName, constraint Type) *TypeParam {\n \t// iface may mutate typ.bound, so we must ensure that iface() is called\n \t// at least once before the resulting TypeParam escapes.\n \tif check != nil {\n-\t\tcheck.later(func() {\n-\t\t\ttyp.iface()\n-\t\t})\n+\t\tcheck.needsCleanup(typ)\n \t} else if constraint != nil {\n \t\ttyp.iface()\n \t}\n@@ -74,8 +74,10 @@ func (t *TypeParam) Constraint() Type {\n \n // SetConstraint sets the type constraint for t.\n //\n-// SetConstraint should not be called concurrently, but once SetConstraint\n-// returns the receiver t is safe for concurrent use.\n+// It must be called by users of NewTypeParam after the bound's underlying is\n+// fully defined, and before using the type parameter in any way other than to\n+// form other types. Once SetConstraint returns the receiver, t is safe for\n+// concurrent use.\n func (t *TypeParam) SetConstraint(bound Type) {\n \tif bound == nil {\n \t\tpanic(\"nil constraint\")\n@@ -95,9 +97,12 @@ func (t *TypeParam) String() string { return TypeString(t, nil) }\n // ----------------------------------------------------------------------------\n // Implementation\n \n+func (t *TypeParam) cleanup() {\n+\tt.iface()\n+\tt.check = nil\n+}\n+\n // iface returns the constraint interface of t.\n-// TODO(gri) If we make tparamIsIface the default, this should be renamed to under\n-//           (similar to Named.under).\n func (t *TypeParam) iface() *Interface {\n \tbound := t.bound\n \n@@ -138,16 +143,6 @@ func (t *TypeParam) iface() *Interface {\n \treturn ityp\n }\n \n-// singleType returns the single type of the type parameter constraint; or nil.\n-func (t *TypeParam) singleType() Type {\n-\treturn t.iface().typeSet().singleType()\n-}\n-\n-// hasTerms reports whether the type parameter constraint has specific type terms.\n-func (t *TypeParam) hasTerms() bool {\n-\treturn t.iface().typeSet().hasTerms()\n-}\n-\n // is calls f with the specific type terms of t's constraint and reports whether\n // all calls to f returned true. If there are no specific terms, is\n // returns the result of f(nil)."}, {"sha": "6603383ea3cb7dbde14fc4d0545a23c85768f267", "filename": "libgo/go/go/types/typeset.go", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -15,18 +15,25 @@ import (\n // API\n \n // A _TypeSet represents the type set of an interface.\n+// Because of existing language restrictions, methods can be \"factored out\"\n+// from the terms. The actual type set is the intersection of the type set\n+// implied by the methods and the type set described by the terms and the\n+// comparable bit. To test whether a type is included in a type set\n+// (\"implements\" relation), the type must implement all methods _and_ be\n+// an element of the type set described by the terms and the comparable bit.\n+// If the term list describes the set of all types and comparable is true,\n+// only comparable types are meant; in all other cases comparable is false.\n type _TypeSet struct {\n-\tcomparable bool // if set, the interface is or embeds comparable\n-\t// TODO(gri) consider using a set for the methods for faster lookup\n-\tmethods []*Func  // all methods of the interface; sorted by unique ID\n-\tterms   termlist // type terms of the type set\n+\tmethods    []*Func  // all methods of the interface; sorted by unique ID\n+\tterms      termlist // type terms of the type set\n+\tcomparable bool     // invariant: !comparable || terms.isAll()\n }\n \n // IsEmpty reports whether type set s is the empty set.\n func (s *_TypeSet) IsEmpty() bool { return s.terms.isEmpty() }\n \n // IsAll reports whether type set s is the set of all types (corresponding to the empty interface).\n-func (s *_TypeSet) IsAll() bool { return !s.comparable && len(s.methods) == 0 && s.terms.isAll() }\n+func (s *_TypeSet) IsAll() bool { return s.IsMethodSet() && len(s.methods) == 0 }\n \n // IsMethodSet reports whether the interface t is fully described by its method set.\n func (s *_TypeSet) IsMethodSet() bool { return !s.comparable && s.terms.isAll() }\n@@ -37,17 +44,10 @@ func (s *_TypeSet) IsComparable(seen map[Type]bool) bool {\n \t\treturn s.comparable\n \t}\n \treturn s.is(func(t *term) bool {\n-\t\treturn t != nil && comparable(t.typ, seen, nil)\n+\t\treturn t != nil && comparable(t.typ, false, seen, nil)\n \t})\n }\n \n-// TODO(gri) IsTypeSet is not a great name for this predicate. Find a better one.\n-\n-// IsTypeSet reports whether the type set s is represented by a finite set of underlying types.\n-func (s *_TypeSet) IsTypeSet() bool {\n-\treturn !s.comparable && len(s.methods) == 0\n-}\n-\n // NumMethods returns the number of methods available.\n func (s *_TypeSet) NumMethods() int { return len(s.methods) }\n \n@@ -101,9 +101,6 @@ func (s *_TypeSet) String() string {\n // hasTerms reports whether the type set has specific type terms.\n func (s *_TypeSet) hasTerms() bool { return !s.terms.isEmpty() && !s.terms.isAll() }\n \n-// singleType returns the single type in s if there is exactly one; otherwise the result is nil.\n-func (s *_TypeSet) singleType() Type { return s.terms.singleType() }\n-\n // subsetOf reports whether s1 \u2286 s2.\n func (s1 *_TypeSet) subsetOf(s2 *_TypeSet) bool { return s1.terms.subsetOf(s2.terms) }\n \n@@ -220,12 +217,12 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \n \tvar todo []*Func\n \tvar seen objset\n-\tvar methods []*Func\n+\tvar allMethods []*Func\n \tmpos := make(map[*Func]token.Pos) // method specification or method embedding position, for good error messages\n \taddMethod := func(pos token.Pos, m *Func, explicit bool) {\n \t\tswitch other := seen.insert(m); {\n \t\tcase other == nil:\n-\t\t\tmethods = append(methods, m)\n+\t\t\tallMethods = append(allMethods, m)\n \t\t\tmpos[m] = pos\n \t\tcase explicit:\n \t\t\tif check == nil {\n@@ -260,7 +257,8 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \t}\n \n \t// collect embedded elements\n-\tvar allTerms = allTermlist\n+\tallTerms := allTermlist\n+\tallComparable := false\n \tfor i, typ := range ityp.embeddeds {\n \t\t// The embedding position is nil for imported interfaces\n \t\t// and also for interface copies after substitution (but\n@@ -269,6 +267,7 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \t\tif ityp.embedPos != nil {\n \t\t\tpos = (*ityp.embedPos)[i]\n \t\t}\n+\t\tvar comparable bool\n \t\tvar terms termlist\n \t\tswitch u := under(typ).(type) {\n \t\tcase *Interface:\n@@ -280,9 +279,7 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \t\t\t\tcheck.errorf(atPos(pos), _UnsupportedFeature, \"embedding constraint interface %s requires go1.18 or later\", typ)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif tset.comparable {\n-\t\t\t\tityp.tset.comparable = true\n-\t\t\t}\n+\t\t\tcomparable = tset.comparable\n \t\t\tfor _, m := range tset.methods {\n \t\t\t\taddMethod(pos, m, false) // use embedding position pos rather than m.pos\n \t\t\t}\n@@ -296,6 +293,8 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \t\t\tif tset == &invalidTypeSet {\n \t\t\t\tcontinue // ignore invalid unions\n \t\t\t}\n+\t\t\tassert(!tset.comparable)\n+\t\t\tassert(len(tset.methods) == 0)\n \t\t\tterms = tset.terms\n \t\tdefault:\n \t\t\tif u == Typ[Invalid] {\n@@ -307,11 +306,11 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \t\t\t}\n \t\t\tterms = termlist{{false, typ}}\n \t\t}\n-\t\t// The type set of an interface is the intersection\n-\t\t// of the type sets of all its elements.\n-\t\t// Intersection cannot produce longer termlists and\n-\t\t// thus cannot overflow.\n-\t\tallTerms = allTerms.intersect(terms)\n+\n+\t\t// The type set of an interface is the intersection of the type sets of all its elements.\n+\t\t// Due to language restrictions, only embedded interfaces can add methods, they are handled\n+\t\t// separately. Here we only need to intersect the term lists and comparable bits.\n+\t\tallTerms, allComparable = intersectTermLists(allTerms, allComparable, terms, comparable)\n \t}\n \tityp.embedPos = nil // not needed anymore (errors have been reported)\n \n@@ -324,15 +323,46 @@ func computeInterfaceTypeSet(check *Checker, pos token.Pos, ityp *Interface) *_T\n \t\t}\n \t}\n \n-\tif methods != nil {\n-\t\tsort.Sort(byUniqueMethodName(methods))\n-\t\tityp.tset.methods = methods\n+\tityp.tset.comparable = allComparable\n+\tif len(allMethods) != 0 {\n+\t\tsortMethods(allMethods)\n+\t\tityp.tset.methods = allMethods\n \t}\n \tityp.tset.terms = allTerms\n \n \treturn ityp.tset\n }\n \n+// TODO(gri) The intersectTermLists function belongs to the termlist implementation.\n+//           The comparable type set may also be best represented as a term (using\n+//           a special type).\n+\n+// intersectTermLists computes the intersection of two term lists and respective comparable bits.\n+// xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.\n+func intersectTermLists(xterms termlist, xcomp bool, yterms termlist, ycomp bool) (termlist, bool) {\n+\tterms := xterms.intersect(yterms)\n+\t// If one of xterms or yterms is marked as comparable,\n+\t// the result must only include comparable types.\n+\tcomp := xcomp || ycomp\n+\tif comp && !terms.isAll() {\n+\t\t// only keep comparable terms\n+\t\ti := 0\n+\t\tfor _, t := range terms {\n+\t\t\tassert(t.typ != nil)\n+\t\t\tif Comparable(t.typ) {\n+\t\t\t\tterms[i] = t\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t}\n+\t\tterms = terms[:i]\n+\t\tif !terms.isAll() {\n+\t\t\tcomp = false\n+\t\t}\n+\t}\n+\tassert(!comp || terms.isAll()) // comparable invariant\n+\treturn terms, comp\n+}\n+\n func sortMethods(list []*Func) {\n \tsort.Sort(byUniqueMethodName(list))\n }"}, {"sha": "2bbe611376091eb05eaedf4325a44f941fb0a450", "filename": "libgo/go/go/types/typeset_test.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypeset_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -26,9 +26,9 @@ func TestTypeSetString(t *testing.T) {\n \t\t\"{int; string}\": \"\u2205\",\n \n \t\t\"{comparable}\":              \"{comparable}\",\n-\t\t\"{comparable; int}\":         \"{comparable; int}\",\n-\t\t\"{~int; comparable}\":        \"{comparable; ~int}\",\n-\t\t\"{int|string; comparable}\":  \"{comparable; int \u222a string}\",\n+\t\t\"{comparable; int}\":         \"{int}\",\n+\t\t\"{~int; comparable}\":        \"{~int}\",\n+\t\t\"{int|string; comparable}\":  \"{int \u222a string}\",\n \t\t\"{comparable; int; string}\": \"\u2205\",\n \n \t\t\"{m()}\":                         \"{func (p.T).m()}\",\n@@ -38,8 +38,8 @@ func TestTypeSetString(t *testing.T) {\n \t\t\"{m1(); comparable; m2() int }\": \"{comparable; func (p.T).m1(); func (p.T).m2() int}\",\n \t\t\"{comparable; error}\":           \"{comparable; func (error).Error() string}\",\n \n-\t\t\"{m(); comparable; int|float32|string}\": \"{comparable; func (p.T).m(); int \u222a float32 \u222a string}\",\n-\t\t\"{m1(); int; m2(); comparable }\":        \"{comparable; func (p.T).m1(); func (p.T).m2(); int}\",\n+\t\t\"{m(); comparable; int|float32|string}\": \"{func (p.T).m(); int \u222a float32 \u222a string}\",\n+\t\t\"{m1(); int; m2(); comparable }\":        \"{func (p.T).m1(); func (p.T).m2(); int}\",\n \n \t\t\"{E}; type E interface{}\":           \"\ud835\udce4\",\n \t\t\"{E}; type E interface{int;string}\": \"\u2205\","}, {"sha": "5bb2d8f8112086fe08c933593ff57a232da51581", "filename": "libgo/go/go/types/typexpr.go", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Ftypexpr.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -144,10 +144,16 @@ func (check *Checker) typ(e ast.Expr) Type {\n // constraint interface.\n func (check *Checker) varType(e ast.Expr) Type {\n \ttyp := check.definedType(e, nil)\n+\tcheck.validVarType(e, typ)\n+\treturn typ\n+}\n \n+// validVarType reports an error if typ is a constraint interface.\n+// The expression e is used for error reporting, if any.\n+func (check *Checker) validVarType(e ast.Expr, typ Type) {\n \t// If we have a type parameter there's nothing to do.\n \tif isTypeParam(typ) {\n-\t\treturn typ\n+\t\treturn\n \t}\n \n \t// We don't want to call under() or complete interfaces while we are in\n@@ -165,8 +171,6 @@ func (check *Checker) varType(e ast.Expr) Type {\n \t\t\t}\n \t\t}\n \t})\n-\n-\treturn typ\n }\n \n // definedType is like typ but also accepts a type name def.\n@@ -254,7 +258,7 @@ func (check *Checker) typInternal(e0 ast.Expr, def *Named) (T Type) {\n \n \tcase *ast.SelectorExpr:\n \t\tvar x operand\n-\t\tcheck.selector(&x, e)\n+\t\tcheck.selector(&x, e, def)\n \n \t\tswitch x.mode {\n \t\tcase typexpr:\n@@ -323,7 +327,7 @@ func (check *Checker) typInternal(e0 ast.Expr, def *Named) (T Type) {\n \t\treturn typ\n \n \tcase *ast.InterfaceType:\n-\t\ttyp := new(Interface)\n+\t\ttyp := check.newInterface()\n \t\tdef.setUnderlying(typ)\n \t\tif def != nil {\n \t\t\ttyp.obj = def.obj\n@@ -415,10 +419,14 @@ func (check *Checker) instantiatedType(ix *typeparams.IndexExpr, def *Named) (re\n \t// evaluate arguments\n \ttargs := check.typeList(ix.Indices)\n \tif targs == nil {\n-\t\tdef.setUnderlying(Typ[Invalid]) // avoid later errors due to lazy instantiation\n+\t\tdef.setUnderlying(Typ[Invalid]) // avoid errors later due to lazy instantiation\n \t\treturn Typ[Invalid]\n \t}\n \n+\t// enableTypeTypeInference controls whether to infer missing type arguments\n+\t// using constraint type inference. See issue #51527.\n+\tconst enableTypeTypeInference = false\n+\n \t// create the instance\n \tctxt := check.bestContext(nil)\n \th := ctxt.instanceHash(orig, targs)\n@@ -438,19 +446,18 @@ func (check *Checker) instantiatedType(ix *typeparams.IndexExpr, def *Named) (re\n \tdef.setUnderlying(inst)\n \n \tinst.resolver = func(ctxt *Context, n *Named) (*TypeParamList, Type, *methodList) {\n-\t\ttparams := orig.TypeParams().list()\n+\t\ttparams := n.orig.TypeParams().list()\n \n-\t\tinferred := targs\n-\t\tif len(targs) < len(tparams) {\n+\t\ttargs := n.targs.list()\n+\t\tif enableTypeTypeInference && len(targs) < len(tparams) {\n \t\t\t// If inference fails, len(inferred) will be 0, and inst.underlying will\n \t\t\t// be set to Typ[Invalid] in expandNamed.\n-\t\t\tinferred = check.infer(ix.Orig, tparams, targs, nil, nil)\n+\t\t\tinferred := check.infer(ix.Orig, tparams, targs, nil, nil)\n \t\t\tif len(inferred) > len(targs) {\n-\t\t\t\tinst.targs = newTypeList(inferred)\n+\t\t\t\tn.targs = newTypeList(inferred)\n \t\t\t}\n \t\t}\n \n-\t\tcheck.recordInstance(ix.Orig, inferred, inst)\n \t\treturn expandNamed(ctxt, n, pos)\n \t}\n \n@@ -463,6 +470,7 @@ func (check *Checker) instantiatedType(ix *typeparams.IndexExpr, def *Named) (re\n \t\t// Since check is non-nil, we can still mutate inst. Unpinning the resolver\n \t\t// frees some memory.\n \t\tinst.resolver = nil\n+\t\tcheck.recordInstance(ix.Orig, inst.TypeArgs().list(), inst)\n \n \t\tif check.validateTArgLen(pos, inst.tparams.Len(), inst.targs.Len()) {\n \t\t\tif i, err := check.verify(pos, inst.tparams.list(), inst.targs.list()); err != nil {"}, {"sha": "7b9aeeee0aea0f48ed12863e27d5dbe3219b7b55", "filename": "libgo/go/go/types/unify.go", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Funify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Funify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funify.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -247,6 +247,17 @@ func (d *tparamsList) set(i int, typ Type) {\n \t}\n }\n \n+// unknowns returns the number of type parameters for which no type has been set yet.\n+func (d *tparamsList) unknowns() int {\n+\tn := 0\n+\tfor _, ti := range d.indices {\n+\t\tif ti <= 0 {\n+\t\t\tn++\n+\t\t}\n+\t}\n+\treturn n\n+}\n+\n // types returns the list of inferred types (via unification) for the type parameters\n // described by d, and an index. If all types were inferred, the returned index is < 0.\n // Otherwise, it is the index of the first type parameter which couldn't be inferred;\n@@ -349,12 +360,16 @@ func (u *unifier) nify(x, y Type, p *ifacePair) (result bool) {\n \tif enableCoreTypeUnification && !u.exact {\n \t\tif isTypeParam(x) && !hasName(y) {\n \t\t\t// When considering the type parameter for unification\n-\t\t\t// we look at the adjusted core type (adjCoreType).\n+\t\t\t// we look at the adjusted core term (adjusted core type\n+\t\t\t// with tilde information).\n \t\t\t// If the adjusted core type is a named type N; the\n \t\t\t// corresponding core type is under(N). Since !u.exact\n \t\t\t// and y doesn't have a name, unification will end up\n \t\t\t// comparing under(N) to y, so we can just use the core\n-\t\t\t// type instead. Optimization.\n+\t\t\t// type instead. And we can ignore the tilde because we\n+\t\t\t// already look at the underlying types on both sides\n+\t\t\t// and we have known types on both sides.\n+\t\t\t// Optimization.\n \t\t\tif cx := coreType(x); cx != nil {\n \t\t\t\tif traceInference {\n \t\t\t\t\tu.tracef(\"core %s \u2261 %s\", x, y)"}, {"sha": "8397d65af0113e93b9dc76bafb77169b76c5af03", "filename": "libgo/go/go/types/union.go", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Funion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Funion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funion.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -103,25 +103,27 @@ func parseUnion(check *Checker, uexpr ast.Expr) Type {\n \n \t\t\t\tif !Identical(u, t.typ) {\n \t\t\t\t\tcheck.errorf(tlist[i], _InvalidUnion, \"invalid use of ~ (underlying type of %s is %s)\", t.typ, u)\n-\t\t\t\t\tcontinue // don't report another error for t\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t// Stand-alone embedded interfaces are ok and are handled by the single-type case\n \t\t\t// in the beginning. Embedded interfaces with tilde are excluded above. If we reach\n-\t\t\t// here, we must have at least two terms in the union.\n-\t\t\tif f != nil && !f.typeSet().IsTypeSet() {\n+\t\t\t// here, we must have at least two terms in the syntactic term list (but not necessarily\n+\t\t\t// in the term list of the union's type set).\n+\t\t\tif f != nil {\n+\t\t\t\ttset := f.typeSet()\n \t\t\t\tswitch {\n-\t\t\t\tcase f.typeSet().NumMethods() != 0:\n+\t\t\t\tcase tset.NumMethods() != 0:\n \t\t\t\t\tcheck.errorf(tlist[i], _InvalidUnion, \"cannot use %s in union (%s contains methods)\", t, t)\n+\t\t\t\t\tcontinue\n \t\t\t\tcase t.typ == universeComparable.Type():\n \t\t\t\t\tcheck.error(tlist[i], _InvalidUnion, \"cannot use comparable in union\")\n-\t\t\t\tcase f.typeSet().comparable:\n+\t\t\t\t\tcontinue\n+\t\t\t\tcase tset.comparable:\n \t\t\t\t\tcheck.errorf(tlist[i], _InvalidUnion, \"cannot use %s in union (%s embeds comparable)\", t, t)\n-\t\t\t\tdefault:\n-\t\t\t\t\tpanic(\"not a type set but no methods and not comparable\")\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tcontinue // don't report another error for t\n \t\t\t}\n \n \t\t\t// Report overlapping (non-disjoint) terms such as"}, {"sha": "303ada4e57bd7df7112f1f4854a308ab56466adb", "filename": "libgo/go/go/types/universe.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Funiverse.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -112,7 +112,7 @@ func defPredeclaredTypes() {\n \t\ttyp := NewNamed(obj, nil, nil)\n \n \t\t// interface{} // marked as comparable\n-\t\tityp := &Interface{obj: obj, complete: true, tset: &_TypeSet{true, nil, allTermlist}}\n+\t\tityp := &Interface{obj: obj, complete: true, tset: &_TypeSet{nil, allTermlist, true}}\n \n \t\ttyp.SetUnderlying(ityp)\n \t\tdef(obj)"}, {"sha": "7d7029bce268c7d05db4c54940ff3f058395ecab", "filename": "libgo/go/go/types/validtype.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fvalidtype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fgo%2Ftypes%2Fvalidtype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fvalidtype.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -79,7 +79,7 @@ func (check *Checker) validType0(typ Type, env *tparamEnv, path []Object) typeIn\n \t\t\t// would have reported a type cycle and couldn't have been\n \t\t\t// imported in the first place.\n \t\t\tassert(t.obj.pkg == check.pkg)\n-\t\t\tt.underlying = Typ[Invalid] // t is in the current package (no race possibilty)\n+\t\t\tt.underlying = Typ[Invalid] // t is in the current package (no race possibility)\n \t\t\t// Find the starting point of the cycle and report it.\n \t\t\tfor i, tn := range path {\n \t\t\t\tif tn == t.obj {"}, {"sha": "88f98a16b2e299b09f99dc4c089786419949a5ae", "filename": "libgo/go/internal/fuzz/coverage.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fcoverage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fcoverage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffuzz%2Fcoverage.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -66,6 +66,17 @@ func countNewCoverageBits(base, snapshot []byte) int {\n \treturn n\n }\n \n+// isCoverageSubset returns true if all the base coverage bits are set in\n+// snapshot\n+func isCoverageSubset(base, snapshot []byte) bool {\n+\tfor i, v := range base {\n+\t\tif v&snapshot[i] != v {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // hasCoverageBit returns true if snapshot has at least one bit set that is\n // also set in base.\n func hasCoverageBit(base, snapshot []byte) bool {"}, {"sha": "c95d9e088bb2fb832d7872fbbc457c3b9d24ec33", "filename": "libgo/go/internal/fuzz/encoding.go", "status": "modified", "additions": 157, "deletions": 38, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fencoding.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fencoding.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffuzz%2Fencoding.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -10,7 +10,9 @@ import (\n \t\"go/ast\"\n \t\"go/parser\"\n \t\"go/token\"\n+\t\"math\"\n \t\"strconv\"\n+\t\"unicode/utf8\"\n )\n \n // encVersion1 will be the first line of a file with version 1 encoding.\n@@ -27,13 +29,64 @@ func marshalCorpusFile(vals ...any) []byte {\n \t// instead of changing to byte and rune respectively.\n \tfor _, val := range vals {\n \t\tswitch t := val.(type) {\n-\t\tcase int, int8, int16, int64, uint, uint16, uint32, uint64, float32, float64, bool:\n+\t\tcase int, int8, int16, int64, uint, uint16, uint32, uint64, bool:\n \t\t\tfmt.Fprintf(b, \"%T(%v)\\n\", t, t)\n+\t\tcase float32:\n+\t\t\tif math.IsNaN(float64(t)) && math.Float32bits(t) != math.Float32bits(float32(math.NaN())) {\n+\t\t\t\t// We encode unusual NaNs as hex values, because that is how users are\n+\t\t\t\t// likely to encounter them in literature about floating-point encoding.\n+\t\t\t\t// This allows us to reproduce fuzz failures that depend on the specific\n+\t\t\t\t// NaN representation (for float32 there are about 2^24 possibilities!),\n+\t\t\t\t// not just the fact that the value is *a* NaN.\n+\t\t\t\t//\n+\t\t\t\t// Note that the specific value of float32(math.NaN()) can vary based on\n+\t\t\t\t// whether the architecture represents signaling NaNs using a low bit\n+\t\t\t\t// (as is common) or a high bit (as commonly implemented on MIPS\n+\t\t\t\t// hardware before around 2012). We believe that the increase in clarity\n+\t\t\t\t// from identifying \"NaN\" with math.NaN() is worth the slight ambiguity\n+\t\t\t\t// from a platform-dependent value.\n+\t\t\t\tfmt.Fprintf(b, \"math.Float32frombits(0x%x)\\n\", math.Float32bits(t))\n+\t\t\t} else {\n+\t\t\t\t// We encode all other values \u2014 including the NaN value that is\n+\t\t\t\t// bitwise-identical to float32(math.Nan()) \u2014 using the default\n+\t\t\t\t// formatting, which is equivalent to strconv.FormatFloat with format\n+\t\t\t\t// 'g' and can be parsed by strconv.ParseFloat.\n+\t\t\t\t//\n+\t\t\t\t// For an ordinary floating-point number this format includes\n+\t\t\t\t// sufficiently many digits to reconstruct the exact value. For positive\n+\t\t\t\t// or negative infinity it is the string \"+Inf\" or \"-Inf\". For positive\n+\t\t\t\t// or negative zero it is \"0\" or \"-0\". For NaN, it is the string \"NaN\".\n+\t\t\t\tfmt.Fprintf(b, \"%T(%v)\\n\", t, t)\n+\t\t\t}\n+\t\tcase float64:\n+\t\t\tif math.IsNaN(t) && math.Float64bits(t) != math.Float64bits(math.NaN()) {\n+\t\t\t\tfmt.Fprintf(b, \"math.Float64frombits(0x%x)\\n\", math.Float64bits(t))\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(b, \"%T(%v)\\n\", t, t)\n+\t\t\t}\n \t\tcase string:\n \t\t\tfmt.Fprintf(b, \"string(%q)\\n\", t)\n \t\tcase rune: // int32\n-\t\t\tfmt.Fprintf(b, \"rune(%q)\\n\", t)\n+\t\t\t// Although rune and int32 are represented by the same type, only a subset\n+\t\t\t// of valid int32 values can be expressed as rune literals. Notably,\n+\t\t\t// negative numbers, surrogate halves, and values above unicode.MaxRune\n+\t\t\t// have no quoted representation.\n+\t\t\t//\n+\t\t\t// fmt with \"%q\" (and the corresponding functions in the strconv package)\n+\t\t\t// would quote out-of-range values to the Unicode replacement character\n+\t\t\t// instead of the original value (see https://go.dev/issue/51526), so\n+\t\t\t// they must be treated as int32 instead.\n+\t\t\t//\n+\t\t\t// We arbitrarily draw the line at UTF-8 validity, which biases toward the\n+\t\t\t// \"rune\" interpretation. (However, we accept either format as input.)\n+\t\t\tif utf8.ValidRune(t) {\n+\t\t\t\tfmt.Fprintf(b, \"rune(%q)\\n\", t)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(b, \"int32(%v)\\n\", t)\n+\t\t\t}\n \t\tcase byte: // uint8\n+\t\t\t// For bytes, we arbitrarily prefer the character interpretation.\n+\t\t\t// (Every byte has a valid character encoding.)\n \t\t\tfmt.Fprintf(b, \"byte(%q)\\n\", t)\n \t\tcase []byte: // []uint8\n \t\t\tfmt.Fprintf(b, \"[]byte(%q)\\n\", t)\n@@ -105,44 +158,78 @@ func parseCorpusValue(line []byte) (any, error) {\n \t\treturn []byte(s), nil\n \t}\n \n-\tidType, ok := call.Fun.(*ast.Ident)\n-\tif !ok {\n-\t\treturn nil, fmt.Errorf(\"expected []byte or primitive type\")\n-\t}\n-\tif idType.Name == \"bool\" {\n-\t\tid, ok := arg.(*ast.Ident)\n+\tvar idType *ast.Ident\n+\tif selector, ok := call.Fun.(*ast.SelectorExpr); ok {\n+\t\txIdent, ok := selector.X.(*ast.Ident)\n+\t\tif !ok || xIdent.Name != \"math\" {\n+\t\t\treturn nil, fmt.Errorf(\"invalid selector type\")\n+\t\t}\n+\t\tswitch selector.Sel.Name {\n+\t\tcase \"Float64frombits\":\n+\t\t\tidType = &ast.Ident{Name: \"float64-bits\"}\n+\t\tcase \"Float32frombits\":\n+\t\t\tidType = &ast.Ident{Name: \"float32-bits\"}\n+\t\tdefault:\n+\t\t\treturn nil, fmt.Errorf(\"invalid selector type\")\n+\t\t}\n+\t} else {\n+\t\tidType, ok = call.Fun.(*ast.Ident)\n \t\tif !ok {\n-\t\t\treturn nil, fmt.Errorf(\"malformed bool\")\n+\t\t\treturn nil, fmt.Errorf(\"expected []byte or primitive type\")\n \t\t}\n-\t\tif id.Name == \"true\" {\n-\t\t\treturn true, nil\n-\t\t} else if id.Name == \"false\" {\n-\t\t\treturn false, nil\n-\t\t} else {\n-\t\t\treturn nil, fmt.Errorf(\"true or false required for type bool\")\n+\t\tif idType.Name == \"bool\" {\n+\t\t\tid, ok := arg.(*ast.Ident)\n+\t\t\tif !ok {\n+\t\t\t\treturn nil, fmt.Errorf(\"malformed bool\")\n+\t\t\t}\n+\t\t\tif id.Name == \"true\" {\n+\t\t\t\treturn true, nil\n+\t\t\t} else if id.Name == \"false\" {\n+\t\t\t\treturn false, nil\n+\t\t\t} else {\n+\t\t\t\treturn nil, fmt.Errorf(\"true or false required for type bool\")\n+\t\t\t}\n \t\t}\n \t}\n+\n \tvar (\n \t\tval  string\n \t\tkind token.Token\n \t)\n \tif op, ok := arg.(*ast.UnaryExpr); ok {\n-\t\t// Special case for negative numbers.\n-\t\tlit, ok := op.X.(*ast.BasicLit)\n-\t\tif !ok || (lit.Kind != token.INT && lit.Kind != token.FLOAT) {\n+\t\tswitch lit := op.X.(type) {\n+\t\tcase *ast.BasicLit:\n+\t\t\tif op.Op != token.SUB {\n+\t\t\t\treturn nil, fmt.Errorf(\"unsupported operation on int/float: %v\", op.Op)\n+\t\t\t}\n+\t\t\t// Special case for negative numbers.\n+\t\t\tval = op.Op.String() + lit.Value // e.g. \"-\" + \"124\"\n+\t\t\tkind = lit.Kind\n+\t\tcase *ast.Ident:\n+\t\t\tif lit.Name != \"Inf\" {\n+\t\t\t\treturn nil, fmt.Errorf(\"expected operation on int or float type\")\n+\t\t\t}\n+\t\t\tif op.Op == token.SUB {\n+\t\t\t\tval = \"-Inf\"\n+\t\t\t} else {\n+\t\t\t\tval = \"+Inf\"\n+\t\t\t}\n+\t\t\tkind = token.FLOAT\n+\t\tdefault:\n \t\t\treturn nil, fmt.Errorf(\"expected operation on int or float type\")\n \t\t}\n-\t\tif op.Op != token.SUB {\n-\t\t\treturn nil, fmt.Errorf(\"unsupported operation on int: %v\", op.Op)\n-\t\t}\n-\t\tval = op.Op.String() + lit.Value // e.g. \"-\" + \"124\"\n-\t\tkind = lit.Kind\n \t} else {\n-\t\tlit, ok := arg.(*ast.BasicLit)\n-\t\tif !ok {\n+\t\tswitch lit := arg.(type) {\n+\t\tcase *ast.BasicLit:\n+\t\t\tval, kind = lit.Value, lit.Kind\n+\t\tcase *ast.Ident:\n+\t\t\tif lit.Name != \"NaN\" {\n+\t\t\t\treturn nil, fmt.Errorf(\"literal value required for primitive type\")\n+\t\t\t}\n+\t\t\tval, kind = \"NaN\", token.FLOAT\n+\t\tdefault:\n \t\t\treturn nil, fmt.Errorf(\"literal value required for primitive type\")\n \t\t}\n-\t\tval, kind = lit.Value, lit.Kind\n \t}\n \n \tswitch typ := idType.Name; typ {\n@@ -152,6 +239,14 @@ func parseCorpusValue(line []byte) (any, error) {\n \t\t}\n \t\treturn strconv.Unquote(val)\n \tcase \"byte\", \"rune\":\n+\t\tif kind == token.INT {\n+\t\t\tswitch typ {\n+\t\t\tcase \"rune\":\n+\t\t\t\treturn parseInt(val, typ)\n+\t\t\tcase \"byte\":\n+\t\t\t\treturn parseUint(val, typ)\n+\t\t\t}\n+\t\t}\n \t\tif kind != token.CHAR {\n \t\t\treturn nil, fmt.Errorf(\"character literal required for byte/rune types\")\n \t\t}\n@@ -191,6 +286,24 @@ func parseCorpusValue(line []byte) (any, error) {\n \t\t\treturn nil, fmt.Errorf(\"float or integer literal required for float64 type\")\n \t\t}\n \t\treturn strconv.ParseFloat(val, 64)\n+\tcase \"float32-bits\":\n+\t\tif kind != token.INT {\n+\t\t\treturn nil, fmt.Errorf(\"integer literal required for math.Float32frombits type\")\n+\t\t}\n+\t\tbits, err := parseUint(val, \"uint32\")\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn math.Float32frombits(bits.(uint32)), nil\n+\tcase \"float64-bits\":\n+\t\tif kind != token.FLOAT && kind != token.INT {\n+\t\t\treturn nil, fmt.Errorf(\"integer literal required for math.Float64frombits type\")\n+\t\t}\n+\t\tbits, err := parseUint(val, \"uint64\")\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\treturn math.Float64frombits(bits.(uint64)), nil\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"expected []byte or primitive type\")\n \t}\n@@ -200,18 +313,24 @@ func parseCorpusValue(line []byte) (any, error) {\n func parseInt(val, typ string) (any, error) {\n \tswitch typ {\n \tcase \"int\":\n-\t\treturn strconv.Atoi(val)\n+\t\t// The int type may be either 32 or 64 bits. If 32, the fuzz tests in the\n+\t\t// corpus may include 64-bit values produced by fuzzing runs on 64-bit\n+\t\t// architectures. When running those tests, we implicitly wrap the values to\n+\t\t// fit in a regular int. (The test case is still \u201cinteresting\u201d, even if the\n+\t\t// specific values of its inputs are platform-dependent.)\n+\t\ti, err := strconv.ParseInt(val, 0, 64)\n+\t\treturn int(i), err\n \tcase \"int8\":\n-\t\ti, err := strconv.ParseInt(val, 10, 8)\n+\t\ti, err := strconv.ParseInt(val, 0, 8)\n \t\treturn int8(i), err\n \tcase \"int16\":\n-\t\ti, err := strconv.ParseInt(val, 10, 16)\n+\t\ti, err := strconv.ParseInt(val, 0, 16)\n \t\treturn int16(i), err\n-\tcase \"int32\":\n-\t\ti, err := strconv.ParseInt(val, 10, 32)\n+\tcase \"int32\", \"rune\":\n+\t\ti, err := strconv.ParseInt(val, 0, 32)\n \t\treturn int32(i), err\n \tcase \"int64\":\n-\t\treturn strconv.ParseInt(val, 10, 64)\n+\t\treturn strconv.ParseInt(val, 0, 64)\n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}\n@@ -221,19 +340,19 @@ func parseInt(val, typ string) (any, error) {\n func parseUint(val, typ string) (any, error) {\n \tswitch typ {\n \tcase \"uint\":\n-\t\ti, err := strconv.ParseUint(val, 10, 0)\n+\t\ti, err := strconv.ParseUint(val, 0, 64)\n \t\treturn uint(i), err\n-\tcase \"uint8\":\n-\t\ti, err := strconv.ParseUint(val, 10, 8)\n+\tcase \"uint8\", \"byte\":\n+\t\ti, err := strconv.ParseUint(val, 0, 8)\n \t\treturn uint8(i), err\n \tcase \"uint16\":\n-\t\ti, err := strconv.ParseUint(val, 10, 16)\n+\t\ti, err := strconv.ParseUint(val, 0, 16)\n \t\treturn uint16(i), err\n \tcase \"uint32\":\n-\t\ti, err := strconv.ParseUint(val, 10, 32)\n+\t\ti, err := strconv.ParseUint(val, 0, 32)\n \t\treturn uint32(i), err\n \tcase \"uint64\":\n-\t\treturn strconv.ParseUint(val, 10, 64)\n+\t\treturn strconv.ParseUint(val, 0, 64)\n \tdefault:\n \t\tpanic(\"unreachable\")\n \t}"}, {"sha": "8e3800eb77f3ff205cc0ac67d6a6b6c04ccfc7ef", "filename": "libgo/go/internal/fuzz/encoding_test.go", "status": "modified", "additions": 261, "deletions": 29, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fencoding_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fencoding_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffuzz%2Fencoding_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -5,85 +5,104 @@\n package fuzz\n \n import (\n+\t\"math\"\n \t\"strconv\"\n-\t\"strings\"\n \t\"testing\"\n+\t\"unicode\"\n )\n \n func TestUnmarshalMarshal(t *testing.T) {\n \tvar tests = []struct {\n-\t\tin string\n-\t\tok bool\n+\t\tdesc   string\n+\t\tin     string\n+\t\treject bool\n+\t\twant   string // if different from in\n \t}{\n \t\t{\n-\t\t\tin: \"int(1234)\",\n-\t\t\tok: false, // missing version\n+\t\t\tdesc:   \"missing version\",\n+\t\t\tin:     \"int(1234)\",\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"malformed string\",\n \t\t\tin: `go test fuzz v1\n string(\"a\"bcad\")`,\n-\t\t\tok: false, // malformed\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"empty value\",\n \t\t\tin: `go test fuzz v1\n int()`,\n-\t\t\tok: false, // empty value\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"negative uint\",\n \t\t\tin: `go test fuzz v1\n uint(-32)`,\n-\t\t\tok: false, // invalid negative uint\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"int8 too large\",\n \t\t\tin: `go test fuzz v1\n int8(1234456)`,\n-\t\t\tok: false, // int8 too large\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"multiplication in int value\",\n \t\t\tin: `go test fuzz v1\n int(20*5)`,\n-\t\t\tok: false, // expression in int value\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"double negation\",\n \t\t\tin: `go test fuzz v1\n int(--5)`,\n-\t\t\tok: false, // expression in int value\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"malformed bool\",\n \t\t\tin: `go test fuzz v1\n bool(0)`,\n-\t\t\tok: false, // malformed bool\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"malformed byte\",\n \t\t\tin: `go test fuzz v1\n byte('aa)`,\n-\t\t\tok: false, // malformed byte\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"byte out of range\",\n \t\t\tin: `go test fuzz v1\n byte('\u2603')`,\n-\t\t\tok: false, // byte out of range\n+\t\t\treject: true,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"extra newline\",\n \t\t\tin: `go test fuzz v1\n-string(\"has final newline\")\n+string(\"has extra newline\")\n `,\n-\t\t\tok: true, // has final newline\n+\t\t\twant: `go test fuzz v1\n+string(\"has extra newline\")`,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"trailing spaces\",\n \t\t\tin: `go test fuzz v1\n string(\"extra\")\n []byte(\"spacing\")  \n     `,\n-\t\t\tok: true, // extra spaces in the final newline\n+\t\t\twant: `go test fuzz v1\n+string(\"extra\")\n+[]byte(\"spacing\")`,\n \t\t},\n \t\t{\n+\t\t\tdesc: \"float types\",\n \t\t\tin: `go test fuzz v1\n float64(0)\n float32(0)`,\n-\t\t\tok: true, // will be an integer literal since there is no decimal\n \t\t},\n \t\t{\n+\t\t\tdesc: \"various types\",\n \t\t\tin: `go test fuzz v1\n int(-23)\n int8(-2)\n@@ -101,19 +120,112 @@ bool(true)\n string(\"hello\\\\xbd\\\\xb2=\\\\xbc \u2318\")\n float64(-12.5)\n float32(2.5)`,\n-\t\t\tok: true,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"float edge cases\",\n+\t\t\t// The two IEEE 754 bit patterns used for the math.Float{64,32}frombits\n+\t\t\t// encodings are non-math.NAN quiet-NaN values. Since they are not equal\n+\t\t\t// to math.NaN(), they should be re-encoded to their bit patterns. They\n+\t\t\t// are, respectively:\n+\t\t\t//   * math.Float64bits(math.NaN())+1\n+\t\t\t//   * math.Float32bits(float32(math.NaN()))+1\n+\t\t\tin: `go test fuzz v1\n+float32(-0)\n+float64(-0)\n+float32(+Inf)\n+float32(-Inf)\n+float32(NaN)\n+float64(+Inf)\n+float64(-Inf)\n+float64(NaN)\n+math.Float64frombits(0x7ff8000000000002)\n+math.Float32frombits(0x7fc00001)`,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"int variations\",\n+\t\t\t// Although we arbitrarily choose default integer bases (0 or 16), we may\n+\t\t\t// want to change those arbitrary choices in the future and should not\n+\t\t\t// break the parser. Verify that integers in the opposite bases still\n+\t\t\t// parse correctly.\n+\t\t\tin: `go test fuzz v1\n+int(0x0)\n+int32(0x41)\n+int64(0xfffffffff)\n+uint32(0xcafef00d)\n+uint64(0xffffffffffffffff)\n+uint8(0b0000000)\n+byte(0x0)\n+byte('\\000')\n+byte('\\u0000')\n+byte('\\'')\n+math.Float64frombits(9221120237041090562)\n+math.Float32frombits(2143289345)`,\n+\t\t\twant: `go test fuzz v1\n+int(0)\n+rune('A')\n+int64(68719476735)\n+uint32(3405705229)\n+uint64(18446744073709551615)\n+byte('\\x00')\n+byte('\\x00')\n+byte('\\x00')\n+byte('\\x00')\n+byte('\\'')\n+math.Float64frombits(0x7ff8000000000002)\n+math.Float32frombits(0x7fc00001)`,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"rune validation\",\n+\t\t\tin: `go test fuzz v1\n+rune(0)\n+rune(0x41)\n+rune(-1)\n+rune(0xfffd)\n+rune(0xd800)\n+rune(0x10ffff)\n+rune(0x110000)\n+`,\n+\t\t\twant: `go test fuzz v1\n+rune('\\x00')\n+rune('A')\n+int32(-1)\n+rune('\ufffd')\n+int32(55296)\n+rune('\\U0010ffff')\n+int32(1114112)`,\n+\t\t},\n+\t\t{\n+\t\t\tdesc: \"int overflow\",\n+\t\t\tin: `go test fuzz v1\n+int(0x7fffffffffffffff)\n+uint(0xffffffffffffffff)`,\n+\t\t\twant: func() string {\n+\t\t\t\tswitch strconv.IntSize {\n+\t\t\t\tcase 32:\n+\t\t\t\t\treturn `go test fuzz v1\n+int(-1)\n+uint(4294967295)`\n+\t\t\t\tcase 64:\n+\t\t\t\t\treturn `go test fuzz v1\n+int(9223372036854775807)\n+uint(18446744073709551615)`\n+\t\t\t\tdefault:\n+\t\t\t\t\tpanic(\"unreachable\")\n+\t\t\t\t}\n+\t\t\t}(),\n \t\t},\n \t}\n \tfor _, test := range tests {\n-\t\tt.Run(test.in, func(t *testing.T) {\n+\t\tt.Run(test.desc, func(t *testing.T) {\n \t\t\tvals, err := unmarshalCorpusFile([]byte(test.in))\n-\t\t\tif test.ok && err != nil {\n-\t\t\t\tt.Fatalf(\"unmarshal unexpected error: %v\", err)\n-\t\t\t} else if !test.ok && err == nil {\n-\t\t\t\tt.Fatalf(\"unmarshal unexpected success\")\n+\t\t\tif test.reject {\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Fatalf(\"unmarshal unexpected success\")\n+\t\t\t\t}\n+\t\t\t\treturn\n \t\t\t}\n-\t\t\tif !test.ok {\n-\t\t\t\treturn // skip the rest of the test\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"unmarshal unexpected error: %v\", err)\n \t\t\t}\n \t\t\tnewB := marshalCorpusFile(vals...)\n \t\t\tif err != nil {\n@@ -122,9 +234,15 @@ float32(2.5)`,\n \t\t\tif newB[len(newB)-1] != '\\n' {\n \t\t\t\tt.Error(\"didn't write final newline to corpus file\")\n \t\t\t}\n-\t\t\tbefore, after := strings.TrimSpace(test.in), strings.TrimSpace(string(newB))\n-\t\t\tif before != after {\n-\t\t\t\tt.Errorf(\"values changed after unmarshal then marshal\\nbefore: %q\\nafter:  %q\", before, after)\n+\n+\t\t\twant := test.want\n+\t\t\tif want == \"\" {\n+\t\t\t\twant = test.in\n+\t\t\t}\n+\t\t\twant += \"\\n\"\n+\t\t\tgot := string(newB)\n+\t\t\tif got != want {\n+\t\t\t\tt.Errorf(\"unexpected marshaled value\\ngot:\\n%s\\nwant:\\n%s\", got, want)\n \t\t\t}\n \t\t})\n \t}\n@@ -170,3 +288,117 @@ func BenchmarkUnmarshalCorpusFile(b *testing.B) {\n \t\t})\n \t}\n }\n+\n+func TestByteRoundTrip(t *testing.T) {\n+\tfor x := 0; x < 256; x++ {\n+\t\tb1 := byte(x)\n+\t\tbuf := marshalCorpusFile(b1)\n+\t\tvs, err := unmarshalCorpusFile(buf)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tb2 := vs[0].(byte)\n+\t\tif b2 != b1 {\n+\t\t\tt.Fatalf(\"unmarshaled %v, want %v:\\n%s\", b2, b1, buf)\n+\t\t}\n+\t}\n+}\n+\n+func TestInt8RoundTrip(t *testing.T) {\n+\tfor x := -128; x < 128; x++ {\n+\t\ti1 := int8(x)\n+\t\tbuf := marshalCorpusFile(i1)\n+\t\tvs, err := unmarshalCorpusFile(buf)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\ti2 := vs[0].(int8)\n+\t\tif i2 != i1 {\n+\t\t\tt.Fatalf(\"unmarshaled %v, want %v:\\n%s\", i2, i1, buf)\n+\t\t}\n+\t}\n+}\n+\n+func FuzzFloat64RoundTrip(f *testing.F) {\n+\tf.Add(math.Float64bits(0))\n+\tf.Add(math.Float64bits(math.Copysign(0, -1)))\n+\tf.Add(math.Float64bits(math.MaxFloat64))\n+\tf.Add(math.Float64bits(math.SmallestNonzeroFloat64))\n+\tf.Add(math.Float64bits(math.NaN()))\n+\tf.Add(uint64(0x7FF0000000000001)) // signaling NaN\n+\tf.Add(math.Float64bits(math.Inf(1)))\n+\tf.Add(math.Float64bits(math.Inf(-1)))\n+\n+\tf.Fuzz(func(t *testing.T, u1 uint64) {\n+\t\tx1 := math.Float64frombits(u1)\n+\n+\t\tb := marshalCorpusFile(x1)\n+\t\tt.Logf(\"marshaled math.Float64frombits(0x%x):\\n%s\", u1, b)\n+\n+\t\txs, err := unmarshalCorpusFile(b)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif len(xs) != 1 {\n+\t\t\tt.Fatalf(\"unmarshaled %d values\", len(xs))\n+\t\t}\n+\t\tx2 := xs[0].(float64)\n+\t\tu2 := math.Float64bits(x2)\n+\t\tif u2 != u1 {\n+\t\t\tt.Errorf(\"unmarshaled %v (bits 0x%x)\", x2, u2)\n+\t\t}\n+\t})\n+}\n+\n+func FuzzRuneRoundTrip(f *testing.F) {\n+\tf.Add(rune(-1))\n+\tf.Add(rune(0xd800))\n+\tf.Add(rune(0xdfff))\n+\tf.Add(rune(unicode.ReplacementChar))\n+\tf.Add(rune(unicode.MaxASCII))\n+\tf.Add(rune(unicode.MaxLatin1))\n+\tf.Add(rune(unicode.MaxRune))\n+\tf.Add(rune(unicode.MaxRune + 1))\n+\tf.Add(rune(-0x80000000))\n+\tf.Add(rune(0x7fffffff))\n+\n+\tf.Fuzz(func(t *testing.T, r1 rune) {\n+\t\tb := marshalCorpusFile(r1)\n+\t\tt.Logf(\"marshaled rune(0x%x):\\n%s\", r1, b)\n+\n+\t\trs, err := unmarshalCorpusFile(b)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif len(rs) != 1 {\n+\t\t\tt.Fatalf(\"unmarshaled %d values\", len(rs))\n+\t\t}\n+\t\tr2 := rs[0].(rune)\n+\t\tif r2 != r1 {\n+\t\t\tt.Errorf(\"unmarshaled rune(0x%x)\", r2)\n+\t\t}\n+\t})\n+}\n+\n+func FuzzStringRoundTrip(f *testing.F) {\n+\tf.Add(\"\")\n+\tf.Add(\"\\x00\")\n+\tf.Add(string([]rune{unicode.ReplacementChar}))\n+\n+\tf.Fuzz(func(t *testing.T, s1 string) {\n+\t\tb := marshalCorpusFile(s1)\n+\t\tt.Logf(\"marshaled %q:\\n%s\", s1, b)\n+\n+\t\trs, err := unmarshalCorpusFile(b)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif len(rs) != 1 {\n+\t\t\tt.Fatalf(\"unmarshaled %d values\", len(rs))\n+\t\t}\n+\t\ts2 := rs[0].(string)\n+\t\tif s2 != s1 {\n+\t\t\tt.Errorf(\"unmarshaled %q\", s2)\n+\t\t}\n+\t})\n+}"}, {"sha": "6e4c4e2d0fbbb1abe77b62b91ffdf3d7a51ec1be", "filename": "libgo/go/internal/fuzz/worker.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fworker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Finternal%2Ffuzz%2Fworker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Ffuzz%2Fworker.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -800,6 +800,7 @@ func (ws *workerServer) minimize(ctx context.Context, args minimizeArgs) (resp m\n \tif err != nil {\n \t\tpanic(err)\n \t}\n+\tinpHash := sha256.Sum256(mem.valueCopy())\n \tif args.Timeout != 0 {\n \t\tvar cancel func()\n \t\tctx, cancel = context.WithTimeout(ctx, args.Timeout)\n@@ -811,12 +812,22 @@ func (ws *workerServer) minimize(ctx context.Context, args minimizeArgs) (resp m\n \tsuccess, err := ws.minimizeInput(ctx, vals, mem, args)\n \tif success {\n \t\twriteToMem(vals, mem)\n+\t\toutHash := sha256.Sum256(mem.valueCopy())\n \t\tmem.header().rawInMem = false\n \t\tresp.WroteToMem = true\n \t\tif err != nil {\n \t\t\tresp.Err = err.Error()\n \t\t} else {\n-\t\t\tresp.CoverageData = coverageSnapshot\n+\t\t\t// If the values didn't change during minimization then coverageSnapshot is likely\n+\t\t\t// a dirty snapshot which represents the very last step of minimization, not the\n+\t\t\t// coverage for the initial input. In that case just return the coverage we were\n+\t\t\t// given initially, since it more accurately represents the coverage map for the\n+\t\t\t// input we are returning.\n+\t\t\tif outHash != inpHash {\n+\t\t\t\tresp.CoverageData = coverageSnapshot\n+\t\t\t} else {\n+\t\t\t\tresp.CoverageData = args.KeepCoverage\n+\t\t\t}\n \t\t}\n \t}\n \treturn resp\n@@ -883,7 +894,8 @@ func (ws *workerServer) minimizeInput(ctx context.Context, vals []any, mem *shar\n \t\t\t}\n \t\t\treturn true\n \t\t}\n-\t\tif keepCoverage != nil && hasCoverageBit(keepCoverage, coverageSnapshot) {\n+\t\t// Minimization should preserve coverage bits.\n+\t\tif keepCoverage != nil && isCoverageSubset(keepCoverage, coverageSnapshot) {\n \t\t\treturn true\n \t\t}\n \t\tvals[args.Index] = prev"}, {"sha": "d91e743a014e21c7b586b733fb731868bf9c49d5", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -703,6 +703,12 @@ var (\n \t_ io.Reader   = (*Buffers)(nil)\n )\n \n+// WriteTo writes contents of the buffers to w.\n+//\n+// WriteTo implements io.WriterTo for Buffers.\n+//\n+// WriteTo modifies the slice v as well as v[i] for 0 <= i < len(v),\n+// but does not modify v[i][j] for any i, j.\n func (v *Buffers) WriteTo(w io.Writer) (n int64, err error) {\n \tif wv, ok := w.(buffersWriter); ok {\n \t\treturn wv.writeBuffers(v)\n@@ -719,6 +725,12 @@ func (v *Buffers) WriteTo(w io.Writer) (n int64, err error) {\n \treturn n, nil\n }\n \n+// Read from the buffers.\n+//\n+// Read implements io.Reader for Buffers.\n+//\n+// Read modifies the slice v as well as v[i] for 0 <= i < len(v),\n+// but does not modify v[i][j] for any i, j.\n func (v *Buffers) Read(p []byte) (n int, err error) {\n \tfor len(p) > 0 && len(*v) > 0 {\n \t\tn0 := copy(p, (*v)[0])"}, {"sha": "2eb60b9ee26002881973e58b5e15b260ad87dbef", "filename": "libgo/go/runtime/mfinal_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fruntime%2Fmfinal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fruntime%2Fmfinal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmfinal_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -45,6 +45,15 @@ func TestFinalizerType(t *testing.T) {\n \t\t{func(x *int) any { return Tintptr(x) }, func(v *int) { finalize(v) }},\n \t\t{func(x *int) any { return (*Tint)(x) }, func(v *Tint) { finalize((*int)(v)) }},\n \t\t{func(x *int) any { return (*Tint)(x) }, func(v Tinter) { finalize((*int)(v.(*Tint))) }},\n+\t\t// Test case for argument spill slot.\n+\t\t// If the spill slot was not counted for the frame size, it will (incorrectly) choose\n+\t\t// call32 as the result has (exactly) 32 bytes. When the argument actually spills,\n+\t\t// it clobbers the caller's frame (likely the return PC).\n+\t\t{func(x *int) any { return x }, func(v any) [4]int64 {\n+\t\t\tprint() // force spill\n+\t\t\tfinalize(v.(*int))\n+\t\t\treturn [4]int64{}\n+\t\t}},\n \t}\n \n \tfor i, tt := range finalizerTests {"}, {"sha": "16870144dda01437c4049f867d4861b655ba63a2", "filename": "libgo/go/runtime/testdata/testprogcgo/aprof.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Faprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Faprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprogcgo%2Faprof.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -10,7 +10,7 @@ package main\n // This is a regression test for issue 14599, where profiling fails when the\n // function is the first C function. Exported functions are the first C\n // functions, so we use an exported function. Exported functions are created in\n-// lexigraphical order of source files, so this file is named aprof.go to\n+// lexicographical order of source files, so this file is named aprof.go to\n // ensure its function is first.\n \n // extern void CallGoNop();"}, {"sha": "ba4df618bfaa0329c6c525524a414e7c4eafd64d", "filename": "libgo/go/strings/builder.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fstrings%2Fbuilder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fstrings%2Fbuilder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fbuilder.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -17,10 +17,9 @@ type Builder struct {\n \tbuf  []byte\n }\n \n-// noescape hides a pointer from escape analysis.  noescape is\n-// the identity function but escape analysis doesn't think the\n-// output depends on the input. noescape is inlined and currently\n-// compiles down to zero instructions.\n+// noescape hides a pointer from escape analysis. It is the identity function\n+// but escape analysis doesn't think the output depends on the input.\n+// noescape is inlined and currently compiles down to zero instructions.\n // USE CAREFULLY!\n // This was copied from the runtime; see issues 23382 and 7921.\n //go:nosplit"}, {"sha": "9fed7c526d8018bd4b7409831e38b07dfed35c5c", "filename": "libgo/go/syscall/syscall_unix_test.go", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fsyscall%2Fsyscall_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fgo%2Fsyscall%2Fsyscall_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -328,33 +328,6 @@ func TestUnixRightsRoundtrip(t *testing.T) {\n \t}\n }\n \n-func TestRlimit(t *testing.T) {\n-\tvar rlimit, zero syscall.Rlimit\n-\tif err := syscall.Getrlimit(syscall.RLIMIT_CPU, &rlimit); err != nil {\n-\t\tt.Fatalf(\"Getrlimit: save failed: %v\", err)\n-\t}\n-\tif zero == rlimit {\n-\t\tt.Fatalf(\"Getrlimit: save failed: got zero value %#v\", rlimit)\n-\t}\n-\tset := rlimit\n-\tset.Cur = set.Max - 1\n-\tif err := syscall.Setrlimit(syscall.RLIMIT_CPU, &set); err != nil {\n-\t\tt.Fatalf(\"Setrlimit: set failed: %#v %v\", set, err)\n-\t}\n-\tvar get syscall.Rlimit\n-\tif err := syscall.Getrlimit(syscall.RLIMIT_CPU, &get); err != nil {\n-\t\tt.Fatalf(\"Getrlimit: get failed: %v\", err)\n-\t}\n-\tset = rlimit\n-\tset.Cur = set.Max - 1\n-\tif set != get {\n-\t\tt.Fatalf(\"Rlimit: change failed: wanted %#v got %#v\", set, get)\n-\t}\n-\tif err := syscall.Setrlimit(syscall.RLIMIT_CPU, &rlimit); err != nil {\n-\t\tt.Fatalf(\"Setrlimit: restore failed: %#v %v\", rlimit, err)\n-\t}\n-}\n-\n func TestSeekFailure(t *testing.T) {\n \t_, err := syscall.Seek(-1, 0, io.SeekStart)\n \tif err == nil {"}, {"sha": "cd2510bb76c189f675ad2eb29331e2f063829cc4", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -198,7 +198,7 @@ done\n     libgofile=${libgotd}/$f\n     merge ${name} ${oldfile} ${newfile} ${libgofile}\n   done\n-  (cd ${newtd} & git ls-files .) | while read f; do\n+  (cd ${newtd} && git ls-files .) | while read f; do\n     if test \"`basename -- $f`\" = \".gitignore\"; then\n       continue\n     fi"}, {"sha": "22dcf23c3ba76e31020b68cf21f2ed406f034e36", "filename": "libgo/misc/cgo/testsanitizers/asan_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fasan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69921f4a7ec081c5b37dae13e3372003e4efd49f/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fasan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftestsanitizers%2Fasan_test.go?ref=69921f4a7ec081c5b37dae13e3372003e4efd49f", "patch": "@@ -63,7 +63,7 @@ func TestASAN(t *testing.T) {\n \t\t\t\t\t// sanitizer library needs a\n \t\t\t\t\t// symbolizer program and can't find it.\n \t\t\t\t\tconst noSymbolizer = \"external symbolizer\"\n-\t\t\t\t\t// Check if -asan option can correctly print where the error occured.\n+\t\t\t\t\t// Check if -asan option can correctly print where the error occurred.\n \t\t\t\t\tif tc.errorLocation != \"\" &&\n \t\t\t\t\t\t!strings.Contains(out, tc.errorLocation) &&\n \t\t\t\t\t\t!strings.Contains(out, noSymbolizer) &&"}]}