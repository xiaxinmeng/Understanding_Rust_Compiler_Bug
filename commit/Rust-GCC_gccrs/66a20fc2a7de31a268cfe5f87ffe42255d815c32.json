{"sha": "66a20fc2a7de31a268cfe5f87ffe42255d815c32", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZhMjBmYzJhN2RlMzFhMjY4Y2ZlNWY4N2ZmZTQyMjU1ZDgxNWMzMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-05-08T21:03:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-05-08T21:03:18Z"}, "message": "cgraph.c (cgraph_call_edge_duplication_hooks): Export.\n\n\n\t* cgraph.c (cgraph_call_edge_duplication_hooks): Export.\n\t(cgraph_create_node_1): Rename to ...\n\t(cgraph_create_empty_node): ... this one; export.\n\t(cgraph_create_node): Update.\n\t(cgraph_set_call_stmt_including_clones): Move to cgraphclones.c\n\t(cgraph_create_edge_including_clones): Likewise.\n\t(cgraph_find_replacement_node): Likewise.\n\t(cgraph_clone_edge): Likewise.\n\t(cgraph_clone_node): Likewise.\n\t(clone_function_name): Likewise.\n\t(cgraph_create_virtual_clone): Likewise.\n\t(cgraph_remove_node_and_inline_clones): Likewise.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Move here from\n\tcgraphunit.c\n\t* cgraph.h: Reorder declarations so they match file of origin.\n\t(cgraph_create_empty_node): Declare.\n\t* cgraphunit.c (update_call_expr): Move to cgraphclones.c\n\t(cgraph_copy_node_for_versioning): Likewise.\n\t(cgraph_function_versioning): Likewise.\n\t(cgraph_materialize_clone): Likewise.\n\t(cgraph_redirect_edge_call_stmt_to_callee): Likewise.\n\t(cgraph_materialize_all_clones): Likewise.\n\t* cgraphclones.c: New file.\n\t* Makefile.in: Update for cgraphclones.\n\nFrom-SVN: r187295", "tree": {"sha": "d628a84cad48249917d726d624c73733baf7b169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d628a84cad48249917d726d624c73733baf7b169"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66a20fc2a7de31a268cfe5f87ffe42255d815c32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a20fc2a7de31a268cfe5f87ffe42255d815c32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66a20fc2a7de31a268cfe5f87ffe42255d815c32", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a20fc2a7de31a268cfe5f87ffe42255d815c32/comments", "author": null, "committer": null, "parents": [{"sha": "aedfe0a8068e1ae6c0fcce1e3175f065b491a5c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aedfe0a8068e1ae6c0fcce1e3175f065b491a5c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aedfe0a8068e1ae6c0fcce1e3175f065b491a5c4"}], "stats": {"total": 1035, "additions": 154, "deletions": 881}, "files": [{"sha": "27072e60909a6f33bc886f34e14affa82a95ed2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=66a20fc2a7de31a268cfe5f87ffe42255d815c32", "patch": "@@ -1,3 +1,30 @@\n+2012-05-08  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_call_edge_duplication_hooks): Export.\n+\t(cgraph_create_node_1): Rename to ...\n+\t(cgraph_create_empty_node): ... this one; export.\n+\t(cgraph_create_node): Update.\n+\t(cgraph_set_call_stmt_including_clones): Move to cgraphclones.c\n+\t(cgraph_create_edge_including_clones): Likewise.\n+\t(cgraph_find_replacement_node): Likewise.\n+\t(cgraph_clone_edge): Likewise.\n+\t(cgraph_clone_node): Likewise.\n+\t(clone_function_name): Likewise.\n+\t(cgraph_create_virtual_clone): Likewise.\n+\t(cgraph_remove_node_and_inline_clones): Likewise.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Move here from\n+\tcgraphunit.c\n+\t* cgraph.h: Reorder declarations so they match file of origin.\n+\t(cgraph_create_empty_node): Declare.\n+\t* cgraphunit.c (update_call_expr): Move to cgraphclones.c\n+\t(cgraph_copy_node_for_versioning): Likewise.\n+\t(cgraph_function_versioning): Likewise.\n+\t(cgraph_materialize_clone): Likewise.\n+\t(cgraph_redirect_edge_call_stmt_to_callee): Likewise.\n+\t(cgraph_materialize_all_clones): Likewise.\n+\t* cgraphclones.c: New file.\n+\t* Makefile.in: Update for cgraphclones.\n+\n 2012-05-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/53176"}, {"sha": "98f83d9156dcfb4ae61c68715d44990c42931a84", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=66a20fc2a7de31a268cfe5f87ffe42255d815c32", "patch": "@@ -1179,6 +1179,7 @@ OBJS = \\\n \tcgraph.o \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n+\tcgraphclones.o \\\n \tcombine.o \\\n \tcombine-stack-adj.o \\\n \tcompare-elim.o \\\n@@ -2929,6 +2930,14 @@ cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H) \\\n    tree-pretty-print.h gimple-pretty-print.h ipa-inline.h $(IPA_UTILS_H) \\\n    $(LTO_STREAMER_H) output.h $(REGSET_H) $(EXCEPT_H)\n+cgraphclones.o : cgraphclones.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \\\n+   $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n+   $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) \\\n+   $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) $(IPA_PROP_H) \\\n+   gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H) \\\n+   tree-pretty-print.h gimple-pretty-print.h ipa-inline.h $(IPA_UTILS_H) \\\n+   $(LTO_STREAMER_H) output.h $(REGSET_H) $(EXCEPT_H)\n cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H) \\\n@@ -3745,6 +3754,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-parloops.c \\\n   $(srcdir)/omp-low.c \\\n   $(srcdir)/targhooks.c $(out_file) $(srcdir)/passes.c $(srcdir)/cgraphunit.c \\\n+  $(srcdir)/cgraphclones.c \\\n   $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-phinodes.c \\\n   $(srcdir)/lto-symtab.c \\"}, {"sha": "d7c4f0d30535b846ba1f1f218183ff34608764c9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 86, "deletions": 489, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=66a20fc2a7de31a268cfe5f87ffe42255d815c32", "patch": "@@ -288,7 +288,7 @@ cgraph_remove_edge_duplication_hook (struct cgraph_2edge_hook_list *entry)\n }\n \n /* Call all edge duplication hooks.  */\n-static void\n+void\n cgraph_call_edge_duplication_hooks (struct cgraph_edge *cs1,\n \t\t\t\t    struct cgraph_edge *cs2)\n {\n@@ -365,8 +365,8 @@ cgraph_allocate_node (void)\n \n /* Allocate new callgraph node and insert it into basic data structures.  */\n \n-static struct cgraph_node *\n-cgraph_create_node_1 (void)\n+struct cgraph_node *\n+cgraph_create_empty_node (void)\n {\n   struct cgraph_node *node = cgraph_allocate_node ();\n \n@@ -382,7 +382,7 @@ cgraph_create_node_1 (void)\n struct cgraph_node *\n cgraph_create_node (tree decl)\n {\n-  struct cgraph_node *node = cgraph_create_node_1 ();\n+  struct cgraph_node *node = cgraph_create_empty_node ();\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n   node->symbol.decl = decl;\n@@ -620,97 +620,6 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n     cgraph_add_edge_to_call_site_hash (e);\n }\n \n-/* Like cgraph_set_call_stmt but walk the clone tree and update all\n-   clones sharing the same function body.  */\n-\n-void\n-cgraph_set_call_stmt_including_clones (struct cgraph_node *orig,\n-\t\t\t\t       gimple old_stmt, gimple new_stmt)\n-{\n-  struct cgraph_node *node;\n-  struct cgraph_edge *edge = cgraph_edge (orig, old_stmt);\n-\n-  if (edge)\n-    cgraph_set_call_stmt (edge, new_stmt);\n-\n-  node = orig->clones;\n-  if (node)\n-    while (node != orig)\n-      {\n-\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n-\tif (edge)\n-\t  cgraph_set_call_stmt (edge, new_stmt);\n-\tif (node->clones)\n-\t  node = node->clones;\n-\telse if (node->next_sibling_clone)\n-\t  node = node->next_sibling_clone;\n-\telse\n-\t  {\n-\t    while (node != orig && !node->next_sibling_clone)\n-\t      node = node->clone_of;\n-\t    if (node != orig)\n-\t      node = node->next_sibling_clone;\n-\t  }\n-      }\n-}\n-\n-/* Like cgraph_create_edge walk the clone tree and update all clones sharing\n-   same function body.  If clones already have edge for OLD_STMT; only\n-   update the edge same way as cgraph_set_call_stmt_including_clones does.\n-\n-   TODO: COUNT and LOOP_DEPTH should be properly distributed based on relative\n-   frequencies of the clones.  */\n-\n-void\n-cgraph_create_edge_including_clones (struct cgraph_node *orig,\n-\t\t\t\t     struct cgraph_node *callee,\n-\t\t\t\t     gimple old_stmt,\n-\t\t\t\t     gimple stmt, gcov_type count,\n-\t\t\t\t     int freq,\n-\t\t\t\t     cgraph_inline_failed_t reason)\n-{\n-  struct cgraph_node *node;\n-  struct cgraph_edge *edge;\n-\n-  if (!cgraph_edge (orig, stmt))\n-    {\n-      edge = cgraph_create_edge (orig, callee, stmt, count, freq);\n-      edge->inline_failed = reason;\n-    }\n-\n-  node = orig->clones;\n-  if (node)\n-    while (node != orig)\n-      {\n-\tstruct cgraph_edge *edge = cgraph_edge (node, old_stmt);\n-\n-        /* It is possible that clones already contain the edge while\n-\t   master didn't.  Either we promoted indirect call into direct\n-\t   call in the clone or we are processing clones of unreachable\n-\t   master where edges has been removed.  */\n-\tif (edge)\n-\t  cgraph_set_call_stmt (edge, stmt);\n-\telse if (!cgraph_edge (node, stmt))\n-\t  {\n-\t    edge = cgraph_create_edge (node, callee, stmt, count,\n-\t\t\t\t       freq);\n-\t    edge->inline_failed = reason;\n-\t  }\n-\n-\tif (node->clones)\n-\t  node = node->clones;\n-\telse if (node->next_sibling_clone)\n-\t  node = node->next_sibling_clone;\n-\telse\n-\t  {\n-\t    while (node != orig && !node->next_sibling_clone)\n-\t      node = node->clone_of;\n-\t    if (node != orig)\n-\t      node = node->next_sibling_clone;\n-\t  }\n-      }\n-}\n-\n /* Allocate a cgraph_edge structure and fill it with data according to the\n    parameters of which only CALLEE can be NULL (when creating an indirect call\n    edge).  */\n@@ -970,6 +879,87 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n   initialize_inline_failed (edge);\n }\n \n+/* If necessary, change the function declaration in the call statement\n+   associated with E so that it corresponds to the edge callee.  */\n+\n+gimple\n+cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n+{\n+  tree decl = gimple_call_fndecl (e->call_stmt);\n+  gimple new_stmt;\n+  gimple_stmt_iterator gsi;\n+#ifdef ENABLE_CHECKING\n+  struct cgraph_node *node;\n+#endif\n+\n+  if (e->indirect_unknown_callee\n+      || decl == e->callee->symbol.decl)\n+    return e->call_stmt;\n+\n+#ifdef ENABLE_CHECKING\n+  if (decl)\n+    {\n+      node = cgraph_get_node (decl);\n+      gcc_assert (!node || !node->clone.combined_args_to_skip);\n+    }\n+#endif\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"updating call of %s/%i -> %s/%i: \",\n+\t       xstrdup (cgraph_node_name (e->caller)), e->caller->uid,\n+\t       xstrdup (cgraph_node_name (e->callee)), e->callee->uid);\n+      print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+      if (e->callee->clone.combined_args_to_skip)\n+\t{\n+\t  fprintf (cgraph_dump_file, \" combined args to skip: \");\n+\t  dump_bitmap (cgraph_dump_file,\n+\t\t       e->callee->clone.combined_args_to_skip);\n+\t}\n+    }\n+\n+  if (e->callee->clone.combined_args_to_skip)\n+    {\n+      int lp_nr;\n+\n+      new_stmt\n+\t= gimple_call_copy_skip_args (e->call_stmt,\n+\t\t\t\t      e->callee->clone.combined_args_to_skip);\n+      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n+\n+      if (gimple_vdef (new_stmt)\n+\t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n+\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n+\n+      gsi = gsi_for_stmt (e->call_stmt);\n+      gsi_replace (&gsi, new_stmt, false);\n+      /* We need to defer cleaning EH info on the new statement to\n+         fixup-cfg.  We may not have dominator information at this point\n+\t and thus would end up with unreachable blocks and have no way\n+\t to communicate that we need to run CFG cleanup then.  */\n+      lp_nr = lookup_stmt_eh_lp (e->call_stmt);\n+      if (lp_nr != 0)\n+\t{\n+\t  remove_stmt_from_eh_lp (e->call_stmt);\n+\t  add_stmt_to_eh_lp (new_stmt, lp_nr);\n+\t}\n+    }\n+  else\n+    {\n+      new_stmt = e->call_stmt;\n+      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n+      update_stmt (new_stmt);\n+    }\n+\n+  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt);\n+\n+  if (cgraph_dump_file)\n+    {\n+      fprintf (cgraph_dump_file, \"  updated to:\");\n+      print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n+    }\n+  return new_stmt;\n+}\n \n /* Update or remove the corresponding cgraph edge if a GIMPLE_CALL\n    OLD_STMT changed into NEW_STMT.  OLD_CALL is gimple_call_fndecl\n@@ -1176,91 +1166,6 @@ cgraph_release_function_body (struct cgraph_node *node)\n     DECL_INITIAL (node->symbol.decl) = error_mark_node;\n }\n \n-/* NODE is being removed from symbol table; see if its entry can be replaced by\n-   other inline clone.  */\n-struct cgraph_node *\n-cgraph_find_replacement_node (struct cgraph_node *node)\n-{\n-  struct cgraph_node *next_inline_clone, *replacement;\n-\n-  for (next_inline_clone = node->clones;\n-       next_inline_clone\n-       && next_inline_clone->symbol.decl != node->symbol.decl;\n-       next_inline_clone = next_inline_clone->next_sibling_clone)\n-    ;\n-\n-  /* If there is inline clone of the node being removed, we need\n-     to put it into the position of removed node and reorganize all\n-     other clones to be based on it.  */\n-  if (next_inline_clone)\n-    {\n-      struct cgraph_node *n;\n-      struct cgraph_node *new_clones;\n-\n-      replacement = next_inline_clone;\n-\n-      /* Unlink inline clone from the list of clones of removed node.  */\n-      if (next_inline_clone->next_sibling_clone)\n-\tnext_inline_clone->next_sibling_clone->prev_sibling_clone\n-\t  = next_inline_clone->prev_sibling_clone;\n-      if (next_inline_clone->prev_sibling_clone)\n-\t{\n-\t  gcc_assert (node->clones != next_inline_clone);\n-\t  next_inline_clone->prev_sibling_clone->next_sibling_clone\n-\t    = next_inline_clone->next_sibling_clone;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (node->clones == next_inline_clone);\n-\t  node->clones = next_inline_clone->next_sibling_clone;\n-\t}\n-\n-      new_clones = node->clones;\n-      node->clones = NULL;\n-\n-      /* Copy clone info.  */\n-      next_inline_clone->clone = node->clone;\n-\n-      /* Now place it into clone tree at same level at NODE.  */\n-      next_inline_clone->clone_of = node->clone_of;\n-      next_inline_clone->prev_sibling_clone = NULL;\n-      next_inline_clone->next_sibling_clone = NULL;\n-      if (node->clone_of)\n-\t{\n-\t  if (node->clone_of->clones)\n-\t    node->clone_of->clones->prev_sibling_clone = next_inline_clone;\n-\t  next_inline_clone->next_sibling_clone = node->clone_of->clones;\n-\t  node->clone_of->clones = next_inline_clone;\n-\t}\n-\n-      /* Merge the clone list.  */\n-      if (new_clones)\n-\t{\n-\t  if (!next_inline_clone->clones)\n-\t    next_inline_clone->clones = new_clones;\n-\t  else\n-\t    {\n-\t      n = next_inline_clone->clones;\n-\t      while (n->next_sibling_clone)\n-\t\tn =  n->next_sibling_clone;\n-\t      n->next_sibling_clone = new_clones;\n-\t      new_clones->prev_sibling_clone = n;\n-\t    }\n-\t}\n-\n-      /* Update clone_of pointers.  */\n-      n = new_clones;\n-      while (n)\n-\t{\n-\t  n->clone_of = next_inline_clone;\n-\t  n = n->next_sibling_clone;\n-\t}\n-      return replacement;\n-    }\n-  else\n-    return NULL;\n-}\n-\n /* Remove the node from cgraph.  */\n \n void\n@@ -1312,7 +1217,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \t}\n       else\n         {\n-\t  /* We are removing node with clones.  this makes clones inconsistent,\n+\t  /* We are removing node with clones.  This makes clones inconsistent,\n \t     but assume they will be removed subsequently and just keep clone\n \t     tree intact.  This can happen in unreachable function removal since\n \t     we remove unreachable functions in random order, not by bottom-up\n@@ -1357,29 +1262,6 @@ cgraph_remove_node (struct cgraph_node *node)\n   free_nodes = node;\n }\n \n-/* Remove the node from cgraph and all inline clones inlined into it.\n-   Skip however removal of FORBIDDEN_NODE and return true if it needs to be\n-   removed.  This allows to call the function from outer loop walking clone\n-   tree.  */\n-\n-bool\n-cgraph_remove_node_and_inline_clones (struct cgraph_node *node, struct cgraph_node *forbidden_node)\n-{\n-  struct cgraph_edge *e, *next;\n-  bool found = false;\n-\n-  if (node == forbidden_node)\n-    return true;\n-  for (e = node->callees; e; e = next)\n-    {\n-      next = e->next_callee;\n-      if (!e->inline_failed)\n-        found |= cgraph_remove_node_and_inline_clones (e->callee, forbidden_node);\n-    }\n-  cgraph_remove_node (node);\n-  return found;\n-}\n-\n /* Likewise indicate that a node is having address taken.  */\n \n void\n@@ -1624,291 +1506,6 @@ cgraph_function_possibly_inlined_p (tree decl)\n   return DECL_POSSIBLY_INLINED (decl);\n }\n \n-/* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */\n-struct cgraph_edge *\n-cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n-\t\t   gimple call_stmt, unsigned stmt_uid, gcov_type count_scale,\n-\t\t   int freq_scale, bool update_original)\n-{\n-  struct cgraph_edge *new_edge;\n-  gcov_type count = e->count * count_scale / REG_BR_PROB_BASE;\n-  gcov_type freq;\n-\n-  /* We do not want to ignore loop nest after frequency drops to 0.  */\n-  if (!freq_scale)\n-    freq_scale = 1;\n-  freq = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n-  if (freq > CGRAPH_FREQ_MAX)\n-    freq = CGRAPH_FREQ_MAX;\n-\n-  if (e->indirect_unknown_callee)\n-    {\n-      tree decl;\n-\n-      if (call_stmt && (decl = gimple_call_fndecl (call_stmt)))\n-\t{\n-\t  struct cgraph_node *callee = cgraph_get_node (decl);\n-\t  gcc_checking_assert (callee);\n-\t  new_edge = cgraph_create_edge (n, callee, call_stmt, count, freq);\n-\t}\n-      else\n-\t{\n-\t  new_edge = cgraph_create_indirect_edge (n, call_stmt,\n-\t\t\t\t\t\t  e->indirect_info->ecf_flags,\n-\t\t\t\t\t\t  count, freq);\n-\t  *new_edge->indirect_info = *e->indirect_info;\n-\t}\n-    }\n-  else\n-    {\n-      new_edge = cgraph_create_edge (n, e->callee, call_stmt, count, freq);\n-      if (e->indirect_info)\n-\t{\n-\t  new_edge->indirect_info\n-\t    = ggc_alloc_cleared_cgraph_indirect_call_info ();\n-\t  *new_edge->indirect_info = *e->indirect_info;\n-\t}\n-    }\n-\n-  new_edge->inline_failed = e->inline_failed;\n-  new_edge->indirect_inlining_edge = e->indirect_inlining_edge;\n-  new_edge->lto_stmt_uid = stmt_uid;\n-  /* Clone flags that depend on call_stmt availability manually.  */\n-  new_edge->can_throw_external = e->can_throw_external;\n-  new_edge->call_stmt_cannot_inline_p = e->call_stmt_cannot_inline_p;\n-  if (update_original)\n-    {\n-      e->count -= new_edge->count;\n-      if (e->count < 0)\n-\te->count = 0;\n-    }\n-  cgraph_call_edge_duplication_hooks (e, new_edge);\n-  return new_edge;\n-}\n-\n-\n-/* Create node representing clone of N executed COUNT times.  Decrease\n-   the execution counts from original node too.\n-   The new clone will have decl set to DECL that may or may not be the same\n-   as decl of N.\n-\n-   When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n-   function's profile to reflect the fact that part of execution is handled\n-   by node.  \n-   When CALL_DUPLICATOIN_HOOK is true, the ipa passes are acknowledged about\n-   the new clone. Otherwise the caller is responsible for doing so later.  */\n-\n-struct cgraph_node *\n-cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n-\t\t   bool update_original,\n-\t\t   VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t   bool call_duplication_hook)\n-{\n-  struct cgraph_node *new_node = cgraph_create_node_1 ();\n-  struct cgraph_edge *e;\n-  gcov_type count_scale;\n-  unsigned i;\n-\n-  new_node->symbol.decl = decl;\n-  symtab_register_node ((symtab_node)new_node);\n-  new_node->origin = n->origin;\n-  if (new_node->origin)\n-    {\n-      new_node->next_nested = new_node->origin->nested;\n-      new_node->origin->nested = new_node;\n-    }\n-  new_node->analyzed = n->analyzed;\n-  new_node->local = n->local;\n-  new_node->symbol.externally_visible = false;\n-  new_node->local.local = true;\n-  new_node->global = n->global;\n-  new_node->rtl = n->rtl;\n-  new_node->count = count;\n-  new_node->frequency = n->frequency;\n-  new_node->clone = n->clone;\n-  new_node->clone.tree_map = 0;\n-  if (n->count)\n-    {\n-      if (new_node->count > n->count)\n-        count_scale = REG_BR_PROB_BASE;\n-      else\n-        count_scale = new_node->count * REG_BR_PROB_BASE / n->count;\n-    }\n-  else\n-    count_scale = 0;\n-  if (update_original)\n-    {\n-      n->count -= count;\n-      if (n->count < 0)\n-\tn->count = 0;\n-    }\n-\n-  FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n-    {\n-      /* Redirect calls to the old version node to point to its new\n-\t version.  */\n-      cgraph_redirect_edge_callee (e, new_node);\n-    }\n-\n-\n-  for (e = n->callees;e; e=e->next_callee)\n-    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n-\t\t       count_scale, freq, update_original);\n-\n-  for (e = n->indirect_calls; e; e = e->next_callee)\n-    cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n-\t\t       count_scale, freq, update_original);\n-  ipa_clone_references ((symtab_node)new_node, &n->symbol.ref_list);\n-\n-  new_node->next_sibling_clone = n->clones;\n-  if (n->clones)\n-    n->clones->prev_sibling_clone = new_node;\n-  n->clones = new_node;\n-  new_node->clone_of = n;\n-\n-  if (call_duplication_hook)\n-    cgraph_call_node_duplication_hooks (n, new_node);\n-  return new_node;\n-}\n-\n-/* Create a new name for clone of DECL, add SUFFIX.  Returns an identifier.  */\n-\n-static GTY(()) unsigned int clone_fn_id_num;\n-\n-tree\n-clone_function_name (tree decl, const char *suffix)\n-{\n-  tree name = DECL_ASSEMBLER_NAME (decl);\n-  size_t len = IDENTIFIER_LENGTH (name);\n-  char *tmp_name, *prefix;\n-\n-  prefix = XALLOCAVEC (char, len + strlen (suffix) + 2);\n-  memcpy (prefix, IDENTIFIER_POINTER (name), len);\n-  strcpy (prefix + len + 1, suffix);\n-#ifndef NO_DOT_IN_LABEL\n-  prefix[len] = '.';\n-#elif !defined NO_DOLLAR_IN_LABEL\n-  prefix[len] = '$';\n-#else\n-  prefix[len] = '_';\n-#endif\n-  ASM_FORMAT_PRIVATE_NAME (tmp_name, prefix, clone_fn_id_num++);\n-  return get_identifier (tmp_name);\n-}\n-\n-/* Create callgraph node clone with new declaration.  The actual body will\n-   be copied later at compilation stage.\n-\n-   TODO: after merging in ipa-sra use function call notes instead of args_to_skip\n-   bitmap interface.\n-   */\n-struct cgraph_node *\n-cgraph_create_virtual_clone (struct cgraph_node *old_node,\n-\t\t\t     VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t     VEC(ipa_replace_map_p,gc) *tree_map,\n-\t\t\t     bitmap args_to_skip,\n-\t\t\t     const char * suffix)\n-{\n-  tree old_decl = old_node->symbol.decl;\n-  struct cgraph_node *new_node = NULL;\n-  tree new_decl;\n-  size_t i;\n-  struct ipa_replace_map *map;\n-\n-  if (!flag_wpa)\n-    gcc_checking_assert  (tree_versionable_function_p (old_decl));\n-\n-  gcc_assert (old_node->local.can_change_signature || !args_to_skip);\n-\n-  /* Make a new FUNCTION_DECL tree node */\n-  if (!args_to_skip)\n-    new_decl = copy_node (old_decl);\n-  else\n-    new_decl = build_function_decl_skip_args (old_decl, args_to_skip, false);\n-  DECL_STRUCT_FUNCTION (new_decl) = NULL;\n-\n-  /* Generate a new name for the new version. */\n-  DECL_NAME (new_decl) = clone_function_name (old_decl, suffix);\n-  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n-  SET_DECL_RTL (new_decl, NULL);\n-\n-  new_node = cgraph_clone_node (old_node, new_decl, old_node->count,\n-\t\t\t\tCGRAPH_FREQ_BASE, false,\n-\t\t\t\tredirect_callers, false);\n-  /* Update the properties.\n-     Make clone visible only within this translation unit.  Make sure\n-     that is not weak also.\n-     ??? We cannot use COMDAT linkage because there is no\n-     ABI support for this.  */\n-  DECL_EXTERNAL (new_node->symbol.decl) = 0;\n-  if (DECL_ONE_ONLY (old_decl))\n-    DECL_SECTION_NAME (new_node->symbol.decl) = NULL;\n-  DECL_COMDAT_GROUP (new_node->symbol.decl) = 0;\n-  TREE_PUBLIC (new_node->symbol.decl) = 0;\n-  DECL_COMDAT (new_node->symbol.decl) = 0;\n-  DECL_WEAK (new_node->symbol.decl) = 0;\n-  DECL_STATIC_CONSTRUCTOR (new_node->symbol.decl) = 0;\n-  DECL_STATIC_DESTRUCTOR (new_node->symbol.decl) = 0;\n-  new_node->clone.tree_map = tree_map;\n-  new_node->clone.args_to_skip = args_to_skip;\n-  FOR_EACH_VEC_ELT (ipa_replace_map_p, tree_map, i, map)\n-    {\n-      tree var = map->new_tree;\n-      symtab_node ref_node;\n-\n-      STRIP_NOPS (var);\n-      if (TREE_CODE (var) != ADDR_EXPR)\n-\tcontinue;\n-      var = get_base_var (var);\n-      if (!var)\n-\tcontinue;\n-      if (TREE_CODE (var) != FUNCTION_DECL\n-\t  && TREE_CODE (var) != VAR_DECL)\n-\tcontinue;\n-\n-      /* Record references of the future statement initializing the constant\n-\t argument.  */\n-      ref_node = symtab_get_node (var);\n-      gcc_checking_assert (ref_node);\n-      ipa_record_reference ((symtab_node)new_node, (symtab_node)ref_node,\n-\t\t\t    IPA_REF_ADDR, NULL);\n-    }\n-  if (!args_to_skip)\n-    new_node->clone.combined_args_to_skip = old_node->clone.combined_args_to_skip;\n-  else if (old_node->clone.combined_args_to_skip)\n-    {\n-      int newi = 0, oldi = 0;\n-      tree arg;\n-      bitmap new_args_to_skip = BITMAP_GGC_ALLOC ();\n-      struct cgraph_node *orig_node;\n-      for (orig_node = old_node; orig_node->clone_of; orig_node = orig_node->clone_of)\n-        ;\n-      for (arg = DECL_ARGUMENTS (orig_node->symbol.decl);\n-\t   arg; arg = DECL_CHAIN (arg), oldi++)\n-\t{\n-\t  if (bitmap_bit_p (old_node->clone.combined_args_to_skip, oldi))\n-\t    {\n-\t      bitmap_set_bit (new_args_to_skip, oldi);\n-\t      continue;\n-\t    }\n-\t  if (bitmap_bit_p (args_to_skip, newi))\n-\t    bitmap_set_bit (new_args_to_skip, oldi);\n-\t  newi++;\n-\t}\n-      new_node->clone.combined_args_to_skip = new_args_to_skip;\n-    }\n-  else\n-    new_node->clone.combined_args_to_skip = args_to_skip;\n-  new_node->symbol.externally_visible = 0;\n-  new_node->local.local = 1;\n-  new_node->lowered = true;\n-\n-  cgraph_call_node_duplication_hooks (old_node, new_node);\n-\n-\n-  return new_node;\n-}\n-\n /* NODE is no longer nested function; update cgraph accordingly.  */\n void\n cgraph_unnest_node (struct cgraph_node *node)"}, {"sha": "ad1b258d485c1d910398d8b745c361b2511d87d2", "filename": "gcc/cgraph.h", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=66a20fc2a7de31a268cfe5f87ffe42255d815c32", "patch": "@@ -500,8 +500,6 @@ void dump_cgraph_node (FILE *, struct cgraph_node *);\n void debug_cgraph_node (struct cgraph_node *);\n void cgraph_remove_edge (struct cgraph_edge *);\n void cgraph_remove_node (struct cgraph_node *);\n-struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n-bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);\n void cgraph_release_function_body (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n@@ -511,31 +509,23 @@ struct cgraph_edge *cgraph_create_indirect_edge (struct cgraph_node *, gimple,\n \t\t\t\t\t\t int, gcov_type, int);\n struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n struct cgraph_node * cgraph_create_node (tree);\n+struct cgraph_node * cgraph_create_empty_node (void);\n struct cgraph_node * cgraph_get_create_node (tree);\n struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, tree, tree);\n struct cgraph_node *cgraph_node_for_asm (tree);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, gimple);\n void cgraph_set_call_stmt (struct cgraph_edge *, gimple);\n-void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);\n-void cgraph_create_edge_including_clones (struct cgraph_node *,\n-\t\t\t\t\t  struct cgraph_node *,\n-\t\t\t\t\t  gimple, gimple, gcov_type, int,\n-\t\t\t\t\t  cgraph_inline_failed_t);\n void cgraph_update_edges_for_call_stmt (gimple, tree, gimple);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n-struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n-\t\t\t\t\tstruct cgraph_node *, gimple,\n-\t\t\t\t\tunsigned, gcov_type, int, bool);\n-struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n-\t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *,\n-\t\t\t\t\tbool);\n struct cgraph_node *cgraph_create_function_alias (tree, tree);\n-void cgraph_call_node_duplication_hooks (struct cgraph_node *node1,\n-\t\t\t\t\t struct cgraph_node *node2);\n+void cgraph_call_node_duplication_hooks (struct cgraph_node *,\n+\t\t\t\t\t struct cgraph_node *);\n+void cgraph_call_edge_duplication_hooks (struct cgraph_edge *,\n+\t\t\t\t         struct cgraph_edge *);\n \n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n void cgraph_make_edge_direct (struct cgraph_edge *, struct cgraph_node *);\n@@ -547,16 +537,10 @@ void cgraph_unnest_node (struct cgraph_node *);\n enum availability cgraph_function_body_availability (struct cgraph_node *);\n void cgraph_add_new_function (tree, bool);\n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n-struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n-\t\t\t                          VEC(cgraph_edge_p,heap)*,\n-\t\t\t                          VEC(ipa_replace_map_p,gc)* tree_map,\n-\t\t\t                          bitmap args_to_skip,\n-\t\t\t\t\t\t  const char *clone_name);\n \n void cgraph_set_nothrow_flag (struct cgraph_node *, bool);\n void cgraph_set_const_flag (struct cgraph_node *, bool, bool);\n void cgraph_set_pure_flag (struct cgraph_node *, bool, bool);\n-tree clone_function_name (tree decl, const char *);\n bool cgraph_node_cannot_return (struct cgraph_node *);\n bool cgraph_edge_cannot_lead_to_return (struct cgraph_edge *);\n bool cgraph_will_be_removed_from_program_if_no_direct_calls\n@@ -610,6 +594,32 @@ void cgraph_finalize_function (tree, bool);\n void finalize_compilation_unit (void);\n void compile (void);\n void init_cgraph (void);\n+bool cgraph_process_new_functions (void);\n+void cgraph_process_same_body_aliases (void);\n+void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias);\n+\n+/* In cgraphclones.c  */\n+\n+struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n+\t\t\t\t\tstruct cgraph_node *, gimple,\n+\t\t\t\t\tunsigned, gcov_type, int, bool);\n+struct cgraph_node * cgraph_clone_node (struct cgraph_node *, tree, gcov_type,\n+\t\t\t\t\tint, bool, VEC(cgraph_edge_p,heap) *,\n+\t\t\t\t\tbool);\n+tree clone_function_name (tree decl, const char *);\n+struct cgraph_node * cgraph_create_virtual_clone (struct cgraph_node *old_node,\n+\t\t\t                          VEC(cgraph_edge_p,heap)*,\n+\t\t\t                          VEC(ipa_replace_map_p,gc)* tree_map,\n+\t\t\t                          bitmap args_to_skip,\n+\t\t\t\t\t\t  const char *clone_name);\n+struct cgraph_node *cgraph_find_replacement_node (struct cgraph_node *);\n+bool cgraph_remove_node_and_inline_clones (struct cgraph_node *, struct cgraph_node *);\n+void cgraph_set_call_stmt_including_clones (struct cgraph_node *, gimple, gimple);\n+void cgraph_create_edge_including_clones (struct cgraph_node *,\n+\t\t\t\t\t  struct cgraph_node *,\n+\t\t\t\t\t  gimple, gimple, gcov_type, int,\n+\t\t\t\t\t  cgraph_inline_failed_t);\n+void cgraph_materialize_all_clones (void);\n struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n \t\ttree, VEC(cgraph_edge_p,heap)*, bitmap);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n@@ -619,10 +629,6 @@ struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tbasic_block, const char *);\n void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*,\n \t\t\t       bool, bitmap, bool, bitmap, basic_block);\n-bool cgraph_process_new_functions (void);\n-void cgraph_process_same_body_aliases (void);\n-void fixup_same_cpp_alias_visibility (symtab_node node, symtab_node target, tree alias);\n-\n \n /* In cgraphbuild.c  */\n unsigned int rebuild_cgraph_edges (void);"}, {"sha": "4c44d91af51d2fc6582e02ddb45a0a7d2c2752a6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 0, "deletions": 367, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a20fc2a7de31a268cfe5f87ffe42255d815c32/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=66a20fc2a7de31a268cfe5f87ffe42255d815c32", "patch": "@@ -1917,373 +1917,6 @@ init_cgraph (void)\n     cgraph_dump_file = dump_begin (TDI_cgraph, NULL);\n }\n \n-/* The edges representing the callers of the NEW_VERSION node were\n-   fixed by cgraph_function_versioning (), now the call_expr in their\n-   respective tree code should be updated to call the NEW_VERSION.  */\n-\n-static void\n-update_call_expr (struct cgraph_node *new_version)\n-{\n-  struct cgraph_edge *e;\n-\n-  gcc_assert (new_version);\n-\n-  /* Update the call expr on the edges to call the new version.  */\n-  for (e = new_version->callers; e; e = e->next_caller)\n-    {\n-      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->symbol.decl);\n-      gimple_call_set_fndecl (e->call_stmt, new_version->symbol.decl);\n-      maybe_clean_eh_stmt_fn (inner_function, e->call_stmt);\n-    }\n-}\n-\n-\n-/* Create a new cgraph node which is the new version of\n-   OLD_VERSION node.  REDIRECT_CALLERS holds the callers\n-   edges which should be redirected to point to\n-   NEW_VERSION.  ALL the callees edges of OLD_VERSION\n-   are cloned to the new version node.  Return the new\n-   version node. \n-\n-   If non-NULL BLOCK_TO_COPY determine what basic blocks \n-   was copied to prevent duplications of calls that are dead\n-   in the clone.  */\n-\n-struct cgraph_node *\n-cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n-\t\t\t\t tree new_decl,\n-\t\t\t\t VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t\t bitmap bbs_to_copy)\n- {\n-   struct cgraph_node *new_version;\n-   struct cgraph_edge *e;\n-   unsigned i;\n-\n-   gcc_assert (old_version);\n-\n-   new_version = cgraph_create_node (new_decl);\n-\n-   new_version->analyzed = old_version->analyzed;\n-   new_version->local = old_version->local;\n-   new_version->symbol.externally_visible = false;\n-   new_version->local.local = old_version->analyzed;\n-   new_version->global = old_version->global;\n-   new_version->rtl = old_version->rtl;\n-   new_version->count = old_version->count;\n-\n-   for (e = old_version->callees; e; e=e->next_callee)\n-     if (!bbs_to_copy\n-\t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n-       cgraph_clone_edge (e, new_version, e->call_stmt,\n-\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n-\t\t\t  CGRAPH_FREQ_BASE,\n-\t\t\t  true);\n-   for (e = old_version->indirect_calls; e; e=e->next_callee)\n-     if (!bbs_to_copy\n-\t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n-       cgraph_clone_edge (e, new_version, e->call_stmt,\n-\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n-\t\t\t  CGRAPH_FREQ_BASE,\n-\t\t\t  true);\n-   FOR_EACH_VEC_ELT (cgraph_edge_p, redirect_callers, i, e)\n-     {\n-       /* Redirect calls to the old version node to point to its new\n-\t  version.  */\n-       cgraph_redirect_edge_callee (e, new_version);\n-     }\n-\n-   cgraph_call_node_duplication_hooks (old_version, new_version);\n-\n-   return new_version;\n- }\n-\n- /* Perform function versioning.\n-    Function versioning includes copying of the tree and\n-    a callgraph update (creating a new cgraph node and updating\n-    its callees and callers).\n-\n-    REDIRECT_CALLERS varray includes the edges to be redirected\n-    to the new version.\n-\n-    TREE_MAP is a mapping of tree nodes we want to replace with\n-    new ones (according to results of prior analysis).\n-    OLD_VERSION_NODE is the node that is versioned.\n-\n-    If non-NULL ARGS_TO_SKIP determine function parameters to remove\n-    from new version.\n-    If SKIP_RETURN is true, the new version will return void.\n-    If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.\n-    If non_NULL NEW_ENTRY determine new entry BB of the clone.\n-\n-    Return the new version's cgraph node.  */\n-\n-struct cgraph_node *\n-cgraph_function_versioning (struct cgraph_node *old_version_node,\n-\t\t\t    VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t    VEC (ipa_replace_map_p,gc)* tree_map,\n-\t\t\t    bitmap args_to_skip,\n-\t\t\t    bool skip_return,\n-\t\t\t    bitmap bbs_to_copy,\n-\t\t\t    basic_block new_entry_block,\n-\t\t\t    const char *clone_name)\n-{\n-  tree old_decl = old_version_node->symbol.decl;\n-  struct cgraph_node *new_version_node = NULL;\n-  tree new_decl;\n-\n-  if (!tree_versionable_function_p (old_decl))\n-    return NULL;\n-\n-  gcc_assert (old_version_node->local.can_change_signature || !args_to_skip);\n-\n-  /* Make a new FUNCTION_DECL tree node for the new version. */\n-  if (!args_to_skip && !skip_return)\n-    new_decl = copy_node (old_decl);\n-  else\n-    new_decl\n-      = build_function_decl_skip_args (old_decl, args_to_skip, skip_return);\n-\n-  /* Generate a new name for the new version. */\n-  DECL_NAME (new_decl) = clone_function_name (old_decl, clone_name);\n-  SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));\n-  SET_DECL_RTL (new_decl, NULL);\n-\n-  /* When the old decl was a con-/destructor make sure the clone isn't.  */\n-  DECL_STATIC_CONSTRUCTOR(new_decl) = 0;\n-  DECL_STATIC_DESTRUCTOR(new_decl) = 0;\n-\n-  /* Create the new version's call-graph node.\n-     and update the edges of the new node. */\n-  new_version_node =\n-    cgraph_copy_node_for_versioning (old_version_node, new_decl,\n-\t\t\t\t     redirect_callers, bbs_to_copy);\n-\n-  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip,\n-\t\t\t    skip_return, bbs_to_copy, new_entry_block);\n-\n-  /* Update the new version's properties.\n-     Make The new version visible only within this translation unit.  Make sure\n-     that is not weak also.\n-     ??? We cannot use COMDAT linkage because there is no\n-     ABI support for this.  */\n-  symtab_make_decl_local (new_version_node->symbol.decl);\n-  DECL_VIRTUAL_P (new_version_node->symbol.decl) = 0;\n-  new_version_node->symbol.externally_visible = 0;\n-  new_version_node->local.local = 1;\n-  new_version_node->lowered = true;\n-\n-  /* Update the call_expr on the edges to call the new version node. */\n-  update_call_expr (new_version_node);\n-\n-  cgraph_call_function_insertion_hooks (new_version_node);\n-  return new_version_node;\n-}\n-\n-/* Given virtual clone, turn it into actual clone.  */\n-static void\n-cgraph_materialize_clone (struct cgraph_node *node)\n-{\n-  bitmap_obstack_initialize (NULL);\n-  node->former_clone_of = node->clone_of->symbol.decl;\n-  if (node->clone_of->former_clone_of)\n-    node->former_clone_of = node->clone_of->former_clone_of;\n-  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->clone_of->symbol.decl, node->symbol.decl,\n-  \t\t\t    node->clone.tree_map, true,\n-\t\t\t    node->clone.args_to_skip, false,\n-\t\t\t    NULL, NULL);\n-  if (cgraph_dump_file)\n-    {\n-      dump_function_to_file (node->clone_of->symbol.decl, cgraph_dump_file, dump_flags);\n-      dump_function_to_file (node->symbol.decl, cgraph_dump_file, dump_flags);\n-    }\n-\n-  /* Function is no longer clone.  */\n-  if (node->next_sibling_clone)\n-    node->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n-  if (node->prev_sibling_clone)\n-    node->prev_sibling_clone->next_sibling_clone = node->next_sibling_clone;\n-  else\n-    node->clone_of->clones = node->next_sibling_clone;\n-  node->next_sibling_clone = NULL;\n-  node->prev_sibling_clone = NULL;\n-  if (!node->clone_of->analyzed && !node->clone_of->clones)\n-    {\n-      cgraph_release_function_body (node->clone_of);\n-      cgraph_node_remove_callees (node->clone_of);\n-      ipa_remove_all_references (&node->clone_of->symbol.ref_list);\n-    }\n-  node->clone_of = NULL;\n-  bitmap_obstack_release (NULL);\n-}\n-\n-/* If necessary, change the function declaration in the call statement\n-   associated with E so that it corresponds to the edge callee.  */\n-\n-gimple\n-cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n-{\n-  tree decl = gimple_call_fndecl (e->call_stmt);\n-  gimple new_stmt;\n-  gimple_stmt_iterator gsi;\n-#ifdef ENABLE_CHECKING\n-  struct cgraph_node *node;\n-#endif\n-\n-  if (e->indirect_unknown_callee\n-      || decl == e->callee->symbol.decl)\n-    return e->call_stmt;\n-\n-#ifdef ENABLE_CHECKING\n-  if (decl)\n-    {\n-      node = cgraph_get_node (decl);\n-      gcc_assert (!node || !node->clone.combined_args_to_skip);\n-    }\n-#endif\n-\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \"updating call of %s/%i -> %s/%i: \",\n-\t       xstrdup (cgraph_node_name (e->caller)), e->caller->uid,\n-\t       xstrdup (cgraph_node_name (e->callee)), e->callee->uid);\n-      print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n-      if (e->callee->clone.combined_args_to_skip)\n-\t{\n-\t  fprintf (cgraph_dump_file, \" combined args to skip: \");\n-\t  dump_bitmap (cgraph_dump_file,\n-\t\t       e->callee->clone.combined_args_to_skip);\n-\t}\n-    }\n-\n-  if (e->callee->clone.combined_args_to_skip)\n-    {\n-      int lp_nr;\n-\n-      new_stmt\n-\t= gimple_call_copy_skip_args (e->call_stmt,\n-\t\t\t\t      e->callee->clone.combined_args_to_skip);\n-      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n-\n-      if (gimple_vdef (new_stmt)\n-\t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n-\tSSA_NAME_DEF_STMT (gimple_vdef (new_stmt)) = new_stmt;\n-\n-      gsi = gsi_for_stmt (e->call_stmt);\n-      gsi_replace (&gsi, new_stmt, false);\n-      /* We need to defer cleaning EH info on the new statement to\n-         fixup-cfg.  We may not have dominator information at this point\n-\t and thus would end up with unreachable blocks and have no way\n-\t to communicate that we need to run CFG cleanup then.  */\n-      lp_nr = lookup_stmt_eh_lp (e->call_stmt);\n-      if (lp_nr != 0)\n-\t{\n-\t  remove_stmt_from_eh_lp (e->call_stmt);\n-\t  add_stmt_to_eh_lp (new_stmt, lp_nr);\n-\t}\n-    }\n-  else\n-    {\n-      new_stmt = e->call_stmt;\n-      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n-      update_stmt (new_stmt);\n-    }\n-\n-  cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt);\n-\n-  if (cgraph_dump_file)\n-    {\n-      fprintf (cgraph_dump_file, \"  updated to:\");\n-      print_gimple_stmt (cgraph_dump_file, e->call_stmt, 0, dump_flags);\n-    }\n-  return new_stmt;\n-}\n-\n-/* Once all functions from compilation unit are in memory, produce all clones\n-   and update all calls.  We might also do this on demand if we don't want to\n-   bring all functions to memory prior compilation, but current WHOPR\n-   implementation does that and it is is bit easier to keep everything right in\n-   this order.  */\n-static void\n-cgraph_materialize_all_clones (void)\n-{\n-  struct cgraph_node *node;\n-  bool stabilized = false;\n-\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Materializing clones\\n\");\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n-#endif\n-\n-  /* We can also do topological order, but number of iterations should be\n-     bounded by number of IPA passes since single IPA pass is probably not\n-     going to create clones of clones it created itself.  */\n-  while (!stabilized)\n-    {\n-      stabilized = true;\n-      FOR_EACH_FUNCTION (node)\n-        {\n-\t  if (node->clone_of && node->symbol.decl != node->clone_of->symbol.decl\n-\t      && !gimple_has_body_p (node->symbol.decl))\n-\t    {\n-\t      if (gimple_has_body_p (node->clone_of->symbol.decl))\n-\t        {\n-\t\t  if (cgraph_dump_file)\n-\t\t    {\n-\t\t      fprintf (cgraph_dump_file, \"cloning %s to %s\\n\",\n-\t\t\t       xstrdup (cgraph_node_name (node->clone_of)),\n-\t\t\t       xstrdup (cgraph_node_name (node)));\n-\t\t      if (node->clone.tree_map)\n-\t\t        {\n-\t\t\t  unsigned int i;\n-\t\t          fprintf (cgraph_dump_file, \"   replace map: \");\n-\t\t\t  for (i = 0; i < VEC_length (ipa_replace_map_p,\n-\t\t\t  \t\t\t      node->clone.tree_map);\n-\t\t\t\t\t\t      i++)\n-\t\t\t    {\n-\t\t\t      struct ipa_replace_map *replace_info;\n-\t\t\t      replace_info = VEC_index (ipa_replace_map_p,\n-\t\t\t      \t\t\t\tnode->clone.tree_map,\n-\t\t\t\t\t\t\ti);\n-\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->old_tree, 0);\n-\t\t\t      fprintf (cgraph_dump_file, \" -> \");\n-\t\t\t      print_generic_expr (cgraph_dump_file, replace_info->new_tree, 0);\n-\t\t\t      fprintf (cgraph_dump_file, \"%s%s;\",\n-\t\t\t      \t       replace_info->replace_p ? \"(replace)\":\"\",\n-\t\t\t\t       replace_info->ref_p ? \"(ref)\":\"\");\n-\t\t\t    }\n-\t\t\t  fprintf (cgraph_dump_file, \"\\n\");\n-\t\t\t}\n-\t\t      if (node->clone.args_to_skip)\n-\t\t\t{\n-\t\t          fprintf (cgraph_dump_file, \"   args_to_skip: \");\n-\t\t          dump_bitmap (cgraph_dump_file, node->clone.args_to_skip);\n-\t\t\t}\n-\t\t      if (node->clone.args_to_skip)\n-\t\t\t{\n-\t\t          fprintf (cgraph_dump_file, \"   combined_args_to_skip:\");\n-\t\t          dump_bitmap (cgraph_dump_file, node->clone.combined_args_to_skip);\n-\t\t\t}\n-\t\t    }\n-\t\t  cgraph_materialize_clone (node);\n-\t\t  stabilized = false;\n-\t        }\n-\t    }\n-\t}\n-    }\n-  FOR_EACH_FUNCTION (node)\n-    if (!node->analyzed && node->callees)\n-      cgraph_node_remove_callees (node);\n-  if (cgraph_dump_file)\n-    fprintf (cgraph_dump_file, \"Materialization Call site updates done.\\n\");\n-#ifdef ENABLE_CHECKING\n-  verify_cgraph ();\n-#endif\n-  cgraph_remove_unreachable_nodes (false, cgraph_dump_file);\n-}\n-\n \n /* Perform simple optimizations based on callgraph.  */\n "}]}