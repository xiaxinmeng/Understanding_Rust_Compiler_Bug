{"sha": "3a840863c276a71a1e3cc123ebcc9d4212491e01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E4NDA4NjNjMjc2YTcxYTFlM2NjMTIzZWJjYzlkNDIxMjQ5MWUwMQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-01-25T18:17:07Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-01-25T18:17:07Z"}, "message": "re PR target/49868 (Implement named address space to place/access data in flash memory)\n\n\tPR target/49868\n\tRename __pgm to __flash.\n\tRename __pgm1 to __flash1.\n\tRename __pgm2 to __flash2.\n\tRename __pgm3 to __flash3.\n\tRename __pgm4 to __flash4.\n\tRename __pgm5 to __flash5.\n\tRename __pgmx to __memx.\n\t* doc/extend.texi (AVR Named Address Spaces)\n\tRename address space names as indicated above.\n\t* config/avr/avr.c (avr_addrspace): Ditto.\n\t* config/avr/avr-protos.h\n\t(avr_mem_pgmx_p): Rename to avr_mem_memx_p.\n\t(avr_mem_pgm_p): Rename to avr_mem_flash_p.\n\t* config/avr/predicates.md: Ditto.\n\t* config/avr/avr.c Ditto, and\n\t(avr_decl_pgmx_p): Rename to avr_decl_memx_p.\n\t(avr_decl_pgm_p): Rename to avr_decl_flash_p.\n\t* config/avr/avr.h (ADDR_SPACE_PGM): Rename to ADDR_SPACE_FLASH.\n\t(ADDR_SPACE_PGM1): Rename to ADDR_SPACE_FLASH1.\n\t(ADDR_SPACE_PGM2): Rename to ADDR_SPACE_FLASH2.\n\t(ADDR_SPACE_PGM3): Rename to ADDR_SPACE_FLASH3.\n\t(ADDR_SPACE_PGM4): Rename to ADDR_SPACE_FLASH4.\n\t(ADDR_SPACE_PGM5): Rename to ADDR_SPACE_FLASH5.\n\t(ADDR_SPACE_PGMX): Rename to ADDR_SPACE_MEMX.\n\t* config/avr/avr.c: Ditto.\n\t* config/avr/avr.md: Ditto.\n\nFrom-SVN: r183529", "tree": {"sha": "c3b9e26e4427fbc42b576378b2fb037f9047b3ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3b9e26e4427fbc42b576378b2fb037f9047b3ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a840863c276a71a1e3cc123ebcc9d4212491e01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a840863c276a71a1e3cc123ebcc9d4212491e01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a840863c276a71a1e3cc123ebcc9d4212491e01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a840863c276a71a1e3cc123ebcc9d4212491e01/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5a5c890825b2792696370183132cfba6727f1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5a5c890825b2792696370183132cfba6727f1c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5a5c890825b2792696370183132cfba6727f1c0"}], "stats": {"total": 238, "additions": 135, "deletions": 103}, "files": [{"sha": "fc98fb42afb838389126330439456dc4db052000", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -1,3 +1,35 @@\n+2012-01-25  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\tRename __pgm to __flash.\n+\tRename __pgm1 to __flash1.\n+\tRename __pgm2 to __flash2.\n+\tRename __pgm3 to __flash3.\n+\tRename __pgm4 to __flash4.\n+\tRename __pgm5 to __flash5.\n+\tRename __pgmx to __memx.\n+\t* doc/extend.texi (AVR Named Address Spaces)\n+\tRename address space names as indicated above.\n+\t* config/avr/avr.c (avr_addrspace): Ditto.\n+\n+\t* config/avr/avr-protos.h\n+\t(avr_mem_pgmx_p): Rename to avr_mem_memx_p.\n+\t(avr_mem_pgm_p): Rename to avr_mem_flash_p.\n+\t* config/avr/predicates.md: Ditto.\n+\t* config/avr/avr.c Ditto, and\n+\t(avr_decl_pgmx_p): Rename to avr_decl_memx_p.\n+\t(avr_decl_pgm_p): Rename to avr_decl_flash_p.\n+\n+\t* config/avr/avr.h (ADDR_SPACE_PGM): Rename to ADDR_SPACE_FLASH.\n+\t(ADDR_SPACE_PGM1): Rename to ADDR_SPACE_FLASH1.\n+\t(ADDR_SPACE_PGM2): Rename to ADDR_SPACE_FLASH2.\n+\t(ADDR_SPACE_PGM3): Rename to ADDR_SPACE_FLASH3.\n+\t(ADDR_SPACE_PGM4): Rename to ADDR_SPACE_FLASH4.\n+\t(ADDR_SPACE_PGM5): Rename to ADDR_SPACE_FLASH5.\n+\t(ADDR_SPACE_PGMX): Rename to ADDR_SPACE_MEMX.\n+\t* config/avr/avr.c: Ditto.\n+\t* config/avr/avr.md: Ditto.\n+\n 2012-01-25  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51992"}, {"sha": "f64dbbf5ae3de6ae69bc82330ebd300a9d4d2c4e", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -120,8 +120,8 @@ extern reg_class_t avr_mode_code_base_reg_class (enum machine_mode, addr_space_t\n extern bool avr_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n extern rtx avr_incoming_return_addr_rtx (void);\n extern rtx avr_legitimize_reload_address (rtx*, enum machine_mode, int, int, int, int, rtx (*)(rtx,int));\n-extern bool avr_mem_pgm_p (rtx);\n-extern bool avr_mem_pgmx_p (rtx);\n+extern bool avr_mem_flash_p (rtx);\n+extern bool avr_mem_memx_p (rtx);\n extern bool avr_load_libgcc_p (rtx);\n extern bool avr_xload_libgcc_p (enum machine_mode);\n #endif /* RTX_CODE */"}, {"sha": "66260876fdebaa643729334f36cab12157731c22", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -83,13 +83,13 @@\n const avr_addrspace_t avr_addrspace[] =\n {\n     { ADDR_SPACE_RAM,  0, 2, \"\"     ,   0 },\n-    { ADDR_SPACE_PGM,  1, 2, \"__pgm\",   0 },\n-    { ADDR_SPACE_PGM1, 1, 2, \"__pgm1\",  1 },\n-    { ADDR_SPACE_PGM2, 1, 2, \"__pgm2\",  2 },\n-    { ADDR_SPACE_PGM3, 1, 2, \"__pgm3\",  3 },\n-    { ADDR_SPACE_PGM4, 1, 2, \"__pgm4\",  4 },\n-    { ADDR_SPACE_PGM5, 1, 2, \"__pgm5\",  5 },\n-    { ADDR_SPACE_PGMX, 1, 3, \"__pgmx\",  0 },\n+    { ADDR_SPACE_FLASH,  1, 2, \"__flash\",   0 },\n+    { ADDR_SPACE_FLASH1, 1, 2, \"__flash1\",  1 },\n+    { ADDR_SPACE_FLASH2, 1, 2, \"__flash2\",  2 },\n+    { ADDR_SPACE_FLASH3, 1, 2, \"__flash3\",  3 },\n+    { ADDR_SPACE_FLASH4, 1, 2, \"__flash4\",  4 },\n+    { ADDR_SPACE_FLASH5, 1, 2, \"__flash5\",  5 },\n+    { ADDR_SPACE_MEMX, 1, 3, \"__memx\",  0 },\n     { 0              , 0, 0, NULL,      0 }\n };\n \n@@ -177,7 +177,7 @@ const struct mcu_type_s *avr_current_device;\n static GTY(()) section *progmem_swtable_section;\n \n /* Unnamed sections associated to __attribute__((progmem)) aka. PROGMEM\n-   or to address space __pgm*.  */\n+   or to address space __flash*.  */\n static GTY(()) section *progmem_section[6];\n \n /* Condition for insns/expanders from avr-dimode.md.  */\n@@ -485,7 +485,7 @@ avr_scalar_mode_supported_p (enum machine_mode mode)\n /* Return TRUE if DECL is a VAR_DECL located in Flash and FALSE, otherwise.  */\n \n static bool\n-avr_decl_pgm_p (tree decl)\n+avr_decl_flash_p (tree decl)\n {\n   if (TREE_CODE (decl) != VAR_DECL\n       || TREE_TYPE (decl) == error_mark_node)\n@@ -501,22 +501,22 @@ avr_decl_pgm_p (tree decl)\n    address space and FALSE, otherwise.  */\n  \n static bool\n-avr_decl_pgmx_p (tree decl)\n+avr_decl_memx_p (tree decl)\n {\n   if (TREE_CODE (decl) != VAR_DECL\n       || TREE_TYPE (decl) == error_mark_node)\n     {\n       return false;\n     }\n \n-  return (ADDR_SPACE_PGMX == TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n+  return (ADDR_SPACE_MEMX == TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n }\n \n \n /* Return TRUE if X is a MEM rtx located in Flash and FALSE, otherwise.  */\n \n bool\n-avr_mem_pgm_p (rtx x)\n+avr_mem_flash_p (rtx x)\n {\n   return (MEM_P (x)\n           && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x)));\n@@ -527,10 +527,10 @@ avr_mem_pgm_p (rtx x)\n    address space and FALSE, otherwise.  */\n \n bool\n-avr_mem_pgmx_p (rtx x)\n+avr_mem_memx_p (rtx x)\n {\n   return (MEM_P (x)\n-          && ADDR_SPACE_PGMX == MEM_ADDR_SPACE (x));\n+          && ADDR_SPACE_MEMX == MEM_ADDR_SPACE (x));\n }\n \n \n@@ -2432,7 +2432,7 @@ avr_load_libgcc_p (rtx op)\n         \n   return (n_bytes > 2\n           && !AVR_HAVE_LPMX\n-          && avr_mem_pgm_p (op));\n+          && avr_mem_flash_p (op));\n }\n \n /* Return true if a value of mode MODE is read by __xload_* function.  */\n@@ -2802,8 +2802,8 @@ output_movqi (rtx insn, rtx operands[], int *l)\n   rtx src = operands[1];\n   int *real_l = l;\n   \n-  if (avr_mem_pgm_p (src)\n-      || avr_mem_pgm_p (dest))\n+  if (avr_mem_flash_p (src)\n+      || avr_mem_flash_p (dest))\n     {\n       return avr_out_lpm (insn, operands, real_l);\n     }\n@@ -2853,8 +2853,8 @@ output_movhi (rtx insn, rtx xop[], int *plen)\n \n   gcc_assert (GET_MODE_SIZE (GET_MODE (dest)) == 2);\n   \n-  if (avr_mem_pgm_p (src)\n-      || avr_mem_pgm_p (dest))\n+  if (avr_mem_flash_p (src)\n+      || avr_mem_flash_p (dest))\n     {\n       return avr_out_lpm (insn, xop, plen);\n     }\n@@ -3424,8 +3424,8 @@ output_movsisf (rtx insn, rtx operands[], int *l)\n   rtx src = operands[1];\n   int *real_l = l;\n   \n-  if (avr_mem_pgm_p (src)\n-      || avr_mem_pgm_p (dest))\n+  if (avr_mem_flash_p (src)\n+      || avr_mem_flash_p (dest))\n     {\n       return avr_out_lpm (insn, operands, real_l);\n     }\n@@ -3725,8 +3725,8 @@ avr_out_movpsi (rtx insn, rtx *op, int *plen)\n   rtx dest = op[0];\n   rtx src = op[1];\n   \n-  if (avr_mem_pgm_p (src)\n-      || avr_mem_pgm_p (dest))\n+  if (avr_mem_flash_p (src)\n+      || avr_mem_flash_p (dest))\n     {\n       return avr_out_lpm (insn, op, plen);\n     }\n@@ -6810,10 +6810,10 @@ avr_progmem_p (tree decl, tree attributes)\n   if (TREE_CODE (decl) != VAR_DECL)\n     return 0;\n \n-  if (avr_decl_pgmx_p (decl))\n+  if (avr_decl_memx_p (decl))\n     return 2;\n \n-  if (avr_decl_pgm_p (decl))\n+  if (avr_decl_flash_p (decl))\n     return 1;\n \n   if (NULL_TREE\n@@ -6878,8 +6878,8 @@ avr_nonconst_pointer_addrspace (tree typ)\n }\n \n \n-/* Sanity check NODE so that all pointers targeting address space AS1\n-   go along with CONST qualifier.  Writing to this address space should\n+/* Sanity check NODE so that all pointers targeting non-generic addres spaces\n+   go along with CONST qualifier.  Writing to these address spaces should\n    be detected and complained about as early as possible.  */\n \n static bool\n@@ -7195,11 +7195,11 @@ avr_section_type_flags (tree decl, const char *name, int reloc)\n       addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));\n \n       /* Attribute progmem puts data in generic address space.\n-         Set section flags as if it was in __pgm to get the right\n+         Set section flags as if it was in __flash to get the right\n          section prefix in the remainder.  */\n \n       if (ADDR_SPACE_GENERIC_P (as))\n-        as = ADDR_SPACE_PGM;\n+        as = ADDR_SPACE_FLASH;\n \n       flags |= as * SECTION_MACH_DEP;\n       flags &= ~SECTION_WRITE;\n@@ -7244,7 +7244,7 @@ avr_encode_section_info (tree decl, rtx rtl, int new_decl_p)\n          patch address space.  */\n       \n       if (-1 == avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n-        as = ADDR_SPACE_PGM;\n+        as = ADDR_SPACE_FLASH;\n \n       AVR_SYMBOL_SET_ADDR_SPACE (sym, as);\n     }\n@@ -9469,12 +9469,12 @@ avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n     case ADDR_SPACE_GENERIC:\n       return avr_legitimate_address_p (mode, x, strict);\n \n-    case ADDR_SPACE_PGM:\n-    case ADDR_SPACE_PGM1:\n-    case ADDR_SPACE_PGM2:\n-    case ADDR_SPACE_PGM3:\n-    case ADDR_SPACE_PGM4:\n-    case ADDR_SPACE_PGM5:\n+    case ADDR_SPACE_FLASH:\n+    case ADDR_SPACE_FLASH1:\n+    case ADDR_SPACE_FLASH2:\n+    case ADDR_SPACE_FLASH3:\n+    case ADDR_SPACE_FLASH4:\n+    case ADDR_SPACE_FLASH5:\n \n       switch (GET_CODE (x))\n         {\n@@ -9490,9 +9490,9 @@ avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n           break;\n         }\n \n-      break; /* PGM */\n+      break; /* FLASH */\n       \n-    case ADDR_SPACE_PGMX:\n+    case ADDR_SPACE_MEMX:\n       if (REG_P (x))\n         ok = (!strict\n               && can_create_pseudo_p());\n@@ -9508,7 +9508,7 @@ avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n                 && REGNO (lo) == REG_Z);\n         }\n       \n-      break; /* PGMX */\n+      break; /* MEMX */\n     }\n \n   if (avr_log.legitimate_address_p)\n@@ -9567,8 +9567,8 @@ avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n \n   /* Up-casting from 16-bit to 24-bit pointer.  */\n   \n-  if (as_from != ADDR_SPACE_PGMX\n-      && as_to == ADDR_SPACE_PGMX)\n+  if (as_from != ADDR_SPACE_MEMX\n+      && as_to == ADDR_SPACE_MEMX)\n     {\n       int msb;\n       rtx sym = src;\n@@ -9584,9 +9584,9 @@ avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n          address space.  */\n \n       if (SYMBOL_REF == GET_CODE (sym)\n-          && ADDR_SPACE_PGM == AVR_SYMBOL_GET_ADDR_SPACE (sym))\n+          && ADDR_SPACE_FLASH == AVR_SYMBOL_GET_ADDR_SPACE (sym))\n         {\n-          as_from = ADDR_SPACE_PGM;\n+          as_from = ADDR_SPACE_FLASH;\n         }\n \n       /* Linearize memory: RAM has bit 23 set.  */\n@@ -9606,8 +9606,8 @@ avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n \n   /* Down-casting from 24-bit to 16-bit throws away the high byte.  */\n \n-  if (as_from == ADDR_SPACE_PGMX\n-      && as_to != ADDR_SPACE_PGMX)\n+  if (as_from == ADDR_SPACE_MEMX\n+      && as_to != ADDR_SPACE_MEMX)\n     {\n       rtx new_src = gen_reg_rtx (Pmode);\n \n@@ -9651,7 +9651,7 @@ avr_emit_movmemhi (rtx *xop)\n   rtx loop_reg, addr0, addr1, a_src, a_dest, insn, xas, reg_x;\n   rtx a_hi8 = NULL_RTX;\n \n-  if (avr_mem_pgm_p (xop[0]))\n+  if (avr_mem_flash_p (xop[0]))\n     return false;\n \n   if (!CONST_INT_P (xop[2]))\n@@ -9666,7 +9666,7 @@ avr_emit_movmemhi (rtx *xop)\n \n   if (PSImode == GET_MODE (a_src))\n     {\n-      gcc_assert (as == ADDR_SPACE_PGMX);\n+      gcc_assert (as == ADDR_SPACE_MEMX);\n \n       loop_mode = (count < 0x100) ? QImode : HImode;\n       loop_reg = gen_rtx_REG (loop_mode, 24);\n@@ -9687,7 +9687,7 @@ avr_emit_movmemhi (rtx *xop)\n         }\n       else if (!ADDR_SPACE_GENERIC_P (as))\n         {\n-          as = ADDR_SPACE_PGM;\n+          as = ADDR_SPACE_FLASH;\n         }\n       \n       addr1 = a_src;\n@@ -9718,7 +9718,7 @@ avr_emit_movmemhi (rtx *xop)\n \n   gcc_assert (TMP_REGNO == LPM_REGNO);\n \n-  if (as != ADDR_SPACE_PGMX)\n+  if (as != ADDR_SPACE_MEMX)\n     {\n       /* Load instruction ([E]LPM or LD) is known at compile time:\n          Do the copy-loop inline.  */\n@@ -9792,7 +9792,7 @@ avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n       avr_asm_len (\"ld %6,%a1+\", xop, plen, 1);\n       break;\n       \n-    case ADDR_SPACE_PGM:\n+    case ADDR_SPACE_FLASH:\n \n       if (AVR_HAVE_LPMX)\n         avr_asm_len (\"lpm %6,%a1+\", xop, plen, 1);\n@@ -9801,11 +9801,11 @@ avr_out_movmem (rtx insn ATTRIBUTE_UNUSED, rtx *xop, int *plen)\n                      \"adiw %1,1\", xop, plen, 2);\n       break;\n       \n-    case ADDR_SPACE_PGM1:\n-    case ADDR_SPACE_PGM2:\n-    case ADDR_SPACE_PGM3:\n-    case ADDR_SPACE_PGM4:\n-    case ADDR_SPACE_PGM5:\n+    case ADDR_SPACE_FLASH1:\n+    case ADDR_SPACE_FLASH2:\n+    case ADDR_SPACE_FLASH3:\n+    case ADDR_SPACE_FLASH4:\n+    case ADDR_SPACE_FLASH5:\n \n       if (AVR_HAVE_ELPMX)\n         avr_asm_len (\"elpm %6,%a1+\", xop, plen, 1);"}, {"sha": "55eca491da216171307b137237e30b23fd7112b0", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -158,13 +158,13 @@ extern const avr_addrspace_t avr_addrspace[];\n enum\n   {\n     ADDR_SPACE_RAM,\n-    ADDR_SPACE_PGM,\n-    ADDR_SPACE_PGM1,\n-    ADDR_SPACE_PGM2,\n-    ADDR_SPACE_PGM3,\n-    ADDR_SPACE_PGM4,\n-    ADDR_SPACE_PGM5,\n-    ADDR_SPACE_PGMX\n+    ADDR_SPACE_FLASH,\n+    ADDR_SPACE_FLASH1,\n+    ADDR_SPACE_FLASH2,\n+    ADDR_SPACE_FLASH3,\n+    ADDR_SPACE_FLASH4,\n+    ADDR_SPACE_FLASH5,\n+    ADDR_SPACE_MEMX\n   };\n \n #define TARGET_CPU_CPP_BUILTINS()\tavr_cpu_cpp_builtins (pfile)"}, {"sha": "0c477943d1ec6601ea7fc1b05fa3bc7599589443", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -367,7 +367,7 @@\n     operands[3] = gen_rtx_REG (HImode, REG_Z);\n     operands[2] = force_operand (XEXP (operands[1], 0), NULL_RTX);\n     operands[1] = replace_equiv_address (operands[1], operands[3]);\n-    set_mem_addr_space (operands[1], ADDR_SPACE_PGM);\n+    set_mem_addr_space (operands[1], ADDR_SPACE_FLASH);\n   })\n     \n (define_insn \"load_<mode>_libgcc\"\n@@ -391,7 +391,7 @@\n    (clobber (reg:HI REG_Z))]\n   \"can_create_pseudo_p()\n    && !avr_xload_libgcc_p (QImode)\n-   && avr_mem_pgmx_p (operands[1])\n+   && avr_mem_memx_p (operands[1])\n    && REG_P (XEXP (operands[1], 0))\"\n   { gcc_unreachable(); }\n   \"&& 1\"\n@@ -416,7 +416,7 @@\n    (clobber (reg:QI 21))\n    (clobber (reg:HI REG_Z))]\n   \"can_create_pseudo_p()\n-   && avr_mem_pgmx_p (operands[1])\n+   && avr_mem_memx_p (operands[1])\n    && REG_P (XEXP (operands[1], 0))\"\n   { gcc_unreachable(); }\n   \"&& 1\"\n@@ -442,7 +442,7 @@\n     DONE;\n   })\n \n-;; Move value from address space pgmx to a register\n+;; Move value from address space memx to a register\n ;; These insns must be prior to respective generic move insn.\n \n (define_insn \"xload_8\"\n@@ -495,7 +495,7 @@\n     rtx dest = operands[0];\n     rtx src  = operands[1]; \n     \n-    if (avr_mem_pgm_p (dest))\n+    if (avr_mem_flash_p (dest))\n       DONE;\n   \n     /* One of the operands has to be in a register.  */\n@@ -506,7 +506,7 @@\n         operands[1] = src = copy_to_mode_reg (<MODE>mode, src);\n       }\n \n-  if (avr_mem_pgmx_p (src))\n+  if (avr_mem_memx_p (src))\n     {\n       rtx addr = XEXP (src, 0);\n \n@@ -682,7 +682,7 @@\n   {\n      rtx addr = XEXP (operands[1], 0);\n \n-     if (!avr_mem_pgm_p (operands[1])\n+     if (!avr_mem_flash_p (operands[1])\n          || !REG_P (addr)\n          || reg_overlap_mentioned_p (addr, operands[0]))\n        {"}, {"sha": "1792a285464440fa1c93d09d52600d8064b64562", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -57,17 +57,17 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE((INTVAL (op)), 0x20, (0x60 - GET_MODE_SIZE(mode)))\")))\n \n-;; Return 1 if OP is a general operand not in program memory\n+;; Return 1 if OP is a general operand not in flash memory\n (define_predicate \"nop_general_operand\"\n   (and (match_operand 0 \"general_operand\")\n-       (match_test \"!avr_mem_pgm_p (op)\")))\n+       (match_test \"!avr_mem_flash_p (op)\")))\n \n ;; Return 1 if OP is an \"ordinary\" general operand, i.e. a general\n ;; operand whose load is not handled by a libgcc call or ELPM.\n (define_predicate \"nox_general_operand\"\n   (and (match_operand 0 \"general_operand\")\n        (not (match_test \"avr_load_libgcc_p (op)\"))\n-       (not (match_test \"avr_mem_pgmx_p (op)\"))))\n+       (not (match_test \"avr_mem_memx_p (op)\"))))\n \n ;; Return 1 if OP is the zero constant for MODE.\n (define_predicate \"const0_operand\""}, {"sha": "b8c4696ced521efd64145872979c516ed0dee602", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a840863c276a71a1e3cc123ebcc9d4212491e01/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=3a840863c276a71a1e3cc123ebcc9d4212491e01", "patch": "@@ -1244,38 +1244,38 @@ needed to locate read-only data in flash memory\n without using (inline) assembler code.\n \n @table @code\n-@item __pgm\n-@cindex @code{__pgm} AVR Named Address Spaces\n-The @code{__pgm} qualifier will locate data in the\n+@item __flash\n+@cindex @code{__flash} AVR Named Address Spaces\n+The @code{__flash} qualifier will locate data in the\n @code{.progmem.data} section. Data will be read using the @code{LPM}\n instruction. Pointers to this address space are 16 bits wide.\n \n-@item __pgm1\n-@item __pgm2\n-@item __pgm3\n-@item __pgm4\n-@item __pgm5\n-@cindex @code{__pgm1} AVR Named Address Spaces\n-@cindex @code{__pgm2} AVR Named Address Spaces\n-@cindex @code{__pgm3} AVR Named Address Spaces\n-@cindex @code{__pgm4} AVR Named Address Spaces\n-@cindex @code{__pgm5} AVR Named Address Spaces\n+@item __flash1\n+@item __flash2\n+@item __flash3\n+@item __flash4\n+@item __flash5\n+@cindex @code{__flash1} AVR Named Address Spaces\n+@cindex @code{__flash2} AVR Named Address Spaces\n+@cindex @code{__flash3} AVR Named Address Spaces\n+@cindex @code{__flash4} AVR Named Address Spaces\n+@cindex @code{__flash5} AVR Named Address Spaces\n These are 16-bit address spaces locating data in section\n @code{.progmem@var{N}.data} where @var{N} refers to\n-address space @code{__pgm@var{N}}.\n+address space @code{__flash@var{N}}.\n The compiler will set the @code{RAMPZ} segment register approptiately \n before reading data by means of the @code{ELPM} instruction.\n \n On devices with less 64@tie{}kiB flash segments as indicated by the address\n space, the compiler will cut down the segment number to a number the\n device actually supports. Counting starts at@tie{}@code{0}\n-for space @code{__pgm}. For example, if you access address space\n-@code{__pgm3} on an ATmega128 device with two 64@tie{}kiB flash segments,\n-the compiler will generate a read from @code{__pgm1}, i.e.@: it\n+for space @code{__flash}. For example, if you access address space\n+@code{__flash3} on an ATmega128 device with two 64@tie{}kiB flash segments,\n+the compiler will generate a read from @code{__flash1}, i.e.@: it\n will load @code{RAMPZ} with@tie{}@code{1} before reading.\n \n-@item __pgmx\n-@cindex @code{__pgmx} AVR Named Address Spaces\n+@item __memx\n+@cindex @code{__memx} AVR Named Address Spaces\n This is a 24-bit address space that linearizes flash and RAM:\n If the high bit of the address is set, data is read from\n RAM using the lower two bytes as RAM address.\n@@ -1288,7 +1288,7 @@ Objects in this address space will be located in @code{.progmem.data}.\n @b{Example}\n \n @example\n-char my_read (const __pgm char ** p)\n+char my_read (const __flash char ** p)\n @{\n     /* p is a pointer to RAM that points to a pointer to flash.\n        The first indirection of p will read that flash pointer\n@@ -1299,7 +1299,7 @@ char my_read (const __pgm char ** p)\n @}\n \n /* Locate array[] in flash memory */\n-const __pgm int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};\n+const __flash int array[] = @{ 3, 5, 7, 11, 13, 17, 19 @};\n \n int i = 1;\n \n@@ -1316,8 +1316,8 @@ The purpose is to facilitate testing if respective address space\n support is available or not:\n \n @example\n-#ifdef __PGM\n-const __pgm int var = 1;\n+#ifdef __FLASH\n+const __flash int var = 1;\n \n int read_i (void)\n @{\n@@ -1332,7 +1332,7 @@ int read_i (void)\n @{\n     return (int) pgm_read_word (&i);\n @}\n-#endif /* __PGM */\n+#endif /* __FLASH */\n @end example\n \n Notice that attribute @ref{AVR Variable Attributes,@code{progmem}}\n@@ -1347,13 +1347,13 @@ from @w{@uref{http://nongnu.org/avr-libc/user-manual,avr-libc}}.\n @itemize\n @item\n Reading across the 64@tie{}KiB section boundary of\n-the @code{__pgm} or @code{__pgm@var{N}} address spaces\n+the @code{__flash} or @code{__flash@var{N}} address spaces\n will show undefined behaviour. The only address space that\n supports reading across the 64@tie{}KiB flash segment boundaries is\n-@code{__pgmx}.\n+@code{__memx}.\n \n @item\n-If you use one if the @code{__pgm@var{N}} address spaces\n+If you use one if the @code{__flash@var{N}} address spaces\n you will have to arrange your linker skript to locate the\n @code{.progmem@var{N}.data} sections according to your needs.\n \n@@ -1372,8 +1372,8 @@ Code like the following is not yet supported because of missing\n support in avr-binutils,\n see @w{@uref{http://sourceware.org/PR13503,PR13503}}.\n @example\n-extern const __pgmx char foo;\n-const __pgmx void *pfoo = &foo;\n+extern const __memx char foo;\n+const __memx void *pfoo = &foo;\n @end example\n The code will throw an assembler warning and the high byte of\n @code{pfoo} will be initialized with@tie{}@code{0}, i.e.@: the"}]}