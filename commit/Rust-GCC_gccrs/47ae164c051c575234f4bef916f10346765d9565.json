{"sha": "47ae164c051c575234f4bef916f10346765d9565", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdhZTE2NGMwNTFjNTc1MjM0ZjRiZWY5MTZmMTAzNDY3NjVkOTU2NQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-05-01T00:02:49Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-05-01T00:02:49Z"}, "message": "selftest: remove \"Yoda ordering\" in assertions\n\ngcc/ChangeLog:\n\t* selftest.c (assert_streq): Rename \"expected\" and \"actual\" to\n\t\"val1\" and \"val2\".  Extend NULL-handling to cover both inputs\n\tsymmetrically, while still requiring both to be non-NULL for a pass.\n\t* selftest.h (assert_streq): Rename \"expected\" and \"actual\" to\n\t\"val1\" and \"val2\".\n\t(ASSERT_EQ): Likewise.\n\t(ASSERT_EQ_AT): Likewise.\n\t(ASSERT_KNOWN_EQ): Likewise.\n\t(ASSERT_KNOWN_EQ_AT): Likewise.\n\t(ASSERT_NE): Likewise.\n\t(ASSERT_MAYBE_NE): Likewise.\n\t(ASSERT_MAYBE_NE_AT): Likewise.\n\t(ASSERT_STREQ): Likewise.  Clarify that both must be non-NULL for\n\tthe assertion to pass.\n\t(ASSERT_STREQ_AT): Likewise.\n\nFrom-SVN: r259782", "tree": {"sha": "760ea48318070f852bfd3d074f8b830bba1bb83e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/760ea48318070f852bfd3d074f8b830bba1bb83e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47ae164c051c575234f4bef916f10346765d9565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ae164c051c575234f4bef916f10346765d9565", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ae164c051c575234f4bef916f10346765d9565", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ae164c051c575234f4bef916f10346765d9565/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe43c635035edcd29eca0a8e3b08d8bcf14d9ba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe43c635035edcd29eca0a8e3b08d8bcf14d9ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe43c635035edcd29eca0a8e3b08d8bcf14d9ba8"}], "stats": {"total": 123, "additions": 74, "deletions": 49}, "files": [{"sha": "84d5bd1d350ae27902d369539d78f0d7654de3e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ae164c051c575234f4bef916f10346765d9565/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ae164c051c575234f4bef916f10346765d9565/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47ae164c051c575234f4bef916f10346765d9565", "patch": "@@ -1,3 +1,21 @@\n+2018-04-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* selftest.c (assert_streq): Rename \"expected\" and \"actual\" to\n+\t\"val1\" and \"val2\".  Extend NULL-handling to cover both inputs\n+\tsymmetrically, while still requiring both to be non-NULL for a pass.\n+\t* selftest.h (assert_streq): Rename \"expected\" and \"actual\" to\n+\t\"val1\" and \"val2\".\n+\t(ASSERT_EQ): Likewise.\n+\t(ASSERT_EQ_AT): Likewise.\n+\t(ASSERT_KNOWN_EQ): Likewise.\n+\t(ASSERT_KNOWN_EQ_AT): Likewise.\n+\t(ASSERT_NE): Likewise.\n+\t(ASSERT_MAYBE_NE): Likewise.\n+\t(ASSERT_MAYBE_NE_AT): Likewise.\n+\t(ASSERT_STREQ): Likewise.  Clarify that both must be non-NULL for\n+\tthe assertion to pass.\n+\t(ASSERT_STREQ_AT): Likewise.\n+\n 2018-04-30  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* doc/invoke.texi (-fpie, -fPIE): Fix grammar and clarify"}, {"sha": "74adc63e65cd004c4d26757511c4422534643dd1", "filename": "gcc/selftest.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ae164c051c575234f4bef916f10346765d9565/gcc%2Fselftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ae164c051c575234f4bef916f10346765d9565/gcc%2Fselftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.c?ref=47ae164c051c575234f4bef916f10346765d9565", "patch": "@@ -63,27 +63,34 @@ fail_formatted (const location &loc, const char *fmt, ...)\n }\n \n /* Implementation detail of ASSERT_STREQ.\n-   Compare val_expected and val_actual with strcmp.  They ought\n-   to be non-NULL; fail gracefully if either are NULL.  */\n+   Compare val1 and val2 with strcmp.  They ought\n+   to be non-NULL; fail gracefully if either or both are NULL.  */\n \n void\n assert_streq (const location &loc,\n-\t      const char *desc_expected, const char *desc_actual,\n-\t      const char *val_expected, const char *val_actual)\n+\t      const char *desc_val1, const char *desc_val2,\n+\t      const char *val1, const char *val2)\n {\n-  /* If val_expected is NULL, the test is buggy.  Fail gracefully.  */\n-  if (val_expected == NULL)\n-    fail_formatted (loc, \"ASSERT_STREQ (%s, %s) expected=NULL\",\n-\t\t    desc_expected, desc_actual);\n-  /* If val_actual is NULL, fail with a custom error message.  */\n-  if (val_actual == NULL)\n-    fail_formatted (loc, \"ASSERT_STREQ (%s, %s) expected=\\\"%s\\\" actual=NULL\",\n-\t\t    desc_expected, desc_actual, val_expected);\n-  if (strcmp (val_expected, val_actual) == 0)\n-    pass (loc, \"ASSERT_STREQ\");\n+  /* If val1 or val2 are NULL, fail with a custom error message.  */\n+  if (val1 == NULL)\n+    if (val2 == NULL)\n+      fail_formatted (loc, \"ASSERT_STREQ (%s, %s) val1=NULL val2=NULL\",\n+\t\t      desc_val1, desc_val2);\n+    else\n+      fail_formatted (loc, \"ASSERT_STREQ (%s, %s) val1=NULL val2=\\\"%s\\\"\",\n+\t\t      desc_val1, desc_val2, val2);\n   else\n-    fail_formatted (loc, \"ASSERT_STREQ (%s, %s) expected=\\\"%s\\\" actual=\\\"%s\\\"\",\n-\t\t    desc_expected, desc_actual, val_expected, val_actual);\n+    if (val2 == NULL)\n+      fail_formatted (loc, \"ASSERT_STREQ (%s, %s) val1=\\\"%s\\\" val2=NULL\",\n+\t\t      desc_val1, desc_val2, val1);\n+    else\n+      {\n+\tif (strcmp (val1, val2) == 0)\n+\t  pass (loc, \"ASSERT_STREQ\");\n+\telse\n+\t  fail_formatted (loc, \"ASSERT_STREQ (%s, %s) val1=\\\"%s\\\" val2=\\\"%s\\\"\",\n+\t\t\t  desc_val1, desc_val2, val1, val2);\n+      }\n }\n \n /* Implementation detail of ASSERT_STR_CONTAINS."}, {"sha": "fc47b2c9ad16d9c9281e1ab1f7d9fefbc35e3128", "filename": "gcc/selftest.h", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ae164c051c575234f4bef916f10346765d9565/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ae164c051c575234f4bef916f10346765d9565/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=47ae164c051c575234f4bef916f10346765d9565", "patch": "@@ -67,8 +67,8 @@ extern void fail_formatted (const location &loc, const char *fmt, ...)\n /* Implementation detail of ASSERT_STREQ.  */\n \n extern void assert_streq (const location &loc,\n-\t\t\t  const char *desc_expected, const char *desc_actual,\n-\t\t\t  const char *val_expected, const char *val_actual);\n+\t\t\t  const char *desc_val1, const char *desc_val2,\n+\t\t\t  const char *val1, const char *val2);\n \n /* Implementation detail of ASSERT_STR_CONTAINS.  */\n \n@@ -263,71 +263,71 @@ extern int num_passes;\n     ::selftest::pass ((LOC), desc_);\t\t\t\t\\\n   SELFTEST_END_STMT\n \n-/* Evaluate EXPECTED and ACTUAL and compare them with ==, calling\n+/* Evaluate VAL1 and VAL2 and compare them with ==, calling\n    ::selftest::pass if they are equal,\n    ::selftest::fail if they are non-equal.  */\n \n-#define ASSERT_EQ(EXPECTED, ACTUAL) \\\n-  ASSERT_EQ_AT ((SELFTEST_LOCATION), (EXPECTED), (ACTUAL))\n+#define ASSERT_EQ(VAL1, VAL2) \\\n+  ASSERT_EQ_AT ((SELFTEST_LOCATION), (VAL1), (VAL2))\n \n /* Like ASSERT_EQ, but treat LOC as the effective location of the\n    selftest.  */\n \n-#define ASSERT_EQ_AT(LOC, EXPECTED, ACTUAL)\t\t       \\\n+#define ASSERT_EQ_AT(LOC, VAL1, VAL2)\t\t       \\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n-  const char *desc_ = \"ASSERT_EQ (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n-  if ((EXPECTED) == (ACTUAL))\t\t\t\t       \\\n+  const char *desc_ = \"ASSERT_EQ (\" #VAL1 \", \" #VAL2 \")\"; \\\n+  if ((VAL1) == (VAL2))\t\t\t\t       \\\n     ::selftest::pass ((LOC), desc_);\t\t\t       \\\n   else\t\t\t\t\t\t\t       \\\n     ::selftest::fail ((LOC), desc_);\t\t\t       \\\n   SELFTEST_END_STMT\n \n-/* Evaluate EXPECTED and ACTUAL and compare them with known_eq, calling\n+/* Evaluate VAL1 and VAL2 and compare them with known_eq, calling\n    ::selftest::pass if they are always equal,\n    ::selftest::fail if they might be non-equal.  */\n \n-#define ASSERT_KNOWN_EQ(EXPECTED, ACTUAL) \\\n-  ASSERT_KNOWN_EQ_AT ((SELFTEST_LOCATION), (EXPECTED), (ACTUAL))\n+#define ASSERT_KNOWN_EQ(VAL1, VAL2) \\\n+  ASSERT_KNOWN_EQ_AT ((SELFTEST_LOCATION), (VAL1), (VAL2))\n \n /* Like ASSERT_KNOWN_EQ, but treat LOC as the effective location of the\n    selftest.  */\n \n-#define ASSERT_KNOWN_EQ_AT(LOC, EXPECTED, ACTUAL)\t\t\t\\\n+#define ASSERT_KNOWN_EQ_AT(LOC, VAL1, VAL2)\t\t\t\\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n-  const char *desc = \"ASSERT_KNOWN_EQ (\" #EXPECTED \", \" #ACTUAL \")\";\t\\\n-  if (known_eq (EXPECTED, ACTUAL))\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_KNOWN_EQ (\" #VAL1 \", \" #VAL2 \")\";\t\\\n+  if (known_eq (VAL1, VAL2))\t\t\t\t\t\\\n     ::selftest::pass ((LOC), desc);\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     ::selftest::fail ((LOC), desc);\t\t\t\t\t\\\n   SELFTEST_END_STMT\n \n-/* Evaluate EXPECTED and ACTUAL and compare them with !=, calling\n+/* Evaluate VAL1 and VAL2 and compare them with !=, calling\n    ::selftest::pass if they are non-equal,\n    ::selftest::fail if they are equal.  */\n \n-#define ASSERT_NE(EXPECTED, ACTUAL)\t\t\t       \\\n+#define ASSERT_NE(VAL1, VAL2)\t\t\t       \\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t       \\\n-  const char *desc_ = \"ASSERT_NE (\" #EXPECTED \", \" #ACTUAL \")\"; \\\n-  if ((EXPECTED) != (ACTUAL))\t\t\t\t       \\\n+  const char *desc_ = \"ASSERT_NE (\" #VAL1 \", \" #VAL2 \")\"; \\\n+  if ((VAL1) != (VAL2))\t\t\t\t       \\\n     ::selftest::pass (SELFTEST_LOCATION, desc_);\t       \\\n   else\t\t\t\t\t\t\t       \\\n     ::selftest::fail (SELFTEST_LOCATION, desc_);\t       \\\n   SELFTEST_END_STMT\n \n-/* Evaluate EXPECTED and ACTUAL and compare them with maybe_ne, calling\n+/* Evaluate VAL1 and VAL2 and compare them with maybe_ne, calling\n    ::selftest::pass if they might be non-equal,\n    ::selftest::fail if they are known to be equal.  */\n \n-#define ASSERT_MAYBE_NE(EXPECTED, ACTUAL) \\\n-  ASSERT_MAYBE_NE_AT ((SELFTEST_LOCATION), (EXPECTED), (ACTUAL))\n+#define ASSERT_MAYBE_NE(VAL1, VAL2) \\\n+  ASSERT_MAYBE_NE_AT ((SELFTEST_LOCATION), (VAL1), (VAL2))\n \n /* Like ASSERT_MAYBE_NE, but treat LOC as the effective location of the\n    selftest.  */\n \n-#define ASSERT_MAYBE_NE_AT(LOC, EXPECTED, ACTUAL)\t\t\t\\\n+#define ASSERT_MAYBE_NE_AT(LOC, VAL1, VAL2)\t\t\t\\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n-  const char *desc = \"ASSERT_MAYBE_NE (\" #EXPECTED \", \" #ACTUAL \")\";\t\\\n-  if (maybe_ne (EXPECTED, ACTUAL))\t\t\t\t\t\\\n+  const char *desc = \"ASSERT_MAYBE_NE (\" #VAL1 \", \" #VAL2 \")\";\t\\\n+  if (maybe_ne (VAL1, VAL2))\t\t\t\t\t\\\n     ::selftest::pass ((LOC), desc);\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     ::selftest::fail ((LOC), desc);\t\t\t\t\t\\\n@@ -371,23 +371,23 @@ extern int num_passes;\n     ::selftest::fail ((LOC), desc_);\t\t\t       \\\n   SELFTEST_END_STMT\n \n-/* Evaluate EXPECTED and ACTUAL and compare them with strcmp, calling\n-   ::selftest::pass if they are equal,\n-   ::selftest::fail if they are non-equal.  */\n+/* Evaluate VAL1 and VAL2 and compare them with strcmp, calling\n+   ::selftest::pass if they are equal (and both are non-NULL),\n+   ::selftest::fail if they are non-equal, or are both NULL.  */\n \n-#define ASSERT_STREQ(EXPECTED, ACTUAL)\t\t\t\t    \\\n+#define ASSERT_STREQ(VAL1, VAL2)\t\t\t\t    \\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n-  ::selftest::assert_streq (SELFTEST_LOCATION, #EXPECTED, #ACTUAL, \\\n-\t\t\t    (EXPECTED), (ACTUAL));\t\t    \\\n+  ::selftest::assert_streq (SELFTEST_LOCATION, #VAL1, #VAL2, \\\n+\t\t\t    (VAL1), (VAL2));\t\t    \\\n   SELFTEST_END_STMT\n \n /* Like ASSERT_STREQ, but treat LOC as the effective location of the\n    selftest.  */\n \n-#define ASSERT_STREQ_AT(LOC, EXPECTED, ACTUAL)\t\t\t    \\\n+#define ASSERT_STREQ_AT(LOC, VAL1, VAL2)\t\t\t    \\\n   SELFTEST_BEGIN_STMT\t\t\t\t\t\t    \\\n-  ::selftest::assert_streq ((LOC), #EXPECTED, #ACTUAL,\t\t    \\\n-\t\t\t    (EXPECTED), (ACTUAL));\t\t    \\\n+  ::selftest::assert_streq ((LOC), #VAL1, #VAL2,\t\t    \\\n+\t\t\t    (VAL1), (VAL2));\t\t    \\\n   SELFTEST_END_STMT\n \n /* Evaluate HAYSTACK and NEEDLE and use strstr to determine if NEEDLE"}]}