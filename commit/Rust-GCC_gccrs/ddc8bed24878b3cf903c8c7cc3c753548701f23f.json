{"sha": "ddc8bed24878b3cf903c8c7cc3c753548701f23f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRjOGJlZDI0ODc4YjNjZjkwM2M4YzdjYzNjNzUzNTQ4NzAxZjIzZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@cygnus.com", "date": "1998-06-15T14:28:02Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-06-15T14:28:02Z"}, "message": "Do not do src->dest copy if register would not be allocated a normal register\n\nCo-Authored-By: Jim Wilson <wilson@cygnus.com>\n\nFrom-SVN: r20512", "tree": {"sha": "cefe4c75689abafce56ef1171dbc7a0d478fa80b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cefe4c75689abafce56ef1171dbc7a0d478fa80b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddc8bed24878b3cf903c8c7cc3c753548701f23f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc8bed24878b3cf903c8c7cc3c753548701f23f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc8bed24878b3cf903c8c7cc3c753548701f23f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc8bed24878b3cf903c8c7cc3c753548701f23f/comments", "author": null, "committer": null, "parents": [{"sha": "3bd89472d1a70eb0d5fc70d36c124293d7eb5599", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd89472d1a70eb0d5fc70d36c124293d7eb5599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd89472d1a70eb0d5fc70d36c124293d7eb5599"}], "stats": {"total": 181, "additions": 165, "deletions": 16}, "files": [{"sha": "784542853b0c7f75f6631f7919c68a61dcacbd22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc8bed24878b3cf903c8c7cc3c753548701f23f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc8bed24878b3cf903c8c7cc3c753548701f23f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddc8bed24878b3cf903c8c7cc3c753548701f23f", "patch": "@@ -1,10 +1,12 @@\n-Mon Jun 15 13:20:33 1998  Jim Wilson  <wilson@cygnus.com>\n+Mon Jun 15 17:06:43 1998  Michael Meissner  <meissner@cygnus.com>\n+\t\t\t  Jim Wilson  <wilson@cygnus.com>\n \n-\t* c-decl.c (shadow_tag_warned): Use specs not declspecs in for loop.\n+\t* regmove.c (copy_src_to_dest): Do not copy src to dest if either\n+\tthe source or destination is special.\n \n-Mon Jun 15 15:33:45 1998  Michael Meissner  <meissner@cygnus.com>\n+Mon Jun 15 13:20:33 1998  Jim Wilson  <wilson@cygnus.com>\n \n-\t* regmove.c: Undo June 11th change for now.\n+\t* c-decl.c (shadow_tag_warned): Use specs not declspecs in for loop.\n \n Mon Jun 15 07:16:29 PDT 1998 Jeff Law  (law@cygnus.com)\n "}, {"sha": "f932da8417dede37ba046f1b2b9d789ba70bb616", "filename": "gcc/regmove.c", "status": "modified", "additions": 159, "deletions": 12, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc8bed24878b3cf903c8c7cc3c753548701f23f/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc8bed24878b3cf903c8c7cc3c753548701f23f/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ddc8bed24878b3cf903c8c7cc3c753548701f23f", "patch": "@@ -43,11 +43,14 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"flags.h\"\n #include \"expr.h\"\n #include \"insn-flags.h\"\n+#include \"basic-block.h\"\n \n static int optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_2\tPROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_3\tPROTO((rtx, rtx, rtx));\n static rtx gen_add3_insn\tPROTO((rtx, rtx, rtx));\n+static void copy_src_to_dest\tPROTO((rtx, rtx, rtx, int));\n+static int *regmove_bb_head;\n \n struct match {\n   int with[MAX_RECOG_OPERANDS];\n@@ -528,6 +531,105 @@ optimize_reg_copy_3 (insn, dest, src)\n   validate_replace_rtx (src, src_reg, insn);\n }\n \n+\f\n+/* If we were not able to update the users of src to use dest directly, try\n+   instead moving the value to dest directly before the operation.  */\n+\n+void\n+copy_src_to_dest (insn, src, dest, loop_depth)\n+     rtx insn;\n+     rtx src;\n+     rtx dest;\n+{\n+  rtx seq;\n+  rtx link;\n+  rtx next;\n+  rtx set;\n+  rtx move_insn;\n+  rtx *p_insn_notes;\n+  rtx *p_move_notes;\n+  int i;\n+  int src_regno;\n+  int dest_regno;\n+  int bb;\n+  int insn_uid;\n+  int move_uid;\n+\n+  /* A REG_LIVE_LENGTH of -1 indicates the register is equivalent to a constant\n+     or memory location and is used infrequently; a REG_LIVE_LENGTH of -2 is\n+     parameter when there is no frame pointer that is not allocated a register.\n+     For now, we just reject them, rather than incrementing the live length.  */\n+\n+  if (GET_CODE (src) == REG && GET_CODE (dest) == REG\n+      && (set = single_set (insn)) != NULL_RTX\n+      && !reg_mentioned_p (dest, SET_SRC (set))\n+      && REG_LIVE_LENGTH (REGNO (dest)) > 0\n+      && REG_LIVE_LENGTH (REGNO (src)) > 0\n+      && validate_replace_rtx (src, dest, insn))\n+    {\n+      /* Generate the src->dest move.  */\n+      start_sequence ();\n+      emit_move_insn (dest, src);\n+      seq = gen_sequence ();\n+      end_sequence ();\n+      emit_insn_before (seq, insn);\n+      move_insn = PREV_INSN (insn);\n+      p_move_notes = &REG_NOTES (move_insn);\n+      p_insn_notes = &REG_NOTES (insn);\n+\n+      /* Move any notes mentioning src to the move instruction */\n+      for (link = REG_NOTES (insn); link != NULL_RTX; link = next)\n+\t{\n+\t  next = XEXP (link, 1);\n+\t  if (XEXP (link, 0) == src)\n+\t    {\n+\t      *p_move_notes = link;\n+\t      p_move_notes = &XEXP (link, 1);\n+\t    }\n+\t  else\n+\t    {\n+\t      *p_insn_notes = link;\n+\t      p_insn_notes = &XEXP (link, 1);\n+\t    }\n+\t}\n+\n+      *p_move_notes = NULL_RTX;\n+      *p_insn_notes = NULL_RTX;\n+\n+      /* Is the insn the head of a basic block?  If so extend it */\n+      insn_uid = INSN_UID (insn);\n+      move_uid = INSN_UID (move_insn);\n+      bb = regmove_bb_head[insn_uid];\n+      if (bb >= 0)\n+\t{\n+\t  basic_block_head[bb] = move_insn;\n+\t  regmove_bb_head[insn_uid] = -1;\n+\t}\n+\n+      /* Update the various register tables.  */\n+      dest_regno = REGNO (dest);\n+      REG_N_SETS (dest_regno) += loop_depth;\n+      REG_N_REFS (dest_regno) += loop_depth;\n+      REG_LIVE_LENGTH (dest_regno)++;\n+      if (REGNO_FIRST_UID (dest_regno) == insn_uid)\n+\tREGNO_FIRST_UID (dest_regno) = move_uid;\n+\n+      src_regno = REGNO (src);\n+      if (! find_reg_note (move_insn, REG_DEAD, src))\n+\tREG_LIVE_LENGTH (src_regno)++;\n+\n+      if (REGNO_FIRST_UID (src_regno) == insn_uid)\n+\tREGNO_FIRST_UID (src_regno) = move_uid;\n+\n+      if (REGNO_LAST_UID (src_regno) == insn_uid)\n+\tREGNO_LAST_UID (src_regno) = move_uid;\n+\n+      if (REGNO_LAST_NOTE_UID (src_regno) == insn_uid)\n+\tREGNO_LAST_NOTE_UID (src_regno) = move_uid;\n+    }\n+}\n+\n+\f\n /* Return whether REG is set in only one location, and is set to a\n    constant, but is set in a different basic block from INSN (an\n    instructions which uses REG).  In this case REG is equivalent to a\n@@ -750,10 +852,16 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   struct match match;\n   int pass;\n   int maxregnum = max_reg_num (), i;\n+  rtx copy_src, copy_dst;\n \n   regno_src_regno = (int *)alloca (sizeof *regno_src_regno * maxregnum);\n   for (i = maxregnum; --i >= 0; ) regno_src_regno[i] = -1;\n \n+  regmove_bb_head = (int *)alloca (sizeof (int) * (get_max_uid () + 1));\n+  for (i = get_max_uid (); --i >= 0; ) regmove_bb_head[i] = -1;\n+  for (i = 0; i < n_basic_blocks; i++)\n+    regmove_bb_head[INSN_UID (basic_block_head[i])] = i;\n+\n   /* A forward/backward pass.  Replace output operands with input operands.  */\n \n   loop_depth = 1;\n@@ -936,6 +1044,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t{\n \t  int insn_code_number = find_matches (insn, &match);\n \t  int operand_number, match_number;\n+\t  int success = 0;\n \t  \n \t  if (insn_code_number < 0)\n \t    continue;\n@@ -946,13 +1055,14 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t     operand.  If safe, then replace the source operand with the\n \t     dest operand in both instructions.  */\n \n+\t  copy_src = NULL_RTX;\n+\t  copy_dst = NULL_RTX;\n \t  for (operand_number = 0;\n \t       operand_number < insn_n_operands[insn_code_number];\n \t       operand_number++)\n \t    {\n \t      rtx set, p, src, dst;\n \t      rtx src_note, dst_note;\n-\t      int success = 0;\n \t      int num_calls = 0;\n \t      enum reg_class src_class, dst_class;\n \t      int length;\n@@ -1016,27 +1126,58 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t      || CLASS_LIKELY_SPILLED_P (src_class))\n \t\t  && (! reg_class_subset_p (dst_class, src_class)\n \t\t      || CLASS_LIKELY_SPILLED_P (dst_class)))\n-\t\tcontinue;\n-\t  \n-\t      if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n-\t\tcontinue;\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n \n \t      /* Can not modify an earlier insn to set dst if this insn\n \t\t uses an old value in the source.  */\n \t      if (reg_overlap_mentioned_p (dst, SET_SRC (set)))\n-\t\tcontinue;\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\n+\t      if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n \n-\t      if (regmove_dump_file)\n-\t\tfprintf (regmove_dump_file,\n-\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n-\t\t\t operand_number, INSN_UID (insn), match_number);\n \n \t      /* If src is set once in a different basic block,\n \t\t and is set equal to a constant, then do not use\n \t\t it for this optimization, as this would make it\n \t\t no longer equivalent to a constant.  */\n-\t      if (reg_is_remote_constant_p (src, insn, f))\n-\t\tcontinue;\n+\n+              if (reg_is_remote_constant_p (src, insn, f))\n+\t\t{\n+\t\t  if (!copy_src)\n+\t\t    {\n+\t\t      copy_src = src;\n+\t\t      copy_dst = dst;\n+\t\t    }\n+\t\t  continue;\n+\t\t}\n+\n+\n+\t      if (regmove_dump_file)\n+\t\tfprintf (regmove_dump_file,\n+\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t operand_number, INSN_UID (insn), match_number);\n \n \t      /* Scan backward to find the first instruction that uses\n \t\t the input operand.  If the operand is set here, then\n@@ -1173,6 +1314,12 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t  break;\n \t\t}\n \t    }\n+\n+\t  /* If we weren't able to replace any of the alternatives, try an\n+\t     alternative appoach of copying the source to the destination.  */\n+\t  if (!success && copy_src != NULL_RTX)\n+\t    copy_src_to_dest (insn, copy_src, copy_dst, loop_depth);\n+\n \t}\n     }\n #endif /* REGISTER_CONSTRAINTS */"}]}