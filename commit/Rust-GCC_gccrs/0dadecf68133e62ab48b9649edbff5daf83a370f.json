{"sha": "0dadecf68133e62ab48b9649edbff5daf83a370f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRhZGVjZjY4MTMzZTYyYWI0OGI5NjQ5ZWRiZmY1ZGFmODNhMzcwZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-17T09:57:24Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-17T09:57:24Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1614", "tree": {"sha": "d184e61c82f88fc3f839a376dd73d48a5f319602", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d184e61c82f88fc3f839a376dd73d48a5f319602"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dadecf68133e62ab48b9649edbff5daf83a370f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dadecf68133e62ab48b9649edbff5daf83a370f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dadecf68133e62ab48b9649edbff5daf83a370f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dadecf68133e62ab48b9649edbff5daf83a370f/comments", "author": null, "committer": null, "parents": [{"sha": "2a5f48f20c76fb7483473073df366ba8dd057b4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a5f48f20c76fb7483473073df366ba8dd057b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a5f48f20c76fb7483473073df366ba8dd057b4c"}], "stats": {"total": 200, "additions": 196, "deletions": 4}, "files": [{"sha": "e1c320973ed84d0eb0ed15e5d799e8cc1ac3e503", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=0dadecf68133e62ab48b9649edbff5daf83a370f", "patch": "@@ -5814,6 +5814,10 @@ cse_insn (insn, in_libcall_block)\n       sets[i].src_in_memory = hash_arg_in_memory;\n       sets[i].src_in_struct = hash_arg_in_struct;\n \n+#if 0\n+      /* It is no longer clear why we used to do this, but it doesn't\n+\t appear to still be needed.  So let's try without it since this\n+\t code hurts cse'ing widened ops.  */\n       /* If source is a perverse subreg (such as QI treated as an SI),\n \t treat it as volatile.  It may do the work of an SI in one context\n \t where the extra bits are not being used, but cannot replace an SI\n@@ -5822,6 +5826,7 @@ cse_insn (insn, in_libcall_block)\n \t  && (GET_MODE_SIZE (GET_MODE (src))\n \t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n \tsets[i].src_volatile = 1;\n+#endif\n \n       /* Locate all possible equivalent forms for SRC.  Try to replace\n          SRC in the insn with each cheaper equivalent."}, {"sha": "8a136c696f426aeebb63708522a94a6a6627f69b", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=0dadecf68133e62ab48b9649edbff5daf83a370f", "patch": "@@ -28,7 +28,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    compiled for the target, and hence definitions concerning only the host\n    do not apply.  */\n \n-#include \"tm.h\"\n+#include \"tconfig.h\"\n #ifndef L_trampoline\n #include \"gstddef.h\"\n #endif\n@@ -1495,7 +1495,7 @@ __do_global_dtors ()\n #ifdef DO_GLOBAL_DTORS_BODY\n   DO_GLOBAL_DTORS_BODY;\n #else\n-  unsigned nptrs = (unsigned) __DTOR_LIST__[0];\n+  unsigned nptrs = (unsigned HOST_WIDE_INT) __DTOR_LIST__[0];\n   unsigned i;\n \n   /* Some systems place the number of pointers"}, {"sha": "c10672bc5705c5417983b60971dc87a99924a1b3", "filename": "gcc/reload.c", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0dadecf68133e62ab48b9649edbff5daf83a370f", "patch": "@@ -207,6 +207,17 @@ static int n_replacements;\n static rtx memlocs[MAX_RECOG_OPERANDS * ((MAX_REGS_PER_ADDRESS * 2) + 1)];\n static int n_memlocs;\n \n+#ifdef SECONDARY_MEMORY_NEEDED\n+\n+/* Save MEMs needed to copy from one class of registers to another.  One MEM\n+   is used per mode, but normally only one or two modes are ever used.  \n+\n+   We keep two versions, before and after register elimination.  */\n+\n+static rtx secondary_memlocs[NUM_MACHINE_MODES];\n+static rtx secondary_memlocs_elim[NUM_MACHINE_MODES];\n+#endif\n+\n /* The instruction we are doing reloads for;\n    so we can test whether a register dies in it.  */\n static rtx this_insn;\n@@ -369,6 +380,73 @@ find_secondary_reload (x, reload_class, reload_mode, in_p, picode, pmode,\n }\n #endif /* HAVE_SECONDARY_RELOADS */\n \f\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\n+/* Return a memory location that will be used to copy X in mode MODE.  \n+   If we haven't already made a location for this mode in this insn,\n+   call find_reloads_address on the location being returned.  */\n+\n+rtx\n+get_secondary_mem (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  rtx loc;\n+  int mem_valid;\n+\n+  /* If MODE is narrower than a word, widen it.  This is required because\n+     most machines that require these memory locations do not support\n+     short load and stores from all registers (e.g., FP registers).  We could\n+     possibly conditionalize this, but we lose nothing by doing the wider\n+     mode.  */\n+\n+  if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n+    mode = mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0);\n+\n+  /* If we already have made a MEM for this insn, return it.  */\n+  if (secondary_memlocs_elim[(int) mode] != 0)\n+    return secondary_memlocs_elim[(int) mode];\n+\n+  /* If this is the first time we've tried to get a MEM for this mode, \n+     allocate a new one.  `something_changed' in reload will get set\n+     by noticing that the frame size has changed.  */\n+\n+  if (secondary_memlocs[(int) mode] == 0)\n+    secondary_memlocs[(int) mode]\n+      = assign_stack_local (mode, GET_MODE_SIZE (mode), 0);\n+\n+  /* Get a version of the address doing any eliminations needed.  If that\n+     didn't give us a new MEM, make a new one if it isn't valid.  */\n+\n+  loc = eliminate_regs (secondary_memlocs[(int) mode], 0, NULL_RTX);\n+  mem_valid = strict_memory_address_p (mode, XEXP (loc, 0));\n+\n+  if (! mem_valid && loc == secondary_memlocs[(int) mode])\n+    loc = copy_rtx (loc);\n+\n+  /* The only time the call below will do anything is if the stack\n+     offset is too large.  In that case IND_LEVELS doesn't matter, so we\n+     can just pass a zero.  */\n+  if (! mem_valid)\n+    find_reloads_address (mode, NULL_PTR, XEXP (loc, 0), &XEXP (loc, 0), x, 0);\n+\n+  secondary_memlocs_elim[(int) mode] = loc;\n+\n+  return loc;\n+}\n+\n+/* Clear any secondary memory locations we've made.  */\n+\n+void\n+clear_secondary_mem ()\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_MACHINE_MODES; i++)\n+    secondary_memlocs[i] = 0;\n+}\n+#endif /* SECONDARY_MEMORY_NEEDED */\n+\f\n /* Record one (sometimes two) reload that needs to be performed.\n    IN is an rtx saying where the data are to be found before this instruction.\n    OUT says where they must be stored after the instruction.\n@@ -569,6 +647,21 @@ push_reload (in, out, inloc, outloc, class,\n       && reg_overlap_mentioned_for_reload_p (in, XEXP (out, 0)))\n     dont_share = 1;\n \n+  /* If IN is a SUBREG of a hard register, make a new REG.  This\n+     simplifies some of the cases below.  */\n+\n+  if (in != 0 && GET_CODE (in) == SUBREG && GET_CODE (SUBREG_REG (in)) == REG\n+      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER)\n+    in = gen_rtx (REG, GET_MODE (in),\n+\t\t  REGNO (SUBREG_REG (in)) + SUBREG_WORD (in));\n+\n+  /* Similarly for OUT.  */\n+  if (out != 0 && GET_CODE (out) == SUBREG\n+      && GET_CODE (SUBREG_REG (out)) == REG\n+      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER)\n+    out = gen_rtx (REG, GET_MODE (out),\n+\t\t  REGNO (SUBREG_REG (out)) + SUBREG_WORD (out));\n+\n   /* Narrow down the class of register wanted if that is\n      desirable on this machine for efficiency.  */\n   if (in != 0)\n@@ -858,6 +951,19 @@ push_reload (in, out, inloc, outloc, class,\n \n \t      n_reloads++;\n \t      i = n_reloads;\n+\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t      /* If we need a memory location to copy between the two\n+\t\t reload regs, set it up now.  */\n+\n+\t      if (in != 0 && secondary_icode == CODE_FOR_nothing\n+\t\t  && SECONDARY_MEMORY_NEEDED (secondary_class, class, inmode))\n+\t\tget_secondary_mem (in, inmode);\n+\n+\t      if (out != 0 && secondary_icode == CODE_FOR_nothing\n+\t\t  && SECONDARY_MEMORY_NEEDED (class, secondary_class, outmode))\n+\t\tget_secondary_mem (out, outmode);\n+#endif\n \t    }\n \t}\n #endif\n@@ -883,6 +989,21 @@ push_reload (in, out, inloc, outloc, class,\n       reload_secondary_p[i] = 0;\n \n       n_reloads++;\n+\n+#ifdef SECONDARY_MEMORY_NEEDED\n+      /* If a memory location is needed for the copy, make one.  */\n+      if (in != 0 && GET_CODE (in) == REG\n+\t  && REGNO (in) < FIRST_PSEUDO_REGISTER\n+\t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (in)),\n+\t\t\t\t     class, inmode))\n+\tget_secondary_mem (in, inmode);\n+\n+      if (out != 0 && GET_CODE (out) == REG\n+\t  && REGNO (out) < FIRST_PSEUDO_REGISTER\n+\t  && SECONDARY_MEMORY_NEEDED (class, REGNO_REG_CLASS (REGNO (out)),\n+\t\t\t\t      outmode))\n+\tget_secondary_mem (out, outmode);\n+#endif\n     }\n   else\n     {\n@@ -1829,6 +1950,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n     no_output_reloads = 1;\n #endif\n      \n+#ifdef SECONDARY_MEMORY_NEEDED\n+  /* The eliminated forms of any secondary memory locations are per-insn, so\n+     clear them out here.  */\n+\n+  bzero (secondary_memlocs_elim, sizeof secondary_memlocs_elim);\n+#endif\n+\n   /* Find what kind of insn this is.  NOPERANDS gets number of operands.\n      Make OPERANDS point to a vector of operand values.\n      Make OPERAND_LOCS point to a vector of pointers to"}, {"sha": "5451ab6590b7cc336fbab112a1c47393f3f4cca2", "filename": "gcc/reload1.c", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dadecf68133e62ab48b9649edbff5daf83a370f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=0dadecf68133e62ab48b9649edbff5daf83a370f", "patch": "@@ -513,6 +513,11 @@ reload (first, global, dumpfile)\n   for (i = 0; i < N_REG_CLASSES; i++)\n     basic_block_needs[i] = 0;\n \n+#ifdef SECONDARY_MEMORY_NEEDED\n+  /* Initialize the secondary memory table.  */\n+  clear_secondary_mem ();\n+#endif\n+\n   /* Remember which hard regs appear explicitly\n      before we merge into `regs_ever_live' the ones in which\n      pseudo regs have been allocated.  */\n@@ -786,6 +791,7 @@ reload (first, global, dumpfile)\n       rtx max_groups_insn[N_REG_CLASSES];\n       rtx max_nongroups_insn[N_REG_CLASSES];\n       rtx x;\n+      int starting_frame_size = get_frame_size ();\n \n       something_changed = 0;\n       bzero (max_needs, sizeof max_needs);\n@@ -1302,6 +1308,11 @@ reload (first, global, dumpfile)\n \t  /* Note that there is a continue statement above.  */\n \t}\n \n+      /* If we allocated any new memory locations, make another pass\n+\t since it might have changed elimination offsets.  */\n+      if (starting_frame_size != get_frame_size ())\n+\tsomething_changed = 1;\n+\n       /* If we have caller-saves, set up the save areas and see if caller-save\n \t will need a spill register.  */\n \n@@ -5298,8 +5309,35 @@ emit_reload_insns (insn)\n \n \t  /* Output the last reload insn.  */\n \t  if (! special)\n-\t    emit_insn_before (gen_move_insn (old, reloadreg),\n-\t\t\t      first_output_reload_insn);\n+\t    {\n+#ifdef SECONDARY_MEMORY_NEEDED\n+\t      /* If we need a memory location to do the move, do it that way.  */\n+\t      if (GET_CODE (old) == REG && REGNO (old) < FIRST_PSEUDO_REGISTER\n+\t\t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (old)),\n+\t\t\t\t\t      REGNO_REG_CLASS (REGNO (reloadreg)),\n+\t\t\t\t\t      GET_MODE (reloadreg)))\n+\t\t{\n+\t\t  /* Get the memory to use and rewrite both registers to\n+\t\t     its mode.  */\n+\t\t  rtx loc = get_secondary_mem (old, GET_MODE (reloadreg));\n+\n+\t\t  if (GET_MODE (loc) != GET_MODE (reloadreg))\n+\t\t    reloadreg = gen_rtx (REG, GET_MODE (loc),\n+\t\t\t\t\t REGNO (reloadreg));\n+\n+\t\t  if (GET_MODE (loc) != GET_MODE (old))\n+\t\t    old = gen_rtx (REG, GET_MODE (loc), REGNO (old));\n+\n+\t\t  emit_insn_before (gen_move_insn (loc, reloadreg),\n+\t\t\t\t    first_output_reload_insn);\n+\t\t  emit_insn_before (gen_move_insn (old, loc),\n+\t\t\t\t    first_output_reload_insn);\n+\t\t}\n+\t      else\n+#endif\n+\t\temit_insn_before (gen_move_insn (old, reloadreg),\n+\t\t\t\t  first_output_reload_insn);\n+\t    }\n \n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n \t  /* If final will look at death notes for this reg,\n@@ -5608,6 +5646,27 @@ gen_input_reload (reloadreg, in, before_insn)\n       emit_insn_before (gen_add2_insn (reloadreg, op1), before_insn);\n     }\n \n+#ifdef SECONDARY_MEMORY_NEEDED\n+  /* If we need a memory location to do the move, do it that way.  */\n+  else if (GET_CODE (in) == REG && REGNO (in) < FIRST_PSEUDO_REGISTER\n+\t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (in)),\n+\t\t\t\t       REGNO_REG_CLASS (REGNO (reloadreg)),\n+\t\t\t\t       GET_MODE (reloadreg)))\n+    {\n+      /* Get the memory to use and rewrite both registers to its mode.  */\n+      rtx loc = get_secondary_mem (in, GET_MODE (reloadreg));\n+\n+      if (GET_MODE (loc) != GET_MODE (reloadreg))\n+\treloadreg = gen_rtx (REG, GET_MODE (loc), REGNO (reloadreg));\n+\n+      if (GET_MODE (loc) != GET_MODE (in))\n+\tin = gen_rtx (REG, GET_MODE (loc), REGNO (in));\n+\n+      emit_insn_before (gen_move_insn (reloadreg, loc), before_insn);\n+      emit_insn_before (gen_move_insn (loc, in), before_insn);\n+    }\n+#endif\n+\n   /* If IN is a simple operand, use gen_move_insn.  */\n   else if (GET_RTX_CLASS (GET_CODE (in)) == 'o' || GET_CODE (in) == SUBREG)\n     emit_insn_before (gen_move_insn (reloadreg, in), before_insn);"}]}