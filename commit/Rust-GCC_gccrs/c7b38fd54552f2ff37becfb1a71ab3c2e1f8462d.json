{"sha": "c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdiMzhmZDU0NTUyZjJmZjM3YmVjZmIxYTcxYWIzYzJlMWY4NDYyZA==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2015-05-12T09:46:47Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2015-05-12T09:46:47Z"}, "message": "Don't take address of ap unless necessary\n\n2015-05-12  Tom de Vries  <tom@codesourcery.com>\n\n\tPR tree-optimization/66010\n\t* gimplify.c (gimplify_modify_expr): Handle new do_deref argument of\n\tifn_va_arg.\n\t* gimplify.h (gimplify_va_arg_internal): Remove loc parameter.\n\t(gimplify_va_arg_internal): Remove loc parameter.  Assert no array-typed\n\tva_lists are passed, and remove corresponding handling.\n\t(gimplify_va_arg_expr): Only take address of ap if necessary.  Add\n\tdo_deref argument to ifn_va_arg.\n\t* tree-stdarg.c (expand_ifn_va_arg_1): Handle new do_deref argument of\n\tifn_va_arg.\n\n\t* c-common.c (build_va_arg): Don't mark ap addressable unless necessary.\n\n\t* gcc.dg/tree-ssa/stdarg-2.c: Undo scan xfails for f15.\n\nFrom-SVN: r223054", "tree": {"sha": "c10f8ac5291a1a6a12e7472c1ad1acd14764ffef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c10f8ac5291a1a6a12e7472c1ad1acd14764ffef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/comments", "author": null, "committer": null, "parents": [{"sha": "fed8bd87d5832d9c61c648ed2a2103f853fad00a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fed8bd87d5832d9c61c648ed2a2103f853fad00a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fed8bd87d5832d9c61c648ed2a2103f853fad00a"}], "stats": {"total": 129, "additions": 91, "deletions": 38}, "files": [{"sha": "d05b31363f94e14d63b22c686f56240af4120105", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -1,3 +1,16 @@\n+2015-05-12  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/66010\n+\t* gimplify.c (gimplify_modify_expr): Handle new do_deref argument of\n+\tifn_va_arg.\n+\t* gimplify.h (gimplify_va_arg_internal): Remove loc parameter.\n+\t(gimplify_va_arg_internal): Remove loc parameter.  Assert no array-typed\n+\tva_lists are passed, and remove corresponding handling.\n+\t(gimplify_va_arg_expr): Only take address of ap if necessary.  Add\n+\tdo_deref argument to ifn_va_arg.\n+\t* tree-stdarg.c (expand_ifn_va_arg_1): Handle new do_deref argument of\n+\tifn_va_arg.\n+\n 2015-05-12  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \tPR target/65955"}, {"sha": "8a19bc119b27300cda5eacf6a54c3621215e6a57", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -1,3 +1,8 @@\n+2015-05-12  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/66010\n+\t* c-common.c (build_va_arg): Don't mark ap addressable unless necessary.\n+\n 2015-05-09  Jason Merrill  <jason@redhat.com>\n \n \t* c-opts.c (c_common_post_options): Also clear"}, {"sha": "2b3ee0c64cf5a97ca0e9840e48e507ee4ab927eb", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -5918,9 +5918,25 @@ set_compound_literal_name (tree decl)\n tree\n build_va_arg (location_t loc, tree expr, tree type)\n {\n-  /* In gimplify_va_arg_expr we take the address of the ap argument, mark it\n-     addressable now.  */\n-  mark_addressable (expr);\n+  tree va_type = TREE_TYPE (expr);\n+  tree canon_va_type = (va_type == error_mark_node\n+\t\t\t? NULL_TREE\n+\t\t\t: targetm.canonical_va_list_type (va_type));\n+\n+  if (canon_va_type != NULL)\n+    {\n+      /* When the va_arg ap argument is a parm decl with declared type va_list,\n+\t and the va_list type is an array, then grokdeclarator changes the type\n+\t of the parm decl to the corresponding pointer type.  We know that that\n+\t pointer is constant, so there's no need to modify it, so there's no\n+\t need to pass it around using an address operator, so there's no need to\n+\t mark it addressable.  */\n+      if (!(TREE_CODE (canon_va_type) == ARRAY_TYPE\n+\t    && TREE_CODE (va_type) != ARRAY_TYPE))\n+\t/* In gimplify_va_arg_expr we take the address of the ap argument, mark\n+\t   it addressable now.  */\n+\tmark_addressable (expr);\n+    }\n \n   expr = build1 (VA_ARG_EXPR, type, expr);\n   SET_EXPR_LOCATION (expr, loc);"}, {"sha": "322d0ba6ba13b11fec295bacaac84c67c97e708c", "filename": "gcc/gimplify.c", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -4658,9 +4658,11 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  tree type = TREE_TYPE (call);\n \t  tree ap = CALL_EXPR_ARG (call, 0);\n \t  tree tag = CALL_EXPR_ARG (call, 1);\n+\t  tree do_deref = CALL_EXPR_ARG (call, 2);\n \t  tree newcall = build_call_expr_internal_loc (EXPR_LOCATION (call),\n-\t\t\t\t\t\t       IFN_VA_ARG, type, 3, ap,\n-\t\t\t\t\t\t       tag, vlasize);\n+\t\t\t\t\t\t       IFN_VA_ARG, type, 4, ap,\n+\t\t\t\t\t\t       tag, do_deref,\n+\t\t\t\t\t\t       vlasize);\n \t  tree *call_p = &(TREE_OPERAND (*from_p, 0));\n \t  *call_p = newcall;\n \t}\n@@ -9304,8 +9306,8 @@ dummy_object (tree type)\n    and TYPE.  */\n \n tree\n-gimplify_va_arg_internal (tree valist, tree type, location_t loc,\n-\t\t\t  gimple_seq *pre_p, gimple_seq *post_p)\n+gimplify_va_arg_internal (tree valist, tree type, gimple_seq *pre_p,\n+\t\t\t  gimple_seq *post_p)\n {\n   tree have_va_type = TREE_TYPE (valist);\n   tree cano_type = targetm.canonical_va_list_type (have_va_type);\n@@ -9317,17 +9319,7 @@ gimplify_va_arg_internal (tree valist, tree type, location_t loc,\n      from multiple evaluations.  */\n   if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n     {\n-      /* For this case, the backends will be expecting a pointer to\n-\t TREE_TYPE (abi), but it's possible we've\n-\t actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n-\t So fix it.  */\n-      if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n-\t{\n-\t  tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n-\t  valist = fold_convert_loc (loc, p1,\n-\t\t\t\t     build_fold_addr_expr_loc (loc, valist));\n-\t}\n-\n+      gcc_assert (TREE_CODE (TREE_TYPE (valist)) != ARRAY_TYPE);\n       gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n     }\n   else\n@@ -9346,7 +9338,7 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n   tree promoted_type, have_va_type;\n   tree valist = TREE_OPERAND (*expr_p, 0);\n   tree type = TREE_TYPE (*expr_p);\n-  tree t, tag, ap;\n+  tree t, tag, ap, do_deref;\n   location_t loc = EXPR_LOCATION (*expr_p);\n \n   /* Verify that valist is of the proper type.  */\n@@ -9400,9 +9392,34 @@ gimplify_va_arg_expr (tree *expr_p, gimple_seq *pre_p,\n     }\n \n   /* Transform a VA_ARG_EXPR into an VA_ARG internal function.  */\n-  ap = build_fold_addr_expr_loc (loc, valist);\n+  if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n+    {\n+      if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n+\t{\n+\t  /* Take the address, but don't strip it.  Gimplify_va_arg_internal\n+\t     expects a pointer to array element type.  */\n+\t  ap = build_fold_addr_expr_loc (loc, valist);\n+\t  do_deref = integer_zero_node;\n+\t}\n+      else\n+\t{\n+\t  /* Don't take the address.  Gimplify_va_arg_internal expects a pointer\n+\t     to array element type, and we already have that.\n+\t     See also comment in build_va_arg.  */\n+\t  ap = valist;\n+\t  do_deref = integer_zero_node;\n+\t}\n+    }\n+  else\n+    {\n+      /* No special handling.  Take the address here, note that it needs to be\n+\t stripped before calling gimplify_va_arg_internal. */\n+      ap = build_fold_addr_expr_loc (loc, valist);\n+      do_deref = integer_one_node;\n+    }\n   tag = build_int_cst (build_pointer_type (type), 0);\n-  *expr_p = build_call_expr_internal_loc (loc, IFN_VA_ARG, type, 2, ap, tag);\n+  *expr_p = build_call_expr_internal_loc (loc, IFN_VA_ARG, type, 3, ap, tag,\n+\t\t\t\t\t  do_deref);\n \n   /* Clear the tentatively set PROP_gimple_lva, to indicate that IFN_VA_ARG\n      needs to be expanded.  */"}, {"sha": "83bf52572bd42041f1843a73b56218dfcf2dce98", "filename": "gcc/gimplify.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fgimplify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Fgimplify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.h?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -82,8 +82,7 @@ extern void gimplify_function_tree (tree);\n extern enum gimplify_status gimplify_va_arg_expr (tree *, gimple_seq *,\n \t\t\t\t\t\t  gimple_seq *);\n gimple gimplify_assign (tree, tree, gimple_seq *);\n-extern tree gimplify_va_arg_internal (tree, tree, location_t, gimple_seq *,\n-\t\t\t\t      gimple_seq *);\n+extern tree gimplify_va_arg_internal (tree, tree, gimple_seq *, gimple_seq *);\n \n /* Return true if gimplify_one_sizepos doesn't need to gimplify\n    expr (when in TYPE_SIZE{,_UNIT} and similar type/decl size/bitsize"}, {"sha": "5d17561a3f95195371842a12125eb131fd21907d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -1,3 +1,8 @@\n+2015-05-12  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR tree-optimization/66010\n+\t* gcc.dg/tree-ssa/stdarg-2.c: Undo scan xfails for f15.\n+\n 2015-05-12  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/65133"}, {"sha": "93a9e8da0d99a5ce08eae86e3eb50afe5eaff394", "filename": "gcc/testsuite/gcc.dg/tree-ssa/stdarg-2.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fstdarg-2.c?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -288,14 +288,9 @@ f15 (int i, ...)\n   f15_1 (ap);\n   va_end (ap);\n }\n-\n-/* Following three dg-finals are marked as xfail due to PR66010/PR66013.  */\n-/* Was: { target { { i?86-*-* x86_64-*-* } && { ! { ia32 || llp64 } } } }.  */\n-/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { xfail *-*-* } } } */\n-/* Was: { target { powerpc*-*-linux* && { powerpc_fprs && ilp32 } } }.  */\n-/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { xfail *-*-* } } } */\n-/* Was: { target s390*-*-linux* }.  */\n-/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save 1 GPR units and 2 FPR units\" \"stdarg\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { { i?86-*-* x86_64-*-* } && { ! { ia32 || llp64 } } } } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save \\[148\\] GPR units and \\[1-9\\]\\[0-9\\]* FPR units\" \"stdarg\" { target { powerpc*-*-linux* && { powerpc_fprs && ilp32 } } } } } */\n+/* { dg-final { scan-tree-dump \"f15: va_list escapes 0, needs to save 1 GPR units and 2 FPR units\" \"stdarg\" { target s390*-*-linux* } } } */\n \n /* We may be able to improve upon this after fixing PR66010/PR66013.  */\n /* { dg-final { scan-tree-dump \"f15: va_list escapes 1, needs to save all GPR units and all FPR units\" \"stdarg\" { target alpha*-*-linux* } } } */"}, {"sha": "3bede7efd6e3f1ce8a587042fded7b65b0790e28", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=c7b38fd54552f2ff37becfb1a71ab3c2e1f8462d", "patch": "@@ -1042,7 +1042,7 @@ expand_ifn_va_arg_1 (function *fun)\n     for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n       {\n \tgimple stmt = gsi_stmt (i);\n-\ttree ap, expr, lhs, type;\n+\ttree ap, expr, lhs, type, do_deref;\n \tgimple_seq pre = NULL, post = NULL;\n \n \tif (!gimple_call_ifn_va_arg_p (stmt))\n@@ -1052,24 +1052,27 @@ expand_ifn_va_arg_1 (function *fun)\n \n \ttype = TREE_TYPE (TREE_TYPE (gimple_call_arg (stmt, 1)));\n \tap = gimple_call_arg (stmt, 0);\n-\tap = build_fold_indirect_ref (ap);\n+\tdo_deref = gimple_call_arg (stmt, 2);\n+\n+\tif (do_deref == integer_one_node)\n+\t  ap = build_fold_indirect_ref (ap);\n \n \tpush_gimplify_context (false);\n \n-\texpr = gimplify_va_arg_internal (ap, type, gimple_location (stmt),\n-\t\t\t\t\t &pre, &post);\n+\texpr = gimplify_va_arg_internal (ap, type, &pre, &post);\n \n \tlhs = gimple_call_lhs (stmt);\n \tif (lhs != NULL_TREE)\n \t  {\n+\t    unsigned int nargs = gimple_call_num_args (stmt);\n \t    gcc_assert (useless_type_conversion_p (TREE_TYPE (lhs), type));\n \n-\t    if (gimple_call_num_args (stmt) == 3)\n+\t    if (nargs == 4)\n \t      {\n \t\t/* We've transported the size of with WITH_SIZE_EXPR here as\n-\t\t   the 3rd argument of the internal fn call.  Now reinstate\n+\t\t   the last argument of the internal fn call.  Now reinstate\n \t\t   it.  */\n-\t\ttree size = gimple_call_arg (stmt, 2);\n+\t\ttree size = gimple_call_arg (stmt, nargs - 1);\n \t\texpr = build2 (WITH_SIZE_EXPR, TREE_TYPE (expr), expr, size);\n \t      }\n "}]}