{"sha": "7c82a41e7f18796040b3e6effbf6c483b7beb915", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4MmE0MWU3ZjE4Nzk2MDQwYjNlNmVmZmJmNmM0ODNiN2JlYjkxNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-06-14T15:58:54Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-06-14T15:58:54Z"}, "message": "re PR c++/15096 (parse error with templates and pointer to const member)\n\n\tPR c++/15096\n\t* decl.c (grokdeclarator): Ignore pointer-to-members when\n\tcomputing template depth.\n\n\tPR c++/14930\n\t* name-lookup.c (pushtag): Do not try to put class declarations in\n\texplicit specialization scopes.\n\n\tPR c++/15096\n\t* g++.dg/template/ptrmem10.C: New test.\n\n\tPR c++/14930\n\t* g++.dg/template/friend30.C: New test.\n\nFrom-SVN: r83112", "tree": {"sha": "3899c5cea0f22109ff80c76fd4ccd139aedf8dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3899c5cea0f22109ff80c76fd4ccd139aedf8dd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c82a41e7f18796040b3e6effbf6c483b7beb915", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82a41e7f18796040b3e6effbf6c483b7beb915", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c82a41e7f18796040b3e6effbf6c483b7beb915", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c82a41e7f18796040b3e6effbf6c483b7beb915/comments", "author": null, "committer": null, "parents": [{"sha": "f3207b37d34107210fda3f7b3bc999ac7537d7c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3207b37d34107210fda3f7b3bc999ac7537d7c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3207b37d34107210fda3f7b3bc999ac7537d7c0"}], "stats": {"total": 102, "additions": 83, "deletions": 19}, "files": [{"sha": "d99aef0a8fdfb7a88220a87e3e8a058516ef4aa7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7c82a41e7f18796040b3e6effbf6c483b7beb915", "patch": "@@ -1,3 +1,13 @@\n+2004-06-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/15096\n+\t* decl.c (grokdeclarator): Ignore pointer-to-members when\n+\tcomputing template depth.\n+\n+\tPR c++/14930\n+\t* name-lookup.c (pushtag): Do not try to put class declarations in\n+\texplicit specialization scopes.\n+\n 2004-06-11  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* decl.c (grokdeclarator): Do not depend on C99's _Bool's behavior."}, {"sha": "417171e760cbc36549927e6cd09e83e82b051b84", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7c82a41e7f18796040b3e6effbf6c483b7beb915", "patch": "@@ -7599,27 +7599,28 @@ grokdeclarator (tree declarator,\n \t    ctype = TREE_OPERAND (declarator, 0);\n \n \t    t = ctype;\n-\t    while (t != NULL_TREE && CLASS_TYPE_P (t))\n-\t      {\n-\t\t/* You're supposed to have one `template <...>'\n-\t\t   for every template class, but you don't need one\n-\t\t   for a full specialization.  For example:\n-\n+\t    if (TREE_CODE (TREE_OPERAND (declarator, 1)) != INDIRECT_REF)\n+\t      while (t != NULL_TREE && CLASS_TYPE_P (t))\n+\t\t{\n+\t\t  /* You're supposed to have one `template <...>'\n+\t\t     for every template class, but you don't need one\n+\t\t     for a full specialization.  For example:\n+\t\t     \n \t\t     template <class T> struct S{};\n \t\t     template <> struct S<int> { void f(); };\n \t\t     void S<int>::f () {}\n-\n-\t\t   is correct; there shouldn't be a `template <>' for\n-\t\t   the definition of `S<int>::f'.  */\n-\t\tif (CLASSTYPE_TEMPLATE_INFO (t)\n-\t\t    && (CLASSTYPE_TEMPLATE_INSTANTIATION (t)\n-\t\t\t|| uses_template_parms (CLASSTYPE_TI_ARGS (t)))\n-\t            && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n-\t\t  template_count += 1;\n-\n-\t\tt = TYPE_MAIN_DECL (t);\n-\t\tt = DECL_CONTEXT (t);\n-\t      }\n+\t\t     \n+\t\t     is correct; there shouldn't be a `template <>' for\n+\t\t     the definition of `S<int>::f'.  */\n+\t\t  if (CLASSTYPE_TEMPLATE_INFO (t)\n+\t\t      && (CLASSTYPE_TEMPLATE_INSTANTIATION (t)\n+\t\t\t  || uses_template_parms (CLASSTYPE_TI_ARGS (t)))\n+\t\t      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n+\t\t    template_count += 1;\n+\t\t  \n+\t\t  t = TYPE_MAIN_DECL (t);\n+\t\t  t = DECL_CONTEXT (t);\n+\t\t}\n \n \t    if (sname == NULL_TREE)\n \t      goto done_scoping;"}, {"sha": "3e42f3b5dce4c041feaf28b694212795074fa1ab", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=7c82a41e7f18796040b3e6effbf6c483b7beb915", "patch": "@@ -4635,7 +4635,16 @@ pushtag (tree name, tree type, int globalize)\n \n   timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n-  while (b->kind == sk_cleanup\n+  while (/* Cleanup scopes are not scopes from the point of view of\n+\t    the language.  */\n+\t b->kind == sk_cleanup\n+\t /* Neither are the scopes used to hold template parameters\n+\t    for an explicit specialization.  For an ordinary template\n+\t    declaration, these scopes are not scopes from the point of\n+\t    view of the language -- but we need a place to stash\n+\t    things that will go in the containing namespace when the\n+\t    template is instantiated.  */\n+\t || (b->kind == sk_template_parms && b->explicit_spec_p)\n \t || (b->kind == sk_class\n \t     && (globalize\n \t\t /* We may be defining a new type in the initializer"}, {"sha": "0bff3abb8defd6dc9366b8baf29c95bcd1cff836", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c82a41e7f18796040b3e6effbf6c483b7beb915", "patch": "@@ -1,3 +1,11 @@\n+2004-06-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/15096\n+\t* g++.dg/template/ptrmem10.C: New test.\n+\n+\tPR c++/14930\n+\t* g++.dg/template/friend30.C: New test.\n+\n 2004-06-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/14928"}, {"sha": "055fc8d89ec74b1a8d060893ca57031bdc9d799c", "filename": "gcc/testsuite/g++.dg/template/friend30.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend30.C?ref=7c82a41e7f18796040b3e6effbf6c483b7beb915", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/14930\n+\n+template<typename T> class Point;\n+\n+template<> class Point<double> {\n+  friend class Plane;\n+  double v;\n+};\n+\n+struct Plane {\n+  double get(const Point<double>& p);\n+};\n+\n+double Plane::get(const Point<double> &p) { return p.v; }\n+"}, {"sha": "b76d5e80a5afce110f9fc55650f6cb8c5db38bc7", "filename": "gcc/testsuite/g++.dg/template/ptrmem10.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c82a41e7f18796040b3e6effbf6c483b7beb915/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem10.C?ref=7c82a41e7f18796040b3e6effbf6c483b7beb915", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/15096\n+\n+template <typename T_>\n+class C1\n+{\n+public:\n+    C1 ();\n+    ~C1 ();\n+    const int C1<T_>::* getPtr () const;\n+\n+private:\n+    int x;\n+    T_ y;\n+};\n+\n+\n+template <typename T_>\n+const int C1<T_>::* C1<T_>::getPtr () const\n+{ return &C1<T_>::x; }\n+\n+"}]}