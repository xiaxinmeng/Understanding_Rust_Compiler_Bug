{"sha": "531dae29a67e915a145d908bd2f46d22bc369c11", "node_id": "C_kwDOANBUbNoAKDUzMWRhZTI5YTY3ZTkxNWExNDVkOTA4YmQyZjQ2ZDIyYmMzNjljMTE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-25T09:38:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-11-25T09:38:33Z"}, "message": "bswap: Improve perform_symbolic_merge [PR103376]\n\nThinking more about it, perhaps we could do more for BIT_XOR_EXPR.\nWe could allow masked1 == masked2 case for it, but would need to\ndo something different than the\n  n->n = n1->n | n2->n;\nwe do on all the bytes together.\nIn particular, for masked1 == masked2 if masked1 != 0 (well, for 0\nboth variants are the same) and masked1 != 0xff we would need to\nclear corresponding n->n byte instead of setting it to the input\nas x ^ x = 0 (but if we don't know what x and y are, the result is\nalso don't know).  Now, for plus it is much harder, because not only\nfor non-zero operands we don't know what the result is, but it can\nmodify upper bytes as well.  So perhaps only if current's byte\nmasked1 && masked2 set the resulting byte to 0xff (unknown) iff\nthe byte above it is 0 and 0, and set that resulting byte to 0xff too.\nAlso, even for | we could instead of return NULL just set the resulting\nbyte to 0xff if it is different, perhaps it will be masked off later on.\n\nThis patch just punts on plus if both corresponding bytes are non-zero,\notherwise implements the above.\n\n2021-11-25  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/103376\n\t* gimple-ssa-store-merging.c (perform_symbolic_merge): For\n\tBIT_IOR_EXPR, if masked1 && masked2 && masked1 != masked2, don't\n\tpunt, but set the corresponding result byte to MARKER_BYTE_UNKNOWN.\n\tFor BIT_XOR_EXPR similarly and if masked1 == masked2 and the\n\tbyte isn't MARKER_BYTE_UNKNOWN, set the corresponding result byte to\n\t0.\n\n\t* gcc.dg/optimize-bswapsi-7.c: New test.", "tree": {"sha": "00facf0d77fa803ed9184eae5a0e4e29d3c89d87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00facf0d77fa803ed9184eae5a0e4e29d3c89d87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/531dae29a67e915a145d908bd2f46d22bc369c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531dae29a67e915a145d908bd2f46d22bc369c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531dae29a67e915a145d908bd2f46d22bc369c11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531dae29a67e915a145d908bd2f46d22bc369c11/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e86218f05c1a866b43ae5af3e303f91fb6d7ff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e86218f05c1a866b43ae5af3e303f91fb6d7ff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e86218f05c1a866b43ae5af3e303f91fb6d7ff0"}], "stats": {"total": 69, "additions": 64, "deletions": 5}, "files": [{"sha": "e7c90ba8b59c33326ad0c67a8c7ba70872316f7e", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531dae29a67e915a145d908bd2f46d22bc369c11/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531dae29a67e915a145d908bd2f46d22bc369c11/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=531dae29a67e915a145d908bd2f46d22bc369c11", "patch": "@@ -556,19 +556,41 @@ perform_symbolic_merge (gimple *source_stmt1, struct symbolic_number *n1,\n   n->bytepos = n_start->bytepos;\n   n->type = n_start->type;\n   size = TYPE_PRECISION (n->type) / BITS_PER_UNIT;\n+  uint64_t res_n = n1->n | n2->n;\n \n   for (i = 0, mask = MARKER_MASK; i < size; i++, mask <<= BITS_PER_MARKER)\n     {\n       uint64_t masked1, masked2;\n \n       masked1 = n1->n & mask;\n       masked2 = n2->n & mask;\n-      /* For BIT_XOR_EXPR or PLUS_EXPR, at least one of masked1 and masked2\n-\t has to be 0, for BIT_IOR_EXPR x | x is still x.  */\n-      if (masked1 && masked2 && (code != BIT_IOR_EXPR || masked1 != masked2))\n-\treturn NULL;\n+      /* If at least one byte is 0, all of 0 | x == 0 ^ x == 0 + x == x.  */\n+      if (masked1 && masked2)\n+\t{\n+\t  /* + can carry into upper bits, just punt.  */\n+\t  if (code == PLUS_EXPR)\n+\t    return NULL;\n+\t  /* x | x is still x.  */\n+\t  if (code == BIT_IOR_EXPR && masked1 == masked2)\n+\t    continue;\n+\t  if (code == BIT_XOR_EXPR)\n+\t    {\n+\t      /* x ^ x is 0, but MARKER_BYTE_UNKNOWN stands for\n+\t\t unknown values and unknown ^ unknown is unknown.  */\n+\t      if (masked1 == masked2\n+\t\t  && masked1 != ((uint64_t) MARKER_BYTE_UNKNOWN\n+\t\t\t\t << i * BITS_PER_MARKER))\n+\t\t{\n+\t\t  res_n &= ~mask;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t  /* Otherwise set the byte to unknown, it might still be\n+\t     later masked off.  */\n+\t  res_n |= mask;\n+\t}\n     }\n-  n->n = n1->n | n2->n;\n+  n->n = res_n;\n   n->n_ops = n1->n_ops + n2->n_ops;\n \n   return source_stmt;"}, {"sha": "1e4db5e48189a01f197dac036a5ed9c1dc810e13", "filename": "gcc/testsuite/gcc.dg/optimize-bswapsi-7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/531dae29a67e915a145d908bd2f46d22bc369c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/531dae29a67e915a145d908bd2f46d22bc369c11/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Foptimize-bswapsi-7.c?ref=531dae29a67e915a145d908bd2f46d22bc369c11", "patch": "@@ -0,0 +1,37 @@\n+/* PR tree-optimization/103376 */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target bswap } */\n+/* { dg-options \"-O2 -fno-tree-vectorize -fdump-tree-optimized\" } */\n+/* { dg-additional-options \"-march=z900\" { target s390-*-* } } */\n+\n+static unsigned int\n+f1 (unsigned int x)\n+{\n+  return (x << 24) | (x >> 8);\n+}\n+\n+unsigned int\n+f2 (unsigned *p)\n+{\n+  return ((f1 (p[0]) | (p[0] >> 8)) & 0xff000000U) | (p[0] >> 24) | ((p[0] & 0xff00U) << 8) | ((p[0] & 0xff0000U) >> 8);\n+}\n+\n+unsigned int\n+f3 (unsigned *p)\n+{\n+  return ((f1 (p[0]) | (p[0] & 0x00ff00ffU)) & 0xff00ff00U) | (f1 (f1 (f1 (p[0]))) & 0x00ff00ffU);\n+}\n+\n+unsigned int\n+f4 (unsigned *p)\n+{\n+  return (f1 (p[0]) ^ (p[0] >> 8)) ^ (p[0] >> 24) ^ ((p[0] & 0xff00U) << 8) ^ ((p[0] & 0xff0000U) >> 8);\n+}\n+\n+unsigned int\n+f5 (unsigned *p)\n+{\n+  return (((f1 (p[0]) | (p[0] >> 16)) ^ (p[0] >> 8)) & 0xffff0000U) ^ (p[0] >> 24) ^ ((p[0] & 0xff00U) << 8) ^ ((p[0] & 0xff0000U) >> 8);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"= __builtin_bswap32 \\\\\\(\" 4 \"optimized\" } } */"}]}