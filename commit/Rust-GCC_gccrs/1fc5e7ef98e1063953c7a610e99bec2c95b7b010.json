{"sha": "1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZjNWU3ZWY5OGUxMDYzOTUzYzdhNjEwZTk5YmVjMmM5NWI3YjAxMA==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-10-30T14:57:46Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-10-30T14:57:46Z"}, "message": "Fortran: Update omp atomic for OpenMP 5\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.c (show_omp_clauses): Handle atomic clauses.\n\t(show_omp_node): Call it for atomic.\n\t* gfortran.h (enum gfc_omp_atomic_op): Add GFC_OMP_ATOMIC_UNSET,\n\tremove GFC_OMP_ATOMIC_SEQ_CST and GFC_OMP_ATOMIC_ACQ_REL.\n\t(enum gfc_omp_memorder): Replace OMP_MEMORDER_LAST by\n\tOMP_MEMORDER_UNSET, add OMP_MEMORDER_SEQ_CST/OMP_MEMORDER_RELAXED.\n\t(gfc_omp_clauses): Add capture and atomic_op.\n\t(gfc_code): remove omp_atomic.\n\t* openmp.c (enum omp_mask1): Add atomic, capture, memorder clauses.\n\t(gfc_match_omp_clauses): Match them.\n\t(OMP_ATOMIC_CLAUSES): Add.\n\t(gfc_match_omp_flush): Update for 'last' to 'unset' change.\n\t(gfc_match_omp_oacc_atomic): Removed and placed content ..\n\t(gfc_match_omp_atomic): ... here. Update for OpenMP 5 clauses.\n\t(gfc_match_oacc_atomic): Match directly here.\n\t(resolve_omp_atomic, gfc_resolve_omp_directive): Update.\n\t* parse.c (parse_omp_oacc_atomic): Update for struct gfc_code changes.\n\t* resolve.c (gfc_resolve_blocks): Update assert.\n\t* st.c (gfc_free_statement): Also call for EXEC_O{ACC,MP}_ATOMIC.\n\t* trans-openmp.c (gfc_trans_omp_atomic): Update.\n\t(gfc_trans_omp_flush): Update for 'last' to 'unset' change.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/atomic-2.f90: New test.\n\t* gfortran.dg/gomp/atomic.f90: New test.", "tree": {"sha": "8fa78bc22948839e36c08f990baaed271bec1dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fa78bc22948839e36c08f990baaed271bec1dd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa701610e51ca9e15573ba080cb93ef726252cfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa701610e51ca9e15573ba080cb93ef726252cfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa701610e51ca9e15573ba080cb93ef726252cfc"}], "stats": {"total": 520, "additions": 410, "deletions": 110}, "files": [{"sha": "43b97ba26ff916a578b7529eb8a5395a54f83626", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -1715,6 +1715,36 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n     }\n   if (omp_clauses->depend_source)\n     fputs (\" DEPEND(source)\", dumpfile);\n+  if (omp_clauses->capture)\n+    fputs (\" CAPTURE\", dumpfile);\n+  if (omp_clauses->atomic_op != GFC_OMP_ATOMIC_UNSET)\n+    {\n+      const char *atomic_op;\n+      switch (omp_clauses->atomic_op)\n+\t{\n+\tcase GFC_OMP_ATOMIC_READ: atomic_op = \"READ\"; break;\n+\tcase GFC_OMP_ATOMIC_WRITE: atomic_op = \"WRITE\"; break;\n+\tcase GFC_OMP_ATOMIC_UPDATE: atomic_op = \"UPDATE\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+      fputc (' ', dumpfile);\n+      fputs (atomic_op, dumpfile);\n+    }\n+  if (omp_clauses->memorder != OMP_MEMORDER_UNSET)\n+    {\n+      const char *memorder;\n+      switch (omp_clauses->memorder)\n+\t{\n+\tcase OMP_MEMORDER_ACQ_REL: memorder = \"ACQ_REL\"; break;\n+\tcase OMP_MEMORDER_ACQUIRE: memorder = \"AQUIRE\"; break;\n+\tcase OMP_MEMORDER_RELAXED: memorder = \"RELAXED\"; break;\n+\tcase OMP_MEMORDER_RELEASE: memorder = \"RELEASE\"; break;\n+\tcase OMP_MEMORDER_SEQ_CST: memorder = \"SEQ_CST\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+      fputc (' ', dumpfile);\n+      fputs (memorder, dumpfile);\n+    }\n }\n \n /* Show a single OpenMP or OpenACC directive node and everything underneath it\n@@ -1880,6 +1910,10 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_TASKWAIT:\n     case EXEC_OMP_TASKYIELD:\n       return;\n+    case EXEC_OACC_ATOMIC:\n+    case EXEC_OMP_ATOMIC:\n+      omp_clauses = c->block ? c->block->ext.omp_clauses : NULL;\n+      break;\n     default:\n       break;\n     }"}, {"sha": "9500032f0e3cfda16c115fc79bc124588912949a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -1343,6 +1343,16 @@ enum gfc_omp_if_kind\n   OMP_IF_LAST\n };\n \n+enum gfc_omp_atomic_op\n+{\n+  GFC_OMP_ATOMIC_UNSET = 0,\n+  GFC_OMP_ATOMIC_UPDATE = 1,\n+  GFC_OMP_ATOMIC_READ = 2,\n+  GFC_OMP_ATOMIC_WRITE = 3,\n+  GFC_OMP_ATOMIC_MASK = 3,\n+  GFC_OMP_ATOMIC_SWAP = 16\n+};\n+\n enum gfc_omp_requires_kind\n {\n   /* Keep in sync with gfc_namespace, esp. with omp_req_mem_order.  */\n@@ -1363,10 +1373,12 @@ enum gfc_omp_requires_kind\n \n enum gfc_omp_memorder\n {\n+  OMP_MEMORDER_UNSET,\n+  OMP_MEMORDER_SEQ_CST,\n   OMP_MEMORDER_ACQ_REL,\n   OMP_MEMORDER_RELEASE,\n   OMP_MEMORDER_ACQUIRE,\n-  OMP_MEMORDER_LAST\n+  OMP_MEMORDER_RELAXED\n };\n \n typedef struct gfc_omp_clauses\n@@ -1383,7 +1395,8 @@ typedef struct gfc_omp_clauses\n   bool nowait, ordered, untied, mergeable;\n   bool inbranch, notinbranch, defaultmap, nogroup;\n   bool sched_simd, sched_monotonic, sched_nonmonotonic;\n-  bool simd, threads, depend_source, order_concurrent;\n+  bool simd, threads, depend_source, order_concurrent, capture;\n+  enum gfc_omp_atomic_op atomic_op;\n   enum gfc_omp_memorder memorder;\n   enum gfc_omp_cancel_kind cancel;\n   enum gfc_omp_proc_bind_kind proc_bind;\n@@ -2682,18 +2695,6 @@ enum gfc_exec_op\n   EXEC_OMP_TASKLOOP, EXEC_OMP_TASKLOOP_SIMD\n };\n \n-enum gfc_omp_atomic_op\n-{\n-  GFC_OMP_ATOMIC_UPDATE = 0,\n-  GFC_OMP_ATOMIC_READ = 1,\n-  GFC_OMP_ATOMIC_WRITE = 2,\n-  GFC_OMP_ATOMIC_CAPTURE = 3,\n-  GFC_OMP_ATOMIC_MASK = 3,\n-  GFC_OMP_ATOMIC_SEQ_CST = 4,\n-  GFC_OMP_ATOMIC_ACQ_REL = 8,\n-  GFC_OMP_ATOMIC_SWAP = 16\n-};\n-\n typedef struct gfc_code\n {\n   gfc_exec_op op;\n@@ -2748,7 +2749,6 @@ typedef struct gfc_code\n     const char *omp_name;\n     gfc_omp_namelist *omp_namelist;\n     bool omp_bool;\n-    gfc_omp_atomic_op omp_atomic;\n   }\n   ext;\t\t/* Points to additional structures required by statement */\n "}, {"sha": "608ff5a0b559e1dbcf72c661b79d10854299cfb0", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 187, "deletions": 64, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -802,6 +802,9 @@ enum omp_mask1\n   OMP_CLAUSE_USE_DEVICE_PTR,\n   OMP_CLAUSE_USE_DEVICE_ADDR,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_DEVICE_TYPE,  /* OpenMP 5.0.  */\n+  OMP_CLAUSE_ATOMIC,  /* OpenMP 5.0.  */\n+  OMP_CLAUSE_CAPTURE,  /* OpenMP 5.0.  */\n+  OMP_CLAUSE_MEMORDER,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_NOWAIT,\n   /* This must come last.  */\n   OMP_MASK1_LAST\n@@ -1017,6 +1020,22 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t  n->expr = alignment;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_MEMORDER)\n+\t      && c->memorder == OMP_MEMORDER_UNSET\n+\t      && gfc_match (\"acq_rel\") == MATCH_YES)\n+\t    {\n+\t      c->memorder = OMP_MEMORDER_ACQ_REL;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n+\t  if ((mask & OMP_CLAUSE_MEMORDER)\n+\t      && c->memorder == OMP_MEMORDER_UNSET\n+\t      && gfc_match (\"acquire\") == MATCH_YES)\n+\t    {\n+\t      c->memorder = OMP_MEMORDER_ACQUIRE;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_ASYNC)\n \t      && !c->async\n \t      && gfc_match (\"async\") == MATCH_YES)\n@@ -1055,6 +1074,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    continue;\n \t  break;\n \tcase 'c':\n+\t  if ((mask & OMP_CLAUSE_CAPTURE)\n+\t      && !c->capture\n+\t      && gfc_match (\"capture\") == MATCH_YES)\n+\t    {\n+\t      c->capture = true;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_COLLAPSE)\n \t      && !c->collapse)\n \t    {\n@@ -1681,6 +1708,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    }\n \t  break;\n \tcase 'r':\n+\t  if ((mask & OMP_CLAUSE_ATOMIC)\n+\t      && c->atomic_op == GFC_OMP_ATOMIC_UNSET\n+\t      && gfc_match (\"read\") == MATCH_YES)\n+\t    {\n+\t      c->atomic_op = GFC_OMP_ATOMIC_READ;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_REDUCTION)\n \t      && gfc_match (\"reduction ( \") == MATCH_YES)\n \t    {\n@@ -1801,6 +1836,22 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      else\n \t\tgfc_current_locus = old_loc;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_MEMORDER)\n+\t      && c->memorder == OMP_MEMORDER_UNSET\n+\t      && gfc_match (\"relaxed\") == MATCH_YES)\n+\t    {\n+\t      c->memorder = OMP_MEMORDER_RELAXED;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n+\t  if ((mask & OMP_CLAUSE_MEMORDER)\n+\t      && c->memorder == OMP_MEMORDER_UNSET\n+\t      && gfc_match (\"release\") == MATCH_YES)\n+\t    {\n+\t      c->memorder = OMP_MEMORDER_RELEASE;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  break;\n \tcase 's':\n \t  if ((mask & OMP_CLAUSE_SAFELEN)\n@@ -1885,6 +1936,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_MEMORDER)\n+\t      && c->memorder == OMP_MEMORDER_UNSET\n+\t      && gfc_match (\"seq_cst\") == MATCH_YES)\n+\t    {\n+\t      c->memorder = OMP_MEMORDER_SEQ_CST;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_SHARED)\n \t      && gfc_match_omp_variable_list (\"shared (\",\n \t\t\t\t\t      &c->lists[OMP_LIST_SHARED],\n@@ -1945,6 +2004,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      c->untied = needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_ATOMIC)\n+\t      && c->atomic_op == GFC_OMP_ATOMIC_UNSET\n+\t      && gfc_match (\"update\") == MATCH_YES)\n+\t    {\n+\t      c->atomic_op = GFC_OMP_ATOMIC_UPDATE;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_USE_DEVICE)\n \t      && gfc_match_omp_variable_list (\"use_device (\",\n \t\t\t\t\t      &c->lists[OMP_LIST_USE_DEVICE],\n@@ -2026,6 +2093,14 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tneeds_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_ATOMIC)\n+\t      && c->atomic_op == GFC_OMP_ATOMIC_UNSET\n+\t      && gfc_match (\"write\") == MATCH_YES)\n+\t    {\n+\t      c->atomic_op = GFC_OMP_ATOMIC_WRITE;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  break;\n \t}\n       break;\n@@ -2658,6 +2733,9 @@ gfc_match_oacc_routine (void)\n   (omp_mask (OMP_CLAUSE_THREADS) | OMP_CLAUSE_SIMD)\n #define OMP_DECLARE_TARGET_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_TO) | OMP_CLAUSE_LINK | OMP_CLAUSE_DEVICE_TYPE)\n+#define OMP_ATOMIC_CLAUSES \\\n+  (omp_mask (OMP_CLAUSE_ATOMIC) | OMP_CLAUSE_CAPTURE | OMP_CLAUSE_HINT\t\\\n+   | OMP_CLAUSE_MEMORDER)\n \n \n static match\n@@ -2768,7 +2846,7 @@ gfc_match_omp_flush (void)\n   gfc_omp_namelist *list = NULL;\n   gfc_omp_clauses *c = NULL;\n   gfc_gobble_whitespace ();\n-  enum gfc_omp_memorder mo = OMP_MEMORDER_LAST;\n+  enum gfc_omp_memorder mo = OMP_MEMORDER_UNSET;\n   if (gfc_match_omp_eos () == MATCH_NO && gfc_peek_ascii_char () != '(')\n     {\n       if (gfc_match (\"acq_rel\") == MATCH_YES)\n@@ -2786,7 +2864,7 @@ gfc_match_omp_flush (void)\n       c->memorder = mo;\n     }\n   gfc_match_omp_variable_list (\" (\", &list, true);\n-  if (list && mo != OMP_MEMORDER_LAST)\n+  if (list && mo != OMP_MEMORDER_UNSET)\n     {\n       gfc_error (\"List specified together with memory order clause in FLUSH \"\n \t\t \"directive at %C\");\n@@ -4014,49 +4092,28 @@ gfc_match_omp_ordered_depend (void)\n }\n \n \n-static match\n-gfc_match_omp_oacc_atomic (bool omp_p)\n+/* omp atomic [clause-list]\n+   - atomic-clause:  read | write | update\n+   - capture\n+   - memory-order-clause: seq_cst | acq_rel | release | acquire | relaxed\n+   - hint(hint-expr)\n+*/\n+\n+match\n+gfc_match_omp_atomic (void)\n {\n-  gfc_omp_atomic_op op = GFC_OMP_ATOMIC_UPDATE;\n-  int seq_cst = 0;\n-  if (gfc_match (\"% seq_cst\") == MATCH_YES)\n-    seq_cst = 1;\n-  locus old_loc = gfc_current_locus;\n-  if (seq_cst && gfc_match_char (',') == MATCH_YES)\n-    seq_cst = 2;\n-  if (seq_cst == 2\n-      || gfc_match_space () == MATCH_YES)\n-    {\n-      gfc_gobble_whitespace ();\n-      if (gfc_match (\"update\") == MATCH_YES)\n-\top = GFC_OMP_ATOMIC_UPDATE;\n-      else if (gfc_match (\"read\") == MATCH_YES)\n-\top = GFC_OMP_ATOMIC_READ;\n-      else if (gfc_match (\"write\") == MATCH_YES)\n-\top = GFC_OMP_ATOMIC_WRITE;\n-      else if (gfc_match (\"capture\") == MATCH_YES)\n-\top = GFC_OMP_ATOMIC_CAPTURE;\n-      else\n-\t{\n-\t  if (seq_cst == 2)\n-\t    gfc_current_locus = old_loc;\n-\t  goto finish;\n-\t}\n-      if (!seq_cst\n-\t  && (gfc_match (\", seq_cst\") == MATCH_YES\n-\t      || gfc_match (\"% seq_cst\") == MATCH_YES))\n-\tseq_cst = 1;\n-    }\n- finish:\n-  if (gfc_match_omp_eos () != MATCH_YES)\n-    {\n-      gfc_error (\"Unexpected junk after $OMP ATOMIC statement at %C\");\n-      return MATCH_ERROR;\n-    }\n-  new_st.op = (omp_p ? EXEC_OMP_ATOMIC : EXEC_OACC_ATOMIC);\n-  if (seq_cst)\n-    op = (gfc_omp_atomic_op) (op | GFC_OMP_ATOMIC_SEQ_CST);\n-  else if (omp_p)\n+  gfc_omp_clauses *c;\n+  locus loc = gfc_current_locus;\n+\n+  if (gfc_match_omp_clauses (&c, OMP_ATOMIC_CLAUSES, true, true) != MATCH_YES)\n+    return MATCH_ERROR;\n+  if (c->atomic_op == GFC_OMP_ATOMIC_UNSET)\n+    c->atomic_op = GFC_OMP_ATOMIC_UPDATE;\n+\n+  if (c->capture && c->atomic_op != GFC_OMP_ATOMIC_UPDATE)\n+    gfc_error (\"OMP ATOMIC at %L with CAPTURE clause must be UPDATE\", &loc);\n+\n+  if (c->memorder == OMP_MEMORDER_UNSET)\n     {\n       gfc_namespace *prog_unit = gfc_current_ns;\n       while (prog_unit->parent)\n@@ -4065,32 +4122,95 @@ gfc_match_omp_oacc_atomic (bool omp_p)\n \t{\n \tcase 0:\n \tcase OMP_REQ_ATOMIC_MEM_ORDER_RELAXED:\n+\t  c->memorder = OMP_MEMORDER_RELAXED;\n \t  break;\n \tcase OMP_REQ_ATOMIC_MEM_ORDER_SEQ_CST:\n-\t  op = (gfc_omp_atomic_op) (op | GFC_OMP_ATOMIC_SEQ_CST);\n+\t  c->memorder = OMP_MEMORDER_SEQ_CST;\n \t  break;\n \tcase OMP_REQ_ATOMIC_MEM_ORDER_ACQ_REL:\n-\t  op = (gfc_omp_atomic_op) (op | GFC_OMP_ATOMIC_ACQ_REL);\n+\t  if (c->atomic_op == GFC_OMP_ATOMIC_READ)\n+\t    c->memorder = OMP_MEMORDER_ACQUIRE;\n+\t  else if (c->atomic_op == GFC_OMP_ATOMIC_READ)\n+\t    c->memorder = OMP_MEMORDER_RELEASE;\n+\t  else\n+\t    c->memorder = OMP_MEMORDER_ACQ_REL;\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n-  new_st.ext.omp_atomic = op;\n+  else\n+    switch (c->atomic_op)\n+      {\n+      case GFC_OMP_ATOMIC_READ:\n+\tif (c->memorder == OMP_MEMORDER_ACQ_REL\n+\t    || c->memorder == OMP_MEMORDER_RELEASE)\n+\t  {\n+\t    gfc_error (\"!$OMP ATOMIC READ at %L incompatible with \"\n+\t\t       \"ACQ_REL or RELEASE clauses\", &loc);\n+\t    c->memorder = OMP_MEMORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      case GFC_OMP_ATOMIC_WRITE:\n+\tif (c->memorder == OMP_MEMORDER_ACQ_REL\n+\t    || c->memorder == OMP_MEMORDER_ACQUIRE)\n+\t  {\n+\t    gfc_error (\"!$OMP ATOMIC WRITE at %L incompatible with \"\n+\t\t       \"ACQ_REL or ACQUIRE clauses\", &loc);\n+\t    c->memorder = OMP_MEMORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      case GFC_OMP_ATOMIC_UPDATE:\n+\tif (c->memorder == OMP_MEMORDER_ACQ_REL\n+\t    || c->memorder == OMP_MEMORDER_ACQUIRE)\n+\t  {\n+\t    gfc_error (\"!$OMP ATOMIC UPDATE at %L incompatible with \"\n+\t\t       \"ACQ_REL or ACQUIRE clauses\", &loc);\n+\t    c->memorder = OMP_MEMORDER_SEQ_CST;\n+\t  }\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+  gfc_error_check ();\n+  new_st.ext.omp_clauses = c;\n+  new_st.op = EXEC_OMP_ATOMIC;\n   return MATCH_YES;\n }\n \n+\n+/* acc atomic [ read | write | update | capture]\n+   acc atomic update capture.  */\n+\n match\n gfc_match_oacc_atomic (void)\n {\n-  return gfc_match_omp_oacc_atomic (false);\n+  gfc_omp_clauses *c = gfc_get_omp_clauses ();\n+  c->atomic_op = GFC_OMP_ATOMIC_UPDATE;\n+  c->memorder = OMP_MEMORDER_RELAXED;\n+  gfc_gobble_whitespace ();\n+  if (gfc_match (\"update capture\") == MATCH_YES)\n+    c->capture = true;\n+  else if (gfc_match (\"update\") == MATCH_YES)\n+    ;\n+  else if (gfc_match (\"read\") == MATCH_YES)\n+    c->atomic_op = GFC_OMP_ATOMIC_READ;\n+  else if (gfc_match (\"write\") == MATCH_YES)\n+    c->atomic_op = GFC_OMP_ATOMIC_WRITE;\n+  else if (gfc_match (\"capture\") == MATCH_YES)\n+    c->capture = true;\n+  gfc_gobble_whitespace ();\n+  if (gfc_match_omp_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Unexpected junk after !$ACC ATOMIC statement at %C\");\n+      gfc_free_omp_clauses (c);\n+      return MATCH_ERROR;\n+    }\n+  new_st.ext.omp_clauses = c;\n+  new_st.op = EXEC_OACC_ATOMIC;\n+  return MATCH_YES;\n }\n \n-match\n-gfc_match_omp_atomic (void)\n-{\n-  return gfc_match_omp_oacc_atomic (true);\n-}\n \n match\n gfc_match_omp_barrier (void)\n@@ -5514,11 +5634,12 @@ is_conversion (gfc_expr *expr, bool widening)\n static void\n resolve_omp_atomic (gfc_code *code)\n {\n-  gfc_code *atomic_code = code;\n+  gfc_code *atomic_code = code->block;\n   gfc_symbol *var;\n   gfc_expr *expr2, *expr2_tmp;\n   gfc_omp_atomic_op aop\n-    = (gfc_omp_atomic_op) (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK);\n+    = (gfc_omp_atomic_op) (atomic_code->ext.omp_clauses->atomic_op\n+\t\t\t   & GFC_OMP_ATOMIC_MASK);\n \n   code = code->block->next;\n   /* resolve_blocks asserts this is initially EXEC_ASSIGN.\n@@ -5531,7 +5652,7 @@ resolve_omp_atomic (gfc_code *code)\n       gfc_error (\"unexpected !$OMP ATOMIC expression at %L\", &code->loc);\n       return;\n     }\n-  if (aop != GFC_OMP_ATOMIC_CAPTURE)\n+  if (!atomic_code->ext.omp_clauses->capture)\n     {\n       if (code->next != NULL)\n \tgoto unexpected;\n@@ -5591,7 +5712,11 @@ resolve_omp_atomic (gfc_code *code)\n \t\t   \"must be scalar and cannot reference var at %L\",\n \t\t   &expr2->where);\n       return;\n-    case GFC_OMP_ATOMIC_CAPTURE:\n+    default:\n+      break;\n+    }\n+  if (atomic_code->ext.omp_clauses->capture)\n+    {\n       expr2_tmp = expr2;\n       if (expr2 == code->expr2)\n \t{\n@@ -5640,9 +5765,6 @@ resolve_omp_atomic (gfc_code *code)\n \t  if (expr2 == NULL)\n \t    expr2 = code->expr2;\n \t}\n-      break;\n-    default:\n-      break;\n     }\n \n   if (gfc_expr_attr (code->expr1).allocatable)\n@@ -5652,12 +5774,12 @@ resolve_omp_atomic (gfc_code *code)\n       return;\n     }\n \n-  if (aop == GFC_OMP_ATOMIC_CAPTURE\n+  if (atomic_code->ext.omp_clauses->capture\n       && code->next == NULL\n       && code->expr2->rank == 0\n       && !expr_references_sym (code->expr2, var, NULL))\n-    atomic_code->ext.omp_atomic\n-      = (gfc_omp_atomic_op) (atomic_code->ext.omp_atomic\n+    atomic_code->ext.omp_clauses->atomic_op\n+      = (gfc_omp_atomic_op) (atomic_code->ext.omp_clauses->atomic_op\n \t\t\t     | GFC_OMP_ATOMIC_SWAP);\n   else if (expr2->expr_type == EXPR_OP)\n     {\n@@ -5867,7 +5989,7 @@ resolve_omp_atomic (gfc_code *code)\n     gfc_error (\"!$OMP ATOMIC assignment must have an operator or \"\n \t       \"intrinsic on right hand side at %L\", &expr2->where);\n \n-  if (aop == GFC_OMP_ATOMIC_CAPTURE && code->next)\n+  if (atomic_code->ext.omp_clauses->capture && code->next)\n     {\n       code = code->next;\n       if (code->expr1->expr_type != EXPR_VARIABLE\n@@ -6866,6 +6988,7 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns ATTRIBUTE_UNUSED)\n \t\t   \"FROM clause\", &code->loc);\n       break;\n     case EXEC_OMP_ATOMIC:\n+      resolve_omp_clauses (code, code->block->ext.omp_clauses, NULL);\n       resolve_omp_atomic (code);\n       break;\n     case EXEC_OMP_CRITICAL:"}, {"sha": "e57669c51e5bf4334203fad86259a65b2d13debb", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -5062,9 +5062,9 @@ parse_omp_oacc_atomic (bool omp_p)\n   np = new_level (cp);\n   np->op = cp->op;\n   np->block = NULL;\n-  np->ext.omp_atomic = cp->ext.omp_atomic;\n-  count = 1 + ((cp->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n-\t       == GFC_OMP_ATOMIC_CAPTURE);\n+  np->ext.omp_clauses = cp->ext.omp_clauses;\n+  cp->ext.omp_clauses = NULL;\n+  count = 1 + np->ext.omp_clauses->capture;\n \n   while (count)\n     {\n@@ -5090,8 +5090,7 @@ parse_omp_oacc_atomic (bool omp_p)\n       gfc_warning_check ();\n       st = next_statement ();\n     }\n-  else if ((cp->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n-\t   == GFC_OMP_ATOMIC_CAPTURE)\n+  else if (np->ext.omp_clauses->capture)\n     gfc_error (\"Missing !$OMP END ATOMIC after !$OMP ATOMIC CAPTURE at %C\");\n   return st;\n }"}, {"sha": "45c144517f251ad94fad8b82657ad7c86999f541", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -10731,15 +10731,12 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \tcase EXEC_OMP_ATOMIC:\n \tcase EXEC_OACC_ATOMIC:\n \t  {\n-\t    gfc_omp_atomic_op aop\n-\t      = (gfc_omp_atomic_op) (b->ext.omp_atomic & GFC_OMP_ATOMIC_MASK);\n-\n \t    /* Verify this before calling gfc_resolve_code, which might\n \t       change it.  */\n \t    gcc_assert (b->next && b->next->op == EXEC_ASSIGN);\n-\t    gcc_assert (((aop != GFC_OMP_ATOMIC_CAPTURE)\n+\t    gcc_assert ((!b->ext.omp_clauses->capture\n \t\t\t && b->next->next == NULL)\n-\t\t\t|| ((aop == GFC_OMP_ATOMIC_CAPTURE)\n+\t\t\t|| (b->ext.omp_clauses->capture\n \t\t\t    && b->next->next != NULL\n \t\t\t    && b->next->next->op == EXEC_ASSIGN\n \t\t\t    && b->next->next->next == NULL));"}, {"sha": "a3b0f12b17109d14f1e0d5b92f1e83d1b31d1724", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -198,6 +198,7 @@ gfc_free_statement (gfc_code *p)\n \tgfc_free_oacc_declare_clauses (p->ext.oacc_declare);\n       break;\n \n+    case EXEC_OACC_ATOMIC:\n     case EXEC_OACC_PARALLEL_LOOP:\n     case EXEC_OACC_PARALLEL:\n     case EXEC_OACC_KERNELS_LOOP:\n@@ -213,6 +214,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OACC_ENTER_DATA:\n     case EXEC_OACC_EXIT_DATA:\n     case EXEC_OACC_ROUTINE:\n+    case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_CRITICAL:\n@@ -266,8 +268,6 @@ gfc_free_statement (gfc_code *p)\n       gfc_free_omp_namelist (p->ext.omp_namelist);\n       break;\n \n-    case EXEC_OACC_ATOMIC:\n-    case EXEC_OMP_ATOMIC:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_MASTER:\n     case EXEC_OMP_END_NOWAIT:"}, {"sha": "d02949ecbe4a4fb99905e19783c726cd89450299", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -3967,7 +3967,7 @@ static tree gfc_trans_omp_workshare (gfc_code *, gfc_omp_clauses *);\n static tree\n gfc_trans_omp_atomic (gfc_code *code)\n {\n-  gfc_code *atomic_code = code;\n+  gfc_code *atomic_code = code->block;\n   gfc_se lse;\n   gfc_se rse;\n   gfc_se vse;\n@@ -3979,12 +3979,16 @@ gfc_trans_omp_atomic (gfc_code *code)\n   enum tree_code aop = OMP_ATOMIC;\n   bool var_on_left = false;\n   enum omp_memory_order mo;\n-  if (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SEQ_CST)\n-    mo = OMP_MEMORY_ORDER_SEQ_CST;\n-  else if (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_ACQ_REL)\n-    mo = OMP_MEMORY_ORDER_ACQ_REL;\n-  else\n-    mo = OMP_MEMORY_ORDER_RELAXED;\n+  switch (atomic_code->ext.omp_clauses->memorder)\n+    {\n+    case OMP_MEMORDER_UNSET: mo = OMP_MEMORY_ORDER_UNSPECIFIED; break;\n+    case OMP_MEMORDER_ACQ_REL: mo = OMP_MEMORY_ORDER_ACQ_REL; break;\n+    case OMP_MEMORDER_ACQUIRE: mo = OMP_MEMORY_ORDER_ACQUIRE; break;\n+    case OMP_MEMORDER_RELAXED: mo = OMP_MEMORY_ORDER_RELAXED; break;\n+    case OMP_MEMORDER_RELEASE: mo = OMP_MEMORY_ORDER_RELEASE; break;\n+    case OMP_MEMORDER_SEQ_CST: mo = OMP_MEMORY_ORDER_SEQ_CST; break;\n+    default: gcc_unreachable ();\n+    }\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n@@ -3996,16 +4000,16 @@ gfc_trans_omp_atomic (gfc_code *code)\n   gfc_start_block (&block);\n \n   expr2 = code->expr2;\n-  if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+  if (((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n        != GFC_OMP_ATOMIC_WRITE)\n       && expr2->expr_type == EXPR_FUNCTION\n       && expr2->value.function.isym\n       && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n     expr2 = expr2->value.function.actual->expr;\n \n-  switch (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+  if ((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n+      == GFC_OMP_ATOMIC_READ)\n     {\n-    case GFC_OMP_ATOMIC_READ:\n       gfc_conv_expr (&vse, code->expr1);\n       gfc_add_block_to_block (&block, &vse.pre);\n \n@@ -4023,7 +4027,9 @@ gfc_trans_omp_atomic (gfc_code *code)\n       gfc_add_block_to_block (&block, &rse.pre);\n \n       return gfc_finish_block (&block);\n-    case GFC_OMP_ATOMIC_CAPTURE:\n+    }\n+  if (atomic_code->ext.omp_clauses->capture)\n+    {\n       aop = OMP_ATOMIC_CAPTURE_NEW;\n       if (expr2->expr_type == EXPR_VARIABLE)\n \t{\n@@ -4042,19 +4048,16 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t      && expr2->value.function.isym->id == GFC_ISYM_CONVERSION)\n \t    expr2 = expr2->value.function.actual->expr;\n \t}\n-      break;\n-    default:\n-      break;\n     }\n \n   gfc_conv_expr (&lse, code->expr1);\n   gfc_add_block_to_block (&block, &lse.pre);\n   type = TREE_TYPE (lse.expr);\n   lhsaddr = gfc_build_addr_expr (NULL, lse.expr);\n \n-  if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+  if (((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n        == GFC_OMP_ATOMIC_WRITE)\n-      || (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SWAP))\n+      || (atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_SWAP))\n     {\n       gfc_conv_expr (&rse, expr2);\n       gfc_add_block_to_block (&block, &rse.pre);\n@@ -4190,9 +4193,9 @@ gfc_trans_omp_atomic (gfc_code *code)\n \n   rhs = gfc_evaluate_now (rse.expr, &block);\n \n-  if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)\n+  if (((atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_MASK)\n        == GFC_OMP_ATOMIC_WRITE)\n-      || (atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_SWAP))\n+      || (atomic_code->ext.omp_clauses->atomic_op & GFC_OMP_ATOMIC_SWAP))\n     x = rhs;\n   else\n     {\n@@ -4791,7 +4794,7 @@ gfc_trans_omp_flush (gfc_code *code)\n {\n   tree call;\n   if (!code->ext.omp_clauses\n-      || code->ext.omp_clauses->memorder == OMP_MEMORDER_LAST)\n+      || code->ext.omp_clauses->memorder == OMP_MEMORDER_UNSET)\n     {\n       call = builtin_decl_explicit (BUILT_IN_SYNC_SYNCHRONIZE);\n       call = build_call_expr_loc (input_location, call, 0);"}, {"sha": "5094caa515402eb1690effac7549afff04d8b6a1", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-2.f90?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+\n+subroutine bar\n+  integer :: i, v\n+  real :: f\n+  !$omp atomic update acq_rel hint(\"abc\") ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+    ! { dg-error \"HINT clause at .1. requires a scalar INTEGER expression\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"Value of HINT clause at .1. shall be a valid constant hint expression\" \"\" { target *-*-* } .-2 }\n+    i = i + 1\n+  !$omp end atomic\n+\n+  !$omp atomic acq_rel capture ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+\n+  !$omp atomic capture,acq_rel , hint (1), update ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+\n+  !$omp atomic hint(0),acquire capture ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+\n+  !$omp atomic write capture ! { dg-error \"OMP ATOMIC at .1. with CAPTURE clause must be UPDATE\" }\n+  i = 2\n+  v = i\n+  !$omp end atomic\n+\n+  !$omp atomic foobar ! { dg-error \"Failed to match clause\" }\n+end"}, {"sha": "8a1cf5b1f6856de1125759c1032501f9e0ecc444", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic.f90", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fc5e7ef98e1063953c7a610e99bec2c95b7b010/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic.f90?ref=1fc5e7ef98e1063953c7a610e99bec2c95b7b010", "patch": "@@ -0,0 +1,111 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp atomic relaxed\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp atomic release\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture relaxed\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture release\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic read acquire\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp atomic seq_cst\" 7 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic read seq_cst\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture seq_cst\" 6 \"original\" } }\n+\n+\n+subroutine foo ()\n+  integer :: x, v\n+  !$omp atomic\n+  i = i + 2\n+\n+  !$omp atomic relaxed\n+  i = i + 2\n+\n+  !$omp atomic seq_cst read\n+  v = x\n+  !$omp atomic seq_cst, read\n+  v = x\n+  !$omp atomic seq_cst write\n+  x = v\n+  !$omp atomic seq_cst ,write\n+  x = v\n+  !$omp atomic seq_cst update\n+  x = x + v\n+  !$omp atomic seq_cst , update\n+  x = x + v\n+  !$omp atomic seq_cst capture\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic update seq_cst capture\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic seq_cst, capture\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic seq_cst, capture, update\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic read , seq_cst\n+  v = x\n+  !$omp atomic write ,seq_cst\n+  x = v\n+  !$omp atomic update, seq_cst\n+  x = x + v\n+  !$omp atomic capture, seq_cst\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic capture, seq_cst ,update\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+end\n+\n+subroutine bar\n+  integer :: i, v\n+  real :: f\n+  !$omp atomic release, hint (0), update\n+  i = i + 1\n+  !$omp end atomic\n+  !$omp atomic hint(0)seq_cst\n+  i = i + 1\n+  !$omp atomic relaxed,update,hint (0)\n+  i = i + 1\n+  !$omp atomic release\n+  i = i + 1\n+  !$omp atomic relaxed\n+  i = i + 1\n+  !$omp atomic relaxed capture update\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic relaxed capture\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic capture,release , hint (1)\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic update capture,release , hint (1)\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic hint(0),relaxed capture\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic hint(0),update relaxed capture\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic read acquire\n+  v = i\n+  !$omp atomic release,write\n+  i = v\n+  !$omp atomic hint(1),update,release\n+  f = f + 2.0\n+end"}]}