{"sha": "7bea4023f2128cde89e4d7942c988b5145bfac19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlYTQwMjNmMjEyOGNkZTg5ZTRkNzk0MmM5ODhiNTE0NWJmYWMxOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-06-04T05:34:59Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-06-04T05:34:59Z"}, "message": "runtime: Better SWIG interface for allocating Go memory from C/C++.\n\nFrom-SVN: r188164", "tree": {"sha": "77d873edc7e97c39f5ed4f5de2a3da54a835ba74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77d873edc7e97c39f5ed4f5de2a3da54a835ba74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bea4023f2128cde89e4d7942c988b5145bfac19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bea4023f2128cde89e4d7942c988b5145bfac19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bea4023f2128cde89e4d7942c988b5145bfac19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bea4023f2128cde89e4d7942c988b5145bfac19/comments", "author": null, "committer": null, "parents": [{"sha": "7b4cf2664334bce391a661d72d4367da728c3fca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4cf2664334bce391a661d72d4367da728c3fca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b4cf2664334bce391a661d72d4367da728c3fca"}], "stats": {"total": 152, "additions": 149, "deletions": 3}, "files": [{"sha": "cacc55623be690fc9ffc138d19a08e04ef45262f", "filename": "libgo/go/syscall/libcall_support.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bea4023f2128cde89e4d7942c988b5145bfac19/libgo%2Fgo%2Fsyscall%2Flibcall_support.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bea4023f2128cde89e4d7942c988b5145bfac19/libgo%2Fgo%2Fsyscall%2Flibcall_support.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_support.go?ref=7bea4023f2128cde89e4d7942c988b5145bfac19", "patch": "@@ -10,3 +10,9 @@ func Entersyscall()\n func Exitsyscall()\n func GetErrno() Errno\n func SetErrno(Errno)\n+\n+// These functions are used by CGO and SWIG.\n+func Cgocall()\n+func CgocallDone()\n+func CgocallBack()\n+func CgocallBackDone()"}, {"sha": "173696e737d7af9f5e02976f55e612632eea51e8", "filename": "libgo/runtime/go-cgo.c", "status": "modified", "additions": 139, "deletions": 3, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bea4023f2128cde89e4d7942c988b5145bfac19/libgo%2Fruntime%2Fgo-cgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bea4023f2128cde89e4d7942c988b5145bfac19/libgo%2Fruntime%2Fgo-cgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cgo.c?ref=7bea4023f2128cde89e4d7942c988b5145bfac19", "patch": "@@ -4,19 +4,129 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n+#include \"runtime.h\"\n #include \"go-alloc.h\"\n #include \"interface.h\"\n #include \"go-panic.h\"\n #include \"go-string.h\"\n \n+/* Go memory allocated by code not written in Go.  We keep a linked\n+   list of these allocations so that the garbage collector can see\n+   them.  */\n+\n+struct cgoalloc\n+{\n+  struct cgoalloc *next;\n+  void *alloc;\n+};\n+\n+/* Prepare to call from code written in Go to code written in C or\n+   C++.  This takes the current goroutine out of the Go scheduler, as\n+   though it were making a system call.  Otherwise the program can\n+   lock up if the C code goes to sleep on a mutex or for some other\n+   reason.  This idea is to call this function, then immediately call\n+   the C/C++ function.  After the C/C++ function returns, call\n+   syscall_cgocalldone.  The usual Go code would look like\n+\n+       syscall.Cgocall()\n+       defer syscall.Cgocalldone()\n+       cfunction()\n+\n+   */\n+\n+/* We let Go code call these via the syscall package.  */\n+void syscall_cgocall(void) __asm__ (\"syscall.Cgocall\");\n+void syscall_cgocalldone(void) __asm__ (\"syscall.CgocallDone\");\n+void syscall_cgocallback(void) __asm__ (\"syscall.CgocallBack\");\n+void syscall_cgocallbackdone(void) __asm__ (\"syscall.CgocallBackDone\");\n+\n+void\n+syscall_cgocall ()\n+{\n+  M* m;\n+  G* g;\n+\n+  m = runtime_m ();\n+  ++m->ncgocall;\n+  g = runtime_g ();\n+  ++g->ncgo;\n+  runtime_entersyscall ();\n+}\n+\n+/* Prepare to return to Go code from C/C++ code.  */\n+\n+void\n+syscall_cgocalldone ()\n+{\n+  G* g;\n+\n+  g = runtime_g ();\n+  __go_assert (g != NULL);\n+  --g->ncgo;\n+  if (g->ncgo == 0)\n+    {\n+      /* We are going back to Go, and we are not in a recursive call.\n+\t Let the garbage collector clean up any unreferenced\n+\t memory.  */\n+      g->cgoalloc = NULL;\n+    }\n+\n+  /* If we are invoked because the C function called _cgo_panic, then\n+     _cgo_panic will already have exited syscall mode.  */\n+  if (g->status == Gsyscall)\n+    runtime_exitsyscall ();\n+}\n+\n+/* Call back from C/C++ code to Go code.  */\n+\n+void\n+syscall_cgocallback ()\n+{\n+  runtime_exitsyscall ();\n+}\n+\n+/* Prepare to return to C/C++ code from a callback to Go code.  */\n+\n+void\n+syscall_cgocallbackdone ()\n+{\n+  runtime_entersyscall ();\n+}\n+\n+/* Allocate memory and save it in a list visible to the Go garbage\n+   collector.  */\n+\n+void *\n+alloc_saved (size_t n)\n+{\n+  void *ret;\n+  G *g;\n+  struct cgoalloc *c;\n+\n+  ret = __go_alloc (n);\n+\n+  g = runtime_g ();\n+  c = (struct cgoalloc *) __go_alloc (sizeof (struct cgoalloc));\n+  c->next = g->cgoalloc;\n+  c->alloc = ret;\n+  g->cgoalloc = c;\n+\n+  return ret;\n+}\n+\n /* These are routines used by SWIG.  The gc runtime library provides\n    the same routines under the same name, though in that case the code\n    is required to import runtime/cgo.  */\n \n void *\n _cgo_allocate (size_t n)\n {\n-  return __go_alloc (n);\n+  void *ret;\n+\n+  runtime_exitsyscall ();\n+  ret = alloc_saved (n);\n+  runtime_entersyscall ();\n+  return ret;\n }\n \n extern const struct __go_type_descriptor string_type_descriptor\n@@ -30,13 +140,39 @@ _cgo_panic (const char *p)\n   struct __go_string *ps;\n   struct __go_empty_interface e;\n \n+  runtime_exitsyscall ();\n   len = __builtin_strlen (p);\n-  data = __go_alloc (len);\n+  data = alloc_saved (len);\n   __builtin_memcpy (data, p, len);\n-  ps = __go_alloc (sizeof *ps);\n+  ps = alloc_saved (sizeof *ps);\n   ps->__data = data;\n   ps->__length = len;\n   e.__type_descriptor = &string_type_descriptor;\n   e.__object = ps;\n+\n+  /* We don't call runtime_entersyscall here, because normally what\n+     will happen is that we will walk up the stack to a Go deferred\n+     function that calls recover.  However, this will do the wrong\n+     thing if this panic is recovered and the stack unwinding is\n+     caught by a C++ exception handler.  It might be possible to\n+     handle this by calling runtime_entersyscall in the personality\n+     function in go-unwind.c.  FIXME.  */\n+\n   __go_panic (e);\n }\n+\n+/* Return the number of CGO calls.  */\n+\n+int64 runtime_NumCgoCall (void) __asm__ (\"runtime.NumCgoCall\");\n+\n+int64\n+runtime_NumCgoCall (void)\n+{\n+  int64 ret;\n+  M* m;\n+\n+  ret = 0;\n+  for (m = runtime_atomicloadp (&runtime_allm); m != NULL; m = m->alllink)\n+    ret += m->ncgocall;\n+  return ret;\n+}"}, {"sha": "76a9eef4fd658e4b679e4d55baf40771beaf17bd", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bea4023f2128cde89e4d7942c988b5145bfac19/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bea4023f2128cde89e4d7942c988b5145bfac19/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=7bea4023f2128cde89e4d7942c988b5145bfac19", "patch": "@@ -153,6 +153,9 @@ struct\tG\n \t// uintptr\tsigpc;\n \tuintptr\tgopc;\t// pc of go statement that created this goroutine\n \n+\tint32\tncgo;\n+\tstruct cgoalloc *cgoalloc;\n+\n \tTraceback* traceback;\n \n \tucontext_t\tcontext;\n@@ -174,6 +177,7 @@ struct\tM\n \tint32\tprofilehz;\n \tint32\thelpgc;\n \tuint32\tfastrand;\n+\tuint64\tncgocall;\n \tNote\thavenextg;\n \tG*\tnextg;\n \tM*\talllink;\t// on allm"}]}