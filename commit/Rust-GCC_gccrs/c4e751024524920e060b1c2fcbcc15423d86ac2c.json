{"sha": "c4e751024524920e060b1c2fcbcc15423d86ac2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRlNzUxMDI0NTI0OTIwZTA2MGIxYzJmY2JjYzE1NDIzZDg2YWMyYw==", "commit": {"author": {"name": "Matt Thomas", "email": "matt@gcc.gnu.org", "date": "2009-04-01T17:00:00Z"}, "committer": {"name": "Matt Thomas", "email": "matt@gcc.gnu.org", "date": "2009-04-01T17:00:00Z"}, "message": "[multiple changes]\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/vax.c: Add #includes to silence warnings.\n\tChange #include order to silence two warnings.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/linux.h (TARGET_DEFAULT): Add the MASK_QMATH flag bit.\n\t(ASM_SPEC): Pass -k to the assembler for PIC code.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config.gcc: Add vax-*-linux* to the switch.\n\t* gcc/config/vax/linux.h: New file. (TARGET_VERSION,\n\tTARGET_OS_CPP_BUILTINS, TARGET_DEFAULT, CPP_SPEC, LINK_SPEC): Define.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/vax.c (vax_output_int_move, adjacent_operands_p):\n\tUse predicate macros instead of GET_CODE() == foo.\n\t* gcc/config/vax/vax.md (movsi_2, movstrictqi, and<mode>3, ashrsi3,\n\tashlsi3, rotrsi3, <unnamed>): Likewise.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/builtins.md (jbbssiqi, jbbssihi, jbbssisi, jbbcciqi,\n\tjbbccihi, jbbccisi): Remova trailing whitespace.\n\t* gcc/config/vax/constraints.md: Likewise.\n\t* gcc/config/vax/elf.h: (ASM_PREFERRED_EH_DATA_FORMAT): Likewise.\n\t* gcc/config/vax/openbsd1.h (OBSD_OLD_GAS): Likewise.\n\t* gcc/config/vax/predicates.md: Likewise.\n\t* gcc/config/vax/vax.c (print_operand_address, vax_output_int_move,\n\tvax_expand_addsub_di_operands, adjacent_operands_p): Likewise.\n\t* gcc/config/vax/vax.h: Likewise.\n\t* gcc/config/vax/vax.md (nonlocal_goto): Likewise.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/vax.c (vax_float_literal, vax_output_int_move)\n\t(indirectable_address_p, adjacent_operands_p): Add spaces around\n\tbraces.\n\t* gcc/config/vax/vax-protos.h (adjacent_operands_p): Likewise.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/vax.c (legitimate_constant_address_p,\n\tlegitimate_constant_p, indirectable_address_p, nonindexed_address_p,\n\tindex_term_p, reg_plus_index_p, legitimate_address_p,\n\tvax_mode_dependent_address_p): Update comments to match functions\n\tmodified by the recent int->bool conversion.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/builtins.md: Update copyright message.\n\t* gcc/config/vax/constraints.md: Likewise.\n\t* gcc/config/vax/netbsd-elf.h: Likewise.\n\t* gcc/config/vax/predicates.md: Likewise.\n\t* gcc/config/vax/vax-protos.h: Likewise.\n\t* gcc/config/vax/vax.c: Likewise.\n\t* gcc/config/vax/vax.h: Likewise.\n\t* gcc/config/vax/vax.md: Likewise.\n\t* gcc/config/vax/vax.opt: Likewise.\n\n2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n\n\t* gcc/config/vax/builtins.md (ffssi2, ffssi2_internal,\n\tsync_lock_test_and_set<mode>, sync_lock_release<mode>): Fix indention.\n\t* gcc/config/vax/constraints.md (B, R): Likewise.\n\t* gcc/config/vax/predicates.md (external_memory_operand,\n\tnonimmediate_addsub_di_operand): Likewise.\n\t* gcc/config/vax/vax.c (vax_output_int_add): Likewise.\n\t* gcc/config/vax/vax.md (movsi, movsi_2, mov<mode>, call_value,\n\tuntyped_call): Likewise.\n\n2009-04-01\tMatt Thomas <matt@3am-software.com>\n\n\t* config/vax/predicates.md: New file. (symbolic_operand,\n\tlocal_symbolic_operand, external_symbolic_operand,\n\texternal_const_operand, nonsymbolic_operand, external_memory_operand,\n\tindirect_memory_operand, indexed_memory_operand,\n\tillegal_blk_memory_operand, illegal_addsub_di_memory_operand,\n\tnonimmediate_addsub_di_operand, general_addsub_di_operand): New\n\tpredicate.\n\t* config/vax/constraints.md: New file. (Z0, U06,  U08, U16, CN6, S08,\n\tS16, I, J, K, L, M, N, O, G, Q, B, R, T): New constraint.\n\t* config/vax/builtins.md: New file. (ffssi2, ffssi2_internal,\n\tsync_lock_test_and_set<mode>, jbbssiqi, jbbssihi, jbbssisi,\n\tsync_lock_release<mode>, jbbcciqi, jbbccihi, jbbccisi): Define.\n\t* config/vax/vax.opt (mqmath): Add option.\n\t* config/vax/vax.md (isfx): Extend with DI.\n\t(VAXintQH, VAXintQHSD): Define.\n\t(tst<mode>, cmp<mode>, *bit<mode>, movmemhi1, truncsiqi2, truncsihi2,\n\tmulsidi3, add<mode>3, sub<mode>, mul<mode>3, div<mode>3, and<mode>,\n\tand<mode>_const_int, ior<mode>3, xor<mode>3, neg<mode>2,\n\tone_cmpl<mode>2, ashlsi3, lshrsi3, rotlsi3): Update constraints.\n\t(movdi): Update constraints and use vax_output_int_move().\n\t(movsi, movsi_2, pushlclsymreg, pushextsymreg, movlclsymreg,\n\tmovextsymreg, adddi3, adcdi3, subdi3, sbcdi3, pushextsym, movextsym,\n\tpushlclsym, movlclsym, movaddr<mode>, pushaddr<mode>,\n\tnonlocal_goto): New.\n\t(mov<mode>): Extend accepted operand types.\n\t(subdi3_old): Rename from subdi3, change update constraints and use\n\ta new implementation.\n\t* gcc/config/vax/vax.h (PCC_BITFIELD_TYPE_MATTERS): Add space.\n\t(FRAME_POINTER_CFA_OFFSET, IRA_COVER_CLASSES, CLASS_MAX_NREGS,\n\tMOVE_RATIO, CLEAR_RATIO): Define.\n\t(REG_CLASS_FROM_LETTER, CONST_OK_FOR_LETTER_P,\n\tCONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT): Delete.\n\t(PRINT_OPERAND): Redefine using a function instead of inlined code.\n\t* gcc/config/vax/vax.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Define.\n\t(split_quadword_operands): Make static and really allow variable\n\tsplitting.\n\t(print_operand_address): Update for PIC generation.\n\t(print_operand, vax_builtin_setjmp_frame_value, vax_output_int_subtract,\n\tindexable_address_p, fixup_mathdi_operand,\n\tvax_expand_addsub_di_operands, adjacent_operands_p): New.\n\t(vax_float_literal, legitimate_constant_p,\n\tindirectable_constant_address_p, index_term_p,\n\treg_plus_index_p): Return bool instead of int.\n\t(vax_rtx_costs): Fix cost for CONST_INT, indent and use HOST_WIDE_INT\n\twhere needed.\n\t(vax_output_int_move, vax_output_int_add): Extend to allow PIC\n\tgeneration.\n\t(vax_output_conditional_branch): Indent.\n\t(legitimate_constant_address_p, indirectable_constant_address_p,\n\tindirectable_address_p, nonindexed_address_p, legitimate_address_p,\n\tvax_mode_dependent_address_p): Return bool instead of int, update for\n\tPIC generation.\n\t* config/vax/vax-protos.h (legitimate_constant_address_p,\n\tlegitimate_constant_p, legitimate_address_p,\n\tvax_mode_dependent_address_p): Change declaration to bool.\n\t(legitimate_pic_operand_p, adjacent_operands_p, print_operand,\n\tvax_expand_addsub_di_operands, vax_output_int_subtract,\n\tvax_output_movmemsi): Declare.\n\t(split_quadword_operands, vax_float_literal): Delete declaration.\n\t* config/vax/netbsd-elf.h (CC1_SPEC, CC1PLUS_SPEC) Define.\n\t* config/vax/elf.h (NO_EXTERNAL_INDIRECT_ADDRESS,\n\tVAX_CC1_AND_CC1PLUS_SPEC, ASM_PREFERRED_EH_DATA_FORMAT,\n\tASM_OUTPUT_DWARF_PCREL): Define.\n\t(ASM_SPEC): Change definition to allow PIC generation.\n\nFrom-SVN: r145416", "tree": {"sha": "5cd091f5d591832d9cff57b0e72cf44d18c4d8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cd091f5d591832d9cff57b0e72cf44d18c4d8a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4e751024524920e060b1c2fcbcc15423d86ac2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e751024524920e060b1c2fcbcc15423d86ac2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4e751024524920e060b1c2fcbcc15423d86ac2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4e751024524920e060b1c2fcbcc15423d86ac2c/comments", "author": null, "committer": null, "parents": [{"sha": "60911f14c3cd3fe787c4dd745df22e324410ce0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60911f14c3cd3fe787c4dd745df22e324410ce0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60911f14c3cd3fe787c4dd745df22e324410ce0c"}], "stats": {"total": 2321, "additions": 1827, "deletions": 494}, "files": [{"sha": "d90743413c171901f674c82744f1d7ac1b60f77b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,3 +1,144 @@\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/vax.c: Add #includes to silence warnings.\n+\tChange #include order to silence two warnings.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/linux.h (TARGET_DEFAULT): Add the MASK_QMATH flag bit.\n+\t(ASM_SPEC): Pass -k to the assembler for PIC code.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config.gcc: Add vax-*-linux* to the switch.\n+\t* gcc/config/vax/linux.h: New file. (TARGET_VERSION,\n+\tTARGET_OS_CPP_BUILTINS, TARGET_DEFAULT, CPP_SPEC, LINK_SPEC): Define.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/vax.c (vax_output_int_move, adjacent_operands_p):\n+\tUse predicate macros instead of GET_CODE() == foo.\n+\t* gcc/config/vax/vax.md (movsi_2, movstrictqi, and<mode>3, ashrsi3,\n+\tashlsi3, rotrsi3, <unnamed>): Likewise.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/builtins.md (jbbssiqi, jbbssihi, jbbssisi, jbbcciqi,\n+\tjbbccihi, jbbccisi): Remova trailing whitespace.\n+\t* gcc/config/vax/constraints.md: Likewise.\n+\t* gcc/config/vax/elf.h: (ASM_PREFERRED_EH_DATA_FORMAT): Likewise.\n+\t* gcc/config/vax/openbsd1.h (OBSD_OLD_GAS): Likewise.\n+\t* gcc/config/vax/predicates.md: Likewise.\n+\t* gcc/config/vax/vax.c (print_operand_address, vax_output_int_move,\n+\tvax_expand_addsub_di_operands, adjacent_operands_p): Likewise.\n+\t* gcc/config/vax/vax.h: Likewise.\n+\t* gcc/config/vax/vax.md (nonlocal_goto): Likewise.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/vax.c (vax_float_literal, vax_output_int_move)\n+\t(indirectable_address_p, adjacent_operands_p): Add spaces around\n+\tbraces.\n+\t* gcc/config/vax/vax-protos.h (adjacent_operands_p): Likewise.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/vax.c (legitimate_constant_address_p,\n+\tlegitimate_constant_p, indirectable_address_p, nonindexed_address_p,\n+\tindex_term_p, reg_plus_index_p, legitimate_address_p,\n+\tvax_mode_dependent_address_p): Update comments to match functions\n+\tmodified by the recent int->bool conversion.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/builtins.md: Update copyright message.\n+\t* gcc/config/vax/constraints.md: Likewise.\n+\t* gcc/config/vax/netbsd-elf.h: Likewise.\n+\t* gcc/config/vax/predicates.md: Likewise.\n+\t* gcc/config/vax/vax-protos.h: Likewise.\n+\t* gcc/config/vax/vax.c: Likewise.\n+\t* gcc/config/vax/vax.h: Likewise.\n+\t* gcc/config/vax/vax.md: Likewise.\n+\t* gcc/config/vax/vax.opt: Likewise.\n+\n+2009-04-01\tJan-Benedict Glaw <jbglaw@jbglaw-dev.homezone.telefonica.de>\n+\n+\t* gcc/config/vax/builtins.md (ffssi2, ffssi2_internal,\n+\tsync_lock_test_and_set<mode>, sync_lock_release<mode>): Fix indention.\n+\t* gcc/config/vax/constraints.md (B, R): Likewise.\n+\t* gcc/config/vax/predicates.md (external_memory_operand,\n+\tnonimmediate_addsub_di_operand): Likewise.\n+\t* gcc/config/vax/vax.c (vax_output_int_add): Likewise.\n+\t* gcc/config/vax/vax.md (movsi, movsi_2, mov<mode>, call_value,\n+\tuntyped_call): Likewise.\n+\n+2009-04-01\tMatt Thomas <matt@3am-software.com>\n+\n+\t* config/vax/predicates.md: New file. (symbolic_operand,\n+\tlocal_symbolic_operand, external_symbolic_operand,\n+\texternal_const_operand, nonsymbolic_operand, external_memory_operand,\n+\tindirect_memory_operand, indexed_memory_operand,\n+\tillegal_blk_memory_operand, illegal_addsub_di_memory_operand,\n+\tnonimmediate_addsub_di_operand, general_addsub_di_operand): New\n+\tpredicate.\n+\t* config/vax/constraints.md: New file. (Z0, U06,  U08, U16, CN6, S08,\n+\tS16, I, J, K, L, M, N, O, G, Q, B, R, T): New constraint.\n+\t* config/vax/builtins.md: New file. (ffssi2, ffssi2_internal,\n+\tsync_lock_test_and_set<mode>, jbbssiqi, jbbssihi, jbbssisi,\n+\tsync_lock_release<mode>, jbbcciqi, jbbccihi, jbbccisi): Define.\n+\t* config/vax/vax.opt (mqmath): Add option.\n+\t* config/vax/vax.md (isfx): Extend with DI.\n+\t(VAXintQH, VAXintQHSD): Define.\n+\t(tst<mode>, cmp<mode>, *bit<mode>, movmemhi1, truncsiqi2, truncsihi2,\n+\tmulsidi3, add<mode>3, sub<mode>, mul<mode>3, div<mode>3, and<mode>,\n+\tand<mode>_const_int, ior<mode>3, xor<mode>3, neg<mode>2,\n+\tone_cmpl<mode>2, ashlsi3, lshrsi3, rotlsi3): Update constraints.\n+\t(movdi): Update constraints and use vax_output_int_move().\n+\t(movsi, movsi_2, pushlclsymreg, pushextsymreg, movlclsymreg,\n+\tmovextsymreg, adddi3, adcdi3, subdi3, sbcdi3, pushextsym, movextsym,\n+\tpushlclsym, movlclsym, movaddr<mode>, pushaddr<mode>,\n+\tnonlocal_goto): New.\n+\t(mov<mode>): Extend accepted operand types.\n+\t(subdi3_old): Rename from subdi3, change update constraints and use\n+\ta new implementation.\n+\t* gcc/config/vax/vax.h (PCC_BITFIELD_TYPE_MATTERS): Add space.\n+\t(FRAME_POINTER_CFA_OFFSET, IRA_COVER_CLASSES, CLASS_MAX_NREGS,\n+\tMOVE_RATIO, CLEAR_RATIO): Define.\n+\t(REG_CLASS_FROM_LETTER, CONST_OK_FOR_LETTER_P,\n+\tCONST_DOUBLE_OK_FOR_LETTER_P, EXTRA_CONSTRAINT): Delete.\n+\t(PRINT_OPERAND): Redefine using a function instead of inlined code.\n+\t* gcc/config/vax/vax.c (TARGET_BUILTIN_SETJMP_FRAME_VALUE): Define.\n+\t(split_quadword_operands): Make static and really allow variable\n+\tsplitting.\n+\t(print_operand_address): Update for PIC generation.\n+\t(print_operand, vax_builtin_setjmp_frame_value, vax_output_int_subtract,\n+\tindexable_address_p, fixup_mathdi_operand,\n+\tvax_expand_addsub_di_operands, adjacent_operands_p): New.\n+\t(vax_float_literal, legitimate_constant_p,\n+\tindirectable_constant_address_p, index_term_p,\n+\treg_plus_index_p): Return bool instead of int.\n+\t(vax_rtx_costs): Fix cost for CONST_INT, indent and use HOST_WIDE_INT\n+\twhere needed.\n+\t(vax_output_int_move, vax_output_int_add): Extend to allow PIC\n+\tgeneration.\n+\t(vax_output_conditional_branch): Indent.\n+\t(legitimate_constant_address_p, indirectable_constant_address_p,\n+\tindirectable_address_p, nonindexed_address_p, legitimate_address_p,\n+\tvax_mode_dependent_address_p): Return bool instead of int, update for\n+\tPIC generation.\n+\t* config/vax/vax-protos.h (legitimate_constant_address_p,\n+\tlegitimate_constant_p, legitimate_address_p,\n+\tvax_mode_dependent_address_p): Change declaration to bool.\n+\t(legitimate_pic_operand_p, adjacent_operands_p, print_operand,\n+\tvax_expand_addsub_di_operands, vax_output_int_subtract,\n+\tvax_output_movmemsi): Declare.\n+\t(split_quadword_operands, vax_float_literal): Delete declaration.\n+\t* config/vax/netbsd-elf.h (CC1_SPEC, CC1PLUS_SPEC) Define.\n+\t* config/vax/elf.h (NO_EXTERNAL_INDIRECT_ADDRESS,\n+\tVAX_CC1_AND_CC1PLUS_SPEC, ASM_PREFERRED_EH_DATA_FORMAT,\n+\tASM_OUTPUT_DWARF_PCREL): Define.\n+\t(ASM_SPEC): Change definition to allow PIC generation.\n+\n 2009-04-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/39226"}, {"sha": "cf8c91b2f12be315884cdf8b37f9e4a39d4082f0", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -2351,6 +2351,9 @@ v850-*-*)\n \tcxx_target_objs=\"v850-c.o\"\n \tuse_gcc_stdint=wrap\n \t;;\n+vax-*-linux*)\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h linux.h vax/elf.h vax/linux.h\"\n+\t;;\n vax-*-netbsdelf*)\n \ttm_file=\"${tm_file} elfos.h netbsd.h netbsd-elf.h vax/elf.h vax/netbsd-elf.h\"\n \t;;"}, {"sha": "389526b38b065dd24600c14bb97a1483abd7bdcd", "filename": "gcc/config/vax/builtins.md", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fbuiltins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fbuiltins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fbuiltins.md?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -0,0 +1,192 @@\n+;; builtin definitions for DEC VAX.\n+;; Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_constants\n+  [\n+    (VUNSPEC_LOCK 100)\t\t; sync lock and test\n+    (VUNSPEC_UNLOCK 101)\t; sync lock release\n+  ]\n+)\n+\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(ffs:SI (match_operand:SI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx label = gen_label_rtx ();\n+  emit_insn (gen_ffssi2_internal (operands[0], operands[1]));\n+  emit_jump_insn (gen_bne (label));\n+  emit_insn (gen_negsi2 (operands[0], const1_rtx));\n+  emit_label (label);\n+  emit_insn (gen_addsi3 (operands[0], operands[0], const1_rtx));\n+  DONE;\n+}\")\n+\n+(define_insn \"ffssi2_internal\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rQ\")\n+\t(ffs:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")))\n+   (set (cc0) (match_dup 0))]\n+  \"\"\n+  \"ffs $0,$32,%1,%0\")\n+\n+(define_expand \"sync_lock_test_and_set<mode>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=&g\")\n+\t(unspec:VAXint [(match_operand:VAXint 1 \"memory_operand\" \"+m\")\n+\t\t    (match_operand:VAXint 2 \"const_int_operand\" \"n\")\n+\t\t   ] VUNSPEC_LOCK))]\n+  \"\"\n+  \"\n+{\n+  rtx label;\n+\n+  if (operands[2] != const1_rtx)\n+    FAIL;\n+\n+  label = gen_label_rtx ();\n+  emit_move_insn (operands[0], const1_rtx);\n+  emit_jump_insn (gen_jbbssi<mode> (operands[1], const0_rtx, label, operands[1]));\n+  emit_move_insn (operands[0], const0_rtx);\n+  emit_label (label);\n+  DONE;\n+}\")\n+\n+(define_insn \"jbbssiqi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (ne (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"g\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 1 \"general_operand\" \"nrm\"))\n+\t\t(const_int 0))\n+\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t    (pc)))\n+     (set (zero_extract:SI (match_operand:QI 3 \"memory_operand\" \"+0\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_dup 1))\n+\t  (const_int 1))])]\n+  \"\"\n+  \"jbssi %1,%0,%l2\")\n+\n+(define_insn \"jbbssihi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (ne (zero_extract:SI (match_operand:HI 0 \"memory_operand\" \"Q\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 1 \"general_operand\" \"nrm\"))\n+\t\t(const_int 0))\n+\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t    (pc)))\n+     (set (zero_extract:SI (match_operand:HI 3 \"memory_operand\" \"+0\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_dup 1))\n+\t  (const_int 1))])]\n+  \"\"\n+  \"jbssi %1,%0,%l2\")\n+\n+(define_insn \"jbbssisi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (ne (zero_extract:SI (match_operand:SI 0 \"memory_operand\" \"Q\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 1 \"general_operand\" \"nrm\"))\n+\t\t(const_int 0))\n+\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t    (pc)))\n+     (set (zero_extract:SI (match_operand:SI 3 \"memory_operand\" \"+0\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_dup 1))\n+\t  (const_int 1))])]\n+  \"\"\n+  \"jbssi %1,%0,%l2\")\n+\n+\n+(define_expand \"sync_lock_release<mode>\"\n+  [(set (match_operand:VAXint 0 \"memory_operand\" \"+m\")\n+\t(unspec:VAXint [(match_operand:VAXint 1 \"const_int_operand\" \"n\")\n+\t\t   ] VUNSPEC_UNLOCK))]\n+  \"\"\n+  \"\n+{\n+  rtx label;\n+  if (operands[1] != const0_rtx)\n+    FAIL;\n+#if 1\n+  label = gen_label_rtx ();\n+  emit_jump_insn (gen_jbbcci<mode> (operands[0], const0_rtx, label, operands[0]));\n+  emit_label (label);\n+#else\n+  emit_move_insn (operands[0], const0_rtx);\n+#endif\n+  DONE;\n+}\")\n+\n+(define_insn \"jbbcciqi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (eq (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"g\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 1 \"general_operand\" \"nrm\"))\n+\t\t(const_int 0))\n+\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t    (pc)))\n+     (set (zero_extract:SI (match_operand:QI 3 \"memory_operand\" \"+0\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_dup 1))\n+\t  (const_int 0))])]\n+  \"\"\n+  \"jbcci %1,%0,%l2\")\n+\n+(define_insn \"jbbccihi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (eq (zero_extract:SI (match_operand:HI 0 \"memory_operand\" \"Q\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 1 \"general_operand\" \"nrm\"))\n+\t\t(const_int 0))\n+\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t    (pc)))\n+     (set (zero_extract:SI (match_operand:HI 3 \"memory_operand\" \"+0\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_dup 1))\n+\t  (const_int 0))])]\n+  \"\"\n+  \"jbcci %1,%0,%l2\")\n+\n+(define_insn \"jbbccisi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else\n+\t    (eq (zero_extract:SI (match_operand:SI 0 \"memory_operand\" \"Q\")\n+\t\t\t\t (const_int 1)\n+\t\t\t\t (match_operand:SI 1 \"general_operand\" \"nrm\"))\n+\t\t(const_int 0))\n+\t    (label_ref (match_operand 2 \"\" \"\"))\n+\t    (pc)))\n+     (set (zero_extract:SI (match_operand:SI 3 \"memory_operand\" \"+0\")\n+\t\t\t   (const_int 1)\n+\t\t\t   (match_dup 1))\n+\t  (const_int 0))])]\n+  \"\"\n+  \"jbcci %1,%0,%l2\")\n+"}, {"sha": "e3266f676a5f472d4560df145ef447d3e1195f06", "filename": "gcc/config/vax/constraints.md", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fconstraints.md?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -0,0 +1,117 @@\n+;; Constraints for the DEC VAX port.\n+;; Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.  */\n+\n+(define_constraint \"Z0\"\n+   \"Match a CONST_INT of 0\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"ival == 0\")))\n+\n+(define_constraint \"U06\"\n+   \"unsigned 6 bit value (0..63)\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"0 <= ival && ival < 64\")))\n+\n+(define_constraint \"U08\"\n+   \"Unsigned 8 bit value\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"0 <= ival && ival < 256\")))\n+\n+(define_constraint \"U16\"\n+   \"Unsigned 16 bit value\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"0 <= ival && ival < 65536\")))\n+\n+(define_constraint \"CN6\"\n+   \"negative 6 bit value (-63..-1)\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"-63 <= ival && ival < 0\")))\n+\n+(define_constraint \"S08\"\n+   \"signed 8 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"-128 <= ival && ival < 128\")))\n+\n+(define_constraint \"S16\"\n+   \"signed 16 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"-32768 <= ival && ival < 32768\")))\n+\n+(define_constraint \"I\"\n+   \"Match a CONST_INT of 0 [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_Z0 (GEN_INT (ival))\")))\n+\n+(define_constraint \"J\"\n+   \"unsigned 6 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_U06 (GEN_INT (ival))\")))\n+\n+(define_constraint \"K\"\n+   \"signed 8 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_S08 (GEN_INT (ival))\")))\n+\n+(define_constraint \"L\"\n+   \"signed 16 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_S16 (GEN_INT (ival))\")))\n+\n+(define_constraint \"M\"\n+   \"Unsigned 8 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_U08 (GEN_INT (ival))\")))\n+\n+(define_constraint \"N\"\n+   \"Unsigned 16 bit value [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_U16 (GEN_INT (ival))\")))\n+\n+(define_constraint \"O\"\n+   \"Negative short literals (-63..-1) [old]\"\n+   (and (match_code \"const_int\")\n+\t(match_test \"satisfies_constraint_CN6 (GEN_INT (ival))\")))\n+\n+/* Similar, but for floating constants, and defining letters G and H.  */\n+\n+(define_constraint \"G\"\n+  \"Match a floating-point zero\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (DFmode) || op == CONST0_RTX (SFmode)\")))\n+\n+/* Optional extra constraints for this machine. */\n+\n+(define_memory_constraint \"Q\"\n+   \"operand is a MEM that does not have a mode-dependent address.\"\n+   (and (match_code \"mem\")\n+\t(match_test \"!mode_dependent_address_p (XEXP (op, 0))\")))\n+\n+(define_memory_constraint \"B\"\n+    \"\"\n+    (and (match_operand:BLK 0 \"memory_operand\")\n+\t (not (match_operand:BLK 0 \"illegal_blk_memory_operand\" \"\"))))\n+\n+(define_memory_constraint \"R\"\n+    \"\"\n+    (and (match_operand:DI 0 \"memory_operand\")\n+\t (not (match_operand:DI 0 \"illegal_addsub_di_memory_operand\" \"\"))))\n+\n+(define_constraint \"T\"\n+    \"@internal satisfies CONSTANT_P and, if pic is enabled, is not a SYMBOL_REF, LABEL_REF, or CONST.\"\n+   (ior (not (match_code \"const,symbol_ref,label_ref\"))\n+\t(match_test \"!flag_pic\")))"}, {"sha": "c7b3d2124b2ca1631fc9346ff126ca0f2200f530", "filename": "gcc/config/vax/elf.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Felf.h?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -85,8 +85,29 @@ along with GCC; see the file COPYING3.  If not see\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n+/* Don't allow *foo which foo is non-local */\n+#define NO_EXTERNAL_INDIRECT_ADDRESS\n+\n+#undef VAX_CC1_AND_CC1PLUS_SPEC\n+#define VAX_CC1_AND_CC1PLUS_SPEC \\\n+  \"%{!fno-pic: \\\n+     %{!fpic: \\\n+       %{!fPIC:-fPIC}}}\"\n+\n /* VAX ELF is always gas; override the generic VAX ASM_SPEC.  */\n \n #undef ASM_SPEC\n-#define ASM_SPEC \"\"\n-\n+#define ASM_SPEC \"%{!fno-pic: %{!mno-asm-pic:-k}}\"\n+\n+/*  We want PCREL dwarf output.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)\t\\\n+  ((GLOBAL ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4)\n+\n+/* Emit a PC-relative relocation.  */\n+#define ASM_OUTPUT_DWARF_PCREL(FILE, SIZE, LABEL)\t\\\n+  do {\t\t\t\t\t\t\t\\\n+    fputs (integer_asm_op (SIZE, FALSE), FILE);\t\t\\\n+    fprintf (FILE, \"%%pcrel%d(\", SIZE * 8);\t\t\\\n+    assemble_name (FILE, LABEL);\t\t\t\\\n+    fputc (')', FILE);\t\t\t\t\t\\\n+  } while (0)"}, {"sha": "af8ebe9d5db39019e2d47bea4fa8332842a46a55", "filename": "gcc/config/vax/linux.h", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Flinux.h?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -0,0 +1,54 @@\n+/* Definitions for VAX running Linux-based GNU systems with ELF format.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (VAX GNU/Linux with ELF)\");\n+\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+\tLINUX_TARGET_OS_CPP_BUILTINS();\t\t\\\n+\tif (flag_pic)\t\t\t\t\\\n+\t  {\t\t\t\t\t\\\n+\t    builtin_define (\"__PIC__\");\t\t\\\n+\t    builtin_define (\"__pic__\");\t\t\\\n+\t  }\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* We use GAS, G-float double and want new DI patterns.  */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_QMATH | MASK_G_FLOAT)\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}\"\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{fpic|fPIC:-k}\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+ \"%(endian_spec) \\\n+  %{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+      %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}} \\\n+    %{static:-static}}\""}, {"sha": "6ba9249e8ffb04f19aa6f20351fc276accdc5b8d", "filename": "gcc/config/vax/netbsd-elf.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fnetbsd-elf.h?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for NetBSD/vax ELF systems.\n-   Copyright (C) 2002, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2007, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -30,10 +30,16 @@ along with GCC; see the file COPYING3.  If not see\n #undef CPP_SPEC\n #define CPP_SPEC NETBSD_CPP_SPEC\n \n+#undef CC1_SPEC\n+#define CC1_SPEC NETBSD_CC1_AND_CC1PLUS_SPEC VAX_CC1_AND_CC1PLUS_SPEC\n+\n+#undef CC1PLUS_SPEC\n+#define CC1PLUS_SPEC NETBSD_CC1_AND_CC1PLUS_SPEC VAX_CC1_AND_CC1PLUS_SPEC\n+\n #define NETBSD_ENTRY_POINT \"__start\"\n \n #undef LINK_SPEC\n-#if 1\n+#if 0\n /* FIXME: We must link all executables statically until PIC support\n    is added to the compiler.  */\n #define LINK_SPEC \\\n@@ -55,5 +61,4 @@ along with GCC; see the file COPYING3.  If not see\n \n /* We use gas, not the UNIX assembler.  */\n #undef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0\n-\n+#define TARGET_DEFAULT MASK_QMATH"}, {"sha": "84b90e5502568abfa7b1e8d727cf66296477ba0d", "filename": "gcc/config/vax/openbsd1.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fopenbsd1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fopenbsd1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fopenbsd1.h?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -18,5 +18,5 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Set up definitions before picking up the common openbsd.h file.  */\n-#define OBSD_OLD_GAS \n+#define OBSD_OLD_GAS\n #define OBSD_NO_DYNAMIC_LIBRARIES"}, {"sha": "775ddcddfe64a37d7dbf0ef346feca6394575287", "filename": "gcc/config/vax/predicates.md", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fpredicates.md?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -0,0 +1,111 @@\n+;; Predicate definitions for DEC VAX.\n+;; Copyright (C) 2007, 2009 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it under\n+;; the terms of the GNU General Public License as published by the Free\n+;; Software Foundation; either version 3, or (at your option) any later\n+;; version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+;; for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Special case of a symbolic operand that's used as a\n+;; operand.\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\"))\n+\n+(define_predicate \"local_symbolic_operand\"\n+  (match_code \"const,symbol_ref,label_ref\")\n+{\n+  if (GET_CODE (op) == LABEL_REF)\n+    return 1;\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return !flag_pic || SYMBOL_REF_LOCAL_P (op);\n+  if (GET_CODE (XEXP (XEXP (op, 0), 0)) == LABEL_REF)\n+    return 1;\n+  return !flag_pic || SYMBOL_REF_LOCAL_P (XEXP (XEXP (op, 0), 0));\n+})\n+\n+(define_predicate \"external_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (not (match_operand 0 \"local_symbolic_operand\" \"\"))))\n+\n+(define_predicate \"external_const_operand\"\n+  (and (match_code \"const\")\n+       (match_test \"GET_CODE (XEXP (XEXP (op, 0), 0)) == SYMBOL_REF\n+\t\t    && !SYMBOL_REF_LOCAL_P (XEXP (XEXP (op, 0), 0))\")))\n+\n+(define_predicate \"nonsymbolic_operand\"\n+  (and (ior (match_test \"!flag_pic\")\n+\t    (not (match_operand 0 \"symbolic_operand\")))\n+       (match_operand 0 \"general_operand\" \"\")))\n+\n+(define_predicate \"external_memory_operand\"\n+   (match_code \"mem\")\n+{\n+  rtx addr = XEXP (op, 0);\n+  if (MEM_P (addr))\n+    addr = XEXP (addr, 0);\n+  if (GET_CODE (addr) == PLUS)\n+    addr = XEXP (addr, 1);\n+  if (MEM_P (addr))\n+    addr = XEXP (addr, 0);\n+  if (GET_CODE (addr) == PLUS)\n+    addr = XEXP (addr, 1);\n+  return external_symbolic_operand (addr, SImode)\n+\t || external_const_operand (addr, SImode);\n+})\n+\n+(define_predicate \"indirect_memory_operand\"\n+   (match_code \"mem\")\n+{\n+  op = XEXP (op, 0);\n+  if (MEM_P (op))\n+    return 1;\n+  if (GET_CODE (op) == PLUS)\n+    op = XEXP (op, 1);\n+  return MEM_P (op);\n+})\n+\n+(define_predicate \"indexed_memory_operand\"\n+   (match_code \"mem\")\n+{\n+  op = XEXP (op, 0);\n+  return GET_CODE (op) != PRE_DEC && GET_CODE (op) != POST_INC\n+\t && mode_dependent_address_p (op);\n+})\n+\n+(define_predicate \"illegal_blk_memory_operand\"\n+   (and (match_code \"mem\")\n+\t(ior (and (match_test \"flag_pic\")\n+\t\t  (match_operand 0 \"external_memory_operand\" \"\"))\n+\t     (ior (match_operand 0 \"indexed_memory_operand\" \"\")\n+\t\t  (ior (match_operand 0 \"indirect_memory_operand\" \"\")\n+\t\t       (match_test \"GET_CODE (XEXP (op, 0)) == PRE_DEC\"))))))\n+\n+(define_predicate \"illegal_addsub_di_memory_operand\"\n+   (and (match_code \"mem\")\n+\t(ior (and (match_test \"flag_pic\")\n+\t\t  (match_operand 0 \"external_memory_operand\" \"\"))\n+\t     (ior (match_operand 0 \"indexed_memory_operand\" \"\")\n+\t\t  (ior (match_operand 0 \"indirect_memory_operand\" \"\")\n+\t\t       (match_test \"GET_CODE (XEXP (op, 0)) == PRE_DEC\"))))))\n+\n+(define_predicate \"nonimmediate_addsub_di_operand\"\n+   (and (match_code \"subreg,reg,mem\")\n+\t(and (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t     (not (match_operand:DI 0 \"illegal_addsub_di_memory_operand\")))))\n+\n+(define_predicate \"general_addsub_di_operand\"\n+   (and (match_code \"const_int,const_double,subreg,reg,mem\")\n+\t(and (match_operand:DI 0 \"general_operand\" \"\")\n+\t     (not (match_operand:DI 0 \"illegal_addsub_di_memory_operand\")))))"}, {"sha": "9b43d4f86e9ee29d323a0629715c720cbcc3e7a1", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler.  VAX version.\n-   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   Copyright (C) 2000, 2002, 2003, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -19,20 +19,24 @@ along with GCC; see the file COPYING3.  If not see\n \n extern void override_options (void);\n \n-extern int legitimate_constant_address_p (rtx);\n-extern int legitimate_constant_p (rtx);\n-extern int legitimate_address_p (enum machine_mode, rtx, int);\n-extern int vax_mode_dependent_address_p (rtx);\n+extern bool legitimate_constant_address_p (rtx);\n+extern bool legitimate_constant_p (rtx);\n+extern bool legitimate_pic_operand_p (rtx);\n+extern bool legitimate_address_p (enum machine_mode, rtx, bool);\n+extern bool vax_mode_dependent_address_p (rtx);\n \n #ifdef RTX_CODE\n+extern bool adjacent_operands_p (rtx, rtx, enum machine_mode);\n extern const char *rev_cond_name (rtx);\n-extern void split_quadword_operands (rtx *, rtx *, int);\n extern void print_operand_address (FILE *, rtx);\n-extern int vax_float_literal (rtx);\n+extern void print_operand (FILE *, rtx, int);\n extern void vax_notice_update_cc (rtx, rtx);\n+extern void vax_expand_addsub_di_operands (rtx *, enum rtx_code);\n extern const char * vax_output_int_move (rtx, rtx *, enum machine_mode);\n extern const char * vax_output_int_add (rtx, rtx *, enum machine_mode);\n+extern const char * vax_output_int_subtract (rtx, rtx *, enum machine_mode);\n extern const char * vax_output_conditional_branch (enum rtx_code);\n+extern const char * vax_output_movmemsi (rtx, rtx *);\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE"}, {"sha": "e91696947e654ebde61c64d9690b279ddbc05665", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 820, "deletions": 143, "changes": 963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,6 +1,6 @@\n /* Subroutines for insn-output.c for VAX.\n    Copyright (C) 1987, 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2004, 2005, 2006, 2007, 2008\n+   2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n+#include \"df.h\"\n #include \"tree.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n@@ -39,6 +40,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"debug.h\"\n #include \"toplev.h\"\n+#include \"tm-preds.h\"\n+#include \"tm-constrs.h\"\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -52,6 +55,7 @@ static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx, bool);\n static bool vax_rtx_costs (rtx, int, int, int *, bool);\n static rtx vax_struct_value_rtx (tree, int);\n+static rtx vax_builtin_setjmp_frame_value (void);\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -87,6 +91,9 @@ static rtx vax_struct_value_rtx (tree, int);\n #undef TARGET_STRUCT_VALUE_RTX\n #define TARGET_STRUCT_VALUE_RTX vax_struct_value_rtx\n \n+#undef TARGET_BUILTIN_SETJMP_FRAME_VALUE\n+#define TARGET_BUILTIN_SETJMP_FRAME_VALUE vax_builtin_setjmp_frame_value\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Set global variables as needed for the options enabled.  */\n@@ -167,27 +174,34 @@ vax_init_libfuncs (void)\n \n /* This is like nonimmediate_operand with a restriction on the type of MEM.  */\n \n-void\n-split_quadword_operands (rtx * operands, rtx * low, int n ATTRIBUTE_UNUSED)\n+static void\n+split_quadword_operands (rtx insn, enum rtx_code code, rtx * operands,\n+\t\t\t rtx * low, int n)\n {\n   int i;\n-  /* Split operands.  */\n \n-  low[0] = low[1] = low[2] = 0;\n-  for (i = 0; i < 3; i++)\n+  for (i = 0; i < n; i++)\n+    low[i] = 0;\n+\n+  for (i = 0; i < n; i++)\n     {\n-      if (low[i])\n-\t/* it's already been figured out */;\n-      else if (MEM_P (operands[i])\n-\t       && (GET_CODE (XEXP (operands[i], 0)) == POST_INC))\n+      if (MEM_P (operands[i])\n+\t  && (GET_CODE (XEXP (operands[i], 0)) == PRE_DEC\n+\t      || GET_CODE (XEXP (operands[i], 0)) == POST_INC))\n \t{\n \t  rtx addr = XEXP (operands[i], 0);\n \t  operands[i] = low[i] = gen_rtx_MEM (SImode, addr);\n-\t  if (which_alternative == 0 && i == 0)\n-\t    {\n-\t      addr = XEXP (operands[i], 0);\n-\t      operands[i+1] = low[i+1] = gen_rtx_MEM (SImode, addr);\n-\t    }\n+\t}\n+      else if (optimize_size && MEM_P (operands[i])\n+\t       && REG_P (XEXP (operands[i], 0))\n+\t       && (code != MINUS || operands[1] != const0_rtx)\n+\t       && find_regno_note (insn, REG_DEAD,\n+\t\t\t\t   REGNO (XEXP (operands[i], 0))))\n+\t{\n+\t  low[i] = gen_rtx_MEM (SImode,\n+\t\t\t\tgen_rtx_POST_INC (Pmode,\n+\t\t\t\t\t\t  XEXP (operands[i], 0)));\n+\t  operands[i] = gen_rtx_MEM (SImode, XEXP (operands[i], 0));\n \t}\n       else\n \t{\n@@ -200,6 +214,7 @@ split_quadword_operands (rtx * operands, rtx * low, int n ATTRIBUTE_UNUSED)\n void\n print_operand_address (FILE * file, rtx addr)\n {\n+  rtx orig = addr;\n   rtx reg1, breg, ireg;\n   rtx offset;\n \n@@ -344,7 +359,11 @@ print_operand_address (FILE * file, rtx addr)\n       /* If REG1 is nonzero, figure out if it is a base or index register.  */\n       if (reg1)\n \t{\n-\t  if (breg != 0 || (offset && MEM_P (offset)))\n+\t  if (breg\n+\t      || (flag_pic && GET_CODE (addr) == SYMBOL_REF)\n+\t      || (offset\n+\t\t  && (MEM_P (offset)\n+\t\t      || (flag_pic && symbolic_operand (offset, SImode)))))\n \t    {\n \t      gcc_assert (!ireg);\n \t      ireg = reg1;\n@@ -354,7 +373,36 @@ print_operand_address (FILE * file, rtx addr)\n \t}\n \n       if (offset != 0)\n-\toutput_address (offset);\n+\t{\n+\t  if (flag_pic && symbolic_operand (offset, SImode))\n+\t    {\n+\t      if (breg && ireg)\n+\t\t{\n+\t\t  debug_rtx (orig);\n+\t\t  output_operand_lossage (\"symbol used with both base and indexed registers\");\n+\t\t}\n+\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n+\t      if (flag_pic > 1 && GET_CODE (offset) == CONST\n+\t\t  && GET_CODE (XEXP (XEXP (offset, 0), 0)) == SYMBOL_REF\n+\t\t  && !SYMBOL_REF_LOCAL_P (XEXP (XEXP (offset, 0), 0)))\n+\t\t{\n+\t\t  debug_rtx (orig);\n+\t\t  output_operand_lossage (\"symbol with offset used in PIC mode\");\n+\t\t}\n+#endif\n+\n+\t      /* symbol(reg) isn't PIC, but symbol[reg] is.  */\n+\t      if (breg)\n+\t\t{\n+\t\t  ireg = breg;\n+\t\t  breg = 0;\n+\t\t}\n+\n+\t    }\n+\n+\t  output_address (offset);\n+\t}\n \n       if (breg != 0)\n \tfprintf (file, \"(%s)\", reg_names[REGNO (breg)]);\n@@ -372,6 +420,64 @@ print_operand_address (FILE * file, rtx addr)\n       output_addr_const (file, addr);\n     }\n }\n+\n+void\n+print_operand (FILE *file, rtx x, int code)\n+{\n+  if (code == '#')\n+    fputc (ASM_DOUBLE_CHAR, file);\n+  else if (code == '|')\n+    fputs (REGISTER_PREFIX, file);\n+  else if (code == 'C')\n+    fputs (rev_cond_name (x), file);\n+  else if (code == 'D' && CONST_INT_P (x) && INTVAL (x) < 0)\n+    fprintf (file, \"$\" NEG_HWI_PRINT_HEX16, INTVAL (x));\n+  else if (code == 'P' && CONST_INT_P (x))\n+    fprintf (file, \"$\" HOST_WIDE_INT_PRINT_DEC, INTVAL (x) + 1);\n+  else if (code == 'N' && CONST_INT_P (x))\n+    fprintf (file, \"$\" HOST_WIDE_INT_PRINT_DEC, ~ INTVAL (x));\n+  /* rotl instruction cannot deal with negative arguments.  */\n+  else if (code == 'R' && CONST_INT_P (x))\n+    fprintf (file, \"$\" HOST_WIDE_INT_PRINT_DEC, 32 - INTVAL (x));\n+  else if (code == 'H' && CONST_INT_P (x))\n+    fprintf (file, \"$%d\", (int) (0xffff & ~ INTVAL (x)));\n+  else if (code == 'h' && CONST_INT_P (x))\n+    fprintf (file, \"$%d\", (short) - INTVAL (x));\n+  else if (code == 'B' && CONST_INT_P (x))\n+    fprintf (file, \"$%d\", (int) (0xff & ~ INTVAL (x)));\n+  else if (code == 'b' && CONST_INT_P (x))\n+    fprintf (file, \"$%d\", (int) (0xff & - INTVAL (x)));\n+  else if (code == 'M' && CONST_INT_P (x))\n+    fprintf (file, \"$%d\", ~((1 << INTVAL (x)) - 1));\n+  else if (REG_P (x))\n+    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n+  else if (MEM_P (x))\n+    output_address (XEXP (x, 0));\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == SFmode)\n+    {\n+      char dstr[30];\n+      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (x),\n+\t\t       sizeof (dstr), 0, 1);\n+      fprintf (file, \"$0f%s\", dstr);\n+    }\n+  else if (GET_CODE (x) == CONST_DOUBLE && GET_MODE (x) == DFmode)\n+    {\n+      char dstr[30];\n+      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (x),\n+\t\t       sizeof (dstr), 0, 1);\n+      fprintf (file, \"$0%c%s\", ASM_DOUBLE_CHAR, dstr);\n+    }\n+  else\n+    {\n+      if (flag_pic > 1 && symbolic_operand (x, SImode))\n+\t{\n+\t  debug_rtx (x);\n+\t  output_operand_lossage (\"symbol used as immediate operand\");\n+\t}\n+      putc ('$', file);\n+      output_addr_const (file, x);\n+    }\n+}\n \f\n const char *\n rev_cond_name (rtx op)\n@@ -404,22 +510,22 @@ rev_cond_name (rtx op)\n     }\n }\n \n-int\n-vax_float_literal(rtx c)\n+static bool\n+vax_float_literal (rtx c)\n {\n   enum machine_mode mode;\n   REAL_VALUE_TYPE r, s;\n   int i;\n \n   if (GET_CODE (c) != CONST_DOUBLE)\n-    return 0;\n+    return false;\n \n   mode = GET_MODE (c);\n \n   if (c == const_tiny_rtx[(int) mode][0]\n       || c == const_tiny_rtx[(int) mode][1]\n       || c == const_tiny_rtx[(int) mode][2])\n-    return 1;\n+    return true;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (r, c);\n \n@@ -430,13 +536,13 @@ vax_float_literal(rtx c)\n       REAL_VALUE_FROM_INT (s, x, 0, mode);\n \n       if (REAL_VALUES_EQUAL (r, s))\n-\treturn 1;\n+\treturn true;\n       ok = exact_real_inverse (mode, &s);\n       gcc_assert (ok);\n       if (REAL_VALUES_EQUAL (r, s))\n-\treturn 1;\n+\treturn true;\n     }\n-  return 0;\n+  return false;\n }\n \n \n@@ -550,10 +656,13 @@ vax_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t patterns will not match).  */\n     case CONST_INT:\n       if (INTVAL (x) == 0)\n-\treturn true;\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n       if (outer_code == AND)\n \t{\n-          *total = ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077) ? 1 : 2;\n+\t  *total = ((unsigned HOST_WIDE_INT) ~INTVAL (x) <= 077) ? 1 : 2;\n \t  return true;\n \t}\n       if ((unsigned HOST_WIDE_INT) INTVAL (x) <= 077\n@@ -577,7 +686,7 @@ vax_rtx_costs (rtx x, int code, int outer_code, int *total,\n       if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n \t*total = vax_float_literal (x) ? 5 : 8;\n       else\n-        *total = ((CONST_DOUBLE_HIGH (x) == 0\n+\t*total = ((CONST_DOUBLE_HIGH (x) == 0\n \t\t   && (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x) < 64)\n \t\t  || (outer_code == PLUS\n \t\t      && CONST_DOUBLE_HIGH (x) == -1\n@@ -783,7 +892,7 @@ vax_rtx_costs (rtx x, int code, int outer_code, int *total,\n \t  else\n \t    {\n \t      if (CONST_DOUBLE_HIGH (op) != 0\n-\t\t  || (unsigned)CONST_DOUBLE_LOW (op) > 63)\n+\t\t  || (unsigned HOST_WIDE_INT)CONST_DOUBLE_LOW (op) > 63)\n \t\t*total += 2;\n \t    }\n \t  break;\n@@ -812,10 +921,10 @@ vax_rtx_costs (rtx x, int code, int outer_code, int *total,\n \n static void\n vax_output_mi_thunk (FILE * file,\n-                     tree thunk ATTRIBUTE_UNUSED,\n-                     HOST_WIDE_INT delta,\n-                     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n-                     tree function)\n+\t\t     tree thunk ATTRIBUTE_UNUSED,\n+\t\t     HOST_WIDE_INT delta,\n+\t\t     HOST_WIDE_INT vcall_offset ATTRIBUTE_UNUSED,\n+\t\t     tree function)\n {\n   fprintf (file, \"\\t.word 0x0ffc\\n\\taddl2 $\" HOST_WIDE_INT_PRINT_DEC, delta);\n   asm_fprintf (file, \",4(%Rap)\\n\");\n@@ -831,6 +940,12 @@ vax_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n   return gen_rtx_REG (Pmode, VAX_STRUCT_VALUE_REGNUM);\n }\n \n+static rtx\n+vax_builtin_setjmp_frame_value (void)\n+{\n+  return hard_frame_pointer_rtx;\n+}\n+\n /* Worker function for NOTICE_UPDATE_CC.  */\n \n void\n@@ -906,28 +1021,161 @@ const char *\n vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t\t     enum machine_mode mode)\n {\n+  rtx hi[3], lo[3];\n+  const char *pattern_hi, *pattern_lo;\n+\n   switch (mode)\n     {\n+    case DImode:\n+      if (operands[1] == const0_rtx)\n+\treturn \"clrq %0\";\n+      if (TARGET_QMATH && optimize_size\n+\t  && (CONST_INT_P (operands[1])\n+\t      || GET_CODE (operands[1]) == CONST_DOUBLE))\n+\t{\n+\t  unsigned HOST_WIDE_INT hval, lval;\n+\t  int n;\n+\n+\t  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t    {\n+\t      gcc_assert (HOST_BITS_PER_WIDE_INT != 64);\n+\n+\t      /* Make sure only the low 32 bits are valid.  */\n+\t      lval = CONST_DOUBLE_LOW (operands[1]) & 0xffffffff;\n+\t      hval = CONST_DOUBLE_HIGH (operands[1]) & 0xffffffff;\n+\t    }\n+\t  else\n+\t    {\n+\t      lval = INTVAL (operands[1]);\n+\t      hval = 0;\n+\t    }\n+\n+\t  /* Here we see if we are trying to see if the 64bit value is really\n+\t     a 6bit shifted some arbitrary amount.  If so, we can use ashq to\n+\t     shift it to the correct value saving 7 bytes (1 addr-mode-byte +\n+\t     8 bytes - 1 shift byte - 1 short literal byte.  */\n+\t  if (lval != 0\n+\t      && (n = exact_log2 (lval & (- lval))) != -1\n+\t      && (lval >> n) < 64)\n+\t    {\n+\t      lval >>= n;\n+\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t      /* On 32bit platforms, if the 6bits didn't overflow into the\n+\t\t upper 32bit value that value better be 0.  If we have\n+\t\t overflowed, make sure it wasn't too much.  */\n+\t      if (hval != 0)\n+\t\t{\n+\t\t  if (n <= 26 || hval >= ((unsigned)1 << (n - 26)))\n+\t\t    n = 0;\t/* failure */\n+\t\t  else\n+\t\t    lval |= hval << (32 - n);\n+\t\t}\n+#endif\n+\t      /*  If n is 0, then ashq is not the best way to emit this.  */\n+\t      if (n > 0)\n+\t\t{\n+\t\t  operands[1] = GEN_INT (lval);\n+\t\t  operands[2] = GEN_INT (n);\n+\t\t  return \"ashq %2,%1,%0\";\n+\t\t}\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t    }\n+\t  /* On 32bit platforms, if the low 32bit value is 0, checkout the\n+\t     upper 32bit value.  */\n+\t  else if (hval != 0\n+\t\t   && (n = exact_log2 (hval & (- hval)) - 1) != -1\n+\t\t   && (hval >> n) < 64)\n+\t    {\n+\t      operands[1] = GEN_INT (hval >> n);\n+\t      operands[2] = GEN_INT (n + 32);\n+\t      return \"ashq %2,%1,%0\";\n+#endif\n+\t    }\n+\t}\n+\n+      if (TARGET_QMATH\n+\t  && (!MEM_P (operands[0])\n+\t      || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t      || GET_CODE (XEXP (operands[0], 0)) == POST_INC\n+\t      || !illegal_addsub_di_memory_operand (operands[0], DImode))\n+\t  && ((CONST_INT_P (operands[1])\n+\t       && (unsigned HOST_WIDE_INT) INTVAL (operands[1]) >= 64)\n+\t      || GET_CODE (operands[1]) == CONST_DOUBLE))\n+\t{\n+\t  hi[0] = operands[0];\n+\t  hi[1] = operands[1];\n+\n+\t  split_quadword_operands (insn, SET, hi, lo, 2);\n+\n+\t  pattern_lo = vax_output_int_move (NULL, lo, SImode);\n+\t  pattern_hi = vax_output_int_move (NULL, hi, SImode);\n+\n+\t  /* The patterns are just movl/movl or pushl/pushl then a movq will\n+\t     be shorter (1 opcode byte + 1 addrmode byte + 8 immediate value\n+\t     bytes .vs. 2 opcode bytes + 2 addrmode bytes + 8 immediate value\n+\t     value bytes.  */\n+\t  if ((!strncmp (pattern_lo, \"movl\", 4)\n+\t      && !strncmp (pattern_hi, \"movl\", 4))\n+\t      || (!strncmp (pattern_lo, \"pushl\", 5)\n+\t\t  && !strncmp (pattern_hi, \"pushl\", 5)))\n+\t    return \"movq %1,%0\";\n+\n+\t  if (MEM_P (operands[0])\n+\t      && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+\t    {\n+\t      output_asm_insn (pattern_hi, hi);\n+\t      operands[0] = lo[0];\n+\t      operands[1] = lo[1];\n+\t      operands[2] = lo[2];\n+\t      return pattern_lo;\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (pattern_lo, lo);\n+\t      operands[0] = hi[0];\n+\t      operands[1] = hi[1];\n+\t      operands[2] = hi[2];\n+\t      return pattern_hi;\n+\t    }\n+\t}\n+      return \"movq %1,%0\";\n+\n     case SImode:\n-      if (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n+      if (symbolic_operand (operands[1], SImode))\n \t{\n \t  if (push_operand (operands[0], SImode))\n \t    return \"pushab %a1\";\n \t  return \"movab %a1,%0\";\n \t}\n+\n       if (operands[1] == const0_rtx)\n-\treturn \"clrl %0\";\n+\t{\n+\t  if (push_operand (operands[1], SImode))\n+\t    return \"pushl %1\";\n+\t  return \"clrl %0\";\n+\t}\n+\n       if (CONST_INT_P (operands[1])\n-\t  && (unsigned) INTVAL (operands[1]) >= 64)\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (operands[1]) >= 64)\n \t{\n-\t  int i = INTVAL (operands[1]);\n-\t  if ((unsigned)(~i) < 64)\n+\t  HOST_WIDE_INT i = INTVAL (operands[1]);\n+\t  int n;\n+\t  if ((unsigned HOST_WIDE_INT)(~i) < 64)\n \t    return \"mcoml %N1,%0\";\n-\t  if ((unsigned)i < 0x100)\n+\t  if ((unsigned HOST_WIDE_INT)i < 0x100)\n \t    return \"movzbl %1,%0\";\n \t  if (i >= -0x80 && i < 0)\n \t    return \"cvtbl %1,%0\";\n-\t  if ((unsigned)i < 0x10000)\n+\t  if (optimize_size\n+\t      && (n = exact_log2 (i & (-i))) != -1\n+\t      && ((unsigned HOST_WIDE_INT)i >> n) < 64)\n+\t    {\n+\t      operands[1] = GEN_INT ((unsigned HOST_WIDE_INT)i >> n);\n+\t      operands[2] = GEN_INT (n);\n+\t      return \"ashl %2,%1,%0\";\n+\t    }\n+\t  if ((unsigned HOST_WIDE_INT)i < 0x10000)\n \t    return \"movzwl %1,%0\";\n \t  if (i >= -0x8000 && i < 0)\n \t    return \"cvtwl %1,%0\";\n@@ -939,25 +1187,27 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n     case HImode:\n       if (CONST_INT_P (operands[1]))\n \t{\n-\t  int i = INTVAL (operands[1]);\n+\t  HOST_WIDE_INT i = INTVAL (operands[1]);\n \t  if (i == 0)\n \t    return \"clrw %0\";\n-\t  else if ((unsigned int)i < 64)\n+\t  else if ((unsigned HOST_WIDE_INT)i < 64)\n \t    return \"movw %1,%0\";\n-\t  else if ((unsigned int)~i < 64)\n+\t  else if ((unsigned HOST_WIDE_INT)~i < 64)\n \t    return \"mcomw %H1,%0\";\n-\t  else if ((unsigned int)i < 256)\n+\t  else if ((unsigned HOST_WIDE_INT)i < 256)\n \t    return \"movzbw %1,%0\";\n+\t  else if (i >= -0x80 && i < 0)\n+\t    return \"cvtbw %1,%0\";\n \t}\n       return \"movw %1,%0\";\n \n     case QImode:\n       if (CONST_INT_P (operands[1]))\n \t{\n-\t  int i = INTVAL (operands[1]);\n+\t  HOST_WIDE_INT i = INTVAL (operands[1]);\n \t  if (i == 0)\n \t    return \"clrb %0\";\n-\t  else if ((unsigned int)~i < 64)\n+\t  else if ((unsigned HOST_WIDE_INT)~i < 64)\n \t    return \"mcomb %B1,%0\";\n \t}\n       return \"movb %1,%0\";\n@@ -982,11 +1232,96 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n    which are not modified very often.  */\n \n const char *\n-vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n-\t\t    enum machine_mode mode)\n+vax_output_int_add (rtx insn, rtx *operands, enum machine_mode mode)\n {\n   switch (mode)\n     {\n+    case DImode:\n+      {\n+\trtx low[3];\n+\tconst char *pattern;\n+\tint carry = 1;\n+\tbool sub;\n+\n+\tif (TARGET_QMATH && 0)\n+\t  debug_rtx (insn);\n+\n+\tsplit_quadword_operands (insn, PLUS, operands, low, 3);\n+\n+\tif (TARGET_QMATH)\n+\t  {\n+\t    gcc_assert (rtx_equal_p (operands[0], operands[1]));\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESSS\n+\t    gcc_assert (!flag_pic || !external_memory_operand (low[2], SImode));\n+\t    gcc_assert (!flag_pic || !external_memory_operand (low[0], SImode));\n+#endif\n+\n+\t    /* No reason to add a 0 to the low part and thus no carry, so just\n+\t       emit the appropriate add/sub instruction.  */\n+\t    if (low[2] == const0_rtx)\n+\t      return vax_output_int_add (NULL, operands, SImode);\n+\n+\t    /* Are we doing addition or subtraction?  */\n+\t    sub = CONST_INT_P (operands[2]) && INTVAL (operands[2]) < 0;\n+\n+\t    /* We can't use vax_output_int_add since some the patterns don't\n+\t       modify the carry bit.  */\n+\t    if (sub)\n+\t      {\n+\t\tif (low[2] == constm1_rtx)\n+\t\t  pattern = \"decl %0\";\n+\t\telse\n+\t\t  pattern = \"subl2 $%n2,%0\";\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (low[2] == const1_rtx)\n+\t\t  pattern = \"incl %0\";\n+\t\telse\n+\t\t  pattern = \"addl2 %2,%0\";\n+\t      }\n+\t    output_asm_insn (pattern, low);\n+\n+\t    /* In 2's complement, -n = ~n + 1.  Since we are dealing with\n+\t       two 32bit parts, we complement each and then add one to\n+\t       low part.  We know that the low part can't overflow since\n+\t       it's value can never be 0.  */\n+\t    if (sub)\n+\t\treturn \"sbwc %N2,%0\";\n+\t    return \"adwc %2,%0\";\n+\t  }\n+\n+\t/* Add low parts.  */\n+\tif (rtx_equal_p (operands[0], operands[1]))\n+\t  {\n+\t    if (low[2] == const0_rtx)\n+\t/* Should examine operand, punt if not POST_INC.  */\n+\t      pattern = \"tstl %0\", carry = 0;\n+\t    else if (low[2] == const1_rtx)\n+\t      pattern = \"incl %0\";\n+\t    else\n+\t      pattern = \"addl2 %2,%0\";\n+\t  }\n+\telse\n+\t  {\n+\t    if (low[2] == const0_rtx)\n+\t      pattern = \"movl %1,%0\", carry = 0;\n+\t    else\n+\t      pattern = \"addl3 %2,%1,%0\";\n+\t  }\n+\tif (pattern)\n+\t  output_asm_insn (pattern, low);\n+\tif (!carry)\n+\t  /* If CARRY is 0, we don't have any carry value to worry about.  */\n+\t  return get_insn_template (CODE_FOR_addsi3, insn);\n+\t/* %0 = C + %1 + %2 */\n+\tif (!rtx_equal_p (operands[0], operands[1]))\n+\t  output_asm_insn ((operands[1] == const0_rtx\n+\t\t\t    ? \"clrl %0\"\n+\t\t\t    : \"movl %1,%0\"), operands);\n+\treturn \"adwc %2,%0\";\n+      }\n+\n     case SImode:\n       if (rtx_equal_p (operands[0], operands[1]))\n \t{\n@@ -995,19 +1330,25 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t  if (operands[2] == constm1_rtx)\n \t    return \"decl %0\";\n \t  if (CONST_INT_P (operands[2])\n-\t      && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t      && (unsigned HOST_WIDE_INT) (- INTVAL (operands[2])) < 64)\n \t    return \"subl2 $%n2,%0\";\n \t  if (CONST_INT_P (operands[2])\n-\t      && (unsigned) INTVAL (operands[2]) >= 64\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) >= 64\n \t      && REG_P (operands[1])\n \t      && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n \t\t   || REGNO (operands[1]) > 11))\n \t    return \"movab %c2(%1),%0\";\n+\t  if (REG_P (operands[0]) && symbolic_operand (operands[2], SImode))\n+\t    return \"movab %a2[%0],%0\";\n \t  return \"addl2 %2,%0\";\n \t}\n \n       if (rtx_equal_p (operands[0], operands[2]))\n-\treturn \"addl2 %1,%0\";\n+\t{\n+\t  if (REG_P (operands[0]) && symbolic_operand (operands[1], SImode))\n+\t    return \"movab %a1[%0],%0\";\n+\t  return \"addl2 %1,%0\";\n+\t}\n \n       if (CONST_INT_P (operands[2])\n \t  && INTVAL (operands[2]) < 32767\n@@ -1017,11 +1358,11 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \treturn \"pushab %c2(%1)\";\n \n       if (CONST_INT_P (operands[2])\n-\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t  && (unsigned HOST_WIDE_INT) (- INTVAL (operands[2])) < 64)\n \treturn \"subl3 $%n2,%1,%0\";\n \n       if (CONST_INT_P (operands[2])\n-\t  && (unsigned) INTVAL (operands[2]) >= 64\n+\t  && (unsigned HOST_WIDE_INT) INTVAL (operands[2]) >= 64\n \t  && REG_P (operands[1])\n \t  && ((INTVAL (operands[2]) < 32767 && INTVAL (operands[2]) > -32768)\n \t       || REGNO (operands[1]) > 11))\n@@ -1031,6 +1372,30 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n       if (REG_P (operands[1]) && REG_P (operands[2]))\n \treturn \"movab (%1)[%2],%0\";\n       */\n+\n+      if (REG_P (operands[1]) && symbolic_operand (operands[2], SImode))\n+\t{\n+\t  if (push_operand (operands[0], SImode))\n+\t    return \"pushab %a2[%1]\";\n+\t  return \"movab %a2[%1],%0\";\n+\t}\n+\n+      if (REG_P (operands[2]) && symbolic_operand (operands[1], SImode))\n+\t{\n+\t  if (push_operand (operands[0], SImode))\n+\t    return \"pushab %a1[%2]\";\n+\t  return \"movab %a1[%2],%0\";\n+\t}\n+\n+      if (flag_pic && REG_P (operands[0])\n+\t  && symbolic_operand (operands[2], SImode))\n+\treturn \"movab %a2,%0;addl2 %1,%0\";\n+\n+      if (flag_pic\n+\t  && (symbolic_operand (operands[1], SImode)\n+\t      || symbolic_operand (operands[1], SImode)))\n+\tdebug_rtx (insn);\n+\n       return \"addl3 %1,%2,%0\";\n \n     case HImode:\n@@ -1041,14 +1406,14 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t  if (operands[2] == constm1_rtx)\n \t    return \"decw %0\";\n \t  if (CONST_INT_P (operands[2])\n-\t      && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t      && (unsigned HOST_WIDE_INT) (- INTVAL (operands[2])) < 64)\n \t    return \"subw2 $%n2,%0\";\n \t  return \"addw2 %2,%0\";\n \t}\n       if (rtx_equal_p (operands[0], operands[2]))\n \treturn \"addw2 %1,%0\";\n       if (CONST_INT_P (operands[2])\n-\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t  && (unsigned HOST_WIDE_INT) (- INTVAL (operands[2])) < 64)\n \treturn \"subw3 $%n2,%1,%0\";\n       return \"addw3 %1,%2,%0\";\n \n@@ -1060,14 +1425,14 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t  if (operands[2] == constm1_rtx)\n \t    return \"decb %0\";\n \t  if (CONST_INT_P (operands[2])\n-\t      && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t      && (unsigned HOST_WIDE_INT) (- INTVAL (operands[2])) < 64)\n \t    return \"subb2 $%n2,%0\";\n \t  return \"addb2 %2,%0\";\n \t}\n       if (rtx_equal_p (operands[0], operands[2]))\n \treturn \"addb2 %1,%0\";\n       if (CONST_INT_P (operands[2])\n-\t  && (unsigned) (- INTVAL (operands[2])) < 64)\n+\t  && (unsigned HOST_WIDE_INT) (- INTVAL (operands[2])) < 64)\n \treturn \"subb3 $%n2,%1,%0\";\n       return \"addb3 %1,%2,%0\";\n \n@@ -1076,6 +1441,81 @@ vax_output_int_add (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n     }\n }\n \n+const char *\n+vax_output_int_subtract (rtx insn, rtx *operands, enum machine_mode mode)\n+{\n+  switch (mode)\n+    {\n+    case DImode:\n+      {\n+\trtx low[3];\n+\tconst char *pattern;\n+\tint carry = 1;\n+\n+\tif (TARGET_QMATH && 0)\n+\t  debug_rtx (insn);\n+\n+\tsplit_quadword_operands (insn, MINUS, operands, low, 3);\n+\n+\tif (TARGET_QMATH)\n+\t  {\n+\t    if (operands[1] == const0_rtx && low[1] == const0_rtx)\n+\t      {\n+\t\t/* Negation is tricky.  It's basically complement and increment.\n+\t\t   Negate hi, then lo, and subtract the carry back.  */\n+\t\tif ((MEM_P (low[0]) && GET_CODE (XEXP (low[0], 0)) == POST_INC)\n+\t\t    || (MEM_P (operands[0])\n+\t\t\t&& GET_CODE (XEXP (operands[0], 0)) == POST_INC))\n+\t\t  fatal_insn (\"illegal operand detected\", insn);\n+\t\toutput_asm_insn (\"mnegl %2,%0\", operands);\n+\t\toutput_asm_insn (\"mnegl %2,%0\", low);\n+\t\treturn \"sbwc $0,%0\";\n+\t      }\n+\t    gcc_assert (rtx_equal_p (operands[0], operands[1]));\n+\t    gcc_assert (rtx_equal_p (low[0], low[1]));\n+\t    if (low[2] == const1_rtx)\n+\t      output_asm_insn (\"decl %0\", low);\n+\t    else\n+\t      output_asm_insn (\"subl2 %2,%0\", low);\n+\t    return \"sbwc %2,%0\";\n+\t  }\n+\n+\t/* Subtract low parts.  */\n+\tif (rtx_equal_p (operands[0], operands[1]))\n+\t  {\n+\t    if (low[2] == const0_rtx)\n+\t      pattern = 0, carry = 0;\n+\t    else if (low[2] == constm1_rtx)\n+\t      pattern = \"decl %0\";\n+\t    else\n+\t      pattern = \"subl2 %2,%0\";\n+\t  }\n+\telse\n+\t  {\n+\t    if (low[2] == constm1_rtx)\n+\t      pattern = \"decl %0\";\n+\t    else if (low[2] == const0_rtx)\n+\t      pattern = get_insn_template (CODE_FOR_movsi, insn), carry = 0;\n+\t    else\n+\t      pattern = \"subl3 %2,%1,%0\";\n+\t  }\n+\tif (pattern)\n+\t  output_asm_insn (pattern, low);\n+\tif (carry)\n+\t  {\n+\t    if (!rtx_equal_p (operands[0], operands[1]))\n+\t      return \"movl %1,%0;sbwc %2,%0\";\n+\t    return \"sbwc %2,%0\";\n+\t    /* %0 = %2 - %1 - C */\n+\t  }\n+\treturn get_insn_template (CODE_FOR_subsi3, insn);\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+  }\n+}\n+\n /* Output a conditional branch.  */\n const char *\n vax_output_conditional_branch (enum rtx_code code)\n@@ -1093,27 +1533,36 @@ vax_output_conditional_branch (enum rtx_code code)\n       case GEU: return \"jgequ %l0\";\n       case LEU: return \"jlequ %l0\";\n       default:\n-        gcc_unreachable ();\n+\tgcc_unreachable ();\n     }\n }\n \n-/* 1 if X is an rtx for a constant that is a valid address.  */\n+/* True if X is an rtx for a constant that is a valid address.  */\n \n-int\n+bool\n legitimate_constant_address_p (rtx x)\n {\n-  return (GET_CODE (x) == LABEL_REF || GET_CODE (x) == SYMBOL_REF\n-\t  || CONST_INT_P (x) || GET_CODE (x) == CONST\n-\t  || GET_CODE (x) == HIGH);\n+  if (GET_CODE (x) == LABEL_REF || GET_CODE (x) == SYMBOL_REF\n+\t  || CONST_INT_P (x) || GET_CODE (x) == HIGH)\n+    return true;\n+  if (GET_CODE (x) != CONST)\n+    return false;\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n+  if (flag_pic\n+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF\n+      && !SYMBOL_REF_LOCAL_P (XEXP (XEXP (x, 0), 0)))\n+    return false;\n+#endif\n+   return true;\n }\n \n-/* Nonzero if the constant value X is a legitimate general operand.\n+/* True if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n \n-int\n+bool\n legitimate_constant_p (rtx x ATTRIBUTE_UNUSED)\n {\n-  return 1;\n+  return true;\n }\n \n /* The other macros defined here are used only in legitimate_address_p ().  */\n@@ -1133,139 +1582,152 @@ legitimate_constant_p (rtx x ATTRIBUTE_UNUSED)\n /* Re-definition of CONSTANT_ADDRESS_P, which is true only when there\n    are no SYMBOL_REFs for external symbols present.  */\n \n-static int\n-indirectable_constant_address_p (rtx x)\n+static bool\n+indirectable_constant_address_p (rtx x, bool indirect)\n {\n-  if (!CONSTANT_ADDRESS_P (x))\n-    return 0;\n-  if (GET_CODE (x) == CONST && GET_CODE (XEXP ((x), 0)) == PLUS)\n-    x = XEXP (XEXP (x, 0), 0);\n-  if (GET_CODE (x) == SYMBOL_REF && !SYMBOL_REF_LOCAL_P (x))\n-    return 0;\n-\n-  return 1;\n+  if (GET_CODE (x) == SYMBOL_REF)\n+    return !flag_pic || SYMBOL_REF_LOCAL_P (x) || !indirect;\n+\n+  if (GET_CODE (x) == CONST)\n+    return !flag_pic\n+\t   || GET_CODE (XEXP (XEXP (x, 0), 0)) != SYMBOL_REF\n+\t   || SYMBOL_REF_LOCAL_P (XEXP (XEXP (x, 0), 0));\n+\n+  return CONSTANT_ADDRESS_P (x);\n }\n \n #else /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n \n-static int\n-indirectable_constant_address_p (rtx x)\n+static bool\n+indirectable_constant_address_p (rtx x, bool indirect ATTRIBUTE_UNUSED)\n {\n   return CONSTANT_ADDRESS_P (x);\n }\n \n #endif /* not NO_EXTERNAL_INDIRECT_ADDRESS */\n \n-/* Nonzero if X is an address which can be indirected.  External symbols\n+/* True if X is an address which can be indirected.  External symbols\n    could be in a sharable image library, so we disallow those.  */\n \n-static int\n-indirectable_address_p(rtx x, int strict)\n+static bool\n+indirectable_address_p (rtx x, bool strict, bool indirect)\n {\n-  if (indirectable_constant_address_p (x))\n-    return 1;\n-  if (BASE_REGISTER_P (x, strict))\n-    return 1;\n-  if (GET_CODE (x) == PLUS\n-      && BASE_REGISTER_P (XEXP (x, 0), strict)\n-      && indirectable_constant_address_p (XEXP (x, 1)))\n-    return 1;\n-  return 0;\n+  if (indirectable_constant_address_p (x, indirect)\n+      || BASE_REGISTER_P (x, strict))\n+    return true;\n+  if (GET_CODE (x) != PLUS\n+      || !BASE_REGISTER_P (XEXP (x, 0), strict)\n+      || (flag_pic && !CONST_INT_P (XEXP (x, 1))))\n+    return false;\n+  return indirectable_constant_address_p (XEXP (x, 1), indirect);\n }\n \n-/* Return 1 if x is a valid address not using indexing.\n+/* Return true if x is a valid address not using indexing.\n    (This much is the easy part.)  */\n-static int\n-nonindexed_address_p (rtx x, int strict)\n+static bool\n+nonindexed_address_p (rtx x, bool strict)\n {\n   rtx xfoo0;\n   if (REG_P (x))\n     {\n       extern rtx *reg_equiv_mem;\n-      if (!reload_in_progress\n+      if (! reload_in_progress\n \t  || reg_equiv_mem[REGNO (x)] == 0\n-\t  || indirectable_address_p (reg_equiv_mem[REGNO (x)], strict))\n-\treturn 1;\n+\t  || indirectable_address_p (reg_equiv_mem[REGNO (x)], strict, false))\n+\treturn true;\n     }\n-  if (indirectable_constant_address_p (x))\n-    return 1;\n-  if (indirectable_address_p (x, strict))\n-    return 1;\n+  if (indirectable_constant_address_p (x, false))\n+    return true;\n+  if (indirectable_address_p (x, strict, false))\n+    return true;\n   xfoo0 = XEXP (x, 0);\n-  if (MEM_P (x) && indirectable_address_p (xfoo0, strict))\n-    return 1;\n+  if (MEM_P (x) && indirectable_address_p (xfoo0, strict, true))\n+    return true;\n   if ((GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC)\n       && BASE_REGISTER_P (xfoo0, strict))\n-    return 1;\n-  return 0;\n+    return true;\n+  return false;\n }\n \n-/* 1 if PROD is either a reg times size of mode MODE and MODE is less\n+/* True if PROD is either a reg times size of mode MODE and MODE is less\n    than or equal 8 bytes, or just a reg if MODE is one byte.  */\n \n-static int\n-index_term_p (rtx prod, enum machine_mode mode, int strict)\n+static bool\n+index_term_p (rtx prod, enum machine_mode mode, bool strict)\n {\n   rtx xfoo0, xfoo1;\n \n   if (GET_MODE_SIZE (mode) == 1)\n     return BASE_REGISTER_P (prod, strict);\n \n   if (GET_CODE (prod) != MULT || GET_MODE_SIZE (mode) > 8)\n-    return 0;\n+    return false;\n \n   xfoo0 = XEXP (prod, 0);\n   xfoo1 = XEXP (prod, 1);\n \n   if (CONST_INT_P (xfoo0)\n       && INTVAL (xfoo0) == (int)GET_MODE_SIZE (mode)\n       && INDEX_REGISTER_P (xfoo1, strict))\n-    return 1;\n+    return true;\n \n   if (CONST_INT_P (xfoo1)\n       && INTVAL (xfoo1) == (int)GET_MODE_SIZE (mode)\n       && INDEX_REGISTER_P (xfoo0, strict))\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n-/* Return 1 if X is the sum of a register\n+/* Return true if X is the sum of a register\n    and a valid index term for mode MODE.  */\n-static int\n-reg_plus_index_p (rtx x, enum machine_mode mode, int strict)\n+static bool\n+reg_plus_index_p (rtx x, enum machine_mode mode, bool strict)\n {\n   rtx xfoo0, xfoo1;\n \n   if (GET_CODE (x) != PLUS)\n-    return 0;\n+    return false;\n \n   xfoo0 = XEXP (x, 0);\n   xfoo1 = XEXP (x, 1);\n \n   if (BASE_REGISTER_P (xfoo0, strict) && index_term_p (xfoo1, mode, strict))\n-    return 1;\n+    return true;\n \n   if (BASE_REGISTER_P (xfoo1, strict) && index_term_p (xfoo0, mode, strict))\n-    return 1;\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n-/* legitimate_address_p returns 1 if it recognizes an RTL expression \"x\"\n+/* Return true if xfoo0 and xfoo1 constitute a valid indexed address.  */\n+static bool\n+indexable_address_p (rtx xfoo0, rtx xfoo1, enum machine_mode mode, bool strict)\n+{\n+  if (!CONSTANT_ADDRESS_P (xfoo0))\n+    return false;\n+  if (BASE_REGISTER_P (xfoo1, strict))\n+    return !flag_pic || mode == QImode;\n+  if (flag_pic && symbolic_operand (xfoo0, SImode))\n+    return false;\n+  return reg_plus_index_p (xfoo1, mode, strict);\n+}\n+\n+/* legitimate_address_p returns true if it recognizes an RTL expression \"x\"\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n    that wants to use this address.  */\n-int\n-legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n+bool\n+legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   rtx xfoo0, xfoo1;\n \n   if (nonindexed_address_p (x, strict))\n-    return 1;\n+    return true;\n \n   if (GET_CODE (x) != PLUS)\n-    return 0;\n+    return false;\n \n   /* Handle <address>[index] represented with index-sum outermost */\n \n@@ -1274,50 +1736,265 @@ legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n \n   if (index_term_p (xfoo0, mode, strict)\n       && nonindexed_address_p (xfoo1, strict))\n-    return 1;\n+    return true;\n \n   if (index_term_p (xfoo1, mode, strict)\n       && nonindexed_address_p (xfoo0, strict))\n-    return 1;\n+    return true;\n \n   /* Handle offset(reg)[index] with offset added outermost */\n \n-  if (indirectable_constant_address_p (xfoo0)\n-      && (BASE_REGISTER_P (xfoo1, strict)\n-          || reg_plus_index_p (xfoo1, mode, strict)))\n-    return 1;\n-\n-  if (indirectable_constant_address_p (xfoo1)\n-      && (BASE_REGISTER_P (xfoo0, strict)\n-          || reg_plus_index_p (xfoo0, mode, strict)))\n-    return 1;\n+  if (indexable_address_p (xfoo0, xfoo1, mode, strict)\n+      || indexable_address_p (xfoo1, xfoo0, mode, strict))\n+    return true;\n \n-  return 0;\n+  return false;\n }\n \n-/* Return 1 if x (a legitimate address expression) has an effect that\n+/* Return true if x (a legitimate address expression) has an effect that\n    depends on the machine mode it is used for.  On the VAX, the predecrement\n    and postincrement address depend thus (the amount of decrement or\n    increment being the length of the operand) and all indexed address depend\n    thus (because the index scale factor is the length of the operand).  */\n \n-int\n+bool\n vax_mode_dependent_address_p (rtx x)\n {\n   rtx xfoo0, xfoo1;\n \n   /* Auto-increment cases are now dealt with generically in recog.c.  */\n-\n   if (GET_CODE (x) != PLUS)\n-    return 0;\n+    return false;\n \n   xfoo0 = XEXP (x, 0);\n   xfoo1 = XEXP (x, 1);\n \n-  if (CONSTANT_ADDRESS_P (xfoo0) && REG_P (xfoo1))\n-    return 0;\n-  if (CONSTANT_ADDRESS_P (xfoo1) && REG_P (xfoo0))\n-    return 0;\n+  if (CONST_INT_P (xfoo0) && REG_P (xfoo1))\n+    return false;\n+  if (CONST_INT_P (xfoo1) && REG_P (xfoo0))\n+    return false;\n+  if (!flag_pic && CONSTANT_ADDRESS_P (xfoo0) && REG_P (xfoo1))\n+    return false;\n+  if (!flag_pic && CONSTANT_ADDRESS_P (xfoo1) && REG_P (xfoo0))\n+    return false;\n+\n+  return true;\n+}\n+\n+static rtx\n+fixup_mathdi_operand (rtx x, enum machine_mode mode)\n+{\n+  if (illegal_addsub_di_memory_operand (x, mode))\n+    {\n+      rtx addr = XEXP (x, 0);\n+      rtx temp = gen_reg_rtx (Pmode);\n+      rtx offset = 0;\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n+      if (GET_CODE (addr) == CONST && flag_pic)\n+\t{\n+\t  offset = XEXP (XEXP (addr, 0), 1);\n+\t  addr = XEXP (XEXP (addr, 0), 0);\n+\t}\n+#endif\n+      emit_move_insn (temp, addr);\n+      if (offset)\n+\ttemp = gen_rtx_PLUS (Pmode, temp, offset);\n+      x = gen_rtx_MEM (DImode, temp);\n+    }\n+  return x;\n+}\n+\n+void\n+vax_expand_addsub_di_operands (rtx * operands, enum rtx_code code)\n+{\n+  int hi_only = operand_subword (operands[2], 0, 0, DImode) == const0_rtx;\n+  rtx temp;\n+\n+  rtx (*gen_old_insn)(rtx, rtx, rtx);\n+  rtx (*gen_si_insn)(rtx, rtx, rtx);\n+  rtx (*gen_insn)(rtx, rtx, rtx);\n+\n+  if (code == PLUS)\n+    {\n+      gen_old_insn = gen_adddi3_old;\n+      gen_si_insn = gen_addsi3;\n+      gen_insn = gen_adcdi3;\n+    }\n+  else if (code == MINUS)\n+    {\n+      gen_old_insn = gen_subdi3_old;\n+      gen_si_insn = gen_subsi3;\n+      gen_insn = gen_sbcdi3;\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* If this is addition (thus operands are commutative) and if there is one\n+     addend that duplicates the desination, we want that addend to be the\n+     first addend.  */\n+  if (code == PLUS\n+      && rtx_equal_p (operands[0], operands[2])\n+      && !rtx_equal_p (operands[1], operands[2]))\n+    {\n+      temp = operands[2];\n+      operands[2] = operands[1];\n+      operands[1] = temp;\n+    }\n+\n+  if (!TARGET_QMATH)\n+    {\n+      emit_insn ((*gen_old_insn) (operands[0], operands[1], operands[2]));\n+    }\n+  else if (hi_only)\n+    {\n+      if (!rtx_equal_p (operands[0], operands[1])\n+\t  && (REG_P (operands[0]) && MEM_P (operands[1])))\n+\t{\n+\t  emit_move_insn (operands[0], operands[1]);\n+\t  operands[1] = operands[0];\n+\t}\n+\n+      operands[0] = fixup_mathdi_operand (operands[0], DImode);\n+      operands[1] = fixup_mathdi_operand (operands[1], DImode);\n+      operands[2] = fixup_mathdi_operand (operands[2], DImode);\n+\n+      if (!rtx_equal_p (operands[0], operands[1]))\n+\temit_move_insn (operand_subword (operands[0], 0, 0, DImode),\n+\t\t\t  operand_subword (operands[1], 0, 0, DImode));\n+\n+      emit_insn ((*gen_si_insn) (operand_subword (operands[0], 1, 0, DImode),\n+\t\t\t\t operand_subword (operands[1], 1, 0, DImode),\n+\t\t\t\t operand_subword (operands[2], 1, 0, DImode)));\n+    }\n+  else\n+    {\n+      /* If are adding the same value together, that's really a multiply by 2,\n+\t and that's just a left shift of 1.  */\n+      if (rtx_equal_p (operands[1], operands[2]))\n+\t{\n+\t  gcc_assert (code != MINUS);\n+\t  emit_insn (gen_ashldi3 (operands[0], operands[1], const1_rtx));\n+\t  return;\n+\t}\n+\n+      operands[0] = fixup_mathdi_operand (operands[0], DImode);\n+\n+      /* If an operand is the same as operand[0], use the operand[0] rtx\n+\t because fixup will an equivalent rtx but not an equal one. */\n+\n+      if (rtx_equal_p (operands[0], operands[1]))\n+\toperands[1] = operands[0];\n+      else\n+\toperands[1] = fixup_mathdi_operand (operands[1], DImode);\n+\n+      if (rtx_equal_p (operands[0], operands[2]))\n+\toperands[2] = operands[0];\n+      else\n+\toperands[2] = fixup_mathdi_operand (operands[2], DImode);\n+\n+      /* If we are subtracting not from ourselves [d = a - b], and because the\n+\t carry ops are two operand only, we would need to do a move prior to\n+\t the subtract.  And if d == b, we would need a temp otherwise\n+\t [d = a, d -= d] and we end up with 0.  Instead we rewrite d = a - b\n+\t into d = -b, d += a.  Since -b can never overflow, even if b == d,\n+\t no temp is needed.\n+\n+\t If we are doing addition, since the carry ops are two operand, if\n+\t we aren't adding to ourselves, move the first addend to the\n+\t destination first.  */\n+\n+      gcc_assert (operands[1] != const0_rtx || code == MINUS);\n+      if (!rtx_equal_p (operands[0], operands[1]) && operands[1] != const0_rtx)\n+\t{\n+\t  if (code == MINUS && CONSTANT_P (operands[1]))\n+\t    {\n+\t      temp = gen_reg_rtx (DImode);\n+\t      emit_insn (gen_sbcdi3 (operands[0], const0_rtx, operands[2]));\n+\t      code = PLUS;\n+\t      gen_insn = gen_adcdi3;\n+\t      operands[2] = operands[1];\n+\t      operands[1] = operands[0];\n+\t    }\n+\t  else\n+\t    emit_move_insn (operands[0], operands[1]);\n+\t}\n+\n+      /* Subtracting a constant will have been rewritten to an addition of the\n+\t negative of that constant before we get here.  */\n+      gcc_assert (!CONSTANT_P (operands[2]) || code == PLUS);\n+      emit_insn ((*gen_insn) (operands[0], operands[1], operands[2]));\n+    }\n+}\n+\n+bool\n+adjacent_operands_p (rtx lo, rtx hi, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT lo_offset;\n+  HOST_WIDE_INT hi_offset;\n+\n+  if (GET_CODE (lo) != GET_CODE (hi))\n+    return false;\n+\n+  if (REG_P (lo))\n+    return mode == SImode && REGNO (lo) + 1 == REGNO (hi);\n+  if (CONST_INT_P (lo))\n+    return INTVAL (hi) == 0 && 0 <= INTVAL (lo) && INTVAL (lo) < 64;\n+  if (CONST_INT_P (lo))\n+    return mode != SImode;\n+\n+  if (!MEM_P (lo))\n+    return false;\n+\n+  if (MEM_VOLATILE_P (lo) || MEM_VOLATILE_P (hi))\n+    return false;\n+\n+  lo = XEXP (lo, 0);\n+  hi = XEXP (hi, 0);\n+\n+  if (GET_CODE (lo) == POST_INC /* || GET_CODE (lo) == PRE_DEC */)\n+    return rtx_equal_p (lo, hi);\n+\n+  switch (GET_CODE (lo))\n+    {\n+    case REG:\n+    case SYMBOL_REF:\n+      lo_offset = 0;\n+      break;\n+    case CONST:\n+      lo = XEXP (lo, 0);\n+      /* FALLTHROUGH */\n+    case PLUS:\n+      if (!CONST_INT_P (XEXP (lo, 1)))\n+\treturn false;\n+      lo_offset = INTVAL (XEXP (lo, 1));\n+      lo = XEXP (lo, 0);\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  switch (GET_CODE (hi))\n+    {\n+    case REG:\n+    case SYMBOL_REF:\n+      hi_offset = 0;\n+      break;\n+    case CONST:\n+      hi = XEXP (hi, 0);\n+      /* FALLTHROUGH */\n+    case PLUS:\n+      if (!CONST_INT_P (XEXP (hi, 1)))\n+\treturn false;\n+      hi_offset = INTVAL (XEXP (hi, 1));\n+      hi = XEXP (hi, 0);\n+      break;\n+    default:\n+      return false;\n+    }\n+\n+  if (GET_CODE (lo) == MULT || GET_CODE (lo) == PLUS)\n+    return false;\n \n-  return 1;\n+  return rtx_equal_p (lo, hi)\n+\t && hi_offset - lo_offset == GET_MODE_SIZE (mode);\n }"}, {"sha": "997029e0f62f2c16f3ada90bcaa1ec061d1a454c", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 27, "deletions": 91, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.  VAX version.\n    Copyright (C) 1987, 1988, 1991, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -104,7 +104,7 @@ along with GCC; see the file COPYING3.  If not see\n #define STRUCTURE_SIZE_BOUNDARY 8\n \n /* A bit-field declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS (!TARGET_VAXC_ALIGNMENT)\n+#define PCC_BITFIELD_TYPE_MATTERS (! TARGET_VAXC_ALIGNMENT)\n \n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 32\n@@ -181,6 +181,9 @@ along with GCC; see the file COPYING3.  If not see\n    This is computed in `reload', in reload1.c.  */\n #define FRAME_POINTER_REQUIRED 1\n \n+/* Offset from the frame pointer register value to the top of stack.  */\n+#define FRAME_POINTER_CFA_OFFSET(FNDECL) 0\n+\n /* Base register for access to arguments of the function.  */\n #define ARG_POINTER_REGNUM VAX_AP_REGNUM\n \n@@ -228,6 +231,20 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define REG_CLASS_NAMES\t\\\n   { \"NO_REGS\", \"ALL_REGS\" }\n \n+/* The following macro defines cover classes for Integrated Register\n+   Allocator.  Cover classes is a set of non-intersected register\n+   classes covering all hard registers used for register allocation\n+   purpose.  Any move between two registers of a cover class should be\n+   cheaper than load or store of the registers.  The macro value is\n+   array of register classes with LIM_REG_CLASSES used as the end\n+   marker.  */\n+#define IRA_COVER_CLASSES { ALL_REGS, LIM_REG_CLASSES }\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n@@ -246,54 +263,6 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define INDEX_REG_CLASS ALL_REGS\n #define BASE_REG_CLASS ALL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) NO_REGS\n-\n-/* The letters I, J, K, L, M, N, and O in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   `I' is the constant zero.\n-   `J' is a value between 0 .. 63 (inclusive)\n-   `K' is a value between -128 and 127 (inclusive)\n-   'L' is a value between -32768 and 32767 (inclusive)\n-   `M' is a value between 0 and 255 (inclusive)\n-   'N' is a value between 0 and 65535 (inclusive)\n-   `O' is a value between -63 and -1 (inclusive)  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  (  (C) == 'I' ?\t(VALUE) == 0\t\t\t\t\\\n-   : (C) == 'J' ?\t0 <= (VALUE) && (VALUE) < 64\t\t\\\n-   : (C) == 'O' ?\t-63 <= (VALUE) && (VALUE) < 0\t\t\\\n-   : (C) == 'K' ?\t-128 <= (VALUE) && (VALUE) < 128\t\\\n-   : (C) == 'M' ?\t0 <= (VALUE) && (VALUE) < 256\t\t\\\n-   : (C) == 'L' ?\t-32768 <= (VALUE) && (VALUE) < 32768\t\\\n-   : (C) == 'N' ?\t0 <= (VALUE) && (VALUE) < 65536\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-\n-   `G' is a floating-point zero.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n-  ((C) == 'G' ? ((VALUE) == CONST0_RTX (DFmode)\t\t\\\n-\t\t || (VALUE) == CONST0_RTX (SFmode))\t\\\n-   : 0)\n-\n-/* Optional extra constraints for this machine.\n-\n-   For the VAX, `Q' means that OP is a MEM that does not have a mode-dependent\n-   address.  */\n-\n-#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\\\n-  ((C) == 'Q'\t\t\t\t\t\t\t\\\n-   ? MEM_P (OP) && !mode_dependent_address_p (XEXP (OP, 0))\t\\\n-   : 0)\n-\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -621,6 +590,11 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 8\n \n+/* If a memory-to-memory move would take MOVE_RATIO or more simple\n+   move-instruction pairs, we will do a movmem or libcall instead.  */\n+#define MOVE_RATIO(speed) ((speed) ? 6 : 3)\n+#define CLEAR_RATIO(speed) ((speed) ? 6 : 2)\n+\n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS 0\n \n@@ -851,49 +825,11 @@ VAX operand formatting codes:\n #  define NEG_HWI_PRINT_HEX16 \"0xffffffff%08lx\"\n #endif\n \n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)  \\\n   ((CODE) == '#' || (CODE) == '|')\n \n-#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n-{ if (CODE == '#') fputc (ASM_DOUBLE_CHAR, FILE);\t\t\t\\\n-  else if (CODE == '|')\t\t\t\t\t\t\t\\\n-    fputs (REGISTER_PREFIX, FILE);\t\t\t\t\t\\\n-  else if (CODE == 'C')\t\t\t\t\t\t\t\\\n-    fputs (rev_cond_name (X), FILE);\t\t\t\t\t\\\n-  else if (CODE == 'D' && CONST_INT_P (X) && INTVAL (X) < 0)\t\t\\\n-    fprintf (FILE, \"$\" NEG_HWI_PRINT_HEX16, INTVAL (X));\t\t\\\n-  else if (CODE == 'P' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$\" HOST_WIDE_INT_PRINT_DEC, INTVAL (X) + 1);\t\\\n-  else if (CODE == 'N' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$\" HOST_WIDE_INT_PRINT_DEC, ~ INTVAL (X));\t\t\\\n-  /* rotl instruction cannot deal with negative arguments.  */\t\t\\\n-  else if (CODE == 'R' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$\" HOST_WIDE_INT_PRINT_DEC, 32 - INTVAL (X));\t\\\n-  else if (CODE == 'H' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$%d\", (int) (0xffff & ~ INTVAL (X)));\t\t\\\n-  else if (CODE == 'h' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$%d\", (short) - INTVAL (x));\t\t\t\\\n-  else if (CODE == 'B' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$%d\", (int) (0xff & ~ INTVAL (X)));\t\t\t\\\n-  else if (CODE == 'b' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$%d\", (int) (0xff & - INTVAL (X)));\t\t\t\\\n-  else if (CODE == 'M' && CONST_INT_P (X))\t\t\t\t\\\n-    fprintf (FILE, \"$%d\", ~((1 << INTVAL (x)) - 1));\t\t\t\\\n-  else if (REG_P (X))\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (MEM_P (X))\t\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { char dstr[30];\t\t\t\t\t\t\t\\\n-      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (X),\t\t\\\n-\t\t       sizeof (dstr), 0, 1);\t\t\t\t\\\n-      fprintf (FILE, \"$0f%s\", dstr); }\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { char dstr[30];\t\t\t\t\t\t\t\\\n-      real_to_decimal (dstr, CONST_DOUBLE_REAL_VALUE (X),\t\t\\\n-\t\t       sizeof (dstr), 0, 1);\t\t\t\t\\\n-      fprintf (FILE, \"$0%c%s\", ASM_DOUBLE_CHAR, dstr); }\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+  print_operand (FILE, X, CODE)\n \n /* Print a memory operand whose address is X, on file FILE.\n    This uses a function in output-vax.c.  */"}, {"sha": "da3ca48e90b956395b479dc336b145662a6f26cb", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 313, "deletions": 245, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,6 +1,6 @@\n ;; Machine description for GNU compiler, VAX Version\n ;; Copyright (C) 1987, 1988, 1991, 1994, 1995, 1996, 1998, 1999, 2000, 2001,\n-;; 2002, 2004, 2005, 2007 Free Software Foundation, Inc.\n+;; 2002, 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -43,7 +43,9 @@\n ;; Integer modes supported on VAX, with a mapping from machine mode\n ;; to mnemonic suffix.  DImode is always a special case.\n (define_mode_iterator VAXint [QI HI SI])\n-(define_mode_attr  isfx [(QI \"b\") (HI \"w\") (SI \"l\")])\n+(define_mode_iterator VAXintQH [QI HI])\n+(define_mode_iterator VAXintQHSD [QI HI SI DI])\n+(define_mode_attr  isfx [(QI \"b\") (HI \"w\") (SI \"l\") (DI \"q\")])\n \n ;; Similar for float modes supported on VAX.\n (define_mode_iterator VAXfp [SF DF])\n@@ -52,13 +54,17 @@\n ;; Some output patterns want integer immediates with a prefix...\n (define_mode_attr  iprefx [(QI \"B\") (HI \"H\") (SI \"N\")])\n \n+;;\n+(include \"constraints.md\")\n+(include \"predicates.md\")\n+\n ;; We don't want to allow a constant operand for test insns because\n ;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n ;; be folded while optimizing anyway.\n \n (define_insn \"tst<mode>\"\n   [(set (cc0)\n-\t(match_operand:VAXint 0 \"nonimmediate_operand\" \"g\"))]\n+\t(match_operand:VAXint 0 \"nonimmediate_operand\" \"nrmT\"))]\n   \"\"\n   \"tst<VAXint:isfx> %0\")\n \n@@ -70,8 +76,8 @@\n \n (define_insn \"cmp<mode>\"\n   [(set (cc0)\n-\t(compare (match_operand:VAXint 0 \"nonimmediate_operand\" \"g\")\n-\t\t (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n+\t(compare (match_operand:VAXint 0 \"nonimmediate_operand\" \"nrmT\")\n+\t\t (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"cmp<VAXint:isfx> %0,%1\")\n \n@@ -86,8 +92,8 @@\n \n (define_insn \"*bit<mode>\"\n   [(set (cc0)\n-\t(and:VAXint (match_operand:VAXint 0 \"general_operand\" \"g\")\n-\t\t   (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n+\t(and:VAXint (match_operand:VAXint 0 \"general_operand\" \"nrmT\")\n+\t\t   (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"bit<VAXint:isfx> %0,%1\")\n \n@@ -115,12 +121,10 @@\n ;;  \"movh %1,%0\")\n \n (define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(match_operand:DI 1 \"general_operand\" \"I,g\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:DI 1 \"general_operand\" \"g\"))]\n   \"\"\n-  \"@\n-   clrq %0\n-   movq %D1,%0\")\n+  \"* return vax_output_int_move (insn, operands, DImode);\")\n \n ;; The VAX move instructions have space-time tradeoffs.  On a MicroVAX\n ;; register-register mov instructions take 3 bytes and 2 CPU cycles.  clrl\n@@ -139,9 +143,37 @@\n ;;  Loads of constants between 64 and 128 used to be done with\n ;; \"addl3 $63,#,dst\" but this is slower than movzbl and takes as much space.\n \n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+#ifdef NO_EXTERNAL_INDIRECT_ADDRESS\n+  if (flag_pic\n+      && GET_CODE (operands[1]) == CONST\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF\n+      && !SYMBOL_REF_LOCAL_P (XEXP (XEXP (operands[1], 0), 0)))\n+    {\n+      rtx symbol_ref = XEXP (XEXP (operands[1], 0), 0);\n+      rtx const_int = XEXP (XEXP (operands[1], 0), 1);\n+      rtx temp = reload_in_progress ? operands[0] : gen_reg_rtx (Pmode);\n+      emit_move_insn (temp, symbol_ref);\n+      emit_move_insn (operands[0], gen_rtx_PLUS (SImode, temp, const_int));\n+      DONE;\n+    }\n+#endif\n+}\")\n+\n+(define_insn \"movsi_2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:SI 1 \"nonsymbolic_operand\" \"nrmT\"))]\n+  \"\"\n+  \"* return vax_output_int_move (insn, operands, SImode);\")\n+\n (define_insn \"mov<mode>\"\n-  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n-        (match_operand:VAXint 1 \"general_operand\" \"g\"))]\n+  [(set (match_operand:VAXintQH 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:VAXintQH 1 \"general_operand\" \"g\"))]\n   \"\"\n   \"* return vax_output_int_move (insn, operands, <MODE>mode);\")\n \n@@ -192,17 +224,19 @@\n    (match_operand 3 \"\" \"\")]\n   \"\"\n   \"\n+{\n   emit_insn (gen_movmemhi1 (operands[0], operands[1], operands[2]));\n   DONE;\n-\")\n+}\")\n \n ;; The definition of this insn does not really explain what it does,\n ;; but it should suffice\n ;; that anything generated as this insn will be recognized as one\n ;; and that it won't successfully combine with anything.\n+\n (define_insn \"movmemhi1\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=m\")\n-\t(match_operand:BLK 1 \"memory_operand\" \"m\"))\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\n    (use (match_operand:HI 2 \"general_operand\" \"g\"))\n    (clobber (reg:SI 0))\n    (clobber (reg:SI 1))\n@@ -217,13 +251,13 @@\n \n (define_insn \"truncsiqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n-\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\")))]\n   \"\"\n   \"cvtlb %1,%0\")\n \n (define_insn \"truncsihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n-\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"g\")))]\n+\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\")))]\n   \"\"\n   \"cvtlw %1,%0\")\n \n@@ -309,56 +343,62 @@\n    add<VAXfp:fsfx>2 %1,%0\n    add<VAXfp:fsfx>3 %1,%2,%0\")\n \n+(define_insn \"pushlclsymreg\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"local_symbolic_operand\" \"i\")))]\n+  \"flag_pic\"\n+  \"pushab %a2[%1]\")\n+\n+(define_insn \"pushextsymreg\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"external_symbolic_operand\" \"i\")))]\n+  \"flag_pic\"\n+  \"pushab %a2[%1]\")\n+\n+(define_insn \"movlclsymreg\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"local_symbolic_operand\" \"i\")))]\n+  \"flag_pic\"\n+  \"movab %a2[%1],%0\")\n+\n+(define_insn \"movextsymreg\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"external_symbolic_operand\" \"i\")))]\n+  \"flag_pic\"\n+  \"movab %a2[%1],%0\")\n+\n (define_insn \"add<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n-\t(plus:VAXint (match_operand:VAXint 1 \"general_operand\" \"g\")\n-\t\t    (match_operand:VAXint 2 \"general_operand\" \"g\")))]\n+\t(plus:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"* return vax_output_int_add (insn, operands, <MODE>mode);\")\n \n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"!reload_in_progress\"\n+  \"vax_expand_addsub_di_operands (operands, PLUS); DONE;\")\n+\n+(define_insn \"adcdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_addsub_di_operand\" \"=Rr\")\n+\t(plus:DI (match_operand:DI 1 \"general_addsub_di_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"general_addsub_di_operand\" \"nRr\")))]\n+  \"TARGET_QMATH\"\n+  \"* return vax_output_int_add (insn, operands, DImode);\")\n+\n ;; The add-with-carry (adwc) instruction only accepts two operands.\n-(define_insn \"adddi3\"\n+(define_insn \"adddi3_old\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro>,ro>\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,ro>\")\n-\t\t (match_operand:DI 2 \"general_operand\" \"Fro,F\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx low[3];\n-  const char *pattern;\n-  int carry = 1;\n-\n-  split_quadword_operands (operands, low, 3);\n-  /* Add low parts.  */\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      if (low[2] == const0_rtx)\n-\t/* Should examine operand, punt if not POST_INC.  */\n-\tpattern = \\\"tstl %0\\\", carry = 0;\n-      else if (low[2] == const1_rtx)\n-        pattern = \\\"incl %0\\\";\n-      else\n-        pattern = \\\"addl2 %2,%0\\\";\n-    }\n-  else\n-    {\n-      if (low[2] == const0_rtx)\n-\tpattern = \\\"movl %1,%0\\\", carry = 0;\n-      else\n-\tpattern = \\\"addl3 %2,%1,%0\\\";\n-    }\n-  if (pattern)\n-    output_asm_insn (pattern, low);\n-  if (!carry)\n-    /* If CARRY is 0, we don't have any carry value to worry about.  */\n-    return get_insn_template (CODE_FOR_addsi3, insn);\n-  /* %0 = C + %1 + %2 */\n-  if (!rtx_equal_p (operands[0], operands[1]))\n-    output_asm_insn ((operands[1] == const0_rtx\n-\t\t      ? \\\"clrl %0\\\"\n-\t\t      : \\\"movl %1,%0\\\"), operands);\n-  return \\\"adwc %2,%0\\\";\n-}\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"Fsro,Fs\")))]\n+  \"!TARGET_QMATH\"\n+  \"* return vax_output_int_add (insn, operands, DImode);\")\n \f\n ;;- All kinds of subtract instructions.\n \n@@ -373,56 +413,34 @@\n \n (define_insn \"sub<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(minus:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g\")\n-\t\t     (match_operand:VAXint 2 \"general_operand\" \"g,g\")))]\n+\t(minus:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n+\t\t     (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))]\n   \"\"\n   \"@\n    sub<VAXint:isfx>2 %2,%0\n    sub<VAXint:isfx>3 %2,%1,%0\")\n \n+(define_expand \"subdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t  (match_operand:DI 2 \"general_operand\" \"g\")))]\n+  \"!reload_in_progress\"\n+  \"vax_expand_addsub_di_operands (operands, MINUS); DONE;\")\n+\n+(define_insn \"sbcdi3\"\n+  [(set (match_operand:DI 0 \"nonimmediate_addsub_di_operand\" \"=Rr,=Rr\")\n+\t(minus:DI (match_operand:DI 1 \"general_addsub_di_operand\" \"0,I\")\n+\t\t  (match_operand:DI 2 \"general_addsub_di_operand\" \"nRr,Rr\")))]\n+  \"TARGET_QMATH\"\n+  \"* return vax_output_int_subtract (insn, operands, DImode);\")\n+\n ;; The subtract-with-carry (sbwc) instruction only takes two operands.\n-(define_insn \"subdi3\"\n+(define_insn \"subdi3_old\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=or>,or>\")\n \t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,or>\")\n-\t\t  (match_operand:DI 2 \"general_operand\" \"For,F\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx low[3];\n-  const char *pattern;\n-  int carry = 1;\n-\n-  split_quadword_operands (operands, low, 3);\n-  /* Subtract low parts.  */\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      if (low[2] == const0_rtx)\n-\tpattern = 0, carry = 0;\n-      else if (low[2] == constm1_rtx)\n-\tpattern = \\\"decl %0\\\";\n-      else\n-\tpattern = \\\"subl2 %2,%0\\\";\n-    }\n-  else\n-    {\n-      if (low[2] == constm1_rtx)\n-\tpattern = \\\"decl %0\\\";\n-      else if (low[2] == const0_rtx)\n-\tpattern = get_insn_template (CODE_FOR_movsi, insn), carry = 0;\n-      else\n-\tpattern = \\\"subl3 %2,%1,%0\\\";\n-    }\n-  if (pattern)\n-    output_asm_insn (pattern, low);\n-  if (carry)\n-    {\n-      if (!rtx_equal_p (operands[0], operands[1]))\n-\treturn \\\"movl %1,%0\\;sbwc %2,%0\\\";\n-      return \\\"sbwc %2,%0\\\";\n-      /* %0 = %2 - %1 - C */\n-    }\n-  return get_insn_template (CODE_FOR_subsi3, insn);\n-}\")\n+\t\t  (match_operand:DI 2 \"general_operand\" \"Fsor,Fs\")))]\n+  \"!TARGET_QMATH\"\n+  \"* return vax_output_int_subtract (insn, operands, DImode);\")\n \f\n ;;- Multiply instructions.\n \n@@ -438,8 +456,8 @@\n \n (define_insn \"mul<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(mult:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g,g\")\n-\t\t    (match_operand:VAXint 2 \"general_operand\" \"g,0,g\")))]\n+\t(mult:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))]\n   \"\"\n   \"@\n    mul<VAXint:isfx>2 %2,%0\n@@ -449,19 +467,19 @@\n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(mult:DI (sign_extend:DI\n-\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"g\"))\n+\t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\"))\n \t\t (sign_extend:DI\n-\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"g\"))))]\n+\t\t  (match_operand:SI 2 \"nonimmediate_operand\" \"nrmT\"))))]\n   \"\"\n   \"emul %1,%2,$0,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(plus:DI\n \t (mult:DI (sign_extend:DI\n-\t\t   (match_operand:SI 1 \"nonimmediate_operand\" \"g\"))\n+\t\t   (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\"))\n \t\t  (sign_extend:DI\n-\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"g\")))\n+\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"nrmT\")))\n \t (sign_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"g\"))))]\n   \"\"\n   \"emul %1,%2,%3,%0\")\n@@ -471,9 +489,9 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(plus:DI\n \t (mult:DI (sign_extend:DI\n-\t\t   (match_operand:SI 1 \"nonimmediate_operand\" \"g\"))\n+\t\t   (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\"))\n \t\t  (sign_extend:DI\n-\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"g\")))\n+\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"nrmT\")))\n \t (match_operand:DI 3 \"immediate_operand\" \"F\")))]\n   \"GET_CODE (operands[3]) == CONST_DOUBLE\n     && CONST_DOUBLE_HIGH (operands[3]) == (CONST_DOUBLE_LOW (operands[3]) >> 31)\"\n@@ -497,8 +515,8 @@\n \n (define_insn \"div<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(div:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g\")\n-\t\t   (match_operand:VAXint 2 \"general_operand\" \"g,g\")))]\n+\t(div:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))]\n   \"\"\n   \"@\n    div<VAXint:isfx>2 %2,%0\n@@ -527,7 +545,7 @@\n   rtx op1 = operands[1];\n \n   /* If there is a constant argument, complement that one.  */\n-  if (CONST_INT_P (operands[2]) && !CONST_INT_P (op1))\n+  if (CONST_INT_P (operands[2]) && ! CONST_INT_P (op1))\n     {\n       operands[1] = operands[2];\n       operands[2] = op1;\n@@ -542,8 +560,8 @@\n \n (define_insn \"*and<mode>\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:VAXint (not:VAXint (match_operand:VAXint 1 \"general_operand\" \"g,g\"))\n-\t\t    (match_operand:VAXint 2 \"general_operand\" \"0,g\")))]\n+\t(and:VAXint (not:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT,nrmT\"))\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"0,nrmT\")))]\n   \"\"\n   \"@\n    bic<VAXint:isfx>2 %1,%0\n@@ -556,7 +574,7 @@\n \n (define_insn \"*and<mode>_const_int\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g\")\n+\t(and:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n \t\t   (match_operand:VAXint 2 \"const_int_operand\" \"n,n\")))]\n   \"\"\n   \"@\n@@ -568,8 +586,8 @@\n \n (define_insn \"ior<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(ior:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g,g\")\n-\t\t   (match_operand:VAXint 2 \"general_operand\" \"g,0,g\")))]\n+\t(ior:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))]\n   \"\"\n   \"@\n    bis<VAXint:isfx>2 %2,%0\n@@ -580,8 +598,8 @@\n \n (define_insn \"xor<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n-\t(xor:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,g,g\")\n-\t\t   (match_operand:VAXint 2 \"general_operand\" \"g,0,g\")))]\n+\t(xor:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n+\t\t   (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))]\n   \"\"\n   \"@\n    xor<VAXint:isfx>2 %2,%0\n@@ -597,13 +615,13 @@\n \n (define_insn \"neg<mode>2\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n-\t(neg:VAXint (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n+\t(neg:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"mneg<VAXint:isfx> %1,%0\")\n \n (define_insn \"one_cmpl<mode>2\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n-\t(not:VAXint (match_operand:VAXint 1 \"general_operand\" \"g\")))]\n+\t(not:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"mcom<VAXint:isfx> %1,%0\")\n \n@@ -620,43 +638,50 @@\n   \"\"\n   \"\n {\n-  if (!CONST_INT_P (operands[2]))\n+  if (! CONST_INT_P(operands[2]))\n     operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n   \"ashl $%n2,%1,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n   \"\"\n   \"ashl %2,%1,%0\")\n \n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"*\n {\n   if (operands[2] == const1_rtx && rtx_equal_p (operands[0], operands[1]))\n     return \\\"addl2 %0,%0\\\";\n-  if (REG_P (operands[1])\n-      && CONST_INT_P (operands[2]))\n+  if (REG_P (operands[1]) && CONST_INT_P (operands[2]))\n     {\n       int i = INTVAL (operands[2]);\n       if (i == 1)\n \treturn \\\"addl3 %1,%1,%0\\\";\n-      if (i == 2)\n-\treturn \\\"moval 0[%1],%0\\\";\n-      if (i == 3)\n-\treturn \\\"movad 0[%1],%0\\\";\n+      if (i == 2 && !optimize_size)\n+\t{\n+\t  if (push_operand (operands[0], SImode))\n+\t    return \\\"pushal 0[%1]\\\";\n+\t  return \\\"moval 0[%1],%0\\\";\n+\t}\n+      if (i == 3 && !optimize_size)\n+\t{\n+\t  if (push_operand (operands[0], SImode))\n+\t    return \\\"pushaq 0[%1]\\\";\n+\t  return \\\"movaq 0[%1],%0\\\";\n+\t}\n     }\n   return \\\"ashl %2,%1,%0\\\";\n }\")\n@@ -695,7 +720,7 @@\n   [(set (match_dup 3)\n \t(minus:QI (const_int 32)\n \t\t  (match_dup 4)))\n-   (set (match_operand:SI 0 \"general_operand\" \"=g\")\n+   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t\t (match_dup 3)\n \t\t\t (match_operand:SI 2 \"register_operand\" \"g\")))]\n@@ -714,27 +739,27 @@\n   \"\"\n   \"\n {\n-  if (!CONST_INT_P (operands[2]))\n+  if (! CONST_INT_P (operands[2]))\n     operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n (define_insn \"rotlsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n   \"rotl %2,%1,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n   \"rotl %R2,%1,%0\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n   \"\"\n   \"rotl %2,%1,%0\")\n@@ -761,7 +786,7 @@\n    \"(INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n    && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n    && (REG_P (operands[0])\n-       || !mode_dependent_address_p (XEXP (operands[0], 0)))\"\n+       || ! mode_dependent_address_p (XEXP (operands[0], 0)))\"\n   \"*\n {\n   if (REG_P (operands[0]))\n@@ -789,7 +814,7 @@\n   \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n    && (REG_P (operands[1])\n-       || !mode_dependent_address_p (XEXP (operands[1], 0)))\"\n+       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n   \"*\n {\n   if (REG_P (operands[1]))\n@@ -816,7 +841,7 @@\n   \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n    && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n    && (REG_P (operands[1])\n-       || !mode_dependent_address_p (XEXP (operands[1], 0)))\"\n+       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n   \"*\n {\n   if (REG_P (operands[1]))\n@@ -842,8 +867,8 @@\n \t(compare\n \t (sign_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n+\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"cmpv %2,%1,%0,%3\")\n \n@@ -852,8 +877,8 @@\n \t(compare\n \t (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n+\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"cmpzv %2,%1,%0,%3\")\n \n@@ -866,13 +891,12 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"ro\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"*\n {\n-  if (!CONST_INT_P (operands[3])\n-      || !CONST_INT_P (operands[2])\n-      || !REG_P (operands[0])\n+  if (! CONST_INT_P (operands[3]) || ! CONST_INT_P (operands[2])\n+      || ! REG_P (operands[0])\n       || (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16))\n     return \\\"extv %3,%2,%1,%0\\\";\n   if (INTVAL (operands[2]) == 8)\n@@ -884,13 +908,12 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"ro\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"*\n {\n-  if (!CONST_INT_P (operands[3])\n-      || !CONST_INT_P (operands[2])\n-      || !REG_P (operands[0]))\n+  if (! CONST_INT_P (operands[3]) || ! CONST_INT_P (operands[2])\n+      || ! REG_P (operands[0]))\n     return \\\"extzv %3,%2,%1,%0\\\";\n   if (INTVAL (operands[2]) == 8)\n     return \\\"rotl %R3,%1,%0\\;movzbl %0,%0\\\";\n@@ -912,8 +935,8 @@\n \t(compare\n \t (sign_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n+\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"cmpv %2,%1,%0,%3\")\n \n@@ -922,21 +945,20 @@\n \t(compare\n \t (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"rm\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n+\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"cmpzv %2,%1,%0,%3\")\n \n (define_insn \"extv\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"*\n {\n-  if (!REG_P (operands[0])\n-      || !CONST_INT_P (operands[2])\n+  if (!REG_P (operands[0]) || !CONST_INT_P (operands[2])\n       || !CONST_INT_P (operands[3])\n       || (INTVAL (operands[2]) != 8 && INTVAL (operands[2]) != 16)\n       || INTVAL (operands[2]) + INTVAL (operands[3]) > 32\n@@ -961,12 +983,11 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n   \"*\n {\n-  if (!REG_P (operands[0])\n-      || !CONST_INT_P (operands[2])\n+  if (!REG_P (operands[0]) || !CONST_INT_P (operands[2])\n       || !CONST_INT_P (operands[3])\n       || INTVAL (operands[2]) + INTVAL (operands[3]) > 32\n       || side_effects_p (operands[1])\n@@ -977,6 +998,28 @@\n     return \\\"rotl %R3,%1,%0\\;movzbl %0,%0\\\";\n   if (INTVAL (operands[2]) == 16)\n     return \\\"rotl %R3,%1,%0\\;movzwl %0,%0\\\";\n+  if (MEM_P (operands[1])\n+      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+      && REG_P (XEXP (XEXP (operands[1], 0), 0))\n+      && CONST_INT_P (XEXP (XEXP (operands[1], 0), 1))\n+      && CONST_INT_P (operands[2])\n+      && CONST_INT_P (operands[3]))\n+    {\n+      HOST_WIDE_INT o = INTVAL (XEXP (XEXP (operands[1], 0), 1));\n+      HOST_WIDE_INT l = INTVAL (operands[2]);\n+      HOST_WIDE_INT v = INTVAL (operands[3]);\n+      if ((o & 3) && (o & 3) * 8 + v + l <= 32)\n+\t{\n+\t  rtx tmp;\n+\t  tmp = XEXP (XEXP (operands[1], 0), 0);\n+\t  if (o & ~3)\n+\t    tmp = gen_rtx_PLUS (SImode, tmp, GEN_INT (o & ~3));\n+\t  operands[1] = gen_rtx_MEM (QImode, tmp);\n+\t  operands[3] = GEN_INT (v + (o & 3) * 8);\n+\t}\n+      if (optimize_size)\n+\treturn \\\"extzv %3,%2,%1,%0\\\";\n+    }\n   return \\\"rotl %R3,%1,%0\\;bicl2 %M2,%0\\\";\n }\")\n \n@@ -991,16 +1034,39 @@\n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+g\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t(match_operand:SI 3 \"general_operand\" \"g\"))]\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n+\t(match_operand:SI 3 \"general_operand\" \"nrmT\"))]\n   \"\"\n-  \"insv %3,%2,%1,%0\")\n+  \"*\n+{\n+  if (MEM_P (operands[0])\n+      && GET_CODE (XEXP (operands[0], 0)) == PLUS\n+      && REG_P (XEXP (XEXP (operands[0], 0), 0))\n+      && CONST_INT_P (XEXP (XEXP (operands[0], 0), 1))\n+      && CONST_INT_P (operands[1])\n+      && CONST_INT_P (operands[2]))\n+    {\n+      HOST_WIDE_INT o = INTVAL (XEXP (XEXP (operands[0], 0), 1));\n+      HOST_WIDE_INT v = INTVAL (operands[2]);\n+      HOST_WIDE_INT l = INTVAL (operands[1]);\n+      if ((o & 3) && (o & 3) * 8 + v + l <= 32)\n+\t{\n+\t  rtx tmp;\n+\t  tmp = XEXP (XEXP (operands[0], 0), 0);\n+\t  if (o & ~3)\n+\t    tmp = gen_rtx_PLUS (SImode, tmp, GEN_INT (o & ~3));\n+\t  operands[0] = gen_rtx_MEM (QImode, tmp);\n+\t  operands[2] = GEN_INT (v + (o & 3) * 8);\n+\t}\n+    }\n+  return \\\"insv %3,%2,%1,%0\\\";\n+}\")\n \n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t(match_operand:SI 3 \"general_operand\" \"g\"))]\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n+\t(match_operand:SI 3 \"general_operand\" \"nrmT\"))]\n   \"\"\n   \"insv %3,%2,%1,%0\")\n \f\n@@ -1044,7 +1110,7 @@\n \t(if_then_else\n \t (ne (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"Q,g\")\n \t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,nrmT\"))\n \t     (const_int 0))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))]\n@@ -1058,7 +1124,7 @@\n \t(if_then_else\n \t (eq (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"Q,g\")\n \t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,nrmT\"))\n \t     (const_int 0))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))]\n@@ -1072,7 +1138,7 @@\n \t(if_then_else\n \t (ne (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,nrmT\"))\n \t     (const_int 0))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))]\n@@ -1086,7 +1152,7 @@\n \t(if_then_else\n \t (eq (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"r,r\")\n \t\t\t      (const_int 1)\n-\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,g\"))\n+\t\t\t      (match_operand:SI 1 \"general_operand\" \"I,nrmT\"))\n \t     (const_int 0))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))]\n@@ -1135,7 +1201,7 @@\n \t(if_then_else\n \t (lt (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n \t\t      (const_int 1))\n-\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))\n    (set (match_dup 0)\n@@ -1148,7 +1214,7 @@\n   [(set (pc)\n \t(if_then_else\n \t (lt (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n-\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))\n    (set (match_dup 0)\n@@ -1162,7 +1228,7 @@\n \t(if_then_else\n \t (le (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n \t\t      (const_int 1))\n-\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))\n    (set (match_dup 0)\n@@ -1175,7 +1241,7 @@\n   [(set (pc)\n \t(if_then_else\n \t (le (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n-\t     (match_operand:SI 1 \"general_operand\" \"g\"))\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))\n    (set (match_dup 0)\n@@ -1278,7 +1344,7 @@\n (define_expand \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n       (call (match_operand:QI 1 \"memory_operand\" \"\")\n-            (match_operand:SI 2 \"const_int_operand\" \"\")))]\n+\t    (match_operand:SI 2 \"const_int_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -1299,9 +1365,9 @@\n \n (define_expand \"untyped_call\"\n   [(parallel [(call (match_operand 0 \"\" \"\")\n-                  (const_int 0))\n-            (match_operand 1 \"\" \"\")\n-            (match_operand 2 \"\" \"\")])]\n+\t      (const_int 0))\n+\t      (match_operand 1 \"\" \"\")\n+\t      (match_operand 2 \"\" \"\")])]\n   \"\"\n   \"\n {\n@@ -1413,13 +1479,37 @@\n   [(match_operand:SI 1 \"const_int_operand\" \"n\")\n    (set (pc)\n \t(plus:SI (sign_extend:SI\n-\t\t  (mem:HI (plus:SI (mult:SI (match_operand:SI 0 \"general_operand\" \"g\")\n+\t\t  (mem:HI (plus:SI (mult:SI (match_operand:SI 0 \"general_operand\" \"nrmT\")\n \t\t\t\t\t    (const_int 2))\n \t\t\t  (pc))))\n \t\t (label_ref:SI (match_operand 2 \"\" \"\"))))]\n   \"\"\n   \"casel %0,$0,%1\")\n \f\n+(define_insn \"pushextsym\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:SI 1 \"external_symbolic_operand\" \"i\"))]\n+  \"\"\n+  \"pushab %a1\")\n+\n+(define_insn \"movextsym\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:SI 1 \"external_symbolic_operand\" \"i\"))]\n+  \"\"\n+  \"movab %a1,%0\")\n+\n+(define_insn \"pushlclsym\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:SI 1 \"local_symbolic_operand\" \"i\"))]\n+  \"\"\n+  \"pushab %a1\")\n+\n+(define_insn \"movlclsym\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:SI 1 \"local_symbolic_operand\" \"i\"))]\n+  \"\"\n+  \"movab %a1,%0\")\n+\f\n ;;- load or push effective address\n ;; These come after the move and add/sub patterns\n ;; because we don't want pushl $1 turned into pushad 1.\n@@ -1428,77 +1518,29 @@\n ;; It does not work to use constraints to distinguish pushes from moves,\n ;; because < matches any autodecrement, not just a push.\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushab %a1\\\";\n-  else\n-    return \\\"movab %a1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:HI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushaw %a1\\\";\n-  else\n-    return \\\"movaw %a1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+(define_insn \"pushaddr<mode>\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:VAXintQHSD 1 \"address_operand\" \"p\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushal %a1\\\";\n-  else\n-    return \\\"moval %a1,%0\\\";\n-}\")\n+  \"pusha<VAXintQHSD:isfx> %a1\")\n \n-(define_insn \"\"\n+(define_insn \"movaddr<mode>\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:DI 1 \"address_operand\" \"p\"))]\n+\t(match_operand:VAXintQHSD 1 \"address_operand\" \"p\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushaq %a1\\\";\n-  else\n-    return \\\"movaq %a1,%0\\\";\n-}\")\n+  \"mova<VAXintQHSD:isfx> %a1,%0\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:SF 1 \"address_operand\" \"p\"))]\n+(define_insn \"pushaddr<mode>\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:VAXfp 1 \"address_operand\" \"p\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushaf %a1\\\";\n-  else\n-    return \\\"movaf %a1,%0\\\";\n-}\")\n+  \"pusha<VAXfp:fsfx> %a1\")\n \n-(define_insn \"\"\n+(define_insn \"movaddr<mode>\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n-\t(match_operand:DF 1 \"address_operand\" \"p\"))]\n+\t(match_operand:VAXfp 1 \"address_operand\" \"p\"))]\n   \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"pushad %a1\\\";\n-  else\n-    return \\\"movad %a1,%0\\\";\n-}\")\n+  \"mova<VAXfp:fsfx> %a1,%0\")\n \f\n ;; These used to be peepholes, but it is more straightforward to do them\n ;; as single insns.  However, we must force the output to be a register\n@@ -1515,7 +1557,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n-\t(and:SI (ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(and:SI (ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\"))\n \t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[3]) & ~((1 << (32 - INTVAL (operands[2]))) - 1)) == 0\"\n@@ -1537,7 +1579,7 @@\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n-\t(and:SI (ashift:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t\t   (match_operand:QI 2 \"const_int_operand\" \"n\"))\n \t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"\"\n@@ -1553,3 +1595,29 @@\n   [(unspec_volatile [(const_int 0)] VUNSPEC_SYNC_ISTREAM)]\n   \"\"\n   \"movpsl -(%|sp)\\;pushal 1(%|pc)\\;rei\")\n+\n+(define_expand \"nonlocal_goto\"\n+  [(use (match_operand 0 \"general_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))\n+   (use (match_operand 2 \"general_operand\" \"\"))\n+   (use (match_operand 3 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  rtx lab = operands[1];\n+  rtx stack = operands[2];\n+  rtx fp = operands[3];\n+\n+  emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n+  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n+\n+  emit_move_insn (hard_frame_pointer_rtx, fp);\n+  emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);\n+\n+  emit_use (hard_frame_pointer_rtx);\n+  emit_use (stack_pointer_rtx);\n+\n+  /* We'll convert this to direct jump via a peephole optimization.  */\n+  emit_indirect_jump (copy_to_reg (lab));\n+  emit_barrier ();\n+  DONE;\n+})"}, {"sha": "82d6dee642293d080f007ae374fed94713064bc1", "filename": "gcc/config/vax/vax.opt", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4e751024524920e060b1c2fcbcc15423d86ac2c/gcc%2Fconfig%2Fvax%2Fvax.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.opt?ref=c4e751024524920e060b1c2fcbcc15423d86ac2c", "patch": "@@ -1,6 +1,6 @@\n ; Options for the VAX port of the compiler.\n \n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n ;\n ; This file is part of GCC.\n ;\n@@ -45,3 +45,7 @@ Generate code for UNIX assembler\n mvaxc-alignment\n Target RejectNegative Mask(VAXC_ALIGNMENT)\n Use VAXC structure conventions\n+\n+mqmath\n+Target Mask(QMATH)\n+Use new adddi3/subdi3 patterns"}]}