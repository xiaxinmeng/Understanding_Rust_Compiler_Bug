{"sha": "c6d2191a0da9f40899da20933f008242f90262e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZkMjE5MWEwZGE5ZjQwODk5ZGEyMDkzM2YwMDgyNDJmOTAyNjJlMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:51:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-24T16:51:58Z"}, "message": "[multiple changes]\n\n2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Global_Item): Emit the\n\tvariable related checks concerning volatile objects only when\n\tSPARK_Mode is on.\n\n2014-02-24  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch5.adb (Analyze_Iterator_Specification): use\n\tError_Msg_Ada_2012_Feature.\n\n2014-02-24  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-rident.ads (Profile_Info): For Ravenscar, the restrictions\n\tNo_Local_Timing_Events and No_Specific_Termination_Handlers\n\tmust be set, according to the Ravenscar profile definition\n\tin D.13(6/3).\n\n2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Expression_Function): If this is a\n\tcompletion, freeze return type and its designated type if needed.\n\n2014-02-24  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause, case\n\t'Address): When moving initialization statements to a freeze\n\tentity, keep them under a single node (i.e. do not unwrap\n\texpressions with actions), and set the Initialization_Statements\n\tattribute again so that processing of a later pragma Import can\n\tstill remove them.\n\n2014-02-24  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfdlli.ads, a-cfhama.adb, a-cfhama.ads,\n\ta-cfhase.adb, a-cfhase.ads, a-cforma.adb, a-cforma.ads,\n\ta-cforse.adb, a-cforse.ads, a-cofove.adb, a-cofove.ads: Rename\n\tLeft/Right to First_To_Previous/Current_To_Last.\n\n2014-02-24  Thomas Quinot  <quinot@adacore.com>\n\n\t* adaint.h (struct file_attributes): New component \"error\"\n\t(__gnat_error_attributes): Accessor for the above.\n\t* adaint.c (__gnat_error_attributes): New subprogram\n\t(__gnat_stat): Fix returned value (expect errno value)\n\t(__gnat_stat_to_attr): Add management of error component (set to\n\tstat errno value, except for missing files where it is set to 0,\n\tand exists is set to 0).\n\t* osint.ads (File_Attributes_Size): Update per change above,\n\talso clarify documentation.\n\t* s-filatt.ads: New file, binding to file attributes related\n\tfunctions.\n\t* Makefile.rtl (s-filatt): New runtime unit.\n\t* s-crtl.ads (strlen): Expose binding to GCC builtin (falls back\n\tto library function if not available on target).\n\t* s-os_lib.ads, s-os_lib.adb (Errno_Message): New subprogram.\n\t* s-oscons-tmplt.c (SIZEOF_struct_file_attributes,\n\tSIZEOF_struct_dirent_alloc): New constants.\n\t* Make-generated.in (s-oscons.ads): Now requires adaint.h.\n\t* a-direct.adb (Fetch_Next_Entry): Fix incorrect buffer sizes.\n\tPerform appropriate error checking if stat fails (do not just\n\tignore existing files if stat fails)\n\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS, GNATBIND_OBJS): Update\n\tdependencies.\n\nFrom-SVN: r208078", "tree": {"sha": "3a271858d673fb57c047135e5a838d33e1ee5af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a271858d673fb57c047135e5a838d33e1ee5af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6d2191a0da9f40899da20933f008242f90262e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d2191a0da9f40899da20933f008242f90262e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6d2191a0da9f40899da20933f008242f90262e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6d2191a0da9f40899da20933f008242f90262e0/comments", "author": null, "committer": null, "parents": [{"sha": "ec77b14454cfb80c70a0b17b7ced31c8956af30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec77b14454cfb80c70a0b17b7ced31c8956af30b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec77b14454cfb80c70a0b17b7ced31c8956af30b"}], "stats": {"total": 1363, "additions": 829, "deletions": 534}, "files": [{"sha": "24bac575282962ae223d068c2922e488956da2fb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -1,3 +1,68 @@\n+2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Global_Item): Emit the\n+\tvariable related checks concerning volatile objects only when\n+\tSPARK_Mode is on.\n+\n+2014-02-24  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch5.adb (Analyze_Iterator_Specification): use\n+\tError_Msg_Ada_2012_Feature.\n+\n+2014-02-24  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* s-rident.ads (Profile_Info): For Ravenscar, the restrictions\n+\tNo_Local_Timing_Events and No_Specific_Termination_Handlers\n+\tmust be set, according to the Ravenscar profile definition\n+\tin D.13(6/3).\n+\n+2014-02-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Expression_Function): If this is a\n+\tcompletion, freeze return type and its designated type if needed.\n+\n+2014-02-24  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause, case\n+\t'Address): When moving initialization statements to a freeze\n+\tentity, keep them under a single node (i.e. do not unwrap\n+\texpressions with actions), and set the Initialization_Statements\n+\tattribute again so that processing of a later pragma Import can\n+\tstill remove them.\n+\n+2014-02-24  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfdlli.ads, a-cfhama.adb, a-cfhama.ads,\n+\ta-cfhase.adb, a-cfhase.ads, a-cforma.adb, a-cforma.ads,\n+\ta-cforse.adb, a-cforse.ads, a-cofove.adb, a-cofove.ads: Rename\n+\tLeft/Right to First_To_Previous/Current_To_Last.\n+\n+2014-02-24  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* adaint.h (struct file_attributes): New component \"error\"\n+\t(__gnat_error_attributes): Accessor for the above.\n+\t* adaint.c (__gnat_error_attributes): New subprogram\n+\t(__gnat_stat): Fix returned value (expect errno value)\n+\t(__gnat_stat_to_attr): Add management of error component (set to\n+\tstat errno value, except for missing files where it is set to 0,\n+\tand exists is set to 0).\n+\t* osint.ads (File_Attributes_Size): Update per change above,\n+\talso clarify documentation.\n+\t* s-filatt.ads: New file, binding to file attributes related\n+\tfunctions.\n+\t* Makefile.rtl (s-filatt): New runtime unit.\n+\t* s-crtl.ads (strlen): Expose binding to GCC builtin (falls back\n+\tto library function if not available on target).\n+\t* s-os_lib.ads, s-os_lib.adb (Errno_Message): New subprogram.\n+\t* s-oscons-tmplt.c (SIZEOF_struct_file_attributes,\n+\tSIZEOF_struct_dirent_alloc): New constants.\n+\t* Make-generated.in (s-oscons.ads): Now requires adaint.h.\n+\t* a-direct.adb (Fetch_Next_Entry): Fix incorrect buffer sizes.\n+\tPerform appropriate error checking if stat fails (do not just\n+\tignore existing files if stat fails)\n+\t* gcc-interface/Make-lang.in (GNAT_ADA_OBJS, GNATBIND_OBJS): Update\n+\tdependencies.\n+\n 2014-02-24  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_prag.adb (Analyze_Global_Item): Move the check concerning"}, {"sha": "8cbc2f3c334be34e8549adf1ebc67b234fddf556", "filename": "gcc/ada/Make-generated.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2FMake-generated.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2FMake-generated.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-generated.in?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -84,7 +84,7 @@ OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i\n #  ld -o s-oscons-tmplt.exe s-oscons-tmplt.obj; \\\n #  ./s-oscons-tmplt.exe > s-oscons-tmplt.s\n \n-$(ADA_GEN_SUBDIR)/s-oscons.ads : $(ADA_GEN_SUBDIR)/s-oscons-tmplt.c $(ADA_GEN_SUBDIR)/gsocket.h $(ADA_GEN_SUBDIR)/xoscons.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n+$(ADA_GEN_SUBDIR)/s-oscons.ads : $(ADA_GEN_SUBDIR)/s-oscons-tmplt.c $(ADA_GEN_SUBDIR)/gsocket.h $(ADA_GEN_SUBDIR)/adaint.h $(ADA_GEN_SUBDIR)/xoscons.adb $(ADA_GEN_SUBDIR)/xutil.ads $(ADA_GEN_SUBDIR)/xutil.adb\n \t-$(MKDIR) $(ADA_GEN_SUBDIR)/bldtools/oscons\n \t$(RM) $(addprefix $(ADA_GEN_SUBDIR)/bldtools/oscons/,$(notdir $^))\n \t$(CP) $^ $(ADA_GEN_SUBDIR)/bldtools/oscons"}, {"sha": "e4f2a5948d9e5bcbbcaa98895d32a14c0c244b6e", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -535,6 +535,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-fatllf$(objext) \\\n   s-fatsfl$(objext) \\\n   s-ficobl$(objext) \\\n+  s-filatt$(objext) \\\n   s-fileio$(objext) \\\n   s-filofl$(objext) \\\n   s-finmas$(objext) \\"}, {"sha": "706bafc6de7d26e838e293db2da068c68a8679fe", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -257,6 +257,36 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return P;\n    end Copy;\n \n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last\n+     (Container : List;\n+      Current : Cursor) return List is\n+      Curs : Cursor := First (Container);\n+      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n+      end if;\n+\n+      if Current /= No_Element and not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= Current.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end Current_To_Last;\n+\n    ------------\n    -- Delete --\n    ------------\n@@ -471,6 +501,35 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       end if;\n    end First_Element;\n \n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : List;\n+      Current : Cursor) return List is\n+      Curs : Cursor := Current;\n+      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end First_To_Previous;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -865,33 +924,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       end if;\n    end Last_Element;\n \n-   ----------\n-   -- Left --\n-   ----------\n-\n-   function Left (Container : List; Position : Cursor) return List is\n-      Curs : Cursor := Position;\n-      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Left;\n-\n    ------------\n    -- Length --\n    ------------\n@@ -1172,34 +1204,6 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       return No_Element;\n    end Reverse_Find;\n \n-   -----------\n-   -- Right --\n-   -----------\n-\n-   function Right (Container : List; Position : Cursor) return List is\n-      Curs : Cursor := First (Container);\n-      C    : List (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if Position /= No_Element and not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Position.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Right;\n-\n    ------------\n    -- Splice --\n    ------------"}, {"sha": "b5ceacacfd0a50d3bd6f2364cbbe6f545d1e7be4", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -48,8 +48,10 @@\n --    There are three new functions:\n \n --      function Strict_Equal (Left, Right : List) return Boolean;\n---      function Left  (Container : List; Position : Cursor) return List;\n---      function Right (Container : List; Position : Cursor) return List;\n+--      function First_To_Previous  (Container : List; Current : Cursor)\n+--         return List;\n+--      function Current_To_Last (Container : List; Current : Cursor)\n+--         return List;\n \n --    See subprogram specifications that follow for details\n \n@@ -313,18 +315,21 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : List; Position : Cursor) return List with\n+   function First_To_Previous (Container : List; Current : Cursor) return List\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : List; Position : Cursor) return List with\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   function Current_To_Last (Container : List; Current : Cursor) return List\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   --  Left returns a container containing all elements preceding Position\n-   --  (excluded) in Container. Right returns a container containing all\n-   --  elements following Position (included) in Container. These two new\n-   --  functions can be used to express invariant properties in loops which\n-   --  iterate over containers. Left returns the part of the container already\n-   --  scanned and Right the part not scanned yet.\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   --  First_To_Previous returns a container containing all elements preceding\n+   --  Current (excluded) in Container. Current_To_Last returns a container\n+   --  containing all elements following Current (included) in Container.\n+   --  These two new functions can be used to express invariant properties in\n+   --  loops which iterate over containers. First_To_Previous returns the part\n+   --  of the container already scanned and Current_To_Last the part not\n+   --  scanned yet.\n \n private\n "}, {"sha": "a8fe127375189b4dc74d4b61e3c74763a8692e75", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -235,6 +235,35 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return Target;\n    end Copy;\n \n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last (Container : Map; Current : Cursor) return Map is\n+      Curs : Cursor := First (Container);\n+      C    : Map (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n+      end if;\n+\n+      if Current /= No_Element and not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= Current.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end Current_To_Last;\n+\n    ---------------------\n    -- Default_Modulus --\n    ---------------------\n@@ -429,6 +458,38 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return (Node => Node);\n    end First;\n \n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : Map;\n+      Current : Cursor) return Map is\n+      Curs : Cursor;\n+      C    : Map (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      Curs := Current;\n+\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end First_To_Previous;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -596,36 +657,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       return Container.Nodes (Position.Node).Key;\n    end Key;\n \n-   ----------\n-   -- Left --\n-   ----------\n-\n-   function Left (Container : Map; Position : Cursor) return Map is\n-      Curs : Cursor;\n-      C    : Map (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      Curs := Position;\n-\n-      if Curs = No_Element then\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Left;\n-\n    ------------\n    -- Length --\n    ------------\n@@ -808,35 +839,6 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       end if;\n    end Reserve_Capacity;\n \n-   -----------\n-   -- Right --\n-   -----------\n-\n-   function Right (Container : Map; Position : Cursor) return Map is\n-      Curs : Cursor := First (Container);\n-      C    : Map (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if Position /= No_Element and not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Position.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Right;\n-\n    --------------\n    -- Set_Next --\n    --------------"}, {"sha": "9a2b37690dd373be13b90f0269057ebe92685494", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -48,8 +48,10 @@\n \n --      function Strict_Equal (Left, Right : Map) return Boolean;\n --      function Overlap (Left, Right : Map) return Boolean;\n---      function Left  (Container : Map; Position : Cursor) return Map;\n---      function Right (Container : Map; Position : Cursor) return Map;\n+--      function First_To_Previous (Container : Map; Current : Cursor)\n+--         return Map;\n+--      function Current_To_Last (Container : Map; Current : Cursor)\n+--         return Map;\n \n --    See detailed specifications for these subprograms\n \n@@ -243,18 +245,21 @@ package Ada.Containers.Formal_Hashed_Maps is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Map; Position : Cursor) return Map with\n+   function First_To_Previous (Container : Map; Current : Cursor) return Map\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : Map; Position : Cursor) return Map with\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   function Current_To_Last (Container : Map; Current : Cursor) return Map\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   --  Left returns a container containing all elements preceding Position\n-   --  (excluded) in Container. Right returns a container containing all\n-   --  elements following Position (included) in Container. These two new\n-   --  functions can be used to express invariant properties in loops which\n-   --  iterate over containers. Left returns the part of the container already\n-   --  scanned and Right the part not scanned yet.\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   --  First_To_Previous returns a container containing all elements preceding\n+   --  Current (excluded) in Container. Current_To_Last returns a container\n+   --  containing all elements following Current (included) in Container.\n+   --  These two new functions can be used to express invariant properties in\n+   --  loops which iterate over containers. First_To_Previous returns the part\n+   --  of the container already scanned and Current_To_Last the part not\n+   --  scanned yet.\n \n    function Overlap (Left, Right : Map) return Boolean with\n      Global => null;"}, {"sha": "27a025394211c5cf0ac70c2229abaa3665e2b577", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -261,6 +261,35 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       return Target;\n    end Copy;\n \n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last (Container : Set; Current : Cursor) return Set is\n+      Curs : Cursor := First (Container);\n+      C    : Set (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n+      end if;\n+\n+      if Current /= No_Element and not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= Current.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end Current_To_Last;\n+\n    ---------------------\n    -- Default_Modulus --\n    ---------------------\n@@ -626,6 +655,36 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       return (Node => Node);\n    end First;\n \n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : Set;\n+      Current : Cursor) return Set is\n+      Curs : Cursor := Current;\n+      C    : Set (Container.Capacity, Container.Modulus) :=\n+        Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end First_To_Previous;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -912,34 +971,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       return True;\n    end Is_Subset;\n \n-   ----------\n-   -- Left --\n-   ----------\n-\n-   function Left (Container : Set; Position : Cursor) return Set is\n-      Curs : Cursor := Position;\n-      C    : Set (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Left;\n-\n    ------------\n    -- Length --\n    ------------\n@@ -1106,35 +1137,6 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       end if;\n    end Reserve_Capacity;\n \n-   -----------\n-   -- Right --\n-   -----------\n-\n-   function Right (Container : Set; Position : Cursor) return Set is\n-      Curs : Cursor := First (Container);\n-      C    : Set (Container.Capacity, Container.Modulus) :=\n-        Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if Position /= No_Element and not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Position.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Right;\n-\n    ------------------\n    --  Set_Element --\n    ------------------"}, {"sha": "4e54ef978322c2b04a18e1ba6e87125ffda9a522", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -48,8 +48,10 @@\n --    There are three new functions:\n \n --      function Strict_Equal (Left, Right : Set) return Boolean;\n---      function Left  (Container : Set; Position : Cursor) return Set;\n---      function Right (Container : Set; Position : Cursor) return Set;\n+--      function First_To_Previous  (Container : Set; Current : Cursor)\n+--         return Set;\n+--      function Current_To_Last (Container : Set; Current : Cursor)\n+--         return Set;\n \n --    See detailed specifications for these subprograms\n \n@@ -310,18 +312,21 @@ package Ada.Containers.Formal_Hashed_Sets is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Set; Position : Cursor) return Set with\n+   function First_To_Previous  (Container : Set; Current : Cursor) return Set\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : Set; Position : Cursor) return Set with\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   function Current_To_Last (Container : Set; Current : Cursor) return Set\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   --  Left returns a container containing all elements preceding Position\n-   --  (excluded) in Container. Right returns a container containing all\n-   --  elements following Position (included) in Container. These two new\n-   --  functions can be used to express invariant properties in loops which\n-   --  iterate over containers. Left returns the part of the container already\n-   --  scanned and Right the part not scanned yet.\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   --  First_To_Previous returns a container containing all elements preceding\n+   --  Current (excluded) in Container. Current_To_Last returns a container\n+   --  containing all elements following Current (included) in Container.\n+   --  These two new functions can be used to express invariant properties in\n+   --  loops which iterate over containers. First_To_Previous returns the part\n+   --  of the container already scanned and Current_To_Last the part not\n+   --  scanned yet.\n \n private\n "}, {"sha": "f8aadf5bbf005adf225856fbf990b74df35c6033", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -48,13 +48,13 @@ package body Ada.Containers.Formal_Ordered_Maps is\n    pragma Inline (Color);\n \n    function Left_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Left);\n+   pragma Inline (Left_Son);\n \n    function Parent (Node : Node_Type) return Count_Type;\n    pragma Inline (Parent);\n \n    function Right_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Right);\n+   pragma Inline (Right_Son);\n \n    procedure Set_Color\n      (Node  : in out Node_Type;\n@@ -322,6 +322,34 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       end return;\n    end Copy;\n \n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last (Container : Map; Current : Cursor) return Map is\n+      Curs : Cursor := First (Container);\n+      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n+\n+      end if;\n+      if Current /= No_Element and not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= Current.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end Current_To_Last;\n+\n    ------------\n    -- Delete --\n    ------------\n@@ -490,6 +518,35 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       return Container.Nodes (First (Container).Node).Key;\n    end First_Key;\n \n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : Map;\n+      Current : Cursor) return Map is\n+      Curs : Cursor := Current;\n+      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end First_To_Previous;\n+\n    -----------\n    -- Floor --\n    -----------\n@@ -725,33 +782,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       return Container.Nodes (Last (Container).Node).Key;\n    end Last_Key;\n \n-   ----------\n-   -- Left --\n-   ----------\n-\n-   function Left (Container : Map; Position : Cursor) return Map is\n-      Curs : Cursor := Position;\n-      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Left;\n-\n    --------------\n    -- Left_Son --\n    --------------\n@@ -964,34 +994,6 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       Container.Nodes (Position.Node).Element := New_Item;\n    end Replace_Element;\n \n-   -----------\n-   -- Right --\n-   -----------\n-\n-   function Right (Container : Map; Position : Cursor) return Map is\n-      Curs : Cursor := First (Container);\n-      C    : Map (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-\n-      end if;\n-      if Position /= No_Element and not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Position.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Right;\n-\n    ---------------\n    -- Right_Son --\n    ---------------"}, {"sha": "64d77fa4c8dfabb65f35c887adb0ad4c74de90a4", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -50,8 +50,10 @@\n \n --      function Strict_Equal (Left, Right : Map) return Boolean;\n --      function Overlap (Left, Right : Map) return Boolean;\n---      function Left  (Container : Map; Position : Cursor) return Map;\n---      function Right (Container : Map; Position : Cursor) return Map;\n+--      function First_To_Previous  (Container : Map; Current : Cursor)\n+--         return Map;\n+--      function Current_To_Last (Container : Map; Current : Cursor)\n+--         return Map;\n \n --    See detailed specifications for these subprograms\n \n@@ -244,18 +246,21 @@ package Ada.Containers.Formal_Ordered_Maps is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Map; Position : Cursor) return Map with\n+   function First_To_Previous (Container : Map; Current : Cursor) return Map\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : Map; Position : Cursor) return Map with\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   function Current_To_Last (Container : Map; Current : Cursor) return Map\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   --  Left returns a container containing all elements preceding Position\n-   --  (excluded) in Container. Right returns a container containing all\n-   --  elements following Position (included) in Container. These two new\n-   --  functions can be used to express invariant properties in loops which\n-   --  iterate over containers. Left returns the part of the container already\n-   --  scanned and Right the part not scanned yet.\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   --  First_To_Previous returns a container containing all elements preceding\n+   --  Current (excluded) in Container. Current_To_Last returns a container\n+   --  containing all elements following Current (included) in Container.\n+   --  These two new functions can be used to express invariant properties in\n+   --  loops which iterate over containers. First_To_Previous returns the part\n+   --  of the container already scanned and Current_To_Last the part not\n+   --  scanned yet.\n \n    function Overlap (Left, Right : Map) return Boolean with\n      Global => null;"}, {"sha": "ac24420cbbd1be76cdef7ee70ae595599ad80571", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -51,13 +51,13 @@ package body Ada.Containers.Formal_Ordered_Sets is\n    pragma Inline (Color);\n \n    function Left_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Left);\n+   pragma Inline (Left_Son);\n \n    function Parent (Node : Node_Type) return Count_Type;\n    pragma Inline (Parent);\n \n    function Right_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Right);\n+   pragma Inline (Right_Son);\n \n    procedure Set_Color\n      (Node  : in out Node_Type;\n@@ -358,6 +358,34 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       return Target;\n    end Copy;\n \n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last (Container : Set; Current : Cursor) return Set is\n+      Curs : Cursor := First (Container);\n+      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         Clear (C);\n+         return C;\n+      end if;\n+\n+      if Current /= No_Element and not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= Current.Node loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end Current_To_Last;\n+\n    ------------\n    -- Delete --\n    ------------\n@@ -566,6 +594,35 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end;\n    end First_Element;\n \n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : Set;\n+      Current : Cursor) return Set is\n+      Curs : Cursor := Current;\n+      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n+      Node : Count_Type;\n+\n+   begin\n+      if Curs = No_Element then\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Curs) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while Curs.Node /= 0 loop\n+         Node := Curs.Node;\n+         Delete (C, Curs);\n+         Curs := Next (Container, (Node => Node));\n+      end loop;\n+\n+      return C;\n+   end First_To_Previous;\n+\n    -----------\n    -- Floor --\n    -----------\n@@ -1091,33 +1148,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       end;\n    end Last_Element;\n \n-   ----------\n-   -- Left --\n-   ----------\n-\n-   function Left (Container : Set; Position : Cursor) return Set is\n-      Curs : Cursor := Position;\n-      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Curs) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= 0 loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Left;\n-\n    --------------\n    -- Left_Son --\n    --------------\n@@ -1360,34 +1390,6 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Replace_Element (Container, Position.Node, New_Item);\n    end Replace_Element;\n \n-   -----------\n-   -- Right --\n-   -----------\n-\n-   function Right (Container : Set; Position : Cursor) return Set is\n-      Curs : Cursor := First (Container);\n-      C    : Set (Container.Capacity) := Copy (Container, Container.Capacity);\n-      Node : Count_Type;\n-\n-   begin\n-      if Curs = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if Position /= No_Element and not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while Curs.Node /= Position.Node loop\n-         Node := Curs.Node;\n-         Delete (C, Curs);\n-         Curs := Next (Container, (Node => Node));\n-      end loop;\n-\n-      return C;\n-   end Right;\n-\n    ---------------\n    -- Right_Son --\n    ---------------"}, {"sha": "8d3189edaec5bdab7ceac8ef8d6944a81b7c75eb", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -49,8 +49,10 @@\n --    There are three new functions:\n \n --      function Strict_Equal (Left, Right : Set) return Boolean;\n---      function Left  (Container : Set; Position : Cursor) return Set;\n---      function Right (Container : Set; Position : Cursor) return Set;\n+--      function First_To_Previous (Container : Set; Current : Cursor)\n+--         return Set;\n+--      function Current_To_Last (Container : Set; Current : Cursor)\n+--         return Set;\n \n --    See detailed specifications for these subprograms\n \n@@ -328,18 +330,21 @@ package Ada.Containers.Formal_Ordered_Sets is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Set; Position : Cursor) return Set with\n+   function First_To_Previous (Container : Set; Current : Cursor) return Set\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : Set; Position : Cursor) return Set with\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   function Current_To_Last (Container : Set; Current : Cursor) return Set\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   --  Left returns a container containing all elements preceding Position\n-   --  (excluded) in Container. Right returns a container containing all\n-   --  elements following Position (included) in Container. These two new\n-   --  functions can be used to express invariant properties in loops which\n-   --  iterate over containers. Left returns the part of the container already\n-   --  scanned and Right the part not scanned yet.\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   --  First_To_Previous returns a container containing all elements preceding\n+   --  Current (excluded) in Container. Current_To_Last returns a container\n+   --  containing all elements following Current (included) in Container.\n+   --  These two new functions can be used to express invariant properties in\n+   --  loops which iterate over containers. First_To_Previous returns the part\n+   --  of the container already scanned and Current_To_Last the part not\n+   --  scanned yet.\n \n private\n "}, {"sha": "81990849de51b296e6efc3652a64bfea8702470c", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -313,6 +313,32 @@ package body Ada.Containers.Formal_Vectors is\n       end return;\n    end Copy;\n \n+   ---------------------\n+   -- Current_To_Last --\n+   ---------------------\n+\n+   function Current_To_Last\n+     (Container : Vector;\n+      Current : Cursor) return Vector is\n+      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n+\n+   begin\n+      if Current = No_Element then\n+         Clear (C);\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while C.Last /= Container.Last - Current.Index + 1 loop\n+         Delete_First (C);\n+      end loop;\n+\n+      return C;\n+   end Current_To_Last;\n+\n    ------------\n    -- Delete --\n    ------------\n@@ -578,6 +604,30 @@ package body Ada.Containers.Formal_Vectors is\n       return Index_Type'First;\n    end First_Index;\n \n+   -----------------------\n+   -- First_To_Previous --\n+   -----------------------\n+\n+   function First_To_Previous\n+     (Container : Vector;\n+      Current : Cursor) return Vector is\n+      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n+\n+   begin\n+      if Current = No_Element then\n+         return C;\n+      end if;\n+\n+      if not Has_Element (Container, Current) then\n+         raise Constraint_Error;\n+      end if;\n+\n+      while C.Last /= Current.Index - 1 loop\n+         Delete_Last (C);\n+      end loop;\n+      return C;\n+   end First_To_Previous;\n+\n    ---------------------\n    -- Generic_Sorting --\n    ---------------------\n@@ -1164,28 +1214,6 @@ package body Ada.Containers.Formal_Vectors is\n       return Count_Type (N);\n    end Length;\n \n-   ----------\n-   -- Left --\n-   ----------\n-\n-   function Left (Container : Vector; Position : Cursor) return Vector is\n-      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n-\n-   begin\n-      if Position = No_Element then\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while C.Last /= Position.Index - 1 loop\n-         Delete_Last (C);\n-      end loop;\n-      return C;\n-   end Left;\n-\n    ----------\n    -- Move --\n    ----------\n@@ -1459,30 +1487,6 @@ package body Ada.Containers.Formal_Vectors is\n       return No_Index;\n    end Reverse_Find_Index;\n \n-   -----------\n-   -- Right --\n-   -----------\n-\n-   function Right (Container : Vector; Position : Cursor) return Vector is\n-      C : Vector (Container.Capacity) := Copy (Container, Container.Capacity);\n-\n-   begin\n-      if Position = No_Element then\n-         Clear (C);\n-         return C;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      while C.Last /= Container.Last - Position.Index + 1 loop\n-         Delete_First (C);\n-      end loop;\n-\n-      return C;\n-   end Right;\n-\n    ----------------\n    -- Set_Length --\n    ----------------"}, {"sha": "d99041a46051e988cf4484c0cbca0ee6cedca190", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -48,8 +48,10 @@\n --    There are three new functions:\n \n --      function Strict_Equal (Left, Right : Vector) return Boolean;\n---      function Left  (Container : Vector; Position : Cursor) return Vector;\n---      function Right (Container : Vector; Position : Cursor) return Vector;\n+--      function First_To_Previous  (Container : Vector; Current : Cursor)\n+--         return Vector;\n+--      function Current_To_Last (Container : Vector; Current : Cursor)\n+--         return Vector;\n \n --    See detailed specifications for these subprograms\n \n@@ -430,18 +432,25 @@ package Ada.Containers.Formal_Vectors is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left (Container : Vector; Position : Cursor) return Vector with\n+   function First_To_Previous\n+     (Container : Vector;\n+      Current : Cursor) return Vector\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   function Right (Container : Vector; Position : Cursor) return Vector with\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   function Current_To_Last\n+     (Container : Vector;\n+      Current : Cursor) return Vector\n+   with\n      Global => null,\n-     Pre    => Has_Element (Container, Position) or else Position = No_Element;\n-   --  Left returns a container containing all elements preceding Position\n-   --  (excluded) in Container. Right returns a container containing all\n-   --  elements following Position (included) in Container. These two new\n-   --  functions can be used to express invariant properties in loops which\n-   --  iterate over containers. Left returns the part of the container already\n-   --  scanned and Right the part not scanned yet.\n+     Pre    => Has_Element (Container, Current) or else Current = No_Element;\n+   --  First_To_Previous returns a container containing all elements preceding\n+   --  Current (excluded) in Container. Current_To_Last returns a container\n+   --  containing all elements following Current (included) in Container.\n+   --  These two new functions can be used to express invariant properties in\n+   --  loops which iterate over containers. First_To_Previous returns the part\n+   --  of the container already scanned and Current_To_Last the part not\n+   --  scanned yet.\n \n private\n "}, {"sha": "c264b4c49c193ba9f008f71859342ec0bd4d25e0", "filename": "gcc/ada/a-direct.adb", "status": "modified", "additions": 45, "deletions": 33, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-direct.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fa-direct.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-direct.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,21 +36,18 @@ with Ada.Directories.Validity;   use Ada.Directories.Validity;\n with Ada.Strings.Fixed;\n with Ada.Strings.Maps;           use Ada.Strings.Maps;\n with Ada.Strings.Unbounded;      use Ada.Strings.Unbounded;\n-with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n-with System;              use System;\n-with System.CRTL;         use System.CRTL;\n-with System.File_IO;      use System.File_IO;\n-with System.OS_Constants; use System.OS_Constants;\n-with System.OS_Lib;       use System.OS_Lib;\n-with System.Regexp;       use System.Regexp;\n+with System;                 use System;\n+with System.CRTL;            use System.CRTL;\n+with System.File_Attributes; use System.File_Attributes;\n+with System.File_IO;         use System.File_IO;\n+with System.OS_Constants;    use System.OS_Constants;\n+with System.OS_Lib;          use System.OS_Lib;\n+with System.Regexp;          use System.Regexp;\n \n package body Ada.Directories is\n \n-   Filename_Max : constant Integer := 1024;\n-   --  1024 is the value of FILENAME_MAX in stdio.h\n-\n    type Dir_Type_Value is new Address;\n    --  This is the low-level address directory structure as returned by the C\n    --  opendir routine.\n@@ -708,7 +705,7 @@ package body Ada.Directories is\n    ----------------------\n \n    procedure Fetch_Next_Entry (Search : Search_Type) is\n-      Name : String (1 .. 255);\n+      Name : String (1 .. NAME_MAX);\n       Last : Natural;\n \n       Kind : File_Kind := Ordinary_File;\n@@ -717,9 +714,7 @@ package body Ada.Directories is\n       Filename_Addr : Address;\n       Filename_Len  : aliased Integer;\n \n-      Buffer : array (0 .. Filename_Max + 12) of Character;\n-      --  12 is the size of the dirent structure (see dirent.h), without the\n-      --  field for the filename.\n+      Buffer : array (1 .. SIZEOF_struct_dirent_alloc) of Character;\n \n       function readdir_gnat\n         (Directory : Address;\n@@ -744,43 +739,60 @@ package body Ada.Directories is\n             exit;\n          end if;\n \n-         declare\n-            subtype Path_String is String (1 .. Filename_Len);\n-            type    Path_String_Access is access Path_String;\n-\n-            function Address_To_Access is new\n-              Ada.Unchecked_Conversion\n-                (Source => Address,\n-                 Target => Path_String_Access);\n+         if Filename_Len > Name'Length then\n+            raise Use_Error with \"file name too long\";\n+         end if;\n \n-            Path_Access : constant Path_String_Access :=\n-              Address_To_Access (Filename_Addr);\n+         declare\n+            subtype Name_String is String (1 .. Filename_Len);\n+            Dent_Name : Name_String;\n+            for Dent_Name'Address use Filename_Addr;\n+            pragma Import (Ada, Dent_Name);\n \n          begin\n             Last := Filename_Len;\n-            Name (1 .. Last) := Path_Access.all;\n+            Name (1 .. Last) := Dent_Name;\n          end;\n \n          --  Check if the entry matches the pattern\n \n          if Match (Name (1 .. Last), Search.Value.Pattern) then\n             declare\n-               Full_Name : constant String :=\n-                 Compose (To_String (Search.Value.Name), Name (1 .. Last));\n-               Found     : Boolean := False;\n+               C_Full_Name : constant String :=\n+                 Compose (To_String (Search.Value.Name), Name (1 .. Last))\n+                   & ASCII.NUL;\n+               Full_Name   : String renames C_Full_Name\n+                               (C_Full_Name'First .. C_Full_Name'Last - 1);\n+               Found       : Boolean := False;\n+               Attr        : aliased File_Attributes;\n+               Exists      : Integer;\n+               Error       : Integer;\n \n             begin\n-               if File_Exists (Full_Name) then\n+               Reset_Attributes (Attr'Access);\n+               Exists := File_Exists_Attr (C_Full_Name'Address, Attr'Access);\n+               Error  := Error_Attributes (Attr'Access);\n+\n+               if Error /= 0 then\n+                  raise Use_Error\n+                    with Full_Name & \": \" & Errno_Message (Err => Error);\n+               end if;\n+\n+               if Exists = 1 then\n \n                   --  Now check if the file kind matches the filter\n \n-                  if Is_Regular_File (Full_Name) then\n+                  if Is_Regular_File_Attr\n+                       (C_Full_Name'Address, Attr'Access) = 1\n+                  then\n                      if Search.Value.Filter (Ordinary_File) then\n                         Kind := Ordinary_File;\n                         Found := True;\n                      end if;\n \n-                  elsif Is_Directory (Full_Name) then\n+                  elsif Is_Directory_Attr\n+                          (C_Full_Name'Address, Attr'Access) = 1\n+                  then\n                      if Search.Value.Filter (Directory) then\n                         Kind := Directory;\n                         Found := True;\n@@ -821,7 +833,7 @@ package body Ada.Directories is\n    begin\n       C_Name (1 .. Name'Length) := Name;\n       C_Name (C_Name'Last) := ASCII.NUL;\n-      return C_File_Exists (C_Name (1)'Address) = 1;\n+      return C_File_Exists (C_Name'Address) = 1;\n    end File_Exists;\n \n    --------------"}, {"sha": "8d574da2cc80f7c84ed715ccc39e4f1c501ae0a2", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -350,7 +350,9 @@ int __gnat_vmsp = 0;\n \n #endif\n \n-/* Used for Ada bindings */\n+/* Used for runtime check that Ada constant File_Attributes_Size is no\n+   less than the actual size of struct file_attributes (see Osint\n+   initialization). */\n int __gnat_size_of_file_attributes = sizeof (struct file_attributes);\n \n void __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr);\n@@ -411,6 +413,7 @@ void\n __gnat_reset_attributes (struct file_attributes* attr)\n {\n   attr->exists     = ATTR_UNSET;\n+  attr->error      = EINVAL;\n \n   attr->writable   = ATTR_UNSET;\n   attr->readable   = ATTR_UNSET;\n@@ -424,6 +427,11 @@ __gnat_reset_attributes (struct file_attributes* attr)\n   attr->file_length = -1;\n }\n \n+int\n+__gnat_error_attributes (struct file_attributes *attr) {\n+  return attr->error;\n+}\n+\n OS_Time\n __gnat_current_time (void)\n {\n@@ -1170,12 +1178,28 @@ void\n __gnat_stat_to_attr (int fd, char* name, struct file_attributes* attr)\n {\n   GNAT_STRUCT_STAT statbuf;\n-  int ret;\n+  int ret, error;\n \n-  if (fd != -1)\n+  if (fd != -1) {\n+    /* GNAT_FSTAT returns -1 and sets errno for failure */\n     ret = GNAT_FSTAT (fd, &statbuf);\n+    error = ret ? errno : 0;\n+\n+  } else {\n+    /* __gnat_stat returns errno value directly */\n+    error = __gnat_stat (name, &statbuf);\n+    ret = error ? -1 : 0;\n+  }\n+\n+  /*\n+   * A missing file is reported as an attr structure with error == 0 and\n+   * exists == 0.\n+   */\n+\n+  if (error == 0 || error == ENOENT)\n+    attr->error = 0;\n   else\n-    ret = __gnat_stat (name, &statbuf);\n+    attr->error = error;\n \n   attr->regular   = (!ret && S_ISREG (statbuf.st_mode));\n   attr->directory = (!ret && S_ISDIR (statbuf.st_mode));\n@@ -1793,6 +1817,9 @@ __gnat_get_libraries_from_registry (void)\n   return result;\n }\n \n+/* Query information for the given file NAME and return it in STATBUF.\n+ * Returns 0 for success, or errno value for failure.\n+ */\n int\n __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n {\n@@ -1807,7 +1834,7 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n   name_len = _tcslen (wname);\n \n   if (name_len > GNAT_MAX_PATH_LEN)\n-    return -1;\n+    return EINVAL;\n \n   ZeroMemory (statbuf, sizeof(GNAT_STRUCT_STAT));\n \n@@ -1860,7 +1887,7 @@ __gnat_stat (char *name, GNAT_STRUCT_STAT *statbuf)\n   return 0;\n \n #else\n-  return GNAT_STAT (name, statbuf);\n+  return GNAT_STAT (name, statbuf) == 0 ? 0 : errno;\n #endif\n }\n "}, {"sha": "28d4c8c2e2f22164b34b6ec95f28924a13ce2cb9", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -78,6 +78,11 @@ typedef long OS_Time;\n */\n \n struct file_attributes {\n+  int           error;\n+  /* Errno value returned by stat()/fstat(). If non-zero, other fields should\n+   * be considered as invalid.\n+   */\n+\n   unsigned char exists;\n \n   unsigned char writable;\n@@ -163,7 +168,8 @@ extern int    __gnat_is_writable_file\t\t   (char *);\n extern int    __gnat_is_readable_file\t\t   (char *name);\n extern int    __gnat_is_executable_file      (char *name);\n \n-extern void __gnat_reset_attributes (struct file_attributes* attr);\n+extern void   __gnat_reset_attributes (struct file_attributes *);\n+extern int    __gnat_error_attributes (struct file_attributes *);\n extern long   __gnat_file_length_attr        (int, char *, struct file_attributes *);\n extern OS_Time __gnat_file_time_name_attr    (char *, struct file_attributes *);\n extern OS_Time __gnat_file_time_fd_attr      (int,    struct file_attributes *);"}, {"sha": "e3c012a88c369981bf2b3296ccaf9c3c696d89fb", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -350,6 +350,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/s-htable.o\t\\\n  ada/s-imenne.o\t\\\n  ada/s-imgenu.o\t\\\n+ ada/s-imgint.o \\\n  ada/s-mastop.o\t\\\n  ada/s-memory.o\t\\\n  ada/s-os_lib.o\t\\\n@@ -457,27 +458,16 @@ GNAT1_ADA_OBJS = $(GNAT_ADA_OBJS) ada/back_end.o ada/gnat1drv.o\n GNAT1_OBJS = $(GNAT1_C_OBJS) $(GNAT1_ADA_OBJS) ada/b_gnat1.o\n \n GNATBIND_OBJS = \\\n- ada/adaint.o     \\\n- ada/argv.o       \\\n- ada/cio.o        \\\n- ada/cstreams.o   \\\n- ada/env.o        \\\n- ada/exit.o       \\\n- ada/final.o      \\\n- ada/init.o       \\\n- ada/initialize.o \\\n- ada/link.o       \\\n- ada/raise.o      \\\n- ada/seh_init.o   \\\n- ada/targext.o    \\\n- ada/ada.o        \\\n  ada/a-clrefi.o   \\\n  ada/a-comlin.o   \\\n  ada/a-elchha.o   \\\n  ada/a-except.o   \\\n+ ada/ada.o        \\\n+ ada/adaint.o     \\\n  ada/ali-util.o   \\\n  ada/ali.o        \\\n  ada/alloc.o      \\\n+ ada/argv.o       \\\n  ada/aspects.o    \\\n  ada/atree.o      \\\n  ada/bcheck.o     \\\n@@ -487,34 +477,41 @@ GNATBIND_OBJS = \\\n  ada/bindusg.o    \\\n  ada/butil.o      \\\n  ada/casing.o     \\\n+ ada/cio.o        \\\n  ada/csets.o      \\\n+ ada/cstreams.o   \\\n  ada/debug.o      \\\n  ada/einfo.o      \\\n  ada/elists.o     \\\n+ ada/env.o        \\\n  ada/err_vars.o   \\\n  ada/errout.o     \\\n  ada/erroutc.o    \\\n+ ada/exit.o       \\\n+ ada/final.o      \\\n  ada/fmap.o       \\\n- ada/fname.o      \\\n  ada/fname-uf.o   \\\n+ ada/fname.o      \\\n  ada/g-byorma.o   \\\n  ada/g-hesora.o   \\\n  ada/g-htable.o   \\\n- ada/s-os_lib.o   \\\n- ada/s-string.o   \\\n  ada/gnat.o       \\\n  ada/gnatbind.o   \\\n  ada/gnatvsn.o    \\\n  ada/hostparm.o   \\\n+ ada/init.o       \\\n+ ada/initialize.o \\\n  ada/interfac.o   \\\n  ada/krunch.o     \\\n  ada/lib.o        \\\n+ ada/link.o       \\\n  ada/namet.o      \\\n  ada/nlists.o     \\\n  ada/opt.o        \\\n  ada/osint-b.o    \\\n  ada/osint.o      \\\n  ada/output.o     \\\n+ ada/raise.o      \\\n  ada/restrict.o   \\\n  ada/rident.o     \\\n  ada/s-addope.o   \\\n@@ -537,8 +534,10 @@ GNATBIND_OBJS = \\\n  ada/s-htable.o   \\\n  ada/s-imenne.o   \\\n  ada/s-imgenu.o   \\\n+ ada/s-imgint.o   \\\n  ada/s-mastop.o   \\\n  ada/s-memory.o   \\\n+ ada/s-os_lib.o   \\\n  ada/s-parame.o   \\\n  ada/s-restri.o   \\\n  ada/s-secsta.o   \\\n@@ -550,31 +549,34 @@ GNATBIND_OBJS = \\\n  ada/s-stalib.o   \\\n  ada/s-stoele.o   \\\n  ada/s-strhas.o   \\\n+ ada/s-string.o   \\\n  ada/s-strops.o   \\\n  ada/s-traent.o   \\\n  ada/s-unstyp.o   \\\n  ada/s-utf_32.o   \\\n  ada/s-wchcnv.o   \\\n  ada/s-wchcon.o   \\\n  ada/s-wchjis.o   \\\n- ada/scng.o       \\\n  ada/scans.o      \\\n  ada/scil_ll.o    \\\n+ ada/scng.o       \\\n  ada/sdefault.o   \\\n+ ada/seh_init.o   \\\n  ada/sem_aux.o    \\\n  ada/sinfo.o      \\\n- ada/sinput.o     \\\n  ada/sinput-c.o   \\\n+ ada/sinput.o     \\\n  ada/snames.o     \\\n  ada/stand.o      \\\n  ada/stringt.o    \\\n- ada/switch-b.o   \\\n- ada/switch.o     \\\n  ada/style.o      \\\n  ada/styleg.o     \\\n  ada/stylesw.o    \\\n+ ada/switch-b.o   \\\n+ ada/switch.o     \\\n  ada/system.o     \\\n  ada/table.o      \\\n+ ada/targext.o    \\\n  ada/targparm.o   \\\n  ada/tree_io.o    \\\n  ada/types.o      \\"}, {"sha": "f18a5ea97cccdb6ffee61a9d61c7e140cf14c828", "filename": "gcc/ada/osint.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fosint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fosint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -758,13 +758,14 @@ private\n    --  detected, the file being written is deleted, and a fatal error is\n    --  signalled.\n \n-   File_Attributes_Size : constant Natural := 24;\n+   File_Attributes_Size : constant Natural := 32;\n    --  This should be big enough to fit a \"struct file_attributes\" on any\n    --  system. It doesn't cause any malfunction if it is too big (which avoids\n    --  the need for either mapping the struct exactly or importing the sizeof\n    --  from C, which would result in dynamic code). However, it does waste\n    --  space (e.g. when a component of this type appears in a record, if it is\n-   --  unnecessarily large).\n+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.\n+   --  SIZEOF_struct_file_attributes instead, which has the exact value.\n \n    type File_Attributes is\n      array (1 .. File_Attributes_Size)"}, {"sha": "8e8aa2d7fc816de6c1d807832fb3a6ca24356e12", "filename": "gcc/ada/s-crtl.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-crtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-crtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -70,6 +70,11 @@ package System.CRTL is\n    function atoi (A : System.Address) return Integer;\n    pragma Import (C, atoi, \"atoi\");\n \n+   function strlen (A : System.Address) return size_t;\n+   pragma Import (Intrinsic, strlen, \"strlen\");\n+   --  Import with convention Intrinsic so that we take advantage of the GCC\n+   --  builtin where available (and fall back to the library function if not).\n+\n    procedure clearerr (stream : FILEs);\n    pragma Import (C, clearerr, \"clearerr\");\n "}, {"sha": "c80626371c9ef9265d45c89ca74ad5458d2bdfa6", "filename": "gcc/ada/s-filatt.ads", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-filatt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-filatt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-filatt.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -0,0 +1,67 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . F I L E _ A T T R I B U T E S               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2013, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a binding to the GNAT file attribute query functions\n+\n+with System.OS_Constants;\n+with System.Storage_Elements;\n+\n+package System.File_Attributes is\n+\n+   type File_Attributes is private;\n+\n+   procedure Reset_Attributes (A : access File_Attributes);\n+   function Error_Attributes (A : access File_Attributes) return Integer;\n+   function File_Exists_Attr\n+     (N : System.Address;\n+      A : access File_Attributes) return Integer;\n+   function Is_Regular_File_Attr\n+     (N : System.Address;\n+      A : access File_Attributes) return Integer;\n+   function Is_Directory_Attr\n+     (N : System.Address;\n+      A : access File_Attributes) return Integer;\n+\n+private\n+\n+   package SOSC renames System.OS_Constants;\n+\n+   type File_Attributes is new System.Storage_Elements.Storage_Array\n+     (1 .. SOSC.SIZEOF_struct_file_attributes);\n+   for File_Attributes'Alignment use Standard'Maximum_Alignment;\n+\n+   pragma Import (C, Reset_Attributes,     \"__gnat_reset_attributes\");\n+   pragma Import (C, Error_Attributes,     \"__gnat_error_attributes\");\n+   pragma Import (C, File_Exists_Attr,     \"__gnat_file_exists_attr\");\n+   pragma Import (C, Is_Regular_File_Attr, \"__gnat_is_regular_file_attr\");\n+   pragma Import (C, Is_Directory_Attr,    \"__gnat_is_directory_attr\");\n+\n+end System.File_Attributes;"}, {"sha": "7b6a28b4408cd44e8d9357c35be0420bf592b3df", "filename": "gcc/ada/s-os_lib.adb", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -88,8 +88,8 @@ package body System.OS_Lib is\n    --  parameters are as in Create_Temp_File.\n \n    function C_String_Length (S : Address) return Integer;\n-   --  Returns the length of a C string. Does check for null address\n-   --  (returns 0).\n+   --  Returns the length of C (null-terminated) string at S, or 0 for\n+   --  Null_Address.\n \n    procedure Spawn_Internal\n      (Program_Name : String;\n@@ -252,13 +252,11 @@ package body System.OS_Lib is\n    ---------------------\n \n    function C_String_Length (S : Address) return Integer is\n-      function Strlen (S : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n    begin\n       if S = Null_Address then\n          return 0;\n       else\n-         return Strlen (S);\n+         return Integer (CRTL.strlen (S));\n       end if;\n    end C_String_Length;\n \n@@ -912,6 +910,38 @@ package body System.OS_Lib is\n       Delete_File (C_Name'Address, Success);\n    end Delete_File;\n \n+   -------------------\n+   -- Errno_Message --\n+   -------------------\n+\n+   function Errno_Message\n+     (Err     : Integer := Errno;\n+      Default : String  := \"\") return String\n+   is\n+      function strerror (errnum : Integer) return System.Address;\n+      pragma Import (C, strerror, \"strerror\");\n+\n+      C_Msg : constant System.Address := strerror (Err);\n+\n+   begin\n+      if C_Msg = Null_Address then\n+         if Default /= \"\" then\n+            return Default;\n+         else\n+            return \"errno =\" & Err'Img;\n+         end if;\n+\n+      else\n+         declare\n+            Msg : String (1 .. Integer (CRTL.strlen (C_Msg)));\n+            for Msg'Address use C_Msg;\n+            pragma Import (Ada, Msg);\n+         begin\n+            return Msg;\n+         end;\n+      end if;\n+   end Errno_Message;\n+\n    ---------------------\n    -- File_Time_Stamp --\n    ---------------------\n@@ -1028,14 +1058,11 @@ package body System.OS_Lib is\n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n \n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n       Suffix_Length : Integer;\n       Result        : String_Access;\n \n    begin\n-      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n+      Suffix_Length := Integer (CRTL.strlen (Target_Exec_Ext_Ptr));\n       Result := new String (1 .. Suffix_Length);\n \n       if Suffix_Length > 0 then\n@@ -1057,14 +1084,11 @@ package body System.OS_Lib is\n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n \n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n       Suffix_Length : Integer;\n       Result        : String_Access;\n \n    begin\n-      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n+      Suffix_Length := Integer (CRTL.strlen (Target_Exec_Ext_Ptr));\n       Result := new String (1 .. Suffix_Length);\n \n       if Suffix_Length > 0 then\n@@ -1086,14 +1110,11 @@ package body System.OS_Lib is\n       procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n       pragma Import (C, Strncpy, \"strncpy\");\n \n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n       Suffix_Length : Integer;\n       Result        : String_Access;\n \n    begin\n-      Suffix_Length := Strlen (Target_Object_Ext_Ptr);\n+      Suffix_Length := Integer (CRTL.strlen (Target_Object_Ext_Ptr));\n       Result := new String (1 .. Suffix_Length);\n \n       if Suffix_Length > 0 then\n@@ -1792,9 +1813,6 @@ package body System.OS_Lib is\n       Canonical_File_Addr : System.Address;\n       Canonical_File_Len  : Integer;\n \n-      function Strlen (S : System.Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n       function Final_Value (S : String) return String;\n       --  Make final adjustment to the returned string. This function strips\n       --  trailing directory separators, and folds returned string to lower\n@@ -1926,7 +1944,7 @@ package body System.OS_Lib is\n          The_Name (The_Name'Last) := ASCII.NUL;\n \n          Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);\n-         Canonical_File_Len  := Strlen (Canonical_File_Addr);\n+         Canonical_File_Len  := Integer (CRTL.strlen (Canonical_File_Addr));\n \n          --  If VMS syntax conversion has failed, return an empty string\n          --  to indicate the failure.\n@@ -1937,17 +1955,12 @@ package body System.OS_Lib is\n \n          declare\n             subtype Path_String is String (1 .. Canonical_File_Len);\n-            type    Path_String_Access is access Path_String;\n-\n-            function Address_To_Access is new\n-               Ada.Unchecked_Conversion (Source => Address,\n-                                     Target => Path_String_Access);\n-\n-            Path_Access : constant Path_String_Access :=\n-                            Address_To_Access (Canonical_File_Addr);\n+            Canonical_File : Path_String;\n+            for Canonical_File'Address use Canonical_File_Addr;\n+            pragma Import (Ada, Canonical_File);\n \n          begin\n-            Path_Buffer (1 .. Canonical_File_Len) := Path_Access.all;\n+            Path_Buffer (1 .. Canonical_File_Len) := Canonical_File;\n             End_Path := Canonical_File_Len;\n             Last := 1;\n          end;"}, {"sha": "92bf50c8d2f9b0f0a66b2366d297f9137e08b137", "filename": "gcc/ada/s-os_lib.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-os_lib.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -962,6 +962,13 @@ package System.OS_Lib is\n    pragma Import (C, Set_Errno, \"__set_errno\");\n    --  Set the task-safe error number\n \n+   function Errno_Message\n+     (Err     : Integer := Errno;\n+      Default : String  := \"\") return String;\n+   --  Return a message describing the given Errno value. If none is provided\n+   --  by the system, return Default if not empty, else return a generic\n+   --  message indicating the numeric errno value.\n+\n    Directory_Separator : constant Character;\n    --  The character that is used to separate parts of a pathname\n "}, {"sha": "deb1855d3665b436eed747ea61e0db7752e3f41a", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -89,6 +89,7 @@ pragma Style_Checks (\"M32766\");\n /* Include gsocket.h before any system header so it can redefine FD_SETSIZE */\n \n #include \"gsocket.h\"\n+#include \"adaint.h\"\n \n #include <stdlib.h>\n #include <string.h>\n@@ -310,6 +311,16 @@ CND(SIZEOF_unsigned_int, \"Size of unsigned int\")\n #endif\n CND(IOV_MAX, \"Maximum writev iovcnt\")\n \n+#ifndef NAME_MAX\n+# define NAME_MAX 255\n+#endif\n+CND(NAME_MAX, \"Maximum file name length\")\n+\n+#ifndef PATH_MAX\n+# define PATH_MAX 1024\n+#endif\n+CND(FILENAME_MAX, \"Maximum file path length\")\n+\n /*\n \n    ---------------------\n@@ -1319,20 +1330,44 @@ CND(SIZEOF_sockaddr_in, \"struct sockaddr_in\")\n CND(SIZEOF_sockaddr_in6, \"struct sockaddr_in6\")\n \n #define SIZEOF_fd_set (sizeof (fd_set))\n-CND(SIZEOF_fd_set, \"fd_set\");\n-CND(FD_SETSIZE, \"Max fd value\");\n+CND(SIZEOF_fd_set, \"fd_set\")\n+CND(FD_SETSIZE, \"Max fd value\")\n \n #define SIZEOF_struct_hostent (sizeof (struct hostent))\n-CND(SIZEOF_struct_hostent, \"struct hostent\");\n+CND(SIZEOF_struct_hostent, \"struct hostent\")\n \n #define SIZEOF_struct_servent (sizeof (struct servent))\n-CND(SIZEOF_struct_servent, \"struct servent\");\n+CND(SIZEOF_struct_servent, \"struct servent\")\n \n #if defined (__linux__)\n #define SIZEOF_sigset (sizeof (sigset_t))\n-CND(SIZEOF_sigset, \"sigset\");\n+CND(SIZEOF_sigset, \"sigset\")\n #endif\n \n+/**\n+ ** Note: this constant can be used in the GNAT runtime library. In compiler\n+ ** units on the other hand, System.OS_Constants is not available, so we\n+ ** declare an Ada constant (Osint.File_Attributes_Size) independently, which\n+ ** is at least as large as sizeof (struct file_attributes), and we have an\n+ ** assertion at initialization of Osint checking that the size is indeed at\n+ ** least sufficient.\n+ **/\n+#define SIZEOF_struct_file_attributes (sizeof (struct file_attributes))\n+CND(SIZEOF_struct_file_attributes, \"struct file_attributes\")\n+\n+/**\n+ ** Maximal size of buffer for struct dirent. Note: Since POSIX.1 does not\n+ ** specify the size of the d_name field, and other nonstandard fields may\n+ ** precede that field within the dirent structure, we must make a conservative\n+ ** computation.\n+ **/\n+{\n+  struct dirent dent;\n+#define SIZEOF_struct_dirent_alloc \\\n+  ((char*) &dent.d_name - (char*) &dent) + NAME_MAX + 1\n+CND(SIZEOF_struct_dirent_alloc, \"struct dirent allocation\")\n+}\n+\n /*\n \n    --  Fields of struct msghdr"}, {"sha": "732ce9dbfe5951e8861df58fedb2a12358f6f41c", "filename": "gcc/ada/s-rident.ads", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-rident.ads?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -476,13 +476,15 @@ package System.Rident is\n \n                            --  plus these additional restrictions:\n \n-                           No_Calendar                     => True,\n-                           No_Implicit_Heap_Allocations    => True,\n-                           No_Relative_Delay               => True,\n-                           No_Select_Statements            => True,\n-                           No_Task_Termination             => True,\n-                           Simple_Barriers                 => True,\n-                           others                          => False),\n+                           No_Calendar                      => True,\n+                           No_Implicit_Heap_Allocations     => True,\n+                           No_Local_Timing_Events           => True,\n+                           No_Relative_Delay                => True,\n+                           No_Select_Statements             => True,\n+                           No_Specific_Termination_Handlers => True,\n+                           No_Task_Termination              => True,\n+                           Simple_Barriers                  => True,\n+                           others                           => False),\n \n                         --  Value settings for Ravenscar (same as Restricted)\n "}, {"sha": "0defeb3efa7f3fd3584ca512a399aea82c4ea6e4", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -3874,21 +3874,13 @@ package body Sem_Ch13 is\n \n                   begin\n                      if Present (Init_Call) then\n+                        Append_Freeze_Action (U_Ent, Init_Call);\n \n-                        --  If the init call is an expression with actions with\n-                        --  null expression, just extract the actions.\n+                        --  Reset Initialization_Statements pointer so that\n+                        --  if there is a pragma Import further down, it can\n+                        --  clear any default initialization.\n \n-                        if Nkind (Init_Call) = N_Expression_With_Actions\n-                          and then\n-                            Nkind (Expression (Init_Call)) = N_Null_Statement\n-                        then\n-                           Append_Freeze_Actions (U_Ent, Actions (Init_Call));\n-\n-                        --  General case: move Init_Call to freeze actions\n-\n-                        else\n-                           Append_Freeze_Action (U_Ent, Init_Call);\n-                        end if;\n+                        Set_Initialization_Statements (U_Ent, Init_Call);\n                      end if;\n                   end;\n "}, {"sha": "2126f7064091cded57c7a37def4fb7a72989d366", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -1688,7 +1688,7 @@ package body Sem_Ch5 is\n       if Present (Subt) then\n          Analyze (Subt);\n \n-         --  Save type of subtype indication for subsequent check.\n+         --  Save type of subtype indication for subsequent check\n \n          if Nkind (Subt) = N_Subtype_Indication then\n             Bas := Entity (Subtype_Mark (Subt));\n@@ -1855,9 +1855,7 @@ package body Sem_Ch5 is\n \n       else\n          Set_Ekind (Def_Id, E_Loop_Parameter);\n-         if Ada_Version < Ada_2012 then\n-            Error_Msg_N (\"container iterators are an Ada 2012 feature\", N);\n-         end if;\n+         Error_Msg_Ada_2012_Feature (\"container iterator\", Sloc (N));\n \n          --  OF present\n "}, {"sha": "cc6795b1b5331a76b652fa36919ffca5e6f45c03", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -369,6 +369,18 @@ package body Sem_Ch6 is\n       elsif Present (Prev) and then Comes_From_Source (Prev) then\n          Set_Has_Completion (Prev, False);\n \n+         --  An expression function that is a completion freezes the\n+         --  expression. This means freezing the return type, and if it is\n+         --  an access type, freezing its designated type as well.\n+         --  Note that we cannot defer this freezing to the analysis of the\n+         --  expression itself, because a freeze node might appear in a\n+         --  nested scope, leading to an elaboration order issue in gigi.\n+\n+         Freeze_Before (N, Etype (Prev));\n+         if Is_Access_Type (Etype (Prev)) then\n+            Freeze_Before (N, Designated_Type (Etype (Prev)));\n+         end if;\n+\n          --  For navigation purposes, indicate that the function is a body\n \n          Generate_Reference (Prev, Defining_Entity (N), 'b', Force => True);"}, {"sha": "384ad0f8dd284f454fb3733918d7018847a42641", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6d2191a0da9f40899da20933f008242f90262e0/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c6d2191a0da9f40899da20933f008242f90262e0", "patch": "@@ -2058,17 +2058,17 @@ package body Sem_Prag is\n                         Ref      => Item);\n                   end if;\n \n-               --  Variable related checks\n-\n-               elsif Is_SPARK_Volatile_Object (Item_Id) then\n+               --  Variable related checks. These are only relevant when\n+               --  SPARK_Mode is on as they are not standard Ada legality\n+               --  rules.\n \n+               elsif SPARK_Mode = On\n+                 and then Is_SPARK_Volatile_Object (Item_Id)\n+               then\n                   --  A volatile object cannot appear as a global item of a\n-                  --  function. This check is only relevant when SPARK_Mode is\n-                  --  on as it is not a standard Ada legality rule.\n+                  --  function.\n \n-                  if SPARK_Mode = On\n-                    and then Ekind_In (Spec_Id, E_Function, E_Generic_Function)\n-                  then\n+                  if Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n                      Error_Msg_NE\n                        (\"volatile object & cannot act as global item of a \"\n                         & \"function (SPARK RM 7.1.3(9))\", Item, Item_Id);"}]}