{"sha": "fc4076752067fb400b43adbd629081df658da246", "node_id": "C_kwDOANBUbNoAKGZjNDA3Njc1MjA2N2ZiNDAwYjQzYWRiZDYyOTA4MWRmNjU4ZGEyNDY", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-01T17:32:11Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-03T14:01:21Z"}, "message": "Provide some context to folding via ranger.\n\nProvide an internal mechanism to supply context to range_of_expr for calls\nto ::fold_stmt.\n\n\t* gimple-range.cc (gimple_ranger::gimple_ranger): Initialize current_bb.\n\t(gimple_ranger::range_of_expr): Pick up range_on_entry when there is\n\tno explcit context and current_bb is set.\n\t(gimple_ranger::fold_stmt): New.\n\t* gimple-range.h (current_bb, fold_stmt): New.\n\t* tree-vrp.c (rvrp_folder::fold_stmt): Call ranger's fold_stmt.", "tree": {"sha": "4df0890738e8abd42d6e29e743b072c880135572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4df0890738e8abd42d6e29e743b072c880135572"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc4076752067fb400b43adbd629081df658da246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4076752067fb400b43adbd629081df658da246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc4076752067fb400b43adbd629081df658da246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4076752067fb400b43adbd629081df658da246/comments", "author": null, "committer": null, "parents": [{"sha": "1967fd8f2197f2b0334ab0fbc26abc3d9efe56c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1967fd8f2197f2b0334ab0fbc26abc3d9efe56c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1967fd8f2197f2b0334ab0fbc26abc3d9efe56c9"}], "stats": {"total": 32, "additions": 30, "deletions": 2}, "files": [{"sha": "e1177b1c5e8f448bbeae2c5167719bcb995efcc0", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4076752067fb400b43adbd629081df658da246/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4076752067fb400b43adbd629081df658da246/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=fc4076752067fb400b43adbd629081df658da246", "patch": "@@ -34,11 +34,13 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"gimple-range.h\"\n+#include \"gimple-fold.h\"\n \n gimple_ranger::gimple_ranger () :\n \tnon_executable_edge_flag (cfun),\n \tm_cache (non_executable_edge_flag),\n-\ttracer (\"\")\n+\ttracer (\"\"),\n+\tcurrent_bb (NULL)\n {\n   // If the cache has a relation oracle, use it.\n   m_oracle = m_cache.oracle ();\n@@ -82,8 +84,19 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n   // If there is no statement, just get the global value.\n   if (!stmt)\n     {\n+      int_range_max tmp;\n       if (!m_cache.get_global_range (r, expr))\n         r = gimple_range_global (expr);\n+      // Pick up implied context information from the on-entry cache\n+      // if current_bb is set.\n+      if (current_bb && m_cache.block_range (tmp, current_bb, expr))\n+\t{\n+\t  r.intersect (tmp);\n+\t  char str[80];\n+\t  sprintf (str, \"picked up range from bb %d\\n\",current_bb->index);\n+\t  if (idx)\n+\t    tracer.print (idx, str);\n+\t}\n     }\n   // For a debug stmt, pick the best value currently available, do not\n   // trigger new value calculations.  PR 100781.\n@@ -295,6 +308,19 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n   return res;\n }\n \n+// This routine will invoke the gimple fold_stmt routine, providing context to\n+// range_of_expr calls via an private interal API.\n+\n+bool\n+gimple_ranger::fold_stmt (gimple_stmt_iterator *gsi, tree (*valueize) (tree))\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  current_bb = gimple_bb (stmt);\n+  bool ret = ::fold_stmt (gsi, valueize);\n+  current_bb = NULL;\n+  return ret;\n+}\n+\n // This routine will export whatever global ranges are known to GCC\n // SSA_RANGE_NAME_INFO and SSA_NAME_PTR_INFO fields.\n "}, {"sha": "615496ec9b8c4036f62e2f00e1fc52f07679caaa", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4076752067fb400b43adbd629081df658da246/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4076752067fb400b43adbd629081df658da246/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=fc4076752067fb400b43adbd629081df658da246", "patch": "@@ -58,10 +58,12 @@ class gimple_ranger : public range_query\n   void debug ();\n   void dump_bb (FILE *f, basic_block bb);\n   auto_edge_flag non_executable_edge_flag;\n+  bool fold_stmt (gimple_stmt_iterator *gsi, tree (*) (tree));\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n   ranger_cache m_cache;\n   range_tracer tracer;\n+  basic_block current_bb;\n };\n \n /* Create a new ranger instance and associate it with a function."}, {"sha": "5380508a9ec316f399b307c719484d122411a0c2", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4076752067fb400b43adbd629081df658da246/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4076752067fb400b43adbd629081df658da246/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=fc4076752067fb400b43adbd629081df658da246", "patch": "@@ -4323,7 +4323,7 @@ class rvrp_folder : public substitute_and_fold_engine\n   {\n     if (m_simplifier.simplify (gsi))\n       return true;\n-    return ::fold_stmt (gsi, follow_single_use_edges);\n+    return m_ranger->fold_stmt (gsi, follow_single_use_edges);\n   }\n \n private:"}]}