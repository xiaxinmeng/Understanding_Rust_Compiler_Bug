{"sha": "0f51ccfcd8de8513d98890ae4e9d9198db1a35b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY1MWNjZmNkOGRlODUxM2Q5ODg5MGFlNGU5ZDkxOThkYjFhMzViMw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-05T20:09:09Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-05T20:09:09Z"}, "message": "Convert diagnostics to use quoting flag q 6/n\n\n        Convert diagnostics to use quoting flag q 6/n\n        * pt.c (finish_member_template_decl,\n        check_specialization_scope,\n        maybe_process_partial_specialization,\n        determine_specialization,\n        check_explicit_specialization, maybe_check_template_type,\n        process_partial_specialization, check_default_tmpl_args,\n        push_template_decl_real, redeclare_class_template,\n        convert_nontype_argument, coerce_template_parms,\n        lookup_template_class, push_tinst_level,\n        instantiate_class_template, tsubst_arg_types,\n        tsubst_function_type, tsubst, tsubst_qualified_id,\n        tsubst_copy_and_build, check_instantiated_args,\n        do_decl_instantiation, do_type_instantiation,\n        invalid_nontype_parm_type_p, check_specialization_namespace,\n        convert_template_argument, determine_specialization,\n        check_template_shadow, tsubst_decl\n        instantiate_pending_templates): Use quoting marks.\n\nFrom-SVN: r88573", "tree": {"sha": "56c8c5935467ded43bd621b39426ccfadaf07266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56c8c5935467ded43bd621b39426ccfadaf07266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3/comments", "author": null, "committer": null, "parents": [{"sha": "7fdc3e09525674e714c5e304b3d7977d55c4028c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fdc3e09525674e714c5e304b3d7977d55c4028c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fdc3e09525674e714c5e304b3d7977d55c4028c"}], "stats": {"total": 288, "additions": 154, "deletions": 134}, "files": [{"sha": "3e2349e8ef1589c3a9a8ec75dc4839a048ab1ecc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0f51ccfcd8de8513d98890ae4e9d9198db1a35b3", "patch": "@@ -1,3 +1,22 @@\n+2004-10-05  Gabriel Dos Reis  <gdr@cs.tamu.edu>\n+\n+\tConvert diagnostics to use quoting flag q 6/n\n+\t* pt.c (finish_member_template_decl, check_specialization_scope, \n+\tmaybe_process_partial_specialization, determine_specialization, \n+\tcheck_explicit_specialization, maybe_check_template_type, \n+\tprocess_partial_specialization, check_default_tmpl_args, \n+\tpush_template_decl_real, redeclare_class_template, \n+\tconvert_nontype_argument, coerce_template_parms, \n+\tlookup_template_class, push_tinst_level, \n+\tinstantiate_class_template, tsubst_arg_types, \n+\ttsubst_function_type, tsubst, tsubst_qualified_id, \n+\ttsubst_copy_and_build, check_instantiated_args, \n+\tdo_decl_instantiation, do_type_instantiation, \n+\tinvalid_nontype_parm_type_p, check_specialization_namespace, \n+\tconvert_template_argument, determine_specialization, \n+\tcheck_template_shadow, tsubst_decl \n+\tinstantiate_pending_templates): Use quoting marks.\n+\n 2004-10-05  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/17829\n@@ -6,7 +25,7 @@\n \n 2004-10-04  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n-\tConvert diagnostics to use quoting flag q 4/n\n+\tConvert diagnostics to use quoting flag q 5/n\n \t* parser.c (cp_parser_name_lookup_error, \n \tcp_parser_diagnose_invalid_type_name, \n \tcp_parser_primary_expression, cp_parser_unqualified_id, "}, {"sha": "3813c38ed41c451019fdebb1c2e4785315ad11bb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 134, "deletions": 133, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f51ccfcd8de8513d98890ae4e9d9198db1a35b3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0f51ccfcd8de8513d98890ae4e9d9198db1a35b3", "patch": "@@ -237,7 +237,7 @@ finish_member_template_decl (tree decl)\n       return NULL_TREE;\n     }\n   else if (TREE_CODE (decl) == FIELD_DECL)\n-    error (\"data member `%D' cannot be a member template\", decl);\n+    error (\"data member %qD cannot be a member template\", decl);\n   else if (DECL_TEMPLATE_INFO (decl))\n     {\n       if (!DECL_TEMPLATE_SPECIALIZATION (decl))\n@@ -249,7 +249,7 @@ finish_member_template_decl (tree decl)\n \treturn decl;\n     } \n   else\n-    error (\"invalid member template declaration `%D'\", decl);\n+    error (\"invalid member template declaration %qD\", decl);\n \n   return error_mark_node;\n }\n@@ -632,8 +632,7 @@ check_specialization_scope (void)\n      shall be declared in the namespace of which the class template\n      is a member.  */\n   if (scope && TREE_CODE (scope) != NAMESPACE_DECL)\n-    error (\"explicit specialization in non-namespace scope `%D'\",\n-\t      scope);\n+    error (\"explicit specialization in non-namespace scope %qD\", scope);\n \n   /* [temp.expl.spec] \n \n@@ -728,8 +727,8 @@ check_specialization_namespace (tree tmpl)\n     return true;\n   else\n     {\n-      pedwarn (\"specialization of `%D' in different namespace\", tmpl);\n-      cp_pedwarn_at (\"  from definition of `%#D'\", tmpl);\n+      pedwarn (\"specialization of %qD in different namespace\", tmpl);\n+      cp_pedwarn_at (\"  from definition of %q#D\", tmpl);\n       return false;\n     }\n }\n@@ -765,7 +764,7 @@ maybe_process_partial_specialization (tree type)\n \t    push_template_decl (TYPE_MAIN_DECL (type));\n \t}\n       else if (CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n-\terror (\"specialization of `%T' after instantiation\", type);\n+\terror (\"specialization of %qT after instantiation\", type);\n     }\n   else if (CLASS_TYPE_P (type)\n \t   && !CLASSTYPE_USE_TEMPLATE (type)\n@@ -797,8 +796,8 @@ maybe_process_partial_specialization (tree type)\n \t  if (current_namespace\n \t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n \t    {\n-\t      pedwarn (\"specializing `%#T' in different namespace\", type);\n-\t      cp_pedwarn_at (\"  from definition of `%#D'\",\n+\t      pedwarn (\"specializing %q#T in different namespace\", type);\n+\t      cp_pedwarn_at (\"  from definition of %q#D\",\n \t\t\t     CLASSTYPE_TI_TEMPLATE (type));\n \t    }\n \n@@ -812,7 +811,7 @@ maybe_process_partial_specialization (tree type)\n \t       t; t = TREE_CHAIN (t))\n \t    if (TREE_VALUE (t) != type\n \t\t&& TYPE_CONTEXT (TREE_VALUE (t)) == context)\n-\t      error (\"specialization `%T' after instantiation `%T'\",\n+\t      error (\"specialization %qT after instantiation %qT\",\n \t\t     type, TREE_VALUE (t));\n \n \t  /* Mark TYPE as a specialization.  And as a result, we only\n@@ -824,7 +823,7 @@ maybe_process_partial_specialization (tree type)\n \t}\n     }\n   else if (processing_specialization)\n-    error (\"explicit specialization of non-template `%T'\", type);\n+    error (\"explicit specialization of non-template %qT\", type);\n }\n \n /* Retrieve the specialization (in the sense of [temp.spec] - a\n@@ -1081,8 +1080,7 @@ register_specialization (tree spec, tree tmpl, tree args)\n \t      if (TREE_USED (fn) \n \t\t  || DECL_EXPLICIT_INSTANTIATION (fn))\n \t\t{\n-\t\t  error (\"specialization of %D after instantiation\",\n-\t\t\t fn);\n+\t\t  error (\"specialization of %qD after instantiation\", fn);\n \t\t  return spec;\n \t\t}\n \t      else\n@@ -1267,7 +1265,7 @@ determine_specialization (tree template_id,\n \n   if (!is_overloaded_fn (fns))\n     {\n-      error (\"`%D' is not a function template\", fns);\n+      error (\"%qD is not a function template\", fns);\n       return error_mark_node;\n     }\n \n@@ -1452,15 +1450,16 @@ determine_specialization (tree template_id,\n \n   if (templates == NULL_TREE && candidates == NULL_TREE)\n     {\n-      cp_error_at (\"template-id `%D' for `%+D' does not match any template declaration\",\n+      cp_error_at (\"template-id %qD for %q+D does not match any template \"\n+                   \"declaration\",\n \t\t   template_id, decl);\n       return error_mark_node;\n     }\n   else if ((templates && TREE_CHAIN (templates))\n \t   || (candidates && TREE_CHAIN (candidates))\n \t   || (templates && candidates))\n     {\n-      cp_error_at (\"ambiguous template specialization `%D' for `%+D'\",\n+      cp_error_at (\"ambiguous template specialization %qD for %q+D\",\n \t\t   template_id, decl);\n       chainon (candidates, templates);\n       print_candidates (candidates);\n@@ -1683,8 +1682,8 @@ check_explicit_specialization (tree declarator,\n \t      /* This case handles bogus declarations like template <>\n \t\t template <class T> void f<int>(); */\n \n-\t      error (\"template-id `%D' in declaration of primary template\",\n-\t\t\tdeclarator);\n+\t      error (\"template-id %qD in declaration of primary template\",\n+                     declarator);\n \t      return decl;\n \t    }\n \t}\n@@ -1710,13 +1709,12 @@ check_explicit_specialization (tree declarator,\n     case tsk_excessive_parms:\n     case tsk_insufficient_parms:\n       if (tsk == tsk_excessive_parms)\n-        error (\"too many template parameter lists in declaration of `%D'\",\n+        error (\"too many template parameter lists in declaration of %qD\",\n \t       decl);\n       else if (template_header_count)\n-\terror(\"too few template parameter lists in declaration of `%D'\",\n-\t      decl);\n+\terror(\"too few template parameter lists in declaration of %qD\", decl);\n       else\n-\terror(\"explicit specialization of `%D' must be introduced by \"\n+\terror(\"explicit specialization of %qD must be introduced by \"\n \t      \"`template <>'\", decl);\n \n       /* Fall through.  */\n@@ -1735,11 +1733,11 @@ check_explicit_specialization (tree declarator,\n \t     template <class T> void f<int>(); */\n \n \t  if (uses_template_parms (declarator))\n-\t    error (\"function template partial specialization `%D' \"\n+\t    error (\"function template partial specialization %qD \"\n \t\t   \"is not allowed\", declarator);\n \t  else\n-\t    error (\"template-id `%D' in declaration of primary template\",\n-\t\t      declarator);\n+\t    error (\"template-id %qD in declaration of primary template\",\n+                   declarator);\n \t  return decl;\n \t}\n \n@@ -1899,8 +1897,7 @@ check_explicit_specialization (tree declarator,\n \t      \n \t  if (fns == NULL_TREE) \n \t    {\n-\t      error (\"no member function `%D' declared in `%T'\",\n-\t\t\tname, ctype);\n+\t      error (\"no member function %qD declared in %qT\", name, ctype);\n \t      return error_mark_node;\n \t    }\n \t  else\n@@ -2050,7 +2047,7 @@ maybe_check_template_type (tree type)\n \t; \n       else if (template_header_count > context_depth + 1)\n \t/* There are two many template parameter lists.  */\n-\terror (\"too many template parameter lists in declaration of `%T'\", type); \n+\terror (\"too many template parameter lists in declaration of %qT\", type); \n     }\n }\n \n@@ -2143,8 +2140,8 @@ check_template_shadow (tree decl)\n       || TEMPLATE_PARMS_FOR_INLINE (current_template_parms))\n     return;\n \n-  cp_error_at (\"declaration of `%#D'\", decl);\n-  cp_error_at (\" shadows template parm `%#D'\", olddecl);\n+  cp_error_at (\"declaration of %q#D\", decl);\n+  cp_error_at (\" shadows template parm %q#D\", olddecl);\n }\n \n /* Return a new TEMPLATE_PARM_INDEX with the indicated INDEX, LEVEL,\n@@ -2548,8 +2545,7 @@ process_partial_specialization (tree decl)\n \t    did_error_intro = 1;\n \t  }\n \n-\terror (\"        `%D'\", \n-\t\t  TREE_VALUE (TREE_VEC_ELT (inner_parms, i)));\n+\terror (\"        %qD\", TREE_VALUE (TREE_VEC_ELT (inner_parms, i)));\n       }\n \n   /* [temp.class.spec]\n@@ -2560,7 +2556,7 @@ process_partial_specialization (tree decl)\n       (inner_args, \n        INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE\n \t\t\t\t\t\t   (maintmpl)))))\n-    error (\"partial specialization `%T' does not specialize any template arguments\", type);\n+    error (\"partial specialization %qT does not specialize any template arguments\", type);\n \n   /* [temp.class.spec]\n \n@@ -2585,7 +2581,7 @@ process_partial_specialization (tree decl)\n \t  && TREE_CODE (arg) != TEMPLATE_PARM_INDEX)\n \t{\n \t  if (tpd.arg_uses_template_parms[i])\n-\t    error (\"template argument `%E' involves template parameter(s)\", arg);\n+\t    error (\"template argument %qE involves template parameter(s)\", arg);\n \t  else \n \t    {\n \t      /* Look at the corresponding template parameter,\n@@ -2629,9 +2625,10 @@ process_partial_specialization (tree decl)\n \t\t    if (tpd2.parms[j] != 0\n \t\t\t&& tpd.arg_uses_template_parms [j])\n \t\t      {\n-\t\t\terror (\"type `%T' of template argument `%E' depends on template parameter(s)\", \n-\t\t\t\t  type,\n-\t\t\t\t  arg);\n+\t\t\terror (\"type %qT of template argument %qE depends \"\n+                               \"on template parameter(s)\", \n+                               type,\n+                               arg);\n \t\t\tbreak;\n \t\t      }\n \t\t}\n@@ -2714,7 +2711,7 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n \t    seen_def_arg_p = 1;\n \t  else if (seen_def_arg_p)\n \t    {\n-\t      error (\"no default argument for `%D'\", TREE_VALUE (parm));\n+\t      error (\"no default argument for %qD\", TREE_VALUE (parm));\n \t      /* For better subsequent error-recovery, we indicate that\n \t\t there should have been a default argument.  */\n \t      TREE_PURPOSE (parm) = error_mark_node;\n@@ -2748,7 +2745,7 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n   else if (is_partial)\n     msg = \"default template arguments may not be used in partial specializations\";\n   else\n-    msg = \"default argument for template parameter for class enclosing `%D'\";\n+    msg = \"default argument for template parameter for class enclosing %qD\";\n \n   if (current_class_type && TYPE_BEING_DEFINED (current_class_type))\n     /* If we're inside a class definition, there's no need to\n@@ -2790,7 +2787,7 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary, int is_partial)\n       /* At this point, if we're still interested in issuing messages,\n \t they must apply to classes surrounding the object declared.  */\n       if (msg)\n-\tmsg = \"default argument for template parameter for class enclosing `%D'\"; \n+\tmsg = \"default argument for template parameter for class enclosing %qD\"; \n     }\n }\n \n@@ -2877,7 +2874,7 @@ push_template_decl_real (tree decl, int is_friend)\n \t      /* [temp.mem]\n \t\t \n \t         A destructor shall not be a member template.  */\n-\t      error (\"destructor `%D' declared as member template\", decl);\n+\t      error (\"destructor %qD declared as member template\", decl);\n \t      return error_mark_node;\n \t    }\n \t  if (NEW_DELETE_OPNAME_P (DECL_NAME (decl))\n@@ -2892,7 +2889,7 @@ push_template_decl_real (tree decl, int is_friend)\n \t         An allocation function can be a function\n \t\t template. ... Template allocation functions shall\n \t\t have two or more parameters.  */\n-\t      error (\"invalid template declaration of `%D'\", decl);\n+\t      error (\"invalid template declaration of %qD\", decl);\n \t      return decl;\n \t    }\n \t}\n@@ -2902,7 +2899,7 @@ push_template_decl_real (tree decl, int is_friend)\n \t/* OK */;\n       else\n \t{\n-\t  error (\"template declaration of `%#D'\", decl);\n+\t  error (\"template declaration of %q#D\", decl);\n \t  return error_mark_node;\n \t}\n     }\n@@ -2972,13 +2969,13 @@ push_template_decl_real (tree decl, int is_friend)\n \t    tmpl = TYPE_TI_TEMPLATE (TREE_TYPE (decl));\n \t  else\n \t    {\n-\t      error (\"`%D' does not declare a template type\", decl);\n+\t      error (\"%qD does not declare a template type\", decl);\n \t      return decl;\n \t    }\n \t}\n       else if (!DECL_LANG_SPECIFIC (decl) || !DECL_TEMPLATE_INFO (decl))\n \t{\n-\t  error (\"template definition of non-template `%#D'\", decl);\n+\t  error (\"template definition of non-template %q#D\", decl);\n \t  return decl;\n \t}\n       else\n@@ -3019,8 +3016,8 @@ push_template_decl_real (tree decl, int is_friend)\n       i = TMPL_PARMS_DEPTH (parms);\n       if (TMPL_ARGS_DEPTH (args) != i)\n \t{\n-\t  error (\"expected %d levels of template parms for `%#D', got %d\",\n-\t\t    i, decl, TMPL_ARGS_DEPTH (args));\n+\t  error (\"expected %d levels of template parms for %q#D, got %d\",\n+                 i, decl, TMPL_ARGS_DEPTH (args));\n \t}\n       else\n \tfor (current = decl; i > 0; --i, parms = TREE_CHAIN (parms))\n@@ -3031,11 +3028,11 @@ push_template_decl_real (tree decl, int is_friend)\n \t    if (TREE_VEC_LENGTH (t) != TREE_VEC_LENGTH (a))\n \t      {\n \t\tif (current == decl)\n-\t\t  error (\"got %d template parameters for `%#D'\",\n-\t\t\t    TREE_VEC_LENGTH (a), decl);\n+\t\t  error (\"got %d template parameters for %q#D\",\n+                         TREE_VEC_LENGTH (a), decl);\n \t\telse\n-\t\t  error (\"got %d template parameters for `%#T'\",\n-\t\t\t    TREE_VEC_LENGTH (a), current);\n+\t\t  error (\"got %d template parameters for %q#T\",\n+                         TREE_VEC_LENGTH (a), current);\n \t\terror (\"  but %d required\", TREE_VEC_LENGTH (t));\n \t      }\n \n@@ -3121,7 +3118,7 @@ redeclare_class_template (tree type, tree parms)\n \n   if (!TYPE_TEMPLATE_INFO (type))\n     {\n-      error (\"`%T' is not a template type\", type);\n+      error (\"%qT is not a template type\", type);\n       return;\n     }\n \n@@ -3137,7 +3134,7 @@ redeclare_class_template (tree type, tree parms)\n \n   if (TREE_VEC_LENGTH (parms) != TREE_VEC_LENGTH (tmpl_parms))\n     {\n-      cp_error_at (\"previous declaration `%D'\", tmpl);\n+      cp_error_at (\"previous declaration %qD\", tmpl);\n       error (\"used %d template parameter%s instead of %d\",\n \t\tTREE_VEC_LENGTH (tmpl_parms), \n \t\tTREE_VEC_LENGTH (tmpl_parms) == 1 ? \"\" : \"s\",\n@@ -3158,8 +3155,8 @@ redeclare_class_template (tree type, tree parms)\n \t  || (TREE_CODE (tmpl_parm) != TYPE_DECL\n \t      && !same_type_p (TREE_TYPE (tmpl_parm), TREE_TYPE (parm))))\n \t{\n-\t  cp_error_at (\"template parameter `%#D'\", tmpl_parm);\n-\t  error (\"redeclared here as `%#D'\", parm);\n+\t  cp_error_at (\"template parameter %q#D\", tmpl_parm);\n+\t  error (\"redeclared here as %q#D\", parm);\n \t  return;\n \t}\n \n@@ -3169,7 +3166,7 @@ redeclare_class_template (tree type, tree parms)\n \n \t     A template-parameter may not be given default arguments\n \t     by two different declarations in the same scope.  */\n-\t  error (\"redefinition of default argument for `%#D'\", parm);\n+\t  error (\"redefinition of default argument for %q#D\", parm);\n \t  error (\"%J  original definition appeared here\", tmpl_parm);\n \t  return;\n \t}\n@@ -3316,7 +3313,7 @@ convert_nontype_argument (tree type, tree expr)\n \t  if (TREE_CODE (e) != ADDR_EXPR)\n \t    {\n \t    bad_argument:\n-\t      error (\"`%E' is not a valid template argument\", expr);\n+\t      error (\"%qE is not a valid template argument\", expr);\n \t      if (TYPE_PTR_P (expr_type))\n \t\t{\n \t\t  if (TREE_CODE (TREE_TYPE (expr_type)) == FUNCTION_TYPE)\n@@ -3325,7 +3322,7 @@ convert_nontype_argument (tree type, tree expr)\n \t\t    error (\"it must be the address of an object with external linkage\");\n \t\t}\n \t      else if (TYPE_PTR_TO_MEMBER_P (expr_type))\n-\t\terror (\"it must be a pointer-to-member of the form `&X::Y'\");\n+\t\terror (\"it must be a pointer-to-member of the form %<&X::Y%>\");\n \n \t      return NULL_TREE;\n \t    }\n@@ -3336,8 +3333,9 @@ convert_nontype_argument (tree type, tree expr)\n \n       if (TREE_CODE (referent) == STRING_CST)\n \t{\n-\t  error (\"string literal %E is not a valid template argument because it is the address of an object with static linkage\", \n-\t\t    referent);\n+\t  error (\"string literal %qE is not a valid template argument \"\n+                 \"because it is the address of an object with static linkage\", \n+                 referent);\n \t  return NULL_TREE;\n \t}\n \n@@ -3351,7 +3349,8 @@ convert_nontype_argument (tree type, tree expr)\n \tgoto bad_argument;\n       else if (!DECL_EXTERNAL_LINKAGE_P (referent))\n \t{\n-\t  error (\"address of non-extern `%E' cannot be used as template argument\", referent); \n+\t  error (\"address of non-extern %qE cannot be used as \"\n+                 \"template argument\", referent); \n \t  return error_mark_node;\n \t}\n     }\n@@ -3360,20 +3359,19 @@ convert_nontype_argument (tree type, tree expr)\n       if (! TREE_CONSTANT (expr))\n \t{\n \tnon_constant:\n-\t  error (\"non-constant `%E' cannot be used as template argument\",\n-\t\t    expr);\n+\t  error (\"non-constant %qE cannot be used as template argument\", expr);\n \t  return NULL_TREE;\n \t}\n     }\n   else \n     {\n       if (TYPE_P (expr))\n-        error (\"type '%T' cannot be used as a value for a non-type \"\n+         error (\"type %qT cannot be used as a value for a non-type \"\n                \"template-parameter\", expr);\n       else if (DECL_P (expr))\n-        error (\"invalid use of '%D' as a non-type template-argument\", expr);\n+        error (\"invalid use of %qD as a non-type template-argument\", expr);\n       else\n-        error (\"invalid use of '%E' as a non-type template-argument\", expr);\n+        error (\"invalid use of %qE as a non-type template-argument\", expr);\n \n       return NULL_TREE;\n     }\n@@ -3751,7 +3749,8 @@ convert_template_argument (tree parm,\n   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n-      pedwarn (\"to refer to a type member of a template parameter, use `typename %E'\", arg);\n+      pedwarn (\"to refer to a type member of a template parameter, \"\n+               \"use %<typename %E%>\", arg);\n       \n       arg = make_typename_type (TREE_OPERAND (arg, 0),\n \t\t\t\tTREE_OPERAND (arg, 1),\n@@ -3764,16 +3763,17 @@ convert_template_argument (tree parm,\n \t{\n \t  if (complain & tf_error)\n \t    {\n-\t      error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t\ti + 1, in_decl);\n+\t      error (\"type/value mismatch at argument %d in template \"\n+                     \"parameter list for %qD\",\n+                     i + 1, in_decl);\n \t      if (is_type)\n-\t\terror (\"  expected a constant of type `%T', got `%T'\",\n-\t\t\t  TREE_TYPE (parm),\n-\t\t\t  (is_tmpl_type ? DECL_NAME (arg) : arg));\n+\t\terror (\"  expected a constant of type %qT, got %qT\",\n+                       TREE_TYPE (parm),\n+                       (is_tmpl_type ? DECL_NAME (arg) : arg));\n \t      else if (requires_tmpl_type)\n-\t\terror (\"  expected a class template, got `%E'\", arg);\n+\t\terror (\"  expected a class template, got %qE\", arg);\n \t      else\n-\t\terror (\"  expected a type, got `%E'\", arg);\n+\t\terror (\"  expected a type, got %qE\", arg);\n \t    }\n \t}\n       return error_mark_node;\n@@ -3782,12 +3782,13 @@ convert_template_argument (tree parm,\n     {\n       if (in_decl && (complain & tf_error))\n \t{\n-\t  error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t    i + 1, in_decl);\n+\t  error (\"type/value mismatch at argument %d in template \"\n+                 \"parameter list for %qD\",\n+                 i + 1, in_decl);\n \t  if (is_tmpl_type)\n-\t    error (\"  expected a type, got `%T'\", DECL_NAME (arg));\n+\t    error (\"  expected a type, got %qT\", DECL_NAME (arg));\n \t  else\n-\t    error (\"  expected a class template, got `%T'\", arg);\n+\t    error (\"  expected a class template, got %qT\", arg);\n \t}\n       return error_mark_node;\n     }\n@@ -3821,9 +3822,11 @@ convert_template_argument (tree parm,\n \t\t{\n \t\t  if (in_decl && (complain & tf_error))\n \t\t    {\n-\t\t      error (\"type/value mismatch at argument %d in template parameter list for `%D'\",\n-\t\t\t\ti + 1, in_decl);\n-\t\t      error (\"  expected a template of type `%D', got `%D'\", parm, arg);\n+\t\t      error (\"type/value mismatch at argument %d in \"\n+                             \"template parameter list for %qD\",\n+                             i + 1, in_decl);\n+\t\t      error (\"  expected a template of type %qD, got %qD\",\n+                             parm, arg);\n \t\t    }\n \t\t  \n \t\t  val = error_mark_node;\n@@ -3858,8 +3861,7 @@ convert_template_argument (tree parm,\n       if (val == NULL_TREE)\n \tval = error_mark_node;\n       else if (val == error_mark_node && (complain & tf_error))\n-\terror (\"could not convert template argument `%E' to `%T'\", \n-\t\t  arg, t);\n+\terror (\"could not convert template argument %qE to %qT\",  arg, t);\n     }\n \n   return val;\n@@ -3899,10 +3901,10 @@ coerce_template_parms (tree parms,\n       if (complain & tf_error) \n \t{\n \t  error (\"wrong number of template arguments (%d, should be %d)\",\n-\t\t    nargs, nparms);\n+                 nargs, nparms);\n \t  \n \t  if (in_decl)\n-\t    cp_error_at (\"provided for `%D'\", in_decl);\n+\t    cp_error_at (\"provided for %qD\", in_decl);\n \t}\n \n       return error_mark_node;\n@@ -4274,7 +4276,7 @@ lookup_template_class (tree d1,\n   if (! template)\n     {\n       if (complain & tf_error)\n-        error (\"`%T' is not a template\", d1);\n+        error (\"%qT is not a template\", d1);\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n \n@@ -4286,9 +4288,9 @@ lookup_template_class (tree d1,\n     {\n       if (complain & tf_error)\n         {\n-          error (\"non-template type `%T' used as a template\", d1);\n+          error (\"non-template type %qT used as a template\", d1);\n           if (in_decl)\n-\t    cp_error_at (\"for template declaration `%D'\", in_decl);\n+\t    cp_error_at (\"for template declaration %qD\", in_decl);\n \t}\n       POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n     }\n@@ -4937,7 +4939,8 @@ push_tinst_level (tree d)\n \treturn 0;\n \n       last_template_error_tick = tinst_level_tick;\n-      error (\"template instantiation depth exceeds maximum of %d (use -ftemplate-depth-NN to increase the maximum) instantiating `%D'\",\n+      error (\"template instantiation depth exceeds maximum of %d (use \"\n+             \"-ftemplate-depth-NN to increase the maximum) instantiating %qD\",\n \t     max_tinst_depth, d);\n \n       print_instantiation_context ();\n@@ -5375,7 +5378,7 @@ instantiate_class_template (tree type)\n   if (t == error_mark_node)\n     {\n       const char *str = \"candidates are:\";\n-      error (\"ambiguous class template instantiation for `%#T'\", type);\n+      error (\"ambiguous class template instantiation for %q#T\", type);\n       for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; \n \t   t = TREE_CHAIN (t))\n \t{\n@@ -6402,7 +6405,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t\t\t\t\tcomplain, in_decl);\n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (VOID_TYPE_P (type)) \n-\t  cp_error_at (\"instantiation of `%D' as type `%T'\", r, type);\n+\t  cp_error_at (\"instantiation of %qD as type %qT\", r, type);\n       }\n       break;\n \n@@ -6522,7 +6525,7 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \n \tTREE_CHAIN (r) = NULL_TREE;\n \tif (TREE_CODE (r) == VAR_DECL && VOID_TYPE_P (type))\n-\t  cp_error_at (\"instantiation of `%D' as type `%T'\", r, type);\n+\t  cp_error_at (\"instantiation of %qD as type %qT\", r, type);\n \t/* Compute the size, alignment, etc. of R.  */\n \tlayout_decl (r, 0);\n       }\n@@ -6564,9 +6567,9 @@ tsubst_arg_types (tree arg_types,\n     {\n       if (complain & tf_error)\n         {\n-          error (\"invalid parameter type `%T'\", type);\n+          error (\"invalid parameter type %qT\", type);\n           if (in_decl)\n-            cp_error_at (\"in declaration `%D'\", in_decl);\n+            cp_error_at (\"in declaration %qD\", in_decl);\n         }\n       return error_mark_node;\n     }\n@@ -6640,7 +6643,7 @@ tsubst_function_type (tree t,\n \t     -- Attempting to create \"pointer to member of T\" when T\n \t     is not a class type.  */\n \t  if (complain & tf_error)\n-\t    error (\"creating pointer to member function of non-class type `%T'\",\n+\t    error (\"creating pointer to member function of non-class type %qT\",\n \t\t      r);\n \t  return error_mark_node;\n \t}\n@@ -6791,7 +6794,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t Attempting to create an array with a size that is\n \t\t zero or negative.  */\n \t    if (complain & tf_error)\n-\t      error (\"creating array with size zero (`%E')\", max);\n+\t      error (\"creating array with size zero (%qE)\", max);\n \n \t    return error_mark_node;\n \t  }\n@@ -7010,9 +7013,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\tif (TREE_CODE (type) == VOID_TYPE)\n \t\t  error (\"forming reference to void\");\n \t\telse\n-\t\t  error (\"forming %s to reference type `%T'\",\n-\t\t\t    (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n-\t\t\t    type);\n+\t\t  error (\"forming %s to reference type %qT\",\n+                         (code == POINTER_TYPE) ? \"pointer\" : \"reference\",\n+                         type);\n \t\tlast_loc = input_location;\n \t      }\n \n@@ -7047,13 +7050,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t       -- Attempting to create \"pointer to member of T\" when T\n \t          is not a class type.  */\n \t    if (complain & tf_error)\n-\t      error (\"creating pointer to member of non-class type `%T'\", r);\n+\t      error (\"creating pointer to member of non-class type %qT\", r);\n \t    return error_mark_node;\n \t  }\n \tif (TREE_CODE (type) == REFERENCE_TYPE)\n \t  {\n \t    if (complain & tf_error)\n-\t      error (\"creating pointer to member reference type `%T'\", type);\n+\t      error (\"creating pointer to member reference type %qT\", type);\n \t    \n \t    return error_mark_node;\n \t  }\n@@ -7139,13 +7142,13 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    || TREE_CODE (type) == REFERENCE_TYPE)\n \t  {\n \t    if (complain & tf_error)\n-\t      error (\"creating array of `%T'\", type);\n+\t      error (\"creating array of %qT\", type);\n \t    return error_mark_node;\n \t  }\n \tif (CLASS_TYPE_P (type) && CLASSTYPE_PURE_VIRTUALS (type))\n \t  {\n \t    if (complain & tf_error)\n-\t      error (\"creating array of `%T', which is an abstract class type\", \n+\t      error (\"creating array of %qT, which is an abstract class type\", \n \t\t     type);\n \t    return error_mark_node;\t    \n \t  }\n@@ -7189,8 +7192,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (!IS_AGGR_TYPE (ctx))\n \t  {\n \t    if (complain & tf_error)\n-\t      error (\"`%T' is not a class, struct, or union type\",\n-\t\t\tctx);\n+\t      error (\"%qT is not a class, struct, or union type\", ctx);\n \t    return error_mark_node;\n \t  }\n \telse if (!uses_template_parms (ctx) && !TYPE_BEING_DEFINED (ctx))\n@@ -7401,9 +7403,9 @@ tsubst_qualified_id (tree qualified_id, tree args,\n \t{\n \t  if (complain & tf_error)\n \t    {\n-\t      error (\"dependent-name `%E' is parsed as a non-type, but \"\n+\t      error (\"dependent-name %qE is parsed as a non-type, but \"\n \t\t     \"instantiation yields a type\", qualified_id);\n-\t      inform (\"say `typename %E' if a type is meant\", qualified_id);\n+\t      inform (\"say %<typename %E%> if a type is meant\", qualified_id);\n \t    }\n \t  return error_mark_node;\n \t}\n@@ -8540,10 +8542,10 @@ tsubst_copy_and_build (tree t,\n \t    if (complain & tf_error)\n \t      {\n \t\tif (TYPE_P (TREE_OPERAND (member, 0)))\n-\t\t  error (\"`%T' is not a class or namespace\", \n+\t\t  error (\"%qT is not a class or namespace\", \n \t\t\t TREE_OPERAND (member, 0));\n \t\telse\n-\t\t  error (\"`%D' is not a class or namespace\", \n+\t\t  error (\"%qD is not a class or namespace\", \n \t\t\t TREE_OPERAND (member, 0));\n \t      }\n \t    return error_mark_node;\n@@ -8668,17 +8670,17 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n \t      if (!(complain & tf_error))\n \t\t/*OK*/;\n \t      else if (TYPE_ANONYMOUS_P (nt))\n-\t\terror (\"`%T' uses anonymous type\", t);\n+\t\terror (\"%qT uses anonymous type\", t);\n \t      else\n-\t\terror (\"`%T' uses local type `%T'\", t, nt);\n+\t\terror (\"%qT uses local type %qT\", t, nt);\n \t      result = true;\n \t    }\n \t  /* In order to avoid all sorts of complications, we do not\n \t     allow variably-modified types as template arguments.  */\n \t  else if (variably_modified_type_p (t, NULL_TREE))\n \t    {\n \t      if (complain & tf_error)\n-\t\terror (\"`%T' is a variably modified type\", t);\n+\t\terror (\"%qT is a variably modified type\", t);\n \t      result = true;\n \t    }\n \t}\n@@ -8689,12 +8691,12 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n \t       && !TREE_CONSTANT (t))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"integral expression `%E' is not constant\", t);\n+\t    error (\"integral expression %qE is not constant\", t);\n \t  result = true;\n \t}\n     }\n   if (result && complain & tf_error)\n-    error (\"  trying to instantiate `%D'\", tmpl);\n+    error (\"  trying to instantiate %qD\", tmpl);\n   return result;\n }\n \n@@ -10526,7 +10528,7 @@ do_decl_instantiation (tree decl, tree storage)\n     return;\n   else if (! DECL_LANG_SPECIFIC (decl))\n     {\n-      error (\"explicit instantiation of non-template `%#D'\", decl);\n+      error (\"explicit instantiation of non-template %q#D\", decl);\n       return;\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n@@ -10542,13 +10544,13 @@ do_decl_instantiation (tree decl, tree storage)\n       result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, false);\n       if (!result || TREE_CODE (result) != VAR_DECL)\n \t{\n-\t  error (\"no matching template for `%D' found\", decl);\n+\t  error (\"no matching template for %qD found\", decl);\n \t  return;\n \t}\n     }\n   else if (TREE_CODE (decl) != FUNCTION_DECL)\n     {\n-      error (\"explicit instantiation of `%#D'\", decl);\n+      error (\"explicit instantiation of %q#D\", decl);\n       return;\n     }\n   else\n@@ -10584,20 +10586,20 @@ do_decl_instantiation (tree decl, tree storage)\n \t the first instantiation was `extern' and the second is not,\n \t and EXTERN_P for the opposite case.  */\n       if (DECL_NOT_REALLY_EXTERN (result) && !extern_p)\n-\tpedwarn (\"duplicate explicit instantiation of `%#D'\", result);\n+\tpedwarn (\"duplicate explicit instantiation of %q#D\", result);\n       /* If an \"extern\" explicit instantiation follows an ordinary\n \t explicit instantiation, the template is instantiated.  */\n       if (extern_p)\n \treturn;\n     }\n   else if (!DECL_IMPLICIT_INSTANTIATION (result))\n     {\n-      error (\"no matching template for `%D' found\", result);\n+      error (\"no matching template for %qD found\", result);\n       return;\n     }\n   else if (!DECL_TEMPLATE_INFO (result))\n     {\n-      pedwarn (\"explicit instantiation of non-template `%#D'\", result);\n+      pedwarn (\"explicit instantiation of non-template %q#D\", result);\n       return;\n     }\n \n@@ -10606,12 +10608,12 @@ do_decl_instantiation (tree decl, tree storage)\n   else if (storage == ridpointers[(int) RID_EXTERN])\n     {\n       if (pedantic && !in_system_header)\n-\tpedwarn (\"ISO C++ forbids the use of `extern' on explicit instantiations\");\n+\tpedwarn (\"ISO C++ forbids the use of %<extern%> on explicit \"\n+                 \"instantiations\");\n       extern_p = 1;\n     }\n   else\n-    error (\"storage class `%D' applied to template instantiation\",\n-\t      storage);\n+    error (\"storage class %qD applied to template instantiation\", storage);\n \n   mark_decl_instantiated (result, extern_p);\n   if (! extern_p)\n@@ -10673,7 +10675,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n   if (! CLASS_TYPE_P (t) || ! CLASSTYPE_TEMPLATE_INFO (t))\n     {\n-      error (\"explicit instantiation of non-template type `%T'\", t);\n+      error (\"explicit instantiation of non-template type %qT\", t);\n       return;\n     }\n \n@@ -10682,8 +10684,8 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n   if (!COMPLETE_TYPE_P (t))\n     {\n       if (complain & tf_error)\n-\terror (\"explicit instantiation of `%#T' before definition of template\",\n-\t\t  t);\n+\terror (\"explicit instantiation of %q#T before definition of template\",\n+               t);\n       return;\n     }\n \n@@ -10701,8 +10703,8 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \tstatic_p = 1;\n       else\n \t{\n-\t  error (\"storage class `%D' applied to template instantiation\",\n-\t\t    storage);\n+\t  error (\"storage class %qD applied to template instantiation\",\n+                 storage);\n \t  extern_p = 0;\n \t}\n     }\n@@ -10735,7 +10737,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n       if (!previous_instantiation_extern_p && !extern_p\n \t  && (complain & tf_error))\n-\tpedwarn (\"duplicate explicit instantiation of `%#T'\", t);\n+\tpedwarn (\"duplicate explicit instantiation of %q#T\", t);\n       \n       /* If we've already instantiated the template, just return now.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t))\n@@ -11098,7 +11100,7 @@ instantiate_decl (tree d, int defer_ok, int undefined_ok)\n \t   shall be present in every translation unit in which it is\n \t   explicitly instantiated.  */\n \tpedwarn\n-\t  (\"explicit instantiation of `%D' but no definition available\", d);\n+\t  (\"explicit instantiation of %qD but no definition available\", d);\n \n       add_pending_template (d);\n       goto out;\n@@ -11244,7 +11246,7 @@ instantiate_pending_templates (int retries)\n     {\n       cp_error_at (\"template instantiation depth exceeds maximum of %d\"\n \t\t   \" (use -ftemplate-depth-NN to increase the maximum)\"\n-\t\t   \" instantiating `%+D', possibly from virtual table\"\n+\t\t   \" instantiating %q+D, possibly from virtual table\"\n \t\t   \" generation\",\n \t\t   max_tinst_depth, TREE_VALUE (pending_templates));\n       return;\n@@ -11521,8 +11523,7 @@ invalid_nontype_parm_type_p (tree type, tsubst_flags_t complain)\n     return 0;\n            \n   if (complain & tf_error)\n-    error (\"`%#T' is not a valid type for a template constant parameter\",\n-              type);\n+    error (\"%q#T is not a valid type for a template constant parameter\", type);\n   return 1;\n }\n "}]}