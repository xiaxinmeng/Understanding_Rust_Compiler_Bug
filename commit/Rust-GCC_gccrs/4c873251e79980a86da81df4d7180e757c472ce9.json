{"sha": "4c873251e79980a86da81df4d7180e757c472ce9", "node_id": "C_kwDOANBUbNoAKDRjODczMjUxZTc5OTgwYTg2ZGE4MWRmNGQ3MTgwZTc1N2M0NzJjZTk", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-25T17:15:33Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-10-27T15:05:59Z"}, "message": "Add support for higher ranked trait bounds\n\nThis adds the type checking for the bounds which will add the relevant\nbounds to the associated types and perform the relevant type checking\nrequired.\n\nFixes #442", "tree": {"sha": "cae275fc36ea6082f915c0a9bbdbb3caf8b61fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cae275fc36ea6082f915c0a9bbdbb3caf8b61fd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c873251e79980a86da81df4d7180e757c472ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c873251e79980a86da81df4d7180e757c472ce9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c873251e79980a86da81df4d7180e757c472ce9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c873251e79980a86da81df4d7180e757c472ce9/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b9ddc724051a678035b0b51e2e3932f01838a5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b9ddc724051a678035b0b51e2e3932f01838a5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b9ddc724051a678035b0b51e2e3932f01838a5e"}], "stats": {"total": 198, "additions": 195, "deletions": 3}, "files": [{"sha": "21f07813389da6ba6bc4fec7760fa2346adfd9fd", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=4c873251e79980a86da81df4d7180e757c472ce9", "patch": "@@ -1387,6 +1387,8 @@ class Struct : public VisItem\n     return generic_params;\n   }\n \n+  WhereClause &get_where_clause () { return where_clause; }\n+\n protected:\n   Struct (Analysis::NodeMapping mappings, Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -1994,6 +1996,8 @@ class Union : public VisItem\n       }\n   }\n \n+  WhereClause &get_where_clause () { return where_clause; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2704,6 +2708,8 @@ class ImplBlock : public VisItem\n     return trait_ref;\n   }\n \n+  WhereClause &get_where_clause () { return where_clause; }\n+\n protected:\n   ImplBlock *clone_item_impl () const override { return new ImplBlock (*this); }\n };"}, {"sha": "062d60b37ea86081d5f307f54f0cba64a472ae4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=4c873251e79980a86da81df4d7180e757c472ce9", "patch": "@@ -150,6 +150,11 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n \n     context->insert_type (alias.get_mappings (), actual_type);\n+\n+    for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n@@ -191,6 +196,11 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n       ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());"}, {"sha": "a32d4a4254976fe7f9e7e613ca9be7cc01d0d61d", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=4c873251e79980a86da81df4d7180e757c472ce9", "patch": "@@ -46,6 +46,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n       = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n \n     context->insert_type (alias.get_mappings (), actual_type);\n+\n+    for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n   }\n \n   void visit (HIR::TupleStruct &struct_decl) override\n@@ -76,6 +81,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     std::vector<TyTy::StructFieldType *> fields;\n \n     size_t idx = 0;\n@@ -136,6 +146,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     std::vector<TyTy::StructFieldType *> fields;\n \n     for (auto &field : struct_decl.get_fields ())\n@@ -188,6 +203,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     std::vector<TyTy::StructFieldType *> variants;\n     union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n       TyTy::BaseType *variant_type\n@@ -259,6 +279,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n       ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n@@ -296,6 +321,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t\t    TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n \t\t\t\t    ABI::RUST, std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n+\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n@@ -327,6 +353,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     auto self\n       = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n     if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "c2b6d7c04af171e11d6b430fe75c62999afcd941", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=4c873251e79980a86da81df4d7180e757c472ce9", "patch": "@@ -277,6 +277,111 @@ class TypeResolveGenericParam : public TypeCheckBase\n   TyTy::ParamType *resolved;\n };\n \n+class ResolveWhereClauseItem : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void Resolve (HIR::WhereClauseItem &item)\n+  {\n+    ResolveWhereClauseItem resolver;\n+    item.accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::LifetimeWhereClauseItem &) override {}\n+\n+  void visit (HIR::TypeBoundWhereClauseItem &item) override\n+  {\n+    auto &binding_type_path = item.get_bound_type ();\n+    TyTy::BaseType *binding = TypeCheckType::Resolve (binding_type_path.get ());\n+\n+    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+    for (auto &bound : item.get_type_param_bounds ())\n+      {\n+\tswitch (bound->get_bound_type ())\n+\t  {\n+\t    case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t      HIR::TraitBound *b\n+\t\t= static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t      auto &type_path = b->get_path ();\n+\t      TraitReference *trait = resolve_trait_path (type_path);\n+\t      TyTy::TypeBoundPredicate predicate (\n+\t\ttrait->get_mappings ().get_defid (), b->get_locus ());\n+\n+\t      auto &final_seg = type_path.get_final_segment ();\n+\t      if (final_seg->is_generic_segment ())\n+\t\t{\n+\t\t  auto final_generic_seg\n+\t\t    = static_cast<HIR::TypePathSegmentGeneric *> (\n+\t\t      final_seg.get ());\n+\t\t  if (final_generic_seg->has_generic_args ())\n+\t\t    {\n+\t\t      HIR::GenericArgs &generic_args\n+\t\t\t= final_generic_seg->get_generic_args ();\n+\n+\t\t      // this is applying generic arguments to a trait\n+\t\t      // reference\n+\t\t      predicate.apply_generic_arguments (&generic_args);\n+\t\t    }\n+\t\t}\n+\n+\t      specified_bounds.push_back (std::move (predicate));\n+\t    }\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+      }\n+    binding->inherit_bounds (specified_bounds);\n+\n+    // When we apply these bounds we must lookup which type this binding\n+    // resolves to, as this is the type which will be used during resolution of\n+    // the block.\n+    NodeId ast_node_id = binding_type_path->get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+      {\n+\t// FIXME\n+\trust_error_at (Location (),\n+\t\t       \"Failed to lookup type reference for node: %s\",\n+\t\t       binding_type_path->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (\n+\t  binding_type_path->get_mappings ().get_crate_num (), ref_node_id,\n+\t  &ref))\n+      {\n+\t// FIXME\n+\trust_error_at (Location (), \"where-clause reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // the base reference for this name _must_ have a type set\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\trust_error_at (mappings->lookup_location (ref),\n+\t\t       \"Failed to resolve where-clause binding type: %s\",\n+\t\t       binding_type_path->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // FIXME\n+    // rust_assert (binding->is_equal (*lookup));\n+    lookup->inherit_bounds (specified_bounds);\n+  }\n+\n+private:\n+  ResolveWhereClauseItem () : TypeCheckBase () {}\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "a492ec3573654d66718f6d873f6a51a6614fbd43", "filename": "gcc/testsuite/rust/compile/torture/traits10.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs?ref=4c873251e79980a86da81df4d7180e757c472ce9", "patch": "@@ -1,6 +1,5 @@\n-trait Foo\n-where\n-    Self: Sized,\n+trait Foo // where\n+//     Self: Sized,\n {\n     fn get(self) -> i32;\n     // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }"}, {"sha": "53a8a8e9481c774ba52cfaa49733fa06e77744cd", "filename": "gcc/testsuite/rust/execute/torture/trait11.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c873251e79980a86da81df4d7180e757c472ce9/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait11.rs?ref=4c873251e79980a86da81df4d7180e757c472ce9", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait FnLike<A, R> {\n+    fn call(&self, arg: A) -> R;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .arg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct S;\n+impl<'a, T> FnLike<&'a T, &'a T> for S {\n+    fn call(&self, arg: &'a T) -> &'a T {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-2 }\n+        arg\n+    }\n+}\n+\n+fn indirect<F>(f: F)\n+where\n+    F: for<'a> FnLike<&'a isize, &'a isize>,\n+{\n+    let x = 3;\n+    let y = f.call(&x);\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *y);\n+    }\n+}\n+\n+fn main() -> i32 {\n+    indirect(S);\n+\n+    0\n+}"}]}