{"sha": "8d019cef1a2ecde418d34b58aece9b5a0be0586f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQwMTljZWYxYTJlY2RlNDE4ZDM0YjU4YWVjZTliNWEwYmUwNTg2Zg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-02-27T12:15:17Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-27T12:15:17Z"}, "message": "Support partial specialization of member class templates.\n\n\t* pt.c (get_class_bindings): Add outer_args parm.\n\t(most_specialized_class): Likewise.\n\t(instantiate_class_template): Pass it.\n\t(more_specialized_class): Likewise.\n\t(lookup_template_class): Get context from template if none\n\twas specified.\n\t(finish_member_template_decl): Don't do anything with a\n\tpartial specialization.\n\t* decl2.c (check_member_template): Use IS_AGGR_TYPE instead of\n\tAGGREGATE_TYPE_P.\n\t* class.c (finish_struct): Member class templates have already been\n\tchecked for name clashes.\n\t* decl.c (pushdecl_with_scope): Handle pushing at class level.\n\nFrom-SVN: r18285", "tree": {"sha": "132ee51a4a24b5c03f0fa420891027b9210b7b84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/132ee51a4a24b5c03f0fa420891027b9210b7b84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d019cef1a2ecde418d34b58aece9b5a0be0586f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d019cef1a2ecde418d34b58aece9b5a0be0586f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d019cef1a2ecde418d34b58aece9b5a0be0586f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d019cef1a2ecde418d34b58aece9b5a0be0586f/comments", "author": null, "committer": null, "parents": [{"sha": "5987a4f34ae693fa52d4f0c4adf136f6becb8984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5987a4f34ae693fa52d4f0c4adf136f6becb8984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5987a4f34ae693fa52d4f0c4adf136f6becb8984"}], "stats": {"total": 94, "additions": 71, "deletions": 23}, "files": [{"sha": "136a71ae3779f27f386784eb86950b9ec9370d95", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8d019cef1a2ecde418d34b58aece9b5a0be0586f", "patch": "@@ -1,3 +1,19 @@\n+Fri Feb 27 11:17:50 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (get_class_bindings): Add outer_args parm.\n+\t(most_specialized_class): Likewise.\n+\t(instantiate_class_template): Pass it.\n+\t(more_specialized_class): Likewise.\n+\t(lookup_template_class): Get context from template if none\n+\twas specified.\n+\t(finish_member_template_decl): Don't do anything with a\n+\tpartial specialization.\n+\t* decl2.c (check_member_template): Use IS_AGGR_TYPE instead of\n+\tAGGREGATE_TYPE_P.\n+\t* class.c (finish_struct): Member class templates have already been\n+\tchecked for name clashes.\n+\t* decl.c (pushdecl_with_scope): Handle pushing at class level.\n+\n Fri Feb 27 02:25:16 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (tsubst, TEMPLATE_DECL): Support member class templates."}, {"sha": "6d64e982a509069c69c5aff6d2bc3cac4d0a9a1f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8d019cef1a2ecde418d34b58aece9b5a0be0586f", "patch": "@@ -4375,6 +4375,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \t  /* Check for inconsistent use of this name in the class body.\n              Enums, types and static vars have already been checked.  */\n \t  if (TREE_CODE (x) != TYPE_DECL && TREE_CODE (x) != USING_DECL\n+\t      && ! (TREE_CODE (x) == TEMPLATE_DECL\n+\t\t    && TREE_CODE (DECL_RESULT (x)) == TYPE_DECL)\n \t      && TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n \t    {\n \t      tree name = DECL_NAME (x);"}, {"sha": "eedf3e2800074440561b9cb0479b964ff311cb83", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8d019cef1a2ecde418d34b58aece9b5a0be0586f", "patch": "@@ -2458,7 +2458,7 @@ extern void end_tree                            PROTO((void));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n extern void pop_tinst_level\t\t\tPROTO((void));\n extern tree most_specialized\t\t\tPROTO((tree, tree, tree));\n-extern tree most_specialized_class\t\tPROTO((tree, tree));\n+extern tree most_specialized_class\t\tPROTO((tree, tree, tree));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));\n extern int is_member_template                   PROTO((tree));"}, {"sha": "b61d44a7e376c896c2e7692e4b2fead1c9237853", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8d019cef1a2ecde418d34b58aece9b5a0be0586f", "patch": "@@ -3503,13 +3503,24 @@ pushdecl_with_scope (x, level)\n      tree x;\n      struct binding_level *level;\n {\n-  register struct binding_level *b = current_binding_level;\n+  register struct binding_level *b;\n   tree function_decl = current_function_decl;\n \n   current_function_decl = NULL_TREE;\n-  current_binding_level = level;\n-  x = pushdecl (x);\n-  current_binding_level = b;\n+  if (level->parm_flag == 2)\n+    {\n+      b = class_binding_level;\n+      class_binding_level = level;\n+      pushdecl_class_level (x);\n+      class_binding_level = b;\n+    }\n+  else\n+    {\n+      b = current_binding_level;\n+      current_binding_level = level;\n+      x = pushdecl (x);\n+      current_binding_level = b;\n+    }\n   current_function_decl = function_decl;\n   return x;\n }"}, {"sha": "fa39b9e4b8ddebdb03460c32dcc89c4714bc86ed", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8d019cef1a2ecde418d34b58aece9b5a0be0586f", "patch": "@@ -1386,8 +1386,8 @@ check_member_template (tmpl)\n \t with member templates.  */ \n       DECL_IGNORED_P (tmpl) = 1;\n     } \n-  else if (TREE_CODE (decl) == TYPE_DECL &&\n-\t   AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n+  else if (TREE_CODE (decl) == TYPE_DECL\n+\t   && IS_AGGR_TYPE (TREE_TYPE (decl)))\n     {\n       if (current_function_decl)\n \t/* 14.5.2.2 [temp.mem]"}, {"sha": "d5362aae34bf5e2ae8652b72c447727926ae6cb7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d019cef1a2ecde418d34b58aece9b5a0be0586f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8d019cef1a2ecde418d34b58aece9b5a0be0586f", "patch": "@@ -77,7 +77,7 @@ static char *mangle_class_name_for_template PROTO((char *, tree, tree, tree));\n static tree tsubst_expr_values PROTO((tree, tree));\n static int comp_template_args PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n-static tree get_class_bindings PROTO((tree, tree, tree));\n+static tree get_class_bindings PROTO((tree, tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n@@ -109,12 +109,14 @@ finish_member_template_decl (template_parameters, decl)\n     {\n       /* Assume that the class is the only declspec.  */\n       decl = TREE_VALUE (decl);\n-      if (IS_AGGR_TYPE (decl) && CLASSTYPE_TEMPLATE_INFO (decl))\n+      if (IS_AGGR_TYPE (decl) && CLASSTYPE_TEMPLATE_INFO (decl)\n+\t  && ! CLASSTYPE_TEMPLATE_SPECIALIZATION (decl))\n \t{\n \t  tree tmpl = CLASSTYPE_TI_TEMPLATE (decl);\n \t  check_member_template (tmpl);\n \t  return tmpl;\n \t}\n+      return NULL_TREE;\n     }\n   else if (DECL_TEMPLATE_INFO (decl) &&\n \t   !DECL_TEMPLATE_SPECIALIZATION (decl))\n@@ -2380,6 +2382,8 @@ lookup_template_class (d1, arglist, in_decl, context)\n \t  if (! template)\n \t    template = IDENTIFIER_CLASS_VALUE (d1);\n \t}\n+      if (template)\n+\tcontext = DECL_CONTEXT (template);\n     }\n   else if (TREE_CODE (d1) == TYPE_DECL && IS_AGGR_TYPE (TREE_TYPE (d1)))\n     {\n@@ -2938,7 +2942,7 @@ instantiate_class_template (type)\n      tree type;\n {\n   tree template, template_info, args, pattern, t, *field_chain;\n-  tree typedecl;\n+  tree typedecl, outer_args;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n@@ -2954,22 +2958,24 @@ instantiate_class_template (type)\n \n   if (DECL_TEMPLATE_INFO (template))\n     {\n-      args = add_to_template_args (DECL_TI_ARGS (template), args);\n+      outer_args = DECL_TI_ARGS (template);\n       while (DECL_TEMPLATE_INFO (template))\n \ttemplate = DECL_TI_TEMPLATE (template);\n     }\n+  else\n+    outer_args = NULL_TREE;\n \n-  /* FIXME deal with partial specializations of member templates.  */\n   t = most_specialized_class\n-    (DECL_TEMPLATE_SPECIALIZATIONS (template), args);\n+    (DECL_TEMPLATE_SPECIALIZATIONS (template), args, outer_args);\n \n   if (t == error_mark_node)\n     {\n       char *str = \"candidates are:\";\n       cp_error (\"ambiguous class template instantiation for `%#T'\", type);\n       for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; t = TREE_CHAIN (t))\n \t{\n-\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args))\n+\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n+\t\t\t\t  args, outer_args))\n \t    {\n \t      cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n \t      str = \"               \";\n@@ -2987,7 +2993,11 @@ instantiate_class_template (type)\n     return type;\n \n   if (t)\n-    args = get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args);\n+    args = get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n+\t\t\t       args, outer_args);\n+\n+  if (outer_args)\n+    args = add_to_template_args (outer_args, args);\n \n   if (pedantic && uses_template_parms (args))\n     /* If there are still template parameters amongst the args, then\n@@ -3617,7 +3627,7 @@ tsubst (t, args, in_decl)\n \tif (PRIMARY_TEMPLATE_P (t))\n \t  TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (tmpl)) = tmpl;\n \n-\t/* FIXME deal with partial specializations.  */\n+\t/* We don't partially instantiate partial specializations.  */\n \tif (TREE_CODE (decl) == TYPE_DECL)\n \t  return tmpl;\n \n@@ -5651,12 +5661,14 @@ more_specialized_class (pat1, pat2)\n   int winner = 0;\n \n   targs = get_class_bindings\n-    (TREE_VALUE (pat1), TREE_PURPOSE (pat1), TREE_PURPOSE (pat2));\n+    (TREE_VALUE (pat1), TREE_PURPOSE (pat1),\n+     TREE_PURPOSE (pat2), NULL_TREE);\n   if (targs)\n     --winner;\n \n   targs = get_class_bindings\n-    (TREE_VALUE (pat2), TREE_PURPOSE (pat2), TREE_PURPOSE (pat1));\n+    (TREE_VALUE (pat2), TREE_PURPOSE (pat2),\n+     TREE_PURPOSE (pat1), NULL_TREE);\n   if (targs)\n     ++winner;\n \n@@ -5718,12 +5730,18 @@ get_bindings (fn, decl, explicit_args)\n }\n \n static tree\n-get_class_bindings (tparms, parms, args)\n-     tree tparms, parms, args;\n+get_class_bindings (tparms, parms, args, outer_args)\n+     tree tparms, parms, args, outer_args;\n {\n   int i, dummy, ntparms = TREE_VEC_LENGTH (tparms);\n   tree vec = make_temp_vec (ntparms);\n \n+  if (outer_args)\n+    {\n+      tparms = tsubst (tparms, outer_args, NULL_TREE);\n+      parms = tsubst (parms, outer_args, NULL_TREE);\n+    }\n+\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i)\n     {\n       switch (unify (tparms, &TREE_VEC_ELT (vec, 0), ntparms,\n@@ -5803,15 +5821,16 @@ most_specialized (fns, decl, explicit_args)\n    SPECS that can produce an instantiation matching ARGS.  */\n \n tree\n-most_specialized_class (specs, mainargs)\n-     tree specs, mainargs;\n+most_specialized_class (specs, mainargs, outer_args)\n+     tree specs, mainargs, outer_args;\n {\n   tree list = NULL_TREE, t, args, champ;\n   int fate;\n \n   for (t = specs; t; t = TREE_CHAIN (t))\n     {\n-      args = get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), mainargs);\n+      args = get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n+\t\t\t\t mainargs, outer_args);\n       if (args)\n \t{\n \t  list = decl_tree_cons (TREE_PURPOSE (t), TREE_VALUE (t), list);"}]}