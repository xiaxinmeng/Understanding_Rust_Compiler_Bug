{"sha": "994571561f3bd92c6826964be7d0b2339e0db115", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk0NTcxNTYxZjNiZDkyYzY4MjY5NjRiZTdkMGIyMzM5ZTBkYjExNQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-28T23:56:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1993-03-28T23:56:26Z"}, "message": "pa.md (smin, [...]): New patterns.\n\n\t* pa.md (smin, umin, smax, umax): New patterns.\n\n\t* pa.md (cbranch define_delay): Enable nullification of\n\tconditional branch delay slots (based upon branch direction).\n\t(conditional branch patterns): Call output_cbranch to get the\n\tcorrect output template.  Long conditional branches with an\n\tannulled delay slot have a length of 3.\n\t(branch on bit patterns): Call output_bb to get the correct\n\toutput template.  Long branches with an annulled delay slot have\n\ta length of 3.\n\t(decrement and branch pattern): Handle nullification of long\n\nFrom-SVN: r3906", "tree": {"sha": "2c931195a63e61848b9d4487b211ff55b0278f62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c931195a63e61848b9d4487b211ff55b0278f62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/994571561f3bd92c6826964be7d0b2339e0db115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994571561f3bd92c6826964be7d0b2339e0db115", "html_url": "https://github.com/Rust-GCC/gccrs/commit/994571561f3bd92c6826964be7d0b2339e0db115", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/994571561f3bd92c6826964be7d0b2339e0db115/comments", "author": null, "committer": null, "parents": [{"sha": "f2878c6b324e8c3816612d3a2b3c5422207ec855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2878c6b324e8c3816612d3a2b3c5422207ec855", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2878c6b324e8c3816612d3a2b3c5422207ec855"}], "stats": {"total": 291, "additions": 213, "deletions": 78}, "files": [{"sha": "1c4b9b5ce7f9b48840b715352f35818c817d1fd3", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 213, "deletions": 78, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/994571561f3bd92c6826964be7d0b2339e0db115/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/994571561f3bd92c6826964be7d0b2339e0db115/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=994571561f3bd92c6826964be7d0b2339e0db115", "patch": "@@ -65,19 +65,36 @@\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n+;; Disallow instructions which use the FPU since they will tie up the FPU\n+;; even if the instruction is nullified.\n+(define_attr \"in_nullified_branch_delay\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"!branch,cbranch,fbranch,call,dyncall,multi,milli,fpcc,fpalu,fpmul,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl\")\n+\t\t     (eq_attr \"length\" \"1\"))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n ;; Unconditional branch, call, and millicode call delay slot description.\n (define_delay (eq_attr \"type\" \"branch,call,milli\")\n   [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n \n-;; Floating point conditional branch delay slot description.\n+;; Floating point conditional branch delay slot description and\n (define_delay (eq_attr \"type\" \"fbranch\")\n   [(eq_attr \"in_branch_delay\" \"true\")\n-   (eq_attr \"in_branch_delay\" \"true\")\n+   (eq_attr \"in_nullified_branch_delay\" \"true\")\n    (nil)])\n \n ;; Integer conditional branch delay slot description.\n+;; Nullification of conditional branches on the PA is dependent on the\n+;; direction of the branch.  Forward branches nullify true (direction > 0),\n+;; and backward branches nullify false (direction < 0).\n+;; If direction == 0, then the direction is unknown and we do not allow\n+;; any nullification.\n (define_delay (eq_attr \"type\" \"cbranch\")\n-  [(eq_attr \"in_branch_delay\" \"true\") (nil) (nil)])\n+  [(eq_attr \"in_branch_delay\" \"true\") \n+   (and (eq_attr \"in_nullified_branch_delay\" \"true\") \n+\t(attr_flag \"forward\"))\n+   (and (eq_attr \"in_nullified_branch_delay\" \"true\")\n+\t(attr_flag \"backward\"))])\n \n ;; Function units of the HPPA. The following data is for the \"Snake\"\n ;; (Mustang CPU + Timex FPU) because that's what I have the docs for.\n@@ -463,6 +480,52 @@\n   [(set_attr \"type\" \"binary,binary\")\n    (set_attr \"length\" \"2,3\")])\n \n+;; Signed/Unsigned minimum and maximum patterns.\n+(define_insn \"sminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(smin:SI (match_operand:SI 1 \"register_operand\" \"%r,0,0\")\n+\t\t (match_operand:SI 2 \"arith11_operand\" \"M,r,I\")))]\n+  \"\"\n+  \"@\n+  comclr,> %1,%2,%0\\;copy %1,%0\n+  comclr,> %2,%0,0\\;copy %2,%0\n+  comiclr,> %2,%0,0\\;ldi %2,%0\"\n+[(set_attr \"type\" \"multi,multi,multi\")\n+ (set_attr \"length\" \"2,2,2\")])\n+\n+(define_insn \"uminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(umin:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"arith11_operand\" \"r,I\")))]\n+  \"\"\n+  \"@\n+  comclr,>> %2,%0,0\\;copy %2,%0\n+  comiclr,>> %2,%0,0\\;ldi %2,%0\"\n+[(set_attr \"type\" \"multi,multi\")\n+ (set_attr \"length\" \"2,2\")])\n+\n+(define_insn \"smaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n+\t(smax:SI (match_operand:SI 1 \"register_operand\" \"%r,0,0\")\n+\t\t (match_operand:SI 2 \"arith11_operand\" \"M,r,I\")))]\n+  \"\"\n+  \"@\n+  comclr,< %1,%2,%0\\;copy %1,%0\n+  comclr,< %2,%0,0\\;copy %2,%0\n+  comiclr,< %2,%0,0\\;ldi %2,%0\"\n+[(set_attr \"type\" \"multi,multi,multi\")\n+ (set_attr \"length\" \"2,2,2\")])\n+\n+(define_insn \"umaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n+\t(umax:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"arith11_operand\" \"r,I\")))]\n+  \"\"\n+  \"@\n+  comclr,<< %2,%0,0\\;copy %2,%0\n+  comiclr,<< %2,%0,0\\;ldi %2,%0\"\n+[(set_attr \"type\" \"multi,multi\")\n+ (set_attr \"length\" \"2,2\")])\n ;;; Experimental conditional move patterns\n \n ; We need the first constraint alternative in order to avoid\n@@ -676,6 +739,9 @@\n \n ;; Match the branch patterns.\n \n+\n+;; Note a long backward conditional branch with an annulled delay slot\n+;; has a length of 3.  \n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -687,15 +753,19 @@\n   \"\"\n   \"*\n {\n-  return (get_attr_length (insn) == 1\n-\t  ? \\\"com%I2b,%S3 %2,%1,%0%#\\\" : \\\"com%I2clr,%B3 %2,%1,0\\;bl %0,0%#\\\");\n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn), \n+\t\t\t get_attr_length (insn), 0, insn);\n }\"\n-  [(set_attr \"type\" \"cbranch\")\n-   (set (attr \"length\") (if_then_else (lt (abs (minus (match_dup 0)\n-\t\t\t\t\t\t      (plus (pc) (const_int 2))))\n-\t\t\t\t\t  (const_int 1023))\n-\t\t\t\t      (const_int 1)\n-\t\t\t\t      (const_int 2)))])\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\") \n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 1023))\n+           (const_int 1)\n+\t   (and (lt (match_dup 0) (pc))\n+\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n+\t\t    (const_int 1)))\n+\t   (const_int 3)]\n+\t  (const_int 2)))])\n \n ;; Match the negated branch.\n \n@@ -710,18 +780,21 @@\n   \"\"\n   \"*\n {\n-  return (get_attr_length (insn) == 1\n-\t  ? \\\"com%I2b,%B3 %2,%1,%0%#\\\" : \\\"com%I2clr,%S3 %2,%1,0%#\\;bl %0,0%#\\\");\n+  return output_cbranch (operands, INSN_ANNULLED_BRANCH_P (insn), \n+\t\t\t get_attr_length (insn), 1, insn);\n }\"\n-  [(set_attr \"type\" \"cbranch\")\n-   (set (attr \"length\") (if_then_else (lt (abs (minus (match_dup 0)\n-\t\t\t\t\t\t      (plus (pc) (const_int 2))))\n-\t\t\t\t\t  (const_int 1023))\n-\t\t\t\t      (const_int 1)\n-\t\t\t\t      (const_int 2)))])\n-\n-;; Branch on bit patterns\n-\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\") \n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 1023))\n+           (const_int 1)\n+\t   (and (lt (match_dup 0) (pc))\n+\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n+\t\t    (const_int 1)))\n+\t   (const_int 3)]\n+\t  (const_int 2)))])\n+\n+;; Branch on Bit patterns.\n (define_insn \"\"\n   [(set (pc)\n \t(if_then_else\n@@ -734,19 +807,21 @@\n   \"\"\n   \"*\n {\n-  if (operands[3] == pc_rtx)\n-    return (get_attr_length (insn) == 1\n-\t    ? \\\"bb,< %0,%1,%2%#\\\" : \\\"extrs,>= %0,%1,1,0\\;bl %2,0%#\\\");\n-  else\n-    return (get_attr_length (insn) == 1\n-\t    ? \\\"bb,>= %0,%1,%3%#\\\" : \\\"extrs,< %0,%1,1,0\\;bl %3,0%#\\\");\n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn), \n+\t\t\t get_attr_length (insn), \n+\t\t\t (operands[3] != pc_rtx),\n+\t\t\t insn, 0);\n }\"\n-  [(set_attr \"type\" \"cbranch\")\n-   (set (attr \"length\") (if_then_else (lt (abs (minus (match_dup 0)\n-\t\t\t\t\t\t      (plus (pc) (const_int 2))))\n-\t\t\t\t\t  (const_int 1023))\n-\t\t\t\t      (const_int 1)\n-\t\t\t\t      (const_int 2)))])\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\") \n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 1023))\n+           (const_int 1)\n+\t   (and (lt (match_dup 0) (pc))\n+\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n+\t\t    (const_int 1)))\n+\t   (const_int 3)]\n+\t  (const_int 2)))])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -760,19 +835,22 @@\n   \"\"\n   \"*\n {\n-  if (operands[3] == pc_rtx)\n-    return (get_attr_length (insn) == 1\n-\t    ? \\\"bb,>= %0,%1,%2%#\\\" : \\\"extrs,< %0,%1,1,0\\;bl %2,0%#\\\");\n-  else\n-    return (get_attr_length (insn) == 1\n-\t    ? \\\"bb,< %0,%1,%3%#\\\" : \\\"extrs,>= %0,%1,1,0\\;bl %3,0%#\\\");\n+  return output_bb (operands, INSN_ANNULLED_BRANCH_P (insn), \n+\t\t\t get_attr_length (insn), \n+\t\t\t (operands[3] != pc_rtx),\n+\t\t\t insn, 1);\n }\"\n-  [(set_attr \"type\" \"cbranch\")\n-   (set (attr \"length\") (if_then_else (lt (abs (minus (match_dup 0)\n-\t\t\t\t\t\t      (plus (pc) (const_int 2))))\n-\t\t\t\t\t  (const_int 1023))\n-\t\t\t\t      (const_int 1)\n-\t\t\t\t      (const_int 2)))])\n+[(set_attr \"type\" \"cbranch\")\n+ (set (attr \"length\") \n+    (cond [(lt (abs (minus (match_dup 0) (plus (pc) (const_int 2))))\n+\t\t      (const_int 1023))\n+           (const_int 1)\n+\t   (and (lt (match_dup 0) (pc))\n+\t\t(eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n+\t\t    (const_int 1)))\n+\t   (const_int 3)]\n+\t  (const_int 2)))])\n+\n ;; Floating point branches\n \n (define_insn \"\"\n@@ -2744,13 +2822,13 @@\n   return \\\"depi %3,%2+%1-1,%1,%0\\\";\n }\")\n \n+;; The dbra pattern from hell.  \n ;; This insn is used for some loop tests, typically loops reversed when\n ;; strength reduction is used.  It is actually created when the instruction\n ;; combination phase combines the special loop test.  Since this insn\n ;; is both a jump insn and has an output, it must deal with it's own\n ;; reloads, hence the `m' constraints.  The `!' constraints direct reload\n ;; to not choose the register alternatives in the event a reload is needed.\n-\n (define_insn \"decrement_and_branch_until_zero\"\n   [(set (pc)\n \t(if_then_else\n@@ -2766,44 +2844,101 @@\n   \"find_reg_note (insn, REG_NONNEG, 0)\"\n \"*\n {\n-  if (which_alternative == 0)\n-    if (get_attr_length (insn) == 1)\n-      return \\\"addib,>= -1,%0,%1%#\\\";\n-    else\n-      return \\\"addi,< -1,%0,%0\\;bl %1,0%#\\\";\n+  if (INSN_ANNULLED_BRANCH_P (insn))\n+    {\n+      /* Loop counter is in a register.  */\n+      if (which_alternative == 0)\n+\t/* Short branch.  Normal handling of nullification.  */\n+        if (get_attr_length (insn) == 1)\n+          return \\\"addib,>=,n -1,%0,%1\\\";\n+\t/* Long Conditional branch forward with delay slot nullified if\n+\t   branch is taken.  */\n+        else if (get_attr_length (insn) == 2)\n+          return \\\"addi,< -1,%0,%0\\;bl,n %1,0\\\";\n+\t/* Long Conditional branch backwards with delay slot nullified\n+\t   if branch is not taken.  */\n+        else\n+          return \\\"addib,< -1,%0,.+16\\;nop\\;bl %1,0\\\";\n+      else\n+        {\n+\t  /* Must reload loop counter from memory.  Ugly.  */\n+          output_asm_insn (\\\"ldw %0,%2\\;ldo -1(%2),%2\\;stw %2,%0\\\", operands);\n+\t  /* Short branch.  Normal handling of nullification.  */\n+          if (get_attr_length (insn) == 4)\n+\t    return \\\"comb,>,n 0,%2,%1\\\";\n+\t  /* Long Conditional branch forward with delay slot nullified if\n+\t     branch is taken.  */\n+          else if (get_attr_length (insn) == 5)\n+\t    return \\\"comclr,<= 0,%2,0\\;bl,n %1,0\\\";\n+\t  else \n+\t  /* Long Conditional branch backwards with delay slot nullified\n+\t     if branch is not taken.  */\n+\t    return \\\"comb,<= 0,%2,.+16\\;nop\\;bl %1,0\\\";\n+        }\n+    }\n   else\n     {\n-      output_asm_insn (\\\"ldw %0,%2\\;ldo -1(%2),%2\\;stw %2,%0\\\", operands);\n-      if (get_attr_length (insn) == 4)\n-\treturn \\\"comb,> 0,%2,%1%#\\\";\n+      /* We are not nullifying the delay slot.  Much simpler.  */\n+      if (which_alternative == 0)\n+        if (get_attr_length (insn) == 1)\n+\t  /* Short form.  */\n+          return \\\"addib,>= -1,%0,%1%#\\\";\n+        else\n+\t  /* Long form.  */\n+          return \\\"addi,< -1,%0,%0\\;bl%* %1,0\\\";\n       else\n-\treturn \\\"comclr,<= 0,%2,0\\;bl %1,0%#\\\";\n+        {\n+\t  /* Reload loop counter from memory.  */\n+          output_asm_insn (\\\"ldw %0,%2\\;ldo -1(%2),%2\\;stw %2,%0\\\", operands);\n+\t  /* Short form.  */\n+          if (get_attr_length (insn) == 4)\n+\t    return \\\"comb,> 0,%2,%1%#\\\";\n+\t  /* Long form.  */\n+          else\n+\t    return \\\"comclr,<= 0,%2,0\\;bl%* %1,0\\\";\n+        }\n     }\n }\"\n+;; Do not expect to understand this the first time through.  \n [(set_attr \"type\" \"cbranch\")\n  (set (attr \"length\")\n-      (if_then_else (eq (symbol_ref \"which_alternative\") (const_int 0))\n-\t\t    (if_then_else (lt (abs (minus (match_dup 1)\n-\t\t\t\t\t\t  (plus (pc) (const_int 2))))\n-\t\t\t\t      (const_int 1023))\n-\t\t\t\t  (const_int 1)\n-\t\t\t\t  (const_int 2))\n-\t\t    (if_then_else (lt (match_dup 1)\n-\t\t\t\t      (pc))\n-\t\t\t\t  (if_then_else\n-\t\t\t\t   (lt (abs (minus (match_dup 1)\n-\t\t\t\t\t\t   (plus (pc)\n-\t\t\t\t\t\t\t (const_int 5))))\n-\t\t\t\t       (const_int 1023))\n-\t\t\t\t   (const_int 4)\n-\t\t\t\t   (const_int 5))\n-\t\t\t\t  (if_then_else\n-\t\t\t\t   (lt (abs (minus (match_dup 1)\n-\t\t\t\t\t\t   (plus (pc)\n-\t\t\t\t\t\t\t (const_int 2))))\n-\t\t\t\t       (const_int 1023))\n-\t\t\t\t   (const_int 4)\n-\t\t\t\t   (const_int 5)))))])\n+      (if_then_else \n+\t(eq_attr \"alternative\" \"0\")\n+;; Loop counter in register case.\n+\t(cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 2))))\n+\t\t   (const_int 1023))\n+;; Short branch has a length of 1.\n+\t       (const_int 1)\n+;; Long backward branch with nullified delay slot has length of 3.\n+\t       (and (lt (match_dup 1) (pc))\n+\t\t    (eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n+\t\t\t(const_int 1)))\n+\t       (const_int 3)]\n+;; Default others to 2.\n+;; Long branches with unfilled delay slots  --or--\n+;; Long forward with nullified delay slot.\n+\t      (const_int 2))\n+;; Loop counter in memory case.   Similar to above except we pay\n+;; 3 extra insns in each case for reloading the counter into a register.\n+\t(if_then_else (lt (match_dup 1) (pc))\n+\t  (cond [(lt (abs (minus (match_dup 1) (plus (pc) (const_int 5))))\n+\t\t     (const_int 1023))\n+;; Short branch has length of 4 (the reloading costs 3 insns)\n+\t\t (const_int 4)\n+\t\t (and (lt (match_dup 1) (pc))\n+\t\t      (eq (symbol_ref \"INSN_ANNULLED_BRANCH_P (insn)\")\n+\t\t\t  (const_int 1)))\n+;; Long backward branch with nullified delay slot has length of 6.\n+\t\t (const_int 6)]\n+;; Default others to 5.\n+;; Long branches with unfilled delay slots  --or--\n+;; Long forward with nullified delay slot.\n+\t\t(const_int 5))\n+\t  (if_then_else (lt (abs (minus (match_dup 1) \n+\t\t\t\t\t(plus (pc) (const_int 2))))\n+\t\t\t    (const_int 1023))\n+\t\t\t(const_int 4)\n+\t\t\t(const_int 5)))))])\n \n \n ;; The next four peepholes take advantage of the new 5 operand "}]}