{"sha": "7d583f4259a56c9054c28e883c375f9c57f8755d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q1ODNmNDI1OWE1NmM5MDU0YzI4ZTg4M2MzNzVmOWM1N2Y4NzU1ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-09-29T16:06:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-09-29T16:06:09Z"}, "message": "builtins.c (unterminated_array): Pass in c_strlen_data * to c_strlen rather than just a tree *.\n\n\t* builtins.c (unterminated_array): Pass in c_strlen_data * to\n\tc_strlen rather than just a tree *.\n\t(c_strlen): Change NONSTR argument to a c_strlen_data pointer.\n\tUpdate recursive calls appropriately.  If caller did not provide a\n\tsuitable data pointer, create a local one.  When a non-terminated\n\tstring is discovered, bubble up information about the string via the\n\tc_strlen_data object.\n\t* builtins.h (c_strlen): Update prototype.\n\t(c_strlen_data): New structure.\n\t* gimple-fold.c (get_range_strlen): Update calls to c_strlen.\n\tFor a type 2 call, if c_strlen indicates a non-terminated string\n\tuse the length of the non-terminated string.\n\t(gimple_fold_builtin_stpcpy): Update calls to c_strlen.\n\nFrom-SVN: r264712", "tree": {"sha": "797b7466a6780a7072c673f67d18031bf368e779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/797b7466a6780a7072c673f67d18031bf368e779"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d583f4259a56c9054c28e883c375f9c57f8755d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d583f4259a56c9054c28e883c375f9c57f8755d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d583f4259a56c9054c28e883c375f9c57f8755d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d583f4259a56c9054c28e883c375f9c57f8755d/comments", "author": null, "committer": null, "parents": [{"sha": "23bce99cbe7016a04e14c2163ed3fe6a5a64f4e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23bce99cbe7016a04e14c2163ed3fe6a5a64f4e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23bce99cbe7016a04e14c2163ed3fe6a5a64f4e2"}], "stats": {"total": 128, "additions": 92, "deletions": 36}, "files": [{"sha": "29f52fd39d3b7e1a9f5a670feaad764216c6b808", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d583f4259a56c9054c28e883c375f9c57f8755d", "patch": "@@ -1,3 +1,19 @@\n+2018-09-29  Jeff Law  <law@redhat.com>\n+\n+\t* builtins.c (unterminated_array): Pass in c_strlen_data * to\n+\tc_strlen rather than just a tree *.\n+\t(c_strlen): Change NONSTR argument to a c_strlen_data pointer.\n+\tUpdate recursive calls appropriately.  If caller did not provide a\n+\tsuitable data pointer, create a local one.  When a non-terminated\n+\tstring is discovered, bubble up information about the string via the\n+\tc_strlen_data object.\n+\t* builtins.h (c_strlen): Update prototype.\n+\t(c_strlen_data): New structure.\n+\t* gimple-fold.c (get_range_strlen): Update calls to c_strlen.\n+\tFor a type 2 call, if c_strlen indicates a non-terminated string\n+\tuse the length of the non-terminated string.\n+\t(gimple_fold_builtin_stpcpy): Update calls to c_strlen.\n+\n 2018-09-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/87467\n@@ -302,8 +318,8 @@\n \t* config/i386/i386.h (NUM_MODES_FOR_MODE_SWITCHING): Update\n \tfor removed I387_MASK_PM entity.\n \n-2018-09-26  Jeff Law  <law@redhat.com>\n \n+2018-09-26  Jeff Law  <law@redhat.com>\n \tRevert\n \t2018-09-26  Alexey Neyman  <stilor@att.net>\n "}, {"sha": "fe411efd9a98a8d93a10153df19ff1211fc478e7", "filename": "gcc/builtins.c", "status": "modified", "additions": 43, "deletions": 27, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=7d583f4259a56c9054c28e883c375f9c57f8755d", "patch": "@@ -570,9 +570,10 @@ warn_string_no_nul (location_t loc, const char *fn, tree arg, tree decl)\n tree\n unterminated_array (tree exp)\n {\n-  tree nonstr = NULL;\n-  c_strlen (exp, 1, &nonstr);\n-  return nonstr;\n+  c_strlen_data data;\n+  memset (&data, 0, sizeof (c_strlen_data));\n+  c_strlen (exp, 1, &data);\n+  return data.decl;\n }\n \n /* Compute the length of a null-terminated character string or wide\n@@ -592,35 +593,45 @@ unterminated_array (tree exp)\n    accesses.  Note that this implies the result is not going to be emitted\n    into the instruction stream.\n \n-   If a not zero-terminated string value is encountered and NONSTR is\n-   non-zero, the declaration of the string value is assigned to *NONSTR.\n-   *NONSTR is accumulating, thus not cleared on success, therefore it has\n-   to be initialized to NULL_TREE by the caller.\n+   Additional information about the string accessed may be recorded\n+   in DATA.  For example, if SRC references an unterminated string,\n+   then the declaration will be stored in the DECL field.   If the\n+   length of the unterminated string can be determined, it'll be\n+   stored in the LEN field.  Note this length could well be different\n+   than what a C strlen call would return.\n \n    ELTSIZE is 1 for normal single byte character strings, and 2 or\n    4 for wide characer strings.  ELTSIZE is by default 1.\n \n    The value returned is of type `ssizetype'.  */\n \n tree\n-c_strlen (tree src, int only_value, tree *nonstr, unsigned eltsize)\n+c_strlen (tree src, int only_value, c_strlen_data *data, unsigned eltsize)\n {\n+  /* If we were not passed a DATA pointer, then get one to a local\n+     structure.  That avoids having to check DATA for NULL before\n+     each time we want to use it.  */\n+  c_strlen_data local_strlen_data;\n+  memset (&local_strlen_data, 0, sizeof (c_strlen_data));\n+  if (!data)\n+    data = &local_strlen_data;\n+\n   gcc_checking_assert (eltsize == 1 || eltsize == 2 || eltsize == 4);\n   STRIP_NOPS (src);\n   if (TREE_CODE (src) == COND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n     {\n       tree len1, len2;\n \n-      len1 = c_strlen (TREE_OPERAND (src, 1), only_value, nonstr, eltsize);\n-      len2 = c_strlen (TREE_OPERAND (src, 2), only_value, nonstr, eltsize);\n+      len1 = c_strlen (TREE_OPERAND (src, 1), only_value, data, eltsize);\n+      len2 = c_strlen (TREE_OPERAND (src, 2), only_value, data, eltsize);\n       if (tree_int_cst_equal (len1, len2))\n \treturn len1;\n     }\n \n   if (TREE_CODE (src) == COMPOUND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n-    return c_strlen (TREE_OPERAND (src, 1), only_value, nonstr, eltsize);\n+    return c_strlen (TREE_OPERAND (src, 1), only_value, data, eltsize);\n \n   location_t loc = EXPR_LOC_OR_LOC (src, input_location);\n \n@@ -666,13 +677,15 @@ c_strlen (tree src, int only_value, tree *nonstr, unsigned eltsize)\n \t start searching for it.  */\n       unsigned len = string_length (ptr, eltsize, strelts);\n \n-      /* Return when an embedded null character is found or none at all.  */\n+      /* Return when an embedded null character is found or none at all.\n+\t In the latter case, set the DECL/LEN field in the DATA structure\n+\t so that callers may examine them.  */\n       if (len + 1 < strelts)\n \treturn NULL_TREE;\n       else if (len >= maxelts)\n \t{\n-\t  if (nonstr && decl)\n-\t    *nonstr = decl;\n+\t  data->decl = decl;\n+\t  data->len = ssize_int (len);\n \t  return NULL_TREE;\n \t}\n \n@@ -737,11 +750,12 @@ c_strlen (tree src, int only_value, tree *nonstr, unsigned eltsize)\n \t\t\t\tstrelts - eltoff);\n \n   /* Don't know what to return if there was no zero termination.\n-     Ideally this would turn into a gcc_checking_assert over time.  */\n+     Ideally this would turn into a gcc_checking_assert over time.\n+     Set DECL/LEN so callers can examine them.  */\n   if (len >= maxelts - eltoff)\n     {\n-      if (nonstr && decl)\n-\t*nonstr = decl;\n+      data->decl = decl;\n+      data->len = ssize_int (len);\n       return NULL_TREE;\n     }\n \n@@ -3965,13 +3979,14 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \t compile-time, not an expression containing a string.  This is\n \t because the latter will potentially produce pessimized code\n \t when used to produce the return value.  */\n-      tree nonstr = NULL_TREE;\n+      c_strlen_data data;\n+      memset (&data, 0, sizeof (c_strlen_data));\n       if (!c_getstr (src, NULL)\n-\t  || !(len = c_strlen (src, 0, &nonstr, 1)))\n+\t  || !(len = c_strlen (src, 0, &data, 1)))\n \treturn expand_movstr (dst, src, target, /*endp=*/2);\n \n-      if (nonstr && !TREE_NO_WARNING (exp))\n-\twarn_string_no_nul (EXPR_LOCATION (exp), \"stpcpy\", src, nonstr);\n+      if (data.decl && !TREE_NO_WARNING (exp))\n+\twarn_string_no_nul (EXPR_LOCATION (exp), \"stpcpy\", src, data.decl);\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n       ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n@@ -8444,22 +8459,23 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n     return NULL_TREE;\n   else\n     {\n-      tree nonstr = NULL_TREE;\n-      tree len = c_strlen (arg, 0, &nonstr);\n+      c_strlen_data data;\n+      memset (&data, 0, sizeof (c_strlen_data));\n+      tree len = c_strlen (arg, 0, &data);\n \n       if (len)\n \treturn fold_convert_loc (loc, type, len);\n \n-      if (!nonstr)\n-\tc_strlen (arg, 1, &nonstr);\n+      if (!data.decl)\n+\tc_strlen (arg, 1, &data);\n \n-      if (nonstr)\n+      if (data.decl)\n \t{\n \t  if (EXPR_HAS_LOCATION (arg))\n \t    loc = EXPR_LOCATION (arg);\n \t  else if (loc == UNKNOWN_LOCATION)\n \t    loc = input_location;\n-\t  warn_string_no_nul (loc, \"strlen\", arg, nonstr);\n+\t  warn_string_no_nul (loc, \"strlen\", arg, data.decl);\n \t}\n \n       return NULL_TREE;"}, {"sha": "3801251f372e3285c5aad5d6e488575c2607694e", "filename": "gcc/builtins.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=7d583f4259a56c9054c28e883c375f9c57f8755d", "patch": "@@ -57,7 +57,14 @@ extern bool get_pointer_alignment_1 (tree, unsigned int *,\n \t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);\n extern unsigned string_length (const void*, unsigned, unsigned);\n-extern tree c_strlen (tree, int, tree * = NULL, unsigned = 1);\n+struct c_strlen_data\n+{\n+  tree decl;\n+  tree len;\n+  tree off;\n+};\n+\n+extern tree c_strlen (tree, int, c_strlen_data * = NULL, unsigned = 1);\n extern void expand_builtin_setjmp_setup (rtx, rtx);\n extern void expand_builtin_setjmp_receiver (rtx);\n extern void expand_builtin_update_setjmp_buf (rtx);"}, {"sha": "cf04c92180b0f34e060f61e597ba3b14d0672b41", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d583f4259a56c9054c28e883c375f9c57f8755d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=7d583f4259a56c9054c28e883c375f9c57f8755d", "patch": "@@ -1337,7 +1337,23 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t    return false;\n \t}\n       else\n-\tval = c_strlen (arg, 1, nonstr, eltsize);\n+\t{\n+\t  c_strlen_data data;\n+\t  memset (&data, 0, sizeof (c_strlen_data));\n+\t  val = c_strlen (arg, 1, &data, eltsize);\n+\n+\t  /* If we potentially had a non-terminated string, then\n+\t     bubble that information up to the caller.  */\n+\t  if (!val)\n+\t    {\n+\t      *nonstr = data.decl;\n+\t      /* If TYPE is asking for a maximum, then use any\n+\t\t length (including the length of an unterminated\n+\t\t string) for VAL.  */\n+\t      if (type == 2)\n+\t\tval = data.len;\n+\t    }\n+\t}\n \n       if (!val && fuzzy)\n \t{\n@@ -2812,21 +2828,22 @@ gimple_fold_builtin_stpcpy (gimple_stmt_iterator *gsi)\n     }\n \n   /* Set to non-null if ARG refers to an unterminated array.  */\n-  tree nonstr = NULL;\n-  tree len = c_strlen (src, 1, &nonstr, 1);\n+  c_strlen_data data;\n+  memset (&data, 0, sizeof (c_strlen_data));\n+  tree len = c_strlen (src, 1, &data, 1);\n   if (!len\n       || TREE_CODE (len) != INTEGER_CST)\n     {\n-      nonstr = unterminated_array (src);\n-      if (!nonstr)\n+      data.decl = unterminated_array (src);\n+      if (!data.decl)\n \treturn false;\n     }\n \n-  if (nonstr)\n+  if (data.decl)\n     {\n       /* Avoid folding calls with unterminated arrays.  */\n       if (!gimple_no_warning_p (stmt))\n-\twarn_string_no_nul (loc, \"stpcpy\", src, nonstr);\n+\twarn_string_no_nul (loc, \"stpcpy\", src, data.decl);\n       gimple_set_no_warning (stmt, true);\n       return false;\n     }"}]}