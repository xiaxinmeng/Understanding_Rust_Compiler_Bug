{"sha": "55f60bd6fe2db6831762e243577515824e2fca5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVmNjBiZDZmZTJkYjY4MzE3NjJlMjQzNTc3NTE1ODI0ZTJmY2E1Yw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-09T13:45:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-09T13:45:33Z"}, "message": "Merge #659\n\n659: Initial intrinsics builtin block r=philberty a=philberty\n\nThis is the initial piece to get the simple intrinsic's mapped over to GCC ones. The\r\nGCC wrapper contains a mapping system of rust names over to the builtin gcc names\r\nas far as I can tell gcc will allow for fallback onto linking against -lm.\r\n\r\nI think this will be a nice piece of work for new contributors, given the number of intrinsics\r\n\r\nAddresses #658 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "b7fa367ee6c97ae3a5b9ab69bb7b1be0e02418c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7fa367ee6c97ae3a5b9ab69bb7b1be0e02418c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55f60bd6fe2db6831762e243577515824e2fca5c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhOg/9CRBK7hj4Ov3rIwAAXLQIADyNRAoLPHfQPNN5POQANe5Z\nrimXrijEiWEJnfeVfMLVxKCo6w8txuE55UvK9tn40kl2arUa348g+cuaGaQkwC//\njL64K5RMZXtklZxR/GftOZg6jWf5+Z1s3mGmUsGzcvmFiO2JX+9NTwkqfxUraExF\nU2VhBSOxpyPIzff6KeJdZ5+aHK54G2/d9muyVwpjANdszGQS2ucM5yBLObewe2dM\nGzeCFWsyBq/cEmwfaCbxpaQyyguKWX7Rbxt1QZDd7yAi6GvdJukKIAewyW7k6IKu\nzMUHSB54PtTaw/hbwtjGU7shPSpttC5zXVO35Dncki+IECLBciaa7qKgwk9suno=\n=hfzk\n-----END PGP SIGNATURE-----\n", "payload": "tree b7fa367ee6c97ae3a5b9ab69bb7b1be0e02418c4\nparent 38f2795947ab8d8080bab81c5e2ccdd24981cbcc\nparent 4faa7d7765f5840779c542430ca6aa9118008a5b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631195133 +0000\ncommitter GitHub <noreply@github.com> 1631195133 +0000\n\nMerge #659\n\n659: Initial intrinsics builtin block r=philberty a=philberty\n\nThis is the initial piece to get the simple intrinsic's mapped over to GCC ones. The\r\nGCC wrapper contains a mapping system of rust names over to the builtin gcc names\r\nas far as I can tell gcc will allow for fallback onto linking against -lm.\r\n\r\nI think this will be a nice piece of work for new contributors, given the number of intrinsics\r\n\r\nAddresses #658 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\nCo-authored-by: Thomas Schwinge <thomas@codesourcery.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55f60bd6fe2db6831762e243577515824e2fca5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55f60bd6fe2db6831762e243577515824e2fca5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55f60bd6fe2db6831762e243577515824e2fca5c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38f2795947ab8d8080bab81c5e2ccdd24981cbcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38f2795947ab8d8080bab81c5e2ccdd24981cbcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38f2795947ab8d8080bab81c5e2ccdd24981cbcc"}, {"sha": "4faa7d7765f5840779c542430ca6aa9118008a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4faa7d7765f5840779c542430ca6aa9118008a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4faa7d7765f5840779c542430ca6aa9118008a5b"}], "stats": {"total": 792, "additions": 473, "deletions": 319}, "files": [{"sha": "0e181a673d360a0c587a1ce8c99127f94ada1009", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -87,6 +87,7 @@ GRS_OBJS = \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n+    rust/rust-compile-intrinsic.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "5a268629581435c09293a66ec518b1268757974c", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -1,5 +1,3 @@\n-\n-\n // This file is part of GCC.\n \n // GCC is free software; you can redistribute it and/or modify it under"}, {"sha": "d78a56613e8b02a1927618834cf0eb88a5dc46c5", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -20,6 +20,7 @@\n #define RUST_COMPILE_EXTERN_ITEM\n \n #include \"rust-compile-base.h\"\n+#include \"rust-compile-intrinsic.h\"\n #include \"rust-compile-tyty.h\"\n #include \"rust-compile-implitem.h\"\n #include \"rust-compile-var-decl.h\"\n@@ -118,6 +119,15 @@ class CompileExternItem : public HIRCompileBase\n \tfntype->override_context ();\n       }\n \n+    if (fntype->get_abi () == TyTy::FnType::ABI::INTRINSIC)\n+      {\n+\tIntrinsics compile (ctx);\n+\tBfunction *fndecl = compile.compile (fntype);\n+\tctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+\treturn;\n+      }\n+\n+    rust_assert (fntype->get_abi () == TyTy::FnType::ABI::C);\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     const unsigned int flags"}, {"sha": "4068a7a62ddb47795f1e15d90b6cbfe8c201c008", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -0,0 +1,91 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-intrinsic.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n+\n+Bfunction *\n+Intrinsics::compile (TyTy::FnType *fntype)\n+{\n+  rust_assert (fntype->get_abi () == TyTy::FnType::ABI::INTRINSIC);\n+\n+  // https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n+  // https://github.com/Rust-GCC/gccrs/issues/658\n+\n+  //   let llvm_name = match name {\n+  //     sym::sqrtf32 => \"llvm.sqrt.f32\",\n+  //     sym::sqrtf64 => \"llvm.sqrt.f64\",\n+  //     sym::powif32 => \"llvm.powi.f32\",\n+  //     sym::powif64 => \"llvm.powi.f64\",\n+  //     sym::sinf32 => \"llvm.sin.f32\",\n+  //     sym::sinf64 => \"llvm.sin.f64\",\n+  //     sym::cosf32 => \"llvm.cos.f32\",\n+  //     sym::cosf64 => \"llvm.cos.f64\",\n+  //     sym::powf32 => \"llvm.pow.f32\",\n+  //     sym::powf64 => \"llvm.pow.f64\",\n+  //     sym::expf32 => \"llvm.exp.f32\",\n+  //     sym::expf64 => \"llvm.exp.f64\",\n+  //     sym::exp2f32 => \"llvm.exp2.f32\",\n+  //     sym::exp2f64 => \"llvm.exp2.f64\",\n+  //     sym::logf32 => \"llvm.log.f32\",\n+  //     sym::logf64 => \"llvm.log.f64\",\n+  //     sym::log10f32 => \"llvm.log10.f32\",\n+  //     sym::log10f64 => \"llvm.log10.f64\",\n+  //     sym::log2f32 => \"llvm.log2.f32\",\n+  //     sym::log2f64 => \"llvm.log2.f64\",\n+  //     sym::fmaf32 => \"llvm.fma.f32\",\n+  //     sym::fmaf64 => \"llvm.fma.f64\",\n+  //     sym::fabsf32 => \"llvm.fabs.f32\",\n+  //     sym::fabsf64 => \"llvm.fabs.f64\",\n+  //     sym::minnumf32 => \"llvm.minnum.f32\",\n+  //     sym::minnumf64 => \"llvm.minnum.f64\",\n+  //     sym::maxnumf32 => \"llvm.maxnum.f32\",\n+  //     sym::maxnumf64 => \"llvm.maxnum.f64\",\n+  //     sym::copysignf32 => \"llvm.copysign.f32\",\n+  //     sym::copysignf64 => \"llvm.copysign.f64\",\n+  //     sym::floorf32 => \"llvm.floor.f32\",\n+  //     sym::floorf64 => \"llvm.floor.f64\",\n+  //     sym::ceilf32 => \"llvm.ceil.f32\",\n+  //     sym::ceilf64 => \"llvm.ceil.f64\",\n+  //     sym::truncf32 => \"llvm.trunc.f32\",\n+  //     sym::truncf64 => \"llvm.trunc.f64\",\n+  //     sym::rintf32 => \"llvm.rint.f32\",\n+  //     sym::rintf64 => \"llvm.rint.f64\",\n+  //     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+  //     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+  //     sym::roundf32 => \"llvm.round.f32\",\n+  //     sym::roundf64 => \"llvm.round.f64\",\n+  //     _ => return None,\n+  // };\n+  // Some(cx.get_intrinsic(&llvm_name))\n+\n+  Bfunction *builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n+    fntype->get_identifier ());\n+  if (builtin != nullptr)\n+    return builtin;\n+\n+  Location locus = ctx->get_mappings ()->lookup_location (fntype->get_ref ());\n+  rust_error_at (locus, \"unknown builtin\");\n+\n+  return ctx->get_backend ()->error_function ();\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "25e298aa57b813e9198991e1b664d6fda83fa1d6", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -0,0 +1,39 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_COMPILE_INTRINSIC\n+#define RUST_COMPILE_INTRINSIC\n+\n+#include \"rust-compile-context.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+class Intrinsics\n+{\n+public:\n+  Intrinsics (Context *ctx);\n+\n+  Bfunction *compile (TyTy::FnType *fntype);\n+\n+private:\n+  Context *ctx;\n+};\n+\n+} // namespace Compile\n+} // namespace Rust\n+\n+#endif // RUST_COMPILE_INTRINSIC"}, {"sha": "105b2eae2880a0bbae1b4fc3afe413ae73e715e9", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -842,7 +842,9 @@ class Backend\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n-  virtual Bfunction *lookup_builtin (const std::string &) = 0;\n+  virtual Bfunction *lookup_gcc_builtin (const std::string &) = 0;\n+\n+  virtual Bfunction *lookup_builtin_by_rust_name (const std::string &) = 0;\n \n   // Utility.\n "}, {"sha": "4c1dda8d9ce1bfab3b758d7848728e6ec8941b6a", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 226, "deletions": 282, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -512,7 +512,9 @@ class Gcc_backend : public Backend\n \n   bool function_set_body (Bfunction *function, Bstatement *code_stmt);\n \n-  Bfunction *lookup_builtin (const std::string &);\n+  Bfunction *lookup_gcc_builtin (const std::string &);\n+\n+  Bfunction *lookup_builtin_by_rust_name (const std::string &);\n \n   void write_global_definitions (const std::vector<Btype *> &,\n \t\t\t\t const std::vector<Bexpression *> &,\n@@ -546,11 +548,13 @@ class Gcc_backend : public Backend\n   static const int builtin_noreturn = 1 << 1;\n   static const int builtin_novops = 1 << 2;\n \n-  void define_builtin (built_in_function bcode, const char *name,\n-\t\t       const char *libname, tree fntype, int flags);\n+  void define_builtin (const std::string rust_name, built_in_function bcode,\n+\t\t       const char *name, const char *libname, tree fntype,\n+\t\t       int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n   std::map<std::string, Bfunction *> builtin_functions_;\n+  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n // A helper function to create a GCC identifier from a C++ string.\n@@ -567,303 +571,230 @@ Gcc_backend::Gcc_backend ()\n {\n   /* We need to define the fetch_and_add functions, since we use them\n      for ++ and --.  */\n-  tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n-  tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n-  p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n-  p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n-  p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n-  this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\",\n-\t\t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n-\n-  // We use __builtin_expect for magic import functions.\n-  this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n-\t\t\tbuild_function_type_list (long_integer_type_node,\n-\t\t\t\t\t\t  long_integer_type_node,\n-\t\t\t\t\t\t  long_integer_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-\n-  // We use __builtin_memcmp for struct comparisons.\n-  this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t  size_type_node, NULL_TREE),\n-\t\t\t0);\n-\n-  // We use __builtin_memmove for copying data.\n-  this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n-\t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t  size_type_node, NULL_TREE),\n-\t\t\t0);\n-\n-  // We use __builtin_memset for zeroing data.\n-  this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n-\t\t\tbuild_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t\t\t  integer_type_node,\n-\t\t\t\t\t\t  size_type_node, NULL_TREE),\n-\t\t\t0);\n-\n-  // Used by runtime/internal/sys and math/bits.\n-  this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  long_long_unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  long_long_unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n-\t\t\t\"popcountll\",\n-\t\t\tbuild_function_type_list (integer_type_node,\n-\t\t\t\t\t\t  long_long_unsigned_type_node,\n-\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n-\t\t\tbuild_function_type_list (uint16_type_node,\n-\t\t\t\t\t\t  uint16_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n-\t\t\tbuild_function_type_list (uint32_type_node,\n-\t\t\t\t\t\t  uint32_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n-\t\t\tbuild_function_type_list (uint64_type_node,\n-\t\t\t\t\t\t  uint64_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n+  // tree t = this->integer_type (true, BITS_PER_UNIT)->get_tree ();\n+  // tree p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_1,\n+  // \"__sync_fetch_and_add_1\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 2)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_2,\n+  // \"__sync_fetch_and_add_2\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 4)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_4,\n+  // \"__sync_fetch_and_add_4\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // t = this->integer_type (true, BITS_PER_UNIT * 8)->get_tree ();\n+  // p = build_pointer_type (build_qualified_type (t, TYPE_QUAL_VOLATILE));\n+  // this->define_builtin (BUILT_IN_SYNC_ADD_AND_FETCH_8,\n+  // \"__sync_fetch_and_add_8\",\n+  //       \t\tNULL, build_function_type_list (t, p, t, NULL_TREE), 0);\n+\n+  // // We use __builtin_expect for magic import functions.\n+  // this->define_builtin (BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n+  //       \t\tbuild_function_type_list (long_integer_type_node,\n+  //       \t\t\t\t\t  long_integer_type_node,\n+  //       \t\t\t\t\t  long_integer_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+\n+  // // We use __builtin_memcmp for struct comparisons.\n+  // this->define_builtin (BUILT_IN_MEMCMP, \"__builtin_memcmp\", \"memcmp\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // We use __builtin_memmove for copying data.\n+  // this->define_builtin (BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n+  //       \t\tbuild_function_type_list (void_type_node, ptr_type_node,\n+  //       \t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // We use __builtin_memset for zeroing data.\n+  // this->define_builtin (BUILT_IN_MEMSET, \"__builtin_memset\", \"memset\",\n+  //       \t\tbuild_function_type_list (void_type_node, ptr_type_node,\n+  //       \t\t\t\t\t  integer_type_node,\n+  //       \t\t\t\t\t  size_type_node, NULL_TREE),\n+  //       \t\t0);\n+\n+  // // Used by runtime/internal/sys and math/bits.\n+  // this->define_builtin (BUILT_IN_CTZ, \"__builtin_ctz\", \"ctz\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CTZLL, \"__builtin_ctzll\", \"ctzll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CLZ, \"__builtin_clz\", \"clz\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_CLZLL, \"__builtin_clzll\", \"clzll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_POPCOUNT, \"__builtin_popcount\", \"popcount\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_POPCOUNTLL, \"__builtin_popcountll\",\n+  //       \t\t\"popcountll\",\n+  //       \t\tbuild_function_type_list (integer_type_node,\n+  //       \t\t\t\t\t  long_long_unsigned_type_node,\n+  //       \t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP16, \"__builtin_bswap16\", \"bswap16\",\n+  //       \t\tbuild_function_type_list (uint16_type_node,\n+  //       \t\t\t\t\t  uint16_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP32, \"__builtin_bswap32\", \"bswap32\",\n+  //       \t\tbuild_function_type_list (uint32_type_node,\n+  //       \t\t\t\t\t  uint32_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n+  // this->define_builtin (BUILT_IN_BSWAP64, \"__builtin_bswap64\", \"bswap64\",\n+  //       \t\tbuild_function_type_list (uint64_type_node,\n+  //       \t\t\t\t\t  uint64_type_node, NULL_TREE),\n+  //       \t\tbuiltin_const);\n \n   // We provide some functions for the math library.\n-  tree math_function_type\n-    = build_function_type_list (double_type_node, double_type_node, NULL_TREE);\n-  tree math_function_type_long\n-    = build_function_type_list (long_double_type_node, long_double_type_node,\n-\t\t\t\tNULL_TREE);\n-  tree math_function_type_two\n-    = build_function_type_list (double_type_node, double_type_node,\n-\t\t\t\tdouble_type_node, NULL_TREE);\n-  tree math_function_type_long_two\n-    = build_function_type_list (long_double_type_node, long_double_type_node,\n-\t\t\t\tlong_double_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ACOS, \"__builtin_acos\", \"acos\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_ACOSL, \"__builtin_acosl\", \"acosl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_ASIN, \"__builtin_asin\", \"asin\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_ASINL, \"__builtin_asinl\", \"asinl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_ATAN, \"__builtin_atan\", \"atan\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_ATANL, \"__builtin_atanl\", \"atanl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_ATAN2, \"__builtin_atan2\", \"atan2\",\n-\t\t\tmath_function_type_two, builtin_const);\n-  this->define_builtin (BUILT_IN_ATAN2L, \"__builtin_atan2l\", \"atan2l\",\n-\t\t\tmath_function_type_long_two, builtin_const);\n-  this->define_builtin (BUILT_IN_CEIL, \"__builtin_ceil\", \"ceil\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_CEILL, \"__builtin_ceill\", \"ceill\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_COS, \"__builtin_cos\", \"cos\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_COSL, \"__builtin_cosl\", \"cosl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_EXP, \"__builtin_exp\", \"exp\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_EXPL, \"__builtin_expl\", \"expl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_EXPM1, \"__builtin_expm1\", \"expm1\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_EXPM1L, \"__builtin_expm1l\", \"expm1l\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_FABS, \"__builtin_fabs\", \"fabs\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_FABSL, \"__builtin_fabsl\", \"fabsl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_FLOOR, \"__builtin_floor\", \"floor\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_FLOORL, \"__builtin_floorl\", \"floorl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_FMOD, \"__builtin_fmod\", \"fmod\",\n-\t\t\tmath_function_type_two, builtin_const);\n-  this->define_builtin (BUILT_IN_FMODL, \"__builtin_fmodl\", \"fmodl\",\n-\t\t\tmath_function_type_long_two, builtin_const);\n-  this->define_builtin (BUILT_IN_LDEXP, \"__builtin_ldexp\", \"ldexp\",\n-\t\t\tbuild_function_type_list (double_type_node,\n-\t\t\t\t\t\t  double_type_node,\n-\t\t\t\t\t\t  integer_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_LDEXPL, \"__builtin_ldexpl\", \"ldexpl\",\n-\t\t\tbuild_function_type_list (long_double_type_node,\n-\t\t\t\t\t\t  long_double_type_node,\n-\t\t\t\t\t\t  integer_type_node, NULL_TREE),\n-\t\t\tbuiltin_const);\n-  this->define_builtin (BUILT_IN_LOG, \"__builtin_log\", \"log\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOGL, \"__builtin_logl\", \"logl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG1P, \"__builtin_log1p\", \"log1p\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG1PL, \"__builtin_log1pl\", \"log1pl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG10, \"__builtin_log10\", \"log10\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG10L, \"__builtin_log10l\", \"log10l\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG2, \"__builtin_log2\", \"log2\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_LOG2L, \"__builtin_log2l\", \"log2l\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_SIN, \"__builtin_sin\", \"sin\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_SINL, \"__builtin_sinl\", \"sinl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_TAN, \"__builtin_tan\", \"tan\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_TANL, \"__builtin_tanl\", \"tanl\",\n-\t\t\tmath_function_type_long, builtin_const);\n-  this->define_builtin (BUILT_IN_TRUNC, \"__builtin_trunc\", \"trunc\",\n-\t\t\tmath_function_type, builtin_const);\n-  this->define_builtin (BUILT_IN_TRUNCL, \"__builtin_truncl\", \"truncl\",\n-\t\t\tmath_function_type_long, builtin_const);\n+  tree math_function_type_f32\n+    = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+  this->define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t\tmath_function_type_f32, builtin_const);\n+\n+  this->define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t\tmath_function_type_f32, builtin_const);\n \n   // We use __builtin_return_address in the thunk we build for\n   // functions which call recover, and for runtime.getcallerpc.\n-  t = build_function_type_list (ptr_type_node, unsigned_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\",\n-\t\t\tNULL, t, 0);\n+  // t = build_function_type_list (ptr_type_node, unsigned_type_node,\n+  // NULL_TREE); this->define_builtin (BUILT_IN_RETURN_ADDRESS,\n+  // \"__builtin_return_address\",\n+  //       \t\tNULL, t, 0);\n \n   // The runtime calls __builtin_dwarf_cfa for runtime.getcallersp.\n-  t = build_function_type_list (ptr_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t, 0);\n+  // t = build_function_type_list (ptr_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_DWARF_CFA, \"__builtin_dwarf_cfa\", NULL, t,\n+  // 0);\n \n   // The runtime calls __builtin_extract_return_addr when recording\n   // the address to which a function returns.\n-  this->define_builtin (\n-    BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n-    build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n+  // this->define_builtin (\n+  //   BUILT_IN_EXTRACT_RETURN_ADDR, \"__builtin_extract_return_addr\", NULL,\n+  //   build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE), 0);\n \n   // The compiler uses __builtin_trap for some exception handling\n   // cases.\n-  this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n-\t\t\tbuild_function_type (void_type_node, void_list_node),\n-\t\t\tbuiltin_noreturn);\n+  // this->define_builtin (BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n+  //       \t\tbuild_function_type (void_type_node, void_list_node),\n+  //       \t\tbuiltin_noreturn);\n \n   // The runtime uses __builtin_prefetch.\n-  this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n-\t\t\tbuild_varargs_function_type_list (void_type_node,\n-\t\t\t\t\t\t\t  const_ptr_type_node,\n-\t\t\t\t\t\t\t  NULL_TREE),\n-\t\t\tbuiltin_novops);\n+  // this->define_builtin (BUILT_IN_PREFETCH, \"__builtin_prefetch\", NULL,\n+  //       \t\tbuild_varargs_function_type_list (void_type_node,\n+  //       \t\t\t\t\t\t  const_ptr_type_node,\n+  //       \t\t\t\t\t\t  NULL_TREE),\n+  //       \t\tbuiltin_novops);\n \n   // The compiler uses __builtin_unreachable for cases that cannot\n   // occur.\n-  this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n-\t\t\tbuild_function_type (void_type_node, void_list_node),\n-\t\t\tbuiltin_const | builtin_noreturn);\n+  // this->define_builtin (BUILT_IN_UNREACHABLE, \"__builtin_unreachable\", NULL,\n+  //       \t\tbuild_function_type (void_type_node, void_list_node),\n+  //       \t\tbuiltin_const | builtin_noreturn);\n \n   // We provide some atomic functions.\n-  t = build_function_type_list (uint32_type_node, ptr_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t, 0);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t, 0);\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, uint32_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n-\t\t\t0);\n-\n-  t = build_function_type_list (void_type_node, ptr_type_node, uint64_type_node,\n-\t\t\t\tinteger_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n-\t\t\t0);\n-\n-  t = build_function_type_list (uint32_type_node, ptr_type_node,\n-\t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\", NULL,\n-\t\t\tt, 0);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\", NULL,\n-\t\t\tt, 0);\n-\n-  t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n-\t\t\t\tuint32_type_node, boolean_type_node,\n-\t\t\t\tinteger_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n-\t\t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n-\n-  t = build_function_type_list (boolean_type_node, ptr_type_node, ptr_type_node,\n-\t\t\t\tuint64_type_node, boolean_type_node,\n-\t\t\t\tinteger_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n-\t\t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n-\n-  t = build_function_type_list (uint32_type_node, ptr_type_node,\n-\t\t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n-\t\t\tNULL, t, 0);\n-\n-  t = build_function_type_list (uint64_type_node, ptr_type_node,\n-\t\t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n-\t\t\tNULL, t, 0);\n-\n-  t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n-\t\t\t\tunsigned_char_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n-\t\t\tNULL, t, 0);\n-  this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n-\t\t\tNULL, t, 0);\n-\n-  t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n-\t\t\t\tunsigned_char_type_node, integer_type_node,\n-\t\t\t\tNULL_TREE);\n-  this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\", NULL,\n-\t\t\tt, 0);\n-  this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\", NULL,\n-\t\t\tt, 0);\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_LOAD_4, \"__atomic_load_4\", NULL, t,\n+  // 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_LOAD_8, \"__atomic_load_8\", NULL, t,\n+  // 0);\n+\n+  // t = build_function_type_list (void_type_node, ptr_type_node,\n+  // uint32_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_STORE_4, \"__atomic_store_4\", NULL, t,\n+  //       \t\t0);\n+\n+  // t = build_function_type_list (void_type_node, ptr_type_node,\n+  // uint64_type_node,\n+  //       \t\t\tinteger_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_STORE_8, \"__atomic_store_8\", NULL, t,\n+  //       \t\t0);\n+\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_4, \"__atomic_exchange_4\",\n+  // NULL,\n+  //       \t\tt, 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_EXCHANGE_8, \"__atomic_exchange_8\",\n+  // NULL,\n+  //       \t\tt, 0);\n+\n+  // t = build_function_type_list (boolean_type_node, ptr_type_node,\n+  // ptr_type_node,\n+  //       \t\t\tuint32_type_node, boolean_type_node,\n+  //       \t\t\tinteger_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_4,\n+  //       \t\t\"__atomic_compare_exchange_4\", NULL, t, 0);\n+\n+  // t = build_function_type_list (boolean_type_node, ptr_type_node,\n+  // ptr_type_node,\n+  //       \t\t\tuint64_type_node, boolean_type_node,\n+  //       \t\t\tinteger_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_COMPARE_EXCHANGE_8,\n+  //       \t\t\"__atomic_compare_exchange_8\", NULL, t, 0);\n+\n+  // t = build_function_type_list (uint32_type_node, ptr_type_node,\n+  //       \t\t\tuint32_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_4, \"__atomic_add_fetch_4\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (uint64_type_node, ptr_type_node,\n+  //       \t\t\tuint64_type_node, integer_type_node, NULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_ADD_FETCH_8, \"__atomic_add_fetch_8\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n+  //       \t\t\tunsigned_char_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_AND_FETCH_1, \"__atomic_and_fetch_1\",\n+  //       \t\tNULL, t, 0);\n+  // this->define_builtin (BUILT_IN_ATOMIC_FETCH_AND_1, \"__atomic_fetch_and_1\",\n+  //       \t\tNULL, t, 0);\n+\n+  // t = build_function_type_list (unsigned_char_type_node, ptr_type_node,\n+  //       \t\t\tunsigned_char_type_node, integer_type_node,\n+  //       \t\t\tNULL_TREE);\n+  // this->define_builtin (BUILT_IN_ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\",\n+  // NULL,\n+  //       \t\tt, 0);\n+  // this->define_builtin (BUILT_IN_ATOMIC_FETCH_OR_1, \"__atomic_fetch_or_1\",\n+  // NULL,\n+  //       \t\tt, 0);\n }\n \n // Get an unnamed integer type.\n@@ -3490,13 +3421,23 @@ Gcc_backend::function_set_body (Bfunction *function, Bstatement *code_stmt)\n // Returns NULL if no built-in function by that name exists.\n \n Bfunction *\n-Gcc_backend::lookup_builtin (const std::string &name)\n+Gcc_backend::lookup_gcc_builtin (const std::string &name)\n {\n   if (this->builtin_functions_.count (name) != 0)\n     return this->builtin_functions_[name];\n   return NULL;\n }\n \n+Bfunction *\n+Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n+{\n+  auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+  if (it == rust_intrinsic_to_gcc_builtin.end ())\n+    return NULL;\n+\n+  return lookup_gcc_builtin (it->second);\n+}\n+\n // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n // FUNCTION_DECLS, and VARIABLE_DECLS declared globally, as well as\n // emit early debugging information.\n@@ -3587,7 +3528,8 @@ Gcc_backend::write_export_data (const char *bytes, unsigned int size)\n // NORETURN_P is true if the function has the noreturn attribute.\n \n void\n-Gcc_backend::define_builtin (built_in_function bcode, const char *name,\n+Gcc_backend::define_builtin (const std::string rust_name,\n+\t\t\t     built_in_function bcode, const char *name,\n \t\t\t     const char *libname, tree fntype, int flags)\n {\n   tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n@@ -3612,6 +3554,8 @@ Gcc_backend::define_builtin (built_in_function bcode, const char *name,\n \tDECL_IS_NOVOPS (decl) = 1;\n       this->builtin_functions_[libname] = this->make_function (decl);\n     }\n+\n+  rust_intrinsic_to_gcc_builtin[rust_name] = name;\n }\n \n // Return the backend generator."}, {"sha": "b1eb2e39a219a043b137c19aca189f52468b23a5", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -33,9 +33,9 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static void Resolve (HIR::ExternalItem *item)\n+  static void Resolve (HIR::ExternalItem *item, const HIR::ExternBlock &parent)\n   {\n-    TypeCheckTopLevelExternItem resolver;\n+    TypeCheckTopLevelExternItem resolver (parent);\n     item->accept_vis (resolver);\n   }\n \n@@ -115,16 +115,21 @@ class TypeCheckTopLevelExternItem : public TypeCheckBase\n     if (function.is_variadic ())\n       flags |= FNTYPE_IS_VARADIC_FLAG;\n \n-    auto fnType\n-      = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t  function.get_mappings ().get_defid (),\n-\t\t\t  function.get_item_name (), flags, std::move (params),\n-\t\t\t  ret_type, std::move (substitutions));\n+    auto fnType = new TyTy::FnType (\n+      function.get_mappings ().get_hirid (),\n+      function.get_mappings ().get_defid (), function.get_item_name (), flags,\n+      TyTy::FnType::get_abi_from_string (parent.get_abi (),\n+\t\t\t\t\t parent.get_locus ()),\n+      std::move (params), ret_type, std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n private:\n-  TypeCheckTopLevelExternItem () : TypeCheckBase () {}\n+  TypeCheckTopLevelExternItem (const HIR::ExternBlock &parent)\n+    : TypeCheckBase (), parent (parent)\n+  {}\n+\n+  const HIR::ExternBlock &parent;\n };\n \n class TypeCheckTopLevelImplItem : public TypeCheckBase\n@@ -233,11 +238,14 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType = new TyTy::FnType (\n-      function.get_mappings ().get_hirid (),\n-      function.get_mappings ().get_defid (), function.get_function_name (),\n-      function.is_method () ? FNTYPE_IS_METHOD_FLAG : FNTYPE_DEFAULT_FLAGS,\n-      std::move (params), ret_type, std::move (substitutions));\n+    auto fnType\n+      = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t  function.get_function_name (),\n+\t\t\t  function.is_method () ? FNTYPE_IS_METHOD_FLAG\n+\t\t\t\t\t\t: FNTYPE_DEFAULT_FLAGS,\n+\t\t\t  TyTy::FnType::ABI::RUST, std::move (params), ret_type,\n+\t\t\t  std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n "}, {"sha": "54280e800beb4b19fd86f455590992f072e6f17b", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -329,11 +329,12 @@ class TypeCheckStmt : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (), false,\n-\t\t\t\t    std::move (params), ret_type,\n-\t\t\t\t    std::move (substitutions));\n+    auto fnType\n+      = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t  function.get_function_name (), FNTYPE_DEFAULT_FLAGS,\n+\t\t\t  TyTy::FnType::ABI::RUST, std::move (params), ret_type,\n+\t\t\t  std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n \n     TyTy::FnType *resolved_fn_type = fnType;"}, {"sha": "6ec17a9178ca88232d292bfea2c2501b430a4b92", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -287,11 +287,12 @@ class TypeCheckTopLevel : public TypeCheckBase\n \tcontext->insert_type (param.get_mappings (), param_tyty);\n       }\n \n-    auto fnType = new TyTy::FnType (function.get_mappings ().get_hirid (),\n-\t\t\t\t    function.get_mappings ().get_defid (),\n-\t\t\t\t    function.get_function_name (),\n-\t\t\t\t    FNTYPE_DEFAULT_FLAGS, std::move (params),\n-\t\t\t\t    ret_type, std::move (substitutions));\n+    auto fnType\n+      = new TyTy::FnType (function.get_mappings ().get_hirid (),\n+\t\t\t  function.get_mappings ().get_defid (),\n+\t\t\t  function.get_function_name (), FNTYPE_DEFAULT_FLAGS,\n+\t\t\t  TyTy::FnType::ABI::RUST, std::move (params), ret_type,\n+\t\t\t  std::move (substitutions));\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n@@ -337,7 +338,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n   {\n     for (auto &item : extern_block.get_extern_items ())\n       {\n-\tTypeCheckTopLevelExternItem::Resolve (item.get ());\n+\tTypeCheckTopLevelExternItem::Resolve (item.get (), extern_block);\n       }\n   }\n "}, {"sha": "bee27487c42a860ae81c8b25cd99c78eafaad65d", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -546,11 +546,12 @@ TraitItemReference::get_type_from_fn (/*const*/ HIR::TraitItemFunc &fn) const\n       context->insert_type (param.get_mappings (), param_tyty);\n     }\n \n-  auto resolved\n-    = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n-\t\t\tfn.get_mappings ().get_defid (),\n-\t\t\tfunction.get_function_name (), function.is_method (),\n-\t\t\tstd::move (params), ret_type, substitutions);\n+  auto resolved = new TyTy::FnType (\n+    fn.get_mappings ().get_hirid (), fn.get_mappings ().get_defid (),\n+    function.get_function_name (),\n+    function.is_method () ? FNTYPE_IS_METHOD_FLAG : FNTYPE_DEFAULT_FLAGS,\n+    TyTy::FnType::ABI::RUST, std::move (params), ret_type, substitutions);\n+\n   context->insert_type (fn.get_mappings (), resolved);\n   return resolved;\n }"}, {"sha": "316caeac69614cb430feea0598c1be73ae941838", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -882,7 +882,7 @@ FnType::clone () const\n       std::pair<HIR::Pattern *, BaseType *> (p.first, p.second->clone ()));\n \n   return new FnType (get_ref (), get_ty_ref (), get_id (), get_identifier (),\n-\t\t     flags, std::move (cloned_params),\n+\t\t     flags, abi, std::move (cloned_params),\n \t\t     get_return_type ()->clone (), clone_substs (),\n \t\t     get_combined_refs ());\n }"}, {"sha": "7f149a9956a128e1c0c5dbc0e0a3ed6c9de05b6a", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 46, "deletions": 4, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -1071,35 +1071,74 @@ class ADTType : public BaseType, public SubstitutionRef\n class FnType : public BaseType, public SubstitutionRef\n {\n public:\n+  // FIXME these could be constants\n #define FNTYPE_DEFAULT_FLAGS 0x00\n #define FNTYPE_IS_METHOD_FLAG 0x01\n #define FNTYPE_IS_EXTERN_FLAG 0x02\n #define FNTYPE_IS_VARADIC_FLAG 0X04\n \n-  FnType (HirId ref, DefId id, std::string identifier, uint8_t flags,\n+  enum ABI\n+  {\n+    UNKNOWN,\n+    RUST,\n+    INTRINSIC,\n+    C,\n+  };\n+\n+  static ABI get_abi_from_string (const std::string &abi, Location locus)\n+  {\n+    if (abi.compare (\"rust\") == 0)\n+      return ABI::C;\n+    else if (abi.compare (\"rust-intrinsic\") == 0)\n+      return ABI::INTRINSIC;\n+    else if (abi.compare (\"C\") == 0)\n+      return ABI::C;\n+\n+    rust_error_at (locus, \"unknown abi specified\");\n+    return ABI::UNKNOWN;\n+  }\n+\n+  static std::string get_string_from_abi (ABI abi)\n+  {\n+    switch (abi)\n+      {\n+      case ABI::RUST:\n+\treturn \"rust\";\n+      case ABI::INTRINSIC:\n+\treturn \"rust-intrinsic\";\n+      case ABI::C:\n+\treturn \"C\";\n+\n+      case ABI::UNKNOWN:\n+\treturn \"unknown\";\n+      }\n+    return \"unknown\";\n+  }\n+\n+  FnType (HirId ref, DefId id, std::string identifier, uint8_t flags, ABI abi,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::FNDEF, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n       params (std::move (params)), type (type), flags (flags),\n-      identifier (identifier), id (id)\n+      identifier (identifier), id (id), abi (abi)\n   {\n     LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n   }\n \n   FnType (HirId ref, HirId ty_ref, DefId id, std::string identifier,\n-\t  uint8_t flags,\n+\t  uint8_t flags, ABI abi,\n \t  std::vector<std::pair<HIR::Pattern *, BaseType *>> params,\n \t  BaseType *type, std::vector<SubstitutionParamMapping> subst_refs,\n \t  std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::FNDEF, refs),\n       SubstitutionRef (std::move (subst_refs),\n \t\t       SubstitutionArgumentMappings::error ()),\n       params (params), type (type), flags (flags), identifier (identifier),\n-      id (id)\n+      id (id), abi (abi)\n   {\n     LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n@@ -1184,12 +1223,15 @@ class FnType : public BaseType, public SubstitutionRef\n   FnType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n+  ABI get_abi () const { return abi; }\n+\n private:\n   std::vector<std::pair<HIR::Pattern *, BaseType *>> params;\n   BaseType *type;\n   uint8_t flags;\n   std::string identifier;\n   DefId id;\n+  ABI abi;\n };\n \n class FnPtr : public BaseType"}, {"sha": "3c604dfb9e4081fc36ca8b940d20cd6e8e43cac2", "filename": "gcc/testsuite/rust/compile/torture/intrinsics-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f60bd6fe2db6831762e243577515824e2fca5c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fintrinsics-1.rs?ref=55f60bd6fe2db6831762e243577515824e2fca5c", "patch": "@@ -0,0 +1,16 @@\n+// { dg-additional-options -fdump-tree-original }\n+\n+extern \"rust-intrinsic\" {\n+    pub fn sqrtf32(x: f32) -> f32;\n+    pub fn sinf32(x: f32) -> f32;\n+}\n+\n+fn main() {\n+    let mut f32;\n+\n+    f32 = sqrtf32(5f32);\n+    // { dg-final { scan-tree-dump-times {(?n)f32 = __builtin_sqrtf \\(5\\.0e\\+0\\);$} 1 original } }\n+\n+    f32 = sinf32(39f32);\n+    // { dg-final { scan-tree-dump-times {(?n)f32 = __builtin_sinf \\(3\\.9e\\+1\\);$} 1 original } }\n+}"}]}