{"sha": "d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRmMGYyMDU1YmYwOGI4NzQzMTY1Y2U1ZGUxYzQ0Nzk3YjYzZjNlYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-12-22T20:08:39Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-12-22T20:08:39Z"}, "message": "re PR c++/25364 (ICE with function pointer as template parameter)\n\n\tPR c++/25364\n\t* typeck.c (build_unary_op): Pass DECLs not names to\n\tbuild_offset_refs.\n\t* init.c (build_offset_ref): Do not do name lookup.  Do not call\n\tmark_used.\n\t* call.c (build_call): Simplify and tidy.\n\t* semantics.c (finish_qualified_id_expr): Call mark_used.\n\tPR c++/25364\n\t* g++.dg/template/call4.C: New test.\n\nFrom-SVN: r108973", "tree": {"sha": "1c84532597b27832609a1b150445d869ef301367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c84532597b27832609a1b150445d869ef301367"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/comments", "author": null, "committer": null, "parents": [{"sha": "57decb7e538606d06f06bc61f7841df2b3c88f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57decb7e538606d06f06bc61f7841df2b3c88f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57decb7e538606d06f06bc61f7841df2b3c88f03"}], "stats": {"total": 212, "additions": 82, "deletions": 130}, "files": [{"sha": "705edbb57576b893931f0233518ffb679b4568be", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -1,3 +1,13 @@\n+2005-12-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25364\n+\t* typeck.c (build_unary_op): Pass DECLs not names to\n+\tbuild_offset_refs.\n+\t* init.c (build_offset_ref): Do not do name lookup.  Do not call\n+\tmark_used.\n+\t* call.c (build_call): Simplify and tidy.\n+\t* semantics.c (finish_qualified_id_expr): Call mark_used.\n+\n 2005-12-22  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/23333"}, {"sha": "f34124085f8bc117749e1ff28be7c71939ecac37", "filename": "gcc/cp/call.c", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -284,18 +284,28 @@ build_call (tree function, tree parms)\n \n   function = build_addr_func (function);\n \n-  if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n-    {\n-      sorry (\"unable to call pointer to member function here\");\n-      return error_mark_node;\n-    }\n-\n+  gcc_assert (TYPE_PTR_P (TREE_TYPE (function)));\n   fntype = TREE_TYPE (TREE_TYPE (function));\n+  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n+\t      || TREE_CODE (fntype) == METHOD_TYPE);\n   result_type = TREE_TYPE (fntype);\n \n   if (TREE_CODE (function) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL)\n-    decl = TREE_OPERAND (function, 0);\n+    {\n+      decl = TREE_OPERAND (function, 0);\n+      if (!TREE_USED (decl))\n+\t{\n+\t  /* We invoke build_call directly for several library\n+\t     functions.  These may have been declared normally if\n+\t     we're building libgcc, so we can't just check\n+\t     DECL_ARTIFICIAL.  */\n+\t  gcc_assert (DECL_ARTIFICIAL (decl)\n+\t\t      || !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)),\n+\t\t\t\t   \"__\", 2));\n+\t  mark_used (decl);\n+\t}\n+    }\n   else\n     decl = NULL_TREE;\n \n@@ -314,17 +324,6 @@ build_call (tree function, tree parms)\n   if (decl && DECL_CONSTRUCTOR_P (decl))\n     is_constructor = 1;\n \n-  if (decl && ! TREE_USED (decl))\n-    {\n-      /* We invoke build_call directly for several library functions.\n-\t These may have been declared normally if we're building libgcc,\n-\t so we can't just check DECL_ARTIFICIAL.  */\n-      gcc_assert (DECL_ARTIFICIAL (decl)\n-\t\t  || !strncmp (IDENTIFIER_POINTER (DECL_NAME (decl)),\n-\t\t\t       \"__\", 2));\n-      mark_used (decl);\n-    }\n-\n   /* Don't pass empty class objects by value.  This is useful\n      for tags in STL, which are used to control overload resolution.\n      We don't need to handle other cases of copying empty classes.  */"}, {"sha": "54b8a08ef7f90246f7d05af0b56153b49c4f282e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 17, "deletions": 110, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -1332,149 +1332,57 @@ get_type_value (tree name)\n    @@ This function should be rewritten and placed in search.c.  */\n \n tree\n-build_offset_ref (tree type, tree name, bool address_p)\n+build_offset_ref (tree type, tree member, bool address_p)\n {\n   tree decl;\n-  tree member;\n   tree basebinfo = NULL_TREE;\n-  tree orig_name = name;\n \n   /* class templates can come in as TEMPLATE_DECLs here.  */\n-  if (TREE_CODE (name) == TEMPLATE_DECL)\n-    return name;\n+  if (TREE_CODE (member) == TEMPLATE_DECL)\n+    return member;\n \n-  if (dependent_type_p (type) || type_dependent_expression_p (name))\n-    return build_qualified_name (NULL_TREE, type, name, \n+  if (dependent_type_p (type) || type_dependent_expression_p (member))\n+    return build_qualified_name (NULL_TREE, type, member, \n \t\t\t\t /*template_p=*/false);\n \n-  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-    {\n-      /* If the NAME is a TEMPLATE_ID_EXPR, we are looking at\n-\t something like `a.template f<int>' or the like.  For the most\n-\t part, we treat this just like a.f.  We do remember, however,\n-\t the template-id that was used.  */\n-      name = TREE_OPERAND (orig_name, 0);\n-\n-      if (DECL_P (name))\n-\tname = DECL_NAME (name);\n-      else\n-\t{\n-\t  if (TREE_CODE (name) == COMPONENT_REF)\n-\t    name = TREE_OPERAND (name, 1);\n-\t  if (TREE_CODE (name) == OVERLOAD)\n-\t    name = DECL_NAME (OVL_CURRENT (name));\n-\t}\n-\n-      gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-    }\n-\n-  if (type == NULL_TREE)\n-    return error_mark_node;\n-\n-  /* Handle namespace names fully here.  */\n-  if (TREE_CODE (type) == NAMESPACE_DECL)\n-    {\n-      tree t = lookup_namespace_name (type, name);\n-      if (t == error_mark_node)\n-\treturn t;\n-      if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n-\t/* Reconstruct the TEMPLATE_ID_EXPR.  */\n-\tt = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t),\n-\t\t    t, TREE_OPERAND (orig_name, 1));\n-      if (! type_unknown_p (t))\n-\t{\n-\t  mark_used (t);\n-\t  t = convert_from_reference (t);\n-\t}\n-      return t;\n-    }\n-\n+  gcc_assert (TYPE_P (type));\n   if (! is_aggr_type (type, 1))\n     return error_mark_node;\n \n-  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-    {\n-      if (! check_dtor_name (type, name))\n-\terror (\"qualified type %qT does not match destructor name %<~%T%>\",\n-\t\t  type, TREE_OPERAND (name, 0));\n-      name = dtor_identifier;\n-    }\n+  gcc_assert (DECL_P (member) || BASELINK_P (member));\n+  /* Callers should call mark_used before this point.  */\n+  gcc_assert (!DECL_P (member) || TREE_USED (member));\n \n   if (!COMPLETE_TYPE_P (complete_type (type))\n       && !TYPE_BEING_DEFINED (type))\n     {\n-      error (\"incomplete type %qT does not have member %qD\", type, name);\n-      return error_mark_node;\n-    }\n-\n-  /* Set up BASEBINFO for member lookup.  */\n-  decl = maybe_dummy_object (type, &basebinfo);\n-\n-  if (BASELINK_P (name) || DECL_P (name))\n-    member = name;\n-  else\n-    {\n-      member = lookup_member (basebinfo, name, 1, 0);\n-\n-      if (member == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n-  if (!member)\n-    {\n-      error (\"%qD is not a member of type %qT\", name, type);\n+      error (\"incomplete type %qT does not have member %qD\", type, member);\n       return error_mark_node;\n     }\n \n+  /* Entities other than non-static members need no further\n+     processing.  */ \n   if (TREE_CODE (member) == TYPE_DECL)\n-    {\n-      TREE_USED (member) = 1;\n-      return member;\n-    }\n-  /* static class members and class-specific enum\n-     values can be returned without further ado.  */\n+    return member;\n   if (TREE_CODE (member) == VAR_DECL || TREE_CODE (member) == CONST_DECL)\n-    {\n-      mark_used (member);\n-      return convert_from_reference (member);\n-    }\n+    return convert_from_reference (member);\n \n   if (TREE_CODE (member) == FIELD_DECL && DECL_C_BIT_FIELD (member))\n     {\n       error (\"invalid pointer to bit-field %qD\", member);\n       return error_mark_node;\n     }\n \n+  /* Set up BASEBINFO for member lookup.  */\n+  decl = maybe_dummy_object (type, &basebinfo);\n+\n   /* A lot of this logic is now handled in lookup_member.  */\n   if (BASELINK_P (member))\n     {\n       /* Go from the TREE_BASELINK to the member function info.  */\n       tree fnfields = member;\n       tree t = BASELINK_FUNCTIONS (fnfields);\n \n-      if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n-\t{\n-\t  /* The FNFIELDS are going to contain functions that aren't\n-\t     necessarily templates, and templates that don't\n-\t     necessarily match the explicit template parameters.  We\n-\t     save all the functions, and the explicit parameters, and\n-\t     then figure out exactly what to instantiate with what\n-\t     arguments in instantiate_type.  */\n-\n-\t  if (TREE_CODE (t) != OVERLOAD)\n-\t    /* The code in instantiate_type which will process this\n-\t       expects to encounter OVERLOADs, not raw functions.  */\n-\t    t = ovl_cons (t, NULL_TREE);\n-\n-\t  t = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n-\t\t      TREE_OPERAND (orig_name, 1));\n-\t  t = build2 (OFFSET_REF, unknown_type_node, decl, t);\n-\n-\t  PTRMEM_OK_P (t) = 1;\n-\n-\t  return t;\n-\t}\n-\n       if (TREE_CODE (t) != TEMPLATE_ID_EXPR && !really_overloaded_fn (t))\n \t{\n \t  /* Get rid of a potential OVERLOAD around it.  */\n@@ -1494,7 +1402,6 @@ build_offset_ref (tree type, tree name, bool address_p)\n \t  else\n \t    perform_or_defer_access_check (basebinfo, t);\n \n-\t  mark_used (t);\n \t  if (DECL_STATIC_FUNCTION_P (t))\n \t    return t;\n \t  member = t;"}, {"sha": "a200bf4eae0afa2e3a0843460475e596ce9d86aa", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -1508,9 +1508,18 @@ finish_qualified_id_expr (tree qualifying_class,\n \t\t\t  bool template_p,\n \t\t\t  bool template_arg_p)\n {\n+  gcc_assert (TYPE_P (qualifying_class));\n+\n   if (error_operand_p (expr))\n     return error_mark_node;\n \n+  if (DECL_P (expr))\n+    mark_used (expr);\n+  else if (BASELINK_P (expr)\n+\t   && TREE_CODE (BASELINK_FUNCTIONS (expr)) != TEMPLATE_ID_EXPR\n+\t   && !really_overloaded_fn (BASELINK_FUNCTIONS (expr)))\n+    mark_used (OVL_CURRENT (BASELINK_FUNCTIONS (expr)));\n+\n   if (template_p)\n     check_template_keyword (expr);\n "}, {"sha": "827b3e59b0f916c3275ed487d23f8540c1789e6d", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -4117,10 +4117,11 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t     is used here to remove this const from the diagnostics\n \t     and the created OFFSET_REF.  */\n \t  tree base = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (arg, 0)));\n-\t  tree name = DECL_NAME (get_first_fn (TREE_OPERAND (arg, 1)));\n+\t  tree fn = get_first_fn (TREE_OPERAND (arg, 1));\n \n \t  if (! flag_ms_extensions)\n \t    {\n+\t      tree name = DECL_NAME (fn);\n \t      if (current_class_type\n \t\t  && TREE_OPERAND (arg, 0) == current_class_ref)\n \t\t/* An expression like &memfn.  */\n@@ -4134,7 +4135,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\t\t \"  Say %<&%T::%D%>\",\n \t\t\t base, name);\n \t    }\n-\t  arg = build_offset_ref (base, name, /*address_p=*/true);\n+\t  arg = build_offset_ref (base, fn, /*address_p=*/true);\n \t}\n \n     offset_ref:"}, {"sha": "dcf9b71c928eceef76bd8f2ac0594648e1f49b15", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -1,3 +1,8 @@\n+2005-12-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25364\n+\t* g++.dg/template/call4.C: New test.\n+\n 2005-12-22  Dale Johannesen  <dalej@apple.com>\n \n \t* gcc.target/i386/sse-17.c:  New."}, {"sha": "1f7eb4c8208de5afe056e19766b6e922b58c66ed", "filename": "gcc/testsuite/g++.dg/template/call4.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcall4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4f0f2055bf08b8743165ce5de1c44797b63f3eb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcall4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcall4.C?ref=d4f0f2055bf08b8743165ce5de1c44797b63f3eb", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/25364\n+\n+class OFX_PropertySuiteV1\n+{\n+  static int propGetDouble ();\n+};\n+template<int dimension,\n+\t class T,\n+\t int (*PROPGET)()\n+  >\n+struct OFX_AnimatedNumberParam\n+{\n+  virtual int paramSetValueAtTime()\n+  {\n+    return PROPGET();\n+  }\n+};\n+void  f()\n+{\n+  new OFX_AnimatedNumberParam<2,double,OFX_PropertySuiteV1::propGetDouble>();\n+}"}]}