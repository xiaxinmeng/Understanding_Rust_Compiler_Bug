{"sha": "686c82b505d95d57302821df084c751b9528cea7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2YzgyYjUwNWQ5NWQ1NzMwMjgyMWRmMDg0Yzc1MWI5NTI4Y2VhNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-02-13T21:12:34Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-02-13T21:12:34Z"}, "message": "re PR fortran/36703 (ICE  (segfault) in reduce_binary0  (arith.c:1778))\n\n2009-02-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/36703\n\tPR fortran/36528\n\t* trans-expr.c (gfc_conv_function_val): Stabilize Cray-pointer\n\tfunction references to ensure that a valid expression is used.\n\t(gfc_conv_function_call): Pass Cray pointers to procedures.\n\n2009-02-13  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/36528\n\t* gfortran.dg/cray_pointers_8.f90: New test.\n\n\tPR fortran/36703\n\t* gfortran.dg/cray_pointers_9.f90: New test.\n\nFrom-SVN: r144164", "tree": {"sha": "b79c353c31da81b90682656be869db0f4b431def", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b79c353c31da81b90682656be869db0f4b431def"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/686c82b505d95d57302821df084c751b9528cea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686c82b505d95d57302821df084c751b9528cea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686c82b505d95d57302821df084c751b9528cea7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686c82b505d95d57302821df084c751b9528cea7/comments", "author": null, "committer": null, "parents": [{"sha": "da964feac45702899e5e8cfffb0d78bdb5759b80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da964feac45702899e5e8cfffb0d78bdb5759b80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da964feac45702899e5e8cfffb0d78bdb5759b80"}], "stats": {"total": 208, "additions": 205, "deletions": 3}, "files": [{"sha": "589db075e1b1f302a6b53a13a43494abe3b940d3", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=686c82b505d95d57302821df084c751b9528cea7", "patch": "@@ -1,3 +1,11 @@\n+2009-02-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/36703\n+\tPR fortran/36528\n+\t* trans-expr.c (gfc_conv_function_val): Stabilize Cray-pointer\n+\tfunction references to ensure that a valid expression is used.\n+\t(gfc_conv_function_call): Pass Cray pointers to procedures.\n+\n 2009-02-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gfortranspec.c (lang_specific_driver): Update copyright notice"}, {"sha": "f0434b2b58ab223948b43a74ed964d4281a319a1", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=686c82b505d95d57302821df084c751b9528cea7", "patch": "@@ -1505,9 +1505,17 @@ gfc_conv_function_val (gfc_se * se, gfc_symbol * sym)\n \tsym->backend_decl = gfc_get_extern_function_decl (sym);\n \n       tmp = sym->backend_decl;\n+\n       if (sym->attr.cray_pointee)\n-\ttmp = convert (build_pointer_type (TREE_TYPE (tmp)),\n-\t\t       gfc_get_symbol_decl (sym->cp_pointer));\n+\t{\n+\t  /* TODO - make the cray pointee a pointer to a procedure,\n+\t     assign the pointer to it and use it for the call.  This\n+\t     will do for now!  */\n+\t  tmp = convert (build_pointer_type (TREE_TYPE (tmp)),\n+\t\t\t gfc_get_symbol_decl (sym->cp_pointer));\n+\t  tmp = gfc_evaluate_now (tmp, &se->pre);\n+\t}\n+\n       if (!POINTER_TYPE_P (TREE_TYPE (tmp)))\n \t{\n \t  gcc_assert (TREE_CODE (tmp) == FUNCTION_DECL);\n@@ -2623,7 +2631,18 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \n \t  if (argss == gfc_ss_terminator)\n             {\n-\t      if (fsym && fsym->attr.value)\n+\t      if (e->expr_type == EXPR_VARIABLE\n+\t\t    && e->symtree->n.sym->attr.cray_pointee\n+\t\t    && fsym && fsym->attr.flavor == FL_PROCEDURE)\n+\t\t{\n+\t\t    /* The Cray pointer needs to be converted to a pointer to\n+\t\t       a type given by the expression.  */\n+\t\t    gfc_conv_expr (&parmse, e);\n+\t\t    type = build_pointer_type (TREE_TYPE (parmse.expr));\n+\t\t    tmp = gfc_get_symbol_decl (e->symtree->n.sym->cp_pointer);\n+\t\t    parmse.expr = convert (type, tmp);\n+\t\t}\n+ \t      else if (fsym && fsym->attr.value)\n \t\t{\n \t\t  if (fsym->ts.type == BT_CHARACTER\n \t\t      && fsym->ts.is_c_interop"}, {"sha": "a0f16507404fa17f34febd07e55f2be067f42697", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=686c82b505d95d57302821df084c751b9528cea7", "patch": "@@ -1,3 +1,11 @@\n+2009-02-13  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/36528\n+\t* gfortran.dg/cray_pointers_8.f90: New test.\n+\n+\tPR fortran/36703\n+\t* gfortran.dg/cray_pointers_9.f90: New test.\n+\n 2009-02-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/39070"}, {"sha": "887c9625ac7bc6b06d8182da8d8b97ede6c8da38", "filename": "gcc/testsuite/gfortran.dg/cray_pointers_8.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_8.f90?ref=686c82b505d95d57302821df084c751b9528cea7", "patch": "@@ -0,0 +1,63 @@\n+! { dg-do run }\n+! { dg-options \"-fcray-pointer\" }\n+!\n+! Test the fix for PR36528 in which the Cray pointer was not passed\n+! correctly to 'euler' so that an undefined reference to fcn was\n+! generated by the linker.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+! from http://groups.google.com/group/comp.lang.fortran/msg/86b65bad78e6af78\n+!\n+real function p1(x)\n+  real, intent(in) :: x\n+  p1 = x\n+end\n+\n+real function euler(xp,xk,dx,f)\n+  real, intent(in) :: xp, xk, dx\n+  interface\n+    real function f(x)\n+      real, intent(in) :: x\n+    end function\n+  end interface\n+  real x, y\n+  y = 0.0\n+  x = xp\n+  do while (x .le. xk)\n+    y = y + f(x)*dx\n+    x = x + dx\n+  end do\n+  euler = y\n+end\n+program main\n+  interface\n+    real function p1 (x)\n+      real, intent(in) :: x\n+    end function\n+    real function fcn (x)\n+      real, intent(in) :: x\n+    end function\n+    real function euler (xp,xk,dx,f)\n+      real, intent(in) :: xp, xk ,dx\n+      interface\n+        real function f(x)\n+          real, intent(in) :: x\n+        end function\n+      end interface\n+    end function\n+  end interface\n+  real x, xp, xk, dx, y, z\n+  pointer (pfcn, fcn)\n+  pfcn = loc(p1)\n+  xp = 0.0\n+  xk = 1.0\n+  dx = 0.0005\n+  y = 0.0\n+  x = xp\n+  do while (x .le. xk)\n+    y = y + fcn(x)*dx\n+    x = x + dx\n+  end do\n+  z = euler(0.0,1.0,0.0005,fcn)\n+  if (abs (y - z) .gt. 1e-6) call abort\n+end"}, {"sha": "81bcb199a1ef1dd59be5814a93277df62900318a", "filename": "gcc/testsuite/gfortran.dg/cray_pointers_9.f90", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/686c82b505d95d57302821df084c751b9528cea7/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcray_pointers_9.f90?ref=686c82b505d95d57302821df084c751b9528cea7", "patch": "@@ -0,0 +1,104 @@\n+! { dg-do compile }\n+! { dg-options \"-fcray-pointer\" }\n+!\n+! Test the fix for PR36703 in which the Cray pointer was not passed\n+! correctly so that the call to 'fun' at line 102 caused an ICE.\n+!\n+! Contributed by James van Buskirk on com.lang.fortran\n+! http://groups.google.com/group/comp.lang.fortran/msg/b600c081a3654936\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+!\n+module funcs\n+   use ISO_C_BINDING           ! Added this USE statement\n+   implicit none\n+! Interface block for function program fptr will invoke\n+! to get the C_FUNPTR\n+   interface\n+      function get_proc(mess) bind(C,name='BlAh')\n+         use ISO_C_BINDING\n+         implicit none\n+         character(kind=C_CHAR) mess(*)\n+         type(C_FUNPTR) get_proc\n+      end function get_proc\n+   end interface\n+end module funcs\n+\n+module other_fun\n+   use ISO_C_BINDING\n+   implicit none\n+   private\n+! Message to be returned by procedure pointed to\n+! by the C_FUNPTR\n+   character, allocatable, save :: my_message(:)\n+! Interface block for the procedure pointed to\n+! by the C_FUNPTR\n+   public abstract_fun\n+   abstract interface\n+      function abstract_fun(x)\n+         use ISO_C_BINDING\n+         import my_message\n+         implicit none\n+         integer(C_INT) x(:)\n+         character(size(my_message),C_CHAR) abstract_fun(size(x))\n+      end function abstract_fun\n+   end interface\n+   contains\n+! Procedure to store the message and get the C_FUNPTR\n+      function gp(message) bind(C,name='BlAh')\n+         character(kind=C_CHAR) message(*)\n+         type(C_FUNPTR) gp\n+         integer(C_INT64_T) i\n+\n+         i = 1\n+         do while(message(i) /= C_NULL_CHAR)\n+            i = i+1\n+         end do\n+\t allocate (my_message(i+1))      ! Added this allocation\n+         my_message = message(int(1,kind(i)):i-1)\n+         gp = get_funloc(make_mess,aux)\n+      end function gp\n+\n+! Intermediate procedure to pass the function and get\n+! back the C_FUNPTR\n+      function get_funloc(x,y)\n+         procedure(abstract_fun) x\n+         type(C_FUNPTR) y\n+         external y\n+         type(C_FUNPTR) get_funloc\n+\n+         get_funloc = y(x)\n+      end function get_funloc\n+\n+! Procedure to convert the function to C_FUNPTR\n+      function aux(x)\n+         interface\n+            subroutine x() bind(C)\n+            end subroutine x\n+         end interface\n+         type(C_FUNPTR) aux\n+\n+         aux = C_FUNLOC(x)\n+      end function aux\n+\n+! Procedure pointed to by the C_FUNPTR\n+      function make_mess(x)\n+         integer(C_INT) x(:)\n+         character(size(my_message),C_CHAR) make_mess(size(x))\n+\n+         make_mess = transfer(my_message,make_mess(1))\n+      end function make_mess\n+end module other_fun\n+\n+program fptr\n+   use funcs\n+   use other_fun\n+   implicit none\n+   procedure(abstract_fun) fun        ! Removed INTERFACE\n+   pointer(p,fun)\n+   type(C_FUNPTR) fp\n+\n+   fp = get_proc('Hello, world'//achar(0))\n+   p = transfer(fp,p)\n+   write(*,'(a)') fun([1,2,3])\n+end program fptr\n+! { dg-final { cleanup-modules \"funcs other_fun\" } }"}]}