{"sha": "5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE1ZmU5MTc1ZWVjMzFiYzljY2UzODJlOGM3Yjk2MWZkNGNmYTFhMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-12-20T07:58:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-12-20T07:58:02Z"}, "message": "re PR target/88547 (missed optimization for vector comparisons)\n\n\tPR target/88547\n\t* config/i386/i386.c (ix86_expand_sse_movcc): For maskcmp, try to\n\temit vpmovm2? instruction perhaps after knot?.  Reorganize code\n\tso that it doesn't have to test !maskcmp in almost every conditional.\n\n\t* gcc.target/i386/pr88547-1.c: New test.\n\nFrom-SVN: r267293", "tree": {"sha": "ac6125912f09dab2e38e55f8106d6fcdeb903739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac6125912f09dab2e38e55f8106d6fcdeb903739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "59faa32efd1416d7f27ee3798c0c8c94583310de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59faa32efd1416d7f27ee3798c0c8c94583310de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59faa32efd1416d7f27ee3798c0c8c94583310de"}], "stats": {"total": 444, "additions": 328, "deletions": 116}, "files": [{"sha": "1c78d979237837c11fcf2292cf3cf2f19dd884d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "patch": "@@ -1,3 +1,10 @@\n+2018-12-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/88547\n+\t* config/i386/i386.c (ix86_expand_sse_movcc): For maskcmp, try to\n+\temit vpmovm2? instruction perhaps after knot?.  Reorganize code\n+\tso that it doesn't have to test !maskcmp in almost every conditional.\n+\n 2018-12-20  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/sysv4.h (GNU_USER_DYNAMIC_LINKER): Define."}, {"sha": "0ea3bb3a4bce81d1a942053f8c3c49e9d1e145c1", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 199, "deletions": 116, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "patch": "@@ -23593,33 +23593,117 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n       cmp = gen_rtx_SUBREG (mode, cmp, 0);\n     }\n \n-  if (vector_all_ones_operand (op_true, mode)\n-      && rtx_equal_p (op_false, CONST0_RTX (mode))\n-      && !maskcmp)\n+  if (maskcmp)\n+    {\n+      rtx (*gen) (rtx, rtx) = NULL;\n+      if ((op_true == CONST0_RTX (mode)\n+\t   && vector_all_ones_operand (op_false, mode))\n+\t  || (op_false == CONST0_RTX (mode)\n+\t      && vector_all_ones_operand (op_true, mode)))\n+\tswitch (mode)\n+\t  {\n+\t  case E_V64QImode:\n+\t    if (TARGET_AVX512BW)\n+\t      gen = gen_avx512bw_cvtmask2bv64qi;\n+\t    break;\n+\t  case E_V32QImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512BW)\n+\t      gen = gen_avx512vl_cvtmask2bv32qi;\n+\t    break;\n+\t  case E_V16QImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512BW)\n+\t      gen = gen_avx512vl_cvtmask2bv16qi;\n+\t    break;\n+\t  case E_V32HImode:\n+\t    if (TARGET_AVX512BW)\n+\t      gen = gen_avx512bw_cvtmask2wv32hi;\n+\t    break;\n+\t  case E_V16HImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512BW)\n+\t      gen = gen_avx512vl_cvtmask2wv16hi;\n+\t    break;\n+\t  case E_V8HImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512BW)\n+\t      gen = gen_avx512vl_cvtmask2wv8hi;\n+\t    break;\n+\t  case E_V16SImode:\n+\t    if (TARGET_AVX512DQ)\n+\t      gen = gen_avx512f_cvtmask2dv16si;\n+\t    break;\n+\t  case E_V8SImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512DQ)\n+\t      gen = gen_avx512vl_cvtmask2dv8si;\n+\t    break;\n+\t  case E_V4SImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512DQ)\n+\t      gen = gen_avx512vl_cvtmask2dv4si;\n+\t    break;\n+\t  case E_V8DImode:\n+\t    if (TARGET_AVX512DQ)\n+\t      gen = gen_avx512f_cvtmask2qv8di;\n+\t    break;\n+\t  case E_V4DImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512DQ)\n+\t      gen = gen_avx512vl_cvtmask2qv4di;\n+\t    break;\n+\t  case E_V2DImode:\n+\t    if (TARGET_AVX512VL && TARGET_AVX512DQ)\n+\t      gen = gen_avx512vl_cvtmask2qv2di;\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+      if (gen && SCALAR_INT_MODE_P (cmpmode))\n+\t{\n+\t  cmp = force_reg (cmpmode, cmp);\n+\t  if (op_true == CONST0_RTX (mode))\n+\t    {\n+\t      rtx (*gen_not) (rtx, rtx);\n+\t      switch (cmpmode)\n+\t\t{\n+\t\tcase E_QImode: gen_not = gen_knotqi; break;\n+\t\tcase E_HImode: gen_not = gen_knothi; break;\n+\t\tcase E_SImode: gen_not = gen_knotsi; break;\n+\t\tcase E_DImode: gen_not = gen_knotdi; break;\n+\t\tdefault: gcc_unreachable ();\n+\t\t}\n+\t      rtx n = gen_reg_rtx (cmpmode);\n+\t      emit_insn (gen_not (n, cmp));\n+\t      cmp = n;\n+\t    }\n+\t  emit_insn (gen (dest, cmp));\n+\t  return;\n+\t}\n+    }\n+  else if (vector_all_ones_operand (op_true, mode)\n+\t   && op_false == CONST0_RTX (mode))\n     {\n       emit_insn (gen_rtx_SET (dest, cmp));\n+      return;\n     }\n-  else if (op_false == CONST0_RTX (mode) && !maskcmp)\n+  else if (op_false == CONST0_RTX (mode))\n     {\n       op_true = force_reg (mode, op_true);\n       x = gen_rtx_AND (mode, cmp, op_true);\n       emit_insn (gen_rtx_SET (dest, x));\n+      return;\n     }\n-  else if (op_true == CONST0_RTX (mode) && !maskcmp)\n+  else if (op_true == CONST0_RTX (mode))\n     {\n       op_false = force_reg (mode, op_false);\n       x = gen_rtx_NOT (mode, cmp);\n       x = gen_rtx_AND (mode, x, op_false);\n       emit_insn (gen_rtx_SET (dest, x));\n+      return;\n     }\n-  else if (INTEGRAL_MODE_P (mode) && op_true == CONSTM1_RTX (mode)\n-\t   && !maskcmp)\n+  else if (INTEGRAL_MODE_P (mode) && op_true == CONSTM1_RTX (mode))\n     {\n       op_false = force_reg (mode, op_false);\n       x = gen_rtx_IOR (mode, cmp, op_false);\n       emit_insn (gen_rtx_SET (dest, x));\n+      return;\n     }\n-  else if (TARGET_XOP && !maskcmp)\n+  else if (TARGET_XOP)\n     {\n       op_true = force_reg (mode, op_true);\n \n@@ -23629,127 +23713,126 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n       emit_insn (gen_rtx_SET (dest, gen_rtx_IF_THEN_ELSE (mode, cmp,\n \t\t\t\t\t\t\t  op_true,\n \t\t\t\t\t\t\t  op_false)));\n+      return;\n     }\n-  else\n-    {\n-      rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;\n-      rtx d = dest;\n \n-      if (!vector_operand (op_true, mode))\n-\top_true = force_reg (mode, op_true);\n-\n-      op_false = force_reg (mode, op_false);\n-\n-      switch (mode)\n-\t{\n-\tcase E_V4SFmode:\n-\t  if (TARGET_SSE4_1)\n-\t    gen = gen_sse4_1_blendvps;\n-\t  break;\n-\tcase E_V2DFmode:\n-\t  if (TARGET_SSE4_1)\n-\t    gen = gen_sse4_1_blendvpd;\n-\t  break;\n-\tcase E_SFmode:\n-\t  if (TARGET_SSE4_1)\n-\t    {\n-\t      gen = gen_sse4_1_blendvss;\n-\t      op_true = force_reg (mode, op_true);\n-\t    }\n-\t  break;\n-\tcase E_DFmode:\n-\t  if (TARGET_SSE4_1)\n-\t    {\n-\t      gen = gen_sse4_1_blendvsd;\n-\t      op_true = force_reg (mode, op_true);\n-\t    }\n-\t  break;\n-\tcase E_V16QImode:\n-\tcase E_V8HImode:\n-\tcase E_V4SImode:\n-\tcase E_V2DImode:\n-\t  if (TARGET_SSE4_1)\n-\t    {\n-\t      gen = gen_sse4_1_pblendvb;\n-\t      if (mode != V16QImode)\n-\t\td = gen_reg_rtx (V16QImode);\n-\t      op_false = gen_lowpart (V16QImode, op_false);\n-\t      op_true = gen_lowpart (V16QImode, op_true);\n-\t      cmp = gen_lowpart (V16QImode, cmp);\n-\t    }\n-\t  break;\n-\tcase E_V8SFmode:\n-\t  if (TARGET_AVX)\n-\t    gen = gen_avx_blendvps256;\n-\t  break;\n-\tcase E_V4DFmode:\n-\t  if (TARGET_AVX)\n-\t    gen = gen_avx_blendvpd256;\n-\t  break;\n-\tcase E_V32QImode:\n-\tcase E_V16HImode:\n-\tcase E_V8SImode:\n-\tcase E_V4DImode:\n-\t  if (TARGET_AVX2)\n-\t    {\n-\t      gen = gen_avx2_pblendvb;\n-\t      if (mode != V32QImode)\n-\t\td = gen_reg_rtx (V32QImode);\n-\t      op_false = gen_lowpart (V32QImode, op_false);\n-\t      op_true = gen_lowpart (V32QImode, op_true);\n-\t      cmp = gen_lowpart (V32QImode, cmp);\n-\t    }\n-\t  break;\n+  rtx (*gen) (rtx, rtx, rtx, rtx) = NULL;\n+  rtx d = dest;\n \n-\tcase E_V64QImode:\n-\t  gen = gen_avx512bw_blendmv64qi;\n-\t  break;\n-\tcase E_V32HImode:\n-\t  gen = gen_avx512bw_blendmv32hi;\n-\t  break;\n-\tcase E_V16SImode:\n-\t  gen = gen_avx512f_blendmv16si;\n-\t  break;\n-\tcase E_V8DImode:\n-\t  gen = gen_avx512f_blendmv8di;\n-\t  break;\n-\tcase E_V8DFmode:\n-\t  gen = gen_avx512f_blendmv8df;\n-\t  break;\n-\tcase E_V16SFmode:\n-\t  gen = gen_avx512f_blendmv16sf;\n-\t  break;\n+  if (!vector_operand (op_true, mode))\n+    op_true = force_reg (mode, op_true);\n \n-\tdefault:\n-\t  break;\n-\t}\n+  op_false = force_reg (mode, op_false);\n \n-      if (gen != NULL)\n+  switch (mode)\n+    {\n+    case E_V4SFmode:\n+      if (TARGET_SSE4_1)\n+\tgen = gen_sse4_1_blendvps;\n+      break;\n+    case E_V2DFmode:\n+      if (TARGET_SSE4_1)\n+\tgen = gen_sse4_1_blendvpd;\n+      break;\n+    case E_SFmode:\n+      if (TARGET_SSE4_1)\n \t{\n-\t  emit_insn (gen (d, op_false, op_true, cmp));\n-\t  if (d != dest)\n-\t    emit_move_insn (dest, gen_lowpart (GET_MODE (dest), d));\n+\t  gen = gen_sse4_1_blendvss;\n+\t  op_true = force_reg (mode, op_true);\n \t}\n-      else\n+      break;\n+    case E_DFmode:\n+      if (TARGET_SSE4_1)\n \t{\n+\t  gen = gen_sse4_1_blendvsd;\n \t  op_true = force_reg (mode, op_true);\n+\t}\n+      break;\n+    case E_V16QImode:\n+    case E_V8HImode:\n+    case E_V4SImode:\n+    case E_V2DImode:\n+      if (TARGET_SSE4_1)\n+\t{\n+\t  gen = gen_sse4_1_pblendvb;\n+\t  if (mode != V16QImode)\n+\t    d = gen_reg_rtx (V16QImode);\n+\t  op_false = gen_lowpart (V16QImode, op_false);\n+\t  op_true = gen_lowpart (V16QImode, op_true);\n+\t  cmp = gen_lowpart (V16QImode, cmp);\n+\t}\n+      break;\n+    case E_V8SFmode:\n+      if (TARGET_AVX)\n+\tgen = gen_avx_blendvps256;\n+      break;\n+    case E_V4DFmode:\n+      if (TARGET_AVX)\n+\tgen = gen_avx_blendvpd256;\n+      break;\n+    case E_V32QImode:\n+    case E_V16HImode:\n+    case E_V8SImode:\n+    case E_V4DImode:\n+      if (TARGET_AVX2)\n+\t{\n+\t  gen = gen_avx2_pblendvb;\n+\t  if (mode != V32QImode)\n+\t    d = gen_reg_rtx (V32QImode);\n+\t  op_false = gen_lowpart (V32QImode, op_false);\n+\t  op_true = gen_lowpart (V32QImode, op_true);\n+\t  cmp = gen_lowpart (V32QImode, cmp);\n+\t}\n+      break;\n \n-\t  t2 = gen_reg_rtx (mode);\n-\t  if (optimize)\n-\t    t3 = gen_reg_rtx (mode);\n-\t  else\n-\t    t3 = dest;\n+    case E_V64QImode:\n+      gen = gen_avx512bw_blendmv64qi;\n+      break;\n+    case E_V32HImode:\n+      gen = gen_avx512bw_blendmv32hi;\n+      break;\n+    case E_V16SImode:\n+      gen = gen_avx512f_blendmv16si;\n+      break;\n+    case E_V8DImode:\n+      gen = gen_avx512f_blendmv8di;\n+      break;\n+    case E_V8DFmode:\n+      gen = gen_avx512f_blendmv8df;\n+      break;\n+    case E_V16SFmode:\n+      gen = gen_avx512f_blendmv16sf;\n+      break;\n \n-\t  x = gen_rtx_AND (mode, op_true, cmp);\n-\t  emit_insn (gen_rtx_SET (t2, x));\n+    default:\n+      break;\n+    }\n \n-\t  x = gen_rtx_NOT (mode, cmp);\n-\t  x = gen_rtx_AND (mode, x, op_false);\n-\t  emit_insn (gen_rtx_SET (t3, x));\n+  if (gen != NULL)\n+    {\n+      emit_insn (gen (d, op_false, op_true, cmp));\n+      if (d != dest)\n+\temit_move_insn (dest, gen_lowpart (GET_MODE (dest), d));\n+    }\n+  else\n+    {\n+      op_true = force_reg (mode, op_true);\n \n-\t  x = gen_rtx_IOR (mode, t3, t2);\n-\t  emit_insn (gen_rtx_SET (dest, x));\n-\t}\n+      t2 = gen_reg_rtx (mode);\n+      if (optimize)\n+\tt3 = gen_reg_rtx (mode);\n+      else\n+\tt3 = dest;\n+\n+      x = gen_rtx_AND (mode, op_true, cmp);\n+      emit_insn (gen_rtx_SET (t2, x));\n+\n+      x = gen_rtx_NOT (mode, cmp);\n+      x = gen_rtx_AND (mode, x, op_false);\n+      emit_insn (gen_rtx_SET (t3, x));\n+\n+      x = gen_rtx_IOR (mode, t3, t2);\n+      emit_insn (gen_rtx_SET (dest, x));\n     }\n }\n "}, {"sha": "9cd453505045cd4a49a5ad15e43c4ca50d6b66d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "patch": "@@ -1,3 +1,8 @@\n+2018-12-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/88547\n+\t* gcc.target/i386/pr88547-1.c: New test.\n+\n 2018-12-19  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/87992"}, {"sha": "1a248854ccd1d7fc39f883d4e38fd1d757923fa5", "filename": "gcc/testsuite/gcc.target/i386/pr88547-1.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr88547-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr88547-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr88547-1.c?ref=5a5fe9175eec31bc9cce382e8c7b961fd4cfa1a3", "patch": "@@ -0,0 +1,117 @@\n+/* PR target/88547 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -mavx512vl -mavx512bw -mavx512dq\" } */\n+/* { dg-final { scan-assembler-not \"vpternlog\" } } */\n+/* { dg-final { scan-assembler-times \"vpmovm2b\\[\\t  ]\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vpmovm2w\\[\\t  ]\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vpmovm2d\\[\\t  ]\" 4 } } */\n+/* { dg-final { scan-assembler-times \"vpmovm2q\\[\\t  ]\" 4 } } */\n+/* { dg-final { scan-assembler-times \"knotb\\[\\t  ]\" 4 } } */\n+/* { dg-final { scan-assembler-times \"knotw\\[\\t  ]\" 4 } } */\n+/* { dg-final { scan-assembler-times \"knotd\\[\\t  ]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"knotq\\[\\t  ]\" 2 } } */\n+\n+typedef signed char v64qi __attribute__((vector_size(64)));\n+typedef unsigned char v64uqi __attribute__((vector_size(64)));\n+typedef short v32hi __attribute__((vector_size(64)));\n+typedef unsigned short v32uhi __attribute__((vector_size(64)));\n+typedef int v16si __attribute__((vector_size(64)));\n+typedef unsigned v16usi __attribute__((vector_size(64)));\n+typedef long long v8di __attribute__((vector_size(64)));\n+typedef unsigned long long v8udi __attribute__((vector_size(64)));\n+\n+v64qi\n+f1 (v64qi x, v64qi y)\n+{\n+  return x <= y;\n+}\n+\n+v64uqi\n+f2 (v64uqi x, v64uqi y)\n+{\n+  return x <= y;\n+}\n+\n+v64qi\n+f3 (v64qi x, v64qi y)\n+{\n+  return x >= y;\n+}\n+\n+v64uqi\n+f4 (v64uqi x, v64uqi y)\n+{\n+  return x >= y;\n+}\n+\n+v32hi\n+f5 (v32hi x, v32hi y)\n+{\n+  return x <= y;\n+}\n+\n+v32uhi\n+f6 (v32uhi x, v32uhi y)\n+{\n+  return x <= y;\n+}\n+\n+v32hi\n+f7 (v32hi x, v32hi y)\n+{\n+  return x >= y;\n+}\n+\n+v32uhi\n+f8 (v32uhi x, v32uhi y)\n+{\n+  return x >= y;\n+}\n+\n+v16si\n+f9 (v16si x, v16si y)\n+{\n+  return x <= y;\n+}\n+\n+v16usi\n+f10 (v16usi x, v16usi y)\n+{\n+  return x <= y;\n+}\n+\n+v16si\n+f11 (v16si x, v16si y)\n+{\n+  return x >= y;\n+}\n+\n+v16usi\n+f12 (v16usi x, v16usi y)\n+{\n+  return x >= y;\n+}\n+\n+v8di\n+f13 (v8di x, v8di y)\n+{\n+  return x <= y;\n+}\n+\n+v8udi\n+f14 (v8udi x, v8udi y)\n+{\n+  return x <= y;\n+}\n+\n+v8di\n+f15 (v8di x, v8di y)\n+{\n+  return x >= y;\n+}\n+\n+v8udi\n+f16 (v8udi x, v8udi y)\n+{\n+  return x >= y;\n+}"}]}