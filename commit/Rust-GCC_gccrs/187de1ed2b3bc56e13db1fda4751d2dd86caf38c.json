{"sha": "187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTg3ZGUxZWQyYjNiYzU2ZTEzZGIxZmRhNDc1MWQyZGQ4NmNhZjM4Yw==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-10-04T15:08:14Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-10-04T15:08:14Z"}, "message": "re PR fortran/33529 (Non-litteral CHARACTER kind values matching is wrong)\n\n\tPR fortran/33529\n\n\t* decl.c (match_char_kind): New function.\n\t(match_char_spec): Use match_char_kind.\n\n\t* gfortran.dg/char_type_len_2.f90: Adjust error message.\n\t* gfortran.dg/char_decl_2.f90: New test.\n\nFrom-SVN: r129012", "tree": {"sha": "2508d1baf30928452ed3c8ece378720e26818a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2508d1baf30928452ed3c8ece378720e26818a34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e8a67206955a2aa97f77991358c009992b30a95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e8a67206955a2aa97f77991358c009992b30a95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e8a67206955a2aa97f77991358c009992b30a95"}], "stats": {"total": 151, "additions": 102, "deletions": 49}, "files": [{"sha": "488d280f7a69780dd18bb6b1f75d093aa15eeb39", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "patch": "@@ -1,3 +1,9 @@\n+2007-10-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/33529\n+\t* decl.c (match_char_kind): New function.\n+\t(match_char_spec): Use match_char_kind.\n+\n 2007-10-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/33502"}, {"sha": "d0eb0ef4a5ff1d5422dbcca1f82bd2380ccc762d", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 81, "deletions": 46, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "patch": "@@ -1886,20 +1886,80 @@ gfc_match_kind_spec (gfc_typespec *ts, bool kind_expr_only)\n }\n \n \n+static match\n+match_char_kind (int * kind, int * is_iso_c)\n+{\n+  locus where;\n+  gfc_expr *e;\n+  match m, n;\n+  const char *msg;\n+\n+  m = MATCH_NO;\n+  e = NULL;\n+  where = gfc_current_locus;\n+\n+  n = gfc_match_init_expr (&e);\n+  if (n == MATCH_NO)\n+    gfc_error (\"Expected initialization expression at %C\");\n+  if (n != MATCH_YES)\n+    return MATCH_ERROR;\n+\n+  if (e->rank != 0)\n+    {\n+      gfc_error (\"Expected scalar initialization expression at %C\");\n+      m = MATCH_ERROR;\n+      goto no_match;\n+    }\n+\n+  msg = gfc_extract_int (e, kind);\n+  *is_iso_c = e->ts.is_iso_c;\n+  if (msg != NULL)\n+    {\n+      gfc_error (msg);\n+      m = MATCH_ERROR;\n+      goto no_match;\n+    }\n+\n+  gfc_free_expr (e);\n+\n+  /* Ignore errors to this point, if we've gotten here.  This means\n+     we ignore the m=MATCH_ERROR from above.  */\n+  if (gfc_validate_kind (BT_CHARACTER, *kind, true) < 0)\n+    {\n+      gfc_error (\"Kind %d is not supported for CHARACTER at %C\", *kind);\n+      m = MATCH_ERROR;\n+    }\n+  else\n+     /* All tests passed.  */\n+     m = MATCH_YES;\n+\n+  if (m == MATCH_ERROR)\n+     gfc_current_locus = where;\n+  \n+  /* Return what we know from the test(s).  */\n+  return m;\n+\n+no_match:\n+  gfc_free_expr (e);\n+  gfc_current_locus = where;\n+  return m;\n+}\n+\n /* Match the various kind/length specifications in a CHARACTER\n    declaration.  We don't return MATCH_NO.  */\n \n static match\n match_char_spec (gfc_typespec *ts)\n {\n-  int kind, seen_length;\n+  int kind, seen_length, is_iso_c;\n   gfc_charlen *cl;\n   gfc_expr *len;\n   match m;\n-  gfc_expr *kind_expr = NULL;\n-  kind = gfc_default_character_kind;\n+\n   len = NULL;\n   seen_length = 0;\n+  kind = 0;\n+  is_iso_c = 0;\n \n   /* Try the old-style specification first.  */\n   old_char_selector = 0;\n@@ -1923,7 +1983,7 @@ match_char_spec (gfc_typespec *ts)\n   /* Try the weird case:  ( KIND = <int> [ , LEN = <len-param> ] ).  */\n   if (gfc_match (\" kind =\") == MATCH_YES)\n     {\n-      m = gfc_match_small_int_expr(&kind, &kind_expr);\n+      m = match_char_kind (&kind, &is_iso_c);\n        \n       if (m == MATCH_ERROR)\n \tgoto done;\n@@ -1959,13 +2019,8 @@ match_char_spec (gfc_typespec *ts)\n       if (gfc_match (\" , kind =\") != MATCH_YES)\n \tgoto syntax;\n \n-      gfc_match_small_int_expr(&kind, &kind_expr);\n-\n-      if (gfc_validate_kind (BT_CHARACTER, kind, true) < 0)\n-\t{\n-\t  gfc_error (\"Kind %d is not a CHARACTER kind at %C\", kind);\n-\t  return MATCH_YES;\n-\t}\n+      if (match_char_kind (&kind, &is_iso_c) == MATCH_ERROR)\n+\tgoto done;\n \n       goto rparen;\n     }\n@@ -1987,7 +2042,7 @@ match_char_spec (gfc_typespec *ts)\n \n   gfc_match (\" kind =\");\t/* Gobble optional text.  */\n \n-  m = gfc_match_small_int_expr(&kind, &kind_expr);\n+  m = match_char_kind (&kind, &is_iso_c);\n   if (m == MATCH_ERROR)\n     goto done;\n   if (m == MATCH_NO)\n@@ -2006,23 +2061,9 @@ match_char_spec (gfc_typespec *ts)\n   return m;\n \n done:\n-  if (gfc_validate_kind (BT_CHARACTER, kind, true) < 0)\n-    {\n-      gfc_error (\"Kind %d is not a CHARACTER kind at %C\", kind);\n-      m = MATCH_ERROR;\n-    }\n-\n-  if (seen_length == 1 && len != NULL\n-      && len->ts.type != BT_INTEGER && len->ts.type != BT_UNKNOWN)\n-    {\n-      gfc_error (\"Expression at %C must be of INTEGER type\");\n-      m = MATCH_ERROR;\n-    }\n-\n   if (m != MATCH_YES)\n     {\n       gfc_free_expr (len);\n-      gfc_free_expr (kind_expr);\n       return m;\n     }\n \n@@ -2037,30 +2078,24 @@ match_char_spec (gfc_typespec *ts)\n     cl->length = len;\n \n   ts->cl = cl;\n-  ts->kind = kind;\n+  ts->kind = kind == 0 ? gfc_default_character_kind : kind;\n \n   /* We have to know if it was a c interoperable kind so we can\n      do accurate type checking of bind(c) procs, etc.  */\n-  if (kind_expr != NULL)\n-    {\n-      /* Mark this as c interoperable if being declared with one\n-\t of the named constants from iso_c_binding.  */\n-      ts->is_c_interop = kind_expr->ts.is_iso_c;\n-      gfc_free_expr (kind_expr);\n-    }\n+  if (kind != 0)\n+    /* Mark this as c interoperable if being declared with one\n+       of the named constants from iso_c_binding.  */\n+    ts->is_c_interop = is_iso_c;\n   else if (len != NULL)\n-    {\n-      /* Here, we might have parsed something such as:\n-\t character(c_char)\n-\t In this case, the parsing code above grabs the c_char when\n-\t looking for the length (line 1690, roughly).  it's the last\n-\t testcase for parsing the kind params of a character variable.\n-\t However, it's not actually the length.\t this seems like it\n-\t could be an error.  \n-\t To see if the user used a C interop kind, test the expr\n-\t of the so called length, and see if it's C interoperable.  */\n-      ts->is_c_interop = len->ts.is_iso_c;\n-    }\n+    /* Here, we might have parsed something such as: character(c_char)\n+       In this case, the parsing code above grabs the c_char when\n+       looking for the length (line 1690, roughly).  it's the last\n+       testcase for parsing the kind params of a character variable.\n+       However, it's not actually the length.\t this seems like it\n+       could be an error.  \n+       To see if the user used a C interop kind, test the expr\n+       of the so called length, and see if it's C interoperable.  */\n+    ts->is_c_interop = len->ts.is_iso_c;\n   \n   return MATCH_YES;\n }"}, {"sha": "6e5dba07d78317d253e427285150ec14f33c1230", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "patch": "@@ -1,3 +1,9 @@\n+2007-10-04  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/33529\n+\t* gfortran.dg/char_type_len_2.f90: Adjust error message.\n+\t* gfortran.dg/char_decl_2.f90: New test.\n+\n 2007-10-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/33641"}, {"sha": "ffce6b158e26e7532de365d8b84a03002e5c750a", "filename": "gcc/testsuite/gfortran.dg/char_decl_2.f90", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_decl_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_decl_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_decl_2.f90?ref=187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "patch": "@@ -0,0 +1,4 @@\n+! { dg-do run }\n+  character (kind=kind(\"a\")) :: u\n+  if (kind(u) /= kind(\"a\")) call abort\n+  end"}, {"sha": "e4fab80205eb6bc29b887d9f630c99921f297aab", "filename": "gcc/testsuite/gfortran.dg/char_type_len_2.f90", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_type_len_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/187de1ed2b3bc56e13db1fda4751d2dd86caf38c/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_type_len_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_type_len_2.f90?ref=187de1ed2b3bc56e13db1fda4751d2dd86caf38c", "patch": "@@ -2,7 +2,9 @@\n ! PR31251 Non-integer character length leads to segfault\n ! Submitted by Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n   character(len=2.3) :: s ! { dg-error \"must be of INTEGER type\" }\n-  character(kind=1,len=4.3) : t ! { dg-error \"must be of INTEGER type\" }\n-  character(len=,,7.2,kind=1) : u ! { dg-error \"Syntax error in CHARACTER declaration\" }\n-  character(len=7,kind=2) : v ! ! { dg-error \"Kind 2 is not a CHARACTER kind\" }\n+  character(kind=1,len=4.3) :: t ! { dg-error \"must be of INTEGER type\" }\n+  character(len=,,7.2,kind=1) :: u ! { dg-error \"Syntax error in CHARACTER declaration\" }\n+  character(len=7,kind=2) :: v ! ! { dg-error \"Kind 2 is not supported for CHARACTER\" }\n+  character(kind=2) :: w ! ! { dg-error \"Kind 2 is not supported for CHARACTER\" }\n+  character(kind=2,len=7) :: x ! ! { dg-error \"Kind 2 is not supported for CHARACTER\" }\n   end"}]}