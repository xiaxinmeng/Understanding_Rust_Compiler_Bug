{"sha": "d6ed1c8903e728f4233122554bab5910853338bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlZDFjODkwM2U3MjhmNDIzMzEyMjU1NGJhYjU5MTA4NTMzMzhiZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-01-21T17:38:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-01-21T17:38:02Z"}, "message": "re PR c++/46977 ([C++0x] ICE: SIGSEGV in htab_find_slot_with_hash (hashtab.c:650))\n\n\tPR c++/46977\n\t* semantics.c (potential_constant_expression_1): Split out from\n\tpotential_constant_expression.  Add want_rval parm.  Handle\n\ttemplate expression forms.  Don't enforce restriction on address\n\tof automatic variable here.  Add a couple of diagnostics that\n\thad been missing.\n\t(require_potential_constant_expression): New entry point.\n\t(build_data_member_initialization, register_constexpr_fundef): Adjust.\n\t(maybe_constant_value): Check potential_constant_expression.\n\t* pt.c (fold_non_dependent_expr_sfinae): Likewise.\n\t* tree.c (build_vec_init_expr): Adjust.\n\nFrom-SVN: r169096", "tree": {"sha": "95871ccf683cdcd1cc68588d8d01c44cb12a7588", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95871ccf683cdcd1cc68588d8d01c44cb12a7588"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6ed1c8903e728f4233122554bab5910853338bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ed1c8903e728f4233122554bab5910853338bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6ed1c8903e728f4233122554bab5910853338bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6ed1c8903e728f4233122554bab5910853338bd/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e90b336fce3f8e4fe7c65301da0a48da3d9e455c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e90b336fce3f8e4fe7c65301da0a48da3d9e455c"}], "stats": {"total": 244, "additions": 188, "deletions": 56}, "files": [{"sha": "dcf8c49dd701c647e4fab092fc1185a72d82a14a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,3 +1,17 @@\n+2011-01-21  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/46977\n+\t* semantics.c (potential_constant_expression_1): Split out from\n+\tpotential_constant_expression.  Add want_rval parm.  Handle\n+\ttemplate expression forms.  Don't enforce restriction on address\n+\tof automatic variable here.  Add a couple of diagnostics that\n+\thad been missing.\n+\t(require_potential_constant_expression): New entry point.\n+\t(build_data_member_initialization, register_constexpr_fundef): Adjust.\n+\t(maybe_constant_value): Check potential_constant_expression.\n+\t* pt.c (fold_non_dependent_expr_sfinae): Likewise.\n+\t* tree.c (build_vec_init_expr): Adjust.\n+\n 2011-01-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/47303"}, {"sha": "75008260f96c57bb6165a6fe9b0bb18b4f62ae01", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -5245,7 +5245,8 @@ extern tree validate_constexpr_fundecl (tree);\n extern tree register_constexpr_fundef (tree, tree);\n extern bool check_constexpr_ctor_body (tree, tree);\n extern tree ensure_literal_type_for_constexpr_object (tree);\n-extern bool potential_constant_expression (tree, tsubst_flags_t);\n+extern bool potential_constant_expression (tree);\n+extern bool require_potential_constant_expression (tree);\n extern tree cxx_constant_value (tree);\n extern tree maybe_constant_value (tree);\n extern tree maybe_constant_init (tree);"}, {"sha": "7d39e1cb4868a6126f8f8ab149adc0747151c498", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -5159,6 +5159,7 @@ fold_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n      as two declarations of the same function, for example.  */\n   if (processing_template_decl\n       && !type_dependent_expression_p (expr)\n+      && potential_constant_expression (expr)\n       && !value_dependent_expression_p (expr))\n     {\n       HOST_WIDE_INT saved_processing_template_decl;\n@@ -17964,11 +17965,11 @@ dependent_scope_p (tree scope)\n    [temp.dep.constexpr].  EXPRESSION is already known to be a constant\n    expression.  */\n \n-/* FIXME this predicate is not appropriate for general expressions; the\n-   predicates we want instead are \"valid constant expression, value\n-   dependent or not?\", \"really constant expression, not value dependent?\"\n-   and \"instantiation-dependent?\".  Try to integrate with\n-   potential_constant_expression?\n+/* Note that this predicate is not appropriate for general expressions;\n+   only constant expressions (that satisfy potential_constant_expression)\n+   can be tested for value dependence.\n+\n+   We should really also have a predicate for \"instantiation-dependent\".\n \n    fold_non_dependent_expr: fold if constant and not type-dependent and not value-dependent.\n      (what about instantiation-dependent constant-expressions?)"}, {"sha": "23ff27bf9a35616c282ddd20b55c9e81cf1eccd4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 147, "deletions": 47, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -5532,7 +5532,7 @@ build_data_member_initialization (tree t, VEC(constructor_elt,gc) **vec)\n \t  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (member))));\n \t  /* But if the initializer isn't constexpr, leave it in so we\n \t     complain later.  */\n-\t  if (potential_constant_expression (init, tf_none))\n+\t  if (potential_constant_expression (init))\n \t    return true;\n \t}\n     }\n@@ -5658,10 +5658,11 @@ register_constexpr_fundef (tree fun, tree body)\n       body = unshare_expr (TREE_OPERAND (body, 0));\n     }\n \n-  if (!potential_constant_expression (body, (DECL_TEMPLATE_INSTANTIATION (fun)\n-\t\t\t\t\t     ? tf_none : tf_error)))\n+  if (!potential_constant_expression (body))\n     {\n       DECL_DECLARED_CONSTEXPR_P (fun) = false;\n+      if (!DECL_TEMPLATE_INSTANTIATION (fun))\n+\trequire_potential_constant_expression (body);\n       return NULL;\n     }\n   fundef->body = body;\n@@ -7115,8 +7116,7 @@ maybe_constant_value (tree t)\n   tree r;\n \n   if (type_dependent_expression_p (t)\n-      /* FIXME shouldn't check value-dependence first; see comment before\n-\t value_dependent_expression_p.  */\n+      || !potential_constant_expression (t)\n       || value_dependent_expression_p (t))\n     return t;\n \n@@ -7148,6 +7148,8 @@ maybe_constant_init (tree t)\n   return t;\n }\n \n+#if 0\n+/* FIXME see ADDR_EXPR section in potential_constant_expression_1.  */\n /* Return true if the object referred to by REF has automatic or thread\n    local storage.  */\n \n@@ -7170,6 +7172,7 @@ check_automatic_or_tls (tree ref)\n   dk = decl_storage_duration (decl);\n   return (dk == dk_auto || dk == dk_thread) ? ck_bad : ck_ok;\n }\n+#endif\n \n /* Return true if the DECL designates a builtin function that is\n    morally constexpr, in the sense that its parameter types and\n@@ -7197,13 +7200,11 @@ morally_constexpr_builtin_function_p (tree decl)\n   return t != NULL;\n }\n \n-/* Return true if T denotes a constant expression, or potential constant\n-   expression if POTENTIAL is true.\n-   Issue diagnostic as appropriate under control of flags.  Variables\n-   with static storage duration initialized by constant expressions\n-   are guaranteed to be statically initialized.\n+/* Return true if T denotes a potentially constant expression.  Issue\n+   diagnostic as appropriate under control of FLAGS.  If WANT_RVAL is true,\n+   an lvalue-rvalue conversion is implied.\n \n-   C++0x [expr.const]\n+   C++0x [expr.const] used to say\n \n    6 An expression is a potential constant expression if it is\n      a constant expression where all occurences of function\n@@ -7216,13 +7217,23 @@ morally_constexpr_builtin_function_p (tree decl)\n       logical OR (5.15), and conditional (5.16) operations that are\n       not evaluated are not considered.   */\n \n-bool\n-potential_constant_expression (tree t, tsubst_flags_t flags)\n+static bool\n+potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n {\n+  enum { any = false, rval = true };\n   int i;\n   tree tmp;\n+\n+  /* C++98 has different rules for the form of a constant expression that\n+     are enforced in the parser, so we can assume that anything that gets\n+     this far is suitable.  */\n+  if (cxx_dialect < cxx0x)\n+    return true;\n+\n   if (t == error_mark_node)\n     return false;\n+  if (t == NULL_TREE)\n+    return true;\n   if (TREE_THIS_VOLATILE (t))\n     {\n       if (flags & tf_error)\n@@ -7235,8 +7246,18 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n   switch (TREE_CODE (t))\n     {\n     case FUNCTION_DECL:\n+    case BASELINK:\n+    case OVERLOAD:\n+    case TEMPLATE_ID_EXPR:\n     case LABEL_DECL:\n     case CONST_DECL:\n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+    case OFFSETOF_EXPR:\n+    case NOEXCEPT_EXPR:\n+    case TEMPLATE_PARM_INDEX:\n+    case TRAIT_EXPR:\n+    case IDENTIFIER_NODE:\n       return true;\n \n     case PARM_DECL:\n@@ -7261,7 +7282,7 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n         const int nargs = call_expr_nargs (t);\n         if (TREE_CODE (fun) != FUNCTION_DECL)\n           {\n-\t    if (potential_constant_expression (fun, flags))\n+\t    if (potential_constant_expression_1 (fun, rval, flags))\n \t      /* Might end up being a constant function pointer.  */\n \t      return true;\n             if (flags & tf_error)\n@@ -7293,19 +7314,17 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n             if (i == 0 && DECL_NONSTATIC_MEMBER_P (fun)\n                 && !DECL_CONSTRUCTOR_P (fun))\n \t      {\n-\t\tif (TREE_CODE (x) == ADDR_EXPR)\n-\t\t  x = TREE_OPERAND (x, 0);\n \t\tif (is_this_parameter (x))\n \t\t  /* OK.  */;\n-                else if (!potential_constant_expression (x, flags))\n+                else if (!potential_constant_expression_1 (x, rval, flags))\n \t\t  {\n \t\t    if (flags & tf_error)\n \t\t      error (\"object argument is not a potential constant \"\n \t\t\t     \"expression\");\n \t\t    return false;\n \t\t  }\n               }\n-\t    else if (!potential_constant_expression (x, flags))\n+\t    else if (!potential_constant_expression_1 (x, rval, flags))\n \t      {\n \t\tif (flags & tf_error)\n \t\t  error (\"argument in position %qP is not a \"\n@@ -7325,10 +7344,10 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n             -- an lvalue of literal type that refers to non-volatile\n                object defined with constexpr, or that refers to a\n                sub-object of such an object;  */\n-      return potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+      return potential_constant_expression_1 (TREE_OPERAND (t, 0), rval, flags);\n \n     case VAR_DECL:\n-      if (!decl_constant_var_p (t))\n+      if (want_rval && !decl_constant_var_p (t))\n         {\n           if (flags & tf_error)\n             error (\"variable %qD is not declared constexpr\", t);\n@@ -7358,14 +7377,19 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n                      \"cannot yield a constant expression\", from);\n             return false;\n           }\n-        return potential_constant_expression (from, flags);\n+        return (potential_constant_expression_1\n+\t\t(from, TREE_CODE (t) != VIEW_CONVERT_EXPR, flags));\n       }\n \n     case ADDR_EXPR:\n       /* -- a unary operator & that is applied to an lvalue that\n             designates an object with thread or automatic storage\n             duration;  */\n       t = TREE_OPERAND (t, 0);\n+#if 0\n+      /* FIXME adjust when issue 1197 is fully resolved.  For now don't do\n+         any checking here, as we might dereference the pointer later.  If\n+         we remove this code, also remove check_automatic_or_tls.  */\n       i = check_automatic_or_tls (t);\n       if (i == ck_ok)\n \treturn true;\n@@ -7376,23 +7400,31 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n                    \"automatic storage is not a constant expression\", t);\n           return false;\n         }\n-      return potential_constant_expression (t, flags);\n+#endif\n+      return potential_constant_expression_1 (t, any, flags);\n \n     case COMPONENT_REF:\n     case BIT_FIELD_REF:\n+    case ARROW_EXPR:\n+    case OFFSET_REF:\n       /* -- a class member access unless its postfix-expression is\n             of literal type or of pointer to literal type.  */\n       /* This test would be redundant, as it follows from the\n \t postfix-expression being a potential constant expression.  */\n-      return potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+      return potential_constant_expression_1 (TREE_OPERAND (t, 0),\n+\t\t\t\t\t      want_rval, flags);\n+\n+    case EXPR_PACK_EXPANSION:\n+      return potential_constant_expression_1 (PACK_EXPANSION_PATTERN (t),\n+\t\t\t\t\t      want_rval, flags);\n \n     case INDIRECT_REF:\n       {\n         tree x = TREE_OPERAND (t, 0);\n         STRIP_NOPS (x);\n         if (is_this_parameter (x))\n \t  return true;\n-\treturn potential_constant_expression (x, flags);\n+\treturn potential_constant_expression_1 (x, rval, flags);\n       }\n \n     case LAMBDA_EXPR:\n@@ -7417,6 +7449,10 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n     case MUST_NOT_THROW_EXPR:\n     case TRY_CATCH_EXPR:\n     case STATEMENT_LIST:\n+      /* Don't bother trying to define a subset of statement-expressions to\n+\t be constant-expressions, at least for now.  */\n+    case STMT_EXPR:\n+    case EXPR_STMT:\n     case BIND_EXPR:\n       if (flags & tf_error)\n         error (\"expression %qE is not a constant-expression\", t);\n@@ -7427,7 +7463,8 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n             class type;  */\n       {\n         tree e = TREE_OPERAND (t, 0);\n-        if (!TYPE_P (e) && TYPE_POLYMORPHIC_P (TREE_TYPE (e)))\n+        if (!TYPE_P (e) && !type_dependent_expression_p (e)\n+\t    && TYPE_POLYMORPHIC_P (TREE_TYPE (e)))\n           {\n             if (flags & tf_error)\n               error (\"typeid-expression is not a constant expression \"\n@@ -7447,6 +7484,7 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n                    \"a constant expression\");\n           return false;\n         }\n+      want_rval = true;\n       goto binary;\n \n     case LT_EXPR:\n@@ -7465,6 +7503,7 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n                    \"constant expression\");\n           return false;\n         }\n+      want_rval = true;\n       goto binary;\n \n     case REALPART_EXPR:\n@@ -7477,22 +7516,41 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n     case ABS_EXPR:\n     case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n-    case PAREN_EXPR:\n     case FIXED_CONVERT_EXPR:\n+    case UNARY_PLUS_EXPR:\n+      return potential_constant_expression_1 (TREE_OPERAND (t, 0), rval,\n+\t\t\t\t\t      flags);\n+\n+    case CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+      return (potential_constant_expression_1\n+\t      (TREE_OPERAND (t, 0),\n+\t       TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE, flags));\n+\n+    case PAREN_EXPR:\n+    case NON_DEPENDENT_EXPR:\n       /* For convenience.  */\n     case RETURN_EXPR:\n-      return potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+      return potential_constant_expression_1 (TREE_OPERAND (t, 0),\n+\t\t\t\t\t      want_rval, flags);\n+\n+    case SCOPE_REF:\n+      return potential_constant_expression_1 (TREE_OPERAND (t, 1),\n+\t\t\t\t\t      want_rval, flags);\n \n     case INIT_EXPR:\n     case TARGET_EXPR:\n-      return potential_constant_expression (TREE_OPERAND (t, 1), flags);\n+      return potential_constant_expression_1 (TREE_OPERAND (t, 1),\n+\t\t\t\t\t      rval, flags);\n \n     case CONSTRUCTOR:\n       {\n         VEC(constructor_elt, gc) *v = CONSTRUCTOR_ELTS (t);\n         constructor_elt *ce;\n         for (i = 0; VEC_iterate (constructor_elt, v, i, ce); ++i)\n-\t  if (!potential_constant_expression (ce->value, flags))\n+\t  if (!potential_constant_expression_1 (ce->value, want_rval, flags))\n \t    return false;\n \treturn true;\n       }\n@@ -7501,11 +7559,13 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n       {\n \tgcc_assert (TREE_PURPOSE (t) == NULL_TREE\n \t\t    || DECL_P (TREE_PURPOSE (t)));\n-\tif (!potential_constant_expression (TREE_VALUE (t), flags))\n+\tif (!potential_constant_expression_1 (TREE_VALUE (t), want_rval,\n+\t\t\t\t\t      flags))\n \t  return false;\n \tif (TREE_CHAIN (t) == NULL_TREE)\n \t  return true;\n-\treturn potential_constant_expression (TREE_CHAIN (t), flags);\n+\treturn potential_constant_expression_1 (TREE_CHAIN (t), want_rval,\n+\t\t\t\t\t\tflags);\n       }\n \n     case TRUNC_DIV_EXPR:\n@@ -7515,10 +7575,24 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-      if (integer_zerop (maybe_constant_value (TREE_OPERAND (t, 1))))\n-\treturn false;\n-      else\n-\tgoto binary;\n+      {\n+\ttree denom = TREE_OPERAND (t, 1);\n+\t/* We can't call maybe_constant_value on an expression\n+\t   that hasn't been through fold_non_dependent_expr yet.  */\n+\tif (!processing_template_decl)\n+\t  denom = maybe_constant_value (denom);\n+\tif (integer_zerop (denom))\n+\t  {\n+\t    if (flags & tf_error)\n+\t      error (\"division by zero is not a constant-expression\");\n+\t    return false;\n+\t  }\n+\telse\n+\t  {\n+\t    want_rval = true;\n+\t    goto binary;\n+\t  }\n+      }\n \n     case COMPOUND_EXPR:\n       {\n@@ -7530,7 +7604,7 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n \tSTRIP_NOPS (op1);\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n-\t  return potential_constant_expression (op0, flags);\n+\t  return potential_constant_expression_1 (op0, want_rval, flags);\n \telse\n \t  goto binary;\n       }\n@@ -7547,12 +7621,10 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n       tmp = boolean_false_node;\n     truth:\n       if (TREE_OPERAND (t, 0) == tmp)\n-\treturn potential_constant_expression (TREE_OPERAND (t, 1), flags);\n+\treturn potential_constant_expression_1 (TREE_OPERAND (t, 1), rval, flags);\n       else\n-\treturn potential_constant_expression (TREE_OPERAND (t, 0), flags);\n+\treturn potential_constant_expression_1 (TREE_OPERAND (t, 0), rval, flags);\n \n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n     case PLUS_EXPR:\n     case MULT_EXPR:\n     case POINTER_PLUS_EXPR:\n@@ -7574,10 +7646,16 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n     case UNEQ_EXPR:\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n+      want_rval = true;\n+      /* Fall through.  */\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+    case MEMBER_REF:\n+    case DOTSTAR_EXPR:\n     binary:\n       for (i = 0; i < 2; ++i)\n-\tif (!potential_constant_expression (TREE_OPERAND (t, i),\n-\t\t\t\t      flags))\n+\tif (!potential_constant_expression_1 (TREE_OPERAND (t, i),\n+\t\t\t\t\t      want_rval, flags))\n \t  return false;\n       return true;\n \n@@ -7587,21 +7665,28 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n \t care about; otherwise we only require that the condition and\n \t either of the legs be potentially constant.  */\n       tmp = TREE_OPERAND (t, 0);\n-      if (!potential_constant_expression (tmp, flags))\n+      if (!potential_constant_expression_1 (tmp, rval, flags))\n \treturn false;\n       else if (tmp == boolean_true_node)\n-\treturn potential_constant_expression (TREE_OPERAND (t, 1), flags);\n+\treturn potential_constant_expression_1 (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\twant_rval, flags);\n       else if (tmp == boolean_false_node)\n-\treturn potential_constant_expression (TREE_OPERAND (t, 2), flags);\n+\treturn potential_constant_expression_1 (TREE_OPERAND (t, 2),\n+\t\t\t\t\t\twant_rval, flags);\n       for (i = 1; i < 3; ++i)\n-\tif (potential_constant_expression (TREE_OPERAND (t, i), tf_none))\n+\tif (potential_constant_expression_1 (TREE_OPERAND (t, i),\n+\t\t\t\t\t     want_rval, tf_none))\n \t  return true;\n       if (flags & tf_error)\n         error (\"expression %qE is not a constant-expression\", t);\n       return false;\n \n     case VEC_INIT_EXPR:\n-      return VEC_INIT_EXPR_IS_CONSTEXPR (t);\n+      if (VEC_INIT_EXPR_IS_CONSTEXPR (t))\n+\treturn true;\n+      if (flags & tf_error)\n+        error (\"non-constant array initialization\");\n+      return false;\n \n     default:\n       sorry (\"unexpected ast of kind %s\", tree_code_name[TREE_CODE (t)]);\n@@ -7610,6 +7695,21 @@ potential_constant_expression (tree t, tsubst_flags_t flags)\n     }\n }\n \n+/* The main entry point to the above.  */\n+\n+bool\n+potential_constant_expression (tree t)\n+{\n+  return potential_constant_expression_1 (t, false, tf_none);\n+}\n+\n+/* Like above, but complain about non-constant expressions.  */\n+\n+bool\n+require_potential_constant_expression (tree t)\n+{\n+  return potential_constant_expression_1 (t, false, tf_warning_or_error);\n+}\n \f\n /* Constructor for a lambda expression.  */\n "}, {"sha": "1a1f150e1cecb5023d644ecb3e6b5ab515323563", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -513,9 +513,13 @@ build_vec_init_expr (tree type, tree init)\n   SET_EXPR_LOCATION (init, input_location);\n \n   if (current_function_decl\n-      && DECL_DECLARED_CONSTEXPR_P (current_function_decl)\n-      && potential_constant_expression (elt_init, tf_warning_or_error))\n-    VEC_INIT_EXPR_IS_CONSTEXPR (init) = true;\n+      && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n+    {\n+      if (potential_constant_expression (elt_init))\n+\tVEC_INIT_EXPR_IS_CONSTEXPR (init) = true;\n+      else if (!processing_template_decl)\n+\trequire_potential_constant_expression (elt_init);\n+    }\n   VEC_INIT_EXPR_VALUE_INIT (init) = value_init;\n \n   init = build_target_expr (slot, init);"}, {"sha": "df43d93cae3069c187b1a25e1f61ec60c99dc850", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -1,3 +1,7 @@\n+2011-01-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/constexpr-stmtexpr.C: New.\n+\n 2011-01-21  Jeff Law <law@redhat.com>\n \n \tPR rtl-optimization/41619"}, {"sha": "40e0c2d65d045a6bc43f720c12475fbc311b4af5", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-stmtexpr.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-stmtexpr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6ed1c8903e728f4233122554bab5910853338bd/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-stmtexpr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-stmtexpr.C?ref=d6ed1c8903e728f4233122554bab5910853338bd", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/46977\n+// { dg-options \"-std=c++0x\" }\n+\n+template < typename > void\n+foo ()\n+{\n+  ({int i;}), 0;\n+}"}]}