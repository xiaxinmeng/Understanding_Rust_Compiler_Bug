{"sha": "d858f359363662cf2555f4d9c259d80aaecae031", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg1OGYzNTkzNjM2NjJjZjI1NTVmNGQ5YzI1OWQ4MGFhZWNhZTAzMQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-16T17:49:20Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-16T17:49:20Z"}, "message": "cfg.c (dump_reg_info): Avoid C++ keywords.\n\n\t* cfg.c (dump_reg_info): Avoid C++ keywords.\n\t* dwarf2asm.c (dw2_force_const_mem,\n\tdw2_asm_output_encoded_addr_rtx): Likewise.\n\t* except.c (gen_eh_region, add_action_record, output_ttype):\n\tLikewise.\n\t* expmed.c (expand_shift): Likewise.\n\t* global.c (find_reg): Likewise.\n\t* graph.c (draw_edge): Likewise.\n\t* local-alloc.c (reg_meets_class_p, find_free_reg): Likewise.\n\t* optabs.c (expand_binop, expand_twoval_unop, expand_twoval_binop,\n\twiden_clz, widen_bswap, expand_parity, expand_unop,\n\temit_cmp_and_jump_insn_1): Likewise.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* ra.h (add_neighbor): Likewise.\n\t* reg-stack.c (remove_regno_note, change_stack): Likewise.\n\t* regclass.c (memory_move_secondary_cost, dump_regclass, regclass,\n\trecord_reg_classes, copy_cost, record_address_regs,\n\tinvalid_mode_change_p): Likewise.\n\t* regrename.c (regrename_optimize, scan_rtx_reg,\n\tdump_def_use_chain, find_oldest_value_reg,\n\treplace_oldest_value_reg, copyprop_hardreg_forward_1): Likewise.\n\nFrom-SVN: r137893", "tree": {"sha": "f4483861429c61796d6c351bc9c5766c15c43137", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4483861429c61796d6c351bc9c5766c15c43137"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d858f359363662cf2555f4d9c259d80aaecae031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d858f359363662cf2555f4d9c259d80aaecae031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d858f359363662cf2555f4d9c259d80aaecae031", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d858f359363662cf2555f4d9c259d80aaecae031/comments", "author": null, "committer": null, "parents": [{"sha": "1bc39d2fcdee654ea1904b9e50d74b3ff7b69dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bc39d2fcdee654ea1904b9e50d74b3ff7b69dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bc39d2fcdee654ea1904b9e50d74b3ff7b69dbc"}], "stats": {"total": 570, "additions": 297, "deletions": 273}, "files": [{"sha": "12cc4e43d77a1cbf55614c9294e31919bfc56507", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -1,3 +1,27 @@\n+2008-07-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* cfg.c (dump_reg_info): Avoid C++ keywords.\n+\t* dwarf2asm.c (dw2_force_const_mem,\n+\tdw2_asm_output_encoded_addr_rtx): Likewise.\n+\t* except.c (gen_eh_region, add_action_record, output_ttype):\n+\tLikewise.\n+\t* expmed.c (expand_shift): Likewise.\n+\t* global.c (find_reg): Likewise.\n+\t* graph.c (draw_edge): Likewise.\n+\t* local-alloc.c (reg_meets_class_p, find_free_reg): Likewise.\n+\t* optabs.c (expand_binop, expand_twoval_unop, expand_twoval_binop,\n+\twiden_clz, widen_bswap, expand_parity, expand_unop,\n+\temit_cmp_and_jump_insn_1): Likewise.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* ra.h (add_neighbor): Likewise.\n+\t* reg-stack.c (remove_regno_note, change_stack): Likewise.\n+\t* regclass.c (memory_move_secondary_cost, dump_regclass, regclass,\n+\trecord_reg_classes, copy_cost, record_address_regs,\n+\tinvalid_mode_change_p): Likewise.\n+\t* regrename.c (regrename_optimize, scan_rtx_reg,\n+\tdump_def_use_chain, find_oldest_value_reg,\n+\treplace_oldest_value_reg, copyprop_hardreg_forward_1): Likewise.\n+\n 2008-07-16  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (processor_target_table): Remove duplicate"}, {"sha": "1f681124105befeaac7818382f5daed07d617871", "filename": "gcc/cfg.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -597,7 +597,7 @@ dump_reg_info (FILE *file)\n   fprintf (file, \"%d registers.\\n\", max);\n   for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n     {\n-      enum reg_class class, altclass;\n+      enum reg_class rclass, altclass;\n       \n       if (regstat_n_sets_and_refs)\n \tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n@@ -628,17 +628,17 @@ dump_reg_info (FILE *file)\n \t  && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n \tfprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n       \n-      class = reg_preferred_class (i);\n+      rclass = reg_preferred_class (i);\n       altclass = reg_alternate_class (i);\n-      if (class != GENERAL_REGS || altclass != ALL_REGS)\n+      if (rclass != GENERAL_REGS || altclass != ALL_REGS)\n \t{\n-\t  if (altclass == ALL_REGS || class == ALL_REGS)\n-\t    fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t  if (altclass == ALL_REGS || rclass == ALL_REGS)\n+\t    fprintf (file, \"; pref %s\", reg_class_names[(int) rclass]);\n \t  else if (altclass == NO_REGS)\n-\t    fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n+\t    fprintf (file, \"; %s or none\", reg_class_names[(int) rclass]);\n \t  else\n \t    fprintf (file, \"; pref %s, else %s\",\n-\t\t     reg_class_names[(int) class],\n+\t\t     reg_class_names[(int) rclass],\n \t\t     reg_class_names[(int) altclass]);\n \t}\n       "}, {"sha": "43d57e9fa8f7d8ceecdaeaf20c3271ccc9d02c25", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -730,11 +730,11 @@ splay_tree_compare_strings (splay_tree_key k1, splay_tree_key k2)\n /* Put X, a SYMBOL_REF, in memory.  Return a SYMBOL_REF to the allocated\n    memory.  Differs from force_const_mem in that a single pool is used for\n    the entire unit of translation, and the memory is not guaranteed to be\n-   \"near\" the function in any interesting sense.  PUBLIC controls whether\n+   \"near\" the function in any interesting sense.  IS_PUBLIC controls whether\n    the symbol can be shared across the entire application (or DSO).  */\n \n static rtx\n-dw2_force_const_mem (rtx x, bool public)\n+dw2_force_const_mem (rtx x, bool is_public)\n {\n   splay_tree_node node;\n   const char *str;\n@@ -755,7 +755,7 @@ dw2_force_const_mem (rtx x, bool public)\n     {\n       tree id;\n \n-      if (public && USE_LINKONCE_INDIRECT)\n+      if (is_public && USE_LINKONCE_INDIRECT)\n \t{\n \t  char *ref_name = XALLOCAVEC (char, strlen (str) + sizeof \"DW.ref.\");\n \n@@ -829,7 +829,7 @@ dw2_output_indirect_constants (void)\n    reference is shared across the entire application (or DSO).  */\n \n void\n-dw2_asm_output_encoded_addr_rtx (int encoding, rtx addr, bool public,\n+dw2_asm_output_encoded_addr_rtx (int encoding, rtx addr, bool is_public,\n \t\t\t\t const char *comment, ...)\n {\n   int size;\n@@ -870,7 +870,7 @@ dw2_asm_output_encoded_addr_rtx (int encoding, rtx addr, bool public,\n \t     the constant pool for this function.  Moreover, we'd like to\n \t     share these constants across the entire unit of translation and\n \t     even, if possible, across the entire application (or DSO).  */\n-\t  addr = dw2_force_const_mem (addr, public);\n+\t  addr = dw2_force_const_mem (addr, is_public);\n \t  encoding &= ~DW_EH_PE_indirect;\n \t  goto restart;\n \t}"}, {"sha": "5118a53cfa30f427102366750d8ae287e75c5c31", "filename": "gcc/except.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -419,30 +419,30 @@ init_eh_for_function (void)\n static struct eh_region *\n gen_eh_region (enum eh_region_type type, struct eh_region *outer)\n {\n-  struct eh_region *new;\n+  struct eh_region *new_eh;\n \n #ifdef ENABLE_CHECKING\n   gcc_assert (doing_eh (0));\n #endif\n \n   /* Insert a new blank region as a leaf in the tree.  */\n-  new = GGC_CNEW (struct eh_region);\n-  new->type = type;\n-  new->outer = outer;\n+  new_eh = GGC_CNEW (struct eh_region);\n+  new_eh->type = type;\n+  new_eh->outer = outer;\n   if (outer)\n     {\n-      new->next_peer = outer->inner;\n-      outer->inner = new;\n+      new_eh->next_peer = outer->inner;\n+      outer->inner = new_eh;\n     }\n   else\n     {\n-      new->next_peer = cfun->eh->region_tree;\n-      cfun->eh->region_tree = new;\n+      new_eh->next_peer = cfun->eh->region_tree;\n+      cfun->eh->region_tree = new_eh;\n     }\n \n-  new->region_number = ++cfun->eh->last_region_number;\n+  new_eh->region_number = ++cfun->eh->last_region_number;\n \n-  return new;\n+  return new_eh;\n }\n \n struct eh_region *\n@@ -3047,19 +3047,19 @@ action_record_hash (const void *pentry)\n static int\n add_action_record (htab_t ar_hash, int filter, int next)\n {\n-  struct action_record **slot, *new, tmp;\n+  struct action_record **slot, *new_ar, tmp;\n \n   tmp.filter = filter;\n   tmp.next = next;\n   slot = (struct action_record **) htab_find_slot (ar_hash, &tmp, INSERT);\n \n-  if ((new = *slot) == NULL)\n+  if ((new_ar = *slot) == NULL)\n     {\n-      new = XNEW (struct action_record);\n-      new->offset = VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data) + 1;\n-      new->filter = filter;\n-      new->next = next;\n-      *slot = new;\n+      new_ar = XNEW (struct action_record);\n+      new_ar->offset = VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data) + 1;\n+      new_ar->filter = filter;\n+      new_ar->next = next;\n+      *slot = new_ar;\n \n       /* The filter value goes in untouched.  The link to the next\n \t record is a \"self-relative\" byte offset, or zero to indicate\n@@ -3072,7 +3072,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n       push_sleb128 (&crtl->eh.action_record_data, next);\n     }\n \n-  return new->offset;\n+  return new_ar->offset;\n }\n \n static int\n@@ -3550,7 +3550,7 @@ static void\n output_ttype (tree type, int tt_format, int tt_format_size)\n {\n   rtx value;\n-  bool public = true;\n+  bool is_public = true;\n \n   if (type == NULL_TREE)\n     value = const0_rtx;\n@@ -3573,7 +3573,7 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n \t      node = varpool_node (type);\n \t      if (node)\n \t\tvarpool_mark_needed_node (node);\n-\t      public = TREE_PUBLIC (type);\n+\t      is_public = TREE_PUBLIC (type);\n \t    }\n \t}\n       else\n@@ -3588,7 +3588,7 @@ output_ttype (tree type, int tt_format, int tt_format_size)\n     assemble_integer (value, tt_format_size,\n \t\t      tt_format_size * BITS_PER_UNIT, 1);\n   else\n-    dw2_asm_output_encoded_addr_rtx (tt_format, value, public, NULL);\n+    dw2_asm_output_encoded_addr_rtx (tt_format, value, is_public, NULL);\n }\n \n void"}, {"sha": "d5127b3c344a48b79359becdd06e01dd4c951f8a", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -2050,7 +2050,7 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   optab lrotate_optab = rotl_optab;\n   optab rrotate_optab = rotr_optab;\n   enum machine_mode op1_mode;\n-  int try;\n+  int attempt;\n \n   op1 = expand_normal (amount);\n   op1_mode = GET_MODE (op1);\n@@ -2105,13 +2105,13 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n       return shifted;\n     }\n \n-  for (try = 0; temp == 0 && try < 3; try++)\n+  for (attempt = 0; temp == 0 && attempt < 3; attempt++)\n     {\n       enum optab_methods methods;\n \n-      if (try == 0)\n+      if (attempt == 0)\n \tmethods = OPTAB_DIRECT;\n-      else if (try == 1)\n+      else if (attempt == 1)\n \tmethods = OPTAB_WIDEN;\n       else\n \tmethods = OPTAB_LIB_WIDEN;"}, {"sha": "c47033e5754437ea84169d14e661dddafef6535c", "filename": "gcc/global.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -978,7 +978,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n   int i, best_reg, pass;\n   HARD_REG_SET used, used1, used2;\n \n-  enum reg_class class = (alt_regs_p\n+  enum reg_class rclass = (alt_regs_p\n \t\t\t  ? reg_alternate_class (allocno[num].reg)\n \t\t\t  : reg_preferred_class (allocno[num].reg));\n   enum machine_mode mode = PSEUDO_REGNO_MODE (allocno[num].reg);\n@@ -995,7 +995,7 @@ find_reg (int num, HARD_REG_SET losers, int alt_regs_p, int accept_call_clobbere\n   if (losers)\n     IOR_HARD_REG_SET (used1, losers);\n \n-  IOR_COMPL_HARD_REG_SET (used1, reg_class_contents[(int) class]);\n+  IOR_COMPL_HARD_REG_SET (used1, reg_class_contents[(int) rclass]);\n \n #ifdef EH_RETURN_DATA_REGNO\n   if (allocno[num].no_eh_reg)"}, {"sha": "643571b6af28894b86eb27747e12bbd010636ac0", "filename": "gcc/graph.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -165,25 +165,25 @@ darkgrey\\n  shape: ellipse\" : \"white\",\n }\n \n static void\n-draw_edge (FILE *fp, int from, int to, int bb_edge, int class)\n+draw_edge (FILE *fp, int from, int to, int bb_edge, int color_class)\n {\n   const char * color;\n   switch (graph_dump_format)\n     {\n     case vcg:\n       color = \"\";\n-      if (class == 2)\n+      if (color_class == 2)\n \tcolor = \"color: red \";\n       else if (bb_edge)\n \tcolor = \"color: blue \";\n-      else if (class == 3)\n+      else if (color_class == 3)\n \tcolor = \"color: green \";\n       fprintf (fp,\n \t       \"edge: { sourcename: \\\"%s.%d\\\" targetname: \\\"%s.%d\\\" %s\",\n \t       current_function_name (), from,\n \t       current_function_name (), to, color);\n-      if (class)\n-\tfprintf (fp, \"class: %d \", class);\n+      if (color_class)\n+\tfprintf (fp, \"class: %d \", color_class);\n       fputs (\"}\\n\", fp);\n       break;\n     case no_graph:"}, {"sha": "98b67700808fcdcc0850a51a03317999344eea20", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -1984,11 +1984,11 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n    True if REG's reg class either contains or is contained in CLASS.  */\n \n static int\n-reg_meets_class_p (int reg, enum reg_class class)\n+reg_meets_class_p (int reg, enum reg_class rclass)\n {\n-  enum reg_class rclass = reg_preferred_class (reg);\n-  return (reg_class_subset_p (rclass, class)\n-\t  || reg_class_subset_p (class, rclass));\n+  enum reg_class rclass2 = reg_preferred_class (reg);\n+  return (reg_class_subset_p (rclass2, rclass)\n+\t  || reg_class_subset_p (rclass, rclass2));\n }\n \n /* Update the class of QTYNO assuming that REG is being tied to it.  */\n@@ -2139,7 +2139,7 @@ wipe_dead_reg (rtx reg, int output_p)\n    register is available.  If not, return -1.  */\n \n static int\n-find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n+find_free_reg (enum reg_class rclass, enum machine_mode mode, int qtyno,\n \t       int accept_call_clobbered, int just_try_suggested,\n \t       int born_index, int dead_index)\n {\n@@ -2171,7 +2171,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n   for (ins = born_index; ins < dead_index; ins++)\n     IOR_HARD_REG_SET (used, regs_live_at[ins]);\n \n-  IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) class]);\n+  IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) rclass]);\n \n   /* Don't use the frame pointer reg in local-alloc even if\n      we may omit the frame pointer, because if we do that and then we\n@@ -2256,7 +2256,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n     {\n       /* Don't try the copy-suggested regs again.  */\n       qty_phys_num_copy_sugg[qtyno] = 0;\n-      return find_free_reg (class, mode, qtyno, accept_call_clobbered, 1,\n+      return find_free_reg (rclass, mode, qtyno, accept_call_clobbered, 1,\n \t\t\t    born_index, dead_index);\n     }\n \n@@ -2274,7 +2274,7 @@ find_free_reg (enum reg_class class, enum machine_mode mode, int qtyno,\n \t\t\t\t optimize_size ? qty[qtyno].n_calls_crossed\n \t\t\t\t : qty[qtyno].freq_calls_crossed))\n     {\n-      i = find_free_reg (class, mode, qtyno, 1, 0, born_index, dead_index);\n+      i = find_free_reg (rclass, mode, qtyno, 1, 0, born_index, dead_index);\n       if (i >= 0)\n \tcaller_save_needed = 1;\n       return i;"}, {"sha": "ee5bec11a41633d0569e478ecc3ec6ae2cf5debf", "filename": "gcc/optabs.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -1571,14 +1571,14 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   enum optab_methods next_methods\n     = (methods == OPTAB_LIB || methods == OPTAB_LIB_WIDEN\n        ? OPTAB_WIDEN : methods);\n-  enum mode_class class;\n+  enum mode_class mclass;\n   enum machine_mode wider_mode;\n   rtx libfunc;\n   rtx temp;\n   rtx entry_last = get_last_insn ();\n   rtx last;\n \n-  class = GET_MODE_CLASS (mode);\n+  mclass = GET_MODE_CLASS (mode);\n \n   /* If subtracting an integer constant, convert this into an addition of\n      the negated constant.  */\n@@ -1609,7 +1609,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t&& optab_handler (rotr_optab, mode)->insn_code != CODE_FOR_nothing)\n        || (binoptab == rotr_optab\n \t   && optab_handler (rotl_optab, mode)->insn_code != CODE_FOR_nothing))\n-      && class == MODE_INT)\n+      && mclass == MODE_INT)\n     {\n       optab otheroptab = (binoptab == rotl_optab ? rotr_optab : rotl_optab);\n       rtx newop1;\n@@ -1658,7 +1658,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      can open-code the operation.  Check for a widening multiply at the\n      wider mode as well.  */\n \n-  if (CLASS_HAS_WIDER_MODES_P (class)\n+  if (CLASS_HAS_WIDER_MODES_P (mclass)\n       && methods != OPTAB_DIRECT && methods != OPTAB_LIB)\n     for (wider_mode = GET_MODE_WIDER_MODE (mode);\n \t wider_mode != VOIDmode;\n@@ -1683,7 +1683,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t || binoptab == xor_optab\n \t\t || binoptab == add_optab || binoptab == sub_optab\n \t\t || binoptab == smul_optab || binoptab == ashl_optab)\n-\t\t&& class == MODE_INT)\n+\t\t&& mclass == MODE_INT)\n \t      {\n \t\tno_extend = 1;\n \t\txop0 = avoid_expensive_constant (mode, binoptab,\n@@ -1703,7 +1703,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t\t\t unsignedp, OPTAB_DIRECT);\n \t    if (temp)\n \t      {\n-\t\tif (class != MODE_INT\n+\t\tif (mclass != MODE_INT\n                     || !TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n                                                GET_MODE_BITSIZE (wider_mode)))\n \t\t  {\n@@ -1734,7 +1734,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* These can be done a word at a time.  */\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n-      && class == MODE_INT\n+      && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n       && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n@@ -1785,7 +1785,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* Synthesize double word shifts from single word shifts.  */\n   if ((binoptab == lshr_optab || binoptab == ashl_optab\n        || binoptab == ashr_optab)\n-      && class == MODE_INT\n+      && mclass == MODE_INT\n       && (GET_CODE (op1) == CONST_INT || !optimize_size)\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing\n@@ -1855,7 +1855,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* Synthesize double word rotates from single word shifts.  */\n   if ((binoptab == rotl_optab || binoptab == rotr_optab)\n-      && class == MODE_INT\n+      && mclass == MODE_INT\n       && GET_CODE (op1) == CONST_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && optab_handler (ashl_optab, word_mode)->insn_code != CODE_FOR_nothing\n@@ -1968,7 +1968,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n   /* These can be done a word at a time by propagating carries.  */\n   if ((binoptab == add_optab || binoptab == sub_optab)\n-      && class == MODE_INT\n+      && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) >= 2 * UNITS_PER_WORD\n       && optab_handler (binoptab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n@@ -2094,7 +2094,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      try using a signed widening multiply.  */\n \n   if (binoptab == smul_optab\n-      && class == MODE_INT\n+      && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n       && optab_handler (smul_optab, word_mode)->insn_code != CODE_FOR_nothing\n       && optab_handler (add_optab, word_mode)->insn_code != CODE_FOR_nothing)\n@@ -2197,7 +2197,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* Look for a wider mode of the same class for which it appears we can do\n      the operation.  */\n \n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       for (wider_mode = GET_MODE_WIDER_MODE (mode);\n \t   wider_mode != VOIDmode;\n@@ -2219,7 +2219,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t   || binoptab == xor_optab\n \t\t   || binoptab == add_optab || binoptab == sub_optab\n \t\t   || binoptab == smul_optab || binoptab == ashl_optab)\n-\t\t  && class == MODE_INT)\n+\t\t  && mclass == MODE_INT)\n \t\tno_extend = 1;\n \n \t      xop0 = widen_operand (xop0, wider_mode, mode,\n@@ -2233,7 +2233,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t\t\t\t   unsignedp, methods);\n \t      if (temp)\n \t\t{\n-\t\t  if (class != MODE_INT\n+\t\t  if (mclass != MODE_INT\n \t\t      || !TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n \t\t\t\t\t\t GET_MODE_BITSIZE (wider_mode)))\n \t\t    {\n@@ -2327,12 +2327,12 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \t\t    int unsignedp)\n {\n   enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n-  enum mode_class class;\n+  enum mode_class mclass;\n   enum machine_mode wider_mode;\n   rtx entry_last = get_last_insn ();\n   rtx last;\n \n-  class = GET_MODE_CLASS (mode);\n+  mclass = GET_MODE_CLASS (mode);\n \n   if (!targ0)\n     targ0 = gen_reg_rtx (mode);\n@@ -2374,7 +2374,7 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       for (wider_mode = GET_MODE_WIDER_MODE (mode);\n \t   wider_mode != VOIDmode;\n@@ -2420,12 +2420,12 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \t\t     int unsignedp)\n {\n   enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n-  enum mode_class class;\n+  enum mode_class mclass;\n   enum machine_mode wider_mode;\n   rtx entry_last = get_last_insn ();\n   rtx last;\n \n-  class = GET_MODE_CLASS (mode);\n+  mclass = GET_MODE_CLASS (mode);\n \n   if (!targ0)\n     targ0 = gen_reg_rtx (mode);\n@@ -2491,7 +2491,7 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       for (wider_mode = GET_MODE_WIDER_MODE (mode);\n \t   wider_mode != VOIDmode;\n@@ -2591,8 +2591,8 @@ expand_simple_unop (enum machine_mode mode, enum rtx_code code, rtx op0,\n static rtx\n widen_clz (enum machine_mode mode, rtx op0, rtx target)\n {\n-  enum mode_class class = GET_MODE_CLASS (mode);\n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       enum machine_mode wider_mode;\n       for (wider_mode = GET_MODE_WIDER_MODE (mode);\n@@ -2702,11 +2702,11 @@ expand_doubleword_clz (enum machine_mode mode, rtx op0, rtx target)\n static rtx\n widen_bswap (enum machine_mode mode, rtx op0, rtx target)\n {\n-  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n   rtx x, last;\n \n-  if (!CLASS_HAS_WIDER_MODES_P (class))\n+  if (!CLASS_HAS_WIDER_MODES_P (mclass))\n     return NULL_RTX;\n \n   for (wider_mode = GET_MODE_WIDER_MODE (mode);\n@@ -2767,8 +2767,8 @@ expand_doubleword_bswap (enum machine_mode mode, rtx op, rtx target)\n static rtx\n expand_parity (enum machine_mode mode, rtx op0, rtx target)\n {\n-  enum mode_class class = GET_MODE_CLASS (mode);\n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       enum machine_mode wider_mode;\n       for (wider_mode = mode; wider_mode != VOIDmode;\n@@ -3116,7 +3116,7 @@ rtx\n expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t     int unsignedp)\n {\n-  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n   rtx temp;\n   rtx libfunc;\n@@ -3163,7 +3163,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       goto try_libcall;\n     }\n \n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     for (wider_mode = GET_MODE_WIDER_MODE (mode);\n \t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n@@ -3180,14 +3180,14 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t    xop0 = widen_operand (xop0, wider_mode, mode, unsignedp,\n \t\t\t\t  (unoptab == neg_optab\n \t\t\t\t   || unoptab == one_cmpl_optab)\n-\t\t\t\t  && class == MODE_INT);\n+\t\t\t\t  && mclass == MODE_INT);\n \n \t    temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\tunsignedp);\n \n \t    if (temp)\n \t      {\n-\t\tif (class != MODE_INT\n+\t\tif (mclass != MODE_INT\n \t\t    || !TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n \t\t\t\t\t       GET_MODE_BITSIZE (wider_mode)))\n \t\t  {\n@@ -3206,7 +3206,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   /* These can be done a word at a time.  */\n   if (unoptab == one_cmpl_optab\n-      && class == MODE_INT\n+      && mclass == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n       && optab_handler (unoptab, word_mode)->insn_code != CODE_FOR_nothing)\n     {\n@@ -3323,7 +3323,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n-  if (CLASS_HAS_WIDER_MODES_P (class))\n+  if (CLASS_HAS_WIDER_MODES_P (mclass))\n     {\n       for (wider_mode = GET_MODE_WIDER_MODE (mode);\n \t   wider_mode != VOIDmode;\n@@ -3343,7 +3343,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \t      xop0 = widen_operand (xop0, wider_mode, mode, unsignedp,\n \t\t\t\t    (unoptab == neg_optab\n \t\t\t\t     || unoptab == one_cmpl_optab)\n-\t\t\t\t    && class == MODE_INT);\n+\t\t\t\t    && mclass == MODE_INT);\n \n \t      temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\t  unsignedp);\n@@ -3358,7 +3358,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n \t      if (temp)\n \t\t{\n-\t\t  if (class != MODE_INT)\n+\t\t  if (mclass != MODE_INT)\n \t\t    {\n \t\t      if (target == 0)\n \t\t\ttarget = gen_reg_rtx (mode);\n@@ -4191,7 +4191,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t\t\t  enum rtx_code comparison, int unsignedp, rtx label)\n {\n   rtx test = gen_rtx_fmt_ee (comparison, mode, x, y);\n-  enum mode_class class = GET_MODE_CLASS (mode);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode = mode;\n \n   /* Try combined insns first.  */\n@@ -4238,7 +4238,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t  return;\n \t}\n \n-      if (!CLASS_HAS_WIDER_MODES_P (class))\n+      if (!CLASS_HAS_WIDER_MODES_P (mclass))\n \tbreak;\n \n       wider_mode = GET_MODE_WIDER_MODE (wider_mode);"}, {"sha": "5f6fec1e95377d04844e2e12592920474a2bf3dc", "filename": "gcc/postreload.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -518,7 +518,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \n       for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n \t{\n-\t  int class = (int) NO_REGS;\n+\t  int rclass = (int) NO_REGS;\n \n \t  if (! TEST_HARD_REG_BIT (equiv_regs[i], regno))\n \t    continue;\n@@ -552,13 +552,13 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t  break;\n \n \t\tcase 'g': case 'r':\n-\t\t  class = reg_class_subunion[(int) class][(int) GENERAL_REGS];\n+\t\t  rclass = reg_class_subunion[(int) rclass][(int) GENERAL_REGS];\n \t\t  break;\n \n \t\tdefault:\n-\t\t  class\n+\t\t  rclass\n \t\t    = (reg_class_subunion\n-\t\t       [(int) class]\n+\t\t       [(int) rclass]\n \t\t       [(int) REG_CLASS_FROM_CONSTRAINT ((unsigned char) c, p)]);\n \t\t  break;\n \n@@ -568,7 +568,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t     alternative yet and the operand being replaced is not\n \t\t     a cheap CONST_INT.  */\n \t\t  if (op_alt_regno[i][j] == -1\n-\t\t      && reg_fits_class_p (testreg, class, 0, mode)\n+\t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n \t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n \t\t\t  || (rtx_cost (recog_data.operand[i], SET)\n \t\t\t      > rtx_cost (testreg, SET))))\n@@ -577,7 +577,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t      op_alt_regno[i][j] = regno;\n \t\t    }\n \t\t  j++;\n-\t\t  class = (int) NO_REGS;\n+\t\t  rclass = (int) NO_REGS;\n \t\t  break;\n \t\t}\n \t      p += CONSTRAINT_LEN (c, p);"}, {"sha": "4fe80c8555b505907b5e45f0025db45280afef6f", "filename": "gcc/ra.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fra.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fra.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.h?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -144,10 +144,10 @@ add_neighbor (int alloc_no, int neighbor)\n \n   if (adjlist == NULL || adjlist->index == ADJACENCY_VEC_LENGTH)\n     {\n-      adjacency_t *new = (adjacency_t *) pool_alloc (adjacency_pool);\n-      new->index = 0;\n-      new->next = adjlist;\n-      adjlist = new;\n+      adjacency_t *new_adj = (adjacency_t *) pool_alloc (adjacency_pool);\n+      new_adj->index = 0;\n+      new_adj->next = adjlist;\n+      adjlist = new_adj;\n       adjacency[alloc_no] = adjlist;\n     }\n "}, {"sha": "eb31bc835cfc90ed141adeaef1073d68671026f9", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -713,18 +713,18 @@ replace_reg (rtx *reg, int regno)\n static void\n remove_regno_note (rtx insn, enum reg_note note, unsigned int regno)\n {\n-  rtx *note_link, this;\n+  rtx *note_link, this_rtx;\n \n   note_link = &REG_NOTES (insn);\n-  for (this = *note_link; this; this = XEXP (this, 1))\n-    if (REG_NOTE_KIND (this) == note\n-\t&& REG_P (XEXP (this, 0)) && REGNO (XEXP (this, 0)) == regno)\n+  for (this_rtx = *note_link; this_rtx; this_rtx = XEXP (this_rtx, 1))\n+    if (REG_NOTE_KIND (this_rtx) == note\n+\t&& REG_P (XEXP (this_rtx, 0)) && REGNO (XEXP (this_rtx, 0)) == regno)\n       {\n-\t*note_link = XEXP (this, 1);\n+\t*note_link = XEXP (this_rtx, 1);\n \treturn;\n       }\n     else\n-      note_link = &XEXP (this, 1);\n+      note_link = &XEXP (this_rtx, 1);\n \n   gcc_unreachable ();\n }\n@@ -2355,7 +2355,7 @@ subst_stack_regs (rtx insn, stack regstack)\n    is no longer needed once this has executed.  */\n \n static void\n-change_stack (rtx insn, stack old, stack new, enum emit_where where)\n+change_stack (rtx insn, stack old, stack new_stack, enum emit_where where)\n {\n   int reg;\n   int update_end = 0;\n@@ -2368,9 +2368,9 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n       && starting_stack_p\n       && where == EMIT_BEFORE)\n     {\n-      BLOCK_INFO (current_block)->stack_in = *new;\n+      BLOCK_INFO (current_block)->stack_in = *new_stack;\n       starting_stack_p = false;\n-      *old = *new;\n+      *old = *new_stack;\n       return;\n     }\n \n@@ -2386,7 +2386,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \n   /* Initialize partially dead variables.  */\n   for (i = FIRST_STACK_REG; i < LAST_STACK_REG + 1; i++)\n-    if (TEST_HARD_REG_BIT (new->reg_set, i)\n+    if (TEST_HARD_REG_BIT (new_stack->reg_set, i)\n \t&& !TEST_HARD_REG_BIT (old->reg_set, i))\n       {\n \told->reg[++old->top] = i;\n@@ -2400,28 +2400,28 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n   /* If the destination block's stack already has a specified layout\n      and contains two or more registers, use a more intelligent algorithm\n      to pop registers that minimizes the number number of fxchs below.  */\n-  if (new->top > 0)\n+  if (new_stack->top > 0)\n     {\n       bool slots[REG_STACK_SIZE];\n       int pops[REG_STACK_SIZE];\n       int next, dest, topsrc;\n \n       /* First pass to determine the free slots.  */\n-      for (reg = 0; reg <= new->top; reg++)\n-\tslots[reg] = TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]);\n+      for (reg = 0; reg <= new_stack->top; reg++)\n+\tslots[reg] = TEST_HARD_REG_BIT (new_stack->reg_set, old->reg[reg]);\n \n       /* Second pass to allocate preferred slots.  */\n       topsrc = -1;\n-      for (reg = old->top; reg > new->top; reg--)\n-\tif (TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n+      for (reg = old->top; reg > new_stack->top; reg--)\n+\tif (TEST_HARD_REG_BIT (new_stack->reg_set, old->reg[reg]))\n \t  {\n \t    dest = -1;\n-\t    for (next = 0; next <= new->top; next++)\n-\t      if (!slots[next] && new->reg[next] == old->reg[reg])\n+\t    for (next = 0; next <= new_stack->top; next++)\n+\t      if (!slots[next] && new_stack->reg[next] == old->reg[reg])\n \t\t{\n \t\t  /* If this is a preference for the new top of stack, record\n \t\t     the fact by remembering it's old->reg in topsrc.  */\n-                  if (next == new->top)\n+                  if (next == new_stack->top)\n \t\t    topsrc = reg;\n \t\t  slots[next] = true;\n \t\t  dest = next;\n@@ -2438,18 +2438,18 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \t slot is still unallocated, in which case we should place the\n \t top of stack there.  */\n       if (topsrc != -1)\n-\tfor (reg = 0; reg < new->top; reg++)\n+\tfor (reg = 0; reg < new_stack->top; reg++)\n \t  if (!slots[reg])\n \t    {\n \t      pops[topsrc] = reg;\n-\t      slots[new->top] = false;\n+\t      slots[new_stack->top] = false;\n \t      slots[reg] = true;\n \t      break;\n \t    }\n \n       /* Third pass allocates remaining slots and emits pop insns.  */\n-      next = new->top;\n-      for (reg = old->top; reg > new->top; reg--)\n+      next = new_stack->top;\n+      for (reg = old->top; reg > new_stack->top; reg--)\n \t{\n \t  dest = pops[reg];\n \t  if (dest == -1)\n@@ -2472,14 +2472,14 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \n       live = 0;\n       for (reg = 0; reg <= old->top; reg++)\n-        if (TEST_HARD_REG_BIT (new->reg_set, old->reg[reg]))\n+        if (TEST_HARD_REG_BIT (new_stack->reg_set, old->reg[reg]))\n           live++;\n \n       next = live;\n       while (old->top >= live)\n-        if (TEST_HARD_REG_BIT (new->reg_set, old->reg[old->top]))\n+        if (TEST_HARD_REG_BIT (new_stack->reg_set, old->reg[old->top]))\n \t  {\n-\t    while (TEST_HARD_REG_BIT (new->reg_set, old->reg[next]))\n+\t    while (TEST_HARD_REG_BIT (new_stack->reg_set, old->reg[next]))\n \t      next--;\n \t    emit_pop_insn (insn, old, FP_MODE_REG (old->reg[next], DFmode),\n \t\t\t   EMIT_BEFORE);\n@@ -2489,13 +2489,13 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \t\t\t EMIT_BEFORE);\n     }\n \n-  if (new->top == -2)\n+  if (new_stack->top == -2)\n     {\n       /* If the new block has never been processed, then it can inherit\n \t the old stack order.  */\n \n-      new->top = old->top;\n-      memcpy (new->reg, old->reg, sizeof (new->reg));\n+      new_stack->top = old->top;\n+      memcpy (new_stack->reg, old->reg, sizeof (new_stack->reg));\n     }\n   else\n     {\n@@ -2505,10 +2505,10 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n       /* By now, the only difference should be the order of the stack,\n \t not their depth or liveliness.  */\n \n-      gcc_assert (hard_reg_set_equal_p (old->reg_set, new->reg_set));\n-      gcc_assert (old->top == new->top);\n+      gcc_assert (hard_reg_set_equal_p (old->reg_set, new_stack->reg_set));\n+      gcc_assert (old->top == new_stack->top);\n \n-      /* If the stack is not empty (new->top != -1), loop here emitting\n+      /* If the stack is not empty (new_stack->top != -1), loop here emitting\n \t swaps until the stack is correct.\n \n \t The worst case number of swaps emitted is N + 2, where N is the\n@@ -2517,16 +2517,16 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \t other regs.  But since we never swap any other reg away from\n \t its correct slot, this algorithm will converge.  */\n \n-      if (new->top != -1)\n+      if (new_stack->top != -1)\n \tdo\n \t  {\n \t    /* Swap the reg at top of stack into the position it is\n \t       supposed to be in, until the correct top of stack appears.  */\n \n-\t    while (old->reg[old->top] != new->reg[new->top])\n+\t    while (old->reg[old->top] != new_stack->reg[new_stack->top])\n \t      {\n-\t\tfor (reg = new->top; reg >= 0; reg--)\n-\t\t  if (new->reg[reg] == old->reg[old->top])\n+\t\tfor (reg = new_stack->top; reg >= 0; reg--)\n+\t\t  if (new_stack->reg[reg] == old->reg[old->top])\n \t\t    break;\n \n \t\tgcc_assert (reg != -1);\n@@ -2539,8 +2539,8 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n \t     incorrect reg to the top of stack, and let the while loop\n \t     above fix it.  */\n \n-\t    for (reg = new->top; reg >= 0; reg--)\n-\t      if (new->reg[reg] != old->reg[reg])\n+\t    for (reg = new_stack->top; reg >= 0; reg--)\n+\t      if (new_stack->reg[reg] != old->reg[reg])\n \t\t{\n \t\t  emit_swap_insn (insn, old,\n \t\t\t\t  FP_MODE_REG (old->reg[reg], DFmode));\n@@ -2551,7 +2551,7 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n       /* At this point there must be no differences.  */\n \n       for (reg = old->top; reg >= 0; reg--)\n-\tgcc_assert (old->reg[reg] == new->reg[reg]);\n+\tgcc_assert (old->reg[reg] == new_stack->reg[reg]);\n     }\n \n   if (update_end)"}, {"sha": "386214dbe0d1e06183624228424ba15395225304", "filename": "gcc/regclass.c", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -738,7 +738,7 @@ init_fake_stack_mems (void)\n    Only needed if secondary reloads are required for memory moves.  */\n \n int\n-memory_move_secondary_cost (enum machine_mode mode, enum reg_class class, int in)\n+memory_move_secondary_cost (enum machine_mode mode, enum reg_class rclass, int in)\n {\n   enum reg_class altclass;\n   int partial_cost = 0;\n@@ -747,17 +747,17 @@ memory_move_secondary_cost (enum machine_mode mode, enum reg_class class, int in\n   rtx mem ATTRIBUTE_UNUSED = top_of_stack[(int) mode];\n \n \n-  altclass = secondary_reload_class (in ? 1 : 0, class, mode, mem);\n+  altclass = secondary_reload_class (in ? 1 : 0, rclass, mode, mem);\n \n   if (altclass == NO_REGS)\n     return 0;\n \n   if (in)\n-    partial_cost = REGISTER_MOVE_COST (mode, altclass, class);\n+    partial_cost = REGISTER_MOVE_COST (mode, altclass, rclass);\n   else\n-    partial_cost = REGISTER_MOVE_COST (mode, class, altclass);\n+    partial_cost = REGISTER_MOVE_COST (mode, rclass, altclass);\n \n-  if (class == altclass)\n+  if (rclass == altclass)\n     /* This isn't simply a copy-to-temporary situation.  Can't guess\n        what it is, so MEMORY_MOVE_COST really ought not to be calling\n        here in that case.\n@@ -1087,23 +1087,23 @@ dump_regclass (FILE *dump)\n   int i;\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n-      int /* enum reg_class */ class;\n+      int /* enum reg_class */ rclass;\n       if (REG_N_REFS (i))\n \t{\n \t  fprintf (dump, \"  Register %i costs:\", i);\n-\t  for (class = 0; class < (int) N_REG_CLASSES; class++)\n-\t    if (contains_reg_of_mode [(enum reg_class) class][PSEUDO_REGNO_MODE (i)]\n+\t  for (rclass = 0; rclass < (int) N_REG_CLASSES; rclass++)\n+\t    if (contains_reg_of_mode [(enum reg_class) rclass][PSEUDO_REGNO_MODE (i)]\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n \t\t&& (!in_inc_dec[i]\n-\t\t    || !forbidden_inc_dec_class[(enum reg_class) class])\n+\t\t    || !forbidden_inc_dec_class[(enum reg_class) rclass])\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t&& ! invalid_mode_change_p (i, (enum reg_class) class,\n+\t\t&& ! invalid_mode_change_p (i, (enum reg_class) rclass,\n \t\t\t\t\t    PSEUDO_REGNO_MODE (i))\n #endif\n \t\t)\n-\t    fprintf (dump, \" %s:%i\", reg_class_names[class],\n-\t\t     costs[i].cost[(enum reg_class) class]);\n+\t    fprintf (dump, \" %s:%i\", reg_class_names[rclass],\n+\t\t     costs[i].cost[(enum reg_class) rclass]);\n \t  fprintf (dump, \" MEM:%i\\n\", costs[i].mem_cost);\n \t}\n     }\n@@ -1382,7 +1382,7 @@ regclass (rtx f, int nregs)\n \t  enum reg_class best = ALL_REGS, alt = NO_REGS;\n \t  /* This is an enum reg_class, but we call it an int\n \t     to save lots of casts.  */\n-\t  int class;\n+\t  int rclass;\n \t  struct costs *p = &costs[i];\n \n \t  if (regno_reg_rtx[i] == NULL)\n@@ -1393,27 +1393,27 @@ regclass (rtx f, int nregs)\n \t  if (optimize && !REG_N_REFS (i) && !REG_N_SETS (i))\n \t    continue;\n \n-\t  for (class = (int) ALL_REGS - 1; class > 0; class--)\n+\t  for (rclass = (int) ALL_REGS - 1; rclass > 0; rclass--)\n \t    {\n \t      /* Ignore classes that are too small for this operand or\n \t\t invalid for an operand that was auto-incremented.  */\n-\t      if (!contains_reg_of_mode [class][PSEUDO_REGNO_MODE (i)]\n+\t      if (!contains_reg_of_mode [rclass][PSEUDO_REGNO_MODE (i)]\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[class])\n+\t\t  || (in_inc_dec[i] && forbidden_inc_dec_class[rclass])\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t  || invalid_mode_change_p (i, (enum reg_class) class,\n+\t\t  || invalid_mode_change_p (i, (enum reg_class) rclass,\n \t\t\t\t\t    PSEUDO_REGNO_MODE (i))\n #endif\n \t\t  )\n \t\t;\n-\t      else if (p->cost[class] < best_cost)\n+\t      else if (p->cost[rclass] < best_cost)\n \t\t{\n-\t\t  best_cost = p->cost[class];\n-\t\t  best = (enum reg_class) class;\n+\t\t  best_cost = p->cost[rclass];\n+\t\t  best = (enum reg_class) rclass;\n \t\t}\n-\t      else if (p->cost[class] == best_cost)\n-\t\tbest = reg_class_subunion[(int) best][class];\n+\t      else if (p->cost[rclass] == best_cost)\n+\t\tbest = reg_class_subunion[(int) best][rclass];\n \t    }\n \n \t  /* If no register class is better than memory, use memory. */\n@@ -1428,19 +1428,19 @@ regclass (rtx f, int nregs)\n \t     will be doing it again later.  */\n \n \t  if ((pass == 1  || dump_file) || ! flag_expensive_optimizations)\n-\t    for (class = 0; class < N_REG_CLASSES; class++)\n-\t      if (p->cost[class] < p->mem_cost\n-\t\t  && (reg_class_size[(int) reg_class_subunion[(int) alt][class]]\n+\t    for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t      if (p->cost[rclass] < p->mem_cost\n+\t\t  && (reg_class_size[(int) reg_class_subunion[(int) alt][rclass]]\n \t\t      > reg_class_size[(int) alt])\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t\t  && ! (in_inc_dec[i] && forbidden_inc_dec_class[class])\n+\t\t  && ! (in_inc_dec[i] && forbidden_inc_dec_class[rclass])\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n-\t\t  && ! invalid_mode_change_p (i, (enum reg_class) class,\n+\t\t  && ! invalid_mode_change_p (i, (enum reg_class) rclass,\n \t\t\t\t\t      PSEUDO_REGNO_MODE (i))\n #endif\n \t\t  )\n-\t\talt = reg_class_subunion[(int) alt][class];\n+\t\talt = reg_class_subunion[(int) alt][rclass];\n \n \t  /* If we don't add any classes, nothing to try.  */\n \t  if (alt == best)\n@@ -1517,7 +1517,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       int alt_cost = 0;\n       enum reg_class classes[MAX_RECOG_OPERANDS];\n       int allows_mem[MAX_RECOG_OPERANDS];\n-      int class;\n+      int rclass;\n \n       for (i = 0; i < n_ops; i++)\n \t{\n@@ -1617,17 +1617,17 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  switch (recog_data.operand_type[i])\n \t\t    {\n \t\t    case OP_INOUT:\n-\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t\tpp->cost[class] = (intable[class][op_class]\n-\t\t\t\t\t   + outtable[op_class][class]);\n+\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t\t\tpp->cost[rclass] = (intable[rclass][op_class]\n+\t\t\t\t\t   + outtable[op_class][rclass]);\n \t\t      break;\n \t\t    case OP_IN:\n-\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t\tpp->cost[class] = intable[class][op_class];\n+\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t\t\tpp->cost[rclass] = intable[rclass][op_class];\n \t\t      break;\n \t\t    case OP_OUT:\n-\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t\tpp->cost[class] = outtable[op_class][class];\n+\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t\t\tpp->cost[rclass] = outtable[op_class][rclass];\n \t\t      break;\n \t\t    }\n \n@@ -1861,17 +1861,17 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t  switch (recog_data.operand_type[i])\n \t\t    {\n \t\t    case OP_INOUT:\n-\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t\tpp->cost[class] = (intable[class][op_class]\n-\t\t\t\t\t   + outtable[op_class][class]);\n+\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t\t\tpp->cost[rclass] = (intable[rclass][op_class]\n+\t\t\t\t\t   + outtable[op_class][rclass]);\n \t\t      break;\n \t\t    case OP_IN:\n-\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t\tpp->cost[class] = intable[class][op_class];\n+\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t\t\tpp->cost[rclass] = intable[rclass][op_class];\n \t\t      break;\n \t\t    case OP_OUT:\n-\t\t      for (class = 0; class < N_REG_CLASSES; class++)\n-\t\t\tpp->cost[class] = outtable[op_class][class];\n+\t\t      for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t\t\tpp->cost[rclass] = outtable[op_class][rclass];\n \t\t      break;\n \t\t    }\n \n@@ -1949,9 +1949,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t    pp->mem_cost = MIN (pp->mem_cost,\n \t\t\t\t(qq->mem_cost + alt_cost) * scale);\n \n-\t    for (class = 0; class < N_REG_CLASSES; class++)\n-\t      pp->cost[class] = MIN (pp->cost[class],\n-\t\t\t\t     (qq->cost[class] + alt_cost) * scale);\n+\t    for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t      pp->cost[rclass] = MIN (pp->cost[rclass],\n+\t\t\t\t     (qq->cost[rclass] + alt_cost) * scale);\n \t  }\n     }\n \n@@ -1978,7 +1978,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t{\n \t  unsigned int regno = REGNO (ops[!i]);\n \t  enum machine_mode mode = GET_MODE (ops[!i]);\n-\t  int class;\n+\t  int rclass;\n \n \t  if (regno >= FIRST_PSEUDO_REGISTER && reg_pref != 0\n \t      && reg_pref[regno].prefclass != NO_REGS)\n@@ -1991,15 +1991,15 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\top_costs[i].cost[(unsigned char) pref] = -1;\n \t    }\n \t  else if (regno < FIRST_PSEUDO_REGISTER)\n-\t    for (class = 0; class < N_REG_CLASSES; class++)\n-\t      if (TEST_HARD_REG_BIT (reg_class_contents[class], regno)\n-\t\t  && reg_class_size[class] == (unsigned) CLASS_MAX_NREGS (class, mode))\n+\t    for (rclass = 0; rclass < N_REG_CLASSES; rclass++)\n+\t      if (TEST_HARD_REG_BIT (reg_class_contents[rclass], regno)\n+\t\t  && reg_class_size[rclass] == (unsigned) CLASS_MAX_NREGS (rclass, mode))\n \t\t{\n-\t\t  if (reg_class_size[class] == 1)\n-\t\t    op_costs[i].cost[class] = -1;\n-\t\t  else if (in_hard_reg_set_p (reg_class_contents[class],\n+\t\t  if (reg_class_size[rclass] == 1)\n+\t\t    op_costs[i].cost[rclass] = -1;\n+\t\t  else if (in_hard_reg_set_p (reg_class_contents[rclass],\n \t\t\t\t\t     mode, regno))\n-\t\t    op_costs[i].cost[class] = -1;\n+\t\t    op_costs[i].cost[rclass] = -1;\n \t\t}\n \t}\n }\n@@ -2010,7 +2010,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n    X must not be a pseudo.  */\n \n static int\n-copy_cost (rtx x, enum machine_mode mode, enum reg_class class, int to_p,\n+copy_cost (rtx x, enum machine_mode mode, enum reg_class rclass, int to_p,\n \t   secondary_reload_info *prev_sri)\n {\n   enum reg_class secondary_class = NO_REGS;\n@@ -2023,34 +2023,34 @@ copy_cost (rtx x, enum machine_mode mode, enum reg_class class, int to_p,\n     return 0;\n \n   /* Get the class we will actually use for a reload.  */\n-  class = PREFERRED_RELOAD_CLASS (x, class);\n+  rclass = PREFERRED_RELOAD_CLASS (x, rclass);\n \n   /* If we need a secondary reload for an intermediate, the\n      cost is that to load the input into the intermediate register, then\n      to copy it.  */\n \n   sri.prev_sri = prev_sri;\n   sri.extra_cost = 0;\n-  secondary_class = targetm.secondary_reload (to_p, x, class, mode, &sri);\n+  secondary_class = targetm.secondary_reload (to_p, x, rclass, mode, &sri);\n \n   if (!move_cost[mode])\n     init_move_cost (mode);\n \n   if (secondary_class != NO_REGS)\n-    return (move_cost[mode][(int) secondary_class][(int) class]\n+    return (move_cost[mode][(int) secondary_class][(int) rclass]\n \t    + sri.extra_cost\n \t    + copy_cost (x, mode, secondary_class, to_p, &sri));\n \n   /* For memory, use the memory move cost, for (hard) registers, use the\n      cost to move between the register classes, and use 2 for everything\n      else (constants).  */\n \n-  if (MEM_P (x) || class == NO_REGS)\n-    return sri.extra_cost + MEMORY_MOVE_COST (mode, class, to_p);\n+  if (MEM_P (x) || rclass == NO_REGS)\n+    return sri.extra_cost + MEMORY_MOVE_COST (mode, rclass, to_p);\n \n   else if (REG_P (x))\n     return (sri.extra_cost\n-\t    + move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) class]);\n+\t    + move_cost[mode][(int) REGNO_REG_CLASS (REGNO (x))][(int) rclass]);\n \n   else\n     /* If this is a constant, we may eventually want to call rtx_cost here.  */\n@@ -2076,12 +2076,12 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \t\t     int scale)\n {\n   enum rtx_code code = GET_CODE (x);\n-  enum reg_class class;\n+  enum reg_class rclass;\n \n   if (context == 1)\n-    class = INDEX_REG_CLASS;\n+    rclass = INDEX_REG_CLASS;\n   else\n-    class = base_reg_class (mode, outer_code, index_code);\n+    rclass = base_reg_class (mode, outer_code, index_code);\n \n   switch (code)\n     {\n@@ -2234,12 +2234,12 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \tstruct costs *pp = &costs[REGNO (x)];\n \tint i;\n \n-\tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, class, 1) * scale) / 2;\n+\tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, rclass, 1) * scale) / 2;\n \n \tif (!move_cost[Pmode])\n \t  init_move_cost (Pmode);\n \tfor (i = 0; i < N_REG_CLASSES; i++)\n-\t  pp->cost[i] += (may_move_in_cost[Pmode][i][(int) class] * scale) / 2;\n+\t  pp->cost[i] += (may_move_in_cost[Pmode][i][(int) rclass] * scale) / 2;\n       }\n       break;\n \n@@ -2627,7 +2627,7 @@ cannot_change_mode_set_regs (HARD_REG_SET *used, enum machine_mode from,\n \n bool\n invalid_mode_change_p (unsigned int regno,\n-\t\t       enum reg_class class ATTRIBUTE_UNUSED,\n+\t\t       enum reg_class rclass ATTRIBUTE_UNUSED,\n \t\t       enum machine_mode from)\n {\n   struct subregs_of_mode_node dummy, *node;\n@@ -2644,7 +2644,7 @@ invalid_mode_change_p (unsigned int regno,\n   mask = 1 << (regno & 7);\n   for (to = VOIDmode; to < NUM_MACHINE_MODES; to++)\n     if (node->modes[to] & mask)\n-      if (CANNOT_CHANGE_MODE_CLASS (from, to, class))\n+      if (CANNOT_CHANGE_MODE_CLASS (from, to, rclass))\n \treturn true;\n \n   return false;"}, {"sha": "0ed810e639387df125308a75adc2a484568fa195", "filename": "gcc/regrename.c", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d858f359363662cf2555f4d9c259d80aaecae031/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=d858f359363662cf2555f4d9c259d80aaecae031", "patch": "@@ -222,13 +222,13 @@ regrename_optimize (void)\n \t{\n \t  int new_reg, best_new_reg;\n \t  int n_uses;\n-\t  struct du_chain *this = all_chains;\n+\t  struct du_chain *this_du = all_chains;\n \t  struct du_chain *tmp, *last;\n \t  HARD_REG_SET this_unavailable;\n-\t  int reg = REGNO (*this->loc);\n+\t  int reg = REGNO (*this_du->loc);\n \t  int i;\n \n-\t  all_chains = this->next_chain;\n+\t  all_chains = this_du->next_chain;\n \n \t  best_new_reg = reg;\n \n@@ -256,7 +256,7 @@ regrename_optimize (void)\n \t     count number of uses, and narrow the set of registers we can\n \t     use for renaming.  */\n \t  n_uses = 0;\n-\t  for (last = this; last->next_use; last = last->next_use)\n+\t  for (last = this_du; last->next_use; last = last->next_use)\n \t    {\n \t      n_uses++;\n \t      IOR_COMPL_HARD_REG_SET (this_unavailable,\n@@ -268,16 +268,16 @@ regrename_optimize (void)\n \t  IOR_COMPL_HARD_REG_SET (this_unavailable,\n \t\t\t\t  reg_class_contents[last->cl]);\n \n-\t  if (this->need_caller_save_reg)\n+\t  if (this_du->need_caller_save_reg)\n \t    IOR_HARD_REG_SET (this_unavailable, call_used_reg_set);\n \n-\t  merge_overlapping_regs (bb, &this_unavailable, this);\n+\t  merge_overlapping_regs (bb, &this_unavailable, this_du);\n \n \t  /* Now potential_regs is a reasonable approximation, let's\n \t     have a closer look at each register still in there.  */\n \t  for (new_reg = 0; new_reg < FIRST_PSEUDO_REGISTER; new_reg++)\n \t    {\n-\t      int nregs = hard_regno_nregs[new_reg][GET_MODE (*this->loc)];\n+\t      int nregs = hard_regno_nregs[new_reg][GET_MODE (*this_du->loc)];\n \n \t      for (i = nregs - 1; i >= 0; --i)\n \t        if (TEST_HARD_REG_BIT (this_unavailable, new_reg + i)\n@@ -302,7 +302,7 @@ regrename_optimize (void)\n \n \t      /* See whether it accepts all modes that occur in\n \t\t definition and uses.  */\n-\t      for (tmp = this; tmp; tmp = tmp->next_use)\n+\t      for (tmp = this_du; tmp; tmp = tmp->next_use)\n \t\tif (! HARD_REGNO_MODE_OK (new_reg, GET_MODE (*tmp->loc))\n \t\t    || (tmp->need_caller_save_reg\n \t\t\t&& ! (HARD_REGNO_CALL_PART_CLOBBERED\n@@ -333,7 +333,7 @@ regrename_optimize (void)\n \t      continue;\n \t    }\n \n-\t  do_replace (this, best_new_reg);\n+\t  do_replace (this_du, best_new_reg);\n \t  tick[best_new_reg] = ++this_tick;\n \t  df_set_regs_ever_live (best_new_reg, true);\n \n@@ -385,15 +385,15 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n     {\n       if (type == OP_OUT)\n \t{\n-\t  struct du_chain *this = XOBNEW (&rename_obstack, struct du_chain);\n-\t  this->next_use = 0;\n-\t  this->next_chain = open_chains;\n-\t  this->loc = loc;\n-\t  this->insn = insn;\n-\t  this->cl = cl;\n-\t  this->need_caller_save_reg = 0;\n-\t  this->earlyclobber = earlyclobber;\n-\t  open_chains = this;\n+\t  struct du_chain *this_du = XOBNEW (&rename_obstack, struct du_chain);\n+\t  this_du->next_use = 0;\n+\t  this_du->next_chain = open_chains;\n+\t  this_du->loc = loc;\n+\t  this_du->insn = insn;\n+\t  this_du->cl = cl;\n+\t  this_du->need_caller_save_reg = 0;\n+\t  this_du->earlyclobber = earlyclobber;\n+\t  open_chains = this_du;\n \t}\n       return;\n     }\n@@ -403,7 +403,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \n   for (p = &open_chains; *p;)\n     {\n-      struct du_chain *this = *p;\n+      struct du_chain *this_du = *p;\n \n       /* Check if the chain has been terminated if it has then skip to\n \t the next chain.\n@@ -412,18 +412,18 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t the chain in Step 3, but are trying to hide in-out operands\n \t from terminate_write in Step 5.  */\n \n-      if (*this->loc == cc0_rtx)\n-\tp = &this->next_chain;\n+      if (*this_du->loc == cc0_rtx)\n+\tp = &this_du->next_chain;\n       else\n \t{\n-\t  int regno = REGNO (*this->loc);\n-\t  int nregs = hard_regno_nregs[regno][GET_MODE (*this->loc)];\n+\t  int regno = REGNO (*this_du->loc);\n+\t  int nregs = hard_regno_nregs[regno][GET_MODE (*this_du->loc)];\n \t  int exact_match = (regno == this_regno && nregs == this_nregs);\n \n \t  if (regno + nregs <= this_regno\n \t      || this_regno + this_nregs <= regno)\n \t    {\n-\t      p = &this->next_chain;\n+\t      p = &this_du->next_chain;\n \t      continue;\n \t    }\n \n@@ -437,23 +437,23 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t\t be replaced with, terminate the chain.  */\n \t      if (cl != NO_REGS)\n \t\t{\n-\t\t  this = XOBNEW (&rename_obstack, struct du_chain);\n-\t\t  this->next_use = 0;\n-\t\t  this->next_chain = (*p)->next_chain;\n-\t\t  this->loc = loc;\n-\t\t  this->insn = insn;\n-\t\t  this->cl = cl;\n-\t\t  this->need_caller_save_reg = 0;\n+\t\t  this_du = XOBNEW (&rename_obstack, struct du_chain);\n+\t\t  this_du->next_use = 0;\n+\t\t  this_du->next_chain = (*p)->next_chain;\n+\t\t  this_du->loc = loc;\n+\t\t  this_du->insn = insn;\n+\t\t  this_du->cl = cl;\n+\t\t  this_du->need_caller_save_reg = 0;\n \t\t  while (*p)\n \t\t    p = &(*p)->next_use;\n-\t\t  *p = this;\n+\t\t  *p = this_du;\n \t\t  return;\n \t\t}\n \t    }\n \n \t  if (action != terminate_overlapping_read || ! exact_match)\n \t    {\n-\t      struct du_chain *next = this->next_chain;\n+\t      struct du_chain *next = this_du->next_chain;\n \n \t      /* Whether the terminated chain can be used for renaming\n \t         depends on the action and this being an exact match.\n@@ -462,26 +462,26 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl,\n \t      if ((action == terminate_dead || action == terminate_write)\n \t\t  && exact_match)\n \t\t{\n-\t\t  this->next_chain = closed_chains;\n-\t\t  closed_chains = this;\n+\t\t  this_du->next_chain = closed_chains;\n+\t\t  closed_chains = this_du;\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Closing chain %s at insn %d (%s)\\n\",\n-\t\t\t     reg_names[REGNO (*this->loc)], INSN_UID (insn),\n+\t\t\t     reg_names[REGNO (*this_du->loc)], INSN_UID (insn),\n \t\t\t     scan_actions_name[(int) action]);\n \t\t}\n \t      else\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Discarding chain %s at insn %d (%s)\\n\",\n-\t\t\t     reg_names[REGNO (*this->loc)], INSN_UID (insn),\n+\t\t\t     reg_names[REGNO (*this_du->loc)], INSN_UID (insn),\n \t\t\t     scan_actions_name[(int) action]);\n \t\t}\n \t      *p = next;\n \t    }\n \t  else\n-\t    p = &this->next_chain;\n+\t    p = &this_du->next_chain;\n \t}\n     }\n }\n@@ -976,15 +976,15 @@ dump_def_use_chain (struct du_chain *chains)\n {\n   while (chains)\n     {\n-      struct du_chain *this = chains;\n-      int r = REGNO (*this->loc);\n-      int nregs = hard_regno_nregs[r][GET_MODE (*this->loc)];\n+      struct du_chain *this_du = chains;\n+      int r = REGNO (*this_du->loc);\n+      int nregs = hard_regno_nregs[r][GET_MODE (*this_du->loc)];\n       fprintf (dump_file, \"Register %s (%d):\", reg_names[r], nregs);\n-      while (this)\n+      while (this_du)\n \t{\n-\t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this->insn),\n-\t\t   reg_class_names[this->cl]);\n-\t  this = this->next_use;\n+\t  fprintf (dump_file, \" %d [%s]\", INSN_UID (this_du->insn),\n+\t\t   reg_class_names[this_du->cl]);\n+\t  this_du = this_du->next_use;\n \t}\n       fprintf (dump_file, \"\\n\");\n       chains = chains->next_chain;\n@@ -1365,17 +1365,17 @@ find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n   for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n     {\n       enum machine_mode oldmode = vd->e[i].mode;\n-      rtx new;\n+      rtx new_rtx;\n \n       if (!in_hard_reg_set_p (reg_class_contents[cl], mode, i))\n \treturn NULL_RTX;\n \n-      new = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i, regno);\n-      if (new)\n+      new_rtx = maybe_mode_change (oldmode, vd->e[regno].mode, mode, i, regno);\n+      if (new_rtx)\n \t{\n-\t  ORIGINAL_REGNO (new) = ORIGINAL_REGNO (reg);\n-\t  REG_ATTRS (new) = REG_ATTRS (reg);\n-\t  return new;\n+\t  ORIGINAL_REGNO (new_rtx) = ORIGINAL_REGNO (reg);\n+\t  REG_ATTRS (new_rtx) = REG_ATTRS (reg);\n+\t  return new_rtx;\n \t}\n     }\n \n@@ -1389,14 +1389,14 @@ static bool\n replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx insn,\n \t\t\t  struct value_data *vd)\n {\n-  rtx new = find_oldest_value_reg (cl, *loc, vd);\n-  if (new)\n+  rtx new_rtx = find_oldest_value_reg (cl, *loc, vd);\n+  if (new_rtx)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"insn %u: replaced reg %u with %u\\n\",\n-\t\t INSN_UID (insn), REGNO (*loc), REGNO (new));\n+\t\t INSN_UID (insn), REGNO (*loc), REGNO (new_rtx));\n \n-      validate_change (insn, loc, new, 1);\n+      validate_change (insn, loc, new_rtx, 1);\n       return true;\n     }\n   return false;\n@@ -1634,7 +1634,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  unsigned int regno = REGNO (src);\n \t  enum machine_mode mode = GET_MODE (src);\n \t  unsigned int i;\n-\t  rtx new;\n+\t  rtx new_rtx;\n \n \t  /* If we are accessing SRC in some mode other that what we\n \t     set it in, make sure that the replacement is valid.  */\n@@ -1649,13 +1649,13 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t     register in the same class.  */\n \t  if (REG_P (SET_DEST (set)))\n \t    {\n-\t      new = find_oldest_value_reg (REGNO_REG_CLASS (regno), src, vd);\n-\t      if (new && validate_change (insn, &SET_SRC (set), new, 0))\n+\t      new_rtx = find_oldest_value_reg (REGNO_REG_CLASS (regno), src, vd);\n+\t      if (new_rtx && validate_change (insn, &SET_SRC (set), new_rtx, 0))\n \t\t{\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"insn %u: replaced reg %u with %u\\n\",\n-\t\t\t     INSN_UID (insn), regno, REGNO (new));\n+\t\t\t     INSN_UID (insn), regno, REGNO (new_rtx));\n \t\t  changed = true;\n \t\t  goto did_replacement;\n \t\t}\n@@ -1665,18 +1665,18 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  for (i = vd->e[regno].oldest_regno; i != regno;\n \t       i = vd->e[i].next_regno)\n \t    {\n-\t      new = maybe_mode_change (vd->e[i].mode, vd->e[regno].mode,\n+\t      new_rtx = maybe_mode_change (vd->e[i].mode, vd->e[regno].mode,\n \t\t\t\t       mode, i, regno);\n-\t      if (new != NULL_RTX)\n+\t      if (new_rtx != NULL_RTX)\n \t\t{\n-\t\t  if (validate_change (insn, &SET_SRC (set), new, 0))\n+\t\t  if (validate_change (insn, &SET_SRC (set), new_rtx, 0))\n \t\t    {\n-\t\t      ORIGINAL_REGNO (new) = ORIGINAL_REGNO (src);\n-\t\t      REG_ATTRS (new) = REG_ATTRS (src);\n+\t\t      ORIGINAL_REGNO (new_rtx) = ORIGINAL_REGNO (src);\n+\t\t      REG_ATTRS (new_rtx) = REG_ATTRS (src);\n \t\t      if (dump_file)\n \t\t\tfprintf (dump_file,\n \t\t\t\t \"insn %u: replaced reg %u with %u\\n\",\n-\t\t\t\t INSN_UID (insn), regno, REGNO (new));\n+\t\t\t\t INSN_UID (insn), regno, REGNO (new_rtx));\n \t\t      changed = true;\n \t\t      goto did_replacement;\n \t\t    }\n@@ -1729,13 +1729,13 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t  if (replaced[i])\n \t    {\n \t      int j;\n-\t      rtx new;\n+\t      rtx new_rtx;\n \n-\t      new = *recog_data.operand_loc[i];\n-\t      recog_data.operand[i] = new;\n+\t      new_rtx = *recog_data.operand_loc[i];\n+\t      recog_data.operand[i] = new_rtx;\n \t      for (j = 0; j < recog_data.n_dups; j++)\n \t\tif (recog_data.dup_num[j] == i)\n-\t\t  validate_unshare_change (insn, recog_data.dup_loc[j], new, 1);\n+\t\t  validate_unshare_change (insn, recog_data.dup_loc[j], new_rtx, 1);\n \n \t      any_replacements = true;\n \t    }"}]}