{"sha": "6ea6c4978111d146db8d33c80d9da93d7bd2bc8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVhNmM0OTc4MTExZDE0NmRiOGQzM2M4MGQ5ZGE5M2Q3YmQyYmM4ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-05-22T06:22:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-05T07:16:41Z"}, "message": "Add new/delete to struct occurence\n\nThis adds an example how to use new/delete operators to pool\nallocated objects.\n\n2020-06-04  Jonathan Wakely  <jwakely@redhat.com>\n\n\t* alloc-pool.h (object_allocator::remove_raw): New.\n\t* tree-ssa-math-opts.c (struct occurrence): Use NSMDI.\n\t(occurrence::occurrence): Add.\n\t(occurrence::~occurrence): Likewise.\n\t(occurrence::new): Likewise.\n\t(occurrence::delete): Likewise.\n\t(occ_new): Remove.\n\t(insert_bb): Use new occurence (...) instead of occ_new.\n\t(register_division_in): Likewise.\n\t(free_bb): Use delete occ instead of manually removing\n\tfrom the pool.", "tree": {"sha": "a548cf85aba746bcf124a908512a8ff704e4fe00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a548cf85aba746bcf124a908512a8ff704e4fe00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80d6f89e78fc3b772701988cc73aa8e8006283be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80d6f89e78fc3b772701988cc73aa8e8006283be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80d6f89e78fc3b772701988cc73aa8e8006283be"}], "stats": {"total": 71, "additions": 45, "deletions": 26}, "files": [{"sha": "4e78dcf6178ae75c16b37f5074fdc5bbfbdcdbba", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=6ea6c4978111d146db8d33c80d9da93d7bd2bc8d", "patch": "@@ -524,6 +524,12 @@ class object_allocator\n     m_allocator.remove (object);\n   }\n \n+  inline void\n+  remove_raw (void *object)\n+  {\n+    m_allocator.remove (object);\n+  }\n+\n   inline size_t\n   num_elts_current ()\n   {"}, {"sha": "104ae97a7072d63c2b98752b1bf2436ba19de3cc", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ea6c4978111d146db8d33c80d9da93d7bd2bc8d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=6ea6c4978111d146db8d33c80d9da93d7bd2bc8d", "patch": "@@ -121,37 +121,57 @@ along with GCC; see the file COPYING3.  If not see\n    division.  */\n struct occurrence {\n   /* The basic block represented by this structure.  */\n-  basic_block bb;\n+  basic_block bb = basic_block();\n \n   /* If non-NULL, the SSA_NAME holding the definition for a reciprocal\n      inserted in BB.  */\n-  tree recip_def;\n+  tree recip_def = tree();\n \n   /* If non-NULL, the SSA_NAME holding the definition for a squared\n      reciprocal inserted in BB.  */\n-  tree square_recip_def;\n+  tree square_recip_def = tree();\n \n   /* If non-NULL, the GIMPLE_ASSIGN for a reciprocal computation that\n      was inserted in BB.  */\n-  gimple *recip_def_stmt;\n+  gimple *recip_def_stmt = nullptr;\n \n   /* Pointer to a list of \"struct occurrence\"s for blocks dominated\n      by BB.  */\n-  struct occurrence *children;\n+  struct occurrence *children = nullptr;\n \n   /* Pointer to the next \"struct occurrence\"s in the list of blocks\n      sharing a common dominator.  */\n-  struct occurrence *next;\n+  struct occurrence *next = nullptr;\n \n   /* The number of divisions that are in BB before compute_merit.  The\n      number of divisions that are in BB or post-dominate it after\n      compute_merit.  */\n-  int num_divisions;\n+  int num_divisions = 0;\n \n   /* True if the basic block has a division, false if it is a common\n      dominator for basic blocks that do.  If it is false and trapping\n      math is active, BB is not a candidate for inserting a reciprocal.  */\n-  bool bb_has_division;\n+  bool bb_has_division = false;\n+\n+  /* Construct a struct occurrence for basic block BB, and whose\n+     children list is headed by CHILDREN.  */\n+  occurrence (basic_block bb, struct occurrence *children)\n+  : bb (bb), children (children)\n+  {\n+    bb->aux = this;\n+  }\n+\n+  /* Destroy a struct occurrence and remove it from its basic block.  */\n+  ~occurrence ()\n+  {\n+    bb->aux = nullptr;\n+  }\n+\n+  /* Allocate memory for a struct occurrence from OCC_POOL.  */\n+  static void* operator new (size_t);\n+\n+  /* Return memory for a struct occurrence to OCC_POOL.  */\n+  static void operator delete (void*, size_t);\n };\n \n static struct\n@@ -191,23 +211,17 @@ static struct occurrence *occ_head;\n /* Allocation pool for getting instances of \"struct occurrence\".  */\n static object_allocator<occurrence> *occ_pool;\n \n-\n-\n-/* Allocate and return a new struct occurrence for basic block BB, and\n-   whose children list is headed by CHILDREN.  */\n-static struct occurrence *\n-occ_new (basic_block bb, struct occurrence *children)\n+void* occurrence::operator new (size_t n)\n {\n-  struct occurrence *occ;\n-\n-  bb->aux = occ = occ_pool->allocate ();\n-  memset (occ, 0, sizeof (struct occurrence));\n-\n-  occ->bb = bb;\n-  occ->children = children;\n-  return occ;\n+  gcc_assert (n == sizeof(occurrence));\n+  return occ_pool->allocate_raw ();\n }\n \n+void occurrence::operator delete (void *occ, size_t n)\n+{\n+  gcc_assert (n == sizeof(occurrence));\n+  occ_pool->remove_raw (occ);\n+}\n \n /* Insert NEW_OCC into our subset of the dominator tree.  P_HEAD points to a\n    list of \"struct occurrence\"s, one per basic block, having IDOM as\n@@ -259,7 +273,7 @@ insert_bb (struct occurrence *new_occ, basic_block idom,\n \t  /* None of the previous blocks has DOM as a dominator: if we tail\n \t     recursed, we would reexamine them uselessly. Just switch BB with\n \t     DOM, and go on looking for blocks dominated by DOM.  */\n-          new_occ = occ_new (dom, new_occ);\n+\t  new_occ = new occurrence (dom, new_occ);\n \t}\n \n       else\n@@ -288,7 +302,7 @@ register_division_in (basic_block bb, int importance)\n   occ = (struct occurrence *) bb->aux;\n   if (!occ)\n     {\n-      occ = occ_new (bb, NULL);\n+      occ = new occurrence (bb, NULL);\n       insert_bb (occ, ENTRY_BLOCK_PTR_FOR_FN (cfun), &occ_head);\n     }\n \n@@ -518,8 +532,7 @@ free_bb (struct occurrence *occ)\n   /* First get the two pointers hanging off OCC.  */\n   next = occ->next;\n   child = occ->children;\n-  occ->bb->aux = NULL;\n-  occ_pool->remove (occ);\n+  delete occ;\n \n   /* Now ensure that we don't recurse unless it is necessary.  */\n   if (!child)"}]}