{"sha": "df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY2NTI1ODU3NWNlOWMxZTNhZThjYTYyOTdjYmU5YzFhNWE1NmFjMw==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-10-29T08:03:47Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2012-10-29T08:03:47Z"}, "message": "i386.c (ix86_decompose_address): Use simplify_gen_subreg to generate SImode equivalent of address...\n\n\t* config/i386/i386.c (ix86_decompose_address): Use simplify_gen_subreg\n\tto generate SImode equivalent of address, zero-extended with AND RTX.\n\t* config/i386/i386.md (ashift to lea splitter): Split to SImode mult.\n\t(simple lea to add/shift peephole2s): Remove peephole2s that operate\n\ton subregs of DImode operations.\n\nFrom-SVN: r192908", "tree": {"sha": "7e41777986763904722065cb1ff51ba59415de4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e41777986763904722065cb1ff51ba59415de4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/comments", "author": null, "committer": null, "parents": [{"sha": "bc3591eb9fba3f19958f7642c755cf65c137f9a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc3591eb9fba3f19958f7642c755cf65c137f9a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc3591eb9fba3f19958f7642c755cf65c137f9a1"}], "stats": {"total": 106, "additions": 19, "deletions": 87}, "files": [{"sha": "54b596b1f86db8270af3b1085ff8331f603eee67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "patch": "@@ -1,10 +1,17 @@\n+2012-10-29  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.c (ix86_decompose_address): Use simplify_gen_subreg\n+\tto generate SImode equivalent of address, zero-extended with AND RTX.\n+\t* config/i386/i386.md (ashift to lea splitter): Split to SImode mult.\n+\t(simple lea to add/shift peephole2s): Remove peephole2s that operate\n+\ton subregs of DImode operations.\n+\n 2012-10-28  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/55106\n \t* lra-constraints.c (skip_usage_debug_insns): New function.\n \t(check_secondary_memory_needed_p): Ditto.\n-\t(inherit_reload_reg): Use the new functions.  Improve debug\n-\toutput.\n+\t(inherit_reload_reg): Use the new functions.  Improve debug output.\n \n 2012-10-29  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n@@ -47,7 +54,8 @@\n \n \t* ipa-inline.c (edge_badness): Reduce precision; use scc hints.\n \t(inline_small_functions): Fix dumps; update all callees after inlining.\n-\t* ipa-inline.h (INLINE_HINT_in_scc, INLINE_HINT_same_scc): New constants.\n+\t* ipa-inline.h (INLINE_HINT_in_scc, INLINE_HINT_same_scc): New\n+\tconstants.\n \t(inline summary): Add SCC_NO.\n \t* ipa-inline-analysis.c (dump_inline_hints): Dump SCC hints.\n \t(reset_inline_summary): Reset scc_no."}, {"sha": "2931e62bed9e8ae5b64f6f0d7e5a16887bcb850b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "patch": "@@ -11821,7 +11821,11 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t\treturn 0;\n \t    }\n \t  else if (GET_MODE (addr) == DImode)\n-\t    addr = gen_rtx_SUBREG (SImode, addr, 0);\n+\t    {\n+\t      addr = simplify_gen_subreg (SImode, addr, DImode, 0);\n+\t      if (addr == NULL_RTX)\n+\t\treturn 0;\n+\t    }\n \t  else if (GET_MODE (addr) != VOIDmode)\n \t    return 0;\n \t}"}, {"sha": "538120c8f2264e275ec42c2d9377a4f393ec1504", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 83, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=df65258575ce9c1e3ae8ca6297cbe9c1a5a56ac3", "patch": "@@ -9600,10 +9600,10 @@\n   \"TARGET_64BIT && reload_completed\n    && true_regnum (operands[0]) != true_regnum (operands[1])\"\n   [(set (match_dup 0)\n-\t(zero_extend:DI (subreg:SI (mult:DI (match_dup 1) (match_dup 2)) 0)))]\n+\t(zero_extend:DI (mult:SI (match_dup 1) (match_dup 2))))]\n {\n-  operands[1] = gen_lowpart (DImode, operands[1]);\n-  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), DImode);\n+  operands[1] = gen_lowpart (SImode, operands[1]);\n+  operands[2] = gen_int_mode (1 << INTVAL (operands[2]), SImode);\n })\n \n ;; This pattern can't accept a variable shift count, since shifts by\n@@ -17357,28 +17357,6 @@\n   [(parallel [(set (match_dup 0) (plus:SWI48 (match_dup 0) (match_dup 1)))\n \t      (clobber (reg:CC FLAGS_REG))])])\n \n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\")\n-  \t(subreg:SI (plus:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t    (match_operand:DI 2 \"nonmemory_operand\")) 0))]\n-  \"TARGET_64BIT && !TARGET_OPT_AGU\n-   && REGNO (operands[0]) == REGNO (operands[1])\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = gen_lowpart (SImode, operands[2]);\")\n-\n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\")\n-  \t(subreg:SI (plus:DI (match_operand:DI 1 \"nonmemory_operand\")\n-\t\t\t    (match_operand:DI 2 \"register_operand\")) 0))]\n-  \"TARGET_64BIT && !TARGET_OPT_AGU\n-   && REGNO (operands[0]) == REGNO (operands[2])\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (plus:SI (match_dup 0) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[1] = gen_lowpart (SImode, operands[1]);\")\n-\n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\")\n   \t(zero_extend:DI\n@@ -17403,36 +17381,6 @@\n \t\t   (zero_extend:DI (plus:SI (match_dup 2) (match_dup 1))))\n \t      (clobber (reg:CC FLAGS_REG))])])\n \n-(define_peephole2\n-  [(set (match_operand:DI 0 \"register_operand\")\n-  \t(zero_extend:DI\n-\t  (subreg:SI (plus:DI (match_dup 0)\n-\t\t\t      (match_operand:DI 1 \"nonmemory_operand\")) 0)))]\n-  \"TARGET_64BIT && !TARGET_OPT_AGU\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (plus:SI (match_dup 2) (match_dup 1))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_lowpart (SImode, operands[0]);\n-})\n-\n-(define_peephole2\n-  [(set (match_operand:DI 0 \"register_operand\")\n-  \t(zero_extend:DI\n-\t  (subreg:SI (plus:DI (match_operand:DI 1 \"nonmemory_operand\")\n-\t\t     \t      (match_dup 0)) 0)))]\n-  \"TARGET_64BIT && !TARGET_OPT_AGU\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (plus:SI (match_dup 2) (match_dup 1))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  operands[1] = gen_lowpart (SImode, operands[1]);\n-  operands[2] = gen_lowpart (SImode, operands[0]);\n-})\n-\n (define_peephole2\n   [(set (match_operand:SWI48 0 \"register_operand\")\n   \t(mult:SWI48 (match_dup 0)\n@@ -17443,18 +17391,6 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[1] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n \n-(define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\")\n-  \t(subreg:SI (mult:DI (match_operand:DI 1 \"register_operand\")\n-\t\t\t    (match_operand:DI 2 \"const_int_operand\")) 0))]\n-  \"TARGET_64BIT\n-   && exact_log2 (INTVAL (operands[2])) >= 0\n-   && REGNO (operands[0]) == REGNO (operands[1])\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\")\n-\n (define_peephole2\n   [(set (match_operand:DI 0 \"register_operand\")\n   \t(zero_extend:DI\n@@ -17469,22 +17405,6 @@\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[2])));\")\n \n-(define_peephole2\n-  [(set (match_operand:DI 0 \"register_operand\")\n-  \t(zero_extend:DI\n-  \t  (subreg:SI (mult:DI (match_dup 0)\n-\t\t\t      (match_operand:DI 1 \"const_int_operand\")) 0)))]\n-  \"TARGET_64BIT\n-   && exact_log2 (INTVAL (operands[2])) >= 0\n-   && peep2_regno_dead_p (0, FLAGS_REG)\"\n-  [(parallel [(set (match_dup 0)\n-\t\t   (zero_extend:DI (ashift:SI (match_dup 2) (match_dup 1))))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-{\n-  operands[1] = GEN_INT (exact_log2 (INTVAL (operands[1])));\n-  operands[2] = gen_lowpart (SImode, operands[0]);\n-})\n-\n ;; The ESP adjustments can be done by the push and pop instructions.  Resulting\n ;; code is shorter, since push is only 1 byte, while add imm, %esp is 3 bytes.\n ;; On many CPUs it is also faster, since special hardware to avoid esp"}]}