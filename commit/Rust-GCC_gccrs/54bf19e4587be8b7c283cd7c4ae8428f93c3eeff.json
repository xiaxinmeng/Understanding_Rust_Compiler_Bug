{"sha": "54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRiZjE5ZTQ1ODdiZThiN2MyODNjZDdjNGFlODQyOGY5M2MzZWVmZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T09:26:02Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-06T09:26:02Z"}, "message": "[multiple changes]\n\n2011-09-06  Robert Dewar  <dewar@adacore.com>\n\n\t* s-osinte-linux.ads, a-iteint.ads, exp_ch6.adb, s-solita.adb: Minor\n\treformatting.\n\n2011-09-06  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-linux-alpha.ads: Minor reformatting\n\t* s-oscons-tmplt.c: Fix generated comments in s-oscons template.\n\tUse sizeof instead of corresponding C defines in s-oscons template.\n\nFrom-SVN: r178575", "tree": {"sha": "04af017264944687bbcfded1b7a11882cfc2a654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/04af017264944687bbcfded1b7a11882cfc2a654"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/comments", "author": null, "committer": null, "parents": [{"sha": "5d42cba16ff7e65fc27cb01f4c181ca5a501aa6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d42cba16ff7e65fc27cb01f4c181ca5a501aa6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d42cba16ff7e65fc27cb01f4c181ca5a501aa6e"}], "stats": {"total": 279, "additions": 147, "deletions": 132}, "files": [{"sha": "23e43296ab821411bc89d866d440d0a389aac524", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -1,3 +1,14 @@\n+2011-09-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-osinte-linux.ads, a-iteint.ads, exp_ch6.adb, s-solita.adb: Minor\n+\treformatting.\n+\n+2011-09-06  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-linux-alpha.ads: Minor reformatting\n+\t* s-oscons-tmplt.c: Fix generated comments in s-oscons template.\n+\tUse sizeof instead of corresponding C defines in s-oscons template.\n+\n 2011-09-06  Vadim Godunko  <godunko@adacore.com>\n \n \t* a-convec.ads, a-iteint.ads: Minor reformatting."}, {"sha": "8ac9e1a12e239477ad746e4ae14e8391a8a7753a", "filename": "gcc/ada/a-iteint.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fa-iteint.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fa-iteint.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-iteint.ads?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -22,13 +22,17 @@ package Ada.Iterator_Interfaces is\n    pragma Pure;\n \n    type Forward_Iterator is limited interface;\n-   function First (Object : Forward_Iterator) return Cursor is abstract;\n+\n+   function First\n+     (Object : Forward_Iterator) return Cursor is abstract;\n    function Next\n      (Object   : Forward_Iterator;\n       Position : Cursor) return Cursor is abstract;\n \n    type Reversible_Iterator is limited interface and Forward_Iterator;\n-   function Last (Object : Reversible_Iterator) return Cursor is abstract;\n+\n+   function Last\n+     (Object : Reversible_Iterator) return Cursor is abstract;\n    function Previous\n      (Object   : Reversible_Iterator;\n       Position : Cursor) return Cursor is abstract;"}, {"sha": "f5765a32c78bae44b77f25d55764c2301118bdec", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 103, "deletions": 104, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -4031,20 +4031,20 @@ package body Exp_Ch6 is\n \n             Insert_After (Parent (Entity (N)), Blk);\n \n-         --  If the context is an assignment, and the left-hand side is\n-         --  free of side-effects, the replacement is also safe.\n+         --  If the context is an assignment, and the left-hand side is free of\n+         --  side-effects, the replacement is also safe.\n          --  Can this be generalized further???\n \n          elsif Nkind (Parent (N)) = N_Assignment_Statement\n            and then\n             (Is_Entity_Name (Name (Parent (N)))\n-               or else\n-                  (Nkind (Name (Parent (N))) = N_Explicit_Dereference\n-                   and then Is_Entity_Name (Prefix (Name (Parent (N)))))\n+              or else\n+                (Nkind (Name (Parent (N))) = N_Explicit_Dereference\n+                  and then Is_Entity_Name (Prefix (Name (Parent (N)))))\n \n-               or else\n-               (Nkind (Name (Parent (N))) = N_Selected_Component\n-                   and then Is_Entity_Name (Prefix (Name (Parent (N))))))\n+              or else\n+                (Nkind (Name (Parent (N))) = N_Selected_Component\n+                  and then Is_Entity_Name (Prefix (Name (Parent (N))))))\n          then\n             --  Replace assignment with the block\n \n@@ -4210,26 +4210,22 @@ package body Exp_Ch6 is\n       end if;\n \n       --  For the unconstrained case, capture the name of the local variable\n-      --  that holds the result. This must be the first declaration\n-      --  in the block, because its bounds cannot depend on local variables.\n-      --  Otherwise there is no way to declare the result outside of the\n-      --  block. Needless to say, in general the bounds will depend on the\n-      --  actuals in the call.\n+      --  that holds the result. This must be the first declaration in the\n+      --  block, because its bounds cannot depend on local variables. Otherwise\n+      --  there is no way to declare the result outside of the block. Needless\n+      --  to say, in general the bounds will depend on the actuals in the call.\n+\n       --  If the context is an assignment statement, as is the case for the\n       --  expansion of an extended return, the left-hand side provides bounds\n       --  even if the return type is unconstrained.\n \n-      if Is_Unc\n-        and then Nkind (Parent (N)) /= N_Assignment_Statement\n-      then\n+      if Is_Unc and then Nkind (Parent (N)) /= N_Assignment_Statement then\n          Targ1 := Defining_Identifier (First (Declarations (Blk)));\n       end if;\n \n       --  If this is a derived function, establish the proper return type\n \n-      if Present (Orig_Subp)\n-        and then Orig_Subp /= Subp\n-      then\n+      if Present (Orig_Subp) and then Orig_Subp /= Subp then\n          Ret_Type := Etype (Orig_Subp);\n       else\n          Ret_Type := Etype (Subp);\n@@ -4413,7 +4409,7 @@ package body Exp_Ch6 is\n                Decl :=\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Temp,\n-                   Object_Definition =>\n+                   Object_Definition   =>\n                      New_Copy_Tree (Object_Definition (Parent (Targ1))));\n \n                Replace_Formals (Decl);\n@@ -4422,8 +4418,7 @@ package body Exp_Ch6 is\n                Decl :=\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Temp,\n-                   Object_Definition =>\n-                     New_Occurrence_Of (Ret_Type, Loc));\n+                   Object_Definition   => New_Occurrence_Of (Ret_Type, Loc));\n \n                Set_Etype (Temp, Ret_Type);\n             end if;\n@@ -4443,9 +4438,7 @@ package body Exp_Ch6 is\n       Replace_Formals (Blk);\n       Set_Parent (Blk, N);\n \n-      if not Comes_From_Source (Subp)\n-        or else Is_Predef\n-      then\n+      if not Comes_From_Source (Subp) or else Is_Predef then\n          Reset_Slocs (Blk);\n       end if;\n \n@@ -4457,7 +4450,7 @@ package body Exp_Ch6 is\n          if Num_Ret = 1\n            and then\n              Nkind (Last (Statements (Handled_Statement_Sequence (Blk)))) =\n-               N_Goto_Statement\n+                                                            N_Goto_Statement\n          then\n             Remove (Last (Statements (Handled_Statement_Sequence (Blk))));\n          else\n@@ -4495,6 +4488,7 @@ package body Exp_Ch6 is\n \n       if Ekind (Subp) = E_Procedure then\n          Rewrite_Procedure_Call (N, Blk);\n+\n       else\n          Rewrite_Function_Call (N, Blk);\n \n@@ -4956,12 +4950,12 @@ package body Exp_Ch6 is\n          Set_Identifier\n            (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n \n-         --  If the object decl was already rewritten as a renaming, then\n-         --  we don't want to do the object allocation and transformation of\n-         --  of the return object declaration to a renaming. This case occurs\n+         --  If the object decl was already rewritten as a renaming, then we\n+         --  don't want to do the object allocation and transformation of of\n+         --  the return object declaration to a renaming. This case occurs\n          --  when the return object is initialized by a call to another\n-         --  build-in-place function, and that function is responsible for the\n-         --  allocation of the return object.\n+         --  build-in-place function, and that function is responsible for\n+         --  the allocation of the return object.\n \n          if Is_Build_In_Place\n            and then Nkind (Ret_Obj_Decl) = N_Object_Renaming_Declaration\n@@ -5245,9 +5239,9 @@ package body Exp_Ch6 is\n                         --  The allocator is returned on the secondary stack,\n                         --  so indicate that the function return, as well as\n                         --  the block that encloses the allocator, must not\n-                        --  release it. The flags must be set now because the\n-                        --  decision to use the secondary stack is done very\n-                        --  late in the course of expanding the return\n+                        --  release it. The flags must be set now because\n+                        --  the decision to use the secondary stack is done\n+                        --  very late in the course of expanding the return\n                         --  statement, past the point where these flags are\n                         --  normally set.\n \n@@ -5324,10 +5318,10 @@ package body Exp_Ch6 is\n                      --  If a separate initialization assignment was created\n                      --  earlier, append that following the assignment of the\n                      --  implicit access formal to the access object, to ensure\n-                     --  that the return object is initialized in that case.\n-                     --  In this situation, the target of the assignment must\n-                     --  be rewritten to denote a dereference of the access to\n-                     --  the return object passed in by the caller.\n+                     --  that the return object is initialized in that case. In\n+                     --  this situation, the target of the assignment must be\n+                     --  rewritten to denote a dereference of the access to the\n+                     --  return object passed in by the caller.\n \n                      if Present (Init_Assignment) then\n                         Rewrite (Name (Init_Assignment),\n@@ -5975,10 +5969,10 @@ package body Exp_Ch6 is\n             Pop_Scope;\n          end if;\n \n-      --  Ada 2005 (AI-348): Generate body for a null procedure.\n-      --  In most cases this is superfluous because calls to it\n-      --  will be automatically inlined, but we definitely need\n-      --  the body if preconditions for the procedure are present.\n+      --  Ada 2005 (AI-348): Generate body for a null procedure. In most\n+      --  cases this is superfluous because calls to it will be automatically\n+      --  inlined, but we definitely need the body if preconditions for the\n+      --  procedure are present.\n \n       elsif Nkind (Specification (N)) = N_Procedure_Specification\n         and then Null_Present (Specification (N))\n@@ -6016,11 +6010,11 @@ package body Exp_Ch6 is\n \n    begin\n       --  Call _Postconditions procedure if procedure with active\n-      --  postconditions. Here, we use the Postcondition_Proc attribute, which\n-      --  is needed for implicitly-generated returns. Functions never\n-      --  have implicitly-generated returns, and there's no room for\n-      --  Postcondition_Proc in E_Function, so we look up the identifier\n-      --  Name_uPostconditions for function returns (see\n+      --  postconditions. Here, we use the Postcondition_Proc attribute,\n+      --  which is needed for implicitly-generated returns. Functions\n+      --  never have implicitly-generated returns, and there's no\n+      --  room for Postcondition_Proc in E_Function, so we look up the\n+      --  identifier Name_uPostconditions for function returns (see\n       --  Expand_Simple_Function_Return).\n \n       if Ekind (Scope_Id) = E_Procedure\n@@ -6225,13 +6219,13 @@ package body Exp_Ch6 is\n       Rec   : Node_Id;\n \n    begin\n-      --  If the protected object is not an enclosing scope, this is an\n-      --  inter-object function call. Inter-object procedure calls are expanded\n-      --  by Exp_Ch9.Build_Simple_Entry_Call. The call is intra-object only if\n-      --  the subprogram being called is in the protected body being compiled,\n-      --  and if the protected object in the call is statically the enclosing\n-      --  type. The object may be an component of some other data structure, in\n-      --  which case this must be handled as an inter-object call.\n+      --  If the protected object is not an enclosing scope, this is an inter-\n+      --  object function call. Inter-object procedure calls are expanded by\n+      --  Exp_Ch9.Build_Simple_Entry_Call. The call is intra-object only if the\n+      --  subprogram being called is in the protected body being compiled, and\n+      --  if the protected object in the call is statically the enclosing type.\n+      --  The object may be an component of some other data structure, in which\n+      --  case this must be handled as an inter-object call.\n \n       if not In_Open_Scopes (Scop)\n         or else not Is_Entity_Name (Name (N))\n@@ -6311,8 +6305,8 @@ package body Exp_Ch6 is\n    -- Expand_Simple_Function_Return --\n    -----------------------------------\n \n-   --  The \"simple\" comes from the syntax rule simple_return_statement.\n-   --  The semantics are not at all simple!\n+   --  The \"simple\" comes from the syntax rule simple_return_statement. The\n+   --  semantics are not at all simple!\n \n    procedure Expand_Simple_Function_Return (N : Node_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n@@ -6333,12 +6327,12 @@ package body Exp_Ch6 is\n       --  The type of the expression (not necessarily the same as R_Type)\n \n       Subtype_Ind : Node_Id;\n-      --  If the result type of the function is class-wide and the\n-      --  expression has a specific type, then we use the expression's\n-      --  type as the type of the return object. In cases where the\n-      --  expression is an aggregate that is built in place, this avoids\n-      --  the need for an expensive conversion of the return object to\n-      --  the specific type on assignments to the individual components.\n+      --  If the result type of the function is class-wide and the expression\n+      --  has a specific type, then we use the expression's type as the type of\n+      --  the return object. In cases where the expression is an aggregate that\n+      --  is built in place, this avoids the need for an expensive conversion\n+      --  of the return object to the specific type on assignments to the\n+      --  individual components.\n \n    begin\n       if Is_Class_Wide_Type (R_Type)\n@@ -6502,13 +6496,13 @@ package body Exp_Ch6 is\n          --  Optimize the case where the result is a function call. In this\n          --  case either the result is already on the secondary stack, or is\n          --  already being returned with the stack pointer depressed and no\n-         --  further processing is required except to set the By_Ref flag to\n-         --  ensure that gigi does not attempt an extra unnecessary copy.\n+         --  further processing is required except to set the By_Ref flag\n+         --  to ensure that gigi does not attempt an extra unnecessary copy.\n          --  (actually not just unnecessary but harmfully wrong in the case\n          --  of a controlled type, where gigi does not know how to do a copy).\n-         --  To make up for a gcc 2.8.1 deficiency (???), we perform\n-         --  the copy for array types if the constrained status of the\n-         --  target type is different from that of the expression.\n+         --  To make up for a gcc 2.8.1 deficiency (???), we perform the copy\n+         --  for array types if the constrained status of the target type is\n+         --  different from that of the expression.\n \n          if Requires_Transient_Scope (Exptyp)\n            and then\n@@ -6602,12 +6596,12 @@ package body Exp_Ch6 is\n          end if;\n       end if;\n \n-      --  Implement the rules of 6.5(8-10), which require a tag check in the\n-      --  case of a limited tagged return type, and tag reassignment for\n+      --  Implement the rules of 6.5(8-10), which require a tag check in\n+      --  the case of a limited tagged return type, and tag reassignment for\n       --  nonlimited tagged results. These actions are needed when the return\n       --  type is a specific tagged type and the result expression is a\n-      --  conversion or a formal parameter, because in that case the tag of the\n-      --  expression might differ from the tag of the specific result type.\n+      --  conversion or a formal parameter, because in that case the tag of\n+      --  the expression might differ from the tag of the specific result type.\n \n       if Is_Tagged_Type (Utyp)\n         and then not Is_Class_Wide_Type (Utyp)\n@@ -6616,8 +6610,8 @@ package body Exp_Ch6 is\n                     or else (Is_Entity_Name (Exp)\n                                and then Ekind (Entity (Exp)) in Formal_Kind))\n       then\n-         --  When the return type is limited, perform a check that the\n-         --  tag of the result is the same as the tag of the return type.\n+         --  When the return type is limited, perform a check that the tag of\n+         --  the result is the same as the tag of the return type.\n \n          if Is_Limited_Type (R_Type) then\n             Insert_Action (Exp,\n@@ -6637,8 +6631,8 @@ package body Exp_Ch6 is\n \n          --  If the result type is a specific nonlimited tagged type, then we\n          --  have to ensure that the tag of the result is that of the result\n-         --  type. This is handled by making a copy of the expression in the\n-         --  case where it might have a different tag, namely when the\n+         --  type. This is handled by making a copy of the expression in\n+         --  the case where it might have a different tag, namely when the\n          --  expression is a conversion or a formal parameter. We create a new\n          --  object of the result type and initialize it from the expression,\n          --  which will implicitly force the tag to be set appropriately.\n@@ -6838,9 +6832,9 @@ package body Exp_Ch6 is\n             case Nkind (Discrim_Source) is\n                when N_Defining_Identifier =>\n \n-                  pragma Assert (Is_Composite_Type (Discrim_Source) and then\n-                                 Has_Discriminants (Discrim_Source) and then\n-                                 Is_Constrained (Discrim_Source));\n+                  pragma Assert (Is_Composite_Type (Discrim_Source)\n+                                  and then Has_Discriminants (Discrim_Source)\n+                                  and then Is_Constrained (Discrim_Source));\n \n                   declare\n                      Discrim   : Entity_Id :=\n@@ -6851,8 +6845,8 @@ package body Exp_Ch6 is\n                   begin\n                      loop\n                         if Ekind (Etype (Discrim)) =\n-                          E_Anonymous_Access_Type then\n-\n+                             E_Anonymous_Access_Type\n+                        then\n                            Check_Against_Result_Level\n                              (Dynamic_Accessibility_Level (Node (Disc_Elmt)));\n                         end if;\n@@ -6865,8 +6859,8 @@ package body Exp_Ch6 is\n \n                when N_Aggregate | N_Extension_Aggregate =>\n \n-                  --  Unimplemented: extension aggregate case where\n-                  --  discrims come from ancestor part, not extension part.\n+                  --  Unimplemented: extension aggregate case where discrims\n+                  --  come from ancestor part, not extension part.\n \n                   declare\n                      Discrim  : Entity_Id :=\n@@ -6894,18 +6888,19 @@ package body Exp_Ch6 is\n                        (Comp_Id : Entity_Id;\n                         Associations : List_Id) return Node_Id\n                      is\n-                        Assoc  : Node_Id := First (Associations);\n+                        Assoc  : Node_Id;\n                         Choice : Node_Id;\n+\n                      begin\n                         --  Simple linear search seems ok here\n \n+                        Assoc := First (Associations);\n                         while Present (Assoc) loop\n                            Choice := First (Choices (Assoc));\n-\n                            while Present (Choice) loop\n                               if (Nkind (Choice) = N_Identifier\n-                                  and then Chars (Choice) = Chars (Comp_Id))\n-                                 or else (Nkind (Choice) = N_Others_Choice)\n+                                   and then Chars (Choice) = Chars (Comp_Id))\n+                                or else (Nkind (Choice) = N_Others_Choice)\n                               then\n                                  return Expression (Assoc);\n                               end if;\n@@ -6928,13 +6923,15 @@ package body Exp_Ch6 is\n \n                      loop\n                         if Positionals_Exhausted then\n-                           Disc_Exp := Associated_Expr (Discrim,\n-                             Component_Associations (Discrim_Source));\n+                           Disc_Exp :=\n+                             Associated_Expr\n+                               (Discrim,\n+                                Component_Associations (Discrim_Source));\n                         end if;\n \n                         if Ekind (Etype (Discrim)) =\n-                          E_Anonymous_Access_Type then\n-\n+                             E_Anonymous_Access_Type\n+                        then\n                            Check_Against_Result_Level\n                              (Dynamic_Accessibility_Level (Disc_Exp));\n                         end if;\n@@ -6950,22 +6947,26 @@ package body Exp_Ch6 is\n                   end;\n \n                when N_Function_Call =>\n-                  --  No check needed; check performed by callee.\n+\n+                  --  No check needed (check performed by callee)\n+\n                   null;\n \n                when others =>\n \n                   declare\n                      Level : constant Node_Id :=\n-                        Make_Integer_Literal (Loc,\n-                          Object_Access_Level (Discrim_Source));\n+                               Make_Integer_Literal (Loc,\n+                                 Object_Access_Level (Discrim_Source));\n+\n                   begin\n                      --  Unimplemented: check for name prefix that includes\n                      --  a dereference of an access value with a dynamic\n                      --  accessibility level (e.g., an access param or a\n                      --  saooaaat) and use dynamic level in that case. For\n                      --  example:\n                      --    return Access_Param.all(Some_Index).Some_Component;\n+                     --  ???\n \n                      Set_Etype (Level, Standard_Natural);\n                      Check_Against_Result_Level (Level);\n@@ -7278,21 +7279,21 @@ package body Exp_Ch6 is\n                  Thunk_Code,\n \n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n-                   Tag_Node =>\n+                   Tag_Node     =>\n                      New_Reference_To (Node (Next_Elmt (Iface_DT_Ptr)), Loc),\n-                   Position => DT_Position (Prim),\n+                   Position     => DT_Position (Prim),\n                    Address_Node =>\n                      Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Reference_To (Thunk_Id, Loc),\n                          Attribute_Name => Name_Unrestricted_Access))),\n \n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n-                   Tag_Node =>\n+                   Tag_Node     =>\n                      New_Reference_To\n                       (Node (Next_Elmt (Next_Elmt (Next_Elmt (Iface_DT_Ptr)))),\n                        Loc),\n-                   Position => DT_Position (Prim),\n+                   Position     => DT_Position (Prim),\n                    Address_Node =>\n                      Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n@@ -7305,13 +7306,12 @@ package body Exp_Ch6 is\n             Next_Elmt (Iface_DT_Ptr);\n             pragma Assert (Has_Thunks (Node (Iface_DT_Ptr)));\n \n-            --  Skip the tag of the no-thunks dispatch table\n+            --  Skip tag of the no-thunks dispatch table\n \n             Next_Elmt (Iface_DT_Ptr);\n             pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n \n-            --  Skip the tag of the predefined primitives no-thunks dispatch\n-            --  table.\n+            --  Skip tag of predefined primitives no-thunks dispatch table\n \n             Next_Elmt (Iface_DT_Ptr);\n             pragma Assert (not Has_Thunks (Node (Iface_DT_Ptr)));\n@@ -7363,8 +7363,8 @@ package body Exp_Ch6 is\n             --  slots.\n \n             elsif Is_Imported (Subp)\n-                    and then (Convention (Subp) = Convention_CPP\n-                                or else Convention (Subp) = Convention_C)\n+               and then (Convention (Subp) = Convention_CPP\n+                           or else Convention (Subp) = Convention_C)\n             then\n                null;\n \n@@ -8276,7 +8276,6 @@ package body Exp_Ch6 is\n    is\n       pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n-\n    begin\n       return\n         not Restriction_Active (No_Finalization)\n@@ -8379,7 +8378,7 @@ package body Exp_Ch6 is\n \n          --  Unimplemented: a cross-dialect subp renaming which does not set\n          --  the Alias attribute (e.g., a rename of a dereference of an access\n-         --  to subprogram value).\n+         --  to subprogram value). ???\n \n          return Present (Extra_Accessibility_Of_Result (Alias (Func_Id)));\n "}, {"sha": "ba72719f8dbcc7c6c1634adb1361300e946911c7", "filename": "gcc/ada/s-linux-alpha.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-linux-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-linux-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-linux-alpha.ads?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---             Copyright (C) 2009-2011, Free Software Foundation, Inc.      --\n+--          Copyright (C) 2009-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --"}, {"sha": "4553f47c5122b356c11d8e2e16b1cf2837411dd1", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -1358,7 +1358,7 @@ CND(WSAEDISCON,         \"Disconnected\")\n #if defined (__APPLE__) || defined (__linux__) || defined (DUMMY)\n /*\n \n-   --  Sizes of pthread data types\n+   --  Sizes of pthread data types (on Darwin these are padding)\n */\n \n #if defined (__APPLE__) || defined (DUMMY)\n@@ -1372,34 +1372,34 @@ CND(WSAEDISCON,         \"Disconnected\")\n #define PTHREAD_RWLOCK_SIZE     __PTHREAD_RWLOCK_SIZE__\n #define PTHREAD_ONCE_SIZE       __PTHREAD_ONCE_SIZE__\n #else\n-#define PTHREAD_SIZE           (sizeof (pthread_t))\n-#define PTHREAD_ATTR_SIZE       __SIZEOF_PTHREAD_ATTR_T\n-#define PTHREAD_MUTEXATTR_SIZE  __SIZEOF_PTHREAD_MUTEXATTR_T\n-#define PTHREAD_MUTEX_SIZE      __SIZEOF_PTHREAD_MUTEX_T\n-#define PTHREAD_CONDATTR_SIZE   __SIZEOF_PTHREAD_CONDATTR_T\n-#define PTHREAD_COND_SIZE       __SIZEOF_PTHREAD_COND_T\n-#define PTHREAD_RWLOCKATTR_SIZE __SIZEOF_PTHREAD_RWLOCKATTR_T\n-#define PTHREAD_RWLOCK_SIZE     __SIZEOF_PTHREAD_RWLOCK_T\n+#define PTHREAD_SIZE            (sizeof (pthread_t))\n+#define PTHREAD_ATTR_SIZE       (sizeof (pthread_attr_t))\n+#define PTHREAD_MUTEXATTR_SIZE  (sizeof (pthread_mutexattr_t))\n+#define PTHREAD_MUTEX_SIZE      (sizeof (pthread_mutex_t))\n+#define PTHREAD_CONDATTR_SIZE   (sizeof (pthread_condattr_t))\n+#define PTHREAD_COND_SIZE       (sizeof (pthread_cond_t))\n+#define PTHREAD_RWLOCKATTR_SIZE (sizeof (pthread_rwlockattr_t))\n+#define PTHREAD_RWLOCK_SIZE     (sizeof (pthread_rwlock_t))\n #define PTHREAD_ONCE_SIZE       (sizeof (pthread_once_t))\n #endif\n \n-CND(PTHREAD_SIZE, \"Pad in pthread_t\")\n+CND(PTHREAD_SIZE, \"pthread_t\")\n \n-CND(PTHREAD_ATTR_SIZE, \"Pad in pthread_attr_t\")\n+CND(PTHREAD_ATTR_SIZE, \"pthread_attr_t\")\n \n-CND(PTHREAD_MUTEXATTR_SIZE, \"Pad in pthread_mutexattr_t\")\n+CND(PTHREAD_MUTEXATTR_SIZE, \"pthread_mutexattr_t\")\n \n-CND(PTHREAD_MUTEX_SIZE, \"Pad in pthread_mutex_t\")\n+CND(PTHREAD_MUTEX_SIZE, \"pthread_mutex_t\")\n \n-CND(PTHREAD_CONDATTR_SIZE, \"Pad in pthread_condattr_t\")\n+CND(PTHREAD_CONDATTR_SIZE, \"pthread_condattr_t\")\n \n-CND(PTHREAD_COND_SIZE, \"Pad in pthread_cond_t\")\n+CND(PTHREAD_COND_SIZE, \"pthread_cond_t\")\n \n-CND(PTHREAD_RWLOCKATTR_SIZE, \"Pad in pthread_rwlockattr_t\")\n+CND(PTHREAD_RWLOCKATTR_SIZE, \"pthread_rwlockattr_t\")\n \n-CND(PTHREAD_RWLOCK_SIZE, \"Pad in pthread_rwlock_t\")\n+CND(PTHREAD_RWLOCK_SIZE, \"pthread_rwlock_t\")\n \n-CND(PTHREAD_ONCE_SIZE, \"Pad in pthread_once_t\")\n+CND(PTHREAD_ONCE_SIZE, \"pthread_once_t\")\n \n #endif\n "}, {"sha": "fa42a607ef785eff12b9f19dfd9dd090492e435b", "filename": "gcc/ada/s-osinte-linux.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-osinte-linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-osinte-linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-linux.ads?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -559,7 +559,7 @@ private\n    pragma Convention (C, timespec);\n \n    type unsigned_long_long_t is mod 2 ** 64;\n-   --  Local type only used to get it's 'Alignment below\n+   --  Local type only used to get the alignment of this type below\n \n    type pthread_attr_t is\n      array (1 .. OS_Constants.PTHREAD_ATTR_SIZE) of unsigned_char;"}, {"sha": "eae66cb7f4758a969a2edc056b16196ff87c1186", "filename": "gcc/ada/s-solita.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54bf19e4587be8b7c283cd7c4ae8428f93c3eeff/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=54bf19e4587be8b7c283cd7c4ae8428f93c3eeff", "patch": "@@ -150,9 +150,10 @@ package body System.Soft_Links.Tasking is\n       EO      : Ada.Exceptions.Exception_Occurrence;\n \n    begin\n-      --  We can only be here because we are terminating the environment task.\n-      --  Task termination for the rest of the tasks is handled in the\n-      --  Task_Wrapper.\n+      --  We can only be here because we are terminating the environment\n+      --  task. Task termination for the rest of the tasks is handled in\n+      --  the Task_Wrapper.\n+\n       --  We do not want to enable this check and e.g. call System.OS_Lib.Abort\n       --  here because some restricted run-times may not have system.os_lib\n       --  (e.g. JVM), and calling abort may do more harm than good to the\n@@ -179,9 +180,9 @@ package body System.Soft_Links.Tasking is\n          Ada.Exceptions.Save_Occurrence (EO, Excep);\n       end if;\n \n-      --  There is no need for explicit protection against race conditions\n-      --  for this part because it can only be executed by the environment\n-      --  task after all the other tasks have been finalized.\n+      --  There is no need for explicit protection against race conditions for\n+      --  this part because it can only be executed by the environment task\n+      --  after all the other tasks have been finalized.\n \n       if Self_Id.Common.Specific_Handler /= null then\n          Self_Id.Common.Specific_Handler.all (Cause, Self_Id, EO);"}]}