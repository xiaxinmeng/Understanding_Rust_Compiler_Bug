{"sha": "0842a17931118249ec6743dfd1aabed36eb14605", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg0MmExNzkzMTExODI0OWVjNjc0M2RmZDFhYWJlZDM2ZWIxNDYwNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-23T20:42:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-23T20:42:58Z"}, "message": "(expand_increment): If postincrement for MEM can't use add directly,\n\nload address in reg and enqueue increment and store of reg.\n\nFrom-SVN: r12785", "tree": {"sha": "e9157d9f056b7841d0b09c1e7fd0d03f3c453ce6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9157d9f056b7841d0b09c1e7fd0d03f3c453ce6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0842a17931118249ec6743dfd1aabed36eb14605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0842a17931118249ec6743dfd1aabed36eb14605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0842a17931118249ec6743dfd1aabed36eb14605", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0842a17931118249ec6743dfd1aabed36eb14605/comments", "author": null, "committer": null, "parents": [{"sha": "3c2f289c1ae0c7d3cee1ba0e2a2bca2b5736786e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c2f289c1ae0c7d3cee1ba0e2a2bca2b5736786e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c2f289c1ae0c7d3cee1ba0e2a2bca2b5736786e"}], "stats": {"total": 16, "additions": 16, "deletions": 0}, "files": [{"sha": "1b0ba5b98b8365b50962052671cb32c9d136ae2f", "filename": "gcc/expr.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0842a17931118249ec6743dfd1aabed36eb14605/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0842a17931118249ec6743dfd1aabed36eb14605/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0842a17931118249ec6743dfd1aabed36eb14605", "patch": "@@ -9642,6 +9642,22 @@ expand_increment (exp, post, ignore)\n \n \t  return enqueue_insn (op0, GEN_FCN (icode) (op0, op0, op1));\n \t}\n+      if (icode != (int) CODE_FOR_nothing && GET_CODE (op0) == MEM)\n+\t{\n+\t  rtx addr = force_reg (Pmode, XEXP (op0, 0));\n+\t  rtx temp, result;\n+\n+\t  op0 = change_address (op0, VOIDmode, addr);\n+\t  temp = force_reg (GET_MODE (op0), op0);\n+\t  if (! (*insn_operand_predicate[icode][2]) (op1, mode))\n+\t    op1 = force_reg (mode, op1);\n+\n+\t  /* The increment queue is LIFO, thus we have to `queue'\n+\t     the instructions in reverse order.  */\n+\t  enqueue_insn (op0, gen_move_insn (op0, temp));\n+\t  result = enqueue_insn (temp, GEN_FCN (icode) (temp, temp, op1));\n+\t  return result;\n+\t}\n     }\n \n   /* Preincrement, or we can't increment with one simple insn.  */"}]}