{"sha": "76fc4a85933e84c70c0441d7d87935d805694052", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmYzRhODU5MzNlODRjNzBjMDQ0MWQ3ZDg3OTM1ZDgwNTY5NDA1Mg==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-15T11:34:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-12-15T11:34:47Z"}, "message": "einfo.ads: Comment fix.\n\ngcc/ada/\n\n2017-12-15  Bob Duff  <duff@adacore.com>\n\n\t* einfo.ads: Comment fix.\n\n2017-12-15  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* s-vercon.adb: Minor style fixes.\n\n2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Freeze_Expr_Types): Do not emit a freeze node for an\n\titype that is the type of a discriminant-dependent component.\n\n2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Part_Of): The context-specific portion of the\n\tanalysis is now directed to several specialized routines.\n\t(Check_Part_Of_Abstract_State): New routine.\n\t(Check_Part_Of_Concurrent_Type): New routine. Reimplement the checks\n\tinvolving the item, the single concurrent type, and their respective\n\tcontexts.\n\t* sem_res.adb (Resolve_Entity_Name): Potential constituents of a single\n\tconcurrent type are now recorded regardless of the SPARK mode.\n\t* sem_util.adb (Check_Part_Of_Reference): Split some of the tests in\n\tindividual predicates.  A Part_Of reference is legal when it appears\n\twithin the statement list of the object's immediately enclosing\n\tpackage.\n\t(Is_Enclosing_Package_Body): New routine.\n\t(Is_Internal_Declaration_Or_Body): New routine.\n\t(Is_Single_Declaration_Or_Body): New routine.\n\t(Is_Single_Task_Pragma): New routine.\n\ngcc/testsuite/\n\n2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat.dg/expr_func2.ads, gnat.dg/expr_func2.adb: New testcase.\n\nFrom-SVN: r255690", "tree": {"sha": "4c3c411bf7593d6fbc01790e009a47688db36fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c3c411bf7593d6fbc01790e009a47688db36fe4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76fc4a85933e84c70c0441d7d87935d805694052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fc4a85933e84c70c0441d7d87935d805694052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fc4a85933e84c70c0441d7d87935d805694052", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fc4a85933e84c70c0441d7d87935d805694052/comments", "author": null, "committer": null, "parents": [{"sha": "f5b39f907f7a2d53a9506fdeafb99078315531eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5b39f907f7a2d53a9506fdeafb99078315531eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5b39f907f7a2d53a9506fdeafb99078315531eb"}], "stats": {"total": 692, "additions": 493, "deletions": 199}, "files": [{"sha": "e07fc18135cf97f4238849528ee697cdc05c2d6f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -1,3 +1,35 @@\n+2017-12-15  Bob Duff  <duff@adacore.com>\n+\n+\t* einfo.ads: Comment fix.\n+\n+2017-12-15  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* s-vercon.adb: Minor style fixes.\n+\n+2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Freeze_Expr_Types): Do not emit a freeze node for an\n+\titype that is the type of a discriminant-dependent component.\n+\n+2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Part_Of): The context-specific portion of the\n+\tanalysis is now directed to several specialized routines.\n+\t(Check_Part_Of_Abstract_State): New routine.\n+\t(Check_Part_Of_Concurrent_Type): New routine. Reimplement the checks\n+\tinvolving the item, the single concurrent type, and their respective\n+\tcontexts.\n+\t* sem_res.adb (Resolve_Entity_Name): Potential constituents of a single\n+\tconcurrent type are now recorded regardless of the SPARK mode.\n+\t* sem_util.adb (Check_Part_Of_Reference): Split some of the tests in\n+\tindividual predicates.  A Part_Of reference is legal when it appears\n+\twithin the statement list of the object's immediately enclosing\n+\tpackage.\n+\t(Is_Enclosing_Package_Body): New routine.\n+\t(Is_Internal_Declaration_Or_Body): New routine.\n+\t(Is_Single_Declaration_Or_Body): New routine.\n+\t(Is_Single_Task_Pragma): New routine.\n+\n 2017-12-15  Patrick Bernardi  <bernardi@adacore.com>\n \n \t* gnat_ugn.texi: Regenerate."}, {"sha": "bb5b5e983f799fc5a37613e30ca80b6b5b670b07", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -649,7 +649,7 @@ package Einfo is\n --       Defined in E_Record_Subtype and E_Class_Wide_Subtype entities.\n --       Each such entity can either have a Discriminant_Constraint, in\n --       which case it represents a distinct type from the base type (and\n---       will have a list of components and discrimants in the list headed by\n+--       will have a list of components and discriminants in the list headed by\n --       First_Entity) or else no such constraint, in which case it will be a\n --       copy of the base type.\n --"}, {"sha": "d54a74310c5a42ce845622ba23bd0f0e3d4aa8af", "filename": "gcc/ada/libgnat/s-vercon.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Flibgnat%2Fs-vercon.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Flibgnat%2Fs-vercon.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vercon.adb?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -38,7 +38,7 @@ package body System.Version_Control is\n    ------------------------\n \n    function Get_Version_String\n-     (V    : System.Unsigned_Types.Unsigned)\n+     (V : System.Unsigned_Types.Unsigned)\n       return Version_String\n    is\n       S : Version_String;"}, {"sha": "352f503a78a148518427865590ed651124cb885c", "filename": "gcc/ada/libgnat/s-vercon.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Flibgnat%2Fs-vercon.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Flibgnat%2Fs-vercon.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vercon.ads?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -39,10 +39,10 @@ package System.Version_Control is\n    pragma Pure;\n \n    subtype Version_String is String (1 .. 8);\n-   --  Eight character string returned by Get_version_String;\n+   --  Eight character string returned by Get_version_String\n \n    function Get_Version_String\n-     (V    : System.Unsigned_Types.Unsigned)\n+     (V : System.Unsigned_Types.Unsigned)\n       return Version_String;\n    --  The version information in the executable file is stored as unsigned\n    --  integers. This routine converts the unsigned integer into an eight"}, {"sha": "163952bb53cc141b1f57bec503ec522fce355537", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -366,10 +366,13 @@ package body Sem_Ch6 is\n \n             procedure Check_And_Freeze_Type (Typ : Entity_Id) is\n             begin\n-               --  Skip Itypes created by the preanalysis\n+               --  Skip Itypes created by the preanalysis, and itypes\n+               --  whose scope is another type (i.e. component subtypes\n+               --  that depend on a discriminant),\n \n                if Is_Itype (Typ)\n-                 and then Scope_Within_Or_Same (Scope (Typ), Def_Id)\n+                 and then (Scope_Within_Or_Same (Scope (Typ), Def_Id)\n+                   or else Is_Type (Scope (Typ)))\n                then\n                   return;\n                end if;"}, {"sha": "d342906ad53737d0aee4b2496bd449f44d11097a", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 239, "deletions": 120, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -3168,71 +3168,26 @@ package body Sem_Prag is\n       Encap_Id : out Entity_Id;\n       Legal    : out Boolean)\n    is\n-      Encap_Typ   : Entity_Id;\n-      Item_Decl   : Node_Id;\n-      Pack_Id     : Entity_Id;\n-      Placement   : State_Space_Kind;\n-      Parent_Unit : Entity_Id;\n+      procedure Check_Part_Of_Abstract_State;\n+      pragma Inline (Check_Part_Of_Abstract_State);\n+      --  Verify the legality of indicator Part_Of when the encapsulator is an\n+      --  abstract state.\n \n-   begin\n-      --  Assume that the indicator is illegal\n-\n-      Encap_Id := Empty;\n-      Legal    := False;\n-\n-      if Nkind_In (Encap, N_Expanded_Name,\n-                          N_Identifier,\n-                          N_Selected_Component)\n-      then\n-         Analyze       (Encap);\n-         Resolve_State (Encap);\n-\n-         Encap_Id := Entity (Encap);\n-\n-         --  The encapsulator is an abstract state\n-\n-         if Ekind (Encap_Id) = E_Abstract_State then\n-            null;\n-\n-         --  The encapsulator is a single concurrent type (SPARK RM 9.3)\n-\n-         elsif Is_Single_Concurrent_Object (Encap_Id) then\n-            null;\n-\n-         --  Otherwise the encapsulator is not a legal choice\n-\n-         else\n-            SPARK_Msg_N\n-              (\"indicator Part_Of must denote abstract state, single \"\n-               & \"protected type or single task type\", Encap);\n-            return;\n-         end if;\n-\n-      --  This is a syntax error, always report\n-\n-      else\n-         Error_Msg_N\n-           (\"indicator Part_Of must denote abstract state, single protected \"\n-            & \"type or single task type\", Encap);\n-         return;\n-      end if;\n-\n-      --  Catch a case where indicator Part_Of denotes the abstract view of a\n-      --  variable which appears as an abstract state (SPARK RM 10.1.2 2).\n-\n-      if From_Limited_With (Encap_Id)\n-        and then Present (Non_Limited_View (Encap_Id))\n-        and then Ekind (Non_Limited_View (Encap_Id)) = E_Variable\n-      then\n-         SPARK_Msg_N (\"indicator Part_Of must denote abstract state\", Encap);\n-         SPARK_Msg_N (\"\\& denotes abstract view of object\", Encap);\n-         return;\n-      end if;\n+      procedure Check_Part_Of_Concurrent_Type;\n+      pragma Inline (Check_Part_Of_Concurrent_Type);\n+      --  Verify the legality of indicator Part_Of when the encapsulator is a\n+      --  single concurrent type.\n \n-      --  The encapsulator is an abstract state\n+      ----------------------------------\n+      -- Check_Part_Of_Abstract_State --\n+      ----------------------------------\n \n-      if Ekind (Encap_Id) = E_Abstract_State then\n+      procedure Check_Part_Of_Abstract_State is\n+         Pack_Id     : Entity_Id;\n+         Placement   : State_Space_Kind;\n+         Parent_Unit : Entity_Id;\n \n+      begin\n          --  Determine where the object, package instantiation or state lives\n          --  with respect to the enclosing packages or package bodies.\n \n@@ -3250,6 +3205,7 @@ package body Sem_Prag is\n             SPARK_Msg_N\n               (\"indicator Part_Of cannot appear in this context \"\n                & \"(SPARK RM 7.2.6(5))\", Indic);\n+\n             Error_Msg_Name_1 := Chars (Scope (Encap_Id));\n             SPARK_Msg_NE\n               (\"\\& is not part of the hidden state of package %\",\n@@ -3267,14 +3223,14 @@ package body Sem_Prag is\n               and then Is_Private_Descendant (Pack_Id)\n             then\n                --  A variable or state abstraction which is part of the visible\n-               --  state of a private child unit (or one of its public\n-               --  descendants) must have its Part_Of indicator specified. The\n-               --  Part_Of indicator must denote a state abstraction declared\n-               --  by either the parent unit of the private unit or by a public\n-               --  descendant of that parent unit.\n+               --  state of a private child unit or its public descendants must\n+               --  have its Part_Of indicator specified. The Part_Of indicator\n+               --  must denote a state declared by either the parent unit of\n+               --  the private unit or by a public descendant of that parent\n+               --  unit.\n \n-               --  Find nearest private ancestor (which can be the current unit\n-               --  itself).\n+               --  Find the nearest private ancestor (which can be the current\n+               --  unit itself).\n \n                Parent_Unit := Pack_Id;\n                while Present (Parent_Unit) loop\n@@ -3288,8 +3244,8 @@ package body Sem_Prag is\n \n                if not Is_Child_Or_Sibling (Pack_Id, Scope (Encap_Id)) then\n                   SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote abstract state of & \"\n-                     & \"or of its public descendant (SPARK RM 7.2.6(3))\",\n+                    (\"indicator Part_Of must denote abstract state of & or of \"\n+                     & \"its public descendant (SPARK RM 7.2.6(3))\",\n                      Indic, Parent_Unit);\n                   return;\n \n@@ -3302,8 +3258,8 @@ package body Sem_Prag is\n \n                else\n                   SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote abstract state of & \"\n-                     & \"or of its public descendant (SPARK RM 7.2.6(3))\",\n+                    (\"indicator Part_Of must denote abstract state of & or of \"\n+                     & \"its public descendant (SPARK RM 7.2.6(3))\",\n                      Indic, Parent_Unit);\n                   return;\n                end if;\n@@ -3315,6 +3271,7 @@ package body Sem_Prag is\n                SPARK_Msg_N\n                  (\"indicator Part_Of cannot appear in this context \"\n                   & \"(SPARK RM 7.2.6(5))\", Indic);\n+\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                SPARK_Msg_NE\n                  (\"\\& is declared in the visible part of package %\",\n@@ -3330,6 +3287,7 @@ package body Sem_Prag is\n                SPARK_Msg_NE\n                  (\"indicator Part_Of must denote an abstract state of \"\n                   & \"package & (SPARK RM 7.2.6(2))\", Indic, Pack_Id);\n+\n                Error_Msg_Name_1 := Chars (Pack_Id);\n                SPARK_Msg_NE\n                  (\"\\& is declared in the private part of package %\",\n@@ -3354,11 +3312,77 @@ package body Sem_Prag is\n             return;\n          end if;\n \n-      --  The encapsulator is a single concurrent type\n+         --  At this point it is known that the Part_Of indicator is legal\n \n-      else\n-         Encap_Typ := Etype (Encap_Id);\n+         Legal := True;\n+      end Check_Part_Of_Abstract_State;\n+\n+      -----------------------------------\n+      -- Check_Part_Of_Concurrent_Type --\n+      -----------------------------------\n \n+      procedure Check_Part_Of_Concurrent_Type is\n+         function In_Proper_Order\n+           (First  : Node_Id;\n+            Second : Node_Id) return Boolean;\n+         pragma Inline (In_Proper_Order);\n+         --  Determine whether node First precedes node Second\n+\n+         procedure Placement_Error;\n+         pragma Inline (Placement_Error);\n+         --  Emit an error concerning the illegal placement of the item with\n+         --  respect to the single concurrent type.\n+\n+         ---------------------\n+         -- In_Proper_Order --\n+         ---------------------\n+\n+         function In_Proper_Order\n+           (First  : Node_Id;\n+            Second : Node_Id) return Boolean\n+         is\n+            N : Node_Id;\n+\n+         begin\n+            if List_Containing (First) = List_Containing (Second) then\n+               N := First;\n+               while Present (N) loop\n+                  if N = Second then\n+                     return True;\n+                  end if;\n+\n+                  Next (N);\n+               end loop;\n+            end if;\n+\n+            return False;\n+         end In_Proper_Order;\n+\n+         ---------------------\n+         -- Placement_Error --\n+         ---------------------\n+\n+         procedure Placement_Error is\n+         begin\n+            SPARK_Msg_N\n+              (\"indicator Part_Of must denote a previously declared single \"\n+               & \"protected type or single task type\", Encap);\n+         end Placement_Error;\n+\n+         --  Local variables\n+\n+         Conc_Typ      : constant Entity_Id := Etype (Encap_Id);\n+         Encap_Decl    : constant Node_Id   := Declaration_Node (Encap_Id);\n+         Encap_Context : constant Node_Id   := Parent (Encap_Decl);\n+\n+         Item_Context : Node_Id;\n+         Item_Decl    : Node_Id;\n+         Prv_Decls    : List_Id;\n+         Vis_Decls    : List_Id;\n+\n+      --  Start of processing for Check_Part_Of_Concurrent_Type\n+\n+      begin\n          --  Only abstract states and variables can act as constituents of an\n          --  encapsulating single concurrent type.\n \n@@ -3370,7 +3394,7 @@ package body Sem_Prag is\n          elsif Ekind (Item_Id) = E_Constant then\n             Error_Msg_Name_1 := Chars (Encap_Id);\n             SPARK_Msg_NE\n-              (Fix_Msg (Encap_Typ, \"constant & cannot act as constituent of \"\n+              (Fix_Msg (Conc_Typ, \"constant & cannot act as constituent of \"\n                & \"single protected type %\"), Indic, Item_Id);\n             return;\n \n@@ -3379,7 +3403,7 @@ package body Sem_Prag is\n          else\n             Error_Msg_Name_1 := Chars (Encap_Id);\n             SPARK_Msg_NE\n-              (Fix_Msg (Encap_Typ, \"package instantiation & cannot act as \"\n+              (Fix_Msg (Conc_Typ, \"package instantiation & cannot act as \"\n                & \"constituent of single protected type %\"), Indic, Item_Id);\n             return;\n          end if;\n@@ -3398,64 +3422,159 @@ package body Sem_Prag is\n             Item_Decl := Declaration_Node (Item_Id);\n          end if;\n \n-         --  Both the item and its encapsulating single concurrent type must\n-         --  appear in the same declarative region (SPARK RM 9.3). Note that\n-         --  privacy is ignored.\n+         Item_Context := Parent (Item_Decl);\n+\n+         --  The item and the single concurrent type must appear in the same\n+         --  declarative region, with the item following the declaration of\n+         --  the single concurrent type (SPARK RM 9(3)).\n+\n+         if Item_Context = Encap_Context then\n+            if Nkind_In (Item_Context, N_Package_Specification,\n+                                       N_Protected_Definition,\n+                                       N_Task_Definition)\n+            then\n+               Prv_Decls := Private_Declarations (Item_Context);\n+               Vis_Decls := Visible_Declarations (Item_Context);\n+\n+               --  The placement is OK when the single concurrent type appears\n+               --  within the visible declarations and the item in the private\n+               --  declarations.\n+               --\n+               --    package Pack is\n+               --       protected PO ...\n+               --    private\n+               --       Constit : ... with Part_Of => PO;\n+               --    end Pack;\n+\n+               if List_Containing (Encap_Decl) = Vis_Decls\n+                 and then List_Containing (Item_Decl) = Prv_Decls\n+               then\n+                  null;\n+\n+               --  The placement is illegal when the item appears within the\n+               --  visible declarations and the single concurrent type is in\n+               --  the private declarations.\n+               --\n+               --    package Pack is\n+               --       Constit : ... with Part_Of => PO;\n+               --    private\n+               --       protected PO ...\n+               --    end Pack;\n+\n+               elsif List_Containing (Item_Decl) = Vis_Decls\n+                 and then List_Containing (Encap_Decl) = Prv_Decls\n+               then\n+                  Placement_Error;\n+                  return;\n+\n+               --  Otherwise both the item and the single concurrent type are\n+               --  in the same list. Ensure that the declaration of the single\n+               --  concurrent type precedes that of the item.\n+\n+               elsif not In_Proper_Order\n+                           (First  => Encap_Decl,\n+                            Second => Item_Decl)\n+               then\n+                  Placement_Error;\n+                  return;\n+               end if;\n+\n+            --  Otherwise both the item and the single concurrent type are\n+            --  in the same list. Ensure that the declaration of the single\n+            --  concurrent type precedes that of the item.\n+\n+            elsif not In_Proper_Order\n+                        (First  => Encap_Decl,\n+                         Second => Item_Decl)\n+            then\n+               Placement_Error;\n+               return;\n+            end if;\n+\n+         --  Otherwise the item and the single concurrent type reside within\n+         --  unrelated regions.\n \n-         if Parent (Item_Decl) /= Parent (Declaration_Node (Encap_Id)) then\n+         else\n             Error_Msg_Name_1 := Chars (Encap_Id);\n             SPARK_Msg_NE\n-              (Fix_Msg (Encap_Typ, \"constituent & must be declared \"\n+              (Fix_Msg (Conc_Typ, \"constituent & must be declared \"\n                & \"immediately within the same region as single protected \"\n                & \"type %\"), Indic, Item_Id);\n             return;\n          end if;\n \n-         --  The declaration of the item should follow the declaration of its\n-         --  encapsulating single concurrent type and must appear in the same\n-         --  declarative region (SPARK RM 9.3).\n+         --  At this point it is known that the Part_Of indicator is legal\n \n-         declare\n-            N : Node_Id;\n+         Legal := True;\n+      end Check_Part_Of_Concurrent_Type;\n \n-         begin\n-            N := Next (Declaration_Node (Encap_Id));\n-            while Present (N) loop\n-               exit when N = Item_Decl;\n-               Next (N);\n-            end loop;\n+   --  Start of processing for Analyze_Part_Of\n \n-            --  The single concurrent type might be in the visible part of a\n-            --  package, and the declaration of the item in the private part\n-            --  of the same package.\n+   begin\n+      --  Assume that the indicator is illegal\n \n-            if No (N) then\n-               declare\n-                  Pack : constant Node_Id :=\n-                           Parent (Declaration_Node (Encap_Id));\n-               begin\n-                  if Nkind (Pack) = N_Package_Specification\n-                    and then not In_Private_Part (Encap_Id)\n-                  then\n-                     N := First (Private_Declarations (Pack));\n-                     while Present (N) loop\n-                        exit when N = Item_Decl;\n-                        Next (N);\n-                     end loop;\n-                  end if;\n-               end;\n-            end if;\n+      Encap_Id := Empty;\n+      Legal    := False;\n \n-            if No (N) then\n-               SPARK_Msg_N\n-                 (\"indicator Part_Of must denote a previously declared \"\n-                  & \"single protected type or single task type\", Encap);\n-               return;\n-            end if;\n-         end;\n+      if Nkind_In (Encap, N_Expanded_Name,\n+                          N_Identifier,\n+                          N_Selected_Component)\n+      then\n+         Analyze       (Encap);\n+         Resolve_State (Encap);\n+\n+         Encap_Id := Entity (Encap);\n+\n+         --  The encapsulator is an abstract state\n+\n+         if Ekind (Encap_Id) = E_Abstract_State then\n+            null;\n+\n+         --  The encapsulator is a single concurrent type (SPARK RM 9.3)\n+\n+         elsif Is_Single_Concurrent_Object (Encap_Id) then\n+            null;\n+\n+         --  Otherwise the encapsulator is not a legal choice\n+\n+         else\n+            SPARK_Msg_N\n+              (\"indicator Part_Of must denote abstract state, single \"\n+               & \"protected type or single task type\", Encap);\n+            return;\n+         end if;\n+\n+      --  This is a syntax error, always report\n+\n+      else\n+         Error_Msg_N\n+           (\"indicator Part_Of must denote abstract state, single protected \"\n+            & \"type or single task type\", Encap);\n+         return;\n       end if;\n \n-      Legal := True;\n+      --  Catch a case where indicator Part_Of denotes the abstract view of a\n+      --  variable which appears as an abstract state (SPARK RM 10.1.2 2).\n+\n+      if From_Limited_With (Encap_Id)\n+        and then Present (Non_Limited_View (Encap_Id))\n+        and then Ekind (Non_Limited_View (Encap_Id)) = E_Variable\n+      then\n+         SPARK_Msg_N (\"indicator Part_Of must denote abstract state\", Encap);\n+         SPARK_Msg_N (\"\\& denotes abstract view of object\", Encap);\n+         return;\n+      end if;\n+\n+      --  The encapsulator is an abstract state\n+\n+      if Ekind (Encap_Id) = E_Abstract_State then\n+         Check_Part_Of_Abstract_State;\n+\n+      --  The encapsulator is a single concurrent type\n+\n+      else\n+         Check_Part_Of_Concurrent_Type;\n+      end if;\n    end Analyze_Part_Of;\n \n    ----------------------------------"}, {"sha": "e48d5e98f5b6503ebb271702ab5577b314867b0a", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -7380,15 +7380,15 @@ package body Sem_Res is\n             then\n                Check_Elab_Call (N);\n             end if;\n+         end if;\n \n-            --  The variable may eventually become a constituent of a single\n-            --  protected/task type. Record the reference now and verify its\n-            --  legality when analyzing the contract of the variable\n-            --  (SPARK RM 9.3).\n+         --  The variable may eventually become a constituent of a single\n+         --  protected/task type. Record the reference now and verify its\n+         --  legality when analyzing the contract of the variable\n+         --  (SPARK RM 9.3).\n \n-            if Ekind (E) = E_Variable then\n-               Record_Possible_Part_Of_Reference (E, N);\n-            end if;\n+         if Ekind (E) = E_Variable then\n+            Record_Possible_Part_Of_Reference (E, N);\n          end if;\n \n          --  A Ghost entity must appear in a specific context"}, {"sha": "248a9b7cff679139cb8d49f6b9f682deb9f63943", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 175, "deletions": 66, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -3281,72 +3281,200 @@ package body Sem_Util is\n    -----------------------------\n \n    procedure Check_Part_Of_Reference (Var_Id : Entity_Id; Ref : Node_Id) is\n+      function Is_Enclosing_Package_Body\n+        (Body_Decl : Node_Id;\n+         Obj_Id    : Entity_Id) return Boolean;\n+      pragma Inline (Is_Enclosing_Package_Body);\n+      --  Determine whether package body Body_Decl or its corresponding spec\n+      --  immediately encloses the declaration of object Obj_Id.\n+\n+      function Is_Internal_Declaration_Or_Body\n+        (Decl : Node_Id) return Boolean;\n+      pragma Inline (Is_Internal_Declaration_Or_Body);\n+      --  Determine whether declaration or body denoted by Decl is internal\n+\n+      function Is_Single_Declaration_Or_Body\n+        (Decl     : Node_Id;\n+         Conc_Typ : Entity_Id) return Boolean;\n+      pragma Inline (Is_Single_Declaration_Or_Body);\n+      --  Determine whether protected/task declaration or body denoted by Decl\n+      --  belongs to single concurrent type Conc_Typ.\n+\n+      function Is_Single_Task_Pragma\n+        (Prag     : Node_Id;\n+         Task_Typ : Entity_Id) return Boolean;\n+      pragma Inline (Is_Single_Task_Pragma);\n+      --  Determine whether pragma Prag belongs to single task type Task_Typ\n+\n+      -------------------------------\n+      -- Is_Enclosing_Package_Body --\n+      -------------------------------\n+\n+      function Is_Enclosing_Package_Body\n+        (Body_Decl : Node_Id;\n+         Obj_Id    : Entity_Id) return Boolean\n+      is\n+         Obj_Context : Node_Id;\n+\n+      begin\n+         --  Find the context of the object declaration\n+\n+         Obj_Context := Parent (Declaration_Node (Obj_Id));\n+\n+         if Nkind (Obj_Context) = N_Package_Specification then\n+            Obj_Context := Parent (Obj_Context);\n+         end if;\n+\n+         --  The object appears immediately within the package body\n+\n+         if Obj_Context = Body_Decl then\n+            return True;\n+\n+         --  The object appears immediately within the corresponding spec\n+\n+         elsif Nkind (Obj_Context) = N_Package_Declaration\n+           and then Unit_Declaration_Node (Corresponding_Spec (Body_Decl)) =\n+                      Obj_Context\n+         then\n+            return True;\n+         end if;\n+\n+         return False;\n+      end Is_Enclosing_Package_Body;\n+\n+      -------------------------------------\n+      -- Is_Internal_Declaration_Or_Body --\n+      -------------------------------------\n+\n+      function Is_Internal_Declaration_Or_Body\n+        (Decl : Node_Id) return Boolean\n+      is\n+      begin\n+         if Comes_From_Source (Decl) then\n+            return False;\n+\n+         --  A body generated for an expression function which has not been\n+         --  inserted into the tree yet (In_Spec_Expression is True) is not\n+         --  considered internal.\n+\n+         elsif Nkind (Decl) = N_Subprogram_Body\n+           and then Was_Expression_Function (Decl)\n+           and then not In_Spec_Expression\n+         then\n+            return False;\n+         end if;\n+\n+         return True;\n+      end Is_Internal_Declaration_Or_Body;\n+\n+      -----------------------------------\n+      -- Is_Single_Declaration_Or_Body --\n+      -----------------------------------\n+\n+      function Is_Single_Declaration_Or_Body\n+        (Decl     : Node_Id;\n+         Conc_Typ : Entity_Id) return Boolean\n+      is\n+         Spec_Id : constant Entity_Id := Unique_Defining_Entity (Decl);\n+\n+      begin\n+         return\n+           Present (Anonymous_Object (Spec_Id))\n+             and then Anonymous_Object (Spec_Id) = Conc_Typ;\n+      end Is_Single_Declaration_Or_Body;\n+\n+      ---------------------------\n+      -- Is_Single_Task_Pragma --\n+      ---------------------------\n+\n+      function Is_Single_Task_Pragma\n+        (Prag     : Node_Id;\n+         Task_Typ : Entity_Id) return Boolean\n+      is\n+         Decl : constant Node_Id := Find_Related_Declaration_Or_Body (Prag);\n+\n+      begin\n+         --  To qualify, the pragma must be associated with single task type\n+         --  Task_Typ.\n+\n+         return\n+           Is_Single_Task_Object (Task_Typ)\n+             and then Nkind (Decl) = N_Object_Declaration\n+             and then Defining_Entity (Decl) = Task_Typ;\n+      end Is_Single_Task_Pragma;\n+\n+      --  Local variables\n+\n       Conc_Obj : constant Entity_Id := Encapsulating_State (Var_Id);\n-      Decl     : Node_Id;\n-      OK_Use   : Boolean := False;\n       Par      : Node_Id;\n       Prag_Nam : Name_Id;\n-      Spec_Id  : Entity_Id;\n+      Prev     : Node_Id;\n+\n+   --  Start of processing for Check_Part_Of_Reference\n \n    begin\n+      --  Nothing to do when the variable was recorded, but did not become a\n+      --  constituent of a single concurrent type.\n+\n+      if No (Conc_Obj) then\n+         return;\n+      end if;\n+\n       --  Traverse the parent chain looking for a suitable context for the\n       --  reference to the concurrent constituent.\n \n-      Par := Parent (Ref);\n+      Prev := Ref;\n+      Par  := Parent (Prev);\n       while Present (Par) loop\n          if Nkind (Par) = N_Pragma then\n             Prag_Nam := Pragma_Name (Par);\n \n             --  A concurrent constituent is allowed to appear in pragmas\n             --  Initial_Condition and Initializes as this is part of the\n-            --  elaboration checks for the constituent (SPARK RM 9.3).\n+            --  elaboration checks for the constituent (SPARK RM 9(3)).\n \n             if Nam_In (Prag_Nam, Name_Initial_Condition, Name_Initializes) then\n-               OK_Use := True;\n-               exit;\n+               return;\n \n             --  When the reference appears within pragma Depends or Global,\n             --  check whether the pragma applies to a single task type. Note\n-            --  that the pragma is not encapsulated by the type definition,\n+            --  that the pragma may not encapsulated by the type definition,\n             --  but this is still a valid context.\n \n-            elsif Nam_In (Prag_Nam, Name_Depends, Name_Global) then\n-               Decl := Find_Related_Declaration_Or_Body (Par);\n-\n-               if Nkind (Decl) = N_Object_Declaration\n-                 and then Defining_Entity (Decl) = Conc_Obj\n-               then\n-                  OK_Use := True;\n-                  exit;\n-               end if;\n+            elsif Nam_In (Prag_Nam, Name_Depends, Name_Global)\n+              and then Is_Single_Task_Pragma (Par, Conc_Obj)\n+            then\n+               return;\n             end if;\n \n-         --  The reference appears somewhere in the definition of the single\n-         --  protected/task type (SPARK RM 9.3).\n+         --  The reference appears somewhere in the definition of a single\n+         --  concurrent type (SPARK RM 9(3)).\n \n          elsif Nkind_In (Par, N_Single_Protected_Declaration,\n                               N_Single_Task_Declaration)\n            and then Defining_Entity (Par) = Conc_Obj\n          then\n-            OK_Use := True;\n-            exit;\n+            return;\n \n-         --  The reference appears within the expanded declaration or the body\n-         --  of the single protected/task type (SPARK RM 9.3).\n+         --  The reference appears within the declaration or body of a single\n+         --  concurrent type (SPARK RM 9(3)).\n \n          elsif Nkind_In (Par, N_Protected_Body,\n                               N_Protected_Type_Declaration,\n                               N_Task_Body,\n                               N_Task_Type_Declaration)\n+           and then Is_Single_Declaration_Or_Body (Par, Conc_Obj)\n          then\n-            Spec_Id := Unique_Defining_Entity (Par);\n+            return;\n \n-            if Present (Anonymous_Object (Spec_Id))\n-              and then Anonymous_Object (Spec_Id) = Conc_Obj\n-            then\n-               OK_Use := True;\n-               exit;\n-            end if;\n+         --  The reference appears within the statement list of the object's\n+         --  immediately enclosing package (SPARK RM 9(3)).\n+\n+         elsif Nkind (Par) = N_Package_Body\n+           and then Nkind (Prev) = N_Handled_Sequence_Of_Statements\n+           and then Is_Enclosing_Package_Body (Par, Var_Id)\n+         then\n+            return;\n \n          --  The reference has been relocated within an internally generated\n          --  package or subprogram. Assume that the reference is legal as the\n@@ -3357,25 +3485,9 @@ package body Sem_Util is\n                               N_Package_Declaration,\n                               N_Subprogram_Body,\n                               N_Subprogram_Declaration)\n-           and then not Comes_From_Source (Par)\n+           and then Is_Internal_Declaration_Or_Body (Par)\n          then\n-            --  Continue to examine the context if the reference appears in a\n-            --  subprogram body which was previously an expression function,\n-            --  unless this is during preanalysis (when In_Spec_Expression is\n-            --  True), as the body may not yet be inserted in the tree.\n-\n-            if Nkind (Par) = N_Subprogram_Body\n-              and then Was_Expression_Function (Par)\n-              and then not In_Spec_Expression\n-            then\n-               null;\n-\n-            --  Otherwise the reference is legal\n-\n-            else\n-               OK_Use := True;\n-               exit;\n-            end if;\n+            return;\n \n          --  The reference has been relocated to an inlined body for GNATprove.\n          --  Assume that the reference is legal as the real check was already\n@@ -3385,30 +3497,27 @@ package body Sem_Util is\n            and then Nkind (Par) = N_Subprogram_Body\n            and then Chars (Defining_Entity (Par)) = Name_uParent\n          then\n-            OK_Use := True;\n-            exit;\n+            return;\n          end if;\n \n-         Par := Parent (Par);\n+         Prev := Par;\n+         Par  := Parent (Prev);\n       end loop;\n \n-      --  The reference is illegal as it appears outside the definition or\n-      --  body of the single protected/task type.\n+      --  At this point it is known that the reference does not appear within a\n+      --  legal context.\n \n-      if not OK_Use then\n-         Error_Msg_NE\n-           (\"reference to variable & cannot appear in this context\",\n-            Ref, Var_Id);\n-         Error_Msg_Name_1 := Chars (Var_Id);\n+      Error_Msg_NE\n+        (\"reference to variable & cannot appear in this context\", Ref, Var_Id);\n+      Error_Msg_Name_1 := Chars (Var_Id);\n \n-         if Is_Single_Protected_Object (Conc_Obj) then\n-            Error_Msg_NE\n-              (\"\\% is constituent of single protected type &\", Ref, Conc_Obj);\n+      if Is_Single_Protected_Object (Conc_Obj) then\n+         Error_Msg_NE\n+           (\"\\% is constituent of single protected type &\", Ref, Conc_Obj);\n \n-         else\n-            Error_Msg_NE\n-              (\"\\% is constituent of single task type &\", Ref, Conc_Obj);\n-         end if;\n+      else\n+         Error_Msg_NE\n+           (\"\\% is constituent of single task type &\", Ref, Conc_Obj);\n       end if;\n    end Check_Part_Of_Reference;\n \n@@ -22127,7 +22236,7 @@ package body Sem_Util is\n    begin\n       --  The variable is a constituent of a single protected/task type. Such\n       --  a variable acts as a component of the type and must appear within a\n-      --  specific region (SPARK RM 9.3). Instead of recording the reference,\n+      --  specific region (SPARK RM 9(3)). Instead of recording the reference,\n       --  verify its legality now.\n \n       if Present (Encap) and then Is_Single_Concurrent_Object (Encap) then"}, {"sha": "8f2075b0eadeef4fbb402d5bb91c8658eeacff3f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -1,3 +1,7 @@\n+2017-12-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/expr_func2.ads, gnat.dg/expr_func2.adb: New testcase.\n+\n 2017-12-15  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/dflt_init_cond.adb, gnat.dg/dflt_init_cond_pkg.ads: New"}, {"sha": "ef366c6df9ce8bef97cd382327960eb6d91cfe5e", "filename": "gcc/testsuite/gnat.dg/expr_func2.adb", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func2.adb?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -0,0 +1,5 @@\n+--  { dg-do compile }\n+\n+package body Expr_Func2 is\n+   procedure Foo is null;\n+end Expr_Func2;"}, {"sha": "bd68f86cb13d795dc2727bfc13f6ef00eb7d6e79", "filename": "gcc/testsuite/gnat.dg/expr_func2.ads", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fc4a85933e84c70c0441d7d87935d805694052/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func2.ads?ref=76fc4a85933e84c70c0441d7d87935d805694052", "patch": "@@ -0,0 +1,22 @@\n+package Expr_Func2 is\n+\n+   type T_Index is range 1 .. 255;\n+\n+   type T_Table is array (T_Index range <>) of Boolean;\n+\n+   type T_Variable_Table (N : T_Index := T_Index'First) is record\n+      Table : T_Table (1 .. N);\n+   end record;\n+\n+   type T_A_Variable_Table is access T_Variable_Table;\n+\n+   function Element (A_Variable_Table : T_A_Variable_Table) return Boolean;\n+\n+private\n+\n+   function Element (A_Variable_Table : T_A_Variable_Table) return Boolean is\n+     (A_Variable_Table.all.Table (1));\n+\n+   procedure Foo;\n+\n+end Expr_Func2;"}]}