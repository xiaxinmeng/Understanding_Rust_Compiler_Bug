{"sha": "ab6155b74f075dee48d39dd00f77cab0fd6b4fe4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2MTU1Yjc0ZjA3NWRlZTQ4ZDM5ZGQwMGY3N2NhYjBmZDZiNGZlNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-05-06T16:58:33Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-05-06T16:58:33Z"}, "message": "(walk_fixup_memory_subreg): Add new arg UNCRITICAL.\n\n(fixup_var_refs_insn): Call with UNCRITICAL of 1 when processing\nREG_NOTES.\n\nFrom-SVN: r4360", "tree": {"sha": "2d0c64f288d0ad6bdf5ee5672a4c34bee2c33446", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d0c64f288d0ad6bdf5ee5672a4c34bee2c33446"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab6155b74f075dee48d39dd00f77cab0fd6b4fe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6155b74f075dee48d39dd00f77cab0fd6b4fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab6155b74f075dee48d39dd00f77cab0fd6b4fe4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6155b74f075dee48d39dd00f77cab0fd6b4fe4/comments", "author": null, "committer": null, "parents": [{"sha": "36aa0bf595347b210b80a80be4fc561673fa5deb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36aa0bf595347b210b80a80be4fc561673fa5deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36aa0bf595347b210b80a80be4fc561673fa5deb"}], "stats": {"total": 18, "additions": 11, "deletions": 7}, "files": [{"sha": "58add12f97438a4dac9005476323de973c060c23", "filename": "gcc/function.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6155b74f075dee48d39dd00f77cab0fd6b4fe4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6155b74f075dee48d39dd00f77cab0fd6b4fe4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ab6155b74f075dee48d39dd00f77cab0fd6b4fe4", "patch": "@@ -1146,7 +1146,8 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel)\n \t     we will get them elsewhere.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (GET_CODE (note) != INSN_LIST)\n-\t      XEXP (note, 0) = walk_fixup_memory_subreg (XEXP (note, 0), insn);\n+\t      XEXP (note, 0)\n+\t\t= walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n \t}\n       insn = next;\n     }\n@@ -1649,7 +1650,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n    If any insns must be emitted to compute NEWADDR, put them before INSN.\n \n    UNCRITICAL nonzero means accept paradoxical subregs.\n-   This is used for subregs found inside of ZERO_EXTRACTs.  */\n+   This is used for subregs found inside of ZERO_EXTRACTs and in REG_NOTES. */\n \n static rtx\n fixup_memory_subreg (x, insn, uncritical)\n@@ -1687,12 +1688,15 @@ fixup_memory_subreg (x, insn, uncritical)\n    If X itself is a (SUBREG (MEM ...) ...), return the replacement expression.\n    Otherwise return X, with its contents possibly altered.\n \n-   If any insns must be emitted to compute NEWADDR, put them before INSN.  */\n+   If any insns must be emitted to compute NEWADDR, put them before INSN. \n+\n+   UNCRITICAL is as in fixup_memory_subreg.  */\n \n static rtx\n-walk_fixup_memory_subreg (x, insn)\n+walk_fixup_memory_subreg (x, insn, uncritical)\n      register rtx x;\n      rtx insn;\n+     int uncritical;\n {\n   register enum rtx_code code;\n   register char *fmt;\n@@ -1704,21 +1708,21 @@ walk_fixup_memory_subreg (x, insn)\n   code = GET_CODE (x);\n \n   if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == MEM)\n-    return fixup_memory_subreg (x, insn, 0);\n+    return fixup_memory_subreg (x, insn, uncritical);\n \n   /* Nothing special about this RTX; fix its operands.  */\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn);\n+\tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn, uncritical);\n       if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j)\n-\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn);\n+\t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn, uncritical);\n \t}\n     }\n   return x;"}]}