{"sha": "cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M5ZDRhODVkNzA1M2I1NWU4MDA2ZTRmNTY2ZjQzZTE4MWJjZDFjMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-15T00:12:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-15T00:12:37Z"}, "message": "stor-layout.c (layout_union): Remove.\n\n\t* stor-layout.c (layout_union): Remove.\n\t(layout_union_field): New function, split out from layout_union.\n\t(finish_union_layout): Likewise.\n\t(layout_field): Handle unions by calling layout_union_field.\n\t(finish_record_layout): Handle unions.\n\t(layout_type): Combine RECORD_TYPE, UNION_TYPE, and\n\tQUAL_UNION_TYPE handling.\n\nFrom-SVN: r32548", "tree": {"sha": "572a5d3ba769fd670d8c9fdda9a48dbe872dc93c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/572a5d3ba769fd670d8c9fdda9a48dbe872dc93c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1/comments", "author": null, "committer": null, "parents": [{"sha": "8901decfba91a9fc7134e8fbb258a14c87335845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8901decfba91a9fc7134e8fbb258a14c87335845", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8901decfba91a9fc7134e8fbb258a14c87335845"}], "stats": {"total": 294, "additions": 162, "deletions": 132}, "files": [{"sha": "fc74992ecad9018a73e1dd3b426cf58f4c862933", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "patch": "@@ -1,3 +1,13 @@\n+2000-03-14  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* stor-layout.c (layout_union): Remove.\n+\t(layout_union_field): New function, split out from layout_union.\n+\t(finish_union_layout): Likewise.\n+\t(layout_field): Handle unions by calling layout_union_field.\n+\t(finish_record_layout): Handle unions.\n+\t(layout_type): Combine RECORD_TYPE, UNION_TYPE, and\n+\tQUAL_UNION_TYPE handling.\n+\n Wed Feb 23 13:00:06 CET 2000  Jan Hubicka  <jh@suse.cz>\n         * flow.c (fixup_reorder_chain): Avoid double labels in the basic block;\n         end of basic block is jump_insn, not barrier; use create_basic_block"}, {"sha": "62363cbbde0bcf5c8bf4ae3274c4f9b73152582f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 152, "deletions": 132, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc9d4a85d7053b55e8006e4f566f43e181bcd1c1/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=cc9d4a85d7053b55e8006e4f566f43e181bcd1c1", "patch": "@@ -50,10 +50,11 @@ unsigned int maximum_field_alignment;\n    May be overridden by front-ends.  */\n unsigned int set_alignment = 0;\n \n-static void layout_union\tPARAMS ((tree));\n static void finalize_record_size PARAMS ((record_layout_info));\n static void compute_record_mode PARAMS ((tree));\n static void finalize_type_size PARAMS ((tree));\n+static void layout_union_field PARAMS ((record_layout_info, tree));\n+static void finish_union_layout PARAMS ((record_layout_info));\n \f\n /* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */\n \n@@ -402,9 +403,9 @@ layout_decl (decl, known_align)\n     }\n }\n \f\n-/* Create a new record_layout_info for the RECORD_TYPE T.  It is the\n-   responsibility of the caller to call `free' for the storage the\n-   returned.  */\n+/* Create a new record_layout_info for T, which may be a RECORD_TYPE,\n+   UNION_TYPE, or QUAL_UNION_TYPE.  It is the responsibility of the\n+   caller to call `free' for the storage the returned.  */\n \n record_layout_info\n new_record_layout_info (t)\n@@ -429,6 +430,65 @@ new_record_layout_info (t)\n   return rli;\n }\n \n+/* Like layout_field, but for unions.  */\n+\n+static void\n+layout_union_field (rli, field)\n+     record_layout_info rli;\n+     tree field;\n+{\n+  tree dsize;\n+      \n+  /* This function should only be used for unions; use layout_field\n+     for RECORD_TYPEs.  */\n+  if (TREE_CODE (rli->t) != UNION_TYPE\n+      && TREE_CODE (rli->t) != QUAL_UNION_TYPE)\n+    abort ();\n+\n+  /* By now, we should only be seeing FIELD_DECLs.  */\n+  if (TREE_CODE (field) != FIELD_DECL)\n+    abort ();\n+\n+  layout_decl (field, 0);\n+  DECL_FIELD_BITPOS (field) = bitsize_int (0);\n+\n+  /* Union must be at least as aligned as any field requires.  */\n+  rli->record_align = MAX (rli->record_align, DECL_ALIGN (field));\n+\n+#ifdef PCC_BITFIELD_TYPE_MATTERS\n+  /* On the m88000, a bit field of declare type `int' forces the\n+     entire union to have `int' alignment.  */\n+  if (PCC_BITFIELD_TYPE_MATTERS && DECL_BIT_FIELD_TYPE (field))\n+    rli->record_align = MAX (rli->record_align, \n+\t\t\t     TYPE_ALIGN (TREE_TYPE (field)));\n+#endif\n+\n+  dsize = DECL_SIZE (field);\n+  if (TREE_CODE (rli->t) == UNION_TYPE)\n+    {\n+      /* Set union_size to max (decl_size, union_size).  There are\n+\t more and less general ways to do this.  Use only CONST_SIZE\n+\t unless forced to use VAR_SIZE.  */\n+\n+      if (TREE_CODE (dsize) == INTEGER_CST\n+\t  && ! TREE_CONSTANT_OVERFLOW (dsize)\n+\t  && TREE_INT_CST_HIGH (dsize) == 0)\n+\trli->const_size\n+\t  = MAX (rli->const_size, TREE_INT_CST_LOW (dsize));\n+      else if (rli->var_size == 0)\n+\trli->var_size = dsize;\n+      else\n+\trli->var_size = size_binop (MAX_EXPR, rli->var_size, dsize);\n+    }\n+  else if (TREE_CODE (rli->t) == QUAL_UNION_TYPE)\n+    rli->var_size = fold (build (COND_EXPR, bitsizetype, \n+\t\t\t\t DECL_QUALIFIER (field),\n+\t\t\t\t DECL_SIZE (field),\n+\t\t\t\t (rli->var_size\n+\t\t\t\t  ? rli->var_size \n+\t\t\t\t  : bitsize_int (0))));\n+}\n+\n /* RLI contains information about the layout of a RECORD_TYPE.  FIELD\n    is a FIELD_DECL to be added after those fields already present in\n    T.  (FIELD is not actually added to the TYPE_FIELDS list here;\n@@ -463,6 +523,13 @@ layout_field (rli, field)\n      be laid out.  Likewise for initialized constant fields.  */\n   else if (TREE_CODE (field) != FIELD_DECL)\n     return;\n+  /* This function should only be used for records; use\n+     layout_union_field for unions.  */\n+  else if (TREE_CODE (rli->t) != RECORD_TYPE)\n+    {\n+      layout_union_field (rli, field);\n+      return;\n+    }\n \n   /* Work out the known alignment so far.  */\n   known_align = rli->var_size ? rli->var_align : rli->const_size;\n@@ -931,129 +998,104 @@ void\n finish_record_layout (rli)\n      record_layout_info rli;\n {\n-  /* Compute the final size.  */\n-  finalize_record_size (rli);\n-  /* Compute the TYPE_MODE for the record.  */\n-  compute_record_mode (rli->t);\n+  /* Use finish_union_layout for unions.  */\n+  if (TREE_CODE (rli->t) != RECORD_TYPE)\n+    finish_union_layout (rli);\n+  else\n+    {\n+      /* Compute the final size.  */\n+      finalize_record_size (rli);\n+      /* Compute the TYPE_MODE for the record.  */\n+      compute_record_mode (rli->t);\n+    }\n+\n   /* Lay out any static members.  This is done now because their type\n      may use the record's type.  */\n   while (rli->pending_statics)\n     {\n       layout_decl (TREE_VALUE (rli->pending_statics), 0);\n       rli->pending_statics = TREE_CHAIN (rli->pending_statics);\n     }\n+\n   /* Perform any last tweaks to the TYPE_SIZE, etc.  */\n   finalize_type_size (rli->t);\n   /* Clean up.  */\n   free (rli);\n }\n \n-\f\n-/* Lay out a UNION_TYPE or QUAL_UNION_TYPE type.\n-   Lay out all the fields, set their positions to zero,\n-   and compute the size and alignment of the union (maximum of any field).\n-   Note that if you set the TYPE_ALIGN before calling this\n-   then the union align is aligned to at least that boundary.  */\n+/* Like finish_record_layout, but for unions.  */\n \n static void\n-layout_union (rec)\n-     tree rec;\n+finish_union_layout (rli)\n+     record_layout_info rli;\n {\n-  register tree field;\n-  unsigned int union_align = BITS_PER_UNIT;\n-\n-  /* The size of the union, based on the fields scanned so far,\n-     is max (CONST_SIZE, VAR_SIZE).\n-     VAR_SIZE may be null; then CONST_SIZE by itself is the size.  */\n-  unsigned HOST_WIDE_INT const_size = 0;\n-  register tree var_size = 0;\n-\n-#ifdef STRUCTURE_SIZE_BOUNDARY\n-  /* Packed structures don't need to have minimum size.  */\n-  if (! TYPE_PACKED (rec))\n-    union_align = STRUCTURE_SIZE_BOUNDARY;\n-#endif\n-\n-  /* If this is a QUAL_UNION_TYPE, we want to process the fields in\n-     the reverse order in building the COND_EXPR that denotes its\n-     size.  We reverse them again later.  */\n-  if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n-    TYPE_FIELDS (rec) = nreverse (TYPE_FIELDS (rec));\n-\n-  for (field = TYPE_FIELDS (rec); field; field = TREE_CHAIN (field))\n-    {\n-      tree dsize;\n-      \n-      /* Enums which are local to this class need not be laid out.  */\n-      if (TREE_CODE (field) == CONST_DECL || TREE_CODE (field) == TYPE_DECL)\n-\tcontinue;\n-\n-      layout_decl (field, 0);\n-      DECL_FIELD_BITPOS (field) = bitsize_int (0);\n-\n-      /* Union must be at least as aligned as any field requires.  */\n-\n-      union_align = MAX (union_align, DECL_ALIGN (field));\n-\n-#ifdef PCC_BITFIELD_TYPE_MATTERS\n-      /* On the m88000, a bit field of declare type `int'\n-\t forces the entire union to have `int' alignment.  */\n-      if (PCC_BITFIELD_TYPE_MATTERS && DECL_BIT_FIELD_TYPE (field))\n-\tunion_align = MAX (union_align, TYPE_ALIGN (TREE_TYPE (field)));\n-#endif\n-\n-      dsize = DECL_SIZE (field);\n-      if (TREE_CODE (rec) == UNION_TYPE)\n-\t{\n-\t  /* Set union_size to max (decl_size, union_size).\n-\t     There are more and less general ways to do this.\n-\t     Use only CONST_SIZE unless forced to use VAR_SIZE.  */\n-\n-\t  if (TREE_CODE (dsize) == INTEGER_CST\n-              && ! TREE_CONSTANT_OVERFLOW (dsize)\n-              && TREE_INT_CST_HIGH (dsize) == 0)\n-\t    const_size\n-\t      = MAX (const_size, TREE_INT_CST_LOW (dsize));\n-\t  else if (var_size == 0)\n-\t    var_size = dsize;\n-\t  else\n-\t    var_size = size_binop (MAX_EXPR, var_size, dsize);\n-\t}\n-      else if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n-\tvar_size = fold (build (COND_EXPR, bitsizetype, DECL_QUALIFIER (field),\n-\t\t\t\tDECL_SIZE (field),\n-\t\t\t\tvar_size ? var_size : bitsize_int (0)));\n-      }\n-\n-  if (TREE_CODE (rec) == QUAL_UNION_TYPE)\n-    TYPE_FIELDS (rec) = nreverse (TYPE_FIELDS (rec));\n+  /* This function should only be used for unions; use\n+     finish_record_layout for RECORD_TYPEs.  */\n+  if (TREE_CODE (rli->t) != UNION_TYPE\n+      && TREE_CODE (rli->t) != QUAL_UNION_TYPE)\n+    abort ();\n \n   /* Determine the ultimate size of the union (in bytes).  */\n-  if (NULL == var_size)\n-    TYPE_SIZE (rec)\n-      = bitsize_int (CEIL (const_size, BITS_PER_UNIT) * BITS_PER_UNIT);\n+  if (NULL == rli->var_size)\n+    TYPE_SIZE (rli->t)\n+      = bitsize_int (CEIL (rli->const_size, BITS_PER_UNIT) * BITS_PER_UNIT);\n \n-  else if (const_size == 0)\n-    TYPE_SIZE (rec) = var_size;\n+  else if (rli->const_size == 0)\n+    TYPE_SIZE (rli->t) = rli->var_size;\n   else\n-    TYPE_SIZE (rec) = size_binop (MAX_EXPR, var_size,\n-\t\t\t\t  round_up (bitsize_int (const_size),\n-\t\t\t\t\t    BITS_PER_UNIT));\n+    TYPE_SIZE (rli->t) = size_binop (MAX_EXPR, rli->var_size,\n+\t\t\t\t     round_up (bitsize_int (rli->const_size),\n+\t\t\t\t\t       BITS_PER_UNIT));\n \n   /* Determine the desired alignment.  */\n #ifdef ROUND_TYPE_ALIGN\n-  TYPE_ALIGN (rec) = ROUND_TYPE_ALIGN (rec, TYPE_ALIGN (rec), union_align);\n+  TYPE_ALIGN (rli->t) = ROUND_TYPE_ALIGN (rli->t, TYPE_ALIGN (rli->t), \n+\t\t\t\t\t  rli->record_align);\n #else\n-  TYPE_ALIGN (rec) = MAX (TYPE_ALIGN (rec), union_align);\n+  TYPE_ALIGN (rli->t) = MAX (TYPE_ALIGN (rli->t), rli->record_align);\n #endif\n \n #ifdef ROUND_TYPE_SIZE\n-  TYPE_SIZE (rec) = ROUND_TYPE_SIZE (rec, TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+  TYPE_SIZE (rli->t) = ROUND_TYPE_SIZE (rli->t, TYPE_SIZE (rli->t), \n+\t\t\t\t\tTYPE_ALIGN (rli->t));\n #else\n   /* Round the size up to be a multiple of the required alignment */\n-  TYPE_SIZE (rec) = round_up (TYPE_SIZE (rec), TYPE_ALIGN (rec));\n+  TYPE_SIZE (rli->t) = round_up (TYPE_SIZE (rli->t), \n+\t\t\t\t TYPE_ALIGN (rli->t));\n #endif\n+\n+  TYPE_MODE (rli->t) = BLKmode;\n+  if (TREE_CODE (TYPE_SIZE (rli->t)) == INTEGER_CST\n+      /* If structure's known alignment is less than\n+\t what the scalar mode would need, and it matters,\n+\t then stick with BLKmode.  */\n+      && (! STRICT_ALIGNMENT\n+\t  || TYPE_ALIGN (rli->t) >= BIGGEST_ALIGNMENT\n+\t  || compare_tree_int (TYPE_SIZE (rli->t), \n+\t\t\t       TYPE_ALIGN (rli->t)) <= 0))\n+    {\n+      tree field;\n+\n+      /* A union which has any BLKmode members must itself be BLKmode;\n+\t it can't go in a register.\n+\t Unless the member is BLKmode only because it isn't aligned.  */\n+      for (field = TYPE_FIELDS (rli->t); \n+\t   field; \n+\t   field = TREE_CHAIN (field))\n+\t{\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\n+\t  if (TYPE_MODE (TREE_TYPE (field)) == BLKmode\n+\t      && ! TYPE_NO_FORCE_BLK (TREE_TYPE (field)))\n+\t    return;\n+\t}\n+\n+      TYPE_MODE (rli->t) \n+\t= mode_for_size_tree (TYPE_SIZE (rli->t), MODE_INT, 1);\n+    }\n }\n+\n \f\n /* Calculate the mode, size, and alignment for TYPE.\n    For an array type, calculate the element separation as well.\n@@ -1287,54 +1329,29 @@ layout_type (type)\n       }\n \n     case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n       {\n \ttree field;\n \trecord_layout_info rli;\n \n \t/* Initialize the layout information.  */\n \trli = new_record_layout_info (type);\n+\t/* If this is a QUAL_UNION_TYPE, we want to process the fields\n+\t   in the reverse order in building the COND_EXPR that denotes\n+\t   its size.  We reverse them again later.  */\n+\tif (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t  TYPE_FIELDS (type) = nreverse (TYPE_FIELDS (type));\n \t/* Layout all the fields.  */\n \tfor (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \t  layout_field (rli, field);\n+\tif (TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t  TYPE_FIELDS (type) = nreverse (TYPE_FIELDS (type));\n \t/* Finish laying out the record.  */\n \tfinish_record_layout (rli);\n       }\n       break;\n \n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      layout_union (type);\n-      TYPE_MODE (type) = BLKmode;\n-      if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t  /* If structure's known alignment is less than\n-\t     what the scalar mode would need, and it matters,\n-\t     then stick with BLKmode.  */\n-\t  && (! STRICT_ALIGNMENT\n-\t      || TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t      || compare_tree_int (TYPE_SIZE (type), TYPE_ALIGN (type)) <= 0))\n-\t{\n-\t  tree field;\n-\n-\t  /* A union which has any BLKmode members must itself be BLKmode;\n-\t     it can't go in a register.\n-\t     Unless the member is BLKmode only because it isn't aligned.  */\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t    {\n-\t      if (TREE_CODE (field) != FIELD_DECL)\n-\t\tcontinue;\n-\n-\t      if (TYPE_MODE (TREE_TYPE (field)) == BLKmode\n-\t\t  && ! TYPE_NO_FORCE_BLK (TREE_TYPE (field)))\n-\t\tgoto union_lose;\n-\t    }\n-\n-\t  TYPE_MODE (type)\n-\t    = mode_for_size_tree (TYPE_SIZE (type), MODE_INT, 1);\n-\n-\tunion_lose: ;\n-\t}\n-      break;\n-\n     case SET_TYPE:  /* Used by Chill and Pascal. */\n       if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST\n \t  || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST)\n@@ -1376,8 +1393,11 @@ layout_type (type)\n     }\n \n   /* Compute the final TYPE_SIZE, TYPE_ALIGN, etc. for TYPE.  For\n-     RECORD_TYPEs, finish_record_layout already called this function.  */\n-  if (TREE_CODE (type) != RECORD_TYPE)\n+     records and unions, finish_record_layout already called this\n+     function.  */\n+  if (TREE_CODE (type) != RECORD_TYPE \n+      && TREE_CODE (type) != UNION_TYPE\n+      && TREE_CODE (type) != QUAL_UNION_TYPE)\n     finalize_type_size (type);\n \n   pop_obstacks ();"}]}