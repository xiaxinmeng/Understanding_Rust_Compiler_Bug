{"sha": "4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEwOWZlODU5NGZlZjE1ZDVjYjM2ZDEwMTllNWI3Yzk1ZGJjNDVmNg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2004-08-13T23:05:36Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2004-08-13T23:05:36Z"}, "message": "configure.in (GCINCS): Don't use \"boehm-cflags\".\n\nlibjava:\n2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* configure.in (GCINCS): Don't use \"boehm-cflags\". Instead, -I\n\tboehm-gc's include dirs.\n\t* configure: Rebuilt.\n\t* include/boehm-gc.h: Include gc_config.h.\n\nboehm-gc:\n2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n\n\t* configure.ac (gc_cflags): Add -Iinclude.\n\t(AC_CONFIG_HEADERS): New. Configure gc_config.h header.\n\tDon't write DEFS to boehm-cflags file.\n\t* configure: Rebuilt.\n\t* gcj_mlc.c: Check #ifdef GC_GCJ_SUPPORT after including headers.\n\t* specific.c: Check #ifdef GC_LINUX_THREADS after including headers.\n\t* include/gc_config_macros.h: Remove backward-compatibility\n\tredefinitions of GC_ names.\n\t* include/gc.h: Include <gc_config.h>.\n\n2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n\n\tImport Boehm GC version 6.3.\n\nFrom-SVN: r85972", "tree": {"sha": "863181355c9339e1361dad10263a322aaabe426e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/863181355c9339e1361dad10263a322aaabe426e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/comments", "author": null, "committer": null, "parents": [{"sha": "f13bb1997aa840029740a52684fb9bcd20e834ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13bb1997aa840029740a52684fb9bcd20e834ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13bb1997aa840029740a52684fb9bcd20e834ab"}], "stats": {"total": 2999, "additions": 2220, "deletions": 779}, "files": [{"sha": "e21bc3d8dfe22efeef43bca48e5b9360c624af8c", "filename": "boehm-gc/BCC_MAKEFILE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FBCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FBCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FBCC_MAKEFILE?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -16,7 +16,7 @@ link=\t $(bcbin)\\ilink32\n cflags=  -O2 -R -v- -vi -H -H=gc.csm -I$(bcinclude);$(gcinclude1);$(gcinclude2) -L$(bclib) \\\r\n \t -w-pro -w-aus -w-par -w-ccc -w-rch -a4 -D__STDC__=0\r\n #defines= -DSILENT\r\n-defines= -DSMALL_CONFIG -DSILENT -DALL_INTERIOR_POINTERS -DUSE_GENERIC -DNO_GETENV -DJAVA_FINALIZATION -DGC_OPERATOR_NEW_ARRAY\r\n+defines= -DSILENT -DALL_INTERIOR_POINTERS -DUSE_GENERIC -DNO_GETENV -DJAVA_FINALIZATION -DGC_OPERATOR_NEW_ARRAY\r\n \r\n .c.obj:\r\n \t$(cc) @&&|\r"}, {"sha": "9ed4d720b23fe99595e4f4a31e1e7991b8f55f84", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,3 +1,19 @@\n+2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* configure.ac (gc_cflags): Add -Iinclude.\n+\t(AC_CONFIG_HEADERS): New. Configure gc_config.h header.\n+\tDon't write DEFS to boehm-cflags file.\n+\t* configure: Rebuilt.\n+\t* gcj_mlc.c: Check #ifdef GC_GCJ_SUPPORT after including headers.\n+\t* specific.c: Check #ifdef GC_LINUX_THREADS after including headers.\n+\t* include/gc_config_macros.h: Remove backward-compatibility \n+\tredefinitions of GC_ names.\n+\t* include/gc.h: Include <gc_config.h>.\n+\n+2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tImport Boehm GC version 6.3.\n+\n 2004-08-12  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* include/Makefile.in: Regenerate"}, {"sha": "20fa40a9a08ce365de46adbf440afbec2560bee6", "filename": "boehm-gc/Makefile.direct", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.direct", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.direct", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.direct?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -36,7 +36,7 @@ CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_\n # -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n # To build the parallel collector in a static library on HP/UX,\n # add to the above:\n-# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -DUSE_HPUX_TLS -D_POSIX_C_SOURCE=199506L\n+# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L\n # To build the thread-safe collector on Tru64, add to the above:\n # -pthread -DGC_OSF1_THREADS\n \n@@ -182,7 +182,7 @@ HOSTCFLAGS=$(CFLAGS)\n #   this facility is only used in a few places.  It is intended primarily\n #   for debugging of the garbage collector itself, but could also\n # -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n-#   the reliability (from 99.9999% to 100%) of some of the debugging\n+#   the reliability (from 99.9999% to 100% mod. bugs) of some of the debugging\n #   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n #   Assumes that all client allocation is done through debugging\n #   allocators.\n@@ -235,6 +235,10 @@ HOSTCFLAGS=$(CFLAGS)\n #   in a way that usually does not involve acquisition of a global lock.\n #   Currently requires -DGC_LINUX_THREADS, but should be easy to port to\n #   other pthreads environments.  Recommended for multiprocessors.\n+# -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported\n+#   \"__thread\" thread-local variables.  This is the default in HP/UX.  It\n+#   may help performance on recent Linux installations.  (It failed for\n+#   me on RedHat 8, but appears to work on RedHat 9.)\n # -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended\n #   for multiprocessors.  Currently requires Linux on X86 or IA64, though\n #   support for other Posix platforms should be fairly easy to add,\n@@ -316,22 +320,23 @@ DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n \tdoc/README.environment doc/tree.html doc/gcdescr.html \\\n \tdoc/README.autoconf doc/README.macros doc/README.ews4800 \\\n \tdoc/README.DGUX386 doc/README.arm.cross doc/leak.html \\\n-\tdoc/scale.html doc/gcinterface.html doc/README.darwin\n+\tdoc/scale.html doc/gcinterface.html doc/README.darwin \\\n+\tdoc/simple_example.html\n \n TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n-\ttests/leak_test.c tests/thread_leak_test.c\n+\ttests/leak_test.c tests/thread_leak_test.c tests/middle.c\n \n GNU_BUILD_FILES= configure.in Makefile.am configure acinclude.m4 \\\n \t\t libtool.m4 install-sh configure.host Makefile.in \\\n-\t\t ltconfig aclocal.m4 config.sub config.guess \\\n+\t\t aclocal.m4 config.sub config.guess \\\n \t\t include/Makefile.am include/Makefile.in \\\n \t\t doc/Makefile.am doc/Makefile.in \\\n \t\t ltmain.sh mkinstalldirs depcomp missing\n \n OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \\\n \t\t BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \\\n \t\t PCR-Makefile SMakefile.amiga Makefile.DLLs \\\n-\t\t digimars.mak Makefile.direct\n+\t\t digimars.mak Makefile.direct NT_STATIC_THREADS_MAKEFILE\n #\tMakefile and Makefile.direct are copies of each other.\n \n OTHER_FILES= Makefile setjmp_t.c callprocs pc_excludes \\\n@@ -363,16 +368,23 @@ SPECIALCFLAGS = -I$(srcdir)/include\n \n all: gc.a gctest\n \n-BSD-pkg-all: bsd-libgc.a\n+LEAKFLAGS=$(CFLAGS) -DFIND_LEAK\n+\n+BSD-pkg-all: bsd-libgc.a bsd-libleak.a\n \n bsd-libgc.a:\n \t$(MAKE) CFLAGS=\"$(CFLAGS)\" clean c++-t\n \tmv gc.a bsd-libgc.a\n \n+bsd-libleak.a:\n+\t$(MAKE) -f Makefile.direct CFLAGS=\"$(LEAKFLAGS)\" clean c++-nt\n+\tmv gc.a bsd-libleak.a\n+\n BSD-pkg-install: BSD-pkg-all\n \t${CP} bsd-libgc.a libgc.a\n \t${INSTALL_DATA} libgc.a ${PREFIX}/lib\n \t${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include\n+\t${INSTALL_MAN} doc/gc.man ${PREFIX}/man/man3/gc.3\n \n pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \\\n include/private/gc_locks.h include/gc.h include/private/gcconfig.h \\"}, {"sha": "20fa40a9a08ce365de46adbf440afbec2560bee6", "filename": "boehm-gc/Makefile.dist", "status": "modified", "additions": 161, "deletions": 56, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.dist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.dist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dist?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,4 +1,4 @@\n-# This is the original manually generated Makefile.  It may stil be used\n+# This is the original manually generated Makefile.  It may still be used\n # to build the collector.\n #\n # Primary targets:\n@@ -10,13 +10,20 @@\n #\t c++ interface to gc.a\n # cord/de - builds dumb editor based on cords.\n ABI_FLAG= \n+# ABI_FLAG should be the cc flag that specifies the ABI.  On most\n+# platforms this will be the empty string.  Possible values:\n+# +DD64 for 64-bit executable on HP/UX.\n+# -n32, -n64, -o32 for SGI/MIPS ABIs.\n+\n+AS_ABI_FLAG=$(ABI_FLAG)\n+# ABI flag for assembler.  On HP/UX this is +A64 for 64 bit\n+# executables.\n+\n CC=cc $(ABI_FLAG)\n CXX=g++ $(ABI_FLAG)\n-AS=as $(ABI_FLAG)\n+AS=as $(AS_ABI_FLAG)\n #  The above doesn't work with gas, which doesn't run cpp.\n #  Define AS as `gcc -c -x assembler-with-cpp' instead.\n-#  Under Irix 6, you will have to specify the ABI (-o32, -n32, or -64)\n-#  if you use something other than the default ABI on your machine.\n \n # Redefining srcdir allows object code for the nonPCR version of the collector\n # to be generated in different directories.\n@@ -27,8 +34,11 @@ CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_\n \n # To build the parallel collector on Linux, add to the above:\n # -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n-# To build the parallel collector n a static library on HP/UX, add to the above:\n-# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -DUSE_HPUX_TLS -D_POSIX_C_SOURCE=199506L\n+# To build the parallel collector in a static library on HP/UX,\n+# add to the above:\n+# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -D_POSIX_C_SOURCE=199506L\n+# To build the thread-safe collector on Tru64, add to the above:\n+# -pthread -DGC_OSF1_THREADS\n \n # HOSTCC and HOSTCFLAGS are used to build executables that will be run as\n # part of the build process, i.e. on the build machine.  These will usually\n@@ -54,12 +64,22 @@ HOSTCFLAGS=$(CFLAGS)\n #   gc.h before performing thr_ or dl* or GC_ operations.)\n #   Must also define -D_REENTRANT.\n # -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.\n-#   Define SOLARIS_THREADS as well.\n+#   (Internally this define GC_SOLARIS_THREADS as well.)\n # -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.\n # -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.\n #   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n # -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n #   see README.linux.  -D_REENTRANT may also be required.\n+# -DGC_OSF1_THREADS enables support for Tru64 pthreads.  Untested.\n+# -DGC_FREEBSD_THREADS enables support for FreeBSD pthreads.  Untested.\n+#   Appeared to run into some underlying thread problems.\n+# -DGC_DARWIN_THREADS enables support for Mac OS X pthreads.  Untested.\n+# -DGC_DGUX386_THREADS enables support for DB/UX on I386 threads.\n+#   See README.DGUX386.\n+# -DGC_WIN32_THREADS enables support for win32 threads.  That makes sense\n+#   for this Makefile only under Cygwin.\n+# -DGC_THREADS should set the appropriate one of the above macros.\n+#   It assumes pthreads for Solaris.\n # -DALL_INTERIOR_POINTERS allows all pointers to the interior\n #   of objects to be recognized.  (See gc_priv.h for consequences.)\n #   Alternatively, GC_all_interior_pointers can be set at process\n@@ -88,26 +108,34 @@ HOSTCFLAGS=$(CFLAGS)\n #   code from the heap.  Currently this only affects the incremental\n #   collector on UNIX machines.  It may greatly improve its performance,\n #   since this may avoid some expensive cache synchronization.\n-# -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n-#   new syntax \"operator new[]\" for allocating and deleting arrays.\n+# -DGC_NO_OPERATOR_NEW_ARRAY declares that the C++ compiler does not support\n+#   the  new syntax \"operator new[]\" for allocating and deleting arrays.\n #   See gc_cpp.h for details.  No effect on the C part of the collector.\n-#   This is defined implicitly in a few environments.\n-# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n-#   as aliases for X, GC_realloc, and GC_free, respectively.\n-#   Calloc is redefined in terms of the new malloc.  X should\n+#   This is defined implicitly in a few environments.  Must also be defined\n+#   by clients that use gc_cpp.h.\n+# -DREDIRECT_MALLOC=X causes malloc to be defined as alias for X.\n+#   Unless the following macros are defined, realloc is also redirected\n+#   to GC_realloc, and free is redirected to GC_free.\n+#   Calloc and strdup are redefined in terms of the new malloc.  X should\n #   be either GC_malloc or GC_malloc_uncollectable, or\n #   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc\n #   with dummy source location information, but still results in\n-#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.)\n+#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.\n+#   It requires that the following two macros also be used.)\n #   The former is occasionally useful for working around leaks in code\n #   you don't want to (or can't) look at.  It may not work for\n #   existing code, but it often does.  Neither works on all platforms,\n #   since some ports use malloc or calloc to obtain system memory.\n-#   (Probably works for UNIX, and win32.)\n+#   (Probably works for UNIX, and win32.)  If you build with DBG_HDRS_ALL,\n+#   you should only use GC_debug_malloc_replacement as a malloc\n+#   replacement.\n # -DREDIRECT_REALLOC=X causes GC_realloc to be redirected to X.\n #   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,\n #   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to\n #   generate leak reports with call stacks for both malloc and realloc.\n+#   This also requires the following:\n+# -DREDIRECT_FREE=X causes free to be redirected to X.  The\n+#   canonical use is -DREDIRECT_FREE=GC_debug_free.\n # -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n #   -DREDIRECT_MALLOC.\n # -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n@@ -135,8 +163,8 @@ HOSTCFLAGS=$(CFLAGS)\n #   Works for Solaris and Irix.\n # -DUSE_MUNMAP causes memory to be returned to the OS under the right\n #   circumstances.  This currently disables VM-based incremental collection.\n-#   This is currently experimental, and works only under some Unix and\n-#   Linux versions.\n+#   This is currently experimental, and works only under some Unix,\n+#   Linux and Windows versions.\n # -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n #   GC_scratch_alloc() to get stack memory.\n # -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n@@ -154,7 +182,7 @@ HOSTCFLAGS=$(CFLAGS)\n #   this facility is only used in a few places.  It is intended primarily\n #   for debugging of the garbage collector itself, but could also\n # -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n-#   the reliability (from 99.9999% to 100%) of some of the debugging\n+#   the reliability (from 99.9999% to 100% mod. bugs) of some of the debugging\n #   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n #   Assumes that all client allocation is done through debugging\n #   allocators.\n@@ -172,8 +200,12 @@ HOSTCFLAGS=$(CFLAGS)\n #   allocated through the debugging interface.  Affects the amount of\n #   information generated in leak reports.  Only matters on platforms\n #   on which we can quickly generate call stacks, currently Linux/(X86 & SPARC)\n-#   and Solaris/SPARC.  Turns on call chain saving on X86.  On X86, client\n+#   and Solaris/SPARC and platforms that provide execinfo.h.\n+#   Default is zero.  On X86, client\n #   code should NOT be compiled with -fomit-frame-pointer.\n+# -DSAVE_CALL_NARGS=<n> Set the number of functions arguments to be\n+#   saved with each call frame.  Default is zero.  Ignored if we\n+#   don't know how to retrieve arguments on the platform.\n # -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n #   altered stubborn objects, at substantial performance cost.\n #   Use only for debugging of the incremental collector.\n@@ -190,8 +222,11 @@ HOSTCFLAGS=$(CFLAGS)\n #   15% or so.\n # -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n #   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n-#   UNTESTED!!\n-# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n+#   Minimally tested.  Didn't appear to be an obvious win on a K6-2/500.\n+# -DUSE_PPC_PREFETCH causes the collector to issue PowerPC style\n+#   prefetch instructions.  No effect except on PowerPC OS X platforms.\n+#   Performance impact untested.\n+# -DGC_USE_LD_WRAP in combination with the old flags listed in README.linux\n #   causes the collector some system and pthread calls in a more transparent\n #   fashion than the usual macro-based approach.  Requires GNU ld, and\n #   currently probably works only with Linux.\n@@ -200,6 +235,10 @@ HOSTCFLAGS=$(CFLAGS)\n #   in a way that usually does not involve acquisition of a global lock.\n #   Currently requires -DGC_LINUX_THREADS, but should be easy to port to\n #   other pthreads environments.  Recommended for multiprocessors.\n+# -DUSE_COMPILER_TLS causes thread local allocation to use compiler-supported\n+#   \"__thread\" thread-local variables.  This is the default in HP/UX.  It\n+#   may help performance on recent Linux installations.  (It failed for\n+#   me on RedHat 8, but appears to work on RedHat 9.)\n # -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended\n #   for multiprocessors.  Currently requires Linux on X86 or IA64, though\n #   support for other Posix platforms should be fairly easy to add,\n@@ -208,60 +247,105 @@ HOSTCFLAGS=$(CFLAGS)\n #   These may otherwise alter its configuration, or turn off GC altogether.\n #   I don't know of a reason to disable this, except possibly if the\n #   resulting process runs as a privileged user?\n+# -DUSE_GLOBAL_ALLOC.  Win32 only.  Use GlobalAlloc instead of\n+#   VirtualAlloc to allocate the heap.  May be needed to work around\n+#   a Windows NT/2000 issue.  Incompatible with USE_MUNMAP.\n+#   See README.win32 for details.\n+# -DMAKE_BACK_GRAPH. Enable GC_PRINT_BACK_HEIGHT environment variable.\n+#   See README.environment for details.  Experimental. Limited platform\n+#   support.  Implies DBG_HDRS_ALL.  All allocation should be done using\n+#   the debug interface.\n # -DSTUBBORN_ALLOC allows allocation of \"hard to change\" objects, and thus\n #   makes incremental collection easier.  Was enabled by default until 6.0.\n #   Rarely used, to my knowledge.\n+# -DHANDLE_FORK attempts to make GC_malloc() work in a child process fork()ed\n+#   from a multithreaded parent.  Currently only supported by pthread_support.c.\n+#   (Similar code should work on Solaris or Irix, but it hasn't been tried.)\n+# -DTEST_WITH_SYSTEM_MALLOC causes gctest to allocate (and leak) large chunks\n+#   of memory with the standard system malloc.  This will cause the root\n+#   set and collected heap to grow significantly if malloced memory is\n+#   somehow getting traced by the collector.  This has no impact on the\n+#   generated library; it only affects the test.\n+# -DPOINTER_MASK=0x... causes candidate pointers to be ANDed with the\n+#   given mask before being considered.  If either this or the following\n+#   macro is defined, it will be assumed that all pointers stored in\n+#   the heap need to be processed this way.  Stack and register pointers\n+#   will be considered both with and without processing.\n+#   These macros are normally needed only to support systems that use\n+#   high-order pointer tags. EXPERIMENTAL.\n+# -DPOINTER_SHIFT=n causes the collector to left shift candidate pointers\n+#   by the indicated amount before trying to interpret them.  Applied\n+#   after POINTER_MASK. EXPERIMENTAL.  See also the preceding macro.\n #\n \n CXXFLAGS= $(CFLAGS) \n AR= ar\n RANLIB= ranlib\n \n \n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o aix_irix_threads.o pthread_support.o pthread_stop_world.o darwin_stop_world.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o backgraph.o win32_threads.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c aix_irix_threads.c pthread_support.c pthread_stop_world.c darwin_stop_world.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c backgraph.c win32_threads.c\n \n CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n \n CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n \n-SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n-    sparc_mach_dep.s include/gc.h include/gc_typed.h \\\n+SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.S \\\n+    sparc_mach_dep.S include/gc.h include/gc_typed.h \\\n     include/private/gc_hdrs.h include/private/gc_priv.h \\\n     include/private/gcconfig.h include/private/gc_pmark.h \\\n     include/gc_inl.h include/gc_inline.h include/gc_mark.h \\\n     threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n-    include/weakpointer.h include/private/gc_locks.h \\\n+    gcname.c include/weakpointer.h include/private/gc_locks.h \\\n     gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n-    include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n-    sparc_netbsd_mach_dep.s \\\n+    include/new_gc_alloc.h include/gc_allocator.h \\\n+    include/javaxfc.h sparc_sunos4_mach_dep.s sparc_netbsd_mach_dep.s \\\n     include/private/solaris_threads.h include/gc_backptr.h \\\n     hpux_test_and_clear.s include/gc_gcj.h \\\n     include/gc_local_alloc.h include/private/dbg_mlc.h \\\n-    include/private/specific.h powerpc_macosx_mach_dep.s \\\n+    include/private/specific.h powerpc_darwin_mach_dep.s \\\n     include/leak_detector.h include/gc_amiga_redirects.h \\\n-    include/gc_pthread_redirects.h $(CORD_SRCS)\n+    include/gc_pthread_redirects.h ia64_save_regs_in_stack.s \\\n+    include/gc_config_macros.h include/private/pthread_support.h \\\n+    include/private/pthread_stop_world.h include/private/darwin_semaphore.h \\\n+    include/private/darwin_stop_world.h $(CORD_SRCS)\n \n DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n-\tdoc/README.amiga doc/README.cords doc/README.debugging \\\n+\tdoc/README.amiga doc/README.cords doc/debugging.html \\\n \tdoc/README.dj doc/README.hp doc/README.linux doc/README.rs6000 \\\n \tdoc/README.sgi doc/README.solaris2 doc/README.uts \\\n \tdoc/README.win32 doc/barrett_diagram doc/README \\\n         doc/README.contributors doc/README.changes doc/gc.man \\\n-\tdoc/README.environment\n+\tdoc/README.environment doc/tree.html doc/gcdescr.html \\\n+\tdoc/README.autoconf doc/README.macros doc/README.ews4800 \\\n+\tdoc/README.DGUX386 doc/README.arm.cross doc/leak.html \\\n+\tdoc/scale.html doc/gcinterface.html doc/README.darwin \\\n+\tdoc/simple_example.html\n \n TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n-\ttests/leak_test.c tests/thread_leak_test.c\n-OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n-           setjmp_t.c SMakefile.amiga configure.in Makefile.am \\\n-           callprocs pc_excludes \\\n-           MacProjects.sit.hqx MacOS.c EMX_MAKEFILE \\\n+\ttests/leak_test.c tests/thread_leak_test.c tests/middle.c\n+\n+GNU_BUILD_FILES= configure.in Makefile.am configure acinclude.m4 \\\n+\t\t libtool.m4 install-sh configure.host Makefile.in \\\n+\t\t aclocal.m4 config.sub config.guess \\\n+\t\t include/Makefile.am include/Makefile.in \\\n+\t\t doc/Makefile.am doc/Makefile.in \\\n+\t\t ltmain.sh mkinstalldirs depcomp missing\n+\n+OTHER_MAKEFILES= OS2_MAKEFILE NT_MAKEFILE NT_THREADS_MAKEFILE gc.mak \\\n+\t\t BCC_MAKEFILE EMX_MAKEFILE WCC_MAKEFILE Makefile.dj \\\n+\t\t PCR-Makefile SMakefile.amiga Makefile.DLLs \\\n+\t\t digimars.mak Makefile.direct NT_STATIC_THREADS_MAKEFILE\n+#\tMakefile and Makefile.direct are copies of each other.\n+\n+OTHER_FILES= Makefile setjmp_t.c callprocs pc_excludes \\\n+           MacProjects.sit.hqx MacOS.c \\\n            Mac_files/datastart.c Mac_files/dataend.c \\\n            Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n            add_gc_prefix.c gc_cpp.cpp \\\n-\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak Makefile.dj \\\n-\t   version.h Makefile.DLLs WCC_MAKEFILE AmigaOS.c $(TESTS)\n+\t   version.h AmigaOS.c \\\n+\t   $(TESTS) $(GNU_BUILD_FILES) $(OTHER_MAKEFILES)\n \n CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n \t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n@@ -284,16 +368,23 @@ SPECIALCFLAGS = -I$(srcdir)/include\n \n all: gc.a gctest\n \n-BSD-pkg-all: bsd-libgc.a\n+LEAKFLAGS=$(CFLAGS) -DFIND_LEAK\n+\n+BSD-pkg-all: bsd-libgc.a bsd-libleak.a\n \n bsd-libgc.a:\n \t$(MAKE) CFLAGS=\"$(CFLAGS)\" clean c++-t\n \tmv gc.a bsd-libgc.a\n \n+bsd-libleak.a:\n+\t$(MAKE) -f Makefile.direct CFLAGS=\"$(LEAKFLAGS)\" clean c++-nt\n+\tmv gc.a bsd-libleak.a\n+\n BSD-pkg-install: BSD-pkg-all\n \t${CP} bsd-libgc.a libgc.a\n \t${INSTALL_DATA} libgc.a ${PREFIX}/lib\n \t${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include\n+\t${INSTALL_MAN} doc/gc.man ${PREFIX}/man/man3/gc.3\n \n pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \\\n include/private/gc_locks.h include/gc.h include/private/gcconfig.h \\\n@@ -304,16 +395,16 @@ mach_dep.o $(SRCS)\n $(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \\\n     $(srcdir)/include/private/gc_priv.h \\\n     $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n-    $(srcdir)/include/gc.h \\\n+    $(srcdir)/include/gc.h $(srcdir)/include/gc_pthread_redirects.h \\\n     $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n-    Makefile\n+    $(srcdir)/include/gc_config_macros.h Makefile\n # The dependency on Makefile is needed.  Changing\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n \n mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n \n-specific.o linux_threads.o: $(srcdir)/include/private/specific.h\n+specific.o pthread_support.o: $(srcdir)/include/private/specific.h\n \n solaris_threads.o solaris_pthreads.o: $(srcdir)/include/private/solaris_threads.h\n \n@@ -408,21 +499,25 @@ liblinuxgc.so: $(OBJS) dyn_load.o\n # \tgcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo\n #\ttouch liblinuxgc.so\n \n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s \\\n-            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_macosx_mach_dep.s $(UTILS)\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s \\\n+\t    $(srcdir)/mips_ultrix_mach_dep.s \\\n+            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_darwin_mach_dep.s \\\n+\t    $(srcdir)/sparc_mach_dep.S $(srcdir)/sparc_sunos4_mach_dep.s \\\n+\t    $(srcdir)/ia64_save_regs_in_stack.s \\\n+\t    $(srcdir)/sparc_netbsd_mach_dep.s $(UTILS)\n \trm -f mach_dep.o\n-\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n+\t./if_mach MIPS IRIX5 $(CC) -c -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n \t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n-\t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n-\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_macosx_mach_dep.s\n-#\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n-#\talpha_mach_dep.s assumes that pointers are not saved in fp registers.\n-#\tGcc on a 21264 can spill pointers to fp registers.  Oops.\n-\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n+\t./if_mach POWERPC DARWIN $(AS) -o mach_dep.o $(srcdir)/powerpc_darwin_mach_dep.s\n+\t./if_mach ALPHA LINUX $(CC) -c -o mach_dep.o $(srcdir)/alpha_mach_dep.S\n+\t./if_mach SPARC SUNOS5 $(CC) -c -o mach_dep.o $(srcdir)/sparc_mach_dep.S\n \t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n \t./if_mach SPARC OPENBSD $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n \t./if_mach SPARC NETBSD $(AS) -o mach_dep.o $(srcdir)/sparc_netbsd_mach_dep.s\n+\t./if_mach IA64 \"\" as $(AS_ABI_FLAG) -o ia64_save_regs_in_stack.o $(srcdir)/ia64_save_regs_in_stack.s\n+\t./if_mach IA64 \"\" $(CC) -c -o mach_dep1.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n+\t./if_mach IA64 \"\" ld -r -o mach_dep.o mach_dep1.o ia64_save_regs_in_stack.o\n \t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n \n mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)\n@@ -462,7 +557,7 @@ cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n \t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n \t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`\n \t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_mach POWERPC MACOSX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n+\t./if_mach POWERPC DARWIN $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n \t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n \t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n \t./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n@@ -481,7 +576,7 @@ if_not_there: $(srcdir)/if_not_there.c\n clean: \n \trm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \\\n \t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n-\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de\n+\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de \n \t-rm -f *~\n \n gctest: tests/test.o gc.a $(UTILS)\n@@ -505,12 +600,22 @@ KandRtest: setjmp_test gctest\n \t./setjmp_test\n \t./gctest\n \n-add_gc_prefix: add_gc_prefix.c\n+add_gc_prefix: $(srcdir)/add_gc_prefix.c $(srcdir)/version.h\n \t$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c\n \n-gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix\n+gcname: $(srcdir)/gcname.c $(srcdir)/version.h\n+\t$(CC) -o gcname $(srcdir)/gcname.c\n+\n+gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix gcname\n+\tcp Makefile Makefile.old\n+\tcp Makefile.direct Makefile\n+\trm -f `./gcname`\n+\tln -s . `./gcname`\n \t./add_gc_prefix $(SRCS) $(DOC_FILES) $(OTHER_FILES) > /tmp/gc.tar-files\n \ttar cvfh gc.tar `cat /tmp/gc.tar-files`\n+\tcp gc.tar `./gcname`.tar\n+\tgzip `./gcname`.tar\n+\trm `./gcname`\n \n pc_gc.tar: $(SRCS) $(OTHER_FILES)\n \ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)"}, {"sha": "7757f15133d5117f2d79f61395a640911f2df31e", "filename": "boehm-gc/Makefile.dj", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -29,7 +29,7 @@ EXE_SUFFIX=.exe\n srcdir= .\n VPATH= $(srcdir)\n \n-CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n+CFLAGS= -gstabs+ -O2 -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n \n # Setjmp_test may yield overly optimistic results when compiled\n # without optimization.\n@@ -157,9 +157,9 @@ AR= ar\n RANLIB= ranlib\n \n \n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o hpux_irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c hpux_irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c\n \n CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n \n@@ -181,7 +181,7 @@ SRCS= $(CSRCS) mips_sgi_mach_dep.S rs6000_mach_dep.s alpha_mach_dep.S \\\n     include/leak_detector.h $(CORD_SRCS)\n \n OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n-           README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n+           README tests/test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n            SCoptions.amiga README.amiga README.win32 cord/README \\\n \t   README.rs6000 README.QUICK callprocs pc_excludes \\\n            barrett_diagram README.OS2 README.Mac MacProjects.sit.hqx \\\n@@ -206,7 +206,7 @@ CURSES= -lcurses -ltermlib\n # the SHELL environment variable.\n SHELL= /bin/sh\n \n-SPECIALCFLAGS = \n+SPECIALCFLAGS = -I$(srcdir)/include\n # Alternative flags to the C compiler for mach_dep.c.\n # Mach_dep.c often doesn't like optimization, and it's\n # not time-critical anyway.\n@@ -224,7 +224,7 @@ $(OBJS) test.o dyn_load.o dyn_load_sunos53.o: \\\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n \n-mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n+mark.o typd_mlc.o finalize.o: $(srcdir)/include/gc_mark.h\n \n base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n \techo > base_lib\n@@ -366,11 +366,11 @@ clean:\n \trm -f threadlibs$(EXE_SUFFIX) cord/cordtest$(EXE_SUFFIX)\n \t-rm -f *~\n \n-gctest$(EXE_SUFFIX): test.o gc.a if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n+gctest$(EXE_SUFFIX): tests/test.o gc.a if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n \trm -f gctest gctest$(EXE_SUFFIX)\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  test.o gc.a -lucb\n-\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o gctest  test.o gc.a -ldld\n-\t./if_not_there gctest$(EXE_SUFFIX) $(CC) $(CFLAGS) -o gctest$(EXE_SUFFIX) test.o gc.a\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld\n+\t./if_not_there gctest$(EXE_SUFFIX) $(CC) $(CFLAGS) -o gctest$(EXE_SUFFIX) tests/test.o gc.a\n \trm -f gctest\n \n # If an optimized setjmp_test generates a segmentation fault,\n@@ -407,8 +407,8 @@ gc.tar.Z: gc.tar\n gc.tar.gz: gc.tar\n \tgzip gc.tar\n \n-lint: $(CSRCS) test.c\n-\tlint -DLINT $(CSRCS) test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall\"\n+lint: $(CSRCS) tests/test.c\n+\tlint -DLINT $(CSRCS) tests/test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall\"\n \n # BTL: added to test shared library version of collector.\n # Currently works only under SunOS5.  Requires GC_INIT call from statically\n@@ -417,8 +417,8 @@ ABSDIR = `pwd`\n gctest_dyn_link: test.o libgc.so\n \t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread\n \n-test_dll.o: test.c libgc_globals.h\n-\t$(CC) $(CFLAGS) -DGC_USE_DLL -c test.c -o test_dll.o\n+test_dll.o: tests/test.c libgc_globals.h\n+\t$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o\n \n test_dll: test_dll.o libgc_dll.a libgc.dll\n \t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll"}, {"sha": "d73b2390d35d3466de3e01ae6f1449ab081d4ec4", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 13, "deletions": 37, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated by automake 1.8.5 from Makefile.am.\n+# Makefile.in generated by automake 1.9 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n@@ -81,15 +81,6 @@ am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n CONFIG_CLEAN_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-am__libgcjgc_la_SOURCES_DIST = allchblk.c alloc.c blacklst.c \\\n-\tchecksums.c dbg_mlc.c dyn_load.c finalize.c gc_dlopen.c \\\n-\tgcj_mlc.c headers.c aix_irix_threads.c malloc.c mallocx.c \\\n-\tmark.c mark_rts.c misc.c new_hblk.c obj_map.c os_dep.c \\\n-\tpcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-\tsolaris_pthreads.c solaris_threads.c specific.c stubborn.c \\\n-\ttypd_mlc.c backgraph.c win32_threads.c pthread_support.c \\\n-\tpthread_stop_world.c darwin_stop_world.c \\\n-\tpowerpc_darwin_mach_dep.s\n @POWERPC_DARWIN_TRUE@am__objects_1 = powerpc_darwin_mach_dep.lo\n am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n \tdbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo \\\n@@ -101,15 +92,6 @@ am__objects_2 = allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n \tpthread_stop_world.lo darwin_stop_world.lo $(am__objects_1)\n am_libgcjgc_la_OBJECTS = $(am__objects_2)\n libgcjgc_la_OBJECTS = $(am_libgcjgc_la_OBJECTS)\n-am__libgcjgc_convenience_la_SOURCES_DIST = allchblk.c alloc.c \\\n-\tblacklst.c checksums.c dbg_mlc.c dyn_load.c finalize.c \\\n-\tgc_dlopen.c gcj_mlc.c headers.c aix_irix_threads.c malloc.c \\\n-\tmallocx.c mark.c mark_rts.c misc.c new_hblk.c obj_map.c \\\n-\tos_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n-\tsolaris_pthreads.c solaris_threads.c specific.c stubborn.c \\\n-\ttypd_mlc.c backgraph.c win32_threads.c pthread_support.c \\\n-\tpthread_stop_world.c darwin_stop_world.c \\\n-\tpowerpc_darwin_mach_dep.s\n am_libgcjgc_convenience_la_OBJECTS = $(am__objects_2)\n libgcjgc_convenience_la_OBJECTS =  \\\n \t$(am_libgcjgc_convenience_la_OBJECTS)\n@@ -129,8 +111,6 @@ LTCCASCOMPILE = $(LIBTOOL) --mode=compile $(CCAS) $(AM_CCASFLAGS) \\\n \t$(CCASFLAGS)\n SOURCES = $(libgcjgc_la_SOURCES) $(libgcjgc_convenience_la_SOURCES) \\\n \t$(gctest_SOURCES)\n-DIST_SOURCES = $(am__libgcjgc_la_SOURCES_DIST) \\\n-\t$(am__libgcjgc_convenience_la_SOURCES_DIST) $(gctest_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -227,6 +207,8 @@ am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n bindir = @bindir@\n build = @build@\n build_alias = @build_alias@\n@@ -430,15 +412,6 @@ distclean-compile:\n .c.lo:\n \t$(LTCOMPILE) -c -o $@ $<\n \n-tests/test.o: tests/test.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tests/test.o `test -f 'tests/test.c' || echo '$(srcdir)/'`tests/test.c\n-\n-tests/test.obj: tests/test.c\n-\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tests/test.obj `if test -f 'tests/test.c'; then $(CYGPATH_W) 'tests/test.c'; else $(CYGPATH_W) '$(srcdir)/tests/test.c'; fi`\n-\n-tests/test.lo: tests/test.c\n-\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tests/test.lo `test -f 'tests/test.c' || echo '$(srcdir)/'`tests/test.c\n-\n .s.o:\n \t$(CCASCOMPILE) -c $<\n \n@@ -454,19 +427,22 @@ clean-libtool:\n distclean-libtool:\n \t-rm -f libtool\n \n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n \n mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n uninstall-info-am:\n \n # This directory's subdirectories are mostly independent; you can cd\n@@ -686,7 +662,7 @@ mostlyclean-generic:\n clean-generic:\n \n distclean-generic:\n-\t-rm -f $(CONFIG_CLEAN_FILES)\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \t-rm -f tests/$(am__dirstamp)\n \n maintainer-clean-generic:"}, {"sha": "d1b6a5d6f1f78496805dab22cc8c29cd49ea46b8", "filename": "boehm-gc/NT_MAKEFILE", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FNT_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2FNT_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_MAKEFILE?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -2,18 +2,19 @@\n # DLLs are included in the root set under NT, but not under win32S.\n # Use \"nmake nodebug=1 all\" for optimized versions of library, gctest and editor.\n \n-CPU= i386\n+MY_CPU=X86\n+CPU=$(MY_CPU)\n !include <ntwin32.mak>\n \n OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj obj_map.obj blacklst.obj finalize.obj new_hblk.obj dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj\n \n all: gctest.exe cord\\de.exe test_cpp.exe\n \n .c.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ -DGC_NOT_DLL $*.c /Fo$*.obj\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ -DGC_NOT_DLL -DGC_BUILD $*.c /Fo$*.obj\n \n .cpp.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -DGC_NOT_DLL $*.CPP /Fo$*.obj\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -DGC_NOT_DLL -DGC_BUILD $*.CPP /Fo$*.obj\n \n $(OBJS) tests\\test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h include\\private\\gc_locks.h include\\private\\gc_pmark.h include\\gc_mark.h\n \n@@ -30,7 +31,7 @@ gctest.exe: tests\\test.obj gc.lib\n #\tmapsympe -n -o gctest.sym gctest.exe\n \n cord\\de_win.rbj: cord\\de_win.res\n-\tcvtres -$(CPU) cord\\de_win.res -o cord\\de_win.rbj\n+\tcvtres /MACHINE:$(MY_CPU) /OUT:cord\\de_win.rbj cord\\de_win.res\n \n cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n "}, {"sha": "18ec86807b0201bfaaa9b34eb775ba403975fc8e", "filename": "boehm-gc/aclocal.m4", "status": "modified", "additions": 145, "deletions": 33, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faclocal.m4?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,4 +1,4 @@\n-# generated automatically by aclocal 1.8.5 -*- Autoconf -*-\n+# generated automatically by aclocal 1.9 -*- Autoconf -*-\n \n # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n # Free Software Foundation, Inc.\n@@ -33,14 +33,14 @@\n # ----------------------------\n # Automake X.Y traces this macro to ensure aclocal.m4 has been\n # generated from the m4 files accompanying Automake X.Y.\n-AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.8\"])\n+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version=\"1.9\"])\n \n # AM_SET_CURRENT_AUTOMAKE_VERSION\n # -------------------------------\n # Call AM_AUTOMAKE_VERSION so it can be traced.\n # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.\n AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-\t [AM_AUTOMAKE_VERSION([1.8.5])])\n+\t [AM_AUTOMAKE_VERSION([1.9])])\n \n # AM_AUX_DIR_EXPAND\n \n@@ -108,7 +108,7 @@ am_aux_dir=`cd $ac_aux_dir && pwd`\n \n # AM_CONDITIONAL                                              -*- Autoconf -*-\n \n-# Copyright (C) 1997, 2000, 2001, 2003 Free Software Foundation, Inc.\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -145,8 +145,8 @@ else\n fi\n AC_CONFIG_COMMANDS_PRE(\n [if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.])\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n fi])])\n \n # serial 7\t\t\t\t\t\t-*- Autoconf -*-\n@@ -319,7 +319,8 @@ AC_SUBST([AMDEPBACKSLASH])\n \n # Generate code to set up dependency tracking.   -*- Autoconf -*-\n \n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+#   Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -355,27 +356,21 @@ AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n   else\n     continue\n   fi\n-  grep '^DEP_FILES *= *[[^ @%:@]]' < \"$mf\" > /dev/null || continue\n-  # Extract the definition of DEP_FILES from the Makefile without\n-  # running `make'.\n+  # Extract the definition of DEPDIR, am__include, and am__quote\n+  # from the Makefile without running `make'.\n   DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n   test -z \"$DEPDIR\" && continue\n+  am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+  test -z \"am__include\" && continue\n+  am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n   # When using ansi2knr, U may be empty or an underscore; expand it\n   U=`sed -n 's/^U = //p' < \"$mf\"`\n-  test -d \"$dirpart/$DEPDIR\" || mkdir \"$dirpart/$DEPDIR\"\n-  # We invoke sed twice because it is the simplest approach to\n-  # changing $(DEPDIR) to its actual value in the expansion.\n-  for file in `sed -n '\n-    /^DEP_FILES = .*\\\\\\\\$/ {\n-      s/^DEP_FILES = //\n-      :loop\n-\ts/\\\\\\\\$//\n-\tp\n-\tn\n-\t/\\\\\\\\$/ b loop\n-      p\n-    }\n-    /^DEP_FILES = / s/^DEP_FILES = //p' < \"$mf\" | \\\n+  # Find all dependency output files, they are included files with\n+  # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+  # simplest approach to changing $(DEPDIR) to its actual value in the\n+  # expansion.\n+  for file in `sed -n \"\n+    s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n        sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n     # Make sure the directory exists.\n     test -f \"$dirpart/$file\" && continue\n@@ -406,7 +401,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n # This macro actually does too much some checks are only needed if\n # your package does certain things.  But this isn't really a big deal.\n \n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n # Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n@@ -482,7 +477,6 @@ AM_MISSING_PROG(AUTOCONF, autoconf)\n AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n AM_MISSING_PROG(AUTOHEADER, autoheader)\n AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AM_MISSING_PROG(AMTAR, tar)\n AM_PROG_INSTALL_SH\n AM_PROG_INSTALL_STRIP\n AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n@@ -491,7 +485,9 @@ AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n AC_REQUIRE([AC_PROG_AWK])dnl\n AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t      \t\t     [_AM_PROG_TAR([v7])])])\n _AM_IF_OPTION([no-dependencies],,\n [AC_PROVIDE_IFELSE([AC_PROG_CC],\n                   [_AM_DEPENDENCIES(CC)],\n@@ -814,13 +810,21 @@ fi\n # this.)\n AC_DEFUN([AM_PROG_MKDIR_P],\n [if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n-  # Keeping the `.' argument allows $(mkdir_p) to be used without\n-  # argument.  Indeed, we sometimes output rules like\n+  # We used to keeping the `.' as first argument, in order to\n+  # allow $(mkdir_p) to be used without argument.  As in\n   #   $(mkdir_p) $(somedir)\n-  # where $(somedir) is conditionally defined.\n-  # (`test -n '$(somedir)' && $(mkdir_p) $(somedir)' is a more\n-  # expensive solution, as it forces Make to start a sub-shell.)\n-  mkdir_p='mkdir -p -- .'\n+  # where $(somedir) is conditionally defined.  However this is wrong\n+  # for two reasons:\n+  #  1. if the package is installed by a user who cannot write `.'\n+  #     make install will fail,\n+  #  2. the above comment should most certainly read\n+  #     $(mkdir_p) $(DESTDIR)$(somedir)\n+  #     so it does not work when $(somedir) is undefined and\n+  #     $(DESTDIR) is not.\n+  #  To support the latter case, we have to write\n+  #     test -z \"$(somedir)\" || $(mkdir_p) $(DESTDIR)$(somedir),\n+  #  so the `.' trick is pointless.\n+  mkdir_p='mkdir -p --'\n else\n   # On NextStep and OpenStep, the `mkdir' command does not\n   # recognize any option.  It will interpret all options as\n@@ -1055,4 +1059,112 @@ fi\n INSTALL_STRIP_PROGRAM=\"\\${SHELL} \\$(install_sh) -c -s\"\n AC_SUBST([INSTALL_STRIP_PROGRAM])])\n \n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004  Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n+# 02111-1307, USA.\n+\n+# serial 1\n+\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n m4_include([acinclude.m4])"}, {"sha": "793c468b928c4b8364c86d9937c01d2c28943650", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -111,7 +111,7 @@ void GC_print_hblkfreelist()\n     for (i = 0; i <= N_HBLK_FLS; ++i) {\n       h = GC_hblkfreelist[i];\n #     ifdef USE_MUNMAP\n-        if (0 != h) GC_printf1(\"Free list %ld (Total size %ld):\\n\",\n+        if (0 != h) GC_printf1(\"Free list %ld:\\n\",\n \t\t               (unsigned long)i);\n #     else\n         if (0 != h) GC_printf2(\"Free list %ld (Total size %ld):\\n\",\n@@ -133,10 +133,12 @@ void GC_print_hblkfreelist()\n         h = hhdr -> hb_next;\n       }\n     }\n-    if (total_free != GC_large_free_bytes) {\n+#   ifndef USE_MUNMAP\n+      if (total_free != GC_large_free_bytes) {\n \tGC_printf1(\"GC_large_free_bytes = %lu (INCONSISTENT!!)\\n\",\n \t\t   (unsigned long) GC_large_free_bytes);\n-    }\n+      }\n+#   endif\n     GC_printf1(\"Total of %lu bytes on free list\\n\", (unsigned long)total_free);\n }\n \n@@ -181,7 +183,7 @@ void GC_dump_regions()\n \t    hhdr = HDR(p);\n \t    GC_printf1(\"\\t0x%lx \", (unsigned long)p);\n \t    if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n-\t\tGC_printf1(\"Missing header!!\\n\", hhdr);\n+\t\tGC_printf1(\"Missing header!!(%ld)\\n\", hhdr);\n \t\tp += HBLKSIZE;\n \t\tcontinue;\n \t    }\n@@ -375,9 +377,8 @@ void GC_unmap_old(void)\n \tif (!IS_MAPPED(hhdr)) continue;\n \tthreshold = (unsigned short)(GC_gc_no - UNMAP_THRESHOLD);\n \tlast_rec = hhdr -> hb_last_reclaimed;\n-\tif (last_rec > GC_gc_no\n-\t    || last_rec < threshold && threshold < GC_gc_no\n-\t\t\t\t       /* not recently wrapped */) {\n+\tif ((last_rec > GC_gc_no || last_rec < threshold)\n+\t    && threshold < GC_gc_no /* not recently wrapped */) {\n           sz = hhdr -> hb_sz;\n \t  GC_unmap((ptr_t)h, sz);\n \t  hhdr -> hb_flags |= WAS_UNMAPPED;\n@@ -422,6 +423,7 @@ void GC_merge_unmapped(void)\n \t      } else {\n \t\tGC_remap((ptr_t)h, size);\n \t\thhdr -> hb_flags &= ~WAS_UNMAPPED;\n+\t\thhdr -> hb_last_reclaimed = nexthdr -> hb_last_reclaimed;\n \t      }\n \t    } else {\n \t      /* Unmap any gap in the middle */\n@@ -468,7 +470,11 @@ int index;\n     if (total_size == bytes) return h;\n     rest = (struct hblk *)((word)h + bytes);\n     rest_hdr = GC_install_header(rest);\n-    if (0 == rest_hdr) return(0);\n+    if (0 == rest_hdr) {\n+\t/* This may be very bad news ... */\n+\tWARN(\"Header allocation failed: Dropping block.\\n\", 0);\n+\treturn(0);\n+    }\n     rest_hdr -> hb_sz = total_size - bytes;\n     rest_hdr -> hb_flags = 0;\n #   ifdef GC_ASSERTIONS\n@@ -784,6 +790,9 @@ signed_word size;\n     size = HBLKSIZE * OBJ_SZ_TO_BLOCKS(size);\n     GC_remove_counts(hbp, (word)size);\n     hhdr->hb_sz = size;\n+#   ifdef USE_MUNMAP\n+      hhdr -> hb_last_reclaimed = GC_gc_no;\n+#   endif\n     \n     /* Check for duplicate deallocation in the easy case */\n       if (HBLK_IS_FREE(hhdr)) {\n@@ -809,11 +818,17 @@ signed_word size;\n \tif (IS_MAPPED(prevhdr)) {\n \t  GC_remove_from_fl(prevhdr, FL_UNKNOWN);\n \t  prevhdr -> hb_sz += hhdr -> hb_sz;\n+#\t  ifdef USE_MUNMAP\n+\t    prevhdr -> hb_last_reclaimed = GC_gc_no;\n+#\t  endif\n \t  GC_remove_header(hbp);\n \t  hbp = prev;\n \t  hhdr = prevhdr;\n \t}\n       }\n+    /* FIXME: It is not clear we really always want to do these merges\t*/\n+    /* with -DUSE_MUNMAP, since it updates ages and hence prevents\t*/\n+    /* unmapping. \t\t\t\t\t\t\t*/\n \n     GC_large_free_bytes += size;\n     GC_add_to_fl(hbp, hhdr);    "}, {"sha": "1ac6ff8111f923f208683bacb9895b13f1313565", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -133,7 +133,7 @@ int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n \t  if (GC_print_stats) {\n \t    GC_printf0(\"Abandoning stopped marking after \");\n \t    GC_printf1(\"%lu msecs\", (unsigned long)time_diff);\n-\t    GC_printf1(\"(attempt %d)\\n\", (unsigned long) GC_n_attempts);\n+\t    GC_printf1(\"(attempt %ld)\\n\", (unsigned long) GC_n_attempts);\n \t  }\n #\tendif\n     \treturn(1);\n@@ -228,10 +228,15 @@ void GC_clear_a_few_frames()\n     for (i = 0; i < NWORDS; i++) frames[i] = 0;\n }\n \n+/* Heap size at which we need a collection to avoid expanding past\t*/\n+/* limits used by blacklisting.\t\t\t\t\t\t*/\n+static word GC_collect_at_heapsize = (word)(-1);\n+\n /* Have we allocated enough to amortize a collection? */\n GC_bool GC_should_collect()\n {\n-    return(GC_adj_words_allocd() >= min_words_allocd());\n+    return(GC_adj_words_allocd() >= min_words_allocd()\n+\t   || GC_heapsize >= GC_collect_at_heapsize);\n }\n \n \n@@ -924,25 +929,37 @@ word n;\n #\tendif\n       }\n #   endif\n-    expansion_slop = 8 * WORDS_TO_BYTES(min_words_allocd());\n-    if (5 * HBLKSIZE * MAXHINCR > expansion_slop) {\n-        expansion_slop = 5 * HBLKSIZE * MAXHINCR;\n-    }\n+    expansion_slop = WORDS_TO_BYTES(min_words_allocd()) + 4*MAXHINCR*HBLKSIZE;\n     if (GC_last_heap_addr == 0 && !((word)space & SIGNB)\n         || GC_last_heap_addr != 0 && GC_last_heap_addr < (ptr_t)space) {\n         /* Assume the heap is growing up */\n         GC_greatest_plausible_heap_addr =\n-            GC_max(GC_greatest_plausible_heap_addr,\n-                   (ptr_t)space + bytes + expansion_slop);\n+            (GC_PTR)GC_max((ptr_t)GC_greatest_plausible_heap_addr,\n+                           (ptr_t)space + bytes + expansion_slop);\n     } else {\n         /* Heap is growing down */\n         GC_least_plausible_heap_addr =\n-            GC_min(GC_least_plausible_heap_addr,\n-                   (ptr_t)space - expansion_slop);\n+            (GC_PTR)GC_min((ptr_t)GC_least_plausible_heap_addr,\n+                           (ptr_t)space - expansion_slop);\n     }\n+#   if defined(LARGE_CONFIG)\n+      if (((ptr_t)GC_greatest_plausible_heap_addr <= (ptr_t)space + bytes\n+           || (ptr_t)GC_least_plausible_heap_addr >= (ptr_t)space)\n+\t  && GC_heapsize > 0) {\n+\t/* GC_add_to_heap will fix this, but ... */\n+\tWARN(\"Too close to address space limit: blacklisting ineffective\\n\", 0);\n+      }\n+#   endif\n     GC_prev_heap_addr = GC_last_heap_addr;\n     GC_last_heap_addr = (ptr_t)space;\n     GC_add_to_heap(space, bytes);\n+    /* Force GC before we are likely to allocate past expansion_slop */\n+      GC_collect_at_heapsize =\n+\t  GC_heapsize + expansion_slop - 2*MAXHINCR*HBLKSIZE;\n+#     if defined(LARGE_CONFIG)\n+        if (GC_collect_at_heapsize < GC_heapsize /* wrapped */)\n+\t  GC_collect_at_heapsize = (word)(-1);\n+#     endif\n     return(TRUE);\n }\n "}, {"sha": "57a6ebc2160f5ad4a9c726c8a9ccf0eb17cc9af0", "filename": "boehm-gc/checksums.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fchecksums.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fchecksums.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fchecksums.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -13,14 +13,14 @@\n /* Boehm, March 29, 1995 12:51 pm PST */\n # ifdef CHECKSUMS\n \n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n /* This is debugging code intended to verify the results of dirty bit\t*/\n /* computations. Works only in a single threaded environment.\t\t*/\n /* We assume that stubborn objects are changed only when they are \t*/\n /* enabled for writing.  (Certain kinds of writing are actually\t\t*/\n /* safe under other conditions.)\t\t\t\t\t*/\n-# define NSUMS 2000\n+# define NSUMS 10000\n \n # define OFFSET 0x10000\n \n@@ -29,7 +29,7 @@ typedef struct {\n \tword old_sum;\n \tword new_sum;\n \tstruct hblk * block;\t/* Block to which this refers + OFFSET  */\n-\t\t\t\t/* to hide it from colector.\t\t*/\n+\t\t\t\t/* to hide it from collector.\t\t*/\n } page_entry;\n \n page_entry GC_sums [NSUMS];\n@@ -76,12 +76,13 @@ int index;\n {\n     page_entry *pe = GC_sums + index;\n     register hdr * hhdr = HDR(h);\n+    struct hblk *b;\n     \n     if (pe -> block != 0 && pe -> block != h + OFFSET) ABORT(\"goofed\");\n     pe -> old_sum = pe -> new_sum;\n     pe -> new_sum = GC_checksum(h);\n #   if !defined(MSWIN32) && !defined(MSWINCE)\n-        if (pe -> new_sum != 0 && !GC_page_was_ever_dirty(h)) {\n+        if (pe -> new_sum != 0x80000000 && !GC_page_was_ever_dirty(h)) {\n             GC_printf1(\"GC_page_was_ever_dirty(0x%lx) is wrong\\n\",\n         \t       (unsigned long)h);\n         }\n@@ -91,13 +92,19 @@ int index;\n     } else {\n     \tGC_n_clean++;\n     }\n-    if (pe -> new_valid && pe -> old_sum != pe -> new_sum) {\n+    b = h;\n+    while (IS_FORWARDING_ADDR_OR_NIL(hhdr) && hhdr != 0) {\n+\tb -= (word)hhdr;\n+\thhdr = HDR(b);\n+    }\n+    if (pe -> new_valid\n+\t&& hhdr != 0 && hhdr -> hb_descr != 0 /* may contain pointers */\n+\t&& pe -> old_sum != pe -> new_sum) {\n     \tif (!GC_page_was_dirty(h) || !GC_page_was_ever_dirty(h)) {\n     \t    /* Set breakpoint here */GC_n_dirty_errors++;\n     \t}\n #\tifdef STUBBORN_ALLOC\n-    \t  if (!IS_FORWARDING_ADDR_OR_NIL(hhdr)\n-    \t    && hhdr -> hb_map != GC_invalid_map\n+    \t  if ( hhdr -> hb_map != GC_invalid_map\n     \t    && hhdr -> hb_obj_kind == STUBBORN\n     \t    && !GC_page_was_changed(h)\n     \t    && !GC_on_free_list(h)) {\n@@ -120,26 +127,17 @@ word dummy;\n    register hdr * hhdr = HDR(h);\n    register bytes = WORDS_TO_BYTES(hhdr -> hb_sz);\n    \n-   bytes += HDR_BYTES + HBLKSIZE-1;\n+   bytes += HBLKSIZE-1;\n    bytes &= ~(HBLKSIZE-1);\n    GC_bytes_in_used_blocks += bytes;\n }\n \n void GC_check_blocks()\n {\n-    word bytes_in_free_blocks = 0;\n-    struct hblk * h = GC_hblkfreelist;\n-    hdr * hhdr = HDR(h);\n-    word sz;\n+    word bytes_in_free_blocks = GC_large_free_bytes;\n     \n     GC_bytes_in_used_blocks = 0;\n     GC_apply_to_all_blocks(GC_add_block, (word)0);\n-    while (h != 0) {\n-        sz = hhdr -> hb_sz;\n-        bytes_in_free_blocks += sz;\n-        h = hhdr -> hb_next;\n-        hhdr = HDR(h);\n-    }\n     GC_printf2(\"GC_bytes_in_used_blocks = %ld, bytes_in_free_blocks = %ld \",\n     \t\tGC_bytes_in_used_blocks, bytes_in_free_blocks);\n     GC_printf1(\"GC_heapsize = %ld\\n\", GC_heapsize);"}, {"sha": "d2de790149c1503e85a05c855040176498acf0bf", "filename": "boehm-gc/configure", "status": "modified", "additions": 331, "deletions": 93, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -309,7 +309,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os mkinstalldirs INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE CFLAGS CXXFLAGS CCAS CCASFLAGS AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT GC_CFLAGS LN_S LIBTOOL CXXCPP CPPFLAGS THREADLIBS POWERPC_DARWIN_TRUE POWERPC_DARWIN_FALSE EXTRA_TEST_LIBS target_all target_noncanonical CPLUSPLUS_TRUE CPLUSPLUS_FALSE AM_CPPFLAGS addobjs addincludes addlibs addtests CPP EGREP MY_CFLAGS toolexecdir toolexeclibdir LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS multi_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os mkinstalldirs INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXX ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE CFLAGS CXXFLAGS CCAS CCASFLAGS AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT GC_CFLAGS LN_S LIBTOOL CXXCPP CPPFLAGS THREADLIBS POWERPC_DARWIN_TRUE POWERPC_DARWIN_FALSE EXTRA_TEST_LIBS target_all target_noncanonical CPLUSPLUS_TRUE CPLUSPLUS_FALSE AM_CPPFLAGS addobjs addincludes addlibs addtests CPP EGREP MY_CFLAGS toolexecdir toolexeclibdir LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -967,7 +967,7 @@ esac\n     else\n       echo \"$as_me: WARNING: no configuration information is in $ac_dir\" >&2\n     fi\n-    cd \"$ac_popdir\"\n+    cd $ac_popdir\n   done\n fi\n \n@@ -1483,7 +1483,7 @@ esac\n mkinstalldirs=\"`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs\"\n \n \n-am__api_version=\"1.8\"\n+am__api_version=\"1.9\"\n # Find a good install program.  We prefer a C program (faster),\n # so one script is as good as another.  But avoid the broken or\n # incompatible versions:\n@@ -1635,13 +1635,21 @@ echo \"$as_me: WARNING: \\`missing' script is too old or missing\" >&2;}\n fi\n \n if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then\n-  # Keeping the `.' argument allows $(mkdir_p) to be used without\n-  # argument.  Indeed, we sometimes output rules like\n+  # We used to keeping the `.' as first argument, in order to\n+  # allow $(mkdir_p) to be used without argument.  As in\n   #   $(mkdir_p) $(somedir)\n-  # where $(somedir) is conditionally defined.\n-  # (`test -n '$(somedir)' && $(mkdir_p) $(somedir)' is a more\n-  # expensive solution, as it forces Make to start a sub-shell.)\n-  mkdir_p='mkdir -p -- .'\n+  # where $(somedir) is conditionally defined.  However this is wrong\n+  # for two reasons:\n+  #  1. if the package is installed by a user who cannot write `.'\n+  #     make install will fail,\n+  #  2. the above comment should most certainly read\n+  #     $(mkdir_p) $(DESTDIR)$(somedir)\n+  #     so it does not work when $(somedir) is undefined and\n+  #     $(DESTDIR) is not.\n+  #  To support the latter case, we have to write\n+  #     test -z \"$(somedir)\" || $(mkdir_p) $(DESTDIR)$(somedir),\n+  #  so the `.' trick is pointless.\n+  mkdir_p='mkdir -p --'\n else\n   # On NextStep and OpenStep, the `mkdir' command does not\n   # recognize any option.  It will interpret all options as\n@@ -1757,7 +1765,7 @@ fi\n \n # Define the identity of the package.\n  PACKAGE=gc\n- VERSION=6.1a1\n+ VERSION=6.3\n \n \n # Some tools Automake needs.\n@@ -1776,9 +1784,6 @@ AUTOHEADER=${AUTOHEADER-\"${am_missing_run}autoheader\"}\n \n MAKEINFO=${MAKEINFO-\"${am_missing_run}makeinfo\"}\n \n-\n-AMTAR=${AMTAR-\"${am_missing_run}tar\"}\n-\n install_sh=${install_sh-\"$am_aux_dir/install-sh\"}\n \n # Installed binaries are usually stripped using `strip' when the user\n@@ -1871,6 +1876,13 @@ INSTALL_STRIP_PROGRAM=\"\\${SHELL} \\$(install_sh) -c -s\"\n \n # We need awk for the \"check\" target.  The system \"awk\" is bad on\n # some platforms.\n+# Always define AMTAR for backward compatibility.\n+\n+AMTAR=${AMTAR-\"${am_missing_run}tar\"}\n+\n+am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'\n+\n+\n \n \n \n@@ -2508,7 +2520,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2566,7 +2579,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2682,7 +2696,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2736,7 +2751,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2781,7 +2797,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -2825,7 +2842,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3183,7 +3201,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_cxx_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_cxx_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3241,7 +3260,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_cxx_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_cxx_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3312,7 +3332,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_cxx_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_cxx_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3356,7 +3377,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_cxx_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_cxx_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -3964,7 +3986,7 @@ case ${gc_basedir} in\n *) gc_flagbasedir='$(top_builddir)/'${gc_basedir} ;;\n esac\n \n-gc_cflags=\"${gc_cflags} -I\"'$(top_builddir)'\"/./targ-include -I${gc_flagbasedir}/libc/include\"\n+gc_cflags=\"${gc_cflags} -Iinclude -I\"'$(top_builddir)'\"/./targ-include -I${gc_flagbasedir}/libc/include\"\n case \"${host}\" in\n   *-*-cygwin32*)\n     gc_cflags=\"${gc_cflags} -I${gc_flagbasedir}/../winsup/include\"\n@@ -4717,7 +4739,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 4720 \"configure\"' > conftest.$ac_ext\n+  echo '#line 4742 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -4864,7 +4886,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -5562,7 +5585,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -6061,7 +6085,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -6231,7 +6256,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -6294,7 +6320,8 @@ if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   cat conftest.err >&5\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n   (exit $ac_status); } &&\n-\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n   { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n@@ -6566,7 +6593,8 @@ else\n   multilib_arg=\n fi\n \n-          ac_config_commands=\"$ac_config_commands boehm-cflags\"\n+          ac_config_headers=\"$ac_config_headers include/gc_config.h\"\n+\n \n                     ac_config_files=\"$ac_config_files Makefile include/Makefile\"\n \n@@ -6644,38 +6672,7 @@ s/^[^=]*=[\t ]*$//;\n }'\n fi\n \n-# Transform confdefs.h into DEFS.\n-# Protect against shell expansion while executing Makefile rules.\n-# Protect against Makefile macro expansion.\n-#\n-# If the first sed substitution is executed (which looks for macros that\n-# take arguments), then we branch to the quote section.  Otherwise,\n-# look for a macro that doesn't take arguments.\n-cat >confdef2opt.sed <<\\_ACEOF\n-t clear\n-: clear\n-s,^[\t ]*#[\t ]*define[\t ][\t ]*\\([^\t (][^\t (]*([^)]*)\\)[\t ]*\\(.*\\),-D\\1=\\2,g\n-t quote\n-s,^[\t ]*#[\t ]*define[\t ][\t ]*\\([^\t ][^\t ]*\\)[\t ]*\\(.*\\),-D\\1=\\2,g\n-t quote\n-d\n-: quote\n-s,[\t `~#$^&*(){}\\\\|;'\"<>?],\\\\&,g\n-s,\\[,\\\\&,g\n-s,\\],\\\\&,g\n-s,\\$,$$,g\n-p\n-_ACEOF\n-# We use echo to avoid assuming a particular line-breaking character.\n-# The extra dot is to prevent the shell from consuming trailing\n-# line-breaks from the sub-command output.  A line-break within\n-# single-quotes doesn't work because, if this script is created in a\n-# platform that uses two characters for line-breaks (e.g., DOS), tr\n-# would break.\n-ac_LF_and_DOT=`echo; echo .`\n-DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr \"$ac_LF_and_DOT\" ' .'`\n-rm -f confdef2opt.sed\n-\n+DEFS=-DHAVE_CONFIG_H\n \n ac_libobjs=\n ac_ltlibobjs=\n@@ -7051,10 +7048,15 @@ Usage: $0 [OPTIONS] [FILE]...\n       --recheck    update $as_me by reconfiguring in the same conditions\n   --file=FILE[:TEMPLATE]\n \t\t   instantiate the configuration file FILE\n+  --header=FILE[:TEMPLATE]\n+\t\t   instantiate the configuration header FILE\n \n Configuration files:\n $config_files\n \n+Configuration headers:\n+$config_headers\n+\n Configuration commands:\n $config_commands\n \n@@ -7175,9 +7177,6 @@ CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n CC=\"$CC\"\n AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"\n \n-DEFS=\"$DEFS\"\n-AM_CPPFLAGS=\"$AM_CPPFLAGS\"\n-\n _ACEOF\n \n \n@@ -7191,7 +7190,7 @@ do\n   \"include/Makefile\" ) CONFIG_FILES=\"$CONFIG_FILES include/Makefile\" ;;\n   \"default-1\" ) CONFIG_COMMANDS=\"$CONFIG_COMMANDS default-1\" ;;\n   \"depfiles\" ) CONFIG_COMMANDS=\"$CONFIG_COMMANDS depfiles\" ;;\n-  \"boehm-cflags\" ) CONFIG_COMMANDS=\"$CONFIG_COMMANDS boehm-cflags\" ;;\n+  \"include/gc_config.h\" ) CONFIG_HEADERS=\"$CONFIG_HEADERS include/gc_config.h\" ;;\n   *) { { echo \"$as_me:$LINENO: error: invalid argument: $ac_config_target\" >&5\n echo \"$as_me: error: invalid argument: $ac_config_target\" >&2;}\n    { (exit 1); exit 1; }; };;\n@@ -7204,6 +7203,7 @@ done\n # bizarre bug on SunOS 4.1.3.\n if $ac_need_defaults; then\n   test \"${CONFIG_FILES+set}\" = set || CONFIG_FILES=$config_files\n+  test \"${CONFIG_HEADERS+set}\" = set || CONFIG_HEADERS=$config_headers\n   test \"${CONFIG_COMMANDS+set}\" = set || CONFIG_COMMANDS=$config_commands\n fi\n \n@@ -7301,7 +7301,6 @@ s,@AUTOCONF@,$AUTOCONF,;t t\n s,@AUTOMAKE@,$AUTOMAKE,;t t\n s,@AUTOHEADER@,$AUTOHEADER,;t t\n s,@MAKEINFO@,$MAKEINFO,;t t\n-s,@AMTAR@,$AMTAR,;t t\n s,@install_sh@,$install_sh,;t t\n s,@STRIP@,$STRIP,;t t\n s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t\n@@ -7310,6 +7309,9 @@ s,@mkdir_p@,$mkdir_p,;t t\n s,@AWK@,$AWK,;t t\n s,@SET_MAKE@,$SET_MAKE,;t t\n s,@am__leading_dot@,$am__leading_dot,;t t\n+s,@AMTAR@,$AMTAR,;t t\n+s,@am__tar@,$am__tar,;t t\n+s,@am__untar@,$am__untar,;t t\n s,@CC@,$CC,;t t\n s,@ac_ct_CC@,$ac_ct_CC,;t t\n s,@EXEEXT@,$EXEEXT,;t t\n@@ -7532,6 +7534,11 @@ esac\n   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;\n   esac\n \n+  if test x\"$ac_file\" != x-; then\n+    { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n+echo \"$as_me: creating $ac_file\" >&6;}\n+    rm -f \"$ac_file\"\n+  fi\n   # Let's still pretend it is `configure' which instantiates (i.e., don't\n   # use $as_me), people would be surprised to read:\n   #    /* config.h.  Generated by config.status.  */\n@@ -7570,12 +7577,6 @@ echo \"$as_me: error: cannot find input file: $f\" >&2;}\n \t fi;;\n       esac\n     done` || { (exit 1); exit 1; }\n-\n-  if test x\"$ac_file\" != x-; then\n-    { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n-echo \"$as_me: creating $ac_file\" >&6;}\n-    rm -f \"$ac_file\"\n-  fi\n _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF\n   sed \"$ac_vpsub\n@@ -7607,6 +7608,251 @@ done\n _ACEOF\n cat >>$CONFIG_STATUS <<\\_ACEOF\n \n+#\n+# CONFIG_HEADER section.\n+#\n+\n+# These sed commands are passed to sed as \"A NAME B NAME C VALUE D\", where\n+# NAME is the cpp macro being defined and VALUE is the value it is being given.\n+#\n+# ac_d sets the value in \"#define NAME VALUE\" lines.\n+ac_dA='s,^\\([\t ]*\\)#\\([\t ]*define[\t ][\t ]*\\)'\n+ac_dB='[\t ].*$,\\1#\\2'\n+ac_dC=' '\n+ac_dD=',;t'\n+# ac_u turns \"#undef NAME\" without trailing blanks into \"#define NAME VALUE\".\n+ac_uA='s,^\\([\t ]*\\)#\\([\t ]*\\)undef\\([\t ][\t ]*\\)'\n+ac_uB='$,\\1#\\2define\\3'\n+ac_uC=' '\n+ac_uD=',;t'\n+\n+for ac_file in : $CONFIG_HEADERS; do test \"x$ac_file\" = x: && continue\n+  # Support \"outfile[:infile[:infile...]]\", defaulting infile=\"outfile.in\".\n+  case $ac_file in\n+  - | *:- | *:-:* ) # input from stdin\n+\tcat >$tmp/stdin\n+\tac_file_in=`echo \"$ac_file\" | sed 's,[^:]*:,,'`\n+\tac_file=`echo \"$ac_file\" | sed 's,:.*,,'` ;;\n+  *:* ) ac_file_in=`echo \"$ac_file\" | sed 's,[^:]*:,,'`\n+\tac_file=`echo \"$ac_file\" | sed 's,:.*,,'` ;;\n+  * )   ac_file_in=$ac_file.in ;;\n+  esac\n+\n+  test x\"$ac_file\" != x- && { echo \"$as_me:$LINENO: creating $ac_file\" >&5\n+echo \"$as_me: creating $ac_file\" >&6;}\n+\n+  # First look for the input files in the build tree, otherwise in the\n+  # src tree.\n+  ac_file_inputs=`IFS=:\n+    for f in $ac_file_in; do\n+      case $f in\n+      -) echo $tmp/stdin ;;\n+      [\\\\/$]*)\n+\t # Absolute (can't be DOS-style, as IFS=:)\n+\t test -f \"$f\" || { { echo \"$as_me:$LINENO: error: cannot find input file: $f\" >&5\n+echo \"$as_me: error: cannot find input file: $f\" >&2;}\n+   { (exit 1); exit 1; }; }\n+\t # Do quote $f, to prevent DOS paths from being IFS'd.\n+\t echo \"$f\";;\n+      *) # Relative\n+\t if test -f \"$f\"; then\n+\t   # Build tree\n+\t   echo \"$f\"\n+\t elif test -f \"$srcdir/$f\"; then\n+\t   # Source tree\n+\t   echo \"$srcdir/$f\"\n+\t else\n+\t   # /dev/null tree\n+\t   { { echo \"$as_me:$LINENO: error: cannot find input file: $f\" >&5\n+echo \"$as_me: error: cannot find input file: $f\" >&2;}\n+   { (exit 1); exit 1; }; }\n+\t fi;;\n+      esac\n+    done` || { (exit 1); exit 1; }\n+  # Remove the trailing spaces.\n+  sed 's/[\t ]*$//' $ac_file_inputs >$tmp/in\n+\n+_ACEOF\n+\n+# Transform confdefs.h into two sed scripts, `conftest.defines' and\n+# `conftest.undefs', that substitutes the proper values into\n+# config.h.in to produce config.h.  The first handles `#define'\n+# templates, and the second `#undef' templates.\n+# And first: Protect against being on the right side of a sed subst in\n+# config.status.  Protect against being in an unquoted here document\n+# in config.status.\n+rm -f conftest.defines conftest.undefs\n+# Using a here document instead of a string reduces the quoting nightmare.\n+# Putting comments in sed scripts is not portable.\n+#\n+# `end' is used to avoid that the second main sed command (meant for\n+# 0-ary CPP macros) applies to n-ary macro definitions.\n+# See the Autoconf documentation for `clear'.\n+cat >confdef2sed.sed <<\\_ACEOF\n+s/[\\\\&,]/\\\\&/g\n+s,[\\\\$`],\\\\&,g\n+t clear\n+: clear\n+s,^[\t ]*#[\t ]*define[\t ][\t ]*\\([^\t (][^\t (]*\\)\\(([^)]*)\\)[\t ]*\\(.*\\)$,${ac_dA}\\1${ac_dB}\\1\\2${ac_dC}\\3${ac_dD},gp\n+t end\n+s,^[\t ]*#[\t ]*define[\t ][\t ]*\\([^\t ][^\t ]*\\)[\t ]*\\(.*\\)$,${ac_dA}\\1${ac_dB}\\1${ac_dC}\\2${ac_dD},gp\n+: end\n+_ACEOF\n+# If some macros were called several times there might be several times\n+# the same #defines, which is useless.  Nevertheless, we may not want to\n+# sort them, since we want the *last* AC-DEFINE to be honored.\n+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines\n+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs\n+rm -f confdef2sed.sed\n+\n+# This sed command replaces #undef with comments.  This is necessary, for\n+# example, in the case of _POSIX_SOURCE, which is predefined and required\n+# on some systems where configure will not decide to define it.\n+cat >>conftest.undefs <<\\_ACEOF\n+s,^[\t ]*#[\t ]*undef[\t ][\t ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,\n+_ACEOF\n+\n+# Break up conftest.defines because some shells have a limit on the size\n+# of here documents, and old seds have small limits too (100 cmds).\n+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS\n+echo '  if grep \"^[\t ]*#[\t ]*define\" $tmp/in >/dev/null; then' >>$CONFIG_STATUS\n+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS\n+echo '  :' >>$CONFIG_STATUS\n+rm -f conftest.tail\n+while grep . conftest.defines >/dev/null\n+do\n+  # Write a limited-size here document to $tmp/defines.sed.\n+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS\n+  # Speed up: don't consider the non `#define' lines.\n+  echo '/^[\t ]*#[\t ]*define/!b' >>$CONFIG_STATUS\n+  # Work around the forget-to-reset-the-flag bug.\n+  echo 't clr' >>$CONFIG_STATUS\n+  echo ': clr' >>$CONFIG_STATUS\n+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS\n+  echo 'CEOF\n+  sed -f $tmp/defines.sed $tmp/in >$tmp/out\n+  rm -f $tmp/in\n+  mv $tmp/out $tmp/in\n+' >>$CONFIG_STATUS\n+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail\n+  rm -f conftest.defines\n+  mv conftest.tail conftest.defines\n+done\n+rm -f conftest.defines\n+echo '  fi # grep' >>$CONFIG_STATUS\n+echo >>$CONFIG_STATUS\n+\n+# Break up conftest.undefs because some shells have a limit on the size\n+# of here documents, and old seds have small limits too (100 cmds).\n+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS\n+rm -f conftest.tail\n+while grep . conftest.undefs >/dev/null\n+do\n+  # Write a limited-size here document to $tmp/undefs.sed.\n+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS\n+  # Speed up: don't consider the non `#undef'\n+  echo '/^[\t ]*#[\t ]*undef/!b' >>$CONFIG_STATUS\n+  # Work around the forget-to-reset-the-flag bug.\n+  echo 't clr' >>$CONFIG_STATUS\n+  echo ': clr' >>$CONFIG_STATUS\n+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS\n+  echo 'CEOF\n+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out\n+  rm -f $tmp/in\n+  mv $tmp/out $tmp/in\n+' >>$CONFIG_STATUS\n+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail\n+  rm -f conftest.undefs\n+  mv conftest.tail conftest.undefs\n+done\n+rm -f conftest.undefs\n+\n+cat >>$CONFIG_STATUS <<\\_ACEOF\n+  # Let's still pretend it is `configure' which instantiates (i.e., don't\n+  # use $as_me), people would be surprised to read:\n+  #    /* config.h.  Generated by config.status.  */\n+  if test x\"$ac_file\" = x-; then\n+    echo \"/* Generated by configure.  */\" >$tmp/config.h\n+  else\n+    echo \"/* $ac_file.  Generated by configure.  */\" >$tmp/config.h\n+  fi\n+  cat $tmp/in >>$tmp/config.h\n+  rm -f $tmp/in\n+  if test x\"$ac_file\" != x-; then\n+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then\n+      { echo \"$as_me:$LINENO: $ac_file is unchanged\" >&5\n+echo \"$as_me: $ac_file is unchanged\" >&6;}\n+    else\n+      ac_dir=`(dirname \"$ac_file\") 2>/dev/null ||\n+$as_expr X\"$ac_file\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t X\"$ac_file\" : 'X\\(//\\)[^/]' \\| \\\n+\t X\"$ac_file\" : 'X\\(//\\)$' \\| \\\n+\t X\"$ac_file\" : 'X\\(/\\)' \\| \\\n+\t .     : '\\(.\\)' 2>/dev/null ||\n+echo X\"$ac_file\" |\n+    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\/\\)[^/].*/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\/\\)$/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\).*/{ s//\\1/; q; }\n+  \t  s/.*/./; q'`\n+      { if $as_mkdir_p; then\n+    mkdir -p \"$ac_dir\"\n+  else\n+    as_dir=\"$ac_dir\"\n+    as_dirs=\n+    while test ! -d \"$as_dir\"; do\n+      as_dirs=\"$as_dir $as_dirs\"\n+      as_dir=`(dirname \"$as_dir\") 2>/dev/null ||\n+$as_expr X\"$as_dir\" : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t X\"$as_dir\" : 'X\\(//\\)[^/]' \\| \\\n+\t X\"$as_dir\" : 'X\\(//\\)$' \\| \\\n+\t X\"$as_dir\" : 'X\\(/\\)' \\| \\\n+\t .     : '\\(.\\)' 2>/dev/null ||\n+echo X\"$as_dir\" |\n+    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\/\\)[^/].*/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\/\\)$/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\).*/{ s//\\1/; q; }\n+  \t  s/.*/./; q'`\n+    done\n+    test ! -n \"$as_dirs\" || mkdir $as_dirs\n+  fi || { { echo \"$as_me:$LINENO: error: cannot create directory \\\"$ac_dir\\\"\" >&5\n+echo \"$as_me: error: cannot create directory \\\"$ac_dir\\\"\" >&2;}\n+   { (exit 1); exit 1; }; }; }\n+\n+      rm -f $ac_file\n+      mv $tmp/config.h $ac_file\n+    fi\n+  else\n+    cat $tmp/config.h\n+    rm -f $tmp/config.h\n+  fi\n+# Compute $ac_file's index in $config_headers.\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $ac_file | $ac_file:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $ac_file\" >`(dirname $ac_file) 2>/dev/null ||\n+$as_expr X$ac_file : 'X\\(.*[^/]\\)//*[^/][^/]*/*$' \\| \\\n+\t X$ac_file : 'X\\(//\\)[^/]' \\| \\\n+\t X$ac_file : 'X\\(//\\)$' \\| \\\n+\t X$ac_file : 'X\\(/\\)' \\| \\\n+\t .     : '\\(.\\)' 2>/dev/null ||\n+echo X$ac_file |\n+    sed '/^X\\(.*[^/]\\)\\/\\/*[^/][^/]*\\/*$/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\/\\)[^/].*/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\/\\)$/{ s//\\1/; q; }\n+  \t  /^X\\(\\/\\).*/{ s//\\1/; q; }\n+  \t  s/.*/./; q'`/stamp-h$_am_stamp_count\n+done\n+_ACEOF\n+cat >>$CONFIG_STATUS <<\\_ACEOF\n+\n #\n # CONFIG_COMMANDS section.\n #\n@@ -7752,27 +7998,21 @@ echo X\"$mf\" |\n   else\n     continue\n   fi\n-  grep '^DEP_FILES *= *[^ #]' < \"$mf\" > /dev/null || continue\n-  # Extract the definition of DEP_FILES from the Makefile without\n-  # running `make'.\n+  # Extract the definition of DEPDIR, am__include, and am__quote\n+  # from the Makefile without running `make'.\n   DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n   test -z \"$DEPDIR\" && continue\n+  am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+  test -z \"am__include\" && continue\n+  am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n   # When using ansi2knr, U may be empty or an underscore; expand it\n   U=`sed -n 's/^U = //p' < \"$mf\"`\n-  test -d \"$dirpart/$DEPDIR\" || mkdir \"$dirpart/$DEPDIR\"\n-  # We invoke sed twice because it is the simplest approach to\n-  # changing $(DEPDIR) to its actual value in the expansion.\n-  for file in `sed -n '\n-    /^DEP_FILES = .*\\\\\\\\$/ {\n-      s/^DEP_FILES = //\n-      :loop\n-\ts/\\\\\\\\$//\n-\tp\n-\tn\n-\t/\\\\\\\\$/ b loop\n-      p\n-    }\n-    /^DEP_FILES = / s/^DEP_FILES = //p' < \"$mf\" | \\\n+  # Find all dependency output files, they are included files with\n+  # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+  # simplest approach to changing $(DEPDIR) to its actual value in the\n+  # expansion.\n+  for file in `sed -n \"\n+    s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n        sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n     # Make sure the directory exists.\n     test -f \"$dirpart/$file\" && continue\n@@ -7818,8 +8058,6 @@ echo \"$as_me: error: cannot create directory $dirpart/$fdir\" >&2;}\n   done\n done\n  ;;\n-    boehm-cflags )\n-echo \"$AM_CPPFLAGS $DEFS\" > boehm-cflags ;;\n   esac\n done\n _ACEOF"}, {"sha": "0137ff6519fec97a0538dc12e3be9bf81d91116b", "filename": "boehm-gc/configure.ac", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.ac?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -37,7 +37,7 @@ _GCC_TOPLEV_NONCANONICAL_TARGET\n mkinstalldirs=\"`cd $ac_aux_dir && ${PWDCMD-pwd}`/mkinstalldirs\"\n AC_SUBST(mkinstalldirs)\n \n-AM_INIT_AUTOMAKE(gc, 6.1a1, no-define)\n+AM_INIT_AUTOMAKE(gc, 6.3, no-define)\n \n # The autoconf 2.5x version of the no-executables hack.\n sinclude(../config/no-executables.m4)\n@@ -79,7 +79,7 @@ case [$]{gc_basedir} in\n *) gc_flagbasedir='[$](top_builddir)/'[$]{gc_basedir} ;;\n esac\n \n-gc_cflags=\"[$]{gc_cflags} -I\"'[$](top_builddir)'\"/./targ-include -I[$]{gc_flagbasedir}/libc/include\"\n+gc_cflags=\"[$]{gc_cflags} -Iinclude -I\"'[$](top_builddir)'\"/./targ-include -I[$]{gc_flagbasedir}/libc/include\"\n case \"${host}\" in\n   *-*-cygwin32*)\n     gc_cflags=\"[$]{gc_cflags} -I[$]{gc_flagbasedir}/../winsup/include\"\n@@ -480,10 +480,7 @@ else\n   multilib_arg=\n fi\n \n-AC_CONFIG_COMMANDS(boehm-cflags, [\n-dnl Put all the -I and -D options in a file.\n-echo \"$AM_CPPFLAGS $DEFS\" > boehm-cflags], [\n-DEFS=\"$DEFS\"\n-AM_CPPFLAGS=\"$AM_CPPFLAGS\"])\n+AC_CONFIG_HEADERS([include/gc_config.h])\n+\n AC_CONFIG_FILES(Makefile include/Makefile)\n AC_OUTPUT"}, {"sha": "ad937b02d4e49a1d1c4beebb4d512633b16ffebf", "filename": "boehm-gc/cord/cordprnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fcordprnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fcordprnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordprnt.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -261,7 +261,7 @@ int CORD_vsprintf(CORD * out, CORD format, va_list args)\n #\t\t    ifdef __va_copy\n                       __va_copy(vsprintf_args, args);\n #\t\t    else\n-#\t\t      if defined(__GNUC__) /* and probably in other cases */\n+#\t\t      if defined(__GNUC__) && !defined(__DJGPP__) /* and probably in other cases */\n                         va_copy(vsprintf_args, args);\n #\t\t      else\n \t\t\tvsprintf_args = args;"}, {"sha": "8f4836a233367cbc3a50d1003fd061345f3954ac", "filename": "boehm-gc/cord/cordtest.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fcordtest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fcordtest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordtest.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -11,6 +11,7 @@\n  * modified is included with the above copyright notice.\n  */\n /* Boehm, August 24, 1994 11:58 am PDT */\n+# include \"gc.h\"\t/* For GC_INIT() only */\n # include \"cord.h\"\n # include <string.h>\n # include <stdio.h>\n@@ -116,7 +117,7 @@ void test_basics()\n \n void test_extras()\n {\n-#   if defined(__OS2__)\n+#   if defined(__OS2__) || defined(__DJGPP__)\n #\tdefine FNAME1 \"tmp1\"\n #\tdefine FNAME2 \"tmp2\"\n #   elif defined(AMIGA)\n@@ -162,6 +163,10 @@ void test_extras()\n         x = CORD_cat(x,x);\n     }\n     if ((f = fopen(FNAME2, \"w\")) == 0) ABORT(\"2nd open failed\");\n+#   ifdef __DJGPP__\n+      /* FIXME: DJGPP workaround.  Why does this help? */\n+      if (fflush(f) != 0) ABORT(\"fflush failed\");\n+#   endif\n     if (CORD_put(x,f) == EOF) ABORT(\"CORD_put failed\");\n     if (fclose(f) == EOF) ABORT(\"fclose failed\");\n     w = CORD_from_file(f2 = fopen(FNAME2, \"rb\"));\n@@ -221,6 +226,7 @@ main()\n #   ifdef THINK_C\n         printf(\"cordtest:\\n\");\n #   endif\n+    GC_INIT();\n     test_basics();\n     test_extras();\n     test_printf();"}, {"sha": "b0a746226cb6ed87ca77866f98f3ead7b34a2109", "filename": "boehm-gc/cord/cordxtra.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fcordxtra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fcordxtra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcordxtra.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -385,9 +385,9 @@ size_t CORD_str(CORD x, size_t start, CORD s)\n         mask <<= 8;\n         mask |= 0xff;\n         s_buf <<= 8;\n-        s_buf |= s_start[i];\n+        s_buf |= (unsigned char)s_start[i];\n         x_buf <<= 8;\n-        x_buf |= CORD_pos_fetch(xpos);\n+        x_buf |= (unsigned char)CORD_pos_fetch(xpos);\n         CORD_next(xpos);\n     }\n     for (match_pos = start; ; match_pos++) {\n@@ -402,7 +402,7 @@ size_t CORD_str(CORD x, size_t start, CORD s)\n \t    return(CORD_NOT_FOUND);\n \t}\n     \tx_buf <<= 8;\n-        x_buf |= CORD_pos_fetch(xpos);\n+        x_buf |= (unsigned char)CORD_pos_fetch(xpos);\n         CORD_next(xpos);\n     }\n }"}, {"sha": "989e19a8881c0801699d2b9d2ecad1ef49151d53", "filename": "boehm-gc/cord/de.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fcord%2Fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fde.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -569,9 +569,9 @@ char ** argv;\n #if defined(MACINTOSH)\n \tconsole_options.title = \"\\pDumb Editor\";\n \tcshow(stdout);\n-\tGC_init();\n \targc = ccommand(&argv);\n #endif\n+    GC_INIT();\n     \n     if (argc != 2) goto usage;\n     arg_file_name = argv[1];"}, {"sha": "aacbb7a1b632e091c6a7cd97f89b587aa2bd83a6", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 85, "deletions": 13, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -2,7 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999-2000 by Hewlett-Packard Company.  All rights reserved.\n+ * Copyright (c) 1999-2004 Hewlett-Packard Development Company, L.P.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -195,13 +195,13 @@ ptr_t p;\n \t\t (unsigned long)i);\n       switch(source) {\n \tcase GC_REFD_FROM_ROOT:\n-\t  GC_err_printf1(\"root at 0x%lx\\n\", (unsigned long)base);\n+\t  GC_err_printf1(\"root at 0x%lx\\n\\n\", (unsigned long)base);\n \t  goto out;\n \tcase GC_REFD_FROM_REG:\n-\t  GC_err_printf0(\"root in register\\n\");\n+\t  GC_err_printf0(\"root in register\\n\\n\");\n \t  goto out;\n \tcase GC_FINALIZER_REFD:\n-\t  GC_err_printf0(\"list of finalizable objects\\n\");\n+\t  GC_err_printf0(\"list of finalizable objects\\n\\n\");\n \t  goto out;\n \tcase GC_REFD_FROM_HEAP:\n \t  GC_err_printf1(\"offset %ld in object:\\n\", (unsigned long)offset);\n@@ -217,15 +217,20 @@ ptr_t p;\n \n   /* Force a garbage collection and generate a backtrace from a\t*/\n   /* random heap address.\t\t\t\t\t*/\n-  void GC_generate_random_backtrace(void)\n+  void GC_generate_random_backtrace_no_gc(void)\n   {\n     void * current;\n-    GC_gcollect();\n     current = GC_generate_random_valid_address();\n-    GC_printf1(\"Chose address 0x%lx in object\\n\", (unsigned long)current);\n+    GC_printf1(\"\\n****Chose address 0x%lx in object\\n\", (unsigned long)current);\n     GC_print_backtrace(current);\n   }\n     \n+  void GC_generate_random_backtrace(void)\n+  {\n+    GC_gcollect();\n+    GC_generate_random_backtrace_no_gc();\n+  }\n+    \n #endif /* KEEP_BACK_PTRS */\n \n # define CROSSES_HBLK(p, sz) \\\n@@ -325,6 +330,58 @@ register oh * ohdr;\n }\n #endif /* !SHORT_DBG_HDRS */\n \n+static GC_describe_type_fn GC_describe_type_fns[MAXOBJKINDS] = {0};\n+\n+void GC_register_describe_type_fn(kind, fn)\n+int kind;\n+GC_describe_type_fn fn;\n+{\n+  GC_describe_type_fns[kind] = fn;\n+}\n+\n+/* Print a type description for the object whose client-visible address\t*/\n+/* is p.\t\t\t\t\t\t\t\t*/\n+void GC_print_type(p)\n+ptr_t p;\n+{\n+    hdr * hhdr = GC_find_header(p);\n+    char buffer[GC_TYPE_DESCR_LEN + 1];\n+    int kind = hhdr -> hb_obj_kind;\n+\n+    if (0 != GC_describe_type_fns[kind] && GC_is_marked(GC_base(p))) {\n+\t/* This should preclude free list objects except with\t*/\n+\t/* thread-local allocation.\t\t\t\t*/\n+\tbuffer[GC_TYPE_DESCR_LEN] = 0;\n+\t(GC_describe_type_fns[kind])(p, buffer);\n+\tGC_ASSERT(buffer[GC_TYPE_DESCR_LEN] == 0);\n+\tGC_err_puts(buffer);\n+    } else {\n+\tswitch(kind) {\n+\t  case PTRFREE:\n+\t    GC_err_puts(\"PTRFREE\");\n+\t    break;\n+\t  case NORMAL:\n+\t    GC_err_puts(\"NORMAL\");\n+\t    break;\n+\t  case UNCOLLECTABLE:\n+\t    GC_err_puts(\"UNCOLLECTABLE\");\n+\t    break;\n+#\t  ifdef ATOMIC_UNCOLLECTABLE\n+\t    case AUNCOLLECTABLE:\n+\t      GC_err_puts(\"ATOMIC UNCOLLECTABLE\");\n+\t      break;\n+#\t  endif\n+\t  case STUBBORN:\n+\t    GC_err_puts(\"STUBBORN\");\n+\t    break;\n+\t  default:\n+\t    GC_err_printf2(\"kind %ld, descr 0x%lx\", kind, hhdr -> hb_descr);\n+\t}\n+    }\n+}\n+\n+    \n+\n void GC_print_obj(p)\n ptr_t p;\n {\n@@ -334,11 +391,13 @@ ptr_t p;\n     GC_err_printf1(\"0x%lx (\", ((unsigned long)ohdr + sizeof(oh)));\n     GC_err_puts(ohdr -> oh_string);\n #   ifdef SHORT_DBG_HDRS\n-      GC_err_printf1(\":%ld)\\n\", (unsigned long)(ohdr -> oh_int));\n+      GC_err_printf1(\":%ld, \", (unsigned long)(ohdr -> oh_int));\n #   else\n-      GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n+      GC_err_printf2(\":%ld, sz=%ld, \", (unsigned long)(ohdr -> oh_int),\n           \t\t\t        (unsigned long)(ohdr -> oh_sz));\n #   endif\n+    GC_print_type((ptr_t)(ohdr + 1));\n+    GC_err_puts(\")\\n\");\n     PRINT_CALL_CHAIN(ohdr);\n }\n \n@@ -403,6 +462,8 @@ void GC_start_debugging()\n     GC_register_displacement((word)sizeof(oh));\n }\n \n+size_t GC_debug_header_size = sizeof(oh);\n+\n # if defined(__STDC__) || defined(__cplusplus)\n     void GC_debug_register_displacement(GC_word offset)\n # else\n@@ -757,7 +818,15 @@ GC_PTR p;\n \t\t    uncollectable = TRUE;\n \t    }\n #\tendif\n-\tif (uncollectable) GC_free(base);\n+\tif (uncollectable) {\n+\t    GC_free(base);\n+\t} else {\n+\t    size_t i;\n+\t    size_t obj_sz = hhdr -> hb_sz - BYTES_TO_WORDS(sizeof(oh));\n+\n+\t    for (i = 0; i < obj_sz; ++i) ((word *)p)[i] = 0xdeadbeef;\n+\t    GC_ASSERT((word *)p + i == (word *)base + hhdr -> hb_sz);\n+\t}\n     } /* !GC_find_leak */\n }\n \n@@ -1013,7 +1082,8 @@ GC_PTR *ocd;\n     GC_finalization_proc my_old_fn;\n     GC_PTR my_old_cd;\n     ptr_t base = GC_base(obj);\n-    if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n+    if (0 == base) return;\n+    if ((ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n \t    \"GC_debug_register_finalizer called with non-base-pointer 0x%lx\\n\",\n \t    obj);\n@@ -1045,7 +1115,8 @@ GC_PTR *ocd;\n     GC_finalization_proc my_old_fn;\n     GC_PTR my_old_cd;\n     ptr_t base = GC_base(obj);\n-    if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n+    if (0 == base) return;\n+    if ((ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n \t  \"GC_debug_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n \t  obj);\n@@ -1078,7 +1149,8 @@ GC_PTR *ocd;\n     GC_finalization_proc my_old_fn;\n     GC_PTR my_old_cd;\n     ptr_t base = GC_base(obj);\n-    if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n+    if (0 == base) return;\n+    if ((ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n \t    \"GC_debug_register_finalizer_ignore_self called with non-base-pointer 0x%lx\\n\",\n \t    obj);"}, {"sha": "ff77113ee8ca21df7e3add510a3e8b0f1dea6dd4", "filename": "boehm-gc/doc/README", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,7 +1,7 @@\n Copyright (c) 1988, 1989 Hans-J. Boehm, Alan J. Demers\n Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n-Copyright (c) 1999-2003 by Hewlett-Packard Company. All rights reserved.\n+Copyright (c) 1999-2004 Hewlett-Packard Development Company, L.P.\n \n The file linux_threads.c is also\n Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n@@ -28,7 +28,7 @@ are GPL'ed, but with an exception that should cover all uses in the\n collector.  (If you are concerned about such things, I recommend you look\n at the notice in config.guess or ltmain.sh.)\n \n-This is version 6.3alpha1 of a conservative garbage collector for C and C++.\n+This is version 6.3 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n "}, {"sha": "e27e7d635b650d5a265bc9972f96be2cbfa53a30", "filename": "boehm-gc/doc/README.changes", "status": "modified", "additions": 213, "deletions": 1, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.changes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.changes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.changes?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1836,7 +1836,7 @@ Since 6.2alpha4:\n    libgccpp.\n \n Since 6.2alpha5:\n- - There was extra underscore in the name of GC_save_registers_in_stack\n+ - There was an extra underscore in the name of GC_save_registers_in_stack\n    for NetBSD/SPARC.  (Thanks to Jaap Boender for the patch.)\n  - Integrated Brian Alliet's patch for Darwin.  This restructured the\n    linuxthreads/pthreads support to separate generic pthreads support\n@@ -1894,7 +1894,219 @@ Since 6.2:\n    (Thanks to Roger Sayle for the patch.)\n  - Applied more AIX threads patches from Scott Ananian.\n \n+Since 6.3alpha1:\n+ - Reenabled I_HOLD_LOCK assertion in aix_irix_threads.h.\n+ - Put back the WINABI qualifier for GC_CreateThread.  (Thanks to\n+   Danny Smith for the patch.  6.3alpha1 had the qualifier in one place\n+   but not elsewhere, which was clearly wrong.)\n+ - Sometimes explicitly define __private_extern__ before DARWIN dyld.h\n+   include.  (Thanks to Andreas Tobker for postting the patch.)\n+ - Included signal.h from pthread_support.c.  Removed GC_looping_handler,\n+   which was dead code.\n+ - GC_find_start was misdeclared by gc_pmark.h if PRINT_BLACK_LIST was\n+   defined.  (Thanks to Glauco Masotti for testing and reporting this.)\n+   Changed GC_find_start to never just return 0.  According to its\n+   comment it doesn't, and it's unclear that's correct.\n+ - GC_alloc_large had several largely compensating bugs in the\n+   computation of GC_words_wasted.  (It was confused about bytes vs.\n+   words in two places.)\n+ - Integrated Slava Sysoltev's patch to support more recent versions of\n+   the Intel compiler on IA64/Linux.\n+ - Changed win32 spinlock initialization to conditionally set a spin count.\n+   (Emmanual Stumpf pointed out that enabling this makes a large performance\n+   difference on win32 multiprocessors.)  Also cleaned up the win32 spinlock\n+   initialization code a bit.\n+ - Fixed thread support for HP/UX/IA64.  The register backing store base for\n+   the main thread was sometimes not set correctly.  (Thanks to Laurent\n+   Morichetti.)\n+ - Added -DEMPTY_GETENV_RESULTS flag to work around Wine problem.\n+ - Declare GC_stack_alloc and GC_stack_free in solaris_threads.h to\n+   avoid 64-bit size mismatches.  (Thanks to Bernie Solomon.)\n+ - Fixed GC_generic_push_regs to avoid a potential and very unfortunate\n+   tail call optimization.  This could lead to prematurely reclaimed\n+   objects on configurations that used the generic routine and the new\n+   build infrastructure (which potentially optimizes mach_dep.c).\n+   This was a serious bug, but it's unclear whether it has resulted in\n+   any real failures.\n+ - Fixed CORD_str to deal with signed characters.  (Thanks to Alexandr\n+   Petrosian for noticing the problem and supplying the patch.)\n+ - Merged a couple of NOSYS/ECOS tests into os_dep.c from gcj.  (Thanks\n+   to Anthony Green.)\n+ - Partially merged a win32 patch from Ben Hutchings, and substantially\n+   revised other parts of win32_threads.c.  It had several problems.\n+   Under MinGW with a statically linked library, the main thread was\n+   not registered.  Cygwin detached threads leaked thread descriptors.\n+   There were several race conditions.  For now, unfortunately the\n+   static threads limit remains, though we increased it, and made table\n+   traversal cost depend on the actual thread count.\n+   There is also still some code duplication with pthread_support.c.\n+   (Thread descriptors did become much smaller, since Ben Hutchings\n+   removed the thread context from them.)\n+ - Integrated a Solaris configure.in patch from Rainer Orth.\n+ - Added GC_IGNORE_FB and associated warning to very partially address\n+   the issue of the collector treating a mapped frame buffer as part\n+   of the root set.  (Thanks to David Peroutka for providing some\n+   insight.  More would be helpful.  Is there anything that can be used\n+   to at least partially identify such memory segments?)\n+   \n+Since 6.3alpha2:\n+ - Removed -DSMALL_CONFIG from BCC_MAKEFILE.\n+ - Changed macros to test for an ARM processor (Patch from Richard Earnshaw.)\n+ - Mostly applied a DJGPP patch from Doug Kaufman.  Especially Makefile.dj\n+   had suffered from serious bit rot.\n+ - Rewrote GC_apply_to_maps, eliminating an off-by-one subscript error,\n+   and a call to alloca (for lcc compatibility).\n+ - Changed USE_MUNMAP behavior on posixy platforms to immediately remap\n+   the memory with PROT_NONE instead of unmapping it.  The latter risks\n+   an intervening mmap grabbing the address space out from underneath us.\n+   Updated this code to reflect a cleaner patch from Ulrich Drepper.\n+ - Replaced _T with _Tp in new_gc_alloc.h to avoid a MACOS X conflict.\n+   (Patch from Andrew Begel.)\n+ - Dynamically choose whether or not lock should spin on win32.  (Thanks\n+   to Maurizio Vairani for the patch.)  This may be a significant performance\n+   improvement for win32.\n+ - Fix Makefile.direct to actually include NT_STATIC_THREADS_MAKEFILE\n+   in the distribution.  (Again thanks to Maurizio Vairani.)\n+ - Maybe_install_looping_handler() was accidentally exported, violating\n+   our name space convention.\n+ - Made os_dep.c use sigsetjmp and SA_NODEFER for NetBSD.  (Thanks to\n+   Christian Limpach.)  (I generalized the patch to use sigsetjmp on all\n+   UNIX_LIKE platforms, admittedly a slightly risky move.  But it may avoid\n+   similar problems on some other platforms. I also cleaned up the defn\n+   of UNIX_LIKE a bit. - Hans)\n+ - Integrated Andrew Begel's Darwin threads patch, adjusted according to\n+   some of Fergus Hendersons's comments.  (Patch didn't apply cleanly,\n+   errors are possible.)\n+ - Added another test or two for the Intel 8.0 compiler to avoid\n+   confusing it with gcc.  The single-threaded collector should now build\n+   with icc, at least on ia64. \n+\n+Since 6.3alpha3:\n+ - USE_MMAP was broken by confusion in the code dealing with USE_MMAP_ANON.\n+   (This was pointed out, and fixes were suggested by several other people.)\n+ - Darwin supprt was broken in alpha3 as a result of my misintegration of\n+   Andrew Begel's patches.  Fixed with another patch from Andrew Begel.\n+ - A new sanity check in pthread_stop_world.c:GC_push_all_stacks() was\n+   overly aggressive.  We may collect from an unregistered thread during\n+   thread creation.  Fixed by explicitly checking for that case.  (Added\n+   GC_in_thread_creation.)\n+\n+Since 6.3alpha4:\n+ - Fix & vs && typo in GC_generic_malloc and\n+   GC_generic_malloc_ignore_off_page.  (Propagated from the gcc tree.)\n+ - Removed SA_NODEFER hack from NetBSD and Solaris write-protect handler.\n+   (According to Christian Limpach, the NetBSD problem is fixed.\n+   Presumably so is the Solaris 2.3 problem.)\n+ - Removed placement delete from gc_cpp.h for the SGI compiler.\n+   (Thanks to Simon Gornall for the patch.)\n+ - Changed semantics of the GC_IGNORE_FB environment variable, based \n+   on experimentation by Nicolas Cannasse pointing out that the old\n+   interpretation was useless.  We still need help in identifying win32\n+   graphics memory mappings.  The current \"solution\" is a hack.\n+ - Removed \"MAKEOVERRIDES =\" from Makefile.am and thus Makefile.in.\n+   It probably made more sense in the gcc context.\n+ - Explicitly ensure that NEED_FIND_LIMIT is defined for {Open,Net}BSD/ELF.\n+ - Replaced USE_HPUX_TLS macro by USE_COMPILER_TLS, since gcc often\n+   supports the same extension on various platforms.\n+ - Added some basic (completely untested) defines for win64, in support\n+   of future work.\n+ - Declared GC_jmp_buf in os_dep.s as JMP_BUF instead of jmp_buf, fixing\n+   a memory overwrite bug on Solaris and perhaps other platforms.\n+ - Added 0 != __libc_stack_end test to GC_linux_stack_base.  (Thanks to Jakub\n+   Jelinek, both for the patch, and for explaining the problem to me.)\n+   Otherwise \"prelink\"ing could cause the collector to fail.\n+ - Changed default thread local storage implementation to USE_PTHREAD_SPECIFIC\n+   for HP/UX with gcc.  The compiler-based implementation appears to work\n+   only with the vendor compiler.\n+ - Export GC_debug_header_size and GC_USR_PTR_FROM_BASE from gc_mark.h,\n+   making client mark code cleaner and less dependent on GC version.\n+ - Export several new procedures and GC_generic_malloc from gc_mark.h\n+   to support user-defined kinds.  Use the new procedures to replace existing\n+   code in gcj_mlc.c and typd_mlc.c.\n+ - Added support for GC_BACKTRACES.\n+ - Fixed a remaining problem in CORD_str with signed characters.  (Thanks\n+   to Alexandr Petrosian for the patch.)\n+ - Removed supposedly redundant, but very buggy, definitions of finalizer\n+   macros from javaxfc.h.  Fortunately this file probably has no users.\n+   The correct declarations were already in gc.h.\n+ - Also need to set GC_in_thread_creation while waiting for GC during\n+   thread termination, since it is also possible to collect from an\n+   unregistered thread in that case.\n+ - Define NO_GETENV for Windows CE, since getenv doesn't appear to exist.\n+   + some other minor WinCE fixes. (Thanks to Alain Novak.)\n+ - Added GC_register_describe_type_fn.\n+ - Arrange for debugging finalizer registration to ignore non-heap\n+   registrations, since the regular version of the routine also behaves\n+   that way.\n+ - GC_gcj_malloc and friends need to check for finalizers waiting to be run.\n+   One of the more obscure allocation routines with missing a LOCK() call.\n+ - Fixed cvtres invocations in NT_MAKEFILE and NT_STATIC_THREADS_MAKEFILE\n+   to work with VS.NET.\n+ - Cleaned up GC_INIT calls in test.  Updated gc.man to encourage GC_INIT\n+   use in portable code.\n+ - Taught the GC to use libunwind if --enable-full-debug is specified on\n+   IA64 and libunwind is present.\n+ - The USE_MUNMAP code could get confused about the age of a block and\n+   prematurely unmap it.  GC_unmap_old had a bug related to wrapping of\n+   GC_gc_no.  GC_freehblk and GC_merge_unmapped didn't maintain\n+   hb_last_reclaimed reasonably when blocks were merged.  The code was\n+   fixed to reflect original intent, but that may not always be an\n+   improvement.  See todo list item.\n+\n+Since 6.3alpha5:\n+ - Define USE_GENERIC_PUSH_REGS for NetBSD/M68K.\n+ - Fixed the X86_64 PREFETCH macros to correctly handle ia32e (which uses\n+   different prefetch instructions from AMD64).  (Thanks to H.J. Lu.)\n+ - GC_config_macros.h did not correctly define GC_WIN32_THREADS from\n+   GC_THREADS. \n+ - Added simple_example.html.\n+ - Merged Andrew Gray's patch to correctly restore signal handlers on\n+   FreeBSD.\n+ - Merged a patch from Andreas Jaeger to deal with prefetch-related warnings\n+   on x86-64.  Added some other casts so that the PREFETCH macros\n+   always get a ptr_t argument.  Removed some casts inthe PREFETCH\n+   implementations.\n+ - At Jesse Jones suggestion: Added a header guard for gc_allocator.h\n+   and changed GC_debug_free to clobber contents of deallocated object.\n+ - The signal masking code in pthread_stop_world.c contained some errors.\n+   In particular SIGSEGV was masked in the handler, in spite of the fact that\n+   it wrote to the heap.  This could lead to an uncaught SIGSEGV, which\n+   apparently became much more likely in Linux 2.6.  Also fixed some\n+   typos, and reduced code duplication in the same area.\n+ - Remove ltconfig, clean up configure messages for DGUX (thanks to\n+   Adrian Bunk for the patches).\n+ - Integrated NetBSD/OpenBSD patches from Marc Recht and Matthias Drochner.\n+\n+Since gc6.3alpha6:\n+ - Compile test_cpp.cc with CXXCOMPILE instead of COMPILE.\n+ - Very large allocations could cause a collector hang.  Correct\n+   calculation of GC_collect_at_heapsize.\n+ - GC_print_hblkfreelist printed some bogus results if USE_MUNMAP\n+   was defined.\n+ - The generic GC_THREADS macro didn't work correctly on Solaris,\n+   since the implementation failed to include gc_config_macros.h\n+   before deciding whether or not to compile the rest of the file.\n+ - Threadlibs.c failed to expand the generic GC_THREADS macro.\n+ - Correct MacOSX thread stop code. (Thanks to Dick Porter.)\n+ - SMALL_OBJ definition was off by one.  This could cause crashes\n+   at startup.  (Thanks to Zoltan Varga for narrowing this down to\n+   a trivial test case.)\n+ - Integrate Paolo Molara's patch to deal with a race in the Darwin\n+   thread stopping code.\n+ - Changed X86_64 implementation to use SA_SIGINFO in the MPROTECT_VDB\n+   implementation.  The old approach appears to have been broken by\n+   recent kernels.\n+ - Add GC_ATTR_UNUSED to eliminate a warning in gc_allocator.h.  (Thanks\n+   to Andrew Begel.)\n+ - Fix GC_task_self declaration in os_dep.c.  (Thanks to Andrew Pinski.)\n+ - Increase INITIAL_BUF_SZ in os_dep.c for Solaris /proc reads.\n+  \n To do:\n+ - The USE_MUNMAP code should really use a separate data structure\n+   indexed by physical page to keep track of time since last use of\n+   a page.  Using hblk headers means we lose track of ages when\n+   blocks are merged, and we can't unmap pages that have been allocated and\n+   dropped by the blacklisting code.  I suspect both of these matter.\n  - A dynamic libgc.so references dlopen unconditionally, but doesn't link\n    against libdl.\n  - GC_proc_fd for Solaris is not correctly updated in response to a"}, {"sha": "97a13dc3e45641787a338160f3da27abc2510743", "filename": "boehm-gc/doc/README.environment", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.environment", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.environment", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.environment?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,6 +1,6 @@\n The garbage collector looks at a number of environment variables which are\n then used to affect its operation.  These are examined only on Un*x-like\n-platforms.\n+platforms and win32.\n \n GC_INITIAL_HEAP_SIZE=<bytes> -\tInitial heap size in bytes.  May speed up\n \t\t\t\tprocess start-up.\n@@ -26,6 +26,14 @@ GC_DUMP_REGULARLY - Generate a GC debugging dump GC_dump() on startup\n \t\t    if you have a bug to report, but please include only the\n \t\t    last complete dump.\n \n+GC_BACKTRACES=<n> - Generate n random backtraces (for heap profiling) after\n+\t\t    each GC.  Collector must have been built with\n+\t\t    KEEP_BACK_PTRS.  This won't generate useful output unless\n+\t\t    most objects in the heap were allocated through debug\n+\t\t    allocators.  This is intended to be only a statistical\n+\t\t    sample;  individual traces may be erroneous due to\n+\t\t    concurrent heap mutation.\n+\n GC_PRINT_ADDRESS_MAP - Linux only.  Dump /proc/self/maps, i.e. various address\n \t\t       maps for the process, to stderr on every GC.  Useful for\n \t\t       mapping root addresses to source for deciphering leak\n@@ -86,6 +94,28 @@ GC_RETRY_SIGNALS, GC_NO_RETRY_SIGNALS - Try to compensate for lost\n \t\t     was turned into a runtime flag to enable last-minute\n \t\t     work-arounds.\n \n+GC_IGNORE_FB[=<n>] -  (Win32 only.) Try to avoid treating a mapped\n+\t\tframe buffer as part of the root set.  Certain (higher end?)\n+\t\tgraphics cards seems to result in the graphics memory mapped\n+\t\tinto the user address space as writable memory.\n+\t\tUnfortunately, there seems to be no systematic way to\n+\t\tidentify such memory.  Setting the environment variable to n\n+\t\tcauses the collector to ignore mappings longer than n MB.\n+\t\tThe default value of n is currently 15.  (This should cover\n+\t\ta 16 MB graphics card, since the mapping appears to be slightly\n+\t\tshorter than all of graphics memory.  It will fail if a dll\n+\t\twrites pointers to collectable objects into a data segment\n+\t\twhose length is >= 15MB.  Empirically that's rare, but\n+\t\tcertainly possible.)  WARNING: Security sensitive applications\n+\t\tshould probably disable this feature by setting\n+\t\tGC_disallow_ignore_fb, or by building with -DNO_GETENV,\n+\t\tsince small values could force collection of reachable\n+\t\tobjects, which is conceivably a\t(difficult to exploit)\n+\t\tsecurity hole.  GC_IGNORE_FB values less than 3 MB\n+\t\tare never honored, eliminating this risk for most,\n+\t\tbut not all, applications.  This feature is likely to disappear\n+\t\tif/when we find a less disgusting \"solution\".\n+\n The following turn on runtime flags that are also program settable.  Checked\n only during initialization.  We expect that they will usually be set through\n other means, but this may help with debugging and testing:"}, {"sha": "df0ef2cda933f68b5f2b37552a000182d38b1a5d", "filename": "boehm-gc/doc/README.macros", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.macros", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.macros", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.macros?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -85,5 +85,10 @@ SRC_M3\t\tSet if the collector is being built as a replacement of the\n \t\tIt's there primarily incase someone wants to port to a similar\n \t\tsystem.\n \n+USE_COMPILER_TLS  Assume the existence of __thread-style thread-local\n+\t\tstorage.  Set automatically for thread-local allocation with\n+\t\tthe HP/UX vendor compiler.  Usable with gcc on sufficiently\n+\t\tup-to-date ELF platforms.\n+\n \n "}, {"sha": "6f57db117647407369b0059a8a91dc12c4454821", "filename": "boehm-gc/doc/README.win32", "status": "modified", "additions": 80, "deletions": 35, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2FREADME.win32?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,34 +1,11 @@\n-The collector has at various times been compiled under Windows 95 & NT,\n-with the original Microsoft SDK, with Visual C++ 2.0, 4.0, and 6, with\n-the GNU win32 environment, with Borland 4.5,  with Watcom C, and recently\n+The collector has at various times been compiled under Windows 95 & later, NT,\n+and XP, with the original Microsoft SDK, with Visual C++ 2.0, 4.0, and 6, with\n+the GNU win32 tools, with Borland 4.5,  with Watcom C, and recently\n with the Digital Mars compiler.  It is likely that some of these have been\n broken in the meantime.  Patches are appreciated.\n \n-It runs under both win32s and win32, but with different semantics.\n-Under win32, all writable pages outside of the heaps and stack are\n-scanned for roots.  Thus the collector sees pointers in DLL data\n-segments.  Under win32s, only the main data segment is scanned.\n-(The main data segment should always be scanned.  Under some\n-versions of win32s, other regions may also be scanned.)\n-Thus all accessible objects should be accessible from local variables\n-or variables in the main data segment.  Alternatively, other data\n-segments (e.g. in DLLs) may be registered with the collector by\n-calling GC_init() and then GC_register_root_section(a), where\n-a is the address of some variable inside the data segment.  (Duplicate\n-registrations are ignored, but not terribly quickly.)\n-\n-(There are two reasons for this.  We didn't want to see many 16:16\n-pointers.  And the VirtualQuery call has different semantics under\n-the two systems, and under different versions of win32s.)\n-\n-Win32 applications compiled with some flavor of gcc currently behave\n-like win32s applications, in that dynamic library data segments are\n-not scanned.  (Gcc does not directly support Microsoft's \"structured\n-exception handling\".  It turns out that use of this feature is\n-unavoidable if you scan arbitrary memory segments obtained from\n-VirtualQuery.)\n-\n-The collector test program \"gctest\" is linked as a GUI application,\n+For historical reasons,\n+the collector test program \"gctest\" is linked as a GUI application,\n but does not open any windows.  Its output appears in the file\n \"gc.log\".  It may be started from the file manager.  The hour glass\n cursor may appear as long as it's running.  If it is started from the\n@@ -60,11 +37,23 @@ This is currently incompatible with -DUSE_MUNMAP.  (Thanks to Jonathan\n Clark for tracking this down.  There's some chance this may be fixed\n in 6.1alpha4, since we now separate heap sections with an unused page.)\n \n+Microsoft Tools\n+---------------\n For Microsoft development tools, rename NT_MAKEFILE as\n MAKEFILE.  (Make sure that the CPU environment variable is defined\n to be i386.)  In order to use the gc_cpp.h C++ interface, all\n client code should include gc_cpp.h.\n \n+For historical reasons,\n+the collector test program \"gctest\" is linked as a GUI application,\n+but does not open any windows.  Its output appears in the file\n+\"gc.log\".  It may be started from the file manager.  The hour glass\n+cursor may appear as long as it's running.  If it is started from the\n+command line, it will usually run in the background.  Wait a few\n+minutes (a few seconds on a modern machine) before you check the output.\n+You should see either a failure indication or a \"Collector appears to\n+work\" message.\n+\n If you would prefer a VC++.NET project file, ask boehm@acm.org.  One has\n been contributed, but it seems to contain some absolute paths etc., so\n it can presumably only be a starting point, and is not in the standard\n@@ -75,13 +64,22 @@ Clients may need to define GC_NOT_DLL before including gc.h, if the\n collector was built as a static library (as it normally is in the\n absence of thread support).\n \n+GNU Tools\n+---------\n For GNU-win32, use the regular makefile, possibly after uncommenting\n the line \"include Makefile.DLLs\".  The latter should be necessary only\n-if you want to package the collector as a DLL.  The GNU-win32 port is\n+if you want to package the collector as a DLL.\n+[Is the following sentence obsolete? -HB] The GNU-win32 port is\n believed to work only for b18, not b19, probably due to linker changes\n in b19.  This is probably fixable with a different definition of\n DATASTART and DATAEND in gcconfig.h.\n \n+The collector should also be buildable under Cygwin with either the\n+old standard Makefile, or with the \"configure;make\" machinery.\n+\n+Borland Tools\n+-------------\n+[Rarely tested.]\n For Borland tools, use BCC_MAKEFILE.  Note that\n Borland's compiler defaults to 1 byte alignment in structures (-a1),\n whereas Visual C++ appears to default to 8 byte alignment (/Zp8).\n@@ -97,6 +95,8 @@ version, change the line near the top.  By default, it does not\n require the assembler.  If you do have the assembler, I recommend\n removing the -DUSE_GENERIC.\n \n+Incremental Collection\n+----------------------\n There is some support for incremental collection.  This is\n currently pretty simple-minded.  Pages are protected.  Protection\n faults are caught by a handler installed at the bottom of the handler\n@@ -112,7 +112,11 @@ is called.)\n \n Note that incremental collection is disabled with -DSMALL_CONFIG.\n \n-James Clark has contributed the necessary code to support win32 threads.\n+Threads\n+-------\n+\n+James Clark has contributed the necessary code to support win32 threads\n+with the collector in a DLL.\n Use NT_THREADS_MAKEFILE (a.k.a gc.mak) instead of NT_MAKEFILE\n to build this version.  Note that this requires some files whose names\n are more than 8 + 3 characters long.  Thus you should unpack the tar file\n@@ -128,12 +132,31 @@ This version relies on the collector residing in a dll.\n \n This version currently supports incremental collection only if it is\n enabled before any additional threads are created.\n-Version 4.13 attempts to fix some of the earlier problems, but there\n-may be other issues.  If you need solid support for win32 threads, you\n-might check with Geodesic Systems.  Their collector must be licensed,\n-but they have invested far more time in win32-specific issues.\n \n-Hans\n+Since 6.3alpha2, threads are also better supported in static library builds\n+with Microsoft tools (use NT_STATIC_THREADS_MAKEFILE) and with the GNU\n+tools.  In all cases,the collector must be built with GC_WIN32_THREADS\n+defined, even if the Cygwin pthreads interface is used.\n+(NT_STATIC_THREADS_MAKEFILE does this implicitly.  Under Cygwin,\n+./configure --enable-threads=posix defines GC_WIN32_THREADS.)  Threads must be\n+created with GC_CreateThread.  This can be accomplished by\n+including gc.h and then calling CreateThread, which is redefined\n+by gc.h.\n+\n+For the statically linked versions, it is required that GC_init()\n+be called before other GC calls, since there seems to be no implicit way\n+to initialize the allocation lock.  The easiest way to ensure this in\n+portable code is to call GC_INIT() from the main executable (not\n+a dynamic library) before calling any other GC_ routines.\n+\n+We strongly advise against using the TerminateThread() win32 API call,\n+especially with the garbage collector.  Any use is likely to provoke a\n+crash in the GC, since it makes it impossible for the collector to\n+correctly track threads.\n+\n+\n+Watcom compiler\n+---------------\n \n Ivan V. Demakov's README for the Watcom port:\n \n@@ -167,4 +190,26 @@ important, otherwise resulting programs will not run.\n \n Ivan Demakov (email: ivan@tgrad.nsk.su)\n \n+Win32S\n+------\n+\n+[The following is probably obsolete.  The win32s support is still in the\n+collector, but I doubt anyone cares, or has tested it recently.]\n+\n+The collector runs under both win32s and win32, but with different semantics.\n+Under win32, all writable pages outside of the heaps and stack are\n+scanned for roots.  Thus the collector sees pointers in DLL data\n+segments.  Under win32s, only the main data segment is scanned.\n+(The main data segment should always be scanned.  Under some\n+versions of win32s, other regions may also be scanned.)\n+Thus all accessible objects should be accessible from local variables\n+or variables in the main data segment.  Alternatively, other data\n+segments (e.g. in DLLs) may be registered with the collector by\n+calling GC_init() and then GC_register_root_section(a), where\n+a is the address of some variable inside the data segment.  (Duplicate\n+registrations are ignored, but not terribly quickly.)\n+\n+(There are two reasons for this.  We didn't want to see many 16:16\n+pointers.  And the VirtualQuery call has different semantics under\n+the two systems, and under different versions of win32s.)\n "}, {"sha": "7c65f2bb40a088acbef94a330b7ee9dcad45ea18", "filename": "boehm-gc/doc/debugging.html", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2Fdebugging.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2Fdebugging.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fdebugging.html?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -47,6 +47,10 @@ <H2>Warning Messages About Needing to Allocate Blacklisted Blocks</h2>\n <PRE>\n Needed to allocate blacklisted block at 0x...\n </pre>\n+or\n+<PRE>\n+Repeated allocation of very large block ...\n+</pre>\n when it needs to allocate a block at a location that it knows to be\n referenced by a false pointer.  These false pointers can be either permanent\n (<I>e.g.</i> a static integer variable that never changes) or temporary.\n@@ -123,7 +127,8 @@ <H2>Unexpectedly Large Heap</h2>\n but were not cleared, or by caches growing without bounds.\n <LI> Pointer misidentification.  The garbage collector is interpreting\n integers or other data as pointers and retaining the \"referenced\"\n-objects.\n+objects.  A common symptom is that GC_dump() shows much of the heap\n+as black-listed.\n <LI> Heap fragmentation.  This should never result in unbounded growth,\n but it may account for larger heaps.  This is most commonly caused\n by allocation of large objects.  On some platforms it can be reduced\n@@ -180,6 +185,12 @@ <H2>Unexpectedly Large Heap</h2>\n <LI> Consider using <TT>GC_malloc_ignore_off_page()</tt>\n to allocate large objects.  (See <TT>gc.h</tt> and above for details.\n Large means &gt; 100K in most environments.)\n+<LI> If your heap size is larger than 100MB or so, build the collector with\n+-DLARGE_CONFIG.  This allows the collector to keep more precise black-list\n+information.\n+<LI> If you are using heaps close to, or larger than, a gigabyte on a 32-bit\n+machine, you may want to consider moving to a platform with 64-bit pointers.\n+This is very likely to resolve any false pointer issues.\n </ol>\n <H2>Prematurely Reclaimed Objects</h2>\n The usual symptom of this is a segmentation fault, or an obviously overwritten"}, {"sha": "2a550c71247e399ddbd36137a3aad57e9e915d7c", "filename": "boehm-gc/doc/gc.man", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2Fgc.man", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2Fgc.man", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgc.man?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,12 +1,14 @@\n-.TH GC_MALLOC 1L \"12 February 1996\"\n+.TH GC_MALLOC 1L \"2 October 2003\"\n .SH NAME\n GC_malloc, GC_malloc_atomic, GC_free, GC_realloc, GC_enable_incremental, GC_register_finalizer, GC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page, GC_set_warn_proc \\- Garbage collecting malloc replacement\n .SH SYNOPSIS\n #include \"gc.h\"\n .br\n-# define malloc(n) GC_malloc(n)\n+void * GC_malloc(size_t size);\n .br\n-... malloc(...) ...\n+void GC_free(void *ptr);\n+.br\n+void * GC_realloc(void *ptr, size_t size);\n .br\n .sp\n cc ... gc.a\n@@ -23,6 +25,11 @@ will attempt to reclaim inaccessible space automatically by invoking a conservat\n GC_malloc\n or friends.\n .LP\n+In most cases it is preferable to call the macros GC_MALLOC, GC_FREE, etc.\n+instead of calling GC_malloc and friends directly.  This allows debugging\n+versions of the routines to be substituted by defining GC_DEBUG before\n+including gc.h.\n+.LP\n See the documentation in the include file gc_cpp.h for an alternate, C++ specific interface to the garbage collector.\n .LP\n Unlike the standard implementations of malloc,\n@@ -56,9 +63,16 @@ It is also possible to use the collector to find storage leaks in programs desti\n .LP\n The collector may, on rare occasion produce warning messages.  On UNIX machines these appear on stderr.  Warning messages can be filtered, redirected, or ignored with\n .I\n-GC_set_warn_proc.\n+GC_set_warn_proc\n This is recommended for production code.  See gc.h for details.\n .LP\n+Fully portable code should call\n+.I\n+GC_INIT\n+from the main program before making any other GC calls.\n+On most platforms this does nothing and the collector is initialized on first use.\n+On a few platforms explicit initialization is necessary.  And it can never hurt. \n+.LP\n Debugging versions of many of the above routines are provided as macros.  Their names are identical to the above, but consist of all capital letters.  If GC_DEBUG is defined before gc.h is included, these routines do additional checking, and allow the leak detecting version of the collector to produce slightly more useful output.  Without GC_DEBUG defined, they behave exactly like the lower-case versions.\n .LP\n On some machines, collection will be performed incrementally after a call to\n@@ -71,10 +85,13 @@ Other facilities not discussed here include limited facilities to support increm\n .SH \"SEE ALSO\"\n The README and gc.h files in the distribution.  More detailed definitions of the functions exported by the collector are given there.  (The above list is not complete.)\n .LP\n+The web site at http://www.hpl.hp.com/personal/Hans_Boehm/gc .\n+.LP\n Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n \\fISoftware Practice & Experience\\fP, September 1988, pp. 807-820.\n .LP\n The malloc(3) man page.\n .LP\n .SH AUTHOR\n-Hans-J. Boehm (boehm@parc.xerox.com).  Some of the code was written by others, most notably Alan Demers.\n+Hans-J. Boehm (Hans.Boehm@hp.com).\n+Some of the code was written by others, most notably Alan Demers."}, {"sha": "cab6bde4fbab9682471022bca6b098a69af86486", "filename": "boehm-gc/doc/gcdescr.html", "status": "modified", "additions": 50, "deletions": 10, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2Fgcdescr.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdoc%2Fgcdescr.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdoc%2Fgcdescr.html?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -4,7 +4,7 @@\n     <AUTHOR> Hans-J. Boehm, HP Labs (Much of this was written at SGI)</author>\n </HEAD>\n <BODY>\n-<H1> <I>This is under construction</i> </h1>\n+<H1> <I>This is under construction, and may always be.</i> </h1>\n <H1> Conservative GC Algorithmic Overview </h1>\n <P>\n This is a description of the algorithms and data structures used in our\n@@ -27,20 +27,22 @@ <H1> Conservative GC Algorithmic Overview </h1>\n is very localized.\n <H2> Introduction </h2>\n The garbage collector uses a modified mark-sweep algorithm.  Conceptually\n-it operates roughly in four phases:\n+it operates roughly in four phases, which are performed occasionally\n+as part of a memory allocation:\n \n <OL>\n \n <LI>\n-<I>Preparation</i> Clear all mark bits, indicating that all objects\n+<I>Preparation</i> Each object has an associated mark bit.\n+Clear all mark bits, indicating that all objects\n are potentially unreachable.\n \n <LI>\n <I>Mark phase</i> Marks all objects that can be reachable via chains of\n-pointers from variables.  Normally the collector has no real information\n+pointers from variables.  Often the collector has no real information\n about the location of pointer variables in the heap, so it\n views all static data areas, stacks and registers as potentially containing\n-containing pointers.  Any bit patterns that represent addresses inside\n+pointers.  Any bit patterns that represent addresses inside\n heap objects managed by the collector are viewed as pointers.\n Unless the client program has made heap object layout information\n available to the collector, any heap objects found to be reachable from\n@@ -87,8 +89,12 @@ <H2>Allocation</h2>\n determine pointer locations.  Or a specific kind may correspond\n to one specific object layout.  Two built-in kinds are uncollectable.\n One (<TT>STUBBORN</tt>) is immutable without special precautions.\n-In spite of that, it is very likely that most applications currently\n+In spite of that, it is very likely that most C clients of the\n+collector currently\n use at most two kinds: <TT>NORMAL</tt> and <TT>PTRFREE</tt> objects.\n+The <A HREF=\"http://gcc.gnu.org/java\">gcj</a> runtime also makes\n+heavy use of a kind (allocated with GC_gcj_malloc) that stores\n+type information at a known offset in method tables.\n <P>\n The collector uses a two level allocator.  A large block is defined to\n be one larger than half of <TT>HBLKSIZE</tt>, which is a power of 2,\n@@ -175,15 +181,44 @@ <H2>Allocation</h2>\n \n <H2>Mark phase</h2>\n \n+At each collection, the collector marks all objects that are\n+possibly reachable from pointer variables.  Since it cannot generally\n+tell where pointer variables are located, it scans the following\n+<I>root segments</i> for pointers:\n+<UL>\n+<LI>The registers.  Depending on the architecture, this may be done using\n+assembly code, or by calling a <TT>setjmp</tt>-like function which saves\n+register contents on the stack.\n+<LI>The stack(s).  In the case of a single-threaded application,\n+on most platforms this\n+is done by scanning the memory between (an approximation of) the current\n+stack pointer and <TT>GC_stackbottom</tt>.  (For Itanium, the register stack\n+scanned separately.)  The <TT>GC_stackbottom</tt> variable is set in\n+a highly platform-specific way depending on the appropriate configuration\n+information in <TT>gcconfig.h</tt>.  Note that the currently active\n+stack needs to be scanned carefully, since callee-save registers of\n+client code may appear inside collector stack frames, which may\n+change during the mark process.  This is addressed by scanning\n+some sections of the stack \"eagerly\", effectively capturing a snapshot\n+at one point in time.\n+<LI>Static data region(s).  In the simplest case, this is the region\n+between <TT>DATASTART</tt> and <TT>DATAEND</tt>, as defined in\n+<TT>gcconfig.h</tt>.  However, in most cases, this will also involve\n+static data regions associated with dynamic libraries.  These are\n+identified by the mostly platform-specific code in <TT>dyn_load.c</tt>.\n+</ul> \n The marker maintains an explicit stack of memory regions that are known\n to be accessible, but that have not yet been searched for contained pointers.\n Each stack entry contains the starting address of the block to be scanned,\n as well as a descriptor of the block.  If no layout information is\n available for the block, then the descriptor is simply a length.\n (For other possibilities, see <TT>gc_mark.h</tt>.)\n <P>\n-At the beginning of the mark phase, all root segments are pushed on the\n-stack by <TT>GC_push_roots</tt>.  If <TT>ALL_INTERIOR_PTRS</tt> is not\n+At the beginning of the mark phase, all root segments\n+(as described above) are pushed on the\n+stack by <TT>GC_push_roots</tt>.  (Registers and eagerly processed\n+stack sections are processed by pushing the referenced objects instead\n+of the stack section itself.)  If <TT>ALL_INTERIOR_PTRS</tt> is not\n defined, then stack roots require special treatment.  In this case, the\n normal marking code ignores interior pointers, but <TT>GC_push_all_stack</tt>\n explicitly checks for interior pointers and pushes descriptors for target\n@@ -479,8 +514,9 @@ <H2>Thread support</h2>\n We support several different threading models.  Unfortunately Pthreads,\n the only reasonably well standardized thread model, supports too narrow\n an interface for conservative garbage collection.  There appears to be\n-no completely portable way to allow the collector to coexist with various Pthreads\n-implementations.  Hence we currently support only a few of the more\n+no completely portable way to allow the collector\n+to coexist with various Pthreads\n+implementations.  Hence we currently support only the more\n common Pthreads implementations.\n <P>\n In particular, it is very difficult for the collector to stop all other\n@@ -510,6 +546,10 @@ <H2>Thread support</h2>\n (really <TT>gc_pthread_redirects.h</tt>), or optionally\n by using ld's function call wrapping mechanism under Linux.\n <P>\n+Recent versions of the collector support several facilites to enhance\n+the processor-scalability and thread performance of the collector.\n+These are discussed in more detail <A HREF=\"scale.html\">here</a>.\n+<P>\n Comments are appreciated.  Please send mail to\n <A HREF=\"mailto:boehm@acm.org\"><TT>boehm@acm.org</tt></a> or\n <A HREF=\"mailto:Hans.Boehm@hp.com\"><TT>Hans.Boehm@hp.com</tt></a>"}, {"sha": "9bd9e060688f881e3b07c89681c111084a57db15", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 106, "deletions": 8, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -91,10 +91,18 @@\n /* Newer versions of GNU/Linux define this macro.  We\n  * define it similarly for any ELF systems that don't.  */\n #  ifndef ElfW\n-#    if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n-#      define ElfW(type) Elf32_##type\n+#    ifdef __NetBSD__\n+#      if ELFSIZE == 32\n+#        define ElfW(type) Elf32_##type\n+#      else\n+#        define ElfW(type) Elf64_##type\n+#      endif\n #    else\n-#      define ElfW(type) Elf64_##type\n+#      if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32\n+#        define ElfW(type) Elf32_##type\n+#      else\n+#        define ElfW(type) Elf64_##type\n+#      endif\n #    endif\n #  endif\n \n@@ -552,6 +560,7 @@ extern void * GC_roots_present();\n \t/* The type is a lie, since the real type doesn't make sense here, */\n \t/* and we only test for NULL.\t\t\t\t\t   */\n \n+\n /* We use /proc to track down all parts of the address space that are\t*/\n /* mapped by the process, and throw out regions we know we shouldn't\t*/\n /* worry about.  This may also work under other SVR4 variants.\t\t*/\n@@ -726,6 +735,90 @@ void GC_register_dynamic_libraries()\n   \n # define HAVE_REGISTER_MAIN_STATIC_DATA\n \n+  GC_bool GC_warn_fb = TRUE;\t/* Warn about traced likely \t*/\n+  \t\t\t\t/* graphics memory.\t\t*/\n+  GC_bool GC_disallow_ignore_fb = FALSE;\n+  int GC_ignore_fb_mb;\t/* Ignore mappings bigger than the \t*/\n+  \t\t\t/* specified number of MB.\t\t*/\n+  GC_bool GC_ignore_fb = FALSE; /* Enable frame buffer \t*/\n+  \t\t\t\t/* checking.\t\t*/\n+  \n+  /* Issue warning if tracing apparent framebuffer. \t\t*/\n+  /* This limits us to one warning, and it's a back door to\t*/\n+  /* disable that.\t\t\t\t\t\t*/\n+ \n+  /* Should [start, start+len) be treated as a frame buffer\t*/\n+  /* and ignored?\t\t\t\t\t\t*/\n+  /* Unfortunately, we currently have no real way to tell\t*/\n+  /* automatically, and rely largely on user input.\t\t*/\n+  /* FIXME: If we had more data on this phenomenon (e.g.\t*/\n+  /* is start aligned to a MB multiple?) we should be able to\t*/\n+  /* do better.\t\t\t\t\t\t\t*/\n+  /* Based on a very limited sample, it appears that:\t\t*/\n+  /* \t- Frame buffer mappings appear as mappings of length\t*/\n+  /* \t  2**n MB - 192K.  (We guess the 192K can vary a bit.)\t*/\n+  /*\t- Have a stating address at best 64K aligned.\t\t*/\n+  /* I'd love more information about the mapping, since I\t*/\n+  /* can't reproduce the problem.\t\t\t\t*/\n+  static GC_bool is_frame_buffer(ptr_t start, size_t len)\n+  {\n+    static GC_bool initialized = FALSE;\n+#   define MB (1024*1024)\n+#   define DEFAULT_FB_MB 15\n+#   define MIN_FB_MB 3\n+\n+    if (GC_disallow_ignore_fb) return FALSE;\n+    if (!initialized) {\n+      char * ignore_fb_string =  GETENV(\"GC_IGNORE_FB\");\n+\n+      if (0 != ignore_fb_string) {\n+\twhile (*ignore_fb_string == ' ' || *ignore_fb_string == '\\t')\n+\t  ++ignore_fb_string;\n+\tif (*ignore_fb_string == '\\0') {\n+\t  GC_ignore_fb_mb = DEFAULT_FB_MB;\n+\t} else {\n+\t  GC_ignore_fb_mb = atoi(ignore_fb_string);\n+\t  if (GC_ignore_fb_mb < MIN_FB_MB) {\n+\t    WARN(\"Bad GC_IGNORE_FB value.  Using %ld\\n\", DEFAULT_FB_MB);\n+\t    GC_ignore_fb_mb = DEFAULT_FB_MB;\n+\t  }\n+\t}\n+\tGC_ignore_fb = TRUE;\n+      } else {\n+\tGC_ignore_fb_mb = DEFAULT_FB_MB;  /* For warning */\n+      }\n+      initialized = TRUE;\n+    }\n+    if (len >= ((size_t)GC_ignore_fb_mb << 20)) {\n+      if (GC_ignore_fb) {\n+\treturn TRUE;\n+      } else {\n+\tif (GC_warn_fb) {\n+\t  WARN(\"Possible frame buffer mapping at 0x%lx: \\n\"\n+\t       \"\\tConsider setting GC_IGNORE_FB to improve performance.\\n\",\n+\t       start);\n+\t  GC_warn_fb = FALSE;\n+\t}\n+\treturn FALSE;\n+      }\n+    } else {\n+      return FALSE;\n+    }\n+  }\n+\n+# ifdef DEBUG_VIRTUALQUERY\n+  void GC_dump_meminfo(MEMORY_BASIC_INFORMATION *buf)\n+  {\n+    GC_printf4(\"BaseAddress = %lx, AllocationBase = %lx, RegionSize = %lx(%lu)\\n\",\n+\t       buf -> BaseAddress, buf -> AllocationBase, buf -> RegionSize,\n+\t       buf -> RegionSize);\n+    GC_printf4(\"\\tAllocationProtect = %lx, State = %lx, Protect = %lx, \"\n+\t       \"Type = %lx\\n\",\n+\t       buf -> AllocationProtect, buf -> State, buf -> Protect,\n+\t       buf -> Type);\n+  }\n+# endif /* DEBUG_VIRTUALQUERY */\n+\n   void GC_register_dynamic_libraries()\n   {\n     MEMORY_BASIC_INFORMATION buf;\n@@ -762,7 +855,11 @@ void GC_register_dynamic_libraries()\n \t    if (buf.State == MEM_COMMIT\n \t\t&& (protect == PAGE_EXECUTE_READWRITE\n \t\t    || protect == PAGE_READWRITE)\n-\t\t&& !GC_is_heap_base(buf.AllocationBase)) {\n+\t\t&& !GC_is_heap_base(buf.AllocationBase)\n+\t\t&& !is_frame_buffer(p, buf.RegionSize)) {  \n+#\t        ifdef DEBUG_VIRTUALQUERY\n+\t          GC_dump_meminfo(&buf);\n+#\t        endif\n \t\tif ((char *)p != limit) {\n \t\t    GC_cond_add_roots(base, limit);\n \t\t    base = p;\n@@ -980,12 +1077,13 @@ void GC_register_dynamic_libraries()\n \n #ifdef DARWIN\n \n+/* __private_extern__ hack required for pre-3.4 gcc versions.\t*/\n #ifndef __private_extern__\n-#define __private_extern__ extern\n-#include <mach-o/dyld.h>\n-#undef __private_extern__\n+# define __private_extern__ extern\n+# include <mach-o/dyld.h>\n+# undef __private_extern__\n #else\n-#include <mach-o/dyld.h>\n+# include <mach-o/dyld.h>\n #endif\n #include <mach-o/getsect.h>\n "}, {"sha": "e103228c2af135f5a4ae596f7163d849ad105b8f", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -807,8 +807,37 @@ void (* GC_finalizer_notifier)() = (void (*) GC_PROTO((void)))0;\n \n static GC_word last_finalizer_notification = 0;\n \n+#ifdef KEEP_BACK_PTRS\n+void GC_generate_random_backtrace_no_gc(void);\n+#endif\n+\n void GC_notify_or_invoke_finalizers GC_PROTO((void))\n {\n+    /* This is a convenient place to generate backtraces if appropriate, */\n+    /* since that code is not callable with the allocation lock.\t */\n+#   ifdef KEEP_BACK_PTRS\n+      if (GC_backtraces > 0) {\n+\tstatic word last_back_trace_gc_no = 3;\t/* Skip early ones. */\n+\tlong i;\n+\n+\tLOCK();\n+\tif (GC_gc_no > last_back_trace_gc_no) {\n+\t  /* Stops when GC_gc_no wraps; that's OK.\t*/\n+\t    last_back_trace_gc_no = (word)(-1);  /* disable others. */\n+\t    for (i = 0; i < GC_backtraces; ++i) {\n+\t      /* FIXME: This tolerates concurrent heap mutation,\t*/\n+\t      /* which may cause occasional mysterious results.\t\t*/\n+\t      /* We need to release the GC lock, since GC_print_callers\t*/\n+\t      /* acquires it.  It probably shouldn't.\t\t\t*/\n+\t      UNLOCK();\n+\t      GC_generate_random_backtrace_no_gc();\n+\t      LOCK();\n+\t    }\n+\t    last_back_trace_gc_no = GC_gc_no;\n+\t}\n+\tUNLOCK();\n+      }\n+#   endif\n     if (GC_finalize_now == 0) return;\n     if (!GC_finalize_on_demand) {\n \t(void) GC_invoke_finalizers();"}, {"sha": "2aaef795d923ef33a64825661faf4dff5ffdf3c0", "filename": "boehm-gc/gcj_mlc.c", "status": "modified", "additions": 49, "deletions": 33, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -14,8 +14,6 @@\n  */\n /* Boehm, July 31, 1995 5:02 pm PDT */\n \n-#ifdef GC_GCJ_SUPPORT\n-\n /*\n  * This is an allocator interface tuned for gcj (the GNU static\n  * java compiler).\n@@ -40,6 +38,8 @@\n #include \"gc_gcj.h\"\n #include \"private/dbg_mlc.h\"\n \n+#ifdef GC_GCJ_SUPPORT\n+\n GC_bool GC_gcj_malloc_initialized = FALSE;\n \n int GC_gcj_kind;\t/* Object kind for objects with descriptors     */\n@@ -72,46 +72,36 @@ void GC_init_gcj_malloc(int mp_index, void * /* really GC_mark_proc */mp)\n         GC_printf0(\"Gcj-style type information is disabled!\\n\");\n       }\n #   endif\n+    GC_ASSERT(GC_mark_procs[mp_index] == (GC_mark_proc)0); /* unused */\n     GC_mark_procs[mp_index] = (GC_mark_proc)mp;\n     if (mp_index >= GC_n_mark_procs) ABORT(\"GC_init_gcj_malloc: bad index\");\n     /* Set up object kind gcj-style indirect descriptor. */\n-      GC_gcjobjfreelist = (ptr_t *)\n-          GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n-      if (GC_gcjobjfreelist == 0) ABORT(\"Couldn't allocate GC_gcjobjfreelist\");\n-      BZERO(GC_gcjobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n-      GC_gcj_kind = GC_n_kinds++;\n-      GC_obj_kinds[GC_gcj_kind].ok_freelist = GC_gcjobjfreelist;\n-      GC_obj_kinds[GC_gcj_kind].ok_reclaim_list = 0;\n+      GC_gcjobjfreelist = (ptr_t *)GC_new_free_list_inner();\n       if (ignore_gcj_info) {\n \t/* Use a simple length-based descriptor, thus forcing a fully\t*/\n \t/* conservative scan.\t\t\t\t\t\t*/\n-        GC_obj_kinds[GC_gcj_kind].ok_descriptor = (0 | GC_DS_LENGTH);\n-        GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = TRUE;\n+\tGC_gcj_kind = GC_new_kind_inner((void **)GC_gcjobjfreelist,\n+\t\t\t\t\t(0 | GC_DS_LENGTH),\n+\t\t\t\t        TRUE, TRUE);\n       } else {\n-\tGC_obj_kinds[GC_gcj_kind].ok_descriptor =\n-    \t  (((word)(-MARK_DESCR_OFFSET - GC_INDIR_PER_OBJ_BIAS))\n-\t   | GC_DS_PER_OBJECT);\n-        GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = FALSE;\n+\tGC_gcj_kind = GC_new_kind_inner(\n+\t\t\t(void **)GC_gcjobjfreelist,\n+\t\t\t(((word)(-MARK_DESCR_OFFSET - GC_INDIR_PER_OBJ_BIAS))\n+\t   \t\t | GC_DS_PER_OBJECT),\n+\t\t\tFALSE, TRUE);\n       }\n-      GC_obj_kinds[GC_gcj_kind].ok_init = TRUE;\n     /* Set up object kind for objects that require mark proc call.\t*/\n-      GC_gcjdebugobjfreelist = (ptr_t *)\n-          GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n-      if (GC_gcjdebugobjfreelist == 0)\n-\t  ABORT(\"Couldn't allocate GC_gcjdebugobjfreelist\");\n-      BZERO(GC_gcjdebugobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n-      GC_gcj_debug_kind = GC_n_kinds++;\n-      GC_obj_kinds[GC_gcj_debug_kind].ok_freelist = GC_gcjdebugobjfreelist;\n-      GC_obj_kinds[GC_gcj_debug_kind].ok_reclaim_list = 0;\n       if (ignore_gcj_info) {\n-        GC_obj_kinds[GC_gcj_kind].ok_descriptor = (0 | GC_DS_LENGTH);\n-        GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = TRUE;\n+\tGC_gcj_debug_kind = GC_gcj_kind;\n+        GC_gcjdebugobjfreelist = GC_gcjobjfreelist;\n       } else {\n-        GC_obj_kinds[GC_gcj_debug_kind].ok_descriptor =\n-    \t  GC_MAKE_PROC(mp_index, 1 /* allocated with debug info */);\n-        GC_obj_kinds[GC_gcj_debug_kind].ok_relocate_descr = FALSE;\n+        GC_gcjdebugobjfreelist = (ptr_t *)GC_new_free_list_inner();\n+\tGC_gcj_debug_kind = GC_new_kind_inner(\n+\t\t\t\t(void **)GC_gcjdebugobjfreelist,\n+\t\t\t\tGC_MAKE_PROC(mp_index,\n+\t\t\t\t     \t     1 /* allocated with debug info */),\n+\t\t\t\tFALSE, TRUE);\n       }\n-      GC_obj_kinds[GC_gcj_debug_kind].ok_init = TRUE;\n     UNLOCK();\n     ENABLE_SIGNALS();\n }\n@@ -124,6 +114,25 @@ ptr_t GC_clear_stack();\n #define GENERAL_MALLOC_IOP(lb,k) \\\n     (GC_PTR)GC_clear_stack(GC_generic_malloc_inner_ignore_off_page(lb, k))\n \n+/* We need a mechanism to release the lock and invoke finalizers.\t*/\n+/* We don't really have an opportunity to do this on a rarely executed\t*/\n+/* path on which the lock is not held.  Thus we check at a \t\t*/\n+/* rarely executed point at which it is safe to release the lock.\t*/\n+/* We do this even where we could just call GC_INVOKE_FINALIZERS,\t*/\n+/* since it's probably cheaper and certainly more uniform.\t\t*/\n+/* FIXME - Consider doing the same elsewhere?\t\t\t\t*/\n+static void maybe_finalize()\n+{\n+   static int last_finalized_no = 0;\n+\n+   if (GC_gc_no == last_finalized_no) return;\n+   if (!GC_is_initialized) return;\n+   UNLOCK();\n+   GC_INVOKE_FINALIZERS();\n+   last_finalized_no = GC_gc_no;\n+   LOCK();\n+}\n+\n /* Allocate an object, clear it, and store the pointer to the\t*/\n /* type structure (vtable in gcj).\t\t\t\t*/\n /* This adds a byte at the end of the object if GC_malloc would.*/\n@@ -143,7 +152,8 @@ DCL_LOCK_STATE;\n \topp = &(GC_gcjobjfreelist[lw]);\n \tLOCK();\n \top = *opp;\n-        if( EXPECT(op == 0, 0)) {\n+        if(EXPECT(op == 0, 0)) {\n+\t    maybe_finalize();\n             op = (ptr_t)GENERAL_MALLOC((word)lb, GC_gcj_kind);\n \t    if (0 == op) {\n \t\tUNLOCK();\n@@ -161,6 +171,7 @@ DCL_LOCK_STATE;\n \tUNLOCK();\n     } else {\n \tLOCK();\n+\tmaybe_finalize();\n \top = (ptr_t)GENERAL_MALLOC((word)lb, GC_gcj_kind);\n \tif (0 == op) {\n \t    UNLOCK();\n@@ -179,10 +190,10 @@ GC_PTR GC_debug_gcj_malloc(size_t lb, void * ptr_to_struct_containing_descr,\n {\n     GC_PTR result;\n \n-    /* We clone the code from GC_debug_gcj_malloc, so that we \t*/\n-    /* dont end up with extra frames on the stack, which could\t*/\n+    /* We're careful to avoid extra calls, which could\t\t */\n     /* confuse the backtrace.\t\t\t\t\t*/\n     LOCK();\n+    maybe_finalize();\n     result = GC_generic_malloc_inner(lb + DEBUG_BYTES, GC_gcj_debug_kind);\n     if (result == 0) {\n \tUNLOCK();\n@@ -215,6 +226,7 @@ DCL_LOCK_STATE;\n     LOCK();\n     op = *opp;\n     if( EXPECT(op == 0, 0) ) {\n+\tmaybe_finalize();\n         op = (ptr_t)GC_clear_stack(\n \t\tGC_generic_malloc_words_small_inner(lw, GC_gcj_kind));\n \tif (0 == op) {\n@@ -242,6 +254,7 @@ void * GC_debug_gcj_fast_malloc(size_t lw,\n     /* dont end up with extra frames on the stack, which could\t*/\n     /* confuse the backtrace.\t\t\t\t\t*/\n     LOCK();\n+    maybe_finalize();\n     result = GC_generic_malloc_inner(lb + DEBUG_BYTES, GC_gcj_debug_kind);\n     if (result == 0) {\n \tUNLOCK();\n@@ -278,6 +291,7 @@ DCL_LOCK_STATE;\n \topp = &(GC_gcjobjfreelist[lw]);\n \tLOCK();\n         if( (op = *opp) == 0 ) {\n+\t    maybe_finalize();\n             op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_gcj_kind);\n #\t    ifdef MERGE_SIZES\n \t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/\n@@ -289,6 +303,8 @@ DCL_LOCK_STATE;\n \t*(void **)op = ptr_to_struct_containing_descr;\n \tUNLOCK();\n     } else {\n+\tLOCK();\n+\tmaybe_finalize();\n         op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_gcj_kind);\n         if (0 != op) {\n           *(void **)op = ptr_to_struct_containing_descr;"}, {"sha": "b7be1d84930be9fb4d54fd59b70572815deb8eda", "filename": "boehm-gc/headers.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fheaders.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fheaders.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fheaders.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -206,7 +206,7 @@ register struct hblk * h;\n {\n     hdr * result;\n     \n-    if (!get_index((word) h)) return(FALSE);\n+    if (!get_index((word) h)) return(0);\n     result = alloc_hdr();\n     SET_HDR(h, result);\n #   ifdef USE_MUNMAP"}, {"sha": "8691e925920eabc542710ca22c9dc9247485cf69", "filename": "boehm-gc/if_not_there.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fif_not_there.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fif_not_there.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_not_there.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -4,19 +4,31 @@\n # include <stdio.h>\n # include <stdlib.h>\n # include <unistd.h>\n+#ifdef __DJGPP__\n+#include <dirent.h>\n+#endif /* __DJGPP__ */\n \n int main(argc, argv, envp)\n int argc;\n char ** argv;\n char ** envp;\n {\n     FILE * f;\n+#ifdef __DJGPP__\n+    DIR * d;\n+#endif /* __DJGPP__ */\n     if (argc < 3) goto Usage;\n     if ((f = fopen(argv[1], \"rb\")) != 0\n         || (f = fopen(argv[1], \"r\")) != 0) {\n         fclose(f);\n         return(0);\n     }\n+#ifdef __DJGPP__\n+    if ((d = opendir(argv[1])) != 0) {\n+\t    closedir(d);\n+\t    return(0);\n+    }\n+#endif\n     printf(\"^^^^Starting command^^^^\\n\");\n     fflush(stdout);\n     execvp(argv[2], argv+2);"}, {"sha": "825bac4ded05c0ee3be1e0c685899a840b12ad0f", "filename": "boehm-gc/include/Makefile.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2FMakefile.in?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated by automake 1.8.5 from Makefile.am.\n+# Makefile.in generated by automake 1.9 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n@@ -135,6 +135,8 @@ am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n bindir = @bindir@\n build = @build@\n build_alias = @build_alias@\n@@ -318,7 +320,7 @@ mostlyclean-generic:\n clean-generic:\n \n distclean-generic:\n-\t-rm -f $(CONFIG_CLEAN_FILES)\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n \n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\""}, {"sha": "e1f2aa8f80fe75b154125e46eece81f4bc4b572e", "filename": "boehm-gc/include/gc.h", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -30,6 +30,7 @@\n \n # define _GC_H\n \n+# include <gc_config.h>\n # include \"gc_config_macros.h\"\n \n # if defined(__STDC__) || defined(__cplusplus)\n@@ -52,11 +53,18 @@\n /* even semi-portably.  The following is probably no better/worse \t*/\n /* than almost anything else.\t\t\t\t\t\t*/\n /* The ANSI standard suggests that size_t and ptr_diff_t might be \t*/\n-/* better choices.  But those appear to have incorrect definitions\t*/\n-/* on may systems.  Notably \"typedef int size_t\" seems to be both\t*/\n-/* frequent and WRONG.\t\t\t\t\t\t\t*/\n-typedef unsigned long GC_word;\n-typedef long GC_signed_word;\n+/* better choices.  But those had incorrect definitions on some older\t*/\n+/* systems.  Notably \"typedef int size_t\" is WRONG.\t\t\t*/\n+#ifndef _WIN64\n+  typedef unsigned long GC_word;\n+  typedef long GC_signed_word;\n+#else\n+  /* Win64 isn't really supported yet, but this is the first step. And\t*/\n+  /* it might cause error messages to show up in more plausible places.\t*/\n+  /* This needs basetsd.h, which is included by windows.h.\t \t*/\n+  typedef ULONG_PTR GC_word;\n+  typedef LONG_PTR GC_word;\n+#endif\n \n /* Public read-only variables */\n \n@@ -247,6 +255,7 @@ GC_API unsigned long GC_time_limit;\n  * allocation, since unlike the regular allocation routines, GC_local_malloc\n  * is not self-initializing.  If you use GC_local_malloc you should arrange\n  * to call this somehow (e.g. from a constructor) before doing any allocation.\n+ * For win32 threads, it needs to be called explicitly.\n  */\n GC_API void GC_init GC_PROTO((void));\n \n@@ -470,14 +479,19 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n # include <features.h>\n # if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1 || __GLIBC__ > 2) \\\n      && !defined(__ia64__)\n-#   define GC_HAVE_BUILTIN_BACKTRACE\n-#   define GC_CAN_SAVE_CALL_STACKS\n+#   ifndef GC_HAVE_BUILTIN_BACKTRACE\n+#     define GC_HAVE_BUILTIN_BACKTRACE\n+#   endif\n # endif\n # if defined(__i386__) || defined(__x86_64__)\n #   define GC_CAN_SAVE_CALL_STACKS\n # endif\n #endif\n \n+#if defined(GC_HAVE_BUILTIN_BACKTRACE) && !defined(GC_CAN_SAVE_CALL_STACKS)\n+# define GC_CAN_SAVE_CALL_STACKS\n+#endif\n+\n #if defined(__sparc__)\n #   define GC_CAN_SAVE_CALL_STACKS\n #endif\n@@ -604,7 +618,7 @@ GC_API GC_PTR GC_debug_realloc_replacement\n \n /* Finalization.  Some of these primitives are grossly unsafe.\t\t*/\n /* The idea is to make them both cheap, and sufficient to build\t\t*/\n-/* a safer layer, closer to PCedar finalization.\t\t\t*/\n+/* a safer layer, closer to Modula-3, Java, or PCedar finalization.\t*/\n /* The interface represents my conclusions from a long discussion\t*/\n /* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, \t\t*/\n /* Christian Jacobi, and Russ Atkinson.  It's not perfect, and\t\t*/\n@@ -774,6 +788,7 @@ GC_API GC_PTR GC_call_with_alloc_lock\n \n /* The following routines are primarily intended for use with a \t*/\n /* preprocessor which inserts calls to check C pointer arithmetic.\t*/\n+/* They indicate failure by invoking the corresponding _print_proc.\t*/\n \n /* Check that p and q point to the same object.  \t\t*/\n /* Fail conspicuously if they don't.\t\t\t\t*/\n@@ -851,7 +866,7 @@ GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n #   define GC_PTR_STORE(p, q) *((p) = (q))\n #endif\n \n-/* Fynctions called to report pointer checking errors */\n+/* Functions called to report pointer checking errors */\n GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));\n \n GC_API void (*GC_is_valid_displacement_print_proc)\n@@ -919,13 +934,19 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n \n #endif /* defined(GC_WIN32_THREADS)  && !cygwin */\n \n-/*\n- * If you are planning on putting\n- * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n- * from the statically loaded program section.\n- * This circumvents a Solaris 2.X (X<=4) linker bug.\n- */\n-#if defined(sparc) || defined(__sparc)\n+ /*\n+  * Fully portable code should call GC_INIT() from the main program\n+  * before making any other GC_ calls.  On most platforms this is a\n+  * no-op and the collector self-initializes.  But a number of platforms\n+  * make that too hard.\n+  */\n+#if (defined(sparc) || defined(__sparc)) && defined(sun)\n+    /*\n+     * If you are planning on putting\n+     * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n+     * from the statically loaded program section.\n+     * This circumvents a Solaris 2.X (X<=4) linker bug.\n+     */\n #   define GC_INIT() { extern end, etext; \\\n \t\t       GC_noop(&end, &etext); }\n #else\n@@ -936,13 +957,13 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n      */\n #   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n # else\n-#  if defined(__APPLE__) && defined(__MACH__)\n+#  if defined(__APPLE__) && defined(__MACH__) || defined(GC_WIN32_THREADS)\n #   define GC_INIT() { GC_init(); }\n #  else\n #   define GC_INIT()\n-#  endif\n-# endif\n-#endif\n+#  endif /* !__MACH && !GC_WIN32_THREADS */\n+# endif /* !AIX && !cygwin */\n+#endif /* !sparc */\n \n #if !defined(_WIN32_WCE) \\\n     && ((defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\"}, {"sha": "fbd244610aa98ad3f9c1e3ee5cdde02b3f67b205", "filename": "boehm-gc/include/gc_config.h.in", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config.h.in?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -0,0 +1,34 @@\n+#undef ALL_INTERIOR_POINTERS\n+#undef ATOMIC_UNCOLLECTABLE\n+#undef DATASTART_IS_ETEXT\n+#undef DBG_HDRS_ALL\n+#undef DGUX_THREADS\n+#undef ECOS\n+#undef GC_AIX_THREADS\n+#undef GC_DARWIN_THREADS\n+#undef GC_DGUX386_THREADS\n+#undef GC_FREEBSD_THREADS\n+#undef GC_GCJ_SUPPORT\n+#undef GC_HPUX_THREADS\n+#undef GC_IRIX_THREADS\n+#undef GC_LINUX_THREADS\n+#undef GC_OSF1_THREADS\n+#undef GC_SOLARIS_PTHREADS\n+#undef GC_SOLARIS_THREADS\n+#undef GC_WIN32_THREADS\n+#undef JAVA_FINALIZATION\n+#undef KEEP_BACK_PTRS\n+#undef MAKE_BACK_GRAPH\n+#undef NO_DEBUGGING\n+#undef NO_EXECUTE_PERMISSION\n+#undef NO_SIGNALS\n+#undef NO_SIGSET\n+#undef PARALLEL_MARK\n+#undef SAVE_CALL_COUNT\n+#undef SILENT\n+#undef SOLARIS25_PROC_VDB_BUG_FIXED\n+#undef STACKBASE\n+#undef SUNOS53_SHARED_LIB\n+#undef THREAD_LOCAL_ALLOC\n+#undef _POSIX_C_SOURCE\n+#undef _REENTRANT"}, {"sha": "90c574ed43cb4f17479f1b6f612fb6288321ffdd", "filename": "boehm-gc/include/gc_config_macros.h", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_config_macros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_config_macros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_config_macros.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,43 +1,7 @@\n /*\n  * This should never be included directly.  It is included only from gc.h.\n  * We separate it only to make gc.h more suitable as documentation.\n- * \n- * Some tests for old macros.  These violate our namespace rules and will\n- * disappear shortly.  Use the GC_ names.\n  */\n-#if defined(SOLARIS_THREADS) || defined(_SOLARIS_THREADS)\n-# define GC_SOLARIS_THREADS\n-#endif\n-#if defined(_SOLARIS_PTHREADS)\n-# define GC_SOLARIS_PTHREADS\n-#endif\n-#if defined(IRIX_THREADS)\n-# define GC_IRIX_THREADS\n-#endif\n-#if defined(DGUX_THREADS)\n-# if !defined(GC_DGUX386_THREADS)\n-#  define GC_DGUX386_THREADS\n-# endif\n-#endif\n-#if defined(AIX_THREADS)\n-# define GC_AIX_THREADS\n-#endif\n-#if defined(HPUX_THREADS)\n-# define GC_HPUX_THREADS\n-#endif\n-#if defined(OSF1_THREADS)\n-# define GC_OSF1_THREADS\n-#endif\n-#if defined(LINUX_THREADS)\n-# define GC_LINUX_THREADS\n-#endif\n-#if defined(WIN32_THREADS)\n-# define GC_WIN32_THREADS\n-#endif\n-#if defined(USE_LD_WRAP)\n-# define GC_USE_LD_WRAP\n-#endif\n-\n #if !defined(_REENTRANT) && (defined(GC_SOLARIS_THREADS) \\\n \t\t             || defined(GC_SOLARIS_PTHREADS) \\\n \t\t\t     || defined(GC_HPUX_THREADS) \\"}, {"sha": "c4d8b50e6b92d9c943032a19e0fd334f08be5371", "filename": "boehm-gc/include/gc_cpp.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_cpp.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -152,6 +152,11 @@ by UseGC.  GC is an alias for UseGC, unless GC_NAME_CONFLICT is defined.\n #   define GC_OPERATOR_NEW_ARRAY\n #endif\n \n+#if    ! defined ( __BORLANDC__ )  /* Confuses the Borland compiler. */ \\\n+    && ! defined ( __sgi )\n+#  define GC_PLACEMENT_DELETE\n+#endif\n+\n enum GCPlacement {UseGC,\n #ifndef GC_NAME_CONFLICT\n \t\t  GC=UseGC,\n@@ -165,7 +170,7 @@ class gc {public:\n     \t/* Must be redefined here, since the other overloadings\t*/\n     \t/* hide the global definition.\t\t\t\t*/\n     inline void operator delete( void* obj );\n-#   ifndef __BORLANDC__  /* Confuses the Borland compiler. */\n+#   ifdef GC_PLACEMENT_DELETE  \n       inline void operator delete( void*, void* );\n #   endif\n \n@@ -174,7 +179,7 @@ class gc {public:\n     inline void* operator new[]( size_t size, GCPlacement gcp );\n     inline void* operator new[]( size_t size, void *p );\n     inline void operator delete[]( void* obj );\n-#   ifndef __BORLANDC__\n+#   ifdef GC_PLACEMENT_DELETE\n       inline void gc::operator delete[]( void*, void* );\n #   endif\n #endif /* GC_OPERATOR_NEW_ARRAY */\n@@ -282,7 +287,7 @@ inline void* gc::operator new( size_t size, void *p ) {\n inline void gc::operator delete( void* obj ) {\n     GC_FREE( obj );}\n     \n-#ifndef __BORLANDC__\n+#ifdef GC_PLACEMENT_DELETE\n   inline void gc::operator delete( void*, void* ) {}\n #endif\n \n@@ -300,7 +305,7 @@ inline void* gc::operator new[]( size_t size, void *p ) {\n inline void gc::operator delete[]( void* obj ) {\n     gc::operator delete( obj );}\n \n-#ifndef __BORLANDC__\n+#ifdef GC_PLACEMENT_DELETE\n   inline void gc::operator delete[]( void*, void* ) {}\n #endif\n     "}, {"sha": "5e79e27b821606f267944e7da5df840fe56cd0be", "filename": "boehm-gc/include/gc_gcj.h", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_gcj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_gcj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_gcj.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -53,7 +53,7 @@\n /* respectively for the allocated objects.  Mark_proc will be \t\t*/\n /* used to build the descriptor for objects allocated through the\t*/\n /* debugging interface.  The mark_proc will be invoked on all such \t*/\n-/* objects with an \"environment\" value of 1.  The client may chose\t*/\n+/* objects with an \"environment\" value of 1.  The client may choose\t*/\n /* to use the same mark_proc for some of its generated mark descriptors.*/\n /* In that case, it should use a different \"environment\" value to\t*/\n /* detect the presence or absence of the debug header.\t\t\t*/\n@@ -88,6 +88,17 @@ extern void * GC_debug_gcj_fast_malloc(size_t lw,\n extern void * GC_gcj_malloc_ignore_off_page(size_t lb,\n \t\t\t\tvoid * ptr_to_struct_containing_descr);\n \n+/* The kind numbers of normal and debug gcj objects.\t\t*/\n+/* Useful only for debug support, we hope.\t\t\t*/\n+extern int GC_gcj_kind;\n+\n+extern int GC_gcj_debug_kind;\n+\n+# if defined(GC_LOCAL_ALLOC_H) && defined(GC_REDIRECT_TO_LOCAL)\n+    --> gc_local_alloc.h should be included after this.  Otherwise\n+    --> we undo the redirection.\n+# endif\n+\n # ifdef GC_DEBUG\n #   define GC_GCJ_MALLOC(s,d) GC_debug_gcj_malloc(s,d,GC_EXTRAS)\n #   define GC_GCJ_FAST_MALLOC(s,d) GC_debug_gcj_fast_malloc(s,d,GC_EXTRAS)"}, {"sha": "1874c7b6d209564102cf4cf0651c70ad36bbff1e", "filename": "boehm-gc/include/gc_local_alloc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_local_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_local_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_local_alloc.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -61,6 +61,7 @@ GC_PTR GC_local_malloc_atomic(size_t bytes);\n #endif\n \n # ifdef GC_DEBUG\n+    /* We don't really use local allocation in this case.\t*/\n #   define GC_LOCAL_MALLOC(s) GC_debug_malloc(s,GC_EXTRAS)\n #   define GC_LOCAL_MALLOC_ATOMIC(s) GC_debug_malloc_atomic(s,GC_EXTRAS)\n #   ifdef GC_GCJ_SUPPORT"}, {"sha": "953bb74dc084c0e1870c05d203a5a3493ffebc73", "filename": "boehm-gc/include/gc_mark.h", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_mark.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -19,10 +19,8 @@\n  * This interface should not be used by normal C or C++ clients.\n  * It will be useful to runtimes for other languages.\n  * \n- * Note that this file is not \"namespace-clean\", i.e. it introduces names\n- * not prefixed with GC_, which may collide with the client's names.  It\n- * should be included only in those few places that directly provide\n- * information to the collector.\n+ * This is an experts-only interface!  There are many ways to break the\n+ * collector in subtle ways by using this functionality.\n  */\n #ifndef GC_MARK_H\n # define GC_MARK_H\n@@ -143,5 +141,63 @@ struct GC_ms_entry *GC_mark_and_push\n \t  GC_mark_and_push(obj, msp, lim, src) : \\\n \t  msp)\n \n+extern size_t GC_debug_header_size;\n+       /* The size of the header added to objects allocated through    */\n+       /* the GC_debug routines.                                       */\n+       /* Defined as a variable so that client mark procedures don't   */\n+       /* need to be recompiled for collector version changes.         */\n+#define GC_USR_PTR_FROM_BASE(p) ((GC_PTR)((char *)(p) + GC_debug_header_size))\n+\n+/* And some routines to support creation of new \"kinds\", e.g. with\t*/\n+/* custom mark procedures, by language runtimes.\t\t\t*/\n+/* The _inner versions assume the caller holds the allocation lock.\t*/\n+\n+/* Return a new free list array.\t*/\n+void ** GC_new_free_list GC_PROTO((void));\n+void ** GC_new_free_list_inner GC_PROTO((void));\n+\n+/* Return a new kind, as specified. */\n+int GC_new_kind GC_PROTO((void **free_list, GC_word mark_descriptor_template,\n+\t\t          int add_size_to_descriptor, int clear_new_objects));\n+\t\t/* The last two parameters must be zero or one. */\n+int GC_new_kind_inner GC_PROTO((void **free_list,\n+\t\t\t\tGC_word mark_descriptor_template,\n+\t\t                int add_size_to_descriptor,\n+\t\t\t\tint clear_new_objects));\n+\n+/* Return a new mark procedure identifier, suitable for use as\t*/\n+/* the first argument in GC_MAKE_PROC.\t\t\t\t*/\n+int GC_new_proc GC_PROTO((GC_mark_proc));\n+int GC_new_proc_inner GC_PROTO((GC_mark_proc));\n+\n+/* Allocate an object of a given kind.  Note that in multithreaded\t*/\n+/* contexts, this is usually unsafe for kinds that have the descriptor\t*/\n+/* in the object itself, since there is otherwise a window in which\t*/\n+/* the descriptor is not correct.  Even in the single-threaded case,\t*/\n+/* we need to be sure that cleared objects on a free list don't\t\t*/\n+/* cause a GC crash if they are accidentally traced.\t\t\t*/\n+/* ptr_t */char * GC_generic_malloc GC_PROTO((GC_word lb, int k));\n+\n+/* FIXME - Should return void *, but that requires other changes.\t*/\n+\n+typedef void (*GC_describe_type_fn) GC_PROTO((void *p, char *out_buf));\n+\t\t\t\t/* A procedure which\t\t\t*/\n+\t\t\t\t/* produces a human-readable \t\t*/\n+\t\t\t\t/* description of the \"type\" of object\t*/\n+\t\t\t\t/* p into the buffer out_buf of length\t*/\n+\t\t\t\t/* GC_TYPE_DESCR_LEN.  This is used by\t*/\n+\t\t\t\t/* the debug support when printing \t*/\n+\t\t\t\t/* objects.\t\t\t\t*/ \n+\t\t\t\t/* These functions should be as robust\t*/\n+\t\t\t\t/* as possible, though we do avoid \t*/\n+\t\t\t\t/* invoking them on objects on the \t*/\n+\t\t\t\t/* global free list.\t\t\t*/\n+#\tdefine GC_TYPE_DESCR_LEN 40\n+\n+void GC_register_describe_type_fn GC_PROTO((int kind, GC_describe_type_fn knd));\n+\t\t\t\t/* Register a describe_type function\t*/\n+\t\t\t\t/* to be used when printing objects\t*/\n+\t\t\t\t/* of a particular kind.\t\t*/\n+\n #endif  /* GC_MARK_H */\n "}, {"sha": "23e01005afed3f7303029b42aa4d5ca200393652", "filename": "boehm-gc/include/javaxfc.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fjavaxfc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fjavaxfc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fjavaxfc.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -18,24 +18,4 @@\n  */\n void GC_finalize_all();\n \n-/*\n- * A version of GC_register_finalizer that allows the object to be\n- * finalized before the objects it references.  This is again error\n- * prone, in that it makes it easy to accidentally reference finalized\n- * objects.  Again, recommended only for JVM implementors.\n- */\n-void GC_register_finalizer_no_order(GC_PTR obj,\n-\t\t\t       GC_finalization_proc fn, GC_PTR cd,\n-\t\t\t       GC_finalization_proc *ofn, GC_PTR * ocd);\n-\n-void GC_debug_register_finalizer_no_order(GC_PTR obj,\n-\t\t\t       GC_finalization_proc fn, GC_PTR cd,\n-\t\t\t       GC_finalization_proc *ofn, GC_PTR * ocd);\n \n-#ifdef GC_DEBUG\n-#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n-#else\n-#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n-\tGC_register_finalizer_no_order(p, f, d, of, od)\n-#endif"}, {"sha": "f2219b7732da43c2a044a6d427215be4c7730138", "filename": "boehm-gc/include/new_gc_alloc.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fnew_gc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fnew_gc_alloc.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -393,12 +393,12 @@ __STL_END_NAMESPACE\n \n __STL_BEGIN_NAMESPACE\n \n-template <class _T>\n-struct _Alloc_traits<_T, gc_alloc >\n+template <class _Tp>\n+struct _Alloc_traits<_Tp, gc_alloc >\n {\n   static const bool _S_instanceless = true;\n-  typedef simple_alloc<_T, gc_alloc > _Alloc_type;\n-  typedef __allocator<_T, gc_alloc > allocator_type;\n+  typedef simple_alloc<_Tp, gc_alloc > _Alloc_type;\n+  typedef __allocator<_Tp, gc_alloc > allocator_type;\n };\n \n inline bool operator==(const gc_alloc&,\n@@ -413,12 +413,12 @@ inline bool operator!=(const gc_alloc&,\n   return false;\n }\n \n-template <class _T>\n-struct _Alloc_traits<_T, single_client_gc_alloc >\n+template <class _Tp>\n+struct _Alloc_traits<_Tp, single_client_gc_alloc >\n {\n   static const bool _S_instanceless = true;\n-  typedef simple_alloc<_T, single_client_gc_alloc > _Alloc_type;\n-  typedef __allocator<_T, single_client_gc_alloc > allocator_type;\n+  typedef simple_alloc<_Tp, single_client_gc_alloc > _Alloc_type;\n+  typedef __allocator<_Tp, single_client_gc_alloc > allocator_type;\n };\n \n inline bool operator==(const single_client_gc_alloc&,\n@@ -433,12 +433,12 @@ inline bool operator!=(const single_client_gc_alloc&,\n   return false;\n }\n \n-template <class _T>\n-struct _Alloc_traits<_T, traceable_alloc >\n+template <class _Tp>\n+struct _Alloc_traits<_Tp, traceable_alloc >\n {\n   static const bool _S_instanceless = true;\n-  typedef simple_alloc<_T, traceable_alloc > _Alloc_type;\n-  typedef __allocator<_T, traceable_alloc > allocator_type;\n+  typedef simple_alloc<_Tp, traceable_alloc > _Alloc_type;\n+  typedef __allocator<_Tp, traceable_alloc > allocator_type;\n };\n \n inline bool operator==(const traceable_alloc&,\n@@ -453,12 +453,12 @@ inline bool operator!=(const traceable_alloc&,\n   return false;\n }\n \n-template <class _T>\n-struct _Alloc_traits<_T, single_client_traceable_alloc >\n+template <class _Tp>\n+struct _Alloc_traits<_Tp, single_client_traceable_alloc >\n {\n   static const bool _S_instanceless = true;\n-  typedef simple_alloc<_T, single_client_traceable_alloc > _Alloc_type;\n-  typedef __allocator<_T, single_client_traceable_alloc > allocator_type;\n+  typedef simple_alloc<_Tp, single_client_traceable_alloc > _Alloc_type;\n+  typedef __allocator<_Tp, single_client_traceable_alloc > allocator_type;\n };\n \n inline bool operator==(const single_client_traceable_alloc&,"}, {"sha": "e0a994de5e2a64c1d095cc7e2c3b4d1a2fea9b34", "filename": "boehm-gc/include/private/dbg_mlc.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fdbg_mlc.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -123,7 +123,6 @@ typedef struct {\n #   define UNCOLLECTABLE_DEBUG_BYTES (sizeof (oh) + sizeof (word))\n #   define DEBUG_BYTES (UNCOLLECTABLE_DEBUG_BYTES - EXTRA_BYTES)\n #endif\n-#define USR_PTR_FROM_BASE(p) ((ptr_t)(p) + sizeof(oh))\n \n /* Round bytes to words without adding extra byte at end.\t*/\n #define SIMPLE_ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)"}, {"sha": "51981914dc5fcf71e5fa54680fdadc33c9390392", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -135,12 +135,7 @@ extern mse * GC_mark_stack;\n /* Return a pointer to within 1st page of object.  \t*/\n /* Set *new_hdr_p to corr. hdr.\t\t\t\t*/\n #ifdef __STDC__\n-# ifdef PRINT_BLACK_LIST\n-    ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p,\n-\t\t    \tword source);\n-# else\n-    ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p);\n-# endif\n+  ptr_t GC_find_start(ptr_t current, hdr *hhdr, hdr **new_hdr_p);\n #else\n   ptr_t GC_find_start();\n #endif"}, {"sha": "08dd8ea247b1083543c2a2d889d7d2bc8bb1de64", "filename": "boehm-gc/include/private/gc_priv.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_priv.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -550,7 +550,7 @@ extern GC_warn_proc GC_current_warn_proc;\n \n #define CPP_MAXOBJBYTES (CPP_HBLKSIZE/2)\n #define MAXOBJBYTES ((word)CPP_MAXOBJBYTES)\n-#define CPP_MAXOBJSZ    BYTES_TO_WORDS(CPP_HBLKSIZE/2)\n+#define CPP_MAXOBJSZ    BYTES_TO_WORDS(CPP_MAXOBJBYTES)\n #define MAXOBJSZ ((word)CPP_MAXOBJSZ)\n \t\t\n # define divHBLKSZ(n) ((n) >> LOG_HBLKSIZE)\n@@ -578,7 +578,7 @@ extern GC_warn_proc GC_current_warn_proc;\n # else\n #       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n # endif\n-# define SMALL_OBJ(bytes) ((bytes) < (MAXOBJBYTES - EXTRA_BYTES))\n+# define SMALL_OBJ(bytes) ((bytes) <= (MAXOBJBYTES - EXTRA_BYTES))\n # define ADD_SLOP(bytes) ((bytes) + EXTRA_BYTES)\n # ifndef MIN_WORDS\n     /* MIN_WORDS is the size of the smallest allocated object.\t*/\n@@ -615,6 +615,10 @@ extern GC_warn_proc GC_current_warn_proc;\n #     define LOG_PHT_ENTRIES  16 /* Collisions are likely if heap grows\t*/\n \t\t\t\t /* to more than 64K hblks >= 256MB.\t*/\n \t\t\t\t /* Each hash table occupies 8K bytes.  */\n+\t\t\t\t /* Even for somewhat smaller heaps, \t*/\n+\t\t\t\t /* say half that, collisions may be an\t*/\n+\t\t\t\t /* issue because we blacklist \t\t*/\n+\t\t\t\t /* addresses outside the heap.\t\t*/\n #   endif\n # endif\n # define PHT_ENTRIES ((word)1 << LOG_PHT_ENTRIES)\n@@ -934,11 +938,11 @@ struct _GC_arrays {\n   \tchar _valid_offsets[VALID_OFFSET_SZ];\n \t\t\t\t/* GC_valid_offsets[i] == TRUE ==> i \t*/\n \t\t\t\t/* is registered as a displacement.\t*/\n-#\tdefine OFFSET_VALID(displ) \\\n-\t  (GC_all_interior_pointers || GC_valid_offsets[displ])\n   \tchar _modws_valid_offsets[sizeof(word)];\n \t\t\t\t/* GC_valid_offsets[i] ==>\t\t  */\n \t\t\t\t/* GC_modws_valid_offsets[i%sizeof(word)] */\n+#   define OFFSET_VALID(displ) \\\n+\t  (GC_all_interior_pointers || GC_valid_offsets[displ])\n # ifdef STUBBORN_ALLOC\n     page_hash_table _changed_pages;\n         /* Stubborn object pages that were changes since last call to\t*/\n@@ -966,7 +970,7 @@ struct _GC_arrays {\n #   endif\n # else\n #   ifdef SMALL_CONFIG\n-#     define MAX_HEAP_SECTS 128\t\t/* Roughly 1GB\t\t\t*/\n+#     define MAX_HEAP_SECTS 128\t\t/* Roughly 256MB (128*2048*1K)\t*/\n #   else\n #     define MAX_HEAP_SECTS 384\t\t/* Roughly 3GB\t\t\t*/\n #   endif\n@@ -1436,6 +1440,7 @@ GC_bool GC_is_tmp_root GC_PROTO((ptr_t p));\n # endif\n void GC_register_dynamic_libraries GC_PROTO((void));\n   \t\t/* Add dynamic library data sections to the root set. */\n+\n GC_bool GC_register_main_static_data GC_PROTO((void));\n \t\t/* We need to register the main data segment.  Returns\t*/\n \t\t/* TRUE unless this is done implicitly as part of\t*/\n@@ -1610,7 +1615,7 @@ void GC_collect_a_little_inner GC_PROTO((int n));\n   \t\t\t\t/* collection work, if appropriate.\t*/\n   \t\t\t\t/* A unit is an amount appropriate for  */\n   \t\t\t\t/* HBLKSIZE bytes of allocation.\t*/\n-ptr_t GC_generic_malloc GC_PROTO((word lb, int k));\n+/* ptr_t GC_generic_malloc GC_PROTO((word lb, int k)); */\n   \t\t\t\t/* Allocate an object of the given\t*/\n   \t\t\t\t/* kind.  By default, there are only\t*/\n   \t\t\t\t/* a few kinds: composite(pointerfree), */\n@@ -1620,6 +1625,7 @@ ptr_t GC_generic_malloc GC_PROTO((word lb, int k));\n \t\t\t\t/* internals to add more, e.g. to\t*/\n \t\t\t\t/* communicate object layout info\t*/\n \t\t\t\t/* to the collector.\t\t\t*/\n+\t\t\t\t/* The actual decl is in gc_mark.h.\t*/\n ptr_t GC_generic_malloc_ignore_off_page GC_PROTO((size_t b, int k));\n   \t\t\t\t/* As above, but pointers past the \t*/\n   \t\t\t\t/* first page of the resulting object\t*/\n@@ -1717,6 +1723,10 @@ extern GC_bool GC_print_stats;\t/* Produce at least some logging output\t*/\n # define COND_DUMP\n #endif\n \n+#ifdef KEEP_BACK_PTRS\n+  extern long GC_backtraces;\n+#endif\n+\n /* Macros used for collector internal allocation.\t*/\n /* These assume the collector lock is held.\t\t*/\n #ifdef DBG_HDRS_ALL"}, {"sha": "38c2a96cc48c45aa167f8289b6c4333a0b6da24a", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 95, "deletions": 22, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -2,7 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n+ * Copyright (c) 2000-2004 Hewlett-Packard Development Company, L.P.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -307,6 +307,10 @@\n #   define I386\n #   define mach_type_known\n # endif\n+# if defined(__NetBSD__) && defined(__x86_64__)\n+#    define X86_64\n+#    define mach_type_known\n+# endif\n # if defined(bsdi) && (defined(i386) || defined(__i386__))\n #    define I386\n #    define BSDI\n@@ -347,6 +351,11 @@\n #     define MSWIN32\t/* or Win32s */\n #     define mach_type_known\n #   endif\n+#   if defined(_MSC_VER) && defined(_M_IA64)\n+#     define IA64\n+#     define MSWIN32\t/* Really win64, but we don't treat 64-bit \t*/\n+\t\t\t/* variants as a differnt platform.\t\t*/\n+#   endif\n # endif\n # if defined(__DJGPP__)\n #   define I386\n@@ -588,7 +597,8 @@\n  * USE_GENERIC_PUSH_REGS the preferred approach for marking from registers.\n  */\n # if defined(__GNUC__) && ((__GNUC__ >= 3) || \\\n-\t\t\t   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))\n+\t\t\t   (__GNUC__ == 2 && __GNUC_MINOR__ >= 8)) \\\n+\t\t       && !defined(__INTEL_COMPILER)\n #   define HAVE_BUILTIN_UNWIND_INIT\n # endif\n \n@@ -599,8 +609,14 @@\n #   ifdef OPENBSD\n #\tdefine OS_TYPE \"OPENBSD\"\n #\tdefine HEURISTIC2\n-\textern char etext[];\n-#\tdefine DATASTART ((ptr_t)(etext))\n+#\tifdef __ELF__\n+#\t  define DATASTART GC_data_start\n+#\t  define DYNAMIC_LOADING\n+#\telse\n+\t  extern char etext[];\n+#\t  define DATASTART ((ptr_t)(etext))\n+#       endif\n+#       define USE_GENERIC_PUSH_REGS\n #   endif\n #   ifdef NETBSD\n #\tdefine OS_TYPE \"NETBSD\"\n@@ -612,6 +628,7 @@\n \t  extern char etext[];\n #\t  define DATASTART ((ptr_t)(etext))\n #       endif\n+#\tdefine USE_GENERIC_PUSH_REGS\n #   endif\n #   ifdef LINUX\n #       define OS_TYPE \"LINUX\"\n@@ -925,10 +942,17 @@\n \n # ifdef I386\n #   define MACH_TYPE \"I386\"\n-#   define ALIGNMENT 4\t/* Appears to hold for all \"32 bit\" compilers\t*/\n+#   if defined(__LP64__) || defined(_WIN64)\n+#     define CPP_WORDSZ 64\n+#     define ALIGNMENT 8\n+#   else\n+#     define CPP_WORDSZ 32\n+#     define ALIGNMENT 4\n+\t\t\t/* Appears to hold for all \"32 bit\" compilers\t*/\n \t\t\t/* except Borland.  The -a4 option fixes \t*/\n \t\t\t/* Borland.\t\t\t\t\t*/\n                         /* Ivan Demakov: For Watcom the option is -zp4. */\n+#   endif\n #   ifndef SMALL_CONFIG\n #     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n \t\t\t  /* improvement on Pentiums.\t\t\t  */\n@@ -1042,7 +1066,7 @@\n \t    /* possibly because Linux threads is itself a malloc client */\n \t    /* and can't deal with the signals.\t\t\t\t*/\n #\tendif\n-#\tdefine HEAP_START 0x1000\n+#\tdefine HEAP_START (ptr_t)0x1000\n \t\t/* This encourages mmap to give us low addresses,\t*/\n \t\t/* thus allowing the heap to grow to ~3GB\t\t*/\n #       ifdef __ELF__\n@@ -1073,6 +1097,8 @@\n #            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       endif\n #\tifdef USE_I686_PREFETCH\n+\t  /* FIXME: Thus should use __builtin_prefetch, but we'll leave that\t*/\n+\t  /* for the next rtelease.\t\t\t\t\t\t*/\n #\t  define PREFETCH(x) \\\n \t    __asm__ __volatile__ (\"\tprefetchnta\t%0\": : \"m\"(*(char *)(x)))\n \t    /* Empirically prefetcht0 is much more effective at reducing\t*/\n@@ -1562,6 +1588,7 @@\n     \t/* first putenv call.\t\t\t\t\t\t*/\n \textern char ** environ;\n #       define STACKBOTTOM ((ptr_t)environ)\n+#       define HPUX_STACKBOTTOM\n #       define DYNAMIC_LOADING\n #       include <unistd.h>\n #       define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n@@ -1571,9 +1598,9 @@\n \t/* address minus one page.\t\t\t\t\t*/\n #\tdefine BACKING_STORE_DISPLACEMENT 0x1000000\n #\tdefine BACKING_STORE_ALIGNMENT 0x1000\n-#       define BACKING_STORE_BASE \\\n-\t  (ptr_t)(((word)GC_stackbottom - BACKING_STORE_DISPLACEMENT - 1) \\\n-\t\t\t& ~(BACKING_STORE_ALIGNMENT - 1))\n+\textern ptr_t GC_register_stackbottom;\n+#\tdefine BACKING_STORE_BASE GC_register_stackbottom\n+\t/* Known to be wrong for recent HP/UX versions!!!\t*/\n #   endif\n #   ifdef LINUX\n #   \tdefine CPP_WORDSZ 64\n@@ -1591,8 +1618,8 @@\n \t/* constants:\t\t\t\t\t\t*/\n #       define BACKING_STORE_ALIGNMENT 0x100000\n #       define BACKING_STORE_DISPLACEMENT 0x80000000\n-\textern char * GC_register_stackbottom;\n-#\tdefine BACKING_STORE_BASE ((ptr_t)GC_register_stackbottom)\n+\textern ptr_t GC_register_stackbottom;\n+#\tdefine BACKING_STORE_BASE GC_register_stackbottom\n #\tdefine SEARCH_FOR_DATA_START\n #\tifdef __GNUC__\n #         define DYNAMIC_LOADING\n@@ -1606,14 +1633,37 @@\n \textern int _end[];\n #\tdefine DATAEND (_end)\n #       ifdef __GNUC__\n-#\t  define PREFETCH(x) \\\n-\t    __asm__ (\"\tlfetch\t[%0]\": : \"r\"((void *)(x)))\n-#\t  define PREFETCH_FOR_WRITE(x) \\\n-\t    __asm__ (\"\tlfetch.excl\t[%0]\": : \"r\"((void *)(x)))\n-#\t  define CLEAR_DOUBLE(x) \\\n-\t    __asm__ (\"\tstf.spill\t[%0]=f0\": : \"r\"((void *)(x)))\n+#\t  ifndef __INTEL_COMPILER\n+#\t    define PREFETCH(x) \\\n+\t      __asm__ (\"\tlfetch\t[%0]\": : \"r\"(x))\n+#\t    define PREFETCH_FOR_WRITE(x) \\\n+\t      __asm__ (\"\tlfetch.excl\t[%0]\": : \"r\"(x))\n+#\t    define CLEAR_DOUBLE(x) \\\n+\t      __asm__ (\"\tstf.spill\t[%0]=f0\": : \"r\"((void *)(x)))\n+#\t  else\n+#           include <ia64intrin.h>\n+#\t    define PREFETCH(x) \\\n+\t      __lfetch(__lfhint_none, (x))\n+#\t    define PREFETCH_FOR_WRITE(x) \\\n+\t      __lfetch(__lfhint_nta,  (x))\n+#\t    define CLEAR_DOUBLE(x) \\\n+\t      __stf_spill((void *)(x), 0)\n+#\t  endif // __INTEL_COMPILER\n #       endif\n #   endif\n+#   ifdef MSWIN32\n+      /* FIXME: This is a very partial guess.  There is no port, yet.\t*/\n+#     define OS_TYPE \"MSWIN32\"\n+\t\t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n+\t\t/* os_dep.c.\t\t\t\t\t\t*/\n+#     define DATAEND  /* not needed */\n+#     if defined(_WIN64)\n+#       define CPP_WORDSZ 64\n+#     else\n+#       define CPP_WORDSZ 32   /* Is this possible?\t*/\n+#     endif\n+#     define ALIGNMENT 8\n+#   endif\n # endif\n \n # ifdef M88K\n@@ -1801,13 +1851,28 @@\n \t     extern int etext[];\n #            define DATASTART ((ptr_t)((((word) (etext)) + 0xfff) & ~0xfff))\n #       endif\n-#\tif defined(__GNUC__) && __GNUC__ >= 3\n-#\t    define PREFETCH(x) __builtin_prefetch ((x), 0, 0)\n-#\t    define PREFETCH_FOR_WRITE(x) __builtin_prefetch ((x), 1)\n+#       if defined(__GNUC__) && __GNUC >= 3\n+#\t    define PREFETCH(x) __builtin_prefetch((x), 0, 0)\n+#\t    define PREFETCH_FOR_WRITE(x) __builtin_prefetch((x), 1)\n #\tendif\n #   endif\n+#   ifdef NETBSD\n+#\tdefine OS_TYPE \"NETBSD\"\n+#\tifdef __ELF__\n+#\t    define DYNAMIC_LOADING\n+#\tendif\n+#\tdefine HEURISTIC2\n+\textern char etext[];\n+#\tdefine SEARCH_FOR_DATA_START\n+#   endif\n # endif\n \n+#if defined(LINUX) && defined(USE_MMAP)\n+    /* The kernel may do a somewhat better job merging mappings etc.\t*/\n+    /* with anonymous mappings.\t\t\t\t\t\t*/\n+#   define USE_MMAP_ANON\n+#endif\n+\n #if defined(LINUX) && defined(REDIRECT_MALLOC)\n     /* Rld appears to allocate some memory with its own allocator, and\t*/\n     /* some through malloc, which might be redirected.  To make this\t*/\n@@ -1862,9 +1927,13 @@\n #   define SUNOS5SIGS\n # endif\n \n-# if defined(SVR4) || defined(LINUX) || defined(IRIX) || defined(HPUX) \\\n+# if defined(FREEBSD) && (__FreeBSD__ >= 4)\n+#   define SUNOS5SIGS\n+# endif\n+\n+# if defined(SVR4) || defined(LINUX) || defined(IRIX5) || defined(HPUX) \\\n \t    || defined(OPENBSD) || defined(NETBSD) || defined(FREEBSD) \\\n-\t    || defined(DGUX) || defined(BSD) \\\n+\t    || defined(DGUX) || defined(BSD) || defined(SUNOS4) \\\n \t    || defined(_AIX) || defined(DARWIN) || defined(OSF1)\n #   define UNIX_LIKE   /* Basic Unix-like system calls work.\t*/\n # endif\n@@ -1980,6 +2049,10 @@\n #\tdefine USE_GENERIC_PUSH_REGS\n # endif\n \n+# if defined(MSWINCE)\n+#   define NO_GETENV\n+# endif\n+\n # if defined(SPARC)\n #   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n \t\t\t\t/* include assembly code to do it well.\t*/"}, {"sha": "b1f62620bd7d4f690c3151a9ccf27a8de5113955", "filename": "boehm-gc/include/private/solaris_threads.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fsolaris_threads.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -30,6 +30,8 @@\n   extern size_t GC_min_stack_sz;\n   extern size_t GC_page_sz;\n   extern void GC_thr_init(void);\n+  extern ptr_t GC_stack_alloc(size_t * stack_size);\n+  extern void GC_stack_free(ptr_t stack, size_t size);\n \n # endif /* GC_SOLARIS_THREADS */\n "}, {"sha": "d04e19f5a4b5dcd9c60f66a24d7ff7e626402250", "filename": "boehm-gc/include/private/specific.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Finclude%2Fprivate%2Fspecific.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fspecific.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -85,7 +85,7 @@ static __inline__ void * PREFIXED(getspecific) (tsd * key) {\n     unsigned hash_val = CACHE_HASH(qtid);\n     tse * volatile * entry_ptr = key -> cache + hash_val;\n     tse * entry = *entry_ptr;   /* Must be loaded only once.\t*/\n-   if (EXPECT(entry -> qtid == qtid, 1)) {\n+    if (EXPECT(entry -> qtid == qtid, 1)) {\n       GC_ASSERT(entry -> thread == pthread_self());\n       return entry -> value;\n     }"}, {"sha": "327e11ca690cfd6beb173e72ff08cc732266cae3", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -431,6 +431,9 @@ ptr_t cold_gc_frame;\n \t\t  (void) setjmp(regs);\n #\t      else\n \t          (void) _setjmp(regs);\n+\t\t  /* We don't want to mess with signals. According to\t*/\n+\t\t  /* SUSV3, setjmp() may or may not save signal mask.\t*/\n+\t\t  /* _setjmp won't, but is less portable.\t\t*/\n #\t      endif\n #\t    endif /* !HAVE_BUILTIN_UNWIND_INIT */\n #           if (defined(SPARC) && !defined(HAVE_BUILTIN_UNWIND_INIT)) \\"}, {"sha": "cb3f37663861a634d0bf100c0f15a4831b0d21f3", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -36,6 +36,7 @@ register struct obj_kind * kind;\n /* Allocate a large block of size lw words.\t*/\n /* The block is not cleared.\t\t\t*/\n /* Flags is 0 or IGNORE_OFF_PAGE.\t\t*/\n+/* We hold the allocation lock.\t\t\t*/\n ptr_t GC_alloc_large(lw, k, flags)\n word lw;\n int k;\n@@ -62,20 +63,21 @@ unsigned flags;\n     if (h == 0) {\n \tresult = 0;\n     } else {\n-\tint total_bytes = BYTES_TO_WORDS(n_blocks * HBLKSIZE);\n+\tint total_bytes = n_blocks * HBLKSIZE;\n \tif (n_blocks > 1) {\n-\t    GC_large_allocd_bytes += n_blocks * HBLKSIZE;\n+\t    GC_large_allocd_bytes += total_bytes;\n \t    if (GC_large_allocd_bytes > GC_max_large_allocd_bytes)\n \t        GC_max_large_allocd_bytes = GC_large_allocd_bytes;\n \t}\n \tresult = (ptr_t) (h -> hb_body);\n-\tGC_words_wasted += total_bytes - lw;\n+\tGC_words_wasted += BYTES_TO_WORDS(total_bytes) - lw;\n     }\n     return result;\n }\n \n \n /* Allocate a large block of size lb bytes.  Clear if appropriate.\t*/\n+/* We hold the allocation lock.\t\t\t\t\t\t*/\n ptr_t GC_alloc_large_and_clear(lw, k, flags)\n word lw;\n int k;\n@@ -311,6 +313,19 @@ DCL_LOCK_STATE;\n }\n \n # ifdef REDIRECT_MALLOC\n+\n+/* Avoid unnecessary nested procedure calls here, by #defining some\t*/\n+/* malloc replacements.  Otherwise we end up saving a \t\t\t*/\n+/* meaningless return address in the object.  It also speeds things up,\t*/\n+/* but it is admittedly quite ugly.\t\t\t\t\t*/\n+# ifdef GC_ADD_CALLER\n+#   define RA GC_RETURN_ADDR,\n+# else\n+#   define RA\n+# endif\n+# define GC_debug_malloc_replacement(lb) \\\n+\tGC_debug_malloc(lb, RA \"unknown\", 0)\n+\n # ifdef __STDC__\n     GC_PTR malloc(size_t lb)\n # else\n@@ -363,6 +378,8 @@ DCL_LOCK_STATE;\n  /* and thus the right thing will happen even without overriding it.\t */\n  /* This seems to be true on most Linux systems.\t\t\t */\n \n+#undef GC_debug_malloc_replacement\n+\n # endif /* REDIRECT_MALLOC */\n \n /* Explicitly deallocate an object p.\t\t\t\t*/"}, {"sha": "d45f21e8e51d642601d9a7499ed8228f9a6615cf", "filename": "boehm-gc/mallocx.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -147,6 +147,16 @@ int obj_kind;\n # endif\n \n # ifdef REDIRECT_REALLOC\n+\n+/* As with malloc, avoid two levels of extra calls here.\t*/\n+# ifdef GC_ADD_CALLER\n+#   define RA GC_RETURN_ADDR,\n+# else\n+#   define RA\n+# endif\n+# define GC_debug_realloc_replacement(p, lb) \\\n+\tGC_debug_realloc(p, lb, RA \"unknown\", 0)\n+\n # ifdef __STDC__\n     GC_PTR realloc(GC_PTR p, size_t lb)\n # else\n@@ -157,6 +167,8 @@ int obj_kind;\n   {\n     return(REDIRECT_REALLOC(p, lb));\n   }\n+\n+# undef GC_debug_realloc_replacement\n # endif /* REDIRECT_REALLOC */\n \n "}, {"sha": "c645bc0eeecc50644936b20adb48db6cf9e99a94", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -558,8 +558,8 @@ register hdr *hhdr, **new_hdr_p;\n \t      current = current - HBLKSIZE*(word)hhdr;\n \t      hhdr = HDR(current);\n \t    } while(IS_FORWARDING_ADDR_OR_NIL(hhdr));\n-\t    /* current points to the start of the large object */\n-\t    if (hhdr -> hb_flags & IGNORE_OFF_PAGE) return(0);\n+\t    /* current points to near the start of the large object */\n+\t    if (hhdr -> hb_flags & IGNORE_OFF_PAGE) return(orig);\n \t    if ((word *)orig - (word *)current\n \t         >= (ptrdiff_t)(hhdr->hb_sz)) {\n \t        /* Pointer past the end of the block */\n@@ -1739,7 +1739,7 @@ register hdr * hhdr;\n {\n     register int sz = hhdr -> hb_sz;\n     \n-    if (sz < MAXOBJSZ) {\n+    if (sz <= MAXOBJSZ) {\n          return(GC_page_was_dirty(h));\n     } else {\n     \t register ptr_t p = (ptr_t)h;"}, {"sha": "5b10feeb961faa9badb793eae3b4659ed24cab5c", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 100, "deletions": 8, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -116,6 +116,11 @@ GC_bool GC_print_back_height = 0;\n   GC_bool GC_dump_regularly = 0;  /* Generate regular debugging dumps. */\n #endif\n \n+#ifdef KEEP_BACK_PTRS\n+  long GC_backtraces = 0;\t/* Number of random backtraces to \t*/\n+  \t\t\t\t/* generate for each GC.\t\t*/\n+#endif\n+\n #ifdef FIND_LEAK\n   int GC_find_leak = 1;\n #else\n@@ -470,7 +475,17 @@ void GC_init()\n     DISABLE_SIGNALS();\n \n #if defined(GC_WIN32_THREADS) && !defined(GC_PTHREADS)\n-    if (!GC_is_initialized) InitializeCriticalSection(&GC_allocate_ml);\n+    if (!GC_is_initialized) {\n+      BOOL (WINAPI *pfn) (LPCRITICAL_SECTION, DWORD) = NULL;\n+      HMODULE hK32 = GetModuleHandle(\"kernel32.dll\");\n+      if (hK32)\n+          (FARPROC) pfn = GetProcAddress(hK32,\n+\t\t\t  \"InitializeCriticalSectionAndSpinCount\");\n+      if (pfn)\n+          pfn(&GC_allocate_ml, 4000);\n+      else\n+\t  InitializeCriticalSection (&GC_allocate_ml);\n+    }\n #endif /* MSWIN32 */\n \n     LOCK();\n@@ -537,7 +552,7 @@ int sig;\n \n static GC_bool installed_looping_handler = FALSE;\n \n-void maybe_install_looping_handler()\n+static void maybe_install_looping_handler()\n {\n     /* Install looping handler before the write fault handler, so we\t*/\n     /* handle write faults correctly.\t\t\t\t\t*/\n@@ -574,6 +589,15 @@ void GC_init_inner()\n       if (0 != GETENV(\"GC_DUMP_REGULARLY\")) {\n         GC_dump_regularly = 1;\n       }\n+#   endif\n+#   ifdef KEEP_BACK_PTRS\n+      {\n+        char * backtraces_string = GETENV(\"GC_BACKTRACES\");\n+        if (0 != backtraces_string) {\n+          GC_backtraces = atol(backtraces_string);\n+\t  if (backtraces_string[0] == '\\0') GC_backtraces = 1;\n+        }\n+      }\n #   endif\n     if (0 != GETENV(\"GC_FIND_LEAK\")) {\n       GC_find_leak = 1;\n@@ -650,14 +674,14 @@ void GC_init_inner()\n \t|| defined(GC_SOLARIS_THREADS)\n       if (GC_stackbottom == 0) {\n \tGC_stackbottom = GC_get_stack_base();\n-#       if defined(LINUX) && defined(IA64)\n+#       if (defined(LINUX) || defined(HPUX)) && defined(IA64)\n \t  GC_register_stackbottom = GC_get_register_stack_base();\n #       endif\n       } else {\n-#       if defined(LINUX) && defined(IA64)\n+#       if (defined(LINUX) || defined(HPUX)) && defined(IA64)\n \t  if (GC_register_stackbottom == 0) {\n \t    WARN(\"GC_register_stackbottom should be set with GC_stackbottom\", 0);\n-\t    /* The following is likely to fail, since we rely on \t*/\n+\t    /* The following may fail, since we may rely on\t \t*/\n \t    /* alignment properties that may not hold with a user set\t*/\n \t    /* GC_stackbottom.\t\t\t\t\t\t*/\n \t    GC_register_stackbottom = GC_get_register_stack_base();\n@@ -754,7 +778,7 @@ void GC_init_inner()\n       }\n #   endif /* !SMALL_CONFIG */\n     COND_DUMP;\n-    /* Get black list set up and/or incrmental GC started */\n+    /* Get black list set up and/or incremental GC started */\n       if (!GC_dont_precollect || GC_incremental) GC_gcollect_inner();\n     GC_is_initialized = TRUE;\n #   ifdef STUBBORN_ALLOC\n@@ -1031,7 +1055,6 @@ GC_CONST char * msg;\n {\n #   if defined(MSWIN32)\n       (void) MessageBoxA(NULL, msg, \"Fatal error in gc\", MB_ICONERROR|MB_OK);\n-      DebugBreak();\n #   else\n       GC_err_printf1(\"%s\\n\", msg);\n #   endif\n@@ -1042,7 +1065,7 @@ GC_CONST char * msg;\n \t    /* about threads.\t\t\t\t\t\t*/\n \t    for(;;) {}\n     }\n-#   ifdef MSWIN32\n+#   if defined(MSWIN32) || defined(MSWINCE)\n \tDebugBreak();\n #   else\n         (void) abort();\n@@ -1064,6 +1087,75 @@ void GC_disable()\n     UNLOCK();\n }\n \n+/* Helper procedures for new kind creation.\t*/\n+void ** GC_new_free_list_inner()\n+{\n+    void *result = GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n+    if (result == 0) ABORT(\"Failed to allocate freelist for new kind\");\n+    BZERO(result, (MAXOBJSZ+1)*sizeof(ptr_t));\n+    return result;\n+}\n+\n+void ** GC_new_free_list()\n+{\n+    void *result;\n+    LOCK(); DISABLE_SIGNALS();\n+    result = GC_new_free_list_inner();\n+    UNLOCK(); ENABLE_SIGNALS();\n+    return result;\n+}\n+\n+int GC_new_kind_inner(fl, descr, adjust, clear)\n+void **fl;\n+GC_word descr;\n+int adjust;\n+int clear;\n+{\n+    int result = GC_n_kinds++;\n+\n+    if (GC_n_kinds > MAXOBJKINDS) ABORT(\"Too many kinds\");\n+    GC_obj_kinds[result].ok_freelist = (ptr_t *)fl;\n+    GC_obj_kinds[result].ok_reclaim_list = 0;\n+    GC_obj_kinds[result].ok_descriptor = descr;\n+    GC_obj_kinds[result].ok_relocate_descr = adjust;\n+    GC_obj_kinds[result].ok_init = clear;\n+    return result;\n+}\n+\n+int GC_new_kind(fl, descr, adjust, clear)\n+void **fl;\n+GC_word descr;\n+int adjust;\n+int clear;\n+{\n+    int result;\n+    LOCK(); DISABLE_SIGNALS();\n+    result = GC_new_kind_inner(fl, descr, adjust, clear);\n+    UNLOCK(); ENABLE_SIGNALS();\n+    return result;\n+}\n+\n+int GC_new_proc_inner(proc)\n+GC_mark_proc proc;\n+{\n+    int result = GC_n_mark_procs++;\n+\n+    if (GC_n_mark_procs > MAX_MARK_PROCS) ABORT(\"Too many mark procedures\");\n+    GC_mark_procs[result] = proc;\n+    return result;\n+}\n+\n+int GC_new_proc(proc)\n+GC_mark_proc proc;\n+{\n+    int result;\n+    LOCK(); DISABLE_SIGNALS();\n+    result = GC_new_proc_inner(proc);\n+    UNLOCK(); ENABLE_SIGNALS();\n+    return result;\n+}\n+\n+\n #if !defined(NO_DEBUGGING)\n \n void GC_dump()"}, {"sha": "e5580e4ca218d9770f7dcf171bf4cc61420852c2", "filename": "boehm-gc/new_hblk.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fnew_hblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fnew_hblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnew_hblk.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -104,7 +104,7 @@ ptr_t ofl;\n     p[3] = 0;\n     p += 4;\n     for (; p < lim; p += 4) {\n-\tPREFETCH_FOR_WRITE(p+64);\n+\tPREFETCH_FOR_WRITE((ptr_t)(p+64));\n         p[0] = (word)(p-4);\n         p[1] = 0;\n \tCLEAR_DOUBLE(p+2);\n@@ -142,7 +142,7 @@ ptr_t ofl;\n     p[4] = (word)p;\n     p += 8;\n     for (; p < lim; p += 8) {\n-\tPREFETCH_FOR_WRITE(p+64);\n+\tPREFETCH_FOR_WRITE((ptr_t)(p+64));\n         p[0] = (word)(p-4);\n         p[4] = (word)p;\n     };\n@@ -171,10 +171,10 @@ ptr_t list;\n   /* If we were more serious about it, these should go inside\t*/\n   /* the loops.  But write prefetches usually don't seem to\t*/\n   /* matter much.\t\t\t\t\t\t*/\n-    PREFETCH_FOR_WRITE((char *)h);\n-    PREFETCH_FOR_WRITE((char *)h + 128);\n-    PREFETCH_FOR_WRITE((char *)h + 256);\n-    PREFETCH_FOR_WRITE((char *)h + 378);\n+    PREFETCH_FOR_WRITE((ptr_t)h);\n+    PREFETCH_FOR_WRITE((ptr_t)h + 128);\n+    PREFETCH_FOR_WRITE((ptr_t)h + 256);\n+    PREFETCH_FOR_WRITE((ptr_t)h + 378);\n   /* Handle small objects sizes more efficiently.  For larger objects \t*/\n   /* the difference is less significant.\t\t\t\t*/\n #  ifndef SMALL_CONFIG"}, {"sha": "21d05635ab81740ddfcc43393be384d09d241c64", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 247, "deletions": 148, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -87,6 +87,12 @@\n #  endif\n #endif\n \n+#if (defined(NETBSD) || defined(OPENBSD)) && defined(__ELF__) \\\n+    && !defined(NEED_FIND_LIMIT)\n+   /* Used by GC_init_netbsd_elf() below.\t*/\n+#  define NEED_FIND_LIMIT\n+#endif\n+\n #ifdef NEED_FIND_LIMIT\n #   include <setjmp.h>\n #endif\n@@ -111,25 +117,30 @@\n # include <sys/uio.h>\n # include <malloc.h>   /* for locking */\n #endif\n-#ifdef USE_MMAP\n+#if defined(USE_MMAP) || defined(USE_MUNMAP)\n+# ifndef USE_MMAP\n+    --> USE_MUNMAP requires USE_MMAP\n+# endif\n # include <sys/types.h>\n # include <sys/mman.h>\n # include <sys/stat.h>\n+# include <errno.h>\n #endif\n \n #ifdef UNIX_LIKE\n # include <fcntl.h>\n-#endif\n-\n-#if defined(SUNOS5SIGS) || defined (HURD) || defined(LINUX)\n-# ifdef SUNOS5SIGS\n+# if defined(SUNOS5SIGS) && !defined(FREEBSD)\n #  include <sys/siginfo.h>\n # endif\n-# undef setjmp\n-# undef longjmp\n-# define setjmp(env) sigsetjmp(env, 1)\n-# define longjmp(env, val) siglongjmp(env, val)\n-# define jmp_buf sigjmp_buf\n+  /* Define SETJMP and friends to be the version that restores\t*/\n+  /* the signal mask.\t\t\t\t\t\t*/\n+# define SETJMP(env) sigsetjmp(env, 1)\n+# define LONGJMP(env, val) siglongjmp(env, val)\n+# define JMP_BUF sigjmp_buf\n+#else\n+# define SETJMP(env) setjmp(env)\n+# define LONGJMP(env, val) longjmp(env, val)\n+# define JMP_BUF jmp_buf\n #endif\n \n #ifdef DARWIN\n@@ -183,45 +194,41 @@ ssize_t GC_repeat_read(int fd, char *buf, size_t count)\n /*\n  * Apply fn to a buffer containing the contents of /proc/self/maps.\n  * Return the result of fn or, if we failed, 0.\n+ * We currently do nothing to /proc/self/maps other than simply read\n+ * it.  This code could be simplified if we could determine its size\n+ * ahead of time.\n  */\n \n word GC_apply_to_maps(word (*fn)(char *))\n {\n     int f;\n     int result;\n-    int maps_size;\n-    char maps_temp[32768];\n-    char *maps_buf;\n-\n-    /* Read /proc/self/maps\t*/\n-        /* Note that we may not allocate, and thus can't use stdio.\t*/\n-        f = open(\"/proc/self/maps\", O_RDONLY);\n-        if (-1 == f) return 0;\n-\t/* stat() doesn't work for /proc/self/maps, so we have to\n-\t   read it to find out how large it is... */\n-\tmaps_size = 0;\n+    size_t maps_size = 4000;  /* Initial guess. \t*/\n+    static char init_buf[1];\n+    static char *maps_buf = init_buf;\n+    static size_t maps_buf_sz = 1;\n+\n+    /* Read /proc/self/maps, growing maps_buf as necessary.\t*/\n+        /* Note that we may not allocate conventionally, and\t*/\n+        /* thus can't use stdio.\t\t\t\t*/\n \tdo {\n-\t    result = GC_repeat_read(f, maps_temp, sizeof(maps_temp));\n-\t    if (result <= 0) return 0;\n-\t    maps_size += result;\n-\t} while (result == sizeof(maps_temp));\n-\n-\tif (maps_size > sizeof(maps_temp)) {\n-\t    /* If larger than our buffer, close and re-read it. */\n-\t    close(f);\n+\t    if (maps_size >= maps_buf_sz) {\n+\t      /* Grow only by powers of 2, since we leak \"too small\" buffers. */\n+\t      while (maps_size >= maps_buf_sz) maps_buf_sz *= 2;\n+\t      maps_buf = GC_scratch_alloc(maps_buf_sz);\n+\t      if (maps_buf == 0) return 0;\n+\t    }\n \t    f = open(\"/proc/self/maps\", O_RDONLY);\n \t    if (-1 == f) return 0;\n-\t    maps_buf = alloca(maps_size);\n-\t    if (NULL == maps_buf) return 0;\n-\t    result = GC_repeat_read(f, maps_buf, maps_size);\n-\t    if (result <= 0) return 0;\n-\t} else {\n-\t    /* Otherwise use the fixed size buffer */\n-\t    maps_buf = maps_temp;\n-\t}\n-\n-\tclose(f);\n-        maps_buf[result] = '\\0';\n+\t    maps_size = 0;\n+\t    do {\n+\t        result = GC_repeat_read(f, maps_buf, maps_buf_sz-1);\n+\t        if (result <= 0) return 0;\n+\t        maps_size += result;\n+\t    } while (result == maps_buf_sz-1);\n+\t    close(f);\n+\t} while (maps_size >= maps_buf_sz);\n+        maps_buf[maps_size] = '\\0';\n \t\n     /* Apply fn to result. */\n \treturn fn(maps_buf);\n@@ -352,7 +359,8 @@ char *GC_parse_map_entry(char *buf_ptr, word *start, word *end,\n # endif /* ECOS_GC_MEMORY_SIZE */\n \n // setjmp() function, as described in ANSI para 7.6.1.1\n-#define setjmp( __env__ )  hal_setjmp( __env__ )\n+#undef SETJMP\n+#define SETJMP( __env__ )  hal_setjmp( __env__ )\n \n // FIXME: This is a simple way of allocating memory which is\n // compatible with ECOS early releases.  Later releases use a more\n@@ -688,9 +696,11 @@ ptr_t GC_get_stack_base()\n \ttypedef void (*handler)();\n #   endif\n \n-#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1) || defined(HURD)\n+#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1) \\\n+    || defined(HURD) || defined(NETBSD)\n \tstatic struct sigaction old_segv_act;\n-#\tif defined(_sigargs) /* !Irix6.x */ || defined(HPUX) || defined(HURD)\n+#\tif defined(_sigargs) /* !Irix6.x */ || defined(HPUX) \\\n+\t|| defined(HURD) || defined(NETBSD)\n \t    static struct sigaction old_bus_act;\n #\tendif\n #   else\n@@ -704,21 +714,17 @@ ptr_t GC_get_stack_base()\n       handler h;\n #   endif\n     {\n-#     if defined(SUNOS5SIGS) || defined(IRIX5)  \\\n-        || defined(OSF1) || defined(HURD)\n+#\tif defined(SUNOS5SIGS) || defined(IRIX5)  \\\n+        || defined(OSF1) || defined(HURD) || defined(NETBSD)\n \t  struct sigaction\tact;\n \n \t  act.sa_handler\t= h;\n-#\t  ifdef SUNOS5SIGS\n+#\t  if 0 /* Was necessary for Solaris 2.3 and very temporary \t*/\n+\t       /* NetBSD bugs.\t\t\t\t\t\t*/\n             act.sa_flags          = SA_RESTART | SA_NODEFER;\n #         else\n             act.sa_flags          = SA_RESTART;\n #\t  endif\n-          /* The presence of SA_NODEFER represents yet another gross    */\n-          /* hack.  Under Solaris 2.3, siglongjmp doesn't appear to     */\n-          /* interact correctly with -lthread.  We hide the confusion   */\n-          /* by making sure that signal handling doesn't affect the     */\n-          /* signal mask.                                               */\n \n \t  (void) sigemptyset(&act.sa_mask);\n #\t  ifdef GC_IRIX_THREADS\n@@ -729,7 +735,7 @@ ptr_t GC_get_stack_base()\n #\t  else\n \t        (void) sigaction(SIGSEGV, &act, &old_segv_act);\n #\t\tif defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n-\t\t   || defined(HPUX) || defined(HURD)\n+\t\t   || defined(HPUX) || defined(HURD) || defined(NETBSD)\n \t\t    /* Under Irix 5.x or HP/UX, we may get SIGBUS.\t*/\n \t\t    /* Pthreads doesn't exist under Irix 5.x, so we\t*/\n \t\t    /* don't have to worry in the threads case.\t\t*/\n@@ -748,13 +754,13 @@ ptr_t GC_get_stack_base()\n # ifdef NEED_FIND_LIMIT\n   /* Some tools to implement HEURISTIC2\t*/\n #   define MIN_PAGE_SIZE 256\t/* Smallest conceivable page size, bytes */\n-    /* static */ jmp_buf GC_jmp_buf;\n+    /* static */ JMP_BUF GC_jmp_buf;\n     \n     /*ARGSUSED*/\n     void GC_fault_handler(sig)\n     int sig;\n     {\n-        longjmp(GC_jmp_buf, 1);\n+        LONGJMP(GC_jmp_buf, 1);\n     }\n \n     void GC_setup_temporary_fault_handler()\n@@ -764,19 +770,19 @@ ptr_t GC_get_stack_base()\n     \n     void GC_reset_fault_handler()\n     {\n-#     if defined(SUNOS5SIGS) || defined(IRIX5) \\\n-\t || defined(OSF1) || defined(HURD)\n-\t(void) sigaction(SIGSEGV, &old_segv_act, 0);\n-#\tif defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n-\t   || defined(HPUX) || defined(HURD)\n-\t    (void) sigaction(SIGBUS, &old_bus_act, 0);\n-#\tendif\n-#      else\n-\t(void) signal(SIGSEGV, old_segv_handler);\n-#\tifdef SIGBUS\n-\t  (void) signal(SIGBUS, old_bus_handler);\n-#\tendif\n-#     endif\n+#       if defined(SUNOS5SIGS) || defined(IRIX5) \\\n+\t   || defined(OSF1) || defined(HURD) || defined(NETBSD)\n+\t  (void) sigaction(SIGSEGV, &old_segv_act, 0);\n+#\t  if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n+\t     || defined(HPUX) || defined(HURD) || defined(NETBSD)\n+\t      (void) sigaction(SIGBUS, &old_bus_act, 0);\n+#\t  endif\n+#       else\n+  \t  (void) signal(SIGSEGV, old_segv_handler);\n+#\t  ifdef SIGBUS\n+\t    (void) signal(SIGBUS, old_bus_handler);\n+#\t  endif\n+#       endif\n     }\n \n     /* Return the first nonaddressible location > p (up) or \t*/\n@@ -786,31 +792,31 @@ ptr_t GC_get_stack_base()\n     ptr_t p;\n     GC_bool up;\n     {\n-      static VOLATILE ptr_t result;\n-  \t\t/* Needs to be static, since otherwise it may not be\t*/\n-  \t\t/* preserved across the longjmp.  Can safely be \t*/\n-  \t\t/* static since it's only called once, with the\t\t*/\n-  \t\t/* allocation lock held.\t\t\t\t*/\n-\n-\n-      GC_setup_temporary_fault_handler();\n-      if (setjmp(GC_jmp_buf) == 0) {\n-\tresult = (ptr_t)(((word)(p))\n-\t\t\t & ~(MIN_PAGE_SIZE-1));\n-\tfor (;;) {\n-\t  if (up) {\n-\t    result += MIN_PAGE_SIZE;\n-\t  } else {\n-\t    result -= MIN_PAGE_SIZE;\n-\t  }\n-\t  GC_noop1((word)(*result));\n+        static VOLATILE ptr_t result;\n+    \t\t/* Needs to be static, since otherwise it may not be\t*/\n+    \t\t/* preserved across the longjmp.  Can safely be \t*/\n+    \t\t/* static since it's only called once, with the\t\t*/\n+    \t\t/* allocation lock held.\t\t\t\t*/\n+\n+\n+\tGC_setup_temporary_fault_handler();\n+\tif (SETJMP(GC_jmp_buf) == 0) {\n+\t    result = (ptr_t)(((word)(p))\n+\t\t\t      & ~(MIN_PAGE_SIZE-1));\n+\t    for (;;) {\n+ \t        if (up) {\n+\t\t    result += MIN_PAGE_SIZE;\n+ \t        } else {\n+\t\t    result -= MIN_PAGE_SIZE;\n+ \t        }\n+\t\tGC_noop1((word)(*result));\n+\t    }\n \t}\n-      }\n-      GC_reset_fault_handler();\n-      if (!up) {\n-\tresult += MIN_PAGE_SIZE;\n-      }\n-      return(result);\n+\tGC_reset_fault_handler();\n+ \tif (!up) {\n+\t    result += MIN_PAGE_SIZE;\n+ \t}\n+\treturn(result);\n     }\n # endif\n \n@@ -821,6 +827,29 @@ ptr_t GC_get_stack_base()\n   }\n #endif\n \n+#ifdef HPUX_STACKBOTTOM\n+\n+#include <sys/param.h>\n+#include <sys/pstat.h>\n+\n+  ptr_t GC_get_register_stack_base(void)\n+  {\n+    struct pst_vm_status vm_status;\n+\n+    int i = 0;\n+    while (pstat_getprocvm(&vm_status, sizeof(vm_status), 0, i++) == 1) {\n+      if (vm_status.pst_type == PS_RSESTACK) {\n+        return (ptr_t) vm_status.pst_vaddr;\n+      }\n+    }\n+\n+    /* old way to get the register stackbottom */\n+    return (ptr_t)(((word)GC_stackbottom - BACKING_STORE_DISPLACEMENT - 1)\n+                   & ~(BACKING_STORE_ALIGNMENT - 1));\n+  }\n+\n+#endif /* HPUX_STACK_BOTTOM */\n+\n #ifdef LINUX_STACKBOTTOM\n \n #include <sys/types.h>\n@@ -903,7 +932,11 @@ ptr_t GC_get_stack_base()\n     size_t i, buf_offset = 0;\n \n     /* First try the easy way.  This should work for glibc 2.2\t*/\n-      if (0 != &__libc_stack_end) {\n+    /* This fails in a prelinked (\"prelink\" command) executable */\n+    /* since the correct value of __libc_stack_end never\t*/\n+    /* becomes visible to us.  The second test works around \t*/\n+    /* this.\t\t\t\t\t\t\t*/  \n+      if (0 != &__libc_stack_end && 0 != __libc_stack_end ) {\n #       ifdef IA64\n \t  /* Some versions of glibc set the address 16 bytes too\t*/\n \t  /* low while the initialization code is running.\t\t*/\n@@ -1328,7 +1361,7 @@ int * etext_addr;\n     /* max_page_size to &etext if &etext is at a page boundary\t*/\n     \n     GC_setup_temporary_fault_handler();\n-    if (setjmp(GC_jmp_buf) == 0) {\n+    if (SETJMP(GC_jmp_buf) == 0) {\n     \t/* Try writing to the address.\t*/\n     \t*result = *result;\n         GC_reset_fault_handler();\n@@ -1362,7 +1395,7 @@ int * etext_addr;\n \t\t\t      & ~((word)max_page_size - 1);\n     VOLATILE ptr_t result = (ptr_t)text_end;\n     GC_setup_temporary_fault_handler();\n-    if (setjmp(GC_jmp_buf) == 0) {\n+    if (SETJMP(GC_jmp_buf) == 0) {\n \t/* Try reading at the address.\t\t\t\t*/\n \t/* This should happen before there is another thread.\t*/\n \tfor (; next_page < (word)(DATAEND); next_page += (word)max_page_size)\n@@ -1497,8 +1530,7 @@ word bytes;\n \n #else  /* Not RS6000 */\n \n-#if defined(USE_MMAP)\n-/* Tested only under Linux, IRIX5 and Solaris 2 */\n+#if defined(USE_MMAP) || defined(USE_MUNMAP)\n \n #ifdef USE_MMAP_FIXED\n #   define GC_MMAP_FLAGS MAP_FIXED | MAP_PRIVATE\n@@ -1508,6 +1540,23 @@ word bytes;\n #   define GC_MMAP_FLAGS MAP_PRIVATE\n #endif\n \n+#ifdef USE_MMAP_ANON\n+# define zero_fd -1\n+# if defined(MAP_ANONYMOUS)\n+#   define OPT_MAP_ANON MAP_ANONYMOUS\n+# else\n+#   define OPT_MAP_ANON MAP_ANON\n+# endif\n+#else\n+  static int zero_fd;\n+# define OPT_MAP_ANON 0\n+#endif \n+\n+#endif /* defined(USE_MMAP) || defined(USE_MUNMAP) */\n+\n+#if defined(USE_MMAP)\n+/* Tested only under Linux, IRIX5 and Solaris 2 */\n+\n #ifndef HEAP_START\n #   define HEAP_START 0\n #endif\n@@ -1520,23 +1569,17 @@ word bytes;\n \n #   ifndef USE_MMAP_ANON\n       static GC_bool initialized = FALSE;\n-      static int fd;\n \n       if (!initialized) {\n-\t  fd = open(\"/dev/zero\", O_RDONLY);\n-\t  fcntl(fd, F_SETFD, FD_CLOEXEC);\n+\t  zero_fd = open(\"/dev/zero\", O_RDONLY);\n+\t  fcntl(zero_fd, F_SETFD, FD_CLOEXEC);\n \t  initialized = TRUE;\n       }\n #   endif\n \n     if (bytes & (GC_page_size -1)) ABORT(\"Bad GET_MEM arg\");\n-#   ifdef USE_MMAP_ANON\n-      result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n-\t\t    GC_MMAP_FLAGS | MAP_ANON, -1, 0/* offset */);\n-#   else\n-      result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n-\t\t    GC_MMAP_FLAGS, fd, 0/* offset */);\n-#   endif\n+    result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n+\t\t  GC_MMAP_FLAGS | OPT_MAP_ANON, zero_fd, 0/* offset */);\n     if (result == MAP_FAILED) return(0);\n     last_addr = (ptr_t)result + bytes + GC_page_size - 1;\n     last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));\n@@ -1794,21 +1837,29 @@ void GC_unmap(ptr_t start, word bytes)\n \t  len -= free_len;\n       }\n #   else\n-      if (munmap(start_addr, len) != 0) ABORT(\"munmap failed\");\n+      /* We immediately remap it to prevent an intervening mmap from\t*/\n+      /* accidentally grabbing the same address space.\t\t\t*/\n+      {\n+\tvoid * result;\n+        result = mmap(start_addr, len, PROT_NONE,\n+\t\t      MAP_PRIVATE | MAP_FIXED | OPT_MAP_ANON,\n+\t\t      zero_fd, 0/* offset */);\n+        if (result != (void *)start_addr) ABORT(\"mmap(...PROT_NONE...) failed\");\n+      }\n       GC_unmapped_bytes += len;\n #   endif\n }\n \n \n void GC_remap(ptr_t start, word bytes)\n {\n-    static int zero_descr = -1;\n     ptr_t start_addr = GC_unmap_start(start, bytes);\n     ptr_t end_addr = GC_unmap_end(start, bytes);\n     word len = end_addr - start_addr;\n-    ptr_t result;\n \n #   if defined(MSWIN32) || defined(MSWINCE)\n+      ptr_t result;\n+\n       if (0 == start_addr) return;\n       while (len != 0) {\n           MEMORY_BASIC_INFORMATION mem_info;\n@@ -1828,13 +1879,17 @@ void GC_remap(ptr_t start, word bytes)\n \t  len -= alloc_len;\n       }\n #   else\n-      if (-1 == zero_descr) zero_descr = open(\"/dev/zero\", O_RDWR);\n-      fcntl(zero_descr, F_SETFD, FD_CLOEXEC);\n+      /* It was already remapped with PROT_NONE. */\n+      int result; \n+\n       if (0 == start_addr) return;\n-      result = mmap(start_addr, len, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n-\t\t    MAP_FIXED | MAP_PRIVATE, zero_descr, 0);\n-      if (result != start_addr) {\n-\t  ABORT(\"mmap remapping failed\");\n+      result = mprotect(start_addr, len,\n+\t\t        PROT_READ | PROT_WRITE | OPT_PROT_EXEC);\n+      if (result != 0) {\n+\t  GC_err_printf3(\n+\t\t\"Mprotect failed at 0x%lx (length %ld) with errno %ld\\n\",\n+\t        start_addr, len, errno);\n+\t  ABORT(\"Mprotect remapping failed\");\n       }\n       GC_unmapped_bytes -= len;\n #   endif\n@@ -2170,9 +2225,9 @@ GC_bool is_ptrfree;\n # endif /* !DARWIN */\n # endif /* MSWIN32 || MSWINCE || DARWIN */\n \n-#if defined(SUNOS4) || defined(FREEBSD)\n+#if defined(SUNOS4) || (defined(FREEBSD) && !defined(SUNOS5SIGS))\n     typedef void (* SIG_PF)();\n-#endif /* SUNOS4 || FREEBSD */\n+#endif /* SUNOS4 || (FREEBSD && !SUNOS5SIGS) */\n \n #if defined(SUNOS5SIGS) || defined(OSF1) || defined(LINUX) \\\n     || defined(HURD)\n@@ -2199,13 +2254,13 @@ GC_bool is_ptrfree;\n #endif /* IRIX5 || OSF1 || HURD */\n \n #if defined(SUNOS5SIGS)\n-# ifdef HPUX\n-#   define SIGINFO __siginfo\n+# if defined(HPUX) || defined(FREEBSD)\n+#   define SIGINFO_T siginfo_t\n # else\n-#   define SIGINFO siginfo\n+#   define SIGINFO_T struct siginfo\n # endif\n # ifdef __STDC__\n-    typedef void (* REAL_SIG_PF)(int, struct SIGINFO *, void *);\n+    typedef void (* REAL_SIG_PF)(int, SIGINFO_T *, void *);\n # else\n     typedef void (* REAL_SIG_PF)();\n # endif\n@@ -2225,8 +2280,11 @@ GC_bool is_ptrfree;\n #   if defined(ALPHA) || defined(M68K)\n       typedef void (* REAL_SIG_PF)(int, int, s_c *);\n #   else\n-#     if defined(IA64) || defined(HP_PA)\n+#     if defined(IA64) || defined(HP_PA) || defined(X86_64)\n         typedef void (* REAL_SIG_PF)(int, siginfo_t *, s_c *);\n+\t/* FIXME:\t\t\t\t\t\t  */\n+\t/* According to SUSV3, the last argument should have type */\n+\t/* void * or ucontext_t *\t\t\t\t  */\n #     else\n         typedef void (* REAL_SIG_PF)(int, s_c);\n #     endif\n@@ -2301,7 +2359,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \n /*ARGSUSED*/\n #if !defined(DARWIN)\n-# if defined (SUNOS4) || defined(FREEBSD)\n+# if defined (SUNOS4) || (defined(FREEBSD) && !defined(SUNOS5SIGS))\n     void GC_write_fault_handler(sig, code, scp, addr)\n     int sig, code;\n     struct sigcontext *scp;\n@@ -2316,7 +2374,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #     define SIG_OK (sig == SIGBUS)\n #     define CODE_OK (code == BUS_PAGE_FAULT)\n #   endif\n-# endif /* SUNOS4 || FREEBSD */\n+# endif /* SUNOS4 || (FREEBSD && !SUNOS5SIGS) */\n \n # if defined(IRIX5) || defined(OSF1) || defined(HURD)\n #   include <errno.h>\n@@ -2339,7 +2397,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #   if defined(ALPHA) || defined(M68K)\n       void GC_write_fault_handler(int sig, int code, s_c * sc)\n #   else\n-#     if defined(IA64) || defined(HP_PA)\n+#     if defined(IA64) || defined(HP_PA) || defined(X86_64)\n         void GC_write_fault_handler(int sig, siginfo_t * si, s_c * scp)\n #     else\n #       if defined(ARM32)\n@@ -2358,11 +2416,11 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \n # if defined(SUNOS5SIGS)\n #  ifdef __STDC__\n-    void GC_write_fault_handler(int sig, struct SIGINFO *scp, void * context)\n+    void GC_write_fault_handler(int sig, SIGINFO_T *scp, void * context)\n #  else\n     void GC_write_fault_handler(sig, scp, context)\n     int sig;\n-    struct SIGINFO *scp;\n+    SIGINFO_T *scp;\n     void * context;\n #  endif\n #   ifdef HPUX\n@@ -2373,9 +2431,14 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \t\t     || (scp -> si_code == SEGV_UNKNOWN) \\\n \t\t     || (scp -> si_code == BUS_OBJERR)\n #   else\n-#     define SIG_OK (sig == SIGSEGV)\n-#     define CODE_OK (scp -> si_code == SEGV_ACCERR)\n-#   endif\n+#     ifdef FREEBSD\n+#       define SIG_OK (sig == SIGBUS)\n+#       define CODE_OK (scp -> si_code == BUS_PAGE_FAULT)\n+#     else\n+#       define SIG_OK (sig == SIGSEGV)\n+#       define CODE_OK (scp -> si_code == SEGV_ACCERR)\n+#     endif\n+#   endif    \n # endif /* SUNOS5SIGS */\n \n # if defined(MSWIN32) || defined(MSWINCE)\n@@ -2400,7 +2463,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \tchar * addr = (char *) (scp -> si_addr);\n #   endif\n #   ifdef LINUX\n-#     if defined(I386) || defined (X86_64)\n+#     if defined(I386)\n \tchar * addr = (char *) (sc.cr2);\n #     else\n #\tif defined(M68K)\n@@ -2435,7 +2498,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #\t  ifdef ALPHA\n             char * addr = get_fault_addr(sc);\n #\t  else\n-#\t    if defined(IA64) || defined(HP_PA)\n+#\t    if defined(IA64) || defined(HP_PA) || defined(X86_64)\n \t      char * addr = si -> si_addr;\n \t      /* I believe this is claimed to work on all platforms for\t*/\n \t      /* Linux 2.3.47 and later.  Hopefully we don't have to\t*/\n@@ -2478,6 +2541,10 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \t    in_allocd_block = (HDR(addr) != 0);\n #\tendif\n         if (!in_allocd_block) {\n+\t    /* FIXME - We should make sure that we invoke the\t*/\n+\t    /* old handler with the appropriate calling \t*/\n+\t    /* sequence, which often depends on SA_SIGINFO.\t*/\n+\n \t    /* Heap blocks now begin and end on page boundaries */\n             SIG_PF old_handler;\n             \n@@ -2494,19 +2561,25 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \t\t    return(EXCEPTION_CONTINUE_SEARCH);\n #\t\tendif\n             } else {\n-#\t\tif defined (SUNOS4) || defined(FREEBSD)\n+#\t\tif defined (SUNOS4) \\\n+                    || (defined(FREEBSD) && !defined(SUNOS5SIGS))\n \t\t    (*old_handler) (sig, code, scp, addr);\n \t\t    return;\n #\t\tendif\n #\t\tif defined (SUNOS5SIGS)\n+                    /*\n+                     * FIXME: For FreeBSD, this code should check if the \n+                     * old signal handler used the traditional BSD style and\n+                     * if so call it using that style.\n+                     */\n \t\t    (*(REAL_SIG_PF)old_handler) (sig, scp, context);\n \t\t    return;\n #\t\tendif\n #\t\tif defined (LINUX)\n #\t\t    if defined(ALPHA) || defined(M68K)\n \t\t        (*(REAL_SIG_PF)old_handler) (sig, code, sc);\n #\t\t    else \n-#\t\t      if defined(IA64) || defined(HP_PA)\n+#\t\t      if defined(IA64) || defined(HP_PA) || defined(X86_64)\n \t\t        (*(REAL_SIG_PF)old_handler) (sig, si, scp);\n #\t\t      else\n \t\t        (*(REAL_SIG_PF)old_handler) (sig, sc);\n@@ -2600,7 +2673,8 @@ void GC_dirty_init()\n       struct sigaction\tact, oldact;\n       /* We should probably specify SA_SIGINFO for Linux, and handle \t*/\n       /* the different architectures more uniformly.\t\t\t*/\n-#     if defined(IRIX5) || defined(LINUX) || defined(OSF1) || defined(HURD)\n+#     if defined(IRIX5) || defined(LINUX) && !defined(X86_64) \\\n+\t || defined(OSF1) || defined(HURD)\n     \tact.sa_flags\t= SA_RESTART;\n         act.sa_handler  = (SIG_PF)GC_write_fault_handler;\n #     else\n@@ -2623,7 +2697,7 @@ void GC_dirty_init()\n         GC_err_printf0(\"Page size not multiple of HBLKSIZE\\n\");\n         ABORT(\"Page size not multiple of HBLKSIZE\");\n     }\n-#   if defined(SUNOS4) || defined(FREEBSD)\n+#   if defined(SUNOS4) || (defined(FREEBSD) && !defined(SUNOS5SIGS))\n       GC_old_bus_handler = signal(SIGBUS, GC_write_fault_handler);\n       if (GC_old_bus_handler == SIG_IGN) {\n         GC_err_printf0(\"Previously ignored bus error!?\");\n@@ -2647,13 +2721,13 @@ void GC_dirty_init()\n #\tendif\n       }\n #   endif\n-#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(LINUX) \\\n-       || defined(OSF1) || defined(HURD)\n+#   if (defined(SUNOS5SIGS) && !defined(FREEBSD)) || defined(IRIX5) \\\n+       || defined(LINUX) || defined(OSF1) || defined(HURD)\n       /* SUNOS5SIGS includes HPUX */\n #     if defined(GC_IRIX_THREADS)\n       \tsigaction(SIGSEGV, 0, &oldact);\n       \tsigaction(SIGSEGV, &act, 0);\n-#     else\n+#     else \n \t{\n \t  int res = sigaction(SIGSEGV, &act, &oldact);\n \t  if (res != 0) ABORT(\"Sigaction failed\");\n@@ -2679,8 +2753,9 @@ void GC_dirty_init()\n \t  GC_err_printf0(\"Replaced other SIGSEGV handler\\n\");\n #       endif\n       }\n-#   endif\n-#   if defined(HPUX) || defined(LINUX) || defined(HURD)\n+#   endif /* (SUNOS5SIGS && !FREEBSD) || IRIX5 || LINUX || OSF1 || HURD */\n+#   if defined(HPUX) || defined(LINUX) || defined(HURD) \\\n+      || (defined(FREEBSD) && defined(SUNOS5SIGS))\n       sigaction(SIGBUS, &act, &oldact);\n       GC_old_bus_handler = oldact.sa_handler;\n       if (GC_old_bus_handler == SIG_IGN) {\n@@ -2692,7 +2767,7 @@ void GC_dirty_init()\n \t  GC_err_printf0(\"Replaced other SIGBUS handler\\n\");\n #       endif\n       }\n-#   endif /* HPUX || LINUX || HURD */\n+#   endif /* HPUX || LINUX || HURD || (FREEBSD && SUNOS5SIGS) */\n #   if defined(MSWIN32)\n       GC_old_segv_handler = SetUnhandledExceptionFilter(GC_write_fault_handler);\n       if (GC_old_segv_handler != NULL) {\n@@ -2977,7 +3052,7 @@ word n;\n #include <sys/procfs.h>\n #include <sys/stat.h>\n \n-#define INITIAL_BUF_SZ 4096\n+#define INITIAL_BUF_SZ 16384\n word GC_proc_buf_size = INITIAL_BUF_SZ;\n char *GC_proc_buf;\n \n@@ -3091,7 +3166,7 @@ int dummy;\n                 GC_proc_buf = bufp = new_buf;\n                 GC_proc_buf_size = new_size;\n             }\n-            if (syscall(SYS_read, GC_proc_fd, bufp, GC_proc_buf_size) <= 0) {\n+            if (READ(GC_proc_fd, bufp, GC_proc_buf_size) <= 0) {\n                 WARN(\"Insufficient space for /proc read\\n\", 0);\n                 /* Punt:\t*/\n         \tmemset(GC_grungy_pages, 0xff, sizeof (page_hash_table));\n@@ -3429,6 +3504,8 @@ static void *GC_mprotect_thread(void *arg) {\n     } msg;\n \n     mach_msg_id_t id;\n+\n+    GC_darwin_register_mach_handler_thread(mach_thread_self());\n     \n     for(;;) {\n         r = mach_msg(\n@@ -3886,13 +3963,15 @@ kern_return_t catch_exception_raise_state_identity(\n \n #endif /* NEED_CALLINFO */\n \n+#if defined(GC_HAVE_BUILTIN_BACKTRACE)\n+# include <execinfo.h>\n+#endif\n+\n #ifdef SAVE_CALL_CHAIN\n \n #if NARGS == 0 && NFRAMES % 2 == 0 /* No padding */ \\\n     && defined(GC_HAVE_BUILTIN_BACKTRACE)\n \n-#include <execinfo.h>\n-\n void GC_save_callers (info) \n struct callinfo info[NFRAMES];\n {\n@@ -3968,6 +4047,8 @@ struct callinfo info[NFRAMES];\n     static int reentry_count = 0;\n     GC_bool stop = FALSE;\n \n+    /* FIXME: This should probably use a different lock, so that we\t*/\n+    /* become callable with or without the allocation lock.\t\t*/\n     LOCK();\n       ++reentry_count;\n     UNLOCK();\n@@ -4002,7 +4083,8 @@ struct callinfo info[NFRAMES];\n #\t  ifdef LINUX\n \t    FILE *pipe;\n #\t  endif\n-#\t  if defined(GC_HAVE_BUILTIN_BACKTRACE)\n+#\t  if defined(GC_HAVE_BUILTIN_BACKTRACE) \\\n+\t     && !defined(GC_BACKTRACE_SYMBOLS_BROKEN)\n \t    char **sym_name =\n \t      backtrace_symbols((void **)(&(info[i].ci_pc)), 1);\n \t    char *name = sym_name[0];\n@@ -4021,6 +4103,9 @@ struct callinfo info[NFRAMES];\n #\t\tdefine RESULT_SZ 200\n \t\tstatic char result_buf[RESULT_SZ];\n \t\tsize_t result_len;\n+\t\tchar *old_preload;\n+#\t\tdefine PRELOAD_SZ 200\n+    \t\tchar preload_buf[PRELOAD_SZ];\n \t\tstatic GC_bool found_exe_name = FALSE;\n \t\tstatic GC_bool will_fail = FALSE;\n \t\tint ret_code;\n@@ -4042,7 +4127,20 @@ struct callinfo info[NFRAMES];\n \t\t/* isn't time critical.\t\t\t\t\t*/\n \t\tsprintf(cmd_buf, \"/usr/bin/addr2line -f -e %s 0x%lx\", exe_name,\n \t\t\t\t (unsigned long)info[i].ci_pc);\n+\t\told_preload = getenv (\"LD_PRELOAD\");\n+\t        if (0 != old_preload) {\n+\t\t  if (strlen (old_preload) >= PRELOAD_SZ) {\n+\t\t    will_fail = TRUE;\n+\t\t    goto out;\n+\t\t  }\n+\t\t  strcpy (preload_buf, old_preload);\n+\t\t  unsetenv (\"LD_PRELOAD\");\n+\t        }\n \t\tpipe = popen(cmd_buf, \"r\");\n+\t\tif (0 != old_preload\n+\t\t    && 0 != setenv (\"LD_PRELOAD\", preload_buf, 0)) {\n+\t\t  WARN(\"Failed to reset LD_PRELOAD\\n\", 0);\n+      \t\t}\n \t\tif (pipe == NULL\n \t\t    || (result_len = fread(result_buf, 1, RESULT_SZ - 1, pipe))\n \t\t       == 0) {\n@@ -4079,7 +4177,8 @@ struct callinfo info[NFRAMES];\n \t    }\n #\t  endif /* LINUX */\n \t  GC_err_printf1(\"\\t\\t%s\\n\", name);\n-#\t  if defined(GC_HAVE_BUILTIN_BACKTRACE)\n+#\t  if defined(GC_HAVE_BUILTIN_BACKTRACE) \\\n+\t     && !defined(GC_BACKTRACE_SYMBOLS_BROKEN)\n \t    free(sym_name);  /* May call GC_free; that's OK */\n #         endif\n \t}"}, {"sha": "2a3b91917c71ca5000873d6b79dd5e6145f22b65", "filename": "boehm-gc/pthread_support.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fpthread_support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fpthread_support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpthread_support.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -47,6 +47,7 @@\n /*#define DEBUG_THREADS 1*/\n /*#define GC_ASSERTIONS*/\n \n+# include \"gc.h\"\n # include \"private/pthread_support.h\"\n \n # if defined(GC_PTHREADS) && !defined(GC_SOLARIS_THREADS) \\"}, {"sha": "1e43d0904f9a53953b2027acd95f4265888a1701", "filename": "boehm-gc/solaris_pthreads.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -16,8 +16,10 @@\n  * Modified by Peter C. for Solaris Posix Threads.\n  */\n \n-# if defined(GC_SOLARIS_PTHREADS)\n+# if defined(GC_SOLARIS_PTHREADS) || defined(GC_THREADS)\n # include \"private/gc_priv.h\"\n+# endif\n+# if defined(GC_SOLARIS_PTHREADS)\n # include <pthread.h>\n # include <thread.h>\n # include <signal.h>"}, {"sha": "0a07690a27aa035d121748fdb4d06feb0e846003", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -16,9 +16,12 @@\n  */\n /* Boehm, September 14, 1994 4:44 pm PDT */\n \n-# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)\n+# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS) \\\n+     || defined(GC_THREADS)\n+#   include \"private/gc_priv.h\"\n+# endif\n \n-# include \"private/gc_priv.h\"\n+# if defined(GC_SOLARIS_THREADS) || defined(GC_SOLARIS_PTHREADS)\n # include \"private/solaris_threads.h\"\n # include <thread.h>\n # include <synch.h>\n@@ -786,6 +789,7 @@ void GC_thr_init(void)\n {\n     GC_thread t;\n     thread_t tid;\n+    int ret;\n \n     if (GC_thr_initialized)\n \t    return;\n@@ -803,9 +807,11 @@ void GC_thr_init(void)\n       t = GC_new_thread(thr_self());\n       t -> stack_size = 0;\n       t -> flags = DETACHED | CLIENT_OWNS_STACK;\n-    if (thr_create(0 /* stack */, 0 /* stack_size */, GC_thr_daemon,\n-    \t\t   0 /* arg */, THR_DETACHED | THR_DAEMON,\n-    \t\t   &tid /* thread_id */) != 0) {\n+    ret = thr_create(0 /* stack */, 0 /* stack_size */, GC_thr_daemon,\n+    \t\t     0 /* arg */, THR_DETACHED | THR_DAEMON,\n+    \t\t     &tid /* thread_id */);\n+    if (ret != 0) {\n+\tGC_err_printf1(\"Thr_create returned %ld\\n\", ret);\n     \tABORT(\"Cant fork daemon\");\n     }\n     thr_setprio(tid, 126);"}, {"sha": "f4e8aeed62c72b9c989360ae79754b8e834f141f", "filename": "boehm-gc/specific.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fspecific.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fspecific.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fspecific.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -11,11 +11,11 @@\n  * modified is included with the above copyright notice.\n  */\n \n-#if defined(GC_LINUX_THREADS)\n-\n #include \"private/gc_priv.h\" /* For GC_compare_and_exchange, GC_memory_barrier */\n #include \"private/specific.h\"\n \n+#if defined(GC_LINUX_THREADS)\n+\n static tse invalid_tse = {INVALID_QTID, 0, 0, INVALID_THREADID};\n \t\t\t/* A thread-specific data entry which will never\t*/\n \t\t\t/* appear valid to a reader.  Used to fill in empty\t*/"}, {"sha": "e1676aadead5ced4bc2a0b183ddbf43f714b19bb", "filename": "boehm-gc/tests/test.c", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftests%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftests%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -208,7 +208,6 @@ sexpr y;\n #ifdef GC_GCJ_SUPPORT\n \n #include \"gc_mark.h\"\n-#include \"private/dbg_mlc.h\"  /* For USR_PTR_FROM_BASE */\n #include \"gc_gcj.h\"\n \n /* The following struct emulates the vtable in gcj.\t*/\n@@ -233,7 +232,7 @@ struct GC_ms_entry * fake_gcj_mark_proc(word * addr,\n     sexpr x;\n     if (1 == env) {\n \t/* Object allocated with debug allocator.\t*/\n-\taddr = (word *)USR_PTR_FROM_BASE(addr);\n+\taddr = (word *)GC_USR_PTR_FROM_BASE(addr);\n     }\n     x = (sexpr)(addr + 1); /* Skip the vtable pointer. */\n     mark_stack_ptr = GC_MARK_AND_PUSH(\n@@ -1256,9 +1255,11 @@ void run_one_test()\n \tFAIL;\n       }\n       if (!TEST_FAIL_COUNT(1)) {\n-#\tif!(defined(RS6000) || defined(POWERPC) || defined(IA64))\n+#\tif!(defined(RS6000) || defined(POWERPC) || defined(IA64)) || defined(M68K)\n \t  /* ON RS6000s function pointers point to a descriptor in the\t*/\n \t  /* data segment, so there should have been no failures.\t*/\n+\t  /* The same applies to IA64.  Something similar seems to\t*/\n+\t  /* be going on with NetBSD/M68K.\t\t\t\t*/\n     \t  (void)GC_printf0(\"GC_is_visible produced wrong failure indication\\n\");\n     \t  FAIL;\n #\tendif\n@@ -1486,10 +1487,6 @@ void SetMinimumStack(long minSize)\n #   endif\n     n_tests = 0;\n     \n-#if defined(__APPLE__) && defined(__MACH__)\n-\tGC_INIT();\n-#endif\n-    \n #   if defined(DJGPP)\n \t/* No good way to determine stack base from library; do it */\n \t/* manually on this platform.\t\t\t\t   */\n@@ -1501,7 +1498,7 @@ void SetMinimumStack(long minSize)\n \t/* Cheat and let stdio initialize toolbox for us.\t*/\n \tprintf(\"Testing GC Macintosh port.\\n\");\n #   endif\n-    GC_INIT();\t/* Only needed if gc is dynamic library.\t*/\n+    GC_INIT();\t/* Only needed on a few platforms.\t*/\n     (void) GC_set_warn_proc(warn_proc);\n #   if (defined(MPROTECT_VDB) || defined(PROC_VDB)) \\\n           && !defined(MAKE_BACK_GRAPH)\n@@ -1794,9 +1791,7 @@ main()\n           (void)GC_printf0(\"pthread_default_stacksize_np failed.\\n\");\n \t}\n #   endif\t/* GC_HPUX_THREADS */\n-# \tif defined(__APPLE__) && defined(__MACH__)\n-\t\tGC_INIT();\n-#\tendif\n+    GC_INIT();\n \n     pthread_attr_init(&attr);\n #   if defined(GC_IRIX_THREADS) || defined(GC_FREEBSD_THREADS) \\"}, {"sha": "6661e411927fba49ccc3d45dac85756ad4ad2d21", "filename": "boehm-gc/tests/test_cpp.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftests%2Ftest_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftests%2Ftest_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftest_cpp.cc?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -192,7 +192,7 @@ int APIENTRY WinMain(\n # endif\n #endif\n \n-   GC_init();\n+   GC_INIT();\n \n #  if defined(MACOS)                        // MacOS\n     char* argv_[] = {\"test_cpp\", \"10\"};     //   doesn't"}, {"sha": "870e38723a8dc4aa7dc34abe2ff5d9f7296ff8d3", "filename": "boehm-gc/tests/trace_test.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftests%2Ftrace_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftests%2Ftrace_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftests%2Ftrace_test.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -10,6 +10,7 @@ struct treenode {\n struct treenode * mktree(int i) {\n   struct treenode * r = GC_MALLOC(sizeof(struct treenode));\n   if (0 == i) return 0;\n+  if (1 == i) r = GC_MALLOC_ATOMIC(sizeof(struct treenode));\n   r -> x = mktree(i-1);\n   r -> y = mktree(i-1);\n   return r;"}, {"sha": "264b7240cbe8d5fa88c590ed5f6e21a88d7a6c9b", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,3 +1,4 @@\n+# include \"gc_config_macros.h\"\n # include \"private/gcconfig.h\"\n # include <stdio.h>\n "}, {"sha": "373257cd260dc7f97a10964a7fd0c9c21a3c0943", "filename": "boehm-gc/typd_mlc.c", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftypd_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Ftypd_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftypd_mlc.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -348,8 +348,6 @@ mse * GC_array_mark_proc GC_PROTO((register word * addr,\n \t\t\t\t   mse * mark_stack_limit,\n \t\t\t\t   word env));\n \n-GC_descr GC_generic_array_descr;\n-\n /* Caller does not hold allocation lock. */\n void GC_init_explicit_typing()\n {\n@@ -370,47 +368,25 @@ void GC_init_explicit_typing()\n     }\n     GC_explicit_typing_initialized = TRUE;\n     /* Set up object kind with simple indirect descriptor. */\n-      GC_eobjfreelist = (ptr_t *)\n-          GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n-      if (GC_eobjfreelist == 0) ABORT(\"Couldn't allocate GC_eobjfreelist\");\n-      BZERO(GC_eobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n-      GC_explicit_kind = GC_n_kinds++;\n-      GC_obj_kinds[GC_explicit_kind].ok_freelist = GC_eobjfreelist;\n-      GC_obj_kinds[GC_explicit_kind].ok_reclaim_list = 0;\n-      GC_obj_kinds[GC_explicit_kind].ok_descriptor =\n-    \t\t(((word)WORDS_TO_BYTES(-1)) | GC_DS_PER_OBJECT);\n-      GC_obj_kinds[GC_explicit_kind].ok_relocate_descr = TRUE;\n-      GC_obj_kinds[GC_explicit_kind].ok_init = TRUE;\n+      GC_eobjfreelist = (ptr_t *)GC_new_free_list_inner();\n+      GC_explicit_kind = GC_new_kind_inner(\n+\t\t      \t    (void **)GC_eobjfreelist,\n+\t\t      \t    (((word)WORDS_TO_BYTES(-1)) | GC_DS_PER_OBJECT),\n+\t\t\t    TRUE, TRUE);\n     \t\t/* Descriptors are in the last word of the object. */\n-      GC_typed_mark_proc_index = GC_n_mark_procs;\n-      GC_mark_procs[GC_typed_mark_proc_index] = GC_typed_mark_proc;\n-      GC_n_mark_procs++;\n-        /* Moving this up breaks DEC AXP compiler.      */\n+      GC_typed_mark_proc_index = GC_new_proc_inner(GC_typed_mark_proc);\n     /* Set up object kind with array descriptor. */\n-      GC_arobjfreelist = (ptr_t *)\n-          GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n-      if (GC_arobjfreelist == 0) ABORT(\"Couldn't allocate GC_arobjfreelist\");\n-      BZERO(GC_arobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n-      if (GC_n_mark_procs >= MAX_MARK_PROCS)\n-      \t\tABORT(\"No slot for array mark proc\");\n-      GC_array_mark_proc_index = GC_n_mark_procs++;\n-      if (GC_n_kinds >= MAXOBJKINDS)\n-      \t\tABORT(\"No kind available for array objects\");\n-      GC_array_kind = GC_n_kinds++;\n-      GC_obj_kinds[GC_array_kind].ok_freelist = GC_arobjfreelist;\n-      GC_obj_kinds[GC_array_kind].ok_reclaim_list = 0;\n-      GC_obj_kinds[GC_array_kind].ok_descriptor =\n-    \t\tGC_MAKE_PROC(GC_array_mark_proc_index, 0);;\n-      GC_obj_kinds[GC_array_kind].ok_relocate_descr = FALSE;\n-      GC_obj_kinds[GC_array_kind].ok_init = TRUE;\n-    \t\t/* Descriptors are in the last word of the object. */\n-            GC_mark_procs[GC_array_mark_proc_index] = GC_array_mark_proc;\n+      GC_arobjfreelist = (ptr_t *)GC_new_free_list_inner();\n+      GC_array_mark_proc_index = GC_new_proc_inner(GC_array_mark_proc);\n+      GC_array_kind = GC_new_kind_inner(\n+\t\t      \t    (void **)GC_arobjfreelist,\n+\t\t\t    GC_MAKE_PROC(GC_array_mark_proc_index, 0),\n+\t\t\t    FALSE, TRUE);\n       for (i = 0; i < WORDSZ/2; i++) {\n           GC_descr d = (((word)(-1)) >> (WORDSZ - i)) << (WORDSZ - i);\n           d |= GC_DS_BITMAP;\n           GC_bm_table[i] = d;\n       }\n-      GC_generic_array_descr = GC_MAKE_PROC(GC_array_mark_proc_index, 0); \n     UNLOCK();\n     ENABLE_SIGNALS();\n }"}, {"sha": "93000c34e1656b3efb46b6277ff416f8c68c2bc8", "filename": "boehm-gc/version.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -3,7 +3,7 @@\n /* it to keep the old-style build process working.\t\t*/\n #define GC_TMP_VERSION_MAJOR 6\n #define GC_TMP_VERSION_MINOR 3\n-#define GC_TMP_ALPHA_VERSION 1\n+#define GC_TMP_ALPHA_VERSION GC_NOT_ALPHA\n \n #ifndef GC_NOT_ALPHA\n #   define GC_NOT_ALPHA 0xff\n@@ -14,7 +14,7 @@\n      GC_TMP_VERSION_MINOR != GC_VERSION_MINOR || \\\n      defined(GC_ALPHA_VERSION) != (GC_TMP_ALPHA_VERSION != GC_NOT_ALPHA) || \\\n      defined(GC_ALPHA_VERSION) && GC_TMP_ALPHA_VERSION != GC_ALPHA_VERSION\n-#   error Inconsistent version info.  Check version.h and configure.in.\n+#   error Inconsistent version info.  Check README, version.h, and configure.in.\n # endif\n #else\n # define GC_VERSION_MAJOR GC_TMP_VERSION_MAJOR"}, {"sha": "d2e97dee7d0b2cec1e1fca50fe6434ace6579daf", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -130,7 +130,7 @@ static GC_thread GC_new_thread(void) {\n \tABORT(\"DuplicateHandle failed\");\n   }\n   thread_table[i].stack_base = GC_get_stack_base();\n-  /* Up until this point, GC_psuh_all_stacks considers this thread\t*/\n+  /* Up until this point, GC_push_all_stacks considers this thread\t*/\n   /* invalid.\t\t\t\t\t\t\t\t*/\n   if (thread_table[i].stack_base == NULL) \n     ABORT(\"Failed to find stack base in GC_new_thread\");"}, {"sha": "6a73f1bf3654a8d287f3b45e6842b39f087bb2fb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -1,3 +1,10 @@\n+2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* configure.in (GCINCS): Don't use \"boehm-cflags\". Instead, -I \n+\tboehm-gc's include dirs.\n+\t* configure: Rebuilt.\n+\t* include/boehm-gc.h: Include gc_config.h.\n+\n 2004-08-13  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* java/net/InetAddress.java (loopbackAddress): Renamed from "}, {"sha": "79926dd4737095c81d44f84e827108a066dded42", "filename": "libjava/configure", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -7481,10 +7481,7 @@ echo \"${ECHO_T}boehm\" >&6\n     GCLIBS=../boehm-gc/libgcjgc_convenience.la\n     JC1GCSPEC='-fuse-boehm-gc'\n     GCTESTSPEC=\"-L`${PWDCMD-pwd}`/../boehm-gc/.libs -rpath `${PWDCMD-pwd}`/../boehm-gc/.libs\"\n-\n-    # We also want to pick up some cpp flags required when including\n-    # boehm-config.h.  Yuck.\n-    GCINCS=\"`cat ../boehm-gc/boehm-cflags`\"\n+    GCINCS='-I$(top_srcdir)/../boehm-gc/include -I../boehm-gc/include'\n     GCOBJS=boehm.lo\n     GCHDR=boehm-gc.h\n     # The POSIX thread support needs to know this."}, {"sha": "fcc7094128ce5b8e818a2a4e544ae49a8504cac1", "filename": "libjava/configure.in", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.in?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -579,11 +579,8 @@ case \"$GC\" in\n     GCLIBS=../boehm-gc/libgcjgc_convenience.la\n     JC1GCSPEC='-fuse-boehm-gc'\n     GCTESTSPEC=\"-L`${PWDCMD-pwd}`/../boehm-gc/.libs -rpath `${PWDCMD-pwd}`/../boehm-gc/.libs\"\n-\n-    # We also want to pick up some cpp flags required when including\n-    # boehm-config.h.  Yuck.\n-    GCINCS=\"`cat ../boehm-gc/boehm-cflags`\"\n-    GCOBJS=boehm.lo\n+    GCINCS='-I$(top_srcdir)/../boehm-gc/include -I../boehm-gc/include'\n+    GCOBJS=boehm.lo    \n     GCHDR=boehm-gc.h\n     # The POSIX thread support needs to know this.\n     AC_DEFINE(HAVE_BOEHM_GC, 1, [Define if Boehm GC in use.])"}, {"sha": "4e0065f5bb28c936e8ca490184e26204ab79eb97", "filename": "libjava/include/boehm-gc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2Finclude%2Fboehm-gc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4109fe8594fef15d5cb36d1019e5b7c95dbc45f6/libjava%2Finclude%2Fboehm-gc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fboehm-gc.h?ref=4109fe8594fef15d5cb36d1019e5b7c95dbc45f6", "patch": "@@ -26,6 +26,8 @@ extern \"C\"\n #include <java/lang/Class.h>\n #include <string.h>\n \n+#include <gc_config.h>\n+\n extern \"C\" void * GC_gcj_malloc(size_t, void *);\n extern \"C\" void * GC_malloc_atomic(size_t);\n #ifdef THREAD_LOCAL_ALLOC"}]}