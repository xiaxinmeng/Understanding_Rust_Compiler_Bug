{"sha": "31de5b771a7621f2e331e2839e8634dad0c6ee70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkZTViNzcxYTc2MjFmMmUzMzFlMjgzOWU4NjM0ZGFkMGM2ZWU3MA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-05-09T09:32:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-05-09T09:32:51Z"}, "message": "tree-flow-inline.h (var_can_have_subvars): Move ...\n\n2008-05-08  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow-inline.h (var_can_have_subvars): Move ...\n\t* tree-ssa-structalias.c (var_can_have_subvars): ... here.\n\t* tree-flow.h (var_can_have_subvars): Remove.\n\t(push_fields_onto_fieldstack): Remove.\n\t(sort_fieldstack): Likewise.\n\t(struct fieldoff): Move ...\n\t* tree-ssa-structalias.c (struct fieldoff): ... here.  Remove\n\talias_set and base_for_components fields.\n\t(sort_fieldstack): Make static.\n\t(push_fields_onto_fieldstack): Likewise.  Remove code that\n\thandles anything but RECORD_TYPEs.  Remove alias_set and\n\tbase_for_components handling.\n\t(create_variable_info_for): Adjust.\n\nFrom-SVN: r135110", "tree": {"sha": "ba1aff86aaec6d938b63ca9a5e6aba055221e3b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba1aff86aaec6d938b63ca9a5e6aba055221e3b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31de5b771a7621f2e331e2839e8634dad0c6ee70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de5b771a7621f2e331e2839e8634dad0c6ee70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31de5b771a7621f2e331e2839e8634dad0c6ee70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de5b771a7621f2e331e2839e8634dad0c6ee70/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3ee6cb3f69311ba36ca1faf2a25bb536e0acc038", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ee6cb3f69311ba36ca1faf2a25bb536e0acc038", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ee6cb3f69311ba36ca1faf2a25bb536e0acc038"}], "stats": {"total": 331, "additions": 109, "deletions": 222}, "files": [{"sha": "b20ba0facf8afe55e9a56cb3a1f3afef4874dcd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31de5b771a7621f2e331e2839e8634dad0c6ee70", "patch": "@@ -1,3 +1,19 @@\n+2008-05-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow-inline.h (var_can_have_subvars): Move ...\n+\t* tree-ssa-structalias.c (var_can_have_subvars): ... here.\n+\t* tree-flow.h (var_can_have_subvars): Remove.\n+\t(push_fields_onto_fieldstack): Remove.\n+\t(sort_fieldstack): Likewise.\n+\t(struct fieldoff): Move ...\n+\t* tree-ssa-structalias.c (struct fieldoff): ... here.  Remove\n+\talias_set and base_for_components fields.\n+\t(sort_fieldstack): Make static.\n+\t(push_fields_onto_fieldstack): Likewise.  Remove code that\n+\thandles anything but RECORD_TYPEs.  Remove alias_set and\n+\tbase_for_components handling.\n+\t(create_variable_info_for): Adjust.\n+\n 2008-05-08  Seongbae Park  <seongbae.park@gmail.com>\n \n \t* common.opt (Wframe-larger-than=): Shorten the help message"}, {"sha": "f2fe01e18d40977b0c3e17b1982c73231517afc5", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=31de5b771a7621f2e331e2839e8634dad0c6ee70", "patch": "@@ -1581,36 +1581,6 @@ ref_contains_array_ref (const_tree ref)\n   return false;\n }\n \n-\n-/* Return true if V is a tree that we can have subvars for.\n-   Normally, this is any aggregate type.  Also complex\n-   types which are not gimple registers can have subvars.  */\n-\n-static inline bool\n-var_can_have_subvars (const_tree v)\n-{\n-  /* Volatile variables should never have subvars.  */\n-  if (TREE_THIS_VOLATILE (v))\n-    return false;\n-\n-  /* Non decls or memory tags can never have subvars.  */\n-  if (!DECL_P (v) || MTAG_P (v))\n-    return false;\n-\n-  /* Aggregates can have subvars.  */\n-  if (AGGREGATE_TYPE_P (TREE_TYPE (v)))\n-    return true;\n-\n-  /* Complex types variables which are not also a gimple register can\n-    have subvars. */\n-  if (TREE_CODE (TREE_TYPE (v)) == COMPLEX_TYPE\n-      && !DECL_GIMPLE_REG_P (v))\n-    return true;\n-\n-  return false;\n-}\n-\n-\n /* Return true, if the two ranges [POS1, SIZE1] and [POS2, SIZE2]\n    overlap.  SIZE1 and/or SIZE2 can be (unsigned)-1 in which case the\n    range is open-ended.  Otherwise return false.  */"}, {"sha": "848a9d986959d6fd357895f8294d1ba9c050e5c3", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=31de5b771a7621f2e331e2839e8634dad0c6ee70", "patch": "@@ -854,7 +854,6 @@ static inline bool ref_contains_array_ref (const_tree);\n static inline bool array_ref_contains_indirect_ref (const_tree);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n-static inline bool var_can_have_subvars (const_tree);\n extern tree create_tag_raw (enum tree_code, tree, const char *);\n extern void delete_mem_ref_stats (struct function *);\n extern void dump_mem_ref_stats (FILE *);\n@@ -1169,39 +1168,6 @@ rtx addr_for_mem_ref (struct mem_address *, bool);\n void get_address_description (tree, struct mem_address *);\n tree maybe_fold_tmr (tree);\n \n-/* This structure is used during pushing fields onto the fieldstack\n-   to track the offset of the field, since bitpos_of_field gives it\n-   relative to its immediate containing type, and we want it relative\n-   to the ultimate containing object.  */\n-\n-struct fieldoff\n-{\n-  /* Type of the field.  */\n-  tree type;\n-\n-  /* Size, in bits, of the field.  */\n-  tree size;\n-\n-  /* Field.  */\n-  tree decl;\n-\n-  /* Offset from the base of the base containing object to this field.  */\n-  HOST_WIDE_INT offset;  \n-\n-  /* Alias set for the field.  */\n-  alias_set_type alias_set;\n-\n-  /* True, if this offset can be a base for further component accesses.  */\n-  unsigned base_for_components : 1;\n-};\n-typedef struct fieldoff fieldoff_s;\n-\n-DEF_VEC_O(fieldoff_s);\n-DEF_VEC_ALLOC_O(fieldoff_s,heap);\n-int push_fields_onto_fieldstack (tree, VEC(fieldoff_s,heap) **,\n-\t\t\t\t HOST_WIDE_INT, bool *, tree);\n-void sort_fieldstack (VEC(fieldoff_s,heap) *);\n-\n void init_alias_heapvars (void);\n void delete_alias_heapvars (void);\n unsigned int execute_fixup_cfg (void);"}, {"sha": "f368631fa2e915f69e33b9e43c231e576a669ba3", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 93, "deletions": 158, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de5b771a7621f2e331e2839e8634dad0c6ee70/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=31de5b771a7621f2e331e2839e8634dad0c6ee70", "patch": "@@ -3994,6 +3994,30 @@ insert_into_field_list_sorted (varinfo_t base, varinfo_t field)\n     }\n }\n \n+/* This structure is used during pushing fields onto the fieldstack\n+   to track the offset of the field, since bitpos_of_field gives it\n+   relative to its immediate containing type, and we want it relative\n+   to the ultimate containing object.  */\n+\n+struct fieldoff\n+{\n+  /* Type of the field.  */\n+  tree type;\n+\n+  /* Size, in bits, of the field.  */\n+  tree size;\n+\n+  /* Field.  */\n+  tree decl;\n+\n+  /* Offset from the base of the base containing object to this field.  */\n+  HOST_WIDE_INT offset;  \n+};\n+typedef struct fieldoff fieldoff_s;\n+\n+DEF_VEC_O(fieldoff_s);\n+DEF_VEC_ALLOC_O(fieldoff_s,heap);\n+\n /* qsort comparison function for two fieldoff's PA and PB */\n \n static int\n@@ -4012,7 +4036,7 @@ fieldoff_compare (const void *pa, const void *pb)\n }\n \n /* Sort a fieldstack according to the field offset and sizes.  */\n-void\n+static void\n sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n {\n   qsort (VEC_address (fieldoff_s, fieldstack),\n@@ -4021,6 +4045,28 @@ sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n \t fieldoff_compare);\n }\n \n+/* Return true if V is a tree that we can have subvars for.\n+   Normally, this is any aggregate type.  Also complex\n+   types which are not gimple registers can have subvars.  */\n+\n+static inline bool\n+var_can_have_subvars (const_tree v)\n+{\n+  /* Volatile variables should never have subvars.  */\n+  if (TREE_THIS_VOLATILE (v))\n+    return false;\n+\n+  /* Non decls or memory tags can never have subvars.  */\n+  if (!DECL_P (v) || MTAG_P (v))\n+    return false;\n+\n+  /* Aggregates without overlapping fields can have subvars.  */\n+  if (TREE_CODE (TREE_TYPE (v)) == RECORD_TYPE)\n+    return true;\n+\n+  return false;\n+}\n+\n /* Given a TYPE, and a vector of field offsets FIELDSTACK, push all\n    the fields of TYPE onto fieldstack, recording their offsets along\n    the way.\n@@ -4030,172 +4076,63 @@ sort_fieldstack (VEC(fieldoff_s,heap) *fieldstack)\n    Returns the number of fields pushed.\n \n    HAS_UNION is set to true if we find a union type as a field of\n-   TYPE.\n-\n-   ADDRESSABLE_TYPE is the type of the outermost object that could\n-   have its address taken.  */\n+   TYPE.  */\n \n-int\n+static int\n push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n-\t\t\t     HOST_WIDE_INT offset, bool *has_union,\n-\t\t\t     tree addressable_type)\n+\t\t\t     HOST_WIDE_INT offset, bool *has_union)\n {\n   tree field;\n   int count = 0;\n-  unsigned int first_element = VEC_length (fieldoff_s, *fieldstack);\n+\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return 0;\n \n   /* If the vector of fields is growing too big, bail out early.\n      Callers check for VEC_length <= MAX_FIELDS_FOR_FIELD_SENSITIVE, make\n      sure this fails.  */\n-  if (first_element > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n+  if (VEC_length (fieldoff_s, *fieldstack) > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n     return 0;\n \n-  if (TREE_CODE (type) == COMPLEX_TYPE)\n-    {\n-      fieldoff_s *real_part, *img_part;\n-      real_part = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-      real_part->type = TREE_TYPE (type);\n-      real_part->size = TYPE_SIZE (TREE_TYPE (type));\n-      real_part->offset = offset;\n-      real_part->decl = NULL_TREE;\n-      real_part->alias_set = -1;\n-      real_part->base_for_components = false;\n-\n-      img_part = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-      img_part->type = TREE_TYPE (type);\n-      img_part->size = TYPE_SIZE (TREE_TYPE (type));\n-      img_part->offset = offset + TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (type)));\n-      img_part->decl = NULL_TREE;\n-      img_part->alias_set = -1;\n-      img_part->base_for_components = false;\n-\n-      count = 2;\n-    }\n-\n-  else if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      tree sz = TYPE_SIZE (type);\n-      tree elsz = TYPE_SIZE (TREE_TYPE (type));\n-      HOST_WIDE_INT nr;\n-      int i;\n-\n-      if (! sz\n-\t  || ! host_integerp (sz, 1)\n-\t  || TREE_INT_CST_LOW (sz) == 0\n-\t  || ! elsz\n-\t  || ! host_integerp (elsz, 1)\n-\t  || TREE_INT_CST_LOW (elsz) == 0)\n-\treturn 0;\n-\n-      nr = TREE_INT_CST_LOW (sz) / TREE_INT_CST_LOW (elsz);\n-      if (nr > SALIAS_MAX_ARRAY_ELEMENTS)\n-\treturn 0;\n-\n-      for (i = 0; i < nr; ++i)\n-\t{\n-\t  bool push = false;\n-\t  int pushed = 0;\n-\n-\t  if (has_union\n-\t      && (TREE_CODE (TREE_TYPE (type)) == QUAL_UNION_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (type)) == UNION_TYPE))\n-\t    *has_union = true;\n-\n-\t  if (!AGGREGATE_TYPE_P (TREE_TYPE (type))) /* var_can_have_subvars */\n-\t    push = true;\n-\t  else if (!(pushed = push_fields_onto_fieldstack\n-\t\t     (TREE_TYPE (type),\n-\t\t      fieldstack,\n-\t\t      offset + i * TREE_INT_CST_LOW (elsz),\n-\t\t      has_union,\n-\t\t      (TYPE_NONALIASED_COMPONENT (type)\n-\t\t       ? addressable_type\n-\t\t       : TREE_TYPE (type)))))\n-\t    /* Empty structures may have actual size, like in C++. So\n-\t       see if we didn't push any subfields and the size is\n-\t       nonzero, push the field onto the stack */\n-\t    push = true;\n-\n-\t  if (push)\n-\t    {\n-\t      fieldoff_s *pair;\n-\n-\t      pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-\t      pair->type = TREE_TYPE (type);\n-\t      pair->size = elsz;\n-\t      pair->decl = NULL_TREE;\n-\t      pair->offset = offset + i * TREE_INT_CST_LOW (elsz);\n-\t      if (TYPE_NONALIASED_COMPONENT (type))\n-\t\tpair->alias_set = get_alias_set (addressable_type);\n-\t      else\n-\t\tpair->alias_set = -1;\n-\t      pair->base_for_components = false;\n-\t      count++;\n-\t    }\n-\t  else\n-\t    count += pushed;\n-\t}\n-    }\n-\n-  else\n-    {\n-      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\tif (TREE_CODE (field) == FIELD_DECL)\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL)\n+      {\n+\tbool push = false;\n+\tint pushed = 0;\n+\n+\tif (has_union\n+\t    && (TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n+\t\t|| TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n+\t  *has_union = true;\n+\n+\tif (!var_can_have_subvars (field))\n+\t  push = true;\n+\telse if (!(pushed = push_fields_onto_fieldstack\n+\t\t   (TREE_TYPE (field),\n+\t\t    fieldstack,\n+\t\t    offset + bitpos_of_field (field),\n+\t\t    has_union))\n+\t\t && (DECL_SIZE (field)\n+\t\t     && !integer_zerop (DECL_SIZE (field))))\n+\t  /* Empty structures may have actual size, like in C++.  So\n+\t     see if we didn't push any subfields and the size is\n+\t     nonzero, push the field onto the stack.  */\n+\t  push = true;\n+\n+\tif (push)\n \t  {\n-\t    bool push = false;\n-\t    int pushed = 0;\n-\n-\t    if (has_union\n-\t        && (TREE_CODE (TREE_TYPE (field)) == QUAL_UNION_TYPE\n-\t\t    || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))\n-\t      *has_union = true;\n-\n-\t    if (!var_can_have_subvars (field))\n-\t      push = true;\n-\t    else if (!(pushed = push_fields_onto_fieldstack\n-\t\t       (TREE_TYPE (field),\n-\t\t        fieldstack,\n-\t\t        offset + bitpos_of_field (field),\n-\t\t        has_union,\n-\t\t        (DECL_NONADDRESSABLE_P (field)\n-\t\t         ? addressable_type\n-\t\t         : TREE_TYPE (field))))\n-\t\t     && ((DECL_SIZE (field)\n-\t\t\t  && !integer_zerop (DECL_SIZE (field)))\n-\t\t\t || (!DECL_SIZE (field)\n-\t\t\t     && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE)))\n-\t      /* Empty structures may have actual size, like in C++.  So\n-\t         see if we didn't push any subfields and the size is\n-\t         nonzero, push the field onto the stack.  Trailing flexible\n-\t\t array members also need a representative to be able to\n-\t\t treat taking their address in PTA.  */\n-\t      push = true;\n-\n-\t    if (push)\n-\t      {\n-\t        fieldoff_s *pair;\n-\n-\t        pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n-\t        pair->type = TREE_TYPE (field);\n-\t        pair->size = DECL_SIZE (field);\n-\t        pair->decl = field;\n-\t        pair->offset = offset + bitpos_of_field (field);\n-\t        if (DECL_NONADDRESSABLE_P (field))\n-\t          pair->alias_set = get_alias_set (addressable_type);\n-\t        else\n-\t          pair->alias_set = -1;\n-\t        pair->base_for_components = false;\n-\t        count++;\n-\t      }\n-\t    else\n-\t      count += pushed;\n-          }\n-    }\n-\n-  /* Make sure the first pushed field is marked as eligible for\n-     being a base for component references.  */\n-  if (count > 0)\n-    VEC_index (fieldoff_s, *fieldstack, first_element)->base_for_components = true;\n+\t    fieldoff_s *pair;\n+\n+\t    pair = VEC_safe_push (fieldoff_s, heap, *fieldstack, NULL);\n+\t    pair->type = TREE_TYPE (field);\n+\t    pair->size = DECL_SIZE (field);\n+\t    pair->decl = field;\n+\t    pair->offset = offset + bitpos_of_field (field);\n+\t    count++;\n+\t  }\n+\telse\n+\t  count += pushed;\n+      }\n \n   return count;\n }\n@@ -4389,16 +4326,14 @@ create_variable_info_for (tree decl, const char *name)\n \t     || TREE_CODE (decltype) == QUAL_UNION_TYPE;\n   if (var_can_have_subvars (decl) && use_field_sensitive && !hasunion)\n     {\n-      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion,\n-\t\t\t\t   decltype);\n+      push_fields_onto_fieldstack (decltype, &fieldstack, 0, &hasunion);\n       if (hasunion)\n \t{\n \t  VEC_free (fieldoff_s, heap, fieldstack);\n \t  notokay = true;\n \t}\n     }\n \n-\n   /* If the variable doesn't have subvars, we may end up needing to\n      sort the field list and create fake variables for all the\n      fields.  */"}]}