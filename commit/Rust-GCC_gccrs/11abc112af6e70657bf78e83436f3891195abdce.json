{"sha": "11abc112af6e70657bf78e83436f3891195abdce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFhYmMxMTJhZjZlNzA2NTdiZjc4ZTgzNDM2ZjM4OTExOTVhYmRjZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-23T04:35:17Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-23T04:35:17Z"}, "message": "dwarf2out.c (output_call_frame_info): Set SYMBOL_FLAG_LOCAL on generated SYMBOL_REFs for labels.\n\n\t* dwarf2out.c (output_call_frame_info): Set SYMBOL_FLAG_LOCAL on\n\tgenerated SYMBOL_REFs for labels.\n\t* config/darwin-protos.h (machopic_validate_stub_or_non_lazy_ptr):\n\tChange prototype.\n\t(machopic_stub_name): Remove.\n\t(machopic_indirection_name): New function.\n\t(machopic_mcount_stub_name): Likewise.\n\t(machopic_classify_name): Remove.\n\t(machopic_function_base_sym): New function.\n\t(machpoic_classify_symbol): Likewise.\n\t(machopic_classify_ident): Remove.\n\t(machopic_define_ident): Likewise.\n\t(machopic_define_name): Likewise.\n\t(machopic_name_defined_p): Likewise.\n\t(machopic_ident_defined_p): Likewise.\n\t(darwin_strip_name_encoding): Likewise.\n\t(machopic_define_symbol): New function.\n\t* config/darwin.c (hashtab.h): Include.\n\t(machopic_defined_list): Remove.\n\t(machopic_classify_ident): Likewise.\n\t(machopic_classify_name): Likewise.\n\t(machopic_ident_defined_p): Likewise.\n\t(machopic_define_ident): Likewise.\n\t(machopic_define_name): Likewise.\n\t(machopic_symbol_defined_p): New function.\n\t(machopic_classify_symbol): Likewise.\n\t(machopic_data_defined_p): Use machopic_classify_symbol.\n\t(machopic_define_symbol): New function.\n\t(machopic_function_base_sym): New function.\n\t(machopic_non_lazy_pointers): Remove.\n\t(machopic_non_lazy_ptr_name): Likewise.\n\t(machopic_stubs): Likewise.\n\t(machopic_stub_name): Likewise.\n\t(NON_LAZY_POINTER_SUFFIX): New macro.\n\t(STUB_SUFFIX): Likewise.\n\t(machopic_indirection): New structure.\n\t(machopic_indirections): New variable.\n\t(machopic_indirection_hash): New function.\n\t(machopic_indirection_eq): Likewise.\n\t(machopic_indirection_name): Likewise.\n\t(machopic_mcount_stub_name): New function.\n\t(machopic_validate_stub_or_non_lazy_pointer): Reimplement to use\n\thash table.\n\t(machopic_indirect_data_reference): Rework to use new functions.\n\t(machopic_indirect_call_target): Likewise.\n\t(machopic_legitimize_pic_address): Likewise.\n\t(machopic_output_indirection): New function.\n\t(machopic_finish): Use it.\n\t(machopic_operand_p): Rework to use new functions.\n\t(darwin_encode_seciton_info): Use SYMBOL_REF_FLAGS.\n\t(darwin_strip_name_encoding): Remove.\n\t(update_non_lazy_ptrs): Remove.\n\t(update_stubs): Likewise.\n\t(darwin_non_lazy_pcrel): Use new functions.\n\t* config/darwin.h (ASM_DECLARE_OBJECT_NAME): Likewise.\n\t(ASM_OUTPUT_LABELREF): Likewise.\n\t(ASM_OUTPUT_ALIGNED_DECL_LOCAL): Likewise.\n\t(MACHO_SYMBOL_FLAG_VARIABLE): New macro.\n\t(MACHO_SYMBOL_FLAG_DEFINED): Likewise.\n\t(TARGET_STRIP_NAME_ENCODING): Do not use\n\tdarwin_strip_name_encoding.\n\t(GEN_LAZY_PTR_NAME_FOR_SYMBOL): Do not use\n\tdarwin_strip_name_encoding.\n\t* config/i386/darwin.h (FUNCTION_PROFILER): Use\n\tmachopic_mcount_stub_name.\n\t* config/i386/i386.c (x86_output_mi_thunk): Use\n\tmachopic_indirection_name, not machopic_stub_name.\n\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Use\n\tmachopic_function_base_sym.\n\t(print_operand): Use machopic_classify_symbol.\n\t(rs6000_emit_prologue): Use machopic_function_base_sym.\n\t(output_profile_hook): Do not use machopic_stub_name.\n\t(macho_branch_isalnds): Do not use darwin_strip_name_encoding.\n\nFrom-SVN: r85071", "tree": {"sha": "05e103b023d945855ad79198ef6ad603c55d9ee8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05e103b023d945855ad79198ef6ad603c55d9ee8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11abc112af6e70657bf78e83436f3891195abdce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11abc112af6e70657bf78e83436f3891195abdce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11abc112af6e70657bf78e83436f3891195abdce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11abc112af6e70657bf78e83436f3891195abdce/comments", "author": null, "committer": null, "parents": [{"sha": "f1f90ae0dee37c133fb46ed973c1eddfcea023fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1f90ae0dee37c133fb46ed973c1eddfcea023fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1f90ae0dee37c133fb46ed973c1eddfcea023fa"}], "stats": {"total": 920, "additions": 379, "deletions": 541}, "files": [{"sha": "7e08c3947d393893b90717e9fe8ab282bcdc001a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -1,3 +1,79 @@\n+2004-07-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* dwarf2out.c (output_call_frame_info): Set SYMBOL_FLAG_LOCAL on\n+\tgenerated SYMBOL_REFs for labels.\n+\t* config/darwin-protos.h (machopic_validate_stub_or_non_lazy_ptr):\n+\tChange prototype.\n+\t(machopic_stub_name): Remove.\n+\t(machopic_indirection_name): New function.\n+\t(machopic_mcount_stub_name): Likewise.\n+\t(machopic_classify_name): Remove.\n+\t(machopic_function_base_sym): New function.\n+\t(machpoic_classify_symbol): Likewise.\n+\t(machopic_classify_ident): Remove.\n+\t(machopic_define_ident): Likewise.\n+\t(machopic_define_name): Likewise.\n+\t(machopic_name_defined_p): Likewise.\n+\t(machopic_ident_defined_p): Likewise.\n+\t(darwin_strip_name_encoding): Likewise.\n+\t(machopic_define_symbol): New function.\n+\t* config/darwin.c (hashtab.h): Include.\n+\t(machopic_defined_list): Remove.\n+\t(machopic_classify_ident): Likewise.\n+\t(machopic_classify_name): Likewise.\n+\t(machopic_ident_defined_p): Likewise.\n+\t(machopic_define_ident): Likewise.\n+\t(machopic_define_name): Likewise.\n+\t(machopic_symbol_defined_p): New function.\n+\t(machopic_classify_symbol): Likewise.\n+\t(machopic_data_defined_p): Use machopic_classify_symbol.\n+\t(machopic_define_symbol): New function.\n+\t(machopic_function_base_sym): New function.\n+\t(machopic_non_lazy_pointers): Remove.\n+\t(machopic_non_lazy_ptr_name): Likewise.\n+\t(machopic_stubs): Likewise.\n+\t(machopic_stub_name): Likewise.\n+\t(NON_LAZY_POINTER_SUFFIX): New macro.\n+\t(STUB_SUFFIX): Likewise.\n+\t(machopic_indirection): New structure.\n+\t(machopic_indirections): New variable.\n+\t(machopic_indirection_hash): New function.\n+\t(machopic_indirection_eq): Likewise.\n+\t(machopic_indirection_name): Likewise.\n+\t(machopic_mcount_stub_name): New function.\n+\t(machopic_validate_stub_or_non_lazy_pointer): Reimplement to use\n+\thash table.\n+\t(machopic_indirect_data_reference): Rework to use new functions.\n+\t(machopic_indirect_call_target): Likewise.\n+\t(machopic_legitimize_pic_address): Likewise.\n+\t(machopic_output_indirection): New function.\n+\t(machopic_finish): Use it.\n+\t(machopic_operand_p): Rework to use new functions.\n+\t(darwin_encode_seciton_info): Use SYMBOL_REF_FLAGS.\n+\t(darwin_strip_name_encoding): Remove.\n+\t(update_non_lazy_ptrs): Remove.\n+\t(update_stubs): Likewise.\n+\t(darwin_non_lazy_pcrel): Use new functions.\n+\t* config/darwin.h (ASM_DECLARE_OBJECT_NAME): Likewise.\n+\t(ASM_OUTPUT_LABELREF): Likewise.\n+\t(ASM_OUTPUT_ALIGNED_DECL_LOCAL): Likewise.\n+\t(MACHO_SYMBOL_FLAG_VARIABLE): New macro.\n+\t(MACHO_SYMBOL_FLAG_DEFINED): Likewise.\n+\t(TARGET_STRIP_NAME_ENCODING): Do not use\n+\tdarwin_strip_name_encoding.\n+\t(GEN_LAZY_PTR_NAME_FOR_SYMBOL): Do not use\n+\tdarwin_strip_name_encoding.\n+\t* config/i386/darwin.h (FUNCTION_PROFILER): Use\n+\tmachopic_mcount_stub_name.\n+\t* config/i386/i386.c (x86_output_mi_thunk): Use\n+\tmachopic_indirection_name, not machopic_stub_name.\n+\t* config/rs6000/rs6000.c (rs6000_legitimize_reload_address): Use\n+\tmachopic_function_base_sym.\n+\t(print_operand): Use machopic_classify_symbol.\n+\t(rs6000_emit_prologue): Use machopic_function_base_sym.\n+\t(output_profile_hook): Do not use machopic_stub_name.\n+\t(macho_branch_isalnds): Do not use darwin_strip_name_encoding.\n+\t\n 2004-07-22  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/7284"}, {"sha": "d2d90049264e05e704ea014cfb9f798d3b57ef9a", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -20,11 +20,12 @@ Boston, MA 02111-1307, USA.  */\n \n extern int name_needs_quotes (const char *);\n \n-extern void machopic_validate_stub_or_non_lazy_ptr (const char *, int);\n+extern void machopic_validate_stub_or_non_lazy_ptr (const char *);\n \n extern const char *machopic_function_base_name (void);\n extern void machopic_output_function_base_name (FILE *);\n-extern const char *machopic_stub_name (const char*);\n+extern const char *machopic_indirection_name (rtx, bool);\n+extern const char *machopic_mcount_stub_name (void);\n \n extern void machopic_picsymbol_stub_section (void);\n extern void machopic_picsymbol_stub1_section (void);\n@@ -40,8 +41,9 @@ extern void mod_term_section (void);\n \n #ifdef RTX_CODE\n \n+extern rtx machopic_function_base_sym (void);\n extern int machopic_operand_p (rtx);\n-extern enum machopic_addr_class machopic_classify_name (const char*);\n+extern enum machopic_addr_class machopic_classify_symbol (rtx);\n \n extern rtx machopic_indirect_data_reference (rtx, rtx);\n extern rtx machopic_indirect_call_target (rtx);\n@@ -53,13 +55,8 @@ extern void machopic_asm_out_destructor (rtx, int);\n \n #ifdef TREE_CODE\n \n-extern enum machopic_addr_class machopic_classify_ident (tree);\n-extern void machopic_define_ident (tree);\n-extern void machopic_define_name (const char*);\n-extern int machopic_name_defined_p (const char*);\n-extern int machopic_ident_defined_p (tree);\n+extern void machopic_define_symbol (rtx);\n extern void darwin_encode_section_info (tree, rtx, int);\n-extern const char *darwin_strip_name_encoding (const char *);\n \n #endif /* TREE_CODE */\n "}, {"sha": "e3bf3a25aeb08565d01b034f6e4daba8c0841e64", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 256, "deletions": 496, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -42,11 +42,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"langhooks.h\"\n #include \"tm_p.h\"\n #include \"errors.h\"\n-\n-static int machopic_data_defined_p (const char *);\n-static void update_non_lazy_ptrs (const char *);\n-static void update_stubs (const char *);\n-static const char *machopic_non_lazy_ptr_name (const char*);\n+#include \"hashtab.h\"\n \n int\n name_needs_quotes (const char *name)\n@@ -63,131 +59,37 @@ name_needs_quotes (const char *name)\n  * flag_pic = 2 ... generate indirections and pure code\n  */\n \n-/* This module assumes that (const (symbol_ref \"foo\")) is a legal pic\n-   reference, which will not be changed.  */\n-\n-static GTY(()) tree machopic_defined_list;\n-\n-enum machopic_addr_class\n-machopic_classify_ident (tree ident)\n+static int\n+machopic_symbol_defined_p (rtx sym_ref)\n {\n-  const char *name = IDENTIFIER_POINTER (ident);\n-  int lprefix = (((name[0] == '*' || name[0] == '&')\n-\t\t  && (name[1] == 'L' || (name[1] == '\"' && name[2] == 'L')))\n-\t\t || (   name[0] == '_'\n-\t\t     && name[1] == 'O'\n-\t\t     && name[2] == 'B'\n-\t\t     && name[3] == 'J'\n-\t\t     && name[4] == 'C'\n-\t\t     && name[5] == '_'));\n-  tree temp;\n-\n-  /* The PIC base symbol is always defined.  */\n-  if (! strcmp (name, \"<pic base>\"))\n-    return MACHOPIC_DEFINED_DATA;\n-\n-  if (name[0] != '!')\n-    {\n-      /* Here if no special encoding to be found.  */\n-      if (lprefix)\n-\t{\n-\t  const char *name = IDENTIFIER_POINTER (ident);\n-\t  int len = strlen (name);\n-\n-\t  if ((len > 5 && !strcmp (name + len - 5, \"$stub\"))\n-\t      || (len > 6 && !strcmp (name + len - 6, \"$stub\\\"\")))\n-\t    return MACHOPIC_DEFINED_FUNCTION;\n-\t  return MACHOPIC_DEFINED_DATA;\n-\t}\n-\n-      for (temp = machopic_defined_list;\n-\t   temp != NULL_TREE;\n-\t   temp = TREE_CHAIN (temp))\n-\t{\n-\t  if (ident == TREE_VALUE (temp))\n-\t    return MACHOPIC_DEFINED_DATA;\n-\t}\n-\n-      if (TREE_ASM_WRITTEN (ident))\n-\treturn MACHOPIC_DEFINED_DATA;\n-\n-      return MACHOPIC_UNDEFINED;\n-    }\n-\n-  else if (name[1] == 'D')\n-    return MACHOPIC_DEFINED_DATA;\n-\n-  else if (name[1] == 'T')\n-    return MACHOPIC_DEFINED_FUNCTION;\n-\n-  /* It is possible that someone is holding a \"stale\" name, which has\n-     since been defined.  See if there is a \"defined\" name (i.e,\n-     different from NAME only in having a '!D_' or a '!T_' instead of\n-     a '!d_' or '!t_' prefix) in the identifier hash tables.  If so, say\n-     that this identifier is defined.  */\n-  else if (name[1] == 'd' || name[1] == 't')\n-    {\n-      char *new_name;\n-      new_name = (char *)alloca (strlen (name) + 1);\n-      strcpy (new_name, name);\n-      new_name[1] = (name[1] == 'd') ? 'D' : 'T';\n-      if (maybe_get_identifier (new_name) != NULL)\n-\treturn  (name[1] == 'd') ? MACHOPIC_DEFINED_DATA\n-\t\t\t\t : MACHOPIC_DEFINED_FUNCTION;\n-    }\n-\n-  for (temp = machopic_defined_list; temp != NULL_TREE; temp = TREE_CHAIN (temp))\n-    {\n-      if (ident == TREE_VALUE (temp))\n-\t{\n-\t  if (name[1] == 'T')\n-\t    return MACHOPIC_DEFINED_FUNCTION;\n-\t  else\n-\t    return MACHOPIC_DEFINED_DATA;\n-\t}\n-    }\n-\n-  if (name[1] == 't' || name[1] == 'T')\n-    {\n-      if (lprefix)\n-\treturn MACHOPIC_DEFINED_FUNCTION;\n-      else\n-\treturn MACHOPIC_UNDEFINED_FUNCTION;\n-    }\n-  else\n-    {\n-      if (lprefix)\n-\treturn MACHOPIC_DEFINED_DATA;\n-      else\n-\treturn MACHOPIC_UNDEFINED_DATA;\n-    }\n+  return ((SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_DEFINED)\n+\t  /* Local symbols must always be defined.  */\n+\t  || SYMBOL_REF_LOCAL_P (sym_ref));\n }\n \n+/* This module assumes that (const (symbol_ref \"foo\")) is a legal pic\n+   reference, which will not be changed.  */\n \n enum machopic_addr_class\n-machopic_classify_name (const char *name)\n+machopic_classify_symbol (rtx sym_ref)\n {\n-  return machopic_classify_ident (get_identifier (name));\n-}\n-\n-int\n-machopic_ident_defined_p (tree ident)\n-{\n-  switch (machopic_classify_ident (ident))\n-    {\n-    case MACHOPIC_UNDEFINED:\n-    case MACHOPIC_UNDEFINED_DATA:\n-    case MACHOPIC_UNDEFINED_FUNCTION:\n-      return 0;\n-    default:\n-      return 1;\n-    }\n+  int flags;\n+  bool function_p;\n+\n+  flags = SYMBOL_REF_FLAGS (sym_ref);\n+  function_p = SYMBOL_REF_FUNCTION_P (sym_ref);\n+  if (machopic_symbol_defined_p (sym_ref))\n+    return (function_p \n+\t    ? MACHOPIC_DEFINED_FUNCTION : MACHOPIC_DEFINED_DATA);\n+  else\n+    return (function_p \n+\t    ? MACHOPIC_UNDEFINED_FUNCTION : MACHOPIC_UNDEFINED_DATA);\n }\n \n static int\n-machopic_data_defined_p (const char *name)\n+machopic_data_defined_p (rtx sym_ref)\n {\n-  switch (machopic_classify_ident (get_identifier (name)))\n+  switch (machopic_classify_symbol (sym_ref))\n     {\n     case MACHOPIC_DEFINED_DATA:\n       return 1;\n@@ -196,24 +98,14 @@ machopic_data_defined_p (const char *name)\n     }\n }\n \n-int\n-machopic_name_defined_p (const char *name)\n-{\n-  return machopic_ident_defined_p (get_identifier (name));\n-}\n-\n-void\n-machopic_define_ident (tree ident)\n-{\n-  if (!machopic_ident_defined_p (ident))\n-    machopic_defined_list =\n-      tree_cons (NULL_TREE, ident, machopic_defined_list);\n-}\n-\n void\n-machopic_define_name (const char *name)\n+machopic_define_symbol (rtx mem)\n {\n-  machopic_define_ident (get_identifier (name));\n+  rtx sym_ref;\n+  if (GET_CODE (mem) != MEM)\n+    abort ();\n+  sym_ref = XEXP (mem, 0);\n+  SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;\n }\n \n static GTY(()) char * function_base;\n@@ -234,6 +126,19 @@ machopic_function_base_name (void)\n   return function_base;\n }\n \n+/* Return a SYMBOL_REF for the PIC function base.  */\n+\n+rtx\n+machopic_function_base_sym (void)\n+{\n+  rtx sym_ref;\n+\n+  sym_ref = gen_rtx_SYMBOL_REF (Pmode, machopic_function_base_name ());\n+  SYMBOL_REF_FLAGS (sym_ref) \n+    |= (MACHO_SYMBOL_FLAG_VARIABLE | MACHO_SYMBOL_FLAG_DEFINED);\n+  return sym_ref;\n+}\n+\n static GTY(()) const char * function_base_func_name;\n static GTY(()) int current_pic_label_num;\n \n@@ -255,182 +160,155 @@ machopic_output_function_base_name (FILE *file)\n   fprintf (file, \"\\\"L%011d$pb\\\"\", current_pic_label_num);\n }\n \n-static GTY(()) tree machopic_non_lazy_pointers;\n-\n-/* Return a non-lazy pointer name corresponding to the given name,\n-   either by finding it in our list of pointer names, or by generating\n-   a new one.  */\n+/* The suffix attached to non-lazy pointer symbols.  */\n+#define NON_LAZY_POINTER_SUFFIX \"$non_lazy_ptr\"\n+/* The suffix attached to stub symbols.  */\n+#define STUB_SUFFIX \"$stub\"\n \n-static const char *\n-machopic_non_lazy_ptr_name (const char *name)\n+typedef struct machopic_indirection GTY (())\n {\n-  const char *temp_name;\n-  tree temp, ident = get_identifier (name);\n+  /* The SYMBOL_REF for the entity referenced.  */\n+  rtx symbol;\n+  /* The IDENTIFIER_NODE giving the name of the stub or non-lazy\n+     pointer.  */\n+  tree ptr_name;\n+  /* True iff this entry is for a stub (as opposed to a non-lazy\n+     pointer).  */\n+  bool stub_p;\n+  /* True iff this stub or pointer pointer has been referenced.  */\n+  bool used;\n+} machopic_indirection;\n+\n+/* A table mapping stub names and non-lazy pointer names to\n+   SYMBOL_REFs for the stubbed-to and pointed-to entities.  */\n+\n+static GTY ((param_is (struct machopic_indirection))) htab_t \n+  machopic_indirections;\n+\n+/* Return a hash value for a SLOT in the indirections hash table.  */\n+\n+static hashval_t\n+machopic_indirection_hash (const void *slot)\n+{\n+  const machopic_indirection *p = (const machopic_indirection *) slot;\n+  return IDENTIFIER_HASH_VALUE (p->ptr_name);\n+}\n \n-  for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n-    {\n-      if (ident == TREE_VALUE (temp))\n-\treturn IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n-    }\n+/* Returns true if the KEY is the same as that associated with\n+   SLOT.  */\n+\n+static int\n+machopic_indirection_eq (const void *slot, const void *key)\n+{\n+  return ((const machopic_indirection *) slot)->ptr_name == (tree) key;\n+}\n \n-  name = darwin_strip_name_encoding (name);\n+/* Return the name of the non-lazy pointer (if STUB_P is false) or\n+   stub (if STUB_B is true) corresponding to the given name.  */\n \n-  /* Try again, but comparing names this time.  */\n-  for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n+const char *\n+machopic_indirection_name (rtx sym_ref, bool stub_p)\n+{\n+  char *buffer;\n+  const char *name = XSTR (sym_ref, 0);\n+  int namelen = strlen (name);\n+  tree ptr_name;\n+  machopic_indirection *p;\n+  \n+  /* Construct the name of the non-lazy pointer or stub.  */\n+  if (stub_p)\n     {\n-      if (TREE_VALUE (temp))\n+      int needs_quotes = name_needs_quotes (name);\n+      buffer = alloca (strlen (\"&L\")\n+\t\t       + namelen\n+\t\t       + strlen (STUB_SUFFIX)\n+\t\t       + 2 /* possible quotes */\n+\t\t       + 1 /* '\\0' */);\n+\n+      if (needs_quotes)\n \t{\n-\t  temp_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-\t  temp_name = darwin_strip_name_encoding (temp_name);\n-\t  if (strcmp (name, temp_name) == 0)\n-\t    return IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n+\t  if (name[0] == '*')\n+\t    sprintf (buffer, \"&\\\"L%s\" STUB_SUFFIX \"\\\"\", name + 1);\n+\t  else\n+\t    sprintf (buffer, \"&\\\"L%s%s\" STUB_SUFFIX \"\\\"\", user_label_prefix, \n+\t\t     name);\n \t}\n+      else if (name[0] == '*')\n+\tsprintf (buffer, \"&L%s\" STUB_SUFFIX, name + 1);\n+      else\n+\tsprintf (buffer, \"&L%s%s\" STUB_SUFFIX, user_label_prefix, name);\n+    }\n+  else\n+    {\n+      buffer = alloca (strlen (\"&L\")\n+\t\t       + strlen (user_label_prefix)\n+\t\t       + namelen\n+\t\t       + strlen (NON_LAZY_POINTER_SUFFIX)\n+\t\t       + 1 /* '\\0' */);\n+      if (name[0] == '*')\n+\tsprintf (buffer, \"&L%s\" NON_LAZY_POINTER_SUFFIX, name + 1);\n+      else\n+\tsprintf (buffer, \"&L%s%s\" NON_LAZY_POINTER_SUFFIX, \n+\t\t user_label_prefix, name);\n     }\n \n-  {\n-    char *buffer;\n-    int namelen = strlen (name);\n-    int bufferlen = 0;\n-    tree ptr_name;\n-\n-    buffer = alloca (namelen + strlen(\"$non_lazy_ptr\") + 5);\n-\n-    strcpy (buffer, \"&L\");\n-    bufferlen = 2;\n-    if (name[0] == '*')\n-      {\n-        memcpy (buffer + bufferlen, name+1, namelen-1+1);\n-        bufferlen += namelen-1;\n-      }\n-    else\n-      {\n-\tstrcpy (buffer + bufferlen, user_label_prefix);\n-\tbufferlen += strlen (user_label_prefix);\n-\tmemcpy (buffer + bufferlen, name, namelen+1);\n-        bufferlen += namelen;\n-      }\n-\n-    memcpy (buffer + bufferlen, \"$non_lazy_ptr\", strlen(\"$non_lazy_ptr\")+1);\n-    bufferlen += strlen(\"$non_lazy_ptr\");\n-    ptr_name = get_identifier (buffer);\n-\n-    machopic_non_lazy_pointers\n-      = tree_cons (ptr_name, ident, machopic_non_lazy_pointers);\n-\n-    TREE_USED (machopic_non_lazy_pointers) = 0;\n-\n-    return IDENTIFIER_POINTER (ptr_name);\n-  }\n+  /* See if we already have it.  */\n+  ptr_name = maybe_get_identifier (buffer);\n+  /* If not, create a mapping from the non-lazy pointer to the\n+     SYMBOL_REF.  */\n+  if (!ptr_name)\n+    {\n+      void **slot;\n+      ptr_name = get_identifier (buffer);\n+      p = (machopic_indirection *) ggc_alloc (sizeof (machopic_indirection));\n+      p->symbol = sym_ref;\n+      p->ptr_name = ptr_name;\n+      p->stub_p = stub_p;\n+      p->used = 0;\n+      if (!machopic_indirections)\n+\tmachopic_indirections \n+\t  = htab_create_ggc (37, \n+\t\t\t     machopic_indirection_hash,\n+\t\t\t     machopic_indirection_eq,\n+\t\t\t     /*htab_del=*/NULL);\n+      slot = htab_find_slot_with_hash (machopic_indirections, ptr_name,\n+\t\t\t\t       IDENTIFIER_HASH_VALUE (ptr_name),\n+\t\t\t\t       INSERT);\n+      *((machopic_indirection **) slot) = p;\n+    }\n+  \n+  return IDENTIFIER_POINTER (ptr_name);\n }\n \n-static GTY(()) tree machopic_stubs;\n-\n-/* Return the name of the stub corresponding to the given name,\n-   generating a new stub name if necessary.  */\n+/* Return the name of the stub for the mcount function.  */\n \n-const char *\n-machopic_stub_name (const char *name)\n+const char*\n+machopic_mcount_stub_name (void)\n {\n-  tree temp, ident = get_identifier (name);\n-  const char *tname;\n-\n-  for (temp = machopic_stubs;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n-    {\n-      if (ident == TREE_VALUE (temp))\n-\treturn IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n-      tname = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-      if (strcmp (name, tname) == 0)\n-\treturn IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n-      /* A library call name might not be section-encoded yet, so try\n-\t it against a stripped name.  */\n-      if (name[0] != '!'\n-\t  && tname[0] == '!'\n-\t  && strcmp (name, tname + 4) == 0)\n-\treturn IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n-    }\n-\n-  name = darwin_strip_name_encoding (name);\n-\n-  {\n-    char *buffer;\n-    int bufferlen = 0;\n-    int namelen = strlen (name);\n-    tree ptr_name;\n-    int needs_quotes = name_needs_quotes (name);\n-\n-    buffer = alloca (namelen + 20);\n-\n-    if (needs_quotes)\n-      {\n-        strcpy (buffer, \"&\\\"L\");\n-        bufferlen = strlen(\"&\\\"L\");\n-      }\n-    else\n-      {\n-        strcpy (buffer, \"&L\");\n-        bufferlen = strlen(\"&L\");\n-      }\n-    \n-    if (name[0] == '*')\n-      {\n-\tmemcpy (buffer + bufferlen, name+1, namelen - 1 +1);\n-        bufferlen += namelen - 1;\n-      }\n-    else\n-      {\n-\tstrcpy (buffer + bufferlen, user_label_prefix);\n-\tbufferlen += strlen (user_label_prefix);\n-\tmemcpy (buffer + bufferlen, name, namelen+1);\n-        bufferlen += namelen;\n-      }\n-\n-    if (needs_quotes)\n-      {\n-        memcpy (buffer + bufferlen, \"$stub\\\"\", strlen(\"$stub\\\"\")+1);\n-        bufferlen += strlen(\"$stub\\\"\");\n-      }\n-    else\n-      {\n-        memcpy (buffer + bufferlen, \"$stub\", strlen(\"$stub\")+1);\n-        bufferlen += strlen(\"$stub\");\n-      }\n-    ptr_name = get_identifier (buffer);\n-\n-    machopic_stubs = tree_cons (ptr_name, ident, machopic_stubs);\n-    TREE_USED (machopic_stubs) = 0;\n-\n-    return IDENTIFIER_POINTER (ptr_name);\n-  }\n+  return \"&L*mcount$stub\";\n }\n \n+/* If NAME is the name of a stub or a non-lazy pointer , mark the stub\n+   or non-lazy pointer as used -- and mark the object to which the\n+   pointer/stub refers as used as well, since the pointer/stub will\n+   emit a reference to it.  */\n+\n void\n-machopic_validate_stub_or_non_lazy_ptr (const char *name, int validate_stub)\n+machopic_validate_stub_or_non_lazy_ptr (const char *name)\n {\n-  const char *real_name;\n-  tree temp, ident = get_identifier (name), id2;\n+  tree ident = get_identifier (name);\n \n-    for (temp = (validate_stub ? machopic_stubs : machopic_non_lazy_pointers);\n-         temp != NULL_TREE;\n-         temp = TREE_CHAIN (temp))\n-      if (ident == TREE_PURPOSE (temp))\n-\t{\n-\t  /* Mark both the stub or non-lazy pointer as well as the\n-\t     original symbol as being referenced.  */\n-          TREE_USED (temp) = 1;\n-\t  if (TREE_CODE (TREE_VALUE (temp)) == IDENTIFIER_NODE)\n-\t    mark_referenced (TREE_VALUE (temp));\n-\t  real_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-\t  real_name = darwin_strip_name_encoding (real_name);\n-\t  id2 = maybe_get_identifier (real_name);\n-\t  if (id2)\n-\t    mark_referenced (id2);\n-\t}\n+  machopic_indirection *p;\n+  \n+  p = ((machopic_indirection *) \n+       (htab_find_with_hash (machopic_indirections, ident,\n+\t\t\t     IDENTIFIER_HASH_VALUE (ident))));\n+  if (p)\n+    {\n+      p->used = 1;\n+      mark_referenced (ident);\n+      mark_referenced (get_identifier (XSTR (p->symbol, 0)));\n+    }\n }\n \n /* Transform ORIG, which may be any data source, to the corresponding\n@@ -446,8 +324,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n \n   if (GET_CODE (orig) == SYMBOL_REF)\n     {\n-      const char *name = XSTR (orig, 0);\n-      int defined = machopic_data_defined_p (name);\n+      int defined = machopic_data_defined_p (orig);\n \n       if (defined && MACHO_DYNAMIC_NO_PIC_P)\n \t{\n@@ -463,8 +340,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n       else if (defined)\n \t{\n #if defined (TARGET_TOC) || defined (HAVE_lo_sum)\n-\t  rtx pic_base = gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t\t     machopic_function_base_name ());\n+\t  rtx pic_base = machopic_function_base_sym ();\n \t  rtx offset = gen_rtx_CONST (Pmode,\n \t\t\t\t      gen_rtx_MINUS (Pmode, orig, pic_base));\n #endif\n@@ -498,8 +374,9 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n \t  return orig;\n \t}\n \n-      ptr_ref = gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t\t    machopic_non_lazy_ptr_name (name));\n+      ptr_ref = (gen_rtx_SYMBOL_REF \n+\t\t (Pmode, \n+\t\t  machopic_indirection_name (orig, /*stub_p=*/false)));\n \n      SYMBOL_REF_DECL (ptr_ref) = SYMBOL_REF_DECL (orig);\n \n@@ -575,24 +452,20 @@ machopic_indirect_call_target (rtx target)\n   if (GET_CODE (target) != MEM)\n     return target;\n \n-  if (MACHOPIC_INDIRECT && GET_CODE (XEXP (target, 0)) == SYMBOL_REF)\n+  if (MACHOPIC_INDIRECT \n+      && GET_CODE (XEXP (target, 0)) == SYMBOL_REF\n+      && !(SYMBOL_REF_FLAGS (XEXP (target, 0))\n+\t   & MACHO_SYMBOL_FLAG_DEFINED))\n     {\n-      enum machine_mode mode = GET_MODE (XEXP (target, 0));\n-      const char *name = XSTR (XEXP (target, 0), 0);\n-\n-      /* If the name is already defined, we need do nothing.  */\n-      if (name[0] == '!' && name[1] == 'T')\n-\treturn target;\n-\n-      if (!machopic_name_defined_p (name))\n-\t{\n-\t  const char *stub_name = machopic_stub_name (name);\n-\t  tree decl = SYMBOL_REF_DECL (XEXP (target, 0));\n-\n-\t  XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);\n-\t  SYMBOL_REF_DECL (XEXP (target, 0)) = decl;\n-\t  RTX_UNCHANGING_P (target) = 1;\n-\t}\n+      rtx sym_ref = XEXP (target, 0);\n+      const char *stub_name = machopic_indirection_name (sym_ref, \n+\t\t\t\t\t\t\t /*stub_p=*/true);\n+      enum machine_mode mode = GET_MODE (sym_ref);\n+      tree decl = SYMBOL_REF_DECL (sym_ref);\n+      \n+      XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);\n+      SYMBOL_REF_DECL (XEXP (target, 0)) = decl;\n+      RTX_UNCHANGING_P (target) = 1;\n     }\n \n   return target;\n@@ -630,7 +503,7 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n       if (MACHO_DYNAMIC_NO_PIC_P)\n \tpic_base = CONST0_RTX (Pmode);\n       else\n-      pic_base = gen_rtx_SYMBOL_REF (Pmode, machopic_function_base_name ());\n+\tpic_base = machopic_function_base_sym ();\n \n       if (GET_CODE (orig) == MEM)\n \t{\n@@ -885,26 +758,31 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n   return pic_ref;\n }\n \n+/* Output the stub or non-lazy pointer in *SLOT, if it has been used.\n+   DATA is the FILE* for assembly output.  Called from\n+   htab_traverse.  */\n \n-void\n-machopic_finish (FILE *asm_out_file)\n+static int\n+machopic_output_indirection (void **slot, void *data)\n {\n-  tree temp;\n+  machopic_indirection *p = *((machopic_indirection **) slot);\n+  FILE *asm_out_file = (FILE *) data;\n+  rtx symbol;\n+  const char *sym_name;\n+  const char *ptr_name;\n+  \n+  if (!p->used)\n+    return 1;\n \n-  for (temp = machopic_stubs;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n+  symbol = p->symbol;\n+  sym_name = XSTR (symbol, 0);\n+  ptr_name = IDENTIFIER_POINTER (p->ptr_name);\n+  \n+  if (p->stub_p)\n     {\n-      const char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-      const char *stub_name = IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n       char *sym;\n       char *stub;\n \n-      if (! TREE_USED (temp))\n-\tcontinue;\n-\n-      sym_name = darwin_strip_name_encoding (sym_name);\n-\n       sym = alloca (strlen (sym_name) + 2);\n       if (sym_name[0] == '*' || sym_name[0] == '&')\n \tstrcpy (sym, sym_name + 1);\n@@ -913,48 +791,47 @@ machopic_finish (FILE *asm_out_file)\n       else\n \tsprintf (sym, \"%s%s\", user_label_prefix, sym_name);\n \n-      stub = alloca (strlen (stub_name) + 2);\n-      if (stub_name[0] == '*' || stub_name[0] == '&')\n-\tstrcpy (stub, stub_name + 1);\n+      stub = alloca (strlen (ptr_name) + 2);\n+      if (ptr_name[0] == '*' || ptr_name[0] == '&')\n+\tstrcpy (stub, ptr_name + 1);\n       else\n-\tsprintf (stub, \"%s%s\", user_label_prefix, stub_name);\n+\tsprintf (stub, \"%s%s\", user_label_prefix, ptr_name);\n \n-      machopic_output_stub (asm_out_file, sym, stub);\n+      machopic_output_stub (asm_out_file, sym, stub);    \n     }\n-\n-  for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n+  else if (machopic_symbol_defined_p (symbol))\n     {\n-      const char *const sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-      const char *const lazy_name = IDENTIFIER_POINTER (TREE_PURPOSE (temp));\n-\n-      if (! TREE_USED (temp))\n-\tcontinue;\n-\n-      if (machopic_ident_defined_p (TREE_VALUE (temp)))\n-\t{\n-\t  data_section ();\n-\t  assemble_align (GET_MODE_ALIGNMENT (Pmode));\n-\t  assemble_label (lazy_name);\n-\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),\n-\t\t\t    GET_MODE_SIZE (Pmode),\n-\t\t\t    GET_MODE_ALIGNMENT (Pmode), 1);\n-\t}\n-      else\n-\t{\n-\t  machopic_nl_symbol_ptr_section ();\n-\t  assemble_name (asm_out_file, lazy_name);\n-\t  fprintf (asm_out_file, \":\\n\");\n-\n-\t  fprintf (asm_out_file, \"\\t.indirect_symbol \");\n-\t  assemble_name (asm_out_file, sym_name);\n-\t  fprintf (asm_out_file, \"\\n\");\n-\n-\t  assemble_integer (const0_rtx, GET_MODE_SIZE (Pmode),\n-\t\t\t    GET_MODE_ALIGNMENT (Pmode), 1);\n-\t}\n+      data_section ();\n+      assemble_align (GET_MODE_ALIGNMENT (Pmode));\n+      assemble_label (ptr_name);\n+      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),\n+\t\t\tGET_MODE_SIZE (Pmode),\n+\t\t\tGET_MODE_ALIGNMENT (Pmode), 1);\n     }\n+  else\n+    {\n+      machopic_nl_symbol_ptr_section ();\n+      assemble_name (asm_out_file, ptr_name);\n+      fprintf (asm_out_file, \":\\n\");\n+      \n+      fprintf (asm_out_file, \"\\t.indirect_symbol \");\n+      assemble_name (asm_out_file, sym_name);\n+      fprintf (asm_out_file, \"\\n\");\n+      \n+      assemble_integer (const0_rtx, GET_MODE_SIZE (Pmode),\n+\t\t\tGET_MODE_ALIGNMENT (Pmode), 1);\n+    }\n+  \n+  return 1;\n+}\n+\n+void\n+machopic_finish (FILE *asm_out_file)\n+{\n+  if (machopic_indirections)\n+    htab_traverse_noresize (machopic_indirections, \n+\t\t\t    machopic_output_indirection,\n+\t\t\t    asm_out_file);\n }\n \n int\n@@ -966,7 +843,7 @@ machopic_operand_p (rtx op)\n \top = XEXP (op, 0);\n \n       if (GET_CODE (op) == SYMBOL_REF)\n-\treturn machopic_name_defined_p (XSTR (op, 0));\n+\treturn machopic_symbol_defined_p (op);\n       else\n \treturn 0;\n     }\n@@ -977,8 +854,8 @@ machopic_operand_p (rtx op)\n   if (GET_CODE (op) == MINUS\n       && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n       && GET_CODE (XEXP (op, 1)) == SYMBOL_REF\n-      && machopic_name_defined_p (XSTR (XEXP (op, 0), 0))\n-      && machopic_name_defined_p (XSTR (XEXP (op, 1), 0)))\n+      && machopic_symbol_defined_p (XEXP (op, 0))\n+      && machopic_symbol_defined_p (XEXP (op, 1)))\n       return 1;\n \n   return 0;\n@@ -991,140 +868,25 @@ machopic_operand_p (rtx op)\n void\n darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n {\n-  char code = '\\0';\n-  int defined = 0;\n   rtx sym_ref;\n-  const char *orig_str;\n-  char *new_str;\n-  size_t len, new_len;\n \n   /* Do the standard encoding things first.  */\n   default_encode_section_info (decl, rtl, first);\n \n-  /* With the introduction of symbol_ref flags, some of the following\n-     code has become redundant and should be removed at some point.  */\n+  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)\n+    return;\n \n-  if ((TREE_CODE (decl) == FUNCTION_DECL\n-       || TREE_CODE (decl) == VAR_DECL)\n-      && !DECL_EXTERNAL (decl)\n+  sym_ref = XEXP (rtl, 0);\n+  if (TREE_CODE (decl) == VAR_DECL)\n+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_VARIABLE;\n+\n+  if (!DECL_EXTERNAL (decl)\n       && (!TREE_PUBLIC (decl) || (!DECL_ONE_ONLY (decl) && !DECL_WEAK (decl)))\n       && ((TREE_STATIC (decl)\n \t   && (!DECL_COMMON (decl) || !TREE_PUBLIC (decl)))\n \t  || (!DECL_COMMON (decl) && DECL_INITIAL (decl)\n \t      && DECL_INITIAL (decl) != error_mark_node)))\n-    defined = 1;\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    code = (defined ? 'T' : 't');\n-  else if (TREE_CODE (decl) == VAR_DECL)\n-    code = (defined ? 'D' : 'd');\n-\n-  if (code == '\\0')\n-    return;\n-\n-  sym_ref = XEXP (rtl, 0);\n-  orig_str = XSTR (sym_ref, 0);\n-  len = strlen (orig_str) + 1;\n-\n-  if (orig_str[0] == '!')\n-    {\n-      /* Already encoded; see if we need to change it.  */\n-      if (code == orig_str[1])\n-\treturn;\n-      /* Yes, tweak a copy of the name and put it in a new string.  */\n-      new_str = alloca (len);\n-      memcpy (new_str, orig_str, len);\n-      new_str[1] = code;\n-      XSTR (sym_ref, 0) = ggc_alloc_string (new_str, len);\n-    }\n-  else\n-    {\n-      /* Add the encoding.  */\n-      new_len = len + 4;\n-      new_str = alloca (new_len);\n-      new_str[0] = '!';\n-      new_str[1] = code;\n-      new_str[2] = '_';\n-      new_str[3] = '_';\n-      memcpy (new_str + 4, orig_str, len);\n-      XSTR (sym_ref, 0) = ggc_alloc_string (new_str, new_len);\n-    }\n-  /* The non-lazy pointer list may have captured references to the\n-     old encoded name, change them.  */\n-  if (TREE_CODE (decl) == VAR_DECL)\n-    update_non_lazy_ptrs (XSTR (sym_ref, 0));\n-  else\n-    update_stubs (XSTR (sym_ref, 0));\n-}\n-\n-/* Undo the effects of the above.  */\n-\n-const char *\n-darwin_strip_name_encoding (const char *str)\n-{\n-  return str[0] == '!' ? str + 4 : str;\n-}\n-\n-/* Scan the list of non-lazy pointers and update any recorded names whose\n-   stripped name matches the argument.  */\n-\n-static void\n-update_non_lazy_ptrs (const char *name)\n-{\n-  const char *name1, *name2;\n-  tree temp;\n-\n-  name1 = darwin_strip_name_encoding (name);\n-\n-  for (temp = machopic_non_lazy_pointers;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n-    {\n-      const char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-\n-      if (*sym_name == '!')\n-\t{\n-\t  name2 = darwin_strip_name_encoding (sym_name);\n-\t  if (strcmp (name1, name2) == 0)\n-\t    {\n-\t      /* FIXME: This breaks the identifier hash table.  */\n-\t      IDENTIFIER_NODE_CHECK (TREE_VALUE (temp))->identifier.id.str\n-\t\t= (unsigned char *) name;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Scan the list of stubs and update any recorded names whose\n-   stripped name matches the argument.  */\n-\n-static void\n-update_stubs (const char *name)\n-{\n-  const char *name1, *name2;\n-  tree temp;\n-\n-  name1 = darwin_strip_name_encoding (name);\n-\n-  for (temp = machopic_stubs;\n-       temp != NULL_TREE;\n-       temp = TREE_CHAIN (temp))\n-    {\n-      const char *sym_name = IDENTIFIER_POINTER (TREE_VALUE (temp));\n-\n-      if (*sym_name == '!')\n-\t{\n-\t  name2 = darwin_strip_name_encoding (sym_name);\n-\t  if (strcmp (name1, name2) == 0)\n-\t    {\n-\t      /* FIXME: This breaks the identifier hash table.  */\n-\t      IDENTIFIER_NODE_CHECK (TREE_VALUE (temp))->identifier.id.str\n-\t\t= (unsigned char *) name;\n-\t      break;\n-\t    }\n-\t}\n-    }\n+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;\n }\n \n void\n@@ -1417,14 +1179,12 @@ darwin_emit_unwind_label (FILE *file, tree decl, int for_eh, int empty)\n void\n darwin_non_lazy_pcrel (FILE *file, rtx addr)\n {\n-  const char *str;\n   const char *nlp_name;\n \n   if (GET_CODE (addr) != SYMBOL_REF)\n     abort ();\n \n-  str = darwin_strip_name_encoding (XSTR (addr, 0));\n-  nlp_name = machopic_non_lazy_ptr_name (str);\n+  nlp_name = machopic_indirection_name (addr, /*stub_p=*/false);\n   fputs (\"\\t.long\\t\", file);\n   ASM_OUTPUT_LABELREF (file, nlp_name);\n   fputs (\"-.\", file);"}, {"sha": "14fa7a15e8ead93ca26f6a47e146b1f8500d5920", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -413,7 +413,7 @@ do { text_section ();\t\t\t\t\t\t\t\\\n \n /* The RTTI data (e.g., __ti4name) is common and public (and static),\n    but it does need to be referenced via indirect PIC data pointers.\n-   The machopic_define_name calls are telling the machopic subsystem\n+   The machopic_define_symbol calls are telling the machopic subsystem\n    that the name *is* defined in this module, so it doesn't need to\n    make them indirect.  */\n \n@@ -427,7 +427,7 @@ do { text_section ();\t\t\t\t\t\t\t\\\n       if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n \t   && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n           || DECL_INITIAL (DECL))\t\t\t\t\t\\\n-        machopic_define_name (xname);\t\t\t\t\t\\\n+        machopic_define_symbol (DECL_RTL (DECL));\t\t\t\\\n     if ((TREE_STATIC (DECL)\t\t\t\t\t\t\\\n \t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n         || DECL_INITIAL (DECL))\t\t\t\t\t\t\\\n@@ -448,7 +448,7 @@ do { text_section ();\t\t\t\t\t\t\t\\\n       if ((TREE_STATIC (DECL)                                           \\\n \t   && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))             \\\n           || DECL_INITIAL (DECL))                                       \\\n-        machopic_define_name (xname);                                   \\\n+        machopic_define_symbol (DECL_RTL (DECL));                       \\\n     if ((TREE_STATIC (DECL)                                             \\\n \t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))               \\\n         || DECL_INITIAL (DECL))                                         \\\n@@ -471,18 +471,18 @@ do { text_section ();\t\t\t\t\t\t\t\\\n #undef\tASM_OUTPUT_LABELREF\n #define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\t\t\t     \\\n   do {\t\t\t\t\t\t\t\t\t     \\\n-       const char *xname = darwin_strip_name_encoding (NAME);\t\t     \\\n+       const char *xname = (NAME);\t\t\t\t\t     \\\n        if (! strcmp (xname, \"<pic base>\"))\t\t\t\t     \\\n          machopic_output_function_base_name(FILE);                           \\\n        else if (xname[0] == '&' || xname[0] == '*')\t\t\t     \\\n          {\t\t\t\t\t\t\t\t     \\\n            int len = strlen (xname);\t\t\t\t\t     \\\n \t   if (len > 6 && !strcmp (\"$stub\", xname + len - 5))\t\t     \\\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname, 1);\t\t     \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n \t   else if (len > 7 && !strcmp (\"$stub\\\"\", xname + len - 6))\t     \\\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname, 1);\t\t     \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n \t   else if (len > 14 && !strcmp (\"$non_lazy_ptr\", xname + len - 13)) \\\n-\t     machopic_validate_stub_or_non_lazy_ptr (xname, 0);\t\t     \\\n+\t     machopic_validate_stub_or_non_lazy_ptr (xname);\t\t     \\\n \t   fputs (&xname[1], FILE);\t\t\t\t\t     \\\n \t }\t\t\t\t\t\t\t\t     \\\n        else if (xname[0] == '+' || xname[0] == '-')\t\t\t     \\\n@@ -514,7 +514,7 @@ do { text_section ();\t\t\t\t\t\t\t\\\n \n /* Ensure correct alignment of bss data.  */\n \n-#undef\tASM_OUTPUT_ALIGNED_DECL_LOCAL\n+#undef\tASM_OUTPUT_ALIGNED_DECL_LOCAL\t\t\t\t\t\n #define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN)\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     fputs (\".lcomm \", (FILE));\t\t\t\t\t\t\\\n@@ -524,11 +524,10 @@ do { text_section ();\t\t\t\t\t\t\t\\\n     if ((DECL) && ((TREE_STATIC (DECL)\t\t\t\t\t\\\n \t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n         || DECL_INITIAL (DECL)))\t\t\t\t\t\\\n-      (* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\t\\\n-    if ((DECL) && ((TREE_STATIC (DECL)\t\t\t\t\t\\\n-\t && (!DECL_COMMON (DECL) || !TREE_PUBLIC (DECL)))\t\t\\\n-        || DECL_INITIAL (DECL)))\t\t\t\t\t\\\n-      machopic_define_name (NAME);\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(* targetm.encode_section_info) (DECL, DECL_RTL (DECL), false);\t\\\n+\tmachopic_define_symbol (DECL_RTL (DECL));\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* The maximum alignment which the object file format can support.\n@@ -791,6 +790,12 @@ objc_section_init (void)\t\t\t\\\n #define JUMP_TABLES_IN_TEXT_SECTION 1\n #endif\n \n+/* Set on a symbol with SYMBOL_FLAG_FUNCTION or\n+   MACHO_SYMBOL_FLAG_VARIABLE to indicate that the function or\n+   variable has been defined in this translation unit.  */\n+#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_MACH_DEP)\n+#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_MACH_DEP) << 1)\n+\n /* Symbolic names for various things we might know about a symbol.  */\n \n enum machopic_addr_class {\n@@ -811,7 +816,7 @@ enum machopic_addr_class {\n #undef TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO  darwin_encode_section_info\n #undef TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING  darwin_strip_name_encoding\n+#define TARGET_STRIP_NAME_ENCODING  default_strip_name_encoding\n \n #define GEN_BINDER_NAME_FOR_STUB(BUF,STUB,STUB_LENGTH)\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n@@ -847,7 +852,7 @@ enum machopic_addr_class {\n \n #define GEN_LAZY_PTR_NAME_FOR_SYMBOL(BUF,SYMBOL,SYMBOL_LENGTH)\t\\\n   do {\t\t\t\t\t\t\t\t\\\n-    const char *symbol_ = darwin_strip_name_encoding (SYMBOL);\t\\\n+    const char *symbol_ = (SYMBOL);                             \\\n     char *buffer_ = (BUF);\t\t\t\t\t\\\n     if (symbol_[0] == '\"')\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\"}, {"sha": "711722ab5aedd6b59becdb42646b422b66277fbf", "filename": "gcc/config/i386/darwin.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fi386%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fi386%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdarwin.h?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -143,9 +143,9 @@ Boston, MA 02111-1307, USA.  */\n     do {\t\t\t\t\t\t\t\t\\\n       if (MACHOPIC_INDIRECT)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  const char *name = machopic_stub_name (\"*mcount\");\t\t\\\n+\t  const char *name = machopic_mcount_stub_name ();\t\t\\\n \t  fprintf (FILE, \"\\tcall %s\\n\", name+1);  /*  skip '&'  */\t\\\n-\t  machopic_validate_stub_or_non_lazy_ptr (name, /*stub:*/1);\t\\\n+\t  machopic_validate_stub_or_non_lazy_ptr (name);\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       else fprintf (FILE, \"\\tcall mcount\\n\");\t\t\t\t\\\n     } while (0)"}, {"sha": "da1a7aacfc38e0e94d24440e3183da56f62a5566", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -15521,8 +15521,10 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n #if TARGET_MACHO\n \tif (TARGET_MACHO)\n \t  {\n-\t    const char *ip = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function));\n-\t    tmp = gen_rtx_SYMBOL_REF (Pmode, machopic_stub_name (ip));\n+\t    rtx sym_ref = XEXP (DECL_RTL (function), 0);\n+\t    tmp = (gen_rtx_SYMBOL_REF \n+\t\t   (Pmode, \n+\t\t    machopic_indirection_name (sym_ref, /*stub_p=*/true)));\n \t    tmp = gen_rtx_MEM (QImode, tmp);\n \t    xops[0] = tmp;\n \t    output_asm_insn (\"jmp\\t%0\", xops);"}, {"sha": "02f3092704fb12d7921ba22d3850c76350f58630", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -3675,8 +3675,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n \t{\n \t  rtx offset = gen_rtx_CONST (Pmode,\n \t\t\t gen_rtx_MINUS (Pmode, x,\n-\t\t\t   gen_rtx_SYMBOL_REF (Pmode,\n-\t\t\t     machopic_function_base_name ())));\n+\t\t\t\t\tmachopic_function_base_sym ()));\n \t  x = gen_rtx_LO_SUM (GET_MODE (x),\n \t\tgen_rtx_PLUS (Pmode, pic_offset_table_rtx,\n \t\t  gen_rtx_HIGH (Pmode, offset)), offset);\n@@ -10092,8 +10091,8 @@ print_operand (FILE *file, rtx x, int code)\n \t  const char *name = XSTR (x, 0);\n #if TARGET_MACHO\n \t  if (MACHOPIC_INDIRECT\n-\t      && machopic_classify_name (name) == MACHOPIC_UNDEFINED_FUNCTION)\n-\t    name = machopic_stub_name (name);\n+\t      && machopic_classify_symbol (x) == MACHOPIC_UNDEFINED_FUNCTION)\n+\t    name = machopic_indirection_name (x, /*stub_p=*/true);\n #endif\n \t  assemble_name (file, name);\n \t}\n@@ -12958,8 +12957,7 @@ rs6000_emit_prologue (void)\n       && flag_pic && current_function_uses_pic_offset_table)\n     {\n       rtx lr = gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM);\n-      const char *picbase = machopic_function_base_name ();\n-      rtx src = gen_rtx_SYMBOL_REF (Pmode, picbase);\n+      rtx src = machopic_function_base_sym ();\n \n       rs6000_maybe_dead (emit_insn (gen_load_macho_picbase (lr, src)));\n \n@@ -14456,12 +14454,9 @@ output_profile_hook (int labelno ATTRIBUTE_UNUSED)\n #if TARGET_MACHO\n       /* For PIC code, set up a stub and collect the caller's address\n \t from r0, which is where the prologue puts it.  */\n-      if (MACHOPIC_INDIRECT)\n-\t{\n-\t  mcount_name = machopic_stub_name (mcount_name);\n-\t  if (current_function_uses_pic_offset_table)\n-\t    caller_addr_regno = 0;\n-\t}\n+      if (MACHOPIC_INDIRECT\n+\t  && current_function_uses_pic_offset_table)\n+\tcaller_addr_regno = 0;\n #endif\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, mcount_name),\n \t\t\t 0, VOIDmode, 1,\n@@ -15902,8 +15897,7 @@ macho_branch_islands (void)\n       const char *label =\n \tIDENTIFIER_POINTER (BRANCH_ISLAND_LABEL_NAME (branch_island));\n       const char *name  =\n-\tdarwin_strip_name_encoding (\n-\t  IDENTIFIER_POINTER (BRANCH_ISLAND_FUNCTION_NAME (branch_island)));\n+\tIDENTIFIER_POINTER (BRANCH_ISLAND_FUNCTION_NAME (branch_island));\n       char name_buf[512];\n       /* Cheap copy of the details from the Darwin ASM_OUTPUT_LABELREF().  */\n       if (name[0] == '*' || name[0] == '&')"}, {"sha": "df1544a390ede44c49aa5a4764f0550100b1b31d", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11abc112af6e70657bf78e83436f3891195abdce/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=11abc112af6e70657bf78e83436f3891195abdce", "patch": "@@ -2265,9 +2265,13 @@ output_call_frame_info (int for_eh)\n \t\t\t\t\t          (DECL_ASSEMBLER_NAME (fde->decl))),\n \t\t     \"FDE initial location\");\n \t  else\n-\t    dw2_asm_output_encoded_addr_rtx (fde_encoding,\n-\t\t     gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin),\n-\t\t     \"FDE initial location\");\n+\t    {\n+\t      rtx sym_ref = gen_rtx_SYMBOL_REF (Pmode, fde->dw_fde_begin);\n+\t      SYMBOL_REF_FLAGS (sym_ref) |= SYMBOL_FLAG_LOCAL;\n+\t      dw2_asm_output_encoded_addr_rtx (fde_encoding,\n+\t\t\t\t\t       sym_ref,\n+\t\t\t\t\t       \"FDE initial location\");\n+\t    }\n \t  dw2_asm_output_delta (size_of_encoded_value (fde_encoding),\n \t\t\t\tfde->dw_fde_end, fde->dw_fde_begin,\n \t\t\t\t\"FDE address range\");"}]}