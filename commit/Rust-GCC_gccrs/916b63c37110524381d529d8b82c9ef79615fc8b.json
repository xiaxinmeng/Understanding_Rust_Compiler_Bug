{"sha": "916b63c37110524381d529d8b82c9ef79615fc8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE2YjYzYzM3MTEwNTI0MzgxZDUyOWQ4YjgyYzllZjc5NjE1ZmM4Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2006-02-01T02:51:13Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2006-02-01T02:51:13Z"}, "message": "re PR c++/25342 (internal compiler error: in lookup_member, at cp/search.c:1209)\n\n\tPR c++/25342\n\t* cp-tree.h (DECL_TEMPLATE_SPECIALIZATIONS): Revise\n\tdocumentation.\n\t* pt.c (determine_specialization): Use INNERMOST_TEMPLATE_PARMS,\n\tnot TREE_VALUE.\n\t(instantiate_class_template): Simplify.\n\t(verify_class_unification): Remove.\n\t(unify): Document parameters.  Use INNERMOST_TEMPLATE_ARGS to\n\tpermit multiple levels of template arguments.\n\t(more_specialized_class): Simplify.\n\t(get_class_bindings): Pass full arguments to unify.  Fold\n\tverify_class_unification into this function.  Return full\n\targuments.\n\t(most_specialized_class): Adjust for changes to\n\tget_class_bindings.  Issue errors here for ambiguity.  Return the\n\tfully deduced arguments for the most specialized class, in\n\taddition to the partial specialization.\n\tPR c++/25342\n\t* g++.gd/template/partial4.C: New test.\n\nFrom-SVN: r110466", "tree": {"sha": "8e110d0cc4538c8628120bf35b2a3d236919c224", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e110d0cc4538c8628120bf35b2a3d236919c224"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/916b63c37110524381d529d8b82c9ef79615fc8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b63c37110524381d529d8b82c9ef79615fc8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916b63c37110524381d529d8b82c9ef79615fc8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916b63c37110524381d529d8b82c9ef79615fc8b/comments", "author": null, "committer": null, "parents": [{"sha": "f51a281b458a3fd4433a339f99a3ec29504b8959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f51a281b458a3fd4433a339f99a3ec29504b8959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f51a281b458a3fd4433a339f99a3ec29504b8959"}], "stats": {"total": 317, "additions": 195, "deletions": 122}, "files": [{"sha": "eb24a755c9561347465ef0df16fee80765f39fc6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=916b63c37110524381d529d8b82c9ef79615fc8b", "patch": "@@ -1,3 +1,23 @@\n+2006-01-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25342\n+\t* cp-tree.h (DECL_TEMPLATE_SPECIALIZATIONS): Revise\n+\tdocumentation.\n+\t* pt.c (determine_specialization): Use INNERMOST_TEMPLATE_PARMS,\n+\tnot TREE_VALUE.\n+\t(instantiate_class_template): Simplify.\n+\t(verify_class_unification): Remove.\n+\t(unify): Document parameters.  Use INNERMOST_TEMPLATE_ARGS to\n+\tpermit multiple levels of template arguments.\n+\t(more_specialized_class): Simplify.\n+\t(get_class_bindings): Pass full arguments to unify.  Fold\n+\tverify_class_unification into this function.  Return full\n+\targuments.\n+\t(most_specialized_class): Adjust for changes to\n+\tget_class_bindings.  Issue errors here for ambiguity.  Return the\n+\tfully deduced arguments for the most specialized class, in\n+\taddition to the partial specialization.\n+\n 2006-01-31  Ben Elliston  <bje@au.ibm.com>\n \n \t* mangle.c: Comment fix."}, {"sha": "7227083b7c3d72ee9ca42a1b7960b8579ce9aab1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=916b63c37110524381d529d8b82c9ef79615fc8b", "patch": "@@ -2729,12 +2729,13 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n \n    For a class template, this list contains the partial\n    specializations of this template.  (Full specializations are not\n-   recorded on this list.)  The TREE_PURPOSE holds the innermost\n-   arguments used in the partial specialization (e.g., for `template\n-   <class T> struct S<T*, int>' this will be `T*'.)  The TREE_VALUE\n-   holds the innermost template parameters for the specialization\n-   (e.g., `T' in the example above.)  The TREE_TYPE is the _TYPE node\n-   for the partial specialization.\n+   recorded on this list.)  The TREE_PURPOSE holds the arguments used\n+   in the partial specialization (e.g., for `template <class T> struct\n+   S<T*, int>' this will be `T*'.)  The arguments will also include\n+   any outer template arguments.  The TREE_VALUE holds the innermost\n+   template parameters for the specialization (e.g., `T' in the\n+   example above.)  The TREE_TYPE is the _TYPE node for the partial\n+   specialization.\n \n    This list is not used for static variable templates.  */\n #define DECL_TEMPLATE_SPECIALIZATIONS(NODE)     DECL_SIZE (NODE)"}, {"sha": "63277e59964aa769da2741ed01ce693b19d4664b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 147, "deletions": 116, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=916b63c37110524381d529d8b82c9ef79615fc8b", "patch": "@@ -144,7 +144,6 @@ static tree process_partial_specialization (tree);\n static void set_current_access_from_decl (tree);\n static void check_default_tmpl_args (tree, tree, int, int);\n static tree get_template_base (tree, tree, tree, tree);\n-static int verify_class_unification (tree, tree, tree);\n static tree try_class_unification (tree, tree, tree, tree);\n static int coerce_template_template_parms (tree, tree, tsubst_flags_t,\n \t\t\t\t\t   tree, tree);\n@@ -1450,7 +1449,8 @@ determine_specialization (tree template_id,\n \t  if (current_binding_level->kind == sk_template_parms\n \t      && !current_binding_level->explicit_spec_p\n \t      && (TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (fn))\n-\t\t  != TREE_VEC_LENGTH (TREE_VALUE (current_template_parms))))\n+\t\t  != TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS \n+\t\t\t\t      (current_template_parms))))\n \t    continue;\n \n \t  /* See whether this function might be a specialization of this\n@@ -2756,7 +2756,7 @@ process_partial_specialization (tree decl)\n     return decl;\n \n   DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)\n-    = tree_cons (inner_args, inner_parms,\n+    = tree_cons (specargs, inner_parms,\n \t\t DECL_TEMPLATE_SPECIALIZATIONS (maintmpl));\n   TREE_TYPE (DECL_TEMPLATE_SPECIALIZATIONS (maintmpl)) = type;\n   return decl;\n@@ -5493,34 +5493,34 @@ instantiate_class_template (tree type)\n   template = most_general_template (CLASSTYPE_TI_TEMPLATE (type));\n   gcc_assert (TREE_CODE (template) == TEMPLATE_DECL);\n \n-  /* Figure out which arguments are being used to do the\n-     instantiation.  */\n-  args = CLASSTYPE_TI_ARGS (type);\n-\n   /* Determine what specialization of the original template to\n      instantiate.  */\n-  t = most_specialized_class (template, args);\n+  t = most_specialized_class (type, template);\n   if (t == error_mark_node)\n     {\n-      const char *str = \"candidates are:\";\n-      error (\"ambiguous class template instantiation for %q#T\", type);\n-      for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t;\n-\t   t = TREE_CHAIN (t))\n-\t{\n-\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args))\n-\t    {\n-\t      error (\"%s %+#T\", str, TREE_TYPE (t));\n-\t      str = \"               \";\n-\t    }\n-\t}\n       TYPE_BEING_DEFINED (type) = 1;\n       return error_mark_node;\n     }\n+  else if (t)\n+    {\n+      /* This TYPE is actually an instantiation of a partial\n+\t specialization.  We replace the innermost set of ARGS with\n+\t the arguments appropriate for substitution.  For example,\n+\t given:\n+       \n+           template <class T> struct S {};\n+\t   template <class T> struct S<T*> {};\n \n-  if (t)\n-    pattern = TREE_TYPE (t);\n+\t and supposing that we are instantiating S<int*>, ARGS will\n+         presently be {int*} -- but we need {int}.  */\n+      pattern = TREE_TYPE (t);\n+      args = TREE_PURPOSE (t);\n+    }\n   else\n-    pattern = TREE_TYPE (template);\n+    {\n+      pattern = TREE_TYPE (template);\n+      args = CLASSTYPE_TI_ARGS (type);\n+    }\n \n   /* If the template we're instantiating is incomplete, then clearly\n      there's nothing we can do.  */\n@@ -5541,34 +5541,6 @@ instantiate_class_template (tree type)\n \n   push_to_top_level ();\n \n-  if (t)\n-    {\n-      /* This TYPE is actually an instantiation of a partial\n-\t specialization.  We replace the innermost set of ARGS with\n-\t the arguments appropriate for substitution.  For example,\n-\t given:\n-\n-\t   template <class T> struct S {};\n-\t   template <class T> struct S<T*> {};\n-\n-\t and supposing that we are instantiating S<int*>, ARGS will\n-\t present be {int*} but we need {int}.  */\n-      tree inner_args\n-\t= get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n-\t\t\t      args);\n-\n-      /* If there were multiple levels in ARGS, replacing the\n-\t innermost level would alter CLASSTYPE_TI_ARGS, which we don't\n-\t want, so we make a copy first.  */\n-      if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n-\t{\n-\t  args = copy_node (args);\n-\t  SET_TMPL_ARGS_LEVEL (args, TMPL_ARGS_DEPTH (args), inner_args);\n-\t}\n-      else\n-\targs = inner_args;\n-    }\n-\n   SET_CLASSTYPE_INTERFACE_UNKNOWN (type);\n \n   /* Set the input location to the template definition. This is needed\n@@ -9734,34 +9706,6 @@ try_one_overload (tree tparms,\n   return 1;\n }\n \n-/* Verify that nondeduce template argument agrees with the type\n-   obtained from argument deduction.  Return nonzero if the\n-   verification fails.\n-\n-   For example:\n-\n-     struct A { typedef int X; };\n-     template <class T, class U> struct C {};\n-     template <class T> struct C<T, typename T::X> {};\n-\n-   Then with the instantiation `C<A, int>', we can deduce that\n-   `T' is `A' but unify () does not check whether `typename T::X'\n-   is `int'.  This function ensure that they agree.\n-\n-   TARGS, PARMS are the same as the arguments of unify.\n-   ARGS contains template arguments from all levels.  */\n-\n-static int\n-verify_class_unification (tree targs, tree parms, tree args)\n-{\n-  parms = tsubst (parms, add_outermost_template_args (args, targs),\n-\t\t  tf_none, NULL_TREE);\n-  if (parms == error_mark_node)\n-    return 1;\n-\n-  return !comp_template_args (parms, INNERMOST_TEMPLATE_ARGS (args));\n-}\n-\n /* PARM is a template class (perhaps with unbound template\n    parameters).  ARG is a fully instantiated type.  If ARG can be\n    bound to PARM, return ARG, otherwise return NULL_TREE.  TPARMS and\n@@ -9924,9 +9868,18 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n   return 1;\n }\n \n-/* Takes parameters as for type_unification.  Returns 0 if the\n-   type deduction succeeds, 1 otherwise.  The parameter STRICT is a\n-   bitwise or of the following flags:\n+/* Deduce the value of template parameters.  TPARMS is the (innermost)\n+   set of template parameters to a template.  TARGS is the bindings\n+   for those template parameters, as determined thus far; TARGS may\n+   include template arguments for outer levels of template parameters\n+   as well.  PARM is a parameter to a template function, or a\n+   subcomponent of that parameter; ARG is the corresponding argument.\n+   This function attempts to match PARM with ARG in a manner\n+   consistent with the existing assignments in TARGS.  If more values\n+   are deduced, then TARGS is updated.\n+\n+   Returns 0 if the type deduction succeeds, 1 otherwise.  The\n+   parameter STRICT is a bitwise or of the following flags:\n \n      UNIFY_ALLOW_NONE:\n        Require an exact match between PARM and ARG.\n@@ -10031,7 +9984,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \treturn (TREE_CODE (arg) == TREE_CODE (parm)\n \t\t&& same_type_p (parm, arg)) ? 0 : 1;\n       idx = TEMPLATE_TYPE_IDX (parm);\n-      targ = TREE_VEC_ELT (targs, idx);\n+      targ = TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx);\n       tparm = TREE_VALUE (TREE_VEC_ELT (tparms, idx));\n \n       /* Check for mixed types and values.  */\n@@ -10132,7 +10085,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t    return 1;\n \t}\n \n-      TREE_VEC_ELT (targs, idx) = arg;\n+      TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n       return 0;\n \n     case TEMPLATE_PARM_INDEX:\n@@ -10146,7 +10099,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t && cp_tree_equal (parm, arg));\n \n       idx = TEMPLATE_PARM_IDX (parm);\n-      targ = TREE_VEC_ELT (targs, idx);\n+      targ = TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx);\n \n       if (targ)\n \treturn !cp_tree_equal (targ, arg);\n@@ -10180,7 +10133,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       else\n \treturn 1;\n \n-      TREE_VEC_ELT (targs, idx) = arg;\n+      TREE_VEC_ELT (INNERMOST_TEMPLATE_ARGS (targs), idx) = arg;\n       return 0;\n \n     case PTRMEM_CST:\n@@ -10705,33 +10658,44 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n   return (better1 > 0) - (better2 > 0);\n }\n \n-/* Given two class template specialization list nodes PAT1 and PAT2, return:\n+/* Determine which of two partial specializations is more specialized.\n \n-   1 if PAT1 is more specialized than PAT2 as described in [temp.class.order].\n-   -1 if PAT2 is more specialized than PAT1.\n-   0 if neither is more specialized.\n+   PAT1 is a TREE_LIST whose TREE_TYPE is the _TYPE node corresponding\n+   to the first partial specialization.  The TREE_VALUE is the\n+   innermost set of template parameters for the partial\n+   specialization.  PAT2 is similar, but for the second template.\n+\n+   Return 1 if the first partial specialization is more specialized;\n+   -1 if the second is more specialized; 0 if neither is more\n+   specialized.\n \n-   FULL_ARGS is the full set of template arguments that triggers this\n-   partial ordering.  */\n+   See [temp.class.order] for information about determining which of\n+   two templates is more specialized.  */ \n \n static int\n-more_specialized_class (tree pat1, tree pat2, tree full_args)\n+more_specialized_class (tree pat1, tree pat2)\n {\n   tree targs;\n+  tree tmpl1, tmpl2;\n   int winner = 0;\n \n+  tmpl1 = TREE_TYPE (pat1);\n+  tmpl2 = TREE_TYPE (pat2);\n+\n   /* Just like what happens for functions, if we are ordering between\n      different class template specializations, we may encounter dependent\n      types in the arguments, and we need our dependency check functions\n      to behave correctly.  */\n   ++processing_template_decl;\n-  targs = get_class_bindings (TREE_VALUE (pat1), TREE_PURPOSE (pat1),\n-\t\t\t      add_outermost_template_args (full_args, TREE_PURPOSE (pat2)));\n+  targs = get_class_bindings (TREE_VALUE (pat1), \n+\t\t\t      CLASSTYPE_TI_ARGS (tmpl1),\n+\t\t\t      CLASSTYPE_TI_ARGS (tmpl2));\n   if (targs)\n     --winner;\n \n-  targs = get_class_bindings (TREE_VALUE (pat2), TREE_PURPOSE (pat2),\n-\t\t\t      add_outermost_template_args (full_args, TREE_PURPOSE (pat1)));\n+  targs = get_class_bindings (TREE_VALUE (pat2), \n+\t\t\t      CLASSTYPE_TI_ARGS (tmpl2),\n+\t\t\t      CLASSTYPE_TI_ARGS (tmpl1));\n   if (targs)\n     ++winner;\n   --processing_template_decl;\n@@ -10806,28 +10770,59 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n      template <class T> struct S<T*, int> {};\n \n    Then, suppose we want to get `S<double*, int>'.  The TPARMS will be\n-   {T}, the PARMS will be {T*, int} and the ARGS will be {double*,\n+   {T}, the SPEC_ARGS will be {T*, int} and the ARGS will be {double*,\n    int}.  The resulting vector will be {double}, indicating that `T'\n    is bound to `double'.  */\n \n static tree\n-get_class_bindings (tree tparms, tree parms, tree args)\n+get_class_bindings (tree tparms, tree spec_args, tree args)\n {\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n-  tree vec = make_tree_vec (ntparms);\n+  tree deduced_args;\n+  tree innermost_deduced_args;\n \n-  if (unify (tparms, vec, parms, INNERMOST_TEMPLATE_ARGS (args),\n+  innermost_deduced_args = make_tree_vec (ntparms);\n+  if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n+    {\n+      deduced_args = copy_node (args);\n+      SET_TMPL_ARGS_LEVEL (deduced_args,\n+\t\t\t   TMPL_ARGS_DEPTH (deduced_args),\n+\t\t\t   innermost_deduced_args);\n+    }\n+  else\n+    deduced_args = innermost_deduced_args; \n+\n+  if (unify (tparms, deduced_args, \n+\t     INNERMOST_TEMPLATE_ARGS (spec_args), \n+\t     INNERMOST_TEMPLATE_ARGS (args), \n \t     UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n \n   for (i =  0; i < ntparms; ++i)\n-    if (! TREE_VEC_ELT (vec, i))\n+    if (! TREE_VEC_ELT (innermost_deduced_args, i))\n       return NULL_TREE;\n \n-  if (verify_class_unification (vec, parms, args))\n+  /* Verify that nondeduced template arguments agree with the type\n+     obtained from argument deduction.\n+     \n+     For example:\n+\n+       struct A { typedef int X; };\n+       template <class T, class U> struct C {};\n+       template <class T> struct C<T, typename T::X> {};\n+\n+     Then with the instantiation `C<A, int>', we can deduce that\n+     `T' is `A' but unify () does not check whether `typename T::X'\n+     is `int'.  */\n+  spec_args = tsubst (spec_args, deduced_args, tf_none, NULL_TREE);\n+  if (spec_args == error_mark_node\n+      /* We only need to check the innermost arguments; the other\n+\t arguments will always agree.  */\n+      || !comp_template_args (INNERMOST_TEMPLATE_ARGS (spec_args),\n+\t\t\t      INNERMOST_TEMPLATE_ARGS (args)))\n     return NULL_TREE;\n \n-  return vec;\n+  return deduced_args;\n }\n \n /* TEMPLATES is a TREE_LIST.  Each TREE_VALUE is a TEMPLATE_DECL.\n@@ -10957,39 +10952,56 @@ most_general_template (tree decl)\n   return decl;\n }\n \n-/* Return the most specialized of the class template specializations\n-   of TMPL which can produce an instantiation matching ARGS, or\n-   error_mark_node if the choice is ambiguous.  */\n+/* Return the most specialized of the class template partial\n+   specializations of TMPL which can produce TYPE, a specialization of\n+   TMPL.  The value returned is actually a TREE_LIST; the TREE_TYPE is\n+   a _TYPE node corresponding to the partial specialization, while the\n+   TREE_PURPOSE is the set of template arguments that must be\n+   substituted into the TREE_TYPE in order to generate TYPE.\n+\n+   If the choice of partial specialization is ambiguous, a diagnostic\n+   is issued, and the error_mark_node is returned.  If there are no\n+   partial specializations of TMPL matching TYPE, then NULL_TREE is\n+   returned.  */\n \n static tree\n-most_specialized_class (tree tmpl, tree args)\n+most_specialized_class (tree type, tree tmpl)\n {\n   tree list = NULL_TREE;\n   tree t;\n   tree champ;\n   int fate;\n+  bool ambiguous_p;\n+  tree args;\n \n   tmpl = most_general_template (tmpl);\n+  args = CLASSTYPE_TI_ARGS (type);\n   for (t = DECL_TEMPLATE_SPECIALIZATIONS (tmpl); t; t = TREE_CHAIN (t))\n     {\n-      tree spec_args\n-\t= get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t), args);\n+      tree partial_spec_args;\n+      tree spec_args;\n+\n+      partial_spec_args = CLASSTYPE_TI_ARGS (TREE_TYPE (t));\n+      spec_args = get_class_bindings (TREE_VALUE (t), \n+\t\t\t\t      partial_spec_args, \n+\t\t\t\t      args);\n       if (spec_args)\n \t{\n-\t  list = tree_cons (TREE_PURPOSE (t), TREE_VALUE (t), list);\n+\t  list = tree_cons (spec_args, TREE_VALUE (t), list);\n \t  TREE_TYPE (list) = TREE_TYPE (t);\n \t}\n     }\n \n   if (! list)\n     return NULL_TREE;\n \n+  ambiguous_p = false;\n   t = list;\n   champ = t;\n   t = TREE_CHAIN (t);\n   for (; t; t = TREE_CHAIN (t))\n     {\n-      fate = more_specialized_class (champ, t, args);\n+      fate = more_specialized_class (champ, t);\n       if (fate == 1)\n \t;\n       else\n@@ -10998,17 +11010,36 @@ most_specialized_class (tree tmpl, tree args)\n \t    {\n \t      t = TREE_CHAIN (t);\n \t      if (! t)\n-\t\treturn error_mark_node;\n+\t\t{\n+\t\t  ambiguous_p = true;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  champ = t;\n \t}\n     }\n \n-  for (t = list; t && t != champ; t = TREE_CHAIN (t))\n+  if (!ambiguous_p)\n+    for (t = list; t && t != champ; t = TREE_CHAIN (t))\n+      {\n+\tfate = more_specialized_class (champ, t);\n+\tif (fate != 1)\n+\t  {\n+\t    ambiguous_p = true;\n+\t    break;\n+\t  }\n+      }\n+\n+  if (ambiguous_p)\n     {\n-      fate = more_specialized_class (champ, t, args);\n-      if (fate != 1)\n-\treturn error_mark_node;\n+      const char *str = \"candidates are:\";\n+      error (\"ambiguous class template instantiation for %q#T\", type);\n+      for (t = list; t; t = TREE_CHAIN (t))\n+\t{\n+\t  error (\"%s %+#T\", str, TREE_TYPE (t));\n+\t  str = \"               \";\n+\t}\n+      return error_mark_node;\n     }\n \n   return champ;"}, {"sha": "cb357c5ca68db4166351af195d9b868af100d4dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=916b63c37110524381d529d8b82c9ef79615fc8b", "patch": "@@ -1,3 +1,8 @@\n+2006-01-31  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/25342\n+\t* g++.gd/template/partial4.C: New test.\n+\n 2006-01-31  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR middle-end/26001"}, {"sha": "8ea202cdfa4969600c87a893fe5ddda36853ea38", "filename": "gcc/testsuite/g++.dg/template/partial4.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/916b63c37110524381d529d8b82c9ef79615fc8b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial4.C?ref=916b63c37110524381d529d8b82c9ef79615fc8b", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/25342\n+\n+template < typename eval >\n+struct tpl_seq_search {\n+  typedef typename eval::enum_type  Enum;\n+  template < Enum first, Enum last >\n+  struct range {\n+  };\n+  template < Enum val >\n+  struct range<val,val> {\n+  };\n+};\n+struct xxx {\n+  typedef int enum_type;\n+  tpl_seq_search<xxx>::range<0, 1> a;\n+};"}]}