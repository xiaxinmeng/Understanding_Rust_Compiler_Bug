{"sha": "69e5544210e3c0e27df3e6590b646c13dcce24e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjllNTU0NDIxMGUzYzBlMjdkZjNlNjU5MGI2NDZjMTNkY2NlMjRlMw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-28T09:15:11Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-30T16:17:18Z"}, "message": "Refactor backward threader registry and profitability code into classes.\n\nThis refactors the registry and the profitability code from the\nbackwards threader into two separate classes.  It cleans up the code,\nand makes it easier for alternate implementations to share code.\n\ngcc/ChangeLog:\n\n\t* tree-ssa-threadbackward.c (class thread_jumps): Split out code\n\tfrom here...\n\t(class back_threader_registry): ...to here...\n\t(class back_threader_profitability): ...and here...\n\t(thread_jumps::thread_through_all_blocks): Remove argument.\n\t(back_threader_registry::back_threader_registry): New.\n\t(back_threader_registry::~back_threader_registry): New.\n\t(back_threader_registry::thread_through_all_blocks): New.\n\t(thread_jumps::profitable_jump_thread_path): Move from here...\n\t(back_threader_profitability::profitable_path_p): ...to here.\n\t(thread_jumps::find_taken_edge): New.\n\t(thread_jumps::convert_and_register_current_path): Move...\n\t(back_threader_registry::register_path): ...to here.\n\t(thread_jumps::register_jump_thread_path_if_profitable): Move...\n\t(thread_jumps::maybe_register_path): ...to here.\n\t(thread_jumps::handle_phi): Call find_taken_edge and\n\tmaybe_register_path.\n\t(thread_jumps::handle_assignment): Same.\n\t(thread_jumps::fsm_find_control_statement_thread_paths): Remove\n\ttree argument to handle_phi and handle_assignment.\n\t(thread_jumps::find_jump_threads_backwards): Set m_name.  Remove\n\tset of m_speed_p and m_max_threaded_paths.\n\t(pass_thread_jumps::execute): Remove second argument from\n\tfind_jump_threads_backwards.\n\t(pass_early_thread_jumps::execute): Same.", "tree": {"sha": "ff08d986511e3f5ed08bc710bfe630633f6fa2ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff08d986511e3f5ed08bc710bfe630633f6fa2ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69e5544210e3c0e27df3e6590b646c13dcce24e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e5544210e3c0e27df3e6590b646c13dcce24e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69e5544210e3c0e27df3e6590b646c13dcce24e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e5544210e3c0e27df3e6590b646c13dcce24e3/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8ea47033a726c9b3455ead98b6ddce2403ec6d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8ea47033a726c9b3455ead98b6ddce2403ec6d9"}], "stats": {"total": 367, "additions": 213, "deletions": 154}, "files": [{"sha": "7dd8594e3d424fab65e8a5618c4faf078f52f3cb", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 213, "deletions": 154, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69e5544210e3c0e27df3e6590b646c13dcce24e3/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69e5544210e3c0e27df3e6590b646c13dcce24e3/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=69e5544210e3c0e27df3e6590b646c13dcce24e3", "patch": "@@ -37,44 +37,79 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-vectorizer.h\"\n \n+// Path registry for the backwards threader.  After all paths have been\n+// registered with register_path(), thread_through_all_blocks() is called\n+// to modify the CFG.\n+\n+class back_threader_registry\n+{\n+public:\n+  back_threader_registry (int max_allowable_paths);\n+  ~back_threader_registry ();\n+  bool register_path (const vec<basic_block> &, edge taken);\n+  bool thread_through_all_blocks ();\n+\n+private:\n+  vec<vec<basic_block>> m_all_paths;\n+  jump_thread_path_registry m_lowlevel_registry;\n+  const int m_max_allowable_paths;\n+  int m_threaded_paths;\n+};\n+\n+// Class to abstract the profitability code for the backwards threader.\n+\n+class back_threader_profitability\n+{\n+public:\n+  back_threader_profitability (bool speed_p)\n+    : m_speed_p (speed_p)\n+  { }\n+  bool profitable_path_p (const vec<basic_block> &, tree name, edge taken,\n+\t\t\t  bool *irreducible_loop = NULL);\n+\n+private:\n+  const bool m_speed_p;\n+};\n+\n class thread_jumps\n {\n public:\n-  void find_jump_threads_backwards (basic_block bb, bool speed_p);\n+  thread_jumps (bool speed_p = true)\n+    : m_profit (speed_p), m_registry (param_max_fsm_thread_paths)\n+  { }\n+  void find_jump_threads_backwards (basic_block bb);\n   bool thread_through_all_blocks ();\n \n private:\n-  edge profitable_jump_thread_path (basic_block bbi, tree name, tree arg,\n-\t\t\t\t    bool *creates_irreducible_loop);\n-  void convert_and_register_current_path (edge taken_edge);\n-  void register_jump_thread_path_if_profitable (tree name, tree arg,\n-\t\t\t\t\t\tbasic_block def_bb);\n-  void handle_assignment (gimple *stmt, tree name, basic_block def_bb);\n-  void handle_phi (gphi *phi, tree name, basic_block def_bb);\n+  void maybe_register_path (const vec<basic_block> &m_path,\n+\t\t\t    tree name,\n+\t\t\t    edge taken_edge);\n+  edge find_taken_edge (const vec<basic_block> &path, tree arg);\n+  void handle_assignment (gimple *stmt, basic_block def_bb);\n+  void handle_phi (gphi *phi, basic_block def_bb);\n   void fsm_find_control_statement_thread_paths (tree name);\n   bool check_subpath_and_update_thread_path (basic_block last_bb,\n \t\t\t\t\t     basic_block new_bb,\n \t\t\t\t\t     int *next_path_length);\n \n-  /* Maximum number of BBs we are allowed to thread.  */\n-  int m_max_threaded_paths;\n   /* Hash to keep track of seen bbs.  */\n   hash_set<basic_block> m_visited_bbs;\n   /* Current path we're analyzing.  */\n   auto_vec<basic_block> m_path;\n   /* Tracks if we have recursed through a loop PHI node.  */\n   bool m_seen_loop_phi;\n-  /* Indicate that we could increase code size to improve the\n-     code path.  */\n-  bool m_speed_p;\n \n-  jump_thread_path_registry m_registry;\n+  tree m_name;\n+  back_threader_profitability m_profit;\n+  back_threader_registry m_registry;\n };\n \n+// Perform the actual jump threading for the all queued paths.\n+\n bool\n thread_jumps::thread_through_all_blocks ()\n {\n-  return m_registry.thread_through_all_blocks (true);\n+  return m_registry.thread_through_all_blocks ();\n }\n \n /* Simple helper to get the last statement from BB, which is assumed\n@@ -133,62 +168,65 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n   return false;\n }\n \n-/* Examine jump threading path PATH to which we want to add BBI.\n+back_threader_registry::back_threader_registry (int max_allowable_paths)\n+  : m_max_allowable_paths (max_allowable_paths)\n+{\n+  m_all_paths.create (5);\n+  m_threaded_paths = 0;\n+}\n \n-   If the resulting path is profitable to thread, then return the\n-   final taken edge from the path, NULL otherwise.\n+back_threader_registry::~back_threader_registry ()\n+{\n+  m_all_paths.release ();\n+}\n+\n+bool\n+back_threader_registry::thread_through_all_blocks ()\n+{\n+  return m_lowlevel_registry.thread_through_all_blocks (true);\n+}\n+\n+/* Examine jump threading path PATH and return TRUE if it is profitable to\n+   thread it, otherwise return FALSE.\n \n    NAME is the SSA_NAME of the variable we found to have a constant\n-   value on PATH.  ARG is the constant value of NAME on that path.\n+   value on PATH.  If unknown, SSA_NAME is NULL.\n \n-   BBI will be appended to PATH when we have a profitable jump\n-   threading path.  Callers are responsible for removing BBI from PATH\n-   in that case.  */\n+   If the taken edge out of the path is known ahead of time it is passed in\n+   TAKEN_EDGE, otherwise it is NULL.\n \n-edge\n-thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n-\t\t\t\t\t   tree arg,\n-\t\t\t\t\t   bool *creates_irreducible_loop)\n+   CREATES_IRREDUCIBLE_LOOP, if non-null is set to TRUE if threading this path\n+   would create an irreducible loop.  */\n+\n+bool\n+back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n+\t\t\t\t\t\ttree name,\n+\t\t\t\t\t\tedge taken_edge,\n+\t\t\t\t\t\tbool *creates_irreducible_loop)\n {\n-  /* Note BBI is not in the path yet, hence the +1 in the test below\n-     to make sure BBI is accounted for in the path length test.  */\n+  gcc_checking_assert (!m_path.is_empty ());\n \n-  /* We can get a length of 0 here when the statement that\n-     makes a conditional generate a compile-time constant\n-     result is in the same block as the conditional.\n+  /* We can an empty path here (excluding the DEF block) when the\n+     statement that makes a conditional generate a compile-time\n+     constant result is in the same block as the conditional.\n \n      That's not really a jump threading opportunity, but instead is\n      simple cprop & simplification.  We could handle it here if we\n      wanted by wiring up all the incoming edges.  If we run this\n      early in IPA, that might be worth doing.   For now we just\n      reject that case.  */\n-  if (m_path.is_empty ())\n-      return NULL;\n+  if (m_path.length () <= 1)\n+      return false;\n \n-  if (m_path.length () + 1\n-      > (unsigned) param_max_fsm_thread_length)\n+  if (m_path.length () > (unsigned) param_max_fsm_thread_length)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n \t\t \"the number of basic blocks on the path \"\n \t\t \"exceeds PARAM_MAX_FSM_THREAD_LENGTH.\\n\");\n-      return NULL;\n+      return false;\n     }\n \n-  if (m_max_threaded_paths <= 0)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n-\t\t \"the number of previously recorded FSM paths to \"\n-\t\t \"thread exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n-      return NULL;\n-    }\n-\n-  /* Add BBI to the path.\n-     From this point onward, if we decide we the path is not profitable\n-     to thread, we must remove BBI from the path.  */\n-  m_path.safe_push (bbi);\n-\n   int n_insns = 0;\n   gimple_stmt_iterator gsi;\n   loop_p loop = m_path[0]->loop_father;\n@@ -256,6 +294,8 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n \t\t     SSA_NAMEs, then we do not have enough information\n \t\t     to consider them associated.  */\n \t\t  if (dst != name\n+\t\t      && name\n+\t\t      && TREE_CODE (name) == SSA_NAME\n \t\t      && (SSA_NAME_VAR (dst) != SSA_NAME_VAR (name)\n \t\t\t  || !SSA_NAME_VAR (dst))\n \t\t      && !virtual_operand_p (dst))\n@@ -276,10 +316,7 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n \t      gimple *stmt = gsi_stmt (gsi);\n \t      if (gimple_call_internal_p (stmt, IFN_UNIQUE)\n \t\t  || gimple_call_builtin_p (stmt, BUILT_IN_CONSTANT_P))\n-\t\t{\n-\t\t  m_path.pop ();\n-\t\t  return NULL;\n-\t\t}\n+\t\treturn false;\n \t      /* Do not count empty statements and labels.  */\n \t      if (gimple_code (stmt) != GIMPLE_NOP\n \t\t  && !(gimple_code (stmt) == GIMPLE_ASSIGN\n@@ -330,75 +367,52 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n \t     \"  Overall: %i insns\\n\",\n \t     stmt_insns, n_insns);\n \n-  /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n-     and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n-     we need to substitute, fold and simplify so we can determine\n-     the edge taken out of the last block.  */\n-  if (gimple_code (stmt) == GIMPLE_COND)\n+  if (creates_irreducible_loop)\n     {\n-      enum tree_code cond_code = gimple_cond_code (stmt);\n-\n-      /* We know the underyling format of the condition.  */\n-      arg = fold_binary (cond_code, boolean_type_node,\n-\t\t\t arg, gimple_cond_rhs (stmt));\n-    }\n-\n-  /* If this path threaded through the loop latch back into the\n-     same loop and the destination does not dominate the loop\n-     latch, then this thread would create an irreducible loop.\n-\n-     We have to know the outgoing edge to figure this out.  */\n-  edge taken_edge = find_taken_edge (m_path[0], arg);\n-\n-  /* There are cases where we may not be able to extract the\n-     taken edge.  For example, a computed goto to an absolute\n-     address.  Handle those cases gracefully.  */\n-  if (taken_edge == NULL)\n-    {\n-      m_path.pop ();\n-      return NULL;\n+      /* If this path threaded through the loop latch back into the\n+\t same loop and the destination does not dominate the loop\n+\t latch, then this thread would create an irreducible loop.  */\n+      *creates_irreducible_loop = false;\n+      if (taken_edge\n+\t  && threaded_through_latch\n+\t  && loop == taken_edge->dest->loop_father\n+\t  && (determine_bb_domination_status (loop, taken_edge->dest)\n+\t      == DOMST_NONDOMINATING))\n+\t*creates_irreducible_loop = true;\n     }\n \n-  *creates_irreducible_loop = false;\n-  if (threaded_through_latch\n-      && loop == taken_edge->dest->loop_father\n-      && (determine_bb_domination_status (loop, taken_edge->dest)\n-\t  == DOMST_NONDOMINATING))\n-    *creates_irreducible_loop = true;\n-\n   if (path_crosses_loops)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n \t\t \"the path crosses loops.\\n\");\n-      m_path.pop ();\n-      return NULL;\n+      return false;\n     }\n \n   /* Threading is profitable if the path duplicated is hot but also\n      in a case we separate cold path from hot path and permit optimization\n      of the hot path later.  Be on the agressive side here. In some testcases,\n      as in PR 78407 this leads to noticeable improvements.  */\n-  if (m_speed_p && (optimize_edge_for_speed_p (taken_edge) || contains_hot_bb))\n+  if (m_speed_p\n+      && ((taken_edge && optimize_edge_for_speed_p (taken_edge))\n+\t  || contains_hot_bb))\n     {\n       if (n_insns >= param_max_fsm_thread_path_insns)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\t    fprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n \t\t     \"the number of instructions on the path \"\n \t\t     \"exceeds PARAM_MAX_FSM_THREAD_PATH_INSNS.\\n\");\n-\t  m_path.pop ();\n-\t  return NULL;\n+\t  return false;\n \t}\n     }\n-  else if (n_insns > 1)\n+  else if (!m_speed_p && n_insns > 1)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n+\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n \t\t \"duplication of %i insns is needed and optimizing for size.\\n\",\n \t\t n_insns);\n-      m_path.pop ();\n-      return NULL;\n+      return false;\n     }\n \n   /* We avoid creating irreducible inner loops unless we thread through\n@@ -410,21 +424,21 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n      the path -- in that case there's little the traditional loop\n      optimizer would have done anyway, so an irreducible loop is not\n      so bad.  */\n-  if (!threaded_multiway_branch && *creates_irreducible_loop\n+  if (!threaded_multiway_branch\n+      && creates_irreducible_loop\n+      && *creates_irreducible_loop\n       && (n_insns * (unsigned) param_fsm_scale_path_stmts\n \t  > (m_path.length () *\n \t     (unsigned) param_fsm_scale_path_blocks)))\n \n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"FSM would create irreducible loop without threading \"\n+\t\t \"  FAIL: FSM would create irreducible loop without threading \"\n \t\t \"multiway branch.\\n\");\n-      m_path.pop ();\n-      return NULL;\n+      return false;\n     }\n \n-\n   /* If this path does not thread through the loop latch, then we are\n      using the FSM threader to find old style jump threads.  This\n      is good, except the FSM threader does not re-use an existing\n@@ -438,10 +452,9 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"FSM did not thread around loop and would copy too \"\n+\t\t \"  FAIL: FSM did not thread around loop and would copy too \"\n \t\t \"many statements.\\n\");\n-      m_path.pop ();\n-      return NULL;\n+      return false;\n     }\n \n   /* When there is a multi-way branch on the path, then threading can\n@@ -452,24 +465,69 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n-\t\t \"FSM Thread through multiway branch without threading \"\n+\t\t \"  FAIL: FSM Thread through multiway branch without threading \"\n \t\t \"a multiway branch.\\n\");\n-      m_path.pop ();\n-      return NULL;\n+      return false;\n     }\n-  return taken_edge;\n+  return true;\n+}\n+\n+/* Return the taken edge out of a path, assuming that the underlying assignment\n+   or PHI SSA resolves to ARG.  */\n+\n+edge\n+thread_jumps::find_taken_edge (const vec<basic_block> &path, tree arg)\n+{\n+  if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n+    return NULL;\n+\n+  gcc_checking_assert (!path.is_empty ());\n+  gimple *stmt = get_gimple_control_stmt (m_path[0]);\n+\n+  /* We have found a constant value for ARG.  For GIMPLE_SWITCH\n+     and GIMPLE_GOTO, we use it as-is.  However, for a GIMPLE_COND\n+     we need to substitute, fold and simplify so we can determine\n+     the edge taken out of the last block.  */\n+  if (gimple_code (stmt) == GIMPLE_COND)\n+    {\n+      enum tree_code cond_code = gimple_cond_code (stmt);\n+\n+      /* We know the underyling format of the condition.  */\n+      arg = fold_binary (cond_code, boolean_type_node,\n+\t\t\t arg, gimple_cond_rhs (stmt));\n+    }\n+\n+  /* If this path threaded through the loop latch back into the\n+     same loop and the destination does not dominate the loop\n+     latch, then this thread would create an irreducible loop.\n+\n+     We have to know the outgoing edge to figure this out.  */\n+  return ::find_taken_edge (m_path[0], arg);\n }\n \n /* The current path PATH is a vector of blocks forming a jump threading\n    path in reverse order.  TAKEN_EDGE is the edge taken from path[0].\n \n    Convert the current path into the form used by register_jump_thread and\n-   register it.   */\n+   register it.\n \n-void\n-thread_jumps::convert_and_register_current_path (edge taken_edge)\n+   Return TRUE if successful or FALSE otherwise.  */\n+\n+bool\n+back_threader_registry::register_path (const vec<basic_block> &m_path,\n+\t\t\t\t       edge taken_edge)\n {\n-  vec<jump_thread_edge *> *path = m_registry.allocate_thread_path ();\n+  if (m_threaded_paths > m_max_allowable_paths)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  FAIL: FSM jump-thread path not considered: \"\n+\t\t \"the number of previously recorded FSM paths to \"\n+\t\t \"thread exceeds PARAM_MAX_FSM_THREAD_PATHS.\\n\");\n+      return false;\n+    }\n+\n+  vec<jump_thread_edge *> *jump_thread_path\n+    = m_lowlevel_registry.allocate_thread_path ();\n \n   /* Record the edges between the blocks in PATH.  */\n   for (unsigned int j = 0; j + 1 < m_path.length (); j++)\n@@ -480,17 +538,19 @@ thread_jumps::convert_and_register_current_path (edge taken_edge)\n       edge e = find_edge (bb1, bb2);\n       gcc_assert (e);\n       jump_thread_edge *x\n-\t= m_registry.allocate_thread_edge (e, EDGE_FSM_THREAD);\n-      path->safe_push (x);\n+\t= m_lowlevel_registry.allocate_thread_edge (e, EDGE_FSM_THREAD);\n+      jump_thread_path->safe_push (x);\n     }\n \n   /* Add the edge taken when the control variable has value ARG.  */\n   jump_thread_edge *x\n-    = m_registry.allocate_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n-  path->safe_push (x);\n+    = m_lowlevel_registry.allocate_thread_edge (taken_edge,\n+\t\t\t\t\t\tEDGE_NO_COPY_SRC_BLOCK);\n+  jump_thread_path->safe_push (x);\n \n-  m_registry.register_jump_thread (path);\n-  --m_max_threaded_paths;\n+  m_lowlevel_registry.register_jump_thread (jump_thread_path);\n+  ++m_threaded_paths;\n+  return true;\n }\n \n /* While following a chain of SSA_NAME definitions, we jumped from a\n@@ -558,19 +618,17 @@ thread_jumps::check_subpath_and_update_thread_path (basic_block last_bb,\n    DEF_BB is the basic block that ultimately defines the constant.  */\n \n void\n-thread_jumps::register_jump_thread_path_if_profitable (tree name, tree arg,\n-\t\t\t\t\t\t       basic_block def_bb)\n+thread_jumps::maybe_register_path (const vec<basic_block> &m_path,\n+\t\t\t\t   tree name,\n+\t\t\t\t   edge taken_edge)\n {\n-  if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n-    return;\n-\n   bool irreducible = false;\n-  edge taken_edge = profitable_jump_thread_path (def_bb, name, arg,\n-\t\t\t\t\t\t &irreducible);\n-  if (taken_edge)\n+  bool profitable = m_profit.profitable_path_p (m_path, name, taken_edge,\n+\t\t\t\t\t\t&irreducible);\n+  if (profitable)\n     {\n-      convert_and_register_current_path (taken_edge);\n-      m_path.pop ();\n+      if (!m_registry.register_path (m_path, taken_edge))\n+\treturn;\n \n       if (irreducible)\n \tvect_free_loop_info_assumptions (m_path[0]->loop_father);\n@@ -585,7 +643,7 @@ thread_jumps::register_jump_thread_path_if_profitable (tree name, tree arg,\n    NAME having a constant value.  */\n \n void\n-thread_jumps::handle_phi (gphi *phi, tree name, basic_block def_bb)\n+thread_jumps::handle_phi (gphi *phi, basic_block def_bb)\n {\n   /* Iterate over the arguments of PHI.  */\n   for (unsigned int i = 0; i < gimple_phi_num_args (phi); i++)\n@@ -608,7 +666,11 @@ thread_jumps::handle_phi (gphi *phi, tree name, basic_block def_bb)\n \t  continue;\n \t}\n \n-      register_jump_thread_path_if_profitable (name, arg, bbi);\n+      m_path.safe_push (bbi);\n+      edge taken_edge = find_taken_edge (m_path, arg);\n+      if (taken_edge)\n+\tmaybe_register_path (m_path, m_name, taken_edge);\n+      m_path.pop ();\n     }\n }\n \n@@ -650,25 +712,23 @@ handle_assignment_p (gimple *stmt)\n    NAME having a constant value.  */\n \n void\n-thread_jumps::handle_assignment (gimple *stmt, tree name, basic_block def_bb)\n+thread_jumps::handle_assignment (gimple *stmt, basic_block def_bb)\n {\n   tree arg = gimple_assign_rhs1 (stmt);\n \n   if (TREE_CODE (arg) == SSA_NAME)\n     fsm_find_control_statement_thread_paths (arg);\n-\n   else\n     {\n-      /* register_jump_thread_path_if_profitable will push the current\n-\t block onto the path.  But the path will always have the current\n-\t block at this point.  So we can just pop it.  */\n-      m_path.pop ();\n-\n-      register_jump_thread_path_if_profitable (name, arg, def_bb);\n-\n-      /* And put the current block back onto the path so that the\n-\t state of the stack is unchanged when we leave.  */\n-      m_path.safe_push (def_bb);\n+      if (CHECKING_P)\n+\t{\n+\t  gcc_assert (!m_path.is_empty ());\n+\t  basic_block top = m_path[m_path.length () - 1];\n+\t  gcc_assert (top == def_bb);\n+\t}\n+      edge taken_edge = find_taken_edge (m_path, arg);\n+      if (taken_edge)\n+\tmaybe_register_path (m_path, m_name, taken_edge);\n     }\n }\n \n@@ -738,9 +798,9 @@ thread_jumps::fsm_find_control_statement_thread_paths (tree name)\n   gcc_assert (m_path.last () == def_bb);\n \n   if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    handle_phi (as_a <gphi *> (def_stmt), name, def_bb);\n+    handle_phi (as_a <gphi *> (def_stmt), def_bb);\n   else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    handle_assignment (def_stmt, name, def_bb);\n+    handle_assignment (def_stmt, def_bb);\n \n   /* Remove all the nodes that we added from NEXT_PATH.  */\n   if (next_path_length)\n@@ -756,8 +816,8 @@ thread_jumps::fsm_find_control_statement_thread_paths (tree name)\n    code path.  */\n \n void\n-thread_jumps::find_jump_threads_backwards (basic_block bb, bool speed_p)\n-{     \n+thread_jumps::find_jump_threads_backwards (basic_block bb)\n+{\n   gimple *stmt = get_gimple_control_stmt (bb);\n   if (!stmt)\n     return;\n@@ -785,8 +845,7 @@ thread_jumps::find_jump_threads_backwards (basic_block bb, bool speed_p)\n   m_path.safe_push (bb);\n   m_visited_bbs.empty ();\n   m_seen_loop_phi = false;\n-  m_speed_p = speed_p;\n-  m_max_threaded_paths = param_max_fsm_thread_paths;\n+  m_name = name;\n \n   fsm_find_control_statement_thread_paths (name);\n }\n@@ -836,7 +895,7 @@ pass_thread_jumps::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (EDGE_COUNT (bb->succs) > 1)\n-\tthreader.find_jump_threads_backwards (bb, true);\n+\tthreader.find_jump_threads_backwards (bb);\n     }\n   bool changed = threader.thread_through_all_blocks ();\n \n@@ -892,12 +951,12 @@ pass_early_thread_jumps::execute (function *fun)\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n   /* Try to thread each block with more than one successor.  */\n-  thread_jumps threader;\n+  thread_jumps threader (/*speed_p=*/false);\n   basic_block bb;\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       if (EDGE_COUNT (bb->succs) > 1)\n-\tthreader.find_jump_threads_backwards (bb, false);\n+\tthreader.find_jump_threads_backwards (bb);\n     }\n   threader.thread_through_all_blocks ();\n "}]}