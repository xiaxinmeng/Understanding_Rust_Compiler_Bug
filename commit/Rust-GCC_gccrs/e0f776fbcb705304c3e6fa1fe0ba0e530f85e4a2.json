{"sha": "e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBmNzc2ZmJjYjcwNTMwNGMzZTZmYTFmZTBiYTBlNTMwZjg1ZTRhMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-02T04:37:37Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-02T04:37:37Z"}, "message": "(same_sign): Removed.\n\n(lshift_double): Don't report arithmetic overflow, since the\nC standard doesn't seem to require it here.\n(force_fit_type): Accept new parameter specifying whether a signed\noverflow has already occurred.  Yield overflow indication.\nAll callers changed.\n(neg_double): Don't report overflow when -0 yields 0.\n(const_binop): Propagate operand overflow for warnings.\nDon't report overflow when -1 + 1 yields 0.\n\nFrom-SVN: r3401", "tree": {"sha": "5ad5d5e799c4bf73c884fc7faaef51148e09169f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ad5d5e799c4bf73c884fc7faaef51148e09169f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2/comments", "author": null, "committer": null, "parents": [{"sha": "42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42b85a5532069a7e2bfdca00fb0d11a7cdbbe61d"}], "stats": {"total": 95, "additions": 54, "deletions": 41}, "files": [{"sha": "9dfa6ae8228b847d84fe39fc911eb05c5d29328f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 54, "deletions": 41, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e0f776fbcb705304c3e6fa1fe0ba0e530f85e4a2", "patch": "@@ -48,7 +48,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Handle floating overflow for `const_binop'.  */\n static jmp_buf float_error;\n \n-int lshift_double ();\n+void lshift_double ();\n void rshift_double ();\n void lrotate_double ();\n void rrotate_double ();\n@@ -61,9 +61,6 @@ static tree const_binop ();\n /* Yield nonzero if a signed left shift of A by B bits overflows.  */\n #define left_shift_overflows(a, b)  ((a)  !=  ((a) << (b)) >> (b))\n \n-/* Yield nonzero if A and B have the same sign.  */\n-#define same_sign(a, b) ((a) ^ (b) >= 0)\n-\n /* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n    Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n    Then this yields nonzero if overflow occurred during the addition.\n@@ -116,12 +113,16 @@ decode (shorts, low, hi)\n \f\n /* Make the integer constant T valid for its type\n    by setting to 0 or 1 all the bits in the constant\n-   that don't belong in the type.  */\n+   that don't belong in the type.\n+   Yield 1 if a signed overflow occurs, 0 otherwise.\n+   If OVERFLOW is nonzero, a signed overflow has already occurred.  */\n \n-void\n-force_fit_type (t)\n+int\n+force_fit_type (t, overflow)\n      tree t;\n+     int overflow;\n {\n+  HOST_WIDE_INT low = TREE_INT_CST_LOW (t), high = TREE_INT_CST_HIGH (t);\n   register int prec = TYPE_PRECISION (TREE_TYPE (t));\n \n   if (TREE_CODE (t) != INTEGER_CST)\n@@ -146,10 +147,12 @@ force_fit_type (t)\n \tTREE_INT_CST_LOW (t) &= ~((HOST_WIDE_INT) (-1) << prec);\n     }\n \n-  /* If it's a signed type and value's sign bit is set, extend the sign.  */\n+  /* Unsigned types do not suffer sign extension or overflow.  */\n+  if (TREE_UNSIGNED (TREE_TYPE (t)))\n+    return 0;\n \n-  if (! TREE_UNSIGNED (TREE_TYPE (t))\n-      && prec != 2 * HOST_BITS_PER_WIDE_INT\n+  /* If the value's sign bit is set, extend the sign.  */\n+  if (prec != 2 * HOST_BITS_PER_WIDE_INT\n       && (prec > HOST_BITS_PER_WIDE_INT\n \t  ? (TREE_INT_CST_HIGH (t)\n \t     & ((HOST_WIDE_INT) 1 << (prec - HOST_BITS_PER_WIDE_INT - 1)))\n@@ -169,6 +172,11 @@ force_fit_type (t)\n \t    TREE_INT_CST_LOW (t) |= ((HOST_WIDE_INT) (-1) << prec);\n \t}\n     }\n+\n+  /* Yield nonzero if signed overflow occurred.  */\n+  return\n+    ((overflow | (low ^ TREE_INT_CST_LOW (t)) | (high ^ TREE_INT_CST_HIGH (t)))\n+     != 0);\n }\n \f\n /* Add two doubleword integers with doubleword result.\n@@ -216,7 +224,7 @@ neg_double (l1, h1, lv, hv)\n     {\n       *lv = 0;\n       *hv = - h1;\n-      return same_sign (h1, *hv);\n+      return (*hv & h1) < 0;\n     }\n   else\n     {\n@@ -327,10 +335,9 @@ mul_double (l1, h1, l2, h2, lv, hv)\n    keeping only PREC bits of result.\n    Shift right if COUNT is negative.\n    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n-   Return nonzero if the arithmetic shift overflows, assuming it's signed.\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n-int\n+void\n lshift_double (l1, h1, count, prec, lv, hv, arith)\n      HOST_WIDE_INT l1, h1;\n      int count, prec;\n@@ -339,20 +346,19 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n {\n   short arg1[MAX_SHORTS];\n   register int i;\n-  register int carry, overflow;\n+  register int carry;\n \n   if (count < 0)\n     {\n       rshift_double (l1, h1, - count, prec, lv, hv, arith);\n-      return 0;\n+      return;\n     }\n \n   encode (arg1, l1, h1);\n \n   if (count > prec)\n     count = prec;\n \n-  overflow = 0;\n   while (count > 0)\n     {\n       carry = 0;\n@@ -363,11 +369,9 @@ lshift_double (l1, h1, count, prec, lv, hv, arith)\n \t  carry >>= 8;\n \t}\n       count--;\n-      overflow |= carry ^ (arg1[7] >> 7);\n     }\n \n   decode (arg1, lv, hv);\n-  return overflow;\n }\n \n /* Shift the doubleword integer in L1, H1 right by COUNT places\n@@ -1054,9 +1058,7 @@ const_binop (code, arg1, arg2, notrunc)\n       HOST_WIDE_INT garbagel, garbageh;\n       register tree t;\n       int uns = TREE_UNSIGNED (TREE_TYPE (arg1));\n-      /* Propagate overflow flags from operands; also record new overflow.  */\n-      int overflow\n-\t= TREE_CONSTANT_OVERFLOW (arg1) | TREE_CONSTANT_OVERFLOW (arg2);\n+      int overflow = 0;\n \n       switch (code)\n \t{\n@@ -1079,10 +1081,13 @@ const_binop (code, arg1, arg2, notrunc)\n \tcase RSHIFT_EXPR:\n \t  int2l = - int2l;\n \tcase LSHIFT_EXPR:\n-\t  overflow = lshift_double (int1l, int1h, int2l,\n-\t\t\t\t    TYPE_PRECISION (TREE_TYPE (arg1)),\n-\t\t\t\t    &low, &hi,\n-\t\t\t\t    !uns);\n+\t  /* It's unclear from the C standard whether shifts can overflow.\n+\t     The following code ignores overflow; perhaps a C standard\n+\t     interpretation ruling is needed.  */\n+\t  lshift_double (int1l, int1h, int2l,\n+\t\t\t TYPE_PRECISION (TREE_TYPE (arg1)),\n+\t\t\t &low, &hi,\n+\t\t\t !uns);\n \t  t = build_int_2 (low, hi);\n \t  break;\n \n@@ -1102,7 +1107,7 @@ const_binop (code, arg1, arg2, notrunc)\n \t      if ((unsigned HOST_WIDE_INT) int2l < int1l)\n \t\t{\n \t\t  hi = int2h++;\n-\t\t  overflow = ! same_sign (hi, int2h);\n+\t\t  overflow = int2h < hi;\n \t\t}\n \t      t = build_int_2 (int2l, int2h);\n \t      break;\n@@ -1113,7 +1118,7 @@ const_binop (code, arg1, arg2, notrunc)\n \t      if ((unsigned HOST_WIDE_INT) int1l < int2l)\n \t\t{\n \t\t  hi = int1h++;\n-\t\t  overflow = ! same_sign (hi, int1h);\n+\t\t  overflow = int1h < hi;\n \t\t}\n \t      t = build_int_2 (int1l, int1h);\n \t      break;\n@@ -1275,9 +1280,10 @@ const_binop (code, arg1, arg2, notrunc)\n \t}\n     got_it:\n       TREE_TYPE (t) = TREE_TYPE (arg1);\n-      if (! notrunc)\n-\tforce_fit_type (t);\n-      TREE_CONSTANT_OVERFLOW (t) = overflow;\n+      TREE_CONSTANT_OVERFLOW (t)\n+\t= ((notrunc ? !uns && overflow : force_fit_type (t, overflow))\n+\t   | TREE_CONSTANT_OVERFLOW (arg1)\n+\t   | TREE_CONSTANT_OVERFLOW (arg2));\n       return t;\n     }\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n@@ -1493,11 +1499,16 @@ fold_convert (t, arg1)\n \t     appropriately sign-extended or truncated.  */\n \t  t = build_int_2 (TREE_INT_CST_LOW (arg1),\n \t\t\t   TREE_INT_CST_HIGH (arg1));\n-\t  /* Carry forward overflow indication unless truncating.  */\n-\t  if (TYPE_PRECISION (type) >= TYPE_PRECISION (TREE_TYPE (t)))\n-\t    TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg1);\n \t  TREE_TYPE (t) = type;\n-\t  force_fit_type (t);\n+\t  /* Indicate an overflow if (1) ARG1 already overflowed,\n+\t     or (2) ARG1 is a too-large unsigned value and T is signed,\n+\t     or (3) force_fit_type indicates an overflow.\n+\t     force_fit_type can't detect (2), since it sees only T's type.  */\n+\t  TREE_CONSTANT_OVERFLOW (t) =\n+\t    (TREE_CONSTANT_OVERFLOW (arg1)\n+\t     | (TREE_INT_CST_HIGH (arg1) < 0\n+\t\t& TREE_UNSIGNED (type) < TREE_UNSIGNED (TREE_TYPE (arg1)))\n+\t     | force_fit_type (t, 0));\n \t}\n #if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n       else if (TREE_CODE (arg1) == REAL_CST)\n@@ -1537,7 +1548,7 @@ fold_convert (t, arg1)\n \t    if (d >= (REAL_VALUE_TYPE) half_word * half_word / 2)\n \t      {\n \t\tlow = d - (REAL_VALUE_TYPE) half_word * half_word / 2;\n-\t\tlow |= (HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT - 1);\n+\t\tlow |= (HOST_WIDE_INT) -1 << (HOST_BITS_PER_WIDE_INT - 1);\n \t      }\n \t    else\n \t      low = (HOST_WIDE_INT) d;\n@@ -1553,7 +1564,7 @@ fold_convert (t, arg1)\n \t  }\n #endif\n \t  TREE_TYPE (t) = type;\n-\t  force_fit_type (t);\n+\t  force_fit_type (t, 0);\n \t}\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n       TREE_TYPE (t) = type;\n@@ -3266,10 +3277,10 @@ fold (expr)\n \t\t\t\t\t TREE_INT_CST_HIGH (arg0),\n \t\t\t\t\t &low, &high);\n \t      t = build_int_2 (low, high);\n-\t      TREE_CONSTANT_OVERFLOW (t)\n-\t\t= overflow | TREE_CONSTANT_OVERFLOW (arg0);\n \t      TREE_TYPE (t) = type;\n-\t      force_fit_type (t);\n+\t      TREE_CONSTANT_OVERFLOW (t)\n+\t\t= (TREE_CONSTANT_OVERFLOW (arg0)\n+\t\t   | force_fit_type (t, overflow));\n \t    }\n \t  else if (TREE_CODE (arg0) == REAL_CST)\n \t    t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n@@ -3299,7 +3310,9 @@ fold (expr)\n \t\t\t\t\t     &low, &high);\n \t\t  t = build_int_2 (low, high);\n \t\t  TREE_TYPE (t) = type;\n-\t\t  force_fit_type (t);\n+\t\t  TREE_CONSTANT_OVERFLOW (t)\n+\t\t    = (TREE_CONSTANT_OVERFLOW (arg0)\n+\t\t       | force_fit_type (t, overflow));\n \t\t}\n \t    }\n \t  else if (TREE_CODE (arg0) == REAL_CST)\n@@ -3321,7 +3334,7 @@ fold (expr)\n \t    t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n \t\t\t     ~ TREE_INT_CST_HIGH (arg0));\n \t  TREE_TYPE (t) = type;\n-\t  force_fit_type (t);\n+\t  force_fit_type (t, 0);\n \t  TREE_CONSTANT_OVERFLOW (t) = TREE_CONSTANT_OVERFLOW (arg0);\n \t}\n       else if (TREE_CODE (arg0) == BIT_NOT_EXPR)"}]}