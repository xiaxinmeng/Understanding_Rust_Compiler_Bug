{"sha": "e0c27d52dd783affbc95bdb53630b35ae044e620", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBjMjdkNTJkZDc4M2FmZmJjOTViZGI1MzYzMGIzNWFlMDQ0ZTYyMA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-07-19T09:49:36Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-07-19T09:49:36Z"}, "message": "[Fortran] Use MIN/MAX_EXPR or IFN_FMIN/MAX for min/max intrinsics when possible\n\n\t* trans-intrinsic.c: (gfc_conv_intrinsic_minmax): Emit MIN_MAX_EXPR\n\tor IFN_FMIN/FMAX sequence to calculate the min/max when possible.\n\n\t* gfortran.dg/max_fmax_aarch64.f90: New test.\n\t* gfortran.dg/min_fmin_aarch64.f90: Likewise.\n\t* gfortran.dg/minmax_integer.f90: Likewise.\n\nFrom-SVN: r262876", "tree": {"sha": "78671068a29a8ff779e7a38e755a617b3e7544ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78671068a29a8ff779e7a38e755a617b3e7544ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0c27d52dd783affbc95bdb53630b35ae044e620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c27d52dd783affbc95bdb53630b35ae044e620", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0c27d52dd783affbc95bdb53630b35ae044e620", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0c27d52dd783affbc95bdb53630b35ae044e620/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4a3f1e98a2635bfc6ded2b84fa9cfd3b845017b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4a3f1e98a2635bfc6ded2b84fa9cfd3b845017b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4a3f1e98a2635bfc6ded2b84fa9cfd3b845017b"}], "stats": {"total": 147, "additions": 113, "deletions": 34}, "files": [{"sha": "c4f9d338784eb6266ee99f8689b3c443f0b5ce78", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e0c27d52dd783affbc95bdb53630b35ae044e620", "patch": "@@ -1,3 +1,8 @@\n+2018-07-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* trans-intrinsic.c: (gfc_conv_intrinsic_minmax): Emit MIN_MAX_EXPR\n+\tor IFN_FMIN/FMAX sequence to calculate the min/max when possible.\n+\n 2018-07-18  Janus Weil  <janus@gcc.gnu.org>\n \t    Thomas Koenig  <tkoenig@gcc.gnu.org>\n "}, {"sha": "c9b5479740c3f98f906132fda5c252274c4b6edd", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 57, "deletions": 34, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e0c27d52dd783affbc95bdb53630b35ae044e620", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans.h\"\n #include \"stringpool.h\"\n #include \"fold-const.h\"\n+#include \"internal-fn.h\"\n #include \"tree-nested.h\"\n #include \"stor-layout.h\"\n #include \"toplev.h\"\t/* For rest_of_decl_compilation.  */\n@@ -3874,14 +3875,15 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n     minmax (a1, a2, a3, ...)\n     {\n       mvar = a1;\n-      if (a2 .op. mvar || isnan (mvar))\n-        mvar = a2;\n-      if (a3 .op. mvar || isnan (mvar))\n-        mvar = a3;\n+      mvar = COMP (mvar, a2)\n+      mvar = COMP (mvar, a3)\n       ...\n-      return mvar\n+      return mvar;\n     }\n- */\n+    Where COMP is MIN/MAX_EXPR for integral types or when we don't\n+    care about NaNs, or IFN_FMIN/MAX when the target has support for\n+    fast NaN-honouring min/max.  When neither holds expand a sequence\n+    of explicit comparisons.  */\n \n /* TODO: Mismatching types can occur when specific names are used.\n    These should be handled during resolution.  */\n@@ -3891,7 +3893,6 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n   tree tmp;\n   tree mvar;\n   tree val;\n-  tree thencase;\n   tree *args;\n   tree type;\n   gfc_actual_arglist *argexpr;\n@@ -3912,55 +3913,77 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, enum tree_code op)\n \n   mvar = gfc_create_var (type, \"M\");\n   gfc_add_modify (&se->pre, mvar, args[0]);\n-  for (i = 1, argexpr = argexpr->next; i < nargs; i++)\n-    {\n-      tree cond, isnan;\n \n+  internal_fn ifn = op == GT_EXPR ? IFN_FMAX : IFN_FMIN;\n+\n+  for (i = 1, argexpr = argexpr->next; i < nargs; i++, argexpr = argexpr->next)\n+    {\n+      tree cond = NULL_TREE;\n       val = args[i];\n \n       /* Handle absent optional arguments by ignoring the comparison.  */\n       if (argexpr->expr->expr_type == EXPR_VARIABLE\n \t  && argexpr->expr->symtree->n.sym->attr.optional\n \t  && TREE_CODE (val) == INDIRECT_REF)\n-\tcond = fold_build2_loc (input_location,\n+\t{\n+\t  cond = fold_build2_loc (input_location,\n \t\t\t\tNE_EXPR, logical_type_node,\n \t\t\t\tTREE_OPERAND (val, 0),\n \t\t\tbuild_int_cst (TREE_TYPE (TREE_OPERAND (val, 0)), 0));\n-      else\n-      {\n-\tcond = NULL_TREE;\n-\n+\t}\n+      else if (!VAR_P (val) && !TREE_CONSTANT (val))\n \t/* Only evaluate the argument once.  */\n-\tif (!VAR_P (val) && !TREE_CONSTANT (val))\n-\t  val = gfc_evaluate_now (val, &se->pre);\n-      }\n+\tval = gfc_evaluate_now (val, &se->pre);\n \n-      thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n+      tree calc;\n+      /* If we dealing with integral types or we don't care about NaNs\n+\t just do a MIN/MAX_EXPR.  */\n+      if (!HONOR_NANS (type) && !HONOR_SIGNED_ZEROS (type))\n+\t{\n+\n+\t  tree_code code = op == GT_EXPR ? MAX_EXPR : MIN_EXPR;\n+\t  calc = fold_build2_loc (input_location, code, type,\n+\t\t\t\t  convert (type, val), mvar);\n+\t  tmp = build2_v (MODIFY_EXPR, mvar, calc);\n \n-      tmp = fold_build2_loc (input_location, op, logical_type_node,\n-\t\t\t     convert (type, val), mvar);\n+\t}\n+      /* If we care about NaNs and we have internal functions available for\n+\t fmin/fmax to perform the comparison, use those.  */\n+      else if (SCALAR_FLOAT_TYPE_P (type)\n+\t      && direct_internal_fn_supported_p (ifn, type, OPTIMIZE_FOR_SPEED))\n+\t{\n+\t  calc = build_call_expr_internal_loc (input_location, ifn, type,\n+\t\t\t\t\t\t2, mvar, convert (type, val));\n+\t  tmp = build2_v (MODIFY_EXPR, mvar, calc);\n \n-      /* FIXME: When the IEEE_ARITHMETIC module is implemented, the call to\n-\t __builtin_isnan might be made dependent on that module being loaded,\n-\t to help performance of programs that don't rely on IEEE semantics.  */\n-      if (FLOAT_TYPE_P (TREE_TYPE (mvar)))\n+\t}\n+      /* Otherwise expand to:\n+\tmvar = a1;\n+\tif (a2 .op. mvar || isnan (mvar))\n+\t  mvar = a2;\n+\tif (a3 .op. mvar || isnan (mvar))\n+\t  mvar = a3;\n+\t...  */\n+      else\n \t{\n-\t  isnan = build_call_expr_loc (input_location,\n-\t\t\t\t       builtin_decl_explicit (BUILT_IN_ISNAN),\n-\t\t\t\t       1, mvar);\n+\t  tree isnan = build_call_expr_loc (input_location,\n+\t\t\t\t\tbuiltin_decl_explicit (BUILT_IN_ISNAN),\n+\t\t\t\t\t1, mvar);\n+\t  tmp = fold_build2_loc (input_location, op, logical_type_node,\n+\t\t\t\t convert (type, val), mvar);\n+\n \t  tmp = fold_build2_loc (input_location, TRUTH_OR_EXPR,\n-\t\t\t\t logical_type_node, tmp,\n-\t\t\t\t fold_convert (logical_type_node, isnan));\n+\t\t\t\t  logical_type_node, tmp,\n+\t\t\t\t  fold_convert (logical_type_node, isnan));\n+\t  tmp = build3_v (COND_EXPR, tmp,\n+\t\t\t  build2_v (MODIFY_EXPR, mvar, convert (type, val)),\n+\t\t\t  build_empty_stmt (input_location));\n \t}\n-      tmp = build3_v (COND_EXPR, tmp, thencase,\n-\t\t      build_empty_stmt (input_location));\n \n       if (cond != NULL_TREE)\n \ttmp = build3_v (COND_EXPR, cond, tmp,\n \t\t\tbuild_empty_stmt (input_location));\n-\n       gfc_add_expr_to_block (&se->pre, tmp);\n-      argexpr = argexpr->next;\n     }\n   se->expr = mvar;\n }"}, {"sha": "f78a7c82a8937bb8322e3c900faafaf0c5669d15", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0c27d52dd783affbc95bdb53630b35ae044e620", "patch": "@@ -1,3 +1,9 @@\n+2018-07-19  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\t* gfortran.dg/max_fmax_aarch64.f90: New test.\n+\t* gfortran.dg/min_fmin_aarch64.f90: Likewise.\n+\t* gfortran.dg/minmax_integer.f90: Likewise.\n+\n 2018-07-19  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* g++.old-deja/g++.mike/p784.C: Add -fpermissive."}, {"sha": "b818241a1f9aa7018efaf300cfecb70f413b7573", "filename": "gcc/testsuite/gfortran.dg/max_fmax_aarch64.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2Fgfortran.dg%2Fmax_fmax_aarch64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2Fgfortran.dg%2Fmax_fmax_aarch64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmax_fmax_aarch64.f90?ref=e0c27d52dd783affbc95bdb53630b35ae044e620", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile { target aarch64*-*-* } }\n+! { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+subroutine foo (a, b, c, d, e, f, g, h)\n+  real (kind=8) :: a, b, c, d, e, f, g, h\n+  a = max (a, b, c, d, e, f, g, h)\n+end subroutine\n+\n+subroutine foof (a, b, c, d, e, f, g, h)\n+  real (kind=4) :: a, b, c, d, e, f, g, h\n+  a = max (a, b, c, d, e, f, g, h)\n+end subroutine\n+\n+\n+! { dg-final { scan-tree-dump-times \"\\.FMAX \" 14 \"optimized\" } }"}, {"sha": "009869b497df7737089971e00c01e1c29c0a3032", "filename": "gcc/testsuite/gfortran.dg/min_fmin_aarch64.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_fmin_aarch64.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_fmin_aarch64.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmin_fmin_aarch64.f90?ref=e0c27d52dd783affbc95bdb53630b35ae044e620", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile { target aarch64*-*-* } }\n+! { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+subroutine foo (a, b, c, d, e, f, g, h)\n+  real (kind=8) :: a, b, c, d, e, f, g, h\n+  a = min (a, b, c, d, e, f, g, h)\n+end subroutine\n+\n+\n+subroutine foof (a, b, c, d, e, f, g, h)\n+  real (kind=4) :: a, b, c, d, e, f, g, h\n+  a = min (a, b, c, d, e, f, g, h)\n+end subroutine\n+\n+! { dg-final { scan-tree-dump-times \"\\.FMIN \" 14 \"optimized\" } }"}, {"sha": "5b6be38c7055ce4e8620cf75ec7d8a182436b24f", "filename": "gcc/testsuite/gfortran.dg/minmax_integer.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmax_integer.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0c27d52dd783affbc95bdb53630b35ae044e620/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmax_integer.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fminmax_integer.f90?ref=e0c27d52dd783affbc95bdb53630b35ae044e620", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do compile }\n+! { dg-options \"-O2 -fdump-tree-optimized\" }\n+\n+subroutine foo (a, b, c, d, e, f, g, h)\n+  integer (kind=4) :: a, b, c, d, e, f, g, h\n+  a = min (a, b, c, d, e, f, g, h)\n+end subroutine\n+\n+subroutine foof (a, b, c, d, e, f, g, h)\n+  integer (kind=4) :: a, b, c, d, e, f, g, h\n+  a = max (a, b, c, d, e, f, g, h)\n+end subroutine\n+\n+! { dg-final { scan-tree-dump-times \"MIN_EXPR\" 7 \"optimized\" } }\n+! { dg-final { scan-tree-dump-times \"MAX_EXPR\" 7 \"optimized\" } }"}]}