{"sha": "f7761c9ad97641df3e7bd4980d50449c7892d88b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjc3NjFjOWFkOTc2NDFkZjNlN2JkNDk4MGQ1MDQ0OWM3ODkyZDg4Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-17T15:24:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-07-17T15:24:57Z"}, "message": "(STACK_CHECK_*): Provide default values.\n\n(probe_stack_range): New declaration.\n\nFrom-SVN: r14467", "tree": {"sha": "17c5efa13a383322a64c7d2b8c0607bb36ae0020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17c5efa13a383322a64c7d2b8c0607bb36ae0020"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7761c9ad97641df3e7bd4980d50449c7892d88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7761c9ad97641df3e7bd4980d50449c7892d88b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7761c9ad97641df3e7bd4980d50449c7892d88b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7761c9ad97641df3e7bd4980d50449c7892d88b/comments", "author": null, "committer": null, "parents": [{"sha": "16d856c1bb3b4ac3dc406a24d5186c81bc24590b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d856c1bb3b4ac3dc406a24d5186c81bc24590b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d856c1bb3b4ac3dc406a24d5186c81bc24590b"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "8775bc0d2ce345f6d96f9c6d292cc17be3c00828", "filename": "gcc/expr.h", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7761c9ad97641df3e7bd4980d50449c7892d88b/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7761c9ad97641df3e7bd4980d50449c7892d88b/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=f7761c9ad97641df3e7bd4980d50449c7892d88b", "patch": "@@ -1,5 +1,5 @@\n /* Definitions for code generation pass of GNU compiler.\n-   Copyright (C) 1987, 91-95, 1996 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 91-96, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -215,6 +215,46 @@ enum direction {none, upward, downward};  /* Value has this type.  */\n #ifndef RETURN_IN_MEMORY\n #define RETURN_IN_MEMORY(TYPE) (TYPE_MODE (TYPE) == BLKmode)\n #endif\n+\n+/* Provide default values for the macros controlling stack checking.  */\n+\n+#ifndef STACK_CHECK_BUILTIN\n+#define STACK_CHECK_BUILTIN 0\n+#endif\n+\n+/* The default interval is one page.  */\n+#ifndef STACK_CHECK_PROBE_INTERVAL\n+#define STACK_CHECK_PROBE_INTERVAL 4096\n+#endif\n+\n+/* The default is to do a store into the stack.  */\n+#ifndef STACK_CHECK_PROBE_LOAD\n+#define STACK_CHECK_PROBE_LOAD 0\n+#endif\n+\n+/* This value is arbitrary, but should be sufficient for most machines.  */\n+#ifndef STACK_CHECK_PROTECT\n+#define STACK_CHECK_PROTECT (75 * UNITS_PER_WORD)\n+#endif\n+\n+/* Make the maximum frame size be the largest we can and still only need\n+   one probe per function.  */\n+#ifndef STACK_CHECK_MAX_FRAME_SIZE\n+#define STACK_CHECK_MAX_FRAME_SIZE \\\n+  (STACK_CHECK_PROBE_INTERVAL - UNITS_PER_WORD)\n+#endif\n+\n+/* This is arbitrary, but should be large enough everywhere.  */\n+#ifndef STACK_CHECK_FIXED_FRAME_SIZE\n+#define STACK_CHECK_FIXED_FRAME_SIZE (4 * UNITS_PER_WORD)\n+#endif\n+\n+/* Provide a reasonable default for the maximum size of an object to\n+   allocate in the fixed frame.  We may need to be able to make this\n+   controllable by the user at some point.  */\n+#ifndef STACK_CHECK_MAX_VAR_SIZE\n+#define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n+#endif\n \f\n /* Optabs are tables saying how to generate insn bodies\n    for various machine modes and numbers of operands.\n@@ -839,6 +879,13 @@ extern void emit_stack_restore PROTO((enum save_level, rtx, rtx));\n    says how many bytes.  */\n extern rtx allocate_dynamic_stack_space PROTO((rtx, rtx, int));\n \n+/* Probe a range of stack addresses from FIRST to FIRST+SIZE, inclusive. \n+   FIRST is a constant and size is a Pmode RTX.  These are offsets from the\n+   current stack pointer.  STACK_GROWS_DOWNWARD says whether to add or\n+   subtract from the stack.  If SIZE is constant, this is done\n+   with a fixed number of probes.  Otherwise, we must make a loop.  */\n+extern void probe_stack_range PROTO((HOST_WIDE_INT, rtx));\n+\n /* Return an rtx that refers to the value returned by a library call\n    in its original home.  This becomes invalid if any more code is emitted.  */\n extern rtx hard_libcall_value PROTO((enum machine_mode));"}]}