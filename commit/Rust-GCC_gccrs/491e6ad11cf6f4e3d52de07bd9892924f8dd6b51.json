{"sha": "491e6ad11cf6f4e3d52de07bd9892924f8dd6b51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDkxZTZhZDExY2Y2ZjRlM2Q1MmRlMDdiZDk4OTI5MjRmOGRkNmI1MQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2009-06-08T17:16:16Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2009-06-08T17:16:16Z"}, "message": "README: Import from libffi 3.0.8.\n\n2009-06-08  Andrew Haley  <aph@redhat.com>\n\n\t* README: Import from libffi 3.0.8.\n\nFrom-SVN: r148286", "tree": {"sha": "f0443220b352f21fa6700351fdc783c4a213ba83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0443220b352f21fa6700351fdc783c4a213ba83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3b5b1a73fada33bb98debab90ab852f8378b4830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5b1a73fada33bb98debab90ab852f8378b4830", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5b1a73fada33bb98debab90ab852f8378b4830"}], "stats": {"total": 378, "additions": 115, "deletions": 263}, "files": [{"sha": "8c646569148f8286b896ae1ffd6c717587d44e86", "filename": "libffi/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=491e6ad11cf6f4e3d52de07bd9892924f8dd6b51", "patch": "@@ -1,3 +1,7 @@\n+2009-06-08  Andrew Haley  <aph@redhat.com>\n+\n+\t* README: Import from libffi 3.0.8.\n+\n 2009-06-08  Andrew Haley  <aph@redhat.com>\n \n \t* testsuite/libffi.call/err_bad_abi.c: Add xfails."}, {"sha": "ef2dc719c9137ae0ee7dfcab91235952ccd147d3", "filename": "libffi/README", "status": "modified", "additions": 111, "deletions": 263, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/491e6ad11cf6f4e3d52de07bd9892924f8dd6b51/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=491e6ad11cf6f4e3d52de07bd9892924f8dd6b51", "patch": "@@ -4,10 +4,8 @@ shipped with GCC as convenience.\n Status\n ======\n \n-libffi-2.00 has not been released yet! This is a development snapshot!\n-\n-libffi-1.20 was released on October 5, 1998. Check the libffi web\n-page for updates: <URL:http://sources.redhat.com/libffi/>.\n+libffi-3.0.8 was released on December 19, 2008. Check the libffi web\n+page for updates: <URL:http://sourceware.org/libffi/>.\n \n \n What is libffi?\n@@ -32,7 +30,7 @@ interface to various calling conventions. This allows a programmer to\n call any function specified by a call interface description at run\n time.  \n \n-Ffi stands for Foreign Function Interface. A foreign function\n+FFI stands for Foreign Function Interface.  A foreign function\n interface is the popular name for the interface that allows code\n written in one language to call code written in another language. The\n libffi library really only provides the lowest, machine dependent\n@@ -41,38 +39,36 @@ exist above libffi that handles type conversions for values passed\n between the two languages.\n \n \n-Supported Platforms and Prerequisites\n-=====================================\n-\n-Libffi has been ported to:\n-\n-\tSunOS 4.1.3 & Solaris 2.x (SPARC-V8, SPARC-V9)\n-\n-\tIrix 5.3 & 6.2 (System V/o32 & n32)\n-\n-\tIntel x86 - Linux (System V ABI)\n-\n-\tAlpha - Linux and OSF/1\n-\n-\tm68k - Linux (System V ABI)\n-\n-\tPowerPC - Linux (System V ABI, Darwin, AIX)\n-\n-\tARM - Linux (System V ABI)\n-\n-Libffi has been tested with the egcs 1.0.2 gcc compiler. Chances are\n-that other versions will work.  Libffi has also been built and tested\n-with the SGI compiler tools.\n-\n-On PowerPC, the tests failed (see the note below).\n-\n-You must use GNU make to build libffi. SGI's make will not work.\n-Sun's probably won't either.\n-\t\n-If you port libffi to another platform, please let me know! I assume\n-that some will be easy (x86 NetBSD), and others will be more difficult\n-(HP).\n-\n+Supported Platforms\n+===================\n+\n+Libffi has been ported to many different platforms, although this\n+release was only tested on:\n+\n+     arm oabi linux\n+     arm eabi linux\n+     hppa linux\n+     mips o32 linux (little endian)\n+     powerpc darwin\n+     powerpc freebsd\n+     powerpc64 linux\n+     sparc solaris\n+     sparc64 freebsd\n+     sparc64 solaris\n+     x86 cygwin\n+     x86 darwin\n+     x86 freebsd\n+     x86 linux\n+     x86 openbsd\n+     x86 solaris\n+     x86-64 darwin\n+     x86-64 linux\n+     x86-64 OS X\n+     x86-64 freebsd\n+     x86-64 solaris\n+     \n+Please send additional platform test results to\n+libffi-discuss@sourceware.org.\n \n Installing libffi\n =================\n@@ -101,216 +97,17 @@ Purify, as it will slow down the library.\n Configure has many other options. Use \"configure --help\" to see them all.\n \n Once configure has finished, type \"make\". Note that you must be using\n-GNU make. SGI's make will not work.  Sun's probably won't either.\n-You can ftp GNU make from prep.ai.mit.edu:/pub/gnu.\n+GNU make.  You can ftp GNU make from prep.ai.mit.edu:/pub/gnu.\n \n-To ensure that libffi is working as advertised, type \"make test\".\n+To ensure that libffi is working as advertised, type \"make check\".\n+This will require that you have DejaGNU installed.\n \n To install the library and header files, type \"make install\".\n \n \n-Using libffi\n-============\n-\n-\tThe Basics\n-\t----------\n-\n-Libffi assumes that you have a pointer to the function you wish to\n-call and that you know the number and types of arguments to pass it,\n-as well as the return type of the function.\n-\n-The first thing you must do is create an ffi_cif object that matches\n-the signature of the function you wish to call. The cif in ffi_cif\n-stands for Call InterFace. To prepare a call interface object, use the\n-following function:\n-\n-ffi_status ffi_prep_cif(ffi_cif *cif, ffi_abi abi,\n-\t\t\tunsigned int nargs, \n-\t\t\tffi_type *rtype, ffi_type **atypes);\n-\n-\tCIF is a pointer to the call interface object you wish\n-\t\tto initialize.\n-\n-\tABI is an enum that specifies the calling convention \n-\t\tto use for the call. FFI_DEFAULT_ABI defaults\n-\t\tto the system's native calling convention. Other\n-\t\tABI's may be used with care. They are system\n-\t\tspecific.\n-\n-\tNARGS is the number of arguments this function accepts.\t\n-\t\tlibffi does not yet support vararg functions.\n-\n-\tRTYPE is a pointer to an ffi_type structure that represents\n-\t\tthe return type of the function. Ffi_type objects\n-\t\tdescribe the types of values. libffi provides\n-\t\tffi_type objects for many of the native C types:\n-\t\tsigned int, unsigned int, signed char, unsigned char,\n-\t\tetc. There is also a pointer ffi_type object and\n-\t\ta void ffi_type. Use &ffi_type_void for functions that \n-\t\tdon't return values.\n-\n-\tATYPES is a vector of ffi_type pointers. ARGS must be NARGS long.\n-\t\tIf NARGS is 0, this is ignored.\n-\n-\n-ffi_prep_cif will return a status code that you are responsible \n-for checking. It will be one of the following:\n-\n-\tFFI_OK - All is good.\n-\n-\tFFI_BAD_TYPEDEF - One of the ffi_type objects that ffi_prep_cif\n-\t\tcame across is bad.\n-\n-\n-Before making the call, the VALUES vector should be initialized \n-with pointers to the appropriate argument values.\n-\n-To call the the function using the initialized ffi_cif, use the\n-ffi_call function:\n-\n-void ffi_call(ffi_cif *cif, void *fn, void *rvalue, void **avalues);\n-\n-\tCIF is a pointer to the ffi_cif initialized specifically\n-\t\tfor this function.\n-\n-\tFN is a pointer to the function you want to call.\n-\n-\tRVALUE is a pointer to a chunk of memory that is to hold the\n-\t\tresult of the function call. Currently, it must be\n-\t\tat least one word in size (except for the n32 version\n-\t\tunder Irix 6.x, which must be a pointer to an 8 byte \n-\t\taligned value (a long long). It must also be at least \n-\t\tword aligned (depending on the return type, and the\n-\t\tsystem's alignment requirements). If RTYPE is \n-\t\t&ffi_type_void, this is ignored. If RVALUE is NULL, \n-\t\tthe return value is discarded.\n-\n-\tAVALUES is a vector of void* that point to the memory locations\n-\t\tholding the argument values for a call.\n-\t\tIf NARGS is 0, this is ignored.\n-\n-\n-If you are expecting a return value from FN it will have been stored\n-at RVALUE.\n-\n-\n-\n-\tAn Example\n-\t----------\n-\n-Here is a trivial example that calls puts() a few times.\n-\n-    #include <stdio.h>\n-    #include <ffi.h>\n-    \n-    int main()\n-    {\n-      ffi_cif cif;\n-      ffi_type *args[1];\n-      void *values[1];\n-      char *s;\n-      int rc;\n-      \n-      /* Initialize the argument info vectors */    \n-      args[0] = &ffi_type_pointer;\n-      values[0] = &s;\n-      \n-      /* Initialize the cif */\n-      if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-    \t\t       &ffi_type_uint, args) == FFI_OK)\n-        {\n-          s = \"Hello World!\";\n-          ffi_call(&cif, puts, &rc, values);\n-          /* rc now holds the result of the call to puts */\n-          \n-          /* values holds a pointer to the function's arg, so to \n-\t     call puts() again all we need to do is change the \n-             value of s */\n-          s = \"This is cool!\";\n-          ffi_call(&cif, puts, &rc, values);\n-        }\n-      \n-      return 0;\n-    }\n-\n-\n-\n-\tAggregate Types\n-\t---------------\n-\n-Although libffi has no special support for unions or bit-fields, it is\n-perfectly happy passing structures back and forth. You must first\n-describe the structure to libffi by creating a new ffi_type object\n-for it. Here is the definition of ffi_type:\n-\n-    typedef struct _ffi_type\n-    {\n-      unsigned size;\n-      short alignment;\n-      short type;\n-      struct _ffi_type **elements;\n-    } ffi_type;\n-    \n-All structures must have type set to FFI_TYPE_STRUCT.  You may set\n-size and alignment to 0. These will be calculated and reset to the\n-appropriate values by ffi_prep_cif().\n-\n-elements is a NULL terminated array of pointers to ffi_type objects\n-that describe the type of the structure elements. These may, in turn,\n-be structure elements.\n-\n-The following example initializes a ffi_type object representing the\n-tm struct from Linux's time.h:\n-\n-\t\t\t\t    struct tm {\n-\t\t\t\t\tint tm_sec;\n-\t\t\t\t\tint tm_min;\n-\t\t\t\t\tint tm_hour;\n-\t\t\t\t\tint tm_mday;\n-\t\t\t\t\tint tm_mon;\n-\t\t\t\t\tint tm_year;\n-\t\t\t\t\tint tm_wday;\n-\t\t\t\t\tint tm_yday;\n-\t\t\t\t\tint tm_isdst;\n-\t\t\t\t\t/* Those are for future use. */\n-\t\t\t\t\tlong int __tm_gmtoff__;\n-\t\t\t\t\t__const char *__tm_zone__;\n-\t\t\t\t    };\n-\n-    {\n-      ffi_type tm_type;\n-      ffi_type *tm_type_elements[12];\n-      int i;\n-\n-      tm_type.size = tm_type.alignment = 0;\n-      tm_type.elements = &tm_type_elements;\n-    \n-      for (i = 0; i < 9; i++)\n-          tm_type_elements[i] = &ffi_type_sint;\n-\n-      tm_type_elements[9] = &ffi_type_slong;\n-      tm_type_elements[10] = &ffi_type_pointer;\n-      tm_type_elements[11] = NULL;\n-\n-      /* tm_type can now be used to represent tm argument types and\n-\t return types for ffi_prep_cif() */\n-    }\n-\n-\n-\n Platform Specific Notes\n =======================\n \n-\tIntel x86\n-\t---------\n-\n-There are no known problems with the x86 port.\n-\n-\tSun SPARC - SunOS 4.1.3 & Solaris 2.x\n-\t-------------------------------------\n-\n-You must use GNU Make to build libffi on Sun platforms.\n-\n \tMIPS - Irix 5.3 & 6.x\n \t---------------------\n \n@@ -339,13 +136,6 @@ If you don't do this you are liable to get spurious bus errors.\n \n You must use GNU Make to build libffi on SGI platforms.\n \n-\tARM - System V ABI\n-\t------------------\n-\n-The ARM port was performed on a NetWinder running ARM Linux ELF\n-(2.0.31) and gcc 2.8.1.\n-\n-\n \n \tPowerPC System V ABI\n \t--------------------\n@@ -375,6 +165,42 @@ arguments' test).\n History\n =======\n \n+3.0.7 Nov-11-08\n+        Fix for ppc FreeBSD.\n+\t(thanks to Andreas Tobler)\n+\n+3.0.6 Jul-17-08\n+        Fix for closures on sh.\n+\tMark the sh/sh64 stack as non-executable.\n+\t(both thanks to Kaz Kojima)\n+\n+3.0.5 Apr-3-08\n+        Fix libffi.pc file.\n+\tFix #define ARM for IcedTea users.\n+\tFix x86 closure bug.\n+\n+3.0.4 Feb-24-08\n+        Fix x86 OpenBSD configury.\n+\n+3.0.3 Feb-22-08\n+        Enable x86 OpenBSD thanks to Thomas Heller, and\n+\tx86-64 FreeBSD thanks to Bj\u00f6rn K\u00f6nig and Andreas Tobler.\n+\tClean up test instruction in README.\n+\n+3.0.2 Feb-21-08\n+        Improved x86 FreeBSD support.\n+\tThanks to Bj\u00f6rn K\u00f6nig.\n+\n+3.0.1 Feb-15-08\n+        Fix instruction cache flushing bug on MIPS.\n+\tThanks to David Daney.\n+\n+3.0.0 Feb-15-08\n+        Many changes, mostly thanks to the GCC project.\n+\tCygnus Solutions is now Red Hat.\n+\n+  [10 years go by...]\n+\n 1.20 Oct-5-98\n \tRaffaele Sena produces ARM port.\n \n@@ -458,34 +284,56 @@ History\n Authors & Credits\n =================\n \n-libffi was written by Anthony Green <green@cygnus.com>.\n+libffi was originally written by Anthony Green <green@redhat.com>.\n+\n+The developers of the GNU Compiler Collection project have made\n+innumerable valuable contributions.  See the ChangeLog file for\n+details.\n \n-Portions of libffi were derived from Gianni Mariani's free gencall\n-library for Silicon Graphics machines.\n+Some of the ideas behind libffi were inspired by Gianni Mariani's free\n+gencall library for Silicon Graphics machines.\n \n The closure mechanism was designed and implemented by Kresten Krab\n Thorup.\n \n-The Sparc port was derived from code contributed by the fine folks at\n-Visible Decisions Inc <http://www.vdi.com>. Further enhancements were\n-made by Gordon Irlam at Cygnus Solutions <http://www.cygnus.com>.\n-\n-The Alpha port was written by Richard Henderson at Cygnus Solutions.\n-\n-Andreas Schwab ported libffi to m68k Linux and provided a number of\n-bug fixes.\n-\n-Geoffrey Keating ported libffi to the PowerPC.\n-\n-Raffaele Sena ported libffi to the ARM.\n+Major processor architecture ports were contributed by the following\n+developers:\n+\n+alpha\t\tRichard Henderson\n+arm\t\tRaffaele Sena\n+cris\t\tSimon Posnjak, Hans-Peter Nilsson\n+frv\t\tAnthony Green\n+ia64\t\tHans Boehm\n+m32r\t\tKazuhiro Inaoka\n+m68k\t\tAndreas Schwab\n+mips\t\tAnthony Green, Casey Marshall\n+mips64\t\tDavid Daney\n+pa\t\tRandolph Chung, Dave Anglin, Andreas Tobler\n+powerpc\t\tGeoffrey Keating, Andreas Tobler, \n+\t\t\t David Edelsohn, John Hornkvist\n+powerpc64\tJakub Jelinek\n+s390\t\tGerhard Tonn, Ulrich Weigand\n+sh\t\tKaz Kojima\n+sh64\t\tKaz Kojima\n+sparc\t\tAnthony Green, Gordon Irlam\n+x86\t\tAnthony Green, Jon Beniston\n+x86-64\t\tBo Thorsen\n \n Jesper Skov and Andrew Haley both did more than their fair share of\n stepping through the code and tracking down bugs.\n \n-Thanks also to Tom Tromey for bug fixes and configuration help.\n+Thanks also to Tom Tromey for bug fixes, documentation and\n+configuration help.\n \n Thanks to Jim Blandy, who provided some useful feedback on the libffi\n interface.\n \n+Andreas Tobler has done a tremendous amount of work on the testsuite.\n+\n+Alex Oliva solved the executable page problem for SElinux.\n+\n+The list above is almost certainly incomplete and inaccurate.  I'm\n+happy to make corrections or additions upon request.\n+\n If you have a problem, or have found a bug, please send a note to\n-green@cygnus.com.\n+green@redhat.com."}]}