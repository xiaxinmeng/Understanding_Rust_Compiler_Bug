{"sha": "a7a44c07369631201744422c02dbe59655201865", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhNDRjMDczNjk2MzEyMDE3NDQ0MjJjMDJkYmU1OTY1NTIwMTg2NQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T11:57:44Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T11:57:44Z"}, "message": "tree-loop-distribution.c (struct partition): New field recording its data reference.\n\n\t* tree-loop-distribution.c (struct partition): New field recording\n\tits data reference.\n\t(partition_alloc, partition_free): Init and release data refs.\n\t(partition_merge_into): Merge data refs.\n\t(build_rdg_partition_for_vertex): Collect data refs for partition.\n\t(pg_add_dependence_edges): Change parameters from vector to bitmap.\n\tUpdate uses.\n\t(distribute_loop): Remve data refs from vertice data of partition\n\tgraph.\n\nFrom-SVN: r249989", "tree": {"sha": "eab04b6cc3ecbc74d06d0f768090248aa4cc8434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eab04b6cc3ecbc74d06d0f768090248aa4cc8434"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7a44c07369631201744422c02dbe59655201865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a44c07369631201744422c02dbe59655201865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a44c07369631201744422c02dbe59655201865", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a44c07369631201744422c02dbe59655201865/comments", "author": null, "committer": null, "parents": [{"sha": "9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fafb14af6ca07c4f102cf9ba4afeb51715083e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fafb14af6ca07c4f102cf9ba4afeb51715083e4"}], "stats": {"total": 191, "additions": 106, "deletions": 85}, "files": [{"sha": "212b3c393986316937ee95e89e3d09b49d2dd117", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a44c07369631201744422c02dbe59655201865/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a44c07369631201744422c02dbe59655201865/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7a44c07369631201744422c02dbe59655201865", "patch": "@@ -1,3 +1,15 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (struct partition): New field recording\n+\tits data reference.\n+\t(partition_alloc, partition_free): Init and release data refs.\n+\t(partition_merge_into): Merge data refs.\n+\t(build_rdg_partition_for_vertex): Collect data refs for partition.\n+\t(pg_add_dependence_edges): Change parameters from vector to bitmap.\n+\tUpdate uses.\n+\t(distribute_loop): Remve data refs from vertice data of partition\n+\tgraph.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (params.h): Include header file."}, {"sha": "eafd11941cc2f0bb6985c78cbef8d7ddf2af3b5e", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 94, "deletions": 85, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a44c07369631201744422c02dbe59655201865/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a44c07369631201744422c02dbe59655201865/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=a7a44c07369631201744422c02dbe59655201865", "patch": "@@ -500,30 +500,40 @@ enum partition_kind {\n     PKIND_NORMAL, PKIND_MEMSET, PKIND_MEMCPY, PKIND_MEMMOVE\n };\n \n+/* Partition for loop distribution.  */\n struct partition\n {\n+  /* Statements of the partition.  */\n   bitmap stmts;\n+  /* Loops of the partition.  */\n   bitmap loops;\n+  /* True if the partition defines variable which is used outside of loop.  */\n   bool reduction_p;\n+  /* For builtin partition, true if it executes one iteration more than\n+     number of loop (latch) iterations.  */\n   bool plus_one;\n   enum partition_kind kind;\n   /* data-references a kind != PKIND_NORMAL partition is about.  */\n   data_reference_p main_dr;\n   data_reference_p secondary_dr;\n+  /* Number of loop (latch) iterations.  */\n   tree niter;\n+  /* Data references in the partition.  */\n+  bitmap datarefs;\n };\n \n \n /* Allocate and initialize a partition from BITMAP.  */\n \n static partition *\n-partition_alloc (bitmap stmts, bitmap loops)\n+partition_alloc (void)\n {\n   partition *partition = XCNEW (struct partition);\n-  partition->stmts = stmts ? stmts : BITMAP_ALLOC (NULL);\n-  partition->loops = loops ? loops : BITMAP_ALLOC (NULL);\n+  partition->stmts = BITMAP_ALLOC (NULL);\n+  partition->loops = BITMAP_ALLOC (NULL);\n   partition->reduction_p = false;\n   partition->kind = PKIND_NORMAL;\n+  partition->datarefs = BITMAP_ALLOC (NULL);\n   return partition;\n }\n \n@@ -534,6 +544,7 @@ partition_free (partition *partition)\n {\n   BITMAP_FREE (partition->stmts);\n   BITMAP_FREE (partition->loops);\n+  BITMAP_FREE (partition->datarefs);\n   free (partition);\n }\n \n@@ -581,6 +592,8 @@ partition_merge_into (partition *dest, partition *partition, enum fuse_type ft)\n   if (partition_reduction_p (partition))\n     dest->reduction_p = true;\n \n+  bitmap_ior_into (dest->datarefs, partition->datarefs);\n+\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Fuse partitions because %s:\\n\", fuse_message[ft]);\n@@ -1051,10 +1064,11 @@ generate_code_for_partition (struct loop *loop,\n static partition *\n build_rdg_partition_for_vertex (struct graph *rdg, int v)\n {\n-  partition *partition = partition_alloc (NULL, NULL);\n+  partition *partition = partition_alloc ();\n   auto_vec<int, 3> nodes;\n-  unsigned i;\n+  unsigned i, j;\n   int x;\n+  data_reference_p dr;\n \n   graphds_dfs (rdg, &v, 1, &nodes, false, NULL);\n \n@@ -1063,6 +1077,14 @@ build_rdg_partition_for_vertex (struct graph *rdg, int v)\n       bitmap_set_bit (partition->stmts, x);\n       bitmap_set_bit (partition->loops,\n \t\t      loop_containing_stmt (RDG_STMT (rdg, x))->num);\n+\n+      for (j = 0; RDG_DATAREFS (rdg, x).iterate (j, &dr); ++j)\n+\t{\n+\t  unsigned idx = (unsigned) DR_INDEX (dr);\n+\t  gcc_assert (idx < datarefs_vec.length ());\n+\n+\t  bitmap_set_bit (partition->datarefs, idx);\n+\t}\n     }\n \n   return partition;\n@@ -1427,63 +1449,74 @@ partition_contains_all_rw (struct graph *rdg,\n \n static int\n pg_add_dependence_edges (struct graph *rdg, int dir,\n-\t\t\t vec<data_reference_p> drs1,\n-\t\t\t vec<data_reference_p> drs2)\n+\t\t\t bitmap drs1, bitmap drs2)\n {\n-  data_reference_p dr1, dr2;\n+  unsigned i, j;\n+  bitmap_iterator bi, bj;\n+  data_reference_p dr1, dr2, saved_dr1;\n \n   /* dependence direction - 0 is no dependence, -1 is back,\n      1 is forth, 2 is both (we can stop then, merging will occur).  */\n-  for (int ii = 0; drs1.iterate (ii, &dr1); ++ii)\n-    for (int jj = 0; drs2.iterate (jj, &dr2); ++jj)\n-      {\n-\tdata_reference_p saved_dr1 = dr1;\n-\tint this_dir = 1;\n-\tddr_p ddr;\n-\t/* Re-shuffle data-refs to be in dominator order.  */\n-\tif (rdg_vertex_for_stmt (rdg, DR_STMT (dr1))\n-\t    > rdg_vertex_for_stmt (rdg, DR_STMT (dr2)))\n-\t  {\n-\t    std::swap (dr1, dr2);\n-\t    this_dir = -this_dir;\n-\t  }\n-\tddr = initialize_data_dependence_relation (dr1, dr2, loop_nest);\n-\tcompute_affine_dependence (ddr, loop_nest[0]);\n-\tif (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-\t  this_dir = 2;\n-\telse if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-\t  {\n-\t    if (DDR_REVERSED_P (ddr))\n-\t      {\n-\t\tstd::swap (dr1, dr2);\n-\t\tthis_dir = -this_dir;\n-\t      }\n-\t    /* Known dependences can still be unordered througout the\n-\t       iteration space, see gcc.dg/tree-ssa/ldist-16.c.  */\n-\t    if (DDR_NUM_DIST_VECTS (ddr) != 1)\n-\t      this_dir = 2;\n-\t    /* If the overlap is exact preserve stmt order.  */\n-\t    else if (lambda_vector_zerop (DDR_DIST_VECT (ddr, 0), 1))\n-\t      ;\n-\t    else\n-\t      {\n-\t\t/* Else as the distance vector is lexicographic positive\n-\t\t   swap the dependence direction.  */\n-\t\tthis_dir = -this_dir;\n-\t      }\n-\t  }\n-\telse\n-\t  this_dir = 0;\n-\tfree_dependence_relation (ddr);\n-\tif (this_dir == 2)\n-\t  return 2;\n-\telse if (dir == 0)\n-\t  dir = this_dir;\n-\telse if (this_dir != 0 && dir != this_dir)\n-\t  return 2;\n-\t/* Shuffle \"back\" dr1.  */\n-\tdr1 = saved_dr1;\n-      }\n+  EXECUTE_IF_SET_IN_BITMAP (drs1, 0, i, bi)\n+    {\n+      dr1 = datarefs_vec[i];\n+\n+      EXECUTE_IF_SET_IN_BITMAP (drs2, 0, j, bj)\n+\t{\n+\t  dr2 = datarefs_vec[j];\n+\n+\t  /* Skip all <read, read> data dependence.  */\n+\t  if (DR_IS_READ (dr1) && DR_IS_READ (dr2))\n+\t    continue;\n+\n+\t  saved_dr1 = dr1;\n+\t  int this_dir = 1;\n+\t  ddr_p ddr;\n+\t  /* Re-shuffle data-refs to be in dominator order.  */\n+\t  if (rdg_vertex_for_stmt (rdg, DR_STMT (dr1))\n+\t      > rdg_vertex_for_stmt (rdg, DR_STMT (dr2)))\n+\t    {\n+\t      std::swap (dr1, dr2);\n+\t      this_dir = -this_dir;\n+\t    }\n+\t  ddr = initialize_data_dependence_relation (dr1, dr2, loop_nest);\n+\t  compute_affine_dependence (ddr, loop_nest[0]);\n+\t  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+\t    this_dir = 2;\n+\t  else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+\t    {\n+\t      if (DDR_REVERSED_P (ddr))\n+\t\t{\n+\t\t  std::swap (dr1, dr2);\n+\t\t  this_dir = -this_dir;\n+\t\t}\n+\t      /* Known dependences can still be unordered througout the\n+\t\t iteration space, see gcc.dg/tree-ssa/ldist-16.c.  */\n+\t      if (DDR_NUM_DIST_VECTS (ddr) != 1)\n+\t\tthis_dir = 2;\n+\t      /* If the overlap is exact preserve stmt order.  */\n+\t      else if (lambda_vector_zerop (DDR_DIST_VECT (ddr, 0), 1))\n+\t\t;\n+\t      else\n+\t\t{\n+\t\t  /* Else as the distance vector is lexicographic positive\n+\t\t     swap the dependence direction.  */\n+\t\t  this_dir = -this_dir;\n+\t\t}\n+\t    }\n+\t  else\n+\t    this_dir = 0;\n+\t  free_dependence_relation (ddr);\n+\t  if (this_dir == 2)\n+\t    return 2;\n+\t  else if (dir == 0)\n+\t    dir = this_dir;\n+\t  else if (this_dir != 0 && dir != this_dir)\n+\t    return 2;\n+\t  /* Shuffle \"back\" dr1.  */\n+\t  dr1 = saved_dr1;\n+\t}\n+    }\n   return dir;\n }\n \n@@ -1644,47 +1677,25 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n       pg = new_graph (partitions.length ());\n       struct pgdata {\n \t  struct partition *partition;\n-\t  vec<data_reference_p> writes;\n-\t  vec<data_reference_p> reads;\n       };\n #define PGDATA(i) ((pgdata *)(pg->vertices[i].data))\n       for (i = 0; partitions.iterate (i, &partition); ++i)\n \t{\n \t  vertex *v = &pg->vertices[i];\n \t  pgdata *data = new pgdata;\n-\t  data_reference_p dr;\n \t  /* FIXME - leaks.  */\n \t  v->data = data;\n-\t  bitmap_iterator bi;\n-\t  unsigned j;\n \t  data->partition = partition;\n-\t  data->reads = vNULL;\n-\t  data->writes = vNULL;\n-\t  EXECUTE_IF_SET_IN_BITMAP (partition->stmts, 0, j, bi)\n-\t    for (int k = 0; RDG_DATAREFS (rdg, j).iterate (k, &dr); ++k)\n-\t      if (DR_IS_READ (dr))\n-\t\tdata->reads.safe_push (dr);\n-\t      else\n-\t\tdata->writes.safe_push (dr);\n \t}\n       struct partition *partition1, *partition2;\n       for (i = 0; partitions.iterate (i, &partition1); ++i)\n \tfor (int j = i + 1; partitions.iterate (j, &partition2); ++j)\n \t  {\n \t    /* dependence direction - 0 is no dependence, -1 is back,\n \t       1 is forth, 2 is both (we can stop then, merging will occur).  */\n-\t    int dir = 0;\n-\t    dir = pg_add_dependence_edges (rdg, dir,\n-\t\t\t\t\t   PGDATA(i)->writes,\n-\t\t\t\t\t   PGDATA(j)->reads);\n-\t    if (dir != 2)\n-\t      dir = pg_add_dependence_edges (rdg, dir,\n-\t\t\t\t\t     PGDATA(i)->reads,\n-\t\t\t\t\t     PGDATA(j)->writes);\n-\t    if (dir != 2)\n-\t      dir = pg_add_dependence_edges (rdg, dir,\n-\t\t\t\t\t     PGDATA(i)->writes,\n-\t\t\t\t\t     PGDATA(j)->writes);\n+\t    int dir = pg_add_dependence_edges (rdg, 0,\n+\t\t\t\t\t       partition1->datarefs,\n+\t\t\t\t\t       partition2->datarefs);\n \t    if (dir == 1 || dir == 2)\n \t      add_edge (pg, i, j);\n \t    if (dir == -1 || dir == 2)\n@@ -1730,8 +1741,6 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n \t  pgdata *data = PGDATA (i);\n \t  if (data->partition)\n \t    partitions.safe_push (data->partition);\n-\t  data->reads.release ();\n-\t  data->writes.release ();\n \t  delete data;\n \t}\n       gcc_assert (partitions.length () == (unsigned)num_sccs);"}]}