{"sha": "8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODcxM2QwZjFjNDZmODExMDdlYTYxNzgxZTJmNGRjOTE4ZDBmYjY3ZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-09-04T14:00:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-09-04T14:00:29Z"}, "message": "re PR tree-optimization/64910 (tree reassociation results in poor code)\n\n2017-09-03  Jeff Law  <law@redhat.com>\n\n\tPR tree-optimization/64910\n\t* tree-ssa-reassoc.c (reassociate_bb): For bitwise binary ops,\n\tswap the first and last operand if the last is a constant.\n\n\tPR tree-optimization/64910\n\t* gcc.dg/tree-ssa/pr64910-2.c: New test.\n\nFrom-SVN: r251659", "tree": {"sha": "48e17398703864eb4a21643c5d2da00328515093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e17398703864eb4a21643c5d2da00328515093"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/comments", "author": null, "committer": null, "parents": [{"sha": "8d2b48ae9f3e1e70dfe2aaf32abb9e74594b8875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2b48ae9f3e1e70dfe2aaf32abb9e74594b8875", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2b48ae9f3e1e70dfe2aaf32abb9e74594b8875"}], "stats": {"total": 108, "additions": 108, "deletions": 0}, "files": [{"sha": "5170417bbb025008b620b4b8046bd9195af0a33d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "patch": "@@ -1,3 +1,9 @@\n+2017-09-04  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/64910\n+\t* tree-ssa-reassoc.c (reassociate_bb): For bitwise binary ops,\n+\tswap the first and last operand if the last is a constant.\n+\n 2017-09-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/82072"}, {"sha": "8920c76f8c5d94aec0e62d0ebc9557ff94ec9f6c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "patch": "@@ -1,3 +1,8 @@\n+2017-09-04  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/64910\n+\t* gcc.dg/tree-ssa/pr64910-2.c: New test.\n+\n 2017-09-04  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/82072"}, {"sha": "2e3d6790776d15d97760a42547f6bce9907cad0e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr64910-2.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64910-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64910-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64910-2.c?ref=8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-reassoc1\" } */\n+\n+/* We want to make sure that we reassociate in a way that has the\n+   constant last.  With the constant last, it's more likely to result\n+   in a bitfield test on targets with such capabilities.  */\n+\n+extern void boo ();\n+\n+int b2b_uc (unsigned char u, unsigned char w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+\n+int b2b_us (unsigned short u, unsigned short w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+\n+int b2b_ui (unsigned int u, unsigned int w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+int b2b_ul (unsigned long u, unsigned long w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+int b2b_ull (unsigned long long u, unsigned long long w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+\n+int b2b_sc (signed char u, signed char w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+\n+int b2b_ss (signed short u, signed short w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+\n+int b2b_si (signed int u, signed int w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+int b2b_sl (signed long u, signed long w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+int b2b_sll (signed long long u, signed long long w)\n+{\n+  if ((u & w) & 0x20)\n+    boo ();\n+}\n+\n+/* The AND of U & W should go into a temporary, when is then ANDed\n+   with the constant.\n+\n+   First verify that we have the right number of ANDs between U and W.  */\n+/* { dg-final { scan-tree-dump-times \"\\[uw\\]_\\[0-9\\]+.D. \\& \\[uw\\]_\\[0-9\\]+.D.;\" 10 \"reassoc1\"} } */\n+\n+/* Then verify that we have the right number of ANDS between a temporary\n+   and the constant.  */\n+/* { dg-final { scan-tree-dump-times \"_\\[0-9]+ \\& 32;\" 10 \"reassoc1\"} } */\n+\n+/* Each function has one AND.  It will have either a second AND or TEST.  So\n+   we can count the number of AND and TEST instructions.  They must be 2X\n+   the number of test functions in this file.  */\n+/* { dg-final { scan-assembler-times \"and|test\" 20 { target { i?86-*-* x86_64-*-*} } } } */\n+\n+/* Similarly on the m68k.  The code for the long long tests is suboptimal,\n+   which catch via the second pattern and xfail.  */\n+/* { dg-final { scan-assembler-times \"and|btst\" 20 { target { m68k-*-* } } } } */\n+/* { dg-final { scan-assembler-not \"or\" { target { m68k-*-* } xfail { *-*-* } } } } */\n+"}, {"sha": "76048196b277804f937984e9dbe850e24e42b723", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8713d0f1c46f81107ea61781e2f4dc918d0fb67d/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=8713d0f1c46f81107ea61781e2f4dc918d0fb67d", "patch": "@@ -5762,6 +5762,18 @@ reassociate_bb (basic_block bb)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Width = %d was chosen for reassociation\\n\", width);\n \n+\n+\t\t  /* For binary bit operations, if the last operand in\n+\t\t     OPS is a constant, move it to the front.  This\n+\t\t     helps ensure that we generate (X & Y) & C rather\n+\t\t     than (X & C) & Y.  The former will often match\n+\t\t     a canonical bit test when we get to RTL.  */\n+\t\t  if ((rhs_code == BIT_AND_EXPR\n+\t\t       || rhs_code == BIT_IOR_EXPR\n+\t\t       || rhs_code == BIT_XOR_EXPR)\n+\t\t      && TREE_CODE (ops.last ()->op) == INTEGER_CST)\n+\t\t    std::swap (*ops[0], *ops[ops_num - 1]);\n+\n \t\t  if (width > 1\n \t\t      && ops.length () > 3)\n \t\t    rewrite_expr_tree_parallel (as_a <gassign *> (stmt),"}]}