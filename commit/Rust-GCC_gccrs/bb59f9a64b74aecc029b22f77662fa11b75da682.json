{"sha": "bb59f9a64b74aecc029b22f77662fa11b75da682", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI1OWY5YTY0Yjc0YWVjYzAyOWIyMmY3NzY2MmZhMTFiNzVkYTY4Mg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-01-02T08:32:09Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-01-02T08:32:09Z"}, "message": "(main): Look for `real-ld' after `gld', before `ld'.\n\nFix typo in -debug part of previous change.\n\n\nLook for tools using paths rather than a single prefix.\n(struct prefix_list, struct path_prefix): New structures.\n(cpath, path): New variables.\n(find_a_file, add_prefix): New functions; simplified versions of\nfunctions from gcc.c.\n(prefix_from_env): New function.\n(main): Get path to search for binaries from COMPILER_PATH\nenvironment variable always set by gcc.c and from PATH.\nQualify names with target machine in cross-environment unless\nusing compiler directories.\nUse find_a_file to find our binaries.\nRemove use of single prefix.\nIf -debug, print strip_file_name.\n(fork_execute): Print program we are trying to execute if -debug and\nwe can't find the file.\n(scan_prog_file): Complain if can't find nm.\n\nFrom-SVN: r3052", "tree": {"sha": "a318cb61d266d3da663daa838a33b89045cd6398", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a318cb61d266d3da663daa838a33b89045cd6398"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb59f9a64b74aecc029b22f77662fa11b75da682", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb59f9a64b74aecc029b22f77662fa11b75da682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb59f9a64b74aecc029b22f77662fa11b75da682", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb59f9a64b74aecc029b22f77662fa11b75da682/comments", "author": null, "committer": null, "parents": [{"sha": "d54d8150fe14e7e1f35d5d7e3141a1ca3d352b98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54d8150fe14e7e1f35d5d7e3141a1ca3d352b98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54d8150fe14e7e1f35d5d7e3141a1ca3d352b98"}], "stats": {"total": 444, "additions": 311, "deletions": 133}, "files": [{"sha": "50381d7951bf6549704a1f372713156250a0eaee", "filename": "gcc/collect2.c", "status": "modified", "additions": 311, "deletions": 133, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb59f9a64b74aecc029b22f77662fa11b75da682/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb59f9a64b74aecc029b22f77662fa11b75da682/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=bb59f9a64b74aecc029b22f77662fa11b75da682", "patch": "@@ -73,11 +73,17 @@ extern int errno;\n \f\n /* On certain systems, we have code that works by scanning the object file\n    directly.  But this code uses system-specific header files and library\n-   functions, so turn it off in a cross-compiler.  */\n+   functions, so turn it off in a cross-compiler.  Likewise, the names of\n+   the utilities aren't correct for a cross-compiler; we have to hope that\n+   cross-versions are in the proper directories.  */\n \n #ifdef CROSS_COMPILE\n #undef OBJECT_FORMAT_COFF\n #undef OBJECT_FORMAT_ROSE\n+#undef MD_EXEC_PREFIX\n+#undef REAL_LD_FILE_NAME\n+#undef REAL_NM_FILE_NAME\n+#undef REAL_STRIP_FILE_NAME\n #endif\n \n /* If we can't use a special method, use the ordinary one:\n@@ -444,7 +450,169 @@ choose_temp_base ()\n   mktemp (temp_filename);\n   temp_filename_length = strlen (temp_filename);\n }\n+\f\n+/* By default, colon separates directories in a path.  */\n+#ifndef PATH_SEPARATOR\n+#define PATH_SEPARATOR ':'\n+#endif\n+\n+/* Structure to hold all the directories in which to search for files to\n+   execute.  */\n+\n+struct prefix_list\n+{\n+  char *prefix;               /* String to prepend to the path. */\n+  struct prefix_list *next;   /* Next in linked list. */\n+};\n+\n+struct path_prefix\n+{\n+  struct prefix_list *plist;  /* List of prefixes to try */\n+  int max_len;                /* Max length of a prefix in PLIST */\n+  char *name;                 /* Name of this list (used in config stuff) */\n+};\n+\n+/* We maintain two prefix lists: one from COMPILER_PATH environment variable\n+   and one from the PATH variable.  */\n+\n+static struct path_prefix cpath, path;\n+\n+#ifdef CROSS_COMPILE\n+/* This is the name of the target machine.  We use it to form the name\n+   of the files to execute.  */\n+\n+static char *target_machine = TARGET_MACHINE;\n+#endif\n+\f\n+/* Search for NAME using prefix list PPREFIX.  We only look for executable\n+   files. \n+\n+   Return 0 if not found, otherwise return its name, allocated with malloc. */\n+\n+static char *\n+find_a_file (pprefix, name)\n+     struct path_prefix *pprefix;\n+     char *name;\n+{\n+  char *temp;\n+  struct prefix_list *pl;\n+  int len = pprefix->max_len + strlen (name) + 1;\n+\n+#ifdef EXECUTABLE_SUFFIX\n+  len += strlen (EXECUTABLE_SUFFIX);\n+#endif\n+\n+  temp = xmalloc (len);\n+\n+  /* Determine the filename to execute (special case for absolute paths).  */\n+\n+  if (*name == '/')\n+    {\n+      if (access (name, X_OK))\n+\t{\n+\t  strcpy (temp, name);\n+\t  return temp;\n+\t}\n+    }\n+  else\n+    for (pl = pprefix->plist; pl; pl = pl->next)\n+      {\n+\tstrcpy (temp, pl->prefix);\n+\tstrcat (temp, name);\n+\tif (access (temp, X_OK) == 0)\n+\t  return temp;\n+\n+#ifdef EXECUTABLE_SUFFIX\n+\t/* Some systems have a suffix for executable files.\n+\t   So try appending that.  */\n+\tstrcat (temp, EXECUTABLE_SUFFIX);\n+\tif (access (temp, X_OK) == 0)\n+\t  return temp;\n+#endif\n+      }\n+\n+  free (temp);\n+  return 0;\n+}\n+\n+/* Add an entry for PREFIX to prefix list PPREFIX.  */\n \n+static void\n+add_prefix (pprefix, prefix)\n+     struct path_prefix *pprefix;\n+     char *prefix;\n+{\n+  struct prefix_list *pl, **prev;\n+  int len;\n+\n+  if (pprefix->plist)\n+    {\n+      for (pl = pprefix->plist; pl->next; pl = pl->next)\n+\t;\n+      prev = &pl->next;\n+    }\n+  else\n+    prev = &pprefix->plist;\n+\n+  /* Keep track of the longest prefix */\n+\n+  len = strlen (prefix);\n+  if (len > pprefix->max_len)\n+    pprefix->max_len = len;\n+\n+  pl = (struct prefix_list *) xmalloc (sizeof (struct prefix_list));\n+  pl->prefix = savestring (prefix, len);\n+\n+  if (*prev)\n+    pl->next = *prev;\n+  else\n+    pl->next = (struct prefix_list *) 0;\n+  *prev = pl;\n+}\n+\f\n+/* Take the value of the environment variable ENV, break it into a path, and\n+   add of the entries to PPREFIX.  */\n+\n+static void\n+prefix_from_env (env, pprefix)\n+     char *env;\n+     struct path_prefix *pprefix;\n+{\n+  char *p = getenv (env);\n+\n+  if (p)\n+    {\n+      char *startp, *endp;\n+      char *nstore = (char *) xmalloc (strlen (p) + 3);\n+\n+      startp = endp = p;\n+      while (1)\n+\t{\n+\t  if (*endp == PATH_SEPARATOR || *endp == 0)\n+\t    {\n+\t      strncpy (nstore, startp, endp-startp);\n+\t      if (endp == startp)\n+\t\t{\n+\t\t  strcpy (nstore, \"./\");\n+\t\t}\n+\t      else if (endp[-1] != '/')\n+\t\t{\n+\t\t  nstore[endp-startp] = '/';\n+\t\t  nstore[endp-startp+1] = 0;\n+\t\t}\n+\t      else\n+\t\tnstore[endp-startp] = 0;\n+\n+\t      add_prefix (pprefix, nstore);\n+\t      if (*endp == 0)\n+\t\tbreak;\n+\t      endp = startp = endp + 1;\n+\t    }\n+\t  else\n+\t    endp++;\n+\t}\n+    }\n+}\n \f\n /* Main program. */\n \n@@ -453,13 +621,26 @@ main (argc, argv)\n      int argc;\n      char *argv[];\n {\n+  char *ld_suffix\t= \"ld\";\n+  char *full_ld_suffix\t= ld_suffix;\n+  char *real_ld_suffix\t= \"real-ld\";\n+  char *full_real_ld_suffix = ld_suffix;\n+  char *gld_suffix\t= \"gld\";\n+  char *full_gld_suffix\t= gld_suffix;\n+  char *nm_suffix\t= \"nm\";\n+  char *full_nm_suffix\t= nm_suffix;\n+  char *gnm_suffix\t= \"gnm\";\n+  char *full_gnm_suffix\t= gnm_suffix;\n+  char *strip_suffix\t= \"strip\";\n+  char *full_strip_suffix = strip_suffix;\n+  char *gstrip_suffix\t= \"gstrip\";\n+  char *full_gstrip_suffix = gstrip_suffix;\n   char *outfile\t\t= \"a.out\";\n   char *arg;\n   FILE *outf;\n   char *ld_file_name;\n   char *c_file_name;\n   char *p;\n-  char *prefix;\n   char **c_argv;\n   char **c_ptr;\n   char **ld1_argv\t= (char **) xcalloc (sizeof (char *), argc+2);\n@@ -507,148 +688,131 @@ main (argc, argv)\n   if (signal (SIGBUS, SIG_IGN) != SIG_IGN)\n     signal (SIGBUS, handler);\n \n-  /* Try to discover a valid linker/assembler/nm/strip to use.  */\n-  len = strlen (argv[0]);\n-  prefix = (char *)0;\n-  if (len >= sizeof (\"ld\")-1)\n-    {\n-      p = argv[0] + len - sizeof (\"ld\") + 1;\n-      if (strcmp (p, \"ld\") == 0)\n-\t{\n-\t  prefix = argv[0];\n-\t  *p = '\\0';\n-\t}\n-    }\n-\n-  if (prefix == (char *)0)\n-    {\n-      p = rindex (argv[0], '/');\n-      if (p != (char *)0)\n-\t{\n-\t  prefix = argv[0];\n-\t  p[1] = '\\0';\n-\t}\n-\n-#ifdef STANDARD_EXEC_PREFIX\n-      else if (access (STANDARD_EXEC_PREFIX, X_OK) == 0)\n-\tprefix = STANDARD_EXEC_PREFIX;\n-#endif\n-\n-#ifdef MD_EXEC_PREFIX\n-      else if (access (MD_EXEC_PREFIX, X_OK) == 0)\n-\tprefix = MD_EXEC_PREFIX;\n-#endif\n-\n-      else if (access (\"/usr/ccs/gcc\", X_OK) == 0)\n-\tprefix = \"/usr/ccs/gcc/\";\n-\n-      else if (access (\"/usr/ccs/bin\", X_OK) == 0)\n-\tprefix = \"/usr/ccs/bin/\";\n-\n-      else\n-\tprefix = \"/bin/\";\n-    }\n+  /* Extract COMPILER_PATH and PATH into our prefix list.  */\n+  prefix_from_env (\"COMPILER_PATH\", &cpath);\n+  prefix_from_env (\"PATH\", &path);\n \n-  clen = len = strlen (prefix);\n-\n-#ifdef STANDARD_BIN_PREFIX\n-  if (clen < sizeof (STANDARD_BIN_PREFIX) - 1)\n-    clen = sizeof (STANDARD_BIN_PREFIX) - 1;\n+#ifdef CROSS_COMPILE\n+  /* If we look for a program in the compiler directories, we just use\n+     the short name, since these directories are already system-specific.\n+     But it we look for a took in the system directories, we need to\n+     qualify the program name with the target machine.  */\n+\n+  full_ld_suffix\n+    = xcalloc (strlen (ld_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_ld_suffix, ld_suffix);\n+  strcat (full_ld_suffix, \"-\");\n+  strcat (full_ld_suffix, target_machine);\n+\n+  full_real_ld_suffix\n+    = xcalloc (strlen (real_ld_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_real_ld_suffix, real_ld_suffix);\n+  strcat (full_real_ld_suffix, \"-\");\n+  strcat (full_real_ld_suffix, target_machine);\n+\n+  full_gld_suffix\n+    = xcalloc (strlen (gld_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_gld_suffix, gld_suffix);\n+  strcat (full_gld_suffix, \"-\");\n+  strcat (full_gld_suffix, target_machine);\n+\n+  full_nm_suffix\n+    = xcalloc (strlen (nm_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_nm_suffix, nm_suffix);\n+  strcat (full_nm_suffix, \"-\");\n+  strcat (full_nm_suffix, target_machine);\n+\n+  full_gnm_suffix\n+    = xcalloc (strlen (gnm_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_gnm_suffix, gnm_suffix);\n+  strcat (full_gnm_suffix, \"-\");\n+  strcat (full_gnm_suffix, target_machine);\n+\n+  full_strip_suffix\n+    = xcalloc (strlen (strip_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_strip_suffix, strip_suffix);\n+  strcat (full_strip_suffix, \"-\");\n+  strcat (full_strip_suffix, target_machine);\n+  \n+  full_gstrip_suffix\n+    = xcalloc (strlen (gstrip_suffix) + strlen (target_machine) + 1, 1);\n+  strcpy (full_gstrip_suffix, gstrip_suffix);\n+  strcat (full_gstrip_suffix, \"-\");\n+  strcat (full_gstrip_suffix, target_machine);\n+#endif /* CROSS_COMPILE */\n+\n+  /* Try to discover a valid linker/nm/strip to use.  */\n+\n+  /* Search the (target-specific) compiler dirs for `gld'.  */\n+  ld_file_name = find_a_file (&cpath, gld_suffix);\n+  /* Search the ordinary system bin directories\n+     for `gld' (if native linking) or `gld-TARGET' (if cross).  */\n+  if (ld_file_name == 0)\n+    ld_file_name = find_a_file (&path, full_gld_suffix);\n+  /* Likewise for `real-ld'.  */\n+  if (ld_file_name == 0)\n+    ld_file_name = find_a_file (&cpath, real_ld_suffix);\n+  if (ld_file_name == 0)\n+    ld_file_name = find_a_file (&path, full_real_ld_suffix);\n+  /* Maybe we know the right file to use (if not cross).  */\n+#ifdef REAL_LD_FILE_NAME\n+  if (ld_file_name == 0)\n+    ld_file_name = find_a_file (&path, REAL_LD_FILE_NAME);\n #endif\n-\n-#ifdef STANDARD_EXEC_PREFIX\n-  if (clen < sizeof (STANDARD_EXEC_PREFIX) - 1)\n-    clen = sizeof (STANDARD_EXEC_PREFIX) - 1;\n+  /* This would be the right place to search the compiler dirs\n+     for `ld', but we don't do that, since this program is installed\n+     there as `ld'.  */\n+  /* Search the ordinary system bin directories\n+     for `ld' (if native linking) or `ld-TARGET' (if cross).  */\n+  if (ld_file_name == 0)\n+    ld_file_name = find_a_file (&path, full_ld_suffix);\n+\n+  nm_file_name = find_a_file (&cpath, gnm_suffix);\n+  if (nm_file_name == 0)\n+    nm_file_name = find_a_file (&path, full_gnm_suffix);\n+  if (nm_file_name == 0)\n+    nm_file_name = find_a_file (&cpath, nm_suffix);\n+#ifdef REAL_NM_FILE_NAME\n+  if (nm_file_name == 0)\n+    nm_file_name = find_a_file (&path, REAL_NM_FILE_NAME);\n #endif\n-\n-  /* Allocate enough string space for the longest possible pathnames.  */\n-  ld_file_name = xcalloc (len + sizeof (\"real-ld\"), 1);\n-  nm_file_name = xcalloc (len + sizeof (\"gnm\"), 1);\n-  strip_file_name = xcalloc (len + sizeof (\"gstrip\"), 1);\n-\n-  /* Determine the full path name of the ld program to use.  */\n-  bcopy (prefix, ld_file_name, len);\n-  strcpy (ld_file_name + len, \"real-ld\");\n-  if (access (ld_file_name, X_OK) < 0)\n-    {\n-      strcpy (ld_file_name + len, \"gld\");\n-      if (access (ld_file_name, X_OK) < 0)\n-\t{\n-\t  free (ld_file_name);\n-#ifdef REAL_LD_FILE_NAME\n-\t  ld_file_name = REAL_LD_FILE_NAME;\n-#else\n-\t  ld_file_name = (access (\"/usr/bin/ld\", X_OK) == 0\n-\t\t\t  ? \"/usr/bin/ld\" : \"/bin/ld\");\n+  if (nm_file_name == 0)\n+    nm_file_name = find_a_file (&path, full_nm_suffix);\n+\n+  strip_file_name = find_a_file (&cpath, gstrip_suffix);\n+  if (strip_file_name == 0)\n+    strip_file_name = find_a_file (&path, full_gstrip_suffix);\n+  if (strip_file_name == 0)\n+    strip_file_name = find_a_file (&cpath, strip_suffix);\n+#ifdef REAL_STRIP_FILE_NAME\n+  if (strip_file_name == 0)\n+    strip_file_name = find_a_file (&path, REAL_STRIP_FILE_NAME);\n #endif\n-\t}\n-    }\n+  if (strip_file_name == 0)\n+    strip_file_name = find_a_file (&path, full_strip_suffix);\n \n   /* Determine the full path name of the C compiler to use.  */\n   c_file_name = getenv (\"COLLECT_GCC\");\n-  /* If this is absolute, it must be a file that exists.\n-     If it is relative, it must be something that execvp was able to find.\n-     Either way, we can pass it to execvp and find the same executable.  */\n   if (c_file_name == 0)\n     {\n-      c_file_name = xcalloc (clen + sizeof (\"gcc\"), 1);\n-      bcopy (prefix, c_file_name, len);\n-      strcpy (c_file_name + len, \"gcc\");\n-      if (access (c_file_name, X_OK) < 0)\n-\t{\n-#ifdef STANDARD_BIN_PREFIX\n-\t  strcpy (c_file_name, STANDARD_BIN_PREFIX);\n-\t  strcat (c_file_name, \"gcc\");\n-\t  if (access (c_file_name, X_OK) < 0)\n-#endif\n-\t    {\n-#ifdef STANDARD_EXEC_PREFIX\n-\t      strcpy (c_file_name, STANDARD_EXEC_PREFIX);\n-\t      strcat (c_file_name, \"gcc\");\n-\t      if (access (c_file_name, X_OK) < 0)\n-#endif\n-\t\t{\n-\t\t  strcpy (c_file_name, \"gcc\");\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Determine the full path name of the nm to use.  */\n-  bcopy (prefix, nm_file_name, len);\n-  strcpy (nm_file_name + len, \"nm\");\n-  if (access (nm_file_name, X_OK) < 0)\n-    {\n-      strcpy (nm_file_name + len, \"gnm\");\n-      if (access (nm_file_name, X_OK) < 0)\n-\t{\n-\t  free (nm_file_name);\n-#ifdef REAL_NM_FILE_NAME\n-\t  nm_file_name = REAL_NM_FILE_NAME;\n+#ifdef CROSS_COMPILE\n+      c_file_name = xcalloc (strlen (\"gcc\") + strlen (target_machine) + 1, 1);\n+      strcpy (c_file_name, \"gcc-\");\n+      strcat (c_file_name, target_machine);\n #else\n-\t  nm_file_name = (access (\"/usr/bin/nm\", X_OK) == 0\n-\t\t\t  ? \"/usr/bin/nm\" : \"/bin/nm\");\n+      c_file_name = \"gcc\";\n #endif\n-\t}\n     }\n \n-  /* Determine the full pathname of the strip to use.  */\n-  bcopy (prefix, strip_file_name, len);\n-  strcpy (strip_file_name + len, \"strip\");\n-  if (access (strip_file_name, X_OK) < 0)\n-    {\n-      strcpy (strip_file_name + len, \"gstrip\");\n-      if (access (strip_file_name, X_OK) < 0)\n-\t{\n-\t  free (strip_file_name);\n-#ifdef REAL_STRIP_FILE_NAME\n-\t  strip_file_name = REAL_STRIP_FILE_NAME;\n-#else\n-\t  strip_file_name = (access (\"/usr/bin/strip\", X_OK) == 0\n-\t\t\t     ? \"/usr/bin/strip\" : \"/bin/strip\");\n-#endif\n-\t}\n-    }\n+  p = find_a_file (&cpath, c_file_name);\n+\n+  /* Here it should be safe to use the system search path since we should have\n+     already qualified the name of the compiler when it is needed.  */\n+  if (p == 0)\n+    p = find_a_file (&path, c_file_name);\n+\n+  if (p)\n+    c_file_name = p;\n \n   *ld1++ = *ld2++ = \"ld\";\n \n@@ -755,10 +919,10 @@ main (argc, argv)\n   if (debug)\n     {\n       char *ptr;\n-      fprintf (stderr, \"prefix              = %s\\n\", prefix);\n       fprintf (stderr, \"ld_file_name        = %s\\n\", ld_file_name);\n       fprintf (stderr, \"c_file_name         = %s\\n\", c_file_name);\n       fprintf (stderr, \"nm_file_name        = %s\\n\", nm_file_name);\n+      fprintf (stderr, \"strip_file_name     = %s\\n\", strip_file_name);\n       fprintf (stderr, \"c_file              = %s\\n\", c_file);\n       fprintf (stderr, \"o_file              = %s\\n\", o_file);\n \n@@ -902,7 +1066,11 @@ fork_execute (prog, argv)\n       char **p_argv;\n       char *str;\n \n-      fprintf (stderr, \"%s\", prog);\n+      if (prog)\n+\tfprintf (stderr, \"%s\", prog);\n+      else\n+\tfprintf (stderr, \"[cannot find %s]\", argv[0]);\n+\n       for (p_argv = &argv[1]; (str = *p_argv) != (char *)0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n \n@@ -912,6 +1080,12 @@ fork_execute (prog, argv)\n   fflush (stdout);\n   fflush (stderr);\n \n+  /* If we can't find a program we need, complain error.  Do this here\n+     since we might not end up needing something that we couldn't find.  */\n+\n+  if (prog == 0)\n+    fatal (\"cannot find `%s'\", argv[0]);\n+\n   pid = vfork ();\n   if (pid == -1)\n     fatal_perror (\"vfork\");\n@@ -1047,6 +1221,10 @@ scan_prog_file (prog_name, which_pass)\n   if (which_pass != PASS_FIRST)\n     return;\n \n+  /* If we don't have an `nm', complain.  */\n+  if (nm_file_name == 0)\n+    fatal (\"cannot find `nm'\");\n+\n   nm_argv[argc++] = \"nm\";\n   if (NM_FLAGS[0] != '\\0')\n     nm_argv[argc++] = NM_FLAGS;"}]}