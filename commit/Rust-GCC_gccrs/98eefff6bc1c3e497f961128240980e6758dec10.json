{"sha": "98eefff6bc1c3e497f961128240980e6758dec10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThlZWZmZjZiYzFjM2U0OTdmOTYxMTI4MjQwOTgwZTY3NThkZWMxMA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2013-11-14T18:39:14Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2013-11-14T18:39:14Z"}, "message": "rs6000.c (rs6000_psave_function_arg): New function.\n\n2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_psave_function_arg): New function.\n\t(rs6000_finish_function_arg): Likewise.\n\t(rs6000_function_arg): Use rs6000_psave_function_arg and\n\trs6000_finish_function_arg to handle both vector and floating\n\tpoint arguments that are also passed in GPRs / the stack.\n\nFrom-SVN: r204806", "tree": {"sha": "70f357739b5ad9a3cc34f0f0fb1fb77d097b6247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70f357739b5ad9a3cc34f0f0fb1fb77d097b6247"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98eefff6bc1c3e497f961128240980e6758dec10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98eefff6bc1c3e497f961128240980e6758dec10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98eefff6bc1c3e497f961128240980e6758dec10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98eefff6bc1c3e497f961128240980e6758dec10/comments", "author": null, "committer": null, "parents": [{"sha": "abc991e700a45651cff383947df78ba2d5187341", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abc991e700a45651cff383947df78ba2d5187341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abc991e700a45651cff383947df78ba2d5187341"}], "stats": {"total": 212, "additions": 119, "deletions": 93}, "files": [{"sha": "bf58d4b7b95f36acc6578f811cfa5c41905d2ff2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98eefff6bc1c3e497f961128240980e6758dec10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98eefff6bc1c3e497f961128240980e6758dec10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98eefff6bc1c3e497f961128240980e6758dec10", "patch": "@@ -1,3 +1,11 @@\n+2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_psave_function_arg): New function.\n+\t(rs6000_finish_function_arg): Likewise.\n+\t(rs6000_function_arg): Use rs6000_psave_function_arg and\n+\trs6000_finish_function_arg to handle both vector and floating\n+\tpoint arguments that are also passed in GPRs / the stack.\n+\n 2013-11-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n \n \t* config/rs6000/rs6000.c (USE_FP_FOR_ARG_P): Remove TYPE argument."}, {"sha": "dd954949db288aff93ce31ab5667eedfa41c330a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 111, "deletions": 93, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98eefff6bc1c3e497f961128240980e6758dec10/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98eefff6bc1c3e497f961128240980e6758dec10/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=98eefff6bc1c3e497f961128240980e6758dec10", "patch": "@@ -9516,6 +9516,83 @@ rs6000_mixed_function_arg (enum machine_mode mode, const_tree type,\n   return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n }\n \n+/* We have an argument of MODE and TYPE that goes into FPRs or VRs,\n+   but must also be copied into the parameter save area starting at\n+   offset ALIGN_WORDS.  Fill in RVEC with the elements corresponding\n+   to the GPRs and/or memory.  Return the number of elements used.  */\n+\n+static int\n+rs6000_psave_function_arg (enum machine_mode mode, const_tree type,\n+\t\t\t   int align_words, rtx *rvec)\n+{\n+  int k = 0;\n+\n+  if (align_words < GP_ARG_NUM_REG)\n+    {\n+      int n_words = rs6000_arg_size (mode, type);\n+\n+      if (align_words + n_words > GP_ARG_NUM_REG\n+\t  || (TARGET_32BIT && TARGET_POWERPC64))\n+\t{\n+\t  /* If this is partially on the stack, then we only\n+\t     include the portion actually in registers here.  */\n+\t  enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n+\t  int i = 0;\n+\n+\t  if (align_words + n_words > GP_ARG_NUM_REG)\n+\t    {\n+\t      /* Not all of the arg fits in gprs.  Say that it goes in memory\n+\t\t too, using a magic NULL_RTX component.  Also see comment in\n+\t\t rs6000_mixed_function_arg for why the normal\n+\t\t function_arg_partial_nregs scheme doesn't work in this case. */\n+\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+\t    }\n+\n+\t  do\n+\t    {\n+\t      rtx r = gen_rtx_REG (rmode, GP_ARG_MIN_REG + align_words);\n+\t      rtx off = GEN_INT (i++ * GET_MODE_SIZE (rmode));\n+\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n+\t    }\n+\t  while (++align_words < GP_ARG_NUM_REG && --n_words != 0);\n+\t}\n+      else\n+\t{\n+\t  /* The whole arg fits in gprs.  */\n+\t  rtx r = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n+\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n+\t}\n+    }\n+  else\n+    {\n+      /* It's entirely in memory.  */\n+      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+    }\n+\n+  return k;\n+}\n+\n+/* RVEC is a vector of K components of an argument of mode MODE.\n+   Construct the final function_arg return value from it.  */\n+\n+static rtx\n+rs6000_finish_function_arg (enum machine_mode mode, rtx *rvec, int k)\n+{\n+  gcc_assert (k >= 1);\n+\n+  /* Avoid returning a PARALLEL in the trivial cases.  */\n+  if (k == 1)\n+    {\n+      if (XEXP (rvec[0], 0) == NULL_RTX)\n+\treturn NULL_RTX;\n+\n+      if (GET_MODE (XEXP (rvec[0], 0)) == mode)\n+\treturn XEXP (rvec[0], 0);\n+    }\n+\n+  return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n+}\n+\n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -9585,32 +9662,25 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n     }\n \n   if (USE_ALTIVEC_FOR_ARG_P (cum, mode, named))\n-    if (TARGET_64BIT && ! cum->prototype)\n-      {\n-\t/* Vector parameters get passed in vector register\n-\t   and also in GPRs or memory, in absence of prototype.  */\n-\tint align_words;\n-\trtx slot;\n-\talign_words = (cum->words + 1) & ~1;\n+    {\n+      rtx rvec[GP_ARG_NUM_REG + 1];\n+      rtx r;\n+      int k = 0;\n \n-\tif (align_words >= GP_ARG_NUM_REG)\n-\t  {\n-\t    slot = NULL_RTX;\n-\t  }\n-\telse\n-\t  {\n-\t    slot = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n-\t  }\n-\treturn gen_rtx_PARALLEL (mode,\n-\t\t gen_rtvec (2,\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       slot, const0_rtx),\n-\t\t\t    gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t       gen_rtx_REG (mode, cum->vregno),\n-\t\t\t\t\t       const0_rtx)));\n-      }\n-    else\n-      return gen_rtx_REG (mode, cum->vregno);\n+      /* Do we also need to pass this argument in the parameter\n+\t save area?  */\n+      if (TARGET_64BIT && ! cum->prototype)\n+\t{\n+\t  int align_words = (cum->words + 1) & ~1;\n+\t  k = rs6000_psave_function_arg (mode, type, align_words, rvec);\n+\t}\n+\n+      /* Describe where this argument goes in the vector registers.  */\n+      r = gen_rtx_REG (mode, cum->vregno);\n+      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n+\n+      return rs6000_finish_function_arg (mode, rvec, k);\n+    }\n   else if (TARGET_ALTIVEC_ABI\n \t   && (ALTIVEC_OR_VSX_VECTOR_MODE (mode)\n \t       || (type && TREE_CODE (type) == VECTOR_TYPE\n@@ -9716,85 +9786,33 @@ rs6000_function_arg (cumulative_args_t cum_v, enum machine_mode mode,\n \t{\n \t  rtx rvec[GP_ARG_NUM_REG + 1];\n \t  rtx r;\n-\t  int k;\n-\t  bool needs_psave;\n+\t  int k = 0;\n \t  enum machine_mode fmode = mode;\n \t  unsigned long n_fpreg = (GET_MODE_SIZE (mode) + 7) >> 3;\n \n-\t  if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n-\t    {\n-\t      /* Currently, we only ever need one reg here because complex\n-\t\t doubles are split.  */\n-\t      gcc_assert (cum->fregno == FP_ARG_MAX_REG\n-\t\t\t  && (fmode == TFmode || fmode == TDmode));\n-\n-\t      /* Long double or _Decimal128 split over regs and memory.  */\n-\t      fmode = DECIMAL_FLOAT_MODE_P (fmode) ? DDmode : DFmode;\n-\t    }\n-\n-\t  /* Do we also need to pass this arg in the parameter save\n-\t     area?  */\n-\t  needs_psave = (type\n-\t\t\t && (cum->nargs_prototype <= 0\n-\t\t\t     || (DEFAULT_ABI == ABI_AIX\n-\t\t\t\t && TARGET_XL_COMPAT\n-\t\t\t\t && align_words >= GP_ARG_NUM_REG)));\n+\t  /* Do we also need to pass this argument in the parameter\n+\t     save area?  */\n+\t  if (type && (cum->nargs_prototype <= 0\n+\t\t       || (DEFAULT_ABI == ABI_AIX\n+\t\t\t   && TARGET_XL_COMPAT\n+\t\t\t   && align_words >= GP_ARG_NUM_REG)))\n+\t    k = rs6000_psave_function_arg (mode, type, align_words, rvec);\n \n-\t  if (!needs_psave && mode == fmode)\n-\t    return gen_rtx_REG (fmode, cum->fregno);\n+\t  /* Describe where this argument goes in the fprs.  */\n \n-\t  k = 0;\n-\t  if (needs_psave)\n+\t  /* Check if the argument is split over registers and memory.\n+\t     This can only ever happen for long double or _Decimal128;\n+\t     complex types are handled via split_complex_arg.  */\n+\t  if (cum->fregno + n_fpreg > FP_ARG_MAX_REG + 1)\n \t    {\n-\t      /* Describe the part that goes in gprs or the stack.\n-\t\t This piece must come first, before the fprs.  */\n-\t      if (align_words < GP_ARG_NUM_REG)\n-\t\t{\n-\t\t  unsigned long n_words = rs6000_arg_size (mode, type);\n-\n-\t\t  if (align_words + n_words > GP_ARG_NUM_REG\n-\t\t      || (TARGET_32BIT && TARGET_POWERPC64))\n-\t\t    {\n-\t\t      /* If this is partially on the stack, then we only\n-\t\t\t include the portion actually in registers here.  */\n-\t\t      enum machine_mode rmode = TARGET_32BIT ? SImode : DImode;\n-\t\t      rtx off;\n-\t\t      int i = 0;\n-\t\t      if (align_words + n_words > GP_ARG_NUM_REG)\n-\t\t\t/* Not all of the arg fits in gprs.  Say that it\n-\t\t\t   goes in memory too, using a magic NULL_RTX\n-\t\t\t   component.  Also see comment in\n-\t\t\t   rs6000_mixed_function_arg for why the normal\n-\t\t\t   function_arg_partial_nregs scheme doesn't work\n-\t\t\t   in this case. */\n-\t\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX,\n-\t\t\t\t\t\t       const0_rtx);\n-\t\t      do\n-\t\t\t{\n-\t\t\t  r = gen_rtx_REG (rmode,\n-\t\t\t\t\t   GP_ARG_MIN_REG + align_words);\n-\t\t\t  off = GEN_INT (i++ * GET_MODE_SIZE (rmode));\n-\t\t\t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, off);\n-\t\t\t}\n-\t\t      while (++align_words < GP_ARG_NUM_REG && --n_words != 0);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* The whole arg fits in gprs.  */\n-\t\t      r = gen_rtx_REG (mode, GP_ARG_MIN_REG + align_words);\n-\t\t      rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t/* It's entirely in memory.  */\n-\t\trvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, NULL_RTX, const0_rtx);\n+\t      gcc_assert (fmode == TFmode || fmode == TDmode);\n+\t      fmode = DECIMAL_FLOAT_MODE_P (fmode) ? DDmode : DFmode;\n \t    }\n \n-\t  /* Describe where this piece goes in the fprs.  */\n \t  r = gen_rtx_REG (fmode, cum->fregno);\n \t  rvec[k++] = gen_rtx_EXPR_LIST (VOIDmode, r, const0_rtx);\n \n-\t  return gen_rtx_PARALLEL (mode, gen_rtvec_v (k, rvec));\n+\t  return rs6000_finish_function_arg (mode, rvec, k);\n \t}\n       else if (align_words < GP_ARG_NUM_REG)\n \t{"}]}