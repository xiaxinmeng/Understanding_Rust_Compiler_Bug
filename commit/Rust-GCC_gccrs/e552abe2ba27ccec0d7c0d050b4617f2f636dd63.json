{"sha": "e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU1MmFiZTJiYTI3Y2NlYzBkN2MwZDA1MGI0NjE3ZjJmNjM2ZGQ2Mw==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:27Z"}, "committer": {"name": "Maciej W. Rozycki", "email": "macro@linux-mips.org", "date": "2020-12-05T18:26:27Z"}, "message": "PR target/95294: VAX: Convert backend to MODE_CC representation\n\nIn the VAX ISA INSV bit-field insert instruction is the only computational\noperation that keeps the condition codes, held in the PSL or Processor\nStatus Longword register, intact.  The instruction is flexible enough it\ncould potentially be used for data moves post-reload, but then reportedly\nit is not the best choice performance-wise, and then we have no addition\noperation available that would keep the condition codes unchanged.\n\nFuthermore, as usually with a complex CISC ISA, for many operations we\nhave several machine instructions or instruction sequences to choose\nfrom that set condition codes in a different manner.\n\nUse the approach then where the condition codes only get introduced by\nreload, by definining instruction splitters for RTL insns that change\ncondition codes in some way, by default considering them clobbered.\n\nThen to prevent code generated from regressing too much provide insns\nthat include a `compare' operation setting the condition codes in\nparallel to the main operation.  The manner condition codes are set by\neach insn is supposed to be provided by the whatever the SELECT_CC_MODE\nmacro expands to.\n\nGiven that individual patterns provided for the same RTL basic operation\nmay set the condion codes differently keeping the information away from\nthe insn patterns themselves would cause a maintenance nightmare and\nwould be bound to fail in a horrible way sooner or later.  Therefore\ninstead let the patterns themselves choose which condition modes they\nsupport, by having one or more subst iterators applied and then have\nindividual comparison operators require the specific condition mode each\naccording to the codes used by the operation.\n\nWhile subst iterators only support one alternative each, there is\nactually no problem with applying multiple ones to a single insn with\nthe result as intended, and if the corresponding subst attribute\nsupplies an empty NO-SUBST-VALUE, then no mess results even.  Make use\nof this observation.\n\nAdd appropriate subst iterators to all the computational patterns then,\naccording to the condition codes they usably set, including DImode ones\nand a substitute DImode comparison instruction in the absence of a CMPQ\nmachine instruction, however do not provide a `cbranchdi4' named pattern\nas without a further development it regresses code quality by resorting\nto the `__cmpdi2' libcall where a simpler operation would do, e.g. to\ncheck for negativity the TSTL machine instruction may be executed over\nthe upper longword only.  This is good material for further work.\n\nDo not apply subst iterators to the increment- or decrement-and-branch\npatterns at this time; these may yet have to be reviewed, in particular\nwhether `*jsobneq_minus_one' is still relevant in the context of the\nrecent integer constant cost review.\n\nAlso add a couple of peepholes to help eliminating comparisons in some\nproblematic cases, such as with the BIT instruction which is bitwise-AND\nfor condition codes only that has no direct counterpart for the actual\ncalculation, because the BIC instruction which does do bitwise-AND and\nproduces a result implements the operation with a bitwise negation of\nits input `mask' operand.  Or the FFS instruction which sets the Z\ncondition code according to its `field' input operand rather than the\nresult produced.  Or the bit-field comparisons we don't have generic\nmiddle-end support for.\n\nCode size stats are as follows, obtained from 17640 and 9086 executables\nbuilt in `check-c' and `check-c++' GCC testing respectively:\n\n                      check-c                 check-c++\n              samples average  median  samples average  median\n---------------------------------------------------------------\nregressions      1813  0.578%  0.198%      289  0.349%  0.175%\nunchanged       15160  0.000%  0.000%     8662  0.000%  0.000%\nprogressions      667 -0.589% -0.194%      135 -0.944% -0.191%\n----------------------------------------------------------------\ntotal           17640  0.037%  0.000%     9086 -0.003%  0.000%\n\nOutliers:\n\nold     new     change  %change filename\n----------------------------------------------------\n2406    2950    +544    +22.610 20111208-1.exe\n4314    5329    +1015   +23.528 pr39417.exe\n2235    3055    +820    +36.689 990404-1.exe\n2631    4213    +1582   +60.129 pr57521.exe\n3063    5579    +2516   +82.142 20000422-1.exe\n\nand:\n\nold     new     change  %change filename\n----------------------------------------------------\n6317    4845    -1472   -23.302 vector-compare-1.exe\n6313    4845    -1468   -23.254 vector-compare-1.exe\n6474    5002    -1472   -22.737 vector-compare-1.exe\n6470    5002    -1468   -22.689 vector-compare-1.exe\n\nWe have some code quality regressions like:\n\n    10861:\t9e ef d9 12 \tmovab 11b40 <p>,r0\n    10865:\t00 00 50\n    10868:\t90 a0 03 a0 \tmovb 0x3(r0),0x2(r0)\n    1086c:\t02\n    1086d:\td1 60 8f 61 \tcmpl (r0),$0x64646261\n    10871:\t62 64 64\n    10874:\t13 07       \tbeql 1087d <main_test+0x21>\n\nto:\n\n    10861:\t9e ef e1 12 \tmovab 11b48 <p>,r0\n    10865:\t00 00 50\n    10868:\t90 a0 03 a0 \tmovb 0x3(r0),0x2(r0)\n    1086c:\t02\n    1086d:\td1 ef d5 12 \tcmpl 11b48 <p>,$0x64646261\n    10871:\t00 00 8f 61\n    10875:\t62 64 64\n    10878:\t13 07       \tbeql 10881 <main_test+0x25>\n\n(from `memmove-2.x2') due to the constant propagation passes eagerly\nreplacing pseudo registers with direct symbol references where possible,\nwhich does not happen with CC0 even though the passes do run regardless.\n\nThere are further code quality regressions due to earlier compilation\nstages trying to push expression evaluation earlier where possible so\nas to make data dependencies further apart from each other.  This works\nwell for computations and architectures that do not involve condition\ncodes set as a side effect of calculations.  However for integer\nnegation that makes assembly code produced like:\n\n\tmovb *8(%ap),%r0\n\tmnegb %r0,%r1\n\ttstb %r0\n\tjeql .L2\n\nthe RTL equibvalent of which the comparison elimination pass cannot\nreally do anything about, because the comparison is made on the source\nrather than the target operand of the negation (we could add a peephole\nfor this, but this seems futile an effort, as one'd have to iterate over\nall the possible such cases), even though this is really equivalent to:\n\n\tmovb *8(%ap),%r0\n\tmnegb %r0,%r1\n\tjeql .L2\n\nor, if R0 is dead at the conclusion of the branch, even:\n\n\tmnegb *8(%ap),%r1\n\tjeql .L2\n\nSince the compiler insists on doing the comparison on the source of the\nnegation it obviously has to load it into a temporary so as to avoid\naccessing the original memory location twice, hence the sequence of\nthree instructions rather than just a single one.  A similar phenomenon\ncan be observed with the XOR operation and in other cases.\n\nIn some cases a comparison does get eliminated, however useless moves\ninto registers done in preparation to it remain, such as with:\n\n\tmovb *8(%ap),%r2\n\tmovb *12(%ap),%r1\n\tsubb3 %r1,%r2,%r0\n\tjlssu .L2\n\nwhere R1 and R2 are both dead at conclusion and therefore:\n\n\tsubb3 *12(%ap),*8(%ap),%r0\n\tjlssu .L2\n\nwould obviously do, but there was to be a comparison before the branch:\n\n\tcmpb %r2,%r1\n\nAll this looks like material for future improvement.\n\nTest cases for comparison elimination and the peepholes will be supplied\nseparately.\n\n\tgcc/\n\tPR target/95294\n\t* config/vax/elf.h (REGISTER_NAMES): Append `%psl'.\n\t* config/vax/vax-modes.def (CCN, CCNZ, CCZ): New modes.\n\t* config/vax/vax-protos.h (vax_select_cc_mode): New prototype.\n\t(vax_maybe_split_dimode_move): Likewise.\n\t(vax_notice_update_cc): Remove prototype.\n\t* config/vax/vax.c (TARGET_FLAGS_REGNUM): New macro.\n\t(TARGET_CC_MODES_COMPATIBLE): Likewise.\n\t(TARGET_MD_ASM_ADJUST): Likewise.\n\t(vax_select_cc_mode): New function\n\t(vax_cc_modes_compatible): Likewise.\n\t(vax_md_asm_adjust): Likewise.\n\t(vax_notice_update_cc): Remove function.\n\t(vax_output_int_move): Factor out code checking if a DImode move\n\tmay have to be split...\n\t(vax_maybe_split_dimode_move): ... into this new function.\n\t* config/vax/vax.h (FIRST_PSEUDO_REGISTER): Bump up.\n\t(FIXED_REGISTERS): Append an entry for PSL.\n\t(CALL_USED_REGISTERS): Likewise.\n\t(NOTICE_UPDATE_CC, OUTPUT_JUMP): Remove macros.\n\t(SELECT_CC_MODE): New macro.\n\t(REGISTER_NAMES): Append `psl'.\n\t* config/vax/predicates.md (const_zero_operand)\n\t(vax_cc_comparison_operator, vax_ccn_comparison_operator)\n\t(vax_ccnz_comparison_operator, vax_ccz_comparison_operator):\n\tNew predicates.\n\t* config/vax/builtins.md: Rewrite for MODE_CC representation.\n\t* config/vax/vax.md: Likewise.", "tree": {"sha": "75d38d154a397dc26a1351a02a84f444e5abf9e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75d38d154a397dc26a1351a02a84f444e5abf9e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/comments", "author": null, "committer": null, "parents": [{"sha": "76a553587f3181605c57801c37b0d3e94ce3aca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a553587f3181605c57801c37b0d3e94ce3aca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a553587f3181605c57801c37b0d3e94ce3aca5"}], "stats": {"total": 2169, "additions": 1904, "deletions": 265}, "files": [{"sha": "846d1f352fffa997758c43a45779332550069dbb", "filename": "gcc/config/vax/builtins.md", "status": "modified", "additions": 95, "deletions": 14, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fbuiltins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fbuiltins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fbuiltins.md?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -39,44 +39,125 @@\n {\n   rtx label = gen_label_rtx ();\n   rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, label);\n-  rtx cond = gen_rtx_NE (VOIDmode, cc0_rtx, const0_rtx);\n+  rtx cond = gen_rtx_NE (VOIDmode, operands[1], const0_rtx);\n   rtx target = gen_rtx_IF_THEN_ELSE (VOIDmode, cond, label_ref, pc_rtx);\n \n-  emit_insn (gen_ctz<mode>2 (operands[0], operands[1]));\n+  emit_insn (gen_ctz<mode>2_ccz (operands[0], operands[1]));\n   emit_jump_insn (gen_rtx_SET (pc_rtx, target));\n   emit_insn (gen_neg<mode>2 (operands[0], const1_rtx));\n   emit_label (label);\n   emit_insn (gen_add<mode>3 (operands[0], operands[0], const1_rtx));\n   DONE;\n }\")\n \n-(define_insn \"ctz<mode>2\"\n+(define_insn_and_split \"ctz<mode>2\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rQ\")\n+\t(ctz:SI (match_operand:VAXint 1 \"general_operand\" \"nrQT\")))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ctz:SI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ctz<mode>2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rQ\")\n \t(ctz:SI (match_operand:VAXint 1 \"general_operand\" \"nrQT\")))\n-   (set (cc0)\n-\t(compare (match_dup 1)\n-\t\t (const_int 0)))]\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n+  \"ffs $0,$<width>,%1,%0\")\n+\n+(define_insn_and_split \"ctz<mode>2_ccz\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rQ\")\n+\t(ctz:SI (match_operand:VAXint 1 \"general_operand\" \"nrQT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (reg:CCZ VAX_PSL_REGNUM)\n+\t   (compare:CCZ (match_dup 1)\n+\t\t\t(const_int 0)))\n+      (set (match_dup 0)\n+\t   (ctz:SI (match_dup 1)))])]\n+  \"\")\n+\n+(define_insn \"*ctz<mode>2_ccz\"\n+  [(set (reg:CCZ VAX_PSL_REGNUM)\n+\t(compare:CCZ (match_operand:VAXint 1 \"general_operand\" \"nrQT\")\n+\t\t     (const_int 0)))\n+   (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rQ\")\n+\t(ctz:SI (match_dup 1)))]\n+  \"reload_completed\"\n   \"ffs $0,$<width>,%1,%0\")\n \n ;; Our FFS hardware instruction supports any field width,\n ;; so handle narrower inputs directly as well.\n (define_peephole2\n-  [(set (match_operand:SI 0 \"register_operand\")\n-        (any_extend:SI (match_operand:VAXintQH 1 \"general_operand\")))\n+  [(parallel\n+     [(set (match_operand:SI 0 \"register_operand\")\n+\t   (any_extend:SI (match_operand:VAXintQH 1 \"general_operand\")))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])\n    (parallel\n      [(set (match_operand:SI 2 \"nonimmediate_operand\")\n \t   (ctz:SI (match_dup 0)))\n-      (set (cc0)\n-\t   (compare (match_dup 2)\n-\t\t    (const_int 0)))])]\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n   \"rtx_equal_p (operands[0], operands[2]) || peep2_reg_dead_p (2, operands[0])\"\n   [(parallel\n      [(set (match_dup 2)\n \t   (ctz:SI (match_dup 1)))\n-      (set (cc0)\n-\t   (compare (match_dup 1)\n-\t\t    (const_int 0)))])]\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+;; The FFS hardware instruction sets the Z condition code based on\n+;; the input field rather than the output operand, so the compare\n+;; elimination pass cannot handle it.  Try to get rid of the extra\n+;; operation by hand.\n+;;\n+;; The \"ctz<mode>2_ccz\" patterns require their `operands[1]' not to\n+;; have a mode dependent address, so all we need to verify is that\n+;; the two operands are not the same, in which case it's the FFS\n+;; output rather than input that condition codes are checked for.\n+(define_peephole2\n+  [(parallel\n+     [(set (match_operand:SI 0 \"nonimmediate_operand\")\n+\t   (ctz:SI (match_operand:VAXint 1 \"general_operand\")))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])\n+   (set (reg:CCZ VAX_PSL_REGNUM)\n+\t(compare:CCZ (match_dup 1)\n+\t\t     (const_int 0)))]\n+  \"!rtx_equal_p (operands[0], operands[1])\"\n+  [(parallel\n+     [(set (reg:CCZ VAX_PSL_REGNUM)\n+\t   (compare:CCZ (match_dup 1)\n+\t\t\t(const_int 0)))\n+      (set (match_dup 0)\n+\t   (ctz:SI (match_dup 1)))])]\n+  \"\")\n+\n+;; This effectively combines the two peepholes above,\n+;; matching the sequence produced by `ffs<mode>2'.\n+(define_peephole2\n+  [(parallel\n+     [(set (match_operand:SI 0 \"register_operand\")\n+\t   (any_extend:SI (match_operand:VAXintQH 1 \"general_operand\")))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])\n+   (parallel\n+     [(set (match_operand:SI 2 \"nonimmediate_operand\")\n+\t   (ctz:SI (match_dup 0)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])\n+   (set (reg:CCZ VAX_PSL_REGNUM)\n+\t(compare:CCZ (match_dup 0)\n+\t\t     (const_int 0)))]\n+  \"!rtx_equal_p (operands[0], operands[2])\n+   && peep2_reg_dead_p (3, operands[0])\"\n+  [(parallel\n+     [(set (reg:CCZ VAX_PSL_REGNUM)\n+\t   (compare:CCZ (match_dup 1)\n+\t\t\t(const_int 0)))\n+      (set (match_dup 2)\n+\t   (ctz:SI (match_dup 1)))])]\n   \"\")\n \n (define_expand \"sync_lock_test_and_set<mode>\""}, {"sha": "f6485eca3f474933057226dd60d5bfc2bb51d858", "filename": "gcc/config/vax/elf.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Felf.h?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -26,7 +26,8 @@ along with GCC; see the file COPYING3.  If not see\n #define REGISTER_PREFIX \"%\"\n #define REGISTER_NAMES \\\n   { \"%r0\", \"%r1\",  \"%r2\",  \"%r3\", \"%r4\", \"%r5\", \"%r6\", \"%r7\", \\\n-    \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%ap\", \"%fp\", \"%sp\", \"%pc\", }\n+    \"%r8\", \"%r9\", \"%r10\", \"%r11\", \"%ap\", \"%fp\", \"%sp\", \"%pc\", \\\n+    \"%psl\" }\n \n #undef SIZE_TYPE\n #define SIZE_TYPE \"long unsigned int\""}, {"sha": "92caf8384fab1c461350a8ea04603288f1cc8ca9", "filename": "gcc/config/vax/predicates.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fpredicates.md?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -17,6 +17,10 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; Return true if OP is a constant zero operand.\n+(define_predicate \"const_zero_operand\"\n+  (match_test \"op == CONST0_RTX (mode)\"))\n+\n ;; Special case of a symbolic operand that's used as a\n ;; operand.\n \n@@ -109,3 +113,19 @@\n (define_predicate \"any_memory_operand\"\n   (ior (match_operand 0 \"memory_operand\")\n        (match_operand 0 \"volatile_mem_operand\")))\n+\n+;; Return true if OP is a comparison operator that requires at least CCmode.\n+(define_predicate \"vax_cc_comparison_operator\"\n+  (match_code \"geu,gtu,leu,ltu\"))\n+\n+;; Return true if OP is a comparison operator that requires at least CCNmode.\n+(define_predicate \"vax_ccn_comparison_operator\"\n+  (match_code \"ge,lt\"))\n+\n+;; Return true if OP is a comparison operator that requires at least CCNZmode.\n+(define_predicate \"vax_ccnz_comparison_operator\"\n+  (match_code \"gt,le\"))\n+\n+;; Return true if OP is a comparison operator that requires at least CCZmode.\n+(define_predicate \"vax_ccz_comparison_operator\"\n+  (match_code \"ne,eq\"))"}, {"sha": "2a7438ee77fcca3eed3f30931102de084b4d8dbf", "filename": "gcc/config/vax/vax-modes.def", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-modes.def?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -20,3 +20,14 @@ along with GCC; see the file COPYING3.  If not see\n /* We just need to reset the floating point formats.  */\n RESET_FLOAT_FORMAT (SF, vax_f_format);\n RESET_FLOAT_FORMAT (DF, vax_d_format);\n+\n+/* `DImode' addition and subtraction operations do their calculation\n+   on the low and then the high longword with separate instructions,\n+   and therefore only usably set N.  */\n+CC_MODE (CCN);\n+/* Non-arithmetic integer instructions such as MOV or XOR as well as\n+   instructions that produce a floating-point result only usably set\n+   N and Z.  */\n+CC_MODE (CCNZ);\n+/* The FFC and FFS instructions only usably set Z.  */\n+CC_MODE (CCZ);"}, {"sha": "aa949c598d782288ba06c84ae11e05f437ed3168", "filename": "gcc/config/vax/vax-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax-protos.h?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -22,13 +22,14 @@ extern void vax_expand_prologue (void);\n \n #ifdef RTX_CODE\n extern bool vax_acceptable_pic_operand_p (rtx, bool, bool);\n+extern machine_mode vax_select_cc_mode (enum rtx_code, rtx, rtx);\n extern const char *cond_name (rtx);\n extern bool adjacent_operands_p (rtx, rtx, machine_mode);\n extern const char *rev_cond_name (rtx);\n extern void print_operand_address (FILE *, rtx);\n extern void print_operand (FILE *, rtx, int);\n-extern void vax_notice_update_cc (rtx, rtx);\n extern void vax_expand_addsub_di_operands (rtx *, enum rtx_code);\n+extern bool vax_maybe_split_dimode_move (rtx *);\n extern const char * vax_output_int_move (rtx, rtx *, machine_mode);\n extern const char * vax_output_int_add (rtx_insn *, rtx *, machine_mode);\n extern const char * vax_output_int_subtract (rtx_insn *, rtx *, machine_mode);"}, {"sha": "54d83dc1da2e9a67242b0f0b3454390fcfb88b6d", "filename": "gcc/config/vax/vax.c", "status": "modified", "additions": 124, "deletions": 79, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.c?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -54,6 +54,10 @@ static void vax_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n static int vax_address_cost_1 (rtx);\n static int vax_address_cost (rtx, machine_mode, addr_space_t, bool);\n static bool vax_rtx_costs (rtx, machine_mode, int, int, int *, bool);\n+static machine_mode vax_cc_modes_compatible (machine_mode, machine_mode);\n+static rtx_insn *vax_md_asm_adjust (vec<rtx> &, vec<rtx> &,\n+\t\t\t\t    vec<const char *> &,\n+\t\t\t\t    vec<rtx> &, HARD_REG_SET &);\n static rtx vax_function_arg (cumulative_args_t, const function_arg_info &);\n static void vax_function_arg_advance (cumulative_args_t,\n \t\t\t\t      const function_arg_info &);\n@@ -81,11 +85,23 @@ static HOST_WIDE_INT vax_starting_frame_offset (void);\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n #define TARGET_ASM_CAN_OUTPUT_MI_THUNK default_can_output_mi_thunk_no_vcall\n \n+/* Enable compare elimination pass.  */\n+#undef TARGET_FLAGS_REGNUM\n+#define TARGET_FLAGS_REGNUM VAX_PSL_REGNUM\n+\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS vax_rtx_costs\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST vax_address_cost\n \n+/* Return the narrowest CC mode that spans both modes offered.  */\n+#undef TARGET_CC_MODES_COMPATIBLE\n+#define TARGET_CC_MODES_COMPATIBLE vax_cc_modes_compatible\n+\n+/* Mark PSL as clobbered for compatibility with the CC0 representation.  */\n+#undef TARGET_MD_ASM_ADJUST\n+#define TARGET_MD_ASM_ADJUST vax_md_asm_adjust\n+\n #undef TARGET_PROMOTE_PROTOTYPES\n #define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n \n@@ -1070,6 +1086,102 @@ vax_acceptable_pic_operand_p (rtx x ATTRIBUTE_UNUSED,\n   return true;\n }\n \f\n+/* Given a comparison code (NE, EQ, etc.) and the operands of a COMPARE,\n+   return the mode to be used for the comparison.  As we have the same\n+   interpretation of condition codes across all the instructions we just\n+   return the narrowest mode suitable for the comparison code requested.  */\n+\n+extern machine_mode\n+vax_select_cc_mode (enum rtx_code op,\n+\t\t    rtx x ATTRIBUTE_UNUSED, rtx y ATTRIBUTE_UNUSED)\n+{\n+  switch (op)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case NE:\n+    case EQ:\n+      return CCZmode;\n+    case GE:\n+    case LT:\n+      return CCNmode;\n+    case GT:\n+    case LE:\n+      return CCNZmode;\n+    case GEU:\n+    case GTU:\n+    case LEU:\n+    case LTU:\n+      return CCmode;\n+    }\n+}\n+\n+/* Return the narrowest CC mode that spans both modes offered.  If they\n+   intersect, this will be the wider of the two, and if they do not then\n+   find find one that is a superset of both (i.e. CCNZmode for a pair\n+   consisting of CCNmode and CCZmode).  A wider CC writer will satisfy\n+   a narrower CC reader, e.g. a comparison operator that uses CCZmode\n+   can use a CCNZmode output of a previous instruction.  */\n+\n+static machine_mode\n+vax_cc_modes_compatible (machine_mode m1, machine_mode m2)\n+{\n+  switch (m1)\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case E_CCmode:\n+      switch (m2)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase E_CCmode:\n+\tcase E_CCNZmode:\n+\tcase E_CCNmode:\n+\tcase E_CCZmode:\n+\t  return m1;\n+\t}\n+    case E_CCNZmode:\n+      switch (m2)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase E_CCmode:\n+\t  return m2;\n+\tcase E_CCNmode:\n+\tcase E_CCNZmode:\n+\tcase E_CCZmode:\n+\t  return m1;\n+\t}\n+    case E_CCNmode:\n+    case E_CCZmode:\n+      switch (m2)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase E_CCmode:\n+\tcase E_CCNZmode:\n+\t  return m2;\n+\tcase E_CCNmode:\n+\tcase E_CCZmode:\n+\t  return m1 == m2 ? m1 : E_CCNZmode;\n+\t}\n+    }\n+}\n+\f\n+/* Mark PSL as clobbered for compatibility with the CC0 representation.  */\n+\n+static rtx_insn *\n+vax_md_asm_adjust (vec<rtx> &outputs ATTRIBUTE_UNUSED,\n+\t\t   vec<rtx> &inputs ATTRIBUTE_UNUSED,\n+\t\t   vec<const char *> &constraints ATTRIBUTE_UNUSED,\n+\t\t   vec<rtx> &clobbers, HARD_REG_SET &clobbered_regs)\n+{\n+  clobbers.safe_push (gen_rtx_REG (CCmode, VAX_PSL_REGNUM));\n+  SET_HARD_REG_BIT (clobbered_regs, VAX_PSL_REGNUM);\n+  return NULL;\n+}\n+\f\n /* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n    Used for C++ multiple inheritance.\n \t.mask\t^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>  #conservative entry mask\n@@ -1102,81 +1214,21 @@ vax_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n   return gen_rtx_REG (Pmode, VAX_STRUCT_VALUE_REGNUM);\n }\n \n-/* Worker function for NOTICE_UPDATE_CC.  */\n+/* Output integer move instructions.  */\n \n-void\n-vax_notice_update_cc (rtx exp, rtx insn ATTRIBUTE_UNUSED)\n+bool\n+vax_maybe_split_dimode_move (rtx *operands)\n {\n-  if (GET_CODE (exp) == SET)\n-    {\n-      if (GET_CODE (SET_SRC (exp)) == CALL)\n-\tCC_STATUS_INIT;\n-      else if (GET_CODE (SET_DEST (exp)) != ZERO_EXTRACT\n-\t       && GET_CODE (SET_DEST (exp)) != PC)\n-\t{\n-\t  cc_status.flags = 0;\n-\t  /* The integer operations below don't set carry or\n-\t     set it in an incompatible way.  That's ok though\n-\t     as the Z bit is all we need when doing unsigned\n-\t     comparisons on the result of these insns (since\n-\t     they're always with 0).  Set CC_NO_OVERFLOW to\n-\t     generate the correct unsigned branches.  */\n-\t  switch (GET_CODE (SET_SRC (exp)))\n-\t    {\n-\t    case NEG:\n-\t      if (GET_MODE_CLASS (GET_MODE (exp)) == MODE_FLOAT)\n-\t\tbreak;\n-\t      /* FALLTHRU */\n-\t    case AND:\n-\t    case IOR:\n-\t    case XOR:\n-\t    case NOT:\n-\t    case MEM:\n-\t    case REG:\n-\t      cc_status.flags = CC_NO_OVERFLOW;\n-\t      break;\n-\t    case CTZ:\n-\t      cc_status.flags = CC_NOT_NEGATIVE;\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t  cc_status.value1 = SET_DEST (exp);\n-\t  cc_status.value2 = SET_SRC (exp);\n-\t}\n-    }\n-  else if (GET_CODE (exp) == PARALLEL\n-\t   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)\n-    {\n-      if (GET_CODE (SET_SRC (XVECEXP (exp, 0, 0))) == CALL)\n-\tCC_STATUS_INIT;\n-      else if (GET_CODE (SET_DEST (XVECEXP (exp, 0, 0))) != PC)\n-\t{\n-\t  cc_status.flags = 0;\n-\t  cc_status.value1 = SET_DEST (XVECEXP (exp, 0, 0));\n-\t  cc_status.value2 = SET_SRC (XVECEXP (exp, 0, 0));\n-\t}\n-      else\n-\t/* PARALLELs whose first element sets the PC are aob,\n-\t   sob insns.  They do change the cc's.  */\n-\tCC_STATUS_INIT;\n-    }\n-  else\n-    CC_STATUS_INIT;\n-  if (cc_status.value1 && REG_P (cc_status.value1)\n-      && cc_status.value2\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\n-    cc_status.value2 = 0;\n-  if (cc_status.value1 && MEM_P (cc_status.value1)\n-      && cc_status.value2\n-      && MEM_P (cc_status.value2))\n-    cc_status.value2 = 0;\n-  /* Actual condition, one line up, should be that value2's address\n-     depends on value1, but that is too much of a pain.  */\n+  return (TARGET_QMATH\n+\t  && (!MEM_P (operands[0])\n+\t      || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n+\t      || GET_CODE (XEXP (operands[0], 0)) == POST_INC\n+\t      || !illegal_addsub_di_memory_operand (operands[0], DImode))\n+\t  && ((CONST_INT_P (operands[1])\n+\t       && (unsigned HOST_WIDE_INT) INTVAL (operands[1]) >= 64)\n+\t      || GET_CODE (operands[1]) == CONST_DOUBLE));\n }\n \n-/* Output integer move instructions.  */\n-\n const char *\n vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t\t     machine_mode mode)\n@@ -1252,14 +1304,7 @@ vax_output_int_move (rtx insn ATTRIBUTE_UNUSED, rtx *operands,\n \t    }\n \t}\n \n-      if (TARGET_QMATH\n-\t  && (!MEM_P (operands[0])\n-\t      || GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n-\t      || GET_CODE (XEXP (operands[0], 0)) == POST_INC\n-\t      || !illegal_addsub_di_memory_operand (operands[0], DImode))\n-\t  && ((CONST_INT_P (operands[1])\n-\t       && (unsigned HOST_WIDE_INT) INTVAL (operands[1]) >= 64)\n-\t      || GET_CODE (operands[1]) == CONST_DOUBLE))\n+      if (vax_maybe_split_dimode_move (operands))\n \t{\n \t  hi[0] = operands[0];\n \t  hi[1] = operands[1];"}, {"sha": "8b2b2d177040550bc0e1c662c09895719c849f73", "filename": "gcc/config/vax/vax.h", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.h?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -120,20 +120,20 @@ along with GCC; see the file COPYING3.  If not see\n    from 0 to just below FIRST_PSEUDO_REGISTER.\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER 16\n+#define FIRST_PSEUDO_REGISTER 17\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the VAX, these are the AP, FP, SP and PC.  */\n-#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n    registers that can be used without being saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n    Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1}\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -465,24 +465,11 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define BRANCH_COST(speed_p, predictable_p) 0\n \f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the VAX.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN)\t\\\n-  vax_notice_update_cc ((EXP), (INSN))\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)\t\\\n-  { if (cc_status.flags & CC_NO_OVERFLOW)\t\\\n-      return NO_OV;\t\t\t\t\\\n-    return NORMAL;\t\t\t\t\\\n-  }\n+/* Given a comparison code (NE, EQ, etc.) and the operands of a COMPARE,\n+   return the mode to be used for the comparison.  As we have the same\n+   interpretation of condition codes across all the instructions we just\n+   return the narrowest mode suitable for the comparison code requested.  */\n+#define SELECT_CC_MODE(OP, X, Y) vax_select_cc_mode (OP, X, Y)\n \f\n /* Control the assembler format that we output.  */\n \n@@ -517,7 +504,8 @@ enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define REGISTER_PREFIX \"\"\n #define REGISTER_NAMES\t\t\t\t\t\\\n   { \"r0\", \"r1\",  \"r2\",  \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n-    \"r8\", \"r9\", \"r10\", \"r11\", \"ap\", \"fp\", \"sp\", \"pc\", }\n+    \"r8\", \"r9\", \"r10\", \"r11\", \"ap\", \"fp\", \"sp\", \"pc\",\t\\\n+    \"psl\" }\n \n /* This is BSD, so it wants DBX format.  */\n "}, {"sha": "b8cf4eed4bc9fb28d2ce5ca766c7d6081456b841", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 1640, "deletions": 148, "changes": 1788, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e552abe2ba27ccec0d7c0d050b4617f2f636dd63/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=e552abe2ba27ccec0d7c0d050b4617f2f636dd63", "patch": "@@ -22,9 +22,6 @@\n ;;- the first one in the file is chosen.\n ;;-\n ;;- See file \"rtl.def\" for documentation on define_insn, match_*, et al.\n-;;-\n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n \n ;; UNSPEC_VOLATILE usage:\n \n@@ -40,6 +37,8 @@\n    (VAX_FP_REGNUM 13)\t    ; Register 13 contains the frame pointer\n    (VAX_SP_REGNUM 14)\t    ; Register 14 contains the stack pointer\n    (VAX_PC_REGNUM 15)\t    ; Register 15 contains the program counter\n+   (VAX_PSL_REGNUM 16)\t    ; Register 16 contains the processor status\n+\t\t\t    ; and condition codes in particular\n   ]\n )\n \n@@ -57,34 +56,96 @@\n ;; Some output patterns want integer immediates with a prefix...\n (define_mode_attr  iprefx [(QI \"B\") (HI \"H\") (SI \"N\")])\n \n+(define_mode_iterator VAXcc [CC CCN CCNZ CCZ])\n+(define_mode_iterator VAXccnz [CCN CCNZ CCZ])\n+(define_mode_attr cc [(CC \"cc\") (CCN \"ccn\") (CCNZ \"ccnz\") (CCZ \"ccz\")])\n+\n+(define_code_iterator any_extract [sign_extract zero_extract])\n+\n ;;\n (include \"constraints.md\")\n (include \"predicates.md\")\n \n-(define_insn \"*cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:VAXint 0 \"nonimmediate_operand\" \"nrmT,nrmT\")\n-\t\t (match_operand:VAXint 1 \"general_operand\" \"I,nrmT\")))]\n+;; Make instructions that set the N, N+Z, and Z condition codes respectively.\n+(define_subst \"subst_<cc>\"\n+  [(set (match_operand 0 \"\")\n+\t(match_operand 1 \"\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n   \"\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz (match_dup 1)\n+\t\t\t (const_int 0)))\n+   (set (match_dup 0)\n+\t(match_dup 1))])\n+\n+(define_subst \"subst_f<cc>\"\n+  [(set (match_operand 0 \"\")\n+\t(match_operand 1 \"\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz (match_dup 1)\n+\t\t\t (const_double_zero)))\n+   (set (match_dup 0)\n+\t(match_dup 1))])\n+\n+;; Select all from the attributes below that apply to a given insn that\n+;; has a clobber on CC for the comparison elimination pass to use it in\n+;; place of a subsequent comparison instruction matching the mode used\n+;; by a comparison operator in branch.\n+;;\n+;; For example a branch doing `eq' in SImode will use `*cmpsi_ccz', so\n+;; to eliminate it a `*movsi_ccz', etc. pattern will be required via the\n+;; `ccz' substitution.  Analogously for the other CC modes.\n+;;\n+;; The general `cc' mode, which sets all of the C, N, V and Z condition\n+;; codes, has to be handled specially as it makes no sense for the usual\n+;; comparison against zero, so no substitution has been defined for it.\n+(define_subst_attr \"ccn\" \"subst_ccn\" \"\" \"_ccn\")\n+(define_subst_attr \"ccnz\" \"subst_ccnz\" \"\" \"_ccnz\")\n+(define_subst_attr \"ccz\" \"subst_ccz\" \"\" \"_ccz\")\n+(define_subst_attr \"fccn\" \"subst_fccn\" \"\" \"_ccn\")\n+(define_subst_attr \"fccnz\" \"subst_fccnz\" \"\" \"_ccnz\")\n+(define_subst_attr \"fccz\" \"subst_fccz\" \"\" \"_ccz\")\n+\n+(define_insn \"*cmp<VAXint:mode>_<VAXcc:mode>\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc (match_operand:VAXint 0 \"general_operand\" \"nrmT,nrmT\")\n+\t\t       (match_operand:VAXint 1 \"general_operand\" \"I,nrmT\")))]\n+  \"reload_completed\"\n   \"@\n    tst<VAXint:isfx> %0\n    cmp<VAXint:isfx> %0,%1\")\n \n-(define_insn \"*cmp<mode>\"\n-  [(set (cc0)\n-\t(compare (match_operand:VAXfp 0 \"general_operand\" \"gF,gF\")\n-\t\t (match_operand:VAXfp 1 \"general_operand\" \"G,gF\")))]\n-  \"\"\n+;; We don't have a CMPQ instruction, but we can set the N and Z condition\n+;; codes with MOVQ, and also this comparison can be folded into a preceding\n+;; operation by the post-reload comparison elimination pass.\n+(define_insn \"*cmpdi_<VAXccnz:mode>\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz (match_operand:DI 0 \"general_operand\" \"r,nmT\")\n+\t\t\t (match_operand:DI 1 \"const_zero_operand\" \"I,I\")))\n+   (clobber (match_scratch:DI 2 \"=X,r\"))]\n+  \"reload_completed\"\n+  \"@\n+   movq %0,%0\n+   movq %0,%2\")\n+\n+(define_insn \"*cmp<VAXfp:mode>_<VAXccnz:mode>\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz (match_operand:VAXfp 0 \"general_operand\" \"gF,gF\")\n+\t\t\t (match_operand:VAXfp 1 \"general_operand\" \"G,gF\")))]\n+  \"reload_completed\"\n   \"@\n    tst<VAXfp:fsfx> %0\n    cmp<VAXfp:fsfx> %0,%1\")\n \n-(define_insn \"*bit<mode>\"\n-  [(set (cc0)\n-\t(compare (and:VAXint (match_operand:VAXint 0 \"general_operand\" \"nrmT\")\n-\t\t\t     (match_operand:VAXint 1 \"general_operand\" \"nrmT\"))\n-\t\t (const_int 0)))]\n-  \"\"\n+(define_insn \"*bit<VAXint:mode>_<VAXccnz:mode>\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz\n+\t  (and:VAXint (match_operand:VAXint 0 \"general_operand\" \"nrmT\")\n+\t\t      (match_operand:VAXint 1 \"general_operand\" \"nrmT\"))\n+\t  (const_int 0)))]\n+  \"reload_completed\"\n   \"bit<VAXint:isfx> %0,%1\")\n \n ;; The VAX has no sCOND insns.  It does have add/subtract with carry\n@@ -95,25 +156,76 @@\n ;; and has been deleted.\n \n \f\n-(define_insn \"mov<mode>\"\n+(define_insn_and_split \"mov<mode>\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n \t(match_operand:VAXfp 1 \"general_operand\" \"G,gF\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*mov<mode><fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(match_operand:VAXfp 1 \"general_operand\" \"G,gF\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    clr<VAXfp:fsfx> %0\n    mov<VAXfp:fsfx> %1,%0\")\n \n ;; Some VAXen don't support this instruction.\n-;;(define_insn \"movti\"\n+;;(define_insn_and_split \"movti\"\n ;;  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=g\")\n ;;\t(match_operand:TI 1 \"general_operand\" \"g\"))]\n ;;  \"\"\n+;;  \"#\"\n+;;  \"reload_completed\"\n+;;  [(parallel\n+;;     [(set (match_dup 0)\n+;;\t   (match_dup 1))\n+;;      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+;;  \"\")\n+;;\n+;;(define_insn \"*movti<ccn><ccnz><ccz>\"\n+;;  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=g\")\n+;;\t(match_operand:TI 1 \"general_operand\" \"g\"))\n+;;   (clobber (reg:CC VAX_PSL_REGNUM))]\n+;;  \"reload_completed\"\n ;;  \"movo %1,%0\")\n \n-(define_insn \"movdi\"\n+(define_insn_and_split \"movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(match_operand:DI 1 \"general_operand\" \"g\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+;; In some cases `vax_output_int_move' splits a `DImode' move into a pair\n+;; of `SImode' moves, in which case the flags aren't usefully set.  Have\n+;; separate patterns then, for the cases where the move may and may not be\n+;; split each.  We use the outer condition only so in some cases we will\n+;; fail to notice the move does not actually get split, but this is OK.\n+(define_insn \"*movdi_maybe_split\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:DI 1 \"general_operand\" \"g\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed && vax_maybe_split_dimode_move (operands)\"\n+  \"* return vax_output_int_move (insn, operands, DImode);\")\n+\n+(define_insn \"*movdi_unsplit<ccn><ccnz><ccz>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:DI 1 \"general_operand\" \"g\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed && !vax_maybe_split_dimode_move (operands)\"\n   \"* return vax_output_int_move (insn, operands, DImode);\")\n \n ;; The VAX move instructions have space-time tradeoffs.  On a MicroVAX\n@@ -155,22 +267,61 @@\n #endif\n }\")\n \n-(define_insn \"movsi_2\"\n+(define_insn_and_split \"movsi_2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(match_operand:SI 1 \"nonsymbolic_operand\" \"nrmT\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movsi_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:SI 1 \"nonsymbolic_operand\" \"nrmT\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"* return vax_output_int_move (insn, operands, SImode);\")\n \n-(define_insn \"mov<mode>\"\n+(define_insn_and_split \"mov<mode>\"\n   [(set (match_operand:VAXintQH 0 \"nonimmediate_operand\" \"=g\")\n \t(match_operand:VAXintQH 1 \"general_operand\" \"g\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*mov<mode><ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXintQH 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:VAXintQH 1 \"general_operand\" \"g\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"* return vax_output_int_move (insn, operands, <MODE>mode);\")\n \n-(define_insn \"movstricthi\"\n-  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+g\"))\n+(define_insn_and_split \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r\"))\n \t(match_operand:HI 1 \"general_operand\" \"g\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movstricthi<ccn><ccnz><ccz>\"\n+  [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+r\"))\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (CONST_INT_P (operands[1]))\n@@ -188,10 +339,23 @@\n   return \\\"movw %1,%0\\\";\n }\")\n \n-(define_insn \"movstrictqi\"\n-  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+g\"))\n+(define_insn_and_split \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+r\"))\n \t(match_operand:QI 1 \"general_operand\" \"g\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (strict_low_part (match_dup 0))\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movstrictqi<ccn><ccnz><ccz>\"\n+  [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+r\"))\n+\t(match_operand:QI 1 \"general_operand\" \"g\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (CONST_INT_P (operands[1]))\n@@ -236,7 +400,7 @@\n ;; that anything generated as this insn will be recognized as one\n ;; and that it won't successfully combine with anything.\n \n-(define_insn \"movmemhi1\"\n+(define_insn_and_split \"movmemhi1\"\n   [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\n \t(match_operand:BLK 1 \"memory_operand\" \"o\"))\n    (use (match_operand:HI 2 \"general_operand\" \"g\"))\n@@ -247,90 +411,286 @@\n    (clobber (reg:SI 4))\n    (clobber (reg:SI 5))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (use (match_dup 2))\n+      (clobber (reg:SI 0))\n+      (clobber (reg:SI 1))\n+      (clobber (reg:SI 2))\n+      (clobber (reg:SI 3))\n+      (clobber (reg:SI 4))\n+      (clobber (reg:SI 5))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movmemhi1\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=o\")\n+\t(match_operand:BLK 1 \"memory_operand\" \"o\"))\n+   (use (match_operand:HI 2 \"general_operand\" \"g\"))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 5))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"movc3 %2,%1,%0\")\n \f\n ;; Extension and truncation insns.\n \n-(define_insn \"truncsiqi2\"\n+(define_insn_and_split \"truncsiqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n \t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (truncate:QI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*truncsiqi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n+\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtlb %1,%0\")\n \n-(define_insn \"truncsihi2\"\n+(define_insn_and_split \"truncsihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n \t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (truncate:HI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*truncsihi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n+\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"nrmT\")))\n+      (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtlw %1,%0\")\n \n-(define_insn \"trunchiqi2\"\n+(define_insn_and_split \"trunchiqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n \t(truncate:QI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (truncate:QI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*trunchiqi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=g\")\n+\t(truncate:QI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtwb %1,%0\")\n \n-(define_insn \"extendhisi2\"\n+(define_insn_and_split \"extendhisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (sign_extend:SI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extendhisi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtwl %1,%0\")\n \n-(define_insn \"extendqihi2\"\n+(define_insn_and_split \"extendqihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (sign_extend:HI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extendqihi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n+\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtbw %1,%0\")\n \n-(define_insn \"extendqisi2\"\n+(define_insn_and_split \"extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (sign_extend:SI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extendqisi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtbl %1,%0\")\n \n-(define_insn \"extendsfdf2\"\n+(define_insn_and_split \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g\")\n \t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (float_extend:DF (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extendsfdf2<fccn><fccnz><fccz>\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=g\")\n+\t(float_extend:DF (match_operand:SF 1 \"general_operand\" \"gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvtf%# %1,%0\")\n \n-(define_insn \"truncdfsf2\"\n+(define_insn_and_split \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g\")\n \t(float_truncate:SF (match_operand:DF 1 \"general_operand\" \"gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (float_truncate:SF (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*truncdfsf2<fccn><fccnz><fccz>\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=g\")\n+\t(float_truncate:SF (match_operand:DF 1 \"general_operand\" \"gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvt%#f %1,%0\")\n \n-(define_insn \"zero_extendhisi2\"\n+(define_insn_and_split \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (zero_extend:SI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*zero_extendhisi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"movzwl %1,%0\")\n \n-(define_insn \"zero_extendqihi2\"\n+(define_insn_and_split \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (zero_extend:HI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*zero_extendqihi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n+\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"movzbw %1,%0\")\n \n-(define_insn \"zero_extendqisi2\"\n+(define_insn_and_split \"zero_extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (zero_extend:SI (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*zero_extendqisi2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"movzbl %1,%0\")\n \f\n ;; Fix-to-float conversion insns.\n \n-(define_insn \"float<VAXint:mode><VAXfp:mode>2\"\n+(define_insn_and_split \"float<VAXint:mode><VAXfp:mode>2\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g\")\n \t(float:VAXfp (match_operand:VAXint 1 \"nonimmediate_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (float:VAXfp (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*float<VAXint:mode><VAXfp:mode>2<fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g\")\n+\t(float:VAXfp (match_operand:VAXint 1 \"nonimmediate_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvt<VAXint:isfx><VAXfp:fsfx> %1,%0\")\n \n ;; Float-to-fix conversion insns.\n \n-(define_insn \"fix_trunc<VAXfp:mode><VAXint:mode>2\"\n+(define_insn_and_split \"fix_trunc<VAXfp:mode><VAXint:mode>2\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n \t(fix:VAXint (match_operand:VAXfp 1 \"general_operand\" \"gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (fix:VAXint (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*fix_trunc<VAXfp:mode><VAXint:mode>2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(fix:VAXint (match_operand:VAXfp 1 \"general_operand\" \"gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"cvt<VAXfp:fsfx><VAXint:isfx> %1,%0\")\n \n (define_expand \"fixuns_trunc<VAXfp:mode><VAXint:mode>2\"\n@@ -340,21 +700,51 @@\n \f\n ;;- All kinds of add instructions.\n \n-(define_insn \"add<mode>3\"\n+(define_insn_and_split \"add<mode>3\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(plus:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF,gF\")\n \t\t    (match_operand:VAXfp 2 \"general_operand\" \"gF,0,gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:VAXfp (match_dup 1)\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*add<mode>3<fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(plus:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF,gF\")\n+\t\t    (match_operand:VAXfp 2 \"general_operand\" \"gF,0,gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    add<VAXfp:fsfx>2 %2,%0\n    add<VAXfp:fsfx>2 %1,%0\n    add<VAXfp:fsfx>3 %1,%2,%0\")\n \n-(define_insn \"add<mode>3\"\n+(define_insn_and_split \"add<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n \t(plus:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")\n \t\t     (match_operand:VAXint 2 \"general_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:VAXint (match_dup 1)\n+\t\t\t(match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*add<mode>3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")\n+\t\t     (match_operand:VAXint 2 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"* return vax_output_int_add (insn, operands, <MODE>mode);\")\n \n (define_expand \"adddi3\"\n@@ -364,37 +754,109 @@\n   \"!reload_in_progress\"\n   \"vax_expand_addsub_di_operands (operands, PLUS); DONE;\")\n \n-(define_insn \"adcdi3\"\n+(define_insn_and_split \"adcdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_addsub_di_operand\" \"=Rr\")\n \t(plus:DI (match_operand:DI 1 \"general_addsub_di_operand\" \"%0\")\n \t\t (match_operand:DI 2 \"general_addsub_di_operand\" \"nRr\")))]\n   \"TARGET_QMATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:DI (match_dup 1)\n+\t\t    (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*adcdi3<ccn>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_addsub_di_operand\" \"=Rr\")\n+\t(plus:DI (match_operand:DI 1 \"general_addsub_di_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"general_addsub_di_operand\" \"nRr\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"TARGET_QMATH && reload_completed\"\n   \"* return vax_output_int_add (insn, operands, DImode);\")\n \n ;; The add-with-carry (adwc) instruction only accepts two operands.\n-(define_insn \"adddi3_old\"\n+(define_insn_and_split \"adddi3_old\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro>,ro>\")\n \t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,ro>\")\n \t\t (match_operand:DI 2 \"general_operand\" \"Fsro,Fs\")))]\n   \"!TARGET_QMATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:DI (match_dup 1)\n+\t\t    (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*adddi3_old<ccn>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro>,ro>\")\n+\t(plus:DI (match_operand:DI 1 \"general_operand\" \"%0,ro>\")\n+\t\t (match_operand:DI 2 \"general_operand\" \"Fsro,Fs\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_QMATH && reload_completed\"\n   \"* return vax_output_int_add (insn, operands, DImode);\")\n \f\n ;;- All kinds of subtract instructions.\n \n-(define_insn \"sub<mode>3\"\n+(define_insn_and_split \"sub<mode>3\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n \t(minus:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF\")\n \t\t     (match_operand:VAXfp 2 \"general_operand\" \"gF,gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (minus:VAXfp (match_dup 1)\n+\t\t\t(match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*sub<mode>3<fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(minus:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF\")\n+\t\t     (match_operand:VAXfp 2 \"general_operand\" \"gF,gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    sub<VAXfp:fsfx>2 %2,%0\n    sub<VAXfp:fsfx>3 %2,%1,%0\")\n \n-(define_insn \"sub<mode>3\"\n+(define_insn_and_split \"sub<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n \t(minus:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n \t\t      (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (minus:VAXint (match_dup 1)\n+\t\t\t (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*sub<mode>3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(minus:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n+\t\t      (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n+  \"@\n+   sub<VAXint:isfx>2 %2,%0\n+   sub<VAXint:isfx>3 %2,%1,%0\")\n+\n+(define_insn \"*sub<mode>3_cc\"\n+  [(set (reg:CC VAX_PSL_REGNUM)\n+\t(compare:CC (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))\n+   (set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(minus:VAXint (match_dup 1)\n+\t\t      (match_dup 2)))]\n+  \"reload_completed\"\n   \"@\n    sub<VAXint:isfx>2 %2,%0\n    sub<VAXint:isfx>3 %2,%1,%0\")\n@@ -406,63 +868,161 @@\n   \"!reload_in_progress\"\n   \"vax_expand_addsub_di_operands (operands, MINUS); DONE;\")\n \n-(define_insn \"sbcdi3\"\n+(define_insn_and_split \"sbcdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_addsub_di_operand\" \"=Rr,Rr\")\n \t(minus:DI (match_operand:DI 1 \"general_addsub_di_operand\" \"0,I\")\n \t\t  (match_operand:DI 2 \"general_addsub_di_operand\" \"nRr,Rr\")))]\n   \"TARGET_QMATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (minus:DI (match_dup 1)\n+\t\t     (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*sbcdi3<ccn>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_addsub_di_operand\" \"=Rr,Rr\")\n+\t(minus:DI (match_operand:DI 1 \"general_addsub_di_operand\" \"0,I\")\n+\t\t  (match_operand:DI 2 \"general_addsub_di_operand\" \"nRr,Rr\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"TARGET_QMATH && reload_completed\"\n   \"* return vax_output_int_subtract (insn, operands, DImode);\")\n \n ;; The subtract-with-carry (sbwc) instruction only takes two operands.\n-(define_insn \"subdi3_old\"\n+(define_insn_and_split \"subdi3_old\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=or>,or>\")\n \t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,or>\")\n \t\t  (match_operand:DI 2 \"general_operand\" \"Fsor,Fs\")))]\n   \"!TARGET_QMATH\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (minus:DI (match_dup 1)\n+\t\t     (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*subdi3_old<ccn>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=or>,or>\")\n+\t(minus:DI (match_operand:DI 1 \"general_operand\" \"0,or>\")\n+\t\t  (match_operand:DI 2 \"general_operand\" \"Fsor,Fs\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_QMATH && reload_completed\"\n   \"* return vax_output_int_subtract (insn, operands, DImode);\")\n \f\n ;;- Multiply instructions.\n \n-(define_insn \"mul<mode>3\"\n+(define_insn_and_split \"mul<mode>3\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(mult:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF,gF\")\n \t\t    (match_operand:VAXfp 2 \"general_operand\" \"gF,0,gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (mult:VAXfp (match_dup 1)\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*mul<mode>3<fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(mult:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF,gF\")\n+\t\t    (match_operand:VAXfp 2 \"general_operand\" \"gF,0,gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    mul<VAXfp:fsfx>2 %2,%0\n    mul<VAXfp:fsfx>2 %1,%0\n    mul<VAXfp:fsfx>3 %1,%2,%0\")\n \n-(define_insn \"mul<mode>3\"\n+(define_insn_and_split \"mul<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(mult:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n \t\t     (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (mult:VAXint (match_dup 1)\n+\t\t\t(match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*mul<mode>3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(mult:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n+\t\t     (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    mul<VAXint:isfx>2 %2,%0\n    mul<VAXint:isfx>2 %1,%0\n    mul<VAXint:isfx>3 %1,%2,%0\")\n \n-(define_insn \"mulsidi3\"\n+(define_insn_and_split \"mulsidi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(mult:DI\n \t  (sign_extend:DI (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n \t  (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"nrmT\"))))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (mult:DI\n+\t     (sign_extend:DI (match_dup 1))\n+\t     (sign_extend:DI (match_dup 2))))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*mulsidi3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(mult:DI\n+\t  (sign_extend:DI (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t  (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"nrmT\"))))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"emul %1,%2,$0,%0\")\n \n-(define_insn \"*maddsidi4\"\n+(define_insn_and_split \"*maddsidi4\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(plus:DI\n \t  (mult:DI\n \t    (sign_extend:DI (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n \t    (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"nrmT\")))\n \t  (sign_extend:DI (match_operand:SI 3 \"general_operand\" \"g\"))))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:DI\n+\t     (mult:DI\n+\t       (sign_extend:DI (match_dup 1))\n+\t       (sign_extend:DI (match_dup 2)))\n+\t     (sign_extend:DI (match_dup 3))))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*maddsidi4_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:DI\n+\t  (mult:DI\n+\t    (sign_extend:DI (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t    (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"nrmT\")))\n+\t  (sign_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"g\"))))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"emul %1,%2,%3,%0\")\n \n ;; 'F' constraint means type CONST_DOUBLE\n-(define_insn \"*maddsidi4_const\"\n+(define_insn_and_split \"*maddsidi4_const\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(plus:DI\n \t  (mult:DI\n@@ -471,6 +1031,29 @@\n \t  (match_operand:DI 3 \"immediate_operand\" \"F\")))]\n   \"GET_CODE (operands[3]) == CONST_DOUBLE\n    && CONST_DOUBLE_HIGH (operands[3]) == (CONST_DOUBLE_LOW (operands[3]) >> 31)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:DI\n+\t     (mult:DI\n+\t       (sign_extend:DI (match_dup 1))\n+\t       (sign_extend:DI (match_dup 2)))\n+\t     (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*maddsidi4_const_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:DI\n+\t  (mult:DI\n+\t    (sign_extend:DI (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t    (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"nrmT\")))\n+\t  (match_operand:DI 3 \"immediate_operand\" \"F\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"GET_CODE (operands[3]) == CONST_DOUBLE\n+   && CONST_DOUBLE_HIGH (operands[3]) == (CONST_DOUBLE_LOW (operands[3]) >> 31)\n+   && reload_completed\"\n   \"*\n {\n   if (CONST_DOUBLE_HIGH (operands[3]))\n@@ -480,34 +1063,85 @@\n \f\n ;;- Divide instructions.\n \n-(define_insn \"div<mode>3\"\n+(define_insn_and_split \"div<mode>3\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n \t(div:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF\")\n \t\t   (match_operand:VAXfp 2 \"general_operand\" \"gF,gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (div:VAXfp (match_dup 1)\n+\t\t      (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*div<mode>3<fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(div:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"0,gF\")\n+\t\t   (match_operand:VAXfp 2 \"general_operand\" \"gF,gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    div<VAXfp:fsfx>2 %2,%0\n    div<VAXfp:fsfx>3 %2,%1,%0\")\n \n-(define_insn \"div<mode>3\"\n+(define_insn_and_split \"div<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n \t(div:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n \t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (div:VAXint (match_dup 1)\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*div<mode>3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(div:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    div<VAXint:isfx>2 %2,%0\n    div<VAXint:isfx>3 %2,%1,%0\")\n \n ;; This is left out because it is very slow;\n ;; we are better off programming around the \"lack\" of this insn.\n-;;(define_insn \"divmoddisi4\"\n+;;(define_insn_and_split \"divmoddisi4\"\n ;;  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n ;;\t(div:SI (match_operand:DI 1 \"general_operand\" \"g\")\n ;;\t\t(match_operand:SI 2 \"general_operand\" \"g\")))\n ;;   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=g\")\n ;;\t(mod:SI (match_dup 1)\n ;;\t\t(match_dup 2)))]\n ;;  \"\"\n+;;  \"#\"\n+;;  \"reload_completed\"\n+;;  [(parallel\n+;;     [(set (match_dup 0)\n+;;\t   (div:SI (match_dup 1)\n+;;\t\t   (match_dup 2)))\n+;;      (set (match_dup 3)\n+;;\t   (mod:SI (match_dup 1)\n+;;\t\t   (match_dup 2)))\n+;;      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+;;  \"\")\n+;;\n+;;(define_insn \"*divmoddisi4<ccn><ccnz><ccz>\"\n+;;  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+;;\t(div:SI (match_operand:DI 1 \"general_operand\" \"g\")\n+;;\t\t(match_operand:SI 2 \"general_operand\" \"g\")))\n+;;   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=g\")\n+;;\t(mod:SI (match_dup 1)\n+;;\t\t(match_dup 2)))\n+;;   (clobber (reg:CC VAX_PSL_REGNUM))]\n+;;  \"reload_completed\"\n ;;  \"ediv %2,%1,%0,%3\")\n \f\n ;; Bit-and on the VAX is done with a clear-bits insn.\n@@ -534,11 +1168,29 @@\n     operands[1] = expand_unop (<MODE>mode, one_cmpl_optab, op1, 0, 1);\n }\")\n \n-(define_insn \"*and<mode>\"\n+(define_insn_and_split \"*and<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n-\t(and:VAXint (not:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT,nrmT\"))\n+\t(and:VAXint (not:VAXint\n+\t\t      (match_operand:VAXint 1 \"general_operand\" \"nrmT,nrmT\"))\n \t\t    (match_operand:VAXint 2 \"general_operand\" \"0,nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (and:VAXint (not:VAXint\n+\t\t\t (match_dup 1))\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*and<mode>3_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(and:VAXint (not:VAXint\n+\t\t      (match_operand:VAXint 1 \"general_operand\" \"nrmT,nrmT\"))\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"0,nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    bic<VAXint:isfx>2 %1,%0\n    bic<VAXint:isfx>3 %1,%2,%0\")\n@@ -548,59 +1200,178 @@\n ;; longer a problem.  However, having these patterns allows optimization\n ;; opportunities in combine.c.\n \n-(define_insn \"*and<mode>_const_int\"\n+(define_insn_and_split \"*and<mode>3_const_int\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n \t(and:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n \t\t    (match_operand:VAXint 2 \"const_int_operand\" \"n,n\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (and:VAXint (match_dup 1)\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*and<mode>3_2_const_int<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(and:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\")\n+\t\t    (match_operand:VAXint 2 \"const_int_operand\" \"n,n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    bic<VAXint:isfx>2 %<VAXint:iprefx>2,%0\n    bic<VAXint:isfx>3 %<VAXint:iprefx>2,%1,%0\")\n \n+;; We have no direct AND operation and consequently the RTL sequence\n+;; the \"and<mode>3\" pattern produces does not match the instruction\n+;; the \"*bit<mode>\" pattern does for the purpose of the compare\n+;; elimination pass.  Try to get rid of the extra operation by hand\n+;; and where the sequence is used to set the condition codes only\n+;; convert MNEG/BIC => BIT.\n+(define_peephole2\n+  [(parallel\n+     [(set (match_operand:VAXint 0 \"register_operand\")\n+\t   (not:VAXint (match_operand:VAXint 1 \"general_operand\")))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])\n+   (parallel\n+     [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t   (compare:VAXccnz\n+\t     (and:VAXint (not:VAXint (match_dup 0))\n+\t\t\t (match_operand:VAXint 3 \"general_operand\"))\n+\t     (const_int 0)))\n+      (set (match_operand:VAXint 2 \"register_operand\")\n+\t   (and:VAXint (not:VAXint (match_dup 0))\n+\t\t       (match_dup 3)))])]\n+  \"peep2_reg_dead_p (2, operands[0]) && peep2_reg_dead_p (2, operands[2])\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz\n+\t  (and:VAXint (match_dup 1)\n+\t\t      (match_dup 3))\n+\t  (const_int 0)))]\n+  \"\")\n \f\n ;;- Bit set instructions.\n \n-(define_insn \"ior<mode>3\"\n+(define_insn_and_split \"ior<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(ior:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n \t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ior:VAXint (match_dup 1)\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ior<mode>3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(ior:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    bis<VAXint:isfx>2 %2,%0\n    bis<VAXint:isfx>2 %1,%0\n    bis<VAXint:isfx>3 %2,%1,%0\")\n \n ;;- xor instructions.\n \n-(define_insn \"xor<mode>3\"\n+(define_insn_and_split \"xor<mode>3\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n \t(xor:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n \t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (xor:VAXint (match_dup 1)\n+\t\t       (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*xor<mode>3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g,g\")\n+\t(xor:VAXint (match_operand:VAXint 1 \"general_operand\" \"0,nrmT,nrmT\")\n+\t\t    (match_operand:VAXint 2 \"general_operand\" \"nrmT,0,nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"@\n    xor<VAXint:isfx>2 %2,%0\n    xor<VAXint:isfx>2 %1,%0\n    xor<VAXint:isfx>3 %2,%1,%0\")\n-\n \f\n-(define_insn \"neg<mode>2\"\n+(define_insn_and_split \"neg<mode>2\"\n   [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g\")\n \t(neg:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"gF\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (neg:VAXfp (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*neg<mode>2<fccn><fccnz><fccz>\"\n+  [(set (match_operand:VAXfp 0 \"nonimmediate_operand\" \"=g\")\n+\t(neg:VAXfp (match_operand:VAXfp 1 \"general_operand\" \"gF\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"mneg<VAXfp:fsfx> %1,%0\")\n \n-(define_insn \"neg<mode>2\"\n+(define_insn_and_split \"neg<mode>2\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n \t(neg:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (neg:VAXint (match_dup 1)))\n+\t (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*neg<mode>2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(neg:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n+  \"mneg<VAXint:isfx> %1,%0\")\n+\n+(define_insn \"*neg<mode>2_cc\"\n+  [(set (reg:CC VAX_PSL_REGNUM)\n+\t(compare:CC (const_int 0)\n+\t\t    (neg:VAXint\n+\t\t      (match_operand:VAXint 1 \"general_operand\" \"0,nrmT\"))))\n+   (set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g,g\")\n+\t(neg:VAXint (match_dup 1)))]\n+  \"reload_completed\"\n   \"mneg<VAXint:isfx> %1,%0\")\n \n-(define_insn \"one_cmpl<mode>2\"\n+(define_insn_and_split \"one_cmpl<mode>2\"\n   [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n \t(not:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))]\n   \"\"\n-  \"mcom<VAXint:isfx> %1,%0\")\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (not:VAXint (match_dup 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n \n+(define_insn \"*one_cmpl<mode>2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:VAXint 0 \"nonimmediate_operand\" \"=g\")\n+\t(not:VAXint (match_operand:VAXint 1 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n+  \"mcom<VAXint:isfx> %1,%0\")\n \f\n ;; Arithmetic right shift on the VAX works by negating the shift count,\n ;; then emitting a right shift with the shift count negated.  This means\n@@ -618,25 +1389,70 @@\n     operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*ashlnegsi3_const_int\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ashiftrt:SI (match_dup 1)\n+\t\t\t(match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ashlnegsi3_const_int_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"ashl $%n2,%1,%0\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*ashlnegsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ashiftrt:SI (match_dup 1)\n+\t\t\t(neg:QI (match_dup 2))))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ashlnegsi3_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"ashl %2,%1,%0\")\n \n-(define_insn \"ashlsi3\"\n+(define_insn_and_split \"ashlsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(ashift:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ashift:SI (match_dup 1)\n+\t\t      (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ashlsi3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (operands[2] == const1_rtx && rtx_equal_p (operands[0], operands[1]))\n@@ -673,18 +1489,48 @@\n   operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n-(define_insn \"ashldi3\"\n+(define_insn_and_split \"ashldi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(ashift:DI (match_operand:DI 1 \"general_operand\" \"g\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ashift:DI (match_dup 1)\n+\t\t      (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ashldi3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(ashift:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"ashq %2,%D1,%0\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*ashlnegdi3\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"g\")\n \t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (ashiftrt:DI (match_dup 1)\n+\t\t\t(neg:QI (match_dup 2))))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*ashlnegdi3_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=g\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"g\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"ashq %2,%D1,%0\")\n \n ;; We used to have expand_shift handle logical right shifts by using extzv,\n@@ -719,42 +1565,104 @@\n     operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n }\")\n \n-(define_insn \"rotlsi3\"\n+(define_insn_and_split \"rotlsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(rotate:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"g\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (rotate:SI (match_dup 1)\n+\t\t      (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*rotlsi3<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"g\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"rotl %2,%1,%0\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*rotrsi3_const_int\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (rotatert:SI (match_dup 1)\n+\t\t\t(match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*rotrsi3_const_int_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"rotl %R2,%1,%0\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*rotrnegsi3\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (rotatert:SI (match_dup 1)\n+\t\t\t(neg:QI (match_dup 2))))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*rotrnegsi3_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"g\"))))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"rotl %2,%1,%0\")\n \n ;; This insn is probably slower than a multiply and an add.\n-;;(define_insn \"*amulsi4\"\n+;;(define_insn_and_split \"*amulsi4\"\n ;;  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n ;;\t(mult:SI (plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n ;;\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n ;;\t\t (match_operand:SI 3 \"general_operand\" \"g\")))]\n ;;  \"\"\n+;;  \"#\"\n+;;  \"reload_completed\"\n+;;  [(parallel\n+;;     [(set (match_dup 0)\n+;;\t   (mult:SI (plus:SI (match_dup 1)\n+;;\t\t\t     (match_dup 2))\n+;;\t\t    (match_dup 3)))\n+;;      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+;;  \"\")\n+;;\n+;;(define_insn \"*amulsi4_2<ccn><ccnz><ccz>\"\n+;;  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+;;\t(mult:SI (plus:SI (match_operand:SI 1 \"general_operand\" \"g\")\n+;;\t\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))\n+;;\t\t (match_operand:SI 3 \"general_operand\" \"g\")))\n+;;   (clobber (reg:CC VAX_PSL_REGNUM))]\n+;;  \"reload_completed\"\n ;;  \"index %1,$0x80000000,$0x7fffffff,%3,%2,%0\")\n \f\n ;; Special cases of bit-field insns which we should\n ;; recognize in preference to the general case.\n ;; These handle aligned 8-bit and 16-bit fields\n ;; that can be done with move or convert instructions.\n \n-(define_insn \"*insv_aligned\"\n+(define_insn_and_split \"*insv_aligned\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+ro\")\n \t\t\t (match_operand:QI 1 \"const_int_operand\" \"n\")\n \t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n@@ -770,6 +1678,34 @@\n    && (!(REG_P (operands[0])\n \t || (SUBREG_P (operands[0]) && REG_P (SUBREG_REG (operands[0]))))\n        || INTVAL (operands[2]) == 0)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (zero_extract:SI (match_dup 0)\n+\t\t\t    (match_dup 1)\n+\t\t\t    (match_dup 2))\n+\t   (match_dup 3))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*insv_aligned_2<ccn><ccnz><ccz>\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+ro\")\n+\t\t\t (match_operand:QI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(match_operand:SI 3 \"general_operand\" \"g\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"(INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n+   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n+   && (!MEM_P (operands[0])\n+       || ((!flag_pic\n+\t    || vax_acceptable_pic_operand_p (XEXP (operands[0], 0),\n+\t\t\t\t\t     true, true))\n+\t   && !mode_dependent_address_p (XEXP (operands[0], 0),\n+\t\t\t\t\t MEM_ADDR_SPACE (operands[0]))))\n+   && (!(REG_P (operands[0])\n+\t || (SUBREG_P (operands[0]) && REG_P (SUBREG_REG (operands[0]))))\n+       || INTVAL (operands[2]) == 0)\n+   && reload_completed\"\n   \"*\n {\n   if (!REG_P (operands[0]))\n@@ -780,13 +1716,12 @@\n   else\n     gcc_assert (INTVAL (operands[2]) == 0);\n \n-  CC_STATUS_INIT;\n   if (INTVAL (operands[1]) == 8)\n     return \\\"movb %3,%0\\\";\n   return \\\"movw %3,%0\\\";\n }\")\n \n-(define_insn \"*extzv_aligned\"\n+(define_insn_and_split \"*extzv_aligned\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&g\")\n \t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n \t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\")\n@@ -802,6 +1737,34 @@\n    && (!(REG_P (operands[1])\n \t || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))))\n        || INTVAL (operands[3]) == 0)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (zero_extract:SI (match_dup 1)\n+\t\t\t    (match_dup 2)\n+\t\t\t    (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extzv_aligned_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=&g\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n+   && (!MEM_P (operands[1])\n+       || ((!flag_pic\n+\t    || vax_acceptable_pic_operand_p (XEXP (operands[1], 0),\n+\t\t\t\t\t     true, true))\n+\t   && !mode_dependent_address_p (XEXP (operands[1], 0),\n+\t\t\t\t\t MEM_ADDR_SPACE (operands[1]))))\n+   && (!(REG_P (operands[1])\n+\t || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))))\n+       || INTVAL (operands[3]) == 0)\n+   && reload_completed\"\n   \"*\n {\n   if (!REG_P (operands[1]))\n@@ -817,7 +1780,7 @@\n   return \\\"movzwl %1,%0\\\";\n }\")\n \n-(define_insn \"*extv_aligned\"\n+(define_insn_and_split \"*extv_aligned\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n \t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\")\n@@ -833,6 +1796,34 @@\n    && (!(REG_P (operands[1])\n \t || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))))\n        || INTVAL (operands[3]) == 0)\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (sign_extract:SI (match_dup 1)\n+\t\t\t    (match_dup 2)\n+\t\t\t    (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extv_aligned_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n+\t\t\t (match_operand:QI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"(INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n+   && (!MEM_P (operands[1])\n+       || ((!flag_pic\n+\t    || vax_acceptable_pic_operand_p (XEXP (operands[1], 0),\n+\t\t\t\t\t     true, true))\n+\t   && !mode_dependent_address_p (XEXP (operands[1], 0),\n+\t\t\t\t\t MEM_ADDR_SPACE (operands[1]))))\n+   && (!(REG_P (operands[1])\n+\t || (SUBREG_P (operands[1]) && REG_P (SUBREG_REG (operands[1]))))\n+       || INTVAL (operands[3]) == 0)\n+   && reload_completed\"\n   \"*\n {\n   if (!REG_P (operands[1]))\n@@ -850,37 +1841,54 @@\n \f\n ;; Register and non-offsettable-memory SImode cases of bit-field insns.\n \n-(define_insn \"*cmpv\"\n-  [(set (cc0)\n-\t(compare\n+(define_insn \"*cmpv_<mode>\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc\n \t (sign_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"ro\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n \t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n \t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n-  \"\"\n+  \"reload_completed\"\n   \"cmpv %2,%1,%0,%3\")\n \n-(define_insn \"*cmpzv\"\n-  [(set (cc0)\n-\t(compare\n+(define_insn \"*cmpzv_<mode>\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc\n \t (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"ro\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n \t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n \t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n-  \"\"\n+  \"reload_completed\"\n   \"cmpzv %2,%1,%0,%3\")\n \n ;; When the field position and size are constant and the destination\n ;; is a register, extv and extzv are much slower than a rotate followed\n ;; by a bicl or sign extension.  Because we might end up choosing ext[z]v\n ;; anyway, we can't allow immediate values for the primary source operand.\n \n-(define_insn \"*extv_non_const\"\n+(define_insn_and_split \"*extv_non_const\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (sign_extract:SI (match_dup 1)\n+\t\t\t    (match_dup 2)\n+\t\t\t    (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extv_non_const_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (! CONST_INT_P (operands[3]) || ! CONST_INT_P (operands[2])\n@@ -892,12 +1900,29 @@\n   return \\\"rotl %R3,%1,%0\\;cvtwl %0,%0\\\";\n }\")\n \n-(define_insn \"*extzv_non_const\"\n+(define_insn_and_split \"*extzv_non_const\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (zero_extract:SI (match_dup 1)\n+\t\t\t    (match_dup 2)\n+\t\t\t    (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extzv_non_const_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"ro\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (! CONST_INT_P (operands[3]) || ! CONST_INT_P (operands[2])\n@@ -918,24 +1943,24 @@\n ;; nonimmediate_operand is used to make sure that mode-ambiguous cases\n ;; don't match these (and therefore match the cases above instead).\n \n-(define_insn \"*cmpv_2\"\n-  [(set (cc0)\n-\t(compare\n+(define_insn \"*cmpv_2_<mode>\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc\n \t (sign_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n \t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n \t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n-  \"\"\n+  \"reload_completed\"\n   \"cmpv %2,%1,%0,%3\")\n \n-(define_insn \"*cmpzv_2\"\n-  [(set (cc0)\n-\t(compare\n+(define_insn \"*cmpzv_2_<mode>\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc\n \t (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"m\")\n \t\t\t  (match_operand:QI 1 \"general_operand\" \"g\")\n \t\t\t  (match_operand:SI 2 \"general_operand\" \"nrmT\"))\n \t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n-  \"\"\n+  \"reload_completed\"\n   \"cmpzv %2,%1,%0,%3\")\n \n (define_expand \"extv\"\n@@ -946,12 +1971,29 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*extv\"\n+(define_insn_and_split \"*extv\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (sign_extract:SI (match_dup 1)\n+\t\t\t    (match_dup 2)\n+\t\t\t    (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extv_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (!REG_P (operands[0]) || !CONST_INT_P (operands[2])\n@@ -976,12 +2018,29 @@\n   \"\"\n   \"\")\n \n-(define_insn \"*extzv\"\n+(define_insn_and_split \"*extzv\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n \t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n \t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (zero_extract:SI (match_dup 1)\n+\t\t\t    (match_dup 2)\n+\t\t\t    (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*extzv_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n+\t\t\t (match_operand:QI 2 \"general_operand\" \"g\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"nrmT\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   if (!REG_P (operands[0]) || !CONST_INT_P (operands[2])\n@@ -1021,6 +2080,28 @@\n   return \\\"rotl %R3,%1,%0\\;bicl2 %M2,%0\\\";\n }\")\n \n+;; Combine EXTV/CMPL and EXTZV/CMPL sequences where the output of\n+;; extraction is used for the comparison only into CMPV and CMPZV\n+;; respectively.\n+(define_peephole2\n+  [(parallel\n+     [(set (match_operand:SI 0 \"register_operand\")\n+\t   (any_extract:SI (match_operand 1 \"general_operand\")\n+\t\t\t   (match_operand:QI 2 \"general_operand\")\n+\t\t\t   (match_operand:SI 3 \"general_operand\")))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])\n+   (set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc (match_dup 0)\n+\t\t       (match_operand:SI 4 \"general_operand\")))]\n+  \"peep2_reg_dead_p (2, operands[0])\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc\n+\t  (any_extract:SI (match_dup 1)\n+\t\t\t  (match_dup 2)\n+\t\t\t  (match_dup 3))\n+\t  (match_dup 4)))]\n+  \"\")\n+\n (define_expand \"insv\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"\")\n@@ -1029,6 +2110,7 @@\n   \"\"\n   \"\")\n \n+;; This one actually doesn't change CC.\n (define_insn \"*insv\"\n   [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+m\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"g\")\n@@ -1060,6 +2142,7 @@\n   return \\\"insv %3,%2,%1,%0\\\";\n }\")\n \n+;; This one actually doesn't change CC.\n (define_insn \"*insv_2\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+ro\")\n \t\t\t (match_operand:QI 1 \"general_operand\" \"g\")\n@@ -1078,48 +2161,88 @@\n ;; Conditional jumps\n \n (define_expand \"cbranch<mode>4\"\n-  [(set (cc0)\n-        (compare (match_operand:VAXint 1 \"nonimmediate_operand\" \"\")\n-                 (match_operand:VAXint 2 \"general_operand\" \"\")))\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t  [(match_operand:VAXint 1 \"general_operand\" \"\")\n+\t\t\t   (match_operand:VAXint 2 \"general_operand\" \"\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn_and_split \"*cbranch<VAXint:mode>4_<VAXcc:mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 0 \"vax_<cc>_comparison_operator\"\n+\t\t\t  [(match_operand:VAXint 1 \"general_operand\" \"nrmT\")\n+\t\t\t   (match_operand:VAXint 2 \"general_operand\" \"nrmT\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:VAXcc VAX_PSL_REGNUM)\n+\t(compare:VAXcc (match_dup 1) (match_dup 2)))\n    (set (pc)\n-        (if_then_else\n-              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n-                                                               (const_int 0)])\n-              (label_ref (match_operand 3 \"\" \"\"))\n-              (pc)))]\n- \"\")\n+\t(if_then_else\n+\t  (match_op_dup 0 [(reg:VAXcc VAX_PSL_REGNUM)\n+\t\t\t   (const_int 0)])\n+\t (label_ref (match_operand 3 \"\" \"\"))\n+\t (pc)))]\n+  \"\")\n \n (define_expand \"cbranch<mode>4\"\n-  [(set (cc0)\n-        (compare (match_operand:VAXfp 1 \"general_operand\" \"\")\n-                 (match_operand:VAXfp 2 \"general_operand\" \"\")))\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 0 \"ordered_comparison_operator\"\n+\t\t\t  [(match_operand:VAXfp 1 \"general_operand\" \"\")\n+\t\t\t   (match_operand:VAXfp 2 \"general_operand\" \"\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn_and_split \"*cbranch<VAXfp:mode>4_<VAXccnz:mode>\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (match_operator 0 \"vax_<cc>_comparison_operator\"\n+\t\t\t  [(match_operand:VAXfp 1 \"general_operand\" \"gF\")\n+\t\t\t   (match_operand:VAXfp 2 \"general_operand\" \"gF\")])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (reg:VAXccnz VAX_PSL_REGNUM)\n+\t(compare:VAXccnz (match_dup 1) (match_dup 2)))\n    (set (pc)\n-        (if_then_else\n-              (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n-                                                               (const_int 0)])\n-              (label_ref (match_operand 3 \"\" \"\"))\n-              (pc)))]\n- \"\")\n-\n-(define_insn \"*branch\"\n+\t(if_then_else\n+ \t  (match_op_dup 0 [(reg:VAXccnz VAX_PSL_REGNUM)\n+\t\t\t   (const_int 0)])\n+\t  (label_ref (match_operand 3 \"\" \"\"))\n+\t  (pc)))]\n+  \"\")\n+\n+(define_insn \"*branch_<mode>\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t\t\t      [(cc0)\n+\t(if_then_else (match_operator 0 \"vax_<cc>_comparison_operator\"\n+\t\t\t\t      [(reg:VAXcc VAX_PSL_REGNUM)\n \t\t\t\t       (const_int 0)])\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n-  \"\"\n+  \"reload_completed\"\n   \"j%k0 %l1\")\n \n ;; Recognize reversed jumps.\n-(define_insn \"*branch_reversed\"\n+(define_insn \"*branch_<mode>_reversed\"\n   [(set (pc)\n-\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t\t\t      [(cc0)\n+\t(if_then_else (match_operator 0 \"vax_<cc>_comparison_operator\"\n+\t\t\t\t      [(reg:VAXcc VAX_PSL_REGNUM)\n \t\t\t\t       (const_int 0)])\n \t\t      (pc)\n \t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n+  \"reload_completed\"\n   \"j%K0 %l1\") ; %K0 negates condition\n \f\n ;; Recognize jbs, jlbs, jbc and jlbc instructions.  Note that the operand\n@@ -1189,7 +2312,7 @@\n \n ;; Normal sob insns.\n \n-(define_insn \"\"\n+(define_insn_and_split \"*jsobgtr\"\n   [(set (pc)\n \t(if_then_else\n \t (gt (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1201,9 +2324,38 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))]\n   \"!TARGET_UNIX_ASM\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (gt (plus:SI (match_dup 0)\n+\t\t\t (const_int -1))\n+\t\t(const_int 0))\n+\t    (label_ref (match_dup 1))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int -1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jsobgtr_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (gt (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t\t      (const_int -1))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_UNIX_ASM && reload_completed\"\n   \"jsobgtr %0,%l1\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*jsobgeq\"\n   [(set (pc)\n \t(if_then_else\n \t (ge (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1215,10 +2367,39 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))]\n   \"!TARGET_UNIX_ASM\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (ge (plus:SI (match_dup 0)\n+\t\t\t (const_int -1))\n+\t\t(const_int 0))\n+\t    (label_ref (match_dup 1))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int -1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jsobgeq_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ge (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t\t      (const_int -1))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_UNIX_ASM && reload_completed\"\n   \"jsobgeq %0,%l1\")\n \n ;; Normal aob insns.  Define a version for when operands[1] is a constant.\n-(define_insn \"\"\n+(define_insn_and_split \"*jaoblss\"\n   [(set (pc)\n \t(if_then_else\n \t (lt (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1230,9 +2411,38 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int 1)))]\n   \"!TARGET_UNIX_ASM\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (lt (plus:SI (match_dup 0)\n+\t\t\t (const_int 1))\n+\t\t(match_dup 1))\n+\t    (label_ref (match_dup 2))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jaoblss_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (lt (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_UNIX_ASM && reload_completed\"\n   \"jaoblss %1,%0,%l2\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*jaoblss_const\"\n   [(set (pc)\n \t(if_then_else\n \t (lt (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1243,9 +2453,36 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int 1)))]\n   \"!TARGET_UNIX_ASM && CONST_INT_P (operands[1])\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (lt (match_dup 0)\n+\t\t(match_dup 1))\n+\t    (label_ref (match_dup 2))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jaoblss_const_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (lt (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_UNIX_ASM && CONST_INT_P (operands[1]) && reload_completed\"\n   \"jaoblss %P1,%0,%l2\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*jaobleq\"\n   [(set (pc)\n \t(if_then_else\n \t (le (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1257,9 +2494,38 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int 1)))]\n   \"!TARGET_UNIX_ASM\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (le (plus:SI (match_dup 0)\n+\t\t\t (const_int 1))\n+\t\t(match_dup 1))\n+\t    (label_ref (match_dup 2))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jaobleq_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (le (plus:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t\t      (const_int 1))\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_UNIX_ASM && reload_completed\"\n   \"jaobleq %1,%0,%l2\")\n \n-(define_insn \"\"\n+(define_insn_and_split \"*jaobleq_const\"\n   [(set (pc)\n \t(if_then_else\n \t (le (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1270,12 +2536,39 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int 1)))]\n   \"!TARGET_UNIX_ASM && CONST_INT_P (operands[1])\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (le (match_dup 0)\n+\t\t(match_dup 1))\n+\t    (label_ref (match_dup 2))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int 1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jaobleq_const_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (le (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t     (match_operand:SI 1 \"general_operand\" \"nrmT\"))\n+\t (label_ref (match_operand 2 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int 1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"!TARGET_UNIX_ASM && CONST_INT_P (operands[1]) && reload_completed\"\n   \"jaobleq %P1,%0,%l2\")\n \n ;; Something like a sob insn, but compares against -1.\n ;; This finds `while (foo--)' which was changed to `while (--foo != -1)'.\n \n-(define_insn \"\"\n+(define_insn_and_split \"*jsobneq_minus_one\"\n   [(set (pc)\n \t(if_then_else\n \t (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n@@ -1286,6 +2579,33 @@\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (pc)\n+\t   (if_then_else\n+\t    (ne (match_dup 0)\n+\t\t(const_int 0))\n+\t    (label_ref (match_dup 1))\n+\t    (pc)))\n+      (set (match_dup 0)\n+\t   (plus:SI (match_dup 0)\n+\t\t    (const_int -1)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*jsobneq_minus_one_2\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:SI 0 \"nonimmediate_operand\" \"+g\")\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"decl %0\\;jgequ %l1\")\n \f\n (define_expand \"call_pop\"\n@@ -1512,41 +2832,126 @@\n ;; This insn is a bit of a lier.  It actually falls through if no case\n ;; matches.  But, we prevent that from ever happening by emitting a jump\n ;; before this, see the define_expand above.\n-(define_insn \"casesi1\"\n+(define_insn_and_split \"casesi1\"\n   [(match_operand:SI 1 \"const_int_operand\" \"n\")\n    (set (pc)\n \t(plus:SI (sign_extend:SI\n-\t\t  (mem:HI (plus:SI (mult:SI (match_operand:SI 0 \"general_operand\" \"nrmT\")\n-\t\t\t\t\t    (const_int 2))\n-\t\t\t  (pc))))\n+\t\t   (mem:HI (plus:SI\n+\t\t\t     (mult:SI\n+\t\t\t       (match_operand:SI 0 \"general_operand\" \"nrmT\")\n+\t\t\t       (const_int 2))\n+\t\t\t     (pc))))\n \t\t (label_ref:SI (match_operand 2 \"\" \"\"))))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(match_dup 1)\n+      (set (pc)\n+\t   (plus:SI (sign_extend:SI\n+\t\t      (mem:HI (plus:SI\n+\t\t\t\t(mult:SI\n+\t\t\t\t  (match_dup 0)\n+\t\t\t\t  (const_int 2))\n+\t\t\t\t(pc))))\n+\t\t    (label_ref:SI (match_dup 2))))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*casesi1\"\n+  [(match_operand:SI 1 \"const_int_operand\" \"n\")\n+   (set (pc)\n+\t(plus:SI (sign_extend:SI\n+\t\t   (mem:HI (plus:SI\n+\t\t\t     (mult:SI\n+\t\t\t       (match_operand:SI 0 \"general_operand\" \"nrmT\")\n+\t\t\t       (const_int 2))\n+\t\t\t     (pc))))\n+\t\t (label_ref:SI (match_operand 2 \"\" \"\"))))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"casel %0,$0,%1\")\n \f\n-(define_insn \"*pushsym\"\n+(define_insn_and_split \"*pushsym\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n \t(match_operand:SI 1 \"pic_symbolic_operand\" \"A\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*pushsym_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:SI 1 \"pic_symbolic_operand\" \"A\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"pushab %a1\")\n \n-(define_insn \"*movsym\"\n+(define_insn_and_split \"*movsym\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(match_operand:SI 1 \"pic_symbolic_operand\" \"A\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movsym_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:SI 1 \"pic_symbolic_operand\" \"A\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"movab %a1,%0\")\n \n-(define_insn \"*pushsymreg\"\n+(define_insn_and_split \"*pushsymreg\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t (match_operand:SI 2 \"pic_symbolic_operand\" \"A\")))]\n   \"flag_pic\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:SI (match_dup 1)\n+\t\t    (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*pushsymreg_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"pic_symbolic_operand\" \"A\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"flag_pic && reload_completed\"\n   \"pushab %a2[%1]\")\n \n-(define_insn \"*movsymreg\"\n+(define_insn_and_split \"*movsymreg\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n \t\t (match_operand:SI 2 \"pic_symbolic_operand\" \"A\")))]\n   \"flag_pic\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (plus:SI (match_dup 1)\n+\t\t    (match_dup 2)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movsymreg_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"pic_symbolic_operand\" \"A\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"flag_pic && reload_completed\"\n   \"movab %a2[%1],%0\")\n \f\n ;;- load or push effective address\n@@ -1557,28 +2962,80 @@\n ;; It does not work to use constraints to distinguish pushes from moves,\n ;; because < matches any autodecrement, not just a push.\n \n-(define_insn \"pushaddr<mode>\"\n+(define_insn_and_split \"pushaddr<mode>\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n \t(match_operand:VAXintQHSD 1 \"address_operand\" \"p\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*pushaddr<mode><ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:VAXintQHSD 1 \"address_operand\" \"p\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"pusha<VAXintQHSD:isfx> %a1\")\n \n-(define_insn \"movaddr<mode>\"\n+(define_insn_and_split \"movaddr<mode>\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(match_operand:VAXintQHSD 1 \"address_operand\" \"p\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movaddr<mode><ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:VAXintQHSD 1 \"address_operand\" \"p\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"mova<VAXintQHSD:isfx> %a1,%0\")\n \n-(define_insn \"pushaddr<mode>\"\n+(define_insn_and_split \"pushaddr<mode>\"\n   [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n \t(match_operand:VAXfp 1 \"address_operand\" \"p\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*pushaddr<mode><ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=g\")\n+\t(match_operand:VAXfp 1 \"address_operand\" \"p\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"pusha<VAXfp:fsfx> %a1\")\n \n-(define_insn \"movaddr<mode>\"\n+(define_insn_and_split \"movaddr<mode>\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n \t(match_operand:VAXfp 1 \"address_operand\" \"p\"))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (match_dup 1))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*movaddr<mode>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g\")\n+\t(match_operand:VAXfp 1 \"address_operand\" \"p\"))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"mova<VAXfp:fsfx> %a1,%0\")\n \f\n ;; These used to be peepholes, but it is more straightforward to do them\n@@ -1594,12 +3051,30 @@\n ;; with other operands constant.  This is what the combiner converts the\n ;; above sequences to before attempting to recognize the new insn.\n \n-(define_insn \"\"\n+(define_insn_and_split \"*andashlnegsi4\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n \t(and:SI (ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\"))\n \t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"(INTVAL (operands[3]) & ~((1 << (32 - INTVAL (operands[2]))) - 1)) == 0\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (and:SI (ashiftrt:SI (match_dup 1)\n+\t\t\t\t(match_dup 2))\n+\t\t   (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*andashlnegsi4_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n+\t(and:SI (ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"(INTVAL (operands[3]) & ~((1 << (32 - INTVAL (operands[2]))) - 1)) == 0\n+   && reload_completed\"\n   \"*\n {\n   unsigned long mask1 = INTVAL (operands[3]);\n@@ -1616,12 +3091,29 @@\n ;; bits that the ashl would anyways, in which case it should have been\n ;; optimized away.\n \n-(define_insn \"\"\n+(define_insn_and_split \"*andashlsi4\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n \t(and:SI (ashift:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n \t\t\t   (match_operand:QI 2 \"const_int_operand\" \"n\"))\n \t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n   \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(parallel\n+     [(set (match_dup 0)\n+\t   (and:SI (ashift:SI (match_dup 1)\n+\t\t\t      (match_dup 2))\n+\t\t   (match_dup 3)))\n+      (clobber (reg:CC VAX_PSL_REGNUM))])]\n+  \"\")\n+\n+(define_insn \"*andashlsi4_2<ccn><ccnz><ccz>\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=ro\")\n+\t(and:SI (ashift:SI (match_operand:SI 1 \"general_operand\" \"nrmT\")\n+\t\t\t   (match_operand:QI 2 \"const_int_operand\" \"n\"))\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))\n+   (clobber (reg:CC VAX_PSL_REGNUM))]\n+  \"reload_completed\"\n   \"*\n {\n   operands[3]"}]}