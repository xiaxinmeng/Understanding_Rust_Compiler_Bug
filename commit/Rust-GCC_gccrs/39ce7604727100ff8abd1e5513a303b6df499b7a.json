{"sha": "39ce7604727100ff8abd1e5513a303b6df499b7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljZTc2MDQ3MjcxMDBmZjhhYmQxZTU1MTNhMzAzYjZkZjQ5OWI3YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-02T09:34:50Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-02T09:34:50Z"}, "message": "[multiple changes]\n\n2013-01-02  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_prag.adb: Minor reformatting.\n\n2013-01-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Get_Associated_Node): If the node is an\n\tidentifier that denotes an unconstrained array in an object\n\tdeclaration, it is rewritten as the name of an anonymous\n\tsubtype whose bounds are given by the initial expression in the\n\tdeclaration. When checking whether that identifier is global\n\treference, use the original node, not the local generated subtype.\n\n2013-01-02  Olivier Hainque  <hainque@adacore.com>\n\n\t* tracebak.c: Revert previous change, incomplete.\n\n2013-01-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): If the aspect\n\tappears on a subprogram body that acts as a spec, place the\n\tcorresponding pragma in the declarations of the body, so that\n\te.g. pre/postcondition checks can be generated appropriately.\n\n2013-01-02  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting and code reorganization.\n\nFrom-SVN: r194781", "tree": {"sha": "9d30ede550d344346619d59afd728b95b281a29e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d30ede550d344346619d59afd728b95b281a29e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39ce7604727100ff8abd1e5513a303b6df499b7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ce7604727100ff8abd1e5513a303b6df499b7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ce7604727100ff8abd1e5513a303b6df499b7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ce7604727100ff8abd1e5513a303b6df499b7a/comments", "author": null, "committer": null, "parents": [{"sha": "1824c168768592a20fcf9fe41634f9ebecabb52c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1824c168768592a20fcf9fe41634f9ebecabb52c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1824c168768592a20fcf9fe41634f9ebecabb52c"}], "stats": {"total": 96, "additions": 68, "deletions": 28}, "files": [{"sha": "7d79a90658ad5885cac9021108240c5efd0faa0c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39ce7604727100ff8abd1e5513a303b6df499b7a", "patch": "@@ -1,3 +1,31 @@\n+2013-01-02  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_prag.adb: Minor reformatting.\n+\n+2013-01-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Get_Associated_Node): If the node is an\n+\tidentifier that denotes an unconstrained array in an object\n+\tdeclaration, it is rewritten as the name of an anonymous\n+\tsubtype whose bounds are given by the initial expression in the\n+\tdeclaration. When checking whether that identifier is global\n+\treference, use the original node, not the local generated subtype.\n+\n+2013-01-02  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* tracebak.c: Revert previous change, incomplete.\n+\n+2013-01-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): If the aspect\n+\tappears on a subprogram body that acts as a spec, place the\n+\tcorresponding pragma in the declarations of the body, so that\n+\te.g. pre/postcondition checks can be generated appropriately.\n+\n+2013-01-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting and code reorganization.\n+\n 2013-01-02  Vincent Celier  <celier@adacore.com>\n \n \t* switch-m.adb (Normalize_Compiler_Switches): Record the"}, {"sha": "9ff1318345cf726dfae40ef934dc31414e35e316", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=39ce7604727100ff8abd1e5513a303b6df499b7a", "patch": "@@ -274,8 +274,8 @@ package body Exp_Prag is\n    --------------------------\n \n    procedure Expand_Pragma_Check (N : Node_Id) is\n-      Cond : constant Node_Id    := Arg2 (N);\n-      Nam  : constant Name_Id    := Chars (Arg1 (N));\n+      Cond : constant Node_Id := Arg2 (N);\n+      Nam  : constant Name_Id := Chars (Arg1 (N));\n       Msg  : Node_Id;\n \n       Loc  : constant Source_Ptr := Sloc (First_Node (Cond));"}, {"sha": "b90a7af19d28727d4bfb1fa750050606d3f52962", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=39ce7604727100ff8abd1e5513a303b6df499b7a", "patch": "@@ -4929,6 +4929,17 @@ package body Sem_Ch12 is\n             Assoc := Associated_Node (Assoc);\n          end if;\n \n+         --  An additional special case: an unconstrained type in an object\n+         --  declaration may have been rewritten as a local subtype constrained\n+         --  by the expression in the declaration. We need to recover the\n+         --  original entity which may be global.\n+\n+         if Present (Original_Node (Assoc))\n+           and then Nkind (Parent (N)) = N_Object_Declaration\n+         then\n+            Assoc := Original_Node (Assoc);\n+         end if;\n+\n          return Assoc;\n       end if;\n    end Get_Associated_Node;"}, {"sha": "a959e51a86272ccc2b71fb168b43f015cb99a488", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=39ce7604727100ff8abd1e5513a303b6df499b7a", "patch": "@@ -1606,6 +1606,17 @@ package body Sem_Ch13 is\n \n                   if Nkind (Parent (N)) = N_Compilation_Unit then\n                      Add_Global_Declaration (Aitem);\n+\n+                  --  If it is a subprogram body, add pragmas to list of\n+                  --  declarations in body.\n+\n+                  elsif Nkind (N) = N_Subprogram_Body then\n+                     if No (Declarations (N)) then\n+                        Set_Declarations (N, New_List);\n+                     end if;\n+\n+                     Append (Aitem, Declarations (N));\n+\n                   else\n                      Insert_After (N, Aitem);\n                   end if;"}, {"sha": "2308234f9e9b78b4cbb5997590d1d6597e0d906b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=39ce7604727100ff8abd1e5513a303b6df499b7a", "patch": "@@ -13633,7 +13633,7 @@ package body Sem_Ch3 is\n \n       Alias_Subp   : Entity_Id;\n       Act_List     : Elist_Id;\n-      Act_Elmt     : Elmt_Id   := No_Elmt;\n+      Act_Elmt     : Elmt_Id;\n       Act_Subp     : Entity_Id := Empty;\n       Elmt         : Elmt_Id;\n       Need_Search  : Boolean   := False;\n@@ -13656,6 +13656,9 @@ package body Sem_Ch3 is\n       if Present (Generic_Actual) then\n          Act_List := Collect_Primitive_Operations (Generic_Actual);\n          Act_Elmt := First_Elmt (Act_List);\n+      else\n+         Act_List := No_Elist;\n+         Act_Elmt := No_Elmt;\n       end if;\n \n       --  Derive primitives inherited from the parent. Note that if the generic\n@@ -13850,15 +13853,17 @@ package body Sem_Ch3 is\n                      pragma Assert\n                        (Is_Generic_Unit\n                           (Scope (Find_Dispatching_Type (Alias_Subp)))\n-                       or else\n-                        Instantiation_Depth\n-                          (Sloc (Find_Dispatching_Type (Alias_Subp))) > 0);\n+                         or else\n+                           Instantiation_Depth\n+                             (Sloc (Find_Dispatching_Type (Alias_Subp))) > 0);\n \n                      declare\n                         Iface_Prim_Loc : constant Source_Ptr :=\n                                          Original_Location (Sloc (Alias_Subp));\n-                        Elmt      : Elmt_Id;\n-                        Prim      : Entity_Id;\n+\n+                        Elmt : Elmt_Id;\n+                        Prim : Entity_Id;\n+\n                      begin\n                         Elmt :=\n                           First_Elmt (Primitive_Operations (Generic_Actual));\n@@ -13868,8 +13873,8 @@ package body Sem_Ch3 is\n \n                            if Present (Interface_Alias (Prim))\n                              and then Original_Location\n-                                        (Sloc (Interface_Alias (Prim)))\n-                                       = Iface_Prim_Loc\n+                                        (Sloc (Interface_Alias (Prim))) =\n+                                                              Iface_Prim_Loc\n                            then\n                               Act_Subp := Alias (Prim);\n                               exit Search;"}, {"sha": "2c8335de68b16e585eed6f2fd7714b1553cb4f5b", "filename": "gcc/ada/tracebak.c", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Ftracebak.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39ce7604727100ff8abd1e5513a303b6df499b7a/gcc%2Fada%2Ftracebak.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftracebak.c?ref=39ce7604727100ff8abd1e5513a303b6df499b7a", "patch": "@@ -287,10 +287,9 @@ __gnat_backtrace (void **array,\n #error Unhandled darwin architecture.\n #endif\n \n-/*---------------------- PPC AIX/PPC Lynx 178/Older Darwin ------------------*/\n+/*------------------------ PPC AIX/Older Darwin -------------------------*/\n #elif ((defined (_POWER) && defined (_AIX)) || \\\n-       (defined (__powerpc__) && defined (__Lynx__) && !defined(__ELF__)) || \\\n-       (defined (__ppc__) && defined (__APPLE__)))\n+(defined (__ppc__) && defined (__APPLE__)))\n \n #define USE_GENERIC_UNWINDER\n \n@@ -308,23 +307,9 @@ struct layout\n    should to feature a null backchain, AIX might expose a null return\n    address instead.  */\n \n-/* Then LynxOS-178 features yet another variation, with return_address\n-   == &__start, which we only add conditionally as this symbol is not\n-   necessarily present elsewhere.  Beware that &bla returns the\n-   address of a descriptor when \"bla\" is a function.  Getting the code\n-   address requires an extra dereference.  */\n-\n-#if defined (__Lynx__)\n-extern void __start();\n-#define EXTRA_STOP_CONDITION(CURRENT) ((CURRENT)->return_address == *(void**)&__start)\n-#else\n-#define EXTRA_STOP_CONDITION(CURRENT) (0)\n-#endif\n-\n #define STOP_FRAME(CURRENT, TOP_STACK) \\\n   (((void *) (CURRENT) < (TOP_STACK)) \\\n-   || (CURRENT)->return_address == NULL \\\n-   || EXTRA_STOP_CONDITION(CURRENT))\n+   || (CURRENT)->return_address == NULL)\n \n /* The PPC ABI has an interesting specificity: the return address saved by a\n    function is located in it's caller's frame, and the save operation only"}]}