{"sha": "4230bdb759b717d87186ccb1df225f241322386b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIzMGJkYjc1OWI3MTdkODcxODZjY2IxZGYyMjVmMjQxMzIyMzg2Yg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-01T15:45:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-01T15:45:30Z"}, "message": "[multiple changes]\n\n2011-08-01  Vincent Celier  <celier@adacore.com>\n\n\t* s-parame-vms-ia64.ads: Fix typo in comment\n\tMinor reformatting\n\t* s-parame-vms-restrict.ads: Removed, unused.\n\n2011-08-01  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch3.adb\n\t(Is_Variable_Size_Array): Remove local subprogram Is_Constant_Bound.\n\t* sem_ch3.adb\n\t(Constrain_Index): Remove side effects in the evaluation of the bounds.\n\t* sem_ch3.ads, sem_ch3.adb\n\t(Is_Constant_Bound): New extended version of the subprogram that was\n\tpreviously located inside function Exp_Ch3.Is_Variable_Size_Array.\n\tMoved here since it is shared by routines of sem_ch3 and exp_ch3.\n\t* sem_aux.ads (Constant_Value): Fix typo in comment.\n\t* checks.adb (Generate_Index_Checks): New implementation which, for\n\tarray objects with constant bounds, generates the runtime check\n\treferencing the bounds of the array type. For other cases this routine\n\tprovides its previous behavior obtaining such values from the array\n\tobject.\n\t* sem_res.adb (Set_Slice_Subtype): Link a copied range subtree with its\n\tparent type.\n\t* atree.adb (New_Copy): Reset flag Is_Overloaded in the new copy since\n\twe cannot have semantic interpretations of the new node.\n\nFrom-SVN: r177051", "tree": {"sha": "befa9ae07ae41881d967d26ca6b36a0e2eddfcd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/befa9ae07ae41881d967d26ca6b36a0e2eddfcd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4230bdb759b717d87186ccb1df225f241322386b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4230bdb759b717d87186ccb1df225f241322386b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4230bdb759b717d87186ccb1df225f241322386b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4230bdb759b717d87186ccb1df225f241322386b/comments", "author": null, "committer": null, "parents": [{"sha": "2010d0783d695583e72d0f412278caf4be041776", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2010d0783d695583e72d0f412278caf4be041776", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2010d0783d695583e72d0f412278caf4be041776"}], "stats": {"total": 522, "additions": 224, "deletions": 298}, "files": [{"sha": "dcbdad8c4a91a7d976e9a76314556b314408156b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -1,3 +1,30 @@\n+2011-08-01  Vincent Celier  <celier@adacore.com>\n+\n+\t* s-parame-vms-ia64.ads: Fix typo in comment\n+\tMinor reformatting\n+\t* s-parame-vms-restrict.ads: Removed, unused.\n+\n+2011-08-01  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch3.adb\n+\t(Is_Variable_Size_Array): Remove local subprogram Is_Constant_Bound.\n+\t* sem_ch3.adb\n+\t(Constrain_Index): Remove side effects in the evaluation of the bounds.\n+\t* sem_ch3.ads, sem_ch3.adb\n+\t(Is_Constant_Bound): New extended version of the subprogram that was\n+\tpreviously located inside function Exp_Ch3.Is_Variable_Size_Array.\n+\tMoved here since it is shared by routines of sem_ch3 and exp_ch3.\n+\t* sem_aux.ads (Constant_Value): Fix typo in comment.\n+\t* checks.adb (Generate_Index_Checks): New implementation which, for\n+\tarray objects with constant bounds, generates the runtime check\n+\treferencing the bounds of the array type. For other cases this routine\n+\tprovides its previous behavior obtaining such values from the array\n+\tobject.\n+\t* sem_res.adb (Set_Slice_Subtype): Link a copied range subtree with its\n+\tparent type.\n+\t* atree.adb (New_Copy): Reset flag Is_Overloaded in the new copy since\n+\twe cannot have semantic interpretations of the new node.\n+\n 2011-08-01  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb (Fully_Conformant_Expressions): handle quantified"}, {"sha": "7852d1de1d56a07877dedf31798db9b4e5951893", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -1202,6 +1202,13 @@ package body Atree is\n          Nodes.Table (New_Id).Rewrite_Ins := False;\n          pragma Debug (New_Node_Debugging_Output (New_Id));\n \n+         --  Clear Is_Overloaded since we cannot have semantic interpretations\n+         --  of this new node\n+\n+         if Nkind (Source) in N_Subexpr then\n+            Set_Is_Overloaded (New_Id, False);\n+         end if;\n+\n          --  Always clear Has_Aspects, the caller must take care of copying\n          --  aspects if this is required for the particular situation.\n "}, {"sha": "e45f013fd2e43effabd6b09dcd72f3302f7e24a8", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 145, "deletions": 49, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -4556,75 +4556,171 @@ package body Checks is\n    ---------------------------\n \n    procedure Generate_Index_Checks (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-      A   : constant Node_Id    := Prefix (N);\n-      Sub : Node_Id;\n-      Ind : Nat;\n-      Num : List_Id;\n+\n+      function Entity_Of_Prefix return Entity_Id;\n+      --  Returns the entity of the prefix of N (or Empty if not found)\n+\n+      function Entity_Of_Prefix return Entity_Id is\n+         P : Node_Id := Prefix (N);\n+      begin\n+         while not Is_Entity_Name (P) loop\n+            if not Nkind_In (P, N_Selected_Component,\n+                                N_Indexed_Component)\n+            then\n+               return Empty;\n+            end if;\n+\n+            P := Prefix (P);\n+         end loop;\n+\n+         return Entity (P);\n+      end Entity_Of_Prefix;\n+\n+      --  Local variables\n+\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      A     : constant Node_Id    := Prefix (N);\n+      A_Ent : constant Entity_Id  := Entity_Of_Prefix;\n+      Sub   : Node_Id;\n \n    begin\n-      --  Ignore call if index checks suppressed for array object or type\n+      --  Ignore call if the prefix is not an array since we have a serious\n+      --  error in the sources. Ignore it also if index checks are suppressed\n+      --  for array object or type.\n \n-      if (Is_Entity_Name (A) and then Index_Checks_Suppressed (Entity (A)))\n+      if not Is_Array_Type (Etype (A))\n+        or else (Present (A_Ent)\n+                   and then Index_Checks_Suppressed (A_Ent))\n         or else Index_Checks_Suppressed (Etype (A))\n       then\n          return;\n       end if;\n \n-      --  Generate the checks\n+      --  Generate a raise of constraint error with the appropriate reason and\n+      --  a condition of the form:\n+\n+      --    Base_Type(Sub) not in array'range (subscript)\n+\n+      --  Note that the reason we generate the conversion to the base type here\n+      --  is that we definitely want the range check to take place, even if it\n+      --  looks like the subtype is OK. Optimization considerations that allow\n+      --  us to omit the check have already been taken into account in the\n+      --  setting of the Do_Range_Check flag earlier on.\n \n       Sub := First (Expressions (N));\n-      Ind := 1;\n-      while Present (Sub) loop\n+\n+      --  Handle string literals\n+\n+      if Ekind (Etype (A)) = E_String_Literal_Subtype then\n          if Do_Range_Check (Sub) then\n             Set_Do_Range_Check (Sub, False);\n \n-            --  Force evaluation except for the case of a simple name of a\n-            --  non-volatile entity.\n+            --  For string literals we obtain the bounds of the string from the\n+            --  associated subtype.\n \n-            if not Is_Entity_Name (Sub)\n-              or else Treat_As_Volatile (Entity (Sub))\n-            then\n-               Force_Evaluation (Sub);\n-            end if;\n+            Insert_Action (N,\n+               Make_Raise_Constraint_Error (Loc,\n+                 Condition =>\n+                    Make_Not_In (Loc,\n+                      Left_Opnd  =>\n+                        Convert_To (Base_Type (Etype (Sub)),\n+                          Duplicate_Subexpr_Move_Checks (Sub)),\n+                      Right_Opnd =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix => New_Reference_To (Etype (A), Loc),\n+                          Attribute_Name => Name_Range)),\n+                 Reason => CE_Index_Check_Failed));\n+         end if;\n \n-            --  Generate a raise of constraint error with the appropriate\n-            --  reason and a condition of the form:\n+      --  General case\n \n-            --    Base_Type(Sub) not in array'range (subscript)\n+      else\n+         declare\n+            A_Idx   : Node_Id := Empty;\n+            A_Range : Node_Id;\n+            Ind     : Nat;\n+            Num     : List_Id;\n+            Range_N : Node_Id;\n \n-            --  Note that the reason we generate the conversion to the base\n-            --  type here is that we definitely want the range check to take\n-            --  place, even if it looks like the subtype is OK. Optimization\n-            --  considerations that allow us to omit the check have already\n-            --  been taken into account in the setting of the Do_Range_Check\n-            --  flag earlier on.\n+         begin\n+            A_Idx := First_Index (Etype (A));\n+            Ind   := 1;\n+            while Present (Sub) loop\n+               if Do_Range_Check (Sub) then\n+                  Set_Do_Range_Check (Sub, False);\n \n-            if Ind = 1 then\n-               Num := No_List;\n-            else\n-               Num :=  New_List (Make_Integer_Literal (Loc, Ind));\n-            end if;\n+                  --  Force evaluation except for the case of a simple name of\n+                  --  a non-volatile entity.\n \n-            Insert_Action (N,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition =>\n-                  Make_Not_In (Loc,\n-                    Left_Opnd  =>\n-                      Convert_To (Base_Type (Etype (Sub)),\n-                        Duplicate_Subexpr_Move_Checks (Sub)),\n-                    Right_Opnd =>\n-                      Make_Attribute_Reference (Loc,\n-                        Prefix         =>\n-                          Duplicate_Subexpr_Move_Checks (A, Name_Req => True),\n-                        Attribute_Name => Name_Range,\n-                        Expressions    => Num)),\n-                Reason => CE_Index_Check_Failed));\n-         end if;\n+                  if not Is_Entity_Name (Sub)\n+                    or else Treat_As_Volatile (Entity (Sub))\n+                  then\n+                     Force_Evaluation (Sub);\n+                  end if;\n \n-         Ind := Ind + 1;\n-         Next (Sub);\n-      end loop;\n+                  if Nkind (A_Idx) = N_Range then\n+                     A_Range := A_Idx;\n+\n+                  elsif Nkind (A_Idx) = N_Identifier\n+                    or else Nkind (A_Idx) = N_Expanded_Name\n+                  then\n+                     A_Range := Scalar_Range (Entity (A_Idx));\n+\n+                  else pragma Assert (Nkind (A_Idx) = N_Subtype_Indication);\n+                     A_Range := Range_Expression (Constraint (A_Idx));\n+                  end if;\n+\n+                  --  For array objects with constant bounds we can generate\n+                  --  the index check using the bounds of the type of the index\n+\n+                  if Present (A_Ent)\n+                    and then Ekind (A_Ent) = E_Variable\n+                    and then Is_Constant_Bound (Low_Bound (A_Range))\n+                    and then Is_Constant_Bound (High_Bound (A_Range))\n+                  then\n+                     Range_N :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Reference_To (Etype (A_Idx), Loc),\n+                         Attribute_Name => Name_Range);\n+\n+                  --  For arrays with non-constant bounds we cannot generate\n+                  --  the index check using the bounds of the type of the index\n+                  --  since it may reference discriminants of some enclosing\n+                  --  type. We obtain the bounds directly from the prefix\n+                  --  object.\n+\n+                  else\n+                     if Ind = 1 then\n+                        Num := No_List;\n+                     else\n+                        Num := New_List (Make_Integer_Literal (Loc, Ind));\n+                     end if;\n+\n+                     Range_N :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix =>\n+                           Duplicate_Subexpr_Move_Checks (A, Name_Req => True),\n+                         Attribute_Name => Name_Range,\n+                         Expressions    => Num);\n+                  end if;\n+\n+                  Insert_Action (N,\n+                     Make_Raise_Constraint_Error (Loc,\n+                       Condition =>\n+                          Make_Not_In (Loc,\n+                            Left_Opnd  =>\n+                              Convert_To (Base_Type (Etype (Sub)),\n+                                Duplicate_Subexpr_Move_Checks (Sub)),\n+                            Right_Opnd => Range_N),\n+                       Reason => CE_Index_Check_Failed));\n+               end if;\n+\n+               A_Idx := Next_Index (A_Idx);\n+               Ind := Ind + 1;\n+               Next (Sub);\n+            end loop;\n+         end;\n+      end if;\n    end Generate_Index_Checks;\n \n    --------------------------"}, {"sha": "c1e83bbb42a2312d1b34ebf87f8d91db247f0d7e", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -7580,37 +7580,8 @@ package body Exp_Ch3 is\n    ----------------------------\n \n    function Is_Variable_Size_Array (E : Entity_Id) return Boolean is\n-\n-      function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n-      --  To simplify handling of array components. Determines whether the\n-      --  given bound is constant (a constant or enumeration literal, or an\n-      --  integer literal) as opposed to per-object, through an expression\n-      --  or a discriminant.\n-\n-      -----------------------\n-      -- Is_Constant_Bound --\n-      -----------------------\n-\n-      function Is_Constant_Bound (Exp : Node_Id) return Boolean is\n-      begin\n-         if Nkind (Exp) = N_Integer_Literal then\n-            return True;\n-         else\n-            return\n-              Is_Entity_Name (Exp)\n-                and then Present (Entity (Exp))\n-                and then\n-                 (Ekind (Entity (Exp)) = E_Constant\n-                   or else Ekind (Entity (Exp)) = E_Enumeration_Literal);\n-         end if;\n-      end Is_Constant_Bound;\n-\n-      --  Local variables\n-\n       Idx : Node_Id;\n \n-   --  Start of processing for Is_Variable_Sized_Array\n-\n    begin\n       pragma Assert (Is_Array_Type (E));\n "}, {"sha": "8612e4283c171c4fa463bcee1ccfb38d958ec3b0", "filename": "gcc/ada/s-parame-vms-ia64.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fs-parame-vms-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fs-parame-vms-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-ia64.ads?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -114,11 +114,10 @@ package System.Parameters is\n    subtype C_Address is System.Address\n      range -2 ** (ptr_bits - 1) .. 2 ** (ptr_bits - 1) - 1;\n    for C_Address'Object_Size use ptr_bits;\n-   --  Number of bits in Interaces.C pointers, normally a standard address,\n+   --  Number of bits in Interfaces.C pointers, normally a standard address,\n    --  except on 64-bit VMS where they are 32-bit addresses, for compatibility\n-   --  with legacy code.\n-   --  System.Aux_DEC.Short_Address can't be used because of elaboration\n-   --  circularity.\n+   --  with legacy code. System.Aux_DEC.Short_Address can't be used because of\n+   --  elaboration circularity.\n \n    C_Malloc_Linkname : constant String := \"__gnat_malloc32\";\n    --  Name of runtime function used to allocate such a pointer"}, {"sha": "7c3cbd677945a819ce742c66313b05170aa449c6", "filename": "gcc/ada/s-parame-vms-restrict.ads", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2010d0783d695583e72d0f412278caf4be041776/gcc%2Fada%2Fs-parame-vms-restrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2010d0783d695583e72d0f412278caf4be041776/gcc%2Fada%2Fs-parame-vms-restrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-parame-vms-restrict.ads?ref=2010d0783d695583e72d0f412278caf4be041776", "patch": "@@ -1,215 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    S Y S T E M . P A R A M E T E R S                     --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the OpenVMS version for restricted tasking\n-\n---  This package defines some system dependent parameters for GNAT. These\n---  are values that are referenced by the runtime library and are therefore\n---  relevant to the target machine.\n-\n---  The parameters whose value is defined in the spec are not generally\n---  expected to be changed. If they are changed, it will be necessary to\n---  recompile the run-time library.\n-\n---  The parameters which are defined by functions can be changed by modifying\n---  the body of System.Parameters in file s-parame.adb. A change to this body\n---  requires only rebinding and relinking of the application.\n-\n---  Note: do not introduce any pragma Inline statements into this unit, since\n---  otherwise the relinking and rebinding capability would be deactivated.\n-\n-with System.Aux_DEC;\n-\n-package System.Parameters is\n-   pragma Pure;\n-\n-   ---------------------------------------\n-   -- Task And Stack Allocation Control --\n-   ---------------------------------------\n-\n-   type Task_Storage_Size is new Integer;\n-   --  Type used in tasking units for task storage size\n-\n-   type Size_Type is new Task_Storage_Size;\n-   --  Type used to provide task storage size to runtime\n-\n-   Unspecified_Size : constant Size_Type := Size_Type'First;\n-   --  Value used to indicate that no size type is set\n-\n-   subtype Ratio is Size_Type range -1 .. 100;\n-   Dynamic : constant Size_Type := -1;\n-   --  The secondary stack ratio is a constant between 0 and 100 which\n-   --  determines the percentage of the allocated task stack that is\n-   --  used by the secondary stack (the rest being the primary stack).\n-   --  The special value of minus one indicates that the secondary\n-   --  stack is to be allocated from the heap instead.\n-\n-   Sec_Stack_Ratio : constant Ratio := Dynamic;\n-   --  This constant defines the handling of the secondary stack\n-\n-   Sec_Stack_Dynamic : constant Boolean := Sec_Stack_Ratio = Dynamic;\n-   --  Convenient Boolean for testing for dynamic secondary stack\n-\n-   function Default_Stack_Size return Size_Type;\n-   --  Default task stack size used if none is specified\n-\n-   function Minimum_Stack_Size return Size_Type;\n-   --  Minimum task stack size permitted\n-\n-   function Adjust_Storage_Size (Size : Size_Type) return Size_Type;\n-   --  Given the storage size stored in the TCB, return the Storage_Size\n-   --  value required by the RM for the Storage_Size attribute. The\n-   --  required adjustment is as follows:\n-   --\n-   --    when Size = Unspecified_Size, return Default_Stack_Size\n-   --    when Size < Minimum_Stack_Size, return Minimum_Stack_Size\n-   --    otherwise return given Size\n-\n-   Default_Env_Stack_Size : constant Size_Type := 8_192_000;\n-   --  Assumed size of the environment task, if no other information\n-   --  is available. This value is used when stack checking is\n-   --  enabled and no GNAT_STACK_LIMIT environment variable is set.\n-\n-   Stack_Grows_Down  : constant Boolean := True;\n-   --  This constant indicates whether the stack grows up (False) or\n-   --  down (True) in memory as functions are called. It is used for\n-   --  proper implementation of the stack overflow check.\n-\n-   ----------------------------------------------\n-   -- Characteristics of types in Interfaces.C --\n-   ----------------------------------------------\n-\n-   long_bits : constant := 32;\n-   --  Number of bits in type long and unsigned_long. The normal convention\n-   --  is that this is the same as type Long_Integer, but this is not true\n-   --  of all targets. For example, in OpenVMS long /= Long_Integer.\n-\n-   ptr_bits  : constant := 32;\n-   subtype C_Address is System.Short_Address;\n-   --  Number of bits in Interaces.C pointers, normally a standard address,\n-   --  except on 64-bit VMS where they are 32-bit addresses, for compatibility\n-   --  with legacy code.\n-\n-   C_Malloc_Linkname : constant String := \"__gnat_malloc32\";\n-   --  Name of runtime function used to allocate such a pointer\n-\n-   ----------------------------------------------\n-   -- Behavior of Pragma Finalize_Storage_Only --\n-   ----------------------------------------------\n-\n-   --  Garbage_Collected is a Boolean constant whose value indicates the\n-   --  effect of the pragma Finalize_Storage_Entry on a controlled type.\n-\n-   --    Garbage_Collected = False\n-\n-   --      The system releases all storage on program termination only,\n-   --      but not other garbage collection occurs, so finalization calls\n-   --      are omitted only for outer level objects can be omitted if\n-   --      pragma Finalize_Storage_Only is used.\n-\n-   --    Garbage_Collected = True\n-\n-   --      The system provides full garbage collection, so it is never\n-   --      necessary to release storage for controlled objects for which\n-   --      a pragma Finalize_Storage_Only is used.\n-\n-   Garbage_Collected : constant Boolean := False;\n-   --  The storage mode for this system (release on program exit)\n-\n-   ---------------------\n-   -- Tasking Profile --\n-   ---------------------\n-\n-   --  In the following sections, constant parameters are defined to\n-   --  allow some optimizations and fine tuning within the tasking run time\n-   --  based on restrictions on the tasking features.\n-\n-   ----------------------\n-   -- Locking Strategy --\n-   ----------------------\n-\n-   Single_Lock : constant Boolean := True;\n-   --  Indicates whether a single lock should be used within the tasking\n-   --  run-time to protect internal structures. If True, a single lock\n-   --  will be used, meaning less locking/unlocking operations, but also\n-   --  more global contention. In general, Single_Lock should be set to\n-   --  True on single processor machines, and to False to multi-processor\n-   --  systems, but this can vary from application to application and also\n-   --  depends on the scheduling policy.\n-\n-   -------------------\n-   -- Task Abortion --\n-   -------------------\n-\n-   No_Abort : constant Boolean := True;\n-   --  This constant indicates whether abort statements and asynchronous\n-   --  transfer of control (ATC) are disallowed. If set to True, it is\n-   --  assumed that neither construct is used, and the run time does not\n-   --  need to defer/undefer abort and check for pending actions at\n-   --  completion points. A value of True for No_Abort corresponds to:\n-   --  pragma Restrictions (No_Abort_Statements);\n-   --  pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);\n-\n-   ---------------------\n-   -- Task Attributes --\n-   ---------------------\n-\n-   Default_Attribute_Count : constant := 4;\n-   --  Number of pre-allocated Address-sized task attributes stored in the\n-   --  task control block.\n-\n-   --------------------\n-   -- Runtime Traces --\n-   --------------------\n-\n-   Runtime_Traces : constant Boolean := False;\n-   --  This constant indicates whether the runtime outputs traces to a\n-   --  predefined output or not (True means that traces are output).\n-   --  See System.Traces for more details.\n-\n-   -----------------------\n-   -- Task Image Length --\n-   -----------------------\n-\n-   Max_Task_Image_Length : constant := 256;\n-   --  This constant specifies the maximum length of a task's image\n-\n-   ------------------------------\n-   -- Exception Message Length --\n-   ------------------------------\n-\n-   Default_Exception_Msg_Max_Length : constant := 512;\n-   --  This constant specifies the maximum number of characters to allow in an\n-   --  exception message (see RM 11.4.1(18)). The value for VMS exceeds the\n-   --  default minimum of 200 to allow for the length of chained VMS condition\n-   --  handling messages.\n-\n-end System.Parameters;"}, {"sha": "21acc70abc059296c9c35a4074f150df1bf5e9df", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -97,7 +97,7 @@ package Sem_Aux is\n    --  Returns the argument unchanged if it is not one of these cases.\n \n    function Constant_Value (Ent : Entity_Id) return Node_Id;\n-   --  Id is a variable, constant, named integer, or named real entity. This\n+   --  Ent is a variable, constant, named integer, or named real entity. This\n    --  call obtains the initialization expression for the entity. Will return\n    --  Empty for for a deferred constant whose full view is not available or\n    --  in some other cases of internal entities, which cannot be treated as"}, {"sha": "fe23c3be837c1670c8855de765385027c92648ea", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -11449,6 +11449,15 @@ package body Sem_Ch3 is\n          Resolve_Discrete_Subtype_Indication (S, T);\n          R := Range_Expression (Constraint (S));\n \n+         --  Capture values of bounds and generate temporaries for them if\n+         --  needed, since checks may cause duplication of the expressions\n+         --  which must not be reevaluated.\n+\n+         if Expander_Active then\n+            Force_Evaluation (Low_Bound (R));\n+            Force_Evaluation (High_Bound (R));\n+         end if;\n+\n       elsif Nkind (S) = N_Discriminant_Association then\n \n          --  Syntactically valid in subtype indication\n@@ -15534,6 +15543,31 @@ package body Sem_Ch3 is\n       return Assoc_List;\n    end Inherit_Components;\n \n+   -----------------------\n+   -- Is_Constant_Bound --\n+   -----------------------\n+\n+   function Is_Constant_Bound (Exp : Node_Id) return Boolean is\n+   begin\n+      if Compile_Time_Known_Value (Exp) then\n+         return True;\n+\n+      elsif Is_Entity_Name (Exp)\n+        and then Present (Entity (Exp))\n+      then\n+         return Is_Constant_Object (Entity (Exp))\n+           or else Ekind (Entity (Exp)) = E_Enumeration_Literal;\n+\n+      elsif Nkind (Exp) in N_Binary_Op then\n+         return Is_Constant_Bound (Left_Opnd (Exp))\n+           and then Is_Constant_Bound (Right_Opnd (Exp))\n+           and then Scope (Entity (Exp)) = Standard_Standard;\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Constant_Bound;\n+\n    -----------------------\n    -- Is_Null_Extension --\n    -----------------------"}, {"sha": "064b0f76ce68aaf1e0f399c7d14d85cdfdc1a278", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -170,6 +170,12 @@ package Sem_Ch3 is\n    --  Given a discriminant somewhere in the Typ_For_Constraint tree and a\n    --  Constraint, return the value of that discriminant.\n \n+   function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n+   --  Determines whether the given bound is a compile-time known value, or a\n+   --  constant entity, or an enumeration literal, or an expression composed\n+   --  of constant-bound subexpressions which are evaluated by means of\n+   --  standard operators.\n+\n    function Is_Null_Extension (T : Entity_Id) return Boolean;\n    --  Returns True if the tagged type T has an N_Full_Type_Declaration that\n    --  is a null extension, meaning that it has an extension part without any"}, {"sha": "2b44924825aac1ab54e7ccb64a8db7be90c8039d", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4230bdb759b717d87186ccb1df225f241322386b/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4230bdb759b717d87186ccb1df225f241322386b", "patch": "@@ -9478,6 +9478,7 @@ package body Sem_Res is\n          --  scheme).\n \n          Set_Scalar_Range (Index_Subtype, New_Copy_Tree (Drange));\n+         Set_Parent       (Scalar_Range (Index_Subtype), Index_Subtype);\n          Set_Etype        (Index_Subtype, Index_Type);\n          Set_Size_Info    (Index_Subtype, Index_Type);\n          Set_RM_Size      (Index_Subtype, RM_Size (Index_Type));"}]}