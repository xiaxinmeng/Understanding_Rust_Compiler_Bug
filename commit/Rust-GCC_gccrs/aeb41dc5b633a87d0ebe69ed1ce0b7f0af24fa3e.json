{"sha": "aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWViNDFkYzViNjMzYTg3ZDBlYmU2OWVkMWNlMGI3ZjBhZjI0ZmEzZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-03-06T00:27:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-03-06T00:27:32Z"}, "message": "compiler: Do not declare type switch variable outside case statements.\n\nFor expressions containing a TypeSwitchGuard with a short variable\ndeclaration e.g. var := x.(type), the spec says that var is declared\nat the beginning of the implicit block for each in each clause.\nPreviously, var was declared in the block for the switch statement\nand each implicit block, which led to errors if the type case clause\nreferenced a type with a similar name as the declared variable.\n\nFixes golang/go#10047.\n\nFrom-SVN: r221230", "tree": {"sha": "046f5dcdb454e83a54280fc6fa5bd40a8f864333", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/046f5dcdb454e83a54280fc6fa5bd40a8f864333"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/comments", "author": null, "committer": null, "parents": [{"sha": "c4571e0e36c9ff80c29ad562c779be2e8fa1b6b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4571e0e36c9ff80c29ad562c779be2e8fa1b6b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4571e0e36c9ff80c29ad562c779be2e8fa1b6b2"}], "stats": {"total": 159, "additions": 79, "deletions": 80}, "files": [{"sha": "a42803dd83070b38b2d77b1ee4809e2283099208", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "patch": "@@ -6030,6 +6030,7 @@ Variable::type()\n   Type* type = this->type_;\n   Expression* init = this->init_;\n   if (this->is_type_switch_var_\n+      && type != NULL\n       && this->type_->is_nil_constant_as_type())\n     {\n       Type_guard_expression* tge = this->init_->type_guard_expression();\n@@ -6103,7 +6104,9 @@ Variable::determine_type()\n   // type here.  It will have an initializer which is a type guard.\n   // We want to initialize it to the value without the type guard, and\n   // use the type of that value as well.\n-  if (this->is_type_switch_var_ && this->type_->is_nil_constant_as_type())\n+  if (this->is_type_switch_var_\n+      && this->type_ != NULL\n+      && this->type_->is_nil_constant_as_type())\n     {\n       Type_guard_expression* tge = this->init_->type_guard_expression();\n       go_assert(tge != NULL);"}, {"sha": "496ab41b6e3bee2a6163e26e537d8ab5955fdd34", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "patch": "@@ -50,8 +50,7 @@ Parse::Parse(Lex* lex, Gogo* gogo)\n     break_stack_(NULL),\n     continue_stack_(NULL),\n     iota_(0),\n-    enclosing_vars_(),\n-    type_switch_vars_()\n+    enclosing_vars_()\n {\n }\n \n@@ -4596,55 +4595,79 @@ Statement*\n Parse::type_switch_body(Label* label, const Type_switch& type_switch,\n \t\t\tLocation location)\n {\n-  Named_object* switch_no = NULL;\n-  if (!type_switch.name.empty())\n-    {\n-      if (Gogo::is_sink_name(type_switch.name))\n-\terror_at(type_switch.location,\n-\t\t \"no new variables on left side of %<:=%>\");\n+  Expression* init = type_switch.expr;\n+  std::string var_name = type_switch.name;\n+  if (!var_name.empty())\n+    {\n+      if (Gogo::is_sink_name(var_name))\n+        {\n+          error_at(type_switch.location,\n+                   \"no new variables on left side of %<:=%>\");\n+          var_name.clear();\n+        }\n       else\n \t{\n-\t  Variable* switch_var = new Variable(NULL, type_switch.expr, false,\n-\t\t\t\t\t      false, false,\n-\t\t\t\t\t      type_switch.location);\n-\t  switch_no = this->gogo_->add_variable(type_switch.name, switch_var);\n+          Location loc = type_switch.location;\n+\t  Temporary_statement* switch_temp =\n+              Statement::make_temporary(NULL, init, loc);\n+\t  this->gogo_->add_statement(switch_temp);\n+          init = Expression::make_temporary_reference(switch_temp, loc);\n \t}\n     }\n \n   Type_switch_statement* statement =\n-    Statement::make_type_switch_statement(switch_no,\n-\t\t\t\t\t  (switch_no == NULL\n-\t\t\t\t\t   ? type_switch.expr\n-\t\t\t\t\t   : NULL),\n-\t\t\t\t\t  location);\n-\n+      Statement::make_type_switch_statement(var_name, init, location);\n   this->push_break_statement(statement, label);\n \n   Type_case_clauses* case_clauses = new Type_case_clauses();\n   bool saw_default = false;\n+  std::vector<Named_object*> implicit_vars;\n   while (!this->peek_token()->is_op(OPERATOR_RCURLY))\n     {\n       if (this->peek_token()->is_eof())\n \t{\n \t  error_at(this->location(), \"missing %<}%>\");\n \t  return NULL;\n \t}\n-      this->type_case_clause(switch_no, case_clauses, &saw_default);\n+      this->type_case_clause(var_name, init, case_clauses, &saw_default,\n+                             &implicit_vars);\n     }\n   this->advance_token();\n \n   statement->add_clauses(case_clauses);\n \n   this->pop_break_statement();\n \n+  // If there is a type switch variable implicitly declared in each case clause,\n+  // check that it is used in at least one of the cases.\n+  if (!var_name.empty())\n+    {\n+      bool used = false;\n+      for (std::vector<Named_object*>::iterator p = implicit_vars.begin();\n+\t   p != implicit_vars.end();\n+\t   ++p)\n+\t{\n+\t  if ((*p)->var_value()->is_used())\n+\t    {\n+\t      used = true;\n+\t      break;\n+\t    }\n+\t}\n+      if (!used)\n+\terror_at(type_switch.location, \"%qs declared and not used\",\n+\t\t Gogo::message_name(var_name).c_str());\n+    }\n   return statement;\n }\n \n // TypeCaseClause  = TypeSwitchCase \":\" [ StatementList ] .\n+// IMPLICIT_VARS is the list of variables implicitly declared for each type\n+// case if there is a type switch variable declared.\n \n void\n-Parse::type_case_clause(Named_object* switch_no, Type_case_clauses* clauses,\n-\t\t\tbool* saw_default)\n+Parse::type_case_clause(const std::string& var_name, Expression* init,\n+                        Type_case_clauses* clauses, bool* saw_default,\n+\t\t\tstd::vector<Named_object*>* implicit_vars)\n {\n   Location location = this->location();\n \n@@ -4661,24 +4684,21 @@ Parse::type_case_clause(Named_object* switch_no, Type_case_clauses* clauses,\n   if (this->statement_list_may_start_here())\n     {\n       this->gogo_->start_block(this->location());\n-      if (switch_no != NULL && types.size() == 1)\n+      if (!var_name.empty())\n \t{\n-\t  Type* type = types.front();\n-\t  Expression* init = Expression::make_var_reference(switch_no,\n-\t\t\t\t\t\t\t    location);\n-\t  init = Expression::make_type_guard(init, type, location);\n-\t  Variable* v = new Variable(type, init, false, false, false,\n-\t\t\t\t     location);\n-\t  v->set_is_type_switch_var();\n-\t  Named_object* no = this->gogo_->add_variable(switch_no->name(), v);\n+\t  Type* type = NULL;\n+          Location var_loc = init->location();\n+\t  if (types.size() == 1)\n+\t    {\n+\t      type = types.front();\n+\t      init = Expression::make_type_guard(init, type, location);\n+\t    }\n \n-\t  // We don't want to issue an error if the compiler\n-\t  // introduced special variable is not used.  Instead we want\n-\t  // to issue an error if the variable defined by the switch\n-\t  // is not used.  That is handled via type_switch_vars_ and\n-\t  // Parse::mark_var_used.\n+\t  Variable* v = new Variable(type, init, false, false, false,\n+\t\t\t\t     var_loc);\n \t  v->set_is_used();\n-\t  this->type_switch_vars_[no] = switch_no;\n+\t  v->set_is_type_switch_var();\n+\t  implicit_vars->push_back(this->gogo_->add_variable(var_name, v));\n \t}\n       this->statement_list();\n       statements = this->gogo_->finish_block(this->location());\n@@ -5752,15 +5772,5 @@ void\n Parse::mark_var_used(Named_object* no)\n {\n   if (no->is_variable())\n-    {\n-      no->var_value()->set_is_used();\n-\n-      // When a type switch uses := to define a variable, then for\n-      // each case with a single type we introduce a new variable with\n-      // the appropriate type.  When we do, if the newly introduced\n-      // variable is used, then the type switch variable is used.\n-      Type_switch_vars::iterator p = this->type_switch_vars_.find(no);\n-      if (p != this->type_switch_vars_.end())\n-\tp->second->var_value()->set_is_used();\n-    }\n+    no->var_value()->set_is_used();\n }"}, {"sha": "734071a73773a8a9f0a4ab9ae589f7a5d7d164be", "filename": "gcc/go/gofrontend/parse.h", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h?ref=aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "patch": "@@ -156,11 +156,6 @@ class Parse\n   // break or continue statement with no label.\n   typedef std::vector<std::pair<Statement*, Label*> > Bc_stack;\n \n-  // Map from type switch variables to the variables they mask, so\n-  // that a use of the type switch variable can become a use of the\n-  // real variable.\n-  typedef Unordered_map(Named_object*, Named_object*) Type_switch_vars;\n-\n   // Parser nonterminals.\n   void identifier_list(Typed_identifier_list*);\n   Expression_list* expression_list(Expression*, bool may_be_sink,\n@@ -259,7 +254,8 @@ class Parse\n   void expr_case_clause(Case_clauses*, bool* saw_default);\n   Expression_list* expr_switch_case(bool*);\n   Statement* type_switch_body(Label*, const Type_switch&, Location);\n-  void type_case_clause(Named_object*, Type_case_clauses*, bool* saw_default);\n+  void type_case_clause(const std::string&, Expression*, Type_case_clauses*,\n+                        bool* saw_default, std::vector<Named_object*>*);\n   void type_switch_case(std::vector<Type*>*, bool*);\n   void select_stat(Label*);\n   void comm_clause(Select_clauses*, bool* saw_default);\n@@ -327,8 +323,6 @@ class Parse\n   // References from the local function to variables defined in\n   // enclosing functions.\n   Enclosing_vars enclosing_vars_;\n-  // Map from type switch variables to real variables.\n-  Type_switch_vars type_switch_vars_;\n };\n \n "}, {"sha": "e1cc75e7e0488ecb7d3194c620587e7653d48818", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "patch": "@@ -4279,11 +4279,8 @@ Type_case_clauses::dump_clauses(Ast_dump_context* ast_dump_context) const\n int\n Type_switch_statement::do_traverse(Traverse* traverse)\n {\n-  if (this->var_ == NULL)\n-    {\n-      if (this->traverse_expression(traverse, &this->expr_) == TRAVERSE_EXIT)\n-\treturn TRAVERSE_EXIT;\n-    }\n+  if (this->traverse_expression(traverse, &this->expr_) == TRAVERSE_EXIT)\n+    return TRAVERSE_EXIT;\n   if (this->clauses_ != NULL)\n     return this->clauses_->traverse(traverse);\n   return TRAVERSE_CONTINUE;\n@@ -4306,10 +4303,7 @@ Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \n   Block* b = new Block(enclosing, loc);\n \n-  Type* val_type = (this->var_ != NULL\n-\t\t    ? this->var_->var_value()->type()\n-\t\t    : this->expr_->type());\n-\n+  Type* val_type = this->expr_->type();\n   if (val_type->interface_type() == NULL)\n     {\n       if (!val_type->is_error())\n@@ -4326,15 +4320,10 @@ Type_switch_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n   // descriptor_temp = ifacetype(val_temp) FIXME: This should be\n   // inlined.\n   bool is_empty = val_type->interface_type()->is_empty();\n-  Expression* ref;\n-  if (this->var_ == NULL)\n-    ref = this->expr_;\n-  else\n-    ref = Expression::make_var_reference(this->var_, loc);\n   Expression* call = Runtime::make_call((is_empty\n \t\t\t\t\t ? Runtime::EFACETYPE\n \t\t\t\t\t : Runtime::IFACETYPE),\n-\t\t\t\t\tloc, 1, ref);\n+\t\t\t\t\tloc, 1, this->expr_);\n   Temporary_reference_expression* lhs =\n     Expression::make_temporary_reference(descriptor_temp, loc);\n   lhs->set_is_lvalue();\n@@ -4384,7 +4373,9 @@ Type_switch_statement::do_dump_statement(Ast_dump_context* ast_dump_context)\n     const\n {\n   ast_dump_context->print_indent();\n-  ast_dump_context->ostream() << \"switch \" << this->var_->name() << \" = \";\n+  ast_dump_context->ostream() << \"switch \";\n+  if (!this->name_.empty())\n+    ast_dump_context->ostream() << this->name_ << \" = \";\n   ast_dump_context->dump_expression(this->expr_);\n   ast_dump_context->ostream() << \" .(type)\";\n   if (ast_dump_context->dump_subblocks())\n@@ -4399,10 +4390,10 @@ Type_switch_statement::do_dump_statement(Ast_dump_context* ast_dump_context)\n // Make a type switch statement.\n \n Type_switch_statement*\n-Statement::make_type_switch_statement(Named_object* var, Expression* expr,\n+Statement::make_type_switch_statement(const std::string& name, Expression* expr,\n \t\t\t\t      Location location)\n {\n-  return new Type_switch_statement(var, expr, location);\n+  return new Type_switch_statement(name, expr, location);\n }\n \n // Class Send_statement."}, {"sha": "8b8b99b4cfdbd8330af7de3882d546517b5b9a0e", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=aeb41dc5b633a87d0ebe69ed1ce0b7f0af24fa3e", "patch": "@@ -250,7 +250,7 @@ class Statement\n \n   // Make a type switch statement.\n   static Type_switch_statement*\n-  make_type_switch_statement(Named_object* var, Expression*, Location);\n+  make_type_switch_statement(const std::string&, Expression*, Location);\n \n   // Make a send statement.\n   static Send_statement*\n@@ -1607,11 +1607,11 @@ class Type_case_clauses\n class Type_switch_statement : public Statement\n {\n  public:\n-  Type_switch_statement(Named_object* var, Expression* expr,\n+  Type_switch_statement(const std::string& name, Expression* expr,\n \t\t\tLocation location)\n     : Statement(STATEMENT_TYPE_SWITCH, location),\n-      var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n-  { go_assert(var == NULL || expr == NULL); }\n+      name_(name), expr_(expr), clauses_(NULL), break_label_(NULL)\n+  { }\n \n   // Add the clauses.\n   void\n@@ -1643,8 +1643,9 @@ class Type_switch_statement : public Statement\n   do_may_fall_through() const;\n \n  private:\n-  // The variable holding the value we are switching on.\n-  Named_object* var_;\n+  // The name of the variable declared in the type switch guard.  Empty if there\n+  // is no variable declared.\n+  std::string name_;\n   // The expression we are switching on if there is no variable.\n   Expression* expr_;\n   // The type case clauses."}]}