{"sha": "10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBiMDRkMWUwYjNmNDQzNWE4ZjJlODA2ZmRkZjEyZmY4Yjg2NDYyMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-07-16T08:41:21Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-07-16T08:41:21Z"}, "message": "Report ambiguous uses of .md attributes\n\nThis patch reports an error if the .md file has an unscoped\nattribute that maps to more than one possible value.\n\n2019-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* read-md.h (md_reader::record_potential_iterator_use): Add a\n\tfile_location parameter.\n\t* read-rtl.c (attribute_use::loc): New field.\n\t(map_attr_string): Take a file_location parameter.  Report cases\n\tin which attributes map to multiple distinct values.\n\t(apply_attribute_uses): Update call accordingly.\n\t(md_reader::handle_overloaded_name): Likewise.\n\t(md_reader::apply_iterator_to_string): Likewise.  Skip empty\n\tnonnull strings.\n\t(record_attribute_use): Take a file_location parameter.\n\tInitialize attribute_use::loc.\n\t(md_reader::record_potential_iterator_use): Take a file_location\n\tparameter.  Update call to record_attribute_use.\n\t(rtx_reader::rtx_alloc_for_name): Update call accordingly.\n\t(rtx_reader::read_rtx_code): Likewise.\n\t(rtx_reader::read_rtx_operand): Likewise.  Record a location\n\tfor implicitly-expanded empty strings.\n\nFrom-SVN: r273511", "tree": {"sha": "32e7d52153214e096034ab2c775e6956a2e86aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32e7d52153214e096034ab2c775e6956a2e86aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "737eb76789cd454918a85983255a1f62efcbfdc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/737eb76789cd454918a85983255a1f62efcbfdc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/737eb76789cd454918a85983255a1f62efcbfdc9"}], "stats": {"total": 91, "additions": 67, "deletions": 24}, "files": [{"sha": "30e6e7ef4b08275524ff0ae51e60a14a1e599e98", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "patch": "@@ -1,3 +1,23 @@\n+2019-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* read-md.h (md_reader::record_potential_iterator_use): Add a\n+\tfile_location parameter.\n+\t* read-rtl.c (attribute_use::loc): New field.\n+\t(map_attr_string): Take a file_location parameter.  Report cases\n+\tin which attributes map to multiple distinct values.\n+\t(apply_attribute_uses): Update call accordingly.\n+\t(md_reader::handle_overloaded_name): Likewise.\n+\t(md_reader::apply_iterator_to_string): Likewise.  Skip empty\n+\tnonnull strings.\n+\t(record_attribute_use): Take a file_location parameter.\n+\tInitialize attribute_use::loc.\n+\t(md_reader::record_potential_iterator_use): Take a file_location\n+\tparameter.  Update call to record_attribute_use.\n+\t(rtx_reader::rtx_alloc_for_name): Update call accordingly.\n+\t(rtx_reader::read_rtx_code): Likewise.\n+\t(rtx_reader::read_rtx_operand): Likewise.  Record a location\n+\tfor implicitly-expanded empty strings.\n+\n 2019-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* read-md.h (md_reader::ptr_loc): Moved from read-md.c."}, {"sha": "377b9f186c5e3e463c6eee3f46c64dd51b2872ef", "filename": "gcc/read-md.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "patch": "@@ -212,8 +212,8 @@ class md_reader\n   rtx copy_rtx_for_iterators (rtx original);\n   void read_conditions ();\n   void record_potential_iterator_use (struct iterator_group *group,\n-\t\t\t\t      rtx x, unsigned int index,\n-\t\t\t\t      const char *name);\n+\t\t\t\t      file_location loc, rtx x,\n+\t\t\t\t      unsigned int index, const char *name);\n   struct mapping *read_mapping (struct iterator_group *group, htab_t table);\n   overloaded_name *handle_overloaded_name (rtx, vec<mapping *> *);\n "}, {"sha": "3b5d999760314b2927df85a7d9ee48516de17dd7", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10b04d1e0b3f4435a8f2e806fddf12ff8b864623/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=10b04d1e0b3f4435a8f2e806fddf12ff8b864623", "patch": "@@ -106,6 +106,9 @@ struct attribute_use {\n   /* The group that describes the use site.  */\n   struct iterator_group *group;\n \n+  /* The location at which the use occurs.  */\n+  file_location loc;\n+\n   /* The name of the attribute, possibly with an \"iterator:\" prefix.  */\n   const char *value;\n \n@@ -361,17 +364,19 @@ find_subst_iter_by_attr (const char *attr)\n \n /* Map attribute string P to its current value.  Return null if the attribute\n    isn't known.  If ITERATOR_OUT is nonnull, store the associated iterator\n-   there.  */\n+   there.  Report any errors against location LOC.  */\n \n static struct map_value *\n-map_attr_string (const char *p, mapping **iterator_out = 0)\n+map_attr_string (file_location loc, const char *p, mapping **iterator_out = 0)\n {\n   const char *attr;\n   struct mapping *iterator;\n   unsigned int i;\n   struct mapping *m;\n   struct map_value *v;\n   int iterator_name_len;\n+  struct map_value *res = NULL;\n+  struct mapping *prev = NULL;\n \n   /* Peel off any \"iterator:\" prefix.  Set ATTR to the start of the\n      attribute name.  */\n@@ -414,13 +419,22 @@ map_attr_string (const char *p, mapping **iterator_out = 0)\n \t  for (v = m->values; v; v = v->next)\n \t    if (v->number == iterator->current_value->number)\n \t      {\n+\t\tif (res && strcmp (v->string, res->string) != 0)\n+\t\t  {\n+\t\t    error_at (loc, \"ambiguous attribute '%s'; could be\"\n+\t\t\t      \" '%s' (via '%s:%s') or '%s' (via '%s:%s')\",\n+\t\t\t      attr, res->string, prev->name, attr,\n+\t\t\t      v->string, iterator->name, attr);\n+\t\t    return v;\n+\t\t  }\n \t\tif (iterator_out)\n \t\t  *iterator_out = iterator;\n-\t\treturn v;\n+\t\tprev = iterator;\n+\t\tres = v;\n \t      }\n \t}\n     }\n-  return NULL;\n+  return res;\n }\n \n /* Apply the current iterator values to STRING.  Return the new string\n@@ -432,16 +446,17 @@ md_reader::apply_iterator_to_string (const char *string)\n   char *base, *copy, *p, *start, *end;\n   struct map_value *v;\n \n-  if (string == 0)\n+  if (string == 0 || string[0] == 0)\n     return string;\n \n+  file_location loc = get_md_ptr_loc (string)->loc;\n   base = p = copy = ASTRDUP (string);\n   while ((start = strchr (p, '<')) && (end = strchr (start, '>')))\n     {\n       p = start + 1;\n \n       *end = 0;\n-      v = map_attr_string (p);\n+      v = map_attr_string (loc, p);\n       *end = '>';\n       if (v == 0)\n \tcontinue;\n@@ -572,7 +587,7 @@ apply_attribute_uses (void)\n \n   FOR_EACH_VEC_ELT (attribute_uses, i, ause)\n     {\n-      v = map_attr_string (ause->value);\n+      v = map_attr_string (ause->loc, ause->value);\n       if (!v)\n \tfatal_with_file_and_line (\"unknown iterator value `%s'\", ause->value);\n       ause->group->apply_iterator (ause->x, ause->index,\n@@ -656,6 +671,7 @@ md_reader::handle_overloaded_name (rtx original, vec<mapping *> *iterators)\n \n   /* Remove the '@', so that no other code needs to worry about it.  */\n   const char *name = XSTR (original, 0);\n+  file_location loc = get_md_ptr_loc (name)->loc;\n   copy_md_ptr_loc (name + 1, name);\n   name += 1;\n   XSTR (original, 0) = name;\n@@ -672,7 +688,7 @@ md_reader::handle_overloaded_name (rtx original, vec<mapping *> *iterators)\n     {\n       *end = 0;\n       mapping *iterator;\n-      if (!map_attr_string (start + 1, &iterator))\n+      if (!map_attr_string (loc, start + 1, &iterator))\n \tfatal_with_file_and_line (\"unknown iterator `%s'\", start + 1);\n       *end = '>';\n \n@@ -1126,24 +1142,25 @@ record_iterator_use (struct mapping *iterator, rtx x, unsigned int index)\n   iterator_uses.safe_push (iuse);\n }\n \n-/* Record that X uses attribute VALUE, which must match a built-in\n-   value from group GROUP.  If the use is in an operand of X, INDEX\n-   is the index of that operand, otherwise it is ignored.  */\n+/* Record that X uses attribute VALUE at location LOC, where VALUE must\n+   match a built-in value from group GROUP.  If the use is in an operand\n+   of X, INDEX is the index of that operand, otherwise it is ignored.  */\n \n static void\n-record_attribute_use (struct iterator_group *group, rtx x,\n+record_attribute_use (struct iterator_group *group, file_location loc, rtx x,\n \t\t      unsigned int index, const char *value)\n {\n-  struct attribute_use ause = {group, value, x, index};\n+  struct attribute_use ause = {group, loc, value, x, index};\n   attribute_uses.safe_push (ause);\n }\n \n /* Interpret NAME as either a built-in value, iterator or attribute\n    for group GROUP.  X and INDEX are the values to pass to GROUP's\n-   apply_iterator callback.  */\n+   apply_iterator callback.  LOC is the location of the use.  */\n \n void\n md_reader::record_potential_iterator_use (struct iterator_group *group,\n+\t\t\t\t\t  file_location loc,\n \t\t\t\t\t  rtx x, unsigned int index,\n \t\t\t\t\t  const char *name)\n {\n@@ -1156,7 +1173,7 @@ md_reader::record_potential_iterator_use (struct iterator_group *group,\n       /* Copy the attribute string into permanent storage, without the\n \t angle brackets around it.  */\n       obstack_grow0 (&m_string_obstack, name + 1, len - 2);\n-      record_attribute_use (group, x, index,\n+      record_attribute_use (group, loc, x, index,\n \t\t\t    XOBFINISH (&m_string_obstack, char *));\n     }\n   else\n@@ -1540,7 +1557,8 @@ rtx_reader::rtx_alloc_for_name (const char *name)\n       /* Pick the first possible code for now, and record the attribute\n \t use for later.  */\n       rtx x = rtx_alloc (check_code_attribute (m));\n-      record_attribute_use (&codes, x, 0, deferred_name);\n+      record_attribute_use (&codes, get_current_location (),\n+\t\t\t    x, 0, deferred_name);\n       return x;\n     }\n \n@@ -1639,8 +1657,8 @@ rtx_reader::read_rtx_code (const char *code_name)\n   c = read_skip_spaces ();\n   if (c == ':')\n     {\n-      read_name (&name);\n-      record_potential_iterator_use (&modes, return_rtx, 0, name.string);\n+      file_location loc = read_name (&name);\n+      record_potential_iterator_use (&modes, loc, return_rtx, 0, name.string);\n     }\n   else\n     unread_char (c);\n@@ -1862,6 +1880,7 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT\n \t\t|| GET_CODE (return_rtx) == DEFINE_INSN_AND_REWRITE))\n \t  {\n+\t    const char *old_stringbuf = stringbuf;\n \t    struct obstack *string_obstack = get_string_obstack ();\n \t    char line_name[20];\n \t    const char *read_md_filename = get_filename ();\n@@ -1875,6 +1894,7 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \t    sprintf (line_name, \":%d\", get_lineno ());\n \t    obstack_grow (string_obstack, line_name, strlen (line_name)+1);\n \t    stringbuf = XOBFINISH (string_obstack, char *);\n+\t    copy_md_ptr_loc (stringbuf, old_stringbuf);\n \t  }\n \n \t/* Find attr-names in the string.  */\n@@ -1946,10 +1966,13 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n     case 'i':\n     case 'n':\n     case 'p':\n-      /* Can be an iterator or an integer constant.  */\n-      read_name (&name);\n-      record_potential_iterator_use (&ints, return_rtx, idx, name.string);\n-      break;\n+      {\n+\t/* Can be an iterator or an integer constant.  */\n+\tfile_location loc = read_name (&name);\n+\trecord_potential_iterator_use (&ints, loc, return_rtx, idx,\n+\t\t\t\t       name.string);\n+\tbreak;\n+      }\n \n     case 'r':\n       read_name (&name);"}]}