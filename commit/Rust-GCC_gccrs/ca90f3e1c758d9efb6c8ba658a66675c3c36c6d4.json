{"sha": "ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E5MGYzZTFjNzU4ZDllZmI2YzhiYTY1OGE2NjY3NWMzYzM2YzZkNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-06-17T16:58:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-06-17T16:58:19Z"}, "message": "re PR c++/11105 ([3.3/3.4 regression of sorts] ICE in mangle_conv_op_name_for_type)\n\n\tPR c++/11105\n\t* cp-tree.h (DECL_CONV_FN_TYPE): New method.\n\t* mangle.c (struct globals): Remove internal_mangling_p.\n\t(write_unqualified_name): Use DECL_CONV_FN_TYPE.\n\t(write_template_parm): Don't write out the level number.\n\t(conv_type_names): New variable.\n\t(hash_type): New function.\n\t(compare_type): Likewise.\n\t(mangle_conv_op_name_for_type): Don't try to mangle conversion\n\toperator names.\n\t* search.c (lookup_conversion_operator): New function.\n\t(lookup_fnfields_1): Use it.\n\n\tPR c++/11105\n\t* g++.dg/abi/conv1.C: Remove it.\n\t* g++.dg/template/conv7.C: New test.\n\t* g++.dg/template/conv8.C: Likewise.\n\t* g++.old-deja/g++.ext/pretty2.C: Do not test __FUNCTION__ for a\n\tconversion operator.\n\nFrom-SVN: r68095", "tree": {"sha": "9158221fab15fe3ae9e6c048a33b2f599faa86c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9158221fab15fe3ae9e6c048a33b2f599faa86c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/comments", "author": null, "committer": null, "parents": [{"sha": "8207b189e50ec5350d3ab72b397ee139282b4e9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8207b189e50ec5350d3ab72b397ee139282b4e9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8207b189e50ec5350d3ab72b397ee139282b4e9d"}], "stats": {"total": 340, "additions": 210, "deletions": 130}, "files": [{"sha": "a3585fce330fc311379ded4825c7e9298d616aa2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -1,3 +1,18 @@\n+2003-06-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11105\n+\t* cp-tree.h (DECL_CONV_FN_TYPE): New method.\n+\t* mangle.c (struct globals): Remove internal_mangling_p.\n+\t(write_unqualified_name): Use DECL_CONV_FN_TYPE.\n+\t(write_template_parm): Don't write out the level number.\n+\t(conv_type_names): New variable.\n+\t(hash_type): New function.\n+\t(compare_type): Likewise.\n+\t(mangle_conv_op_name_for_type): Don't try to mangle conversion\n+\toperator names.\n+\t* search.c (lookup_conversion_operator): New function.\n+\t(lookup_fnfields_1): Use it.\n+\n 2003-06-17  Andreas Jaeger  <aj@suse.de>\n \n \t* except.c: Remove duplicate declaration of push_eh_cleanup."}, {"sha": "aeae2310ba844c2b57f1dd769bffe669f2f73599", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -1856,6 +1856,11 @@ struct lang_decl GTY(())\n #define DECL_CONV_FN_P(NODE) \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)))\n \n+/* If FN is a conversion operator, the type to which it converts.\n+   Otherwise, NULL_TREE.  */\n+#define DECL_CONV_FN_TYPE(FN) \\\n+  (DECL_CONV_FN_P (FN) ? TREE_TYPE (DECL_NAME (FN)) : NULL_TREE)\n+\n /* Nonzero if NODE, which is a TEMPLATE_DECL, is a template\n    conversion operator to a type dependent on the innermost template\n    args.  */"}, {"sha": "4c5366251995a9c3aea02c49221a68e9b29982fd", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -102,11 +102,6 @@ static struct globals\n   /* The entity that is being mangled.  */\n   tree entity;\n \n-  /* We are mangling an internal symbol. It is important to keep those\n-     involving template parmeters distinct by distinguishing their level\n-     and, for non-type parms, their type.  */\n-  bool internal_mangling_p;\n-\n   /* True if the mangling will be different in a future version of the\n      ABI.  */\n   bool need_abi_warning;\n@@ -1006,7 +1001,7 @@ write_unqualified_name (const tree decl)\n \t  type = TREE_TYPE (fn_type);\n \t}\n       else\n-\ttype = TREE_TYPE (DECL_NAME (decl));\n+\ttype = DECL_CONV_FN_TYPE (decl);\n       write_conversion_operator_name (type);\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (decl))\n@@ -2250,15 +2245,6 @@ write_template_param (const tree parm)\n   if (parm_index > 0)\n     write_unsigned_number (parm_index - 1);\n   write_char ('_');\n-  if (G.internal_mangling_p)\n-    {\n-      if (parm_level > 0)\n-\twrite_unsigned_number (parm_level - 1);\n-      write_char ('_');\n-      if (parm_type)\n-\twrite_type (parm_type);\n-      write_char ('_');\n-    }\n }\n \n /*  <template-template-param>\n@@ -2600,40 +2586,51 @@ mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n   return get_identifier (result);\n }\n \n+/* This hash table maps TYPEs to the IDENTIFIER for a conversion\n+   operator to TYPE.  The nodes are TREE_LISTs whose TREE_PURPOSE is\n+   the TYPE and whose TREE_VALUE is the IDENTIFIER.  */\n+\n+static GTY ((param_is (union tree_node))) htab_t conv_type_names;\n+\n+/* Hash a node (VAL1) in the table.  */\n+\n+static hashval_t\n+hash_type (const void *val)\n+{\n+  return htab_hash_pointer (TREE_PURPOSE (*((tree *) val)));\n+}\n+\n+/* Compare VAL1 (a node in the table) with VAL2 (a TYPE).  */\n+\n+static int\n+compare_type (const void *val1, const void *val2)\n+{\n+  return TREE_PURPOSE ((tree) val1) == (tree) val2;\n+}\n+\n /* Return an identifier for the mangled unqualified name for a\n    conversion operator to TYPE.  This mangling is not specified by the\n    ABI spec; it is only used internally.  */\n \n tree\n mangle_conv_op_name_for_type (const tree type)\n {\n+  void **slot;\n   tree identifier;\n-  const char *mangled_type;\n-  char *op_name;\n+  char buffer[64];\n \n-  /* Build the internal mangling for TYPE.  */\n-  G.internal_mangling_p = true;\n-  mangled_type = mangle_type_string (type);\n-  G.internal_mangling_p = false;\n-  \n-  /* Allocate a temporary buffer for the complete name.  */\n-  op_name = concat (\"operator \", mangled_type, NULL);\n-  /* Find or create an identifier.  */\n-  identifier = get_identifier (op_name);\n-  /* Done with the temporary buffer.  */\n-  free (op_name);\n-\n-  /* It had better be a unique mangling for the type.  */\n-  if (IDENTIFIER_TYPENAME_P (identifier)\n-      && !same_type_p (type, TREE_TYPE (identifier)))\n-    {\n-      /* In G++ 3.2, the name mangling scheme was ambiguous.  In later\n-\t versions of the ABI, this problem has been fixed.  */\n-      if (abi_version_at_least (2))\n-\tabort ();\n-      error (\"due to a defect in the G++ 3.2 ABI, G++ has assigned the \"\n-\t     \"same mangled name to two different types\");\n-    }\n+  if (conv_type_names == NULL) \n+    conv_type_names = htab_create_ggc (31, &hash_type, &compare_type, NULL);\n+\n+  slot = htab_find_slot_with_hash (conv_type_names, type, \n+\t\t\t\t   htab_hash_pointer (type), INSERT);\n+  if (*slot)\n+    return TREE_VALUE ((tree) *slot);\n+\n+  /* Create a unique name corresponding to TYPE.  */\n+  sprintf (buffer, \"operator %d\\n\", htab_elements (conv_type_names));\n+  identifier = get_identifier (buffer);\n+  *slot = build_tree_list (type, identifier);\n   \n   /* Set bits on the identifier so we know later it's a conversion.  */\n   IDENTIFIER_OPNAME_P (identifier) = 1;"}, {"sha": "3df6f733f74c01bd45674239499bf9b50b0b077d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 119, "deletions": 74, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -1338,99 +1338,144 @@ lookup_fnfields (tree xbasetype, tree name, int protect)\n   return rval;\n }\n \n+/* Return the index in the CLASSTYPE_METHOD_VEC for CLASS_TYPE\n+   corresponding to \"operator TYPE ()\", or -1 if there is no such\n+   operator.  Only CLASS_TYPE itself is searched; this routine does\n+   not scan the base classes of CLASS_TYPE.  */\n+\n+static int\n+lookup_conversion_operator (tree class_type, tree type)\n+{\n+  int pass;\n+  int i;\n+\n+  tree methods = CLASSTYPE_METHOD_VEC (class_type);\n+\n+  for (pass = 0; pass < 2; ++pass)\n+    for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+\t i < TREE_VEC_LENGTH (methods);\n+\t ++i)\n+      {\n+\ttree fn = TREE_VEC_ELT (methods, i);\n+\t/* The size of the vector may have some unused slots at the\n+\t   end.  */\n+\tif (!fn)\n+\t  break;\n+\n+\t/* All the conversion operators come near the beginning of the\n+\t   class.  Therefore, if FN is not a conversion operator, there\n+\t   is no matching conversion operator in CLASS_TYPE.  */\n+\tfn = OVL_CURRENT (fn);\n+\tif (!DECL_CONV_FN_P (fn))\n+\t  break;\n+\t\n+\tif (pass == 0)\n+\t  {\n+\t    /* On the first pass we only consider exact matches.  If\n+\t       the types match, this slot is the one where the right\n+\t       conversion operators can be found.  */\n+\t    if (TREE_CODE (fn) != TEMPLATE_DECL\n+\t\t&& same_type_p (DECL_CONV_FN_TYPE (fn), type))\n+\t      return i;\n+\t  }\n+\telse\n+\t  {\n+\t    /* On the second pass we look for template conversion\n+\t       operators.  It may be possible to instantiate the\n+\t       template to get the type desired.  All of the template\n+\t       conversion operators share a slot.  By looking for\n+\t       templates second we ensure that specializations are\n+\t       preferred over templates.  */\n+\t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t      return i;\n+\t  }\n+      }\n+\n+  return -1;\n+}\n+\n /* TYPE is a class type. Return the index of the fields within\n    the method vector with name NAME, or -1 is no such field exists.  */\n \n int\n lookup_fnfields_1 (tree type, tree name)\n {\n-  tree method_vec = (CLASS_TYPE_P (type)\n-\t\t     ? CLASSTYPE_METHOD_VEC (type)\n-\t\t     : NULL_TREE);\n+  tree method_vec;\n+  tree *methods;\n+  tree tmp;\n+  int i;\n+  int len;\n \n-  if (method_vec != 0)\n-    {\n-      register int i;\n-      register tree *methods = &TREE_VEC_ELT (method_vec, 0);\n-      int len = TREE_VEC_LENGTH (method_vec);\n-      tree tmp;\n+  if (!CLASS_TYPE_P (type))\n+    return -1;\n \n-#ifdef GATHER_STATISTICS\n-      n_calls_lookup_fnfields_1++;\n-#endif /* GATHER_STATISTICS */\n+  method_vec = CLASSTYPE_METHOD_VEC (type);\n+\n+  if (!method_vec)\n+    return -1;\n+\n+  methods = &TREE_VEC_ELT (method_vec, 0);\n+  len = TREE_VEC_LENGTH (method_vec);\n \n-      /* Constructors are first...  */\n-      if (name == ctor_identifier)\n-\treturn (methods[CLASSTYPE_CONSTRUCTOR_SLOT] \n-\t\t? CLASSTYPE_CONSTRUCTOR_SLOT : -1);\n-      /* and destructors are second.  */\n-      if (name == dtor_identifier)\n-\treturn (methods[CLASSTYPE_DESTRUCTOR_SLOT]\n-\t\t? CLASSTYPE_DESTRUCTOR_SLOT : -1);\n-\n-      for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-\t   i < len && methods[i]; \n-\t   ++i)\n-\t{\n #ifdef GATHER_STATISTICS\n-\t  n_outer_fields_searched++;\n+  n_calls_lookup_fnfields_1++;\n #endif /* GATHER_STATISTICS */\n \n-\t  tmp = OVL_CURRENT (methods[i]);\n-\t  if (DECL_NAME (tmp) == name)\n-\t    return i;\n-\n-\t  /* If the type is complete and we're past the conversion ops,\n-\t     switch to binary search.  */\n-\t  if (! DECL_CONV_FN_P (tmp)\n-\t      && COMPLETE_TYPE_P (type))\n-\t    {\n-\t      int lo = i + 1, hi = len;\n+  /* Constructors are first...  */\n+  if (name == ctor_identifier)\n+    return (methods[CLASSTYPE_CONSTRUCTOR_SLOT] \n+\t    ? CLASSTYPE_CONSTRUCTOR_SLOT : -1);\n+  /* and destructors are second.  */\n+  if (name == dtor_identifier)\n+    return (methods[CLASSTYPE_DESTRUCTOR_SLOT]\n+\t    ? CLASSTYPE_DESTRUCTOR_SLOT : -1);\n+  if (IDENTIFIER_TYPENAME_P (name))\n+    return lookup_conversion_operator (type, TREE_TYPE (name));\n+\n+  /* Skip the conversion operators.  */\n+  i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+  while (i < len && methods[i] && DECL_CONV_FN_P (OVL_CURRENT (methods[i])))\n+    i++;\n+\n+  /* If the type is complete, use binary search.  */\n+  if (COMPLETE_TYPE_P (type))\n+    {\n+      int lo = i;\n+      int hi = len;\n \n-\t      while (lo < hi)\n-\t\t{\n-\t\t  i = (lo + hi) / 2;\n+      while (lo < hi)\n+\t{\n+\t  i = (lo + hi) / 2;\n \n #ifdef GATHER_STATISTICS\n-\t\t  n_outer_fields_searched++;\n+\t  n_outer_fields_searched++;\n #endif /* GATHER_STATISTICS */\n \n-\t\t  tmp = methods[i];\n-\t\t  /* This slot may be empty; we allocate more slots\n-\t\t     than we need.  In that case, the entry we're\n-\t\t     looking for is closer to the beginning of the\n-\t\t     list. */\n-\t\t  if (tmp)\n-\t\t    tmp = DECL_NAME (OVL_CURRENT (tmp));\n-\t\t  if (!tmp || tmp > name)\n-\t\t    hi = i;\n-\t\t  else if (tmp < name)\n-\t\t    lo = i + 1;\n-\t\t  else\n-\t\t    return i;\n-\t\t}\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* If we didn't find it, it might have been a template\n-\t conversion operator to a templated type.  If there are any,\n-\t such template conversion operators will all be overloaded on\n-\t the first conversion slot.  (Note that we don't look for this\n-\t case above so that we will always find specializations\n-\t first.)  */\n-      if (IDENTIFIER_TYPENAME_P (name)) \n-\t{\n-\t  i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n-\t  if (i < len && methods[i])\n-\t    {\n-\t      tmp = OVL_CURRENT (methods[i]);\n-\t      if (TREE_CODE (tmp) == TEMPLATE_DECL\n-\t\t  && DECL_TEMPLATE_CONV_FN_P (tmp))\n-\t\treturn i;\n-\t    }\n+\t  tmp = methods[i];\n+\t  /* This slot may be empty; we allocate more slots than we\n+\t     need.  In that case, the entry we're looking for is\n+\t     closer to the beginning of the list. */\n+\t  if (tmp)\n+\t    tmp = DECL_NAME (OVL_CURRENT (tmp));\n+\t  if (!tmp || tmp > name)\n+\t    hi = i;\n+\t  else if (tmp < name)\n+\t    lo = i + 1;\n+\t  else\n+\t    return i;\n \t}\n     }\n+  else\n+    for (; i < len && methods[i]; ++i)\n+      {\n+#ifdef GATHER_STATISTICS\n+\tn_outer_fields_searched++;\n+#endif /* GATHER_STATISTICS */\n+\t\n+\ttmp = OVL_CURRENT (methods[i]);\n+\tif (DECL_NAME (tmp) == name)\n+\t  return i;\n+      }\n \n   return -1;\n }"}, {"sha": "9c1fcd25707bec08864805d69e166f4289a50d36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -1,3 +1,12 @@\n+2003-06-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11105\n+\t* g++.dg/abi/conv1.C: Remove it.\n+\t* g++.dg/template/conv7.C: New test.\n+\t* g++.dg/template/conv8.C: Likewise.\n+\t* g++.old-deja/g++.ext/pretty2.C: Do not test __FUNCTION__ for a\n+\tconversion operator.\n+\n 2003-06-17  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.dg/compat/compat-common.h (DEBUG_INIT): New."}, {"sha": "fdedea20b13a72395e7bd2023cba35460153df2d", "filename": "gcc/testsuite/g++.dg/abi/conv1.C", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8207b189e50ec5350d3ab72b397ee139282b4e9d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fconv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8207b189e50ec5350d3ab72b397ee139282b4e9d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fconv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fconv1.C?ref=8207b189e50ec5350d3ab72b397ee139282b4e9d", "patch": "@@ -1,13 +0,0 @@\n-// { dg-options \"-fabi-version=1\" }\n-\n-template<class T1>\n-struct A {\n-  typedef typename T1::X X;\n-  operator X() const;\n-};\n-\n-template <class T0, class T1 >\n-struct B {\n-  typedef typename T1::X X;\n-  operator X() const; // { dg-error \"\" }\n-};"}, {"sha": "86758b3623d4ed2a952bead4f028cbf6028840db", "filename": "gcc/testsuite/g++.dg/template/conv7.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv7.C?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options \"-fabi-version=0\" }\n+\n+template <typename T> struct S {\n+    struct I{};\n+    operator I* ();\n+};\n+\n+template <typename T> struct S2 : S<T> {\n+    operator typename S<T>::I* ();\n+};\n+\n+template struct S2<int>;"}, {"sha": "96f3b98651693cb7a2472795d519d3b807ca0c8e", "filename": "gcc/testsuite/g++.dg/template/conv8.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv8.C?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options \"-fabi-version=1\" }\n+\n+template <typename T> struct S {\n+    struct I{};\n+    operator I* ();\n+};\n+\n+template <typename T> struct S2 : S<T> {\n+    operator typename S<T>::I* ();\n+};\n+\n+template struct S2<int>;"}, {"sha": "c309dc8d62db5ace537ba75150c7109a6cf179d4", "filename": "gcc/testsuite/g++.old-deja/g++.ext/pretty2.C", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ext%2Fpretty2.C?ref=ca90f3e1c758d9efb6c8ba658a66675c3c36c6d4", "patch": "@@ -1,5 +1,5 @@\n // { dg-do run  }\n-// Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+// Copyright (C) 1999, 2000, 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 21 Nov 1999 <nathan@acm.org>\n \n // make sure __FUNCTION__ and __PRETTY_FUNCTION__ work in member functions\n@@ -68,8 +68,6 @@ X::operator int ()\n   printf (\"__FUNCTION__ %s\\n\", function);\n   printf (\"__PRETTY_FUNCTION__ %s\\n\", pretty);\n   \n-  if (strcmp (function, \"operator i\"))\n-    bad = true;\n   if (strcmp (pretty, \"X::operator int()\"))\n     bad = true;\n   return 0;"}]}