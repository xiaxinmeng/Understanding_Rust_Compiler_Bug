{"sha": "f645e9a2bfbb081915758e0538164bd7c65d6def", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY0NWU5YTJiZmJiMDgxOTE1NzU4ZTA1MzgxNjRiZDdjNjVkNmRlZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-07-12T12:07:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-07-12T12:07:35Z"}, "message": "re PR tree-optimization/40585 (tracer duplicates blocks w/o adjusting EH tree)\n\n\n\tPR tree-optimization/40585\n\t* except.c (expand_resx_expr): When there already is resume\n\tinstruction, produce linked list.\n\t(build_post_landing_pads): Assert that resume is empty.\n\t(connect_post_landing_pads): Handle resume lists.\n\t(dump_eh_tree): Dump resume list.\n\nFrom-SVN: r149530", "tree": {"sha": "664bba0151c5567ef526a334b8502130112e2e2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/664bba0151c5567ef526a334b8502130112e2e2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f645e9a2bfbb081915758e0538164bd7c65d6def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f645e9a2bfbb081915758e0538164bd7c65d6def", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f645e9a2bfbb081915758e0538164bd7c65d6def", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f645e9a2bfbb081915758e0538164bd7c65d6def/comments", "author": null, "committer": null, "parents": [{"sha": "06066f92aaea9e9b0fff53a693b300bb9aa1121a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06066f92aaea9e9b0fff53a693b300bb9aa1121a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06066f92aaea9e9b0fff53a693b300bb9aa1121a"}], "stats": {"total": 116, "additions": 75, "deletions": 41}, "files": [{"sha": "89edef15925f4f85cb05ab25276425eb1e6f0711", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f645e9a2bfbb081915758e0538164bd7c65d6def/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f645e9a2bfbb081915758e0538164bd7c65d6def/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f645e9a2bfbb081915758e0538164bd7c65d6def", "patch": "@@ -1,3 +1,12 @@\n+2009-07-12  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR tree-optimization/40585\n+\t* except.c (expand_resx_expr): When there already is resume\n+\tinstruction, produce linked list.\n+\t(build_post_landing_pads): Assert that resume is empty.\n+\t(connect_post_landing_pads): Handle resume lists.\n+\t(dump_eh_tree): Dump resume list.\n+\n 2009-07-12  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-parloops.c (loop_parallel_p): Call vect_is_simple_reduction"}, {"sha": "06e5529dddc09a9b108e0419c38e0612256c0378", "filename": "gcc/except.c", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f645e9a2bfbb081915758e0538164bd7c65d6def/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f645e9a2bfbb081915758e0538164bd7c65d6def/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=f645e9a2bfbb081915758e0538164bd7c65d6def", "patch": "@@ -440,12 +440,16 @@ void\n expand_resx_expr (tree exp)\n {\n   int region_nr = TREE_INT_CST_LOW (TREE_OPERAND (exp, 0));\n+  rtx insn;\n   struct eh_region_d *reg = VEC_index (eh_region,\n \t\t\t\t       cfun->eh->region_array, region_nr);\n \n-  gcc_assert (!reg->resume);\n   do_pending_stack_adjust ();\n-  reg->resume = emit_jump_insn (gen_rtx_RESX (VOIDmode, region_nr));\n+  insn = emit_jump_insn (gen_rtx_RESX (VOIDmode, region_nr));\n+  if (reg->resume)\n+    reg->resume = gen_rtx_INSN_LIST (VOIDmode, insn, reg->resume);\n+  else\n+    reg->resume = insn;\n   emit_barrier ();\n }\n \n@@ -2012,6 +2016,7 @@ build_post_landing_pads (void)\n \t  /* We delay the generation of the _Unwind_Resume until we generate\n \t     landing pads.  We emit a marker here so as to get good control\n \t     flow data in the meantime.  */\n+\t  gcc_assert (!region->resume);\n \t  region->resume\n \t    = emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n \t  emit_barrier ();\n@@ -2040,6 +2045,7 @@ build_post_landing_pads (void)\n \t  /* We delay the generation of the _Unwind_Resume until we generate\n \t     landing pads.  We emit a marker here so as to get good control\n \t     flow data in the meantime.  */\n+\t  gcc_assert (!region->resume);\n \t  region->resume\n \t    = emit_jump_insn (gen_rtx_RESX (VOIDmode, region->region_number));\n \t  emit_barrier ();\n@@ -2080,6 +2086,7 @@ connect_post_landing_pads (void)\n       struct eh_region_d *outer;\n       rtx seq;\n       rtx barrier;\n+      rtx resume_list;\n \n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n       /* Mind we don't process a region more than once.  */\n@@ -2088,54 +2095,63 @@ connect_post_landing_pads (void)\n \n       /* If there is no RESX, or it has been deleted by flow, there's\n \t nothing to fix up.  */\n-      if (! region->resume || INSN_DELETED_P (region->resume))\n+      if (! region->resume)\n \tcontinue;\n \n       /* Search for another landing pad in this function.  */\n       for (outer = region->outer; outer ; outer = outer->outer)\n \tif (outer->post_landing_pad)\n \t  break;\n \n-      start_sequence ();\n-\n-      if (outer)\n+      for (resume_list = region->resume; resume_list;\n+      \t   resume_list = (GET_CODE (resume_list) == INSN_LIST\n+\t\t\t  ? XEXP (resume_list, 1) : NULL_RTX))\n \t{\n-\t  edge e;\n-\t  basic_block src, dest;\n-\n-\t  emit_jump (outer->post_landing_pad);\n-\t  src = BLOCK_FOR_INSN (region->resume);\n-\t  dest = BLOCK_FOR_INSN (outer->post_landing_pad);\n-\t  while (EDGE_COUNT (src->succs) > 0)\n-\t    remove_edge (EDGE_SUCC (src, 0));\n-\t  e = make_edge (src, dest, 0);\n-\t  e->probability = REG_BR_PROB_BASE;\n-\t  e->count = src->count;\n-\t}\n-      else\n-\t{\n-\t  emit_library_call (unwind_resume_libfunc, LCT_THROW,\n-\t\t\t     VOIDmode, 1, crtl->eh.exc_ptr, ptr_mode);\n-\n-\t  /* What we just emitted was a throwing libcall, so it got a\n-\t     barrier automatically added after it.  If the last insn in\n-\t     the libcall sequence isn't the barrier, it's because the\n-\t     target emits multiple insns for a call, and there are insns\n-\t     after the actual call insn (which are redundant and would be\n-\t     optimized away).  The barrier is inserted exactly after the\n-\t     call insn, so let's go get that and delete the insns after\n-\t     it, because below we need the barrier to be the last insn in\n-\t     the sequence.  */\n-\t  delete_insns_since (NEXT_INSN (last_call_insn ()));\n-\t}\n+\t  rtx resume = (GET_CODE (resume_list) == INSN_LIST\n+\t\t\t? XEXP (resume_list, 0) : resume_list);\n+          if (INSN_DELETED_P (resume))\n+\t    continue;\n+\t  start_sequence ();\n \n-      seq = get_insns ();\n-      end_sequence ();\n-      barrier = emit_insn_before (seq, region->resume);\n-      /* Avoid duplicate barrier.  */\n-      gcc_assert (BARRIER_P (barrier));\n-      delete_insn (barrier);\n-      delete_insn (region->resume);\n+\t  if (outer)\n+\t    {\n+\t      edge e;\n+\t      basic_block src, dest;\n+\n+\t      emit_jump (outer->post_landing_pad);\n+\t      src = BLOCK_FOR_INSN (resume);\n+\t      dest = BLOCK_FOR_INSN (outer->post_landing_pad);\n+\t      while (EDGE_COUNT (src->succs) > 0)\n+\t\tremove_edge (EDGE_SUCC (src, 0));\n+\t      e = make_edge (src, dest, 0);\n+\t      e->probability = REG_BR_PROB_BASE;\n+\t      e->count = src->count;\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_library_call (unwind_resume_libfunc, LCT_THROW,\n+\t\t\t\t VOIDmode, 1, crtl->eh.exc_ptr, ptr_mode);\n+\n+\t      /* What we just emitted was a throwing libcall, so it got a\n+\t\t barrier automatically added after it.  If the last insn in\n+\t\t the libcall sequence isn't the barrier, it's because the\n+\t\t target emits multiple insns for a call, and there are insns\n+\t\t after the actual call insn (which are redundant and would be\n+\t\t optimized away).  The barrier is inserted exactly after the\n+\t\t call insn, so let's go get that and delete the insns after\n+\t\t it, because below we need the barrier to be the last insn in\n+\t\t the sequence.  */\n+\t      delete_insns_since (NEXT_INSN (last_call_insn ()));\n+\t    }\n+\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\t  barrier = emit_insn_before (seq, resume);\n+\t  /* Avoid duplicate barrier.  */\n+\t  gcc_assert (BARRIER_P (barrier));\n+\t  delete_insn (barrier);\n+\t  delete_insn (resume);\n+\t}\n \n       /* ??? From tree-ssa we can wind up with catch regions whose\n \t label is not instantiated, but whose resx is present.  Now\n@@ -4419,6 +4435,15 @@ dump_eh_tree (FILE * out, struct function *fun)\n \t}\n       if (i->resume)\n \t{\n+\t  rtx resume_list = i->resume;\n+          fprintf (out, \" resume:\");\n+\t  while (GET_CODE (resume_list) == INSN_LIST)\n+\t    {\n+\t      fprintf (out, \"%i,\", INSN_UID (XEXP (resume_list, 0)));\n+\t      if (NOTE_P (XEXP (resume_list, 0)))\n+\t\tfprintf (out, \" (deleted)\");\n+\t      resume_list = XEXP (resume_list, 1);\n+\t    }\n           fprintf (out, \" resume:%i\", INSN_UID (i->resume));\n \t  if (NOTE_P (i->resume))\n \t    fprintf (out, \" (deleted)\");"}]}