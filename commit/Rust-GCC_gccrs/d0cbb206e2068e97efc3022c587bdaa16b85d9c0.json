{"sha": "d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjYmIyMDZlMjA2OGU5N2VmYzMwMjJjNTg3YmRhYTE2Yjg1ZDljMA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-12-09T18:54:47Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-12-09T18:54:47Z"}, "message": "re PR libfortran/88411 (Random crashes for ASYNCHRONOUS writes (bad locking?))\n\n2018-12-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/88411\n\t* io/transfer.c (dta_transfer_init): Do not treat as an\n\tasynchronous statement unless the statement has\n\tASYNCHRONOUS=\"YES\".\n\t(st_write_done): Likewise.\n\t(st_read_done): Do not perform async_wait for synchronous I/O\n\ton an async unit.\n\t(st_read_done): Likewise.\n\n2018-12-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/88411\n\t* testsuite/libgomp.fortran/async_io_8.f90: New test.\n\nFrom-SVN: r266929", "tree": {"sha": "73a313fa1bb5731bfb41b304166e42efd23d89d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73a313fa1bb5731bfb41b304166e42efd23d89d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/comments", "author": null, "committer": null, "parents": [{"sha": "59cd1934df18511835b88e36edf0327db5db738b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59cd1934df18511835b88e36edf0327db5db738b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59cd1934df18511835b88e36edf0327db5db738b"}], "stats": {"total": 66, "additions": 54, "deletions": 12}, "files": [{"sha": "7e56fead3a5cb47d555b024dd73be67b821255b6", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "patch": "@@ -1,3 +1,14 @@\n+2018-12-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/88411\n+\t* io/transfer.c (dta_transfer_init): Do not treat as an\n+\tasynchronous statement unless the statement has\n+\tASYNCHRONOUS=\"YES\".\n+\t(st_write_done): Likewise.\n+\t(st_read_done): Do not perform async_wait for synchronous I/O\n+\ton an async unit.\n+\t(st_read_done): Likewise.\n+\n 2018-12-02  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/88137"}, {"sha": "6fcec8a479e46a5e4d79687640c83690a0d9800a", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "patch": "@@ -3189,7 +3189,7 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \t}\n     }\n \n-  if (au)\n+  if (au && dtp->u.p.async)\n     {\n       NOTE (\"enqueue_data_transfer\");\n       enqueue_data_transfer_init (au, dtp, read_flag);\n@@ -4313,11 +4313,8 @@ st_read_done (st_parameter_dt *dtp)\n \t    *dtp->id = enqueue_done_id (dtp->u.p.current_unit->au, AIO_READ_DONE);  \n \t  else\n \t    {\n-\t      enqueue_done (dtp->u.p.current_unit->au, AIO_READ_DONE);\n-\t      /* An asynchronous unit without ASYNCHRONOUS=\"YES\" - make this\n-\t\t synchronous by performing a wait operation.  */\n-\t      if (!dtp->u.p.async)\n-\t\tasync_wait (&dtp->common, dtp->u.p.current_unit->au);\n+\t      if (dtp->u.p.async)\n+\t\tenqueue_done (dtp->u.p.current_unit->au, AIO_READ_DONE);\n \t    }\n \t}\n       else\n@@ -4401,18 +4398,17 @@ st_write_done (st_parameter_dt *dtp)\n {\n   if (dtp->u.p.current_unit)\n     {\n-      if (dtp->u.p.current_unit->au)\n+      if (dtp->u.p.current_unit->au && dtp->u.p.async)\n \t{\n \t  if (dtp->common.flags & IOPARM_DT_HAS_ID)\n \t    *dtp->id = enqueue_done_id (dtp->u.p.current_unit->au,\n \t\t\t\t\tAIO_WRITE_DONE);\n \t  else\n \t    {\n-\t      enqueue_done (dtp->u.p.current_unit->au, AIO_WRITE_DONE);\n-\t      /* An asynchronous unit without ASYNCHRONOUS=\"YES\" - make this\n-\t\t synchronous by performing a wait operation.  */\n-\t      if (!dtp->u.p.async)\n-\t\tasync_wait (&dtp->common, dtp->u.p.current_unit->au);\n+\t      /* We perform synchronous I/O on an asynchronous unit, so no need\n+\t\t to enqueue AIO_READ_DONE.  */\n+\t      if (dtp->u.p.async)\n+\t\tenqueue_done (dtp->u.p.current_unit->au, AIO_WRITE_DONE);\n \t    }\n \t}\n       else"}, {"sha": "13ec674809a4261e34a13ff6918f003139f54769", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "patch": "@@ -1,3 +1,8 @@\n+2018-12-09  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/88411\n+\t* testsuite/libgomp.fortran/async_io_8.f90: New test.\n+\n 2018-12-09  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "f5ae93dc3a83bb99d652138b727439191c6c17ab", "filename": "libgomp/testsuite/libgomp.fortran/async_io_8.f90", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0cbb206e2068e97efc3022c587bdaa16b85d9c0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fasync_io_8.f90?ref=d0cbb206e2068e97efc3022c587bdaa16b85d9c0", "patch": "@@ -0,0 +1,30 @@\n+! { dg-do run }\n+! PR libfortran/88411\n+! This used to generate errors due to a mixup of\n+! synchronous and asynchronous execution.\n+! Test case by Harald Anlauf.\n+program gfcbug153\n+  implicit none\n+  integer :: iu, irecl\n+  real    :: a(100,20), b(1,3000)\n+  iu = 10\n+  a  = 0.\n+  b  = 0.\n+  inquire (iolength = irecl) a\n+  open (iu, file=\"file1.dat\", access='direct', &\n+       asynchronous='yes', &\n+       recl=irecl)\n+  write(iu, rec=1) a(:,:)\n+  write(iu, rec=2) a(:,:)\n+  write(iu, rec=3) a(:,:)\n+  close (iu,status=\"delete\")\n+\n+  inquire (iolength = irecl) b\n+  open (iu, file=\"file2.dat\", access='direct', &\n+       asynchronous='yes', &\n+       recl=irecl)\n+  write(iu, rec=1) b(:,:)\n+  write(iu, rec=2) b(:,:)\n+  write(iu, rec=3) b(:,:)\n+  close (iu,status=\"delete\")\n+end program"}]}