{"sha": "878885b41142dd76e858b1f705bd31f357a5acc5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc4ODg1YjQxMTQyZGQ3NmU4NThiMWY3MDViZDMxZjM1N2E1YWNjNQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-03-15T22:03:19Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-03-15T22:03:19Z"}, "message": "[multiple changes]\n\n2000-03-15  Tom Tromey  <tromey@cygnus.com>\n\n\t* java/io/natFileDescriptorWin32.cc (winerr): Now static.\n\n\t* prims.cc (win32_exception_handler): Reformatted.\n\n\t* include/win32-threads.h (_Jv_HaveCondDestroy): New define.\n\t(_Jv_HaveMutexDestroy): Likewise.\n\n2000-03-15 Jon Beniston <jb7216@bristol.ac.uk>\n\n\t* java/io/natFileDescriptorWin32.cc: New file.\n\t* java/io/natFileWin32.cc: New file.\n\t* java/net/natInetAddress.cc: Added conditional inclusion of\n\tWindows / Winsock headers.\n\t* java/net/natPlainDatagramSocketImpl.cc: Added conditional\n\tinclusion of Windows / Winsock headers.\n\t* java/net/natPlainSocketImpl.cc: Added conditional inclusion of\n\tWindows / Winsock headers.\n\t* include/win32-signal.h: New file.\n\t* include/win32-threads.h: New file.\n\t* win32-threads.cc: New file.\n\t* exception.cc (win32_get_restart_frame): New function.\n\t* prims.cc (win32_exception_handler): New function.\n\t(main_init) Performs Winsock initialisation.\n\t(main_init) Installs exeception handler.\n\nFrom-SVN: r32567", "tree": {"sha": "6ff411e4ce4a6ce8717905d98f2d63b7479a6539", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ff411e4ce4a6ce8717905d98f2d63b7479a6539"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/878885b41142dd76e858b1f705bd31f357a5acc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878885b41142dd76e858b1f705bd31f357a5acc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/878885b41142dd76e858b1f705bd31f357a5acc5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/878885b41142dd76e858b1f705bd31f357a5acc5/comments", "author": null, "committer": null, "parents": [{"sha": "1a7b4c697c6ea7b132db9fdb84d3c9ff97c48e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a7b4c697c6ea7b132db9fdb84d3c9ff97c48e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a7b4c697c6ea7b132db9fdb84d3c9ff97c48e19"}], "stats": {"total": 1033, "additions": 1031, "deletions": 2}, "files": [{"sha": "53012d97d780a5458b1ae3d61989c26823110288", "filename": "libjava/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -1,3 +1,30 @@\n+2000-03-15  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/io/natFileDescriptorWin32.cc (winerr): Now static.\n+\n+\t* prims.cc (win32_exception_handler): Reformatted.\n+\n+\t* include/win32-threads.h (_Jv_HaveCondDestroy): New define.\n+\t(_Jv_HaveMutexDestroy): Likewise.\n+\n+2000-03-15 Jon Beniston <jb7216@bristol.ac.uk>\n+\n+\t* java/io/natFileDescriptorWin32.cc: New file.\n+\t* java/io/natFileWin32.cc: New file.\n+\t* java/net/natInetAddress.cc: Added conditional inclusion of\n+\tWindows / Winsock headers.\n+\t* java/net/natPlainDatagramSocketImpl.cc: Added conditional\n+\tinclusion of Windows / Winsock headers.\n+\t* java/net/natPlainSocketImpl.cc: Added conditional inclusion of\n+\tWindows / Winsock headers.\n+\t* include/win32-signal.h: New file.\n+\t* include/win32-threads.h: New file.\n+\t* win32-threads.cc: New file.\n+\t* exception.cc (win32_get_restart_frame): New function.\n+\t* prims.cc (win32_exception_handler): New function.\n+\t(main_init) Performs Winsock initialisation.\n+\t(main_init) Installs exeception handler.\n+\n 2000-03-14  Tom Tromey  <tromey@cygnus.com>\n \n \t* jni.cc (mangled_name): Fixed assertion."}, {"sha": "30ef55c078cdd673b11400ef66050dfe71966611", "filename": "libjava/exception.cc", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -37,7 +37,7 @@ extern \"C\" void __throw () __attribute__ ((__noreturn__));\n extern \"C\" void __sjthrow () __attribute__ ((__noreturn__));\n extern \"C\" short __get_eh_table_version (void *table);\n extern \"C\" short __get_eh_table_language (void *table);\n-\n+extern \"C\" void *__get_eh_context ();\n \n extern \"C\" void *\n _Jv_type_matcher (java_eh_info *info, void* match_info, \n@@ -161,3 +161,36 @@ _Jv_Throw (void *value)\n   __throw ();\n #endif\n }\n+\n+#ifdef USE_WIN32_SIGNALLING\n+\n+// This is a mangled version of _Jv_Throw and __sjthrow except\n+// rather than calling longjmp, it returns a pointer to the jmp buffer\n+\n+extern \"C\" int *\n+win32_get_restart_frame (void *value)\n+{\n+  struct eh_context *eh = (struct eh_context *)__get_eh_context ();\n+  void ***dhc = &eh->dynamic_handler_chain;\n+ \n+  java_eh_info *ehinfo = *(__get_eh_info ());\n+  if (ehinfo == NULL)\n+    {\n+      _Jv_eh_alloc ();\n+      ehinfo = *(__get_eh_info ());\n+    }\n+  ehinfo->eh_info.match_function = (__eh_matcher) _Jv_type_matcher;\n+  ehinfo->eh_info.language = EH_LANG_Java;\n+  ehinfo->eh_info.version = 1;\n+  ehinfo->value = value;\n+\n+  // FIXME: Run clean ups?\n+\n+  int *jmpbuf = (int*)&(*dhc)[2];\n+\n+  *dhc = (void**)(*dhc)[0];\n+\n+  return  jmpbuf;\n+}\n+\n+#endif /* USE_WIN32_SIGNALLING */"}, {"sha": "b4a60be880863d97d9d729e25fc28f160610b2ee", "filename": "libjava/include/win32-signal.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Finclude%2Fwin32-signal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Finclude%2Fwin32-signal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-signal.h?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -0,0 +1,43 @@\n+// win32-signal.h - Catch runtime signals and turn them into exceptions.\n+\n+/* Copyright (C) 1998, 1999  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Exception handling is done totally differently on Win32 this stuff\n+// just keeps it compatible\n+\n+#ifndef JAVA_SIGNAL_H\n+#define JAVA_SIGNAL_H 1\n+\n+#define HANDLE_SEGV 1\n+#define HANDLE_FPE 1\n+\n+#define SIGNAL_HANDLER(_name)\t\\\n+static void _name (int _dummy)\n+\n+#define MAKE_THROW_FRAME    do {} while (0)\n+#define HANDLE_DIVIDE_OVERFLOW\tdo {} while (0)\n+\n+#define INIT_SEGV\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    nullp = new java::lang::NullPointerException ();\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+#define INIT_FPE\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    arithexception = new java::lang::ArithmeticException \t\\\n+      (JvNewStringLatin1 (\"/ by zero\"));\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+\n+#endif /* JAVA_SIGNAL_H */"}, {"sha": "d87fea07d2ab8bea3a09a3da6695bbf9295db24b", "filename": "libjava/include/win32-threads.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Finclude%2Fwin32-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Finclude%2Fwin32-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-threads.h?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -0,0 +1,138 @@\n+// -*- c++ -*-\n+// win32-threads.h - Defines for using Win32 threads.\n+\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_WIN32_THREADS__\n+#define __JV_WIN32_THREADS__\n+\n+#include <windows.h>\n+\n+//\n+// Typedefs.\n+//\n+\n+typedef HANDLE _Jv_ConditionVariable_t;\n+typedef HANDLE _Jv_Mutex_t;\n+\n+typedef struct\n+{\n+  int flags;            // Flags are defined in implementation.\n+  HANDLE handle;        // Actual handle to the thread\n+} _Jv_Thread_t;\n+\n+typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n+\n+//\n+// Condition variables.\n+//\n+\n+inline void\n+_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n+{\n+  *cv = CreateEvent (NULL, 0, 0, NULL);\n+}\n+\n+#define _Jv_HaveCondDestroy\n+\n+inline void\n+_Jv_CondDestroy (_Jv_ConditionVariable_t *cv)\n+{\n+  CloseHandle (*cv);\n+  cv = NULL;\n+}\n+\n+int _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n+\t\t  jlong millis, jint nanos);\n+\n+inline int\n+_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+{\n+  return PulseEvent (*cv) ? 0 : GetLastError ();        // FIXME: Map error code?\n+}\n+\n+inline int\n+_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n+{\n+  return PulseEvent (*cv) ? 0 : GetLastError ();        // FIXME: Map error code?\n+}\n+\n+//\n+// Mutexes.\n+//\n+\n+inline void\n+_Jv_MutexInit (_Jv_Mutex_t *mu)\n+{\n+  *mu = CreateMutex (NULL, 0, NULL);\n+}\n+\n+#define _Jv_HaveMutexDestroy\n+\n+inline void\n+_Jv_MutexDestroy (_Jv_Mutex_t *mu)\n+{\n+  CloseHandle (*mu);\n+  mu = NULL;\n+}\n+\n+int _Jv_MutexLock (_Jv_Mutex_t *mu);\n+\n+inline int\n+_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+{\n+  return ReleaseMutex(*mu) ? 0 : GetLastError();        // FIXME: Map error code?\n+}\n+\n+//\n+// Thread creation and manipulation.\n+//\n+\n+void _Jv_InitThreads (void);\n+void _Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *thread);\n+\n+inline java::lang::Thread *\n+_Jv_ThreadCurrent (void)\n+{\n+  extern DWORD _Jv_ThreadKey;\n+  return (java::lang::Thread *) TlsGetValue(_Jv_ThreadKey);\n+}\n+\n+inline _Jv_Thread_t *\n+_Jv_ThreadCurrentData (void)\n+{\n+  extern DWORD _Jv_ThreadDataKey;\n+  return (_Jv_Thread_t *) TlsGetValue(_Jv_ThreadDataKey);\n+}\n+\n+inline void\n+_Jv_ThreadYield (void)\n+{\n+  Sleep (0);\n+}\n+\n+void _Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio);\n+void _Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data,\n+\t\t      _Jv_ThreadStartFunc *meth);\n+void _Jv_ThreadWait (void);\n+void _Jv_ThreadInterrupt (_Jv_Thread_t *data);\n+\n+// Remove defines from <windows.h> that conflict with various things in libgcj code\n+\n+#undef TRUE\n+#undef FALSE\n+#undef MAX_PRIORITY\n+#undef MIN_PRIORITY\n+#undef min\n+#undef max\n+#undef interface\n+#undef STRICT\n+#undef VOID\n+\n+#endif /* __JV_WIN32_THREADS__ */"}, {"sha": "0bfd924abf03565ef82609d579e6340cae9cc069", "filename": "libjava/java/io/natFileDescriptorWin32.cc", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -0,0 +1,250 @@\n+// natFileDescriptorWin32.cc - Native part of FileDescriptor class.\n+\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// FIXME: In order to support interrupting of IO operations, we\n+// need to change to use the windows asynchronous IO functions\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <windows.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/io/FileDescriptor.h>\n+#include <java/io/SyncFailedException.h>\n+#include <java/io/IOException.h>\n+#include <java/io/InterruptedIOException.h>\n+#include <java/io/EOFException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/String.h>\n+#include <java/lang/Thread.h>\n+#include <java/io/FileNotFoundException.h>\n+\n+static char *\n+winerr (void)\n+{\n+  static LPVOID last = NULL;\n+  LPVOID old = NULL;\n+\n+  if (last)\n+    old = last;\n+\n+  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+    FORMAT_MESSAGE_FROM_SYSTEM |\n+    FORMAT_MESSAGE_IGNORE_INSERTS,\n+    NULL,\n+    GetLastError(),\n+    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+    (LPTSTR) &last,\n+    0,\n+    NULL);\n+\n+  if (old)\n+    LocalFree (old);\n+\n+  return (char *)last;\n+}\n+\n+jboolean\n+java::io::FileDescriptor::valid (void) {\n+  BY_HANDLE_FILE_INFORMATION info;\n+  return GetFileInformationByHandle ((HANDLE)fd, &info) != 0;\n+}\n+\n+void\n+java::io::FileDescriptor::sync (void) {\n+  if (! FlushFileBuffers ((HANDLE)fd))\n+    JvThrow (new SyncFailedException (JvNewStringLatin1 (winerr ())));\n+}\n+\n+jint\n+java::io::FileDescriptor::open (jstring path, jint jflags) {\n+\n+  HANDLE handle = NULL;\n+  DWORD access = 0;\n+  DWORD share = FILE_SHARE_READ;\n+  DWORD create = OPEN_EXISTING;\n+  char buf[MAX_PATH] = \"\";\n+\n+  jsize total = JvGetStringUTFRegion(path, 0, path->length(), buf);\n+  buf[total] = '\\0';\n+\n+  JvAssert((jflags & READ) || (jflags & WRITE));\n+\n+  if ((jflags & READ) && (jflags & WRITE))\n+    {\n+      access = GENERIC_READ | GENERIC_WRITE;\n+      share = 0;\n+      if (jflags & APPEND)\n+\tcreate = OPEN_ALWAYS;\n+      else\n+\tcreate = CREATE_ALWAYS;\n+    }\n+  else if(jflags & READ)\n+    access = GENERIC_READ;\n+  else\n+    {\n+      access = GENERIC_WRITE;\n+      share = 0;\n+      if (jflags & APPEND)\n+\tcreate = OPEN_ALWAYS;\n+      else\n+        create = CREATE_ALWAYS;\n+    }\n+\n+  handle = CreateFile(buf, access, share, NULL, create, 0, NULL);\n+\n+  if (handle == INVALID_HANDLE_VALUE)\n+    {\n+      char msg[MAX_PATH + 1000];\n+      sprintf (msg, \"%s: %s\", buf, winerr ());\n+      JvThrow (new FileNotFoundException (JvNewStringLatin1 (msg)));\n+    }\n+\n+  return (jint)handle;\n+}\n+\n+void\n+java::io::FileDescriptor::write (jint b)\n+{\n+  DWORD bytesWritten;\n+  jbyte buf = (jbyte)b;\n+\n+  if (WriteFile ((HANDLE)fd, &buf, 1, &bytesWritten, NULL))\n+    {\n+      if (java::lang::Thread::interrupted())\n+        {\n+          InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n+          iioe->bytesTransferred = bytesWritten;\n+          JvThrow (iioe);\n+        }\n+      if (bytesWritten != 1)\n+        JvThrow (new IOException (JvNewStringLatin1 (winerr ())));\n+    }\n+  else\n+    JvThrow (new IOException (JvNewStringLatin1 (winerr ())));\n+  // FIXME: loop until bytesWritten == 1\n+}\n+\n+void\n+java::io::FileDescriptor::write(jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    JvThrow (new java::lang::NullPointerException);\n+  if(offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    JvThrow (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  jbyte *buf = elements (b) + offset;\n+  DWORD bytesWritten;\n+  if (WriteFile ((HANDLE)fd, buf, len, &bytesWritten, NULL))\n+    {\n+      if (java::lang::Thread::interrupted())\n+        {\n+          InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n+          iioe->bytesTransferred = bytesWritten;\n+          JvThrow (iioe);\n+        }\n+    }\n+  else\n+    JvThrow(new IOException (JvNewStringLatin1 (winerr ())));\n+  // FIXME: loop until bytesWritten == len\n+}\n+\n+void\n+java::io::FileDescriptor::close (void)\n+{\n+  HANDLE save = (HANDLE)fd;\n+  fd = (jint)INVALID_HANDLE_VALUE;\n+  if (! CloseHandle (save))\n+    JvThrow (new IOException (JvNewStringLatin1 (winerr ())));\n+}\n+\n+jint\n+java::io::FileDescriptor::seek (jlong pos, jint whence)\n+{\n+  JvAssert (whence == SET || whence == CUR);\n+\n+  jlong len = length();\n+  jlong here = getFilePointer();\n+\n+  if ((whence == SET && pos > len) || (whence == CUR && here + pos > len))\n+    JvThrow (new EOFException);\n+\n+  LONG high = pos >> 32;\n+  DWORD low = SetFilePointer ((HANDLE)fd, (DWORD)(0xffffffff & pos), &high, whence == SET ? FILE_BEGIN : FILE_CURRENT);\n+  if ((low == 0xffffffff) && (GetLastError () != NO_ERROR))\n+    JvThrow (new IOException (JvNewStringLatin1 (winerr ())));\n+  return low;\n+}\n+\n+jlong\n+java::io::FileDescriptor::getFilePointer(void)\n+{\n+  LONG high = 0;\n+  DWORD low = SetFilePointer ((HANDLE)fd, 0, &high, FILE_CURRENT);\n+  if ((low == 0xffffffff) && (GetLastError() != NO_ERROR))\n+    JvThrow(new IOException (JvNewStringLatin1 (winerr ())));\n+  return (((jlong)high) << 32L) | (jlong)low;\n+}\n+\n+jlong\n+java::io::FileDescriptor::length(void)\n+{\n+  DWORD high;\n+  DWORD low;\n+\n+  low = GetFileSize ((HANDLE)fd, &high);\n+  // FIXME: Error checking\n+  return (((jlong)high) << 32L) | (jlong)low;\n+}\n+\n+jint\n+java::io::FileDescriptor::read(void)\n+{\n+  CHAR buf;\n+  DWORD read;\n+\n+  if (! ReadFile ((HANDLE)fd, &buf, 1, &read, NULL))\n+    JvThrow (new IOException (JvNewStringLatin1 (winerr ())));\n+  if (! read)\n+    return -1;\n+  else\n+    return (jint)(buf & 0xff);\n+}\n+\n+jint\n+java::io::FileDescriptor::read(jbyteArray buffer, jint offset, jint count)\n+{\n+  if (! buffer)\n+    JvThrow(new java::lang::NullPointerException);\n+\n+  jsize bsize = JvGetArrayLength (buffer);\n+  if (offset < 0 || count < 0 || offset + count > bsize)\n+    JvThrow (new java::lang::ArrayIndexOutOfBoundsException);\n+\n+  jbyte *bytes = elements (buffer) + offset;\n+\n+  DWORD read;\n+  if (! ReadFile((HANDLE)fd, bytes, count, &read, NULL))\n+    JvThrow (new IOException (JvNewStringLatin1 (winerr ())));\n+\n+  return (jint)read;\n+}\n+\n+jint\n+java::io::FileDescriptor::available(void)\n+{\n+  // FIXME:\n+  return length() - getFilePointer();\n+}"}, {"sha": "a56845a71348317ddc53bf35572d3147775547fe", "filename": "libjava/java/io/natFileWin32.cc", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileWin32.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -0,0 +1,210 @@\n+// natFileWin32.cc - Native part of File class.\n+\n+/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include <windows.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/io/File.h>\n+#include <java/io/IOException.h>\n+#include <java/util/Vector.h>\n+#include <java/lang/String.h>\n+#include <java/io/FilenameFilter.h>\n+#include <java/lang/System.h>\n+\n+jboolean\n+java::io::File::access (jstring canon, jint query)\n+{\n+  if (! canon)\n+    return false;\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  JvAssert (query == READ || query == WRITE || query == EXISTS);\n+\n+  // FIXME: Is it possible to differentiate between existing and reading?\n+  // If the file exists but cannot be read because of the secuirty attributes\n+  // on an NTFS disk this wont work (it reports it can be read but cant)\n+  // Could we use something from the security API?\n+  DWORD attributes = GetFileAttributes (buf);\n+  if ((query == EXISTS) || (query == READ))\n+    return (attributes == 0xffffffff) ? false : true;\n+  else\n+    return ((attributes != 0xffffffff) && ((attributes & FILE_ATTRIBUTE_READONLY) == 0)) ? true : false;\n+}\n+\n+jboolean\n+java::io::File::stat (jstring canon, jint query)\n+{\n+  if (! canon)\n+    return false;\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  JvAssert (query == DIRECTORY || query == ISFILE);\n+\n+  DWORD attributes = GetFileAttributes (buf);\n+  if (attributes == 0xffffffff)\n+    return false;\n+\n+  if (query == DIRECTORY)\n+    return attributes & FILE_ATTRIBUTE_DIRECTORY ? true : false;\n+  else\n+    return attributes & FILE_ATTRIBUTE_DIRECTORY ? false : true;\n+}\n+\n+jlong\n+java::io::File::attr (jstring canon, jint query)\n+{\n+  if (! canon)\n+    return false;\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  JvAssert (query == MODIFIED || query == LENGTH);\n+\n+  WIN32_FILE_ATTRIBUTE_DATA info;\n+  if (! GetFileAttributesEx(buf, GetFileExInfoStandard, &info))\n+    return 0;\n+\n+  if (query == LENGTH)\n+    return ((long long)info.nFileSizeHigh) << 32 | (unsigned long long)info.nFileSizeLow;\n+  else {\n+    // FIXME? This is somewhat compiler dependant (the LL constant suffix)\n+    // The file time as return by windows is the number of 100-nanosecond intervals since January 1, 1601\n+    return (((((long long)info.ftLastWriteTime.dwHighDateTime) << 32) | ((unsigned long long)info.ftLastWriteTime.dwLowDateTime)) - 116444736000000000LL) / 10000LL;\n+  }\n+}\n+\n+jstring\n+java::io::File::getCanonicalPath (void)\n+{\n+  char buf[MAX_PATH], buf2[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  LPTSTR unused;\n+  if(!GetFullPathName(buf, MAX_PATH, buf2, &unused))\n+    _Jv_Throw (new IOException (JvNewStringLatin1 (\"GetFullPathName failed\")));\n+\n+  // FIXME: what encoding to assume for file names?  This affects many\n+  // calls.\n+  return JvNewStringUTF(buf2);\n+}\n+\n+jboolean\n+java::io::File::isAbsolute (void)\n+{\n+  if (path->charAt(0) == '/' || path->charAt(0) == '\\\\')\n+    return true;\n+  if (path->length() < 3)\n+    return false;\n+  // Hard-code A-Za-z because Windows (I think) can't use non-ASCII\n+  // letters as drive names.\n+  if ((path->charAt(0) < 'a' || path->charAt(0) > 'z')\n+      && (path->charAt(0) < 'A' || path->charAt(0) > 'Z'))\n+    return false;\n+  return (path->charAt(1) == ':'\n+\t  && (path->charAt(2) == '/' || path->charAt(2) == '\\\\'));\n+}\n+\n+jstringArray\n+java::io::File::performList (jstring canon, FilenameFilter *filter)\n+{\n+  if (! canon)\n+    return NULL;\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n+  // FIXME?\n+  strcpy(&buf[total], \"\\\\*.*\");\n+\n+  WIN32_FIND_DATA data;\n+  HANDLE handle = FindFirstFile (buf, &data);\n+  if (handle == INVALID_HANDLE_VALUE)\n+    return NULL;\n+\n+  java::util::Vector *vec = new java::util::Vector ();\n+\n+  do\n+    {\n+      if (strcmp (data.cFileName, \".\") && strcmp (data.cFileName, \"..\"))\n+        {\n+          jstring name = JvNewStringUTF (data.cFileName);\n+          if (! filter || (filter && filter->accept(this, name)))\n+            vec->addElement (name);\n+        }\n+    }\n+  while (FindNextFile (handle, &data));\n+\n+  if (GetLastError () != ERROR_NO_MORE_FILES)\n+    return NULL;\n+\n+  FindClose (handle);\n+\n+  jobjectArray ret = JvNewObjectArray (vec->size(), canon->getClass(), NULL);\n+  vec->copyInto (ret);\n+  return reinterpret_cast<jstringArray> (ret);\n+}\n+\n+jboolean\n+java::io::File::performMkdir (void)\n+{\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion(path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  return (CreateDirectory(buf, NULL)) ? true : false;\n+}\n+\n+jboolean\n+java::io::File::performRenameTo (File *dest)\n+{\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion(path, 0, path->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+  char buf2[MAX_PATH];\n+  total = JvGetStringUTFRegion(dest->path, 0, dest->path->length(), buf2);\n+  // FIXME?\n+  buf2[total] = '\\0';\n+\n+  return (MoveFile(buf, buf2)) ? true : false;\n+}\n+\n+jboolean\n+java::io::File::performDelete (jstring canon)\n+{\n+  char buf[MAX_PATH];\n+  jsize total = JvGetStringUTFRegion(canon, 0, canon->length(), buf);\n+  // FIXME?\n+  buf[total] = '\\0';\n+\n+  DWORD attributes = GetFileAttributes (buf);\n+  if (attributes == 0xffffffff)\n+    return false;\n+\n+  if (attributes & FILE_ATTRIBUTE_DIRECTORY)\n+    return (RemoveDirectory (buf)) ? true : false;\n+  else\n+    return (DeleteFile (buf)) ? true : false;\n+}"}, {"sha": "a25e643957b0be24d7565359e74a66b318076f1e", "filename": "libjava/java/net/natInetAddress.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fnet%2FnatInetAddress.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddress.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -14,6 +14,17 @@ details.  */\n # define _REENTRANT 1\n #endif\n \n+#ifdef USE_WINSOCK\n+\n+#include <windows.h>\n+#include <winsock.h>\n+\n+#ifndef MAXHOSTNAMELEN\n+#define MAXHOSTNAMELEN\t64\n+#endif /* MAXHOSTNAMELEN */\n+\n+#else\n+\n #ifdef HAVE_UNISTD_H\n #include <unistd.h>\n #endif\n@@ -35,6 +46,8 @@ details.  */\n #include <netdb.h>\n #endif\n \n+#endif /* USE_WINSOCK */\n+\n #include <gcj/cni.h>\n #include <jvm.h>\n #include <java/net/InetAddress.h>"}, {"sha": "94383f8309dc181a943852708022a4544e88c7c4", "filename": "libjava/java/net/natPlainDatagramSocketImpl.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImpl.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -8,6 +8,15 @@ details.  */\n \n #include <config.h>\n \n+#ifdef USE_WINSOCK\n+#include <windows.h>\n+#include <winsock.h>\n+#include <errno.h>\n+#include <string.h>\n+#ifndef ENOPROTOOPT\n+#define ENOPROTOOPT 109\n+#endif\n+#else /* USE_WINSOCK */\n #ifdef HAVE_SYS_TYPES_H\n #include <sys/types.h>\n #endif\n@@ -26,6 +35,7 @@ details.  */\n #endif\n #include <errno.h>\n #include <string.h>\n+#endif /* USE_WINSOCK */\n \n #if HAVE_BSTRING_H\n // Needed for bzero, implicitly used by FD_ZERO on IRIX 5.2 "}, {"sha": "52187461f49a529c49c8628f030ef242b510f96c", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -8,7 +8,17 @@ details.  */\n \n #include <config.h>\n \n+\n #ifndef DISABLE_JAVA_NET\n+#ifdef USE_WINSOCK\n+#include <windows.h>\n+#include <winsock.h>\n+#include <errno.h>\n+#include <string.h>\n+#ifndef ENOPROTOOPT\n+#define ENOPROTOOPT 109\n+#endif\n+#else /* USE_WINSOCK */\n #include <sys/types.h>\n #include <sys/socket.h>\n #include <sys/time.h>\n@@ -19,6 +29,7 @@ details.  */\n #include <netinet/tcp.h>\n #include <errno.h>\n #include <string.h>\n+#endif /* USE_WINSOCK */\n #endif /* DISABLE_JAVA_NET */\n \n #if HAVE_BSTRING_H"}, {"sha": "81668a86c887d5c89e724b5b2f37a757d2d4c066", "filename": "libjava/prims.cc", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -10,6 +10,15 @@ details.  */\n \n #include <config.h>\n \n+#ifdef USE_WIN32_SIGNALLING\n+#include <windows.h>\n+#endif /* USE_WIN32_SIGNALLING */\n+\n+#ifdef USE_WINSOCK\n+#undef __INSIDE_CYGWIN__\n+#include <winsock.h>\n+#endif /* USE_WINSOCK */\n+\n #include <stdlib.h>\n #include <stdarg.h>\n #include <stdio.h>\n@@ -589,6 +598,32 @@ _Jv_ThisExecutable (const char *name)\n     }\n }\n \n+#ifdef USE_WIN32_SIGNALLING\n+\n+extern \"C\" int* win32_get_restart_frame (void *);\n+\n+LONG CALLBACK\n+win32_exception_handler (LPEXCEPTION_POINTERS e)\n+{\n+  int* setjmp_buf;\n+  if (e->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)   \n+    setjmp_buf = win32_get_restart_frame (nullp);\n+  else if (e->ExceptionRecord->ExceptionCode == EXCEPTION_INT_DIVIDE_BY_ZERO)\n+    setjmp_buf = win32_get_restart_frame (arithexception);\n+  else\n+    return EXCEPTION_CONTINUE_SEARCH;\n+\n+  e->ContextRecord->Ebp = setjmp_buf[0];\n+  // FIXME: Why does i386-signal.h increment the PC here, do we need to do it?\n+  e->ContextRecord->Eip = setjmp_buf[1];\n+  // FIXME: Is this the stack pointer? Do we need it?\n+  e->ContextRecord->Esp = setjmp_buf[2];\n+\n+  return EXCEPTION_CONTINUE_EXECUTION;\n+}\n+\n+#endif\n+\n static void\n main_init ()\n {\n@@ -606,12 +641,24 @@ main_init ()\n   LTDL_SET_PRELOADED_SYMBOLS ();\n #endif\n \n-  // FIXME: we only want this on POSIX systems.\n+#ifdef USE_WINSOCK\n+  // Initialise winsock for networking\n+  WSADATA data;\n+  if (WSAStartup (MAKEWORD (1, 1), &data))\n+      MessageBox (NULL, \"Error initialising winsock library.\", \"Error\", MB_OK | MB_ICONEXCLAMATION);\n+#endif /* USE_WINSOCK */\n+\n+#ifdef USE_WIN32_SIGNALLING\n+  // Install exception handler\n+  SetUnhandledExceptionFilter (win32_exception_handler);\n+#else\n+  // We only want this on POSIX systems.\n   struct sigaction act;\n   act.sa_handler = SIG_IGN;\n   sigemptyset (&act.sa_mask);\n   act.sa_flags = 0;\n   sigaction (SIGPIPE, &act, NULL);\n+#endif /* USE_WIN32_SIGNALLING */\n \n   _Jv_JNI_Init ();\n }"}, {"sha": "9c6ae8caf1c3b833806b2714bf44f77768538c16", "filename": "libjava/win32-threads.cc", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fwin32-threads.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/878885b41142dd76e858b1f705bd31f357a5acc5/libjava%2Fwin32-threads.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32-threads.cc?ref=878885b41142dd76e858b1f705bd31f357a5acc5", "patch": "@@ -0,0 +1,247 @@\n+// win32-threads.cc - interface between libjava and Win32 threads.\n+\n+/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+// If we're using the Boehm GC, then we need to override some of the\n+// thread primitives.  This is fairly gross.\n+#ifdef HAVE_BOEHM_GC\n+extern \"C\"\n+{\n+#include <boehm-config.h>\n+#include <gc.h>\n+};\n+#endif /* HAVE_BOEHM_GC */\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <java/lang/Thread.h>\n+#include <java/lang/System.h>\n+\n+#include <errno.h>\n+\n+#ifndef ETIMEDOUT\n+#define ETIMEDOUT 116\n+#endif\n+\n+// This is used to implement thread startup.\n+struct starter\n+{\n+  _Jv_ThreadStartFunc *method;\n+  java::lang::Thread *object;\n+  _Jv_Thread_t *data;\n+};\n+\n+// Controls access to the variable below\n+static HANDLE daemon_mutex;\n+static HANDLE daemon_cond;\n+// Number of non-daemon threads - _Jv_ThreadWait returns when this is 0\n+static int non_daemon_count;\n+\n+// TLS key get Java object representing the thread\n+DWORD _Jv_ThreadKey;\n+// TLS key to get _Jv_Thread_t* representing the thread\n+DWORD _Jv_ThreadDataKey;\n+\n+//\n+// These are the flags that can appear in _Jv_Thread_t.\n+//\n+\n+// Thread started.\n+#define FLAG_START   0x01\n+// Thread is daemon.\n+#define FLAG_DAEMON  0x02\n+\n+//\n+// Condition variables.\n+//\n+\n+int\n+_Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint nanos)\n+{\n+  DWORD time;\n+  DWORD rval;\n+\n+  _Jv_MutexUnlock (mu);\n+\n+  if((millis == 0) && (nanos > 0))\n+    time = 1;\n+  else if(millis == 0)\n+    time = INFINITE;\n+  else\n+    time = millis;\n+\n+  rval = WaitForSingleObject (*cv, time);\n+  _Jv_MutexLock (mu);\n+\n+  if (rval == WAIT_FAILED)\n+    return GetLastError ();       // FIXME: Map to errno?\n+  else if (rval == WAIT_TIMEOUT)\n+    return ETIMEDOUT;\n+  else\n+    return 0;\n+}\n+\n+//\n+// Mutexes.\n+//\n+\n+int\n+_Jv_MutexLock (_Jv_Mutex_t *mu)\n+{\n+  DWORD rval;\n+\n+  // FIXME: Are Win32 mutexs recursive? Should we use critical section objects\n+  rval = WaitForSingleObject (*mu, INFINITE);\n+\n+  if (rval == WAIT_FAILED)\n+    return GetLastError ();       // FIXME: Map to errno?\n+  else if (rval == WAIT_TIMEOUT)\n+    return ETIMEDOUT;\n+  else\n+    return 0;\n+}\n+\n+//\n+// Threads.\n+//\n+\n+void\n+_Jv_InitThreads (void)\n+{\n+  _Jv_ThreadKey = TlsAlloc();\n+  _Jv_ThreadDataKey = TlsAlloc();\n+  daemon_mutex = CreateMutex(NULL, 0, NULL);\n+  daemon_cond = CreateEvent(NULL, 0, 0, NULL);\n+  non_daemon_count = 0;\n+}\n+\n+void\n+_Jv_ThreadInitData (_Jv_Thread_t **data, java::lang::Thread *)\n+{\n+  _Jv_Thread_t *info = new _Jv_Thread_t;\n+  info->flags = 0;\n+\n+  // FIXME register a finalizer for INFO here.\n+  // FIXME also must mark INFO somehow.\n+\n+  *data = info;\n+}\n+\n+void\n+_Jv_ThreadSetPriority (_Jv_Thread_t *data, jint prio)\n+{\n+  int actual = THREAD_PRIORITY_NORMAL;\n+\n+  if (data->flags & FLAG_START)\n+    {\n+      switch (prio)\n+        {\n+          case 10:\n+            actual = THREAD_PRIORITY_TIME_CRITICAL;\n+            break;\n+          case 9:\n+            actual = THREAD_PRIORITY_HIGHEST;\n+            break;\n+          case 8:\n+          case 7:\n+            actual = THREAD_PRIORITY_ABOVE_NORMAL;\n+            break;\n+          case 6:\n+          case 5:\n+            actual = THREAD_PRIORITY_NORMAL;\n+            break;\n+          case 4:\n+          case 3:\n+            actual = THREAD_PRIORITY_BELOW_NORMAL;\n+            break;\n+          case 2:\n+            actual = THREAD_PRIORITY_LOWEST;\n+            break;\n+          case 1:\n+            actual = THREAD_PRIORITY_IDLE;\n+            break;\n+        }\n+      SetThreadPriority(data->handle, actual);\n+    }\n+}\n+\n+// This function is called when a thread is started.  We don't arrange\n+// to call the `run' method directly, because this function must\n+// return a value.\n+static DWORD __stdcall\n+really_start (void* x)\n+{\n+  struct starter *info = (struct starter *) x;\n+\n+  TlsSetValue (_Jv_ThreadKey, info->object);\n+  TlsSetValue (_Jv_ThreadDataKey, info->data);\n+  info->method (info->object);\n+\n+  if (! (info->data->flags & FLAG_DAEMON))\n+    {\n+      WaitForSingleObject (daemon_mutex, INFINITE);\n+      non_daemon_count--;\n+      if (! non_daemon_count)\n+          PulseEvent (daemon_cond);\n+      ReleaseMutex (daemon_mutex);\n+    }\n+\n+  return 0;\n+}\n+\n+void\n+_Jv_ThreadStart (java::lang::Thread *thread, _Jv_Thread_t *data, _Jv_ThreadStartFunc *meth)\n+{\n+  DWORD id;\n+  struct starter *info;\n+\n+  // Do nothing if thread has already started\n+  if (data->flags & FLAG_START)\n+    return;\n+  data->flags |= FLAG_START;\n+\n+  // FIXME: handle marking the info object for GC.\n+  info = (struct starter *) _Jv_AllocBytes (sizeof (struct starter));\n+  info->method = meth;\n+  info->object = thread;\n+  info->data = data;\n+\n+  if (! thread->isDaemon ())\n+    {\n+      WaitForSingleObject (daemon_mutex, INFINITE);\n+      non_daemon_count++;\n+      ReleaseMutex (daemon_mutex);\n+    }\n+  else\n+    data->flags |= FLAG_DAEMON;\n+\n+  HANDLE h = CreateThread(NULL, 0, really_start, info, 0, &id);\n+  _Jv_ThreadSetPriority(data, thread->getPriority());\n+\n+  //if (!h)\n+    //JvThrow ();\n+}\n+\n+void\n+_Jv_ThreadWait (void)\n+{\n+  WaitForSingleObject(daemon_mutex, INFINITE);\n+  if(non_daemon_count)\n+      SignalObjectAndWait(daemon_mutex, daemon_cond, INFINITE, 0);\n+  ReleaseMutex(daemon_mutex);\n+}\n+\n+void\n+_Jv_ThreadInterrupt (_Jv_Thread_t *data)\n+{\n+  MessageBox(NULL, \"Unimplemented\", \"win32-threads.cc:_Jv_ThreadInterrupt\", MB_OK);\n+  // FIXME:\n+}"}]}