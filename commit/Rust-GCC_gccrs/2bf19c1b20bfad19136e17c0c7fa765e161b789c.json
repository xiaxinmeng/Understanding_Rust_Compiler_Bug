{"sha": "2bf19c1b20bfad19136e17c0c7fa765e161b789c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJmMTljMWIyMGJmYWQxOTEzNmUxN2MwYzdmYTc2NWUxNjFiNzg5Yw==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-10T14:21:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-10T14:21:43Z"}, "message": "Merge #666\n\n666: Super Traits Support r=philberty a=philberty\n\nThis adds initial super traits support. Super traits are implemented by\r\nexplicitly adding the super trait bound to the implicit Self type parameter\r\non traits. This will improve as we enhance the type system to handle bounds\r\nand where constraints in general as they reuse all that same code path.\r\n\r\nFixes #565 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "9921253c39d493c64aa3218de4965f12ff20e022", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9921253c39d493c64aa3218de4965f12ff20e022"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bf19c1b20bfad19136e17c0c7fa765e161b789c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhO2n3CRBK7hj4Ov3rIwAAobIIAIMP1eHATOTw74B/UV0LudWw\nHmXk/PAaorOvDTpIHYqFI2bzQHBrMi8BdOKqDSvehA+zlJ39/bm+TkGvUM6Jrvly\negtCg/Ozk2cbmTml69qU0Vh9Amm6Jn4PTTOaZK50tCz/93gofyvNp5MbsFPOB6eu\nCbbgFvELD1glV0Ayp2nSpYmWq4gw4/yla6+Uak7JMy7yeZFxjhnW2J89hmrB2Xae\nmmCsAWRnvKdigj02fqaiL4R4RV8FzdDV4gZ2l+sQ4bykpRlMe+1AleJQmxCKA/Al\n9GuEfFJ8VYe8SW74/kyoBOkBU84RToveusvWcYYZ4QaWTudl2u5ZOixSnYqDgyE=\n=mnHJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 9921253c39d493c64aa3218de4965f12ff20e022\nparent c0254d7efe135ca3de755504a1f042010ee45786\nparent a1c87bfea6c5e2fd6b2d23b12b563fcaf5ec09a1\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631283703 +0000\ncommitter GitHub <noreply@github.com> 1631283703 +0000\n\nMerge #666\n\n666: Super Traits Support r=philberty a=philberty\n\nThis adds initial super traits support. Super traits are implemented by\r\nexplicitly adding the super trait bound to the implicit Self type parameter\r\non traits. This will improve as we enhance the type system to handle bounds\r\nand where constraints in general as they reuse all that same code path.\r\n\r\nFixes #565 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf19c1b20bfad19136e17c0c7fa765e161b789c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf19c1b20bfad19136e17c0c7fa765e161b789c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf19c1b20bfad19136e17c0c7fa765e161b789c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0254d7efe135ca3de755504a1f042010ee45786", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0254d7efe135ca3de755504a1f042010ee45786", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0254d7efe135ca3de755504a1f042010ee45786"}, {"sha": "a1c87bfea6c5e2fd6b2d23b12b563fcaf5ec09a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c87bfea6c5e2fd6b2d23b12b563fcaf5ec09a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c87bfea6c5e2fd6b2d23b12b563fcaf5ec09a1"}], "stats": {"total": 280, "additions": 207, "deletions": 73}, "files": [{"sha": "936e11f81fec1f8d0628ae39c4f03ef2a37427dd", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 76, "deletions": 67, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -40,7 +40,7 @@ class TypeParam : public GenericParam\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   // bool has_type;\n@@ -60,8 +60,8 @@ class TypeParam : public GenericParam\n \n   TypeParam (Analysis::NodeMapping mappings, Identifier type_representation,\n \t     Location locus = Location (),\n-\t     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds\n-\t     = std::vector<std::unique_ptr<TypeParamBound> > (),\n+\t     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds\n+\t     = std::vector<std::unique_ptr<TypeParamBound>> (),\n \t     std::unique_ptr<Type> type = nullptr,\n \t     AST::Attribute outer_attr = AST::Attribute::create_empty ())\n     : GenericParam (mappings), outer_attr (std::move (outer_attr)),\n@@ -122,7 +122,7 @@ class TypeParam : public GenericParam\n     return type->get_mappings ();\n   }\n \n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n@@ -197,7 +197,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   // bool has_type_param_bounds;\n   // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n \n   // should this store location info?\n@@ -211,7 +211,7 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   TypeBoundWhereClauseItem (\n     std::vector<LifetimeParam> for_lifetimes, std::unique_ptr<Type> bound_type,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds)\n+    std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n       type_param_bounds (std::move (type_param_bounds))\n@@ -261,13 +261,12 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n struct WhereClause\n {\n private:\n-  std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items;\n+  std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items;\n \n   // should this store location info?\n \n public:\n-  WhereClause (\n-    std::vector<std::unique_ptr<WhereClauseItem> > where_clause_items)\n+  WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items)\n     : where_clause_items (std::move (where_clause_items))\n   {}\n \n@@ -296,7 +295,7 @@ struct WhereClause\n   // Creates a WhereClause with no items.\n   static WhereClause create_empty ()\n   {\n-    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem> > ());\n+    return WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> ());\n   }\n \n   // Returns whether the WhereClause has no items.\n@@ -645,7 +644,7 @@ class Module : public VisItem\n   // bool has_inner_attrs;\n   AST::AttrVec inner_attrs;\n   // bool has_items;\n-  std::vector<std::unique_ptr<Item> > items;\n+  std::vector<std::unique_ptr<Item>> items;\n \n public:\n   std::string as_string () const override;\n@@ -658,7 +657,7 @@ class Module : public VisItem\n \n   // Full constructor\n   Module (Analysis::NodeMapping mappings, Identifier module_name,\n-\t  Location locus, std::vector<std::unique_ptr<Item> > items,\n+\t  Location locus, std::vector<std::unique_ptr<Item>> items,\n \t  Visibility visibility = Visibility::create_error (),\n \t  AST::AttrVec inner_attrs = AST::AttrVec (),\n \t  AST::AttrVec outer_attrs = AST::AttrVec ())\n@@ -696,7 +695,7 @@ class Module : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<Item> > &get_items () { return items; };\n+  std::vector<std::unique_ptr<Item>> &get_items () { return items; };\n \n   /* Override that runs the function recursively on all items contained within\n    * the module. */\n@@ -867,11 +866,11 @@ class UseTreeList : public UseTree\n   PathType path_type;\n   AST::SimplePath path;\n \n-  std::vector<std::unique_ptr<UseTree> > trees;\n+  std::vector<std::unique_ptr<UseTree>> trees;\n \n public:\n   UseTreeList (PathType path_type, AST::SimplePath path,\n-\t       std::vector<std::unique_ptr<UseTree> > trees, Location locus)\n+\t       std::vector<std::unique_ptr<UseTree>> trees, Location locus)\n     : UseTree (locus), path_type (path_type), path (std::move (path)),\n       trees (std::move (trees))\n   {\n@@ -1043,7 +1042,7 @@ class Function : public VisItem, public ImplItem\n {\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<GenericParam>> generic_params;\n   std::vector<FunctionParam> function_params;\n   std::unique_ptr<Type> return_type;\n   WhereClause where_clause;\n@@ -1069,7 +1068,7 @@ class Function : public VisItem, public ImplItem\n   // Mega-constructor with all possible fields\n   Function (Analysis::NodeMapping mappings, Identifier function_name,\n \t    FunctionQualifiers qualifiers,\n-\t    std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t    std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t    std::vector<FunctionParam> function_params,\n \t    std::unique_ptr<Type> return_type, WhereClause where_clause,\n \t    std::unique_ptr<BlockExpr> function_body, Visibility vis,\n@@ -1139,11 +1138,11 @@ class Function : public VisItem, public ImplItem\n     return function_params;\n   }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1203,7 +1202,7 @@ class TypeAlias : public VisItem, public ImplItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1223,7 +1222,7 @@ class TypeAlias : public VisItem, public ImplItem\n \n   // Mega-constructor with all possible fields\n   TypeAlias (Analysis::NodeMapping mappings, Identifier new_type_name,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t     WhereClause where_clause, std::unique_ptr<Type> existing_type,\n \t     Visibility vis, AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n@@ -1268,11 +1267,11 @@ class TypeAlias : public VisItem, public ImplItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n@@ -1318,7 +1317,7 @@ class Struct : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1336,14 +1335,14 @@ class Struct : public VisItem\n \n   Location get_locus () const override final { return locus; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n \n protected:\n   Struct (Analysis::NodeMapping mappings, Identifier struct_name,\n-\t  std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t  WhereClause where_clause, Visibility vis, Location locus,\n \t  AST::AttrVec outer_attrs = AST::AttrVec ())\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n@@ -1465,7 +1464,7 @@ class StructStruct : public Struct\n   // Mega-constructor with all possible fields\n   StructStruct (Analysis::NodeMapping mappings, std::vector<StructField> fields,\n \t\tIdentifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tWhereClause where_clause, bool is_unit, Visibility vis,\n \t\tAST::AttrVec outer_attrs, Location locus)\n     : Struct (std::move (mappings), std::move (struct_name),\n@@ -1476,7 +1475,7 @@ class StructStruct : public Struct\n \n   // Unit struct constructor\n   StructStruct (Analysis::NodeMapping mappings, Identifier struct_name,\n-\t\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\tWhereClause where_clause, Visibility vis,\n \t\tAST::AttrVec outer_attrs, Location locus)\n     : Struct (std::move (mappings), std::move (struct_name),\n@@ -1597,7 +1596,7 @@ class TupleStruct : public Struct\n   // Mega-constructor with all possible fields\n   TupleStruct (Analysis::NodeMapping mappings, std::vector<TupleField> fields,\n \t       Identifier struct_name,\n-\t       std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t       std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t       WhereClause where_clause, Visibility vis,\n \t       AST::AttrVec outer_attrs, Location locus)\n     : Struct (std::move (mappings), std::move (struct_name),\n@@ -1786,12 +1785,12 @@ class Enum : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::vector<std::unique_ptr<EnumItem> > items;\n+  std::vector<std::unique_ptr<EnumItem>> items;\n \n   Location locus;\n \n@@ -1810,8 +1809,8 @@ class Enum : public VisItem\n \n   // Mega-constructor\n   Enum (Analysis::NodeMapping mappings, Identifier enum_name, Visibility vis,\n-\tstd::vector<std::unique_ptr<GenericParam> > generic_params,\n-\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem> > items,\n+\tstd::vector<std::unique_ptr<GenericParam>> generic_params,\n+\tWhereClause where_clause, std::vector<std::unique_ptr<EnumItem>> items,\n \tAST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       enum_name (std::move (enum_name)),\n@@ -1884,7 +1883,7 @@ class Union : public VisItem\n \n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_where_clause;\n   WhereClause where_clause;\n@@ -1903,7 +1902,7 @@ class Union : public VisItem\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n   Union (Analysis::NodeMapping mappings, Identifier union_name, Visibility vis,\n-\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t WhereClause where_clause, std::vector<StructField> variants,\n \t AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n@@ -1944,7 +1943,7 @@ class Union : public VisItem\n   Union (Union &&other) = default;\n   Union &operator= (Union &&other) = default;\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n@@ -2116,7 +2115,7 @@ struct TraitFunctionDecl\n private:\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<GenericParam>> generic_params;\n   std::vector<FunctionParam> function_params;\n   std::unique_ptr<Type> return_type;\n   WhereClause where_clause;\n@@ -2125,7 +2124,7 @@ struct TraitFunctionDecl\n public:\n   // Mega-constructor\n   TraitFunctionDecl (Identifier function_name, FunctionQualifiers qualifiers,\n-\t\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t\t     SelfParam self, std::vector<FunctionParam> function_params,\n \t\t     std::unique_ptr<Type> return_type,\n \t\t     WhereClause where_clause)\n@@ -2196,7 +2195,7 @@ struct TraitFunctionDecl\n \n   Identifier get_function_name () const { return function_name; }\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n@@ -2366,18 +2365,17 @@ class TraitItemType : public TraitItem\n   AST::AttrVec outer_attrs;\n \n   Identifier name;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n+  std::vector<std::unique_ptr<TypeParamBound>>\n     type_param_bounds; // inlined form\n   Location locus;\n \n public:\n   // Returns whether trait item type has type param bounds.\n   bool has_type_param_bounds () const { return !type_param_bounds.empty (); }\n \n-  TraitItemType (\n-    Analysis::NodeMapping mappings, Identifier name,\n-    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    AST::AttrVec outer_attrs, Location locus)\n+  TraitItemType (Analysis::NodeMapping mappings, Identifier name,\n+\t\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n+\t\t AST::AttrVec outer_attrs, Location locus)\n     : TraitItem (mappings), outer_attrs (std::move (outer_attrs)),\n       name (std::move (name)),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n@@ -2421,7 +2419,7 @@ class TraitItemType : public TraitItem\n \n   Identifier get_name () const { return name; }\n \n-  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n   {\n     return type_param_bounds;\n   }\n@@ -2441,10 +2439,10 @@ class Trait : public VisItem\n {\n   bool has_unsafe;\n   Identifier name;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params;\n-  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+  std::vector<std::unique_ptr<GenericParam>> generic_params;\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n   WhereClause where_clause;\n-  std::vector<std::unique_ptr<TraitItem> > trait_items;\n+  std::vector<std::unique_ptr<TraitItem>> trait_items;\n   Location locus;\n \n public:\n@@ -2462,7 +2460,7 @@ class Trait : public VisItem\n   // Returns whether trait has trait items.\n   bool has_trait_items () const { return !trait_items.empty (); }\n \n-  std::vector<std::unique_ptr<TraitItem> > &get_trait_items ()\n+  std::vector<std::unique_ptr<TraitItem>> &get_trait_items ()\n   {\n     return trait_items;\n   }\n@@ -2471,10 +2469,10 @@ class Trait : public VisItem\n \n   // Mega-constructor\n   Trait (Analysis::NodeMapping mappings, Identifier name, bool is_unsafe,\n-\t std::vector<std::unique_ptr<GenericParam> > generic_params,\n-\t std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+\t std::vector<std::unique_ptr<GenericParam>> generic_params,\n+\t std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds,\n \t WhereClause where_clause,\n-\t std::vector<std::unique_ptr<TraitItem> > trait_items, Visibility vis,\n+\t std::vector<std::unique_ptr<TraitItem>> trait_items, Visibility vis,\n \t AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n       has_unsafe (is_unsafe), name (std::move (name)),\n@@ -2534,16 +2532,27 @@ class Trait : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n \n-  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  const std::vector<std::unique_ptr<GenericParam>> &get_generic_params () const\n   {\n     return generic_params;\n   }\n \n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n+  const std::vector<std::unique_ptr<TypeParamBound>> &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2552,18 +2561,18 @@ class Trait : public VisItem\n \n class ImplBlock : public VisItem\n {\n-  std::vector<std::unique_ptr<GenericParam> > generic_params;\n+  std::vector<std::unique_ptr<GenericParam>> generic_params;\n   std::unique_ptr<Type> impl_type;\n   std::unique_ptr<TypePath> trait_ref;\n   WhereClause where_clause;\n   AST::AttrVec inner_attrs;\n   Location locus;\n-  std::vector<std::unique_ptr<ImplItem> > impl_items;\n+  std::vector<std::unique_ptr<ImplItem>> impl_items;\n \n public:\n   ImplBlock (Analysis::NodeMapping mappings,\n-\t     std::vector<std::unique_ptr<ImplItem> > impl_items,\n-\t     std::vector<std::unique_ptr<GenericParam> > generic_params,\n+\t     std::vector<std::unique_ptr<ImplItem>> impl_items,\n+\t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n \t     std::unique_ptr<Type> impl_type,\n \t     std::unique_ptr<TypePath> trait_ref, WhereClause where_clause,\n \t     Visibility vis, AST::AttrVec inner_attrs, AST::AttrVec outer_attrs,\n@@ -2619,12 +2628,12 @@ class ImplBlock : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<ImplItem> > &get_impl_items ()\n+  std::vector<std::unique_ptr<ImplItem>> &get_impl_items ()\n   {\n     return impl_items;\n   };\n \n-  const std::vector<std::unique_ptr<ImplItem> > &get_impl_items () const\n+  const std::vector<std::unique_ptr<ImplItem>> &get_impl_items () const\n   {\n     return impl_items;\n   };\n@@ -2642,7 +2651,7 @@ class ImplBlock : public VisItem\n \n   std::unique_ptr<Type> &get_type () { return impl_type; };\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n@@ -2832,7 +2841,7 @@ class ExternalFunctionItem : public ExternalItem\n {\n   // bool has_generics;\n   // Generics generic_params;\n-  std::vector<std::unique_ptr<GenericParam> > generic_params; // inlined\n+  std::vector<std::unique_ptr<GenericParam>> generic_params; // inlined\n \n   // bool has_return_type;\n   // FunctionReturnType return_type;\n@@ -2856,7 +2865,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   ExternalFunctionItem (\n     Analysis::NodeMapping mappings, Identifier item_name,\n-    std::vector<std::unique_ptr<GenericParam> > generic_params,\n+    std::vector<std::unique_ptr<GenericParam>> generic_params,\n     std::unique_ptr<Type> return_type, WhereClause where_clause,\n     std::vector<NamedFunctionParam> function_params, bool has_variadics,\n     Visibility vis, AST::AttrVec outer_attrs, Location locus)\n@@ -2905,7 +2914,7 @@ class ExternalFunctionItem : public ExternalItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  std::vector<std::unique_ptr<GenericParam>> &get_generic_params ()\n   {\n     return generic_params;\n   }\n@@ -2938,7 +2947,7 @@ class ExternBlock : public VisItem\n   AST::AttrVec inner_attrs;\n \n   // bool has_extern_items;\n-  std::vector<std::unique_ptr<ExternalItem> > extern_items;\n+  std::vector<std::unique_ptr<ExternalItem>> extern_items;\n \n   Location locus;\n \n@@ -2957,7 +2966,7 @@ class ExternBlock : public VisItem\n   std::string get_abi () const { return abi; }\n \n   ExternBlock (Analysis::NodeMapping mappings, std::string abi,\n-\t       std::vector<std::unique_ptr<ExternalItem> > extern_items,\n+\t       std::vector<std::unique_ptr<ExternalItem>> extern_items,\n \t       Visibility vis, AST::AttrVec inner_attrs,\n \t       AST::AttrVec outer_attrs, Location locus)\n     : VisItem (std::move (mappings), std::move (vis), std::move (outer_attrs)),\n@@ -2998,7 +3007,7 @@ class ExternBlock : public VisItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::vector<std::unique_ptr<ExternalItem> > &get_extern_items ()\n+  std::vector<std::unique_ptr<ExternalItem>> &get_extern_items ()\n   {\n     return extern_items;\n   }"}, {"sha": "b0e2c0d93ec7814bccd33c8971b5bfcaf0e66534", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -113,10 +113,6 @@ class TraitResolver : public TypeCheckBase\n \treturn tref;\n       }\n \n-    // Check if there is a super-trait, and apply this bound to the Self\n-    // TypeParam\n-    // FIXME\n-\n     TyTy::BaseType *self = nullptr;\n     std::vector<TyTy::SubstitutionParamMapping> substitutions;\n     for (auto &generic_param : trait_reference->get_generic_params ())\n@@ -147,6 +143,38 @@ class TraitResolver : public TypeCheckBase\n \n     rust_assert (self != nullptr);\n \n+    // Check if there is a super-trait, and apply this bound to the Self\n+    // TypeParam\n+    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+\n+    // They also inherit themselves as a bound this enables a trait item to\n+    // reference other Self::trait_items\n+    specified_bounds.push_back (\n+      TyTy::TypeBoundPredicate (trait_reference->get_mappings ().get_defid (),\n+\t\t\t\ttrait_reference->get_locus ()));\n+\n+    if (trait_reference->has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : trait_reference->get_type_param_bounds ())\n+\t  {\n+\t    if (bound->get_bound_type ()\n+\t\t== HIR::TypeParamBound::BoundType::TRAITBOUND)\n+\t      {\n+\t\tHIR::TraitBound *b\n+\t\t  = static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t\t// FIXME this might be recursive we need a check for that\n+\n+\t\tTraitReference *trait = resolve_trait_path (b->get_path ());\n+\t\tTyTy::TypeBoundPredicate predicate (\n+\t\t  trait->get_mappings ().get_defid (), bound->get_locus ());\n+\n+\t\tspecified_bounds.push_back (std::move (predicate));\n+\t      }\n+\t  }\n+      }\n+    self->inherit_bounds (specified_bounds);\n+\n     std::vector<TraitItemReference> item_refs;\n     for (auto &item : trait_reference->get_trait_items ())\n       {"}, {"sha": "398b531ede1b9919c8ad88fb514ca961b55c938f", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -99,7 +99,14 @@ BaseType::bounds_compatible (const BaseType &other, Location locus) const\n void\n BaseType::inherit_bounds (const BaseType &other)\n {\n-  for (auto &bound : other.get_specified_bounds ())\n+  inherit_bounds (other.get_specified_bounds ());\n+}\n+\n+void\n+BaseType::inherit_bounds (\n+  const std::vector<TyTy::TypeBoundPredicate> &specified_bounds)\n+{\n+  for (auto &bound : specified_bounds)\n     {\n       add_bound (bound);\n     }\n@@ -310,7 +317,8 @@ StructFieldType::clone () const\n void\n SubstitutionParamMapping::override_context ()\n {\n-  rust_assert (param->can_resolve ());\n+  if (!param->can_resolve ())\n+    return;\n \n   auto mappings = Analysis::Mappings::get ();\n   auto context = Resolver::TypeCheckContext::get ();"}, {"sha": "d3d4afd8ba780eb819a662eba30afd91ec508956", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -258,6 +258,9 @@ class BaseType : public TypeBoundsMappings\n \n   void inherit_bounds (const BaseType &other);\n \n+  void inherit_bounds (\n+    const std::vector<TyTy::TypeBoundPredicate> &specified_bounds);\n+\n   virtual bool is_unit () const { return false; }\n \n   virtual bool is_concrete () const { return true; }"}, {"sha": "afc4a86de6d5ed496b26417cc5add5964b959f20", "filename": "gcc/testsuite/rust/compile/torture/traits16.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits16.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits16.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits16.rs?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -0,0 +1,20 @@\n+trait A {\n+    fn a() -> i32 {\n+        123\n+    }\n+\n+    fn b() -> i32 {\n+        Self::a() + 456\n+    }\n+}\n+\n+struct S;\n+impl A for S {}\n+\n+fn main() {\n+    let a;\n+    a = S::a();\n+\n+    let b;\n+    b = S::b();\n+}"}, {"sha": "6da8bcb0082d600598031c24efb731f0d7f92a74", "filename": "gcc/testsuite/rust/compile/torture/traits17.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits17.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits17.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits17.rs?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -0,0 +1,23 @@\n+trait A {\n+    fn a() -> i32 {\n+        123\n+    }\n+}\n+\n+trait B: A {\n+    fn b() -> i32 {\n+        Self::a() + 456\n+    }\n+}\n+\n+struct S;\n+impl A for S {}\n+impl B for S {}\n+\n+fn main() {\n+    let a;\n+    a = S::a();\n+\n+    let b;\n+    b = S::b();\n+}"}, {"sha": "accfa9d0a36b628f7156802bc866f1cb1bfb76b8", "filename": "gcc/testsuite/rust/execute/torture/trait3.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bf19c1b20bfad19136e17c0c7fa765e161b789c/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait3.rs?ref=2bf19c1b20bfad19136e17c0c7fa765e161b789c", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-output \"123, 777\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait A {\n+    fn a() -> i32 {\n+        123\n+    }\n+}\n+\n+trait B: A {\n+    fn b() -> i32 {\n+        <T as A>::a() + 456\n+    }\n+}\n+\n+struct T;\n+// { dg-warning \"struct is never constructed\" \"\" { target *-*-* } .-1 }\n+\n+impl A for T {\n+    fn a() -> i32 {\n+        321\n+    }\n+}\n+\n+struct S;\n+impl A for S {}\n+impl B for S {}\n+\n+fn main() -> i32 {\n+    let aa = S::a();\n+    let bb = S::b();\n+\n+    unsafe {\n+        let a = \"%i, %i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, aa, bb);\n+    }\n+    0\n+}"}]}