{"sha": "a172951945776ac4033b7e9f63070f48da8eaf74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE3Mjk1MTk0NTc3NmFjNDAzM2I3ZTlmNjMwNzBmNDhkYThlYWY3NA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1997-09-02T21:40:31Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-09-02T21:40:31Z"}, "message": "Fix i386 code generation error reported by Mumit Khan.\n\n\t* local-alloc.c (contains_replace_regs): New function.\n\t(update_equiv_regs): When adding a REG_EQUIV note for a set of a MEM,\n\tverify that there is no existing REG_EQUIV note, and add a call to\n\tcontains_place_regs.\n\nFrom-SVN: r15041", "tree": {"sha": "969de79a6e26ab0230a130085da738fc62913631", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/969de79a6e26ab0230a130085da738fc62913631"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a172951945776ac4033b7e9f63070f48da8eaf74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a172951945776ac4033b7e9f63070f48da8eaf74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a172951945776ac4033b7e9f63070f48da8eaf74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a172951945776ac4033b7e9f63070f48da8eaf74/comments", "author": null, "committer": null, "parents": [{"sha": "37dac03995186a0404c5f17a39d69c8bb248dfc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37dac03995186a0404c5f17a39d69c8bb248dfc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37dac03995186a0404c5f17a39d69c8bb248dfc9"}], "stats": {"total": 68, "additions": 67, "deletions": 1}, "files": [{"sha": "d982628ace592f5b61cdb8c0a8ea75156cc79dea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a172951945776ac4033b7e9f63070f48da8eaf74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a172951945776ac4033b7e9f63070f48da8eaf74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a172951945776ac4033b7e9f63070f48da8eaf74", "patch": "@@ -1,3 +1,10 @@\n+Tue Sep  2 14:22:43 1997  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* local-alloc.c (contains_replace_regs): New function.\n+\t(update_equiv_regs): When adding a REG_EQUIV note for a set of a MEM,\n+\tverify that there is no existing REG_EQUIV note, and add a call to\n+\tcontains_place_regs.\n+\n Tue Sep  2 12:48:11 1997  H.J. Lu  (hjl@gnu.ai.mit.edu)\n \n \t* config/alpha/elf.h (CPP_PREDEFINES): Add -D__PIC__ -D__pic__."}, {"sha": "7a3e103c6bf61635a588b7fa7fcab6196760c94f", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a172951945776ac4033b7e9f63070f48da8eaf74/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a172951945776ac4033b7e9f63070f48da8eaf74/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=a172951945776ac4033b7e9f63070f48da8eaf74", "patch": "@@ -246,6 +246,7 @@ static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n static void alloc_qty_for_scratch PROTO((rtx, int, rtx, int, int));\n static void validate_equiv_mem_from_store PROTO((rtx, rtx));\n static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n+static int contains_replace_regs PROTO((rtx, char *));\n static int memref_referenced_p\tPROTO((rtx, rtx));\n static int memref_used_between_p PROTO((rtx, rtx, rtx));\n static void optimize_reg_copy_1\tPROTO((rtx, rtx, rtx));\n@@ -600,6 +601,52 @@ validate_equiv_mem (start, reg, memref)\n \n   return 0;\n }\n+\n+/* TRUE if X uses any registers for which reg_equiv_replace is true.  */\n+\n+static int\n+contains_replace_regs (x, reg_equiv_replace)\n+     rtx x;\n+     char *reg_equiv_replace;\n+{\n+  int i, j;\n+  char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n+\n+  switch (code)\n+    {\n+    case CONST_INT:\n+    case CONST:\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_DOUBLE:\n+    case PC:\n+    case CC0:\n+    case HIGH:\n+    case LO_SUM:\n+      return 0;\n+\n+    case REG:\n+      return reg_equiv_replace[REGNO (x)];\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    switch (fmt[i])\n+      {\n+      case 'e':\n+\tif (contains_replace_regs (XEXP (x, i), reg_equiv_replace))\n+\t  return 1;\n+\tbreak;\n+      case 'E':\n+\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t  if (contains_replace_regs (XVECEXP (x, i, j), reg_equiv_replace))\n+\t    return 1;\n+\tbreak;\n+      }\n+\n+  return 0;\n+}\n \f\n /* TRUE if X references a memory location that would be affected by a store\n    to MEMREF.  */\n@@ -1005,12 +1052,24 @@ update_equiv_regs ()\n \t in a single basic block, see if the register is always equivalent\n \t to that memory location and if moving the store from INSN to the\n \t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n-\t initializing insn.  */\n+\t initializing insn.\n+\n+\t Don't add a REG_EQUIV note if the insn already has one.  The existing\n+\t REG_EQUIV is likely more useful than the one we are adding.\n+\n+\t If one of the regs in the address is marked as reg_equiv_replace,\n+\t then we can't add this REG_EQUIV note.  The reg_equiv_replace\n+\t optimization may move the set of this register immediately before\n+\t insn, which puts it after reg_equiv_init_insn[regno], and hence\n+\t the mention in the REG_EQUIV note would be to an uninitialized\n+\t pseudo.  */\n \n       if (GET_CODE (dest) == MEM && GET_CODE (SET_SRC (set)) == REG\n \t  && (regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n \t  && REG_BASIC_BLOCK (regno) >= 0\n \t  && reg_equiv_init_insn[regno] != 0\n+\t  && ! find_reg_note (insn, REG_EQUIV, NULL_RTX)\n+\t  && ! contains_replace_regs (XEXP (dest, 0), reg_equiv_replace)\n \t  && validate_equiv_mem (reg_equiv_init_insn[regno], SET_SRC (set),\n \t\t\t\t dest)\n \t  && ! memref_used_between_p (SET_DEST (set),"}]}