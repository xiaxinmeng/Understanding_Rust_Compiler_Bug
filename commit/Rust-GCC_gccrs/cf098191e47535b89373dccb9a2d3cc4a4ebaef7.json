{"sha": "cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YwOTgxOTFlNDc1MzViODkzNzNkY2NiOWEyZDNjYzRhNGViYWVmNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:42:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:42:52Z"}, "message": "poly_int: GET_MODE_SIZE\n\nThis patch changes GET_MODE_SIZE from unsigned short to poly_uint16.\nThe non-mechanical parts were handled by previous patches.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (mode_size): Change from unsigned short to\n\tpoly_uint16_pod.\n\t(mode_to_bytes): Return a poly_uint16 rather than an unsigned short.\n\t(GET_MODE_SIZE): Return a constant if ONLY_FIXED_SIZE_MODES,\n\tor if measurement_type is not polynomial.\n\t(fixed_size_mode::includes_p): Check for constant-sized modes.\n\t* genmodes.c (emit_mode_size_inline): Make mode_size_inline\n\treturn a poly_uint16 rather than an unsigned short.\n\t(emit_mode_size): Change the type of mode_size from unsigned short\n\tto poly_uint16_pod.  Use ZERO_COEFFS for the initializer.\n\t(emit_mode_adjustments): Cope with polynomial vector sizes.\n\t* lto-streamer-in.c (lto_input_mode_table): Use bp_unpack_poly_value\n\tfor GET_MODE_SIZE.\n\t* lto-streamer-out.c (lto_write_mode_table): Use bp_pack_poly_value\n\tfor GET_MODE_SIZE.\n\t* auto-inc-dec.c (try_merge): Treat GET_MODE_SIZE as polynomial.\n\t* builtins.c (expand_ifn_atomic_compare_exchange_into_call): Likewise.\n\t* caller-save.c (setup_save_areas): Likewise.\n\t(replace_reg_with_saved_mem): Likewise.\n\t* calls.c (emit_library_call_value_1): Likewise.\n\t* combine-stack-adj.c (combine_stack_adjustments_for_block): Likewise.\n\t* combine.c (simplify_set, make_extraction, simplify_shift_const_1)\n\t(gen_lowpart_for_combine): Likewise.\n\t* convert.c (convert_to_integer_1): Likewise.\n\t* cse.c (equiv_constant, cse_insn): Likewise.\n\t* cselib.c (autoinc_split, cselib_hash_rtx): Likewise.\n\t(cselib_subst_to_values): Likewise.\n\t* dce.c (word_dce_process_block): Likewise.\n\t* df-problems.c (df_word_lr_mark_ref): Likewise.\n\t* dwarf2cfi.c (init_one_dwarf_reg_size): Likewise.\n\t* dwarf2out.c (multiple_reg_loc_descriptor, mem_loc_descriptor)\n\t(concat_loc_descriptor, concatn_loc_descriptor, loc_descriptor)\n\t(rtl_for_decl_location): Likewise.\n\t* emit-rtl.c (gen_highpart, widen_memory_access): Likewise.\n\t* expmed.c (extract_bit_field_1, extract_integral_bit_field): Likewise.\n\t* expr.c (emit_group_load_1, clear_storage_hints): Likewise.\n\t(emit_move_complex, emit_move_multi_word, emit_push_insn): Likewise.\n\t(expand_expr_real_1): Likewise.\n\t* function.c (assign_parm_setup_block_p, assign_parm_setup_block)\n\t(pad_below): Likewise.\n\t* gimple-fold.c (optimize_atomic_compare_exchange_p): Likewise.\n\t* gimple-ssa-store-merging.c (rhs_valid_for_store_merging_p): Likewise.\n\t* ira.c (get_subreg_tracking_sizes): Likewise.\n\t* ira-build.c (ira_create_allocno_objects): Likewise.\n\t* ira-color.c (coalesced_pseudo_reg_slot_compare): Likewise.\n\t(ira_sort_regnos_for_alter_reg): Likewise.\n\t* ira-costs.c (record_operand_costs): Likewise.\n\t* lower-subreg.c (interesting_mode_p, simplify_gen_subreg_concatn)\n\t(resolve_simple_move): Likewise.\n\t* lra-constraints.c (get_reload_reg, operands_match_p): Likewise.\n\t(process_addr_reg, simplify_operand_subreg, curr_insn_transform)\n\t(lra_constraints): Likewise.\n\t(CONST_POOL_OK_P): Reject variable-sized modes.\n\t* lra-spills.c (slot, assign_mem_slot, pseudo_reg_slot_compare)\n\t(add_pseudo_to_slot, lra_spill): Likewise.\n\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n\t* optabs-query.c (get_best_extraction_insn): Likewise.\n\t* optabs-tree.c (expand_vec_cond_expr_p): Likewise.\n\t* optabs.c (expand_vec_perm_var, expand_vec_cond_expr): Likewise.\n\t(expand_mult_highpart, valid_multiword_target_p): Likewise.\n\t* recog.c (offsettable_address_addr_space_p): Likewise.\n\t* regcprop.c (maybe_mode_change): Likewise.\n\t* reginfo.c (choose_hard_reg_mode, record_subregs_of_mode): Likewise.\n\t* regrename.c (build_def_use): Likewise.\n\t* regstat.c (dump_reg_info): Likewise.\n\t* reload.c (complex_word_subreg_p, push_reload, find_dummy_reload)\n\t(find_reloads, find_reloads_subreg_address): Likewise.\n\t* reload1.c (eliminate_regs_1): Likewise.\n\t* rtlanal.c (for_each_inc_dec_find_inc_dec, rtx_cost): Likewise.\n\t* simplify-rtx.c (avoid_constant_pool_reference): Likewise.\n\t(simplify_binary_operation_1, simplify_subreg): Likewise.\n\t* targhooks.c (default_function_arg_padding): Likewise.\n\t(default_hard_regno_nregs, default_class_max_nregs): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_binary): Likewise.\n\t(verify_gimple_assign_ternary): Likewise.\n\t* tree-inline.c (estimate_move_cost): Likewise.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n\t* tree-ssa-loop-ivopts.c (add_autoinc_candidates): Likewise.\n\t(get_address_cost_ainc): Likewise.\n\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment): Likewise.\n\t(vect_supportable_dr_alignment): Likewise.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n\t(vectorizable_reduction): Likewise.\n\t* tree-vect-stmts.c (vectorizable_assignment, vectorizable_shift)\n\t(vectorizable_operation, vectorizable_load): Likewise.\n\t* tree.c (build_same_sized_truth_vector_type): Likewise.\n\t* valtrack.c (cleanup_auto_inc_dec): Likewise.\n\t* var-tracking.c (emit_note_insn_var_location): Likewise.\n\t* config/arc/arc.h (ASM_OUTPUT_CASE_END): Use as_a <scalar_int_mode>.\n\t(ADDR_VEC_ALIGN): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256201", "tree": {"sha": "b7e4116030d6ae86efa3903e434e630d01cecc46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7e4116030d6ae86efa3903e434e630d01cecc46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/comments", "author": null, "committer": null, "parents": [{"sha": "73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a699ae37a7fe98ad0b8c50ac95f5a882fd97da"}], "stats": {"total": 846, "additions": 535, "deletions": 311}, "files": [{"sha": "e4759c30c11b7f563719705af10befec1ff71562", "filename": "gcc/ChangeLog", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1,3 +1,98 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (mode_size): Change from unsigned short to\n+\tpoly_uint16_pod.\n+\t(mode_to_bytes): Return a poly_uint16 rather than an unsigned short.\n+\t(GET_MODE_SIZE): Return a constant if ONLY_FIXED_SIZE_MODES,\n+\tor if measurement_type is not polynomial.\n+\t(fixed_size_mode::includes_p): Check for constant-sized modes.\n+\t* genmodes.c (emit_mode_size_inline): Make mode_size_inline\n+\treturn a poly_uint16 rather than an unsigned short.\n+\t(emit_mode_size): Change the type of mode_size from unsigned short\n+\tto poly_uint16_pod.  Use ZERO_COEFFS for the initializer.\n+\t(emit_mode_adjustments): Cope with polynomial vector sizes.\n+\t* lto-streamer-in.c (lto_input_mode_table): Use bp_unpack_poly_value\n+\tfor GET_MODE_SIZE.\n+\t* lto-streamer-out.c (lto_write_mode_table): Use bp_pack_poly_value\n+\tfor GET_MODE_SIZE.\n+\t* auto-inc-dec.c (try_merge): Treat GET_MODE_SIZE as polynomial.\n+\t* builtins.c (expand_ifn_atomic_compare_exchange_into_call): Likewise.\n+\t* caller-save.c (setup_save_areas): Likewise.\n+\t(replace_reg_with_saved_mem): Likewise.\n+\t* calls.c (emit_library_call_value_1): Likewise.\n+\t* combine-stack-adj.c (combine_stack_adjustments_for_block): Likewise.\n+\t* combine.c (simplify_set, make_extraction, simplify_shift_const_1)\n+\t(gen_lowpart_for_combine): Likewise.\n+\t* convert.c (convert_to_integer_1): Likewise.\n+\t* cse.c (equiv_constant, cse_insn): Likewise.\n+\t* cselib.c (autoinc_split, cselib_hash_rtx): Likewise.\n+\t(cselib_subst_to_values): Likewise.\n+\t* dce.c (word_dce_process_block): Likewise.\n+\t* df-problems.c (df_word_lr_mark_ref): Likewise.\n+\t* dwarf2cfi.c (init_one_dwarf_reg_size): Likewise.\n+\t* dwarf2out.c (multiple_reg_loc_descriptor, mem_loc_descriptor)\n+\t(concat_loc_descriptor, concatn_loc_descriptor, loc_descriptor)\n+\t(rtl_for_decl_location): Likewise.\n+\t* emit-rtl.c (gen_highpart, widen_memory_access): Likewise.\n+\t* expmed.c (extract_bit_field_1, extract_integral_bit_field): Likewise.\n+\t* expr.c (emit_group_load_1, clear_storage_hints): Likewise.\n+\t(emit_move_complex, emit_move_multi_word, emit_push_insn): Likewise.\n+\t(expand_expr_real_1): Likewise.\n+\t* function.c (assign_parm_setup_block_p, assign_parm_setup_block)\n+\t(pad_below): Likewise.\n+\t* gimple-fold.c (optimize_atomic_compare_exchange_p): Likewise.\n+\t* gimple-ssa-store-merging.c (rhs_valid_for_store_merging_p): Likewise.\n+\t* ira.c (get_subreg_tracking_sizes): Likewise.\n+\t* ira-build.c (ira_create_allocno_objects): Likewise.\n+\t* ira-color.c (coalesced_pseudo_reg_slot_compare): Likewise.\n+\t(ira_sort_regnos_for_alter_reg): Likewise.\n+\t* ira-costs.c (record_operand_costs): Likewise.\n+\t* lower-subreg.c (interesting_mode_p, simplify_gen_subreg_concatn)\n+\t(resolve_simple_move): Likewise.\n+\t* lra-constraints.c (get_reload_reg, operands_match_p): Likewise.\n+\t(process_addr_reg, simplify_operand_subreg, curr_insn_transform)\n+\t(lra_constraints): Likewise.\n+\t(CONST_POOL_OK_P): Reject variable-sized modes.\n+\t* lra-spills.c (slot, assign_mem_slot, pseudo_reg_slot_compare)\n+\t(add_pseudo_to_slot, lra_spill): Likewise.\n+\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n+\t* optabs-query.c (get_best_extraction_insn): Likewise.\n+\t* optabs-tree.c (expand_vec_cond_expr_p): Likewise.\n+\t* optabs.c (expand_vec_perm_var, expand_vec_cond_expr): Likewise.\n+\t(expand_mult_highpart, valid_multiword_target_p): Likewise.\n+\t* recog.c (offsettable_address_addr_space_p): Likewise.\n+\t* regcprop.c (maybe_mode_change): Likewise.\n+\t* reginfo.c (choose_hard_reg_mode, record_subregs_of_mode): Likewise.\n+\t* regrename.c (build_def_use): Likewise.\n+\t* regstat.c (dump_reg_info): Likewise.\n+\t* reload.c (complex_word_subreg_p, push_reload, find_dummy_reload)\n+\t(find_reloads, find_reloads_subreg_address): Likewise.\n+\t* reload1.c (eliminate_regs_1): Likewise.\n+\t* rtlanal.c (for_each_inc_dec_find_inc_dec, rtx_cost): Likewise.\n+\t* simplify-rtx.c (avoid_constant_pool_reference): Likewise.\n+\t(simplify_binary_operation_1, simplify_subreg): Likewise.\n+\t* targhooks.c (default_function_arg_padding): Likewise.\n+\t(default_hard_regno_nregs, default_class_max_nregs): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_binary): Likewise.\n+\t(verify_gimple_assign_ternary): Likewise.\n+\t* tree-inline.c (estimate_move_cost): Likewise.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n+\t* tree-ssa-loop-ivopts.c (add_autoinc_candidates): Likewise.\n+\t(get_address_cost_ainc): Likewise.\n+\t* tree-vect-data-refs.c (vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_supportable_dr_alignment): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n+\t(vectorizable_reduction): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_assignment, vectorizable_shift)\n+\t(vectorizable_operation, vectorizable_load): Likewise.\n+\t* tree.c (build_same_sized_truth_vector_type): Likewise.\n+\t* valtrack.c (cleanup_auto_inc_dec): Likewise.\n+\t* var-tracking.c (emit_note_insn_var_location): Likewise.\n+\t* config/arc/arc.h (ASM_OUTPUT_CASE_END): Use as_a <scalar_int_mode>.\n+\t(ADDR_VEC_ALIGN): Likewise.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d02fa9d081c73708ef40244c81dc0eaba659c607", "filename": "gcc/auto-inc-dec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fauto-inc-dec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fauto-inc-dec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-inc-dec.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -601,7 +601,7 @@ try_merge (void)\n     inc_insn.reg_res : mem_insn.reg0;\n \n   /* The width of the mem being accessed.  */\n-  int size = GET_MODE_SIZE (GET_MODE (mem));\n+  poly_int64 size = GET_MODE_SIZE (GET_MODE (mem));\n   rtx_insn *last_insn = NULL;\n   machine_mode reg_mode = GET_MODE (inc_reg);\n "}, {"sha": "1d6e69d30ce6a2d0506c42a9c9b2933a114502ab", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -5989,7 +5989,7 @@ expand_ifn_atomic_compare_exchange_into_call (gcall *call, machine_mode mode)\n   for (z = 4; z < 6; z++)\n     vec->quick_push (gimple_call_arg (call, z));\n   /* At present we only have BUILT_IN_ATOMIC_COMPARE_EXCHANGE_{1,2,4,8,16}.  */\n-  unsigned int bytes_log2 = exact_log2 (GET_MODE_SIZE (mode));\n+  unsigned int bytes_log2 = exact_log2 (GET_MODE_SIZE (mode).to_constant ());\n   gcc_assert (bytes_log2 < 5);\n   built_in_function fncode\n     = (built_in_function) ((int) BUILT_IN_ATOMIC_COMPARE_EXCHANGE_1"}, {"sha": "524de495b51759d3efe6694893a99c706516015d", "filename": "gcc/caller-save.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -607,9 +607,9 @@ setup_save_areas (void)\n \t\t    break;\n \t\t}\n \t      if (k < 0\n-\t\t  && (GET_MODE_SIZE (regno_save_mode[regno][1])\n-\t\t      <= GET_MODE_SIZE (regno_save_mode\n-\t\t\t\t\t[saved_reg2->hard_regno][1])))\n+\t\t  && known_le (GET_MODE_SIZE (regno_save_mode[regno][1]),\n+\t\t\t       GET_MODE_SIZE (regno_save_mode\n+\t\t\t\t\t      [saved_reg2->hard_regno][1])))\n \t\t{\n \t\t  saved_reg->slot\n \t\t    = adjust_address_nv\n@@ -631,8 +631,8 @@ setup_save_areas (void)\n \t\t  slot = prev_save_slots[j];\n \t\t  if (slot == NULL_RTX)\n \t\t    continue;\n-\t\t  if (GET_MODE_SIZE (regno_save_mode[regno][1])\n-\t\t      <= GET_MODE_SIZE (GET_MODE (slot))\n+\t\t  if (known_le (GET_MODE_SIZE (regno_save_mode[regno][1]),\n+\t\t\t\tGET_MODE_SIZE (GET_MODE (slot)))\n \t\t      && best_slot_num < 0)\n \t\t    best_slot_num = j;\n \t\t  if (GET_MODE (slot) == regno_save_mode[regno][1])\n@@ -1147,7 +1147,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t    machine_mode smode = save_mode[regno];\n \t    gcc_assert (smode != VOIDmode);\n \t    if (hard_regno_nregs (regno, smode) > 1)\n-\t      smode = mode_for_size (GET_MODE_SIZE (mode) / nregs,\n+\t      smode = mode_for_size (exact_div (GET_MODE_SIZE (mode), nregs),\n \t\t\t\t     GET_MODE_CLASS (mode), 0).require ();\n \t    XVECEXP (mem, 0, i) = gen_rtx_REG (smode, regno + i);\n \t  }"}, {"sha": "bdd49914fb27eab43f78752f0735a6be90f9236f", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -4686,7 +4686,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   rtx mem_value = 0;\n   rtx valreg;\n   int pcc_struct_value = 0;\n-  int struct_value_size = 0;\n+  poly_int64 struct_value_size = 0;\n   int flags;\n   int reg_parm_stack_space = 0;\n   poly_int64 needed;\n@@ -4925,7 +4925,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t   end it should be padded.  */\n \targvec[count].locate.where_pad =\n \t  BLOCK_REG_PADDING (mode, NULL_TREE,\n-\t\t\t     GET_MODE_SIZE (mode) <= UNITS_PER_WORD);\n+\t\t\t     known_le (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n #endif\n \n       targetm.calls.function_arg_advance (args_so_far, mode, (tree) 0, true);\n@@ -5176,9 +5176,6 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n-#ifdef BLOCK_REG_PADDING\n-      int size = 0;\n-#endif\n       \n       /* Handle calls that pass values in multiple non-contiguous\n \t locations.  The PA64 has examples of this for library calls.  */\n@@ -5188,19 +5185,19 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n         {\n \t  emit_move_insn (reg, val);\n #ifdef BLOCK_REG_PADDING\n-\t  size = GET_MODE_SIZE (argvec[argnum].mode);\n+\t  poly_int64 size = GET_MODE_SIZE (argvec[argnum].mode);\n \n \t  /* Copied from load_register_parameters.  */\n \n \t  /* Handle case where we have a value that needs shifting\n \t     up to the msb.  eg. a QImode value and we're padding\n \t     upward on a BYTES_BIG_ENDIAN machine.  */\n-\t  if (size < UNITS_PER_WORD\n+\t  if (known_lt (size, UNITS_PER_WORD)\n \t      && (argvec[argnum].locate.where_pad\n \t\t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n \t    {\n \t      rtx x;\n-\t      int shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n+\t      poly_int64 shift = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n \n \t      /* Assigning REG here rather than a temp makes CALL_FUSAGE\n \t\t report the whole reg as used.  Strictly speaking, the"}, {"sha": "4573dc2a87df0b0c90e34a03badb1bb54e5f5159", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -622,11 +622,11 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t  if (MEM_P (dest)\n \t      && ((STACK_GROWS_DOWNWARD\n \t\t   ? (GET_CODE (XEXP (dest, 0)) == PRE_DEC\n-\t\t      && last_sp_adjust\n-\t\t\t == (HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (dest)))\n+\t\t      && known_eq (last_sp_adjust,\n+\t\t\t\t   GET_MODE_SIZE (GET_MODE (dest))))\n \t\t   : (GET_CODE (XEXP (dest, 0)) == PRE_INC\n-\t\t      && last_sp_adjust\n-\t\t         == -(HOST_WIDE_INT) GET_MODE_SIZE (GET_MODE (dest))))\n+\t\t      && known_eq (-last_sp_adjust,\n+\t\t\t\t   GET_MODE_SIZE (GET_MODE (dest)))))\n \t\t  || ((STACK_GROWS_DOWNWARD\n \t\t       ? last_sp_adjust >= 0 : last_sp_adjust <= 0)\n \t\t      && GET_CODE (XEXP (dest, 0)) == PRE_MODIFY"}, {"sha": "3a42de53455c598f92e544588e96fdd459ca5205", "filename": "gcc/combine.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -6931,10 +6931,10 @@ simplify_set (rtx x)\n \n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n       && !OBJECT_P (SUBREG_REG (src))\n-      && (((GET_MODE_SIZE (GET_MODE (src)) + (UNITS_PER_WORD - 1))\n-\t   / UNITS_PER_WORD)\n-\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))\n-\t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n+      && (known_equal_after_align_up\n+\t  (GET_MODE_SIZE (GET_MODE (src)),\n+\t   GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))),\n+\t   UNITS_PER_WORD))\n       && (WORD_REGISTER_OPERATIONS || !paradoxical_subreg_p (src))\n       && ! (REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t    && !REG_CAN_CHANGE_MODE_P (REGNO (dest),\n@@ -7773,7 +7773,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n       && ! mode_dependent_address_p (XEXP (inner, 0), MEM_ADDR_SPACE (inner))\n       && ! MEM_VOLATILE_P (inner))\n     {\n-      int offset = 0;\n+      poly_int64 offset = 0;\n \n       /* The computations below will be correct if the machine is big\n \t endian in both bits and bytes or little endian in bits and bytes.\n@@ -10469,8 +10469,6 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n   machine_mode mode = result_mode;\n   machine_mode shift_mode;\n   scalar_int_mode tmode, inner_mode, int_mode, int_varop_mode, int_result_mode;\n-  unsigned int mode_words\n-    = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n   /* We form (outer_op (code varop count) (outer_const)).  */\n   enum rtx_code outer_op = UNKNOWN;\n   HOST_WIDE_INT outer_const = 0;\n@@ -10651,9 +10649,8 @@ simplify_shift_const_1 (enum rtx_code code, machine_mode result_mode,\n \t  if (subreg_lowpart_p (varop)\n \t      && is_int_mode (GET_MODE (SUBREG_REG (varop)), &inner_mode)\n \t      && GET_MODE_SIZE (inner_mode) > GET_MODE_SIZE (int_varop_mode)\n-\t      && (unsigned int) ((GET_MODE_SIZE (inner_mode)\n-\t\t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\t\t == mode_words\n+\t      && (CEIL (GET_MODE_SIZE (inner_mode), UNITS_PER_WORD)\n+\t\t  == CEIL (GET_MODE_SIZE (int_mode), UNITS_PER_WORD))\n \t      && GET_MODE_CLASS (int_varop_mode) == MODE_INT)\n \t    {\n \t      varop = SUBREG_REG (varop);\n@@ -11625,17 +11622,16 @@ static rtx\n gen_lowpart_for_combine (machine_mode omode, rtx x)\n {\n   machine_mode imode = GET_MODE (x);\n-  unsigned int osize = GET_MODE_SIZE (omode);\n-  unsigned int isize = GET_MODE_SIZE (imode);\n   rtx result;\n \n   if (omode == imode)\n     return x;\n \n   /* We can only support MODE being wider than a word if X is a\n      constant integer or has a mode the same size.  */\n-  if (GET_MODE_SIZE (omode) > UNITS_PER_WORD\n-      && ! (CONST_SCALAR_INT_P (x) || isize == osize))\n+  if (maybe_gt (GET_MODE_SIZE (omode), UNITS_PER_WORD)\n+      && ! (CONST_SCALAR_INT_P (x)\n+\t    || known_eq (GET_MODE_SIZE (imode), GET_MODE_SIZE (omode))))\n     goto fail;\n \n   /* X might be a paradoxical (subreg (mem)).  In that case, gen_lowpart\n@@ -11652,8 +11648,6 @@ gen_lowpart_for_combine (machine_mode omode, rtx x)\n \n       if (imode == omode)\n \treturn x;\n-\n-      isize = GET_MODE_SIZE (imode);\n     }\n \n   result = gen_lowpart_common (omode, x);"}, {"sha": "a04a3e9f1167db2a04fe33f5d59d002381074d93", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1291,7 +1291,8 @@ do {\t\t\t\t\t\t\t\\\n   do                                                    \\\n     {                                                   \\\n       if (GET_CODE (PATTERN (JUMPTABLE)) == ADDR_DIFF_VEC \\\n-\t  && ((GET_MODE_SIZE (GET_MODE (PATTERN (JUMPTABLE))) \\\n+\t  && ((GET_MODE_SIZE (as_a <scalar_int_mode>\t\\\n+\t\t\t      (GET_MODE (PATTERN (JUMPTABLE)))) \\\n \t       * XVECLEN (PATTERN (JUMPTABLE), 1) + 1)\t\\\n \t      & 2))\t\t\t\t\t\\\n       arc_toggle_unalign ();\t\t\t\t\\\n@@ -1405,7 +1406,8 @@ do { \\\n  : SImode)\n \n #define ADDR_VEC_ALIGN(VEC_INSN) \\\n-  (exact_log2 (GET_MODE_SIZE (GET_MODE (PATTERN (VEC_INSN)))))\n+  (exact_log2 (GET_MODE_SIZE (as_a <scalar_int_mode> \\\n+\t\t\t      (GET_MODE (PATTERN (VEC_INSN))))))\n #undef ASM_OUTPUT_BEFORE_CASE_LABEL\n #define ASM_OUTPUT_BEFORE_CASE_LABEL(FILE, PREFIX, NUM, TABLE) \\\n   ASM_OUTPUT_ALIGN ((FILE), ADDR_VEC_ALIGN (TABLE))"}, {"sha": "e168a266ff4b8d149d19de0fcbbfc5da1ad67f73", "filename": "gcc/convert.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -922,13 +922,15 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t    }\n \n \t  CASE_CONVERT:\n-\t    /* Don't introduce a \"can't convert between vector values of\n-\t       different size\" error.  */\n-\t    if (TREE_CODE (TREE_TYPE (TREE_OPERAND (expr, 0))) == VECTOR_TYPE\n-\t\t&& (GET_MODE_SIZE (TYPE_MODE\n-\t\t\t\t   (TREE_TYPE (TREE_OPERAND (expr, 0))))\n-\t\t    != GET_MODE_SIZE (TYPE_MODE (type))))\n-\t      break;\n+\t    {\n+\t      tree argtype = TREE_TYPE (TREE_OPERAND (expr, 0));\n+\t      /* Don't introduce a \"can't convert between vector values\n+\t\t of different size\" error.  */\n+\t      if (TREE_CODE (argtype) == VECTOR_TYPE\n+\t\t  && maybe_ne (GET_MODE_SIZE (TYPE_MODE (argtype)),\n+\t\t\t       GET_MODE_SIZE (TYPE_MODE (type))))\n+\t\tbreak;\n+\t    }\n \t    /* If truncating after truncating, might as well do all at once.\n \t       If truncating after extending, we may get rid of wasted work.  */\n \t    return convert (type, get_unwidened (TREE_OPERAND (expr, 0), type));"}, {"sha": "825b0bd8989ca4c7a29ba2f02f39f66c953060f3", "filename": "gcc/cse.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3807,8 +3807,8 @@ equiv_constant (rtx x)\n \n       /* If we didn't and if doing so makes sense, see if we previously\n \t assigned a constant value to the enclosing word mode SUBREG.  */\n-      if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode)\n-\t  && GET_MODE_SIZE (word_mode) < GET_MODE_SIZE (imode))\n+      if (known_lt (GET_MODE_SIZE (mode), UNITS_PER_WORD)\n+\t  && known_lt (UNITS_PER_WORD, GET_MODE_SIZE (imode)))\n \t{\n \t  poly_int64 byte = (SUBREG_BYTE (x)\n \t\t\t     - subreg_lowpart_offset (mode, word_mode));\n@@ -5986,9 +5986,10 @@ cse_insn (rtx_insn *insn)\n \t   already entered SRC and DEST of the SET in the table.  */\n \n \tif (GET_CODE (dest) == SUBREG\n-\t    && (((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) - 1)\n-\t\t / UNITS_PER_WORD)\n-\t\t== (GET_MODE_SIZE (GET_MODE (dest)) - 1) / UNITS_PER_WORD)\n+\t    && (known_equal_after_align_down\n+\t\t(GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))) - 1,\n+\t\t GET_MODE_SIZE (GET_MODE (dest)) - 1,\n+\t\t UNITS_PER_WORD))\n \t    && !partial_subreg_p (dest)\n \t    && sets[i].src_elt != 0)\n \t  {"}, {"sha": "586b8cc3a66daa087aec9afb3c881c4af9d80fc1", "filename": "gcc/cselib.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -805,14 +805,14 @@ autoinc_split (rtx x, rtx *off, machine_mode memmode)\n       if (memmode == VOIDmode)\n \treturn x;\n \n-      *off = GEN_INT (-GET_MODE_SIZE (memmode));\n+      *off = gen_int_mode (-GET_MODE_SIZE (memmode), GET_MODE (x));\n       return XEXP (x, 0);\n \n     case PRE_INC:\n       if (memmode == VOIDmode)\n \treturn x;\n \n-      *off = GEN_INT (GET_MODE_SIZE (memmode));\n+      *off = gen_int_mode (GET_MODE_SIZE (memmode), GET_MODE (x));\n       return XEXP (x, 0);\n \n     case PRE_MODIFY:\n@@ -1068,6 +1068,7 @@ static unsigned int\n cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n {\n   cselib_val *e;\n+  poly_int64 offset;\n   int i, j;\n   enum rtx_code code;\n   const char *fmt;\n@@ -1203,14 +1204,15 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n     case PRE_INC:\n       /* We can't compute these without knowing the MEM mode.  */\n       gcc_assert (memmode != VOIDmode);\n-      i = GET_MODE_SIZE (memmode);\n+      offset = GET_MODE_SIZE (memmode);\n       if (code == PRE_DEC)\n-\ti = -i;\n+\toffset = -offset;\n       /* Adjust the hash so that (mem:MEMMODE (pre_* (reg))) hashes\n \t like (mem:MEMMODE (plus (reg) (const_int I))).  */\n       hash += (unsigned) PLUS - (unsigned)code\n \t+ cselib_hash_rtx (XEXP (x, 0), create, memmode)\n-\t+ cselib_hash_rtx (GEN_INT (i), create, memmode);\n+\t+ cselib_hash_rtx (gen_int_mode (offset, GET_MODE (x)),\n+\t\t\t   create, memmode);\n       return hash ? hash : 1 + (unsigned) PLUS;\n \n     case PRE_MODIFY:\n@@ -1871,6 +1873,7 @@ cselib_subst_to_values (rtx x, machine_mode memmode)\n   struct elt_list *l;\n   rtx copy = x;\n   int i;\n+  poly_int64 offset;\n \n   switch (code)\n     {\n@@ -1907,11 +1910,11 @@ cselib_subst_to_values (rtx x, machine_mode memmode)\n     case PRE_DEC:\n     case PRE_INC:\n       gcc_assert (memmode != VOIDmode);\n-      i = GET_MODE_SIZE (memmode);\n+      offset = GET_MODE_SIZE (memmode);\n       if (code == PRE_DEC)\n-\ti = -i;\n+\toffset = -offset;\n       return cselib_subst_to_values (plus_constant (GET_MODE (x),\n-\t\t\t\t\t\t    XEXP (x, 0), i),\n+\t\t\t\t\t\t    XEXP (x, 0), offset),\n \t\t\t\t     memmode);\n \n     case PRE_MODIFY:"}, {"sha": "590b6874e53d4f9b456e38a8c53dbdd622388f75", "filename": "gcc/dce.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -884,8 +884,8 @@ word_dce_process_block (basic_block bb, bool redo_out,\n \tdf_ref use;\n \tFOR_EACH_INSN_USE (use, insn)\n \t  if (DF_REF_REGNO (use) >= FIRST_PSEUDO_REGISTER\n-\t      && (GET_MODE_SIZE (GET_MODE (DF_REF_REAL_REG (use)))\n-\t\t  == 2 * UNITS_PER_WORD)\n+\t      && known_eq (GET_MODE_SIZE (GET_MODE (DF_REF_REAL_REG (use))),\n+\t\t\t   2 * UNITS_PER_WORD)\n \t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (use))\n \t      && !bitmap_bit_p (local_live, 2 * DF_REF_REGNO (use) + 1))\n \t    dead_debug_add (&debug, use, DF_REF_REGNO (use));"}, {"sha": "3d73bc5df10a009be19c0a6cb7181ee2f31470c2", "filename": "gcc/df-problems.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2815,7 +2815,7 @@ df_word_lr_mark_ref (df_ref ref, bool is_set, regset live)\n   regno = REGNO (reg);\n   reg_mode = GET_MODE (reg);\n   if (regno < FIRST_PSEUDO_REGISTER\n-      || GET_MODE_SIZE (reg_mode) != 2 * UNITS_PER_WORD)\n+      || maybe_ne (GET_MODE_SIZE (reg_mode), 2 * UNITS_PER_WORD))\n     return true;\n \n   if (GET_CODE (orig_reg) == SUBREG"}, {"sha": "3ae5b8e894f68b4221c56b782aa8f0ad746574f0", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -270,8 +270,8 @@ void init_one_dwarf_reg_size (int regno, machine_mode regmode,\n   const unsigned int rnum = DWARF2_FRAME_REG_OUT (dnum, 1);\n   const unsigned int dcol = DWARF_REG_TO_UNWIND_COLUMN (rnum);\n   \n-  const HOST_WIDE_INT slotoffset = dcol * GET_MODE_SIZE (slotmode);\n-  const HOST_WIDE_INT regsize = GET_MODE_SIZE (regmode);\n+  poly_int64 slotoffset = dcol * GET_MODE_SIZE (slotmode);\n+  poly_int64 regsize = GET_MODE_SIZE (regmode);\n \n   init_state->processed_regno[regno] = true;\n \n@@ -285,7 +285,8 @@ void init_one_dwarf_reg_size (int regno, machine_mode regmode,\n       init_state->wrote_return_column = true;\n     }\n \n-  if (slotoffset < 0)\n+  /* ??? When is this true?  Should it be a test based on DCOL instead?  */\n+  if (maybe_lt (slotoffset, 0))\n     return;\n \n   emit_move_insn (adjust_address (table, slotmode, slotoffset),"}, {"sha": "ae91c2d750bd773113c45f1dcdb4c2462a389463", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -13184,7 +13184,10 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs,\n       gcc_assert ((unsigned) DBX_REGISTER_NUMBER (reg) == dbx_reg_number (rtl));\n       nregs = REG_NREGS (rtl);\n \n-      size = GET_MODE_SIZE (GET_MODE (rtl)) / nregs;\n+      /* At present we only track constant-sized pieces.  */\n+      if (!GET_MODE_SIZE (GET_MODE (rtl)).is_constant (&size))\n+\treturn NULL;\n+      size /= nregs;\n \n       loc_result = NULL;\n       while (nregs--)\n@@ -13204,7 +13207,9 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs,\n \n   gcc_assert (GET_CODE (regs) == PARALLEL);\n \n-  size = GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0)));\n+  /* At present we only track constant-sized pieces.  */\n+  if (!GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0))).is_constant (&size))\n+    return NULL;\n   loc_result = NULL;\n \n   for (i = 0; i < XVECLEN (regs, 0); ++i)\n@@ -14797,7 +14802,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n       if (is_a <scalar_int_mode> (mode, &int_mode)\n \t  && is_a <scalar_int_mode> (GET_MODE (inner), &inner_mode)\n \t  ? GET_MODE_SIZE (int_mode) <= GET_MODE_SIZE (inner_mode)\n-\t  : GET_MODE_SIZE (mode) == GET_MODE_SIZE (GET_MODE (inner)))\n+\t  : known_eq (GET_MODE_SIZE (mode), GET_MODE_SIZE (GET_MODE (inner))))\n \t{\n \t  dw_die_ref type_die;\n \t  dw_loc_descr_ref cvt;\n@@ -14813,8 +14818,7 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t      mem_loc_result = NULL;\n \t      break;\n \t    }\n-\t  if (GET_MODE_SIZE (mode)\n-\t      != GET_MODE_SIZE (GET_MODE (inner)))\n+\t  if (maybe_ne (GET_MODE_SIZE (mode), GET_MODE_SIZE (GET_MODE (inner))))\n \t    cvt = new_loc_descr (dwarf_OP (DW_OP_convert), 0, 0);\n \t  else\n \t    cvt = new_loc_descr (dwarf_OP (DW_OP_reinterpret), 0, 0);\n@@ -14975,15 +14979,17 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n \t    {\n \t      dw_die_ref type_die;\n \t      dw_loc_descr_ref deref;\n+\t      HOST_WIDE_INT size;\n \n \t      if (dwarf_strict && dwarf_version < 5)\n \t\treturn NULL;\n+\t      if (!GET_MODE_SIZE (mode).is_constant (&size))\n+\t\treturn NULL;\n \t      type_die\n \t\t= base_type_for_mode (mode, SCALAR_INT_MODE_P (mode));\n \t      if (type_die == NULL)\n \t\treturn NULL;\n-\t      deref = new_loc_descr (dwarf_OP (DW_OP_deref_type),\n-\t\t\t\t     GET_MODE_SIZE (mode), 0);\n+\t      deref = new_loc_descr (dwarf_OP (DW_OP_deref_type), size, 0);\n \t      deref->dw_loc_oprnd2.val_class = dw_val_class_die_ref;\n \t      deref->dw_loc_oprnd2.v.val_die_ref.die = type_die;\n \t      deref->dw_loc_oprnd2.v.val_die_ref.external = 0;\n@@ -15760,6 +15766,12 @@ mem_loc_descriptor (rtx rtl, machine_mode mode,\n static dw_loc_descr_ref\n concat_loc_descriptor (rtx x0, rtx x1, enum var_init_status initialized)\n {\n+  /* At present we only track constant-sized pieces.  */\n+  unsigned int size0, size1;\n+  if (!GET_MODE_SIZE (GET_MODE (x0)).is_constant (&size0)\n+      || !GET_MODE_SIZE (GET_MODE (x1)).is_constant (&size1))\n+    return 0;\n+\n   dw_loc_descr_ref cc_loc_result = NULL;\n   dw_loc_descr_ref x0_ref\n     = loc_descriptor (x0, VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n@@ -15770,10 +15782,10 @@ concat_loc_descriptor (rtx x0, rtx x1, enum var_init_status initialized)\n     return 0;\n \n   cc_loc_result = x0_ref;\n-  add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x0)));\n+  add_loc_descr_op_piece (&cc_loc_result, size0);\n \n   add_loc_descr (&cc_loc_result, x1_ref);\n-  add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x1)));\n+  add_loc_descr_op_piece (&cc_loc_result, size1);\n \n   if (initialized == VAR_INIT_STATUS_UNINITIALIZED)\n     add_loc_descr (&cc_loc_result, new_loc_descr (DW_OP_GNU_uninit, 0, 0));\n@@ -15790,18 +15802,23 @@ concatn_loc_descriptor (rtx concatn, enum var_init_status initialized)\n   unsigned int i;\n   dw_loc_descr_ref cc_loc_result = NULL;\n   unsigned int n = XVECLEN (concatn, 0);\n+  unsigned int size;\n \n   for (i = 0; i < n; ++i)\n     {\n       dw_loc_descr_ref ref;\n       rtx x = XVECEXP (concatn, 0, i);\n \n+      /* At present we only track constant-sized pieces.  */\n+      if (!GET_MODE_SIZE (GET_MODE (x)).is_constant (&size))\n+\treturn NULL;\n+\n       ref = loc_descriptor (x, VOIDmode, VAR_INIT_STATUS_INITIALIZED);\n       if (ref == NULL)\n \treturn NULL;\n \n       add_loc_descr (&cc_loc_result, ref);\n-      add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x)));\n+      add_loc_descr_op_piece (&cc_loc_result, size);\n     }\n \n   if (cc_loc_result && initialized == VAR_INIT_STATUS_UNINITIALIZED)\n@@ -15920,15 +15937,18 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \trtvec par_elems = XVEC (rtl, 0);\n \tint num_elem = GET_NUM_ELEM (par_elems);\n \tmachine_mode mode;\n-\tint i;\n+\tint i, size;\n \n \t/* Create the first one, so we have something to add to.  */\n \tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n \t\t\t\t     VOIDmode, initialized);\n \tif (loc_result == NULL)\n \t  return NULL;\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n-\tadd_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n+\t/* At present we only track constant-sized pieces.  */\n+\tif (!GET_MODE_SIZE (mode).is_constant (&size))\n+\t  return NULL;\n+\tadd_loc_descr_op_piece (&loc_result, size);\n \tfor (i = 1; i < num_elem; i++)\n \t  {\n \t    dw_loc_descr_ref temp;\n@@ -15939,7 +15959,10 @@ loc_descriptor (rtx rtl, machine_mode mode,\n \t      return NULL;\n \t    add_loc_descr (&loc_result, temp);\n \t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n-\t    add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n+\t    /* At present we only track constant-sized pieces.  */\n+\t    if (!GET_MODE_SIZE (mode).is_constant (&size))\n+\t      return NULL;\n+\t    add_loc_descr_op_piece (&loc_result, size);\n \t  }\n       }\n       break;\n@@ -19178,7 +19201,7 @@ rtl_for_decl_location (tree decl)\n \t    rtl = DECL_INCOMING_RTL (decl);\n \t  else if ((rtl == NULL_RTX || is_pseudo_reg (rtl))\n \t\t   && SCALAR_INT_MODE_P (dmode)\n-\t\t   && GET_MODE_SIZE (dmode) <= GET_MODE_SIZE (pmode)\n+\t\t   && known_le (GET_MODE_SIZE (dmode), GET_MODE_SIZE (pmode))\n \t\t   && DECL_INCOMING_RTL (decl))\n \t    {\n \t      rtx inc = DECL_INCOMING_RTL (decl);\n@@ -19219,12 +19242,12 @@ rtl_for_decl_location (tree decl)\n \t       /* Big endian correction check.  */\n \t       && BYTES_BIG_ENDIAN\n \t       && TYPE_MODE (TREE_TYPE (decl)) != GET_MODE (rtl)\n-\t       && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl)))\n-\t\t   < UNITS_PER_WORD))\n+\t       && known_lt (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))),\n+\t\t\t    UNITS_PER_WORD))\n \t{\n \t  machine_mode addr_mode = get_address_mode (rtl);\n-\t  int offset = (UNITS_PER_WORD\n-\t\t\t- GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))));\n+\t  poly_int64 offset = (UNITS_PER_WORD\n+\t\t\t       - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (decl))));\n \n \t  rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),\n \t\t\t     plus_constant (addr_mode, XEXP (rtl, 0), offset));"}, {"sha": "eedd161672232e9e1afacb9233789b2728452afa", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1605,13 +1605,13 @@ gen_lowpart_common (machine_mode mode, rtx x)\n rtx\n gen_highpart (machine_mode mode, rtx x)\n {\n-  unsigned int msize = GET_MODE_SIZE (mode);\n+  poly_uint64 msize = GET_MODE_SIZE (mode);\n   rtx result;\n \n   /* This case loses if X is a subreg.  To catch bugs early,\n      complain if an invalid MODE is used even in other cases.  */\n-  gcc_assert (msize <= UNITS_PER_WORD\n-\t      || msize == (unsigned int) GET_MODE_UNIT_SIZE (GET_MODE (x)));\n+  gcc_assert (known_le (msize, (unsigned int) UNITS_PER_WORD)\n+\t      || known_eq (msize, GET_MODE_UNIT_SIZE (GET_MODE (x))));\n \n   result = simplify_gen_subreg (mode, x, GET_MODE (x),\n \t\t\t\tsubreg_highpart_offset (mode, GET_MODE (x)));\n@@ -2573,7 +2573,7 @@ rtx\n widen_memory_access (rtx memref, machine_mode mode, poly_int64 offset)\n {\n   rtx new_rtx = adjust_address_1 (memref, mode, offset, 1, 1, 0, 0);\n-  unsigned int size = GET_MODE_SIZE (mode);\n+  poly_uint64 size = GET_MODE_SIZE (mode);\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (new_rtx == memref)"}, {"sha": "4433460033ba40acd18f909eb1984eb51bdcd8e5", "filename": "gcc/expmed.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1632,7 +1632,7 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n       && !MEM_P (op0)\n       && VECTOR_MODE_P (tmode)\n       && known_eq (bitsize, GET_MODE_SIZE (tmode))\n-      && GET_MODE_SIZE (GET_MODE (op0)) > GET_MODE_SIZE (tmode))\n+      && maybe_gt (GET_MODE_SIZE (GET_MODE (op0)), GET_MODE_SIZE (tmode)))\n     {\n       machine_mode new_mode = GET_MODE (op0);\n       if (GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode))\n@@ -1643,7 +1643,8 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t\t\t   GET_MODE_UNIT_BITSIZE (tmode), &nunits)\n \t      || !mode_for_vector (inner_mode, nunits).exists (&new_mode)\n \t      || !VECTOR_MODE_P (new_mode)\n-\t      || GET_MODE_SIZE (new_mode) != GET_MODE_SIZE (GET_MODE (op0))\n+\t      || maybe_ne (GET_MODE_SIZE (new_mode),\n+\t\t\t   GET_MODE_SIZE (GET_MODE (op0)))\n \t      || GET_MODE_INNER (new_mode) != GET_MODE_INNER (tmode)\n \t      || !targetm.vector_mode_supported_p (new_mode))\n \t    new_mode = VOIDmode;\n@@ -1699,8 +1700,8 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \tnew_mode = MIN_MODE_VECTOR_INT;\n \n       FOR_EACH_MODE_FROM (new_mode, new_mode)\n-\tif (GET_MODE_SIZE (new_mode) == GET_MODE_SIZE (GET_MODE (op0))\n-\t    && GET_MODE_UNIT_SIZE (new_mode) == GET_MODE_SIZE (tmode)\n+\tif (known_eq (GET_MODE_SIZE (new_mode), GET_MODE_SIZE (GET_MODE (op0)))\n+\t    && known_eq (GET_MODE_UNIT_SIZE (new_mode), GET_MODE_SIZE (tmode))\n \t    && targetm.vector_mode_supported_p (new_mode))\n \t  break;\n       if (new_mode != VOIDmode)\n@@ -1758,7 +1759,7 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,\n \t}\n       else\n \t{\n-\t  HOST_WIDE_INT size = GET_MODE_SIZE (GET_MODE (op0));\n+\t  poly_int64 size = GET_MODE_SIZE (GET_MODE (op0));\n \t  rtx mem = assign_stack_temp (GET_MODE (op0), size);\n \t  emit_move_insn (mem, op0);\n \t  op0 = adjust_bitfield_address_size (mem, BLKmode, 0, size);\n@@ -1858,7 +1859,8 @@ extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,\n       /* The mode must be fixed-size, since extract_bit_field_1 handles\n \t extractions from variable-sized objects before calling this\n \t function.  */\n-      unsigned int target_size = GET_MODE_SIZE (GET_MODE (target));\n+      unsigned int target_size\n+\t= GET_MODE_SIZE (GET_MODE (target)).to_constant ();\n       last = get_last_insn ();\n       for (i = 0; i < nwords; i++)\n \t{"}, {"sha": "281a714a797483f5de6a8d287938f8a5e7693297", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2238,7 +2238,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type,\n       else if (VECTOR_MODE_P (GET_MODE (dst))\n \t       && REG_P (src))\n \t{\n-\t  int slen = GET_MODE_SIZE (GET_MODE (src));\n+\t  poly_uint64 slen = GET_MODE_SIZE (GET_MODE (src));\n \t  rtx mem;\n \n \t  mem = assign_stack_temp (GET_MODE (src), slen);\n@@ -2970,7 +2970,7 @@ clear_storage_hints (rtx object, rtx size, enum block_op_methods method,\n      just move a zero.  Otherwise, do this a piece at a time.  */\n   if (mode != BLKmode\n       && CONST_INT_P (size)\n-      && INTVAL (size) == (HOST_WIDE_INT) GET_MODE_SIZE (mode))\n+      && known_eq (INTVAL (size), GET_MODE_SIZE (mode)))\n     {\n       rtx zero = CONST0_RTX (mode);\n       if (zero != NULL)\n@@ -3508,7 +3508,7 @@ emit_move_complex (machine_mode mode, rtx x, rtx y)\n \t existing block move logic.  */\n       if (MEM_P (x) && MEM_P (y))\n \t{\n-\t  emit_block_move (x, y, GEN_INT (GET_MODE_SIZE (mode)),\n+\t  emit_block_move (x, y, gen_int_mode (GET_MODE_SIZE (mode), Pmode),\n \t\t\t   BLOCK_OP_NO_LIBCALL);\n \t  return get_last_insn ();\n \t}\n@@ -3573,9 +3573,12 @@ emit_move_multi_word (machine_mode mode, rtx x, rtx y)\n   rtx_insn *seq;\n   rtx inner;\n   bool need_clobber;\n-  int i;\n+  int i, mode_size;\n \n-  gcc_assert (GET_MODE_SIZE (mode) >= UNITS_PER_WORD);\n+  /* This function can only handle cases where the number of words is\n+     known at compile time.  */\n+  mode_size = GET_MODE_SIZE (mode).to_constant ();\n+  gcc_assert (mode_size >= UNITS_PER_WORD);\n \n   /* If X is a push on the stack, do the push now and replace\n      X with a reference to the stack pointer.  */\n@@ -3594,9 +3597,7 @@ emit_move_multi_word (machine_mode mode, rtx x, rtx y)\n   start_sequence ();\n \n   need_clobber = false;\n-  for (i = 0;\n-       i < (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n-       i++)\n+  for (i = 0; i < CEIL (mode_size, UNITS_PER_WORD); i++)\n     {\n       rtx xpart = operand_subword (x, i, 1, mode);\n       rtx ypart;\n@@ -4337,7 +4338,7 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n \t  /* A value is to be stored in an insufficiently aligned\n \t     stack slot; copy via a suitably aligned slot if\n \t     necessary.  */\n-\t  size = GEN_INT (GET_MODE_SIZE (mode));\n+\t  size = gen_int_mode (GET_MODE_SIZE (mode), Pmode);\n \t  if (!MEM_P (xinner))\n \t    {\n \t      temp = assign_temp (type, 1, 1);\n@@ -4493,9 +4494,10 @@ emit_push_insn (rtx x, machine_mode mode, tree type, rtx size,\n     }\n   else if (partial > 0)\n     {\n-      /* Scalar partly in registers.  */\n-\n-      int size = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+      /* Scalar partly in registers.  This case is only supported\n+\t for fixed-wdth modes.  */\n+      int size = GET_MODE_SIZE (mode).to_constant ();\n+      size /= UNITS_PER_WORD;\n       int i;\n       int not_stack;\n       /* # bytes of start of argument\n@@ -11158,10 +11160,13 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t  gcc_assert (!TREE_ADDRESSABLE (exp));\n \n \t\t  if (GET_MODE (op0) == BLKmode)\n-\t\t    emit_block_move (new_with_op0_mode, op0,\n-\t\t\t\t     GEN_INT (GET_MODE_SIZE (mode)),\n-\t\t\t\t     (modifier == EXPAND_STACK_PARM\n-\t\t\t\t      ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n+\t\t    {\n+\t\t      rtx size_rtx = gen_int_mode (mode_size, Pmode);\n+\t\t      emit_block_move (new_with_op0_mode, op0, size_rtx,\n+\t\t\t\t       (modifier == EXPAND_STACK_PARM\n+\t\t\t\t\t? BLOCK_OP_CALL_PARM\n+\t\t\t\t\t: BLOCK_OP_NORMAL));\n+\t\t    }\n \t\t  else\n \t\t    emit_move_insn (new_with_op0_mode, op0);\n "}, {"sha": "d1d2edb2f1fadc1ab6dff5c1841cef9fb48e0aae", "filename": "gcc/function.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2882,7 +2882,7 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n   /* Only assign_parm_setup_block knows how to deal with register arguments\n      that are padded at the least significant end.  */\n   if (REG_P (data->entry_parm)\n-      && GET_MODE_SIZE (data->promoted_mode) < UNITS_PER_WORD\n+      && known_lt (GET_MODE_SIZE (data->promoted_mode), UNITS_PER_WORD)\n       && (BLOCK_REG_PADDING (data->passed_mode, data->passed_type, 1)\n \t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n     return true;\n@@ -2945,7 +2945,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       SET_DECL_ALIGN (parm, MAX (DECL_ALIGN (parm), BITS_PER_WORD));\n       stack_parm = assign_stack_local (BLKmode, size_stored,\n \t\t\t\t       DECL_ALIGN (parm));\n-      if (GET_MODE_SIZE (GET_MODE (entry_parm)) == size)\n+      if (known_eq (GET_MODE_SIZE (GET_MODE (entry_parm)), size))\n \tPUT_MODE (stack_parm, GET_MODE (entry_parm));\n       set_mem_attributes (stack_parm, parm, 1);\n     }\n@@ -4346,8 +4346,10 @@ static void\n pad_below (struct args_size *offset_ptr, machine_mode passed_mode, tree sizetree)\n {\n   unsigned int align = PARM_BOUNDARY / BITS_PER_UNIT;\n-  if (passed_mode != BLKmode)\n-    offset_ptr->constant += -GET_MODE_SIZE (passed_mode) & (align - 1);\n+  int misalign;\n+  if (passed_mode != BLKmode\n+      && known_misalignment (GET_MODE_SIZE (passed_mode), align, &misalign))\n+    offset_ptr->constant += -misalign & (align - 1);\n   else\n     {\n       if (TREE_CODE (sizetree) != INTEGER_CST"}, {"sha": "b134c1b751526f7fd5d26d9b7cc53d4b16aaf3a0", "filename": "gcc/genmodes.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -987,10 +987,10 @@ inline __attribute__((__always_inline__))\\n\\\n #else\\n\\\n extern __inline__ __attribute__((__always_inline__, __gnu_inline__))\\n\\\n #endif\\n\\\n-unsigned short\\n\\\n+poly_uint16\\n\\\n mode_size_inline (machine_mode mode)\\n\\\n {\\n\\\n-  extern %sunsigned short mode_size[NUM_MACHINE_MODES];\\n\\\n+  extern %spoly_uint16_pod mode_size[NUM_MACHINE_MODES];\\n\\\n   gcc_assert (mode >= 0 && mode < NUM_MACHINE_MODES);\\n\\\n   switch (mode)\\n\\\n     {\\n\", adj_bytesize ? \"\" : \"const \");\n@@ -1376,11 +1376,11 @@ emit_mode_size (void)\n   int c;\n   struct mode_data *m;\n \n-  print_maybe_const_decl (\"%sunsigned short\", \"mode_size\",\n+  print_maybe_const_decl (\"%spoly_uint16_pod\", \"mode_size\",\n \t\t\t  \"NUM_MACHINE_MODES\", bytesize);\n \n   for_all_modes (c, m)\n-    tagged_printf (\"%u\", m->bytesize, m->name);\n+    tagged_printf (\"{ %u\" ZERO_COEFFS \" }\", m->bytesize, m->name);\n \n   print_closer ();\n }\n@@ -1647,17 +1647,33 @@ emit_mode_adjustments (void)\n \\nvoid\\\n \\ninit_adjust_machine_modes (void)\\\n \\n{\\\n-\\n  size_t s ATTRIBUTE_UNUSED;\");\n+\\n  poly_uint16 ps ATTRIBUTE_UNUSED;\\n\\\n+  size_t s ATTRIBUTE_UNUSED;\");\n \n   /* Size adjustments must be propagated to all containing modes.\n      A size adjustment forces us to recalculate the alignment too.  */\n   for (a = adj_bytesize; a; a = a->next)\n     {\n-      printf (\"\\n  /* %s:%d */\\n  s = %s;\\n\",\n-\t      a->file, a->line, a->adjustment);\n-      printf (\"  mode_size[E_%smode] = s;\\n\", a->mode->name);\n-      printf (\"  mode_unit_size[E_%smode] = s;\\n\", a->mode->name);\n-      printf (\"  mode_base_align[E_%smode] = s & (~s + 1);\\n\",\n+      printf (\"\\n  /* %s:%d */\\n\", a->file, a->line);\n+      switch (a->mode->cl)\n+\t{\n+\tcase MODE_VECTOR_INT:\n+\tcase MODE_VECTOR_FLOAT:\n+\tcase MODE_VECTOR_FRACT:\n+\tcase MODE_VECTOR_UFRACT:\n+\tcase MODE_VECTOR_ACCUM:\n+\tcase MODE_VECTOR_UACCUM:\n+\t  printf (\"  ps = %s;\\n\", a->adjustment);\n+\t  printf (\"  s = mode_unit_size[E_%smode];\\n\", a->mode->name);\n+\t  break;\n+\n+\tdefault:\n+\t  printf (\"  ps = s = %s;\\n\", a->adjustment);\n+\t  printf (\"  mode_unit_size[E_%smode] = s;\\n\", a->mode->name);\n+\t  break;\n+\t}\n+      printf (\"  mode_size[E_%smode] = ps;\\n\", a->mode->name);\n+      printf (\"  mode_base_align[E_%smode] = known_alignment (ps);\\n\",\n \t      a->mode->name);\n \n       for (m = a->mode->contained; m; m = m->next_cont)\n@@ -1678,11 +1694,12 @@ emit_mode_adjustments (void)\n \t    case MODE_VECTOR_UFRACT:\n \t    case MODE_VECTOR_ACCUM:\n \t    case MODE_VECTOR_UACCUM:\n-\t      printf (\"  mode_size[E_%smode] = %d*s;\\n\",\n+\t      printf (\"  mode_size[E_%smode] = %d * ps;\\n\",\n \t\t      m->name, m->ncomponents);\n \t      printf (\"  mode_unit_size[E_%smode] = s;\\n\", m->name);\n-\t      printf (\"  mode_base_align[E_%smode] = (%d*s) & (~(%d*s)+1);\\n\",\n-\t\t      m->name, m->ncomponents, m->ncomponents);\n+\t      printf (\"  mode_base_align[E_%smode]\"\n+\t\t      \" = known_alignment (%d * ps);\\n\",\n+\t\t      m->name, m->ncomponents);\n \t      break;\n \n \t    default:"}, {"sha": "7e4cb74d7cc853cb9a30004aa1769083d2068b11", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3803,7 +3803,7 @@ optimize_atomic_compare_exchange_p (gimple *stmt)\n       && optab_handler (sync_compare_and_swap_optab, mode) == CODE_FOR_nothing)\n     return false;\n \n-  if (int_size_in_bytes (etype) != GET_MODE_SIZE (mode))\n+  if (maybe_ne (int_size_in_bytes (etype), GET_MODE_SIZE (mode)))\n     return false;\n \n   return true;"}, {"sha": "9321177d761b5b72260d29aa409c42da5e0db606", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3798,8 +3798,9 @@ lhs_valid_for_store_merging_p (tree lhs)\n static bool\n rhs_valid_for_store_merging_p (tree rhs)\n {\n-  return native_encode_expr (rhs, NULL,\n-\t\t\t     GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (rhs)))) != 0;\n+  unsigned HOST_WIDE_INT size;\n+  return (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (rhs))).is_constant (&size)\n+\t  && native_encode_expr (rhs, NULL, size) != 0);\n }\n \n /* If MEM is a memory reference usable for store merging (either as"}, {"sha": "9ece3ae1d949de380eab0a4c5795dc45d25212f1", "filename": "gcc/ira-build.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -566,7 +566,7 @@ ira_create_allocno_objects (ira_allocno_t a)\n   int n = ira_reg_class_max_nregs[aclass][mode];\n   int i;\n \n-  if (GET_MODE_SIZE (mode) != 2 * UNITS_PER_WORD || n != 2)\n+  if (n != 2 || maybe_ne (GET_MODE_SIZE (mode), n * UNITS_PER_WORD))\n     n = 1;\n \n   ALLOCNO_NUM_OBJECTS (a) = n;"}, {"sha": "43f5d57cf3e6b4417a1cc05b18b59f2bba681d39", "filename": "gcc/ira-color.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3939,7 +3939,8 @@ coalesced_pseudo_reg_slot_compare (const void *v1p, const void *v2p)\n \t\t\t     regno_max_ref_mode[regno1]);\n   mode2 = wider_subreg_mode (PSEUDO_REGNO_MODE (regno2),\n \t\t\t     regno_max_ref_mode[regno2]);\n-  if ((diff = GET_MODE_SIZE (mode2) - GET_MODE_SIZE (mode1)) != 0)\n+  if ((diff = compare_sizes_for_sort (GET_MODE_SIZE (mode2),\n+\t\t\t\t      GET_MODE_SIZE (mode1))) != 0)\n     return diff;\n   return regno1 - regno2;\n }\n@@ -4228,9 +4229,10 @@ ira_sort_regnos_for_alter_reg (int *pseudo_regnos, int n,\n \t      machine_mode mode = wider_subreg_mode\n \t\t(PSEUDO_REGNO_MODE (ALLOCNO_REGNO (a)),\n \t\t reg_max_ref_mode[ALLOCNO_REGNO (a)]);\n-\t      fprintf (ira_dump_file, \" a%dr%d(%d,%d)\",\n-\t\t       ALLOCNO_NUM (a), ALLOCNO_REGNO (a), ALLOCNO_FREQ (a),\n-\t\t       GET_MODE_SIZE (mode));\n+\t      fprintf (ira_dump_file, \" a%dr%d(%d,\",\n+\t\t       ALLOCNO_NUM (a), ALLOCNO_REGNO (a), ALLOCNO_FREQ (a));\n+\t      print_dec (GET_MODE_SIZE (mode), ira_dump_file, SIGNED);\n+\t      fprintf (ira_dump_file, \")\\n\");\n \t    }\n \n \t  if (a == allocno)"}, {"sha": "2b4ae38f410c1a61ecdd9eea9fbe8d4bafe8e5e5", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1368,12 +1368,12 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n       rtx src = SET_SRC (set);\n \n       if (GET_CODE (dest) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (dest))\n-\t      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))))\n+\t  && known_eq (GET_MODE_SIZE (GET_MODE (dest)),\n+\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))))\n \tdest = SUBREG_REG (dest);\n       if (GET_CODE (src) == SUBREG\n-\t  && (GET_MODE_SIZE (GET_MODE (src))\n-\t      == GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n+\t  && known_eq (GET_MODE_SIZE (GET_MODE (src)),\n+\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (src)))))\n \tsrc = SUBREG_REG (src);\n       if (REG_P (src) && REG_P (dest)\n \t  && find_regno_note (insn, REG_DEAD, REGNO (src))"}, {"sha": "b70e2c60b745e875188a2bd2cf8a3f4701ff63a5", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -4046,9 +4046,9 @@ get_subreg_tracking_sizes (rtx x, HOST_WIDE_INT *outer_size,\n \t\t\t   HOST_WIDE_INT *inner_size, HOST_WIDE_INT *start)\n {\n   rtx reg = regno_reg_rtx[REGNO (SUBREG_REG (x))];\n-  *outer_size = GET_MODE_SIZE (GET_MODE (x));\n-  *inner_size = GET_MODE_SIZE (GET_MODE (reg));\n-  return SUBREG_BYTE (x).is_constant (start);\n+  return (GET_MODE_SIZE (GET_MODE (x)).is_constant (outer_size)\n+\t  && GET_MODE_SIZE (GET_MODE (reg)).is_constant (inner_size)\n+\t  && SUBREG_BYTE (x).is_constant (start));\n }\n \n /* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] for"}, {"sha": "32e70dcbd12be73adef472d108809d6ce295cd07", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -110,7 +110,8 @@ static inline bool\n interesting_mode_p (machine_mode mode, unsigned int *bytes,\n \t\t    unsigned int *words)\n {\n-  *bytes = GET_MODE_SIZE (mode);\n+  if (!GET_MODE_SIZE (mode).is_constant (bytes))\n+    return false;\n   *words = CEIL (*bytes, UNITS_PER_WORD);\n   return true;\n }\n@@ -667,8 +668,8 @@ simplify_gen_subreg_concatn (machine_mode outermode, rtx op,\n     {\n       rtx op2;\n \n-      if ((GET_MODE_SIZE (GET_MODE (op))\n-\t   == GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n+      if (known_eq (GET_MODE_SIZE (GET_MODE (op)),\n+\t\t    GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n \t  && known_eq (SUBREG_BYTE (op), 0))\n \treturn simplify_gen_subreg_concatn (outermode, SUBREG_REG (op),\n \t\t\t\t\t    GET_MODE (SUBREG_REG (op)), byte);\n@@ -869,8 +870,7 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n   if (GET_CODE (src) == SUBREG\n       && resolve_reg_p (SUBREG_REG (src))\n       && (maybe_ne (SUBREG_BYTE (src), 0)\n-\t  || (GET_MODE_SIZE (orig_mode)\n-\t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))))\n+\t  || maybe_ne (orig_size, GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))))\n     {\n       real_dest = dest;\n       dest = gen_reg_rtx (orig_mode);\n@@ -884,8 +884,8 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n   if (GET_CODE (dest) == SUBREG\n       && resolve_reg_p (SUBREG_REG (dest))\n       && (maybe_ne (SUBREG_BYTE (dest), 0)\n-\t  || (GET_MODE_SIZE (orig_mode)\n-\t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))))\n+\t  || maybe_ne (orig_size,\n+\t\t       GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))))\n     {\n       rtx reg, smove;\n       rtx_insn *minsn;"}, {"sha": "4d307af701138c0c4282296ad493722bc6145a23", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -591,7 +591,8 @@ get_reload_reg (enum op_type type, machine_mode mode, rtx original,\n \t      {\n \t\tif (in_subreg_p)\n \t\t  continue;\n-\t\tif (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (mode))\n+\t\tif (maybe_lt (GET_MODE_SIZE (GET_MODE (reg)),\n+\t\t\t      GET_MODE_SIZE (mode)))\n \t\t  continue;\n \t\treg = lowpart_subreg (mode, reg, GET_MODE (reg));\n \t\tif (reg == NULL_RTX || GET_CODE (reg) != SUBREG)\n@@ -827,6 +828,7 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n   ((MODE) != VOIDmode\t\t\t\t\\\n    && CONSTANT_P (X)\t\t\t\t\\\n    && GET_CODE (X) != HIGH\t\t\t\\\n+   && GET_MODE_SIZE (MODE).is_constant ()\t\\\n    && !targetm.cannot_force_const_mem (MODE, X))\n \n /* True if C is a non-empty register class that has too few registers\n@@ -1394,7 +1396,7 @@ process_addr_reg (rtx *loc, bool check_only_p, rtx_insn **before, rtx_insn **aft\n \t -fno-split-wide-types specified.  */\n       if (!REG_P (reg)\n \t  || in_class_p (reg, cl, &new_class)\n-\t  || GET_MODE_SIZE (mode) <= GET_MODE_SIZE (ptr_mode))\n+\t  || known_le (GET_MODE_SIZE (mode), GET_MODE_SIZE (ptr_mode)))\n        loc = &SUBREG_REG (*loc);\n     }\n \n@@ -1557,8 +1559,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t     a word.  */\n \t  if (!(maybe_ne (GET_MODE_PRECISION (mode),\n \t\t\t  GET_MODE_PRECISION (innermode))\n-\t\t&& GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n-\t\t&& GET_MODE_SIZE (innermode) <= UNITS_PER_WORD\n+\t\t&& known_le (GET_MODE_SIZE (mode), UNITS_PER_WORD)\n+\t\t&& known_le (GET_MODE_SIZE (innermode), UNITS_PER_WORD)\n \t\t&& WORD_REGISTER_OPERATIONS)\n \t      && (!(MEM_ALIGN (subst) < GET_MODE_ALIGNMENT (mode)\n \t\t    && targetm.slow_unaligned_access (mode, MEM_ALIGN (subst)))\n@@ -4245,7 +4247,8 @@ curr_insn_transform (bool check_only_p)\n \t\t\t\t  (ira_class_hard_regs[goal_alt[i]][0],\n \t\t\t\t   GET_MODE (reg), byte, mode) >= 0)))\n \t\t      || (partial_subreg_p (mode, GET_MODE (reg))\n-\t\t\t  && GET_MODE_SIZE (GET_MODE (reg)) <= UNITS_PER_WORD\n+\t\t\t  && known_le (GET_MODE_SIZE (GET_MODE (reg)),\n+\t\t\t\t       UNITS_PER_WORD)\n \t\t\t  && WORD_REGISTER_OPERATIONS)))\n \t\t{\n \t\t  /* An OP_INOUT is required when reloading a subreg of a\n@@ -4745,8 +4748,8 @@ lra_constraints (bool first_p)\n \t\t/* Prevent access beyond equivalent memory for\n \t\t   paradoxical subregs.  */\n \t\t|| (MEM_P (x)\n-\t\t    && (GET_MODE_SIZE (lra_reg_info[i].biggest_mode)\n-\t\t\t> GET_MODE_SIZE (GET_MODE (x))))\n+\t\t    && maybe_gt (GET_MODE_SIZE (lra_reg_info[i].biggest_mode),\n+\t\t\t\t GET_MODE_SIZE (GET_MODE (x))))\n \t\t|| (pic_offset_table_rtx\n \t\t    && ((CONST_POOL_OK_P (PSEUDO_REGNO_MODE (i), x)\n \t\t\t && (targetm.preferred_reload_class"}, {"sha": "64162c76e1afe787d2e00e9ce3bc6166aec9507f", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -107,7 +107,7 @@ struct slot\n   /* Maximum alignment required by all users of the slot.  */\n   unsigned int align;\n   /* Maximum size required by all users of the slot.  */\n-  HOST_WIDE_INT size;\n+  poly_int64 size;\n   /* Memory representing the all stack slot.  It can be different from\n      memory representing a pseudo belonging to give stack slot because\n      pseudo can be placed in a part of the corresponding stack slot.\n@@ -132,10 +132,10 @@ assign_mem_slot (int i)\n {\n   rtx x = NULL_RTX;\n   machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n-  HOST_WIDE_INT inherent_size = PSEUDO_REGNO_BYTES (i);\n+  poly_int64 inherent_size = PSEUDO_REGNO_BYTES (i);\n   machine_mode wider_mode\n     = wider_subreg_mode (mode, lra_reg_info[i].biggest_mode);\n-  HOST_WIDE_INT total_size = GET_MODE_SIZE (wider_mode);\n+  poly_int64 total_size = GET_MODE_SIZE (wider_mode);\n   poly_int64 adjust = 0;\n \n   lra_assert (regno_reg_rtx[i] != NULL_RTX && REG_P (regno_reg_rtx[i])\n@@ -191,16 +191,15 @@ pseudo_reg_slot_compare (const void *v1p, const void *v2p)\n   const int regno1 = *(const int *) v1p;\n   const int regno2 = *(const int *) v2p;\n   int diff, slot_num1, slot_num2;\n-  int total_size1, total_size2;\n \n   slot_num1 = pseudo_slots[regno1].slot_num;\n   slot_num2 = pseudo_slots[regno2].slot_num;\n   if ((diff = slot_num1 - slot_num2) != 0)\n     return (frame_pointer_needed\n \t    || (!FRAME_GROWS_DOWNWARD) == STACK_GROWS_DOWNWARD ? diff : -diff);\n-  total_size1 = GET_MODE_SIZE (lra_reg_info[regno1].biggest_mode);\n-  total_size2 = GET_MODE_SIZE (lra_reg_info[regno2].biggest_mode);\n-  if ((diff = total_size2 - total_size1) != 0)\n+  poly_int64 total_size1 = GET_MODE_SIZE (lra_reg_info[regno1].biggest_mode);\n+  poly_int64 total_size2 = GET_MODE_SIZE (lra_reg_info[regno2].biggest_mode);\n+  if ((diff = compare_sizes_for_sort (total_size2, total_size1)) != 0)\n     return diff;\n   return regno1 - regno2;\n }\n@@ -315,7 +314,8 @@ add_pseudo_to_slot (int regno, int slot_num)\n \t\t\t\t\t lra_reg_info[regno].biggest_mode);\n   unsigned int align = spill_slot_alignment (mode);\n   slots[slot_num].align = MAX (slots[slot_num].align, align);\n-  slots[slot_num].size = MAX (slots[slot_num].size, GET_MODE_SIZE (mode));\n+  slots[slot_num].size = upper_bound (slots[slot_num].size,\n+\t\t\t\t      GET_MODE_SIZE (mode));\n \n   if (slots[slot_num].regno < 0)\n     {\n@@ -580,8 +580,10 @@ lra_spill (void)\n     {\n       for (i = 0; i < slots_num; i++)\n \t{\n-\t  fprintf (lra_dump_file, \"  Slot %d regnos (width = %d):\", i,\n-\t\t   GET_MODE_SIZE (GET_MODE (slots[i].mem)));\n+\t  fprintf (lra_dump_file, \"  Slot %d regnos (width = \", i);\n+\t  print_dec (GET_MODE_SIZE (GET_MODE (slots[i].mem)),\n+\t\t     lra_dump_file, SIGNED);\n+\t  fprintf (lra_dump_file, \"):\");\n \t  for (curr_regno = slots[i].regno;;\n \t       curr_regno = pseudo_slots[curr_regno].next - pseudo_slots)\n \t    {"}, {"sha": "46be029f2551b60e63aa30f1b0096d1958ce9245", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1617,7 +1617,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n     {\n       enum mode_class mclass\n \t= bp_unpack_enum (&bp, mode_class, MAX_MODE_CLASS);\n-      unsigned int size = bp_unpack_value (&bp, 8);\n+      poly_uint16 size = bp_unpack_poly_value (&bp, 16);\n       poly_uint16 prec = bp_unpack_poly_value (&bp, 16);\n       machine_mode inner = (machine_mode) bp_unpack_value (&bp, 8);\n       poly_uint16 nunits = bp_unpack_poly_value (&bp, 16);\n@@ -1651,7 +1651,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n \t     pass ? mr = (machine_mode) (mr + 1)\n \t\t  : mr = GET_MODE_WIDER_MODE (mr).else_void ())\n \t  if (GET_MODE_CLASS (mr) != mclass\n-\t      || GET_MODE_SIZE (mr) != size\n+\t      || maybe_ne (GET_MODE_SIZE (mr), size)\n \t      || maybe_ne (GET_MODE_PRECISION (mr), prec)\n \t      || (inner == m\n \t\t  ? GET_MODE_INNER (mr) != mr"}, {"sha": "8ffcecd494cc7cc03f4956f604a45234bcc67ece", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2810,7 +2810,7 @@ lto_write_mode_table (void)\n \t    continue;\n \t  bp_pack_value (&bp, m, 8);\n \t  bp_pack_enum (&bp, mode_class, MAX_MODE_CLASS, GET_MODE_CLASS (m));\n-\t  bp_pack_value (&bp, GET_MODE_SIZE (m), 8);\n+\t  bp_pack_poly_value (&bp, GET_MODE_SIZE (m), 16);\n \t  bp_pack_poly_value (&bp, GET_MODE_PRECISION (m), 16);\n \t  bp_pack_value (&bp, GET_MODE_INNER (m), 8);\n \t  bp_pack_poly_value (&bp, GET_MODE_NUNITS (m), 16);"}, {"sha": "8e918d6dd31febb4172dd0ce7d8633f08093a166", "filename": "gcc/machmode.h", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -22,7 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n \n typedef opt_mode<machine_mode> opt_machine_mode;\n \n-extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n+extern CONST_MODE_SIZE poly_uint16_pod mode_size[NUM_MACHINE_MODES];\n extern const poly_uint16_pod mode_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n extern const poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\n@@ -514,7 +514,7 @@ complex_mode::includes_p (machine_mode m)\n \n /* Return the base GET_MODE_SIZE value for MODE.  */\n \n-ALWAYS_INLINE unsigned short\n+ALWAYS_INLINE poly_uint16\n mode_to_bytes (machine_mode mode)\n {\n #if GCC_VERSION >= 4001\n@@ -596,7 +596,29 @@ mode_to_nunits (machine_mode mode)\n \n /* Get the size in bytes of an object of mode MODE.  */\n \n-#define GET_MODE_SIZE(MODE) (mode_to_bytes (MODE))\n+#if ONLY_FIXED_SIZE_MODES\n+#define GET_MODE_SIZE(MODE) ((unsigned short) mode_to_bytes (MODE).coeffs[0])\n+#else\n+ALWAYS_INLINE poly_uint16\n+GET_MODE_SIZE (machine_mode mode)\n+{\n+  return mode_to_bytes (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_poly<typename T::measurement_type>::type\n+GET_MODE_SIZE (const T &mode)\n+{\n+  return mode_to_bytes (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_nonpoly<typename T::measurement_type>::type\n+GET_MODE_SIZE (const T &mode)\n+{\n+  return mode_to_bytes (mode).coeffs[0];\n+}\n+#endif\n \n /* Get the size in bits of an object of mode MODE.  */\n \n@@ -761,9 +783,9 @@ class fixed_size_mode\n /* Return true if MODE has a fixed size.  */\n \n inline bool\n-fixed_size_mode::includes_p (machine_mode)\n+fixed_size_mode::includes_p (machine_mode mode)\n {\n-  return true;\n+  return mode_to_bytes (mode).is_constant ();\n }\n \n /* Wrapper for mode arguments to target macros, so that if a target"}, {"sha": "3fcda29d32649c6811fbca5084c655c8ec011d07", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3404,7 +3404,8 @@ omp_clause_aligned_alignment (tree clause)\n \ttree type = lang_hooks.types.type_for_mode (mode, 1);\n \tif (type == NULL_TREE || TYPE_MODE (type) != mode)\n \t  continue;\n-\tunsigned int nelts = GET_MODE_SIZE (vmode) / GET_MODE_SIZE (mode);\n+\tpoly_uint64 nelts = exact_div (GET_MODE_SIZE (vmode),\n+\t\t\t\t       GET_MODE_SIZE (mode));\n \ttype = build_vector_type (type, nelts);\n \tif (TYPE_MODE (type) != vmode)\n \t  continue;"}, {"sha": "d70380605b2737c69f5409f55a22fd9c8d1bd600", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -213,7 +213,7 @@ get_best_extraction_insn (extraction_insn *insn,\n \t  FOR_EACH_MODE_FROM (mode_iter, mode)\n \t    {\n \t      mode = mode_iter.require ();\n-\t      if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (field_mode)\n+\t      if (maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (field_mode))\n \t\t  || TRULY_NOOP_TRUNCATION_MODES_P (insn->field_mode,\n \t\t\t\t\t\t    field_mode))\n \t\tbreak;"}, {"sha": "60119cb442ea984306f64889e4054ab343cc9611", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -327,7 +327,7 @@ expand_vec_cond_expr_p (tree value_type, tree cmp_op_type, enum tree_code code)\n \t\t\t       TYPE_MODE (cmp_op_type)) != CODE_FOR_nothing)\n     return true;\n \n-  if (GET_MODE_SIZE (value_mode) != GET_MODE_SIZE (cmp_op_mode)\n+  if (maybe_ne (GET_MODE_SIZE (value_mode), GET_MODE_SIZE (cmp_op_mode))\n       || maybe_ne (GET_MODE_NUNITS (value_mode), GET_MODE_NUNITS (cmp_op_mode)))\n     return false;\n "}, {"sha": "daac5457223232dcae76565b973ec1b9bbc7e52d", "filename": "gcc/optabs.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -5614,10 +5614,9 @@ rtx\n expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n {\n   enum insn_code icode;\n-  unsigned int i, w, u;\n+  unsigned int i, u;\n   rtx tmp, sel_qi;\n \n-  w = GET_MODE_SIZE (mode);\n   u = GET_MODE_UNIT_SIZE (mode);\n \n   if (!target || GET_MODE (target) != mode)\n@@ -5655,7 +5654,7 @@ expand_vec_perm_var (machine_mode mode, rtx v0, rtx v1, rtx sel, rtx target)\n   /* Broadcast the low byte each element into each of its bytes.\n      The encoding has U interleaved stepped patterns, one for each\n      byte of an element.  */\n-  vec_perm_builder const_sel (w, u, 3);\n+  vec_perm_builder const_sel (GET_MODE_SIZE (mode), u, 3);\n   unsigned int low_byte_in_u = BYTES_BIG_ENDIAN ? u - 1 : 0;\n   for (i = 0; i < 3; ++i)\n     for (unsigned int j = 0; j < u; ++j)\n@@ -5758,7 +5757,7 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n   unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));\n \n \n-  gcc_assert (GET_MODE_SIZE (mode) == GET_MODE_SIZE (cmp_op_mode)\n+  gcc_assert (known_eq (GET_MODE_SIZE (mode), GET_MODE_SIZE (cmp_op_mode))\n \t      && known_eq (GET_MODE_NUNITS (mode),\n \t\t\t   GET_MODE_NUNITS (cmp_op_mode)));\n \n@@ -5887,7 +5886,7 @@ expand_mult_highpart (machine_mode mode, rtx op0, rtx op1,\n   wmode = insn_data[icode].operand[0].mode;\n   gcc_checking_assert (known_eq (2 * GET_MODE_NUNITS (wmode),\n \t\t\t\t GET_MODE_NUNITS (mode)));\n-  gcc_checking_assert (GET_MODE_SIZE (wmode) == GET_MODE_SIZE (mode));\n+  gcc_checking_assert (known_eq (GET_MODE_SIZE (wmode), GET_MODE_SIZE (mode)));\n \n   create_output_operand (&eops[0], gen_reg_rtx (wmode), wmode);\n   create_input_operand (&eops[1], op0, mode);\n@@ -7035,10 +7034,12 @@ bool\n valid_multiword_target_p (rtx target)\n {\n   machine_mode mode;\n-  int i;\n+  int i, size;\n \n   mode = GET_MODE (target);\n-  for (i = 0; i < GET_MODE_SIZE (mode); i += UNITS_PER_WORD)\n+  if (!GET_MODE_SIZE (mode).is_constant (&size))\n+    return false;\n+  for (i = 0; i < size; i += UNITS_PER_WORD)\n     if (!validate_subreg (word_mode, mode, target, i))\n       return false;\n   return true;"}, {"sha": "d6aa9036f57b014fdaa4677efa46207016f69b4f", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1945,7 +1945,7 @@ offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n   int (*addressp) (machine_mode, rtx, addr_space_t) =\n     (strictp ? strict_memory_address_addr_space_p\n \t     : memory_address_addr_space_p);\n-  unsigned int mode_sz = GET_MODE_SIZE (mode);\n+  poly_int64 mode_sz = GET_MODE_SIZE (mode);\n \n   if (CONSTANT_ADDRESS_P (y))\n     return 1;\n@@ -1967,7 +1967,7 @@ offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n      Clearly that depends on the situation in which it's being used.\n      However, the current situation in which we test 0xffffffff is\n      less than ideal.  Caveat user.  */\n-  if (mode_sz == 0)\n+  if (known_eq (mode_sz, 0))\n     mode_sz = BIGGEST_ALIGNMENT / BITS_PER_UNIT;\n \n   /* If the expression contains a constant term,\n@@ -1998,7 +1998,7 @@ offsettable_address_addr_space_p (int strictp, machine_mode mode, rtx y,\n      go inside a LO_SUM here, so we do so as well.  */\n   if (GET_CODE (y) == LO_SUM\n       && mode != BLKmode\n-      && mode_sz <= GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT)\n+      && known_le (mode_sz, GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT))\n     z = gen_rtx_LO_SUM (address_mode, XEXP (y, 0),\n \t\t\tplus_constant (address_mode, XEXP (y, 1),\n \t\t\t\t       mode_sz - 1));"}, {"sha": "e2a78a2b0e15f779599b33961c6867fdd39c1207", "filename": "gcc/regcprop.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -406,8 +406,11 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n     {\n       int copy_nregs = hard_regno_nregs (copy_regno, copy_mode);\n       int use_nregs = hard_regno_nregs (copy_regno, new_mode);\n-      int copy_offset\n-\t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n+      poly_uint64 bytes_per_reg;\n+      if (!can_div_trunc_p (GET_MODE_SIZE (copy_mode),\n+\t\t\t    copy_nregs, &bytes_per_reg))\n+\treturn NULL_RTX;\n+      poly_uint64 copy_offset = bytes_per_reg * (copy_nregs - use_nregs);\n       poly_uint64 offset\n \t= subreg_size_lowpart_offset (GET_MODE_SIZE (new_mode) + copy_offset,\n \t\t\t\t      GET_MODE_SIZE (orig_mode));"}, {"sha": "f4071dac8b48406905812454a366ce14f01001d5", "filename": "gcc/reginfo.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -631,38 +631,40 @@ choose_hard_reg_mode (unsigned int regno ATTRIBUTE_UNUSED,\n \n   /* We first look for the largest integer mode that can be validly\n      held in REGNO.  If none, we look for the largest floating-point mode.\n-     If we still didn't find a valid mode, try CCmode.  */\n+     If we still didn't find a valid mode, try CCmode.\n \n+     The tests use maybe_gt rather than known_gt because we want (for example)\n+     N V4SFs to win over plain V4SF even though N might be 1.  */\n   FOR_EACH_MODE_IN_CLASS (mode, MODE_INT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n-\t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n+\t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n-\t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n+\t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FLOAT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n-\t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n+\t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_INT)\n     if (hard_regno_nregs (regno, mode) == nregs\n \t&& targetm.hard_regno_mode_ok (regno, mode)\n \t&& (!call_saved\n \t    || !targetm.hard_regno_call_part_clobbered (regno, mode))\n-\t&& GET_MODE_SIZE (mode) > GET_MODE_SIZE (found_mode))\n+\t&& maybe_gt (GET_MODE_SIZE (mode), GET_MODE_SIZE (found_mode)))\n       found_mode = mode;\n \n   if (found_mode != VOIDmode)\n@@ -1299,8 +1301,8 @@ record_subregs_of_mode (rtx subreg, bool partial_def)\n \t The size of the outer mode must ordered wrt the size of the\n \t inner mode's registers, since otherwise we wouldn't know at\n \t compile time how many registers the outer mode occupies.  */\n-      poly_uint64 size = MAX (REGMODE_NATURAL_SIZE (shape.inner_mode),\n-\t\t\t      GET_MODE_SIZE (shape.outer_mode));\n+      poly_uint64 size = ordered_max (REGMODE_NATURAL_SIZE (shape.inner_mode),\n+\t\t\t\t      GET_MODE_SIZE (shape.outer_mode));\n       gcc_checking_assert (known_lt (size, GET_MODE_SIZE (shape.inner_mode)));\n       if (known_ge (shape.offset, size))\n \tshape.offset -= size;"}, {"sha": "f930a65e0c1cddc782e6b4431bf8fc55d64ef325", "filename": "gcc/regrename.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -1697,9 +1697,11 @@ build_def_use (basic_block bb)\n \t\t     not already tracking such a reg, we won't start here,\n \t\t     and we must instead make sure to make the operand visible\n \t\t     to the machinery that tracks hard registers.  */\n+\t\t  machine_mode i_mode = recog_data.operand_mode[i];\n+\t\t  machine_mode matches_mode = recog_data.operand_mode[matches];\n \t\t  if (matches >= 0\n-\t\t      && (GET_MODE_SIZE (recog_data.operand_mode[i])\n-\t\t\t  != GET_MODE_SIZE (recog_data.operand_mode[matches]))\n+\t\t      && maybe_ne (GET_MODE_SIZE (i_mode),\n+\t\t\t\t   GET_MODE_SIZE (matches_mode))\n \t\t      && !verify_reg_in_set (op, &live_in_chains))\n \t\t    {\n \t\t      untracked_operands |= 1 << i;"}, {"sha": "beeea1f0cd5b2c4cc9982985d456506a6e6ee9d6", "filename": "gcc/regstat.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -436,8 +436,12 @@ dump_reg_info (FILE *file)\n       else if (REG_N_CALLS_CROSSED (i))\n \tfprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n       if (regno_reg_rtx[i] != NULL\n-\t  && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n-\tfprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+\t  && maybe_ne (PSEUDO_REGNO_BYTES (i), UNITS_PER_WORD))\n+\t{\n+\t  fprintf (file, \"; \");\n+\t  print_dec (PSEUDO_REGNO_BYTES (i), file, SIGNED);\n+\t  fprintf (file, \" bytes\");\n+\t}\n \n       rclass = reg_preferred_class (i);\n       altclass = reg_alternate_class (i);"}, {"sha": "88299a8a9058196e6a0f88600348fc208cc8c314", "filename": "gcc/reload.c", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -823,9 +823,11 @@ static bool\n complex_word_subreg_p (machine_mode outer_mode, rtx reg)\n {\n   machine_mode inner_mode = GET_MODE (reg);\n-  return (GET_MODE_SIZE (outer_mode) <= UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD\n-\t  && GET_MODE_SIZE (inner_mode) / UNITS_PER_WORD != REG_NREGS (reg));\n+  poly_uint64 reg_words = REG_NREGS (reg) * UNITS_PER_WORD;\n+  return (known_le (GET_MODE_SIZE (outer_mode), UNITS_PER_WORD)\n+\t  && maybe_gt (GET_MODE_SIZE (inner_mode), UNITS_PER_WORD)\n+\t  && !known_equal_after_align_up (GET_MODE_SIZE (inner_mode),\n+\t\t\t\t\t  reg_words, UNITS_PER_WORD));\n }\n \n /* Return true if X is a SUBREG that will need reloading of its SUBREG_REG\n@@ -1061,17 +1063,18 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t&& REGNO (SUBREG_REG (in)) >= FIRST_PSEUDO_REGISTER)\n \t       || MEM_P (SUBREG_REG (in)))\n \t      && (paradoxical_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n-\t\t  || (GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n+\t\t  || (known_le (GET_MODE_SIZE (inmode), UNITS_PER_WORD)\n \t\t      && is_a <scalar_int_mode> (GET_MODE (SUBREG_REG (in)),\n \t\t\t\t\t\t &inner_mode)\n \t\t      && GET_MODE_SIZE (inner_mode) <= UNITS_PER_WORD\n \t\t      && paradoxical_subreg_p (inmode, inner_mode)\n \t\t      && LOAD_EXTEND_OP (inner_mode) != UNKNOWN)\n \t\t  || (WORD_REGISTER_OPERATIONS\n \t\t      && partial_subreg_p (inmode, GET_MODE (SUBREG_REG (in)))\n-\t\t      && ((GET_MODE_SIZE (inmode) - 1) / UNITS_PER_WORD ==\n-\t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) - 1)\n-\t\t\t   / UNITS_PER_WORD)))))\n+\t\t      && (known_equal_after_align_down\n+\t\t\t  (GET_MODE_SIZE (inmode) - 1,\n+\t\t\t   GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))) - 1,\n+\t\t\t   UNITS_PER_WORD)))))\n \t  || (REG_P (SUBREG_REG (in))\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n@@ -1099,7 +1102,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t  && MEM_P (in))\n \t/* This is supposed to happen only for paradoxical subregs made by\n \t   combine.c.  (SUBREG (MEM)) isn't supposed to occur other ways.  */\n-\tgcc_assert (GET_MODE_SIZE (GET_MODE (in)) <= GET_MODE_SIZE (inmode));\n+\tgcc_assert (known_le (GET_MODE_SIZE (GET_MODE (in)),\n+\t\t\t      GET_MODE_SIZE (inmode)));\n \n       inmode = GET_MODE (in);\n     }\n@@ -1158,16 +1162,17 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t      && (paradoxical_subreg_p (outmode, GET_MODE (SUBREG_REG (out)))\n \t\t  || (WORD_REGISTER_OPERATIONS\n \t\t      && partial_subreg_p (outmode, GET_MODE (SUBREG_REG (out)))\n-\t\t      && ((GET_MODE_SIZE (outmode) - 1) / UNITS_PER_WORD ==\n-\t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1)\n-\t\t\t   / UNITS_PER_WORD)))))\n+\t\t      && (known_equal_after_align_down\n+\t\t\t  (GET_MODE_SIZE (outmode) - 1,\n+\t\t\t   GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1,\n+\t\t\t   UNITS_PER_WORD)))))\n \t  || (REG_P (SUBREG_REG (out))\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      /* The case of a word mode subreg\n \t\t is handled differently in the following statement.  */\n-\t      && ! (GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n-\t\t    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out)))\n-\t\t        > UNITS_PER_WORD))\n+\t      && ! (known_le (GET_MODE_SIZE (outmode), UNITS_PER_WORD)\n+\t\t    && maybe_gt (GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))),\n+\t\t\t\t UNITS_PER_WORD))\n \t      && !targetm.hard_regno_mode_ok (subreg_regno (out), outmode))\n \t  || (secondary_reload_class (0, rclass, outmode, out) != NO_REGS\n \t      && (secondary_reload_class (0, rclass, GET_MODE (SUBREG_REG (out)),\n@@ -1185,8 +1190,8 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n       outloc = &SUBREG_REG (out);\n       out = *outloc;\n       gcc_assert (WORD_REGISTER_OPERATIONS || !MEM_P (out)\n-\t\t  || GET_MODE_SIZE (GET_MODE (out))\n-\t\t     <= GET_MODE_SIZE (outmode));\n+\t\t  || known_le (GET_MODE_SIZE (GET_MODE (out)),\n+\t\t\t       GET_MODE_SIZE (outmode)));\n       outmode = GET_MODE (out);\n     }\n \n@@ -1593,13 +1598,13 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t       What's going on here.  */\n \t    && (in != out\n \t\t|| (GET_CODE (in) == SUBREG\n-\t\t    && (((GET_MODE_SIZE (GET_MODE (in)) + (UNITS_PER_WORD - 1))\n-\t\t\t / UNITS_PER_WORD)\n-\t\t\t== ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n-\t\t\t     + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))))\n+\t\t    && (known_equal_after_align_up\n+\t\t\t(GET_MODE_SIZE (GET_MODE (in)),\n+\t\t\t GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))),\n+\t\t\t UNITS_PER_WORD))))\n \t    /* Make sure the operand fits in the reg that dies.  */\n-\t    && (GET_MODE_SIZE (rel_mode)\n-\t\t<= GET_MODE_SIZE (GET_MODE (XEXP (note, 0))))\n+\t    && known_le (GET_MODE_SIZE (rel_mode),\n+\t\t\t GET_MODE_SIZE (GET_MODE (XEXP (note, 0))))\n \t    && targetm.hard_regno_mode_ok (regno, inmode)\n \t    && targetm.hard_regno_mode_ok (regno, outmode))\n \t  {\n@@ -1937,9 +1942,9 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \n   /* If operands exceed a word, we can't use either of them\n      unless they have the same size.  */\n-  if (GET_MODE_SIZE (outmode) != GET_MODE_SIZE (inmode)\n-      && (GET_MODE_SIZE (outmode) > UNITS_PER_WORD\n-\t  || GET_MODE_SIZE (inmode) > UNITS_PER_WORD))\n+  if (maybe_ne (GET_MODE_SIZE (outmode), GET_MODE_SIZE (inmode))\n+      && (maybe_gt (GET_MODE_SIZE (outmode), UNITS_PER_WORD)\n+\t  || maybe_gt (GET_MODE_SIZE (inmode), UNITS_PER_WORD)))\n     return 0;\n \n   /* Note that {in,out}_offset are needed only when 'in' or 'out'\n@@ -2885,8 +2890,8 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t  if (replace\n \t      && MEM_P (op)\n \t      && REG_P (reg)\n-\t      && (GET_MODE_SIZE (GET_MODE (reg))\n-\t\t  >= GET_MODE_SIZE (GET_MODE (op)))\n+\t      && known_ge (GET_MODE_SIZE (GET_MODE (reg)),\n+\t\t\t   GET_MODE_SIZE (GET_MODE (op)))\n \t      && reg_equiv_constant (REGNO (reg)) == 0)\n \t    set_unique_reg_note (emit_insn_before (gen_rtx_USE (VOIDmode, reg),\n \t\t\t\t\t\t   insn),\n@@ -3127,8 +3132,8 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \t\t\t\t   && (paradoxical_subreg_p\n \t\t\t\t       (operand_mode[i], GET_MODE (operand)))))\n \t\t\t      || BYTES_BIG_ENDIAN\n-\t\t\t      || ((GET_MODE_SIZE (operand_mode[i])\n-\t\t\t\t   <= UNITS_PER_WORD)\n+\t\t\t      || (known_le (GET_MODE_SIZE (operand_mode[i]),\n+\t\t\t\t\t    UNITS_PER_WORD)\n \t\t\t\t  && (is_a <scalar_int_mode>\n \t\t\t\t      (GET_MODE (operand), &inner_mode))\n \t\t\t\t  && (GET_MODE_SIZE (inner_mode)\n@@ -3625,7 +3630,7 @@ find_reloads (rtx_insn *insn, int replace, int ind_levels, int live_known,\n \n \t      if (! win && ! did_match\n \t\t  && this_alternative[i] != NO_REGS\n-\t\t  && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n+\t\t  && known_le (GET_MODE_SIZE (operand_mode[i]), UNITS_PER_WORD)\n \t\t  && reg_class_size [(int) preferred_class[i]] > 0\n \t\t  && ! small_register_class_p (preferred_class[i]))\n \t\t{\n@@ -6146,8 +6151,9 @@ find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n \n   if (WORD_REGISTER_OPERATIONS\n       && partial_subreg_p (outer_mode, inner_mode)\n-      && ((GET_MODE_SIZE (outer_mode) - 1) / UNITS_PER_WORD\n-          == (GET_MODE_SIZE (inner_mode) - 1) / UNITS_PER_WORD))\n+      && known_equal_after_align_down (GET_MODE_SIZE (outer_mode) - 1,\n+\t\t\t\t       GET_MODE_SIZE (inner_mode) - 1,\n+\t\t\t\t       UNITS_PER_WORD))\n     return NULL;\n \n   /* Since we don't attempt to handle paradoxical subregs, we can just"}, {"sha": "a4cc3ee02eafa7fa91e1c52877cb3a14cca364b9", "filename": "gcc/reload1.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2829,8 +2829,8 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n \n       if (new_rtx != SUBREG_REG (x))\n \t{\n-\t  int x_size = GET_MODE_SIZE (GET_MODE (x));\n-\t  int new_size = GET_MODE_SIZE (GET_MODE (new_rtx));\n+\t  poly_int64 x_size = GET_MODE_SIZE (GET_MODE (x));\n+\t  poly_int64 new_size = GET_MODE_SIZE (GET_MODE (new_rtx));\n \n \t  if (MEM_P (new_rtx)\n \t      && ((partial_subreg_p (GET_MODE (x), GET_MODE (new_rtx))\n@@ -2842,9 +2842,10 @@ eliminate_regs_1 (rtx x, machine_mode mem_mode, rtx insn,\n \t\t      So if the number of words is the same, preserve the\n \t\t      subreg so that push_reload can see it.  */\n \t\t   && !(WORD_REGISTER_OPERATIONS\n-\t\t\t&& (x_size - 1) / UNITS_PER_WORD\n-\t\t\t   == (new_size -1 ) / UNITS_PER_WORD))\n-\t\t  || x_size == new_size)\n+\t\t\t&& known_equal_after_align_down (x_size - 1,\n+\t\t\t\t\t\t\t new_size - 1,\n+\t\t\t\t\t\t\t UNITS_PER_WORD)))\n+\t\t  || known_eq (x_size, new_size))\n \t      )\n \t    return adjust_address_nv (new_rtx, GET_MODE (x), SUBREG_BYTE (x));\n \t  else if (insn && GET_CODE (insn) == DEBUG_INSN)"}, {"sha": "b7283910f74252a0f0b53d2bce2300c3a31c8796", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3346,7 +3346,7 @@ for_each_inc_dec_find_inc_dec (rtx mem, for_each_inc_dec_fn fn, void *data)\n     case PRE_INC:\n     case POST_INC:\n       {\n-\tint size = GET_MODE_SIZE (GET_MODE (mem));\n+\tpoly_int64 size = GET_MODE_SIZE (GET_MODE (mem));\n \trtx r1 = XEXP (x, 0);\n \trtx c = gen_int_mode (size, GET_MODE (r1));\n \treturn fn (mem, x, r1, r1, c, data);\n@@ -3355,7 +3355,7 @@ for_each_inc_dec_find_inc_dec (rtx mem, for_each_inc_dec_fn fn, void *data)\n     case PRE_DEC:\n     case POST_DEC:\n       {\n-\tint size = GET_MODE_SIZE (GET_MODE (mem));\n+\tpoly_int64 size = GET_MODE_SIZE (GET_MODE (mem));\n \trtx r1 = XEXP (x, 0);\n \trtx c = gen_int_mode (-size, GET_MODE (r1));\n \treturn fn (mem, x, r1, r1, c, data);\n@@ -4194,7 +4194,7 @@ rtx_cost (rtx x, machine_mode mode, enum rtx_code outer_code,\n \n   /* A size N times larger than UNITS_PER_WORD likely needs N times as\n      many insns, taking N times as long.  */\n-  factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+  factor = estimated_poly_value (GET_MODE_SIZE (mode)) / UNITS_PER_WORD;\n   if (factor == 0)\n     factor = 1;\n \n@@ -4225,7 +4225,7 @@ rtx_cost (rtx x, machine_mode mode, enum rtx_code outer_code,\n       /* A SET doesn't have a mode, so let's look at the SET_DEST to get\n \t the mode for the factor.  */\n       mode = GET_MODE (SET_DEST (x));\n-      factor = GET_MODE_SIZE (mode) / UNITS_PER_WORD;\n+      factor = estimated_poly_value (GET_MODE_SIZE (mode)) / UNITS_PER_WORD;\n       if (factor == 0)\n \tfactor = 1;\n       /* FALLTHRU */"}, {"sha": "e7273a4fdb40ae7a2d1ddc023f7896999fe5eae8", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -263,7 +263,7 @@ avoid_constant_pool_reference (rtx x)\n          If that fails we have no choice but to return the original memory.  */\n       if (offset == 0 && cmode == GET_MODE (x))\n \treturn c;\n-      else if (offset >= 0 && offset < GET_MODE_SIZE (cmode))\n+      else if (known_in_range_p (offset, 0, GET_MODE_SIZE (cmode)))\n         {\n           rtx tem = simplify_subreg (GET_MODE (x), c, cmode, offset);\n           if (tem && CONSTANT_P (tem))\n@@ -3821,13 +3821,13 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t  && GET_CODE (trueop0) == VEC_CONCAT)\n \t{\n \t  rtx vec = trueop0;\n-\t  int offset = INTVAL (XVECEXP (trueop1, 0, 0)) * GET_MODE_SIZE (mode);\n+\t  offset = INTVAL (XVECEXP (trueop1, 0, 0)) * GET_MODE_SIZE (mode);\n \n \t  /* Try to find the element in the VEC_CONCAT.  */\n \t  while (GET_MODE (vec) != mode\n \t\t && GET_CODE (vec) == VEC_CONCAT)\n \t    {\n-\t      HOST_WIDE_INT vec_size;\n+\t      poly_int64 vec_size;\n \n \t      if (CONST_INT_P (XEXP (vec, 0)))\n \t        {\n@@ -3842,13 +3842,15 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t      else\n \t        vec_size = GET_MODE_SIZE (GET_MODE (XEXP (vec, 0)));\n \n-\t      if (offset < vec_size)\n+\t      if (known_lt (offset, vec_size))\n \t\tvec = XEXP (vec, 0);\n-\t      else\n+\t      else if (known_ge (offset, vec_size))\n \t\t{\n \t\t  offset -= vec_size;\n \t\t  vec = XEXP (vec, 1);\n \t\t}\n+\t      else\n+\t\tbreak;\n \t      vec = avoid_constant_pool_reference (vec);\n \t    }\n \n@@ -3917,8 +3919,9 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n \t\t\t\t      : GET_MODE_INNER (mode));\n \n \tgcc_assert (VECTOR_MODE_P (mode));\n-\tgcc_assert (GET_MODE_SIZE (op0_mode) + GET_MODE_SIZE (op1_mode)\n-\t\t    == GET_MODE_SIZE (mode));\n+\tgcc_assert (known_eq (GET_MODE_SIZE (op0_mode)\n+\t\t\t      + GET_MODE_SIZE (op1_mode),\n+\t\t\t      GET_MODE_SIZE (mode)));\n \n \tif (VECTOR_MODE_P (op0_mode))\n \t  gcc_assert (GET_MODE_INNER (mode)\n@@ -6315,10 +6318,12 @@ simplify_subreg (machine_mode outermode, rtx op,\n   gcc_assert (GET_MODE (op) == innermode\n \t      || GET_MODE (op) == VOIDmode);\n \n-  if (!multiple_p (byte, GET_MODE_SIZE (outermode)))\n+  poly_uint64 outersize = GET_MODE_SIZE (outermode);\n+  if (!multiple_p (byte, outersize))\n     return NULL_RTX;\n \n-  if (maybe_ge (byte, GET_MODE_SIZE (innermode)))\n+  poly_uint64 innersize = GET_MODE_SIZE (innermode);\n+  if (maybe_ge (byte, innersize))\n     return NULL_RTX;\n \n   if (outermode == innermode && known_eq (byte, 0U))\n@@ -6363,6 +6368,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n   if (GET_CODE (op) == SUBREG)\n     {\n       machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n+      poly_uint64 innermostsize = GET_MODE_SIZE (innermostmode);\n       rtx newx;\n \n       if (outermode == innermostmode\n@@ -6380,12 +6386,10 @@ simplify_subreg (machine_mode outermode, rtx op,\n       /* See whether resulting subreg will be paradoxical.  */\n       if (!paradoxical_subreg_p (outermode, innermostmode))\n \t{\n-\t  /* In nonparadoxical subregs we can't handle negative offsets.  */\n-\t  if (maybe_lt (final_offset, 0))\n-\t    return NULL_RTX;\n \t  /* Bail out in case resulting subreg would be incorrect.  */\n-\t  if (!multiple_p (final_offset, GET_MODE_SIZE (outermode))\n-\t      || maybe_ge (final_offset, GET_MODE_SIZE (innermostmode)))\n+\t  if (maybe_lt (final_offset, 0)\n+\t      || maybe_ge (poly_uint64 (final_offset), innermostsize)\n+\t      || !multiple_p (final_offset, outersize))\n \t    return NULL_RTX;\n \t}\n       else\n@@ -6410,9 +6414,8 @@ simplify_subreg (machine_mode outermode, rtx op,\n \t  if (SUBREG_PROMOTED_VAR_P (op)\n \t      && SUBREG_PROMOTED_SIGN (op) >= 0\n \t      && GET_MODE_CLASS (outermode) == MODE_INT\n-\t      && IN_RANGE (GET_MODE_SIZE (outermode),\n-\t\t\t   GET_MODE_SIZE (innermode),\n-\t\t\t   GET_MODE_SIZE (innermostmode))\n+\t      && known_ge (outersize, innersize)\n+\t      && known_le (outersize, innermostsize)\n \t      && subreg_lowpart_p (newx))\n \t    {\n \t      SUBREG_PROMOTED_VAR_P (newx) = 1;\n@@ -6462,22 +6465,21 @@ simplify_subreg (machine_mode outermode, rtx op,\n          have instruction to move the whole thing.  */\n       && (! MEM_VOLATILE_P (op)\n \t  || ! have_insn_for (SET, innermode))\n-      && GET_MODE_SIZE (outermode) <= GET_MODE_SIZE (GET_MODE (op)))\n+      && known_le (outersize, innersize))\n     return adjust_address_nv (op, outermode, byte);\n \n   /* Handle complex or vector values represented as CONCAT or VEC_CONCAT\n      of two parts.  */\n   if (GET_CODE (op) == CONCAT\n       || GET_CODE (op) == VEC_CONCAT)\n     {\n-      unsigned int part_size;\n       poly_uint64 final_offset;\n       rtx part, res;\n \n       machine_mode part_mode = GET_MODE (XEXP (op, 0));\n       if (part_mode == VOIDmode)\n \tpart_mode = GET_MODE_INNER (GET_MODE (op));\n-      part_size = GET_MODE_SIZE (part_mode);\n+      poly_uint64 part_size = GET_MODE_SIZE (part_mode);\n       if (known_lt (byte, part_size))\n \t{\n \t  part = XEXP (op, 0);\n@@ -6491,7 +6493,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n       else\n \treturn NULL_RTX;\n \n-      if (maybe_gt (final_offset + GET_MODE_SIZE (outermode), part_size))\n+      if (maybe_gt (final_offset + outersize, part_size))\n \treturn NULL_RTX;\n \n       part_mode = GET_MODE (part);"}, {"sha": "e064dd8983a25d3433d03339e106e52393a85af1", "filename": "gcc/targhooks.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -795,7 +795,9 @@ default_function_arg_padding (machine_mode mode, const_tree type)\n       size = int_size_in_bytes (type);\n     }\n   else\n-    size = GET_MODE_SIZE (mode);\n+    /* Targets with variable-sized modes must override this hook\n+       and handle variable-sized modes explicitly.  */\n+    size = GET_MODE_SIZE (mode).to_constant ();\n \n   if (size < (PARM_BOUNDARY / BITS_PER_UNIT))\n     return PAD_DOWNWARD;\n@@ -1520,7 +1522,9 @@ default_addr_space_convert (rtx op ATTRIBUTE_UNUSED,\n unsigned int\n default_hard_regno_nregs (unsigned int, machine_mode mode)\n {\n-  return CEIL (GET_MODE_SIZE (mode), UNITS_PER_WORD);\n+  /* Targets with variable-sized modes must provide their own definition\n+     of this hook.  */\n+  return CEIL (GET_MODE_SIZE (mode).to_constant (), UNITS_PER_WORD);\n }\n \n bool\n@@ -1846,7 +1850,10 @@ default_class_max_nregs (reg_class_t rclass ATTRIBUTE_UNUSED,\n   return (unsigned char) CLASS_MAX_NREGS ((enum reg_class) rclass,\n \t\t\t\t\t  MACRO_MODE (mode));\n #else\n-  return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD);\n+  /* Targets with variable-sized modes must provide their own definition\n+     of this hook.  */\n+  unsigned int size = GET_MODE_SIZE (mode).to_constant ();\n+  return (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n #endif\n }\n "}, {"sha": "eb7a89a988581d5377a1ea59d1faeea6068fc929", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -4177,8 +4177,8 @@ verify_gimple_assign_binary (gassign *stmt)\n \t\t || (!INTEGRAL_TYPE_P (lhs_type)\n \t\t     && !SCALAR_FLOAT_TYPE_P (lhs_type))))\n \t    || !useless_type_conversion_p (lhs_type, rhs2_type)\n-\t    || (GET_MODE_SIZE (element_mode (rhs2_type))\n-\t\t< 2 * GET_MODE_SIZE (element_mode (rhs1_type))))\n+\t    || maybe_lt (GET_MODE_SIZE (element_mode (rhs2_type)),\n+\t\t\t 2 * GET_MODE_SIZE (element_mode (rhs1_type))))\n           {\n             error (\"type mismatch in widening sum reduction\");\n             debug_generic_expr (lhs_type);\n@@ -4197,8 +4197,8 @@ verify_gimple_assign_binary (gassign *stmt)\n         if (TREE_CODE (rhs1_type) != VECTOR_TYPE\n             || TREE_CODE (lhs_type) != VECTOR_TYPE\n \t    || !types_compatible_p (rhs1_type, rhs2_type)\n-            || (GET_MODE_SIZE (element_mode (lhs_type))\n-\t\t!= 2 * GET_MODE_SIZE (element_mode (rhs1_type))))\n+\t    || maybe_ne (GET_MODE_SIZE (element_mode (lhs_type)),\n+\t\t\t 2 * GET_MODE_SIZE (element_mode (rhs1_type))))\n           {\n             error (\"type mismatch in vector widening multiplication\");\n             debug_generic_expr (lhs_type);\n@@ -4231,8 +4231,8 @@ verify_gimple_assign_binary (gassign *stmt)\n \t\t || (INTEGRAL_TYPE_P (TREE_TYPE (rhs1_type))\n \t\t     == INTEGRAL_TYPE_P (TREE_TYPE (lhs_type))))\n \t    || !types_compatible_p (rhs1_type, rhs2_type)\n-            || (GET_MODE_SIZE (element_mode (rhs1_type))\n-\t\t!= 2 * GET_MODE_SIZE (element_mode (lhs_type))))\n+\t    || maybe_ne (GET_MODE_SIZE (element_mode (rhs1_type)),\n+\t\t\t 2 * GET_MODE_SIZE (element_mode (lhs_type))))\n           {\n             error (\"type mismatch in vector pack expression\");\n             debug_generic_expr (lhs_type);\n@@ -4532,8 +4532,8 @@ verify_gimple_assign_ternary (gassign *stmt)\n \t\t     && !SCALAR_FLOAT_TYPE_P (lhs_type))))\n \t    || !types_compatible_p (rhs1_type, rhs2_type)\n \t    || !useless_type_conversion_p (lhs_type, rhs3_type)\n-\t    || (GET_MODE_SIZE (element_mode (rhs3_type))\n-\t\t< 2 * GET_MODE_SIZE (element_mode (rhs1_type))))\n+\t    || maybe_lt (GET_MODE_SIZE (element_mode (rhs3_type)),\n+\t\t\t 2 * GET_MODE_SIZE (element_mode (rhs1_type))))\n           {\n             error (\"type mismatch in dot product reduction\");\n             debug_generic_expr (lhs_type);"}, {"sha": "5910745d0962ae0a0434a5d1e1b9ec43d136dc6d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3808,10 +3808,11 @@ estimate_move_cost (tree type, bool ARG_UNUSED (speed_p))\n   if (TREE_CODE (type) == VECTOR_TYPE)\n     {\n       scalar_mode inner = SCALAR_TYPE_MODE (TREE_TYPE (type));\n-      machine_mode simd\n-\t= targetm.vectorize.preferred_simd_mode (inner);\n-      int simd_mode_size = GET_MODE_SIZE (simd);\n-      return ((GET_MODE_SIZE (TYPE_MODE (type)) + simd_mode_size - 1)\n+      machine_mode simd = targetm.vectorize.preferred_simd_mode (inner);\n+      int orig_mode_size\n+\t= estimated_poly_value (GET_MODE_SIZE (TYPE_MODE (type)));\n+      int simd_mode_size = estimated_poly_value (GET_MODE_SIZE (simd));\n+      return ((orig_mode_size + simd_mode_size - 1)\n \t      / simd_mode_size);\n     }\n "}, {"sha": "1aad176ccbda5dffda029c51dcb6fb611631ba42", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2044,8 +2044,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t  op1 = gimple_assign_rhs1 (def_stmt);\n \t  if (conv_code == ERROR_MARK)\n \t    {\n-\t      if (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (elt->value)))\n-\t\t  != GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op1))))\n+\t      if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (elt->value))),\n+\t\t\t    GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op1)))))\n \t\treturn false;\n \t      conv_code = code;\n \t    }\n@@ -2119,8 +2119,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t= build_vector_type (build_nonstandard_integer_type (elem_size, 1),\n \t\t\t     nelts);\n       if (GET_MODE_CLASS (TYPE_MODE (mask_type)) != MODE_VECTOR_INT\n-\t  || GET_MODE_SIZE (TYPE_MODE (mask_type))\n-\t     != GET_MODE_SIZE (TYPE_MODE (type)))\n+\t  || maybe_ne (GET_MODE_SIZE (TYPE_MODE (mask_type)),\n+\t\t       GET_MODE_SIZE (TYPE_MODE (type))))\n \treturn false;\n       op2 = vec_perm_indices_to_tree (mask_type, indices);\n       if (conv_code == ERROR_MARK)"}, {"sha": "63f01d2234439ea3b42c543ec595eb1b193de863", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -3148,10 +3148,10 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n   mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n   if (((USE_LOAD_PRE_INCREMENT (mem_mode)\n \t|| USE_STORE_PRE_INCREMENT (mem_mode))\n-       && GET_MODE_SIZE (mem_mode) == cstepi)\n+       && known_eq (GET_MODE_SIZE (mem_mode), cstepi))\n       || ((USE_LOAD_PRE_DECREMENT (mem_mode)\n \t   || USE_STORE_PRE_DECREMENT (mem_mode))\n-\t  && GET_MODE_SIZE (mem_mode) == -cstepi))\n+\t  && known_eq (GET_MODE_SIZE (mem_mode), -cstepi)))\n     {\n       enum tree_code code = MINUS_EXPR;\n       tree new_base;\n@@ -3170,10 +3170,10 @@ add_autoinc_candidates (struct ivopts_data *data, tree base, tree step,\n     }\n   if (((USE_LOAD_POST_INCREMENT (mem_mode)\n \t|| USE_STORE_POST_INCREMENT (mem_mode))\n-       && GET_MODE_SIZE (mem_mode) == cstepi)\n+       && known_eq (GET_MODE_SIZE (mem_mode), cstepi))\n       || ((USE_LOAD_POST_DECREMENT (mem_mode)\n \t   || USE_STORE_POST_DECREMENT (mem_mode))\n-\t  && GET_MODE_SIZE (mem_mode) == -cstepi))\n+\t  && known_eq (GET_MODE_SIZE (mem_mode), -cstepi)))\n     {\n       add_candidate_1 (data, base, step, important, IP_AFTER_USE, use,\n \t\t       use->stmt);\n@@ -4295,7 +4295,7 @@ get_address_cost_ainc (poly_int64 ainc_step, poly_int64 ainc_offset,\n       ainc_cost_data_list[idx] = data;\n     }\n \n-  HOST_WIDE_INT msize = GET_MODE_SIZE (mem_mode);\n+  poly_int64 msize = GET_MODE_SIZE (mem_mode);\n   if (known_eq (ainc_offset, 0) && known_eq (msize, ainc_step))\n     return comp_cost (data->costs[AINC_POST_INC], 0);\n   if (known_eq (ainc_offset, 0) && known_eq (msize, -ainc_step))"}, {"sha": "26431203f11e583ccde41168ab1800d14313f973", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -2139,11 +2139,22 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n               vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n               gcc_assert (vectype);\n \n+\t      /* At present we don't support versioning for alignment\n+\t\t with variable VF, since there's no guarantee that the\n+\t\t VF is a power of two.  We could relax this if we added\n+\t\t a way of enforcing a power-of-two size.  */\n+\t      unsigned HOST_WIDE_INT size;\n+\t      if (!GET_MODE_SIZE (TYPE_MODE (vectype)).is_constant (&size))\n+\t\t{\n+\t\t  do_versioning = false;\n+\t\t  break;\n+\t\t}\n+\n               /* The rightmost bits of an aligned address must be zeros.\n                  Construct the mask needed for this test.  For example,\n                  GET_MODE_SIZE for the vector mode V4SI is 16 bytes so the\n                  mask must be 15 = 0xf. */\n-              mask = GET_MODE_SIZE (TYPE_MODE (vectype)) - 1;\n+\t      mask = size - 1;\n \n               /* FORNOW: use the same mask to test all potentially unaligned\n                  references in the loop.  The vectorizer currently supports\n@@ -6078,8 +6089,8 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \t    ;\n \t  else if (!loop_vinfo\n \t\t   || (nested_in_vect_loop\n-\t\t       && (TREE_INT_CST_LOW (DR_STEP (dr))\n-\t\t\t   != GET_MODE_SIZE (TYPE_MODE (vectype)))))\n+\t\t       && maybe_ne (TREE_INT_CST_LOW (DR_STEP (dr)),\n+\t\t\t\t    GET_MODE_SIZE (TYPE_MODE (vectype)))))\n \t    return dr_explicit_realign;\n \t  else\n \t    return dr_explicit_realign_optimized;"}, {"sha": "2fd11df6c09e1d55de146d5c59722fca6dc054cc", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -527,8 +527,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      return false;\n \t    }\n \n-\t  if ((GET_MODE_SIZE (TYPE_MODE (vectype))\n-\t       != GET_MODE_SIZE (TYPE_MODE (vf_vectype))))\n+\t  if (maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n+\t\t\tGET_MODE_SIZE (TYPE_MODE (vf_vectype))))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -6156,7 +6156,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n           if (dump_enabled_p ())\n             dump_printf (MSG_NOTE, \"op not supported by target.\\n\");\n \n-          if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n+\t  if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n \t      || !vect_worthwhile_without_simd_p (loop_vinfo, code))\n             return false;\n "}, {"sha": "27a8f7bb7ae11310e85a29f8a8ee1f5154f49602", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -4776,8 +4776,8 @@ vectorizable_assignment (gimple *stmt, gimple_stmt_iterator *gsi,\n        || code == VIEW_CONVERT_EXPR)\n       && (!vectype_in\n \t  || maybe_ne (TYPE_VECTOR_SUBPARTS (vectype_in), nunits)\n-\t  || (GET_MODE_SIZE (TYPE_MODE (vectype))\n-\t      != GET_MODE_SIZE (TYPE_MODE (vectype_in)))))\n+\t  || maybe_ne (GET_MODE_SIZE (TYPE_MODE (vectype)),\n+\t\t       GET_MODE_SIZE (TYPE_MODE (vectype_in)))))\n     return false;\n \n   /* We do not handle bit-precision changes.  */\n@@ -5147,7 +5147,7 @@ vectorizable_shift (gimple *stmt, gimple_stmt_iterator *gsi,\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n-      if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n+      if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n \t  || (!vec_stmt\n \t      && !vect_worthwhile_without_simd_p (vinfo, code)))\n         return false;\n@@ -5471,7 +5471,7 @@ vectorizable_operation (gimple *stmt, gimple_stmt_iterator *gsi,\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n-      if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n+      if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)\n \t  || (!vec_stmt && !vect_worthwhile_without_simd_p (vinfo, code)))\n         return false;\n       if (dump_enabled_p ())\n@@ -7483,7 +7483,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n      nested within an outer-loop that is being vectorized.  */\n \n   if (nested_in_vect_loop\n-      && (DR_STEP_ALIGNMENT (dr) % GET_MODE_SIZE (TYPE_MODE (vectype))) != 0)\n+      && !multiple_p (DR_STEP_ALIGNMENT (dr),\n+\t\t      GET_MODE_SIZE (TYPE_MODE (vectype))))\n     {\n       gcc_assert (alignment_support_scheme != dr_explicit_realign_optimized);\n       compute_in_loop = true;"}, {"sha": "92376d179ac4cc147df768995f5738f159bbae34", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -10570,9 +10570,9 @@ build_same_sized_truth_vector_type (tree vectype)\n   if (VECTOR_BOOLEAN_TYPE_P (vectype))\n     return vectype;\n \n-  unsigned HOST_WIDE_INT size = GET_MODE_SIZE (TYPE_MODE (vectype));\n+  poly_uint64 size = GET_MODE_SIZE (TYPE_MODE (vectype));\n \n-  if (!size)\n+  if (known_eq (size, 0U))\n     size = tree_to_uhwi (TYPE_SIZE_UNIT (vectype));\n \n   return build_truth_vector_type (TYPE_VECTOR_SUBPARTS (vectype), size);"}, {"sha": "4741d0010717eaa2bfabc29e9c2d2103f5282b4c", "filename": "gcc/valtrack.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -94,13 +94,15 @@ cleanup_auto_inc_dec (rtx src, machine_mode mem_mode ATTRIBUTE_UNUSED)\n \n     case PRE_INC:\n     case PRE_DEC:\n-      gcc_assert (mem_mode != VOIDmode && mem_mode != BLKmode);\n-      return gen_rtx_PLUS (GET_MODE (x),\n-\t\t\t   cleanup_auto_inc_dec (XEXP (x, 0), mem_mode),\n-\t\t\t   gen_int_mode (code == PRE_INC\n-\t\t\t\t\t ? GET_MODE_SIZE (mem_mode)\n-\t\t\t\t\t : -GET_MODE_SIZE (mem_mode),\n-\t\t\t\t\t GET_MODE (x)));\n+      {\n+\tgcc_assert (mem_mode != VOIDmode && mem_mode != BLKmode);\n+\tpoly_int64 offset = GET_MODE_SIZE (mem_mode);\n+\tif (code == PRE_DEC)\n+\t  offset = -offset;\n+\treturn gen_rtx_PLUS (GET_MODE (x),\n+\t\t\t     cleanup_auto_inc_dec (XEXP (x, 0), mem_mode),\n+\t\t\t     gen_int_mode (offset, GET_MODE (x)));\n+      }\n \n     case POST_INC:\n     case POST_DEC:"}, {"sha": "fbb63dbc305f0d49a2873bfb94d262f822e17231", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf098191e47535b89373dccb9a2d3cc4a4ebaef7/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=cf098191e47535b89373dccb9a2d3cc4a4ebaef7", "patch": "@@ -8685,7 +8685,7 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n     {\n       machine_mode mode, wider_mode;\n       rtx loc2;\n-      HOST_WIDE_INT offset;\n+      HOST_WIDE_INT offset, size, wider_size;\n \n       if (i == 0 && var->onepart)\n \t{\n@@ -8740,14 +8740,22 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n       mode = GET_MODE (var->var_part[i].cur_loc);\n       if (mode == VOIDmode && var->onepart)\n \tmode = DECL_MODE (decl);\n-      last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n+      /* We ony track subparts of constant-sized objects, since at present\n+\t there's no representation for polynomial pieces.  */\n+      if (!GET_MODE_SIZE (mode).is_constant (&size))\n+\t{\n+\t  complete = false;\n+\t  continue;\n+\t}\n+      last_limit = offsets[n_var_parts] + size;\n \n       /* Attempt to merge adjacent registers or memory.  */\n       for (j = i + 1; j < var->n_var_parts; j++)\n \tif (last_limit <= VAR_PART_OFFSET (var, j))\n \t  break;\n       if (j < var->n_var_parts\n \t  && GET_MODE_WIDER_MODE (mode).exists (&wider_mode)\n+\t  && GET_MODE_SIZE (wider_mode).is_constant (&wider_size)\n \t  && var->var_part[j].cur_loc\n \t  && mode == GET_MODE (var->var_part[j].cur_loc)\n \t  && (REG_P (loc[n_var_parts]) || MEM_P (loc[n_var_parts]))\n@@ -8785,14 +8793,12 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n \t      if ((REG_P (XEXP (loc[n_var_parts], 0))\n \t\t   && rtx_equal_p (XEXP (loc[n_var_parts], 0),\n \t\t\t\t   XEXP (XEXP (loc2, 0), 0))\n-\t\t   && INTVAL (XEXP (XEXP (loc2, 0), 1))\n-\t\t      == GET_MODE_SIZE (mode))\n+\t\t   && INTVAL (XEXP (XEXP (loc2, 0), 1)) == size)\n \t\t  || (GET_CODE (XEXP (loc[n_var_parts], 0)) == PLUS\n \t\t      && CONST_INT_P (XEXP (XEXP (loc[n_var_parts], 0), 1))\n \t\t      && rtx_equal_p (XEXP (XEXP (loc[n_var_parts], 0), 0),\n \t\t\t\t      XEXP (XEXP (loc2, 0), 0))\n-\t\t      && INTVAL (XEXP (XEXP (loc[n_var_parts], 0), 1))\n-\t\t\t + GET_MODE_SIZE (mode)\n+\t\t      && INTVAL (XEXP (XEXP (loc[n_var_parts], 0), 1)) + size\n \t\t\t == INTVAL (XEXP (XEXP (loc2, 0), 1))))\n \t\tnew_loc = adjust_address_nv (loc[n_var_parts],\n \t\t\t\t\t     wider_mode, 0);\n@@ -8802,7 +8808,7 @@ emit_note_insn_var_location (variable **varp, emit_note_data *data)\n \t    {\n \t      loc[n_var_parts] = new_loc;\n \t      mode = wider_mode;\n-\t      last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n+\t      last_limit = offsets[n_var_parts] + wider_size;\n \t      i = j;\n \t    }\n \t}"}]}