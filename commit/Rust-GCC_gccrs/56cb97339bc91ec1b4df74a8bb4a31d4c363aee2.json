{"sha": "56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjYjk3MzM5YmM5MWVjMWI0ZGY3NGE4YmI0YTMxZDRjMzYzYWVlMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-09-10T21:34:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-09-10T21:34:41Z"}, "message": "c-common.h (add_stmt): Change prototype.\n\n\t* c-common.h (add_stmt): Change prototype.\n\t(RECHAIN_STMTS): New macro.\n\t(CASE_LABEL_DECL): Likewise.\n\t(genrtl_case_label): Change prototype.\n\t(c_expand_start_case): Remove prototype.\n\t(build_case_label): Change prototype.\n\t(decl_constant_value): Declare.\n\t* c-common.c (check_case_value): Handle C++'s extensions to C\n\tsemantics.\n\t* c-commnon.def (CASE_LABEL): Add room for the CASE_LABEL_DECL\n\tfield.\n\t* c-parse.in (stmt): Adjust handling of return statements and case\n\tlaels.\n\t* c-semantics.c (add_stmt): Return the new statement.\n\t(genrtl_return_stmt): Take the RETURN_STMT as input, not the\n\treturned expression.  Directly generate RTL, rather than calling\n\tc_expand_return.\n\t(genrtl_switch_stmt): Don't call c_expand_start_case.\n\t(build_case_label): Take the LABEL_DECL as input, too.\n\t(genrtl_case_label): Just call add_case_node.\n\t(expand_stmt): Adjust calls to genrtl_return_stmt and\n\tgenrtl_case_label.\n\t* c-tree.h (c_expand_start_case): Declare.\n\t* c-typeck.c (decl_constant_value): Give it external linkage.\n\t(c_expand_return): Don't call expand_return or expand_null_return;\n\tuse genrtl_return_stmt instead.\n\t* stmt.c (struct nesting): Remove num_ranges field.\n\t(add_case_node): Give it external linkage.\n\t(expand_start_case): Don't set num_ranges.\n\t(expand_start_case_dummy): Don't clear it.\n\t(pushcase): Rely on add_case_node to handle `default' labels.\n\t(add_case_node): Handle `default' labels.\n\t* tree.c (tree_int_cst_compare): New function.\n\t* tree.h (tree_int_cst_compare): Declare.\n\t(add_case_node): Likewise.\n\n\t* cp-tree.h (push_switch): Change prototype.\n\t(check_cp_case_value): Remove declaration.\n\t(decl_constant_value): Likewise.\n\t* decl.c (struct cp_switch): Add switch_stmt and cases.\n\t(case_compare): New function.\n\t(push_switch): Set switch_stmt.  Initialize cases.\n\t(pop_switch): Clean up cases.\n\t(define_case_label): Rename to ...\n\t(finish_case_label): ... this.  Do semantic analysis for case\n\tlabels here.\n\t(start_function): Correct comment.\n\t* decl2.c (check_cp_case_value): Remove.\n\t* expr.c (do_case): Remove.\n\t* pt.c (tsubst_expr): Adjust call to finish_case_label.\n\t* semantics.c (genrtl_do_poplevel): Remove declaration.\n\t(RECHAIN_STMTS): Remove.\n\t(finish_break_stmt): Use build_break_stmt.\n\t(finish_continue_stmt): Use build_continue_stmt.\n\t(finish_switch_cond): Adjust condition here, rater than in\n\tc_expand_start_case.\n\t(finish_case_label): Remove.\n\t* typeck.c (c_expand_return): Remove.\n\t(c_expand_start_case): Likewise.\n\nFrom-SVN: r36305", "tree": {"sha": "e6b472ea3504de9f1d42acce2241fe0cbaf55dcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6b472ea3504de9f1d42acce2241fe0cbaf55dcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/comments", "author": null, "committer": null, "parents": [{"sha": "2c9f4db73acfb821ad776df950e908daac642530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c9f4db73acfb821ad776df950e908daac642530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c9f4db73acfb821ad776df950e908daac642530"}], "stats": {"total": 664, "additions": 387, "deletions": 277}, "files": [{"sha": "e03db7dfa854ec45799b195057c2c0d3da067436", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -1,3 +1,41 @@\n+2000-09-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* c-common.h (add_stmt): Change prototype.\n+\t(RECHAIN_STMTS): New macro.\n+\t(CASE_LABEL_DECL): Likewise.\n+\t(genrtl_case_label): Change prototype.\n+\t(c_expand_start_case): Remove prototype.\n+\t(build_case_label): Change prototype.\n+\t(decl_constant_value): Declare.\n+\t* c-common.c (check_case_value): Handle C++'s extensions to C\n+\tsemantics.\n+\t* c-commnon.def (CASE_LABEL): Add room for the CASE_LABEL_DECL\n+\tfield. \n+\t* c-parse.in (stmt): Adjust handling of return statements and case\n+\tlaels.\n+\t* c-semantics.c (add_stmt): Return the new statement.\n+\t(genrtl_return_stmt): Take the RETURN_STMT as input, not the\n+\treturned expression.  Directly generate RTL, rather than calling\n+\tc_expand_return.\n+\t(genrtl_switch_stmt): Don't call c_expand_start_case.\n+\t(build_case_label): Take the LABEL_DECL as input, too.\n+\t(genrtl_case_label): Just call add_case_node.\n+\t(expand_stmt): Adjust calls to genrtl_return_stmt and\n+\tgenrtl_case_label.\n+\t* c-tree.h (c_expand_start_case): Declare.\n+\t* c-typeck.c (decl_constant_value): Give it external linkage.\n+\t(c_expand_return): Don't call expand_return or expand_null_return;\n+\tuse genrtl_return_stmt instead.\n+\t* stmt.c (struct nesting): Remove num_ranges field.\n+\t(add_case_node): Give it external linkage.\n+\t(expand_start_case): Don't set num_ranges.\n+\t(expand_start_case_dummy): Don't clear it.\n+\t(pushcase): Rely on add_case_node to handle `default' labels.\n+\t(add_case_node): Handle `default' labels.\n+\t* tree.c (tree_int_cst_compare): New function.\n+\t* tree.h (tree_int_cst_compare): Declare.\n+\t(add_case_node): Likewise.\n+\n 2000-09-10  Richard Henderson  <rth@cygnus.com>\n \n \t* c-parse.in: Revert last change."}, {"sha": "5e093372121f4e26a6791f2f3c57bcfc95525894", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -2678,6 +2678,18 @@ check_case_value (value)\n \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (value);\n+  /* In C++, the following is allowed:\n+\n+       const int i = 3;\n+       switch (...) { case i: ... }\n+\n+     So, we try to reduce the VALUE to a constant that way.  */\n+  if (c_language == clk_cplusplus)\n+    {\n+      value = decl_constant_value (value);\n+      STRIP_TYPE_NOPS (value);\n+      value = fold (value);\n+    }\n \n   if (TREE_CODE (value) != INTEGER_CST\n       && value != error_mark_node)"}, {"sha": "b262dd763859183e6ca5f77c656fe96359b70f05", "filename": "gcc/c-common.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -95,8 +95,8 @@ DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n /* Used to represent a CASE_LABEL. The operands are CASE_LOW and\n    CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n    'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case\n-   label. */\n-DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n+   label.  The CASE_LABEL_DECL is a LABEL_DECL for this node.  */\n+DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 3)\n \n /* A STMT_EXPR represents a statement-expression.  The\n    STMT_EXPR_STMT is the statement given by the expression.  */"}, {"sha": "4fb65608b7ea15adc64b508613b77c8821d48991", "filename": "gcc/c-common.h", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -256,7 +256,7 @@ typedef tree (*walk_tree_fn)                    PARAMS ((tree *,\n \n extern stmt_tree current_stmt_tree              PARAMS ((void));\n extern void begin_stmt_tree                     PARAMS ((tree *));\n-extern void add_stmt\t\t\t\tPARAMS ((tree));\n+extern tree add_stmt\t\t\t\tPARAMS ((tree));\n extern void finish_stmt_tree                    PARAMS ((tree *));\n \n extern int statement_code_p                     PARAMS ((enum tree_code));\n@@ -268,6 +268,18 @@ extern void prep_stmt                           PARAMS ((tree));\n extern void (*lang_expand_stmt)                 PARAMS ((tree));\n extern void expand_stmt                         PARAMS ((tree));\n \n+/* LAST_TREE contains the last statement parsed.  These are chained\n+   together through the TREE_CHAIN field, but often need to be\n+   re-organized since the parse is performed bottom-up.  This macro\n+   makes LAST_TREE the indicated SUBSTMT of STMT.  */\n+\n+#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    substmt = TREE_CHAIN (stmt);\t\t\\\n+    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n+    last_tree = stmt;\t\t\t\t\\\n+  } while (0)\n+\n /* The variant of the C language being processed.  Each C language\n    front-end defines this variable.  */\n \n@@ -457,6 +469,7 @@ extern tree simple_type_promotes_to\t\tPARAMS ((tree));\n    of a case label, respectively. */\n #define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n #define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n+#define CASE_LABEL_DECL(NODE)   TREE_OPERAND (CASE_LABEL_CHECK (NODE), 2)\n \n /* GOTO_STMT accessor. This gives access to the label associated with\n    a goto statement. */\n@@ -570,7 +583,7 @@ extern void genrtl_break_stmt                   PARAMS ((void));\n extern void genrtl_continue_stmt                PARAMS ((void));\n extern void genrtl_scope_stmt                   PARAMS ((tree));\n extern void genrtl_switch_stmt                  PARAMS ((tree));\n-extern void genrtl_case_label                   PARAMS ((tree, tree));\n+extern void genrtl_case_label                   PARAMS ((tree));\n extern void genrtl_compound_stmt                PARAMS ((tree));\n extern void genrtl_asm_stmt                     PARAMS ((tree, tree,\n \t\t\t\t\t\t\t tree, tree,\n@@ -589,10 +602,9 @@ extern void emit_local_var                      PARAMS ((tree));\n extern void make_rtl_for_local_static           PARAMS ((tree));\n extern tree expand_cond                         PARAMS ((tree));\n extern void c_expand_return\t\t\tPARAMS ((tree));\n-extern tree c_expand_start_case\t\t\tPARAMS ((tree));\n extern void do_case\t\t\t\tPARAMS ((tree, tree));\n extern tree build_stmt                          PARAMS ((enum tree_code, ...));\n-extern tree build_case_label                    PARAMS ((tree, tree));\n+extern tree build_case_label                    PARAMS ((tree, tree, tree));\n extern tree build_continue_stmt                 PARAMS ((void));\n extern tree build_break_stmt                    PARAMS ((void));\n extern tree build_return_stmt                   PARAMS ((tree));\n@@ -620,6 +632,8 @@ extern tree common_type                         PARAMS ((tree, tree));\n \n extern tree expand_tree_builtin                 PARAMS ((tree, tree, tree));\n \n+extern tree decl_constant_value\t\tPARAMS ((tree));\n+\n /* Hook currently used only by the C++ front end to reset internal state\n    after entering or leaving a header file.  */\n extern void extract_interface_info\t\tPARAMS ((void));"}, {"sha": "bd9e652de89651e7f4cabb1450ff9e6dfd9b550c", "filename": "gcc/c-parse.in", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -1879,13 +1879,11 @@ stmt:\n                   stmt_count++;\n \t\t  genrtl_continue_stmt (); }\n \t| RETURN ';'\n-                { tree return_stmt = build_return_stmt (NULL_TREE);\n-                  stmt_count++;\n-\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n+                { stmt_count++;\n+\t\t  c_expand_return (NULL_TREE); }\n \t| RETURN expr ';'\n-                { tree return_stmt = build_return_stmt ($2);\n-                  stmt_count++;\n-\t\t  genrtl_return_stmt (RETURN_EXPR(return_stmt)); }\n+                { stmt_count++;\n+\t\t  c_expand_return ($2); }\n \t| ASM_KEYWORD maybe_type_qual '(' expr ')' ';'\n \t\t{ stmt_count++;\n \t\t  emit_line_note ($<filename>-1, $<lineno>0);\n@@ -1943,20 +1941,14 @@ stmt:\n    also at the end of a compound statement.  */\n \n label:\t  CASE expr_no_commas ':'\n-                { tree case_label_tree = build_case_label ($2, NULL_TREE);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t}\n+                { stmt_count++;\n+\t\t  do_case ($2, NULL_TREE); }\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-                { tree case_label_tree = build_case_label ($2, $4);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t}\n+                { stmt_count++;\n+\t\t  do_case ($2, $4); }\n \t| DEFAULT ':'\n-                { tree case_label_tree = build_case_label (NULL_TREE, NULL_TREE);\n-\t\t  stmt_count++;\n-\t\t  genrtl_case_label(CASE_LOW(case_label_tree), CASE_HIGH(case_label_tree));\n-\t\t}\n+                { stmt_count++;\n+\t\t  do_case (NULL_TREE, NULL_TREE); }\n \t| identifier save_filename save_lineno ':' maybe_attribute\n \t\t{ tree label = define_label ($2, $3, $1);\n \t\t  stmt_count++;"}, {"sha": "991311ef1171623c33148d1ab9cb573cac46ec83", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -58,7 +58,7 @@ begin_stmt_tree (t)\n \n /* T is a statement.  Add it to the statement-tree.  */\n \n-void\n+tree\n add_stmt (t)\n      tree t;\n {\n@@ -68,6 +68,7 @@ add_stmt (t)\n   /* When we expand a statement-tree, we must know whether or not the\n      statements are full-expresions.  We record that fact here.  */\n   STMT_IS_FULL_EXPR_P (last_tree) = stmts_are_full_exprs_p ();\n+  return t;\n }\n \n /* Remove declarations of internal variables that are not used from a\n@@ -434,14 +435,23 @@ build_return_stmt (expr)\n   return (build_stmt (RETURN_STMT, expr));\n }\n \n-/* Generate the RTL for EXPR, which is a RETURN_STMT. */\n+/* Generate the RTL for STMT, which is a RETURN_STMT. */\n \n void\n-genrtl_return_stmt (expr)\n-     tree expr;\n+genrtl_return_stmt (stmt)\n+     tree stmt;\n {\n+  tree expr = RETURN_EXPR (stmt);\n+\n   emit_line_note (input_filename, lineno);\n-  c_expand_return (expr);\n+  if (!expr)\n+    expand_null_return ();\n+  else\n+    {\n+      expand_start_target_temps ();\n+      expand_return (expr);\n+      expand_end_target_temps ();\n+    }\n }\n \n /* Generate the RTL for T, which is a FOR_STMT. */\n@@ -547,40 +557,38 @@ genrtl_switch_stmt (t)\n   genrtl_do_pushlevel ();\n  \n   cond = expand_cond (SWITCH_COND (t));\n-  if (cond != error_mark_node)\n-    {\n-      emit_line_note (input_filename, lineno);\n-      c_expand_start_case (cond);\n-    }\n-  else\n+  if (cond == error_mark_node)\n     /* The code is in error, but we don't want expand_end_case to\n        crash. */\n-    c_expand_start_case (boolean_false_node);\n+    cond = boolean_false_node;\n \n+  emit_line_note (input_filename, lineno);\n+  expand_start_case (1, cond, TREE_TYPE (cond), \"switch statement\");\n   expand_stmt (SWITCH_BODY (t));\n-\n   expand_end_case (cond);\n }\n \n /* Create a CASE_LABEL tree node and return it. */\n \n tree\n-build_case_label (low_value, high_value)\n+build_case_label (low_value, high_value, label_decl)\n      tree low_value;\n      tree high_value;\n+     tree label_decl;\n {\n-  return build_stmt (CASE_LABEL, low_value, high_value);\n+  return build_stmt (CASE_LABEL, low_value, high_value, label_decl);\n }\n \n \n /* Generate the RTL for a CASE_LABEL. */\n \n void \n-genrtl_case_label (low_value, high_value)\n-     tree low_value;\n-     tree high_value;\n+genrtl_case_label (case_label)\n+     tree case_label;\n {\n-  do_case (low_value, high_value);\n+  tree duplicate;\n+  add_case_node (CASE_LOW (case_label), CASE_HIGH (case_label), \n+\t\t CASE_LABEL_DECL (case_label), &duplicate);\n }\n \n /* Generate the RTL for T, which is a COMPOUND_STMT. */\n@@ -677,7 +685,7 @@ expand_stmt (t)\n       switch (TREE_CODE (t))\n \t{\n \tcase RETURN_STMT:\n-\t  genrtl_return_stmt (RETURN_EXPR (t));\n+\t  genrtl_return_stmt (t);\n \t  break;\n \n \tcase EXPR_STMT:\n@@ -721,7 +729,7 @@ expand_stmt (t)\n \t  break;\n \n \tcase CASE_LABEL:\n-\t  genrtl_case_label (CASE_LOW (t), CASE_HIGH (t));\n+\t  genrtl_case_label (t);\n \t  break;\n \n \tcase LABEL_STMT:"}, {"sha": "92f0b4533290e9d46fe1bac278ba05a547349eb3", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -268,6 +268,7 @@ extern void set_init_label\t\t\tPARAMS ((tree));\n extern void process_init_element\t\tPARAMS ((tree));\n extern void pedwarn_c99\t\t\t\tPARAMS ((const char *, ...))\n \t\t\t\t\t\t\tATTRIBUTE_PRINTF_1;\n+extern tree c_expand_start_case                 PARAMS ((tree));\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "49227ff82c5c1f0194f757b49a8c90bb2222669e", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -54,7 +54,6 @@ static tree qualify_type\t\tPARAMS ((tree, tree));\n static int comp_target_types\t\tPARAMS ((tree, tree));\n static int function_types_compatible_p\tPARAMS ((tree, tree));\n static int type_lists_compatible_p\tPARAMS ((tree, tree));\n-static tree decl_constant_value\t\tPARAMS ((tree));\n static tree lookup_field\t\tPARAMS ((tree, tree, tree *));\n static tree convert_arguments\t\tPARAMS ((tree, tree, tree, tree));\n static tree pointer_int_sum\t\tPARAMS ((enum tree_code, tree, tree));\n@@ -838,7 +837,7 @@ c_alignof_expr (expr)\n \n /* Return either DECL or its known constant value (if it has one).  */\n \n-static tree\n+tree\n decl_constant_value (decl)\n      tree decl;\n {\n@@ -6629,14 +6628,12 @@ c_expand_return (retval)\n       if ((warn_return_type || flag_isoc99)\n \t  && valtype != 0 && TREE_CODE (valtype) != VOID_TYPE)\n \tpedwarn_c99 (\"`return' with no value, in function returning non-void\");\n-      expand_null_return ();\n     }\n   else if (valtype == 0 || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n       if (pedantic || TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n \tpedwarn (\"`return' with a value, in function returning void\");\n-      expand_return (retval);\n     }\n   else\n     {\n@@ -6701,11 +6698,11 @@ c_expand_return (retval)\n \t  break;\n \t}\n \n-      t = build (MODIFY_EXPR, TREE_TYPE (res), res, t);\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_return (t);\n+      retval = build (MODIFY_EXPR, TREE_TYPE (res), res, t);\n       current_function_returns_value = 1;\n     }\n+\n+  genrtl_return_stmt (build_return_stmt (retval));\n }\n \f\n /* Start a C switch statement, testing expression EXP."}, {"sha": "1ba64f02baccf31125953c2752dc1dcef07a7370", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -1,3 +1,29 @@\n+2000-09-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (push_switch): Change prototype.\n+\t(check_cp_case_value): Remove declaration.\n+\t(decl_constant_value): Likewise.\n+\t* decl.c (struct cp_switch): Add switch_stmt and cases.\n+\t(case_compare): New function.\n+\t(push_switch): Set switch_stmt.  Initialize cases.\n+\t(pop_switch): Clean up cases.\n+\t(define_case_label): Rename to ...\n+\t(finish_case_label): ... this.  Do semantic analysis for case\n+\tlabels here.\n+\t(start_function): Correct comment.\n+\t* decl2.c (check_cp_case_value): Remove.\n+\t* expr.c (do_case): Remove.\n+\t* pt.c (tsubst_expr): Adjust call to finish_case_label.\n+\t* semantics.c (genrtl_do_poplevel): Remove declaration.\n+\t(RECHAIN_STMTS): Remove.\n+\t(finish_break_stmt): Use build_break_stmt.\n+\t(finish_continue_stmt): Use build_continue_stmt.\n+\t(finish_switch_cond): Adjust condition here, rater than in\n+\tc_expand_start_case.\n+\t(finish_case_label): Remove.\n+\t* typeck.c (c_expand_return): Remove.\n+\t(c_expand_start_case): Likewise.\n+\t\n 2000-09-07  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* ir.texi: Document type nodes."}, {"sha": "8dbb82e29ad1da4659944c09e8ccae540552d791", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -3829,7 +3829,7 @@ extern void pop_nested_namespace\t\tPARAMS ((tree));\n extern void maybe_push_to_top_level\t\tPARAMS ((int));\n extern void push_to_top_level\t\t\tPARAMS ((void));\n extern void pop_from_top_level\t\t\tPARAMS ((void));\n-extern void push_switch\t\t\t\tPARAMS ((void));\n+extern void push_switch\t\t\t\tPARAMS ((tree));\n extern void pop_switch\t\t\t\tPARAMS ((void));\n extern tree identifier_type_value\t\tPARAMS ((tree));\n extern void set_identifier_type_value\t\tPARAMS ((tree, tree));\n@@ -3990,7 +3990,6 @@ extern tree reparse_absdcl_as_casts\t\tPARAMS ((tree, tree));\n extern tree build_expr_from_tree\t\tPARAMS ((tree));\n extern tree reparse_decl_as_expr\t\tPARAMS ((tree, tree));\n extern tree finish_decl_parsing\t\t\tPARAMS ((tree));\n-extern tree check_cp_case_value\t\t\tPARAMS ((tree));\n extern void set_decl_namespace                  PARAMS ((tree, tree, int));\n extern tree current_decl_namespace              PARAMS ((void));\n extern void push_decl_namespace                 PARAMS ((tree));\n@@ -4075,7 +4074,6 @@ extern tree get_type_value\t\t\tPARAMS ((tree));\n extern tree build_member_call\t\t\tPARAMS ((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPARAMS ((tree, tree));\n extern tree resolve_offset_ref\t\t\tPARAMS ((tree));\n-extern tree decl_constant_value\t\t\tPARAMS ((tree));\n extern tree build_new\t\t\t\tPARAMS ((tree, tree, tree, int));\n extern tree build_vec_init\t\t\tPARAMS ((tree, tree, tree, tree, int));\n extern tree build_x_delete\t\t\tPARAMS ((tree, int, tree));"}, {"sha": "9ac30e40832cd282c65534dceda13f58c7751747", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 188, "deletions": 6, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -187,6 +187,7 @@ static tree check_special_function_return_type\n   PARAMS ((special_function_kind, tree, tree, tree));\n static tree push_cp_library_fn PARAMS ((enum tree_code, tree));\n static tree build_cp_library_fn PARAMS ((tree, enum tree_code, tree));\n+static int case_compare PARAMS ((splay_tree_key, splay_tree_key));\n \n #if defined (DEBUG_CP_BINDING_LEVELS)\n static void indent PARAMS ((void));\n@@ -5176,17 +5177,52 @@ struct cp_switch\n {\n   struct binding_level *level;\n   struct cp_switch *next;\n+  /* The SWITCH_STMT being built.  */\n+  tree switch_stmt;\n+  /* A splay-tree mapping the low element of a case range to the high\n+     element, or NULL_TREE if there is no high element.  Used to\n+     determine whether or not a new case label duplicates an old case\n+     label.  We need a tree, rather than simply a hash table, because\n+     of the GNU case range extension.  */\n+  splay_tree cases;\n };\n \n+/* A stack of the currently active switch statements.  The innermost\n+   switch statement is on the top of the stack.  There is no need to\n+   mark the stack for garbage collection because it is only active\n+   during the processing of the body of a function, and we never\n+   collect at that point.  */\n+   \n static struct cp_switch *switch_stack;\n \n+static int\n+case_compare (k1, k2)\n+     splay_tree_key k1;\n+     splay_tree_key k2;\n+{\n+  /* Consider a NULL key (such as arises with a `default' label) to be\n+     smaller than anything else.  */\n+  if (!k1)\n+    return k2 ? -1 : 0;\n+  else if (!k2)\n+    return k1 ? 1 : 0;\n+\n+  return tree_int_cst_compare ((tree) k1, (tree) k2);\n+}\n+\n+/* Called right after a switch-statement condition is parsed.\n+   SWITCH_STMT is the switch statement being parsed.  */\n+\n void\n-push_switch ()\n+push_switch (switch_stmt)\n+     tree switch_stmt;\n {\n   struct cp_switch *p\n     = (struct cp_switch *) xmalloc (sizeof (struct cp_switch));\n   p->level = current_binding_level;\n   p->next = switch_stack;\n+  p->switch_stmt = switch_stmt;\n+  p->cases = splay_tree_new (case_compare, NULL, NULL);\n   switch_stack = p;\n }\n \n@@ -5196,6 +5232,7 @@ pop_switch ()\n   struct cp_switch *cs;\n   \n   cs = switch_stack;\n+  splay_tree_delete (cs->cases);\n   switch_stack = switch_stack->next;\n   free (cs);\n }\n@@ -5204,14 +5241,150 @@ pop_switch ()\n    is a bad place for one.  */\n \n void\n-define_case_label ()\n+finish_case_label (low_value, high_value)\n+     tree low_value;\n+     tree high_value;\n {\n-  tree cleanup = last_cleanup_this_contour ();\n+  tree label;\n+  tree cleanup;\n+  tree type;\n+  tree cond;\n+  tree case_label;\n+  splay_tree_node node;\n \n   if (! switch_stack)\n-    /* Don't crash; we'll complain in do_case.  */\n+    {\n+      if (high_value)\n+\terror (\"case label not within a switch statement\");\n+      else if (low_value)\n+\tcp_error (\"case label `%E' not within a switch statement\", \n+\t\t  low_value);\n+      else\n+\terror (\"`default' label not within a switch statement\");\n+      return;\n+    }\n+\n+  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\n+  if (processing_template_decl)\n+    {\n+      /* For templates, just add the case label; we'll do semantic\n+\t analysis at instantiation-time.  */\n+      add_stmt (build_case_label (low_value, high_value, label));\n+      return;\n+    }\n+\n+  /* Find the condition on which this switch statement depends.  */\n+  cond = SWITCH_COND (switch_stack->switch_stmt);\n+  if (cond && TREE_CODE (cond) == TREE_LIST)\n+    cond = TREE_VALUE (cond);\n+  /* If there was an error processing the switch condition, bail now\n+     before we get more confused.  */\n+  if (!cond || cond == error_mark_node)\n     return;\n+  type = TREE_TYPE (cond);\n \n+  if ((low_value && TREE_TYPE (low_value) \n+       && POINTER_TYPE_P (TREE_TYPE (low_value))) \n+      || (high_value && TREE_TYPE (high_value)\n+\t  && POINTER_TYPE_P (TREE_TYPE (high_value))))\n+    error (\"pointers are not permitted as case values\");\n+\n+  /* Case ranges are a GNU extension.  */\n+  if (high_value && pedantic)\n+    pedwarn (\"ISO C++ forbids range expressions in switch statement\");\n+\n+  if (low_value)\n+    {\n+      low_value = check_case_value (low_value);\n+      low_value = convert_and_check (type, low_value);\n+    }\n+  if (high_value)\n+    {\n+      high_value = check_case_value (high_value);\n+      high_value = convert_and_check (type, high_value);\n+    }\n+\n+  /* If an error has occurred, bail out now.  */\n+  if (low_value == error_mark_node || high_value == error_mark_node)\n+    return;\n+\n+  /* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't\n+     really a case range, even though it was written that way.  Remove\n+     the HIGH_VALUE to simplify later processing.  */\n+  if (tree_int_cst_equal (low_value, high_value))\n+    high_value = NULL_TREE;\n+  if (low_value && high_value \n+      && !tree_int_cst_lt (low_value, high_value)) \n+    warning (\"empty range specified\");\n+\n+  /* Look up the LOW_VALUE in the table of case labels we already\n+     have.  */\n+  node = splay_tree_lookup (switch_stack->cases, (splay_tree_key) low_value);\n+  /* If there was not an exact match, check for overlapping ranges.\n+     There's no need to do this if there's no LOW_VALUE or HIGH_VALUE;\n+     that's a `default' label and the only overlap is an exact match.  */\n+  if (!node && (low_value || high_value))\n+    {\n+      splay_tree_node low_bound;\n+      splay_tree_node high_bound;\n+\n+      /* Even though there wasn't an exact match, there might be an\n+\t overlap between this case range and another case range.\n+\t Since we've (inductively) not allowed any overlapping case\n+\t ranges, we simply need to find the greatest low case label\n+\t that is smaller that LOW_VALUE, and the smallest low case\n+\t label that is greater than LOW_VALUE.  If there is an overlap\n+\t it will occur in one of these two ranges.  */\n+      low_bound = splay_tree_predecessor (switch_stack->cases,\n+\t\t\t\t\t  (splay_tree_key) low_value);\n+      high_bound = splay_tree_successor (switch_stack->cases,\n+\t\t\t\t\t (splay_tree_key) low_value);\n+\n+      /* Check to see if the LOW_BOUND overlaps.  It is smaller than\n+\t the LOW_VALUE, so there is no need to check unless the\n+\t LOW_BOUND is in fact itself a case range.  */\n+      if (low_bound\n+\t  && CASE_HIGH ((tree) low_bound->value)\n+\t  && tree_int_cst_compare (CASE_HIGH ((tree) low_bound->value),\n+\t\t\t\t    low_value) >= 0)\n+\tnode = low_bound;\n+      /* Check to see if the HIGH_BOUND overlaps.  The low end of that\n+\t range is bigger than the low end of the current range, so we\n+\t are only interested if the current range is a real range, and\n+\t not an ordinary case label.  */\n+      else if (high_bound \n+\t       && high_value\n+\t       && (tree_int_cst_compare ((tree) high_bound->key,\n+\t\t\t\t\t high_value)\n+\t\t   <= 0))\n+\tnode = high_bound;\n+    }\n+  /* If there was an overlap, issue an error.  */\n+  if (node)\n+    {\n+      tree duplicate = CASE_LABEL_DECL ((tree) node->value);\n+\n+      if (high_value)\n+\t{\n+\t  error (\"duplicate (or overlapping) case value\");\n+\t  cp_error_at (\"this is the first entry overlapping that value\",\n+\t\t       duplicate);\n+\t}\n+      else if (low_value)\n+\t{\n+\t  cp_error (\"duplicate case value `%E'\", low_value) ;\n+\t  cp_error_at (\"previously used here\", duplicate);\n+\t}\n+      else\n+\t{\n+\t  error (\"multiple default labels in one switch\");\n+\t  cp_error_at (\"this is the first default label\", duplicate);\n+\t}\n+      return;\n+    }\n+\n+  cleanup = last_cleanup_this_contour ();\n   if (cleanup)\n     {\n       static int explained = 0;\n@@ -5228,9 +5401,18 @@ define_case_label ()\n \n   /* After labels, make any new cleanups go into their\n      own new (temporary) binding contour.  */\n-\n   current_binding_level->more_cleanups_ok = 0;\n   current_function_return_value = NULL_TREE;\n+\n+  /* Add a representation for the case label to the statement\n+     tree.  */\n+  case_label = build_case_label (low_value, high_value, label);\n+  add_stmt (case_label);\n+\n+  /* Register this case label in the splay tree.  */\n+  splay_tree_insert (switch_stack->cases, \n+\t\t     (splay_tree_key) low_value,\n+\t\t     (splay_tree_value) case_label);\n }\n \f\n /* Return the list of declarations of the current level.\n@@ -13601,7 +13783,7 @@ start_function (declspecs, declarator, attrs, flags)\n   if (flags & SF_INCLASS_INLINE)\n     maybe_begin_member_template_processing (decl1);\n \n-  /* Effective C++ rule 15.  See also c_expand_return.  */\n+  /* Effective C++ rule 15.  */\n   if (warn_ecpp\n       && DECL_OVERLOADED_OPERATOR_P (decl1) == NOP_EXPR\n       && TREE_CODE (TREE_TYPE (fntype)) == VOID_TYPE)"}, {"sha": "e97d52593ab68bf685bb925c7953a97ed6bc80b1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -4329,35 +4329,6 @@ finish_decl_parsing (decl)\n     }\n }\n \n-tree\n-check_cp_case_value (value)\n-     tree value;\n-{\n-  if (value == NULL_TREE)\n-    return value;\n-\n-  /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-  STRIP_TYPE_NOPS (value);\n-  value = decl_constant_value (value);\n-  STRIP_TYPE_NOPS (value);\n-  value = fold (value);\n-\n-  if (TREE_CODE (value) != INTEGER_CST\n-      && value != error_mark_node)\n-    {\n-      cp_error (\"case label `%E' does not reduce to an integer constant\",\n-\t\tvalue);\n-      value = error_mark_node;\n-    }\n-  else\n-    /* Promote char or short to int.  */\n-    value = default_conversion (value);\n-\n-  constant_expression_warning (value);\n-\n-  return value;\n-}\n-\n /* Return 1 if root encloses child. */\n \n static int"}, {"sha": "39095ec17db9950f24d4163ee35f211cfc7fcb46", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -205,82 +205,3 @@ extract_init (decl, init)\n   return 0;\n }\n \n-void\n-do_case (start, end)\n-     tree start, end;\n-{\n-  tree value1 = NULL_TREE, value2 = NULL_TREE, label;\n-\n-  if (start != NULL_TREE && TREE_TYPE (start) != NULL_TREE \n-      && POINTER_TYPE_P (TREE_TYPE (start)))\n-    error (\"pointers are not permitted as case values\");\n-\n-  if (end && pedantic)\n-    pedwarn (\"ISO C++ forbids range expressions in switch statement\");\n-\n-  if (start)\n-    value1 = check_cp_case_value (start);\n-  if (end)\n-    value2 = check_cp_case_value (end);\n-  \n-  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-  if (value1 != error_mark_node\n-      && value2 != error_mark_node)\n-    {\n-      tree duplicate;\n-      int success;\n-\n-      if (end)\n-\tsuccess = pushcase_range (value1, value2, convert_and_check,\n-\t\t\t\t  label, &duplicate);\n-      else if (start)\n-\tsuccess = pushcase (value1, convert_and_check, label, &duplicate);\n-      else\n-\tsuccess = pushcase (NULL_TREE, 0, label, &duplicate);\n-\n-      if (success == 1)\n-\t{\n-\t  if (end)\n-\t    error (\"case label not within a switch statement\");\n-\t  else if (start)\n-\t    cp_error (\"case label `%E' not within a switch statement\", start);\n-\t  else\n-\t    error (\"default label not within a switch statement\");\n-\t}\n-      else if (success == 2)\n-\t{\n-\t  if (end)\n-\t    {\n-\t      error (\"duplicate (or overlapping) case value\");\n-\t      cp_error_at (\"this is the first entry overlapping that value\",\n-\t\t\t   duplicate);\n-\t    }\n-\t  else if (start)\n-\t    {\n-\t      cp_error (\"duplicate case value `%E'\", start);\n-\t      cp_error_at (\"previously used here\", duplicate);\n-\t    }\n-\t  else\n-\t    {\n-\t      error (\"multiple default labels in one switch\");\n-\t      cp_error_at (\"this is the first default label\", duplicate);\n-\t    }\n-\t}\n-      else if (success == 3)\n-\twarning (\"case value out of range\");\n-      else if (success == 4)\n-\twarning (\"empty range specified\");\n-      else if (success == 5)\n-\t{\n-\t  if (end)\n-\t    error (\"case label within scope of cleanup or variable array\");\n-\t  else if (! start)\n-\t    error (\"`default' label within scope of cleanup or variable array\");\n-\t  else\n-\t    cp_error (\"case label `%E' within scope of cleanup or variable array\", start);\n-\t}\n-    }\n-\n-  current_function_return_value = NULL_TREE;\n-}"}, {"sha": "dc6f00f931c0f6760b108f1060fd810ad1090027", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -7269,7 +7269,8 @@ tsubst_expr (t, args, complain, in_decl)\n     case CASE_LABEL:\n       prep_stmt (t);\n       finish_case_label (tsubst_expr (CASE_LOW (t), args, complain, in_decl),\n-\t\t\t tsubst_expr (CASE_HIGH (t), args, complain, in_decl));\n+\t\t\t tsubst_expr (CASE_HIGH (t), args, complain,\n+\t\t\t\t      in_decl));\n       break;\n \n     case LABEL_STMT:"}, {"sha": "b7abff29dec27544b7fa17f89bc85cd9e3f6e696", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -55,23 +55,9 @@ static void genrtl_handler PARAMS ((tree));\n static void genrtl_catch_block PARAMS ((tree));\n static void genrtl_ctor_stmt PARAMS ((tree));\n static void genrtl_subobject PARAMS ((tree));\n-static tree genrtl_do_poplevel PARAMS ((void));\n static void genrtl_named_return_value PARAMS ((void));\n static void cp_expand_stmt PARAMS ((tree));\n \n-/* When parsing a template, LAST_TREE contains the last statement\n-   parsed.  These are chained together through the TREE_CHAIN field,\n-   but often need to be re-organized since the parse is performed\n-   bottom-up.  This macro makes LAST_TREE the indicated SUBSTMT of\n-   STMT.  */\n-\n-#define RECHAIN_STMTS(stmt, substmt)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    substmt = TREE_CHAIN (stmt);\t\t\\\n-    TREE_CHAIN (stmt) = NULL_TREE;\t\t\\\n-    last_tree = stmt;\t\t\t\t\\\n-  } while (0)\n-\n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n \n #define FINISH_COND(cond, stmt, substmt) \t\t\\\n@@ -520,15 +506,15 @@ finish_for_stmt (for_stmt)\n void\n finish_break_stmt ()\n {\n-  add_stmt (build_stmt (BREAK_STMT));\n+  add_stmt (build_break_stmt ());\n }\n \n /* Finish a continue-statement.  */\n \n void\n finish_continue_stmt ()\n {\n-  add_stmt (build_stmt (CONTINUE_STMT));\n+  add_stmt (build_continue_stmt ());\n }\n \n /* Begin a switch-statement.  Returns a new SWITCH_STMT if\n@@ -553,6 +539,9 @@ finish_switch_cond (cond, switch_stmt)\n {\n   if (!processing_template_decl)\n     {\n+      tree type;\n+      tree index;\n+\n       /* Convert the condition to an integer or enumeration type.  */\n       cond = build_expr_type_conversion (WANT_INT | WANT_ENUM, cond, 1);\n       if (cond == NULL_TREE)\n@@ -565,9 +554,19 @@ finish_switch_cond (cond, switch_stmt)\n \t  cond = default_conversion (cond);\n \t  cond = fold (build1 (CLEANUP_POINT_EXPR, TREE_TYPE (cond), cond));\n \t}\n+\n+      type = TREE_TYPE (cond);\n+      index = get_unwidened (cond, NULL_TREE);\n+      /* We can't strip a conversion from a signed type to an unsigned,\n+\t because if we did, int_fits_type_p would do the wrong thing\n+\t when checking case values for being in range,\n+\t and it's too hard to do the right thing.  */\n+      if (TREE_UNSIGNED (TREE_TYPE (cond))\n+\t  == TREE_UNSIGNED (TREE_TYPE (index)))\n+\tcond = index;\n     }\n   FINISH_COND (cond, switch_stmt, SWITCH_COND (switch_stmt));\n-  push_switch ();\n+  push_switch (switch_stmt);\n }\n \n /* Finish the body of a switch-statement, which may be given by\n@@ -583,21 +582,6 @@ finish_switch_stmt (switch_stmt)\n   finish_stmt ();\n }\n \n-/* Finish a case-label.  */\n-\n-void \n-finish_case_label (low_value, high_value)\n-     tree low_value;\n-     tree high_value;\n-{\n-  /* Add a representation for the case label to the statement\n-     tree.  */\n-  add_stmt (build_stmt (CASE_LABEL, low_value, high_value));\n-  /* And warn about crossing initializations, etc.  */\n-  if (!processing_template_decl)\n-    define_case_label ();\n-}\n-\n /* Generate the RTL for T, which is a TRY_BLOCK. */\n \n static void "}, {"sha": "e15a7248930ff29cab49231ce97b3f6a00f6e172", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -6839,56 +6839,7 @@ check_return_expr (retval)\n   return retval;\n }\n \n-/* Expand a C `return' statement.\n-   RETVAL is the expression for what to return,\n-   or a null pointer for `return;' with no value.\n-\n-   C++: upon seeing a `return', we must call destructors on all\n-   variables in scope which had constructors called on them.\n-   This means that if in a destructor, the base class destructors\n-   must be called before returning.\n-\n-   The RETURN statement in C++ has initialization semantics.  */\n-\n-void\n-c_expand_return (retval)\n-     tree retval;\n-{\n-  if (!retval)\n-    expand_null_return ();\n-  else\n-    {\n-      expand_start_target_temps ();\n-      expand_return (retval);\n-      expand_end_target_temps ();\n-    }\n-}\n \f\n-/* Start a C switch statement, testing expression EXP.\n-   Return EXP if it is valid, an error node otherwise.  */\n-\n-tree\n-c_expand_start_case (exp)\n-     tree exp;\n-{\n-  tree type;\n-  tree index;\n-\n-  type = TREE_TYPE (exp);\n-  index = get_unwidened (exp, NULL_TREE);\n-  /* We can't strip a conversion from a signed type to an unsigned,\n-     because if we did, int_fits_type_p would do the wrong thing\n-     when checking case values for being in range,\n-     and it's too hard to do the right thing.  */\n-  if (TREE_UNSIGNED (TREE_TYPE (exp))\n-      == TREE_UNSIGNED (TREE_TYPE (index)))\n-    exp = index;\n-\n-  expand_start_case (1, exp, type, \"switch statement\");\n-\n-  return exp;\n-}\n-\n /* Returns non-zero if the pointer-type FROM can be converted to the\n    pointer-type TO via a qualification conversion.  If CONSTP is -1,\n    then we return non-zero if the pointers are similar, and the"}, {"sha": "6adee8159d7321e3bc2d290bb82d04089616c10b", "filename": "gcc/stmt.c", "status": "modified", "additions": 22, "deletions": 26, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -240,8 +240,6 @@ struct nesting\n \t  tree index_expr;\n \t  /* Type that INDEX_EXPR should be converted to.  */\n \t  tree nominal_type;\n-\t  /* Number of range exprs in case statement.  */\n-\t  int num_ranges;\n \t  /* Name of this kind of statement, for warnings.  */\n \t  const char *printname;\n \t  /* Used to save no_line_numbers till we see the first case label.\n@@ -421,7 +419,6 @@ static int node_has_high_bound\t\tPARAMS ((case_node_ptr, tree));\n static int node_is_bounded\t\tPARAMS ((case_node_ptr, tree));\n static void emit_jump_if_reachable\tPARAMS ((rtx));\n static void emit_case_nodes\t\tPARAMS ((rtx, case_node_ptr, rtx, tree));\n-static int add_case_node\t\tPARAMS ((tree, tree, tree, tree *));\n static struct case_node *case_tree2list\tPARAMS ((case_node *, case_node *));\n static void mark_cond_nesting           PARAMS ((struct nesting *));\n static void mark_loop_nesting           PARAMS ((struct nesting *));\n@@ -4426,7 +4423,6 @@ expand_start_case (exit_flag, expr, type, printname)\n   thiscase->data.case_stmt.index_expr = expr;\n   thiscase->data.case_stmt.nominal_type = type;\n   thiscase->data.case_stmt.default_label = 0;\n-  thiscase->data.case_stmt.num_ranges = 0;\n   thiscase->data.case_stmt.printname = printname;\n   thiscase->data.case_stmt.line_number_status = force_line_numbers ();\n   case_stack = thiscase;\n@@ -4464,7 +4460,6 @@ expand_start_case_dummy ()\n   thiscase->data.case_stmt.start = 0;\n   thiscase->data.case_stmt.nominal_type = 0;\n   thiscase->data.case_stmt.default_label = 0;\n-  thiscase->data.case_stmt.num_ranges = 0;\n   case_stack = thiscase;\n   nesting_stack = thiscase;\n   start_cleanup_deferral ();\n@@ -4580,21 +4575,7 @@ pushcase (value, converter, label, duplicate)\n \t  || ! int_fits_type_p (value, index_type)))\n     return 3;\n \n-  /* Fail if this is a duplicate or overlaps another entry.  */\n-  if (value == 0)\n-    {\n-      if (case_stack->data.case_stmt.default_label != 0)\n-\t{\n-\t  *duplicate = case_stack->data.case_stmt.default_label;\n-\t  return 2;\n-\t}\n-      case_stack->data.case_stmt.default_label = label;\n-    }\n-  else\n-    return add_case_node (value, value, label, duplicate);\n-\n-  expand_label (label);\n-  return 0;\n+  return add_case_node (value, value, label, duplicate);\n }\n \n /* Like pushcase but this case applies to all values between VALUE1 and\n@@ -4670,14 +4651,33 @@ pushcase_range (value1, value2, converter, label, duplicate)\n    into case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid\n    slowdown for large switch statements.  */\n \n-static int\n+int\n add_case_node (low, high, label, duplicate)\n      tree low, high;\n      tree label;\n      tree *duplicate;\n {\n   struct case_node *p, **q, *r;\n \n+  /* If there's no HIGH value, then this is not a case range; it's\n+     just a simple case label.  But that's just a degenerate case\n+     range.  */\n+  if (!high)\n+    high = low;\n+\n+  /* Handle default labels specially.  */\n+  if (!high && !low)\n+    {\n+      if (case_stack->data.case_stmt.default_label != 0)\n+\t{\n+\t  *duplicate = case_stack->data.case_stmt.default_label;\n+\t  return 2;\n+\t}\n+      case_stack->data.case_stmt.default_label = label;\n+      expand_label (label);\n+      return 0;\n+    }\n+\n   q = &case_stack->data.case_stmt.case_list;\n   p = *q;\n \n@@ -4709,14 +4709,10 @@ add_case_node (low, high, label, duplicate)\n   r->low = copy_node (low);\n \n   /* If the bounds are equal, turn this into the one-value case.  */\n-\n   if (tree_int_cst_equal (low, high))\n     r->high = r->low;\n   else\n-    {\n-      r->high = copy_node (high);\n-      case_stack->data.case_stmt.num_ranges++;\n-    }\n+    r->high = copy_node (high);\n \n   r->code_label = label;\n   expand_label (label);"}, {"sha": "d396cc11ca8d16e7fdaab84586301fae64bb9328", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -4293,6 +4293,21 @@ tree_int_cst_lt (t1, t2)\n   return INT_CST_LT_UNSIGNED (t1, t2);\n }\n \n+/* Returns -1 if T1 < T2, 0 if T1 == T2, and 1 if T1 > T2.  */\n+\n+int\n+tree_int_cst_compare (t1, t2)\n+     tree t1;\n+     tree t2;\n+{\n+  if (tree_int_cst_lt (t1, t2))\n+    return -1;\n+  else if (tree_int_cst_lt (t2, t1))\n+    return 1;\n+  else \n+    return 0;\n+}\n+\n /* Return 1 if T is an INTEGER_CST that can be represented in a single\n    HOST_WIDE_INT value.  If POS is nonzero, the result must be positive.  */\n "}, {"sha": "baf3226666139c262b0f8d10cc63e20bdf8e3e9e", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cb97339bc91ec1b4df74a8bb4a31d4c363aee2/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=56cb97339bc91ec1b4df74a8bb4a31d4c363aee2", "patch": "@@ -1943,6 +1943,7 @@ extern int attribute_list_equal\t\tPARAMS ((tree, tree));\n extern int attribute_list_contained\tPARAMS ((tree, tree));\n extern int tree_int_cst_equal\t\tPARAMS ((tree, tree));\n extern int tree_int_cst_lt\t\tPARAMS ((tree, tree));\n+extern int tree_int_cst_compare         PARAMS ((tree, tree));\n extern int host_integerp\t\tPARAMS ((tree, int));\n extern HOST_WIDE_INT tree_low_cst\tPARAMS ((tree, int));\n extern int tree_int_cst_msb\t\tPARAMS ((tree));\n@@ -2497,6 +2498,8 @@ extern int expand_dcc_cleanup\t\t\tPARAMS ((tree));\n extern void expand_start_case\t\t\tPARAMS ((int, tree, tree,\n \t\t\t\t\t\t       const char *));\n extern void expand_end_case\t\t\tPARAMS ((tree));\n+extern int add_case_node                        PARAMS ((tree, tree,\n+\t\t\t\t\t\t\t tree, tree *));\n extern int pushcase\t\t\t\tPARAMS ((tree,\n \t\t\t\t\t\t       tree (*) (tree, tree),\n \t\t\t\t\t\t       tree, tree *));"}]}