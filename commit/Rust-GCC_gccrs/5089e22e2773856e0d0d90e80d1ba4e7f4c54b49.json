{"sha": "5089e22e2773856e0d0d90e80d1ba4e7f4c54b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA4OWUyMmUyNzczODU2ZTBkMGQ5MGU4MGQxYmE0ZTdmNGM1NGI0OQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-23T19:42:32Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-03-23T19:42:32Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r579", "tree": {"sha": "29ea75ebc401c3a57f500cdd882e74d1c076fefd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29ea75ebc401c3a57f500cdd882e74d1c076fefd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49/comments", "author": null, "committer": null, "parents": [{"sha": "e93203903669146c1bbab38354559007eef68054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e93203903669146c1bbab38354559007eef68054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e93203903669146c1bbab38354559007eef68054"}], "stats": {"total": 157, "additions": 121, "deletions": 36}, "files": [{"sha": "ef116ef69a1fca5bd700548cc9716a9ec20616bb", "filename": "gcc/combine.c", "status": "modified", "additions": 119, "deletions": 34, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5089e22e2773856e0d0d90e80d1ba4e7f4c54b49", "patch": "@@ -114,7 +114,7 @@ static int combine_successes;\n static int total_attempts, total_merges, total_extras, total_successes;\n \f\n /* Vector mapping INSN_UIDs to cuids.\n-   The cuids are like uids but increase monononically always.\n+   The cuids are like uids but increase monotonically always.\n    Combine always uses cuids so that it can compare them.\n    But actually renumbering the uids, which we used to do,\n    proves to be a bad idea because it makes it hard to compare\n@@ -174,7 +174,7 @@ static int previous_num_undos;\n \f\n /* The next group of arrays allows the recording of the last value assigned\n    to (hard or pseudo) register n.  We use this information to see if a\n-   operation being processed is redundant given the a prior operation peformed\n+   operation being processed is redundant given a prior operation performed\n    on the register.  For example, an `and' with a constant is redundant if\n    all the zero bits are already known to be turned off.\n \n@@ -517,7 +517,7 @@ combine_instructions (f, nregs)\n \n \t  /* Finally, see if any of the insns that this insn links to\n \t     explicitly references CC0.  If so, try this insn, that insn,\n-\t     and its prececessor if it sets CC0.  */\n+\t     and its predecessor if it sets CC0.  */\n \t  for (links = LOG_LINKS (insn); links; links = XEXP (links, 1))\n \t    if (GET_CODE (XEXP (links, 0)) == INSN\n \t\t&& GET_CODE (PATTERN (XEXP (links, 0))) == SET\n@@ -576,7 +576,7 @@ set_significant (x, set)\n \treturn;\n \n       /* If this is a complex assignment, see if we can convert it into a\n-\t simple assignent.  */\n+\t simple assignment.  */\n       set = expand_field_assignment (set);\n       if (SET_DEST (set) == x)\n \treg_significant[REGNO (x)]\n@@ -682,9 +682,16 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t It can worsen register allocation, and can even make invalid reload\n \t insns, since the reg inside may need to be copied from in the\n \t outside mode, and that may be invalid if it is an fp reg copied in\n-\t integer mode.  */\n+\t integer mode.  As a special exception, we can allow this if\n+\t I3 is simply copying DEST, a REG,  to CC0.  */\n       || (GET_CODE (src) == SUBREG\n-\t  && ! MODES_TIEABLE_P (GET_MODE (src), GET_MODE (SUBREG_REG (src))))\n+\t  && ! MODES_TIEABLE_P (GET_MODE (src), GET_MODE (SUBREG_REG (src)))\n+#ifdef HAVE_cc0\n+\t  && ! (GET_CODE (i3) == INSN && GET_CODE (PATTERN (i3)) == SET\n+\t\t&& SET_DEST (PATTERN (i3)) == cc0_rtx\n+\t\t&& GET_CODE (dest) == REG && dest == SET_SRC (PATTERN (i3)))\n+#endif\n+\t  )\n       /* If we couldn't eliminate a field assignment, we can't combine.  */\n       || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == STRICT_LOW_PART\n       /* Don't combine with an insn that sets a register to itself if it has\n@@ -1031,29 +1038,56 @@ try_combine (i3, i2, i1)\n       && find_reg_note (i3, REG_DEAD, SET_SRC (PATTERN (i3)))\n       && GET_CODE (PATTERN (i2)) == PARALLEL\n       && ! side_effects_p (SET_DEST (PATTERN (i3)))\n+      /* If the dest of I3 is a ZERO_EXTRACT or STRICT_LOW_PART, the code\n+\t below would need to check what is inside (and reg_overlap_mentioned_p\n+\t doesn't support those codes anyway).  Don't allow those destinations;\n+\t the resulting insn isn't likely to be recognized anyway.  */\n+      && GET_CODE (SET_DEST (PATTERN (i3))) != ZERO_EXTRACT\n+      && GET_CODE (SET_DEST (PATTERN (i3))) != STRICT_LOW_PART\n       && ! reg_overlap_mentioned_p (SET_SRC (PATTERN (i3)),\n \t\t\t\t    SET_DEST (PATTERN (i3)))\n       && next_real_insn (i2) == i3)\n-    for (i = 0; i < XVECLEN (PATTERN (i2), 0); i++)\n-      if (SET_DEST (XVECEXP (PATTERN (i2), 0, i)) == SET_SRC (PATTERN (i3)))\n-\t{\n-\t  combine_merges++;\n+    {\n+      rtx p2 = PATTERN (i2);\n+\n+      /* Make sure that the destination of I3,\n+\t which we are going to substitute into one output of I2,\n+\t is not used within another output of I2.  We must avoid making this:\n+\t (parallel [(set (mem (reg 69)) ...)\n+\t\t    (set (reg 69) ...)])\n+\t which is not well-defined as to order of actions.\n+\t (Besides, reload can't handle output reloads for this.)\n+\n+\t The problem can also happen if the dest of I3 is a memory ref,\n+\t if another dest in I2 is an indirect memory ref.  */\n+      for (i = 0; i < XVECLEN (p2, 0); i++)\n+\tif (GET_CODE (XVECEXP (p2, 0, i)) == SET\n+\t    && reg_overlap_mentioned_p (SET_DEST (PATTERN (i3)),\n+\t\t\t\t\tSET_DEST (XVECEXP (p2, 0, i))))\n+\t  break;\n \n-\t  subst_insn = i3;\n-\t  subst_low_cuid = INSN_CUID (i2);\n+      if (i == XVECLEN (p2, 0))\n+\tfor (i = 0; i < XVECLEN (p2, 0); i++)\n+\t  if (SET_DEST (XVECEXP (p2, 0, i)) == SET_SRC (PATTERN (i3)))\n+\t    {\n+\t      combine_merges++;\n \n-\t  added_sets_2 = 0;\n-\t  i2dest = SET_SRC (PATTERN (i3));\n+\t      subst_insn = i3;\n+\t      subst_low_cuid = INSN_CUID (i2);\n \n-\t  /* Replace the dest in I2 with our dest and make the resulting\n-\t     insn the new pattern for I3.  Then skip to where we\n-\t     validate the pattern.  Everything was set up above.  */\n-\t  SUBST (SET_DEST (XVECEXP (PATTERN (i2), 0, i)), \n-\t\t SET_DEST (PATTERN (i3)));\n+\t      added_sets_2 = 0;\n+\t      i2dest = SET_SRC (PATTERN (i3));\n \n-\t  newpat = PATTERN (i2);\n-\t  goto validate_replacement;\n-\t}\n+\t      /* Replace the dest in I2 with our dest and make the resulting\n+\t\t insn the new pattern for I3.  Then skip to where we\n+\t\t validate the pattern.  Everything was set up above.  */\n+\t      SUBST (SET_DEST (XVECEXP (p2, 0, i)), \n+\t\t     SET_DEST (PATTERN (i3)));\n+\n+\t      newpat = p2;\n+\t      goto validate_replacement;\n+\t    }\n+    }\n \n #ifndef HAVE_cc0\n   /* If we have no I1 and I2 looks like:\n@@ -1134,7 +1168,7 @@ try_combine (i3, i2, i1)\n      output operand.  However, that exception can give rise to insns like\n      \tmov r3,(r3)+\n      which is a famous insn on the PDP-11 where the value of r3 used as the\n-     source was model-dependant.  Avoid this sort of thing.  */\n+     source was model-dependent.  Avoid this sort of thing.  */\n \n #if 0\n   if (!(GET_CODE (PATTERN (i3)) == SET\n@@ -1175,7 +1209,7 @@ try_combine (i3, i2, i1)\n \n   /* If the set in I2 needs to be kept around, we must make a copy of\n      PATTERN (I2), so that when we substitute I1SRC for I1DEST in\n-     PATTERN (I2), we are only substituing for the original I1DEST, not into\n+     PATTERN (I2), we are only substituting for the original I1DEST, not into\n      an already-substituted copy.  This also prevents making self-referential\n      rtx.  If I2 is a PARALLEL, we just need the piece that assigns I2SRC to\n      I2DEST.  */\n@@ -1517,6 +1551,50 @@ try_combine (i3, i2, i1)\n       i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n       if (i2_code_number >= 0)\n \tinsn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n+\n+      if (insn_code_number >= 0)\n+\t{\n+\t  rtx insn;\n+\t  rtx link;\n+\n+\t  /* If we will be able to accept this, we have made a change to the\n+\t     destination of I3.  This can invalidate a LOG_LINKS pointing\n+\t     to I3.  No other part of combine.c makes such a transformation.\n+\n+\t     The new I3 will have a destination that was previously the\n+\t     destination of I1 or I2 and which was used in i2 or I3.  Call\n+\t     distribute_links to make a LOG_LINK from the next use of\n+\t     that destination.  */\n+\n+\t  PATTERN (i3) = newpat;\n+\t  distribute_links (gen_rtx (INSN_LIST, VOIDmode, i3, 0));\n+\n+\t  /* I3 now uses what used to be its destination and which is\n+\t     now I2's destination.  That means we need a LOG_LINK from\n+\t     I3 to I2.  But we used to have one, so we still will.\n+\n+\t     However, some later insn might be using I2's dest and have\n+\t     a LOG_LINK pointing at I3.  We must remove this link.\n+\t     The simplest way to remove the link is to point it at I1,\n+\t     which we know will be a NOTE.  */\n+\n+\t  for (insn = NEXT_INSN (i3);\n+\t       insn && GET_CODE (insn) != CODE_LABEL\n+\t       && GET_CODE (PREV_INSN (insn)) != JUMP_INSN;\n+\t       insn = NEXT_INSN (insn))\n+\t    {\n+\t      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n+\t\t  && reg_referenced_p (SET_DEST (newi2pat), PATTERN (insn)))\n+\t\t{\n+\t\t  for (link = LOG_LINKS (insn); link;\n+\t\t       link = XEXP (link, 1))\n+\t\t    if (XEXP (link, 0) == i3)\n+\t\t      XEXP (link, 0) = i1;\n+\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n     }\n \t    \n   /* Similarly, check for a case where we have a PARALLEL of two independent\n@@ -1620,7 +1698,7 @@ try_combine (i3, i2, i1)\n \n     /* Ensure that we do not have something that should not be shared but\n        occurs multiple times in the new insns.  Check this by first\n-       restting all the `used' flags and then copying anything is shared.  */\n+       resetting all the `used' flags and then copying anything is shared.  */\n \n     reset_used_flags (i3notes);\n     reset_used_flags (i2notes);\n@@ -2082,7 +2160,7 @@ find_split_point (loc)\n    \n    IN_DEST is non-zero if we are processing the SET_DEST of a SET.\n \n-   UNIQUE_COPY is non-zero if each substition must be unique.  We do this\n+   UNIQUE_COPY is non-zero if each substitution must be unique.  We do this\n    by copying if `n_occurrences' is non-zero.  */\n \n static rtx\n@@ -4435,7 +4513,8 @@ make_field_assignment (x)\n   /* Shift OTHER right POS places and make it the source, restricting it\n      to the proper length and mode.  */\n \n-  src = force_to_mode (simplify_shift_const (0, LSHIFTRT, mode, other, pos),\n+  src = force_to_mode (simplify_shift_const (0, LSHIFTRT, GET_MODE (src),\n+\t\t\t\t\t     other, pos),\n \t\t       mode, len, dest);\n \n   return gen_rtx_combine (SET, VOIDmode, assign, src);\n@@ -6253,7 +6332,7 @@ gen_unary (code, mode, op0)\n \n    It is possible that we might detect that a comparison is either always\n    true or always false.  However, we do not perform general constant\n-   folding in combine, so this knowlege isn't useful.  Such tautologies\n+   folding in combine, so this knowledge isn't useful.  Such tautologies\n    should have been detected earlier.  Hence we ignore all such cases.  */\n \n static enum rtx_code\n@@ -6685,7 +6764,7 @@ simplify_comparison (code, pop0, pop1)\n \n \tcase PLUS:\n \t  /* (eq (plus X C1) C2) -> (eq X (minus C2 C1)).  We can only do\n-\t     this for equality comparisons due to pathalogical cases involving\n+\t     this for equality comparisons due to pathological cases involving\n \t     overflows.  */\n \t  if (equality_comparison_p && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t      && (tem = simplify_binary_operation (MINUS, mode, op1,\n@@ -7576,9 +7655,9 @@ reg_bitfield_target_p (reg, body)\n \n   if (GET_CODE (body) == SET)\n     return ((GET_CODE (SET_DEST (body)) == ZERO_EXTRACT\n-\t     && reg == XEXP (SET_DEST (body), 0))\n+\t     && rtx_equal_p (reg, XEXP (SET_DEST (body), 0)))\n \t    || (GET_CODE (SET_DEST (body)) == STRICT_LOW_PART\n-\t\t&& reg == SUBREG_REG (XEXP (SET_DEST (body), 0))));\n+\t\t&& rtx_equal_p (reg, SUBREG_REG (XEXP (SET_DEST (body), 0)))));\n \n   else if (GET_CODE (body) == PARALLEL)\n     for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n@@ -7742,7 +7821,11 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t  {\n \t\t    rtx set = single_set (tem);\n \n-\t\t    if (set != 0 && ! side_effects_p (SET_SRC (set)))\n+\t\t    /* Verify that it was the set, and not a clobber that\n+\t\t       modified the register.  */\n+\n+\t\t    if (set != 0 && ! side_effects_p (SET_SRC (set))\n+\t\t\t&& rtx_equal_p (XEXP (note, 0), SET_DEST (set)))\n \t\t      {\n \t\t\t/* Move the notes and links of TEM elsewhere.\n \t\t\t   This might delete other dead insns recursively. \n@@ -7830,6 +7913,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\t  = emit_insn_before (gen_rtx (USE, VOIDmode, piece),\n \t\t\t\t\t      place);\n \n+\t\t\tall_used = 0;\n \t\t\tREG_NOTES (use_insn)\n \t\t\t  = gen_rtx (EXPR_LIST, REG_DEAD, piece,\n \t\t\t\t     REG_NOTES (use_insn));\n@@ -7878,7 +7962,8 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n }\n \f\n /* Similarly to above, distribute the LOG_LINKS that used to be present on\n-   I3, I2, and I1 to new locations.  */\n+   I3, I2, and I1 to new locations.  This is also called in one case to\n+   add a link pointing at I3 when I3's destination is changed.  */\n \n static void\n distribute_links (links)\n@@ -7921,7 +8006,7 @@ distribute_links (links)\n \t when we reach a set of the register or the end of the basic block.\n \n \t Note that this correctly handles the link that used to point from\n-\t I3 to I2.  Also note that not much seaching is typically done here\n+\t I3 to I2.  Also note that not much searching is typically done here\n \t since most links don't point very far away.  */\n \n       for (insn = NEXT_INSN (XEXP (link, 0));"}, {"sha": "5e10494e7670b71c10f62dc2056b16fa5f47b9bf", "filename": "gcc/config/m68k/sun3.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49/gcc%2Fconfig%2Fm68k%2Fsun3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5089e22e2773856e0d0d90e80d1ba4e7f4c54b49/gcc%2Fconfig%2Fm68k%2Fsun3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fsun3.h?ref=5089e22e2773856e0d0d90e80d1ba4e7f4c54b49", "patch": "@@ -43,15 +43,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* -m68881 is the default */\n #define CPP_SPEC \\\n \"%{!msoft-float:%{mfpa:-D__HAVE_FPA__ }%{!mfpa:-D__HAVE_68881__ }}\\\n-%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}}} \\\n+%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}} \\\n %{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n \n #else\n \n /* -msoft-float is the default */\n #define CPP_SPEC \\\n \"%{m68881:-D__HAVE_68881__ }%{mfpa:-D__HAVE_FPA__ }\\\n-%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}}} \\\n+%{m68000:-D__mc68010__}%{mc68000:-D__mc68010__}%{!mc68000:%{!m68000:-D__mc68020__}} \\\n %{!ansi:%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}}\"\n \n #endif"}]}