{"sha": "1cfabf34d83637a5e9ffa11dc38379d017738cf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNmYWJmMzRkODM2MzdhNWU5ZmZhMTFkYzM4Mzc5ZDAxNzczOGNmNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-11-02T14:40:44Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-11-02T14:40:44Z"}, "message": "simple-object.h: New file.\n\ninclude/:\n\t* simple-object.h: New file.\nlibiberty/:\n\t* simple-object.c: New file.\n\t* simple-object-common.h: New file.\n\t* simple-object-elf.c: New file.\n\t* simple-object-mach-o.c: New file.\n\t* simple-object-coff.c: New file.\n\t* simple-object.txh: New file.\n\t* configure.ac: Add AC_TYPE_SSIZE_T.\n\t* Makefile.in: Rebuild dependencies.\n\t(CFILES): Add simple-object.c, simple-object-coff,\n\tsimple-object-elf.c, and simple-object-mach-o.c.\n\t(REQUIRED_OFILES): Add corresponding object files.\n\t* configure: Rebuild.\n\t* config.in: Rebuild.\n\t* functions.texi: Rebuild.\n\nCo-Authored-By: Dave Korn <dave.korn.cygwin@gmail.com>\nCo-Authored-By: Iain Sandoe <iains@gcc.gnu.org>\n\nFrom-SVN: r166185", "tree": {"sha": "b13f59ad5c9b124df2fcf21f33e4c80b19f23808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b13f59ad5c9b124df2fcf21f33e4c80b19f23808"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cfabf34d83637a5e9ffa11dc38379d017738cf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfabf34d83637a5e9ffa11dc38379d017738cf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cfabf34d83637a5e9ffa11dc38379d017738cf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cfabf34d83637a5e9ffa11dc38379d017738cf7/comments", "author": null, "committer": null, "parents": [{"sha": "fee3eacd6fea60bfc2bed8477315ea1f125a278c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee3eacd6fea60bfc2bed8477315ea1f125a278c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee3eacd6fea60bfc2bed8477315ea1f125a278c"}], "stats": {"total": 4157, "additions": 4152, "deletions": 5}, "files": [{"sha": "07abc0d654e4bfc1961cc5e7ec8eb66648354ef3", "filename": "include/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,3 +1,7 @@\n+2010-11-02  Ian Lance Taylor  <iant@google.com>\n+\n+\t* simple-object.h: New file.\n+\n 2010-10-15  Dave Korn  <dave.korn.cygwin@gmail.com> \n \n \tSync LD plugin patch series (part 1/6) with src/include/."}, {"sha": "a72e4a19bc2fa24a972eb1829497d690720fb56e", "filename": "include/simple-object.h", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/include%2Fsimple-object.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/include%2Fsimple-object.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fsimple-object.h?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,203 @@\n+/* simple-object.h -- simple routines to read and write object files\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#ifndef SIMPLE_OBJECT_H\n+#define SIMPLE_OBJECT_H\n+\n+#include <stddef.h>\n+#include <sys/types.h>\n+\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* This header file provides four types with associated functions.\n+   They are used to read and write object files.  This is a minimal\n+   interface, intended to support the needs of gcc without bringing in\n+   all the power and complexity of BFD.  */\n+\n+/* The type simple_object_read * is used to read an existing object\n+   file.  */\n+\n+typedef struct simple_object_read_struct simple_object_read;\n+\n+/* Create an simple_object_read given DESCRIPTOR, an open file\n+   descriptor, and OFFSET, an offset within the file.  The offset is\n+   for use with archives, and should be 0 for an ordinary object file.\n+   The descriptor must remain open until done with the returned\n+   simple_object_read.  SEGMENT_NAME is used on Mach-O and is required\n+   on that platform: it means to only look at sections within the\n+   segment with that name.  It is ignored for other object file\n+   formats.  On error, this function returns NULL, and sets *ERRMSG to\n+   an error string and sets *ERR to an errno value or 0 if there is no\n+   relevant errno.  */\n+\n+extern simple_object_read *\n+simple_object_start_read (int descriptor, off_t offset,\n+\t\t\t  const char *segment_name, const char **errmsg,\n+\t\t\t  int *err);\n+\n+/* Call PFN for each section in SIMPLE_OBJECT, passing it the section\n+   name, offset within the file of the section contents, and length of\n+   the section contents.  The offset within the file is relative to\n+   the offset passed to simple_object_start_read.  The DATA argument\n+   to simple_object_find_sections is passed on to PFN.  If PFN returns\n+   0, the loop is stopped and simple_object_find_sections returns.  If\n+   PFN returns non-zero, the loop continues.  On success this returns\n+   NULL.  On error it returns an error string, and sets *ERR to an\n+   errno value or 0 if there is no relevant errno.  */\n+\n+extern const char *\n+simple_object_find_sections (simple_object_read *simple_object,\n+\t\t\t     int (*pfn) (void *data, const char *,\n+\t\t\t\t\t off_t offset, off_t length),\n+\t\t\t     void *data,\n+\t\t\t     int *err);\n+\n+/* Look for the section NAME in SIMPLE_OBJECT.  This returns\n+   information for the first section NAME in SIMPLE_OBJECT.  Note that\n+   calling this multiple times is inefficient; use\n+   simple_object_find_sections instead.\n+\n+   If found, return 1 and set *OFFSET to the offset in the file of the\n+   section contents and set *LENGTH to the length of the section\n+   contents.  *OFFSET will be relative to the offset passed to\n+   simple_object_start_read.\n+\n+   If the section is not found, and no error occurs, return 0 and set\n+   *ERRMSG to NULL.\n+\n+   If an error occurs, return 0, set *ERRMSG to an error message, and\n+   set *ERR to an errno value or 0 if there is no relevant errno.  */\n+\n+extern int\n+simple_object_find_section (simple_object_read *simple_object,\n+\t\t\t    const char *name, off_t *offset, off_t *length,\n+\t\t\t    const char **errmsg, int *err);\n+\n+/* Release all resources associated with SIMPLE_OBJECT.  This does not\n+   close the file descriptor.  */\n+\n+extern void\n+simple_object_release_read (simple_object_read *);\n+\n+/* The type simple_object_attributes holds the attributes of an object\n+   file that matter for creating a file or ensuring that two files are\n+   compatible.  This is a set of magic numbers.  */\n+\n+typedef struct simple_object_attributes_struct simple_object_attributes;\n+\n+/* Fetch the attributes of SIMPLE_OBJECT.  This information will\n+   persist until simple_object_attributes_release is called, even if\n+   SIMPLE_OBJECT is closed.  On error this returns NULL, sets *ERRMSG\n+   to an error message, and sets *ERR to an errno value or 0 if there\n+   isn't one.  */\n+\n+extern simple_object_attributes *\n+simple_object_fetch_attributes (simple_object_read *simple_object,\n+\t\t\t\tconst char **errmsg, int *err);\n+\n+/* Compare ATTRS1 and ATTRS2.  If they could be linked together\n+   without error, return NULL.  Otherwise, return an error message,\n+   set *ERR to an errno value or 0 if there isn't one.  */\n+\n+extern const char *\n+simple_object_attributes_compare (simple_object_attributes *attrs1,\n+\t\t\t    simple_object_attributes *attrs2,\n+\t\t\t    int *err);\n+\n+/* Release all resources associated with ATTRS.  */\n+\n+extern void\n+simple_object_release_attributes (simple_object_attributes *attrs);\n+\n+/* The type simple_object_write is used to create a new object file.  */\n+\n+typedef struct simple_object_write_struct simple_object_write;\n+\n+/* Start creating a new object file which is like ATTRS.  You must\n+   fetch attribute information from an existing object file before you\n+   can create a new one.  There is currently no support for creating\n+   an object file de novo.  The segment name is only used on Mach-O,\n+   where it is required.  It means that all sections are created\n+   within that segment.  It is ignored for other object file formats.\n+   On error this function returns NULL, sets *ERRMSG to an error\n+   message, and sets *ERR to an errno value or 0 if there isn't\n+   one.  */\n+\n+extern simple_object_write *\n+simple_object_start_write (simple_object_attributes *attrs,\n+\t\t\t   const char *segment_name,\n+\t\t\t   const char **errmsg, int *err);\n+\n+/* The type simple_object_write_section is a handle for a section\n+   which is being written.  */\n+\n+typedef struct simple_object_write_section_struct simple_object_write_section;\n+\n+/* Add a section to SIMPLE_OBJECT.  NAME is the name of the new\n+   section.  ALIGN is the required alignment expressed as the number\n+   of required low-order 0 bits (e.g., 2 for alignment to a 32-bit\n+   boundary).  The section is created as containing data, readable,\n+   not writable, not executable, not loaded at runtime.  On error this\n+   returns NULL, sets *ERRMSG to an error message, and sets *ERR to an\n+   errno value or 0 if there isn't one.  */\n+\n+extern simple_object_write_section *\n+simple_object_write_create_section (simple_object_write *simple_object,\n+\t\t\t\t    const char *name, unsigned int align,\n+\t\t\t\t    const char **errmsg, int *err);\n+\n+/* Add data BUFFER/SIZE to SECTION in SIMPLE_OBJECT.  If COPY is\n+   non-zero, the data will be copied into memory if necessary.  If\n+   COPY is zero, BUFFER must persist until SIMPLE_OBJECT is released.\n+   On success this returns NULL.  On error this returns an error\n+   message, and sets *ERR to an errno value or 0 if there isn't\n+   one.  */\n+\n+extern const char *\n+simple_object_write_add_data (simple_object_write *simple_object,\n+\t\t\t      simple_object_write_section *section,\n+\t\t\t      const void *buffer, size_t size,\n+\t\t\t      int copy, int *err);\n+\n+/* Write the complete object file to DESCRIPTOR, an open file\n+   descriptor.  This returns NULL on success.  On error this returns\n+   an error message, and sets *ERR to an errno value or 0 if there\n+   isn't one.  */\n+\n+extern const char *\n+simple_object_write_to_file (simple_object_write *simple_object,\n+\t\t\t     int descriptor, int *err);\n+\n+/* Release all resources associated with SIMPLE_OBJECT, including any\n+   simple_object_write_section's that may have been created.  */\n+\n+extern void\n+simple_object_release_write (simple_object_write *);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "fa38b09b61594966b72fbd46ccd0f93cc6d0aa44", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1,3 +1,22 @@\n+2010-11-02  Ian Lance Taylor  <iant@google.com>\n+\t    Dave Korn  <dave.korn.cygwin@gmail.com>\n+\t    Iain Sandoe  <iains@gcc.gnu.org>\n+\n+\t* simple-object.c: New file.\n+\t* simple-object-common.h: New file.\n+\t* simple-object-elf.c: New file.\n+\t* simple-object-mach-o.c: New file.\n+\t* simple-object-coff.c: New file.\n+\t* simple-object.txh: New file.\n+\t* configure.ac: Add AC_TYPE_SSIZE_T.\n+\t* Makefile.in: Rebuild dependencies.\n+\t(CFILES): Add simple-object.c, simple-object-coff,\n+\tsimple-object-elf.c, and simple-object-mach-o.c.\n+\t(REQUIRED_OFILES): Add corresponding object files.\n+\t* configure: Rebuild.\n+\t* config.in: Rebuild.\n+\t* functions.texi: Rebuild.\n+\n 2010-10-29  Ian Lance Taylor  <iant@google.com>\n \n \t* setproctitle.c: Add space after function name in @deftypefn"}, {"sha": "7a8bb02195e713966447c89eee291ea54963f048", "filename": "libiberty/Makefile.in", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FMakefile.in?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -2,8 +2,8 @@\n # Originally written by K. Richard Pixley <rich@cygnus.com>.\n #\n # Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-# 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software\n-# Foundation\n+# 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+# Free Software Foundation\n #\n # This file is part of the libiberty library.\n # Libiberty is free software; you can redistribute it and/or\n@@ -145,6 +145,8 @@ CFILES = alloca.c argv.c asprintf.c atexit.c\t\t\t\t\\\n          physmem.c putenv.c\t\t\t\t\t\t\\\n \trandom.c regex.c rename.c rindex.c\t\t\t\t\\\n \tsafe-ctype.c setenv.c setproctitle.c sha1.c sigsetmask.c        \\\n+\t simple-object.c simple-object-coff.c simple-object-elf.c\t\\\n+\t simple-object-mach-o.c\t\t\t\t\t\t\\\n          snprintf.c sort.c\t\t\t\t\t\t\\\n \t spaces.c splay-tree.c stpcpy.c stpncpy.c strcasecmp.c\t\t\\\n \t strchr.c strdup.c strerror.c strncasecmp.c strncmp.c\t\t\\\n@@ -172,11 +174,15 @@ REQUIRED_OFILES =\t\t\t\t\t\t\t\\\n \t./getruntime.$(objext) ./hashtab.$(objext) ./hex.$(objext)\t\\\n \t./lbasename.$(objext) ./lrealpath.$(objext)\t\t\t\\\n \t./make-relative-prefix.$(objext) ./make-temp-file.$(objext)\t\\\n-\t./objalloc.$(objext) ./obstack.$(objext)\t\t\t\\\n+\t./objalloc.$(objext)\t\t\t\t\t\t\\\n+\t./obstack.$(objext)\t\t\t\t\t\t\\\n \t./partition.$(objext) ./pexecute.$(objext) ./physmem.$(objext)\t\\\n \t./pex-common.$(objext) ./pex-one.$(objext)\t\t\t\\\n \t./@pexecute@.$(objext)\t\t\t\t\t\t\\\n-\t./safe-ctype.$(objext) ./sort.$(objext) ./spaces.$(objext)\t\\\n+\t./safe-ctype.$(objext)\t\t\t\t\t\t\\\n+\t./simple-object.$(objext) ./simple-object-coff.$(objext)\t\\\n+\t./simple-object-elf.$(objext) ./simple-object-mach-o.$(objext)\t\\\n+\t./sort.$(objext) ./spaces.$(objext)\t\t\t\t\\\n \t./splay-tree.$(objext) ./strerror.$(objext)\t\t\t\\\n \t./strsignal.$(objext) ./unlink-if-ordinary.$(objext)\t\t\\\n \t./xatexit.$(objext) ./xexit.$(objext) ./xmalloc.$(objext)\t\\\n@@ -312,7 +318,7 @@ TEXISRC = \\\n # Additional files that have texi snippets that need to be collected\n # and sorted.  Some are here because the sources are imported from\n # elsewhere.  Others represent headers in ../include.\n-TEXIFILES = fnmatch.txh pexecute.txh\n+TEXIFILES = fnmatch.txh pexecute.txh simple-object.txh\n \n libiberty.info : $(srcdir)/libiberty.texi $(TEXISRC)\n \t$(MAKEINFO) -I$(srcdir) $(srcdir)/libiberty.texi\n@@ -965,6 +971,38 @@ $(CONFIGURED_OFILES): stamp-picdir\n \telse true; fi\n \t$(COMPILE.c) $(srcdir)/sigsetmask.c $(OUTPUT_OPTION)\n \n+./simple-object-coff.$(objext): $(srcdir)/simple-object-coff.c config.h \\\n+\t$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/simple-object-coff.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/simple-object-coff.c $(OUTPUT_OPTION)\n+\n+./simple-object-elf.$(objext): $(srcdir)/simple-object-elf.c config.h \\\n+\t$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/simple-object-elf.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/simple-object-elf.c $(OUTPUT_OPTION)\n+\n+./simple-object-mach-o.$(objext): $(srcdir)/simple-object-mach-o.c config.h \\\n+\t$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/simple-object-mach-o.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/simple-object-mach-o.c $(OUTPUT_OPTION)\n+\n+./simple-object.$(objext): $(srcdir)/simple-object.c config.h \\\n+\t$(INCDIR)/ansidecl.h $(INCDIR)/libiberty.h \\\n+\t$(srcdir)/simple-object-common.h $(INCDIR)/simple-object.h\n+\tif [ x\"$(PICFLAG)\" != x ]; then \\\n+\t  $(COMPILE.c) $(PICFLAG) $(srcdir)/simple-object.c -o pic/$@; \\\n+\telse true; fi\n+\t$(COMPILE.c) $(srcdir)/simple-object.c $(OUTPUT_OPTION)\n+\n ./snprintf.$(objext): $(srcdir)/snprintf.c $(INCDIR)/ansidecl.h\n \tif [ x\"$(PICFLAG)\" != x ]; then \\\n \t  $(COMPILE.c) $(PICFLAG) $(srcdir)/snprintf.c -o pic/$@; \\"}, {"sha": "0e5f3d2acfbcecf012a7ab179756f24dd7a7a785", "filename": "libiberty/config.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfig.in?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -467,6 +467,9 @@\n /* Define to `int' if <sys/types.h> does not define. */\n #undef pid_t\n \n+/* Define to `int' if <sys/types.h> does not define. */\n+#undef ssize_t\n+\n /* Define to the type of an unsigned integer type wide enough to hold a\n    pointer, if such a type exists, and if the system does not define it. */\n #undef uintptr_t"}, {"sha": "3d7ba30a2cde7e6a4ce6ea689f9fd45c4b43bbc8", "filename": "libiberty/configure", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -5203,6 +5203,17 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n fi\n \n \n+ac_fn_c_check_type \"$LINENO\" \"ssize_t\" \"ac_cv_type_ssize_t\" \"$ac_includes_default\"\n+if test \"x$ac_cv_type_ssize_t\" = x\"\"yes; then :\n+\n+else\n+\n+cat >>confdefs.h <<_ACEOF\n+#define ssize_t int\n+_ACEOF\n+\n+fi\n+\n \n # Given the above check, we always have uintptr_t or a fallback\n # definition.  So define HAVE_UINTPTR_T in case any imported code"}, {"sha": "8136f25d850169b836c86055952274a6c5ff09fd", "filename": "libiberty/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fconfigure.ac?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -290,6 +290,7 @@ fi\n \n AC_TYPE_INTPTR_T\n AC_TYPE_UINTPTR_T\n+AC_TYPE_SSIZE_T\n \n # Given the above check, we always have uintptr_t or a fallback\n # definition.  So define HAVE_UINTPTR_T in case any imported code"}, {"sha": "b3543cbfc6d12df5367c3346666dd5da2ffd82ea", "filename": "libiberty/functions.texi", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Ffunctions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Ffunctions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ffunctions.texi?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -1181,6 +1181,186 @@ be the value @code{1}).\n \n @end deftypefn\n \n+@c simple-object.txh:87\n+@deftypefn Extension {const char *} simple_object_attributes_compare (simple_object_attributes *@var{attrs1}, simple_object_attributes *@var{attrs2}, int *@var{err})\n+\n+Compare @var{attrs1} and @var{attrs2}.  If they could be linked\n+together without error, return @code{NULL}.  Otherwise, return an\n+error message and set @code{*@var{err}} to an errno value or @code{0}\n+if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:73\n+@deftypefn Extension {simple_object_attributes *} simple_object_fetch_attributes (simple_object_read *@var{simple_object}, const char **@var{errmsg}, int *@var{err})\n+\n+Fetch the attributes of @var{simple_object}.  The attributes are\n+internal information such as the format of the object file, or the\n+architecture it was compiled for.  This information will persist until\n+@code{simple_object_attributes_release} is called, even if\n+@var{simple_object} itself is released.\n+\n+On error this returns @code{NULL}, sets @code{*@var{errmsg}} to an\n+error message, and sets @code{*@var{err}} to an errno value or\n+@code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:44\n+@deftypefn Extension {int} simple_object_find_section (simple_object_read *@var{simple_object} off_t *@var{offset}, off_t *@var{length}, const char **@var{errmsg}, int *@var{err})           \n+\n+Look for the section @var{name} in @var{simple_object}.  This returns\n+information for the first section with that name.\n+\n+If found, return 1 and set @code{*@var{offset}} to the offset in the\n+file of the section contents and set @code{*@var{length}} to the\n+length of the section contents.  The value in @code{*@var{offset}}\n+will be relative to the offset passed to\n+@code{simple_object_open_read}.\n+\n+If the section is not found, and no error occurs,\n+@code{simple_object_find_section} returns @code{0} and set\n+@code{*@var{errmsg}} to @code{NULL}.\n+\n+If an error occurs, @code{simple_object_find_section} returns\n+@code{0}, sets @code{*@var{errmsg}} to an error message, and sets\n+@code{*@var{err}} to an errno value or @code{0} if there is no\n+relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:25\n+@deftypefn Extension {const char *} simple_object_find_sections (simple_object_read *@var{simple_object}, int (*@var{pfn}) (void *@var{data}, const char *@var{name}, off_t @var{offset}, off_t @var{length}), void *@var{data}, int *@var{err})\n+\n+This function calls @var{pfn} for each section in @var{simple_object}.\n+It calls @var{pfn} with the section name, the offset within the file\n+of the section contents, and the length of the section contents.  The\n+offset within the file is relative to the offset passed to\n+@code{simple_object_open_read}.  The @var{data} argument to this\n+function is passed along to @var{pfn}.\n+\n+If @var{pfn} returns @code{0}, the loop over the sections stops and\n+@code{simple_object_find_sections} returns.  If @var{pfn} returns some\n+other value, the loop continues.\n+\n+On success @code{simple_object_find_sections} returns.  On error it\n+returns an error string, and sets @code{*@var{err}} to an errno value\n+or @code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:2\n+@deftypefn Extension {simple_object_read *} simple_object_open_read (int @var{descriptor}, off_t @var{offset}, const char *{segment_name}, const char **@var{errmsg}, int *@var{err})\n+\n+Opens an object file for reading.  Creates and returns an\n+@code{simple_object_read} pointer which may be passed to other\n+functions to extract data from the object file.\n+\n+@var{descriptor} holds a file descriptor which permits reading.\n+\n+@var{offset} is the offset into the file; this will be @code{0} in the\n+normal case, but may be a different value when reading an object file\n+in an archive file.\n+\n+@var{segment_name} is only used with the Mach-O file format used on\n+Darwin aka Mac OS X.  It is required on that platform, and means to\n+only look at sections within the segment with that name.  The\n+parameter is ignored on other systems.\n+\n+If an error occurs, this functions returns @code{NULL} and sets\n+@code{*@var{errmsg}} to an error string and sets @code{*@var{err}} to\n+an errno value or @code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:96\n+@deftypefn Extension {void} simple_object_release_attributes (simple_object_attributes *@var{attrs})\n+\n+Release all resources associated with @var{attrs}.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:66\n+@deftypefn Extension {void} simple_object_release_read (simple_object_read *@var{simple_object})\n+\n+Release all resources associated with @var{simple_object}.  This does\n+not close the file descriptor.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:164\n+@deftypefn Extension {void} simple_object_release_write (simple_object_write *@var{simple_object})\n+\n+Release all resources associated with @var{simple_object}.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:102\n+@deftypefn Extension {simple_object_write *} simple_object_start_write (simple_object_attributes @var{attrs}, const char *@var{segment_name}, const char **@var{errmsg}, int *@var{err})\n+\n+Start creating a new object file using the object file format\n+described in @var{attrs}.  You must fetch attribute information from\n+an existing object file before you can create a new one.  There is\n+currently no support for creating an object file de novo.\n+\n+@var{segment_name} is only used with Mach-O as found on Darwin aka Mac\n+OS X.  The parameter is required on that target.  It means that all\n+sections are created within the named segment.  It is ignored for\n+other object file formats.\n+\n+On error @code{simple_object_start_write} returns @code{NULL}, sets\n+@code{*@var{ERRMSG}} to an error message, and sets @code{*@var{err}}\n+to an errno value or @code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:137\n+@deftypefn Extension {const char *} simple_object_write_add_data (simple_object_write *@var{simple_object}, simple_object_write_section *@var{section}, const void *@var{buffer}, size_t @var{size}, int @var{copy}, int *@var{err})\n+\n+Add data @var{buffer}/@var{size} to @var{section} in\n+@var{simple_object}.  If @var{copy} is non-zero, the data will be\n+copied into memory if necessary.  If @var{copy} is zero, @var{buffer}\n+must persist until @code{simple_object_write_to_file} is called.  is\n+released.\n+\n+On success this returns @code{NULL}.  On error this returns an error\n+message, and sets @code{*@var{err}} to an errno value or 0 if there is\n+no relevant erro.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:120\n+@deftypefn Extension {simple_object_write_section *} simple_object_write_create_section (simple_object_write *@var{simple_object}, const char *@var{name}, unsigned int @var{align}, const char **@var{errmsg}, int *@var{err})\n+\n+Add a section to @var{simple_object}.  @var{name} is the name of the\n+new section.  @var{align} is the required alignment expressed as the\n+number of required low-order 0 bits (e.g., 2 for alignment to a 32-bit\n+boundary).\n+\n+The section is created as containing data, readable, not writable, not\n+executable, not loaded at runtime.  The section is not written to the\n+file until @code{simple_object_write_to_file} is called.\n+\n+On error this returns @code{NULL}, sets @code{*@var{errmsg}} to an\n+error message, and sets @code{*@var{err}} to an errno value or\n+@code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@c simple-object.txh:151\n+@deftypefn Extension {const char *} simple_object_write_to_file (simple_object_write *@var{simple_object}, int @var{descriptor}, int *@var{err})\n+\n+Write the complete object file to @var{descriptor}, an open file\n+descriptor.  This writes out all the data accumulated by calls to\n+@code{simple_object_write_create_section} and\n+@var{simple_object_write_add_data}.\n+\n+This returns @code{NULL} on success.  On error this returns an error\n+message and sets @code{*@var{err}} to an errno value or @code{0} if\n+there is no relevant errno.\n+\n+@end deftypefn\n+\n @c snprintf.c:28\n @deftypefn Supplemental int snprintf (char *@var{buf}, size_t @var{n}, const char *@var{format}, ...)\n "}, {"sha": "9ba1dd4bac024df6bd3abf44494e6c2ba253a7dc", "filename": "libiberty/simple-object-coff.c", "status": "added", "additions": 804, "deletions": 0, "changes": 804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-coff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-coff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-coff.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,804 @@\n+/* simple-object-coff.c -- routines to manipulate COFF object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+#include \"simple-object.h\"\n+\n+#include <errno.h>\n+#include <stddef.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#ifdef HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#include \"simple-object-common.h\"\n+\n+/* COFF structures and constants.  */\n+\n+/* COFF file header.  */\n+\n+struct external_filehdr\n+{\n+  unsigned char f_magic[2];\t/* magic number\t\t\t*/\n+  unsigned char f_nscns[2];\t/* number of sections\t\t*/\n+  unsigned char f_timdat[4];\t/* time & date stamp\t\t*/\n+  unsigned char f_symptr[4];\t/* file pointer to symtab\t*/\n+  unsigned char f_nsyms[4];\t/* number of symtab entries\t*/\n+  unsigned char f_opthdr[2];\t/* sizeof(optional hdr)\t\t*/\n+  unsigned char f_flags[2];\t/* flags\t\t\t*/\n+};\n+\n+/* Bits for filehdr f_flags field.  */\n+\n+#define F_EXEC\t\t\t(0x0002)\n+#define IMAGE_FILE_SYSTEM\t(0x1000)\n+#define IMAGE_FILE_DLL\t\t(0x2000)\n+\n+/* COFF section header.  */\n+\n+struct external_scnhdr\n+{\n+  unsigned char s_name[8];\t/* section name\t\t\t\t*/\n+  unsigned char s_paddr[4];\t/* physical address, aliased s_nlib \t*/\n+  unsigned char s_vaddr[4];\t/* virtual address\t\t\t*/\n+  unsigned char s_size[4];\t/* section size\t\t\t\t*/\n+  unsigned char s_scnptr[4];\t/* file ptr to raw data for section \t*/\n+  unsigned char s_relptr[4];\t/* file ptr to relocation\t\t*/\n+  unsigned char s_lnnoptr[4];\t/* file ptr to line numbers\t\t*/\n+  unsigned char s_nreloc[2];\t/* number of relocation entries\t\t*/\n+  unsigned char s_nlnno[2];\t/* number of line number entries\t*/\n+  unsigned char s_flags[4];\t/* flags\t\t\t\t*/\n+};\n+\n+/* The length of the s_name field in struct external_scnhdr.  */\n+\n+#define SCNNMLEN (8)\n+\n+/* Bits for scnhdr s_flags field.  This includes some bits defined\n+   only for PE.  This may need to be moved into coff_magic.  */\n+\n+#define STYP_DATA\t\t\t(1 << 6)\n+#define IMAGE_SCN_MEM_DISCARDABLE\t(1 << 25)\n+#define IMAGE_SCN_MEM_SHARED\t\t(1 << 28)\n+#define IMAGE_SCN_MEM_READ\t\t(1 << 30)\n+\n+#define IMAGE_SCN_ALIGN_POWER_BIT_POS\t     20\n+#define IMAGE_SCN_ALIGN_POWER_CONST(val)     \\\n+  (((val) + 1) << IMAGE_SCN_ALIGN_POWER_BIT_POS)\n+\n+/* COFF symbol table entry.  */\n+\n+#define E_SYMNMLEN\t8\t/* # characters in a symbol name\t*/\n+\n+struct external_syment\n+{\n+  union\n+  {\n+    unsigned char e_name[E_SYMNMLEN];\n+\n+    struct\n+    {\n+      unsigned char e_zeroes[4];\n+      unsigned char e_offset[4];\n+    } e;\n+  } e;\n+\n+  unsigned char e_value[4];\n+  unsigned char e_scnum[2];\n+  unsigned char e_type[2];\n+  unsigned char e_sclass[1];\n+  unsigned char e_numaux[1];\n+};\n+\n+/* Length allowed for filename in aux sym format 4.  */\n+\n+#define E_FILNMLEN\t18\n+\n+/* Omits x_sym and other unused variants.  */\n+\n+union external_auxent\n+{\n+  /* Aux sym format 4: file.  */\n+  union\n+  {\n+    char x_fname[E_FILNMLEN];\n+    struct\n+    {\n+      unsigned char x_zeroes[4];\n+      unsigned char x_offset[4];\n+    } x_n;\n+  } x_file;\n+  /* Aux sym format 5: section.  */\n+  struct\n+  {\n+    unsigned char x_scnlen[4];\t\t/* section length\t\t*/\n+    unsigned char x_nreloc[2];\t\t/* # relocation entries\t\t*/\n+    unsigned char x_nlinno[2];\t\t/* # line numbers\t\t*/\n+    unsigned char x_checksum[4];\t/* section COMDAT checksum\t*/\n+    unsigned char x_associated[2];\t/* COMDAT assoc section index\t*/\n+    unsigned char x_comdat[1];\t\t/* COMDAT selection number\t*/\n+  } x_scn;\n+};\n+\n+/* Symbol-related constants.  */\n+\n+#define IMAGE_SYM_DEBUG\t\t(-2)\n+#define IMAGE_SYM_TYPE_NULL\t(0)\n+#define IMAGE_SYM_DTYPE_NULL\t(0)\n+#define IMAGE_SYM_CLASS_STATIC\t(3)\n+#define IMAGE_SYM_CLASS_FILE\t(103)\n+\n+#define IMAGE_SYM_TYPE \\\n+  ((IMAGE_SYM_DTYPE_NULL << 4) | IMAGE_SYM_TYPE_NULL)\n+\n+/* Private data for an simple_object_read.  */\n+\n+struct simple_object_coff_read\n+{\n+  /* Magic number.  */\n+  unsigned short magic;\n+  /* Whether the file is big-endian.  */\n+  unsigned char is_big_endian;\n+  /* Number of sections.  */\n+  unsigned short nscns;\n+  /* File offset of symbol table.  */\n+  off_t symptr;\n+  /* Number of symbol table entries.  */\n+  unsigned int nsyms;\n+  /* Flags.  */\n+  unsigned short flags;\n+  /* Offset of section headers in file.  */\n+  off_t scnhdr_offset;\n+};\n+\n+/* Private data for an simple_object_attributes.  */\n+\n+struct simple_object_coff_attributes\n+{\n+  /* Magic number.  */\n+  unsigned short magic;\n+  /* Whether the file is big-endian.  */\n+  unsigned char is_big_endian;\n+  /* Flags.  */\n+  unsigned short flags;\n+};\n+\n+/* There is no magic number which indicates a COFF file as opposed to\n+   any other sort of file.  Instead, each COFF file starts with a\n+   two-byte magic number which also indicates the type of the target.\n+   This struct holds a magic number as well as characteristics of that\n+   COFF format.  */\n+\n+struct coff_magic_struct\n+{\n+  /* Magic number.  */\n+  unsigned short magic;\n+  /* Whether this magic number is for a big-endian file.  */\n+  unsigned char is_big_endian;\n+  /* Flag bits, in the f_flags fields, which indicates that this file\n+     is not a relocatable object file.  There is no flag which\n+     specifically indicates a relocatable object file, it is only\n+     implied by the absence of these flags.  */\n+  unsigned short non_object_flags;\n+};\n+\n+/* This is a list of the COFF magic numbers which we recognize, namely\n+   the ones used on Windows.  More can be added as needed.  */\n+\n+static const struct coff_magic_struct coff_magic[] =\n+{\n+  /* i386.  */\n+  { 0x14c, 0, F_EXEC | IMAGE_FILE_SYSTEM | IMAGE_FILE_DLL },\n+  /* x86_64.  */\n+  { 0x8664, 0, F_EXEC | IMAGE_FILE_SYSTEM | IMAGE_FILE_DLL }\n+};\n+\n+/* See if we have a COFF file.  */\n+\n+static void *\n+simple_object_coff_match (unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],\n+\t\t\t  int descriptor, off_t offset,\n+\t\t\t  const char *segment_name ATTRIBUTE_UNUSED,\n+\t\t\t  const char **errmsg, int *err)\n+{\n+  size_t c;\n+  unsigned short magic_big;\n+  unsigned short magic_little;\n+  unsigned short magic;\n+  size_t i;\n+  int is_big_endian;\n+  unsigned short (*fetch_16) (const unsigned char *);\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  unsigned char hdrbuf[sizeof (struct external_filehdr)];\n+  unsigned short flags;\n+  struct simple_object_coff_read *ocr;\n+\n+  c = sizeof (coff_magic) / sizeof (coff_magic[0]);\n+  magic_big = simple_object_fetch_big_16 (header);\n+  magic_little = simple_object_fetch_little_16 (header);\n+  for (i = 0; i < c; ++i)\n+    {\n+      if (coff_magic[i].is_big_endian\n+\t  ? coff_magic[i].magic == magic_big\n+\t  : coff_magic[i].magic == magic_little)\n+\tbreak;\n+    }\n+  if (i >= c)\n+    {\n+      *errmsg = NULL;\n+      *err = 0;\n+      return NULL;\n+    }\n+  is_big_endian = coff_magic[i].is_big_endian;\n+\n+  magic = is_big_endian ? magic_big : magic_little;\n+  fetch_16 = (is_big_endian\n+\t      ? simple_object_fetch_big_16\n+\t      : simple_object_fetch_little_16);\n+  fetch_32 = (is_big_endian\n+\t      ? simple_object_fetch_big_32\n+\t      : simple_object_fetch_little_32);\n+\n+  if (!simple_object_internal_read (descriptor, offset, hdrbuf, sizeof hdrbuf,\n+\t\t\t\t    errmsg, err))\n+    return NULL;\n+\n+  flags = fetch_16 (hdrbuf + offsetof (struct external_filehdr, f_flags));\n+  if ((flags & coff_magic[i].non_object_flags) != 0)\n+    {\n+      *errmsg = \"not relocatable object file\";\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  ocr = XNEW (struct simple_object_coff_read);\n+  ocr->magic = magic;\n+  ocr->is_big_endian = is_big_endian;\n+  ocr->nscns = fetch_16 (hdrbuf + offsetof (struct external_filehdr, f_nscns));\n+  ocr->symptr = fetch_32 (hdrbuf\n+\t\t\t  + offsetof (struct external_filehdr, f_symptr));\n+  ocr->nsyms = fetch_32 (hdrbuf + offsetof (struct external_filehdr, f_nsyms));\n+  ocr->flags = flags;\n+  ocr->scnhdr_offset = (sizeof (struct external_filehdr)\n+\t\t\t+ fetch_16 (hdrbuf + offsetof (struct external_filehdr,\n+\t\t\t\t\t\t       f_opthdr)));\n+\n+  return (void *) ocr;\n+}\n+\n+/* Read the string table in a COFF file.  */\n+\n+static char *\n+simple_object_coff_read_strtab (simple_object_read *sobj, size_t *strtab_size,\n+\t\t\t\tconst char **errmsg, int *err)\n+{\n+  struct simple_object_coff_read *ocr =\n+    (struct simple_object_coff_read *) sobj->data;\n+  off_t strtab_offset;\n+  unsigned char strsizebuf[4];\n+  size_t strsize;\n+  char *strtab;\n+\n+  strtab_offset = ocr->symptr + ocr->nsyms * sizeof (struct external_syment);\n+  if (!simple_object_internal_read (sobj->descriptor, strtab_offset,\n+\t\t\t\t    strsizebuf, 4, errmsg, err))\n+    return NULL;\n+  strsize = (ocr->is_big_endian\n+\t     ? simple_object_fetch_big_32 (strsizebuf)\n+\t     : simple_object_fetch_little_32 (strsizebuf));\n+  strtab = XNEWVEC (char, strsize);\n+  if (!simple_object_internal_read (sobj->descriptor, strtab_offset,\n+\t\t\t\t    (unsigned char *) strtab, strsize, errmsg,\n+\t\t\t\t    err))\n+    {\n+      XDELETEVEC (strtab);\n+      return NULL;\n+    }\n+  *strtab_size = strsize;\n+  return strtab;\n+}\n+\n+/* Find all sections in a COFF file.  */\n+\n+static const char *\n+simple_object_coff_find_sections (simple_object_read *sobj,\n+\t\t\t\t  int (*pfn) (void *, const char *,\n+\t\t\t\t\t      off_t offset, off_t length),\n+\t\t\t\t  void *data,\n+\t\t\t\t  int *err)\n+{\n+  struct simple_object_coff_read *ocr =\n+    (struct simple_object_coff_read *) sobj->data;\n+  size_t scnhdr_size;\n+  unsigned char *scnbuf;\n+  const char *errmsg;\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  unsigned int nscns;\n+  char *strtab;\n+  size_t strtab_size;\n+  unsigned int i;\n+\n+  scnhdr_size = sizeof (struct external_scnhdr);\n+  scnbuf = XNEWVEC (unsigned char, scnhdr_size * ocr->nscns);\n+  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t    sobj->offset + ocr->scnhdr_offset,\n+\t\t\t\t    scnbuf, scnhdr_size * ocr->nscns, &errmsg,\n+\t\t\t\t    err))\n+    {\n+      XDELETEVEC (scnbuf);\n+      return errmsg;\n+    }\n+\n+  fetch_32 = (ocr->is_big_endian\n+\t      ? simple_object_fetch_big_32\n+\t      : simple_object_fetch_little_32);\n+\n+  nscns = ocr->nscns;\n+  strtab = NULL;\n+  strtab_size = 0;\n+  for (i = 0; i < nscns; ++i)\n+    {\n+      unsigned char *scnhdr;\n+      unsigned char *scnname;\n+      char namebuf[SCNNMLEN + 1];\n+      char *name;\n+      off_t scnptr;\n+      unsigned int size;\n+\n+      scnhdr = scnbuf + i * scnhdr_size;\n+      scnname = scnhdr + offsetof (struct external_scnhdr, s_name);\n+      memcpy (namebuf, scnname, SCNNMLEN);\n+      namebuf[SCNNMLEN] = '\\0';\n+      name = &namebuf[0];\n+      if (namebuf[0] == '/')\n+\t{\n+\t  size_t strindex;\n+\t  char *end;\n+\n+\t  strindex = strtol (namebuf + 1, &end, 10);\n+\t  if (*end == '\\0')\n+\t    {\n+\t      /* The real section name is found in the string\n+\t\t table.  */\n+\t      if (strtab == NULL)\n+\t\t{\n+\t\t  strtab = simple_object_coff_read_strtab (sobj,\n+\t\t\t\t\t\t\t   &strtab_size,\n+\t\t\t\t\t\t\t   &errmsg, err);\n+\t\t  if (strtab == NULL)\n+\t\t    {\n+\t\t      XDELETEVEC (scnbuf);\n+\t\t      return errmsg;\n+\t\t    }\n+\t\t}\n+\n+\t      if (strindex < 4 || strindex >= strtab_size)\n+\t\t{\n+\t\t  XDELETEVEC (strtab);\n+\t\t  XDELETEVEC (scnbuf);\n+\t\t  *err = 0;\n+\t\t  return \"section string index out of range\";\n+\t\t}\n+\n+\t      name = strtab + strindex;\n+\t    }\n+\t}\n+\n+      scnptr = fetch_32 (scnhdr + offsetof (struct external_scnhdr, s_scnptr));\n+      size = fetch_32 (scnhdr + offsetof (struct external_scnhdr, s_size));\n+\n+      if (!(*pfn) (data, name, scnptr, size))\n+\tbreak;\n+    }\n+\n+  if (strtab != NULL)\n+    XDELETEVEC (strtab);\n+  XDELETEVEC (scnbuf);\n+\n+  return NULL;\n+}\n+\n+/* Fetch the attributes for an simple_object_read.  */\n+\n+static void *\n+simple_object_coff_fetch_attributes (simple_object_read *sobj,\n+\t\t\t\t     const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\t     int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_coff_read *ocr =\n+    (struct simple_object_coff_read *) sobj->data;\n+  struct simple_object_coff_attributes *ret;\n+\n+  ret = XNEW (struct simple_object_coff_attributes);\n+  ret->magic = ocr->magic;\n+  ret->is_big_endian = ocr->is_big_endian;\n+  ret->flags = ocr->flags;\n+  return ret;\n+}\n+\n+/* Release the private data for an simple_object_read.  */\n+\n+static void\n+simple_object_coff_release_read (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Compare two attributes structures.  */\n+\n+static const char *\n+simple_object_coff_attributes_compare (void *data1, void *data2, int *err)\n+{\n+  struct simple_object_coff_attributes *attrs1 =\n+    (struct simple_object_coff_attributes *) data1;\n+  struct simple_object_coff_attributes *attrs2 =\n+    (struct simple_object_coff_attributes *) data2;\n+\n+  if (attrs1->magic != attrs2->magic\n+      || attrs1->is_big_endian != attrs2->is_big_endian)\n+    {\n+      *err = 0;\n+      return \"COFF object format mismatch\";\n+    }\n+  return NULL;\n+}\n+\n+/* Release the private data for an attributes structure.  */\n+\n+static void\n+simple_object_coff_release_attributes (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Prepare to write out a file.  */\n+\n+static void *\n+simple_object_coff_start_write (void *attributes_data,\n+\t\t\t\tconst char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\tint *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_coff_attributes *attrs =\n+    (struct simple_object_coff_attributes *) attributes_data;\n+  struct simple_object_coff_attributes *ret;\n+\n+  /* We're just going to record the attributes, but we need to make a\n+     copy because the user may delete them.  */\n+  ret = XNEW (struct simple_object_coff_attributes);\n+  *ret = *attrs;\n+  return ret;\n+}\n+\n+/* Write out a COFF filehdr.  */\n+\n+static int\n+simple_object_coff_write_filehdr (simple_object_write *sobj, int descriptor,\n+\t\t\t\t  unsigned int nscns, size_t symtab_offset,\n+\t\t\t\t  unsigned int nsyms, const char **errmsg,\n+\t\t\t\t  int *err)\n+{\n+  struct simple_object_coff_attributes *attrs =\n+    (struct simple_object_coff_attributes *) sobj->data;\n+  unsigned char hdrbuf[sizeof (struct external_filehdr)];\n+  unsigned char *hdr;\n+  void (*set_16) (unsigned char *, unsigned short);\n+  void (*set_32) (unsigned char *, unsigned int);\n+\n+  hdr = &hdrbuf[0];\n+\n+  set_16 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_16\n+\t    : simple_object_set_little_16);\n+  set_32 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_32\n+\t    : simple_object_set_little_32);\n+\n+  memset (hdr, 0, sizeof (struct external_filehdr));\n+\n+  set_16 (hdr + offsetof (struct external_filehdr, f_magic), attrs->magic);\n+  set_16 (hdr + offsetof (struct external_filehdr, f_nscns), nscns);\n+  /* f_timdat left as zero.  */\n+  set_32 (hdr + offsetof (struct external_filehdr, f_symptr), symtab_offset);\n+  set_32 (hdr + offsetof (struct external_filehdr, f_nsyms), nsyms);\n+  /* f_opthdr left as zero.  */\n+  set_16 (hdr + offsetof (struct external_filehdr, f_flags), attrs->flags);\n+\n+  return simple_object_internal_write (descriptor, 0, hdrbuf,\n+\t\t\t\t       sizeof (struct external_filehdr),\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out a COFF section header.  */\n+\n+static int\n+simple_object_coff_write_scnhdr (simple_object_write *sobj, int descriptor,\n+\t\t\t\t const char *name, size_t *name_offset,\n+\t\t\t\t off_t scnhdr_offset, size_t scnsize,\n+\t\t\t\t off_t offset, unsigned int align,\n+\t\t\t\t const char **errmsg, int *err)\n+{\n+  struct simple_object_coff_attributes *attrs =\n+    (struct simple_object_coff_attributes *) sobj->data;\n+  void (*set_32) (unsigned char *, unsigned int);\n+  unsigned char hdrbuf[sizeof (struct external_scnhdr)];\n+  unsigned char *hdr;\n+  size_t namelen;\n+  unsigned int flags;\n+\n+  set_32 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_32\n+\t    : simple_object_set_little_32);\n+\n+  memset (hdrbuf, 0, sizeof hdrbuf);\n+  hdr = &hdrbuf[0];\n+\n+  namelen = strlen (name);\n+  if (namelen <= SCNNMLEN)\n+    strncpy ((char *) hdr + offsetof (struct external_scnhdr, s_name), name,\n+\t     SCNNMLEN);\n+  else\n+    {\n+      snprintf ((char *) hdr + offsetof (struct external_scnhdr, s_name),\n+\t\tSCNNMLEN, \"/%lu\", (unsigned long) *name_offset);\n+      *name_offset += namelen + 1;\n+    }\n+\n+  /* s_paddr left as zero.  */\n+  /* s_vaddr left as zero.  */\n+  set_32 (hdr + offsetof (struct external_scnhdr, s_size), scnsize);\n+  set_32 (hdr + offsetof (struct external_scnhdr, s_scnptr), offset);\n+  /* s_relptr left as zero.  */\n+  /* s_lnnoptr left as zero.  */\n+  /* s_nreloc left as zero.  */\n+  /* s_nlnno left as zero.  */\n+  flags = (STYP_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_MEM_SHARED\n+\t   | IMAGE_SCN_MEM_READ);\n+  /* PE can represent alignment up to 13.  */\n+  if (align > 13)\n+    align = 13;\n+  flags |= IMAGE_SCN_ALIGN_POWER_CONST(align);\n+  set_32 (hdr + offsetof (struct external_scnhdr, s_flags), flags);\n+\n+  return simple_object_internal_write (descriptor, scnhdr_offset, hdrbuf,\n+\t\t\t\t       sizeof (struct external_scnhdr),\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out a complete COFF file.  */\n+\n+static const char *\n+simple_object_coff_write_to_file (simple_object_write *sobj, int descriptor,\n+\t\t\t\t  int *err)\n+{\n+  struct simple_object_coff_attributes *attrs =\n+    (struct simple_object_coff_attributes *) sobj->data;\n+  unsigned int nscns, secnum;\n+  simple_object_write_section *section;\n+  off_t scnhdr_offset;\n+  size_t symtab_offset;\n+  off_t secsym_offset;\n+  unsigned int nsyms;\n+  size_t offset;\n+  size_t name_offset;\n+  const char *errmsg;\n+  unsigned char strsizebuf[4];\n+  /* The interface doesn't give us access to the name of the input file\n+     yet.  We want to use its basename for the FILE symbol.  This is\n+     what 'gas' uses when told to assemble from stdin.  */\n+  const char *source_filename = \"fake\";\n+  size_t sflen;\n+  union\n+  {\n+    struct external_syment sym;\n+    union external_auxent aux;\n+  } syms[2];\n+  void (*set_16) (unsigned char *, unsigned short);\n+  void (*set_32) (unsigned char *, unsigned int);\n+\n+  set_16 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_16\n+\t    : simple_object_set_little_16);\n+  set_32 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_32\n+\t    : simple_object_set_little_32);\n+\n+  nscns = 0;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    ++nscns;\n+\n+  scnhdr_offset = sizeof (struct external_filehdr);\n+  offset = scnhdr_offset + nscns * sizeof (struct external_scnhdr);\n+  name_offset = 4;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t mask;\n+      size_t new_offset;\n+      size_t scnsize;\n+      struct simple_object_write_section_buffer *buffer;\n+\n+      mask = (1U << section->align) - 1;\n+      new_offset = offset & mask;\n+      new_offset &= ~ mask;\n+      while (new_offset > offset)\n+\t{\n+\t  unsigned char zeroes[16];\n+\t  size_t write;\n+\n+\t  memset (zeroes, 0, sizeof zeroes);\n+\t  write = new_offset - offset;\n+\t  if (write > sizeof zeroes)\n+\t    write = sizeof zeroes;\n+\t  if (!simple_object_internal_write (descriptor, offset, zeroes, write,\n+\t\t\t\t\t     &errmsg, err))\n+\t    return errmsg;\n+\t}\n+\n+      scnsize = 0;\n+      for (buffer = section->buffers; buffer != NULL; buffer = buffer->next)\n+\t{\n+\t  if (!simple_object_internal_write (descriptor, offset + scnsize,\n+\t\t\t\t\t     ((const unsigned char *)\n+\t\t\t\t\t      buffer->buffer),\n+\t\t\t\t\t     buffer->size, &errmsg, err))\n+\t    return errmsg;\n+\t  scnsize += buffer->size;\n+\t}\n+\n+      if (!simple_object_coff_write_scnhdr (sobj, descriptor, section->name,\n+\t\t\t\t\t    &name_offset, scnhdr_offset,\n+\t\t\t\t\t    scnsize, offset, section->align,\n+\t\t\t\t\t    &errmsg, err))\n+\treturn errmsg;\n+\n+      scnhdr_offset += sizeof (struct external_scnhdr);\n+      offset += scnsize;\n+    }\n+\n+  /* Symbol table is always half-word aligned.  */\n+  offset += (offset & 1);\n+  /* There is a file symbol and a section symbol per section,\n+     and each of these has a single auxiliary symbol following.  */\n+  nsyms = 2 * (nscns + 1);\n+  symtab_offset = offset;\n+  /* Advance across space reserved for symbol table to locate\n+     start of string table.  */\n+  offset += nsyms * sizeof (struct external_syment);\n+\n+  /* Write out file symbol.  */\n+  memset (&syms[0], 0, sizeof (syms));\n+  strcpy ((char *)&syms[0].sym.e.e_name[0], \".file\");\n+  set_16 (&syms[0].sym.e_scnum[0], IMAGE_SYM_DEBUG);\n+  set_16 (&syms[0].sym.e_type[0], IMAGE_SYM_TYPE);\n+  syms[0].sym.e_sclass[0] = IMAGE_SYM_CLASS_FILE;\n+  syms[0].sym.e_numaux[0] = 1;\n+  /* The name need not be nul-terminated if it fits into the x_fname field\n+     directly, but must be if it has to be placed into the string table.  */\n+  sflen = strlen (source_filename);\n+  if (sflen <= E_FILNMLEN)\n+    memcpy (&syms[1].aux.x_file.x_fname[0], source_filename, sflen);\n+  else\n+    {\n+      set_32 (&syms[1].aux.x_file.x_n.x_offset[0], name_offset);\n+      if (!simple_object_internal_write (descriptor, offset + name_offset,\n+\t\t\t\t\t ((const unsigned char *)\n+\t\t\t\t\t  source_filename),\n+\t\t\t\t\t sflen + 1, &errmsg, err))\n+\treturn errmsg;\n+      name_offset += strlen (source_filename) + 1;\n+    }\n+  if (!simple_object_internal_write (descriptor, symtab_offset,\n+\t\t\t\t     (const unsigned char *) &syms[0],\n+\t\t\t\t     sizeof (syms), &errmsg, err))\n+    return errmsg;\n+\n+  /* Write the string table length, followed by the strings and section\n+     symbols in step with each other.  */\n+  set_32 (strsizebuf, name_offset);\n+  if (!simple_object_internal_write (descriptor, offset, strsizebuf, 4,\n+\t\t\t\t     &errmsg, err))\n+    return errmsg;\n+\n+  name_offset = 4;\n+  secsym_offset = symtab_offset + sizeof (syms);\n+  memset (&syms[0], 0, sizeof (syms));\n+  set_16 (&syms[0].sym.e_type[0], IMAGE_SYM_TYPE);\n+  syms[0].sym.e_sclass[0] = IMAGE_SYM_CLASS_STATIC;\n+  syms[0].sym.e_numaux[0] = 1;\n+  secnum = 1;\n+\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t namelen;\n+      size_t scnsize;\n+      struct simple_object_write_section_buffer *buffer;\n+\n+      namelen = strlen (section->name);\n+      set_16 (&syms[0].sym.e_scnum[0], secnum++);\n+      scnsize = 0;\n+      for (buffer = section->buffers; buffer != NULL; buffer = buffer->next)\n+\tscnsize += buffer->size;\n+      set_32 (&syms[1].aux.x_scn.x_scnlen[0], scnsize);\n+      if (namelen > SCNNMLEN)\n+\t{\n+\t  set_32 (&syms[0].sym.e.e.e_zeroes[0], 0);\n+\t  set_32 (&syms[0].sym.e.e.e_offset[0], name_offset);\n+\t  if (!simple_object_internal_write (descriptor, offset + name_offset,\n+\t\t\t\t\t     ((const unsigned char *)\n+\t\t\t\t\t      section->name),\n+\t\t\t\t\t     namelen + 1, &errmsg, err))\n+\t    return errmsg;\n+\t  name_offset += namelen + 1;\n+\t}\n+      else\n+\t{\n+\t  memcpy (&syms[0].sym.e.e_name[0], section->name,\n+\t\t  strlen (section->name));\n+\t  memset (&syms[0].sym.e.e_name[strlen (section->name)], 0,\n+\t\t  E_SYMNMLEN - strlen (section->name));\n+\t}\n+\n+      if (!simple_object_internal_write (descriptor, secsym_offset,\n+\t\t\t\t\t (const unsigned char *) &syms[0],\n+\t\t\t\t\t sizeof (syms), &errmsg, err))\n+\treturn errmsg;\n+      secsym_offset += sizeof (syms);\n+    }\n+\n+  if (!simple_object_coff_write_filehdr (sobj, descriptor, nscns,\n+\t\t\t\t\t symtab_offset, nsyms, &errmsg, err))\n+    return errmsg;\n+\n+  return NULL;\n+}\n+\n+/* Release the private data for an simple_object_write structure.  */\n+\n+static void\n+simple_object_coff_release_write (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* The COFF functions.  */\n+\n+const struct simple_object_functions simple_object_coff_functions =\n+{\n+  simple_object_coff_match,\n+  simple_object_coff_find_sections,\n+  simple_object_coff_fetch_attributes,\n+  simple_object_coff_release_read,\n+  simple_object_coff_attributes_compare,\n+  simple_object_coff_release_attributes,\n+  simple_object_coff_start_write,\n+  simple_object_coff_write_to_file,\n+  simple_object_coff_release_write\n+};"}, {"sha": "8f743908e315c4645dac0edfaead635fd8299cea", "filename": "libiberty/simple-object-common.h", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-common.h?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,355 @@\n+/* simple-object-common.h -- common structs for object file manipulation.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+\n+This file is part of the libiberty library.\n+Libiberty is free software; you can redistribute it and/or\n+modify it under the terms of the GNU Library General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+Libiberty is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+Library General Public License for more details.\n+\n+You should have received a copy of the GNU Library General Public\n+License along with libiberty; see the file COPYING.LIB.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* Forward reference.  */\n+struct simple_object_functions;\n+\n+/* An object file opened for reading.  */\n+\n+struct simple_object_read_struct\n+{\n+  /* The file descriptor.  */\n+  int descriptor;\n+  /* The offset within the file.  */\n+  off_t offset;\n+  /* The functions which do the actual work.  */\n+  const struct simple_object_functions *functions;\n+  /* Private data for the object file format.  */\n+  void *data;\n+};\n+\n+/* Object file attributes.  */\n+\n+struct simple_object_attributes_struct\n+{\n+  /* The functions which do the actual work.  */\n+  const struct simple_object_functions *functions;\n+  /* Private data for the object file format.  */\n+  void *data;\n+};\n+\n+/* An object file being created.  */\n+\n+struct simple_object_write_struct\n+{\n+  /* The functions which do the actual work.  */\n+  const struct simple_object_functions *functions;\n+  /* The segment_name argument from the user.  */\n+  char *segment_name;\n+  /* The start of the list of sections.  */\n+  simple_object_write_section *sections;\n+  /* The last entry in the list of sections.  */\n+  simple_object_write_section *last_section;\n+  /* Private data for the object file format.  */\n+  void *data;\n+};\n+\n+/* A section in an object file being created.  */\n+\n+struct simple_object_write_section_struct\n+{\n+  /* Next in the list of sections attached to an\n+     simple_object_write.  */\n+  simple_object_write_section *next;\n+  /* The name of this section.  */\n+  char *name;\n+  /* The required alignment.  */\n+  unsigned int align;\n+  /* The first data attached to this section.  */\n+  struct simple_object_write_section_buffer *buffers;\n+  /* The last data attached to this section.  */\n+  struct simple_object_write_section_buffer *last_buffer;\n+};\n+\n+/* Data attached to a section.  */\n+\n+struct simple_object_write_section_buffer\n+{\n+  /* The next data for this section.  */\n+  struct simple_object_write_section_buffer *next;\n+  /* The size of the buffer.  */\n+  size_t size;\n+  /* The actual bytes.  */\n+  const void *buffer;\n+  /* A buffer to free, or NULL.  */\n+  void *free_buffer;\n+};\n+\n+/* The number of bytes we read from the start of the file to pass to\n+   the match function.  */\n+#define SIMPLE_OBJECT_MATCH_HEADER_LEN (16)\n+\n+/* Format-specific object file functions.  */\n+\n+struct simple_object_functions\n+{\n+  /* If this file matches these functions, return a new value for the\n+     private data for an simple_object_read.  HEADER is the first 16\n+     bytes of the file.  DESCRIPTOR, OFFSET, SEGMENT_NAME, ERRMSG, and\n+     ERR are as for simple_object_open_read.  If this file does not\n+     match, this function should return NULL with *ERRMSG set to\n+     NULL.  */\n+  void *(*match) (unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],\n+\t\t  int descriptor, off_t offset, const char *segment_name,\n+\t\t  const char **errmsg, int *err);\n+\n+  /* Implement simple_object_find_sections.  */\n+  const char *(*find_sections) (simple_object_read *,\n+\t\t\t\tint (*pfn) (void *, const char *,\n+\t\t\t\t\t    off_t offset, off_t length),\n+\t\t\t\tvoid *data,\n+\t\t\t\tint *err);\n+\n+  /* Return the private data for the attributes for SOBJ.  */\n+  void *(*fetch_attributes) (simple_object_read *sobj, const char **errmsg,\n+\t\t\t     int *err);\n+\n+  /* Release the private data for an simple_object_read.  */\n+  void (*release_read) (void *);\n+\n+  /* Compare the private data for the attributes of two files.  If\n+     they are the same, in the sense that they could be linked\n+     together, return NULL.  Otherwise return an error message.  */\n+  const char *(*attributes_compare) (void *, void *, int *err);\n+\n+  /* Release the private data for an simple_object_attributes.  */\n+  void (*release_attributes) (void *);\n+\n+  /* Start creating an object file.  */\n+  void *(*start_write) (void *attributes_data, const char **errmsg,\n+\t\t\tint *err);\n+\n+  /* Write the complete object file.  */\n+  const char *(*write_to_file) (simple_object_write *sobj, int descriptor,\n+\t\t\t\tint *err);\n+\n+  /* Release the private data for an simple_object_write.  */\n+  void (*release_write) (void *);\n+};\n+\n+/* The known object file formats.  */\n+\n+extern const struct simple_object_functions simple_object_coff_functions;\n+extern const struct simple_object_functions simple_object_elf_functions;\n+extern const struct simple_object_functions simple_object_mach_o_functions;\n+\n+/* Read SIZE bytes from DESCRIPTOR at file offset OFFSET into BUFFER.\n+   Return non-zero on success.  On failure return 0 and set *ERRMSG\n+   and *ERR.  */\n+\n+extern int\n+simple_object_internal_read (int descriptor, off_t offset,\n+\t\t\t     unsigned char *buffer, size_t size,\n+\t\t\t     const char **errmsg, int *err);\n+\n+/* Write SIZE bytes from BUFFER to DESCRIPTOR at file offset OFFSET.\n+   Return non-zero on success.  On failure return 0 and set *ERRMSG\n+   and *ERR.  */\n+\n+extern int\n+simple_object_internal_write (int descriptor, off_t offset,\n+\t\t\t      const unsigned char *buffer, size_t size,\n+\t\t\t      const char **errmsg, int *err);\n+\n+/* Define ulong_type as an unsigned 64-bit type if available.\n+   Otherwise just make it unsigned long.  */\n+\n+#ifdef UNSIGNED_64BIT_TYPE\n+__extension__ typedef UNSIGNED_64BIT_TYPE ulong_type;\n+#else\n+typedef unsigned long ulong_type;\n+#endif\n+\n+/* Fetch a big-endian 16-bit value.  */\n+\n+static inline unsigned short\n+simple_object_fetch_big_16 (const unsigned char *buf)\n+{\n+  return ((unsigned short) buf[0] << 8) | (unsigned short) buf[1];\n+}\n+\n+/* Fetch a little-endian 16-bit value.  */\n+\n+static inline unsigned short\n+simple_object_fetch_little_16 (const unsigned char *buf)\n+{\n+  return ((unsigned short) buf[1] << 8) | (unsigned short) buf[0];\n+}\n+\n+/* Fetch a big-endian 32-bit value.  */\n+\n+static inline unsigned int\n+simple_object_fetch_big_32 (const unsigned char *buf)\n+{\n+  return (((unsigned int) buf[0] << 24)\n+\t  | ((unsigned int) buf[1] << 16)\n+\t  | ((unsigned int) buf[2] << 8)\n+\t  | (unsigned int) buf[3]);\n+}\n+\n+/* Fetch a little-endian 32-bit value.  */\n+\n+static inline unsigned int\n+simple_object_fetch_little_32 (const unsigned char *buf)\n+{\n+  return (((unsigned int) buf[3] << 24)\n+\t  | ((unsigned int) buf[2] << 16)\n+\t  | ((unsigned int) buf[1] << 8)\n+\t  | (unsigned int) buf[0]);\n+}\n+\n+/* Fetch a big-endian 32-bit value as a ulong_type.  */\n+\n+static inline ulong_type\n+simple_object_fetch_big_32_ulong (const unsigned char *buf)\n+{\n+  return (ulong_type) simple_object_fetch_big_32 (buf);\n+}\n+\n+/* Fetch a little-endian 32-bit value as a ulong_type.  */\n+\n+static inline ulong_type\n+simple_object_fetch_little_32_ulong (const unsigned char *buf)\n+{\n+  return (ulong_type) simple_object_fetch_little_32 (buf);\n+}\n+\n+#ifdef UNSIGNED_64BIT_TYPE\n+\n+/* Fetch a big-endian 64-bit value.  */\n+\n+static inline ulong_type\n+simple_object_fetch_big_64 (const unsigned char *buf)\n+{\n+  return (((ulong_type) buf[0] << 56)\n+\t  | ((ulong_type) buf[1] << 48)\n+\t  | ((ulong_type) buf[2] << 40)\n+\t  | ((ulong_type) buf[3] << 32)\n+\t  | ((ulong_type) buf[4] << 24)\n+\t  | ((ulong_type) buf[5] << 16)\n+\t  | ((ulong_type) buf[6] << 8)\n+\t  | (ulong_type) buf[7]);\n+}\n+\n+/* Fetch a little-endian 64-bit value.  */\n+\n+static inline ulong_type\n+simple_object_fetch_little_64 (const unsigned char *buf)\n+{\n+  return (((ulong_type) buf[7] << 56)\n+\t  | ((ulong_type) buf[6] << 48)\n+\t  | ((ulong_type) buf[5] << 40)\n+\t  | ((ulong_type) buf[4] << 32)\n+\t  | ((ulong_type) buf[3] << 24)\n+\t  | ((ulong_type) buf[2] << 16)\n+\t  | ((ulong_type) buf[1] << 8)\n+\t  | (ulong_type) buf[0]);\n+}\n+\n+#endif\n+\n+/* Store a big-endian 16-bit value.  */\n+\n+static inline void\n+simple_object_set_big_16 (unsigned char *buf, unsigned short val)\n+{\n+  buf[0] = (val >> 8) & 0xff;\n+  buf[1] = val & 0xff;\n+}\n+\n+/* Store a little-endian 16-bit value.  */\n+\n+static inline void\n+simple_object_set_little_16 (unsigned char *buf, unsigned short val)\n+{\n+  buf[1] = (val >> 8) & 0xff;\n+  buf[0] = val & 0xff;\n+}\n+\n+/* Store a big-endian 32-bit value.  */\n+\n+static inline void\n+simple_object_set_big_32 (unsigned char *buf, unsigned int val)\n+{\n+  buf[0] = (val >> 24) & 0xff;\n+  buf[1] = (val >> 16) & 0xff;\n+  buf[2] = (val >> 8) & 0xff;\n+  buf[3] = val & 0xff;\n+}\n+\n+/* Store a little-endian 32-bit value.  */\n+\n+static inline void\n+simple_object_set_little_32 (unsigned char *buf, unsigned int val)\n+{\n+  buf[3] = (val >> 24) & 0xff;\n+  buf[2] = (val >> 16) & 0xff;\n+  buf[1] = (val >> 8) & 0xff;\n+  buf[0] = val & 0xff;\n+}\n+\n+/* Store a big-endian 32-bit value coming in as a ulong_type.  */\n+\n+static inline void\n+simple_object_set_big_32_ulong (unsigned char *buf, ulong_type val)\n+{\n+  simple_object_set_big_32 (buf, val);\n+}\n+\n+/* Store a little-endian 32-bit value coming in as a ulong_type.  */\n+\n+static inline void\n+simple_object_set_little_32_ulong (unsigned char *buf, ulong_type val)\n+{\n+  simple_object_set_little_32 (buf, val);\n+}\n+\n+#ifdef UNSIGNED_64BIT_TYPE\n+\n+/* Store a big-endian 64-bit value.  */\n+\n+static inline void\n+simple_object_set_big_64 (unsigned char *buf, ulong_type val)\n+{\n+  buf[0] = (val >> 56) & 0xff;\n+  buf[1] = (val >> 48) & 0xff;\n+  buf[2] = (val >> 40) & 0xff;\n+  buf[3] = (val >> 32) & 0xff;\n+  buf[4] = (val >> 24) & 0xff;\n+  buf[5] = (val >> 16) & 0xff;\n+  buf[6] = (val >> 8) & 0xff;\n+  buf[7] = val & 0xff;\n+}\n+\n+/* Store a little-endian 64-bit value.  */\n+\n+static inline void\n+simple_object_set_little_64 (unsigned char *buf, ulong_type val)\n+{\n+  buf[7] = (val >> 56) & 0xff;\n+  buf[6] = (val >> 48) & 0xff;\n+  buf[5] = (val >> 40) & 0xff;\n+  buf[4] = (val >> 32) & 0xff;\n+  buf[3] = (val >> 24) & 0xff;\n+  buf[2] = (val >> 16) & 0xff;\n+  buf[1] = (val >> 8) & 0xff;\n+  buf[0] = val & 0xff;\n+}\n+\n+#endif"}, {"sha": "5b8cfba1cd64a40f2fb02c6ad3ac577a0567706c", "filename": "libiberty/simple-object-elf.c", "status": "added", "additions": 916, "deletions": 0, "changes": 916, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-elf.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,916 @@\n+/* simple-object-elf.c -- routines to manipulate ELF object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+#include \"simple-object.h\"\n+\n+#include <errno.h>\n+#include <stddef.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#ifdef HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#include \"simple-object-common.h\"\n+\n+/* ELF structures and constants.  */\n+\n+/* 32-bit ELF file header.  */\n+\n+typedef struct {\n+  unsigned char\te_ident[16];\t\t/* ELF \"magic number\" */\n+  unsigned char\te_type[2];\t\t/* Identifies object file type */\n+  unsigned char\te_machine[2];\t\t/* Specifies required architecture */\n+  unsigned char\te_version[4];\t\t/* Identifies object file version */\n+  unsigned char\te_entry[4];\t\t/* Entry point virtual address */\n+  unsigned char\te_phoff[4];\t\t/* Program header table file offset */\n+  unsigned char\te_shoff[4];\t\t/* Section header table file offset */\n+  unsigned char\te_flags[4];\t\t/* Processor-specific flags */\n+  unsigned char\te_ehsize[2];\t\t/* ELF header size in bytes */\n+  unsigned char\te_phentsize[2];\t\t/* Program header table entry size */\n+  unsigned char\te_phnum[2];\t\t/* Program header table entry count */\n+  unsigned char\te_shentsize[2];\t\t/* Section header table entry size */\n+  unsigned char\te_shnum[2];\t\t/* Section header table entry count */\n+  unsigned char\te_shstrndx[2];\t\t/* Section header string table index */\n+} Elf32_External_Ehdr;\n+\n+/* 64-bit ELF file header.  */\n+\n+typedef struct {\n+  unsigned char\te_ident[16];\t\t/* ELF \"magic number\" */\n+  unsigned char\te_type[2];\t\t/* Identifies object file type */\n+  unsigned char\te_machine[2];\t\t/* Specifies required architecture */\n+  unsigned char\te_version[4];\t\t/* Identifies object file version */\n+  unsigned char\te_entry[8];\t\t/* Entry point virtual address */\n+  unsigned char\te_phoff[8];\t\t/* Program header table file offset */\n+  unsigned char\te_shoff[8];\t\t/* Section header table file offset */\n+  unsigned char\te_flags[4];\t\t/* Processor-specific flags */\n+  unsigned char\te_ehsize[2];\t\t/* ELF header size in bytes */\n+  unsigned char\te_phentsize[2];\t\t/* Program header table entry size */\n+  unsigned char\te_phnum[2];\t\t/* Program header table entry count */\n+  unsigned char\te_shentsize[2];\t\t/* Section header table entry size */\n+  unsigned char\te_shnum[2];\t\t/* Section header table entry count */\n+  unsigned char\te_shstrndx[2];\t\t/* Section header string table index */\n+} Elf64_External_Ehdr;\n+\n+/* Indexes and values in e_ident field of Ehdr.  */\n+\n+#define EI_MAG0\t\t0\t/* File identification byte 0 index */\n+#define ELFMAG0\t\t   0x7F\t/* Magic number byte 0 */\n+\n+#define EI_MAG1\t\t1\t/* File identification byte 1 index */\n+#define ELFMAG1\t\t    'E'\t/* Magic number byte 1 */\n+\n+#define EI_MAG2\t\t2\t/* File identification byte 2 index */\n+#define ELFMAG2\t\t    'L'\t/* Magic number byte 2 */\n+\n+#define EI_MAG3\t\t3\t/* File identification byte 3 index */\n+#define ELFMAG3\t\t    'F'\t/* Magic number byte 3 */\n+\n+#define EI_CLASS\t4\t/* File class */\n+#define ELFCLASSNONE\t      0\t/* Invalid class */\n+#define ELFCLASS32\t      1\t/* 32-bit objects */\n+#define ELFCLASS64\t      2\t/* 64-bit objects */\n+\n+#define EI_DATA\t\t5\t/* Data encoding */\n+#define ELFDATANONE\t      0\t/* Invalid data encoding */\n+#define ELFDATA2LSB\t      1\t/* 2's complement, little endian */\n+#define ELFDATA2MSB\t      2\t/* 2's complement, big endian */\n+\n+#define EI_VERSION\t6\t/* File version */\n+#define EV_CURRENT\t1\t\t/* Current version */\n+\n+#define EI_OSABI\t7\t/* Operating System/ABI indication */\n+\n+/* Values for e_type field of Ehdr.  */\n+\n+#define ET_REL\t\t1\t/* Relocatable file */\n+\n+/* Special section index values.  */\n+\n+#define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n+#define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n+\n+/* 32-bit ELF program header.  */\n+\n+typedef struct {\n+  unsigned char\tp_type[4];\t\t/* Identifies program segment type */\n+  unsigned char\tp_offset[4];\t\t/* Segment file offset */\n+  unsigned char\tp_vaddr[4];\t\t/* Segment virtual address */\n+  unsigned char\tp_paddr[4];\t\t/* Segment physical address */\n+  unsigned char\tp_filesz[4];\t\t/* Segment size in file */\n+  unsigned char\tp_memsz[4];\t\t/* Segment size in memory */\n+  unsigned char\tp_flags[4];\t\t/* Segment flags */\n+  unsigned char\tp_align[4];\t\t/* Segment alignment, file & memory */\n+} Elf32_External_Phdr;\n+\n+/* 64-bit ELF program header.  */\n+\n+typedef struct {\n+  unsigned char\tp_type[4];\t\t/* Identifies program segment type */\n+  unsigned char\tp_flags[4];\t\t/* Segment flags */\n+  unsigned char\tp_offset[8];\t\t/* Segment file offset */\n+  unsigned char\tp_vaddr[8];\t\t/* Segment virtual address */\n+  unsigned char\tp_paddr[8];\t\t/* Segment physical address */\n+  unsigned char\tp_filesz[8];\t\t/* Segment size in file */\n+  unsigned char\tp_memsz[8];\t\t/* Segment size in memory */\n+  unsigned char\tp_align[8];\t\t/* Segment alignment, file & memory */\n+} Elf64_External_Phdr;\n+\n+/* 32-bit ELF section header */\n+\n+typedef struct {\n+  unsigned char\tsh_name[4];\t\t/* Section name, index in string tbl */\n+  unsigned char\tsh_type[4];\t\t/* Type of section */\n+  unsigned char\tsh_flags[4];\t\t/* Miscellaneous section attributes */\n+  unsigned char\tsh_addr[4];\t\t/* Section virtual addr at execution */\n+  unsigned char\tsh_offset[4];\t\t/* Section file offset */\n+  unsigned char\tsh_size[4];\t\t/* Size of section in bytes */\n+  unsigned char\tsh_link[4];\t\t/* Index of another section */\n+  unsigned char\tsh_info[4];\t\t/* Additional section information */\n+  unsigned char\tsh_addralign[4];\t/* Section alignment */\n+  unsigned char\tsh_entsize[4];\t\t/* Entry size if section holds table */\n+} Elf32_External_Shdr;\n+\n+/* 64-bit ELF section header.  */\n+\n+typedef struct {\n+  unsigned char\tsh_name[4];\t\t/* Section name, index in string tbl */\n+  unsigned char\tsh_type[4];\t\t/* Type of section */\n+  unsigned char\tsh_flags[8];\t\t/* Miscellaneous section attributes */\n+  unsigned char\tsh_addr[8];\t\t/* Section virtual addr at execution */\n+  unsigned char\tsh_offset[8];\t\t/* Section file offset */\n+  unsigned char\tsh_size[8];\t\t/* Size of section in bytes */\n+  unsigned char\tsh_link[4];\t\t/* Index of another section */\n+  unsigned char\tsh_info[4];\t\t/* Additional section information */\n+  unsigned char\tsh_addralign[8];\t/* Section alignment */\n+  unsigned char\tsh_entsize[8];\t\t/* Entry size if section holds table */\n+} Elf64_External_Shdr;\n+\n+/* Values for sh_type field.  */\n+\n+#define SHT_PROGBITS\t1\t\t/* Program data */\n+#define SHT_STRTAB\t3\t\t/* A string table */\n+\n+/* Functions to fetch and store different ELF types, depending on the\n+   endianness and size.  */\n+\n+struct elf_type_functions\n+{\n+  unsigned short (*fetch_Elf_Half) (const unsigned char *);\n+  unsigned int (*fetch_Elf_Word) (const unsigned char *);\n+  ulong_type (*fetch_Elf_Addr) (const unsigned char *);\n+  void (*set_Elf_Half) (unsigned char *, unsigned short);\n+  void (*set_Elf_Word) (unsigned char *, unsigned int);\n+  void (*set_Elf_Addr) (unsigned char *, ulong_type);\n+};\n+\n+static const struct elf_type_functions elf_big_32_functions =\n+{\n+  simple_object_fetch_big_16,\n+  simple_object_fetch_big_32,\n+  simple_object_fetch_big_32_ulong,\n+  simple_object_set_big_16,\n+  simple_object_set_big_32,\n+  simple_object_set_big_32_ulong\n+};\n+\n+static const struct elf_type_functions elf_little_32_functions =\n+{\n+  simple_object_fetch_little_16,\n+  simple_object_fetch_little_32,\n+  simple_object_fetch_little_32_ulong,\n+  simple_object_set_little_16,\n+  simple_object_set_little_32,\n+  simple_object_set_little_32_ulong\n+};\n+\n+#ifdef UNSIGNED_64BIT_TYPE\n+\n+static const struct elf_type_functions elf_big_64_functions =\n+{\n+  simple_object_fetch_big_16,\n+  simple_object_fetch_big_32,\n+  simple_object_fetch_big_64,\n+  simple_object_set_big_16,\n+  simple_object_set_big_32,\n+  simple_object_set_big_64\n+};\n+\n+static const struct elf_type_functions elf_little_64_functions =\n+{\n+  simple_object_fetch_little_16,\n+  simple_object_fetch_little_32,\n+  simple_object_fetch_little_64,\n+  simple_object_set_little_16,\n+  simple_object_set_little_32,\n+  simple_object_set_little_64\n+};\n+\n+#endif\n+\n+/* Hideous macro to fetch the value of a field from an external ELF\n+   struct of some sort.  TYPEFUNCS is the set of type functions.\n+   BUFFER points to the external data.  STRUCTTYPE is the appropriate\n+   struct type.  FIELD is a field within the struct.  TYPE is the type\n+   of the field in the struct: Elf_Half, Elf_Word, or Elf_Addr.  */\n+\n+#define ELF_FETCH_STRUCT_FIELD(TYPEFUNCS, STRUCTTYPE, FIELD, BUFFER, TYPE) \\\n+  ((TYPEFUNCS)->fetch_ ## TYPE ((BUFFER) + offsetof (STRUCTTYPE, FIELD)))\n+\n+/* Even more hideous macro to fetch the value of FIELD from BUFFER.\n+   SIZE is 32 or 64.  STRUCTTYPE is the name of the struct from\n+   elf/external.h: Ehdr, Shdr, etc.  FIELD is the name of a field in\n+   the struct.  TYPE is the type of the field in the struct: Elf_Half,\n+   Elf_Word, or Elf_Addr.  */\n+\n+#define ELF_FETCH_SIZED_FIELD(TYPEFUNCS, SIZE, STRUCTTYPE, BUFFER,\t\\\n+\t\t\t      FIELD, TYPE)\t\t\t\t\\\n+  ELF_FETCH_STRUCT_FIELD (TYPEFUNCS,\t\t\t\t\t\\\n+\t\t\t  Elf ## SIZE ## _External_ ## STRUCTTYPE,\t\\\n+\t\t\t  FIELD, BUFFER, TYPE)\n+\n+/* Like ELF_FETCH_SIZED_FIELD but taking an ELFCLASS value.  */\n+\n+#define ELF_FETCH_FIELD(TYPEFUNCS, CLASS, STRUCTTYPE, BUFFER,\t\t\\\n+\t\t\tFIELD, TYPE)\t\t\t\t\t\\\n+  ((CLASS) == ELFCLASS32\t\t\t\t\t\t\\\n+    ? ELF_FETCH_SIZED_FIELD (TYPEFUNCS, 32, STRUCTTYPE, BUFFER, FIELD,\t\\\n+\t\t\t     TYPE)\t\t\t\t\t\\\n+    : ELF_FETCH_SIZED_FIELD (TYPEFUNCS, 64, STRUCTTYPE, BUFFER, FIELD,\t\\\n+\t\t\t     TYPE))\n+\n+/* Hideous macro to set the value of a field in an external ELF\n+   structure to VAL.  TYPEFUNCS is the set of type functions.  BUFFER\n+   points to the external data.  STRUCTTYPE is the appropriate\n+   structure type.  FIELD is a field within the struct.  TYPE is the\n+   type of the field in the struct: Elf_Half, Elf_Word, or\n+   Elf_Addr.  */\n+\n+#define ELF_SET_STRUCT_FIELD(TYPEFUNCS, STRUCTTYPE, FIELD, BUFFER, TYPE, VAL) \\\n+  (TYPEFUNCS)->set_ ## TYPE ((BUFFER) + offsetof (STRUCTTYPE, FIELD), (VAL))\n+\n+/* Even more hideous macro to set the value of FIELD in BUFFER to VAL.\n+   SIZE is 32 or 64.  STRUCTTYPE is the name of the struct from\n+   elf/external.h: Ehdr, Shdr, etc.  FIELD is the name of a field in\n+   the struct.  TYPE is the type of the field in the struct: Elf_Half,\n+   Elf_Word, or Elf_Addr.  */\n+\n+#define ELF_SET_SIZED_FIELD(TYPEFUNCS, SIZE, STRUCTTYPE, BUFFER, FIELD, \\\n+\t\t\t    TYPE, VAL)\t\t\t\t\t\\\n+  ELF_SET_STRUCT_FIELD (TYPEFUNCS,\t\t\t\t\t\\\n+\t\t\tElf ## SIZE ## _External_ ## STRUCTTYPE,\t\\\n+\t\t\tFIELD, BUFFER, TYPE, VAL)\n+\n+/* Like ELF_SET_SIZED_FIELD but taking an ELFCLASS value.  */\n+\n+#define ELF_SET_FIELD(TYPEFUNCS, CLASS, STRUCTTYPE, BUFFER, FIELD,\t\\\n+\t\t      TYPE, VAL)\t\t\t\t\t\\\n+  ((CLASS) == ELFCLASS32\t\t\t\t\t\t\\\n+    ? ELF_SET_SIZED_FIELD (TYPEFUNCS, 32, STRUCTTYPE, BUFFER, FIELD,\t\\\n+\t\t\t   TYPE, VAL)\t\t\t\t\t\\\n+    : ELF_SET_SIZED_FIELD (TYPEFUNCS, 64, STRUCTTYPE, BUFFER, FIELD,\t\\\n+\t\t\t   TYPE, VAL))\n+\n+/* Private data for an simple_object_read.  */\n+\n+struct simple_object_elf_read\n+{\n+  /* Type functions.  */\n+  const struct elf_type_functions* type_functions;\n+  /* Elf data.  */\n+  unsigned char ei_data;\n+  /* Elf class.  */\n+  unsigned char ei_class;\n+  /* ELF OS ABI.  */\n+  unsigned char ei_osabi;\n+  /* Elf machine number.  */\n+  unsigned short machine;\n+  /* Processor specific flags.  */\n+  unsigned int flags;\n+  /* File offset of section headers.  */\n+  ulong_type shoff;\n+  /* Number of sections.  */\n+  unsigned int shnum;\n+  /* Index of string table section header.  */\n+  unsigned int shstrndx;\n+};\n+\n+/* Private data for an simple_object_attributes.  */\n+\n+struct simple_object_elf_attributes\n+{\n+  /* Type functions.  */\n+  const struct elf_type_functions* type_functions;\n+  /* Elf data.  */\n+  unsigned char ei_data;\n+  /* Elf class.  */\n+  unsigned char ei_class;\n+  /* ELF OS ABI.  */\n+  unsigned char ei_osabi;\n+  /* Elf machine number.  */\n+  unsigned short machine;\n+  /* Processor specific flags.  */\n+  unsigned int flags;\n+};\n+\n+/* See if we have an ELF file.  */\n+\n+static void *\n+simple_object_elf_match (unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],\n+\t\t\t int descriptor, off_t offset,\n+\t\t\t const char *segment_name ATTRIBUTE_UNUSED,\n+\t\t\t const char **errmsg, int *err)\n+{\n+  unsigned char ei_data;\n+  unsigned char ei_class;\n+  const struct elf_type_functions *type_functions;\n+  unsigned char ehdr[sizeof (Elf64_External_Ehdr)];\n+  struct simple_object_elf_read *eor;\n+\n+  if (header[EI_MAG0] != ELFMAG0\n+      || header[EI_MAG1] != ELFMAG1\n+      || header[EI_MAG2] != ELFMAG2\n+      || header[EI_MAG3] != ELFMAG3\n+      || header[EI_VERSION] != EV_CURRENT)\n+    {\n+      *errmsg = NULL;\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  ei_data = header[EI_DATA];\n+  if (ei_data != ELFDATA2LSB && ei_data != ELFDATA2MSB)\n+    {\n+      *errmsg = \"unknown ELF endianness\";\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  ei_class = header[EI_CLASS];\n+  switch (ei_class)\n+    {\n+    case ELFCLASS32:\n+      type_functions = (ei_data == ELFDATA2LSB\n+\t\t\t? &elf_little_32_functions\n+\t\t\t: &elf_big_32_functions);\n+      break;\n+\n+    case ELFCLASS64:\n+#ifndef UNSIGNED_64BIT_TYPE\n+      *errmsg = \"64-bit ELF objects not supported\";\n+      *err = 0;\n+      return NULL;\n+#else\n+      type_functions = (ei_data == ELFDATA2LSB\n+\t\t\t? &elf_little_64_functions\n+\t\t\t: &elf_big_64_functions);\n+      break;\n+#endif\n+\n+    default:\n+      *errmsg = \"unrecognized ELF size\";\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  if (!simple_object_internal_read (descriptor, offset, ehdr, sizeof ehdr,\n+\t\t\t\t    errmsg, err))\n+    return NULL;\n+\n+  eor = XNEW (struct simple_object_elf_read);\n+  eor->type_functions = type_functions;\n+  eor->ei_data = ei_data;\n+  eor->ei_class = ei_class;\n+  eor->ei_osabi = header[EI_OSABI];\n+  eor->machine = ELF_FETCH_FIELD (type_functions, ei_class, Ehdr, ehdr,\n+\t\t\t\t  e_machine, Elf_Half);\n+  eor->flags = ELF_FETCH_FIELD (type_functions, ei_class, Ehdr, ehdr,\n+\t\t\t\te_flags, Elf_Word);\n+  eor->shoff = ELF_FETCH_FIELD (type_functions, ei_class, Ehdr, ehdr,\n+\t\t\t\te_shoff, Elf_Addr);\n+  eor->shnum = ELF_FETCH_FIELD (type_functions, ei_class, Ehdr, ehdr,\n+\t\t\t\te_shnum, Elf_Half);\n+  eor->shstrndx = ELF_FETCH_FIELD (type_functions, ei_class, Ehdr, ehdr,\n+\t\t\t\t   e_shstrndx, Elf_Half);\n+\n+  if ((eor->shnum == 0 || eor->shstrndx == SHN_XINDEX)\n+      && eor->shoff != 0)\n+    {\n+      unsigned char shdr[sizeof (Elf64_External_Shdr)];\n+\n+      /* Object file has more than 0xffff sections.  */\n+\n+      if (!simple_object_internal_read (descriptor, offset + eor->shoff, shdr,\n+\t\t\t\t\t(ei_class == ELFCLASS32\n+\t\t\t\t\t ? sizeof (Elf32_External_Shdr)\n+\t\t\t\t\t : sizeof (Elf64_External_Shdr)),\n+\t\t\t\t\terrmsg, err))\n+\t{\n+\t  XDELETE (eor);\n+\t  return NULL;\n+\t}\n+\n+      if (eor->shnum == 0)\n+\teor->shnum = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t      shdr, sh_size, Elf_Addr);\n+\n+      if (eor->shstrndx == SHN_XINDEX)\n+\t{\n+\t  eor->shstrndx = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t   shdr, sh_link, Elf_Word);\n+\n+\t  /* Versions of the GNU binutils between 2.12 and 2.18 did\n+\t     not handle objects with more than SHN_LORESERVE sections\n+\t     correctly.  All large section indexes were offset by\n+\t     0x100.  There is more information at\n+\t     http://sourceware.org/bugzilla/show_bug.cgi?id-5900 .\n+\t     Fortunately these object files are easy to detect, as the\n+\t     GNU binutils always put the section header string table\n+\t     near the end of the list of sections.  Thus if the\n+\t     section header string table index is larger than the\n+\t     number of sections, then we know we have to subtract\n+\t     0x100 to get the real section index.  */\n+\t  if (eor->shstrndx >= eor->shnum\n+\t      && eor->shstrndx >= SHN_LORESERVE + 0x100)\n+\t    eor->shstrndx -= 0x100;\n+\t}\n+    }\n+\n+  if (eor->shstrndx >= eor->shnum)\n+    {\n+      *errmsg = \"invalid ELF shstrndx >= shnum\";\n+      *err = 0;\n+      XDELETE (eor);\n+      return NULL;\n+    }\n+\n+  return (void *) eor;\n+}\n+\n+/* Find all sections in an ELF file.  */\n+\n+static const char *\n+simple_object_elf_find_sections (simple_object_read *sobj,\n+\t\t\t\t int (*pfn) (void *, const char *,\n+\t\t\t\t\t     off_t offset, off_t length),\n+\t\t\t\t void *data,\n+\t\t\t\t int *err)\n+{\n+  struct simple_object_elf_read *eor =\n+    (struct simple_object_elf_read *) sobj->data;\n+  const struct elf_type_functions *type_functions = eor->type_functions;\n+  unsigned char ei_class = eor->ei_class;\n+  size_t shdr_size;\n+  unsigned int shnum;\n+  unsigned char *shdrs;\n+  const char *errmsg;\n+  unsigned char *shstrhdr;\n+  size_t name_size;\n+  off_t shstroff;\n+  unsigned char *names;\n+  unsigned int i;\n+\n+  shdr_size = (ei_class == ELFCLASS32\n+\t       ? sizeof (Elf32_External_Shdr)\n+\t       : sizeof (Elf64_External_Shdr));\n+\n+  /* Read the section headers.  We skip section 0, which is not a\n+     useful section.  */\n+\n+  shnum = eor->shnum;\n+  shdrs = XNEWVEC (unsigned char, shdr_size * (shnum - 1));\n+\n+  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t    sobj->offset + eor->shoff + shdr_size,\n+\t\t\t\t    shdrs,\n+\t\t\t\t    shdr_size * (shnum - 1),\n+\t\t\t\t    &errmsg, err))\n+    {\n+      XDELETEVEC (shdrs);\n+      return errmsg;\n+    }\n+\n+  /* Read the section names.  */\n+\n+  shstrhdr = shdrs + (eor->shstrndx - 1) * shdr_size;\n+  name_size = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t       shstrhdr, sh_size, Elf_Addr);\n+  shstroff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t      shstrhdr, sh_offset, Elf_Addr);\n+  names = XNEWVEC (unsigned char, name_size);\n+  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t    sobj->offset + shstroff,\n+\t\t\t\t    names, name_size, &errmsg, err))\n+    {\n+      XDELETEVEC (names);\n+      XDELETEVEC (shdrs);\n+      return errmsg;\n+    }\n+\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      unsigned char *shdr;\n+      unsigned int sh_name;\n+      const char *name;\n+      off_t offset;\n+      off_t length;\n+\n+      shdr = shdrs + (i - 1) * shdr_size;\n+      sh_name = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_name, Elf_Word);\n+      if (sh_name >= name_size)\n+\t{\n+\t  *err = 0;\n+\t  XDELETEVEC (names);\n+\t  XDELETEVEC (shdrs);\n+\t  return \"ELF section name out of range\";\n+\t}\n+\n+      name = (const char *) names + sh_name;\n+      offset = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\tshdr, sh_offset, Elf_Addr);\n+      length = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\tshdr, sh_size, Elf_Addr);\n+\n+      if (!(*pfn) (data, name, offset, length))\n+\tbreak;\n+    }\n+\n+  XDELETEVEC (names);\n+  XDELETEVEC (shdrs);\n+\n+  return NULL;\n+}\n+\n+/* Fetch the attributes for an simple_object_read.  */\n+\n+static void *\n+simple_object_elf_fetch_attributes (simple_object_read *sobj,\n+\t\t\t\t    const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\t    int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_elf_read *eor =\n+    (struct simple_object_elf_read *) sobj->data;\n+  struct simple_object_elf_attributes *ret;\n+\n+  ret = XNEW (struct simple_object_elf_attributes);\n+  ret->type_functions = eor->type_functions;\n+  ret->ei_data = eor->ei_data;\n+  ret->ei_class = eor->ei_class;\n+  ret->ei_osabi = eor->ei_osabi;\n+  ret->machine = eor->machine;\n+  ret->flags = eor->flags;\n+  return ret;\n+}\n+\n+/* Release the privata data for an simple_object_read.  */\n+\n+static void\n+simple_object_elf_release_read (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Compare two attributes structures.  */\n+\n+static const char *\n+simple_object_elf_attributes_compare (void *data1, void *data2, int *err)\n+{\n+  struct simple_object_elf_attributes *attrs1 =\n+    (struct simple_object_elf_attributes *) data1;\n+  struct simple_object_elf_attributes *attrs2 =\n+    (struct simple_object_elf_attributes *) data2;\n+\n+  if (attrs1->ei_data != attrs2->ei_data\n+      || attrs1->ei_class != attrs2->ei_class\n+      || attrs1->machine != attrs2->machine)\n+    {\n+      *err = 0;\n+      return \"ELF object format mismatch\";\n+    }\n+  return NULL;\n+}\n+\n+/* Release the private data for an attributes structure.  */\n+\n+static void\n+simple_object_elf_release_attributes (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Prepare to write out a file.  */\n+\n+static void *\n+simple_object_elf_start_write (void *attributes_data,\n+\t\t\t       const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t       int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_elf_attributes *attrs =\n+    (struct simple_object_elf_attributes *) attributes_data;\n+  struct simple_object_elf_attributes *ret;\n+\n+  /* We're just going to record the attributes, but we need to make a\n+     copy because the user may delete them.  */\n+  ret = XNEW (struct simple_object_elf_attributes);\n+  *ret = *attrs;\n+  return ret;\n+}\n+\n+/* Write out an ELF ehdr.  */\n+\n+static int\n+simple_object_elf_write_ehdr (simple_object_write *sobj, int descriptor,\n+\t\t\t      const char **errmsg, int *err)\n+{\n+  struct simple_object_elf_attributes *attrs =\n+    (struct simple_object_elf_attributes *) sobj->data;\n+  const struct elf_type_functions* fns;\n+  unsigned char cl;\n+  size_t ehdr_size;\n+  unsigned char buf[sizeof (Elf64_External_Ehdr)];\n+  simple_object_write_section *section;\n+  unsigned int shnum;\n+\n+  fns = attrs->type_functions;\n+  cl = attrs->ei_class;\n+\n+  shnum = 0;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    ++shnum;\n+  if (shnum > 0)\n+    {\n+      /* Add a section header for the dummy section and one for\n+\t .shstrtab.  */\n+      shnum += 2;\n+    }\n+\n+  ehdr_size = (cl == ELFCLASS32\n+\t       ? sizeof (Elf32_External_Ehdr)\n+\t       : sizeof (Elf64_External_Ehdr));\n+  memset (buf, 0, sizeof (Elf64_External_Ehdr));\n+\n+  buf[EI_MAG0] = ELFMAG0;\n+  buf[EI_MAG1] = ELFMAG1;\n+  buf[EI_MAG2] = ELFMAG2;\n+  buf[EI_MAG3] = ELFMAG3;\n+  buf[EI_CLASS] = cl;\n+  buf[EI_DATA] = attrs->ei_data;\n+  buf[EI_VERSION] = EV_CURRENT;\n+  buf[EI_OSABI] = attrs->ei_osabi;\n+\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_type, Elf_Half, ET_REL);\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_machine, Elf_Half, attrs->machine);\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_version, Elf_Word, EV_CURRENT);\n+  /* e_entry left as zero.  */\n+  /* e_phoff left as zero.  */\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_shoff, Elf_Addr, ehdr_size);\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_flags, Elf_Word, attrs->flags);\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_ehsize, Elf_Half, ehdr_size);\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_phentsize, Elf_Half,\n+\t\t (cl == ELFCLASS32\n+\t\t  ? sizeof (Elf32_External_Phdr)\n+\t\t  : sizeof (Elf64_External_Phdr)));\n+  /* e_phnum left as zero.  */\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_shentsize, Elf_Half,\n+\t\t (cl == ELFCLASS32\n+\t\t  ? sizeof (Elf32_External_Shdr)\n+\t\t  : sizeof (Elf64_External_Shdr)));\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_shnum, Elf_Half, shnum);\n+  ELF_SET_FIELD (fns, cl, Ehdr, buf, e_shstrndx, Elf_Half,\n+\t\t shnum == 0 ? 0 : shnum - 1);\n+\n+  return simple_object_internal_write (descriptor, 0, buf, ehdr_size,\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out an ELF shdr.  */\n+\n+static int\n+simple_object_elf_write_shdr (simple_object_write *sobj, int descriptor,\n+\t\t\t      off_t offset, unsigned int sh_name,\n+\t\t\t      unsigned int sh_type, unsigned int sh_flags,\n+\t\t\t      unsigned int sh_offset, unsigned int sh_size,\n+\t\t\t      unsigned int sh_addralign, const char **errmsg,\n+\t\t\t      int *err)\n+{\n+  struct simple_object_elf_attributes *attrs =\n+    (struct simple_object_elf_attributes *) sobj->data;\n+  const struct elf_type_functions* fns;\n+  unsigned char cl;\n+  size_t shdr_size;\n+  unsigned char buf[sizeof (Elf64_External_Shdr)];\n+\n+  fns = attrs->type_functions;\n+  cl = attrs->ei_class;\n+\n+  shdr_size = (cl == ELFCLASS32\n+\t       ? sizeof (Elf32_External_Shdr)\n+\t       : sizeof (Elf64_External_Shdr));\n+  memset (buf, 0, sizeof (Elf64_External_Shdr));\n+\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_name, Elf_Word, sh_name);\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_type, Elf_Word, sh_type);\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_flags, Elf_Addr, sh_flags);\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_offset, Elf_Addr, sh_offset);\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_size, Elf_Addr, sh_size);\n+  /* sh_link left as zero.  */\n+  /* sh_info left as zero.  */\n+  ELF_SET_FIELD (fns, cl, Shdr, buf, sh_addralign, Elf_Addr, sh_addralign);\n+  /* sh_entsize left as zero.  */\n+\n+  return simple_object_internal_write (descriptor, offset, buf, shdr_size,\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out a complete ELF file.\n+   Ehdr\n+   initial dummy Shdr\n+   user-created Shdrs\n+   .shstrtab Shdr\n+   user-created section data\n+   .shstrtab data  */\n+\n+static const char *\n+simple_object_elf_write_to_file (simple_object_write *sobj, int descriptor,\n+\t\t\t\t int *err)\n+{\n+  struct simple_object_elf_attributes *attrs =\n+    (struct simple_object_elf_attributes *) sobj->data;\n+  unsigned char cl;\n+  size_t ehdr_size;\n+  size_t shdr_size;\n+  const char *errmsg;\n+  simple_object_write_section *section;\n+  unsigned int shnum;\n+  size_t shdr_offset;\n+  size_t sh_offset;\n+  size_t sh_name;\n+  unsigned char zero;\n+\n+  if (!simple_object_elf_write_ehdr (sobj, descriptor, &errmsg, err))\n+    return errmsg;\n+\n+  cl = attrs->ei_class;\n+  if (cl == ELFCLASS32)\n+    {\n+      ehdr_size = sizeof (Elf32_External_Ehdr);\n+      shdr_size = sizeof (Elf32_External_Shdr);\n+    }\n+  else\n+    {\n+      ehdr_size = sizeof (Elf64_External_Ehdr);\n+      shdr_size = sizeof (Elf64_External_Shdr);\n+    }\n+\n+  shnum = 0;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    ++shnum;\n+  if (shnum == 0)\n+    return NULL;\n+\n+  /* Add initial dummy Shdr and .shstrtab.  */\n+  shnum += 2;\n+\n+  shdr_offset = ehdr_size;\n+  sh_offset = shdr_offset + shnum * shdr_size;\n+\n+  if (!simple_object_elf_write_shdr (sobj, descriptor, shdr_offset,\n+\t\t\t\t     0, 0, 0, 0, 0, 0, &errmsg, err))\n+    return errmsg;\n+\n+  shdr_offset += shdr_size;\n+\n+  sh_name = 1;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t mask;\n+      size_t new_sh_offset;\n+      size_t sh_size;\n+      struct simple_object_write_section_buffer *buffer;\n+\n+      mask = (1U << section->align) - 1;\n+      new_sh_offset = sh_offset + mask;\n+      new_sh_offset &= ~ mask;\n+      while (new_sh_offset > sh_offset)\n+\t{\n+\t  unsigned char zeroes[16];\n+\t  size_t write;\n+\n+\t  memset (zeroes, 0, sizeof zeroes);\n+\t  write = new_sh_offset - sh_offset;\n+\t  if (write > sizeof zeroes)\n+\t    write = sizeof zeroes;\n+\t  if (!simple_object_internal_write (descriptor, sh_offset, zeroes,\n+\t\t\t\t\t     write, &errmsg, err))\n+\t    return errmsg;\n+\t  sh_offset += write;\n+\t}\n+\n+      sh_size = 0;\n+      for (buffer = section->buffers; buffer != NULL; buffer = buffer->next)\n+\t{\n+\t  if (!simple_object_internal_write (descriptor, sh_offset + sh_size,\n+\t\t\t\t\t     ((const unsigned char *)\n+\t\t\t\t\t      buffer->buffer),\n+\t\t\t\t\t     buffer->size, &errmsg, err))\n+\t    return errmsg;\n+\t  sh_size += buffer->size;\n+\t}\n+\n+      if (!simple_object_elf_write_shdr (sobj, descriptor, shdr_offset,\n+\t\t\t\t\t sh_name, SHT_PROGBITS, 0, sh_offset,\n+\t\t\t\t\t sh_size, 1U << section->align,\n+\t\t\t\t\t &errmsg, err))\n+\treturn errmsg;\n+\n+      shdr_offset += shdr_size;\n+      sh_name += strlen (section->name) + 1;\n+      sh_offset += sh_size;\n+    }\n+\n+  if (!simple_object_elf_write_shdr (sobj, descriptor, shdr_offset,\n+\t\t\t\t     sh_name, SHT_STRTAB, 0, sh_offset,\n+\t\t\t\t     sh_name + strlen (\".shstrtab\") + 1,\n+\t\t\t\t     1, &errmsg, err))\n+    return errmsg;\n+\n+  /* .shstrtab has a leading zero byte.  */\n+  zero = 0;\n+  if (!simple_object_internal_write (descriptor, sh_offset, &zero, 1,\n+\t\t\t\t     &errmsg, err))\n+    return errmsg;\n+  ++sh_offset;\n+\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t len;\n+\n+      len = strlen (section->name) + 1;\n+      if (!simple_object_internal_write (descriptor, sh_offset,\n+\t\t\t\t\t (const unsigned char *) section->name,\n+\t\t\t\t\t len, &errmsg, err))\n+\treturn errmsg;\n+      sh_offset += len;\n+    }\n+\n+  if (!simple_object_internal_write (descriptor, sh_offset,\n+\t\t\t\t     (const unsigned char *) \".shstrtab\",\n+\t\t\t\t     strlen (\".shstrtab\") + 1, &errmsg, err))\n+    return errmsg;\n+\n+  return NULL;\n+}\n+\n+/* Release the private data for an simple_object_write structure.  */\n+\n+static void\n+simple_object_elf_release_write (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* The ELF functions.  */\n+\n+const struct simple_object_functions simple_object_elf_functions =\n+{\n+  simple_object_elf_match,\n+  simple_object_elf_find_sections,\n+  simple_object_elf_fetch_attributes,\n+  simple_object_elf_release_read,\n+  simple_object_elf_attributes_compare,\n+  simple_object_elf_release_attributes,\n+  simple_object_elf_start_write,\n+  simple_object_elf_write_to_file,\n+  simple_object_elf_release_write\n+};"}, {"sha": "4067b16bab5cfa3ae830d91226c96f8a297d97b6", "filename": "libiberty/simple-object-mach-o.c", "status": "added", "additions": 1022, "deletions": 0, "changes": 1022, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-mach-o.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object-mach-o.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-mach-o.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,1022 @@\n+/* simple-object-mach-o.c -- routines to manipulate Mach-O object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+#include \"simple-object.h\"\n+\n+#include <stddef.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#ifdef HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#include \"simple-object-common.h\"\n+\n+/* Mach-O structures and constants.  */\n+\n+/* Mach-O header (32-bit version).  */\n+\n+struct mach_o_header_32\n+{\n+  unsigned char magic[4];\t/* Magic number.  */\n+  unsigned char cputype[4];\t/* CPU that this object is for.  */\n+  unsigned char cpusubtype[4];\t/* CPU subtype.  */\n+  unsigned char filetype[4];\t/* Type of file.  */\n+  unsigned char ncmds[4];\t/* Number of load commands.  */\n+  unsigned char sizeofcmds[4];\t/* Total size of load commands.  */\n+  unsigned char flags[4];\t/* Flags for special featues.  */\n+};\n+\n+/* Mach-O header (64-bit version).  */\n+\n+struct mach_o_header_64\n+{\n+  unsigned char magic[4];\t/* Magic number.  */\n+  unsigned char cputype[4];\t/* CPU that this object is for.  */\n+  unsigned char cpusubtype[4];\t/* CPU subtype.  */\n+  unsigned char filetype[4];\t/* Type of file.  */\n+  unsigned char ncmds[4];\t/* Number of load commands.  */\n+  unsigned char sizeofcmds[4];\t/* Total size of load commands.  */\n+  unsigned char flags[4];\t/* Flags for special featues.  */\n+  unsigned char reserved[4];\t/* Reserved.  Duh.  */\n+};\n+\n+/* For magic field in header.  */\n+\n+#define MACH_O_MH_MAGIC\t\t\t0xfeedface\n+#define MACH_O_MH_MAGIC_64\t\t0xfeedfacf\n+\n+/* For filetype field in header.  */\n+\n+#define MACH_O_MH_OBJECT\t\t0x01\n+\n+/* A Mach-O file is a list of load commands.  This is the header of a\n+   load command.  */\n+\n+struct mach_o_load_command\n+{\n+  unsigned char cmd[4];\t\t/* The type of load command.  */\n+  unsigned char cmdsize[4];\t/* Size in bytes of entire command.  */\n+};\n+\n+/* For cmd field in load command.   */\n+\n+#define MACH_O_LC_SEGMENT\t\t0x01\n+#define MACH_O_LC_SEGMENT_64\t\t0x19\n+\n+/* LC_SEGMENT load command.  */\n+\n+struct mach_o_segment_command_32\n+{\n+  unsigned char cmd[4];\t\t/* The type of load command (LC_SEGMENT).  */\n+  unsigned char cmdsize[4];\t/* Size in bytes of entire command.  */\n+  unsigned char segname[16];\t/* Name of this segment.  */\n+  unsigned char vmaddr[4];\t/* Virtual memory address of this segment.  */\n+  unsigned char vmsize[4];\t/* Size there, in bytes.  */\n+  unsigned char fileoff[4];\t/* Offset in bytes of the data to be mapped.  */\n+  unsigned char filesize[4];\t/* Size in bytes on disk.  */\n+  unsigned char maxprot[4];\t/* Maximum permitted vmem protection.  */\n+  unsigned char initprot[4];\t/* Initial vmem protection.  */\n+  unsigned char nsects[4];\t/* Number of sections in this segment.  */\n+  unsigned char flags[4];\t/* Flags that affect the loading.  */\n+};\n+\n+/* LC_SEGMENT_64 load command.  */\n+\n+struct mach_o_segment_command_64\n+{\n+  unsigned char cmd[4];\t\t/* The type of load command (LC_SEGMENT_64).  */\n+  unsigned char cmdsize[4];\t/* Size in bytes of entire command.  */\n+  unsigned char segname[16];\t/* Name of this segment.  */\n+  unsigned char vmaddr[8];\t/* Virtual memory address of this segment.  */\n+  unsigned char vmsize[8];\t/* Size there, in bytes.  */\n+  unsigned char fileoff[8];\t/* Offset in bytes of the data to be mapped.  */\n+  unsigned char filesize[8];\t/* Size in bytes on disk.  */\n+  unsigned char maxprot[4];\t/* Maximum permitted vmem protection.  */\n+  unsigned char initprot[4];\t/* Initial vmem protection.  */\n+  unsigned char nsects[4];\t/* Number of sections in this segment.  */\n+  unsigned char flags[4];\t/* Flags that affect the loading.  */\n+};\n+\n+/* 32-bit section header.  */\n+\n+struct mach_o_section_32\n+{\n+  unsigned char sectname[16];\t/* Section name.  */\n+  unsigned char segname[16];\t/* Segment that the section belongs to.  */\n+  unsigned char addr[4];\t/* Address of this section in memory.  */\n+  unsigned char size[4];\t/* Size in bytes of this section.  */\n+  unsigned char offset[4];\t/* File offset of this section.  */\n+  unsigned char align[4];\t/* log2 of this section's alignment.  */\n+  unsigned char reloff[4];\t/* File offset of this section's relocs.  */\n+  unsigned char nreloc[4];\t/* Number of relocs for this section.  */\n+  unsigned char flags[4];\t/* Section flags/attributes.  */\n+  unsigned char reserved1[4];\n+  unsigned char reserved2[4];\n+};\n+\n+/* 64-bit section header.  */\n+\n+struct mach_o_section_64\n+{\n+  unsigned char sectname[16];\t/* Section name.  */\n+  unsigned char segname[16];\t/* Segment that the section belongs to.  */\n+  unsigned char addr[8];\t/* Address of this section in memory.  */\n+  unsigned char size[8];\t/* Size in bytes of this section.  */\n+  unsigned char offset[4];\t/* File offset of this section.  */\n+  unsigned char align[4];\t/* log2 of this section's alignment.  */\n+  unsigned char reloff[4];\t/* File offset of this section's relocs.  */\n+  unsigned char nreloc[4];\t/* Number of relocs for this section.  */\n+  unsigned char flags[4];\t/* Section flags/attributes.  */\n+  unsigned char reserved1[4];\n+  unsigned char reserved2[4];\n+  unsigned char reserved3[4];\n+};\n+\n+/* Flags for Mach-O sections.  */\n+\n+#define MACH_O_S_ATTR_DEBUG\t\t\t0x02000000\n+\n+/* The length of a segment or section name.  */\n+\n+#define MACH_O_NAME_LEN (16)\n+\n+/* A GNU specific extension for long section names.  */\n+\n+#define GNU_SECTION_NAMES \"__section_names\"\n+\n+/* Private data for an simple_object_read.  */\n+\n+struct simple_object_mach_o_read\n+{\n+  /* User specified segment name.  */\n+  char *segment_name;\n+  /* Magic number.  */\n+  unsigned int magic;\n+  /* Whether this file is big-endian.  */\n+  int is_big_endian;\n+  /* CPU type from header.  */\n+  unsigned int cputype;\n+  /* CPU subtype from header.  */\n+  unsigned int cpusubtype;\n+  /* Number of commands, from header.  */\n+  unsigned int ncmds;\n+  /* Flags from header.  */\n+  unsigned int flags;\n+  /* Reserved field from header, only used on 64-bit.  */\n+  unsigned int reserved;\n+};\n+\n+/* Private data for an simple_object_attributes.  */\n+\n+struct simple_object_mach_o_attributes\n+{\n+  /* Magic number.  */\n+  unsigned int magic;\n+  /* Whether this file is big-endian.  */\n+  int is_big_endian;\n+  /* CPU type from header.  */\n+  unsigned int cputype;\n+  /* CPU subtype from header.  */\n+  unsigned int cpusubtype;\n+  /* Flags from header.  */\n+  unsigned int flags;\n+  /* Reserved field from header, only used on 64-bit.  */\n+  unsigned int reserved;\n+};\n+\n+/* See if we have a Mach-O file.  */\n+\n+static void *\n+simple_object_mach_o_match (\n+    unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN],\n+    int descriptor,\n+    off_t offset,\n+    const char *segment_name,\n+    const char **errmsg,\n+    int *err)\n+{\n+  unsigned int magic;\n+  int is_big_endian;\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  unsigned int filetype;\n+  struct simple_object_mach_o_read *omr;\n+  unsigned char buf[sizeof (struct mach_o_header_64)];\n+  unsigned char *b;\n+\n+  magic = simple_object_fetch_big_32 (header);\n+  if (magic == MACH_O_MH_MAGIC || magic == MACH_O_MH_MAGIC_64)\n+    is_big_endian = 1;\n+  else\n+    {\n+      magic = simple_object_fetch_little_32 (header);\n+      if (magic == MACH_O_MH_MAGIC || magic == MACH_O_MH_MAGIC_64)\n+\tis_big_endian = 0;\n+      else\n+\t{\n+\t  *errmsg = NULL;\n+\t  *err = 0;\n+\t  return NULL;\n+\t}\n+    }\n+\n+#ifndef UNSIGNED_64BIT_TYPE\n+  if (magic == MACH_O_MH_MAGIC_64)\n+    {\n+      *errmsg = \"64-bit Mach-O objects not supported\";\n+      *err = 0;\n+      return NULL;\n+    }\n+#endif\n+\n+  /* We require the user to provide a segment name.  This is\n+     unfortunate but I don't see any good choices here.  */\n+\n+  if (segment_name == NULL)\n+    {\n+      *errmsg = \"Mach-O file found but no segment name specified\";\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  if (strlen (segment_name) > MACH_O_NAME_LEN)\n+    {\n+      *errmsg = \"Mach-O segment name too long\";\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  /* The 32-bit and 64-bit headers are similar enough that we can use\n+     the same code.  */\n+\n+  fetch_32 = (is_big_endian\n+\t      ? simple_object_fetch_big_32\n+\t      : simple_object_fetch_little_32);\n+\n+  if (!simple_object_internal_read (descriptor, offset, buf,\n+\t\t\t\t    (magic == MACH_O_MH_MAGIC\n+\t\t\t\t     ? sizeof (struct mach_o_header_32)\n+\t\t\t\t     : sizeof (struct mach_o_header_64)),\n+\t\t\t\t    errmsg, err))\n+    return NULL;\n+\n+  b = &buf[0];\n+\n+  filetype = (*fetch_32) (b + offsetof (struct mach_o_header_32, filetype));\n+  if (filetype != MACH_O_MH_OBJECT)\n+    {\n+      *errmsg = \"Mach-O file is not object file\";\n+      *err = 0;\n+      return NULL;\n+    }\n+\n+  omr = XNEW (struct simple_object_mach_o_read);\n+  omr->segment_name = xstrdup (segment_name);\n+  omr->magic = magic;\n+  omr->is_big_endian = is_big_endian;\n+  omr->cputype = (*fetch_32) (b + offsetof (struct mach_o_header_32, cputype));\n+  omr->cpusubtype = (*fetch_32) (b\n+\t\t\t\t + offsetof (struct mach_o_header_32,\n+\t\t\t\t\t     cpusubtype));\n+  omr->ncmds = (*fetch_32) (b + offsetof (struct mach_o_header_32, ncmds));\n+  omr->flags = (*fetch_32) (b + offsetof (struct mach_o_header_32, flags));\n+  if (magic == MACH_O_MH_MAGIC)\n+    omr->reserved = 0;\n+  else\n+    omr->reserved = (*fetch_32) (b\n+\t\t\t\t + offsetof (struct mach_o_header_64,\n+\t\t\t\t\t     reserved));\n+\n+  return (void *) omr;\n+}\n+\n+/* Get the file offset and size from a section header.  */\n+\n+static void\n+simple_object_mach_o_section_info (int is_big_endian, int is_32,\n+\t\t\t\t   const unsigned char *sechdr, off_t *offset,\n+\t\t\t\t   size_t *size)\n+{\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  ulong_type (*fetch_64) (const unsigned char *);\n+\n+  fetch_32 = (is_big_endian\n+\t      ? simple_object_fetch_big_32\n+\t      : simple_object_fetch_little_32);\n+\n+  fetch_64 = NULL;\n+#ifdef UNSIGNED_64BIT_TYPE\n+  fetch_64 = (is_big_endian\n+\t      ? simple_object_fetch_big_64\n+\t      : simple_object_fetch_little_64);\n+#endif\n+\n+  if (is_32)\n+    {\n+      *offset = fetch_32 (sechdr\n+\t\t\t  + offsetof (struct mach_o_section_32, offset));\n+      *size = fetch_32 (sechdr\n+\t\t\t+ offsetof (struct mach_o_section_32, size));\n+    }\n+  else\n+    {\n+      *offset = fetch_32 (sechdr\n+\t\t\t  + offsetof (struct mach_o_section_64, offset));\n+      *size = fetch_64 (sechdr\n+\t\t\t+ offsetof (struct mach_o_section_64, size));\n+    }\n+}\n+\n+/* Handle a segment in a Mach-O file.  Return 1 if we should continue,\n+   0 if the caller should return.  */\n+\n+static int\n+simple_object_mach_o_segment (simple_object_read *sobj, off_t offset,\n+\t\t\t      const unsigned char *segbuf,\n+\t\t\t      int (*pfn) (void *, const char *, off_t offset,\n+\t\t\t\t\t  off_t length),\n+\t\t\t      void *data,\n+\t\t\t      const char **errmsg, int *err)\n+{\n+  struct simple_object_mach_o_read *omr =\n+    (struct simple_object_mach_o_read *) sobj->data;\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  int is_32;\n+  size_t seghdrsize;\n+  size_t sechdrsize;\n+  size_t segname_offset;\n+  size_t sectname_offset;\n+  unsigned int nsects;\n+  unsigned char *secdata;\n+  unsigned int i;\n+  unsigned int strtab_index;\n+  char *strtab;\n+  size_t strtab_size;\n+\n+  fetch_32 = (omr->is_big_endian\n+\t      ? simple_object_fetch_big_32\n+\t      : simple_object_fetch_little_32);\n+\n+  is_32 = omr->magic == MACH_O_MH_MAGIC;\n+\n+  if (is_32)\n+    {\n+      seghdrsize = sizeof (struct mach_o_segment_command_32);\n+      sechdrsize = sizeof (struct mach_o_section_32);\n+      segname_offset = offsetof (struct mach_o_section_32, segname);\n+      sectname_offset = offsetof (struct mach_o_section_32, sectname);\n+      nsects = (*fetch_32) (segbuf\n+\t\t\t    + offsetof (struct mach_o_segment_command_32,\n+\t\t\t\t\tnsects));\n+    }\n+  else\n+    {\n+      seghdrsize = sizeof (struct mach_o_segment_command_64);\n+      sechdrsize = sizeof (struct mach_o_section_64);\n+      segname_offset = offsetof (struct mach_o_section_64, segname);\n+      sectname_offset = offsetof (struct mach_o_section_64, sectname);\n+      nsects = (*fetch_32) (segbuf\n+\t\t\t    + offsetof (struct mach_o_segment_command_64,\n+\t\t\t\t\tnsects));\n+    }\n+\n+  secdata = XNEWVEC (unsigned char, nsects * sechdrsize);\n+  if (!simple_object_internal_read (sobj->descriptor, offset + seghdrsize,\n+\t\t\t\t    secdata, nsects * sechdrsize, errmsg, err))\n+    {\n+      XDELETEVEC (secdata);\n+      return 0;\n+    }\n+\n+  /* Scan for a __section_names section.  This is in effect a GNU\n+     extension that permits section names longer than 16 chars.  */\n+\n+  for (i = 0; i < nsects; ++i)\n+    {\n+      size_t nameoff;\n+\n+      nameoff = i * sechdrsize + segname_offset;\n+      if (strcmp ((char *) secdata + nameoff, omr->segment_name) != 0)\n+\tcontinue;\n+      nameoff = i * sechdrsize + sectname_offset;\n+      if (strcmp ((char *) secdata + nameoff, GNU_SECTION_NAMES) == 0)\n+\tbreak;\n+    }\n+\n+  strtab_index = i;\n+  if (strtab_index >= nsects)\n+    {\n+      strtab = NULL;\n+      strtab_size = 0;\n+    }\n+  else\n+    {\n+      off_t strtab_offset;\n+\n+      simple_object_mach_o_section_info (omr->is_big_endian, is_32,\n+\t\t\t\t\t secdata + strtab_index * sechdrsize,\n+\t\t\t\t\t &strtab_offset, &strtab_size);\n+      strtab = XNEWVEC (char, strtab_size);\n+      if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\tsobj->offset + strtab_offset,\n+\t\t\t\t\t(unsigned char *) strtab, strtab_size,\n+\t\t\t\t\terrmsg, err))\n+\t{\n+\t  XDELETEVEC (strtab);\n+\t  XDELETEVEC (secdata);\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* Process the sections.  */\n+\n+  for (i = 0; i < nsects; ++i)\n+    {\n+      const unsigned char *sechdr;\n+      char namebuf[MACH_O_NAME_LEN + 1];\n+      char *name;\n+      off_t secoffset;\n+      size_t secsize;\n+\n+      if (i == strtab_index)\n+\tcontinue;\n+\n+      sechdr = secdata + i * sechdrsize;\n+\n+      if (strcmp ((char *) sechdr + segname_offset, omr->segment_name) != 0)\n+\tcontinue;\n+\n+      memcpy (namebuf, sechdr + sectname_offset, MACH_O_NAME_LEN);\n+      namebuf[MACH_O_NAME_LEN] = '\\0';\n+\n+      name = &namebuf[0];\n+      if (strtab != NULL && name[0] == '_' && name[1] == '_')\n+\t{\n+\t  unsigned long stringoffset;\n+\n+\t  if (sscanf (name + 2, \"%08lX\", &stringoffset) == 1)\n+\t    {\n+\t      if (stringoffset >= strtab_size)\n+\t\t{\n+\t\t  *errmsg = \"section name offset out of range\";\n+\t\t  *err = 0;\n+\t\t  XDELETEVEC (strtab);\n+\t\t  XDELETEVEC (secdata);\n+\t\t  return 0;\n+\t\t}\n+\n+\t      name = strtab + stringoffset;\n+\t    }\n+\t}\n+\n+      simple_object_mach_o_section_info (omr->is_big_endian, is_32, sechdr,\n+\t\t\t\t\t &secoffset, &secsize);\n+\n+      if (!(*pfn) (data, name, secoffset, secsize))\n+\t{\n+\t  *errmsg = NULL;\n+\t  *err = 0;\n+\t  XDELETEVEC (strtab);\n+\t  XDELETEVEC (secdata);\n+\t  return 0;\n+\t}\n+    }\n+\n+  XDELETEVEC (strtab);\n+  XDELETEVEC (secdata);\n+\n+  return 1;\n+}\n+\n+/* Find all sections in a Mach-O file.  */\n+\n+static const char *\n+simple_object_mach_o_find_sections (simple_object_read *sobj,\n+\t\t\t\t    int (*pfn) (void *, const char *,\n+\t\t\t\t\t\toff_t offset, off_t length),\n+\t\t\t\t    void *data,\n+\t\t\t\t    int *err)\n+{\n+  struct simple_object_mach_o_read *omr =\n+    (struct simple_object_mach_o_read *) sobj->data;\n+  off_t offset;\n+  size_t seghdrsize;\n+  unsigned int (*fetch_32) (const unsigned char *);\n+  const char *errmsg;\n+  unsigned int i;\n+\n+  if (omr->magic == MACH_O_MH_MAGIC)\n+    {\n+      offset = sizeof (struct mach_o_header_32);\n+      seghdrsize = sizeof (struct mach_o_segment_command_32);\n+    }\n+  else\n+    {\n+      offset = sizeof (struct mach_o_header_64);\n+      seghdrsize = sizeof (struct mach_o_segment_command_64);\n+    }\n+\n+  fetch_32 = (omr->is_big_endian\n+\t      ? simple_object_fetch_big_32\n+\t      : simple_object_fetch_little_32);\n+\n+  for (i = 0; i < omr->ncmds; ++i)\n+    {\n+      unsigned char loadbuf[sizeof (struct mach_o_load_command)];\n+      unsigned int cmd;\n+      unsigned int cmdsize;\n+\n+      if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\tsobj->offset + offset,\n+\t\t\t\t\tloadbuf,\n+\t\t\t\t\tsizeof (struct mach_o_load_command),\n+\t\t\t\t\t&errmsg, err))\n+\treturn errmsg;\n+\n+      cmd = (*fetch_32) (loadbuf + offsetof (struct mach_o_load_command, cmd));\n+      cmdsize = (*fetch_32) (loadbuf\n+\t\t\t     + offsetof (struct mach_o_load_command, cmdsize));\n+\n+      if (cmd == MACH_O_LC_SEGMENT || cmd == MACH_O_LC_SEGMENT_64)\n+\t{\n+\t  unsigned char segbuf[sizeof (struct mach_o_segment_command_64)];\n+\t  int r;\n+\n+\t  if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\t    sobj->offset + offset,\n+\t\t\t\t\t    segbuf, seghdrsize, &errmsg, err))\n+\t    return errmsg;\n+\n+\t  r = simple_object_mach_o_segment (sobj, offset, segbuf, pfn,\n+\t\t\t\t\t    data, &errmsg, err);\n+\t  if (!r)\n+\t    return errmsg;\n+\t}\n+\n+      offset += cmdsize;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Fetch the attributes for an simple_object_read.  */\n+\n+static void *\n+simple_object_mach_o_fetch_attributes (simple_object_read *sobj,\n+\t\t\t\t       const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\t       int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_mach_o_read *omr =\n+    (struct simple_object_mach_o_read *) sobj->data;\n+  struct simple_object_mach_o_attributes *ret;\n+\n+  ret = XNEW (struct simple_object_mach_o_attributes);\n+  ret->magic = omr->magic;\n+  ret->is_big_endian = omr->is_big_endian;\n+  ret->cputype = omr->cputype;\n+  ret->cpusubtype = omr->cpusubtype;\n+  ret->flags = omr->flags;\n+  ret->reserved = omr->reserved;\n+  return ret;\n+}\n+\n+/* Release the private data for an simple_object_read.  */\n+\n+static void\n+simple_object_mach_o_release_read (void *data)\n+{\n+  struct simple_object_mach_o_read *omr =\n+    (struct simple_object_mach_o_read *) data;\n+\n+  free (omr->segment_name);\n+  XDELETE (omr);\n+}\n+\n+/* Compare two attributes structures.  */\n+\n+static const char *\n+simple_object_mach_o_attributes_compare (void *data1, void *data2, int *err)\n+{\n+  struct simple_object_mach_o_attributes *attrs1 =\n+    (struct simple_object_mach_o_attributes *) data1;\n+  struct simple_object_mach_o_attributes *attrs2 =\n+    (struct simple_object_mach_o_attributes *) data2;\n+\n+  if (attrs1->magic != attrs2->magic\n+      || attrs1->is_big_endian != attrs2->is_big_endian\n+      || attrs1->cputype != attrs2->cputype)\n+    {\n+      *err = 0;\n+      return \"Mach-O object format mismatch\";\n+    }\n+  return NULL;\n+}\n+\n+/* Release the private data for an attributes structure.  */\n+\n+static void\n+simple_object_mach_o_release_attributes (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* Prepare to write out a file.  */\n+\n+static void *\n+simple_object_mach_o_start_write (void *attributes_data,\n+\t\t\t\t  const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\t  int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_mach_o_attributes *attrs =\n+    (struct simple_object_mach_o_attributes *) attributes_data;\n+  struct simple_object_mach_o_attributes *ret;\n+\n+  /* We're just going to record the attributes, but we need to make a\n+     copy because the user may delete them.  */\n+  ret = XNEW (struct simple_object_mach_o_attributes);\n+  *ret = *attrs;\n+  return ret;\n+}\n+\n+/* Write out the header of a Mach-O file.  */\n+\n+static int\n+simple_object_mach_o_write_header (simple_object_write *sobj, int descriptor,\n+\t\t\t\t   size_t nsects, const char **errmsg,\n+\t\t\t\t   int *err)\n+{\n+  struct simple_object_mach_o_attributes *attrs =\n+    (struct simple_object_mach_o_attributes *) sobj->data;\n+  void (*set_32) (unsigned char *, unsigned int);\n+  unsigned char hdrbuf[sizeof (struct mach_o_header_64)];\n+  unsigned char *hdr;\n+  size_t wrsize;\n+\n+  set_32 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_32\n+\t    : simple_object_set_little_32);\n+\n+  memset (hdrbuf, 0, sizeof hdrbuf);\n+\n+  /* The 32-bit and 64-bit headers start out the same.  */\n+\n+  hdr = &hdrbuf[0];\n+  set_32 (hdr + offsetof (struct mach_o_header_32, magic), attrs->magic);\n+  set_32 (hdr + offsetof (struct mach_o_header_32, cputype), attrs->cputype);\n+  set_32 (hdr + offsetof (struct mach_o_header_32, cpusubtype),\n+\t  attrs->cpusubtype);\n+  set_32 (hdr + offsetof (struct mach_o_header_32, filetype), MACH_O_MH_OBJECT);\n+  set_32 (hdr + offsetof (struct mach_o_header_32, ncmds), 1);\n+  set_32 (hdr + offsetof (struct mach_o_header_32, flags), attrs->flags);\n+  if (attrs->magic == MACH_O_MH_MAGIC)\n+    {\n+      wrsize = sizeof (struct mach_o_header_32);\n+      set_32 (hdr + offsetof (struct mach_o_header_32, sizeofcmds),\n+\t      (sizeof (struct mach_o_segment_command_32)\n+\t       + nsects * sizeof (struct mach_o_section_32)));\n+    }\n+  else\n+    {\n+      set_32 (hdr + offsetof (struct mach_o_header_64, sizeofcmds),\n+\t      (sizeof (struct mach_o_segment_command_64)\n+\t       + nsects * sizeof (struct mach_o_section_64)));\n+      set_32 (hdr + offsetof (struct mach_o_header_64, reserved),\n+\t      attrs->reserved);\n+      wrsize = sizeof (struct mach_o_header_64);\n+    }\n+\n+  return simple_object_internal_write (descriptor, 0, hdrbuf, wrsize,\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write a Mach-O section header.  */\n+\n+static int\n+simple_object_mach_o_write_section_header (simple_object_write *sobj,\n+\t\t\t\t\t   int descriptor,\n+\t\t\t\t\t   size_t sechdr_offset,\n+\t\t\t\t\t   const char *name, size_t secaddr,\n+\t\t\t\t\t   size_t secsize, size_t offset,\n+\t\t\t\t\t   unsigned int align,\n+\t\t\t\t\t   const char **errmsg, int *err)\n+{\n+  struct simple_object_mach_o_attributes *attrs =\n+    (struct simple_object_mach_o_attributes *) sobj->data;\n+  void (*set_32) (unsigned char *, unsigned int);\n+  unsigned char hdrbuf[sizeof (struct mach_o_section_64)];\n+  unsigned char *hdr;\n+  size_t sechdrsize;\n+\n+  set_32 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_32\n+\t    : simple_object_set_little_32);\n+\n+  memset (hdrbuf, 0, sizeof hdrbuf);\n+\n+  hdr = &hdrbuf[0];\n+  if (attrs->magic == MACH_O_MH_MAGIC)\n+    {\n+      strncpy ((char *) hdr + offsetof (struct mach_o_section_32, sectname),\n+\t       name, MACH_O_NAME_LEN);\n+      strncpy ((char *) hdr + offsetof (struct mach_o_section_32, segname),\n+\t       sobj->segment_name, MACH_O_NAME_LEN);\n+      set_32 (hdr + offsetof (struct mach_o_section_32, addr), secaddr);\n+      set_32 (hdr + offsetof (struct mach_o_section_32, size), secsize);\n+      set_32 (hdr + offsetof (struct mach_o_section_32, offset), offset);\n+      set_32 (hdr + offsetof (struct mach_o_section_32, align), align);\n+      /* reloff left as zero.  */\n+      /* nreloc left as zero.  */\n+      set_32 (hdr + offsetof (struct mach_o_section_32, flags),\n+\t      MACH_O_S_ATTR_DEBUG);\n+      /* reserved1 left as zero.  */\n+      /* reserved2 left as zero.  */\n+      sechdrsize = sizeof (struct mach_o_section_32);\n+    }\n+  else\n+    {\n+#ifdef UNSIGNED_64BIT_TYPE\n+      void (*set_64) (unsigned char *, ulong_type);\n+\n+      set_64 = (attrs->is_big_endian\n+\t\t? simple_object_set_big_64\n+\t\t: simple_object_set_little_64);\n+\n+      strncpy ((char *) hdr + offsetof (struct mach_o_section_64, sectname),\n+\t       name, MACH_O_NAME_LEN);\n+      strncpy ((char *) hdr + offsetof (struct mach_o_section_64, segname),\n+\t       sobj->segment_name, MACH_O_NAME_LEN);\n+      set_64 (hdr + offsetof (struct mach_o_section_64, addr), secaddr);\n+      set_64 (hdr + offsetof (struct mach_o_section_64, size), secsize);\n+      set_32 (hdr + offsetof (struct mach_o_section_64, offset), offset);\n+      set_32 (hdr + offsetof (struct mach_o_section_64, align), align);\n+      /* reloff left as zero.  */\n+      /* nreloc left as zero.  */\n+      set_32 (hdr + offsetof (struct mach_o_section_64, flags),\n+\t      MACH_O_S_ATTR_DEBUG);\n+      /* reserved1 left as zero.  */\n+      /* reserved2 left as zero.  */\n+      /* reserved3 left as zero.  */\n+#endif\n+      sechdrsize = sizeof (struct mach_o_section_64);\n+    }\n+\n+  return simple_object_internal_write (descriptor, sechdr_offset, hdr,\n+\t\t\t\t       sechdrsize, errmsg, err);\n+}\n+\n+/* Write out the single segment and the sections of a Mach-O file.  */\n+\n+static int\n+simple_object_mach_o_write_segment (simple_object_write *sobj, int descriptor,\n+\t\t\t\t    size_t nsects, const char **errmsg,\n+\t\t\t\t    int *err)\n+{\n+  struct simple_object_mach_o_attributes *attrs =\n+    (struct simple_object_mach_o_attributes *) sobj->data;\n+  void (*set_32) (unsigned char *, unsigned int);\n+  size_t hdrsize;\n+  size_t seghdrsize;\n+  size_t sechdrsize;\n+  size_t cmdsize;\n+  size_t offset;\n+  size_t sechdr_offset;\n+  size_t secaddr;\n+  unsigned int name_offset;\n+  simple_object_write_section *section;\n+  unsigned char hdrbuf[sizeof (struct mach_o_segment_command_64)];\n+  unsigned char *hdr;\n+\n+  set_32 = (attrs->is_big_endian\n+\t    ? simple_object_set_big_32\n+\t    : simple_object_set_little_32);\n+\n+  /* Write out the sections first.  */\n+\n+  if (attrs->magic == MACH_O_MH_MAGIC)\n+    {\n+      hdrsize = sizeof (struct mach_o_header_32);\n+      seghdrsize = sizeof (struct mach_o_segment_command_32);\n+      sechdrsize = sizeof (struct mach_o_section_32);\n+    }\n+  else\n+    {\n+      hdrsize = sizeof (struct mach_o_header_64);\n+      seghdrsize = sizeof (struct mach_o_segment_command_64);\n+      sechdrsize = sizeof (struct mach_o_section_64);\n+    }\n+\n+  sechdr_offset = hdrsize + seghdrsize;\n+  cmdsize = seghdrsize + nsects * sechdrsize;\n+  offset = hdrsize + cmdsize;\n+  name_offset = 0;\n+  secaddr = 0;\n+\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t mask;\n+      size_t new_offset;\n+      size_t secsize;\n+      struct simple_object_write_section_buffer *buffer;\n+      char namebuf[MACH_O_NAME_LEN + 1];\n+\n+      mask = (1U << section->align) - 1;\n+      new_offset = offset + mask;\n+      new_offset &= ~ mask;\n+      while (new_offset > offset)\n+\t{\n+\t  unsigned char zeroes[16];\n+\t  size_t write;\n+\n+\t  memset (zeroes, 0, sizeof zeroes);\n+\t  write = new_offset - offset;\n+\t  if (write > sizeof zeroes)\n+\t    write = sizeof zeroes;\n+\t  if (!simple_object_internal_write (descriptor, offset, zeroes, write,\n+\t\t\t\t\t     errmsg, err))\n+\t    return 0;\n+\t  offset += write;\n+\t}\n+\n+      secsize = 0;\n+      for (buffer = section->buffers; buffer != NULL; buffer = buffer->next)\n+\t{\n+\t  if (!simple_object_internal_write (descriptor, offset + secsize,\n+\t\t\t\t\t     ((const unsigned char *)\n+\t\t\t\t\t      buffer->buffer),\n+\t\t\t\t\t     buffer->size, errmsg, err))\n+\t    return 0;\n+\t  secsize += buffer->size;\n+\t}\n+\n+      snprintf (namebuf, sizeof namebuf, \"__%08X\", name_offset);\n+      if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n+\t\t\t\t\t\t      sechdr_offset, namebuf,\n+\t\t\t\t\t\t      secaddr, secsize, offset,\n+\t\t\t\t\t\t      section->align,\n+\t\t\t\t\t\t      errmsg, err))\n+\treturn 0;\n+\n+      sechdr_offset += sechdrsize;\n+      offset += secsize;\n+      name_offset += strlen (section->name) + 1;\n+      secaddr += secsize;\n+    }\n+\n+  /* Write out the section names.  */\n+\n+  if (!simple_object_mach_o_write_section_header (sobj, descriptor,\n+\t\t\t\t\t\t  sechdr_offset,\n+\t\t\t\t\t\t  GNU_SECTION_NAMES, secaddr,\n+\t\t\t\t\t\t  name_offset, offset, 0,\n+\t\t\t\t\t\t  errmsg, err))\n+    return 0;\n+\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    {\n+      size_t namelen;\n+\n+      namelen = strlen (section->name) + 1;\n+      if (!simple_object_internal_write (descriptor, offset,\n+\t\t\t\t\t (const unsigned char *) section->name,\n+\t\t\t\t\t namelen, errmsg, err))\n+\treturn 0;\n+      offset += namelen;\n+    }\n+\n+  /* Write out the segment header.  */\n+\n+  memset (hdrbuf, 0, sizeof hdrbuf);\n+\n+  hdr = &hdrbuf[0];\n+  if (attrs->magic == MACH_O_MH_MAGIC)\n+    {\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_32, cmd),\n+\t      MACH_O_LC_SEGMENT);\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_32, cmdsize),\n+\t      cmdsize);\n+      strncpy (((char *) hdr\n+\t\t+ offsetof (struct mach_o_segment_command_32, segname)),\n+\t       sobj->segment_name, MACH_O_NAME_LEN);\n+      /* vmaddr left as zero.  */\n+      /* vmsize left as zero.  */\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_32, fileoff),\n+\t      hdrsize + cmdsize);\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_32, filesize),\n+\t      offset - (hdrsize + cmdsize));\n+      /* maxprot left as zero.  */\n+      /* initprot left as zero.  */\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_32, nsects),\n+\t      nsects);\n+      /* flags left as zero.  */\n+    }\n+  else\n+    {\n+#ifdef UNSIGNED_64BIT_TYPE\n+      void (*set_64) (unsigned char *, ulong_type);\n+\n+      set_64 = (attrs->is_big_endian\n+\t\t? simple_object_set_big_64\n+\t\t: simple_object_set_little_64);\n+\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_64, cmd),\n+\t      MACH_O_LC_SEGMENT);\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_64, cmdsize),\n+\t      cmdsize);\n+      strncpy (((char *) hdr\n+\t\t+ offsetof (struct mach_o_segment_command_64, segname)),\n+\t       sobj->segment_name, MACH_O_NAME_LEN);\n+      /* vmaddr left as zero.  */\n+      /* vmsize left as zero.  */\n+      set_64 (hdr + offsetof (struct mach_o_segment_command_64, fileoff),\n+\t      hdrsize + cmdsize);\n+      set_64 (hdr + offsetof (struct mach_o_segment_command_64, filesize),\n+\t      offset - (hdrsize + cmdsize));\n+      /* maxprot left as zero.  */\n+      /* initprot left as zero.  */\n+      set_32 (hdr + offsetof (struct mach_o_segment_command_64, nsects),\n+\t      nsects);\n+      /* flags left as zero.  */\n+#endif\n+    }\n+\n+  return simple_object_internal_write (descriptor, hdrsize, hdr, seghdrsize,\n+\t\t\t\t       errmsg, err);\n+}\n+\n+/* Write out a complete Mach-O file.  */\n+\n+static const char *\n+simple_object_mach_o_write_to_file (simple_object_write *sobj, int descriptor,\n+\t\t\t\t    int *err)\n+{\n+  size_t nsects;\n+  simple_object_write_section *section;\n+  const char *errmsg;\n+\n+  /* Start at 1 for symbol_names section.  */\n+  nsects = 1;\n+  for (section = sobj->sections; section != NULL; section = section->next)\n+    ++nsects;\n+\n+  if (!simple_object_mach_o_write_header (sobj, descriptor, nsects,\n+\t\t\t\t\t  &errmsg, err))\n+    return errmsg;\n+\n+  if (!simple_object_mach_o_write_segment (sobj, descriptor, nsects,\n+\t\t\t\t\t   &errmsg, err))\n+    return errmsg;\n+\n+  return NULL;\n+}\n+\n+/* Release the private data for an simple_object_write structure.  */\n+\n+static void\n+simple_object_mach_o_release_write (void *data)\n+{\n+  XDELETE (data);\n+}\n+\n+/* The Mach-O functions.  */\n+\n+const struct simple_object_functions simple_object_mach_o_functions =\n+{\n+  simple_object_mach_o_match,\n+  simple_object_mach_o_find_sections,\n+  simple_object_mach_o_fetch_attributes,\n+  simple_object_mach_o_release_read,\n+  simple_object_mach_o_attributes_compare,\n+  simple_object_mach_o_release_attributes,\n+  simple_object_mach_o_start_write,\n+  simple_object_mach_o_write_to_file,\n+  simple_object_mach_o_release_write\n+};"}, {"sha": "c9bd82f271416b5bf270fd31bddded4a9f9d8cf8", "filename": "libiberty/simple-object.c", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object.c?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,423 @@\n+/* simple-object.c -- simple routines to read and write object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 51 Franklin Street - Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libiberty.h\"\n+#include \"simple-object.h\"\n+\n+#include <errno.h>\n+\n+#ifdef HAVE_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAVE_STDINT_H\n+#include <stdint.h>\n+#endif\n+\n+#ifdef HAVE_STRING_H\n+#include <string.h>\n+#endif\n+\n+#ifdef HAVE_INTTYPES_H\n+#include <inttypes.h>\n+#endif\n+\n+#ifndef SEEK_SET\n+#define SEEK_SET 0\n+#endif\n+\n+#include \"simple-object-common.h\"\n+\n+/* The known object file formats.  */\n+\n+static const struct simple_object_functions * const format_functions[] =\n+{\n+  &simple_object_elf_functions,\n+  &simple_object_mach_o_functions,\n+  &simple_object_coff_functions\n+};\n+\n+/* Read data from a file using the simple_object error reporting\n+   conventions.  */\n+\n+int\n+simple_object_internal_read (int descriptor, off_t offset,\n+\t\t\t     unsigned char *buffer, size_t size,\n+\t\t\t     const char **errmsg, int *err)\n+{\n+  ssize_t got;\n+\n+  if (lseek (descriptor, offset, SEEK_SET) < 0)\n+    {\n+      *errmsg = \"lseek\";\n+      *err = errno;\n+      return 0;\n+    }\n+\n+  got = read (descriptor, buffer, size);\n+  if (got < 0)\n+    {\n+      *errmsg = \"read\";\n+      *err = errno;\n+      return 0;\n+    }\n+\n+  if ((size_t) got < size)\n+    {\n+      *errmsg = \"file too short\";\n+      *err = 0;\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Write data to a file using the simple_object error reporting\n+   conventions.  */\n+\n+int\n+simple_object_internal_write (int descriptor, off_t offset,\n+\t\t\t      const unsigned char *buffer, size_t size,\n+\t\t\t      const char **errmsg, int *err)\n+{\n+  ssize_t wrote;\n+\n+  if (lseek (descriptor, offset, SEEK_SET) < 0)\n+    {\n+      *errmsg = \"lseek\";\n+      *err = errno;\n+      return 0;\n+    }\n+\n+  wrote = write (descriptor, buffer, size);\n+  if (wrote < 0)\n+    {\n+      *errmsg = \"write\";\n+      *err = errno;\n+      return 0;\n+    }\n+\n+  if ((size_t) wrote < size)\n+    {\n+      *errmsg = \"short write\";\n+      *err = 0;\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Open for read.  */\n+\n+simple_object_read *\n+simple_object_start_read (int descriptor, off_t offset,\n+\t\t\t  const char *segment_name, const char **errmsg,\n+\t\t\t  int *err)\n+{\n+  unsigned char header[SIMPLE_OBJECT_MATCH_HEADER_LEN];\n+  size_t len, i;\n+\n+  if (!simple_object_internal_read (descriptor, offset, header,\n+\t\t\t\t    SIMPLE_OBJECT_MATCH_HEADER_LEN,\n+\t\t\t\t    errmsg, err))\n+    return NULL;\n+\n+  len = sizeof (format_functions) / sizeof (format_functions[0]);\n+  for (i = 0; i < len; ++i)\n+    {\n+      void *data;\n+\n+      data = format_functions[i]->match (header, descriptor, offset,\n+\t\t\t\t\t segment_name, errmsg, err);\n+      if (data != NULL)\n+\t{\n+\t  simple_object_read *ret;\n+\n+\t  ret = XNEW (simple_object_read);\n+\t  ret->descriptor = descriptor;\n+\t  ret->offset = offset;\n+\t  ret->functions = format_functions[i];\n+\t  ret->data = data;\n+\t  return ret;\n+\t}\n+    }\n+\n+  *errmsg = \"file not recognized\";\n+  *err = 0;\n+  return NULL;\n+}\n+\n+/* Find all sections.  */\n+\n+const char *\n+simple_object_find_sections (simple_object_read *sobj,\n+\t\t\t     int (*pfn) (void *, const char *, off_t, off_t),\n+\t\t\t     void *data,\n+\t\t\t     int *err)\n+{\n+  return sobj->functions->find_sections (sobj, pfn, data, err);\n+}\n+\n+/* Internal data passed to find_one_section.  */\n+\n+struct find_one_section_data\n+{\n+  /* The section we are looking for.  */\n+  const char *name;\n+  /* Where to store the section offset.  */\n+  off_t *offset;\n+  /* Where to store the section length.  */\n+  off_t *length;\n+  /* Set if the name is found.  */\n+  int found;\n+};\n+\n+/* Internal function passed to find_sections.  */\n+\n+static int\n+find_one_section (void *data, const char *name, off_t offset, off_t length)\n+{\n+  struct find_one_section_data *fosd = (struct find_one_section_data *) data;\n+\n+  if (strcmp (name, fosd->name) != 0)\n+    return 1;\n+\n+  *fosd->offset = offset;\n+  *fosd->length = length;\n+  fosd->found = 1;\n+\n+  /* Stop iteration.  */\n+  return 0;\n+}\n+\n+/* Find a section.  */\n+\n+int\n+simple_object_find_section (simple_object_read *sobj, const char *name,\n+\t\t\t    off_t *offset, off_t *length,\n+\t\t\t    const char **errmsg, int *err)\n+{\n+  struct find_one_section_data fosd;\n+\n+  fosd.name = name;\n+  fosd.offset = offset;\n+  fosd.length = length;\n+  fosd.found = 0;\n+\n+  *errmsg = simple_object_find_sections (sobj, find_one_section,\n+\t\t\t\t\t (void *) &fosd, err);\n+  if (*errmsg != NULL)\n+    return 0;\n+  if (!fosd.found)\n+    return 0;\n+  return 1;\n+}\n+\n+/* Fetch attributes.  */\n+\n+simple_object_attributes *\n+simple_object_fetch_attributes (simple_object_read *sobj, const char **errmsg,\n+\t\t\t\tint *err)\n+{\n+  void *data;\n+  simple_object_attributes *ret;\n+\n+  data = sobj->functions->fetch_attributes (sobj, errmsg, err);\n+  if (data == NULL)\n+    return NULL;\n+  ret = XNEW (simple_object_attributes);\n+  ret->functions = sobj->functions;\n+  ret->data = data;\n+  return ret;\n+}\n+\n+/* Release an simple_object_read.  */\n+\n+void\n+simple_object_release_read (simple_object_read *sobj)\n+{\n+  sobj->functions->release_read (sobj->data);\n+  XDELETE (sobj);\n+}\n+\n+/* Compare attributes.  */\n+\n+const char *\n+simple_object_attributes_compare (simple_object_attributes *attrs1,\n+\t\t\t\t  simple_object_attributes *attrs2,\n+\t\t\t\t  int *err)\n+{\n+  if (attrs1->functions != attrs2->functions)\n+    {\n+      *err = 0;\n+      return \"different object file format\";\n+    }\n+  return attrs1->functions->attributes_compare (attrs1->data, attrs2->data,\n+\t\t\t\t\t\terr);\n+}\n+\n+/* Release an attributes structure.  */\n+\n+void\n+simple_object_release_attributes (simple_object_attributes *attrs)\n+{\n+  attrs->functions->release_attributes (attrs->data);\n+  XDELETE (attrs);\n+}\n+\n+/* Start creating an object file.  */\n+\n+simple_object_write *\n+simple_object_start_write (simple_object_attributes *attrs,\n+\t\t\t   const char *segment_name, const char **errmsg,\n+\t\t\t   int *err)\n+{\n+  void *data;\n+  simple_object_write *ret;\n+\n+  data = attrs->functions->start_write (attrs->data, errmsg, err);\n+  if (data == NULL)\n+    return NULL;\n+  ret = XNEW (simple_object_write);\n+  ret->functions = attrs->functions;\n+  ret->segment_name = xstrdup (segment_name);\n+  ret->sections = NULL;\n+  ret->last_section = NULL;\n+  ret->data = data;\n+  return ret;\n+}\n+\n+/* Start creating a section.  */\n+\n+simple_object_write_section *\n+simple_object_write_create_section (simple_object_write *sobj, const char *name,\n+\t\t\t\t    unsigned int align,\n+\t\t\t\t    const char **errmsg ATTRIBUTE_UNUSED,\n+\t\t\t\t    int *err ATTRIBUTE_UNUSED)\n+{\n+  simple_object_write_section *ret;\n+\n+  ret = XNEW (simple_object_write_section);\n+  ret->next = NULL;\n+  ret->name = xstrdup (name);\n+  ret->align = align;\n+  ret->buffers = NULL;\n+  ret->last_buffer = NULL;\n+\n+  if (sobj->last_section == NULL)\n+    {\n+      sobj->sections = ret;\n+      sobj->last_section = ret;\n+    }\n+  else\n+    {\n+      sobj->last_section->next = ret;\n+      sobj->last_section = ret;\n+    }\n+\n+  return ret;\n+}\n+\n+/* Add data to a section.  */\n+\n+const char *\n+simple_object_write_add_data (simple_object_write *sobj ATTRIBUTE_UNUSED,\n+\t\t\t      simple_object_write_section *section,\n+\t\t\t      const void *buffer,\n+\t\t\t      size_t size, int copy,\n+\t\t\t      int *err ATTRIBUTE_UNUSED)\n+{\n+  struct simple_object_write_section_buffer *wsb;\n+\n+  wsb = XNEW (struct simple_object_write_section_buffer);\n+  wsb->next = NULL;\n+  wsb->size = size;\n+\n+  if (!copy)\n+    {\n+      wsb->buffer = buffer;\n+      wsb->free_buffer = NULL;\n+    }\n+  else\n+    {\n+      wsb->free_buffer = (void *) XNEWVEC (char, size);\n+      memcpy (wsb->free_buffer, buffer, size);\n+      wsb->buffer = wsb->free_buffer;\n+    }\n+\n+  if (section->last_buffer == NULL)\n+    {\n+      section->buffers = wsb;\n+      section->last_buffer = wsb;\n+    }\n+  else\n+    {\n+      section->last_buffer->next = wsb;\n+      section->last_buffer = wsb;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Write the complete object file.  */\n+\n+const char *\n+simple_object_write_to_file (simple_object_write *sobj, int descriptor,\n+\t\t\t     int *err)\n+{\n+  return sobj->functions->write_to_file (sobj, descriptor, err);\n+}\n+\n+/* Release an simple_object_write.  */\n+\n+void\n+simple_object_release_write (simple_object_write *sobj)\n+{\n+  simple_object_write_section *section;\n+\n+  free (sobj->segment_name);\n+\n+  section = sobj->sections;\n+  while (section != NULL)\n+    {\n+      struct simple_object_write_section_buffer *buffer;\n+      simple_object_write_section *next_section;\n+\n+      buffer = section->buffers;\n+      while (buffer != NULL)\n+\t{\n+\t  struct simple_object_write_section_buffer *next_buffer;\n+\n+\t  if (buffer->free_buffer != NULL)\n+\t    XDELETEVEC (buffer->free_buffer);\n+\t  next_buffer = buffer->next;\n+\t  XDELETE (buffer);\n+\t  buffer = next_buffer;\n+\t}\n+\n+      next_section = section->next;\n+      free (section->name);\n+      XDELETE (section);\n+      section = next_section;\n+    }\n+\n+  sobj->functions->release_write (sobj->data);\n+  XDELETE (sobj);\n+}"}, {"sha": "907233a93934189f36910b388e416b8a121e5e98", "filename": "libiberty/simple-object.txh", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object.txh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cfabf34d83637a5e9ffa11dc38379d017738cf7/libiberty%2Fsimple-object.txh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object.txh?ref=1cfabf34d83637a5e9ffa11dc38379d017738cf7", "patch": "@@ -0,0 +1,168 @@\n+@c -*- mode: texinfo -*-\n+@deftypefn Extension {simple_object_read *} simple_object_open_read (int @var{descriptor}, off_t @var{offset}, const char *{segment_name}, const char **@var{errmsg}, int *@var{err})\n+\n+Opens an object file for reading.  Creates and returns an\n+@code{simple_object_read} pointer which may be passed to other\n+functions to extract data from the object file.\n+\n+@var{descriptor} holds a file descriptor which permits reading.\n+\n+@var{offset} is the offset into the file; this will be @code{0} in the\n+normal case, but may be a different value when reading an object file\n+in an archive file.\n+\n+@var{segment_name} is only used with the Mach-O file format used on\n+Darwin aka Mac OS X.  It is required on that platform, and means to\n+only look at sections within the segment with that name.  The\n+parameter is ignored on other systems.\n+\n+If an error occurs, this functions returns @code{NULL} and sets\n+@code{*@var{errmsg}} to an error string and sets @code{*@var{err}} to\n+an errno value or @code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {const char *} simple_object_find_sections (simple_object_read *@var{simple_object}, int (*@var{pfn}) (void *@var{data}, const char *@var{name}, off_t @var{offset}, off_t @var{length}), void *@var{data}, int *@var{err})\n+\n+This function calls @var{pfn} for each section in @var{simple_object}.\n+It calls @var{pfn} with the section name, the offset within the file\n+of the section contents, and the length of the section contents.  The\n+offset within the file is relative to the offset passed to\n+@code{simple_object_open_read}.  The @var{data} argument to this\n+function is passed along to @var{pfn}.\n+\n+If @var{pfn} returns @code{0}, the loop over the sections stops and\n+@code{simple_object_find_sections} returns.  If @var{pfn} returns some\n+other value, the loop continues.\n+\n+On success @code{simple_object_find_sections} returns.  On error it\n+returns an error string, and sets @code{*@var{err}} to an errno value\n+or @code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {int} simple_object_find_section (simple_object_read *@var{simple_object} off_t *@var{offset}, off_t *@var{length}, const char **@var{errmsg}, int *@var{err})           \n+\n+Look for the section @var{name} in @var{simple_object}.  This returns\n+information for the first section with that name.\n+\n+If found, return 1 and set @code{*@var{offset}} to the offset in the\n+file of the section contents and set @code{*@var{length}} to the\n+length of the section contents.  The value in @code{*@var{offset}}\n+will be relative to the offset passed to\n+@code{simple_object_open_read}.\n+\n+If the section is not found, and no error occurs,\n+@code{simple_object_find_section} returns @code{0} and set\n+@code{*@var{errmsg}} to @code{NULL}.\n+\n+If an error occurs, @code{simple_object_find_section} returns\n+@code{0}, sets @code{*@var{errmsg}} to an error message, and sets\n+@code{*@var{err}} to an errno value or @code{0} if there is no\n+relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {void} simple_object_release_read (simple_object_read *@var{simple_object})\n+\n+Release all resources associated with @var{simple_object}.  This does\n+not close the file descriptor.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {simple_object_attributes *} simple_object_fetch_attributes (simple_object_read *@var{simple_object}, const char **@var{errmsg}, int *@var{err})\n+\n+Fetch the attributes of @var{simple_object}.  The attributes are\n+internal information such as the format of the object file, or the\n+architecture it was compiled for.  This information will persist until\n+@code{simple_object_attributes_release} is called, even if\n+@var{simple_object} itself is released.\n+\n+On error this returns @code{NULL}, sets @code{*@var{errmsg}} to an\n+error message, and sets @code{*@var{err}} to an errno value or\n+@code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {const char *} simple_object_attributes_compare (simple_object_attributes *@var{attrs1}, simple_object_attributes *@var{attrs2}, int *@var{err})\n+\n+Compare @var{attrs1} and @var{attrs2}.  If they could be linked\n+together without error, return @code{NULL}.  Otherwise, return an\n+error message and set @code{*@var{err}} to an errno value or @code{0}\n+if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {void} simple_object_release_attributes (simple_object_attributes *@var{attrs})\n+\n+Release all resources associated with @var{attrs}.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {simple_object_write *} simple_object_start_write (simple_object_attributes @var{attrs}, const char *@var{segment_name}, const char **@var{errmsg}, int *@var{err})\n+\n+Start creating a new object file using the object file format\n+described in @var{attrs}.  You must fetch attribute information from\n+an existing object file before you can create a new one.  There is\n+currently no support for creating an object file de novo.\n+\n+@var{segment_name} is only used with Mach-O as found on Darwin aka Mac\n+OS X.  The parameter is required on that target.  It means that all\n+sections are created within the named segment.  It is ignored for\n+other object file formats.\n+\n+On error @code{simple_object_start_write} returns @code{NULL}, sets\n+@code{*@var{ERRMSG}} to an error message, and sets @code{*@var{err}}\n+to an errno value or @code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {simple_object_write_section *} simple_object_write_create_section (simple_object_write *@var{simple_object}, const char *@var{name}, unsigned int @var{align}, const char **@var{errmsg}, int *@var{err})\n+\n+Add a section to @var{simple_object}.  @var{name} is the name of the\n+new section.  @var{align} is the required alignment expressed as the\n+number of required low-order 0 bits (e.g., 2 for alignment to a 32-bit\n+boundary).\n+\n+The section is created as containing data, readable, not writable, not\n+executable, not loaded at runtime.  The section is not written to the\n+file until @code{simple_object_write_to_file} is called.\n+\n+On error this returns @code{NULL}, sets @code{*@var{errmsg}} to an\n+error message, and sets @code{*@var{err}} to an errno value or\n+@code{0} if there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {const char *} simple_object_write_add_data (simple_object_write *@var{simple_object}, simple_object_write_section *@var{section}, const void *@var{buffer}, size_t @var{size}, int @var{copy}, int *@var{err})\n+\n+Add data @var{buffer}/@var{size} to @var{section} in\n+@var{simple_object}.  If @var{copy} is non-zero, the data will be\n+copied into memory if necessary.  If @var{copy} is zero, @var{buffer}\n+must persist until @code{simple_object_write_to_file} is called.  is\n+released.\n+\n+On success this returns @code{NULL}.  On error this returns an error\n+message, and sets @code{*@var{err}} to an errno value or 0 if there is\n+no relevant erro.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {const char *} simple_object_write_to_file (simple_object_write *@var{simple_object}, int @var{descriptor}, int *@var{err})\n+\n+Write the complete object file to @var{descriptor}, an open file\n+descriptor.  This writes out all the data accumulated by calls to\n+@code{simple_object_write_create_section} and\n+@var{simple_object_write_add_data}.\n+\n+This returns @code{NULL} on success.  On error this returns an error\n+message and sets @code{*@var{err}} to an errno value or @code{0} if\n+there is no relevant errno.\n+\n+@end deftypefn\n+\n+@deftypefn Extension {void} simple_object_release_write (simple_object_write *@var{simple_object})\n+\n+Release all resources associated with @var{simple_object}.\n+\n+@end deftypefn"}]}