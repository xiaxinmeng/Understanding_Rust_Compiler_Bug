{"sha": "326a31e9513774c3088ed46f4d7b2ee54dd18c5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI2YTMxZTk1MTM3NzRjMzA4OGVkNDZmNGQ3YjJlZTU0ZGQxOGM1Yg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2005-05-13T18:22:57Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2005-05-13T18:22:57Z"}, "message": "re PR middle-end/20714 (emit_no_conflict_block does invalid reordering)\n\n\tPR middle-end/20714:\n\t* optabs.c (no_conflict_data): New struct.\n\t(no_conflict_move_test): New function.\n\t(emit_no_conflict_block): Use it.\n\nFrom-SVN: r99674", "tree": {"sha": "244f8f1b9f276ca8684a405ccc5d61cad35ae084", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/244f8f1b9f276ca8684a405ccc5d61cad35ae084"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/326a31e9513774c3088ed46f4d7b2ee54dd18c5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326a31e9513774c3088ed46f4d7b2ee54dd18c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/326a31e9513774c3088ed46f4d7b2ee54dd18c5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326a31e9513774c3088ed46f4d7b2ee54dd18c5b/comments", "author": null, "committer": null, "parents": [{"sha": "223dcf1c00775e2727e599e4d885372490347ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/223dcf1c00775e2727e599e4d885372490347ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/223dcf1c00775e2727e599e4d885372490347ed0"}], "stats": {"total": 66, "additions": 48, "deletions": 18}, "files": [{"sha": "2c4c492dcff7d2dfad535dd106b1225bc49cc174", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326a31e9513774c3088ed46f4d7b2ee54dd18c5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326a31e9513774c3088ed46f4d7b2ee54dd18c5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=326a31e9513774c3088ed46f4d7b2ee54dd18c5b", "patch": "@@ -1,3 +1,10 @@\n+2005-05-13  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR middle-end/20714:\n+\t* optabs.c (no_conflict_data): New struct.\n+\t(no_conflict_move_test): New function.\n+\t(emit_no_conflict_block): Use it.\n+\n 2005-05-13  Adam Nemet  <anemet@lnxw.com>\n \n \t* doc/invoke.texi (Debugging Options): Option"}, {"sha": "d3c4934c544743ed340ff27df8886854a5b745d2", "filename": "gcc/optabs.c", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326a31e9513774c3088ed46f4d7b2ee54dd18c5b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326a31e9513774c3088ed46f4d7b2ee54dd18c5b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=326a31e9513774c3088ed46f4d7b2ee54dd18c5b", "patch": "@@ -2943,6 +2943,39 @@ emit_unop_insn (int icode, rtx target, rtx op0, enum rtx_code code)\n     emit_move_insn (target, temp);\n }\n \f\n+struct no_conflict_data\n+{\n+  rtx target, first, insn;\n+  bool must_stay;\n+};\n+\n+/* Called via note_stores by emit_no_conflict_block.  Set P->must_stay\n+   if the currently examined clobber / store has to stay in the list of\n+   insns that constitute the actual no_conflict block.  */\n+static void\n+no_conflict_move_test (rtx dest, rtx set, void *p0)\n+{\n+  struct no_conflict_data *p= p0;\n+\n+  /* If this inns directly contributes to setting the target, it must stay.  */\n+  if (reg_overlap_mentioned_p (p->target, dest))\n+    p->must_stay = true;\n+  /* If we haven't committed to keeping any other insns in the list yet,\n+     there is nothing more to check.  */\n+  else if (p->insn == p->first)\n+    return;\n+  /* If this insn sets / clobbers a register that feeds one of the insns\n+     already in the list, this insn has to stay too.  */\n+  else if (reg_mentioned_p (dest, PATTERN (p->first))\n+\t   || reg_used_between_p (dest, p->first, p->insn)\n+\t   /* Likewise if this insn depends on a register set by a previous\n+\t      insn in the list.  */\n+\t   || (GET_CODE (set) == SET\n+\t       && (modified_in_p (SET_SRC (set), p->first)\n+\t\t   || modified_between_p (SET_SRC (set), p->first, p->insn))))\n+    p->must_stay = true;\n+}\n+\n /* Emit code to perform a series of operations on a multi-word quantity, one\n    word at a time.\n \n@@ -2988,8 +3021,8 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n      these from the list.  */\n   for (insn = insns; insn; insn = next)\n     {\n-      rtx set = 0, note;\n-      int i;\n+      rtx note;\n+      struct no_conflict_data data;\n \n       next = NEXT_INSN (insn);\n \n@@ -3000,22 +3033,12 @@ emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n       if ((note = find_reg_note (insn, REG_RETVAL, NULL)) != NULL)\n \tremove_note (insn, note);\n \n-      if (GET_CODE (PATTERN (insn)) == SET || GET_CODE (PATTERN (insn)) == USE\n-\t  || GET_CODE (PATTERN (insn)) == CLOBBER)\n-\tset = PATTERN (insn);\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t{\n-\t  for (i = 0; i < XVECLEN (PATTERN (insn), 0); i++)\n-\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, i)) == SET)\n-\t      {\n-\t\tset = XVECEXP (PATTERN (insn), 0, i);\n-\t\tbreak;\n-\t      }\n-\t}\n-\n-      gcc_assert (set);\n-\n-      if (! reg_overlap_mentioned_p (target, SET_DEST (set)))\n+      data.target = target;\n+      data.first = insns;\n+      data.insn = insn;\n+      data.must_stay = 0;\n+      note_stores (PATTERN (insn), no_conflict_move_test, &data);\n+      if (! data.must_stay)\n \t{\n \t  if (PREV_INSN (insn))\n \t    NEXT_INSN (PREV_INSN (insn)) = next;"}]}