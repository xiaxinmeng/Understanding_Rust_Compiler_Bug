{"sha": "798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk4ZDNkMDQ1NGMzZjhkZTYxZjk1ZjlkOGZmNTNkYTM0NjVmMTlmYQ==", "commit": {"author": {"name": "Greta Yorsh", "email": "greta.yorsh@arm.com", "date": "2013-05-16T12:02:06Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2013-05-16T12:02:06Z"}, "message": "Internal memcpy using LDRD/STRD\n\n2013-05-16  Greta Yorsh  <Greta.Yorsh@arm.com>\n\ngcc/\n\n\t* config/arm/arm-protos.h (gen_movmem_ldrd_strd): New declaration.\n\t* config/arm/arm.c (next_consecutive_mem): New function.\n\t(gen_movmem_ldrd_strd): Likewise.\n\t* config/arm/arm.md (movmemqi): Update condition and code.\n\t(unaligned_loaddi, unaligned_storedi): New patterns.\n\ngcc/testsuite\n\n\t* gcc.target/arm/unaligned-memcpy-2.c: Adjust expected output.\n\t* gcc.target/arm/unaligned-memcpy-3.c: Likewise.\n\t* gcc.target/arm/unaligned-memcpy-4.c: Likewise.\n\nFrom-SVN: r198970", "tree": {"sha": "28b8ace00c5999333e50f2f7c6f89542be4caa3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28b8ace00c5999333e50f2f7c6f89542be4caa3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/comments", "author": null, "committer": null, "parents": [{"sha": "0baddc4592fcdcb85d1417e7f06c2666eb7912e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0baddc4592fcdcb85d1417e7f06c2666eb7912e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0baddc4592fcdcb85d1417e7f06c2666eb7912e8"}], "stats": {"total": 233, "additions": 226, "deletions": 7}, "files": [{"sha": "15fe33b4c16cf603d96fb061a494c5e4d46a64fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -1,3 +1,11 @@\n+2013-05-16  Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* config/arm/arm-protos.h (gen_movmem_ldrd_strd): New declaration.\n+\t* config/arm/arm.c (next_consecutive_mem): New function.\n+\t(gen_movmem_ldrd_strd): Likewise.\n+\t* config/arm/arm.md (movmemqi): Update condition and code.\n+\t(unaligned_loaddi, unaligned_storedi): New patterns.\n+\n 2013-05-16  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config.gcc: Obsolete *-*-solaris2.9*."}, {"sha": "c791341f69b80244980d0e3524ceb35c97cd0b0a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -120,6 +120,7 @@ extern bool offset_ok_for_ldrd_strd (HOST_WIDE_INT);\n extern bool operands_ok_ldrd_strd (rtx, rtx, rtx, HOST_WIDE_INT, bool, bool);\n extern bool gen_operands_ldrd_strd (rtx *, bool, bool, bool);\n extern int arm_gen_movmemqi (rtx *);\n+extern bool gen_movmem_ldrd_strd (rtx *);\n extern enum machine_mode arm_select_cc_mode (RTX_CODE, rtx, rtx);\n extern enum machine_mode arm_select_dominance_cc_mode (rtx, rtx,\n \t\t\t\t\t\t       HOST_WIDE_INT);"}, {"sha": "c4f5c6907f815daa5ac6e0b10430b30d1deee089", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -11855,6 +11855,134 @@ arm_gen_movmemqi (rtx *operands)\n   return 1;\n }\n \n+/* Helper for gen_movmem_ldrd_strd. Increase the address of memory rtx\n+by mode size.  */\n+inline static rtx\n+next_consecutive_mem (rtx mem)\n+{\n+  enum machine_mode mode = GET_MODE (mem);\n+  HOST_WIDE_INT offset = GET_MODE_SIZE (mode);\n+  rtx addr = plus_constant (Pmode, XEXP (mem, 0), offset);\n+\n+  return adjust_automodify_address (mem, mode, addr, offset);\n+}\n+\n+/* Copy using LDRD/STRD instructions whenever possible.\n+   Returns true upon success. */\n+bool\n+gen_movmem_ldrd_strd (rtx *operands)\n+{\n+  unsigned HOST_WIDE_INT len;\n+  HOST_WIDE_INT align;\n+  rtx src, dst, base;\n+  rtx reg0;\n+  bool src_aligned, dst_aligned;\n+  bool src_volatile, dst_volatile;\n+\n+  gcc_assert (CONST_INT_P (operands[2]));\n+  gcc_assert (CONST_INT_P (operands[3]));\n+\n+  len = UINTVAL (operands[2]);\n+  if (len > 64)\n+    return false;\n+\n+  /* Maximum alignment we can assume for both src and dst buffers.  */\n+  align = INTVAL (operands[3]);\n+\n+  if ((!unaligned_access) && (len >= 4) && ((align & 3) != 0))\n+    return false;\n+\n+  /* Place src and dst addresses in registers\n+     and update the corresponding mem rtx.  */\n+  dst = operands[0];\n+  dst_volatile = MEM_VOLATILE_P (dst);\n+  dst_aligned = MEM_ALIGN (dst) >= BITS_PER_WORD;\n+  base = copy_to_mode_reg (SImode, XEXP (dst, 0));\n+  dst = adjust_automodify_address (dst, VOIDmode, base, 0);\n+\n+  src = operands[1];\n+  src_volatile = MEM_VOLATILE_P (src);\n+  src_aligned = MEM_ALIGN (src) >= BITS_PER_WORD;\n+  base = copy_to_mode_reg (SImode, XEXP (src, 0));\n+  src = adjust_automodify_address (src, VOIDmode, base, 0);\n+\n+  if (!unaligned_access && !(src_aligned && dst_aligned))\n+    return false;\n+\n+  if (src_volatile || dst_volatile)\n+    return false;\n+\n+  /* If we cannot generate any LDRD/STRD, try to generate LDM/STM.  */\n+  if (!(dst_aligned || src_aligned))\n+    return arm_gen_movmemqi (operands);\n+\n+  src = adjust_address (src, DImode, 0);\n+  dst = adjust_address (dst, DImode, 0);\n+  while (len >= 8)\n+    {\n+      len -= 8;\n+      reg0 = gen_reg_rtx (DImode);\n+      if (src_aligned)\n+        emit_move_insn (reg0, src);\n+      else\n+        emit_insn (gen_unaligned_loaddi (reg0, src));\n+\n+      if (dst_aligned)\n+        emit_move_insn (dst, reg0);\n+      else\n+        emit_insn (gen_unaligned_storedi (dst, reg0));\n+\n+      src = next_consecutive_mem (src);\n+      dst = next_consecutive_mem (dst);\n+    }\n+\n+  gcc_assert (len < 8);\n+  if (len >= 4)\n+    {\n+      /* More than a word but less than a double-word to copy.  Copy a word.  */\n+      reg0 = gen_reg_rtx (SImode);\n+      src = adjust_address (src, SImode, 0);\n+      dst = adjust_address (dst, SImode, 0);\n+      if (src_aligned)\n+        emit_move_insn (reg0, src);\n+      else\n+        emit_insn (gen_unaligned_loadsi (reg0, src));\n+\n+      if (dst_aligned)\n+        emit_move_insn (dst, reg0);\n+      else\n+        emit_insn (gen_unaligned_storesi (dst, reg0));\n+\n+      src = next_consecutive_mem (src);\n+      dst = next_consecutive_mem (dst);\n+      len -= 4;\n+    }\n+\n+  if (len == 0)\n+    return true;\n+\n+  /* Copy the remaining bytes.  */\n+  if (len >= 2)\n+    {\n+      dst = adjust_address (dst, HImode, 0);\n+      src = adjust_address (src, HImode, 0);\n+      reg0 = gen_reg_rtx (SImode);\n+      emit_insn (gen_unaligned_loadhiu (reg0, src));\n+      emit_insn (gen_unaligned_storehi (dst, gen_lowpart (HImode, reg0)));\n+      src = next_consecutive_mem (src);\n+      dst = next_consecutive_mem (dst);\n+      if (len == 2)\n+        return true;\n+    }\n+\n+  dst = adjust_address (dst, QImode, 0);\n+  src = adjust_address (src, QImode, 0);\n+  reg0 = gen_reg_rtx (QImode);\n+  emit_move_insn (reg0, src);\n+  emit_move_insn (dst, reg0);\n+  return true;\n+}\n+\n /* Select a dominance comparison mode if possible for a test of the general\n    form (OP (COND_OR (X) (Y)) (const_int 0)).  We support three forms.\n    COND_OR == DOM_CC_X_AND_Y => (X && Y)"}, {"sha": "4b45c984bf43923412d62188008a97761a6732e7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -4421,6 +4421,64 @@\n    (set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"store1\")])\n \n+;; Unaligned double-word load and store.\n+;; Split after reload into two unaligned single-word accesses.\n+;; It prevents lower_subreg from splitting some other aligned\n+;; double-word accesses too early. Used for internal memcpy.\n+\n+(define_insn_and_split \"unaligned_loaddi\"\n+  [(set (match_operand:DI 0 \"s_register_operand\" \"=l,r\")\n+\t(unspec:DI [(match_operand:DI 1 \"memory_operand\" \"o,o\")]\n+\t\t   UNSPEC_UNALIGNED_LOAD))]\n+  \"unaligned_access && TARGET_32BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_UNALIGNED_LOAD))\n+   (set (match_dup 2) (unspec:SI [(match_dup 3)] UNSPEC_UNALIGNED_LOAD))]\n+  {\n+    operands[2] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[3] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+\n+    /* If the first destination register overlaps with the base address,\n+       swap the order in which the loads are emitted.  */\n+    if (reg_overlap_mentioned_p (operands[0], operands[1]))\n+      {\n+        rtx tmp = operands[1];\n+        operands[1] = operands[3];\n+        operands[3] = tmp;\n+        tmp = operands[0];\n+        operands[0] = operands[2];\n+        operands[2] = tmp;\n+      }\n+  }\n+  [(set_attr \"arch\" \"t2,any\")\n+   (set_attr \"length\" \"4,8\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"load2\")])\n+\n+(define_insn_and_split \"unaligned_storedi\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=o,o\")\n+\t(unspec:DI [(match_operand:DI 1 \"s_register_operand\" \"l,r\")]\n+\t\t   UNSPEC_UNALIGNED_STORE))]\n+  \"unaligned_access && TARGET_32BIT\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_UNALIGNED_STORE))\n+   (set (match_dup 2) (unspec:SI [(match_dup 3)] UNSPEC_UNALIGNED_STORE))]\n+  {\n+    operands[2] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[3] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\n+  [(set_attr \"arch\" \"t2,any\")\n+   (set_attr \"length\" \"4,8\")\n+   (set_attr \"predicable\" \"yes\")\n+   (set_attr \"type\" \"store2\")])\n+\n+\n (define_insn \"*extv_reg\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(sign_extract:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n@@ -7374,10 +7432,18 @@\n    (match_operand:BLK 1 \"general_operand\" \"\")\n    (match_operand:SI 2 \"const_int_operand\" \"\")\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\n-  \"TARGET_EITHER\"\n+  \"\"\n   \"\n   if (TARGET_32BIT)\n     {\n+      if (TARGET_LDRD && current_tune->prefer_ldrd_strd\n+          && !optimize_function_for_size_p (cfun))\n+        {\n+          if (gen_movmem_ldrd_strd (operands))\n+            DONE;\n+          FAIL;\n+        }\n+\n       if (arm_gen_movmemqi (operands))\n         DONE;\n       FAIL;"}, {"sha": "879b9bc1fc78e440accb4376f1ca5a61585bbae4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -1,3 +1,9 @@\n+2013-05-16  Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* gcc.target/arm/unaligned-memcpy-2.c: Adjust expected output.\n+\t* gcc.target/arm/unaligned-memcpy-3.c: Likewise.\n+\t* gcc.target/arm/unaligned-memcpy-4.c: Likewise.\n+\n 2013-05-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* gcc.dg/visibility-21.c: New."}, {"sha": "f7bc2f4f3161ee28a8cfbab0fdb4b04ae46d9ec0", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-2.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-2.c?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -14,7 +14,10 @@ void aligned_dest (char *src)\n /* Expect a multi-word store for the main part of the copy, but subword\n    loads/stores for the remainder.  */\n \n-/* { dg-final { scan-assembler-times \"stmia\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldmia\" 0 } } */\n+/* { dg-final { scan-assembler-times \"ldrd\" 0 } } */\n+/* { dg-final { scan-assembler-times \"stmia\" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */\n+/* { dg-final { scan-assembler-times \"strd\" 1 { target { arm_prefer_ldrd_strd } } } } */\n /* { dg-final { scan-assembler-times \"ldrh\" 1 } } */\n /* { dg-final { scan-assembler-times \"strh\" 1 } } */\n /* { dg-final { scan-assembler-times \"ldrb\" 1 } } */"}, {"sha": "9e2d1641bbc8b78ca154d4994d5da77a9bce2f82", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-3.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-3.c?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -14,8 +14,11 @@ void aligned_src (char *dest)\n /* Expect a multi-word load for the main part of the copy, but subword\n    loads/stores for the remainder.  */\n \n-/* { dg-final { scan-assembler-times \"ldmia\" 1 } } */\n-/* { dg-final { scan-assembler-times \"ldrh\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldmia\" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */\n+/* { dg-final { scan-assembler-times \"ldrd\" 1 { target { arm_prefer_ldrd_strd } } } } */\n+/* { dg-final { scan-assembler-times \"strd\" 0 } } */\n+/* { dg-final { scan-assembler-times \"stm\" 0 } } */\n+/* { dg-final { scan-assembler-times \"ldrh\" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */\n /* { dg-final { scan-assembler-times \"strh\" 1 } } */\n-/* { dg-final { scan-assembler-times \"ldrb\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldrb\" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */\n /* { dg-final { scan-assembler-times \"strb\" 1 } } */"}, {"sha": "4708c5101407c96a40caf59f25c9522def7b530e", "filename": "gcc/testsuite/gcc.target/arm/unaligned-memcpy-4.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/798d3d0454c3f8de61f95f9d8ff53da3465f19fa/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Funaligned-memcpy-4.c?ref=798d3d0454c3f8de61f95f9d8ff53da3465f19fa", "patch": "@@ -14,5 +14,9 @@ void aligned_both (void)\n \n /* We know both src and dest to be aligned: expect multiword loads/stores.  */\n \n-/* { dg-final { scan-assembler-times \"ldmia\" 1 } } */\n-/* { dg-final { scan-assembler-times \"stmia\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ldmia\" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */\n+/* { dg-final { scan-assembler-times \"stmia\" 1 { target { ! { arm_prefer_ldrd_strd } } } } } */\n+/* { dg-final { scan-assembler \"ldrd\" { target { arm_prefer_ldrd_strd } } } } */\n+/* { dg-final { scan-assembler-times \"ldm\" 0 { target { arm_prefer_ldrd_strd } } } } */\n+/* { dg-final { scan-assembler \"strd\" { target { arm_prefer_ldrd_strd } } } } */\n+/* { dg-final { scan-assembler-times \"stm\" 0 { target { arm_prefer_ldrd_strd } } } } */"}]}