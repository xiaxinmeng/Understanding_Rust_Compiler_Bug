{"sha": "e732b4248592cc992eddcd00d37c6457d99381e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTczMmI0MjQ4NTkyY2M5OTJlZGRjZDAwZDM3YzY0NTdkOTkzODFlNw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-09T23:21:38Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-09T23:21:38Z"}, "message": "compiler: stack allocate non-escaping makeslice\n    \n    If we're making a slice of constant size that does not need to\n    escape, allocate it on stack.\n    \n    In lower, do not create temporaries for constant size makeslice,\n    so that it is easier to detect the slice is constant size later.\n    \n    Reviewed-on: https://go-review.googlesource.com/85636\n\nFrom-SVN: r256404", "tree": {"sha": "f67e2b7279b92512a19b582799ce951bbc70d1ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f67e2b7279b92512a19b582799ce951bbc70d1ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e732b4248592cc992eddcd00d37c6457d99381e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e732b4248592cc992eddcd00d37c6457d99381e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e732b4248592cc992eddcd00d37c6457d99381e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e732b4248592cc992eddcd00d37c6457d99381e7/comments", "author": null, "committer": null, "parents": [{"sha": "9ac55031c41077b7465c64ac80587587709acbba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ac55031c41077b7465c64ac80587587709acbba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ac55031c41077b7465c64ac80587587709acbba"}], "stats": {"total": 75, "additions": 61, "deletions": 14}, "files": [{"sha": "6dbbf0f63c6e06c73ff88d39d1a7ae05aa6ceee8", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e732b4248592cc992eddcd00d37c6457d99381e7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e732b4248592cc992eddcd00d37c6457d99381e7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=e732b4248592cc992eddcd00d37c6457d99381e7", "patch": "@@ -1,4 +1,4 @@\n-91169ab206266361624236f0137668162ee8cb9b\n+b361bec95927fd6209c286906f98deeedcfe1da3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "2e0a14302591ed512a96d21589b798a1dad21f0f", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e732b4248592cc992eddcd00d37c6457d99381e7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e732b4248592cc992eddcd00d37c6457d99381e7/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=e732b4248592cc992eddcd00d37c6457d99381e7", "patch": "@@ -7496,17 +7496,17 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n \n   Expression* cap_arg = NULL;\n   bool cap_small = false;\n+  Numeric_constant nclen;\n+  Numeric_constant nccap;\n+  unsigned long vlen;\n+  unsigned long vcap;\n   if (is_slice && parg != args->end())\n     {\n       cap_arg = *parg;\n       cap_arg->determine_type(&int_context);\n       if (!this->check_int_value(cap_arg, false, &cap_small))\n \treturn Expression::make_error(this->location());\n \n-      Numeric_constant nclen;\n-      Numeric_constant nccap;\n-      unsigned long vlen;\n-      unsigned long vcap;\n       if (len_arg->numeric_constant_value(&nclen)\n \t  && cap_arg->numeric_constant_value(&nccap)\n \t  && nclen.to_unsigned_long(&vlen) == Numeric_constant::NC_UL_VALID\n@@ -7531,19 +7531,25 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n   Expression* call;\n   if (is_slice)\n     {\n-      Type* et = type->array_type()->element_type();\n-      Expression* type_arg = Expression::make_type_descriptor(et, type_loc);\n       if (cap_arg == NULL)\n \t{\n-\t  Temporary_statement* temp = Statement::make_temporary(NULL,\n-\t\t\t\t\t\t\t\tlen_arg,\n-\t\t\t\t\t\t\t\tloc);\n-\t  inserter->insert(temp);\n-\t  len_arg = Expression::make_temporary_reference(temp, loc);\n-\t  cap_arg = Expression::make_temporary_reference(temp, loc);\n-\t  cap_small = len_small;\n+          cap_small = len_small;\n+          if (len_arg->numeric_constant_value(&nclen)\n+              && nclen.to_unsigned_long(&vlen) == Numeric_constant::NC_UL_VALID)\n+            cap_arg = Expression::make_integer_ul(vlen, len_arg->type(), loc);\n+          else\n+            {\n+              Temporary_statement* temp = Statement::make_temporary(NULL,\n+                                                                    len_arg,\n+                                                                    loc);\n+              inserter->insert(temp);\n+              len_arg = Expression::make_temporary_reference(temp, loc);\n+              cap_arg = Expression::make_temporary_reference(temp, loc);\n+            }\n \t}\n \n+      Type* et = type->array_type()->element_type();\n+      Expression* type_arg = Expression::make_type_descriptor(et, type_loc);\n       Runtime::Function code = Runtime::MAKESLICE;\n       if (!len_small || !cap_small)\n \tcode = Runtime::MAKESLICE64;"}, {"sha": "a3f71a4a485a33a64784f3d153604a8b60afe8c4", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e732b4248592cc992eddcd00d37c6457d99381e7/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e732b4248592cc992eddcd00d37c6457d99381e7/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=e732b4248592cc992eddcd00d37c6457d99381e7", "patch": "@@ -64,6 +64,47 @@ Mark_address_taken::expression(Expression** pexpr)\n         }\n       aie->array()->address_taken(escapes);\n     }\n+\n+  // Rewrite non-escaping makeslice with constant size to stack allocation.\n+  Unsafe_type_conversion_expression* uce =\n+    expr->unsafe_conversion_expression();\n+  if (uce != NULL\n+      && uce->type()->is_slice_type()\n+      && Node::make_node(uce->expr())->encoding() == Node::ESCAPE_NONE\n+      && uce->expr()->call_expression() != NULL)\n+    {\n+      Call_expression* call = uce->expr()->call_expression();\n+      if (call->fn()->func_expression() != NULL\n+          && call->fn()->func_expression()->runtime_code() == Runtime::MAKESLICE)\n+        {\n+          Expression* len_arg = call->args()->at(1);\n+          Expression* cap_arg = call->args()->at(2);\n+          Numeric_constant nclen;\n+          Numeric_constant nccap;\n+          unsigned long vlen;\n+          unsigned long vcap;\n+          if (len_arg->numeric_constant_value(&nclen)\n+              && cap_arg->numeric_constant_value(&nccap)\n+              && nclen.to_unsigned_long(&vlen) == Numeric_constant::NC_UL_VALID\n+              && nccap.to_unsigned_long(&vcap) == Numeric_constant::NC_UL_VALID)\n+            {\n+              // Turn it into a slice expression of an addressable array,\n+              // which is allocated on stack.\n+              Location loc = expr->location();\n+              Type* elmt_type = expr->type()->array_type()->element_type();\n+              Expression* len_expr =\n+                Expression::make_integer_ul(vcap, cap_arg->type(), loc);\n+              Type* array_type = Type::make_array_type(elmt_type, len_expr);\n+              Expression* alloc = Expression::make_allocation(array_type, loc);\n+              alloc->allocation_expression()->set_allocate_on_stack();\n+              Expression* array = Expression::make_unary(OPERATOR_MULT, alloc, loc);\n+              Expression* zero = Expression::make_integer_ul(0, len_arg->type(), loc);\n+              Expression* slice =\n+                Expression::make_array_index(array, zero, len_arg, cap_arg, loc);\n+              *pexpr = slice;\n+            }\n+        }\n+    }\n   return TRAVERSE_CONTINUE;\n }\n "}]}