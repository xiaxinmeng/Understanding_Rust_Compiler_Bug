{"sha": "5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU5ZDZhYTRjMmZkMjQ1ODM3ZWMyNmRlMWQwMWVlOGViNzc4NmFmMw==", "commit": {"author": {"name": "Julia Koval", "email": "julia.koval@intel.com", "date": "2017-11-28T10:35:37Z"}, "committer": {"name": "Julia Koval", "email": "jkoval@gcc.gnu.org", "date": "2017-11-28T10:35:37Z"}, "message": "Remove Cilk Plus support.\n\n\t* Makefile.def (target_modules): Remove libcilkrts.\n\t* Makefile.in: Ditto.\n\t* configure: Ditto.\n\t* configure.ac: Ditto.\n\ncontrib/\n\t* contrib/gcc_update: Ditto.\n\ngcc/\n\t* Makefile.in (cilkplus.def, cilk-builtins.def, c-family/cilk.o, \n\tc-family/c-cilkplus.o, c-family/array-notation-common.o,\n\tcilk-common.o, cilk.h, cilk-common.c): Remove.\n\t* builtin-types.def\n\t(BT_FN_INT_PTR_PTR_PTR_FTYPE_BT_INT_BT_PTR_BT_PTR_BT_PTR): Remove.\n\t* builtins.c (is_builtin_name): Remove cilkplus condition.\n\t(BUILT_IN_CILK_DETACH, BUILT_IN_CILK_POP_FRAME): Remove.\n\t* builtins.def (DEF_CILK_BUILTIN_STUB, DEF_CILKPLUS_BUILTIN,\n\tcilk-builtins.def, cilkplus.def): Remove.\n\t* cif-code.def (CILK_SPAWN): Remove.\n\t* cilk-builtins.def: Delete.\n\t* cilk-common.c: Ditto.\n\t* cilk.h: Ditto.\n\t* cilkplus.def: Ditto.\n\t* config/darwin.h (fcilkplus): Delete.\n\t* cppbuiltin.c: Ditto.\n\t* doc/extend.texi: Remove cilkplus doc.\n\t* doc/generic.texi: Ditto.\n\t* doc/invoke.texi: Ditto.\n\t* doc/passes.texi: Ditto.\n\t* gcc.c (fcilkplus): Remove.\n\t* gengtype.c (cilk.h): Remove.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Remove cilkplus support.\n\t* gimple.h (GF_OMP_FOR_KIND_CILKFOR, GF_OMP_FOR_KIND_CILKSIMD): Remove.\n\t* gimplify.c (gimplify_return_expr, maybe_fold_stmt,\n\tgimplify_call_expr, is_gimple_stmt, gimplify_modify_expr,\n\tgimplify_scan_omp_clauses, gimplify_adjust_omp_clauses,\n\tgimplify_omp_for, gimplify_expr): Remove cilkplus conditions.\n\t* ipa-fnsummary.c (ipa_dump_fn_summary, compute_fn_summary,\n\tinline_read_section): Ditto.\n\t* ipa-inline-analysis.c (cilk.h): Remove.\n\t* ira.c (ira_setup_eliminable_regset): Remove cilkplus support.\n\t* lto-wrapper.c (merge_and_complain, append_compiler_options,\n\tappend_linker_options): Remove condition for fcilkplus.\n\t* lto/lto-lang.c (cilk.h): Remove.\n\t(lto_init): Remove condition for fcilkplus.\n\t* omp-expand.c (expand_cilk_for_call): Delete.\n\t(expand_omp_taskreg, expand_omp_for_static_chunk,\n\texpand_omp_for): Remove cilkplus\n\tconditions.\n\t(expand_cilk_for): Delete.\n\t* omp-general.c (omp_extract_for_data): Remove cilkplus support.\n\t* omp-low.c (scan_sharing_clauses, create_omp_child_function,\n\texecute_lower_omp, diagnose_sb_0): Ditto.\n\t* omp-simd-clone.c (simd_clone_clauses_extract): Ditto.\n\t* tree-core.h (OMP_CLAUSE__CILK_FOR_COUNT_): Delete.\n\t* tree-nested.c: Ditto.\n\t* tree-pretty-print.c (dump_omp_clause): Remove cilkplus support.\n\t(dump_generic_node): Ditto.\n\t* tree.c (OMP_CLAUSE__CILK_FOR_COUNT_): Delete.\n\t* tree.def (cilk_simd, cilk_for, cilk_spawn_stmt,\n\tcilk_sync_stmt): Delete.\n\t* tree.h (CILK_SPAWN_FN, EXPR_CILK_SPAWN): Delete.\n\ngcc/c-family/\n\t* array-notation-common.c: Delete.\n\t* c-cilkplus.c: Ditto.\n\t* c-common.c (_Cilk_spawn, _Cilk_sync, _Cilk_for): Remove.\n\t* c-common.def (ARRAY_NOTATION_REF): Remove.\n\t* c-common.h (RID_CILK_SPAWN, build_array_notation_expr,\n\tbuild_array_notation_ref, C_ORT_CILK, c_check_cilk_loop,\n\tc_validate_cilk_plus_loop, cilkplus_an_parts,\n\tcilk_ignorable_spawn_rhs_op,\n\tcilk_recognize_spawn): Remove.\n\t* c-gimplify.c (CILK_SPAWN_STMT): Remove.\n\t* c-omp.c: Remove CILK_SIMD check.\n\t* c-pragma.c: Ditto.\n\t* c-pragma.h: Remove CILK related pragmas.\n\t* c-pretty-print.c (c_pretty_printer::postfix_expression): Remove\n\tARRAY_NOTATION_REF condition.\n\t(c_pretty_printer::expression): Ditto.\n\t* c.opt (fcilkplus): Remove.\n\t* cilk.c: Delete.\n\ngcc/c/\n\t* Make-lang.in (c/c-array-notation.o): Remove.\n\t* c-array-notation.c: Delete.\n\t* c-decl.c: Remove cilkplus condition.\n\t* c-parser.c (c_parser_cilk_simd, c_parser_cilk_for,\n\tc_parser_cilk_verify_simd, c_parser_array_notation,\n\tc_parser_cilk_clause_vectorlength, c_parser_cilk_grainsize,\n\tc_parser_cilk_simd_fn_vector_attrs,\n\tc_finish_cilk_simd_fn_tokens): Delete.\n\t(c_parser_declaration_or_fndef): Remove cilkplus condition.\n\t(c_parser_direct_declarator_inner): Ditto.\n\t(CILK_SIMD_FN_CLAUSE_MASK): Delete.\n\t(c_parser_attributes, c_parser_compound_statement,\n\tc_parser_statement_after_labels, c_parser_if_statement,\n\tc_parser_switch_statement, c_parser_while_statement,\n\tc_parser_do_statement, c_parser_for_statement,\n\tc_parser_unary_expression, c_parser_postfix_expression,\n\tc_parser_postfix_expression_after_primary,\n\tc_parser_pragma, c_parser_omp_clause_name, c_parser_omp_all_clauses,\n\tc_parser_omp_for_loop,\n\tc_finish_omp_declare_simd): Remove cilkplus support.\n\t* c-typeck.c (build_array_ref, build_function_call_vec,\n\tconvert_arguments, lvalue_p, build_compound_expr, c_finish_return,\n\tc_finish_if_stmt, c_finish_loop,\n\tbuild_binary_op): Remove cilkplus support.\n\t\ngcc/cp/\n\t* Make-lang.in (cp/cp-array-notation.o, cp/cp-cilkplus.o): Delete.\n\t* call.c (convert_for_arg_passing, build_cxx_call): Remove cilkplus.\n\t* constexpr.c (potential_constant_expression_1): Ditto.\n\t* cp-array-notation.c: Delete.\n\t* cp-cilkplus.c: Ditto.\n\t* cp-cilkplus.h: Ditto.\n\t* cp-gimplify.c (cp_gimplify_expr, cp_fold_r, cp_genericize): Remove\n\tcilkplus condition.\n\t* cp-objcp-common.c (ARRAY_NOTATION_REF): Delete.\n\t* cp-tree.h (cilkplus_an_triplet_types_ok_p): Delete.\n\t* decl.c (grokfndecl, finish_function): Remove cilkplus condition.\n\t* error.c (dump_decl, dump_expr): Remove ARRAY_NOTATION_REF condition.\n\t* lambda.c (cp-cilkplus.h): Remove.\n\t* parser.c (cp_parser_cilk_simd, cp_parser_cilk_for,\n\tcp_parser_cilk_simd_vectorlength): Delete.\n\t(cp_debug_parser, cp_parser_ctor_initializer_opt_and_function_body,\n\tcp_parser_postfix_expression, cp_parser_postfix_open_square_expression,\n\tcp_parser_statement, cp_parser_jump_statement,\n\tcp_parser_direct_declarator,\n\tcp_parser_late_return_type_opt, cp_parser_gnu_attribute_list,\n\tcp_parser_omp_clause_name, cp_parser_omp_clause_aligned,\n\tcp_parser_omp_clause_linear, cp_parser_omp_all_clauses,\n\tcp_parser_omp_flush, cp_parser_omp_for_cond, cp_parser_omp_for_incr,\n\tcp_parser_omp_for_loop_init, cp_parser_omp_for_loop,\n\tcp_parser_omp_declare_simd): Remove cilkplus support.\n\t(CILK_SIMD_FN_CLAUSE_MASK, cp_parser_late_parsing_cilk_simd_fn_info,\n\tcp_parser_cilk_grainsize): Remove.\n\t(cp_parser_pragma, c_parse_file): Remove cilkplus support.\n\t(cp_parser_cilk_simd_vectorlength, cp_parser_cilk_simd_linear,\n\tcp_parser_cilk_simd_clause_name, cp_parser_cilk_simd_all_clauses,\n\tcp_parser_cilk_simd, cp_parser_cilk_for): Remove.\n\t* parser.h (IN_CILK_SIMD_FOR, IN_CILK_SPAWN): Remove.\n\t* pt.c (tsubst_attribute, tsubst_expr, tsubst_copy_and_build): Remove\n\tcilkplus support.\n\t* semantics.c (finish_goto_stmt, begin_while_stmt, finish_do_body,\n\tfinish_init_stmt, finish_switch_cond, simplify_aggr_init_expr,\n\tfinish_omp_clauses, finish_omp_clauses,\n\tfinish_omp_for): Remove cilkplus support.\n\t* tree.c (lvalue_kind): Remove ARRAY_NOTATION_REF conditon.\n\t* typeck.c (cp_build_array_ref, cp_build_compound_expr,\n\tcheck_return_expr): Remove cilkplus support.\n\ngcc/testsuite/\n\t* c-c++-common/attr-simd-3.c: Delete.\n\t* c-c++-common/cilk-plus/AN/an-if.c: Delete.\n\t* c-c++-common/cilk-plus/AN/array_test1.c: Delete.\n\t* c-c++-common/cilk-plus/AN/array_test2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/array_test_ND.c: Delete.\n\t* c-c++-common/cilk-plus/AN/builtin_fn_custom.c: Delete.\n\t* c-c++-common/cilk-plus/AN/builtin_fn_mutating.c: Delete.\n\t* c-c++-common/cilk-plus/AN/builtin_func_double.c: Delete.\n\t* c-c++-common/cilk-plus/AN/builtin_func_double2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/comma_exp.c: Delete.\n\t* c-c++-common/cilk-plus/AN/conditional.c: Delete.\n\t* c-c++-common/cilk-plus/AN/decl-ptr-colon.c: Delete.\n\t* c-c++-common/cilk-plus/AN/dimensionless-arrays.c: Delete.\n\t* c-c++-common/cilk-plus/AN/exec-once.c: Delete.\n\t* c-c++-common/cilk-plus/AN/exec-once2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/fn_ptr-2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/fn_ptr.c: Delete.\n\t* c-c++-common/cilk-plus/AN/fp_triplet_values.c: Delete.\n\t* c-c++-common/cilk-plus/AN/gather-scatter-errors.c: Delete.\n\t* c-c++-common/cilk-plus/AN/gather_scatter.c: Delete.\n\t* c-c++-common/cilk-plus/AN/if_test.c: Delete.\n\t* c-c++-common/cilk-plus/AN/if_test_errors.c: Delete.\n\t* c-c++-common/cilk-plus/AN/misc.c: Delete.\n\t* c-c++-common/cilk-plus/AN/n-ptr-test.c: Delete.\n\t* c-c++-common/cilk-plus/AN/parser_errors.c: Delete.\n\t* c-c++-common/cilk-plus/AN/parser_errors2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/parser_errors3.c: Delete.\n\t* c-c++-common/cilk-plus/AN/parser_errors4.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr57457-2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr57457.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr57490.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr57541-2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr57541.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr57577.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr58942.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr61191.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr61455-2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr61455.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr61962.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr61963.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr62008.c: Delete.\n\t* c-c++-common/cilk-plus/AN/pr63884.c: Delete.\n\t* c-c++-common/cilk-plus/AN/rank_mismatch.c: Delete.\n\t* c-c++-common/cilk-plus/AN/rank_mismatch2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/rank_mismatch3.c: Delete.\n\t* c-c++-common/cilk-plus/AN/sec_implicit.c: Delete.\n\t* c-c++-common/cilk-plus/AN/sec_implicit2.c: Delete.\n\t* c-c++-common/cilk-plus/AN/sec_implicit_ex.c: Delete.\n\t* c-c++-common/cilk-plus/AN/sec_reduce_ind_same_value.c: Delete.\n\t* c-c++-common/cilk-plus/AN/sec_reduce_max_min_ind.c: Delete.\n\t* c-c++-common/cilk-plus/AN/sec_reduce_return.c: Delete.\n\t* c-c++-common/cilk-plus/AN/side-effects-1.c: Delete.\n\t* c-c++-common/cilk-plus/AN/test_builtin_return.c: Delete.\n\t* c-c++-common/cilk-plus/AN/test_sec_limits.c: Delete.\n\t* c-c++-common/cilk-plus/AN/tst_lngth.c: Delete.\n\t* c-c++-common/cilk-plus/AN/vla.c: Delete.\n\t* c-c++-common/cilk-plus/CK/Wparentheses-1.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk-for-2.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk-for-3.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk-fors.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk_for_errors.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk_for_grain.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk_for_grain_errors.c: Delete.\n\t* c-c++-common/cilk-plus/CK/cilk_for_ptr_iter.c: Delete.\n\t* c-c++-common/cilk-plus/CK/compound_cilk_spawn.c: Delete.\n\t* c-c++-common/cilk-plus/CK/concec_cilk_spawn.c: Delete.\n\t* c-c++-common/cilk-plus/CK/errors.c: Delete.\n\t* c-c++-common/cilk-plus/CK/fib.c: Delete.\n\t* c-c++-common/cilk-plus/CK/fib_init_expr_xy.c: Delete.\n\t* c-c++-common/cilk-plus/CK/fib_no_return.c: Delete.\n\t* c-c++-common/cilk-plus/CK/fib_no_sync.c: Delete.\n\t* c-c++-common/cilk-plus/CK/invalid_spawns.c: Delete.\n\t* c-c++-common/cilk-plus/CK/invalid_sync.c: Delete.c\n\t* c-c++-common/cilk-plus/CK/nested_cilk_for.c: Delete.\n\t* c-c++-common/cilk-plus/CK/no_args_error.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr59631.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr60197-2.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr60197.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr60469.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr60586.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr63307.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr69826-1.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr69826-2.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr79428-4.c: Delete.\n\t* c-c++-common/cilk-plus/CK/pr79428-7.c: Delete.\n\t* c-c++-common/cilk-plus/CK/spawn_in_return.c: Delete.\n\t* c-c++-common/cilk-plus/CK/spawnee_inline.c: Delete.\n\t* c-c++-common/cilk-plus/CK/spawner_inline.c: Delete.\n\t* c-c++-common/cilk-plus/CK/spawning_arg.c: Delete.\n\t* c-c++-common/cilk-plus/CK/steal_check.c: Delete.\n\t* c-c++-common/cilk-plus/CK/sync_wo_spawn.c: Delete.\n\t* c-c++-common/cilk-plus/CK/test__cilk.c: Delete.\n\t* c-c++-common/cilk-plus/CK/varargs_test.c: Delete.\n\t* c-c++-common/cilk-plus/PS/Wparentheses-1.c: Delete.\n\t* c-c++-common/cilk-plus/PS/body.c: Delete.\n\t* c-c++-common/cilk-plus/PS/clauses1.c: Delete.\n\t* c-c++-common/cilk-plus/PS/clauses2.c: Delete.\n\t* c-c++-common/cilk-plus/PS/clauses3.c: Delete.\n\t* c-c++-common/cilk-plus/PS/clauses4.c: Delete.\n\t* c-c++-common/cilk-plus/PS/for1.c: Delete.\n\t* c-c++-common/cilk-plus/PS/for2.c: Delete.\n\t* c-c++-common/cilk-plus/PS/for3.c: Delete.\n\t* c-c++-common/cilk-plus/PS/pr69363.c: Delete.\n\t* c-c++-common/cilk-plus/PS/reduction-1.c: Delete.\n\t* c-c++-common/cilk-plus/PS/reduction-2.c: Delete.\n\t* c-c++-common/cilk-plus/PS/reduction-3.c: Delete.\n\t* c-c++-common/cilk-plus/PS/run-1.c: Delete.\n\t* c-c++-common/cilk-plus/PS/safelen.c: Delete.\n\t* c-c++-common/cilk-plus/PS/vectorlength-2.c: Delete.\n\t* c-c++-common/cilk-plus/PS/vectorlength-3.c: Delete.\n\t* c-c++-common/cilk-plus/PS/vectorlength.c: Delete.\n\t* c-c++-common/cilk-plus/SE/ef_error.c: Delete.\n\t* c-c++-common/cilk-plus/SE/ef_error2.c: Delete.\n\t* c-c++-common/cilk-plus/SE/ef_error3.c: Delete.\n\t* c-c++-common/cilk-plus/SE/ef_test.c: Delete.\n\t* c-c++-common/cilk-plus/SE/ef_test2.c: Delete.\n\t* c-c++-common/cilk-plus/SE/vlength_errors.c: Delete.\n\t* g++.dg/cilk-plus/AN/array_function.c: Delete.\n\t* g++.dg/cilk-plus/AN/array_test1_tplt.c: Delete.\n\t* g++.dg/cilk-plus/AN/array_test2_tplt.c: Delete.\n\t* g++.dg/cilk-plus/AN/array_test_ND_tplt.c: Delete.\n\t* g++.dg/cilk-plus/AN/braced_list.c: Delete.\n\t* g++.dg/cilk-plus/AN/builtin_fn_custom_tplt.c: Delete.\n\t* g++.dg/cilk-plus/AN/builtin_fn_mutating_tplt.c: Delete.\n\t* g++.dg/cilk-plus/AN/fp_triplet_values_tplt.c: Delete.\n\t* g++.dg/cilk-plus/AN/postincr_test.c: Delete.\n\t* g++.dg/cilk-plus/AN/preincr_test.c: Delete.\n\t* g++.dg/cilk-plus/CK/catch_exc.c: Delete.\n\t* g++.dg/cilk-plus/CK/cf3.c: Delete.\n\t* g++.dg/cilk-plus/CK/cilk-for-tplt.c: Delete.\n\t* g++.dg/cilk-plus/CK/const_spawn.c: Delete.\n\t* g++.dg/cilk-plus/CK/fib-opr-overload.c: Delete.\n\t* g++.dg/cilk-plus/CK/fib-tplt.c: Delete.\n\t* g++.dg/cilk-plus/CK/for1.c: Delete.\n\t* g++.dg/cilk-plus/CK/lambda_spawns.c: Delete.\n\t* g++.dg/cilk-plus/CK/lambda_spawns_tplt.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr60586.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr66326.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr68001.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr68997.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr69024.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr69048.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr69267.c: Delete.\n\t* g++.dg/cilk-plus/CK/pr80038.c: Delete.\n\t* g++.dg/cilk-plus/CK/stl_iter.c: Delete.\n\t* g++.dg/cilk-plus/CK/stl_rev_iter.c: Delete.\n\t* g++.dg/cilk-plus/CK/stl_test.c: Delete.\n\t* g++.dg/cilk-plus/cilk-plus.exp\n\t* g++.dg/cilk-plus/ef_test.C: Delete.\n\t* g++.dg/cilk-plus/for.C: Delete.\n\t* g++.dg/cilk-plus/for2.C: Delete.\n\t* g++.dg/cilk-plus/for3.C: Delete.\n\t* g++.dg/cilk-plus/for4.C: Delete.\n\t* g++.dg/cilk-plus/pr60967.C: Delete.\n\t* g++.dg/cilk-plus/pr69028.C: Delete.\n\t* g++.dg/cilk-plus/pr70565.C: Delete.\n\t* g++.dg/pr57662.C: Delete.\n\t* gcc.dg/cilk-plus/cilk-plus.exp\n\t* gcc.dg/cilk-plus/for1.c: Delete.\n\t* gcc.dg/cilk-plus/for2.c: Delete.\n\t* gcc.dg/cilk-plus/jump-openmp.c: Delete.\n\t* gcc.dg/cilk-plus/jump.c: Delete.\n\t* gcc.dg/cilk-plus/pr69798-1.c: Delete.\n\t* gcc.dg/cilk-plus/pr69798-2.c: Delete.\n\t* gcc.dg/cilk-plus/pr78306.c: Delete.\n\t* gcc.dg/cilk-plus/pr79116.c: Delete.\n\t* gcc.dg/graphite/id-28.c: Delete.\n\t* lib/cilk-plus-dg.exp: Delete.\n\t* lib/target-supports.exp (cilkplus_runtime): Delete.\n\nCo-Authored-By: Sebastian Peryt <sebastian.peryt@intel.com>\n\nFrom-SVN: r255195", "tree": {"sha": "193e05dc5baa657f44264efe9cf165e8572a0ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/193e05dc5baa657f44264efe9cf165e8572a0ccc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/comments", "author": {"login": "vaalfreja", "id": 5216345, "node_id": "MDQ6VXNlcjUyMTYzNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5216345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vaalfreja", "html_url": "https://github.com/vaalfreja", "followers_url": "https://api.github.com/users/vaalfreja/followers", "following_url": "https://api.github.com/users/vaalfreja/following{/other_user}", "gists_url": "https://api.github.com/users/vaalfreja/gists{/gist_id}", "starred_url": "https://api.github.com/users/vaalfreja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vaalfreja/subscriptions", "organizations_url": "https://api.github.com/users/vaalfreja/orgs", "repos_url": "https://api.github.com/users/vaalfreja/repos", "events_url": "https://api.github.com/users/vaalfreja/events{/privacy}", "received_events_url": "https://api.github.com/users/vaalfreja/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1be49a38e45a80d1ee6854f262c94abeb621dfda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1be49a38e45a80d1ee6854f262c94abeb621dfda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1be49a38e45a80d1ee6854f262c94abeb621dfda"}], "stats": {"total": 83179, "additions": 473, "deletions": 82706}, "files": [{"sha": "f2365c51425c623adf758fa90534a24d6f58e095", "filename": "ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,11 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+\t    Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* Makefile.def (target_modules): Remove libcilkrts.\n+\t* Makefile.in: Ditto.\n+\t* configure: Ditto.\n+\t* configure.ac: Ditto.\n+\n 2017-11-28  Julia Koval  <julia.koval@intel.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "4b9f757f58652f3284c67371e39c9225ca594a96", "filename": "Makefile.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -144,8 +144,6 @@ target_modules = { module= libvtv;\n \t\t   bootstrap=true;\n \t\t   lib_path=.libs;\n \t\t   raw_cxx=true; };\n-target_modules = { module= libcilkrts;\n-\t\t   lib_path=.libs; };\n target_modules = { module= liboffloadmic;\n \t\t   lib_path=.libs;\n \t\t   extra_configure_flags='@extra_liboffloadmic_configure_flags@'; };\n@@ -533,7 +531,6 @@ dependencies = { module=all-m4; on=all-build-texinfo; };\n // on libgcc and newlib/libgloss.\n lang_env_dependencies = { module=libitm; cxx=true; };\n lang_env_dependencies = { module=libffi; cxx=true; };\n-lang_env_dependencies = { module=libcilkrts; cxx=true; };\n lang_env_dependencies = { module=liboffloadmic; cxx=true; };\n lang_env_dependencies = { module=newlib; no_c=true; };\n lang_env_dependencies = { module=libgloss; no_c=true; };\n@@ -567,8 +564,6 @@ dependencies = { module=install-target-libsanitizer; on=install-target-libstdc++\n dependencies = { module=install-target-libsanitizer; on=install-target-libgcc; };\n dependencies = { module=install-target-libvtv; on=install-target-libstdc++-v3; };\n dependencies = { module=install-target-libvtv; on=install-target-libgcc; };\n-dependencies = { module=install-target-libcilkrts; on=install-target-libstdc++-v3; };\n-dependencies = { module=install-target-libcilkrts; on=install-target-libgcc; };\n dependencies = { module=install-target-liboffloadmic; on=install-target-libstdc++-v3; };\n dependencies = { module=install-target-liboffloadmic; on=install-target-libgcc; };\n dependencies = { module=install-target-libitm; on=install-target-libgcc; };"}, {"sha": "38774f542a641389332121e702110015d9592721", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 489, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -612,7 +612,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libmpx)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libcilkrts)$(TARGET_LIB_PATH_liboffloadmic)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libmpx)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_liboffloadmic)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -630,10 +630,6 @@ TARGET_LIB_PATH_libmpx = $$r/$(TARGET_SUBDIR)/libmpx/.libs:\n TARGET_LIB_PATH_libvtv = $$r/$(TARGET_SUBDIR)/libvtv/.libs:\n @endif target-libvtv\n \n-@if target-libcilkrts\n-TARGET_LIB_PATH_libcilkrts = $$r/$(TARGET_SUBDIR)/libcilkrts/.libs:\n-@endif target-libcilkrts\n-\n @if target-liboffloadmic\n TARGET_LIB_PATH_liboffloadmic = $$r/$(TARGET_SUBDIR)/liboffloadmic/.libs:\n @endif target-liboffloadmic\n@@ -997,7 +993,6 @@ configure-target:  \\\n     maybe-configure-target-libsanitizer \\\n     maybe-configure-target-libmpx \\\n     maybe-configure-target-libvtv \\\n-    maybe-configure-target-libcilkrts \\\n     maybe-configure-target-liboffloadmic \\\n     maybe-configure-target-libssp \\\n     maybe-configure-target-newlib \\\n@@ -1161,7 +1156,6 @@ all-target: maybe-all-target-libmpx\n @if target-libvtv-no-bootstrap\n all-target: maybe-all-target-libvtv\n @endif target-libvtv-no-bootstrap\n-all-target: maybe-all-target-libcilkrts\n all-target: maybe-all-target-liboffloadmic\n all-target: maybe-all-target-libssp\n all-target: maybe-all-target-newlib\n@@ -1256,7 +1250,6 @@ info-target: maybe-info-target-libstdc++-v3\n info-target: maybe-info-target-libsanitizer\n info-target: maybe-info-target-libmpx\n info-target: maybe-info-target-libvtv\n-info-target: maybe-info-target-libcilkrts\n info-target: maybe-info-target-liboffloadmic\n info-target: maybe-info-target-libssp\n info-target: maybe-info-target-newlib\n@@ -1342,7 +1335,6 @@ dvi-target: maybe-dvi-target-libstdc++-v3\n dvi-target: maybe-dvi-target-libsanitizer\n dvi-target: maybe-dvi-target-libmpx\n dvi-target: maybe-dvi-target-libvtv\n-dvi-target: maybe-dvi-target-libcilkrts\n dvi-target: maybe-dvi-target-liboffloadmic\n dvi-target: maybe-dvi-target-libssp\n dvi-target: maybe-dvi-target-newlib\n@@ -1428,7 +1420,6 @@ pdf-target: maybe-pdf-target-libstdc++-v3\n pdf-target: maybe-pdf-target-libsanitizer\n pdf-target: maybe-pdf-target-libmpx\n pdf-target: maybe-pdf-target-libvtv\n-pdf-target: maybe-pdf-target-libcilkrts\n pdf-target: maybe-pdf-target-liboffloadmic\n pdf-target: maybe-pdf-target-libssp\n pdf-target: maybe-pdf-target-newlib\n@@ -1514,7 +1505,6 @@ html-target: maybe-html-target-libstdc++-v3\n html-target: maybe-html-target-libsanitizer\n html-target: maybe-html-target-libmpx\n html-target: maybe-html-target-libvtv\n-html-target: maybe-html-target-libcilkrts\n html-target: maybe-html-target-liboffloadmic\n html-target: maybe-html-target-libssp\n html-target: maybe-html-target-newlib\n@@ -1600,7 +1590,6 @@ TAGS-target: maybe-TAGS-target-libstdc++-v3\n TAGS-target: maybe-TAGS-target-libsanitizer\n TAGS-target: maybe-TAGS-target-libmpx\n TAGS-target: maybe-TAGS-target-libvtv\n-TAGS-target: maybe-TAGS-target-libcilkrts\n TAGS-target: maybe-TAGS-target-liboffloadmic\n TAGS-target: maybe-TAGS-target-libssp\n TAGS-target: maybe-TAGS-target-newlib\n@@ -1686,7 +1675,6 @@ install-info-target: maybe-install-info-target-libstdc++-v3\n install-info-target: maybe-install-info-target-libsanitizer\n install-info-target: maybe-install-info-target-libmpx\n install-info-target: maybe-install-info-target-libvtv\n-install-info-target: maybe-install-info-target-libcilkrts\n install-info-target: maybe-install-info-target-liboffloadmic\n install-info-target: maybe-install-info-target-libssp\n install-info-target: maybe-install-info-target-newlib\n@@ -1772,7 +1760,6 @@ install-pdf-target: maybe-install-pdf-target-libstdc++-v3\n install-pdf-target: maybe-install-pdf-target-libsanitizer\n install-pdf-target: maybe-install-pdf-target-libmpx\n install-pdf-target: maybe-install-pdf-target-libvtv\n-install-pdf-target: maybe-install-pdf-target-libcilkrts\n install-pdf-target: maybe-install-pdf-target-liboffloadmic\n install-pdf-target: maybe-install-pdf-target-libssp\n install-pdf-target: maybe-install-pdf-target-newlib\n@@ -1858,7 +1845,6 @@ install-html-target: maybe-install-html-target-libstdc++-v3\n install-html-target: maybe-install-html-target-libsanitizer\n install-html-target: maybe-install-html-target-libmpx\n install-html-target: maybe-install-html-target-libvtv\n-install-html-target: maybe-install-html-target-libcilkrts\n install-html-target: maybe-install-html-target-liboffloadmic\n install-html-target: maybe-install-html-target-libssp\n install-html-target: maybe-install-html-target-newlib\n@@ -1944,7 +1930,6 @@ installcheck-target: maybe-installcheck-target-libstdc++-v3\n installcheck-target: maybe-installcheck-target-libsanitizer\n installcheck-target: maybe-installcheck-target-libmpx\n installcheck-target: maybe-installcheck-target-libvtv\n-installcheck-target: maybe-installcheck-target-libcilkrts\n installcheck-target: maybe-installcheck-target-liboffloadmic\n installcheck-target: maybe-installcheck-target-libssp\n installcheck-target: maybe-installcheck-target-newlib\n@@ -2030,7 +2015,6 @@ mostlyclean-target: maybe-mostlyclean-target-libstdc++-v3\n mostlyclean-target: maybe-mostlyclean-target-libsanitizer\n mostlyclean-target: maybe-mostlyclean-target-libmpx\n mostlyclean-target: maybe-mostlyclean-target-libvtv\n-mostlyclean-target: maybe-mostlyclean-target-libcilkrts\n mostlyclean-target: maybe-mostlyclean-target-liboffloadmic\n mostlyclean-target: maybe-mostlyclean-target-libssp\n mostlyclean-target: maybe-mostlyclean-target-newlib\n@@ -2116,7 +2100,6 @@ clean-target: maybe-clean-target-libstdc++-v3\n clean-target: maybe-clean-target-libsanitizer\n clean-target: maybe-clean-target-libmpx\n clean-target: maybe-clean-target-libvtv\n-clean-target: maybe-clean-target-libcilkrts\n clean-target: maybe-clean-target-liboffloadmic\n clean-target: maybe-clean-target-libssp\n clean-target: maybe-clean-target-newlib\n@@ -2202,7 +2185,6 @@ distclean-target: maybe-distclean-target-libstdc++-v3\n distclean-target: maybe-distclean-target-libsanitizer\n distclean-target: maybe-distclean-target-libmpx\n distclean-target: maybe-distclean-target-libvtv\n-distclean-target: maybe-distclean-target-libcilkrts\n distclean-target: maybe-distclean-target-liboffloadmic\n distclean-target: maybe-distclean-target-libssp\n distclean-target: maybe-distclean-target-newlib\n@@ -2288,7 +2270,6 @@ maintainer-clean-target: maybe-maintainer-clean-target-libstdc++-v3\n maintainer-clean-target: maybe-maintainer-clean-target-libsanitizer\n maintainer-clean-target: maybe-maintainer-clean-target-libmpx\n maintainer-clean-target: maybe-maintainer-clean-target-libvtv\n-maintainer-clean-target: maybe-maintainer-clean-target-libcilkrts\n maintainer-clean-target: maybe-maintainer-clean-target-liboffloadmic\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n maintainer-clean-target: maybe-maintainer-clean-target-newlib\n@@ -2430,7 +2411,6 @@ check-target:  \\\n     maybe-check-target-libsanitizer \\\n     maybe-check-target-libmpx \\\n     maybe-check-target-libvtv \\\n-    maybe-check-target-libcilkrts \\\n     maybe-check-target-liboffloadmic \\\n     maybe-check-target-libssp \\\n     maybe-check-target-newlib \\\n@@ -2612,7 +2592,6 @@ install-target:  \\\n     maybe-install-target-libsanitizer \\\n     maybe-install-target-libmpx \\\n     maybe-install-target-libvtv \\\n-    maybe-install-target-libcilkrts \\\n     maybe-install-target-liboffloadmic \\\n     maybe-install-target-libssp \\\n     maybe-install-target-newlib \\\n@@ -2718,7 +2697,6 @@ install-strip-target:  \\\n     maybe-install-strip-target-libsanitizer \\\n     maybe-install-strip-target-libmpx \\\n     maybe-install-strip-target-libvtv \\\n-    maybe-install-strip-target-libcilkrts \\\n     maybe-install-strip-target-liboffloadmic \\\n     maybe-install-strip-target-libssp \\\n     maybe-install-strip-target-newlib \\\n@@ -42863,464 +42841,6 @@ maintainer-clean-target-libvtv:\n \n \n \n-.PHONY: configure-target-libcilkrts maybe-configure-target-libcilkrts\n-maybe-configure-target-libcilkrts:\n-@if gcc-bootstrap\n-configure-target-libcilkrts: stage_current\n-@endif gcc-bootstrap\n-@if target-libcilkrts\n-maybe-configure-target-libcilkrts: configure-target-libcilkrts\n-configure-target-libcilkrts: \n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\techo \"Checking multilib configuration for libcilkrts...\"; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts; \\\n-\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libcilkrts/multilib.tmp 2> /dev/null; \\\n-\tif test -r $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n-\t  if cmp -s $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; then \\\n-\t    rm -f $(TARGET_SUBDIR)/libcilkrts/multilib.tmp; \\\n-\t  else \\\n-\t    rm -f $(TARGET_SUBDIR)/libcilkrts/Makefile; \\\n-\t    mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n-\t  fi; \\\n-\telse \\\n-\t  mv $(TARGET_SUBDIR)/libcilkrts/multilib.tmp $(TARGET_SUBDIR)/libcilkrts/multilib.out; \\\n-\tfi; \\\n-\ttest ! -f $(TARGET_SUBDIR)/libcilkrts/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libcilkrts; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\techo Configuring in $(TARGET_SUBDIR)/libcilkrts; \\\n-\tcd \"$(TARGET_SUBDIR)/libcilkrts\" || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(TARGET_SUBDIR)/libcilkrts/ | \\\n-\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n-\tesac; \\\n-\tmodule_srcdir=libcilkrts; \\\n-\trm -f no-such-file || : ; \\\n-\tCONFIG_SITE=no-such-file $(SHELL) \\\n-\t  $$s/$$module_srcdir/configure \\\n-\t  --srcdir=$${topdir}/$$module_srcdir \\\n-\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n-\t  --target=${target_alias}  \\\n-\t  || exit 1\n-@endif target-libcilkrts\n-\n-\n-\n-\n-\n-.PHONY: all-target-libcilkrts maybe-all-target-libcilkrts\n-maybe-all-target-libcilkrts:\n-@if gcc-bootstrap\n-all-target-libcilkrts: stage_current\n-@endif gcc-bootstrap\n-@if target-libcilkrts\n-TARGET-target-libcilkrts=all\n-maybe-all-target-libcilkrts: all-target-libcilkrts\n-all-target-libcilkrts: configure-target-libcilkrts\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n-\t\t$(TARGET-target-libcilkrts))\n-@endif target-libcilkrts\n-\n-\n-\n-\n-\n-.PHONY: check-target-libcilkrts maybe-check-target-libcilkrts\n-maybe-check-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-check-target-libcilkrts: check-target-libcilkrts\n-\n-check-target-libcilkrts:\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n-\n-@endif target-libcilkrts\n-\n-.PHONY: install-target-libcilkrts maybe-install-target-libcilkrts\n-maybe-install-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-install-target-libcilkrts: install-target-libcilkrts\n-\n-install-target-libcilkrts: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n-\n-@endif target-libcilkrts\n-\n-.PHONY: install-strip-target-libcilkrts maybe-install-strip-target-libcilkrts\n-maybe-install-strip-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-install-strip-target-libcilkrts: install-strip-target-libcilkrts\n-\n-install-strip-target-libcilkrts: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n-\n-@endif target-libcilkrts\n-\n-# Other targets (info, dvi, pdf, etc.)\n-\n-.PHONY: maybe-info-target-libcilkrts info-target-libcilkrts\n-maybe-info-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-info-target-libcilkrts: info-target-libcilkrts\n-\n-info-target-libcilkrts: \\\n-    configure-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing info in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           info) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-dvi-target-libcilkrts dvi-target-libcilkrts\n-maybe-dvi-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-dvi-target-libcilkrts: dvi-target-libcilkrts\n-\n-dvi-target-libcilkrts: \\\n-    configure-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing dvi in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           dvi) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-pdf-target-libcilkrts pdf-target-libcilkrts\n-maybe-pdf-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-pdf-target-libcilkrts: pdf-target-libcilkrts\n-\n-pdf-target-libcilkrts: \\\n-    configure-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing pdf in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           pdf) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-html-target-libcilkrts html-target-libcilkrts\n-maybe-html-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-html-target-libcilkrts: html-target-libcilkrts\n-\n-html-target-libcilkrts: \\\n-    configure-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing html in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           html) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-TAGS-target-libcilkrts TAGS-target-libcilkrts\n-maybe-TAGS-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-TAGS-target-libcilkrts: TAGS-target-libcilkrts\n-\n-TAGS-target-libcilkrts: \\\n-    configure-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing TAGS in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           TAGS) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-install-info-target-libcilkrts install-info-target-libcilkrts\n-maybe-install-info-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-install-info-target-libcilkrts: install-info-target-libcilkrts\n-\n-install-info-target-libcilkrts: \\\n-    configure-target-libcilkrts \\\n-    info-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-info in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-info) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-install-pdf-target-libcilkrts install-pdf-target-libcilkrts\n-maybe-install-pdf-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-install-pdf-target-libcilkrts: install-pdf-target-libcilkrts\n-\n-install-pdf-target-libcilkrts: \\\n-    configure-target-libcilkrts \\\n-    pdf-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-pdf) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-install-html-target-libcilkrts install-html-target-libcilkrts\n-maybe-install-html-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-install-html-target-libcilkrts: install-html-target-libcilkrts\n-\n-install-html-target-libcilkrts: \\\n-    configure-target-libcilkrts \\\n-    html-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-html in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-html) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-installcheck-target-libcilkrts installcheck-target-libcilkrts\n-maybe-installcheck-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-installcheck-target-libcilkrts: installcheck-target-libcilkrts\n-\n-installcheck-target-libcilkrts: \\\n-    configure-target-libcilkrts \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing installcheck in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           installcheck) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-mostlyclean-target-libcilkrts mostlyclean-target-libcilkrts\n-maybe-mostlyclean-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-mostlyclean-target-libcilkrts: mostlyclean-target-libcilkrts\n-\n-mostlyclean-target-libcilkrts: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           mostlyclean) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-clean-target-libcilkrts clean-target-libcilkrts\n-maybe-clean-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-clean-target-libcilkrts: clean-target-libcilkrts\n-\n-clean-target-libcilkrts: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing clean in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           clean) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-distclean-target-libcilkrts distclean-target-libcilkrts\n-maybe-distclean-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-distclean-target-libcilkrts: distclean-target-libcilkrts\n-\n-distclean-target-libcilkrts: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing distclean in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           distclean) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-.PHONY: maybe-maintainer-clean-target-libcilkrts maintainer-clean-target-libcilkrts\n-maybe-maintainer-clean-target-libcilkrts:\n-@if target-libcilkrts\n-maybe-maintainer-clean-target-libcilkrts: maintainer-clean-target-libcilkrts\n-\n-maintainer-clean-target-libcilkrts: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libcilkrts/Makefile ] || exit 0; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libcilkrts\"; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libcilkrts && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           maintainer-clean) \\\n-\t  || exit 1\n-\n-@endif target-libcilkrts\n-\n-\n-\n-\n-\n .PHONY: configure-target-liboffloadmic maybe-configure-target-liboffloadmic\n maybe-configure-target-liboffloadmic:\n @if gcc-bootstrap\n@@ -57245,7 +56765,6 @@ configure-stagetrain-target-libvtv: maybe-all-stagetrain-gcc\n configure-stagefeedback-target-libvtv: maybe-all-stagefeedback-gcc\n configure-stageautoprofile-target-libvtv: maybe-all-stageautoprofile-gcc\n configure-stageautofeedback-target-libvtv: maybe-all-stageautofeedback-gcc\n-configure-target-libcilkrts: stage_last\n configure-target-liboffloadmic: stage_last\n configure-target-libssp: stage_last\n configure-target-newlib: stage_last\n@@ -57289,7 +56808,6 @@ configure-target-libstdc++-v3: maybe-all-gcc\n configure-target-libsanitizer: maybe-all-gcc\n configure-target-libmpx: maybe-all-gcc\n configure-target-libvtv: maybe-all-gcc\n-configure-target-libcilkrts: maybe-all-gcc\n configure-target-liboffloadmic: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n configure-target-newlib: maybe-all-gcc\n@@ -58469,8 +57987,6 @@ install-target-libsanitizer: maybe-install-target-libstdc++-v3\n install-target-libsanitizer: maybe-install-target-libgcc\n install-target-libvtv: maybe-install-target-libstdc++-v3\n install-target-libvtv: maybe-install-target-libgcc\n-install-target-libcilkrts: maybe-install-target-libstdc++-v3\n-install-target-libcilkrts: maybe-install-target-libgcc\n install-target-liboffloadmic: maybe-install-target-libstdc++-v3\n install-target-liboffloadmic: maybe-install-target-libgcc\n install-target-libitm: maybe-install-target-libgcc\n@@ -58542,7 +58058,6 @@ configure-target-libstdc++-v3: maybe-all-target-libgcc\n configure-target-libsanitizer: maybe-all-target-libgcc\n configure-target-libmpx: maybe-all-target-libgcc\n configure-target-libvtv: maybe-all-target-libgcc\n-configure-target-libcilkrts: maybe-all-target-libgcc\n configure-target-liboffloadmic: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n configure-target-newlib: maybe-all-target-libgcc\n@@ -58573,9 +58088,6 @@ configure-target-libmpx: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libvtv: maybe-all-target-newlib maybe-all-target-libgloss\n \n-configure-target-libcilkrts: maybe-all-target-newlib maybe-all-target-libgloss\n-configure-target-libcilkrts: maybe-all-target-libstdc++-v3\n-\n configure-target-liboffloadmic: maybe-all-target-newlib maybe-all-target-libgloss\n configure-target-liboffloadmic: maybe-all-target-libstdc++-v3\n "}, {"sha": "1e00f01c3842a6581264c219bd2fee65f40356c9", "filename": "configure", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -2751,7 +2751,6 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n-\t\ttarget-libcilkrts \\\n \t\ttarget-liboffloadmic \\\n \t\ttarget-libhsail-rt \\\n \t\ttarget-libatomic \\\n@@ -3188,25 +3187,6 @@ $as_echo \"yes\" >&6; }\n     fi\n fi\n \n-# Disable libcilkrts on unsupported systems.\n-if test -d ${srcdir}/libcilkrts; then\n-    if test x$enable_libcilkrts = x; then\n-\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for libcilkrts support\" >&5\n-$as_echo_n \"checking for libcilkrts support... \" >&6; }\n-\tif (srcdir=${srcdir}/libcilkrts; \\\n-\t\t. ${srcdir}/configure.tgt; \\\n-\t\ttest -n \"$UNSUPPORTED\")\n-\tthen\n-\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n-$as_echo \"no\" >&6; }\n-\t    noconfigdirs=\"$noconfigdirs target-libcilkrts\"\n-\telse\n-\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n-$as_echo \"yes\" >&6; }\n-\tfi\n-    fi\n-fi\n-\n # Disable liboffloadmic on unsupported systems.\n if test -d ${srcdir}/liboffloadmic; then\n     if test x$enable_liboffloadmic != xno; then\n@@ -6496,19 +6476,19 @@ $as_echo \"using paths configured with --with-target-bdw-gc options\" >&6; }\n   fi\n esac\n \n-# Disable libcilkrts, libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n+# Disable libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*)\n-    # Disable libcilkrts, libitm, libsanitizer if we're not building libstdc++\n+    # Disable libitm, libsanitizer if we're not building libstdc++\n     case \"${noconfigdirs}\" in\n       *target-libstdc++-v3*)\n-        noconfigdirs=\"$noconfigdirs target-libcilkrts target-libitm target-libsanitizer\"\n+        noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer\"\n         ;;\n       *) ;;\n     esac\n     ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-libcilkrts target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n+    noconfigdirs=\"$noconfigdirs target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n "}, {"sha": "fbf7400c412663dd1cf813f4e837fac859a63eb6", "filename": "configure.ac", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -150,7 +150,6 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n-\t\ttarget-libcilkrts \\\n \t\ttarget-liboffloadmic \\\n \t\ttarget-libhsail-rt \\\n \t\ttarget-libatomic \\\n@@ -537,22 +536,6 @@ if test -d ${srcdir}/libatomic; then\n     fi\n fi\n \n-# Disable libcilkrts on unsupported systems.\n-if test -d ${srcdir}/libcilkrts; then\n-    if test x$enable_libcilkrts = x; then\n-\tAC_MSG_CHECKING([for libcilkrts support])\n-\tif (srcdir=${srcdir}/libcilkrts; \\\n-\t\t. ${srcdir}/configure.tgt; \\\n-\t\ttest -n \"$UNSUPPORTED\")\n-\tthen\n-\t    AC_MSG_RESULT([no])\n-\t    noconfigdirs=\"$noconfigdirs target-libcilkrts\"\n-\telse\n-\t    AC_MSG_RESULT([yes])\n-\tfi\n-    fi\n-fi\n-\n # Disable liboffloadmic on unsupported systems.\n if test -d ${srcdir}/liboffloadmic; then\n     if test x$enable_liboffloadmic != xno; then\n@@ -2156,19 +2139,19 @@ case ,${enable_languages},:${enable_objc_gc} in *,objc,*:yes|*,objc,*:auto)\n   fi\n esac\n \n-# Disable libcilkrts, libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n+# Disable libitm, libsanitizer, libvtv, liboffloadmic if we're not building C++\n case ,${enable_languages}, in\n   *,c++,*)\n-    # Disable libcilkrts, libitm, libsanitizer if we're not building libstdc++\n+    # Disable libitm, libsanitizer if we're not building libstdc++\n     case \"${noconfigdirs}\" in\n       *target-libstdc++-v3*)\n-        noconfigdirs=\"$noconfigdirs target-libcilkrts target-libitm target-libsanitizer\"\n+        noconfigdirs=\"$noconfigdirs target-libitm target-libsanitizer\"\n         ;;\n       *) ;;\n     esac\n     ;;\n   *)\n-    noconfigdirs=\"$noconfigdirs target-libcilkrts target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n+    noconfigdirs=\"$noconfigdirs target-liboffloadmic target-libitm target-libsanitizer target-libvtv\"\n     ;;\n esac\n "}, {"sha": "16c1f41f5428b2fa55cdca454954a2ef95eae748", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,8 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+            Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* contrib/gcc_update: Ditto.\n+\n 2017-11-08  Martin Liska  <mliska@suse.cz>\n \n \t* analyze_brprob.py: Fix abbreviations for SI units."}, {"sha": "a33bb543902489e055b4de1a3dbbf0894adbe610", "filename": "contrib/gcc_update", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -159,9 +159,6 @@ libsanitizer/sanitizer_common/Makefile.in: libsanitizer/sanitizer_common/Makefil\n libvtv/aclocal.m4: libvtv/configure.ac libvtv/acinclude.m4\n libvtv/Makefile.in: libvtv/Makefile.am libvtv/aclocal.m4\n libvtv/configure: libvtv/configure.ac libvtv/aclocal.m4\n-libcilkrts/aclocal.m4: libcilkrts/configure.ac\n-libcilkrts/Makefile.in: libcilkrts/Makefile.am\n-libcilkrts/configure: libcilkrts/configure.ac\n liboffloadmic/aclocal.m4: liboffloadmic/configure.ac\n liboffloadmic/Makefile.in: liboffloadmic/Makefile.am\n liboffloadmic/configure: liboffloadmic/configure.ac"}, {"sha": "a86c833d4bb05e6804e56d95a6e8e7154e814395", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,63 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+            Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* Makefile.in (cilkplus.def, cilk-builtins.def, c-family/cilk.o, \n+\tc-family/c-cilkplus.o, c-family/array-notation-common.o,\n+\tcilk-common.o, cilk.h, cilk-common.c): Remove.\n+\t* builtin-types.def\n+\t(BT_FN_INT_PTR_PTR_PTR_FTYPE_BT_INT_BT_PTR_BT_PTR_BT_PTR): Remove.\n+\t* builtins.c (is_builtin_name): Remove cilkplus condition.\n+\t(BUILT_IN_CILK_DETACH, BUILT_IN_CILK_POP_FRAME): Remove.\n+\t* builtins.def (DEF_CILK_BUILTIN_STUB, DEF_CILKPLUS_BUILTIN,\n+\tcilk-builtins.def, cilkplus.def): Remove.\n+\t* cif-code.def (CILK_SPAWN): Remove.\n+\t* cilk-builtins.def: Delete.\n+\t* cilk-common.c: Ditto.\n+\t* cilk.h: Ditto.\n+\t* cilkplus.def: Ditto.\n+\t* config/darwin.h (fcilkplus): Delete.\n+\t* cppbuiltin.c: Ditto.\n+\t* doc/extend.texi: Remove cilkplus doc.\n+\t* doc/generic.texi: Ditto.\n+\t* doc/invoke.texi: Ditto.\n+\t* doc/passes.texi: Ditto.\n+\t* gcc.c (fcilkplus): Remove.\n+\t* gengtype.c (cilk.h): Remove.\n+\t* gimple-pretty-print.c (dump_gimple_omp_for): Remove cilkplus\n+\tsupport.\n+\t* gimple.h (GF_OMP_FOR_KIND_CILKFOR, GF_OMP_FOR_KIND_CILKSIMD):\n+\tRemove.\n+\t* gimplify.c (gimplify_return_expr, maybe_fold_stmt,\n+\tgimplify_call_expr,\n+\tis_gimple_stmt, gimplify_modify_expr, gimplify_scan_omp_clauses,\n+\tgimplify_adjust_omp_clauses, gimplify_omp_for, gimplify_expr): Remove\n+\tcilkplus conditions.\n+\t* ipa-fnsummary.c (ipa_dump_fn_summary, compute_fn_summary,\n+\tinline_read_section): Ditto.\n+\t* ipa-inline-analysis.c (cilk.h): Remove.\n+\t* ira.c (ira_setup_eliminable_regset): Remove cilkplus support.\n+\t* lto-wrapper.c (merge_and_complain, append_compiler_options,\n+\tappend_linker_options): Remove condition for fcilkplus.\n+\t* lto/lto-lang.c (cilk.h): Remove.\n+\t(lto_init): Remove condition for fcilkplus.\n+\t* omp-expand.c (expand_cilk_for_call): Delete.\n+\t(expand_omp_taskreg, expand_omp_for_static_chunk,\n+\texpand_omp_for): Remove cilkplus\n+\tconditions.\n+\t(expand_cilk_for): Delete.\n+\t* omp-general.c (omp_extract_for_data): Remove cilkplus support.\n+\t* omp-low.c (scan_sharing_clauses, create_omp_child_function,\n+\texecute_lower_omp, diagnose_sb_0): Ditto.\n+\t* omp-simd-clone.c (simd_clone_clauses_extract): Ditto.\n+\t* tree-core.h (OMP_CLAUSE__CILK_FOR_COUNT_): Delete.\n+\t* tree-nested.c: Ditto.\n+\t* tree-pretty-print.c (dump_omp_clause): Remove cilkplus support.\n+\t(dump_generic_node): Ditto.\n+\t* tree.c (OMP_CLAUSE__CILK_FOR_COUNT_): Delete.\n+\t* tree.def (cilk_simd, cilk_for, cilk_spawn_stmt, cilk_sync_stmt):\n+\tDelete.\n+\t* tree.h (CILK_SPAWN_FN, EXPR_CILK_SPAWN): Delete.\n+\n 2017-11-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/aarch64/aarch64.md (div<mode>3): Change check to TARGET_FLOAT."}, {"sha": "f821b00d74220999010c14475405d189d548ce84", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -923,7 +923,7 @@ RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params-enum.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n-\tgtm-builtins.def sanitizer.def cilkplus.def cilk-builtins.def \\\n+\tgtm-builtins.def sanitizer.def \\\n \thsa-builtins.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n@@ -1195,9 +1195,8 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-lex.o c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n   c-family/c-semantics.o c-family/c-ada-spec.o \\\n-  c-family/c-cilkplus.o \\\n-  c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o \\\n-  c-family/c-attribs.o c-family/c-warn.o c-family/known-headers.o\n+  c-family/c-ubsan.o c-family/known-headers.o \\\n+  c-family/c-attribs.o c-family/c-warn.o\n \n # Language-independent object files.\n # We put the *-match.o and insn-*.o files first so that a parallel make\n@@ -1246,7 +1245,6 @@ OBJS = \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n \tcgraphclones.o \\\n-\tcilk-common.o \\\n \tcombine.o \\\n \tcombine-stack-adj.o \\\n \tcompare-elim.o \\\n@@ -2508,8 +2506,8 @@ s-match: build/genmatch$(build_exeext) $(srcdir)/match.pd cfn-operators.pd\n GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n-  $(srcdir)/wide-int.h $(srcdir)/alias.h $(srcdir)/cilk.h \\\n-  $(srcdir)/cilk-common.c $(srcdir)/coverage.c  $(srcdir)/rtl.h \\\n+  $(srcdir)/wide-int.h $(srcdir)/alias.h \\\n+  $(srcdir)/coverage.c  $(srcdir)/rtl.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/tree-core.h \\\n   $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\"}, {"sha": "bb50e604e190980a23da66676c62e16da9427e15", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -520,8 +520,6 @@ DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_CONST_STRING, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_FILEPTR_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_FILEPTR, BT_CONST_STRING, BT_VALIST_ARG)\n-DEF_FUNCTION_TYPE_3 (BT_FN_INT_PTR_PTR_PTR,\n-\t\t     BT_INT, BT_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_INT_UINT_UINT,\n \t\t     BT_INT, BT_INT, BT_UINT, BT_UINT)\n DEF_FUNCTION_TYPE_3 (BT_FN_UINT_UINT_UINT_UINT,"}, {"sha": "afc975e6deed1d729077236a24f556a77ae570b1", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -63,7 +63,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n-#include \"cilk.h\"\n #include \"tree-chkp.h\"\n #include \"rtl-chkp.h\"\n #include \"internal-fn.h\"\n@@ -203,10 +202,6 @@ is_builtin_name (const char *name)\n     return true;\n   if (strncmp (name, \"__atomic_\", 9) == 0)\n     return true;\n-  if (flag_cilkplus \n-      && (!strcmp (name, \"__cilkrts_detach\")   \n-\t  || !strcmp (name, \"__cilkrts_pop_frame\")))\n-    return true;\n   return false;\n }\n \n@@ -7626,14 +7621,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n       expand_builtin_set_thread_pointer (exp);\n       return const0_rtx;\n \n-    case BUILT_IN_CILK_DETACH:\n-      expand_builtin_cilk_detach (exp);\n-      return const0_rtx;\n-      \n-    case BUILT_IN_CILK_POP_FRAME:\n-      expand_builtin_cilk_pop_frame (exp);\n-      return const0_rtx;\n-\n     case BUILT_IN_CHKP_INIT_PTR_BOUNDS:\n     case BUILT_IN_CHKP_NULL_PTR_BOUNDS:\n     case BUILT_IN_CHKP_COPY_PTR_BOUNDS:"}, {"sha": "3fdd2dc222c18df10676dc6ea0ef11ac393947a5", "filename": "gcc/builtins.def", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -221,7 +221,6 @@ along with GCC; see the file COPYING3.  If not see\n \t       (flag_openacc \\\n \t\t|| flag_openmp \\\n \t\t|| flag_tree_parallelize_loops > 1 \\\n-\t\t|| flag_cilkplus \\\n \t\t|| flag_offload_abi != OFFLOAD_ABI_UNSET))\n \n #undef DEF_HSA_BUILTIN\n@@ -237,13 +236,6 @@ along with GCC; see the file COPYING3.  If not see\n \t       (false))\n #endif\n \n-/* Builtin used by implementation of Cilk Plus.  Most of these are decomposed\n-   by the compiler but a few are implemented in libcilkrts.  */ \n-#undef DEF_CILK_BUILTIN_STUB\n-#define DEF_CILK_BUILTIN_STUB(ENUM, NAME) \\\n-  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_LAST, BT_LAST, false, false, \\\n-\t       false, ATTR_LAST, false, false)\n-\n /* Builtin used by the implementation of GNU TM.  These\n    functions are mapped to the actual implementation of the STM library. */\n #undef DEF_TM_BUILTIN\n@@ -263,11 +255,6 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t\t| SANITIZE_UNDEFINED_NONDEFAULT) \\\n \t       || flag_sanitize_coverage))\n \n-#undef DEF_CILKPLUS_BUILTIN\n-#define DEF_CILKPLUS_BUILTIN(ENUM, NAME, TYPE, ATTRS)  \\\n-  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_FN_INT_VAR, BT_LAST, \\\n-  \t       false, false, false, ATTRS, false, flag_cilkplus) \n-\n /* Builtin used by the implementation of Pointer Bounds Checker.  */\n #undef DEF_CHKP_BUILTIN\n #define DEF_CHKP_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n@@ -1033,18 +1020,12 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Heterogeneous Systems Architecture.  */\n #include \"hsa-builtins.def\"\n \n-/* Cilk keywords builtins.  */\n-#include \"cilk-builtins.def\"\n-\n /* GTM builtins. */\n #include \"gtm-builtins.def\"\n \n /* Sanitizer builtins. */\n #include \"sanitizer.def\"\n \n-/* Cilk Plus builtins.  */\n-#include \"cilkplus.def\"\n-\n /* Pointer Bounds Checker builtins.  */\n #include \"chkp-builtins.def\"\n "}, {"sha": "ce966bbaa4caf5750d30b23c8bbd1418adb1bfb2", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,25 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+            Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* array-notation-common.c: Delete.\n+\t* c-cilkplus.c: Ditto.\n+\t* c-common.c (_Cilk_spawn, _Cilk_sync, _Cilk_for): Remove.\n+\t* c-common.def (ARRAY_NOTATION_REF): Remove.\n+\t* c-common.h (RID_CILK_SPAWN, build_array_notation_expr,\n+\tbuild_array_notation_ref, C_ORT_CILK, c_check_cilk_loop,\n+\tc_validate_cilk_plus_loop, cilkplus_an_parts,\n+\tcilk_ignorable_spawn_rhs_op,\n+\tcilk_recognize_spawn): Remove.\n+\t* c-gimplify.c (CILK_SPAWN_STMT): Remove.\n+\t* c-omp.c: Remove CILK_SIMD check.\n+\t* c-pragma.c: Ditto.\n+\t* c-pragma.h: Remove CILK related pragmas.\n+\t* c-pretty-print.c (c_pretty_printer::postfix_expression): Remove\n+\tARRAY_NOTATION_REF condition.\n+\t(c_pretty_printer::expression): Ditto.\n+\t* c.opt (fcilkplus): Remove.\n+\t* cilk.c: Delete.\n+\n 2017-11-21  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* c-pretty-print.c (pp_c_additive_expression,"}, {"sha": "a4809948e20368a36c57504e11050c7ba7f9f2d6", "filename": "gcc/c-family/array-notation-common.c", "status": "removed", "additions": 0, "deletions": 689, "changes": 689, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc-family%2Farray-notation-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc-family%2Farray-notation-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Farray-notation-common.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,689 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   This file contains the builtin functions for Array\n-   notations.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n-                  Intel Corporation\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\" \n-#include \"coretypes.h\"\n-#include \"options.h\"\n-#include \"c-family/c-common.h\"\n-#include \"tree-iterator.h\"\n-#include \"stringpool.h\"\n-#include \"attribs.h\"\n-\n-/* Returns true if the function call in FNDECL is  __sec_implicit_index.  */\n-\n-bool\n-is_sec_implicit_index_fn (tree fndecl)\n-{\n-  if (!fndecl)\n-    return false;\n-\n-  if (TREE_CODE (fndecl) == ADDR_EXPR)\n-    fndecl = TREE_OPERAND (fndecl, 0);\n-\n-  return\n-    (TREE_CODE (fndecl) == FUNCTION_DECL\n-     && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-     && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CILKPLUS_SEC_IMPLICIT_INDEX);\n-}\n-\n-/* Returns the first and only argument for FN, which should be a\n-   sec_implicit_index function.  FN's location in the source file is as \n-   indicated by LOCATION.  The argument to FN must be a constant integer\n-   expression, otherwise returns -1.  */\n-\n-HOST_WIDE_INT\n-extract_sec_implicit_index_arg (location_t location, tree fn)\n-{\n-  tree fn_arg;\n-  HOST_WIDE_INT return_int = 0;\n-\n-  if (TREE_CODE (fn) == CALL_EXPR)\n-    {\n-      fn_arg = CALL_EXPR_ARG (fn, 0);\n-      if (TREE_CODE (fn_arg) == INTEGER_CST)\n-\treturn_int = int_cst_value (fn_arg);\n-      else\n-\t{\n-\t  /* If the location is unknown, and if fn has a location, then use that\n-\t     information so that the user has a better idea where the error\n-\t     could be.  */\n-\t  if (location == UNKNOWN_LOCATION && EXPR_HAS_LOCATION (fn))\n-\t    location = EXPR_LOCATION (fn);\n-\t  error_at (location, \"__sec_implicit_index parameter must be an \" \n-\t\t    \"integer constant expression\");\n-\t  return -1;\n-\t}\n-    }\n-  return return_int;\n-}\n-\n-/* Returns true if there is a length mismatch among exprssions that are at the\n-   same dimension and one the same side of the equal sign.  The Array notation\n-   lengths (LIST->LENGTH) is passed in as a 2D vector of trees.  */\n-\n-bool\n-length_mismatch_in_expr_p (location_t loc, vec<vec<an_parts> >list)\n-{\n-  size_t ii, jj;\n-  tree length = NULL_TREE;\n-  \n-  size_t x = list.length ();\n-  size_t y = list[0].length ();\n-  \n-  for (jj = 0; jj < y; jj++)\n-    {\n-      length = NULL_TREE;\n-      for (ii = 0; ii < x; ii++)\n-\t{\n-\t  if (!length)\n-\t    length = list[ii][jj].length;\n-\t  else if (TREE_CODE (length) == INTEGER_CST)\n-\t    {\n-\t      /* If length is a INTEGER, and list[ii][jj] is an integer then\n-\t\t check if they are equal.  If they are not equal then return\n-\t\t true.  */\n-\t      if (TREE_CODE (list[ii][jj].length) == INTEGER_CST\n-\t\t  && !tree_int_cst_equal (list[ii][jj].length, length))\n-\t\t{ \n-\t\t  error_at (loc, \"length mismatch in expression\"); \n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t  else\n-\t    /* We set the length node as the current node just in case it turns\n-\t       out to be an integer.  */\n-\t    length = list[ii][jj].length;\n-\t}\n-    }\n-  return false;\n-}\n-\n-/* Given an FNDECL of type FUNCTION_DECL or ADDR_EXPR, return the corresponding\n-   BUILT_IN_CILKPLUS_SEC_REDUCE_* being called.  If none, return\n-   BUILT_IN_NONE.  */\n-\n-enum built_in_function\n-is_cilkplus_reduce_builtin (tree fndecl)\n-{\n-  if (!fndecl)\n-    return BUILT_IN_NONE;\n-  if (TREE_CODE (fndecl) == ADDR_EXPR)\n-    fndecl = TREE_OPERAND (fndecl, 0);\n-\n-  if (TREE_CODE (fndecl) == FUNCTION_DECL\n-      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n-    switch (DECL_FUNCTION_CODE (fndecl))\n-      {\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-      case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-\treturn DECL_FUNCTION_CODE (fndecl);\n-      default:\n-\tbreak;\n-      }\n-\n-  return BUILT_IN_NONE;\n-}\n-\n-/* This function will recurse into EXPR finding any\n-   ARRAY_NOTATION_EXPRs and calculate the overall rank of EXPR,\n-   storing it in *RANK. LOC is the location of the original expression.\n-\n-   ORIG_EXPR is the original expression used to display if any rank\n-   mismatch errors are found.\n-\n-   Upon entry, *RANK must be either 0, or the rank of a parent\n-   expression that must have the same rank as the one being\n-   calculated.  It is illegal to have multiple array notation with different\n-   rank in the same expression (see examples below for clarification).\n-\n-   If there were any rank mismatches while calculating the rank, an\n-   error will be issued, and FALSE will be returned.  Otherwise, TRUE\n-   is returned.  \n-\n-   If IGNORE_BUILTIN_FN is TRUE, ignore array notation specific\n-   built-in functions (__sec_reduce_*, etc).\n-\n-   Here are some examples of array notations and their rank:\n-\n-   Expression\t\t\t    RANK\n-   5\t\t\t\t    0\n-   X (a variable)\t\t    0\n-   *Y (a pointer)\t\t    0\n-   A[5]\t\t\t\t    0\n-   B[5][10]\t\t\t    0\n-   A[:]\t\t\t\t    1 \n-   B[0:10]\t\t\t    1\n-   C[0:10:2]\t\t\t    1\n-   D[5][0:10:2]\t\t\t    1 (since D[5] is considered \"scalar\")\n-   D[5][:][10]\t\t\t    1 \n-   E[:] + 5\t\t\t    1 \n-   F[:][:][:] + 5 + X\t\t    3\n-   F[:][:][:] + E[:] + 5 + X\t    RANKMISMATCH-ERROR since rank (E[:]) = 1 and\n-                                    rank (F[:][:][:]) = 3.  They must be equal \n-\t\t\t\t    or have a rank of zero.\n-   F[:][5][10] + E[:] * 5 + *Y      1\n-\n-   int func (int);\n-   func (A[:])\t\t\t    1\n-   func (B[:][:][:][:])             4 \n-   \n-   int func2 (int, int)\n-   func2 (A[:], B[:][:][:][:])\t    RANKMISMATCH-ERROR -- Since Rank (A[:]) = 1 \n-\t\t\t\t    and Rank (B[:][:][:][:]) = 4\n-\n-   A[:] + func (B[:][:][:][:])\t    RANKMISMATCH-ERROR\n-   func2 (A[:], B[:]) + func (A)    1 \n-\n- */\n-\n-bool\n-find_rank (location_t loc, tree orig_expr, tree expr, bool ignore_builtin_fn,\n-\t   size_t *rank)\n-{\n-  tree ii_tree;\n-  size_t ii = 0, current_rank = 0;\n-\n-  if (TREE_CODE (expr) == ARRAY_NOTATION_REF)\n-    {\n-      ii_tree = expr;\n-      while (ii_tree)\n-\t{\n-\t  if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n-\t    {\n-\t      current_rank++;\n-\t      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t    }\n-\t  else if (handled_component_p (ii_tree)\n-\t\t   || INDIRECT_REF_P (ii_tree))\n-\t    ii_tree = TREE_OPERAND (ii_tree, 0);\n-\t  else if (TREE_CODE (ii_tree) == PARM_DECL\n-\t\t   || VAR_P (ii_tree))\n-\t    break;\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-      if (*rank == 0)\n-\t/* In this case, all the expressions this function has encountered thus\n-\t   far have been scalars or expressions with zero rank.  Please see\n-\t   header comment for examples of such expression.  */\n-\t*rank = current_rank;\n-      else if (*rank != current_rank)\n-\t{\n-\t  /* In this case, find rank is being recursed through a set of \n-\t     expression of the form A <OPERATION> B, where A and B both have\n-\t     array notations in them and the rank of A is not equal to rank of\n-\t     B.  \n-\t     A simple example of such case is the following: X[:] + Y[:][:] */ \n-\t  *rank = current_rank;\n-\t  return false;\n-\t}\n-    }\n-  else if (TREE_CODE (expr) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator ii_tsi;\n-      for (ii_tsi = tsi_start (expr); !tsi_end_p (ii_tsi);\n-\t   tsi_next (&ii_tsi))\n-\tif (!find_rank (loc, orig_expr, *tsi_stmt_ptr (ii_tsi),\n-\t\t\tignore_builtin_fn, rank))\n-\t  return false;\n-    }\n-  else\n-    {\n-      if (TREE_CODE (expr) == CALL_EXPR)\n-\t{\n-\t  tree func_name = CALL_EXPR_FN (expr);\n-\t  tree prev_arg = NULL_TREE, arg;\n-\t  call_expr_arg_iterator iter;\n-\t  size_t prev_rank = 0;\n-\t  if (TREE_CODE (func_name) == ADDR_EXPR)\n-\t    if (!ignore_builtin_fn)\n-\t      if (is_cilkplus_reduce_builtin (func_name))\n-\t\t/* If it is a built-in function, then we know it returns a \n-\t\t   scalar.  */\n-\t\treturn true;\n-\t  if (!find_rank (loc, orig_expr, func_name, ignore_builtin_fn, rank))\n-\t    return false;\n-\t  FOR_EACH_CALL_EXPR_ARG (arg, iter, expr)\n-\t    {\n-\t      if (!find_rank (loc, orig_expr, arg, ignore_builtin_fn, rank))\n-\t\t{\n-\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg)\n-\t\t      && prev_rank != *rank)\n-\t\t    error_at (EXPR_LOCATION (prev_arg),\n-\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n-\t\t\t      arg);\n-\t\t  else if (prev_arg && prev_rank != *rank)\n-\t\t    /* Here the original expression is printed as a \"heads-up\"\n-\t\t       to the programmer.  This is because since there is no \n-\t\t       location information for the offending argument, the \n-\t\t       error could be in some internally generated code that is\n-\t\t       not visible for the programmer.  Thus, the correct fix\n-\t\t       may lie in the original expression.  */\n-\t\t    error_at (loc, \"rank mismatch in expression %qE\",\n-\t\t\t      orig_expr);\n-\t\t  return false;\n-\t\t}\n-\t      prev_arg = arg;\n-\t      prev_rank = *rank;\n-\t    }\t\n-\t}\n-      else\n-\t{\n-\t  tree prev_arg = NULL_TREE;\n-\t  for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (expr)); ii++)\n-\t    {\n-\t      if (TREE_OPERAND (expr, ii)\n-\t\t  && !find_rank (loc, orig_expr, TREE_OPERAND (expr, ii),\n-\t\t\t\t ignore_builtin_fn, rank))\n-\t\t{\n-\t\t  if (prev_arg && EXPR_HAS_LOCATION (prev_arg))\n-\t\t    error_at (EXPR_LOCATION (prev_arg),\n-\t\t\t      \"rank mismatch between %qE and %qE\", prev_arg,\n-\t\t\t      TREE_OPERAND (expr, ii));\n-\t\t  return false;\n-\t\t}\n-\t      prev_arg = TREE_OPERAND (expr, ii);\n-\t    }\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Extracts all array notations in NODE and stores them in ARRAY_LIST.  If \n-   IGNORE_BUILTIN_FN is set, then array notations inside array notation\n-   specific built-in functions are ignored.  The NODE can be constants,\n-   VAR_DECL, PARM_DECLS, STATEMENT_LISTS or full expressions.   */\n-\n-void\n-extract_array_notation_exprs (tree node, bool ignore_builtin_fn,\n-\t\t\t      vec<tree, va_gc> **array_list)\n-{\n-  size_t ii = 0;  \n-\n-  if (!node)\n-    return;\n-  if (TREE_CODE (node) == ARRAY_NOTATION_REF)\n-    {\n-      vec_safe_push (*array_list, node);\n-      return;\n-    }\n-  if (TREE_CODE (node) == DECL_EXPR)\n-    {\n-      tree x = DECL_EXPR_DECL (node);\n-      if (DECL_INITIAL (x))\n-\textract_array_notation_exprs (DECL_INITIAL (x),\n-\t\t\t\t      ignore_builtin_fn,\n-\t\t\t\t      array_list);\n-    }\n-  else if (TREE_CODE (node) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator ii_tsi;\n-      for (ii_tsi = tsi_start (node); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n-\textract_array_notation_exprs (*tsi_stmt_ptr (ii_tsi),\n-\t\t\t\t      ignore_builtin_fn, array_list);\n-    }\n-  else if (TREE_CODE (node) == CALL_EXPR)\n-    {\n-      tree arg;\n-      call_expr_arg_iterator iter;\n-      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (node)))\n-\t{\n-\t  if (ignore_builtin_fn)\n-\t    return;\n-\t  else\n-\t    {\n-\t      vec_safe_push (*array_list, node);\n-\t      return;\n-\t    }\n-\t}\n-      if (is_sec_implicit_index_fn (CALL_EXPR_FN (node)))\n-\t{\n-\t  vec_safe_push (*array_list, node);\n-\t  return;\n-\t}\n-      /* This will extract array notations in function pointers.  */\n-      extract_array_notation_exprs (CALL_EXPR_FN (node), ignore_builtin_fn,\n-\t\t\t\t    array_list);\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, node)\n-\textract_array_notation_exprs (arg, ignore_builtin_fn, array_list);\n-    } \n-  else \n-    for (ii = 0; ii < TREE_CODE_LENGTH (TREE_CODE (node)); ii++) \n-      if (TREE_OPERAND (node, ii))\n-\textract_array_notation_exprs (TREE_OPERAND (node, ii),\n-\t\t\t\t      ignore_builtin_fn, array_list);\n-  return;\n-}\n-\n-/* LIST contains all the array notations found in *ORIG and ARRAY_OPERAND\n-   contains the expanded ARRAY_REF.  E.g., if LIST[<some_index>] contains\n-   an array_notation expression, then ARRAY_OPERAND[<some_index>] contains its\n-   expansion.  If *ORIG matches LIST[<some_index>] then *ORIG is set to\n-   ARRAY_OPERAND[<some_index>].  This function recursively steps through\n-   all the sub-trees of *ORIG, if it is larger than a single\n-   ARRAY_NOTATION_REF.  */\n-\n-void\n-replace_array_notations (tree *orig, bool ignore_builtin_fn,\n-\t\t\t vec<tree, va_gc> *list,\n-\t\t\t vec<tree, va_gc> *array_operand)\n-{\n-  size_t ii = 0;\n-  extern tree build_c_cast (location_t, tree, tree);\n-  tree node = NULL_TREE, node_replacement = NULL_TREE;\n-  \n-  if (vec_safe_length (list) == 0)\n-    return;\n-\n-  if (TREE_CODE (*orig) == ARRAY_NOTATION_REF)\n-    {\n-      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n-\tif (*orig == node)\n-\t  {\n-\t    node_replacement = (*array_operand)[ii];\n-\t    *orig = node_replacement;\n-\t  }\n-    }\n-  else if (TREE_CODE (*orig) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator ii_tsi;\n-      for (ii_tsi = tsi_start (*orig); !tsi_end_p (ii_tsi); tsi_next (&ii_tsi))\n-\treplace_array_notations (tsi_stmt_ptr (ii_tsi), ignore_builtin_fn, list,\n-\t\t\t\t array_operand);\n-    }\n-  else if (TREE_CODE (*orig) == CALL_EXPR)\n-    {\n-      tree arg;\n-      call_expr_arg_iterator iter;\n-      if (is_cilkplus_reduce_builtin (CALL_EXPR_FN (*orig)))\n-\t{\n-\t  if (!ignore_builtin_fn)\n-\t    {\n-\t      for (ii = 0; vec_safe_iterate (list, ii, &node); ii++) \n-\t\tif (*orig == node)\n-\t\t  {\n-\t\t    node_replacement = (*array_operand)[ii];\n-\t\t    *orig = node_replacement;\n-\t\t  }\n-\t    }\n-\t  return;\n-\t}\n-      if (is_sec_implicit_index_fn (CALL_EXPR_FN (*orig)))\n-\t{\n-\t  for (ii = 0; vec_safe_iterate (list, ii, &node); ii++)\n-\t    if (*orig == node)\n-\t      {\n-\t\tnode_replacement = (*array_operand)[ii];\n-\t\t*orig = build_c_cast (EXPR_LOCATION (*orig),\n-\t\t\t\t      TREE_TYPE (*orig), node_replacement);\n-\t      }\n-\t  return;\n-\t}\n-      /* Fixes array notations in array notations in function pointers.  */\n-      replace_array_notations (&CALL_EXPR_FN (*orig), ignore_builtin_fn, list,\n-\t\t\t       array_operand);\n-      ii = 0;\n-      FOR_EACH_CALL_EXPR_ARG (arg, iter, *orig)\n-\t{\n-\t  replace_array_notations (&arg, ignore_builtin_fn, list,\n-\t\t\t\t   array_operand);\n-\t  CALL_EXPR_ARG (*orig, ii) = arg;\n-\t  ii++;\n-\t}     \n-    }\n-  else\n-    {\n-      for (ii = 0; ii < (size_t) TREE_CODE_LENGTH (TREE_CODE (*orig)); ii++) \n-\tif (TREE_OPERAND (*orig, ii))\n-\t  replace_array_notations (&TREE_OPERAND (*orig, ii), ignore_builtin_fn,\n-\t\t\t\t   list, array_operand);\n-    }\n-  return;\n-}\n-\n-/* Callback for walk_tree.  Find all the scalar expressions in *TP and push \n-   them in DATA struct, typecasted to (void *).  If *WALK_SUBTREES is set to 0 \n-   then do not go into the *TP's subtrees.  Since this function steps through \n-   all the subtrees, *TP and TP can be NULL_TREE and NULL, respectively.  The \n-   function returns NULL_TREE unconditionally.  */\n-\n-tree\n-find_inv_trees (tree *tp, int *walk_subtrees, void *data)\n-{\n-  struct inv_list *i_list = (struct inv_list *) data;\n-  unsigned int ii = 0;\n-\n-  if (!tp || !*tp)\n-    return NULL_TREE;\n-  if (TREE_CONSTANT (*tp))\n-    return NULL_TREE; /* No need to save constant to a variable.  */\n-  if (TREE_CODE (*tp) != COMPOUND_EXPR && !contains_array_notation_expr (*tp))\n-    {\n-      vec_safe_push (i_list->list_values, *tp);\n-      *walk_subtrees = 0;\n-    }\n-  else if (TREE_CODE (*tp) == ARRAY_NOTATION_REF\n-\t   || TREE_CODE (*tp) == ARRAY_REF\n-\t   || TREE_CODE (*tp) == CALL_EXPR)\n-    /* No need to step through the internals of array notation.  */\n-    *walk_subtrees = 0;\n-  else\n-    {\n-      *walk_subtrees = 1;\n-\n-      /* This function is used by C and C++ front-ends.  In C++, additional\n-\t tree codes such as TARGET_EXPR must be eliminated.  These codes are\n-\t passed into additional_tcodes and are walked through and checked.  */\n-      for (ii = 0; ii < vec_safe_length (i_list->additional_tcodes); ii++)\n-\tif (TREE_CODE (*tp) == (*(i_list->additional_tcodes))[ii])\n-\t  *walk_subtrees = 0;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Callback for walk_tree.  Replace all the scalar expressions in *TP with the \n-   appropriate replacement stored in the struct *DATA (typecasted to void*).  \n-   The subtrees are not touched if *WALK_SUBTREES is set to zero.  */\n-\n-tree\n-replace_inv_trees (tree *tp, int *walk_subtrees, void *data)\n-{\n-  size_t ii = 0;\n-  tree t, r;\n-  struct inv_list *i_list = (struct inv_list *) data;\n-\n-  if (vec_safe_length (i_list->list_values))\n-    {\n-      for (ii = 0; vec_safe_iterate (i_list->list_values, ii, &t); ii++)\n-\tif (simple_cst_equal (*tp, t) == 1)\n-\t  {\n-\t    vec_safe_iterate (i_list->replacement, ii, &r);\n-\t    gcc_assert (r != NULL_TREE);\n-\t    *tp = r;\n-\t    *walk_subtrees = 0;\n-\t  }\n-    }\n-  else\n-    *walk_subtrees = 0;\n-  return NULL_TREE;\n-}\n-\n-/* Returns true if EXPR or any of its subtrees contain ARRAY_NOTATION_EXPR \n-   node.  */\n-\n-bool\n-contains_array_notation_expr (tree expr)\n-{\n-  vec<tree, va_gc> *array_list = NULL;\n-\n-  if (!expr)\n-    return false;\n-  if (TREE_CODE (expr) == FUNCTION_DECL)\n-    if (is_cilkplus_reduce_builtin (expr))\n-      return true;\n-  \n-  extract_array_notation_exprs (expr, false, &array_list);\n-  if (vec_safe_length (array_list) == 0)\n-    return false;\n-  else\n-    return true;\n-}\n-\n-/* This function will check if OP is a CALL_EXPR that is a built-in array \n-   notation function.  If so, then we will return its type to be the type of\n-   the array notation inside.  */\n-\n-tree\n-find_correct_array_notation_type (tree op)\n-{\n-  tree fn_arg, return_type = NULL_TREE;\n-\n-  if (op)\n-    {\n-      return_type = TREE_TYPE (op); /* This is the default case.  */\n-      if (TREE_CODE (op) == CALL_EXPR) \n-\tif (is_cilkplus_reduce_builtin (CALL_EXPR_FN (op))) \n-\t  { \n-\t    fn_arg = CALL_EXPR_ARG (op, 0); \n-\t    if (fn_arg) \n-\t      return_type = TREE_TYPE (fn_arg); \n-\t  }\n-    } \n-  return return_type;\n-}\n-\n-/* Extracts all the array notation triplet information from LIST and stores\n-   them in the following fields of the 2-D array NODE(size x rank):\n-   START, LENGTH and STRIDE, holding the starting index, length, and stride,\n-   respectively.  In addition, it also sets two bool fields, IS_VECTOR and\n-   COUNT_DOWN, in NODE indicating whether a certain value at a certain field\n-   is a vector and if the array is accessed from high to low.  */\n-\n-void\n-cilkplus_extract_an_triplets (vec<tree, va_gc> *list, size_t size, size_t rank,\n-\t\t\t      vec<vec<struct cilkplus_an_parts> > *node)\n-{\n-  vec<vec<tree> > array_exprs = vNULL;\n-\n-  node->safe_grow_cleared (size);\n-  array_exprs.safe_grow_cleared (size);\n-\n-  if (rank > 0)\n-    for (size_t ii = 0; ii < size; ii++)\n-      {\n-\t(*node)[ii].safe_grow_cleared (rank);\n-\tarray_exprs[ii].safe_grow_cleared (rank);\n-      }\n-  for (size_t ii = 0; ii < size; ii++)\n-    {\n-      size_t jj = 0;\n-      tree ii_tree = (*list)[ii];\n-      while (ii_tree)\n-\t{\n-\t  if (TREE_CODE (ii_tree) == ARRAY_NOTATION_REF)\n-\t    {\n-\t      array_exprs[ii][jj] = ii_tree;\n-\t      jj++;\n-\t      ii_tree = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t    }\n-\t  else if (TREE_CODE (ii_tree) == ARRAY_REF)\n-\t    ii_tree = TREE_OPERAND (ii_tree, 0);\n-\t  else\n-\t    break;\n-\t}\n-    }\n-  for (size_t ii = 0; ii < size; ii++)\n-    if (TREE_CODE ((*list)[ii]) == ARRAY_NOTATION_REF)\n-      for (size_t jj = 0; jj < rank; jj++)\n-\t{\n-\t  tree ii_tree = array_exprs[ii][jj];\n-\t  (*node)[ii][jj].is_vector = true;\n-\t  (*node)[ii][jj].value = ARRAY_NOTATION_ARRAY (ii_tree);\n-\t  (*node)[ii][jj].start\n-\t    = fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t   ARRAY_NOTATION_START (ii_tree));\n-\t  (*node)[ii][jj].length\n-\t    = fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t   ARRAY_NOTATION_LENGTH (ii_tree));\n-\t  (*node)[ii][jj].stride\n-\t    = fold_build1 (CONVERT_EXPR, integer_type_node,\n-\t\t\t   ARRAY_NOTATION_STRIDE (ii_tree));\n-\t}\n-\n-  release_vec_vec (array_exprs);\n-}\n-\n-/* Replaces all the __sec_implicit_arg functions in LIST with the induction\n-   variable stored in VAR at the appropriate location pointed by the\n-   __sec_implicit_arg's first parameter.  Emits an error if the parameter is\n-   not between 0 and RANK.  */\n-\n-vec <tree, va_gc> *\n-fix_sec_implicit_args (location_t loc, vec <tree, va_gc> *list,\n-\t\t       vec<an_loop_parts> an_loop_info, size_t rank,\n-\t\t       tree orig_stmt)\n-{\n-  vec <tree, va_gc> *array_operand = NULL;\n-  for (size_t ii = 0; ii < vec_safe_length (list); ii++)\n-    if (TREE_CODE ((*list)[ii]) == CALL_EXPR\n-\t&& is_sec_implicit_index_fn (CALL_EXPR_FN ((*list)[ii])))\n-      {\n-\tint idx = extract_sec_implicit_index_arg (loc, (*list)[ii]);\n-\tif (idx < 0)\n-\t  /* In this case, the returning function would have emitted an\n-\t     error thus it is not necessary to do so again.  */\n-\t  return NULL;\n-\telse if (idx < (int) rank)\n-\t  vec_safe_push (array_operand, an_loop_info[idx].var);\n-\telse\n-\t  {\n-\t    error_at (loc, \"__sec_implicit_index argument %d must be \"\n-\t\t      \"less than the rank of %qE\", idx, orig_stmt);\n-\t    return NULL;\n-\t  }\n-      }\n-    else\n-      /* Save the existing value into the array operand.  */\n-      vec_safe_push (array_operand, (*list)[ii]);\n-  return array_operand;\n-}\n-\n-/* Returns true if NAME is an IDENTIFIER_NODE with identifier \"vector\",\n-   \"__vector\", or \"__vector__\".  */\n-\n-bool\n-is_cilkplus_vector_p (tree name)\n-{\n-  return flag_cilkplus && is_attribute_p (\"vector\", name);\n-}"}, {"sha": "a537193798d231c4f55fd04e9202ee0eef217f30", "filename": "gcc/c-family/c-cilkplus.c", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc-family%2Fc-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc-family%2Fc-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cilkplus.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,175 +0,0 @@\n-/* This file contains routines to construct and validate Cilk Plus\n-   constructs within the C and C++ front ends.\n-\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"c-common.h\"\n-\n-/* Validate the body of a _Cilk_for construct or a <#pragma simd> for\n-   loop.\n-\n-   Returns true if there were no errors, false otherwise.  */\n-\n-bool\n-c_check_cilk_loop (location_t loc, tree decl)\n-{\n-  if (TREE_THIS_VOLATILE (decl))\n-    {\n-      error_at (loc, \"iteration variable cannot be volatile\");\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* Calculate number of iterations of CILK_FOR.  */\n-\n-tree\n-cilk_for_number_of_iterations (tree cilk_for)\n-{\n-  tree t, v, n1, n2, step, type, init, cond, incr, itype;\n-  enum tree_code cond_code;\n-  location_t loc = EXPR_LOCATION (cilk_for);\n-\n-  init = TREE_VEC_ELT (OMP_FOR_INIT (cilk_for), 0);\n-  v = TREE_OPERAND (init, 0);\n-  cond = TREE_VEC_ELT (OMP_FOR_COND (cilk_for), 0);\n-  incr = TREE_VEC_ELT (OMP_FOR_INCR (cilk_for), 0);\n-  type = TREE_TYPE (v);\n-\n-  gcc_assert (TREE_CODE (TREE_TYPE (v)) == INTEGER_TYPE\n-\t      || TREE_CODE (TREE_TYPE (v)) == POINTER_TYPE);\n-  n1 = TREE_OPERAND (init, 1);\n-  cond_code = TREE_CODE (cond);\n-  n2 = TREE_OPERAND (cond, 1);\n-  switch (cond_code)\n-    {\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case NE_EXPR:\n-      break;\n-    case LE_EXPR:\n-      if (POINTER_TYPE_P (TREE_TYPE (n2)))\n-\tn2 = fold_build_pointer_plus_hwi_loc (loc, n2, 1);\n-      else\n-\tn2 = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (n2), n2,\n-\t\t\t      build_int_cst (TREE_TYPE (n2), 1));\n-      cond_code = LT_EXPR;\n-      break;\n-    case GE_EXPR:\n-      if (POINTER_TYPE_P (TREE_TYPE (n2)))\n-\tn2 = fold_build_pointer_plus_hwi_loc (loc, n2, -1);\n-      else\n-\tn2 = fold_build2_loc (loc, MINUS_EXPR, TREE_TYPE (n2), n2,\n-\t\t\t      build_int_cst (TREE_TYPE (n2), 1));\n-      cond_code = GT_EXPR;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  step = NULL_TREE;\n-  switch (TREE_CODE (incr))\n-    {\n-    case PREINCREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-      step = build_int_cst (TREE_TYPE (v), 1);\n-      break;\n-    case PREDECREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-      step = build_int_cst (TREE_TYPE (v), -1);\n-      break;\n-    case MODIFY_EXPR:\n-      t = TREE_OPERAND (incr, 1);\n-      gcc_assert (TREE_OPERAND (t, 0) == v);\n-      switch (TREE_CODE (t))\n-\t{\n-\tcase PLUS_EXPR:\n-\t  step = TREE_OPERAND (t, 1);\n-\t  break;\n-\tcase POINTER_PLUS_EXPR:\n-\t  step = fold_convert (ssizetype, TREE_OPERAND (t, 1));\n-\t  break;\n-\tcase MINUS_EXPR:\n-\t  step = TREE_OPERAND (t, 1);\n-\t  step = fold_build1_loc (loc, NEGATE_EXPR, TREE_TYPE (step), step);\n-\t  break;\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  itype = type;\n-  if (POINTER_TYPE_P (itype))\n-    itype = signed_type_for (itype);\n-  if (cond_code == NE_EXPR)\n-    {\n-      /* For NE_EXPR, we need to find out if the iterator increases\n-\t or decreases from whether step is positive or negative.  */\n-      tree stype = itype;\n-      if (TYPE_UNSIGNED (stype))\n-\tstype = signed_type_for (stype);\n-      cond = fold_build2_loc (loc, GE_EXPR, boolean_type_node,\n-\t\t\t      fold_convert_loc (loc, stype, step),\n-\t\t\t      build_int_cst (stype, 0));\n-      t = fold_build3_loc (loc, COND_EXPR, itype, cond,\n-\t\t\t   build_int_cst (itype, -1),\n-\t\t\t   build_int_cst (itype, 1));\n-    }\n-  else\n-    t = build_int_cst (itype, (cond_code == LT_EXPR ? -1 : 1));\n-  t = fold_build2_loc (loc, PLUS_EXPR, itype,\n-\t\t       fold_convert_loc (loc, itype, step), t);\n-  t = fold_build2_loc (loc, PLUS_EXPR, itype, t,\n-\t\t       fold_convert_loc (loc, itype, n2));\n-  t = fold_build2_loc (loc, MINUS_EXPR, itype, t,\n-\t\t       fold_convert_loc (loc, itype, n1));\n-  if (TYPE_UNSIGNED (itype) && cond_code == GT_EXPR)\n-    t = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n-\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype, t),\n-\t\t\t fold_build1_loc (loc, NEGATE_EXPR, itype,\n-\t\t\t\t\t  fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t\t    step)));\n-  else if (TYPE_UNSIGNED (itype) && cond_code == NE_EXPR)\n-    {\n-      tree t1\n-\t= fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n-\t\t\t   fold_convert_loc (loc, itype, step));\n-      tree t2\n-\t= fold_build2_loc (loc, TRUNC_DIV_EXPR, itype,\n-\t\t\t   fold_build1_loc (loc, NEGATE_EXPR, itype, t),\n-\t\t\t   fold_build1_loc (loc, NEGATE_EXPR, itype,\n-\t\t\t\t\t    fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t\t      step)));\n-      t = fold_build3_loc (loc, COND_EXPR, itype, cond, t1, t2);\n-    }\n-  else\n-    t = fold_build2_loc (loc, TRUNC_DIV_EXPR, itype, t,\n-\t\t\t fold_convert_loc (loc, itype, step));\n-  cond = fold_build2_loc (loc, cond_code, boolean_type_node, n1, n2);\n-  t = fold_build3_loc (loc, COND_EXPR, itype, cond, t,\n-\t\t       build_int_cst (itype, 0));\n-  return t;\n-}"}, {"sha": "8256165730d0fb7703da27140ab8c2e509c9889a", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -338,9 +338,6 @@ const struct c_common_resword c_common_reswords[] =\n   { \"_Atomic\",\t\tRID_ATOMIC,    D_CONLY },\n   { \"_Bool\",\t\tRID_BOOL,      D_CONLY },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n-  { \"_Cilk_spawn\",      RID_CILK_SPAWN, 0 },\n-  { \"_Cilk_sync\",       RID_CILK_SYNC,  0 },\n-  { \"_Cilk_for\",        RID_CILK_FOR,   0 },\n   { \"_Imaginary\",\tRID_IMAGINARY, D_CONLY },\n   { \"_Float16\",         RID_FLOAT16,   D_CONLY },\n   { \"_Float32\",         RID_FLOAT32,   D_CONLY },\n@@ -3935,9 +3932,6 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n   targetm.init_builtins ();\n \n   build_common_builtin_nodes ();\n-\n-  if (flag_cilkplus)\n-    cilk_init_builtins ();\n }\n \n /* Like get_identifier, but avoid warnings about null arguments when\n@@ -7569,7 +7563,6 @@ c_common_init_ts (void)\n {\n   MARK_TS_TYPED (C_MAYBE_CONST_EXPR);\n   MARK_TS_TYPED (EXCESS_PRECISION_EXPR);\n-  MARK_TS_TYPED (ARRAY_NOTATION_REF);\n }\n \n /* Build a user-defined numeric literal out of an integer constant type VALUE"}, {"sha": "2d894728b0485782c5141e94babfd9f907d2d322", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -55,13 +55,6 @@ DEFTREECODE (USERDEF_LITERAL, \"userdef_literal\", tcc_exceptional, 3)\n    or for the purpose of -Wsizeof-pointer-memaccess warning.  */\n DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", tcc_expression, 1)\n \n-/* Array Notation expression.\n-   Operand 0 is the array.\n-   Operand 1 is the starting array index.\n-   Operand 2 contains the number of elements you need to access.\n-   Operand 3 is the stride.  */\n-DEFTREECODE (ARRAY_NOTATION_REF, \"array_notation_ref\", tcc_reference, 4) \n-\n /*\n Local variables:\n mode:c"}, {"sha": "5e55e5efba6c0637fb93c1267a22b20f86f6caf1", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 3, "deletions": 91, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -184,9 +184,6 @@ enum rid\n   /* C++ transactional memory.  */\n   RID_ATOMIC_NOEXCEPT, RID_ATOMIC_CANCEL, RID_SYNCHRONIZED,\n \n-  /* Cilk Plus keywords.  */\n-  RID_CILK_SPAWN, RID_CILK_SYNC, RID_CILK_FOR,\n-  \n   /* Objective-C (\"AT\" reserved words - they are only keywords when\n      they follow '@')  */\n   RID_AT_ENCODE,   RID_AT_END,\n@@ -586,9 +583,6 @@ extern void push_cleanup (tree, tree, bool);\n \n extern tree build_modify_expr (location_t, tree, tree, enum tree_code,\n \t\t\t       location_t, tree, tree);\n-extern tree build_array_notation_expr (location_t, tree, tree, enum tree_code,\n-\t\t\t\t       location_t, tree, tree);\n-extern tree build_array_notation_ref (location_t, tree, tree, tree, tree, tree);\n extern tree build_indirect_ref (location_t, tree, ref_operator);\n \n extern bool has_c_linkage (const_tree decl);\n@@ -1255,9 +1249,8 @@ enum c_omp_clause_split\n enum c_omp_region_type\n {\n   C_ORT_OMP\t\t\t= 1 << 0,\n-  C_ORT_CILK\t\t\t= 1 << 1,\n-  C_ORT_ACC\t\t\t= 1 << 2,\n-  C_ORT_DECLARE_SIMD\t\t= 1 << 3,\n+  C_ORT_ACC\t\t\t= 1 << 1,\n+  C_ORT_DECLARE_SIMD\t\t= 1 << 2,\n   C_ORT_OMP_DECLARE_SIMD\t= C_ORT_OMP | C_ORT_DECLARE_SIMD\n };\n \n@@ -1364,23 +1357,6 @@ enum stv_conv {\n extern enum stv_conv scalar_to_vector (location_t loc, enum tree_code code,\n \t\t\t\t       tree op0, tree op1, bool);\n \n-/* In c-cilkplus.c  */\n-extern tree c_validate_cilk_plus_loop (tree *, int *, void *);\n-extern bool c_check_cilk_loop (location_t, tree);\n-\n-/* These #defines allow users to access different operands of the\n-   array notation tree.  */\n-\n-#define ARRAY_NOTATION_CHECK(NODE) TREE_CHECK (NODE, ARRAY_NOTATION_REF)\n-#define ARRAY_NOTATION_ARRAY(NODE) \\\n-  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 0)\n-#define ARRAY_NOTATION_START(NODE) \\\n-  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 1)\n-#define ARRAY_NOTATION_LENGTH(NODE) \\\n-  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 2)\n-#define ARRAY_NOTATION_STRIDE(NODE) \\\n-  TREE_OPERAND (ARRAY_NOTATION_CHECK (NODE), 3)\n-\n /* This structure holds all the scalar values and its appropriate variable \n    replacment.  It is mainly used by the function that pulls all the invariant\n    parts that should be executed only once, which comes with array notation \n@@ -1392,76 +1368,12 @@ struct inv_list\n   vec<enum tree_code, va_gc> *additional_tcodes; \n };\n \n-/* This structure holds all the important components that can be extracted\n-   from an ARRAY_NOTATION_REF expression.  It is used to pass array notation\n-   information between the functions that are responsible for expansion.  */\n-typedef struct cilkplus_an_parts\n-{\n-  tree value;\n-  tree start;\n-  tree length;\n-  tree stride;\n-  bool is_vector;\n-} an_parts;\n-\n-/* This structure holds the components necessary to create the loop around\n-   the ARRAY_REF that is created using the ARRAY_NOTATION information.  */\n-\n-typedef struct cilkplus_an_loop_parts\n-{\n-  tree var;         /* Loop induction variable.  */\n-  tree incr;        /* Loop increment/decrement expression.  */\n-  tree cmp;         /* Loop condition.  */\n-  tree ind_init;    /* Initialization of the loop induction variable.  */\n-} an_loop_parts; \n-\n-/* In array-notation-common.c.  */\n-extern HOST_WIDE_INT extract_sec_implicit_index_arg (location_t, tree);\n-extern bool is_sec_implicit_index_fn (tree);\n-extern void array_notation_init_builtins (void);\n-extern struct c_expr fix_array_notation_expr (location_t, enum tree_code, \n-\t\t\t\t\t      struct c_expr);\n-extern bool contains_array_notation_expr (tree);\n-extern tree expand_array_notation_exprs (tree);\n-extern tree fix_conditional_array_notations (tree);\n-extern tree find_correct_array_notation_type (tree);\n-extern bool length_mismatch_in_expr_p (location_t, vec<vec<an_parts> >);\n-extern enum built_in_function is_cilkplus_reduce_builtin (tree);\n-extern bool find_rank (location_t, tree, tree, bool, size_t *);\n-extern void extract_array_notation_exprs (tree, bool, vec<tree, va_gc> **);\n-extern void replace_array_notations (tree *, bool, vec<tree, va_gc> *,\n-\t\t\t\t     vec<tree, va_gc> *);\n extern tree find_inv_trees (tree *, int *, void *);\n extern tree replace_inv_trees (tree *, int *, void *);\n-extern tree find_correct_array_notation_type (tree op);\n-extern void cilkplus_extract_an_triplets (vec<tree, va_gc> *, size_t, size_t,\n-\t\t\t\t\t  vec<vec<an_parts> > *);\n-extern vec <tree, va_gc> *fix_sec_implicit_args\n-  (location_t, vec <tree, va_gc> *, vec<an_loop_parts>, size_t, tree);\n-extern bool is_cilkplus_vector_p (tree);\n-\n-/* In cilk.c.  */\n-extern tree insert_cilk_frame (tree);\n-extern void cilk_init_builtins (void);\n-extern int gimplify_cilk_spawn (tree *);\n-extern void cilk_install_body_with_frame_cleanup (tree, tree, void *);\n-extern bool cilk_detect_spawn_and_unwrap (tree *);\n-extern bool cilk_set_spawn_marker (location_t, tree);\n-extern tree build_cilk_sync (void);\n-extern tree build_cilk_spawn (location_t, tree);\n-extern tree make_cilk_frame (tree);\n-extern tree create_cilk_function_exit (tree, bool, bool);\n-extern void cilk_outline (tree, tree *, void *);\n-extern bool contains_cilk_spawn_stmt (tree);\n-extern tree cilk_for_number_of_iterations (tree);\n-extern bool check_no_cilk (tree, const char *, const char *,\n-\t\t           location_t loc = UNKNOWN_LOCATION);\n+\n extern bool reject_gcc_builtin (const_tree, location_t = UNKNOWN_LOCATION);\n extern bool valid_array_size_p (location_t, tree, tree);\n \n-extern bool cilk_ignorable_spawn_rhs_op (tree);\n-extern bool cilk_recognize_spawn (tree, tree *);\n-\n /* In c-warn.c.  */\n extern void constant_expression_warning (tree);\n extern void constant_expression_error (tree);"}, {"sha": "152eb8ad29e03de1440a2381a22f928f67e1ccd6", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -36,7 +36,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"langhooks.h\"\n #include \"dumpfile.h\"\n-#include \"cilk.h\"\n #include \"c-ubsan.h\"\n \n /*  The gimplification pass converts the language-dependent trees\n@@ -277,25 +276,6 @@ c_gimplify_expr (tree *expr_p, gimple_seq *pre_p ATTRIBUTE_UNUSED,\n \tbreak;\n       }\n \n-    case CILK_SPAWN_STMT:\n-      gcc_assert(fn_contains_cilk_spawn_p (cfun)\n-\t\t && cilk_detect_spawn_and_unwrap (expr_p));\n-\n-      if (!seen_error ())\n-        return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n-      return GS_ERROR;\n-\n-    case MODIFY_EXPR:\n-    case INIT_EXPR:\n-    case CALL_EXPR:\n-      if (fn_contains_cilk_spawn_p (cfun)\n-\t  && cilk_detect_spawn_and_unwrap (expr_p)\n-\t  /* If an error is found, the spawn wrapper is removed and the\n-\t     original expression (MODIFY/INIT/CALL_EXPR) is processes as\n-\t     it is supposed to be.  */\n-\t  && !seen_error ())\n-        return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n-\n     default:;\n     }\n "}, {"sha": "5c5d7a73fdd3eae60cbd23e0c5dc638e48c2bcd2", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -536,10 +536,6 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   bool fail = false;\n   int i;\n \n-  if ((code == CILK_SIMD || code == CILK_FOR)\n-      && !c_check_cilk_loop (locus, TREE_VEC_ELT (declv, 0)))\n-    fail = true;\n-\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (initv));\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (condv));\n   gcc_assert (TREE_VEC_LENGTH (declv) == TREE_VEC_LENGTH (incrv));\n@@ -671,8 +667,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t{\n \t\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (decl)))\n \t\t    {\n-\t\t      if (code != CILK_SIMD && code != CILK_FOR)\n-\t\t\tcond_ok = false;\n+\t\t      cond_ok = false;\n \t\t    }\n \t\t  else if (operand_equal_p (TREE_OPERAND (cond, 1),\n \t\t\t\t\t    TYPE_MIN_VALUE (TREE_TYPE (decl)),\n@@ -684,7 +679,7 @@ c_finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t\t\t\t    0))\n \t\t    TREE_SET_CODE (cond, TREE_CODE (cond) == NE_EXPR\n \t\t\t\t\t ? LT_EXPR : GE_EXPR);\n-\t\t  else if (code != CILK_SIMD && code != CILK_FOR)\n+\t\t  else\n \t\t    cond_ok = false;\n \t\t}\n "}, {"sha": "daa9e5ade388bad5b5f7ed86a3b477e2eb574801", "filename": "gcc/c-family/c-pragma.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1343,20 +1343,6 @@ c_pp_lookup_pragma (unsigned int id, const char **space, const char **name)\n \treturn;\n       }\n \n-  if (id == PRAGMA_CILK_SIMD)\n-    {\n-      *space = NULL;\n-      *name = \"simd\";\n-      return;\n-    }\n-\n-  if (id == PRAGMA_CILK_GRAINSIZE)\n-    {\n-      *space = \"cilk\";\n-      *name = \"grainsize\";\n-      return;\n-    }\n-\n   if (id >= PRAGMA_FIRST_EXTERNAL\n       && (id < PRAGMA_FIRST_EXTERNAL + registered_pp_pragmas.length ()))\n     {\n@@ -1532,10 +1518,6 @@ init_pragma (void)\n \t\t\t\t      omp_pragmas_simd[i].id, true, true);\n     }\n \n-  if (flag_cilkplus)\n-    cpp_register_deferred_pragma (parse_in, NULL, \"simd\", PRAGMA_CILK_SIMD,\n-\t\t\t\t  true, false);\n-\n   if (!flag_preprocess_only)\n     cpp_register_deferred_pragma (parse_in, \"GCC\", \"pch_preprocess\",\n \t\t\t\t  PRAGMA_GCC_PCH_PREPROCESS, false, false);\n@@ -1544,10 +1526,6 @@ init_pragma (void)\n     cpp_register_deferred_pragma (parse_in, \"GCC\", \"ivdep\", PRAGMA_IVDEP, false,\n \t\t\t\t  false);\n \n-  if (flag_cilkplus)\n-    cpp_register_deferred_pragma (parse_in, \"cilk\", \"grainsize\",\n-\t\t\t\t  PRAGMA_CILK_GRAINSIZE, true, false);\n-\n #ifdef HANDLE_PRAGMA_PACK_WITH_EXPANSION\n   c_register_pragma_with_expansion (0, \"pack\", handle_pragma_pack);\n #else"}, {"sha": "e035b3a8eca5b9273088ad49d5979ab552c32f62", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -67,12 +67,6 @@ enum pragma_kind {\n   PRAGMA_OMP_THREADPRIVATE,\n   PRAGMA_OMP_TEAMS,\n \n-  /* Top level clause to handle all Cilk Plus pragma simd clauses.  */\n-  PRAGMA_CILK_SIMD,\n-\n-  /* This pragma handles setting of grainsize for a _Cilk_for.  */\n-  PRAGMA_CILK_GRAINSIZE,\n-\n   PRAGMA_GCC_PCH_PREPROCESS,\n   PRAGMA_IVDEP,\n \n@@ -134,20 +128,8 @@ enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_UNTIED,\n   PRAGMA_OMP_CLAUSE_USE_DEVICE_PTR,\n \n-  /* Clauses for Cilk Plus SIMD-enabled function.  */\n-  PRAGMA_CILK_CLAUSE_NOMASK,\n-  PRAGMA_CILK_CLAUSE_MASK,\n-  PRAGMA_CILK_CLAUSE_VECTORLENGTH,\n-  PRAGMA_CILK_CLAUSE_NONE = PRAGMA_OMP_CLAUSE_NONE,\n-  PRAGMA_CILK_CLAUSE_LINEAR = PRAGMA_OMP_CLAUSE_LINEAR,\n-  PRAGMA_CILK_CLAUSE_PRIVATE = PRAGMA_OMP_CLAUSE_PRIVATE,\n-  PRAGMA_CILK_CLAUSE_FIRSTPRIVATE = PRAGMA_OMP_CLAUSE_FIRSTPRIVATE,\n-  PRAGMA_CILK_CLAUSE_LASTPRIVATE = PRAGMA_OMP_CLAUSE_LASTPRIVATE,\n-  PRAGMA_CILK_CLAUSE_REDUCTION = PRAGMA_OMP_CLAUSE_REDUCTION,\n-  PRAGMA_CILK_CLAUSE_UNIFORM = PRAGMA_OMP_CLAUSE_UNIFORM,\n-\n   /* Clauses for OpenACC.  */\n-  PRAGMA_OACC_CLAUSE_ASYNC = PRAGMA_CILK_CLAUSE_VECTORLENGTH + 1,\n+  PRAGMA_OACC_CLAUSE_ASYNC,\n   PRAGMA_OACC_CLAUSE_AUTO,\n   PRAGMA_OACC_CLAUSE_COPY,\n   PRAGMA_OACC_CLAUSE_COPYOUT,"}, {"sha": "de5ab4b54353309608d219fde48d6d34db9d9340", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1482,17 +1482,6 @@ c_pretty_printer::postfix_expression (tree e)\n       pp_c_right_bracket (this);\n       break;\n \n-    case ARRAY_NOTATION_REF:\n-      postfix_expression (ARRAY_NOTATION_ARRAY (e));\n-      pp_c_left_bracket (this);\n-      expression (ARRAY_NOTATION_START (e));\n-      pp_colon (this);\n-      expression (ARRAY_NOTATION_LENGTH (e));\n-      pp_colon (this);\n-      expression (ARRAY_NOTATION_STRIDE (e));\n-      pp_c_right_bracket (this);\n-      break;\n-      \n     case CALL_EXPR:\n       {\n \tcall_expr_arg_iterator iter;\n@@ -2192,7 +2181,6 @@ c_pretty_printer::expression (tree e)\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n     case ARRAY_REF:\n-    case ARRAY_NOTATION_REF:\n     case CALL_EXPR:\n     case COMPONENT_REF:\n     case BIT_FIELD_REF:"}, {"sha": "b25481057365a59e9ce49aa0a8b3d52726550cd6", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1330,9 +1330,9 @@ Driver\n static-libmpxwrappers\n Driver\n \n-fcilkplus\n+fcilkplus Undocumented\n C ObjC C++ ObjC++ LTO Report Var(flag_cilkplus) Init(0)\n-Enable Cilk Plus.\n+Deprecated in GCC 8.  This switch has no effect.\n \n fconcepts\n C++ ObjC++ Var(flag_concepts)"}, {"sha": "e6df498e471a05d623d579e97e376720ce4808c1", "filename": "gcc/c-family/cilk.c", "status": "removed", "additions": 0, "deletions": 1363, "changes": 1363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,1363 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   This file contains the CilkPlus Intrinsics\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n-   Intel Corporation\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"function.h\"\n-#include \"c-family/c-common.h\"\n-#include \"gimple-expr.h\"\n-#include \"stringpool.h\"\n-#include \"cgraph.h\"\n-#include \"diagnostic.h\"\n-#include \"gimplify.h\"\n-#include \"tree-iterator.h\"\n-#include \"tree-inline.h\"\n-#include \"toplev.h\"\n-#include \"calls.h\"\n-#include \"cilk.h\"\n-\n-enum add_variable_type {\n-    /* Reference to previously-defined variable.  */\n-    ADD_READ,\n-    /* Definition of a new variable in inner-scope.  */\n-    ADD_BIND,\n-    /* Write to possibly previously-defined variable.  */\n-    ADD_WRITE\n-};\n-\n-enum cilk_block_type {\n-    /* Indicates a _Cilk_spawn block.  30 was an arbitary number picked for \n-       ease of debugging.  */\n-    CILK_BLOCK_SPAWN = 30,\n-    /* Indicates _Cilk_for statement block.  */\n-    CILK_BLOCK_FOR\n-};\n-\n-struct wrapper_data\n-{\n-  /* Kind of function to be created.  */\n-  enum cilk_block_type type;\n-  /* Signature of helper function.  */\n-  tree fntype;\n-  /* Containing function.  */\n-  tree context;\n-  /* Disposition of all variables in the inner statement.  */\n-  hash_map<tree, tree> *decl_map;\n-  /* True if this function needs a static chain.  */\n-  bool nested;\n-  /* Arguments to be passed to wrapper function, currently a list.  */\n-  tree arglist;\n-  /* Argument types, a list.  */\n-  tree argtypes;\n-  /* Incoming parameters.  */\n-  tree parms;\n-  /* Outer BLOCK object.  */\n-  tree block;\n-};\n-\n-static tree contains_cilk_spawn_stmt_walker (tree *tp, int *, void *);\n-static void extract_free_variables (tree, struct wrapper_data *,\n-\t\t\t\t    enum add_variable_type);\n-static HOST_WIDE_INT cilk_wrapper_count;\n-\n-/* Marks the CALL_EXPR or FUNCTION_DECL, FCALL, as a spawned function call\n-   and the current function as a spawner.  Emit error if the function call\n-   is outside a function or if a non function-call is spawned.  */\n-\n-inline bool\n-cilk_set_spawn_marker (location_t loc, tree fcall)\n-{\n-  if (!current_function_decl)\n-    {\n-      error_at (loc, \"%<_Cilk_spawn%> may only be used inside a function\");\n-      return false;\n-    }\n-  else if (fcall == error_mark_node)\n-    /* Error reporting here is not necessary here since if FCALL is an\n-       error_mark_node, the function marking it as error would have reported\n-       it.  */\n-    return false; \n-  else if (TREE_CODE (fcall) != CALL_EXPR\n-\t   /* In C++, TARGET_EXPR is generated when we have an overloaded\n-\t      '=' operator.  */\n-\t   && TREE_CODE (fcall) != TARGET_EXPR)\n-    { \n-      error_at (loc, \"only function calls can be spawned\");\n-      return false;\n-    }\n-  else\n-    {\n-      cfun->calls_cilk_spawn = true;\n-      if (TREE_CODE (fcall) == CALL_EXPR)\n-        EXPR_CILK_SPAWN (fcall) = 1;\n-      else /* TREE_CODE (fcall) == TARGET_EXPR */\n-        EXPR_CILK_SPAWN (TREE_OPERAND (fcall, 1)) = 1;\n-      return true;\n-    }\n-}\n-\n-/* This function will output the exit conditions for a spawn call.  */\n-\n-tree\n-create_cilk_function_exit (tree frame, bool detaches, bool needs_sync)\n-{\n-  tree epi = alloc_stmt_list ();\n-\n-  if (needs_sync) \n-    append_to_statement_list (build_cilk_sync (), &epi);\n-  tree func_ptr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, frame);\n-  tree pop_frame = build_call_expr (cilk_pop_fndecl, 1, func_ptr);\n-  tree worker = cilk_dot (frame, CILK_TI_FRAME_WORKER, 0);\n-  tree current = cilk_arrow (worker, CILK_TI_WORKER_CUR, 0);\n-  tree parent = cilk_dot (frame, CILK_TI_FRAME_PARENT, 0);\n-  tree set_current = build2 (MODIFY_EXPR, void_type_node, current, parent);\n-  append_to_statement_list (set_current, &epi);\n-  append_to_statement_list (pop_frame, &epi);\n-  tree call = build_call_expr (cilk_leave_fndecl, 1, func_ptr);\n-  if (!detaches)\n-    {\n-      tree flags = cilk_dot (frame, CILK_TI_FRAME_FLAGS, false);\n-      tree flags_cmp_expr = fold_build2 (NE_EXPR, TREE_TYPE (flags), flags, \n-\t\t\t\t\t build_int_cst (TREE_TYPE (flags), \n-\t\t\t\t\t\t\tCILK_FRAME_VERSION));\n-      call = fold_build3 (COND_EXPR, void_type_node, flags_cmp_expr,\n-\t\t\t  call, build_empty_stmt (EXPR_LOCATION (flags)));\n-    }\n-  append_to_statement_list (call, &epi);  \n-  return epi;\n-}\n-\n-/* Trying to get the correct cfun for the FUNCTION_DECL indicated by OUTER.  */\n-\n-static void\n-pop_cfun_to (tree outer)\n-{\n-  pop_cfun ();\n-  current_function_decl = outer;\n-  gcc_assert (cfun == DECL_STRUCT_FUNCTION (current_function_decl));\n-  gcc_assert (cfun->decl == current_function_decl);\n-}\n-\n-/* This function does whatever is necessary to make the compiler emit a newly \n-   generated function, FNDECL.  */\n-\n-static void\n-call_graph_add_fn (tree fndecl)\n-{\n-  const tree outer = current_function_decl;\n-  struct function *f = DECL_STRUCT_FUNCTION (fndecl);\n-  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n-\n-  f->is_cilk_function = 1;\n-  f->curr_properties = cfun->curr_properties;\n-  gcc_assert (cfun == DECL_STRUCT_FUNCTION (outer)); \n-  gcc_assert (cfun->decl == outer);\n-\n-  push_cfun (f);\n-  cgraph_node::create (fndecl);\n-  pop_cfun_to (outer);\n-}\n-\n-/* Return true if this is a tree which is allowed to contain a spawn as \n-   operand 0.\n-   A spawn call may be wrapped in a series of unary operations such\n-   as conversions.  These conversions need not be \"useless\"\n-   to be disregarded because they are retained in the spawned\n-   statement.  They are bypassed only to look for a spawn\n-   within.\n-   A comparison to constant is simple enough to allow, and\n-   is used to convert to bool.  */\n-\n-bool\n-cilk_ignorable_spawn_rhs_op (tree exp)\n-{\n-  enum tree_code code = TREE_CODE (exp);\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_expression:\n-      return code == ADDR_EXPR;\n-    case tcc_comparison:\n-      /* We need the spawn as operand 0 for now.   That's where it\n-\t appears in the only case we really care about, conversion\n-\t to bool.  */\n-      return (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST);\n-    case tcc_unary:\n-    case tcc_reference:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Helper function for walk_tree.  If *TP is a CILK_SPAWN_STMT, then unwrap\n-   this \"wrapper.\"  The function returns NULL_TREE regardless.  */\n-\n-static tree\n-unwrap_cilk_spawn_stmt (tree *tp, int *walk_subtrees, void *)\n-{\n-  if (TREE_CODE (*tp) == CILK_SPAWN_STMT)\n-    {\n-      *tp = CILK_SPAWN_FN (*tp);\n-      *walk_subtrees = 0;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Returns true when EXP is a CALL_EXPR with _Cilk_spawn in front.  Unwraps\n-   CILK_SPAWN_STMT wrapper from the CALL_EXPR in *EXP0 statement.  */\n-\n-bool\n-cilk_recognize_spawn (tree exp, tree *exp0)\n-{\n-  bool spawn_found = false;\n-  if (TREE_CODE (exp) == CILK_SPAWN_STMT)\n-    {\n-      /* Remove the CALL_EXPR from CILK_SPAWN_STMT wrapper.  */\n-      exp = CILK_SPAWN_FN (exp);\n-      walk_tree (exp0, unwrap_cilk_spawn_stmt, NULL, NULL);\n-      spawn_found = true;\n-    }\n-  /* _Cilk_spawn can't be wrapped in expression such as PLUS_EXPR.  */\n-  else if (contains_cilk_spawn_stmt (exp))\n-    {\n-      location_t loc = EXPR_LOCATION (exp);\n-      if (loc == UNKNOWN_LOCATION)\n-\t{\n-\t  tree stmt = walk_tree (&exp,\n-\t\t\t\t contains_cilk_spawn_stmt_walker,\n-\t\t\t\t NULL,\n-\t\t\t\t NULL);\n-\t  gcc_assert (stmt != NULL_TREE);\n-\t  loc = EXPR_LOCATION (stmt);\n-\t}\n-      error_at (loc, \"invalid use of %<_Cilk_spawn%>\");\n-    }\n-  return spawn_found;\n-}\n-\n-/* Returns true if *EXP0 is a recognized form of spawn.  Recognized forms are,\n-   after conversion to void, a call expression at outer level or an assignment\n-   at outer level with the right hand side being a spawned call.\n-   In addition to this, it also unwraps the CILK_SPAWN_STMT cover from the\n-   CALL_EXPR that is being spawned.\n-   Note that `=' in C++ may turn into a CALL_EXPR rather than a MODIFY_EXPR.  */\n-\n-bool\n-cilk_detect_spawn_and_unwrap (tree *exp0)\n-{\n-  tree exp = *exp0;\n-\n-  if (!TREE_SIDE_EFFECTS (exp))\n-    return false;\n-\n-  /* Strip off any conversion to void.  It does not affect whether spawn \n-     is supported here.  */\n-  if (TREE_CODE (exp) == CONVERT_EXPR && VOID_TYPE_P (TREE_TYPE (exp)))\n-    exp = TREE_OPERAND (exp, 0);\n-\n-  if (TREE_CODE (exp) == MODIFY_EXPR || TREE_CODE (exp) == INIT_EXPR)\n-    exp = TREE_OPERAND (exp, 1);\n-\n-  while (cilk_ignorable_spawn_rhs_op (exp))\n-    exp = TREE_OPERAND (exp, 0);\n-\n-  if (TREE_CODE (exp) == TARGET_EXPR)\n-    if (TARGET_EXPR_INITIAL (exp)\n-\t&& TREE_CODE (TARGET_EXPR_INITIAL (exp)) != AGGR_INIT_EXPR)\n-      exp = TARGET_EXPR_INITIAL (exp);\n-\n-  /* Happens with C++ TARGET_EXPR.  */\n-  if (exp == NULL_TREE)\n-    return false;\n-\n-  while (TREE_CODE (exp) == CLEANUP_POINT_EXPR || TREE_CODE (exp) == EXPR_STMT)\n-    exp = TREE_OPERAND (exp, 0);\n-  \n-  /* Now we should have a CALL_EXPR with a CILK_SPAWN_STMT wrapper around \n-     it, or return false.  */\n-  if (cilk_recognize_spawn (exp, exp0))\n-    return true;\n-  return false;\n-}\n-\n-/* This function will build and return a FUNCTION_DECL using information \n-   from *WD.  */\n-\n-static tree\n-create_cilk_helper_decl (struct wrapper_data *wd)\n-{\n-  char name[20];\n-  if (wd->type == CILK_BLOCK_FOR)\n-    sprintf (name, \"_cilk_for_\" HOST_WIDE_INT_PRINT_DEC, cilk_wrapper_count++);\n-  else if (wd->type == CILK_BLOCK_SPAWN)\n-    sprintf (name, \"_cilk_spn_\" HOST_WIDE_INT_PRINT_DEC, cilk_wrapper_count++);\n-  else\n-    gcc_unreachable (); \n-  \n-  clean_symbol_name (name);\n-\n-  tree fndecl = build_decl (DECL_SOURCE_LOCATION (current_function_decl),\n-\t\t\t    FUNCTION_DECL, get_identifier (name), wd->fntype);\n-\n-  TREE_PUBLIC (fndecl) = 0;\n-  TREE_STATIC (fndecl) = 1;\n-  TREE_USED (fndecl) = 1;\n-  DECL_ARTIFICIAL (fndecl) = 0;\n-  DECL_IGNORED_P (fndecl) = 0;\n-  DECL_EXTERNAL (fndecl) = 0;\n-\n-  DECL_CONTEXT (fndecl) = wd->context; \n-  tree block = make_node (BLOCK);\n-  DECL_INITIAL (fndecl) = block;\n-  TREE_USED (block) = 1;\n-  BLOCK_SUPERCONTEXT (block) = fndecl;\n-  gcc_assert (!DECL_SAVED_TREE (fndecl));\n-\n-  /* Inlining would defeat the purpose of this wrapper.\n-     Either it secretly switches stack frames or it allocates\n-     a stable stack frame to hold function arguments even if\n-     the parent stack frame is stolen.  */\n-  DECL_UNINLINABLE (fndecl) = 1;\n-\n-  tree result_decl = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, \n-\t\t\t\t void_type_node);\n-  DECL_ARTIFICIAL (result_decl) = 0;\n-  DECL_IGNORED_P (result_decl) = 1;\n-  DECL_CONTEXT (result_decl) = fndecl;\n-  DECL_RESULT (fndecl) = result_decl;\n-  \n-  return fndecl;\n-}\n-\n-struct cilk_decls\n-{\n-  tree key;\n-  tree *val;\n-};\n-\n-/* A function used by traversal to fill vector of decls for further work.  */\n-\n-bool\n-fill_decls_vec (tree const &key0, tree *val0, auto_vec<struct cilk_decls> *v)\n-{\n-  tree t1 = key0;\n-  struct cilk_decls dp;\n-\n-  if (DECL_P (t1))\n-    {\n-      dp.key = t1;\n-      dp.val = val0;\n-      v->safe_push (dp);\n-    }\n-  return true;\n-}\n-\n-/* Function that actually creates necessary parm lists.  */\n-\n-static void\n-create_parm_list (struct wrapper_data *wd, tree *val0, tree arg)\n-{\n-  tree val = *val0;\n-  tree parm;\n-\n-  if (val == error_mark_node || val == arg)\n-    return;\n-\n-  if (TREE_CODE (val) == PAREN_EXPR)\n-    {\n-      /* We should not reach here with a register receiver.\n-\t We may see a register variable modified in the\n-\t argument list.  Because register variables are\n-\t worker-local we don't need to work hard to support\n-\t them in code that spawns.  */\n-      if (VAR_P (arg) && DECL_HARD_REGISTER (arg))\n-\t{\n-\t  error_at (EXPR_LOCATION (arg),\n-\t\t    \"explicit register variable %qD may not be modified in \"\n-\t\t    \"spawn\", arg);\n-\t  arg = null_pointer_node;\n-\t}\n-      else\n-\targ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), arg);\n-\n-      val = TREE_OPERAND (val, 0);\n-      *val0 = val;\n-      gcc_assert (INDIRECT_REF_P (val));\n-      parm = TREE_OPERAND (val, 0);\n-      STRIP_NOPS (parm);\n-    }\n-  else\n-    parm = val;\n-  TREE_CHAIN (parm) = wd->parms;\n-  wd->parms = parm;\n-  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes);\n-  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist);\n-}\n-\n-/* Sorting decls in a vector.  */\n-\n-static int\n-compare_decls (const void *a, const void *b)\n-{\n-  const struct cilk_decls *t1 = (const struct cilk_decls *) a;\n-  const struct cilk_decls *t2 = (const struct cilk_decls *) b;\n-\n-  if (DECL_UID (t1->key) > DECL_UID (t2->key))\n-    return 1;\n-  else if (DECL_UID (t1->key) < DECL_UID (t2->key))\n-    return -1;\n-  else\n-    return 0;\n-}\n-\n-/* This function is used to build a wrapper of a certain type.  */\n-\n-static void\n-build_wrapper_type (struct wrapper_data *wd)\n-{\n-  unsigned int j;\n-  struct cilk_decls * c;\n-  auto_vec<struct cilk_decls> vd;\n-  wd->arglist = NULL_TREE;\n-  wd->parms = NULL_TREE;\n-  wd->argtypes = void_list_node;\n-\n-  gcc_assert (wd->type != CILK_BLOCK_FOR);\n-  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n-  vd.qsort (compare_decls);\n-\n-  FOR_EACH_VEC_ELT (vd, j, c)\n-   create_parm_list (wd, c->val, c->key);\n-\n-  /* Now build a function.\n-     Its return type is void (all side effects are via explicit parameters).\n-     Its parameters are WRAPPER_PARMS with type WRAPPER_TYPES.\n-     Actual arguments in the caller are WRAPPER_ARGS.  */\n-  wd->fntype = build_function_type (void_type_node, wd->argtypes);\n-}\n-\n-/* This function checks all the CALL_EXPRs in *TP found by cilk_outline.  */\n-\n-static tree\n-check_outlined_calls (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, \n-\t\t      void *data)\n-{\n-  bool *throws = (bool *) data;\n-  tree t = *tp;\n-  int flags;\n-\n-  if (TREE_CODE (t) != CALL_EXPR)\n-    return 0;\n-  flags = call_expr_flags (t);\n-\n-  if (!(flags & ECF_NOTHROW) && flag_exceptions)\n-    *throws = true;\n-  if (flags & ECF_RETURNS_TWICE)\n-    error_at (EXPR_LOCATION (t), \n-\t      \"cannot spawn call to function that returns twice\");\n-  return 0;\n-}\n-\n-/* Each DECL in the source code (spawned statement) is passed to this function\n-   once.  Each instance of the DECL is replaced with the result of this \n-   function.\n-\n-   The parameters of the wrapper should have been entered into the map already.\n-   This function only deals with variables with scope limited to the \n-   spawned expression.  */\n-\n-static tree\n-copy_decl_for_cilk (tree decl, copy_body_data *id)\n-{\n-  switch (TREE_CODE (decl))\n-    {\n-    case VAR_DECL:\n-      return copy_decl_no_change (decl, id);\n-\n-    case LABEL_DECL:\n-      error_at (EXPR_LOCATION (decl), \"invalid use of label %q+D in \"\n-\t\t\"%<_Cilk_spawn%>\", \n-\t\tdecl);\n-      return error_mark_node;\n-\n-    case RESULT_DECL:\n-    case PARM_DECL:\n-      /* RESULT_DECL and PARM_DECL has already been entered into the map.  */\n-    default:\n-      gcc_unreachable ();\n-      return error_mark_node;\n-    }\n-}\n-\n-/* Alter a tree STMT from OUTER_FN to form the body of INNER_FN.  */\n-\n-void\n-cilk_outline (tree inner_fn, tree *stmt_p, void *w)\n-{\n-  struct wrapper_data *wd = (struct wrapper_data *) w;\n-  const tree outer_fn = wd->context;\n-  const bool nested = (wd->type == CILK_BLOCK_FOR);\n-  copy_body_data id;\n-  bool throws;\n-  auto_vec<struct cilk_decls> vd;\n-  unsigned int j;\n-  struct cilk_decls * c;\n-\n-  DECL_STATIC_CHAIN (outer_fn) = 1;\n-\n-  memset (&id, 0, sizeof (id));\n-  /* Copy from the function containing the spawn...  */\n-  id.src_fn = outer_fn;\n-\n-  /* ...to the wrapper.  */\n-  id.dst_fn = inner_fn; \n-  id.src_cfun = DECL_STRUCT_FUNCTION (outer_fn);\n-\n-  /* There shall be no RETURN in spawn helper.  */\n-  id.retvar = 0; \n-  id.decl_map = wd->decl_map;\n-  id.copy_decl = nested ? copy_decl_no_change : copy_decl_for_cilk;\n-  id.block = DECL_INITIAL (inner_fn);\n-  id.transform_lang_insert_block = NULL;\n-\n-  id.transform_new_cfg = true;\n-  id.transform_call_graph_edges = CB_CGE_MOVE;\n-  id.remap_var_for_cilk = true;\n-  id.regimplify = true; /* unused? */\n-\n-  insert_decl_map (&id, wd->block, DECL_INITIAL (inner_fn));\n-\n-  wd->decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n-  vd.qsort (compare_decls);\n-  /* We don't want the private variables any more.  */\n-  FOR_EACH_VEC_ELT (vd, j, c)\n-   if (*(c->val) == error_mark_node)\n-     *(c->val) = nested ? copy_decl_no_change (c->key, &id)\n-\t\t\t: copy_decl_for_cilk (c->key, &id);\n-\n-  walk_tree (stmt_p, copy_tree_body_r, (void *) &id, NULL);\n-\n-  /* See if this function can throw or calls something that should\n-     not be spawned.  The exception part is only necessary if\n-     flag_exceptions && !flag_non_call_exceptions.  */\n-  throws = false ;\n-  (void) walk_tree_without_duplicates (stmt_p, check_outlined_calls, &throws);\n-}\n-\n-/* Generate the body of a wrapper function that assigns the\n-   result of the expression RHS into RECEIVER.  RECEIVER must\n-   be NULL if this is not a spawn -- the wrapper will return\n-   a value.  If this is a spawn, the wrapper will return void.  */\n-\n-static tree\n-create_cilk_wrapper_body (tree stmt, struct wrapper_data *wd)\n-{\n-  const tree outer = current_function_decl;\n-  tree fndecl;\n-  tree p;\n-\n-   /* Build the type of the wrapper and its argument list from the\n-     variables that it requires.  */\n-  build_wrapper_type (wd);\n-\n-  /* Emit a function that takes WRAPPER_PARMS incoming and applies ARGS \n-     (modified) to the wrapped function.  Return the wrapper and modified ARGS \n-     to the caller to generate a function call.  */\n-  fndecl = create_cilk_helper_decl (wd);\n-  push_struct_function (fndecl);\n-  if (wd->nested && (wd->type == CILK_BLOCK_FOR))\n-    {\n-      gcc_assert (TREE_VALUE (wd->arglist) == NULL_TREE);\n-      TREE_VALUE (wd->arglist) = build2 (FDESC_EXPR, ptr_type_node,\n-\t\t\t\t\t fndecl, integer_one_node);\n-    }\n-  DECL_ARGUMENTS (fndecl) = wd->parms;\n-\n-  for (p = wd->parms; p; p = TREE_CHAIN (p))\n-    DECL_CONTEXT (p) = fndecl;\n-\n-  /* The statement containing the spawn expression might create temporaries with\n-     destructors defined; if so we need to add a CLEANUP_POINT_EXPR to ensure\n-     the expression is properly gimplified.  */\n-  stmt = fold_build_cleanup_point_expr (void_type_node, stmt);\n-\n-  gcc_assert (!DECL_SAVED_TREE (fndecl));\n-  cilk_install_body_with_frame_cleanup (fndecl, stmt, (void *) wd);\n-  gcc_assert (DECL_SAVED_TREE (fndecl));\n-\n-  pop_cfun_to (outer);\n-\n-  /* Recognize the new function.  */\n-  call_graph_add_fn (fndecl);\n-  return fndecl;\n-}\n-\n-/* Initializes the wrapper data structure.  */\n-\n-static void\n-init_wd (struct wrapper_data *wd, enum cilk_block_type type)\n-{\n-  wd->type = type;\n-  wd->fntype = NULL_TREE;\n-  wd->context = current_function_decl;\n-  wd->decl_map = new hash_map<tree, tree>;\n-  /* _Cilk_for bodies are always nested.  Others start off as \n-     normal functions.  */\n-  wd->nested = (type == CILK_BLOCK_FOR);\n-  wd->arglist = NULL_TREE;\n-  wd->argtypes = NULL_TREE;\n-  wd->block = NULL_TREE;\n-}\n-\n-/* Clears the wrapper data structure.  */\n-\n-static void\n-free_wd (struct wrapper_data *wd)\n-{\n-  delete wd->decl_map;\n-  wd->nested = false;\n-  wd->arglist = NULL_TREE;\n-  wd->argtypes = NULL_TREE;\n-  wd->parms = NULL_TREE;\n-}\n-\n-\n- /* Given a variable in an expression to be extracted into\n-   a helper function, declare the helper function parameter\n-   to receive it.\n-\n-   On entry the value of the (key, value) pair may be\n-\n-   (*, error_mark_node) -- Variable is private to helper function,\n-   do nothing.\n-\n-   (var, var) -- Reference to outer scope (function or global scope).\n-\n-   (var, integer 0) -- Capture by value, save newly-declared PARM_DECL\n-   for value in value slot.\n-\n-   (var, integer 1) -- Capture by reference, declare pointer to type\n-   as new PARM_DECL and store (spawn_stmt (indirect_ref (parm)).\n-   \n-   (var, ???) -- Pure output argument, handled similarly to above.\n-*/\n-\n-bool\n-declare_one_free_variable (tree var0, tree *map0)\n-{\n-  const_tree var = var0;\n-  tree map = *map0;\n-  tree var_type = TREE_TYPE (var), arg_type;\n-  bool by_reference;\n-  tree parm;\n-\n-  gcc_assert (DECL_P (var));\n-\n-  /* Ignore truly local variables.  */\n-  if (map == error_mark_node)\n-    return true;\n-  /* Ignore references to the parent function.  */\n-  if (map == var)\n-    return true;\n-\n-  gcc_assert (TREE_CODE (map) == INTEGER_CST);\n-\n-  /* A value is passed by reference if:\n-\n-     1. It is addressable, so that a copy may not be made.\n-     2. It is modified in the spawned statement.\n-     In the future this function may want to arrange\n-     a warning if the spawned statement is a loop body\n-     because an output argument would indicate a race.\n-     Note: Earlier passes must have marked the variable addressable.\n-     3. It is expensive to copy.  */\n-  by_reference =\n-    (TREE_ADDRESSABLE (var_type)\n-     /* Arrays must be passed by reference.  This is required for C\n-\tsemantics -- arrays are not first class objects.  Other\n-\taggregate types can and should be passed by reference if\n-\tthey are not passed to the spawned function.  We aren't yet\n-\tdistinguishing safe uses in argument calculation from unsafe\n-\tuses as outgoing function arguments, so we make a copy to\n-\tstabilize the value.  */\n-     || TREE_CODE (var_type) == ARRAY_TYPE\n-     || (tree) map == integer_one_node);\n-\n-  if (by_reference)\n-    var_type = build_qualified_type (build_pointer_type (var_type),\n-\t\t\t\t     TYPE_QUAL_RESTRICT);\n-  gcc_assert (!TREE_ADDRESSABLE (var_type));\n-\n-  /* Maybe promote to int.  */\n-  if (INTEGRAL_TYPE_P (var_type) && COMPLETE_TYPE_P (var_type)\n-      && tree_int_cst_lt (TYPE_SIZE (var_type), TYPE_SIZE (integer_type_node)))\n-    arg_type = integer_type_node;\n-  else\n-    arg_type = var_type;\n-\n-  parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE, var_type);\n-  DECL_ARG_TYPE (parm) = arg_type;\n-  DECL_ARTIFICIAL (parm) = 0;\n-  TREE_READONLY (parm) = 1;\n-  \n-  if (by_reference)\n-    {\n-      parm = build1 (INDIRECT_REF, TREE_TYPE (var_type), parm);\n-      parm = build1 (PAREN_EXPR, void_type_node, parm);\n-    }\n-  *map0 = parm;\n-  return true;\n-}\n- \n-/* Returns a wrapper function for a _Cilk_spawn.  */\n-\n-static tree\n-create_cilk_wrapper (tree exp, tree *args_out)\n-{\n-  struct wrapper_data wd;\n-  tree fndecl;\n-  unsigned int j;\n-  struct cilk_decls * c;\n-  auto_vec<struct cilk_decls> vd;\n-\n-  init_wd (&wd, CILK_BLOCK_SPAWN);\n-\n-  if (TREE_CODE (exp) == CONVERT_EXPR)\n-    exp = TREE_OPERAND (exp, 0);\n-  \n-  /* Special handling for top level INIT_EXPR.  Usually INIT_EXPR means the \n-     variable is defined in the spawned expression and can be private to the \n-     spawn helper.  A top level INIT_EXPR defines a variable to be initialized \n-     by spawn and the variable must remain in the outer function.  */\n-  if (TREE_CODE (exp) == INIT_EXPR)\n-    {\n-      extract_free_variables (TREE_OPERAND (exp, 0), &wd, ADD_WRITE);\n-      extract_free_variables (TREE_OPERAND (exp, 1), &wd, ADD_READ);\n-      /* TREE_TYPE should be void.  Be defensive.  */\n-      if (TREE_TYPE (exp) != void_type_node)\n-\textract_free_variables (TREE_TYPE (exp), &wd, ADD_READ);\n-    }\n-  else\n-    extract_free_variables (exp, &wd, ADD_READ);\n-  wd.decl_map->traverse<auto_vec<struct cilk_decls> *, fill_decls_vec> (&vd);\n-  vd.qsort (compare_decls);\n-  FOR_EACH_VEC_ELT (vd, j, c)\n-   declare_one_free_variable (c->key, c->val);\n-\n-  wd.block = TREE_BLOCK (exp);\n-  if (!wd.block)\n-    wd.block = DECL_INITIAL (current_function_decl);\n-\n-  /* Now fvars maps the old variable to incoming variable.  Update\n-     the expression and arguments to refer to the new names.  */\n-  fndecl = create_cilk_wrapper_body (exp, &wd);\n-  *args_out = wd.arglist;\n-  \n-  free_wd (&wd);\n-\n-  return fndecl;\n-}\n-\n-/* Transform *SPAWN_P, a spawned CALL_EXPR, to gimple.  *SPAWN_P can be a\n-   CALL_EXPR, INIT_EXPR or MODIFY_EXPR.  Returns GS_OK if everything is fine,\n-   and GS_UNHANDLED, otherwise.  */\n-\n-int\n-gimplify_cilk_spawn (tree *spawn_p)\n-{\n-  tree expr = *spawn_p;\n-  tree function, call1, call2, new_args;\n-  tree ii_args = NULL_TREE;\n-  int total_args = 0, ii = 0;\n-  tree *arg_array;\n-  tree setjmp_cond_expr = NULL_TREE;\n-  tree setjmp_expr, spawn_expr, setjmp_value = NULL_TREE;\n-\n-  cfun->calls_cilk_spawn = 1;\n-  cfun->is_cilk_function = 1;\n-\n-  /* Remove CLEANUP_POINT_EXPR and EXPR_STMT from *spawn_p.  */\n-  while (TREE_CODE (expr) == CLEANUP_POINT_EXPR\n-         || TREE_CODE (expr) == EXPR_STMT)\n-    expr = TREE_OPERAND (expr, 0);\n-\n-  new_args = NULL;\n-  function = create_cilk_wrapper (expr, &new_args);\n-\n-  /* This should give the number of parameters.  */\n-  total_args = list_length (new_args);\n-  if (total_args)\n-    arg_array = XNEWVEC (tree, total_args);\n-  else\n-    arg_array = NULL;\n-\n-  ii_args = new_args;\n-  for (ii = 0; ii < total_args; ii++)\n-    {\n-      arg_array[ii] = TREE_VALUE (ii_args);\n-      ii_args = TREE_CHAIN (ii_args);\n-    }\n-  \n-  TREE_USED (function) = 1;\n-  rest_of_decl_compilation (function, 0, 0);\n-\n-  call1 = cilk_call_setjmp (cfun->cilk_frame_decl);\n-\n-  if (arg_array == NULL || *arg_array == NULL_TREE)\n-    call2 = build_call_expr (function, 0);\n-  else \n-    call2 = build_call_expr_loc_array (EXPR_LOCATION (*spawn_p), function, \n-\t\t\t\t\t total_args, arg_array);\n-  *spawn_p = alloc_stmt_list ();\n-  tree f_ptr_type = build_pointer_type (TREE_TYPE (cfun->cilk_frame_decl));\n-  tree frame_ptr = build1 (ADDR_EXPR, f_ptr_type, cfun->cilk_frame_decl);\n-  tree save_fp = build_call_expr (cilk_save_fp_fndecl, 1, frame_ptr);\n-  append_to_statement_list (save_fp, spawn_p);\t\t  \n-  setjmp_value = create_tmp_var (TREE_TYPE (call1));\n-  setjmp_expr = fold_build2 (MODIFY_EXPR, void_type_node, setjmp_value, call1);\n-\n-  append_to_statement_list_force (setjmp_expr, spawn_p);\n-  \n-  setjmp_cond_expr = fold_build2 (EQ_EXPR, TREE_TYPE (call1), setjmp_value,\n-\t\t\t\t  build_int_cst (TREE_TYPE (call1), 0));\n-  spawn_expr = fold_build3 (COND_EXPR, void_type_node, setjmp_cond_expr,\n-\t\t\t    call2, build_empty_stmt (EXPR_LOCATION (call1)));\n-  append_to_statement_list (spawn_expr, spawn_p);\n-\n-  free (arg_array);\n-  return GS_OK;\n-}\n-\n-/* Make the frames necessary for a spawn call.  */\n-\n-tree\n-make_cilk_frame (tree fn)\n-{\n-  struct function *f = DECL_STRUCT_FUNCTION (fn);\n-  tree decl;\n-\n-  if (f->cilk_frame_decl)\n-    return f->cilk_frame_decl;\n-\n-  decl = build_decl (EXPR_LOCATION (fn), VAR_DECL, NULL_TREE, \n-\t\t     cilk_frame_type_decl);\n-  DECL_CONTEXT (decl) = fn;\n-  DECL_SEEN_IN_BIND_EXPR_P (decl) = 1;\n-  f->cilk_frame_decl = decl;\n-  return decl;\n-}\n-\n-/* Add a new variable, VAR to a variable list in WD->DECL_MAP.  HOW indicates\n-   whether the variable is previously defined, currently defined, or a variable \n-   that is being written to.  */\n-\n-static void\n-add_variable (struct wrapper_data *wd, tree var, enum add_variable_type how)\n-{\n-  tree *valp = wd->decl_map->get (var);\n-  if (valp)\n-    {\n-      tree val = (tree) *valp;\n-      /* If the variable is local, do nothing.  */\n-      if (val == error_mark_node)\n-\treturn;\n-      /* If the variable was entered with itself as value,\n-\t meaning it belongs to an outer scope, do not alter\n-\t the value.  */\n-      if (val == var) \n-\treturn;\n-      /* A statement expression may cause a variable to be\n-\t bound twice, once in BIND_EXPR and again in a\n-\t DECL_EXPR.  That case caused a return in the \n-\t test above.  Any other duplicate definition is\n-\t an error.  */\n-      gcc_assert (how != ADD_BIND);\n-      if (how != ADD_WRITE)\n-\treturn;\n-      /* This variable might have been entered as read but is now written.  */\n-      *valp = var;\n-      wd->nested = true;\n-      return;\n-    }\n-  else\n-    {\n-      tree val = NULL_TREE;\n-\n-      /* Nested function rewriting silently discards hard register\n-\t assignments for function scope variables, and they wouldn't\n-\t work anyway.  Warn here.  This misses one case: if the\n-\t register variable is used as the loop bound or increment it\n-\t has already been added to the map.  */\n-      if ((how != ADD_BIND) && VAR_P (var)\n-\t  && !DECL_EXTERNAL (var) && DECL_HARD_REGISTER (var))\n-\twarning (0, \"register assignment ignored for %qD used in Cilk block\",\n-\t\t var);\n-\n-      switch (how)\n-\t{\n-\t  /* ADD_BIND means always make a fresh new variable.  */\n-\tcase ADD_BIND:\n-\t  val = error_mark_node;\n-\t  break;\n-\t  /* ADD_READ means\n-\t     1. For cilk_for, refer to the outer scope definition as-is\n-\t     2. For a spawned block, take a scalar in an rgument\n-\t     and otherwise refer to the outer scope definition as-is.\n-\t     3. For a spawned call, take a scalar in an argument.  */\n-\tcase ADD_READ:\n-\t  switch (wd->type)\n-\t    {\n-\t    case CILK_BLOCK_FOR:\n-\t      val = var;\n-\t      break;\n-\t    case CILK_BLOCK_SPAWN:\n-\t      if (TREE_ADDRESSABLE (var))\n-\t\t{\n-\t\t  val = var;\n-\t\t  wd->nested = true;\n-\t\t  break;\n-\t\t}\n-\t      val = integer_zero_node;\n-\t      break;\n-\t    }\n-\t  break;\n-\tcase ADD_WRITE:\n-\t  switch (wd->type)\n-\t    {\n-\t    case CILK_BLOCK_FOR:\n-\t      val = var;\n-\t      wd->nested = true;\n-\t      break;\n-\t    case CILK_BLOCK_SPAWN:\n-\t      if (TREE_ADDRESSABLE (var))\n-\t\tval = integer_one_node;\n-\t      else\n-\t\t{\n-\t\t  val = var;\n-\t\t  wd->nested = true;\n-\t\t}\n-\t      break;\n-\t    }\n-\t}\n-      wd->decl_map->put (var, val);\n-    }\n-}\n-\n-/* Find the variables referenced in an expression T.  This does not avoid \n-   duplicates because a variable may be read in one context and written in \n-   another.  HOW describes the context in which the reference is seen.  If \n-   NESTED is true a nested function is being generated and variables in the \n-   original context should not be remapped.  */\n-\n-static void\n-extract_free_variables (tree t, struct wrapper_data *wd,\n-\t\t\tenum add_variable_type how)\n-{  \n-  if (t == NULL_TREE)\n-    return;\n-\n-  enum tree_code code = TREE_CODE (t);\n-  bool is_expr = IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code));\n-\n-  if (is_expr)\n-    extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n-\n-  switch (code)\n-    {\n-    case ERROR_MARK:\n-    case IDENTIFIER_NODE:\n-    case VOID_CST:\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case FIXED_CST:\n-    case STRING_CST:\n-    case BLOCK:\n-    case PLACEHOLDER_EXPR:\n-    case FIELD_DECL:\n-    case VOID_TYPE:\n-    case REAL_TYPE:\n-      /* These do not contain variable references.  */\n-      return;\n-\n-    case SSA_NAME:\n-      /* Currently we don't see SSA_NAME.  */\n-      extract_free_variables (SSA_NAME_VAR (t), wd, how);\n-      return;\n-\n-    case LABEL_DECL:\n-      /* This might be a reference to a label outside the Cilk block,\n-\t which is an error, or a reference to a label in the Cilk block\n-\t that we haven't seen yet.  We can't tell.  Ignore it.  An\n-\t invalid use will cause an error later in copy_decl_for_cilk.  */\n-      return;\n-\n-    case RESULT_DECL:\n-      if (wd->type != CILK_BLOCK_SPAWN)\n-\tTREE_ADDRESSABLE (t) = 1;\n-      /* FALLTHRU */\n-    case VAR_DECL:\n-    case PARM_DECL:\n-      if (!is_global_var (t))\n-\tadd_variable (wd, t, how);\n-      return;\n-\n-    case NON_LVALUE_EXPR:\n-    case CONVERT_EXPR:\n-    case NOP_EXPR:\n-      extract_free_variables (TREE_OPERAND (t, 0), wd, ADD_READ);\n-      return;\n-\n-    case VEC_INIT_EXPR:\n-    case INIT_EXPR:\n-      extract_free_variables (TREE_OPERAND (t, 0), wd, ADD_BIND);\n-      extract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n-      return;\n-\n-    case MODIFY_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-      /* These write their result.  */\n-      extract_free_variables (TREE_OPERAND (t, 0), wd, ADD_WRITE);\n-      extract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n-      return;\n-\n-    case ADDR_EXPR:\n-      /* This might modify its argument, and the value needs to be\n-\t passed by reference in any case to preserve identity and\n-\t type if is a promoting type.  In the case of a nested loop\n-\t just notice that we touch the variable.  It will already\n-\t be addressable, and marking it modified will cause a spurious\n-\t warning about writing the control variable.  */\n-      if (wd->type != CILK_BLOCK_SPAWN)\n-\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_READ);\n-      else \n-\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_WRITE);\n-      return;\n-\n-    case ARRAY_REF:\n-      /* Treating ARRAY_REF and BIT_FIELD_REF identically may\n-\t mark the array as written but the end result is correct\n-\t because the array is passed by pointer anyway.  */\n-    case BIT_FIELD_REF:\n-      /* Propagate the access type to the object part of which\n-\t is being accessed here.  As for ADDR_EXPR, don't do this\n-\t in a nested loop, unless the access is to a fixed index.  */\n-      if (wd->type != CILK_BLOCK_FOR || TREE_CONSTANT (TREE_OPERAND (t, 1)))\n-\textract_free_variables (TREE_OPERAND (t, 0), wd, how);\n-      else\n-\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_READ);\n-      extract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n-      extract_free_variables (TREE_OPERAND (t, 2), wd, ADD_READ);\n-      return;\n-\n-    case TREE_LIST:\n-      extract_free_variables (TREE_PURPOSE (t), wd, ADD_READ);\n-      extract_free_variables (TREE_VALUE (t), wd, ADD_READ);\n-      extract_free_variables (TREE_CHAIN (t), wd, ADD_READ);\n-      return;\n-\n-    case TREE_VEC:\n-      {\n-\tint len = TREE_VEC_LENGTH (t);\n-\tint i;\n-\tfor (i = 0; i < len; i++)\n-\t  extract_free_variables (TREE_VEC_ELT (t, i), wd, ADD_READ);\n-\treturn;\n-      }\n-\n-    case VECTOR_CST:\n-      {\n-\tunsigned ii = 0;\n-\tfor (ii = 0; ii < VECTOR_CST_NELTS (t); ii++)\n-\t  extract_free_variables (VECTOR_CST_ELT (t, ii), wd, ADD_READ); \n-\tbreak;\n-      }\n-\n-    case COMPLEX_CST:\n-      extract_free_variables (TREE_REALPART (t), wd, ADD_READ);\n-      extract_free_variables (TREE_IMAGPART (t), wd, ADD_READ);\n-      return;\n-\n-    case BIND_EXPR:\n-      {\n-\ttree decl;\n-\tfor (decl = BIND_EXPR_VARS (t); decl; decl = TREE_CHAIN (decl))\n-\t  {\n-\t    add_variable (wd, decl, ADD_BIND);\n-\t    /* A self-referential initialization is no problem because\n-\t       we already entered the variable into the map as local.  */\n-\t    extract_free_variables (DECL_INITIAL (decl), wd, ADD_READ);\n-\t    extract_free_variables (DECL_SIZE (decl), wd, ADD_READ);\n-\t    extract_free_variables (DECL_SIZE_UNIT (decl), wd, ADD_READ);\n-\t  }\n-\textract_free_variables (BIND_EXPR_BODY (t), wd, ADD_READ);\n-\treturn;\n-      }\n-\n-    case STATEMENT_LIST:\n-      {\n-\ttree_stmt_iterator i;\n-\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n-\t  extract_free_variables (*tsi_stmt_ptr (i), wd, ADD_READ);\n-\treturn;\n-      }\n-\n-    case TARGET_EXPR:\n-      {\n-\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_BIND);\n-\textract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n-\textract_free_variables (TREE_OPERAND (t, 2), wd, ADD_READ);\n-\tif (TREE_OPERAND (t, 3) != TREE_OPERAND (t, 1))\n-\t  extract_free_variables (TREE_OPERAND (t, 3), wd, ADD_READ);\n-\treturn;\n-      }\n-\n-    case RETURN_EXPR:\n-      if (TREE_NO_WARNING (t))\n-\t{\n-\t  gcc_assert (errorcount);\n-\t  return;\n-\t}\n-      return;\n-\n-    case DECL_EXPR:\n-      if (TREE_CODE (DECL_EXPR_DECL (t)) != TYPE_DECL)\n-\textract_free_variables (DECL_EXPR_DECL (t), wd, ADD_BIND);\n-      return;\n-\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-      extract_free_variables (TYPE_MIN_VALUE (t), wd, ADD_READ);\n-      extract_free_variables (TYPE_MAX_VALUE (t), wd, ADD_READ);\n-      return;\n-\n-    case POINTER_TYPE:\n-      extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n-      break;\n-\n-    case ARRAY_TYPE:\n-      extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n-      extract_free_variables (TYPE_DOMAIN (t), wd, ADD_READ);\n-      return;\n-\n-    case RECORD_TYPE:\n-      extract_free_variables (TYPE_FIELDS (t), wd, ADD_READ);\n-      return;\n-    \n-    case METHOD_TYPE:\n-      extract_free_variables (TYPE_ARG_TYPES (t), wd, ADD_READ);\n-      extract_free_variables (TYPE_METHOD_BASETYPE (t), wd, ADD_READ);\n-      return;\n-\n-    case AGGR_INIT_EXPR:\n-      {\n-\tint len = 0;\n-\tint ii = 0;\n-\textract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n-\tif (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST)\n-\t  {\n-\t    len = TREE_INT_CST_LOW (TREE_OPERAND (t, 0));\n-\n-\t    for (ii = 3; ii < len; ii++)\n-\t      extract_free_variables (TREE_OPERAND (t, ii), wd, ADD_READ);\n-\t    extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n-\t  }\n-\tbreak;\n-      }\n-\n-    case CALL_EXPR:\n-      {\n-\tint len = 0;\n-\tint ii = 0;\n-\tif (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST)\n-\t  {\n-\t    len = TREE_INT_CST_LOW (TREE_OPERAND (t, 0));\n-\n-\t    for (ii = 0; ii < len; ii++)\n-\t      extract_free_variables (TREE_OPERAND (t, ii), wd, ADD_READ);\n-\t    extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n-\t  }\n-\tbreak;\n-      }\n-\n-    case CONSTRUCTOR:\n-      {\n-\tunsigned HOST_WIDE_INT idx = 0;\n-\tconstructor_elt *ce;\n-\tfor (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (t), idx, &ce); idx++)\n-\t  extract_free_variables (ce->value, wd, ADD_READ);\n-\tbreak;\n-      }\n-\n-    default:\n-      if (is_expr)\n-\t{\n-\t  int i, len;\n-\n-\t  /* Walk over all the sub-trees of this operand.  */\n-\t  len = TREE_CODE_LENGTH (code);\n-\n-\t  /* Go through the subtrees.  We need to do this in forward order so\n-\t     that the scope of a FOR_EXPR is handled properly.  */\n-\t  for (i = 0; i < len; ++i)\n-\t    extract_free_variables (TREE_OPERAND (t, i), wd, ADD_READ);\n-\t}\n-    }\n-}\n-\n-/* Add appropriate frames needed for a Cilk spawned function call, FNDECL. \n-   Returns the __cilkrts_stack_frame * variable.  */\n-\n-tree\n-insert_cilk_frame (tree fndecl)\n-{\n-  tree addr, body, enter, out, orig_body;\n-  location_t loc = EXPR_LOCATION (fndecl);\n-\n-  if (!cfun || cfun->decl != fndecl)\n-    push_cfun (DECL_STRUCT_FUNCTION (fndecl)); \n-\n-  tree decl = cfun->cilk_frame_decl;\n-  if (!decl)\n-    {\n-      tree *saved_tree = &DECL_SAVED_TREE (fndecl);\n-      decl = make_cilk_frame (fndecl);\n-      add_local_decl (cfun, decl);\n-\n-      addr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, decl);\n-      enter = build_call_expr (cilk_enter_fndecl, 1, addr);\n-      out = create_cilk_function_exit (cfun->cilk_frame_decl, false, true);\n-\n-      /* The new body will be:\n-\t __cilkrts_enter_frame_1 (&sf);\n-\t try {\n-\t    orig_body;\n-\t } \n-\t finally {\n-\t     __cilkrts_pop_frame (&sf);\n-\t     __cilkrts_leave_frame (&sf);\n-         }  */\n-\n-      body = alloc_stmt_list ();\n-      orig_body = *saved_tree;\n-\n-      if (TREE_CODE (orig_body) == BIND_EXPR)\n-\torig_body = BIND_EXPR_BODY (orig_body);\n- \n-      append_to_statement_list (enter, &body);\n-      append_to_statement_list (build_stmt (loc, TRY_FINALLY_EXPR, orig_body, \n-\t\t\t\t\t    out), &body);\n-      if (TREE_CODE (*saved_tree) == BIND_EXPR)\n-\tBIND_EXPR_BODY (*saved_tree) = body;\n-      else\n-\t*saved_tree = body;\n-    }\n-  return decl;\n-}\n-\n-/* Wraps CALL, a CALL_EXPR, into a CILK_SPAWN_STMT tree and returns it.  */\n-\n-tree\n-build_cilk_spawn (location_t loc, tree call)\n-{\n-  if (!cilk_set_spawn_marker (loc, call))\n-    return error_mark_node;\n-  tree spawn_stmt = build1 (CILK_SPAWN_STMT, TREE_TYPE (call), call);\n-  TREE_SIDE_EFFECTS (spawn_stmt) = 1;\n-  return spawn_stmt;\n-}\n-\n-/* Returns a tree of type CILK_SYNC_STMT.  */\n-\n-tree\n-build_cilk_sync (void)\n-{\n-  tree sync = build0 (CILK_SYNC_STMT, void_type_node);\n-  TREE_SIDE_EFFECTS (sync) = 1;\n-  return sync;\n-}\n-\n-/* Helper for contains_cilk_spawn_stmt, callback for walk_tree.  Return\n-   non-null tree if TP contains CILK_SPAWN_STMT.  */\n-\n-static tree\n-contains_cilk_spawn_stmt_walker (tree *tp, int *, void *)\n-{\n-  if (TREE_CODE (*tp) == CILK_SPAWN_STMT)\n-    return *tp;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Returns true if EXPR or any of its subtrees contain CILK_SPAWN_STMT\n-   node.  */\n-\n-bool\n-contains_cilk_spawn_stmt (tree expr)\n-{\n-  return walk_tree (&expr, contains_cilk_spawn_stmt_walker, NULL, NULL)\n-\t != NULL_TREE;\n-}\n-\n-/* Return a error location for EXPR if LOC is not set.  */\n-\n-static location_t\n-get_error_location (tree expr, location_t loc)\n-{\n-  if (loc == UNKNOWN_LOCATION)\n-    {\n-      if (TREE_CODE (expr) == MODIFY_EXPR)\n-        expr = TREE_OPERAND (expr, 0);\n-      loc = EXPR_LOCATION (expr);\n-    }\n-  return loc;\n-}\n-\n-/* Check that no array notation or spawn statement is in EXPR.\n-   If not true generate an error at LOC for ARRAY_GMSGID or\n-   SPAWN_MSGID.  */\n-\n-bool\n-check_no_cilk (tree expr, const char *array_msgid, const char *spawn_msgid,\n-\t      location_t loc)\n-{\n-  if (!flag_cilkplus)\n-    return false;\n-  if (contains_array_notation_expr (expr))\n-    {\n-      loc = get_error_location (expr, loc);\n-      error_at (loc, array_msgid);\n-      return true;\n-    }\n-  if (walk_tree (&expr, contains_cilk_spawn_stmt_walker, NULL, NULL))\n-    {\n-      loc = get_error_location (expr, loc);\n-      error_at (loc, spawn_msgid);\n-      return true;\n-    }\n-  return false;\n-}"}, {"sha": "ff730438258636841e7ed20c70e2a3ed95482e5d", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,31 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+            Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* Make-lang.in (c/c-array-notation.o): Remove.\n+\t* c-array-notation.c: Delete.\n+\t* c-decl.c: Remove cilkplus condition.\n+\t* c-parser.c (c_parser_cilk_simd, c_parser_cilk_for,\n+\tc_parser_cilk_verify_simd, c_parser_array_notation,\n+\tc_parser_cilk_clause_vectorlength, c_parser_cilk_grainsize,\n+\tc_parser_cilk_simd_fn_vector_attrs,\n+\tc_finish_cilk_simd_fn_tokens): Delete.\n+\t(c_parser_declaration_or_fndef): Remove cilkplus condition.\n+\t(c_parser_direct_declarator_inner): Ditto.\n+\t(CILK_SIMD_FN_CLAUSE_MASK): Delete.\n+\t(c_parser_attributes, c_parser_compound_statement,\n+\tc_parser_statement_after_labels, c_parser_if_statement,\n+\tc_parser_switch_statement, c_parser_while_statement,\n+\tc_parser_do_statement, c_parser_for_statement,\n+\tc_parser_unary_expression, c_parser_postfix_expression,\n+\tc_parser_postfix_expression_after_primary,\n+\tc_parser_pragma, c_parser_omp_clause_name, c_parser_omp_all_clauses,\n+\tc_parser_omp_for_loop, c_finish_omp_declare_simd): Remove cilkplus\n+\tsupport.\n+\t* c-typeck.c (build_array_ref, build_function_call_vec,\n+\tconvert_arguments,\n+\tlvalue_p, build_compound_expr, c_finish_return, c_finish_if_stmt,\n+\tc_finish_loop, build_binary_op): Remove cilkplus support.\n+\n 2017-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* c-typeck.c (c_start_case): Build SWITCH_EXPR using build2 instead"}, {"sha": "55da67849932bec73cc78a97fac3a5bc5bf58987", "filename": "gcc/c/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FMake-lang.in?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -51,7 +51,7 @@ CFLAGS-c/gccspec.o += $(DRIVER_DEFINES)\n # Language-specific object files for C and Objective C.\n C_AND_OBJC_OBJS = attribs.o c/c-errors.o c/c-decl.o c/c-typeck.o \\\n   c/c-convert.o c/c-aux-info.o c/c-objc-common.o c/c-parser.o \\\n-  c/c-array-notation.o c/c-fold.o c/gimple-parser.o \\\n+  c/c-fold.o c/gimple-parser.o \\\n   $(C_COMMON_OBJS) $(C_TARGET_OBJS)\n \n # Language-specific object files for C."}, {"sha": "40f1cfdabb82b7fddf62247ffc07ad8f949fd700", "filename": "gcc/c/c-array-notation.c", "status": "removed", "additions": 0, "deletions": 1407, "changes": 1407, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc%2Fc-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fc%2Fc-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-array-notation.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,1407 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   This file contains routines to handle Array Notation expression\n-   handling routines in the C Compiler.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n-                  Intel Corporation.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* The Array Notation Transformation Technique:\n-\n-   An array notation expression has 4 major components:\n-   1. The array name\n-   2. Start Index\n-   3. Number of elements we need to access (we call it length)\n-   4. Stride\n-\n-   For example, A[0:5:2], implies that we are accessing A[0], A[2], A[4],\n-   A[6] and A[8]. The user is responsible to make sure the access length does\n-   not step outside the array's size.\n-   \n-   In this section, I highlight the overall method on how array notations are\n-   broken up into C/C++ code.  Almost all the functions follows this overall\n-   technique:\n-\n-   Let's say we have an array notation in a statement like this:\n-\n-   A[St1:Ln:Str1] = B[St2:Ln:Str2] + <NON ARRAY_NOTATION_STMT>\n-\n-   where St{1,2} = Starting index,\n-   Ln = Number of elements we need to access,\n-   and Str{1,2} = the stride.\n-   Note: The length of both the array notation expressions must be the same.\n-   \n-   The above expression is broken into the following\n-   (with the help of c_finish_loop function from c-typeck.c):\n-   \n-   Tmp_Var = 0;\n-   goto compare_label:\n-   body_label:\n-\n-   A[St1+Tmp_Var*Str1] = B[St1+Tmp_Var*Str2] + <NON ARRAY_NOTATION_STMT>;\n-   Tmp_Var++;\n-   \n-   compare_label:\t\t\t\t\n-     if (Tmp_Var < Ln)\n-       goto body_label;\n-     else\n-       goto exit_label;\n-   exit_label:\t\t  \t      \n-\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"c-tree.h\"\n-#include \"gimple-expr.h\"\n-#include \"tree-iterator.h\"\n-\n-/* If *VALUE is not of type INTEGER_CST, PARM_DECL or VAR_DECL, then map it\n-   to a variable and then set *VALUE to the new variable.  */\n-\n-static inline void\n-make_triplet_val_inv (location_t loc, tree *value)\n-{\n-  tree var, new_exp;\n-  if (TREE_CODE (*value) != INTEGER_CST\n-      && TREE_CODE (*value) != PARM_DECL\n-      && !VAR_P (*value))\n-    {\n-      var = build_decl (loc, VAR_DECL, NULL_TREE, integer_type_node);\n-      new_exp = build_modify_expr (loc, var, TREE_TYPE (var), NOP_EXPR, loc,\n-\t\t\t\t   *value, TREE_TYPE (*value));\n-      add_stmt (new_exp);\n-      *value = var;\n-    }\n-}\n-\n-/* Populates the INCR and CMP vectors with the increment (of type POSTINCREMENT\n-   or POSTDECREMENT) and comparison (of TYPE GT_EXPR or LT_EXPR) expressions,\n-   using data from LENGTH, COUNT_DOWN, and VAR.  INCR and CMP vectors are of\n-   size RANK.  */\n-\n-static void\n-create_cmp_incr (location_t loc, vec<an_loop_parts> *node, size_t rank,\n-\t\t vec<vec<an_parts> > an_info)\n-{\n-  for (size_t ii = 0; ii < rank; ii++)\n-    {\n-      tree var = (*node)[ii].var;\n-      tree length = an_info[0][ii].length;\n-      (*node)[ii].incr = build_unary_op (loc, POSTINCREMENT_EXPR, var, false);\n-      (*node)[ii].cmp = build2 (LT_EXPR, boolean_type_node, var, length);\n-    }\n-}\n-\n-/* Returns a vector of size RANK that contains an array ref that is derived from\n-   array notation triplet parameters stored in VALUE, START, STRIDE.  IS_VECTOR\n-   is used to check if the data stored at its corresponding location is an\n-   array notation. VAR is the induction variable passed in by the caller.\n-\n-   For example: For an array notation A[5:10:2], the vector start  will be\n-   of size 1 holding '5', stride of same size as start but holding the value of\n-   as 2, is_vector as true and count_down as false. Let's assume VAR is 'x'\n-   This function returns a vector of size 1 with the following data:\n-   A[5 + (x * 2)] .\n-*/\n-\n-static vec<tree, va_gc> *\n-create_array_refs (location_t loc, vec<vec<an_parts> > an_info,\n-\t\t   vec<an_loop_parts> an_loop_info, size_t size, size_t rank)\n-{\n-  tree ind_mult, ind_incr;\n-  vec<tree, va_gc> *array_operand = NULL;\n-  for (size_t ii = 0; ii < size; ii++)\n-    if (an_info[ii][0].is_vector)\n-      {\n-\ttree array_opr = an_info[ii][rank - 1].value;\n-\tfor (int s_jj = rank - 1; s_jj >= 0; s_jj--)\n-\t  {\n-\t    tree var = an_loop_info[s_jj].var;\n-\t    tree stride = an_info[ii][s_jj].stride;\n-\t    tree start = an_info[ii][s_jj].start;\n-\t    ind_mult = build2 (MULT_EXPR, TREE_TYPE (var), var, stride);\n-\t    ind_incr = build2 (PLUS_EXPR, TREE_TYPE (var), start, ind_mult);\n-\t    array_opr = build_array_ref (loc, array_opr, ind_incr);\n-\t  }\n-\tvec_safe_push (array_operand, array_opr);\n-      }\n-    else\n-      /* This is just a dummy node to make sure both the list sizes for both\n-\t array list and array operand list are the same.  */\n-      vec_safe_push (array_operand, integer_one_node);\n-  return array_operand;\n-}\t\t     \n-  \n-/* Replaces all the scalar expressions in *NODE.  Returns a STATEMENT_LIST that\n-   holds the NODE along with variables that holds the results of the invariant\n-   expressions.  */\n-\n-tree\n-replace_invariant_exprs (tree *node)\n-{\n-  size_t ix = 0;\n-  tree node_list = NULL_TREE;\n-  tree t = NULL_TREE, new_var = NULL_TREE, new_node; \n-  struct inv_list data;\n-\n-  data.list_values = NULL;\n-  data.replacement = NULL;\n-  data.additional_tcodes = NULL;\n-  walk_tree (node, find_inv_trees, (void *)&data, NULL);\n-\n-  if (vec_safe_length (data.list_values))\n-    {\n-      node_list = push_stmt_list ();\n-      for (ix = 0; vec_safe_iterate (data.list_values, ix, &t); ix++)\n-\t{\n-\t  new_var = build_decl (EXPR_LOCATION (t), VAR_DECL, NULL_TREE,\n-\t\t\t\tTREE_TYPE (t));\n-\t  gcc_assert (new_var != NULL_TREE && new_var != error_mark_node);\n-\t  new_node = build2 (MODIFY_EXPR, TREE_TYPE (t), new_var, t);\n-\t  add_stmt (new_node);\n-\t  vec_safe_push (data.replacement, new_var);\n-\t}\n-      walk_tree (node, replace_inv_trees, (void *)&data, NULL);\n-      node_list = pop_stmt_list (node_list);\n-    }\n-  return node_list;\n-}\n-\n-/* Given a CALL_EXPR to an array notation built-in function in\n-   AN_BUILTIN_FN, replace the call with the appropriate loop and\n-   computation.  Return the computation in *NEW_VAR.\n-\n-   The return value in *NEW_VAR will always be a scalar.  If the\n-   built-in is __sec_reduce_mutating, *NEW_VAR is set to NULL_TREE.  */\n-\n-static tree\n-fix_builtin_array_notation_fn (tree an_builtin_fn, tree *new_var)\n-{\n-  tree new_var_type = NULL_TREE, func_parm, new_expr, new_yes_expr, new_no_expr;\n-  tree array_ind_value = NULL_TREE, new_no_ind, new_yes_ind, new_no_list;\n-  tree new_yes_list, new_cond_expr, new_var_init = NULL_TREE;\n-  tree new_exp_init = NULL_TREE;\n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0, rank = 0, ii = 0;\n-  tree loop_init, array_op0;\n-  tree identity_value = NULL_TREE, call_fn = NULL_TREE, new_call_expr, body;\n-  location_t location = UNKNOWN_LOCATION;\n-  tree loop_with_init = alloc_stmt_list ();\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n-  enum built_in_function an_type =\n-    is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n-  if (an_type == BUILT_IN_NONE)\n-    return NULL_TREE;\n-\n-  /* Builtin call should contain at least one argument.  */\n-  if (call_expr_nargs (an_builtin_fn) == 0)\n-    {\n-      error_at (EXPR_LOCATION (an_builtin_fn), \"Invalid builtin arguments\");\n-      return error_mark_node;\n-    }\n-\n-  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE\n-      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    {\n-      call_fn = CALL_EXPR_ARG (an_builtin_fn, 2);\n-      if (TREE_CODE (call_fn) == ADDR_EXPR)\n-\tcall_fn = TREE_OPERAND (call_fn, 0);\n-      identity_value = CALL_EXPR_ARG (an_builtin_fn, 0);\n-      func_parm = CALL_EXPR_ARG (an_builtin_fn, 1);\n-    }\n-  else\n-    func_parm = CALL_EXPR_ARG (an_builtin_fn, 0);\n-  \n-  /* Fully fold any EXCESSIVE_PRECISION EXPR that can occur in the function\n-     parameter.  */\n-  func_parm = c_fully_fold (func_parm, false, NULL);\n-  if (func_parm == error_mark_node)\n-    return error_mark_node;\n-  \n-  location = EXPR_LOCATION (an_builtin_fn);\n-  \n-  if (!find_rank (location, an_builtin_fn, an_builtin_fn, true, &rank))\n-    return error_mark_node;\n- \n-  if (rank == 0)\n-    {\n-      error_at (location, \"Invalid builtin arguments\");\n-      return error_mark_node;\n-    }\n-  else if (rank > 1 \n-\t   && (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-\t       || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND))\n-    {\n-      error_at (location, \"__sec_reduce_min_ind or __sec_reduce_max_ind cannot\"\n-\t\t\" have arrays with dimension greater than 1\");\n-      return error_mark_node;\n-    }\n-  \n-  extract_array_notation_exprs (func_parm, true, &array_list);\n-  list_size = vec_safe_length (array_list);\n-  switch (an_type)\n-    {\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      new_var_type = TREE_TYPE ((*array_list)[0]);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      new_var_type = integer_type_node;\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      new_var_type = integer_type_node;\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-      if (call_fn && identity_value) \n-\tnew_var_type = TREE_TYPE ((*array_list)[0]);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-      new_var_type = NULL_TREE;\n-      break;\n-    default:\n-      gcc_unreachable (); \n-    }\n-\n-  an_loop_info.safe_grow_cleared (rank);\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  loop_init = alloc_stmt_list ();\n-\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n-      an_loop_info[ii].ind_init =\n-\tbuild_modify_expr (location, an_loop_info[ii].var,\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n-\t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var));\t\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t     list_size, rank);\n-  replace_array_notations (&func_parm, true, array_list, array_operand);\n-\n-  create_cmp_incr (location, &an_loop_info, rank, an_info);\n-  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    {\n-      *new_var = build_decl (location, VAR_DECL, NULL_TREE, new_var_type);\n-      gcc_assert (*new_var && *new_var != error_mark_node);\n-    }\n-  else\n-    *new_var = NULL_TREE;\n-  \n-  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n-    array_ind_value = build_decl (location, VAR_DECL, NULL_TREE, \n-\t\t\t\t  TREE_TYPE (func_parm));\n-  array_op0 = (*array_operand)[0];\n-  if (INDIRECT_REF_P (array_op0))\n-    array_op0 = TREE_OPERAND (array_op0, 0);\n-  switch (an_type)\n-    {\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (new_var_type), new_var_type);\n-      new_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), PLUS_EXPR,\n-\t location, func_parm, TREE_TYPE (func_parm));\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_one_cst (new_var_type), new_var_type);\n-      new_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), MULT_EXPR,\n-\t location, func_parm, TREE_TYPE (func_parm));\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_one_cst (new_var_type), new_var_type);\n-      /* Initially you assume everything is zero, now if we find a case where \n-\t it is NOT true, then we set the result to false. Otherwise \n-\t we just keep the previous value.  */\n-      new_yes_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (TREE_TYPE (*new_var)),\n-\t TREE_TYPE (*new_var));\n-      new_no_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_cond_expr = build2 (NE_EXPR, TREE_TYPE (func_parm), func_parm,\n-\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n-      new_expr = build_conditional_expr\n-\t(location, new_cond_expr, false,\n-\t new_yes_expr, TREE_TYPE (new_yes_expr), location,\n-\t new_no_expr, TREE_TYPE (new_no_expr), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_one_cst (new_var_type), new_var_type);\n-      /* Initially you assume everything is non-zero, now if we find a case\n-\t where it is NOT true, then we set the result to false.  Otherwise\n-\t we just keep the previous value.  */\n-      new_yes_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (TREE_TYPE (*new_var)),\n-\t TREE_TYPE (*new_var));\n-      new_no_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_cond_expr = build2 (EQ_EXPR, TREE_TYPE (func_parm), func_parm,\n-\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n-      new_expr = build_conditional_expr\n-\t(location, new_cond_expr, false,\n-\t new_yes_expr, TREE_TYPE (new_yes_expr), location,\n-\t new_no_expr, TREE_TYPE (new_no_expr), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (new_var_type), new_var_type);\n-      /* Initially we assume there are NO zeros in the list. When we find \n-\t a non-zero, we keep the previous value.  If we find a zero, we \n-\t set the value to true.  */\n-      new_yes_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_one_cst (new_var_type), new_var_type);\n-      new_no_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_cond_expr = build2 (EQ_EXPR, TREE_TYPE (func_parm), func_parm,\n-\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n-      new_expr = build_conditional_expr\n-\t(location, new_cond_expr, false,\n-\t new_yes_expr, TREE_TYPE (new_yes_expr), location,\n-\t new_no_expr, TREE_TYPE (new_no_expr), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (new_var_type), new_var_type);\n-      /* Initially we assume there are NO non-zeros in the list. When we find \n-\t a zero, we keep the previous value.  If we find a non-zero, we set \n-\t the value to true.  */\n-      new_yes_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_one_cst (new_var_type), new_var_type);\n-      new_no_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_cond_expr = build2 (NE_EXPR, TREE_TYPE (func_parm), func_parm,\n-\t\t\t      build_zero_cst (TREE_TYPE (func_parm)));\n-      new_expr = build_conditional_expr\n-\t(location, new_cond_expr, false,\n-\t new_yes_expr, TREE_TYPE (new_yes_expr), location,\n-\t new_no_expr, TREE_TYPE (new_no_expr), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-      if (TYPE_MIN_VALUE (new_var_type))\n-\tnew_var_init = build_modify_expr\n-\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t   location, TYPE_MIN_VALUE (new_var_type), new_var_type);\n-      else\n-\tnew_var_init = build_modify_expr\n-\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t   location, func_parm, new_var_type);\n-      new_no_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_yes_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, func_parm, TREE_TYPE (*new_var));\n-      new_expr = build_conditional_expr\n-\t(location,\n-\t build2 (LT_EXPR, TREE_TYPE (*new_var), *new_var, func_parm), false,\n-\t new_yes_expr, TREE_TYPE (*new_var), location,\n-\t new_no_expr, TREE_TYPE (*new_var), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      if (TYPE_MAX_VALUE (new_var_type))\n-\tnew_var_init = build_modify_expr\n-\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t   location, TYPE_MAX_VALUE (new_var_type), new_var_type);\n-      else\n-\tnew_var_init = build_modify_expr\n-\t  (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t   location, func_parm, new_var_type);\n-      new_no_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_yes_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, func_parm, TREE_TYPE (*new_var));\n-      new_expr = build_conditional_expr\n-\t(location,\n-\t build2 (GT_EXPR, TREE_TYPE (*new_var), *new_var, func_parm), false,\n-\t new_yes_expr, TREE_TYPE (*new_var), location,\n-\t new_no_expr, TREE_TYPE (*new_var), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (new_var_type), new_var_type);\n-      new_exp_init = build_modify_expr\n-\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t NOP_EXPR, location, func_parm, TREE_TYPE (func_parm));\n-      new_no_ind = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_no_expr = build_modify_expr\n-\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t NOP_EXPR,\n-\t location, array_ind_value, TREE_TYPE (array_ind_value));\n-      if (list_size > 1)\n-\t{\n-\t  new_yes_ind = build_modify_expr\n-\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t     location, an_loop_info[0].var, TREE_TYPE (an_loop_info[0].var));\n-\t  new_yes_expr = build_modify_expr\n-\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t     NOP_EXPR,\n-\t     location, func_parm, TREE_TYPE ((*array_operand)[0]));\n-\t}\n-      else\n-\t{\n-\t  new_yes_ind = build_modify_expr\n-\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t     location, TREE_OPERAND (array_op0, 1),\n-\t     TREE_TYPE (TREE_OPERAND (array_op0, 1)));\n-\t  new_yes_expr = build_modify_expr\n-\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t     NOP_EXPR,\n-\t     location, func_parm, TREE_TYPE (TREE_OPERAND (array_op0, 1)));\n-\t}\n-      new_yes_list = alloc_stmt_list ();\n-      append_to_statement_list (new_yes_ind, &new_yes_list);\n-      append_to_statement_list (new_yes_expr, &new_yes_list);\n-\n-      new_no_list = alloc_stmt_list ();\n-      append_to_statement_list (new_no_ind, &new_no_list);\n-      append_to_statement_list (new_no_expr, &new_no_list);\n- \n-      new_expr = build_conditional_expr\n-\t(location,\n-\t build2 (LE_EXPR, TREE_TYPE (array_ind_value), array_ind_value,\n-\t\t func_parm),\n-\t false,\n-\t new_yes_list, TREE_TYPE (*new_var), location,\n-\t new_no_list, TREE_TYPE (*new_var), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, build_zero_cst (new_var_type), new_var_type);\n-      new_exp_init = build_modify_expr\n-\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t NOP_EXPR, location, func_parm, TREE_TYPE (func_parm));\n-      new_no_ind = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, *new_var, TREE_TYPE (*new_var));\n-      new_no_expr = build_modify_expr\n-\t(location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t NOP_EXPR,\n-\t location, array_ind_value, TREE_TYPE (array_ind_value));\n-      if (list_size > 1)\n-\t{\n-\t  new_yes_ind = build_modify_expr\n-\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t     location, an_loop_info[0].var, TREE_TYPE (an_loop_info[0].var));\n-\t  new_yes_expr = build_modify_expr\n-\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t     NOP_EXPR,\n-\t     location, func_parm, TREE_TYPE (array_op0));\n-\t}\n-      else\n-\t{\n-\t  new_yes_ind = build_modify_expr\n-\t    (location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t     location, TREE_OPERAND (array_op0, 1),\n-\t     TREE_TYPE (TREE_OPERAND (array_op0, 1)));\n-\t  new_yes_expr = build_modify_expr\n-\t    (location, array_ind_value, TREE_TYPE (array_ind_value),\n-\t     NOP_EXPR,\n-\t     location, func_parm, TREE_TYPE (TREE_OPERAND (array_op0, 1)));\n-\t}\n-      new_yes_list = alloc_stmt_list ();\n-      append_to_statement_list (new_yes_ind, &new_yes_list);\n-      append_to_statement_list (new_yes_expr, &new_yes_list);\n-\n-      new_no_list = alloc_stmt_list ();\n-      append_to_statement_list (new_no_ind, &new_no_list);\n-      append_to_statement_list (new_no_expr, &new_no_list);\n- \n-      new_expr = build_conditional_expr\n-\t(location,\n-\t build2 (GE_EXPR, TREE_TYPE (array_ind_value), array_ind_value,\n-\t\t func_parm),\n-\t false,\n-\t new_yes_list, TREE_TYPE (*new_var), location,\n-\t new_no_list, TREE_TYPE (*new_var), location);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-      new_var_init = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, identity_value, new_var_type);\n-      new_call_expr = build_call_expr (call_fn, 2, *new_var, func_parm);\n-      new_expr = build_modify_expr\n-\t(location, *new_var, TREE_TYPE (*new_var), NOP_EXPR,\n-\t location, new_call_expr, TREE_TYPE (*new_var));\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-      new_expr = build_call_expr (call_fn, 2, identity_value, func_parm);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-      break;\n-    }\n-\n-  for (ii = 0; ii < rank; ii++)\n-    append_to_statement_list (an_loop_info[ii].ind_init, &loop_init);\n-\n-  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND)\n-    append_to_statement_list (new_exp_init, &loop_init);\n-  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    append_to_statement_list (new_var_init, &loop_init);\n-\n-  append_to_statement_list_force (loop_init, &loop_with_init);\n-  body = new_expr;\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      c_finish_loop (location, an_loop_info[ii].cmp, an_loop_info[ii].incr,\n-\t\t     body, NULL_TREE, NULL_TREE, true);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list_force (body, &loop_with_init);\n-\n-  release_vec_vec (an_info);\n-  \n-  return loop_with_init;\n-}\n-\n-/* Returns a loop with ARRAY_REF inside it with an appropriate modify expr.\n-   The LHS and/or RHS will be array notation expressions that have a MODIFYCODE\n-   Their locations are specified by LHS_LOC, RHS_LOC.  The location of the\n-   modify expression is location.  The original type of LHS and RHS are passed\n-   in LHS_ORIGTYPE and RHS_ORIGTYPE.  */\n-\n-tree\n-build_array_notation_expr (location_t location, tree lhs, tree lhs_origtype,\n-\t\t\t   enum tree_code modifycode, location_t rhs_loc,\n-\t\t\t   tree rhs, tree rhs_origtype)\n-{\n-  bool found_builtin_fn = false;\n-  tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n-  tree array_expr = NULL_TREE;\n-  tree an_init = NULL_TREE;\n-  auto_vec<tree> cond_expr;\n-  tree body, loop_with_init = alloc_stmt_list();\n-  tree scalar_mods = NULL_TREE;\n-  vec<tree, va_gc> *rhs_array_operand = NULL, *lhs_array_operand = NULL;\n-  size_t lhs_rank = 0, rhs_rank = 0;\n-  size_t ii = 0;\n-  vec<tree, va_gc> *lhs_list = NULL, *rhs_list = NULL;\n-  tree new_modify_expr, new_var = NULL_TREE, builtin_loop = NULL_TREE;\n-  size_t rhs_list_size = 0, lhs_list_size = 0; \n-  vec<vec<an_parts> > lhs_an_info = vNULL, rhs_an_info = vNULL;\n-  auto_vec<an_loop_parts> lhs_an_loop_info, rhs_an_loop_info;\n-  \n-  /* If either of this is true, an error message must have been send out\n-     already.  Not necessary to send out multiple error messages.  */\n-  if (lhs == error_mark_node || rhs == error_mark_node)\n-    return error_mark_node;\n-  \n-  if (!find_rank (location, rhs, rhs, false, &rhs_rank))\n-    return error_mark_node;\n-  \n-  extract_array_notation_exprs (rhs, false, &rhs_list);\n-  rhs_list_size = vec_safe_length (rhs_list);\n-  an_init = push_stmt_list ();\n-  if (rhs_rank)\n-    {\n-      scalar_mods = replace_invariant_exprs (&rhs);\n-      if (scalar_mods)\n-\tadd_stmt (scalar_mods);\n-    }\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    {\n-      tree rhs_node = (*rhs_list)[ii];\n-      if (TREE_CODE (rhs_node) == CALL_EXPR)\n-\t{\n-\t  builtin_loop = fix_builtin_array_notation_fn (rhs_node, &new_var);\n-\t  if (builtin_loop == error_mark_node)\n-\t    {\n-\t      pop_stmt_list (an_init); \n-\t      return error_mark_node;\n-\t    }\n-\t  else if (builtin_loop)\n-\t    {\n-\t      add_stmt (builtin_loop);\n-\t      found_builtin_fn = true;\n-\t      if (new_var)\n-\t\t{\n-\t\t  vec<tree, va_gc> *rhs_sub_list = NULL, *new_var_list = NULL;\n-\t\t  vec_safe_push (rhs_sub_list, rhs_node);\n-\t\t  vec_safe_push (new_var_list, new_var);\n-\t\t  replace_array_notations (&rhs, false, rhs_sub_list,\n-\t\t\t\t\t   new_var_list);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  lhs_rank = 0;\n-  rhs_rank = 0;\n-  if (!find_rank (location, lhs, lhs, true, &lhs_rank))\n-    {\n-      pop_stmt_list (an_init);\n-      return error_mark_node;\n-    }\n-  \n-  if (!find_rank (location, rhs, rhs, true, &rhs_rank))\n-    {\n-      pop_stmt_list (an_init);\n-      return error_mark_node;\n-    }\n-\n-  if (lhs_rank == 0 && rhs_rank == 0)\n-    {\n-      if (found_builtin_fn)\n-\t{\n-\t  new_modify_expr = build_modify_expr (location, lhs, lhs_origtype,\n-\t\t\t\t\t       modifycode, rhs_loc, rhs,\n-\t\t\t\t\t       rhs_origtype);\n-\t  add_stmt (new_modify_expr);\n-\t  pop_stmt_list (an_init);\t  \n-\t  return an_init;\n-\t}\n-      else\n-\t{\n-\t  pop_stmt_list (an_init);\n-\t  return NULL_TREE;\n-\t}\n-    }\n-  rhs_list_size = 0;\n-  rhs_list = NULL;\n-  extract_array_notation_exprs (rhs, true, &rhs_list);\n-  extract_array_notation_exprs (lhs, true, &lhs_list);\n-  rhs_list_size = vec_safe_length (rhs_list);\n-  lhs_list_size = vec_safe_length (lhs_list);\n-  \n-  if (lhs_rank == 0 && rhs_rank != 0)\n-    {\n-      tree rhs_base = rhs;\n-      if (TREE_CODE (rhs_base) == ARRAY_NOTATION_REF)\n-\t{\n-\t  for (ii = 0; ii < (size_t) rhs_rank; ii++)\n-\t    rhs_base = ARRAY_NOTATION_ARRAY (rhs);\n-      \n-\t  error_at (location, \"%qE cannot be scalar when %qE is not\", lhs,\n-\t\t    rhs_base);\n-\t  return error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  error_at (location, \"%qE cannot be scalar when %qE is not\", lhs,\n-\t\t    rhs_base);\n-\t  return error_mark_node;\n-\t}\n-    }\n-  if (lhs_rank != 0 && rhs_rank != 0 && lhs_rank != rhs_rank)\n-    {\n-      error_at (location, \"rank mismatch between %qE and %qE\", lhs, rhs);\n-      pop_stmt_list (an_init);\n-      return error_mark_node;\n-    }\n-  \n-  /* Here we assign the array notation components to variable so that we can\n-     satisfy the exec once rule.  */\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    { \n-      tree array_node = (*lhs_list)[ii];\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n-      make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n-    }\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    if ((*rhs_list)[ii] && TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n-      {  \n-\ttree array_node = (*rhs_list)[ii];\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n-      }\n-  \n-  cond_expr.safe_grow_cleared (MAX (lhs_rank, rhs_rank));\n-\n-  lhs_an_loop_info.safe_grow_cleared (lhs_rank);\n-  if (rhs_rank)\n-    rhs_an_loop_info.safe_grow_cleared (rhs_rank);\n-\n-  cilkplus_extract_an_triplets (lhs_list, lhs_list_size, lhs_rank,\n-\t\t\t\t&lhs_an_info);\n-  if (rhs_rank)\n-    {\n-      rhs_an_loop_info.safe_grow_cleared (rhs_rank);\n-      cilkplus_extract_an_triplets (rhs_list, rhs_list_size, rhs_rank,\n-\t\t\t\t    &rhs_an_info);\n-    }\n-  if (length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_an_info)\n-      || (rhs_rank\n-\t  && length_mismatch_in_expr_p (EXPR_LOCATION (rhs), rhs_an_info)))\n-    {\n-      pop_stmt_list (an_init);\n-      goto error;\n-    }\n-  if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n-      && TREE_CODE (lhs_an_info[0][0].length) == INTEGER_CST\n-      && rhs_an_info[0][0].length\n-      && TREE_CODE (rhs_an_info[0][0].length) == INTEGER_CST)\n-    {\n-      HOST_WIDE_INT l_length = int_cst_value (lhs_an_info[0][0].length);\n-      HOST_WIDE_INT r_length = int_cst_value (rhs_an_info[0][0].length);\n-      /* Length can be negative or positive.  As long as the magnitude is OK,\n-\t then the array notation is valid.  */\n-      if (absu_hwi (l_length) != absu_hwi (r_length))\n-\t{\n-\t  error_at (location, \"length mismatch between LHS and RHS\");\n-\t  pop_stmt_list (an_init);\n-\t  goto error;\n-\t}\n-    }\n-  for (ii = 0; ii < lhs_rank; ii++)\n-    if (lhs_an_info[0][ii].is_vector)\n-      {\n-\tlhs_an_loop_info[ii].var = create_tmp_var (integer_type_node);\n-\tlhs_an_loop_info[ii].ind_init = build_modify_expr\n-\t  (location, lhs_an_loop_info[ii].var,\n-\t   TREE_TYPE (lhs_an_loop_info[ii].var), NOP_EXPR,\n-\t   location, build_zero_cst (TREE_TYPE (lhs_an_loop_info[ii].var)),\n-\t   TREE_TYPE (lhs_an_loop_info[ii].var));\n-      }\n-  for (ii = 0; ii < rhs_rank; ii++)\n-    {\n-      /* When we have a polynomial, we assume that the indices are of type \n-\t integer.  */\n-      rhs_an_loop_info[ii].var = create_tmp_var (integer_type_node);\n-      rhs_an_loop_info[ii].ind_init = build_modify_expr\n-\t(location, rhs_an_loop_info[ii].var,\n-\t TREE_TYPE (rhs_an_loop_info[ii].var), NOP_EXPR,\n-\t location, build_int_cst (TREE_TYPE (rhs_an_loop_info[ii].var), 0),\n-\t TREE_TYPE (rhs_an_loop_info[ii].var));\n-    }\n-  if (lhs_rank)\n-    {\n-      lhs_array_operand = create_array_refs\n-\t(location, lhs_an_info, lhs_an_loop_info, lhs_list_size, lhs_rank);\n-      replace_array_notations (&lhs, true, lhs_list, lhs_array_operand);\n-      array_expr_lhs = lhs;\n-    }\n-  if (rhs_array_operand)\n-    vec_safe_truncate (rhs_array_operand, 0);\n-  if (rhs_rank)\n-    {\n-      rhs_array_operand = create_array_refs\n-\t(location, rhs_an_info, rhs_an_loop_info, rhs_list_size, rhs_rank);\n-      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-      vec_safe_truncate (rhs_array_operand, 0);\n-      rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n-\t\t\t\t\t\t rhs_an_loop_info, rhs_rank,\n-\t\t\t\t\t\t rhs);\n-      if (!rhs_array_operand)\n-\tgoto error;\n-      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-    }\n-  else if (rhs_list_size > 0)\n-    {\n-      rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n-\t\t\t\t\t\t lhs_an_loop_info, lhs_rank,\n-\t\t\t\t\t\t lhs);\n-      if (!rhs_array_operand)\n-\tgoto error;\n-      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-    }\n-  array_expr_lhs = lhs;\n-  array_expr_rhs = rhs;\n-  array_expr = build_modify_expr (location, array_expr_lhs, lhs_origtype, \n-\t\t\t\t  modifycode, rhs_loc, array_expr_rhs, \n-\t\t\t\t  rhs_origtype);\n-  create_cmp_incr (location, &lhs_an_loop_info, lhs_rank, lhs_an_info);\n-  if (rhs_rank)\n-    create_cmp_incr (location, &rhs_an_loop_info, rhs_rank, rhs_an_info);\n-  \n-  for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n-    if (ii < lhs_rank && ii < rhs_rank)\n-      cond_expr[ii] = build2 (TRUTH_ANDIF_EXPR, boolean_type_node,\n-\t\t\t      lhs_an_loop_info[ii].cmp,\n-\t\t\t      rhs_an_loop_info[ii].cmp);\n-    else if (ii < lhs_rank && ii >= rhs_rank)\n-      cond_expr[ii] = lhs_an_loop_info[ii].cmp;\n-    else\n-      gcc_unreachable ();\n-\n-  an_init = pop_stmt_list (an_init);\n-  append_to_statement_list_force (an_init, &loop_with_init);\n-  body = array_expr;\n-  for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n-    {\n-      tree incr_list = alloc_stmt_list ();\n-      tree new_loop = push_stmt_list ();\n-      if (lhs_rank)\n-\tadd_stmt (lhs_an_loop_info[ii].ind_init);\n-      if (rhs_rank)\n-\tadd_stmt (rhs_an_loop_info[ii].ind_init);\n-      if (lhs_rank)\n-\tappend_to_statement_list_force (lhs_an_loop_info[ii].incr, &incr_list);\n-      if (rhs_rank && rhs_an_loop_info[ii].incr)\n-\tappend_to_statement_list_force (rhs_an_loop_info[ii].incr, &incr_list);\n-      c_finish_loop (location, cond_expr[ii], incr_list, body, NULL_TREE,\n-\t\t     NULL_TREE, true);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list_force (body, &loop_with_init);\n-\n-  release_vec_vec (lhs_an_info);\n-  release_vec_vec (rhs_an_info);\n-  return loop_with_init;\n-\n-error:\n-  release_vec_vec (lhs_an_info);\n-  release_vec_vec (rhs_an_info);\n-\n-  return error_mark_node;\n-}\n-\n-/* Helper function for fix_conditional_array_notations.  Encloses the \n-   conditional statement passed in STMT with a loop around it\n-   and replaces the condition in STMT with a ARRAY_REF tree-node to the array.\n-   The condition must have an ARRAY_NOTATION_REF tree.  An expansion of array\n-   notation in STMT is returned in a STATEMENT_LIST.  */\n-\n-static tree\n-fix_conditional_array_notations_1 (tree stmt)\n-{\n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0;\n-  tree cond = NULL_TREE, builtin_loop = NULL_TREE, new_var = NULL_TREE;\n-  size_t rank = 0, ii = 0;\n-  tree loop_init;\n-  location_t location = EXPR_LOCATION (stmt);\n-  tree body = NULL_TREE, loop_with_init = alloc_stmt_list ();\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n- \n-  if (TREE_CODE (stmt) == COND_EXPR)\n-    cond = COND_EXPR_COND (stmt);\n-  else if (TREE_CODE (stmt) == SWITCH_EXPR)\n-    cond = SWITCH_COND (stmt);\n-  else if (truth_value_p (TREE_CODE (stmt)))\n-    cond = TREE_OPERAND (stmt, 0);\n-  else\n-    /* Otherwise dont even touch the statement.  */\n-    return stmt;\n-\n-  if (!find_rank (location, cond, cond, false, &rank))\n-    return error_mark_node;\n-  \n-  extract_array_notation_exprs (stmt, false, &array_list);\n-  loop_init = push_stmt_list ();\n-  for (ii = 0; ii < vec_safe_length (array_list); ii++)\n-    { \n-      tree array_node = (*array_list)[ii];\n-      if (TREE_CODE (array_node) == CALL_EXPR)\n-\t{\n-\t  builtin_loop = fix_builtin_array_notation_fn (array_node, &new_var);\n-\t  if (builtin_loop == error_mark_node)\n-\t    {\n-\t      add_stmt (error_mark_node);\n-\t      pop_stmt_list (loop_init);\n-\t      return loop_init;\n-\t    }\n-\t  else if (builtin_loop)\n-\t    {\n-\t      vec <tree, va_gc>* sub_list = NULL, *new_var_list = NULL;\n-\t      vec_safe_push (sub_list, array_node);\n-\t      vec_safe_push (new_var_list, new_var);\n-\t      add_stmt (builtin_loop);\n-\t      replace_array_notations (&stmt, false, sub_list, new_var_list); \n-\t    }\n-\t}\n-    }\n-  if (!find_rank (location, stmt, stmt, true, &rank))\n-    {\n-      pop_stmt_list (loop_init);\n-      return error_mark_node;\n-    }\n-  if (rank == 0)\n-    {\n-      add_stmt (stmt);\n-      pop_stmt_list (loop_init); \n-      return loop_init;\n-    }  \n-  extract_array_notation_exprs (stmt, true, &array_list);\n-\n-  if (vec_safe_length (array_list) == 0)\n-    return stmt;\n-\n-  list_size = vec_safe_length (array_list);\n-  an_loop_info.safe_grow_cleared (rank);\n-  \n-  for (ii = 0; ii < list_size; ii++)\n-    if ((*array_list)[ii]\n-\t&& TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n-      {\n-\ttree array_node = (*array_list)[ii];\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n-\tmake_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n-      }\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n-      an_loop_info[ii].ind_init =\n-\tbuild_modify_expr (location, an_loop_info[ii].var,\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n-\t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var));\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t     list_size, rank);\n-  replace_array_notations (&stmt, true, array_list, array_operand);\n-  create_cmp_incr (location, &an_loop_info, rank, an_info);\n-  \n-  loop_init = pop_stmt_list (loop_init);\n-  body = stmt;\n-  append_to_statement_list_force (loop_init, &loop_with_init);\n-\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      add_stmt (an_loop_info[ii].ind_init);\n-      c_finish_loop (location, an_loop_info[ii].cmp, an_loop_info[ii].incr,\n-\t\t     body, NULL_TREE, NULL_TREE, true);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list_force (body, &loop_with_init);\n-  release_vec_vec (an_info);\n-\n-  return loop_with_init;\n-}\n-\n-/* Top-level function to replace ARRAY_NOTATION_REF in a conditional statement\n-   in STMT.   An expansion of array notation in STMT is returned as a \n-   STATEMENT_LIST.  */\n-\n-tree\n-fix_conditional_array_notations (tree stmt)\n-{\n-  if (TREE_CODE (stmt) == STATEMENT_LIST)\n-    {\n-      tree_stmt_iterator tsi;\n-      for (tsi = tsi_start (stmt); !tsi_end_p (tsi); tsi_next (&tsi))\n-\t{\n-\t  tree single_stmt = *tsi_stmt_ptr (tsi);\n-\t  *tsi_stmt_ptr (tsi) =\n-\t    fix_conditional_array_notations_1 (single_stmt);\n-\t}\n-      return stmt;\n-    }\n-  else\n-    return fix_conditional_array_notations_1 (stmt);\n-}\n-\n-/* Create a struct c_expr that contains a loop with ARRAY_REF expr at location\n-   LOCATION with the tree_code CODE and the array notation expr is\n-   passed in ARG.  Returns the fixed c_expr in ARG itself.  */\n-\n-struct c_expr \n-fix_array_notation_expr (location_t location, enum tree_code code,\n-\t\t\t struct c_expr arg)\n-{\n-\n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0, rank = 0, ii = 0;\n-  tree loop_init;\n-  tree body, loop_with_init = alloc_stmt_list ();\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n-  \n-  if (!find_rank (location, arg.value, arg.value, false, &rank))\n-    {\n-      /* If this function returns a NULL, we convert the tree value in the\n-\t structure to error_mark_node and the parser should take care of the\n-\t rest.  */\n-      arg.value = error_mark_node;\n-      return arg;\n-    }\n-  \n-  if (rank == 0)\n-    return arg;\n-  \n-  extract_array_notation_exprs (arg.value, true, &array_list);\n-\n-  if (vec_safe_length (array_list) == 0)\n-    return arg;\n-\n-  list_size = vec_safe_length (array_list);\n-\n-  an_loop_info.safe_grow_cleared (rank);\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  \n-  loop_init = push_stmt_list ();\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n-      an_loop_info[ii].ind_init =\n-\tbuild_modify_expr (location, an_loop_info[ii].var,\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR,\n-\t\t\t   location,\n-\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var));;\n-\t\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t     list_size, rank);\n-  replace_array_notations (&arg.value, true, array_list, array_operand);\n-  create_cmp_incr (location, &an_loop_info, rank, an_info);\n-\n-  arg = default_function_array_read_conversion (location, arg);\n-  if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n-    arg.value = build_unary_op (location, code, arg.value, false);\n-  else if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n-    arg = parser_build_unary_op (location, code, arg);\n-\n-  loop_init = pop_stmt_list (loop_init);\n-  append_to_statement_list_force (loop_init, &loop_with_init);\n-  body = arg.value;\n-\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      add_stmt (an_loop_info[ii].ind_init);\n-      c_finish_loop (location, an_loop_info[ii].cmp,\n-\t\t     an_loop_info[ii].incr, body, NULL_TREE,\n-\t\t     NULL_TREE, true);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list_force (body, &loop_with_init);\n-  arg.value = loop_with_init;\n-  release_vec_vec (an_info);\n-  return arg;\n-}\n-\n-/* Replaces array notations in a void function call arguments in ARG and returns\n-   a STATEMENT_LIST.  */\n-\n-static tree\n-fix_array_notation_call_expr (tree arg)\n-{\n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  tree new_var = NULL_TREE;\n-  size_t list_size = 0, rank = 0, ii = 0;\n-  tree loop_init;\n-  tree body, loop_with_init = alloc_stmt_list ();\n-  location_t location = UNKNOWN_LOCATION;\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n-\n-  if (TREE_CODE (arg) == CALL_EXPR\n-      && is_cilkplus_reduce_builtin (CALL_EXPR_FN (arg)))\n-    {\n-      loop_init = fix_builtin_array_notation_fn (arg, &new_var);\n-      /* We are ignoring the new var because either the user does not want to\n-\t capture it OR he is using sec_reduce_mutating function.  */\n-      return loop_init;\n-    }  \n-  if (!find_rank (location, arg, arg, false, &rank))\n-    return error_mark_node;\n-  \n-  if (rank == 0)\n-    return arg;\n-  \n-  extract_array_notation_exprs (arg, true, &array_list);\n-  if (vec_safe_length (array_list) == 0)\n-    return arg;\n-  \n-  list_size = vec_safe_length (array_list);\n-  location = EXPR_LOCATION (arg);\n-  an_loop_info.safe_grow_cleared (rank);\n-  \n-  loop_init = push_stmt_list ();\n-  for (ii = 0; ii < list_size; ii++)\n-    if ((*array_list)[ii]\n-\t&& TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n-\t{\n-\t  tree array_node = (*array_list)[ii];\n-\t  make_triplet_val_inv (location, &ARRAY_NOTATION_START (array_node));\n-\t  make_triplet_val_inv (location, &ARRAY_NOTATION_LENGTH (array_node));\n-\t  make_triplet_val_inv (location, &ARRAY_NOTATION_STRIDE (array_node));\n-\t}\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  if (length_mismatch_in_expr_p (location, an_info))\n-    {\n-      pop_stmt_list (loop_init);\n-      return error_mark_node;\n-    }\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      an_loop_info[ii].var = create_tmp_var (integer_type_node);\n-      an_loop_info[ii].ind_init =\n-\tbuild_modify_expr (location, an_loop_info[ii].var,\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var), NOP_EXPR, location,\n-\t\t\t   build_int_cst (TREE_TYPE (an_loop_info[ii].var), 0),\n-\t\t\t   TREE_TYPE (an_loop_info[ii].var));\n-\t\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t     list_size, rank);\n-  replace_array_notations (&arg, true, array_list, array_operand);\n-  create_cmp_incr (location, &an_loop_info, rank, an_info);\n-  loop_init = pop_stmt_list (loop_init);\n-  append_to_statement_list_force (loop_init, &loop_with_init);\n-  body = arg;\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      add_stmt (an_loop_info[ii].ind_init);\n-      c_finish_loop (location, an_loop_info[ii].cmp, an_loop_info[ii].incr,\n-\t\t     body, NULL_TREE, NULL_TREE, true);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list_force (body, &loop_with_init);\n-  release_vec_vec (an_info);\n-  return loop_with_init;\n-}\n-\n-/* Expands the built-in functions in a return.  EXPR is a RETURN_EXPR with\n-   a built-in reduction function.  This function returns the expansion code for\n-   the built-in function.  */\n-\n-static tree\n-fix_return_expr (tree expr)\n-{\n-  tree new_mod_list, new_var, new_mod, retval_expr, retval_type;\n-  location_t loc = EXPR_LOCATION (expr);\n-\n-  new_mod_list = alloc_stmt_list ();\n-  retval_expr = TREE_OPERAND (expr, 0);\n-  retval_type = TREE_TYPE (TREE_OPERAND (retval_expr, 1));\n-  new_var = build_decl (loc, VAR_DECL, NULL_TREE, TREE_TYPE (retval_expr));\n-  new_mod = build_array_notation_expr (loc, new_var, TREE_TYPE (new_var),\n-\t\t\t\t       NOP_EXPR, loc,\n-\t\t\t\t       TREE_OPERAND (retval_expr, 1),\n-\t\t\t\t       retval_type);\n-  TREE_OPERAND (retval_expr, 1) = new_var;\n-  TREE_OPERAND (expr, 0) = retval_expr;\n-  append_to_statement_list_force (new_mod, &new_mod_list);\n-  append_to_statement_list_force (expr, &new_mod_list);\n-  return new_mod_list;\n-}\n-\n-/* Callback for walk_tree.  Expands all array notations in *TP.  *WALK_SUBTREES\n-   is set to 1 unless *TP contains no array notation expressions.  */\n-\n-static tree\n-expand_array_notations (tree *tp, int *walk_subtrees, void *)\n-{\n-  if (!contains_array_notation_expr (*tp))\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-  *walk_subtrees = 1;\n-\n-  switch (TREE_CODE (*tp))\n-    {\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case TRUTH_NOT_EXPR:\n-    case COND_EXPR:\n-      *tp = fix_conditional_array_notations (*tp);\n-      break;\n-    case MODIFY_EXPR:\n-      {\n-\tlocation_t loc = EXPR_HAS_LOCATION (*tp) ? EXPR_LOCATION (*tp) :\n-\t  UNKNOWN_LOCATION;\n-\ttree lhs = TREE_OPERAND (*tp, 0);\n-\ttree rhs = TREE_OPERAND (*tp, 1);\n-\tlocation_t rhs_loc = EXPR_HAS_LOCATION (rhs) ? EXPR_LOCATION (rhs) :\n-\t  UNKNOWN_LOCATION;\n-\t*tp = build_array_notation_expr (loc, lhs, TREE_TYPE (lhs), NOP_EXPR,\n-\t\t\t\t\t rhs_loc, rhs, TREE_TYPE (rhs));\n-      }\n-      break;\n-    case DECL_EXPR:\n-      {\n-\ttree x = DECL_EXPR_DECL (*tp);\n-\tif (DECL_INITIAL (x))\n-\t  {\n-\t    location_t loc = DECL_SOURCE_LOCATION (x);\n-\t    tree lhs = x;\n-\t    tree rhs = DECL_INITIAL (x);\n-\t    DECL_INITIAL (x) = NULL;\n-\t    tree new_modify_expr = build_modify_expr (loc, lhs,\n-\t\t\t\t\t\t      TREE_TYPE (lhs),\n-\t\t\t\t\t\t      NOP_EXPR,\n-\t\t\t\t\t\t      loc, rhs,\n-\t\t\t\t\t\t      TREE_TYPE(rhs));\n-\t    expand_array_notations (&new_modify_expr, walk_subtrees, NULL);\n-\t    *tp = new_modify_expr;\n-\t  }\n-      }\n-      break;\n-    case CALL_EXPR:\n-      *tp = fix_array_notation_call_expr (*tp);\n-      break;\n-    case RETURN_EXPR:\n-      *tp = fix_return_expr (*tp);\n-      break;\n-    case COMPOUND_EXPR:\n-      if (TREE_CODE (TREE_OPERAND (*tp, 0)) == SAVE_EXPR)\n-\t{\n-\t  /* In here we are calling expand_array_notations because\n-\t     we need to be able to catch the return value and check if\n-\t     it is an error_mark_node.  */\n-\t  expand_array_notations (&TREE_OPERAND (*tp, 1), walk_subtrees, NULL);\n-\n-\t  /* SAVE_EXPR cannot have an error_mark_node inside it.  This check\n-\t     will make sure that if there is an error in expanding of\n-\t     array notations (e.g. rank mismatch) then replace the entire\n-\t     SAVE_EXPR with an error_mark_node.  */\n-\t  if (TREE_OPERAND (*tp, 1) == error_mark_node)\n-\t    *tp = error_mark_node;\n-\t}\n-      break;\n-    case ARRAY_NOTATION_REF:\n-      /* If we are here, then we are dealing with cases like this:\n-\t A[:];\n-\t A[x:y:z];\n-\t A[x:y];\n-\t Replace those with just void zero node.  */\n-      *tp = void_node;\n-    default:\n-      break;\n-    }\n-  return NULL_TREE;\n-} \n-\n-/* Walks through tree node T and expands all array notations in its subtrees.\n-   The return value is the same type as T but with all array notations \n-   replaced with appropriate ARRAY_REFS with a loop around it.  */\n-\n-tree\n-expand_array_notation_exprs (tree t)\n-{\n-  walk_tree (&t, expand_array_notations, NULL, NULL);\n-  return t;\n-}\n-\n-/* This handles expression of the form \"a[i:j:k]\" or \"a[:]\" or \"a[i:j],\" which\n-   denotes an array notation expression.  If a is a variable or a member, then\n-   we generate a ARRAY_NOTATION_REF front-end tree and return it.\n-   This tree is broken down to ARRAY_REF toward the end of parsing.\n-   ARRAY_NOTATION_REF tree holds the START_INDEX, LENGTH, STRIDE and the TYPE\n-   of ARRAY_REF.  Restrictions on START_INDEX, LENGTH and STRIDE is same as that\n-   of the index field passed into ARRAY_REF.  The only additional restriction\n-   is that, unlike index in ARRAY_REF, stride, length and start_index cannot\n-   contain ARRAY_NOTATIONS.   */\n-\n-tree\n-build_array_notation_ref (location_t loc, tree array, tree start_index, \n-\t\t\t  tree length, tree stride, tree type)\n-{\n-  tree array_ntn_tree = NULL_TREE;\n-  size_t stride_rank = 0, length_rank = 0, start_rank = 0;\n-  \n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (start_index)))\n-    {\n-      error_at (loc,\n-\t\t\"start-index of array notation triplet is not an integer\");\n-      return error_mark_node;\n-    }\n-  if (!INTEGRAL_TYPE_P (TREE_TYPE (length)))\n-    {\n-      error_at (loc, \"length of array notation triplet is not an integer\");\n-      return error_mark_node;\n-    }\n-\n-  /* The stride is an optional field.  */\n-  if (stride && !INTEGRAL_TYPE_P (TREE_TYPE (stride)))\n-    {\n-      error_at (loc, \"stride of array notation triplet is not an integer\");\n-      return error_mark_node;\n-    }  \n-  if (!stride)\n-    {\n-      if (TREE_CONSTANT (start_index) && TREE_CONSTANT (length) \n-\t  && tree_int_cst_lt (length, start_index))\n-\tstride = build_int_cst (TREE_TYPE (start_index), -1);\n-      else\n-\tstride = build_int_cst (TREE_TYPE (start_index), 1);\n-    }\t      \n-\n-  if (!find_rank (loc, start_index, start_index, false, &start_rank))\n-    return error_mark_node;\n-  if (!find_rank (loc, length, length, false, &length_rank))\n-    return error_mark_node;\n-  if (!find_rank (loc, stride, stride, false, &stride_rank))\n-    return error_mark_node;\n-\n-  if (start_rank != 0)\n-    {\n-      error_at (loc, \"rank of an array notation triplet's start-index is not \"\n-\t\t\"zero\");\n-      return error_mark_node;\n-    }\n-  if (length_rank != 0)\n-    {\n-      error_at (loc, \"rank of an array notation triplet's length is not zero\");\n-      return error_mark_node;\n-    }\n-  if (stride_rank != 0)\n-    {\n-      error_at (loc, \"rank of array notation triplet's stride is not zero\");\n-      return error_mark_node;\n-    }  \n-  array_ntn_tree = build4 (ARRAY_NOTATION_REF, NULL_TREE, NULL_TREE, NULL_TREE,\n-\t\t\t   NULL_TREE, NULL_TREE);\n-  ARRAY_NOTATION_ARRAY (array_ntn_tree) = array;\n-  ARRAY_NOTATION_START (array_ntn_tree) = start_index;\n-  ARRAY_NOTATION_LENGTH (array_ntn_tree) = length;\n-  ARRAY_NOTATION_STRIDE (array_ntn_tree) = stride;\n-  TREE_TYPE (array_ntn_tree) = type;\n-  \n-  return array_ntn_tree;\n-}"}, {"sha": "56c63d80ec4b0407872d493e6704a48bcd4c051e", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -50,7 +50,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"plugin.h\"\n #include \"c-family/c-ada-spec.h\"\n-#include \"cilk.h\"\n #include \"builtins.h\"\n #include \"spellcheck-tree.h\"\n #include \"gcc-rich-location.h\"\n@@ -9388,12 +9387,6 @@ finish_function (void)\n   /* Tie off the statement tree for this function.  */\n   DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));\n \n-  /* If the function has _Cilk_spawn in front of a function call inside it\n-     i.e. it is a spawning function, then add the appropriate Cilk plus\n-     functions inside.  */\n-  if (fn_contains_cilk_spawn_p (cfun))\n-    cfun->cilk_frame_decl = insert_cilk_frame (fndecl);\n-\n   finish_fname_decls ();\n \n   /* Complain if there's just no return statement.  */"}, {"sha": "4da24a64cd1a8535213c1ae50677c586ff2ac71e", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 37, "deletions": 955, "changes": 992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -203,12 +203,6 @@ struct GTY(()) c_parser {\n      keywords are valid.  */\n   BOOL_BITFIELD objc_property_attr_context : 1;\n \n-  /* Cilk Plus specific parser/lexer information.  */\n-\n-  /* Buffer to hold all the tokens from parsing the vector attribute for the\n-     SIMD-enabled functions (formerly known as elemental functions).  */\n-  vec <c_token, va_gc> *cilk_simd_fn_tokens;\n-\n   /* Location of the last consumed token.  */\n   location_t last_token_location;\n };\n@@ -1493,14 +1487,6 @@ static void c_parser_objc_at_dynamic_declaration (c_parser *);\n static bool c_parser_objc_diagnose_bad_element_prefix\n   (c_parser *, struct c_declspecs *);\n \n-/* Cilk Plus supporting routines.  */\n-static void c_parser_cilk_simd (c_parser *, bool *);\n-static void c_parser_cilk_for (c_parser *, tree, bool *);\n-static bool c_parser_cilk_verify_simd (c_parser *, enum pragma_context);\n-static tree c_parser_array_notation (location_t, c_parser *, tree, tree);\n-static tree c_parser_cilk_clause_vectorlength (c_parser *, tree, bool);\n-static void c_parser_cilk_grainsize (c_parser *, bool *);\n-\n static void c_parser_parse_rtl_body (c_parser *parser, char *start_with_pass);\n \n /* Parse a translation unit (C90 6.7, C99 6.9, C11 6.9).\n@@ -1986,8 +1972,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t\tC_DTR_NORMAL, &dummy);\n       if (declarator == NULL)\n \t{\n-\t  if (omp_declare_simd_clauses.exists ()\n-\t      || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n+\t  if (omp_declare_simd_clauses.exists ())\n \t    c_finish_omp_declare_simd (parser, NULL_TREE, NULL_TREE,\n \t\t\t\t       omp_declare_simd_clauses);\n \t  if (oacc_routine_data)\n@@ -2091,8 +2076,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n \t\t  if (!d)\n \t\t    d = error_mark_node;\n-\t\t  if (omp_declare_simd_clauses.exists ()\n-\t\t      || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n+\t\t  if (omp_declare_simd_clauses.exists ())\n \t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n \t\t\t\t\t       omp_declare_simd_clauses);\n \t\t}\n@@ -2104,8 +2088,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n \t\t  if (!d)\n \t\t    d = error_mark_node;\n-\t\t  if (omp_declare_simd_clauses.exists ()\n-\t\t      || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n+\t\t  if (omp_declare_simd_clauses.exists ())\n \t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n \t\t\t\t\t       omp_declare_simd_clauses);\n \t\t  init_loc = c_parser_peek_token (parser)->location;\n@@ -2146,8 +2129,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\tif (declarator->kind == cdk_function)\n \t\t  if (DECL_ARGUMENTS (d) == NULL_TREE)\n \t\t    DECL_ARGUMENTS (d) = declarator->u.arg_info->parms;\n-\t      if (omp_declare_simd_clauses.exists ()\n-\t\t  || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n+\t      if (omp_declare_simd_clauses.exists ())\n \t\t{\n \t\t  tree parms = NULL_TREE;\n \t\t  if (d && TREE_CODE (d) == FUNCTION_DECL)\n@@ -2303,8 +2285,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \tc_parser_declaration_or_fndef (parser, false, false, false,\n \t\t\t\t       true, false, NULL, vNULL);\n       store_parm_decls ();\n-      if (omp_declare_simd_clauses.exists ()\n-\t  || !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n+      if (omp_declare_simd_clauses.exists ())\n \tc_finish_omp_declare_simd (parser, current_function_decl, NULL_TREE,\n \t\t\t\t   omp_declare_simd_clauses);\n       if (oacc_routine_data)\n@@ -2339,11 +2320,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  return;\n \t}\n       else\n-\t{\n-\t  fnbody = c_parser_compound_statement (parser);\n-\t  if (flag_cilkplus && contains_array_notation_expr (fnbody))\n-\t    fnbody = expand_array_notation_exprs (fnbody);\n-\t}\n+\tfnbody = c_parser_compound_statement (parser);\n       tree fndecl = current_function_decl;\n       if (nested)\n \t{\n@@ -3799,15 +3776,6 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t      dimen.value = NULL_TREE;\n \t      star_seen = false;\n \t    }\n-\t  else if (flag_cilkplus\n-\t\t   && c_parser_next_token_is (parser, CPP_COLON))\n-\t    {\n-\t      dimen.value = error_mark_node;\n-\t      star_seen = false;\n-\t      error_at (c_parser_peek_token (parser)->location,\n-\t\t\t\"array notations cannot be used in declaration\");\n-\t      c_parser_consume_token (parser);\n-\t    }   \n \t  else if (c_parser_next_token_is (parser, CPP_MULT))\n \t    {\n \t      if (c_parser_peek_2nd_token (parser)->type == CPP_CLOSE_SQUARE)\n@@ -3830,14 +3798,6 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n \t}\n       if (c_parser_next_token_is (parser, CPP_CLOSE_SQUARE))\n \tc_parser_consume_token (parser);\n-      else if (flag_cilkplus\n-\t       && c_parser_next_token_is (parser, CPP_COLON))\n-\t{\n-\t  error_at (c_parser_peek_token (parser)->location,\n-\t\t    \"array notations cannot be used in declaration\");\n-\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-\t  return NULL;\n-\t}\n       else\n \t{\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n@@ -4283,76 +4243,6 @@ c_parser_attribute_any_word (c_parser *parser)\n   return attr_name;\n }\n \n-#define CILK_SIMD_FN_CLAUSE_MASK\t\t\t\t  \\\n-\t((OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_VECTORLENGTH)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_LINEAR)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_UNIFORM)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_MASK)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_NOMASK))\n-\n-/* Parses the vector attribute of SIMD enabled functions in Cilk Plus.\n-   VEC_TOKEN is the \"vector\" token that is replaced with \"simd\" and\n-   pushed into the token list. \n-   Syntax:\n-   vector\n-   vector (<vector attributes>).  */\n-\n-static void\n-c_parser_cilk_simd_fn_vector_attrs (c_parser *parser, c_token vec_token)\n-{\n-  gcc_assert (is_cilkplus_vector_p (vec_token.value));\n-  \n-  int paren_scope = 0;\n-  vec_safe_push (parser->cilk_simd_fn_tokens, vec_token);\n-  /* Consume the \"vector\" token.  */\n-  c_parser_consume_token (parser);\n-\n-  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n-    {\n-      c_parser_consume_token (parser);\n-      paren_scope++;\n-    }\n-  while (paren_scope > 0)\n-    {\n-      c_token *token = c_parser_peek_token (parser);\n-      if (token->type == CPP_OPEN_PAREN)\n-        paren_scope++;\n-      else if (token->type == CPP_CLOSE_PAREN)\n-        paren_scope--;\n-      /* Do not push the last ')' since we are not pushing the '('.  */\n-      if (!(token->type == CPP_CLOSE_PAREN && paren_scope == 0))\n-\tvec_safe_push (parser->cilk_simd_fn_tokens, *token);\n-      c_parser_consume_token (parser);\n-    }\n-  \n-  /* Since we are converting an attribute to a pragma, we need to end the\n-     attribute with PRAGMA_EOL.  */\n-  c_token eol_token;\n-  memset (&eol_token, 0, sizeof (eol_token));\n-  eol_token.type = CPP_PRAGMA_EOL;\n-  vec_safe_push (parser->cilk_simd_fn_tokens, eol_token);\n-}\n-\n-/* Add 2 CPP_EOF at the end of PARSER->ELEM_FN_TOKENS vector.  */\n-\n-static void\n-c_finish_cilk_simd_fn_tokens (c_parser *parser)\n-{\n-  c_token last_token = parser->cilk_simd_fn_tokens->last ();\n-\n-  /* c_parser_attributes is called in several places, so if these EOF\n-     tokens are already inserted, then don't do them again.  */\n-  if (last_token.type == CPP_EOF)\n-    return;\n-  \n-  /* Two CPP_EOF token are added as a safety net since the normal C\n-     front-end has two token look-ahead.  */\n-  c_token eof_token;\n-  eof_token.type = CPP_EOF;\n-  vec_safe_push (parser->cilk_simd_fn_tokens, eof_token);\n-  vec_safe_push (parser->cilk_simd_fn_tokens, eof_token);\n-}\n-\n /* Parse (possibly empty) attributes.  This is a GNU extension.\n \n    attributes:\n@@ -4420,16 +4310,6 @@ c_parser_attributes (c_parser *parser)\n \t  if (attr_name == NULL)\n \t    break;\n \t  attr_name = canonicalize_attr_name (attr_name);\n-\t  if (is_cilkplus_vector_p (attr_name))\n-\t    {\n-\t      c_token *v_token = c_parser_peek_token (parser);\n-\t      v_token->value = canonicalize_attr_name (v_token->value);\n-\t      c_parser_cilk_simd_fn_vector_attrs (parser, *v_token);\n-\t      /* If the next token isn't a comma, we're done.  */\n-\t      if (!c_parser_next_token_is (parser, CPP_COMMA))\n-\t\tbreak;\n-\t      continue;\n-\t    }\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n \t    {\n@@ -4526,8 +4406,6 @@ c_parser_attributes (c_parser *parser)\n       parser->lex_untranslated_string = false;\n     }\n \n-  if (flag_cilkplus && !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n-    c_finish_cilk_simd_fn_tokens (parser);\n   return attrs;\n }\n \n@@ -5011,9 +4889,6 @@ c_parser_compound_statement (c_parser *parser)\n   stmt = c_begin_compound_stmt (true);\n   c_parser_compound_statement_nostart (parser);\n \n-  /* If the compound stmt contains array notations, then we expand them.  */\n-  if (flag_cilkplus && contains_array_notation_expr (stmt))\n-    stmt = expand_array_notation_exprs (stmt);\n   return c_end_compound_stmt (brace_loc, stmt, true);\n }\n \n@@ -5507,24 +5382,6 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \tcase RID_FOR:\n \t  c_parser_for_statement (parser, false, if_p);\n \t  break;\n-\tcase RID_CILK_FOR:\n-\t  if (!flag_cilkplus)\n-\t    {\n-\t      error_at (c_parser_peek_token (parser)->location,\n-\t\t\t\"-fcilkplus must be enabled to use %<_Cilk_for%>\");\n-\t      c_parser_skip_to_end_of_block_or_statement (parser);\n-\t    }\n-\t  else\n-\t    c_parser_cilk_for (parser, integer_zero_node, if_p);\n-\t  break;\n-\tcase RID_CILK_SYNC:\n-\t  c_parser_consume_token (parser);\n-\t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n-\t  if (!flag_cilkplus) \n-\t    error_at (loc, \"-fcilkplus must be enabled to use %<_Cilk_sync%>\");\n-\t  else \n-\t    add_stmt (build_cilk_sync ());\n-\t  break;\n \tcase RID_GOTO:\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -5539,11 +5396,6 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \n \t      c_parser_consume_token (parser);\n \t      val = c_parser_expression (parser);\n-\t      if (check_no_cilk (val.value,\n-\t\t\t\t \"Cilk array notation cannot be used as a computed goto expression\",\n-\t\t\t\t \"%<_Cilk_spawn%> statement cannot be used as a computed goto expression\",\n-\t\t\t\t loc))\n-\t        val.value = error_mark_node;\n \t      val = convert_lvalue_to_rvalue (loc, val, false, true);\n \t      stmt = c_finish_goto_ptr (loc, val.value);\n \t    }\n@@ -5598,15 +5450,8 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t    {\n \t      struct c_expr expr = c_parser_expression (parser);\n \t      expr = convert_lvalue_to_rvalue (loc, expr, false, false);\n-\t      if (check_no_cilk (expr.value,\n-\t\t \"Cilk array notation cannot be used for a throw expression\",\n-\t\t \"%<_Cilk_spawn%> statement cannot be used for a throw expression\"))\n-\t        expr.value = error_mark_node;\n-\t      else\n-\t\t{\n-\t          expr.value = c_fully_fold (expr.value, false, NULL);\n-\t          stmt = objc_build_throw_stmt (loc, expr.value);\n-\t\t}\n+\t      expr.value = c_fully_fold (expr.value, false, NULL);\n+\t      stmt = objc_build_throw_stmt (loc, expr.value);\n \t      goto expect_semicolon;\n \t    }\n \t  break;\n@@ -5884,7 +5729,6 @@ c_parser_if_statement (c_parser *parser, bool *if_p, vec<tree> *chain)\n   bool nested_if = false;\n   tree first_body, second_body;\n   bool in_if_block;\n-  tree if_stmt;\n \n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_IF));\n   token_indent_info if_tinfo\n@@ -5893,11 +5737,6 @@ c_parser_if_statement (c_parser *parser, bool *if_p, vec<tree> *chain)\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_paren_condition (parser);\n-  if (flag_cilkplus && contains_cilk_spawn_stmt (cond))\n-    {\n-      error_at (loc, \"if statement cannot contain %<Cilk_spawn%>\");\n-      cond = error_mark_node;\n-    }\n   in_if_block = parser->in_if_block;\n   parser->in_if_block = true;\n   first_body = c_parser_if_body (parser, &nested_if, if_tinfo);\n@@ -5956,12 +5795,8 @@ c_parser_if_statement (c_parser *parser, bool *if_p, vec<tree> *chain)\n \t}\n     }\n   c_finish_if_stmt (loc, cond, first_body, second_body);\n-  if_stmt = c_end_compound_stmt (loc, block, flag_isoc99);\n+  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n \n-  /* If the if statement contains array notations, then we expand them.  */\n-  if (flag_cilkplus && contains_array_notation_expr (if_stmt))\n-    if_stmt = fix_conditional_array_notations (if_stmt);\n-  add_stmt (if_stmt);\n   c_parser_maybe_reclassify_token (parser);\n }\n \n@@ -5993,11 +5828,6 @@ c_parser_switch_statement (c_parser *parser, bool *if_p)\n       ce = convert_lvalue_to_rvalue (switch_cond_loc, ce, true, false);\n       expr = ce.value;\n       /* ??? expr has no valid location?  */\n-      if (check_no_cilk (expr,\n-\t \"Cilk array notation cannot be used as a condition for switch statement\",\n-\t \"%<_Cilk_spawn%> statement cannot be used as a condition for switch statement\",\n-\t\t\t switch_cond_loc))\n-        expr = error_mark_node;\n       parens.skip_until_found_close (parser);\n     }\n   else\n@@ -6050,10 +5880,6 @@ c_parser_while_statement (c_parser *parser, bool ivdep, bool *if_p)\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n   cond = c_parser_paren_condition (parser);\n-  if (check_no_cilk (cond,\n-         \"Cilk array notation cannot be used as a condition for while statement\",\n-\t \"%<_Cilk_spawn%> statement cannot be used as a condition for while statement\"))\n-    cond = error_mark_node;\n   if (ivdep && cond != error_mark_node)\n     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node,\n@@ -6116,10 +5942,6 @@ c_parser_do_statement (c_parser *parser, bool ivdep)\n   new_cont = c_cont_label;\n   c_cont_label = save_cont;\n   cond = c_parser_paren_condition (parser);\n-  if (check_no_cilk (cond,\n-\t \"Cilk array notation cannot be used as a condition for a do-while statement\",\n-\t \"%<_Cilk_spawn%> statement cannot be used as a condition for a do-while statement\"))\n-    cond = error_mark_node;\n   if (ivdep && cond != error_mark_node)\n     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n \t\t   build_int_cst (integer_type_node,\n@@ -6278,8 +6100,6 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t    struct c_expr ce;\n \t    tree init_expression;\n \t    ce = c_parser_expression (parser);\n-\t    /* In theory we could forbid _Cilk_spawn here, as the spec says \"only in top\n-\t       level statement\", but it works just fine, so allow it.  */\n \t    init_expression = ce.value;\n \t    parser->objc_could_be_foreach_context = false;\n \t    if (c_parser_next_token_is_keyword (parser, RID_IN))\n@@ -6321,10 +6141,6 @@ c_parser_for_statement (c_parser *parser, bool ivdep, bool *if_p)\n \t  else\n \t    {\n \t      cond = c_parser_condition (parser);\n-\t      if (check_no_cilk (cond,\n-\t\t \"Cilk array notation cannot be used in a condition for a for-loop\",\n-\t\t \"%<_Cilk_spawn%> statement cannot be used in a condition for a for-loop\"))\n-\t\tcond = error_mark_node;\n \t      c_parser_skip_until_found (parser, CPP_SEMICOLON,\n \t\t\t\t\t \"expected %<;%>\");\n \t    }\n@@ -7284,27 +7100,15 @@ c_parser_unary_expression (c_parser *parser)\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n \n-      /* If there is array notations in op, we expand them.  */\n-      if (flag_cilkplus && TREE_CODE (op.value) == ARRAY_NOTATION_REF)\n-\treturn fix_array_notation_expr (exp_loc, PREINCREMENT_EXPR, op);\n-      else\n-\t{\n-\t  op = default_function_array_read_conversion (exp_loc, op);\n-\t  return parser_build_unary_op (op_loc, PREINCREMENT_EXPR, op);\n-\t}\n+      op = default_function_array_read_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, PREINCREMENT_EXPR, op);\n     case CPP_MINUS_MINUS:\n       c_parser_consume_token (parser);\n       exp_loc = c_parser_peek_token (parser)->location;\n       op = c_parser_cast_expression (parser, NULL);\n       \n-      /* If there is array notations in op, we expand them.  */\n-      if (flag_cilkplus && TREE_CODE (op.value) == ARRAY_NOTATION_REF)\n-\treturn fix_array_notation_expr (exp_loc, PREDECREMENT_EXPR, op);\n-      else\n-\t{\n-\t  op = default_function_array_read_conversion (exp_loc, op);\n-\t  return parser_build_unary_op (op_loc, PREDECREMENT_EXPR, op);\n-\t}\n+      op = default_function_array_read_conversion (exp_loc, op);\n+      return parser_build_unary_op (op_loc, PREDECREMENT_EXPR, op);\n     case CPP_AND:\n       c_parser_consume_token (parser);\n       op = c_parser_cast_expression (parser, NULL);\n@@ -9082,30 +8886,6 @@ c_parser_postfix_expression (c_parser *parser)\n \tcase RID_GENERIC:\n \t  expr = c_parser_generic_selection (parser);\n \t  break;\n-\tcase RID_CILK_SPAWN:\n-\t  c_parser_consume_token (parser);\n-\t  if (!flag_cilkplus)\n-\t    {\n-\t      error_at (loc, \"-fcilkplus must be enabled to use \"\n-\t\t\t\"%<_Cilk_spawn%>\");\n-\t      expr = c_parser_cast_expression (parser, NULL);\n-\t      expr.set_error ();\n-\t    }\n-\t  else if (c_parser_peek_token (parser)->keyword == RID_CILK_SPAWN)\n-\t    {\n-\t      error_at (loc, \"consecutive %<_Cilk_spawn%> keywords \"\n-\t\t\t\"are not permitted\");\n-\t      /* Now flush out all the _Cilk_spawns.  */\n-\t      while (c_parser_peek_token (parser)->keyword == RID_CILK_SPAWN)\n-\t\tc_parser_consume_token (parser);\n-\t      expr = c_parser_cast_expression (parser, NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      expr = c_parser_cast_expression (parser, NULL);\n-\t      expr.value = build_cilk_spawn (loc, expr.value);\n-\t    }\n-\t  break;\n \tdefault:\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.set_error ();\n@@ -9249,39 +9029,13 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \tcase CPP_OPEN_SQUARE:\n \t  /* Array reference.  */\n \t  c_parser_consume_token (parser);\n-\t  if (flag_cilkplus\n-\t      && c_parser_peek_token (parser)->type == CPP_COLON)\n-\t    /* If we are here, then we have something like this:\n-\t       Array [ : ]\n-\t    */\n-\t    expr.value = c_parser_array_notation (expr_loc, parser, NULL_TREE,\n-\t\t\t\t\t\t  expr.value);\n-\t  else\n-\t    {\t      \n-\t      idx = c_parser_expression (parser).value;\n-\t      /* Here we have 3 options:\n-\t\t 1. Array [EXPR] -- Normal Array call.\n-\t\t 2. Array [EXPR : EXPR] -- Array notation without stride.\n-\t\t 3. Array [EXPR : EXPR : EXPR] -- Array notation with stride.\n-\n-\t\t For 1, we just handle it just like a normal array expression.\n-\t\t For 2 and 3 we handle it like we handle array notations.  The\n-\t\t idx value we have above becomes the initial/start index.\n-\t      */\n-\t      if (flag_cilkplus\n-\t\t  && c_parser_peek_token (parser)->type == CPP_COLON)\n-\t\texpr.value = c_parser_array_notation (expr_loc, parser, idx, \n-\t\t\t\t\t\t      expr.value);\n-\t      else\n-\t\t{\n-\t\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n-\t\t\t\t\t     \"expected %<]%>\");\n-\t\t  start = expr.get_start ();\n-\t\t  finish = parser->tokens_buf[0].location;\n-\t\t  expr.value = build_array_ref (op_loc, expr.value, idx);\n-\t\t  set_c_expr_source_range (&expr, start, finish);\n-\t\t}\n-\t    }\n+\t  idx = c_parser_expression (parser).value;\n+\t  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE,\n+\t\t\t\t     \"expected %<]%>\");\n+\t  start = expr.get_start ();\n+\t  finish = parser->tokens_buf[0].location;\n+\t  expr.value = build_array_ref (op_loc, expr.value, idx);\n+\t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n \t  break;\n@@ -9422,16 +9176,9 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  start = expr.get_start ();\n \t  finish = c_parser_peek_token (parser)->get_finish ();\n \t  c_parser_consume_token (parser);\n-\t  /* If the expressions have array notations, we expand them.  */\n-\t  if (flag_cilkplus\n-\t      && TREE_CODE (expr.value) == ARRAY_NOTATION_REF)\n-\t    expr = fix_array_notation_expr (expr_loc, POSTINCREMENT_EXPR, expr);\n-\t  else\n-\t    {\n-\t      expr = default_function_array_read_conversion (expr_loc, expr);\n-\t      expr.value = build_unary_op (op_loc, POSTINCREMENT_EXPR,\n-\t\t\t\t\t   expr.value, false);\n-\t    }\n+\t  expr = default_function_array_read_conversion (expr_loc, expr);\n+\t  expr.value = build_unary_op (op_loc, POSTINCREMENT_EXPR,\n+\t\t\t\t       expr.value, false);\n \t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n@@ -9441,16 +9188,9 @@ c_parser_postfix_expression_after_primary (c_parser *parser,\n \t  start = expr.get_start ();\n \t  finish = c_parser_peek_token (parser)->get_finish ();\n \t  c_parser_consume_token (parser);\n-\t  /* If the expressions have array notations, we expand them.  */\n-\t  if (flag_cilkplus\n-\t      && TREE_CODE (expr.value) == ARRAY_NOTATION_REF)\n-\t    expr = fix_array_notation_expr (expr_loc, POSTDECREMENT_EXPR, expr);\n-\t  else\n-\t    {\n-\t      expr = default_function_array_read_conversion (expr_loc, expr);\n-\t      expr.value = build_unary_op (op_loc, POSTDECREMENT_EXPR,\n-\t\t\t\t\t   expr.value, false);\n-\t    }\n+\t  expr = default_function_array_read_conversion (expr_loc, expr);\n+\t  expr.value = build_unary_op (op_loc, POSTDECREMENT_EXPR,\n+\t\t\t\t       expr.value, false);\n \t  set_c_expr_source_range (&expr, start, finish);\n \t  expr.original_code = ERROR_MARK;\n \t  expr.original_type = NULL;\n@@ -11206,30 +10946,6 @@ c_parser_pragma (c_parser *parser, enum pragma_context context, bool *if_p)\n       c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n       return false;\n \n-    case PRAGMA_CILK_SIMD:\n-      if (!c_parser_cilk_verify_simd (parser, context))\n-\treturn false;\n-      c_parser_consume_pragma (parser);\n-      c_parser_cilk_simd (parser, if_p);\n-      return false;\n-    case PRAGMA_CILK_GRAINSIZE:\n-      if (!flag_cilkplus)\n-\t{\n-\t  warning (0, \"%<#pragma grainsize%> ignored because -fcilkplus is not\"\n-\t\t   \" enabled\");\n-\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n-\t  return false;\n-\t}\n-      if (context == pragma_external)\n-\t{\n-\t  error_at (c_parser_peek_token (parser)->location,\n-\t\t    \"%<#pragma grainsize%> must be inside a function\");\n-\t  c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n-\t  return false;\n-\t}\n-      c_parser_cilk_grainsize (parser, if_p);\n-      return false;\n-\n     case PRAGMA_OACC_WAIT:\n       if (context != pragma_compound)\n \t{\n@@ -11412,8 +11128,6 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_MAP;\n \t  else if (!strcmp (\"mergeable\", p))\n \t    result = PRAGMA_OMP_CLAUSE_MERGEABLE;\n-\t  else if (flag_cilkplus && !strcmp (\"mask\", p))\n-\t    result = PRAGMA_CILK_CLAUSE_MASK;\n \t  break;\n \tcase 'n':\n \t  if (!strcmp (\"nogroup\", p))\n@@ -11432,8 +11146,6 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_NUM_THREADS;\n \t  else if (!strcmp (\"num_workers\", p))\n \t    result = PRAGMA_OACC_CLAUSE_NUM_WORKERS;\n-\t  else if (flag_cilkplus && !strcmp (\"nomask\", p))\n-\t    result = PRAGMA_CILK_CLAUSE_NOMASK;\n \t  break;\n \tcase 'o':\n \t  if (!strcmp (\"ordered\", p))\n@@ -11512,8 +11224,6 @@ c_parser_omp_clause_name (c_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_VECTOR;\n \t  else if (!strcmp (\"vector_length\", p))\n \t    result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;\n-\t  else if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n-\t    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n \t  break;\n \tcase 'w':\n \t  if (!strcmp (\"wait\", p))\n@@ -13414,7 +13124,7 @@ c_parser_omp_clause_aligned (c_parser *parser, tree list)\n    linear ( modifier ( variable-list ) : expression ) */\n \n static tree\n-c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n+c_parser_omp_clause_linear (c_parser *parser, tree list)\n {\n   location_t clause_loc = c_parser_peek_token (parser)->location;\n   tree nl, c, step;\n@@ -13424,8 +13134,7 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n   if (!parens.require_open (parser))\n     return list;\n \n-  if (!is_cilk_simd_fn\n-      && c_parser_next_token_is (parser, CPP_NAME))\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n     {\n       c_token *tok = c_parser_peek_token (parser);\n       const char *p = IDENTIFIER_POINTER (tok->value);\n@@ -13454,11 +13163,6 @@ c_parser_omp_clause_linear (c_parser *parser, tree list, bool is_cilk_simd_fn)\n       expr = convert_lvalue_to_rvalue (expr_loc, expr, false, true);\n       step = expr.value;\n       step = c_fully_fold (step, false, NULL);\n-      if (is_cilk_simd_fn && TREE_CODE (step) == PARM_DECL)\n-\t{\n-\t  sorry (\"using parameters for %<linear%> step is not supported yet\");\n-\t  step = integer_one_node;\n-\t}\n       if (!INTEGRAL_TYPE_P (TREE_TYPE (step)))\n \t{\n \t  error_at (clause_loc, \"%<linear%> clause step expression must \"\n@@ -14218,7 +13922,7 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t\t\t  const char *where, bool finish_p = true)\n {\n   tree clauses = NULL;\n-  bool first = true, cilk_simd_fn = false;\n+  bool first = true;\n \n   while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n     {\n@@ -14324,13 +14028,11 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  c_name = \"untied\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_INBRANCH:\n-\tcase PRAGMA_CILK_CLAUSE_MASK:\n \t  clauses = c_parser_omp_clause_branch (parser, OMP_CLAUSE_INBRANCH,\n \t\t\t\t\t\tclauses);\n \t  c_name = \"inbranch\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOTINBRANCH:\n-\tcase PRAGMA_CILK_CLAUSE_NOMASK:\n \t  clauses = c_parser_omp_clause_branch (parser, OMP_CLAUSE_NOTINBRANCH,\n \t\t\t\t\t\tclauses);\n \t  c_name = \"notinbranch\";\n@@ -14407,9 +14109,7 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  c_name = \"aligned\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINEAR: \n-\t  if (((mask >> PRAGMA_CILK_CLAUSE_VECTORLENGTH) & 1) != 0)\n-\t   cilk_simd_fn = true; \n-\t  clauses = c_parser_omp_clause_linear (parser, clauses, cilk_simd_fn); \n+\t  clauses = c_parser_omp_clause_linear (parser, clauses); \n \t  c_name = \"linear\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEPEND:\n@@ -14444,10 +14144,6 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_safelen (parser, clauses);\n \t  c_name = \"safelen\";\n \t  break;\n-\tcase PRAGMA_CILK_CLAUSE_VECTORLENGTH:\n-\t  clauses = c_parser_cilk_clause_vectorlength (parser, clauses, true);\n-\t  c_name = \"simdlen\";\n-\t  break;\n \tcase PRAGMA_OMP_CLAUSE_SIMDLEN:\n \t  clauses = c_parser_omp_clause_simdlen (parser, clauses);\n \t  c_name = \"simdlen\";\n@@ -15781,18 +15477,11 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   condv = make_tree_vec (count);\n   incrv = make_tree_vec (count);\n \n-  if (code != CILK_FOR\n-      && !c_parser_next_token_is_keyword (parser, RID_FOR))\n+  if (!c_parser_next_token_is_keyword (parser, RID_FOR))\n     {\n       c_parser_error (parser, \"for statement expected\");\n       return NULL;\n     }\n-  if (code == CILK_FOR\n-      && !c_parser_next_token_is_keyword (parser, RID_CILK_FOR))\n-    {\n-      c_parser_error (parser, \"_Cilk_for statement expected\");\n-      return NULL;\n-    }\n   for_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n \n@@ -15892,10 +15581,6 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t    case LT_EXPR:\n \t    case LE_EXPR:\n \t      break;\n-\t    case NE_EXPR:\n-\t      if (code == CILK_SIMD || code == CILK_FOR)\n-\t\tbreak;\n-\t      /* FALLTHRU.  */\n \t    default:\n \t      /* Can't be cond = error_mark_node, because we want to preserve\n \t\t the location until c_finish_omp_for.  */\n@@ -15972,10 +15657,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n     if_p = NULL;\n \n   save_break = c_break_label;\n-  if (code == CILK_SIMD)\n-    c_break_label = build_int_cst (size_type_node, 2);\n-  else\n-    c_break_label = size_one_node;\n+  c_break_label = size_one_node;\n   save_cont = c_cont_label;\n   c_cont_label = NULL_TREE;\n   body = push_stmt_list ();\n@@ -17529,18 +17211,6 @@ static void\n c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n \t\t\t   vec<c_token> clauses)\n {\n-  if (flag_cilkplus\n-      && (clauses.exists ()\n-\t  || lookup_attribute (\"simd\", DECL_ATTRIBUTES (fndecl)))\n-      && !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n-    {\n-      error (\"%<#pragma omp declare simd%> or %<simd%> attribute cannot be \"\n-\t     \"used in the same function marked as a Cilk Plus SIMD-enabled \"\n-\t     \"function\");\n-      vec_free (parser->cilk_simd_fn_tokens);\n-      return;\n-    }\n-  \n   /* Normally first token is CPP_NAME \"simd\".  CPP_EOF there indicates\n      error has been reported and CPP_PRAGMA that c_finish_omp_declare_simd\n      has already processed the tokens.  */\n@@ -17567,60 +17237,26 @@ c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n \n   unsigned int tokens_avail = parser->tokens_avail;\n   gcc_assert (parser->tokens == &parser->tokens_buf[0]);\n-  bool is_cilkplus_cilk_simd_fn = false;\n   \n-  if (flag_cilkplus && !vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n-    {\n-      parser->tokens = parser->cilk_simd_fn_tokens->address ();\n-      parser->tokens_avail = vec_safe_length (parser->cilk_simd_fn_tokens);\n-      is_cilkplus_cilk_simd_fn = true;\n-\n-      if (lookup_attribute (\"simd\", DECL_ATTRIBUTES (fndecl)) != NULL)\n-\t{\n-\t  error_at (DECL_SOURCE_LOCATION (fndecl),\n-\t\t    \"%<__simd__%> attribute cannot be used in the same \"\n-\t\t    \"function marked as a Cilk Plus SIMD-enabled function\");\n-\t  vec_free (parser->cilk_simd_fn_tokens);\n-\t  return;\n-\t}\n \n-    }\n-  else\n-    {\n-      parser->tokens = clauses.address ();\n-      parser->tokens_avail = clauses.length ();\n-    }\n+  parser->tokens = clauses.address ();\n+  parser->tokens_avail = clauses.length ();\n   \n   /* c_parser_omp_declare_simd pushed 2 extra CPP_EOF tokens at the end.  */\n   while (parser->tokens_avail > 3)\n     {\n       c_token *token = c_parser_peek_token (parser);\n-      if (!is_cilkplus_cilk_simd_fn) \n-\tgcc_assert (token->type == CPP_NAME \n-\t\t    && strcmp (IDENTIFIER_POINTER (token->value), \"simd\") == 0);\n-      else\n-\tgcc_assert (token->type == CPP_NAME\n-\t\t    && is_cilkplus_vector_p (token->value));\n+      gcc_assert (token->type == CPP_NAME\n+\t\t  && strcmp (IDENTIFIER_POINTER (token->value), \"simd\") == 0);\n       c_parser_consume_token (parser);\n       parser->in_pragma = true;\n \n       tree c = NULL_TREE;\n-      if (is_cilkplus_cilk_simd_fn) \n-\tc = c_parser_omp_all_clauses (parser, CILK_SIMD_FN_CLAUSE_MASK,\n-\t\t\t\t      \"SIMD-enabled functions attribute\");\n-      else \n-\tc = c_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n+      c = c_parser_omp_all_clauses (parser, OMP_DECLARE_SIMD_CLAUSE_MASK,\n \t\t\t\t      \"#pragma omp declare simd\");\n       c = c_omp_declare_simd_clauses_to_numbers (parms, c);\n       if (c != NULL_TREE)\n \tc = tree_cons (NULL_TREE, c, NULL_TREE);\n-      if (is_cilkplus_cilk_simd_fn) \n-\t{\n-\t  tree k = build_tree_list (get_identifier (\"cilk simd function\"), \n-\t\t\t\t    NULL_TREE);\n-\t  TREE_CHAIN (k) = DECL_ATTRIBUTES (fndecl);\n-\t  DECL_ATTRIBUTES (fndecl) = k;\n-\t}\n       c = build_tree_list (get_identifier (\"omp declare simd\"), c);\n       TREE_CHAIN (c) = DECL_ATTRIBUTES (fndecl);\n       DECL_ATTRIBUTES (fndecl) = c;\n@@ -17630,9 +17266,6 @@ c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n   parser->tokens_avail = tokens_avail;\n   if (clauses.exists ())\n     clauses[0].type = CPP_PRAGMA;\n-\n-  if (!vec_safe_is_empty (parser->cilk_simd_fn_tokens))\n-    vec_free (parser->cilk_simd_fn_tokens);\n }\n \n \n@@ -18384,419 +18017,7 @@ c_parser_omp_threadprivate (c_parser *parser)\n \n   c_parser_skip_to_pragma_eol (parser);\n }\n-\f\n-/* Cilk Plus <#pragma simd> parsing routines.  */\n-\n-/* Helper function for c_parser_pragma.  Perform some sanity checking\n-   for <#pragma simd> constructs.  Returns FALSE if there was a\n-   problem.  */\n-\n-static bool\n-c_parser_cilk_verify_simd (c_parser *parser,\n-\t\t\t\t  enum pragma_context context)\n-{\n-  if (!flag_cilkplus)\n-    {\n-      warning (0, \"pragma simd ignored because -fcilkplus is not enabled\");\n-      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n-      return false;\n-    }\n-  if (context == pragma_external)\n-    {\n-      c_parser_error (parser,\"pragma simd must be inside a function\");\n-      c_parser_skip_until_found (parser, CPP_PRAGMA_EOL, NULL);\n-      return false;\n-    }\n-  return true;\n-}\n-\n-/* Cilk Plus:\n-   This function is shared by SIMD-enabled functions and #pragma simd.  \n-   If IS_SIMD_FN is true then it is parsing a SIMD-enabled function and \n-   CLAUSES is unused.  The main purpose of this function is to parse a\n-   vectorlength attribute or clause and check for parse errors.\n-   When IS_SIMD_FN is true then the function is merely caching the tokens\n-   in PARSER->CILK_SIMD_FN_TOKENS.  If errors are found then the token\n-   cache is cleared since there is no reason to continue.\n-   Syntax:\n-   vectorlength ( constant-expression )  */\n-\n-static tree\n-c_parser_cilk_clause_vectorlength (c_parser *parser, tree clauses, \n-\t\t\t\t   bool is_simd_fn)\n-{\n-  if (is_simd_fn)\n-    check_no_duplicate_clause (clauses, OMP_CLAUSE_SIMDLEN, \"vectorlength\");\n-  else\n-  /* The vectorlength clause behaves exactly like OpenMP's safelen\n-     clause.  Represent it in OpenMP terms.  */\n-    check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\");\n-\n-  matching_parens parens;\n-  if (!parens.require_open (parser))\n-    return clauses;\n-\n-  location_t loc = c_parser_peek_token (parser)->location;\n-  tree expr = c_parser_expr_no_commas (parser, NULL).value;\n-  expr = c_fully_fold (expr, false, NULL);\n-\n-  /* If expr is an error_mark_node then the above function would have\n-     emitted an error.  No reason to do it twice.  */\n-  if (expr == error_mark_node)\n-    ;\n-  else if (!TREE_TYPE (expr)\n-\t   || !TREE_CONSTANT (expr)\n-\t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n-  \n-    error_at (loc, \"vectorlength must be an integer constant\");  \n-  else if (wi::exact_log2 (wi::to_wide (expr)) == -1)\n-    error_at (loc, \"vectorlength must be a power of 2\");\n-  else\n-    {\n-      if (is_simd_fn)\n-\t{\n-\t  tree u = build_omp_clause (loc, OMP_CLAUSE_SIMDLEN);\n-\t  OMP_CLAUSE_SIMDLEN_EXPR (u) = expr;\n-\t  OMP_CLAUSE_CHAIN (u) = clauses;\n-\t  clauses = u;\n-\t}\n-      else\n-\t{\n-\t  tree u = build_omp_clause (loc, OMP_CLAUSE_SAFELEN);\n-\t  OMP_CLAUSE_SAFELEN_EXPR (u) = expr;\n-\t  OMP_CLAUSE_CHAIN (u) = clauses;\n-\t  clauses = u;\n-\t}\n-    }\n-\n-  parens.require_close (parser);\n-\n-  return clauses;\n-}\n-\n-/* Cilk Plus:\n-   linear ( simd-linear-variable-list )\n-\n-   simd-linear-variable-list:\n-     simd-linear-variable\n-     simd-linear-variable-list , simd-linear-variable\n-\n-   simd-linear-variable:\n-     id-expression\n-     id-expression : simd-linear-step\n-\n-   simd-linear-step:\n-   conditional-expression */\n-\n-static tree\n-c_parser_cilk_clause_linear (c_parser *parser, tree clauses)\n-{\n-  matching_parens parens;\n-  if (!parens.require_open (parser))\n-    return clauses;\n-\n-  location_t loc = c_parser_peek_token (parser)->location;\n-\n-  if (c_parser_next_token_is_not (parser, CPP_NAME)\n-      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n-    c_parser_error (parser, \"expected identifier\");\n-\n-  while (c_parser_next_token_is (parser, CPP_NAME)\n-\t && c_parser_peek_token (parser)->id_kind == C_ID_ID)\n-    {\n-      tree var = lookup_name (c_parser_peek_token (parser)->value);\n-\n-      if (var == NULL)\n-\t{\n-\t  undeclared_variable (c_parser_peek_token (parser)->location,\n-\t\t\t       c_parser_peek_token (parser)->value);\n-\tc_parser_consume_token (parser);\n-\t}\n-      else if (var == error_mark_node)\n-\tc_parser_consume_token (parser);\n-      else\n-\t{\n-\t  tree step = integer_one_node;\n-\n-\t  /* Parse the linear step if present.  */\n-\t  if (c_parser_peek_2nd_token (parser)->type == CPP_COLON)\n-\t    {\n-\t      c_parser_consume_token (parser);\n-\t      c_parser_consume_token (parser);\n-\n-\t      tree expr = c_parser_expr_no_commas (parser, NULL).value;\n-\t      expr = c_fully_fold (expr, false, NULL);\n-\n-\t      if (TREE_TYPE (expr)\n-\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (expr))\n-\t\t  && (TREE_CONSTANT (expr)\n-\t\t      || DECL_P (expr)))\n-\t\tstep = expr;\n-\t      else\n-\t\tc_parser_error (parser,\n-\t\t\t\t\"step size must be an integer constant \"\n-\t\t\t\t\"expression or an integer variable\");\n-\t    }\n-\t  else\n-\t    c_parser_consume_token (parser);\n-\n-\t  /* Use OMP_CLAUSE_LINEAR, which has the same semantics.  */\n-\t  tree u = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n-\t  OMP_CLAUSE_DECL (u) = var;\n-\t  OMP_CLAUSE_LINEAR_STEP (u) = step;\n-\t  OMP_CLAUSE_CHAIN (u) = clauses;\n-\t  clauses = u;\n-\t}\n-\n-      if (c_parser_next_token_is_not (parser, CPP_COMMA))\n-\tbreak;\n-\n-      c_parser_consume_token (parser);\n-    }\n-\n-  parens.skip_until_found_close (parser);\n-\n-  return clauses;\n-}\n-\n-/* Returns the name of the next clause.  If the clause is not\n-   recognized SIMD_OMP_CLAUSE_NONE is returned and the next token is\n-   not consumed.  Otherwise, the appropriate pragma_simd_clause is\n-   returned and the token is consumed.  */\n-\n-static pragma_omp_clause\n-c_parser_cilk_clause_name (c_parser *parser)\n-{\n-  pragma_omp_clause result;\n-  c_token *token = c_parser_peek_token (parser);\n-\n-  if (!token->value || token->type != CPP_NAME)\n-    return PRAGMA_CILK_CLAUSE_NONE;\n-\n-  const char *p = IDENTIFIER_POINTER (token->value);\n-\n-  if (!strcmp (p, \"vectorlength\"))\n-    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n-  else if (!strcmp (p, \"linear\"))\n-    result = PRAGMA_CILK_CLAUSE_LINEAR;\n-  else if (!strcmp (p, \"private\"))\n-    result = PRAGMA_CILK_CLAUSE_PRIVATE;\n-  else if (!strcmp (p, \"firstprivate\"))\n-    result = PRAGMA_CILK_CLAUSE_FIRSTPRIVATE;\n-  else if (!strcmp (p, \"lastprivate\"))\n-    result = PRAGMA_CILK_CLAUSE_LASTPRIVATE;\n-  else if (!strcmp (p, \"reduction\"))\n-    result = PRAGMA_CILK_CLAUSE_REDUCTION;\n-  else\n-    return PRAGMA_CILK_CLAUSE_NONE;\n-\n-  c_parser_consume_token (parser);\n-  return result;\n-}\n-\n-/* Parse all #<pragma simd> clauses.  Return the list of clauses\n-   found.  */\n-\n-static tree\n-c_parser_cilk_all_clauses (c_parser *parser)\n-{\n-  tree clauses = NULL;\n-\n-  while (c_parser_next_token_is_not (parser, CPP_PRAGMA_EOL))\n-    {\n-      pragma_omp_clause c_kind;\n-\n-      c_kind = c_parser_cilk_clause_name (parser);\n-\n-      switch (c_kind)\n-\t{\n-\tcase PRAGMA_CILK_CLAUSE_VECTORLENGTH:\n-\t  clauses = c_parser_cilk_clause_vectorlength (parser, clauses, false);\n-\t  break;\n-\tcase PRAGMA_CILK_CLAUSE_LINEAR:\n-\t  clauses = c_parser_cilk_clause_linear (parser, clauses);\n-\t  break;\n-\tcase PRAGMA_CILK_CLAUSE_PRIVATE:\n-\t  /* Use the OpenMP counterpart.  */\n-\t  clauses = c_parser_omp_clause_private (parser, clauses);\n-\t  break;\n-\tcase PRAGMA_CILK_CLAUSE_FIRSTPRIVATE:\n-\t  /* Use the OpenMP counterpart.  */\n-\t  clauses = c_parser_omp_clause_firstprivate (parser, clauses);\n-\t  break;\n-\tcase PRAGMA_CILK_CLAUSE_LASTPRIVATE:\n-\t  /* Use the OpenMP counterpart.  */\n-\t  clauses = c_parser_omp_clause_lastprivate (parser, clauses);\n-\t  break;\n-\tcase PRAGMA_CILK_CLAUSE_REDUCTION:\n-\t  /* Use the OpenMP counterpart.  */\n-\t  clauses = c_parser_omp_clause_reduction (parser, clauses);\n-\t  break;\n-\tdefault:\n-\t  c_parser_error (parser, \"expected %<#pragma simd%> clause\");\n-\t  goto saw_error;\n-\t}\n-    }\n-\n- saw_error:\n-  c_parser_skip_to_pragma_eol (parser);\n-  return c_finish_omp_clauses (clauses, C_ORT_CILK);\n-}\n-\n-/* This function helps parse the grainsize pragma for a _Cilk_for statement.\n-   Here is the correct syntax of this pragma:\n-\t    #pragma cilk grainsize = <EXP>\n- */\n-\n-static void\n-c_parser_cilk_grainsize (c_parser *parser, bool *if_p)\n-{\n-  extern tree convert_to_integer (tree, tree);\n-\n-  /* consume the 'grainsize' keyword.  */\n-  c_parser_consume_pragma (parser);\n-\n-  if (c_parser_require (parser, CPP_EQ, \"expected %<=%>\") != 0)\n-    {\n-      struct c_expr g_expr = c_parser_binary_expression (parser, NULL, NULL);\n-      if (g_expr.value == error_mark_node)\n-\t{\n-\t  c_parser_skip_to_pragma_eol (parser);\n-\t  return;\n-\t}\n-      tree grain = convert_to_integer (long_integer_type_node,\n-\t\t\t\t       c_fully_fold (g_expr.value, false,\n-\t\t\t\t\t\t     NULL));\n-      c_parser_skip_to_pragma_eol (parser);\n-      c_token *token = c_parser_peek_token (parser);\n-      if (token && token->type == CPP_KEYWORD\n-\t  && token->keyword == RID_CILK_FOR)\n-\t{\n-\t  if (grain == NULL_TREE || grain == error_mark_node)\n-\t    grain = integer_zero_node;\n-\t  c_parser_cilk_for (parser, grain, if_p);\n-\t}\n-      else\n-\twarning (0, \"%<#pragma cilk grainsize%> is not followed by \"\n-\t\t    \"%<_Cilk_for%>\");\n-    }\n-  else\n-    c_parser_skip_to_pragma_eol (parser);\n-}\n-\n-/* Main entry point for parsing Cilk Plus <#pragma simd> for loops.  */\n-\n-static void\n-c_parser_cilk_simd (c_parser *parser, bool *if_p)\n-{\n-  tree clauses = c_parser_cilk_all_clauses (parser);\n-  tree block = c_begin_compound_stmt (true);\n-  location_t loc = c_parser_peek_token (parser)->location;\n-  c_parser_omp_for_loop (loc, parser, CILK_SIMD, clauses, NULL, if_p);\n-  block = c_end_compound_stmt (loc, block, true);\n-  add_stmt (block);\n-}\n-\n-/* Create an artificial decl with TYPE and emit initialization of it with\n-   INIT.  */\n-\n-static tree\n-c_get_temp_regvar (tree type, tree init)\n-{\n-  location_t loc = EXPR_LOCATION (init);\n-  tree decl = build_decl (loc, VAR_DECL, NULL_TREE, type);\n-  DECL_ARTIFICIAL (decl) = 1;\n-  DECL_IGNORED_P (decl) = 1;\n-  pushdecl (decl);\n-  tree t = build2 (INIT_EXPR, type, decl, init);\n-  add_stmt (t);\n-  return decl;\n-}\n-\n-/* Main entry point for parsing Cilk Plus _Cilk_for loops.\n-  GRAIN is the grain value passed in through pragma or 0.  */\n-\n-static void\n-c_parser_cilk_for (c_parser *parser, tree grain, bool *if_p)\n-{\n-  tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n-  OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n-  OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n-  clauses = c_finish_omp_clauses (clauses, C_ORT_CILK);\n-\n-  tree block = c_begin_compound_stmt (true);\n-  tree sb = push_stmt_list ();\n-  location_t loc = c_parser_peek_token (parser)->location;\n-  tree omp_for = c_parser_omp_for_loop (loc, parser, CILK_FOR, clauses, NULL,\n-\t\t\t\t\tif_p);\n-  sb = pop_stmt_list (sb);\n-\n-  if (omp_for)\n-    {\n-      tree omp_par = make_node (OMP_PARALLEL);\n-      TREE_TYPE (omp_par) = void_type_node;\n-      OMP_PARALLEL_CLAUSES (omp_par) = NULL_TREE;\n-      tree bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-      TREE_SIDE_EFFECTS (bind) = 1;\n-      BIND_EXPR_BODY (bind) = sb;\n-      OMP_PARALLEL_BODY (omp_par) = bind;\n-      if (OMP_FOR_PRE_BODY (omp_for))\n-\t{\n-\t  add_stmt (OMP_FOR_PRE_BODY (omp_for));\n-\t  OMP_FOR_PRE_BODY (omp_for) = NULL_TREE;\n-\t}\n-      tree init = TREE_VEC_ELT (OMP_FOR_INIT (omp_for), 0);\n-      tree decl = TREE_OPERAND (init, 0);\n-      tree cond = TREE_VEC_ELT (OMP_FOR_COND (omp_for), 0);\n-      tree incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), 0);\n-      tree t = TREE_OPERAND (cond, 1), c, clauses = NULL_TREE;\n-      if (TREE_CODE (t) != INTEGER_CST)\n-\t{\n-\t  TREE_OPERAND (cond, 1) = c_get_temp_regvar (TREE_TYPE (t), t);\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (cond, 1);\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      if (TREE_CODE (incr) == MODIFY_EXPR)\n-\t{\n-\t  t = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n-\t  if (TREE_CODE (t) != INTEGER_CST)\n-\t    {\n-\t      TREE_OPERAND (TREE_OPERAND (incr, 1), 1)\n-\t\t= c_get_temp_regvar (TREE_TYPE (t), t);\n-\t      c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n-\t      OMP_CLAUSE_CHAIN (c) = clauses;\n-\t      clauses = c;\n-\t    }\n-\t}\n-      t = TREE_OPERAND (init, 1);\n-      if (TREE_CODE (t) != INTEGER_CST)\n-\t{\n-\t  TREE_OPERAND (init, 1) = c_get_temp_regvar (TREE_TYPE (t), t);\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (init, 1);\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n-      OMP_CLAUSE_DECL (c) = decl;\n-      OMP_CLAUSE_CHAIN (c) = clauses;\n-      clauses = c;\n-      c = build_omp_clause (input_location, OMP_CLAUSE__CILK_FOR_COUNT_);\n-      OMP_CLAUSE_OPERAND (c, 0)\n-\t= cilk_for_number_of_iterations (omp_for);\n-      OMP_CLAUSE_CHAIN (c) = clauses;\n-      OMP_PARALLEL_CLAUSES (omp_par) = c_finish_omp_clauses (c, C_ORT_CILK);\n-      add_stmt (omp_par);\n-    }\n-\n-  block = c_end_compound_stmt (loc, block, true);\n-  add_stmt (block);\n-}\n \n-\f\n /* Parse a transaction attribute (GCC Extension).\n \n    transaction-attribute:\n@@ -19042,145 +18263,6 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n-/* This function parses Cilk Plus array notation.  The starting index is\n-   passed in INITIAL_INDEX and the array name is passes in ARRAY_VALUE.  The\n-   return value of this function is a tree_node called VALUE_TREE of type\n-   ARRAY_NOTATION_REF.  */\n-\n-static tree \n-c_parser_array_notation (location_t loc, c_parser *parser, tree initial_index, \n-\t\t\t tree array_value)\n-{\n-  c_token *token = NULL;\n-  tree start_index = NULL_TREE, end_index = NULL_TREE, stride = NULL_TREE;\n-  tree value_tree = NULL_TREE, type = NULL_TREE, array_type = NULL_TREE;\n-  tree array_type_domain = NULL_TREE; \n-\n-  if (array_value == error_mark_node || initial_index == error_mark_node)\n-    {\n-      /* No need to continue.  If either of these 2 were true, then an error\n-\t must be emitted already.  Thus, no need to emit them twice.  */\n-      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-      return error_mark_node;\n-    }\n-  \n-  array_type = TREE_TYPE (array_value);\n-  gcc_assert (array_type);\n-  if (TREE_CODE (array_type) != ARRAY_TYPE\n-      && TREE_CODE (array_type) != POINTER_TYPE)\n-    {\n-      error_at (loc, \"base of array section must be pointer or array type\");\n-      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-      return error_mark_node;\n-    }\n-  type = TREE_TYPE (array_type);\n-  token = c_parser_peek_token (parser);\n-   \n-  if (token->type == CPP_EOF)\n-    {\n-      c_parser_error (parser, \"expected %<:%> or numeral\");\n-      return value_tree;\n-    }\n-  else if (token->type == CPP_COLON)\n-    {\n-      if (!initial_index)\n-\t{\n-\t  /* If we are here, then we have a case like this A[:].  */\n-\t  c_parser_consume_token (parser);\n-\t  if (TREE_CODE (array_type) == POINTER_TYPE)\n-\t    {\n-\t      error_at (loc, \"start-index and length fields necessary for \"\n-\t\t\t\"using array notations in pointers\");\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (TREE_CODE (array_type) == FUNCTION_TYPE)\n-\t    {\n-\t      error_at (loc, \"array notations cannot be used with function \"\n-\t\t\t\"type\");\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-\t      return error_mark_node;\n-\t    }\n-\t  array_type_domain = TYPE_DOMAIN (array_type);\n-\n-\t  if (!array_type_domain)\n-\t    {\n-\t      error_at (loc, \"start-index and length fields necessary for \"\n-\t\t\t\"using array notations in dimensionless arrays\");\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-\t      return error_mark_node;\n-\t    }\n-\n-\t  start_index = TYPE_MIN_VALUE (array_type_domain);\n-\t  start_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node,\n-\t\t\t\t     start_index);\n-\t  if (!TYPE_MAX_VALUE (array_type_domain)\n-\t      || !TREE_CONSTANT (TYPE_MAX_VALUE (array_type_domain)))\n-\t    {\n-\t      error_at (loc, \"start-index and length fields necessary for \"\n-\t\t\t\"using array notations in variable-length arrays\");\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-\t      return error_mark_node;\n-\t    }\n-\t  end_index = TYPE_MAX_VALUE (array_type_domain);\n-\t  end_index = fold_build2 (PLUS_EXPR, TREE_TYPE (end_index),\n-\t\t\t\t   end_index, integer_one_node);\n-\t  end_index = fold_build1 (CONVERT_EXPR, ptrdiff_type_node, end_index);\n-\t  stride = build_int_cst (integer_type_node, 1);\n-\t  stride = fold_build1 (CONVERT_EXPR, ptrdiff_type_node, stride);\n-\t}\n-      else if (initial_index != error_mark_node)\n-\t{\n-\t  /* If we are here, then there should be 2 possibilities:\n-\t     1. Array [EXPR : EXPR]\n-\t     2. Array [EXPR : EXPR : EXPR]\n-\t  */\n-\t  start_index = initial_index;\n-\n-\t  if (TREE_CODE (array_type) == FUNCTION_TYPE)\n-\t    {\n-\t      error_at (loc, \"array notations cannot be used with function \"\n-\t\t\t\"type\");\n-\t      c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, NULL);\n-\t      return error_mark_node;\n-\t    }\n-\t  c_parser_consume_token (parser); /* consume the ':' */\n-\t  struct c_expr ce = c_parser_expression (parser);\n-\t  ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n-\t  end_index = ce.value;\n-\t  if (!end_index || end_index == error_mark_node)\n-\t    {\n-\t      c_parser_skip_to_end_of_block_or_statement (parser);\n-\t      return error_mark_node;\n-\t    }\n-\t  if (c_parser_peek_token (parser)->type == CPP_COLON)\n-\t    {\n-\t      c_parser_consume_token (parser);\n-\t      ce = c_parser_expression (parser);\n-\t      ce = convert_lvalue_to_rvalue (loc, ce, false, false);\n-\t      stride = ce.value;\n-\t      if (!stride || stride == error_mark_node)\n-\t\t{\n-\t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\tc_parser_error (parser, \"expected array notation expression\");\n-    }\n-  else\n-    c_parser_error (parser, \"expected array notation expression\");\n-  \n-  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n-\n-  value_tree = build_array_notation_ref (loc, array_value, start_index,\n-\t\t\t\t\t end_index, stride, type);\n-  if (value_tree != error_mark_node)\n-    SET_EXPR_LOCATION (value_tree, loc);\n-  return value_tree;\n-}\n-\n /* Parse the body of a function declaration marked with \"__RTL\".\n \n    The RTL parser works on the level of characters read from a"}, {"sha": "f761305bfdc1a8af39a02b32313090851d33fc5e", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 14, "deletions": 142, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-general.h\"\n #include \"c-family/c-objc.h\"\n #include \"c-family/c-ubsan.h\"\n-#include \"cilk.h\"\n #include \"gomp-constants.h\"\n #include \"spellcheck-tree.h\"\n #include \"gcc-rich-location.h\"\n@@ -2593,17 +2592,6 @@ build_array_ref (location_t loc, tree array, tree index)\n       || TREE_TYPE (index) == error_mark_node)\n     return error_mark_node;\n \n-  if (flag_cilkplus && contains_array_notation_expr (index))\n-    {\n-      size_t rank = 0;\n-      if (!find_rank (loc, index, index, true, &rank))\n-\treturn error_mark_node;\n-      if (rank > 1)\n-\t{\n-\t  error_at (loc, \"rank of the array's index is greater than 1\");\n-\t  return error_mark_node;\n-\t}\n-    }\n   if (TREE_CODE (TREE_TYPE (array)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (array)) != POINTER_TYPE\n       /* Allow vector[index] but not index[vector].  */\n@@ -3033,10 +3021,6 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n \t often rewritten and don't match the original parameter list.  */\n       if (name && !strncmp (IDENTIFIER_POINTER (name), \"__atomic_\", 9))\n         origtypes = NULL;\n-\n-      if (flag_cilkplus\n-\t  && is_cilkplus_reduce_builtin (function))\n-\torigtypes = NULL;\n     }\n   if (TREE_CODE (TREE_TYPE (function)) == FUNCTION_TYPE)\n     function = function_to_pointer_conversion (loc, function);\n@@ -3261,8 +3245,6 @@ convert_arguments (location_t loc, vec<location_t> arg_loc, tree typelist,\n \t  break;\n \t}\n     }\n-  if (flag_cilkplus && fundecl && is_cilkplus_reduce_builtin (fundecl))\n-    return vec_safe_length (values);\n \n   /* Scan the given expressions and types, producing individual\n      converted arguments.  */\n@@ -4733,7 +4715,6 @@ lvalue_p (const_tree ref)\n \n     case INDIRECT_REF:\n     case ARRAY_REF:\n-    case ARRAY_NOTATION_REF:\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n@@ -5301,14 +5282,6 @@ build_compound_expr (location_t loc, tree expr1, tree expr2)\n   tree eptype = NULL_TREE;\n   tree ret;\n \n-  if (flag_cilkplus\n-      && (TREE_CODE (expr1) == CILK_SPAWN_STMT\n-\t  || TREE_CODE (expr2) == CILK_SPAWN_STMT))\n-    {\n-      error_at (loc,\n-\t\t\"spawned function call cannot be part of a comma expression\");\n-      return error_mark_node;\n-    }\n   expr1_int_operands = EXPR_INT_CONST_OPERANDS (expr1);\n   if (expr1_int_operands)\n     expr1 = remove_c_maybe_const_expr (expr1);\n@@ -10051,7 +10024,6 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n   tree valtype = TREE_TYPE (TREE_TYPE (current_function_decl)), ret_stmt;\n   bool no_warning = false;\n   bool npc = false;\n-  size_t rank = 0;\n \n   /* Use the expansion point to handle cases such as returning NULL\n      in a function returning void.  */\n@@ -10061,25 +10033,6 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n     warning_at (xloc, 0,\n \t\t\"function declared %<noreturn%> has a %<return%> statement\");\n \n-  if (flag_cilkplus && contains_array_notation_expr (retval))\n-    {\n-      /* Array notations are allowed in a return statement if it is inside a\n-\t built-in array notation reduction function.  */\n-      if (!find_rank (loc, retval, retval, false, &rank))\n-\treturn error_mark_node;\n-      if (rank >= 1)\n-\t{\n-\t  error_at (loc, \"array notation expression cannot be used as a \"\n-\t\t    \"return value\");\n-\t  return error_mark_node;\n-\t}\n-    }\n-  if (flag_cilkplus && retval && contains_cilk_spawn_stmt (retval))\n-    {\n-      error_at (loc, \"use of %<_Cilk_spawn%> in a return statement is not \"\n-\t\t\"allowed\");\n-      return error_mark_node;\n-    }\n   if (retval)\n     {\n       tree semantic_type = NULL_TREE;\n@@ -10425,35 +10378,6 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n {\n   tree stmt;\n \n-  /* If the condition has array notations, then the rank of the then_block and\n-     else_block must be either 0 or be equal to the rank of the condition.  If\n-     the condition does not have array notations then break them up as it is\n-     broken up in a normal expression.  */\n-  if (flag_cilkplus && contains_array_notation_expr (cond))\n-    {\n-      size_t then_rank = 0, cond_rank = 0, else_rank = 0;\n-      if (!find_rank (if_locus, cond, cond, true, &cond_rank))\n-\treturn;\n-      if (then_block\n-\t  && !find_rank (if_locus, then_block, then_block, true, &then_rank))\n-\treturn;\n-      if (else_block\n-\t  && !find_rank (if_locus, else_block, else_block, true, &else_rank)) \n-\treturn;\n-      if (cond_rank != then_rank && then_rank != 0)\n-\t{\n-\t  error_at (if_locus, \"rank-mismatch between if-statement%'s condition\"\n-\t\t    \" and the then-block\");\n-\t  return;\n-\t}\n-      else if (cond_rank != else_rank && else_rank != 0)\n-\t{\n-\t  error_at (if_locus, \"rank-mismatch between if-statement%'s condition\"\n-\t\t    \" and the else-block\");\n-\t  return;\n-\t}\n-    }\n-\n   stmt = build3 (COND_EXPR, void_type_node, cond, then_block, else_block);\n   SET_EXPR_LOCATION (stmt, if_locus);\n   add_stmt (stmt);\n@@ -10471,9 +10395,6 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n {\n   tree entry = NULL, exit = NULL, t;\n \n-  /* In theory could forbid cilk spawn for loop increment expression,\n-     but it should work just fine.  */\n-  \n   /* If the condition is zero don't generate a loop construct.  */\n   if (cond && integer_zerop (cond))\n     {\n@@ -11037,18 +10958,9 @@ build_binary_op (location_t location, enum tree_code code,\n       op1 = default_conversion (op1);\n     }\n \n-  /* When Cilk Plus is enabled and there are array notations inside op0, then\n-     we check to see if there are builtin array notation functions.  If\n-     so, then we take on the type of the array notation inside it.  */\n-  if (flag_cilkplus && contains_array_notation_expr (op0)) \n-    orig_type0 = type0 = find_correct_array_notation_type (op0);\n-  else\n-    orig_type0 = type0 = TREE_TYPE (op0);\n+  orig_type0 = type0 = TREE_TYPE (op0);\n \n-  if (flag_cilkplus && contains_array_notation_expr (op1))\n-    orig_type1 = type1 = find_correct_array_notation_type (op1);\n-  else \n-    orig_type1 = type1 = TREE_TYPE (op1);\n+  orig_type1 = type1 = TREE_TYPE (op1);\n \n   /* The expression codes of the data types of the arguments tell us\n      whether the arguments are integers, floating, pointers, etc.  */\n@@ -13292,38 +13204,21 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t\"clause on %<simd%> or %<for%> constructs\");\n \t      OMP_CLAUSE_LINEAR_KIND (c) = OMP_CLAUSE_LINEAR_DEFAULT;\n \t    }\n-\t  if (ort & C_ORT_CILK)\n+\t  if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n \t    {\n-\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t\t  && !SCALAR_FLOAT_TYPE_P (TREE_TYPE (t))\n-\t\t  && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n-\t\t{\n-\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"linear clause applied to non-integral, \"\n-\t\t\t    \"non-floating, non-pointer variable with type %qT\",\n-\t\t\t    TREE_TYPE (t));\n-\t\t  remove = true;\n-\t\t  break;\n-\t\t}\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\"linear clause applied to non-integral non-pointer \"\n+\t\t\t\"variable with type %qT\", TREE_TYPE (t));\n+\t      remove = true;\n+\t      break;\n \t    }\n-\t  else\n+\t  if (TYPE_ATOMIC (TREE_TYPE (t)))\n \t    {\n-\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t\t  && TREE_CODE (TREE_TYPE (t)) != POINTER_TYPE)\n-\t\t{\n-\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"linear clause applied to non-integral non-pointer \"\n-\t\t\t    \"variable with type %qT\", TREE_TYPE (t));\n-\t\t  remove = true;\n-\t\t  break;\n-\t\t}\n-\t      if (TYPE_ATOMIC (TREE_TYPE (t)))\n-\t\t{\n-\t\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t    \"%<_Atomic%> %qD in %<linear%> clause\", t);\n-\t\t  remove = true;\n-\t\t  break;\n-\t\t}\n+\t      error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t    \"%<_Atomic%> %qD in %<linear%> clause\", t);\n+\t      remove = true;\n+\t      break;\n \t    }\n \t  if (ort == C_ORT_OMP_DECLARE_SIMD)\n \t    {\n@@ -13855,7 +13750,6 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_HINT:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n-\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n@@ -14407,28 +14301,6 @@ c_tree_equal (tree t1, tree t2)\n   return false;\n }\n \n-/* Inserts \"cleanup\" functions after the function-body of FNDECL.  FNDECL is a \n-   spawn-helper and BODY is the newly created body for FNDECL.  */\n-\n-void\n-cilk_install_body_with_frame_cleanup (tree fndecl, tree body, void *w)\n-{\n-  tree list = alloc_stmt_list ();\n-  tree frame = make_cilk_frame (fndecl);\n-  tree dtor = create_cilk_function_exit (frame, false, true);\n-  add_local_decl (cfun, frame);\n-  \n-  DECL_SAVED_TREE (fndecl) = list;\n-\n-  tree body_list = alloc_stmt_list ();\n-  cilk_outline (fndecl, &body, (struct wrapper_data *) w);\n-  body = fold_build_cleanup_point_expr (void_type_node, body);\n-\n-  append_to_statement_list (body, &body_list);\n-  append_to_statement_list (build_stmt (EXPR_LOCATION (body), TRY_FINALLY_EXPR,\n-\t\t\t\t       \tbody_list, dtor), &list);\n-}\n-\n /* Returns true when the function declaration FNDECL is implicit,\n    introduced as a result of a call to an otherwise undeclared\n    function, and false otherwise.  */"}, {"sha": "92d81d30a495d9b4e30dffc092526172d5049299", "filename": "gcc/cif-code.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -128,10 +128,6 @@ DEFCIFCODE(USES_COMDAT_LOCAL, CIF_FINAL_ERROR,\n DEFCIFCODE(ATTRIBUTE_MISMATCH, CIF_FINAL_ERROR,\n \t   N_(\"function attribute mismatch\"))\n \n-/* We can't inline because of mismatched caller/callee attributes.  */\n-DEFCIFCODE(CILK_SPAWN, CIF_FINAL_ERROR,\n-\t   N_(\"caller function contains cilk spawn\"))\n-\n /* We proved that the call is unreachable.  */\n DEFCIFCODE(UNREACHABLE, CIF_FINAL_ERROR,\n \t   N_(\"unreachable\"))"}, {"sha": "348d08efd9e3c82defa5e0b92198f5a3f8a8428a", "filename": "gcc/cilk-builtins.def", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilk-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilk-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-builtins.def?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,35 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   Cilk Plus builtins used in the GNU compiler.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>\n-   \t          Intel Corporation.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_ENTER_FRAME, \"__cilkrts_enter_frame_1\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_ENTER_FRAME_FAST, \n-\t\t       \"__cilkrts_enter_frame_fast_1\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_DETACH, \"__cilkrts_detach\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_RETHROW, \"__cilkrts_rethrow\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SYNCHED, \"__cilkrts_synched\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SYNC, \"__cilkrts_sync\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_LEAVE_FRAME, \"__cilkrts_leave_frame\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_POP_FRAME, \"__cilkrts_pop_frame\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SAVE_FP, \"__cilkrts_save_fp_ctrl_state\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_FOR_32, \"__cilkrts_cilk_for_32\")\n-DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_FOR_64, \"__cilkrts_cilk_for_64\")"}, {"sha": "edde47118697bb4832f7634819715a2dd8d9ccbd", "filename": "gcc/cilk-common.c", "status": "removed", "additions": 0, "deletions": 571, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilk-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilk-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-common.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,571 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   This file contains the CilkPlus Intrinsics\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n-   Intel Corporation\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"function.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"stringpool.h\"\n-#include \"expmed.h\"\n-#include \"optabs-query.h\"\n-#include \"insn-config.h\"\n-#include \"memmodel.h\"\n-#include \"emit-rtl.h\"\n-#include \"recog.h\"\n-#include \"fold-const.h\"\n-#include \"stor-layout.h\"\n-#include \"langhooks.h\"\n-#include \"explow.h\"\n-#include \"profile-count.h\"\n-#include \"expr.h\"\n-#include \"tree-iterator.h\"\n-#include \"gimplify.h\"\n-#include \"cilk.h\"\n-\n-/* This structure holds all the important fields of the internal structures,\n-   internal built-in functions, and Cilk-specific data types.  Explanation of \n-   all the these fielsd are given in cilk.h.  */\n-tree cilk_trees[(int) CILK_TI_MAX];\n-\n-/* Returns the value in structure FRAME pointed by the FIELD_NUMBER\n-   (e.g. X.y).  \n-   FIELD_NUMBER is an index to the structure FRAME_PTR.  For details\n-   about these fields, refer to cilk_trees structure in cilk.h and\n-   cilk_init_builtins function  in this file.  Returns a TREE that is the type \n-   of the field represented by FIELD_NUMBER.  If VOLATIL parameter is set\n-   to true then the returning field is set as volatile.  */\n-\n-tree\n-cilk_dot (tree frame, int field_number, bool volatil)\n-{\n-  tree field = cilk_trees[field_number];\n-  field = fold_build3 (COMPONENT_REF, TREE_TYPE (field), frame, field, \n-\t\t       NULL_TREE);\n-  TREE_THIS_VOLATILE (field) = volatil;\n-  return field;\n-}\n-\n-/* Returns the address of a field in FRAME_PTR, pointed by FIELD_NUMBER.  \n-   (e.g. (&X)->y).   Please see cilk_dot function for explanation of the \n-   FIELD_NUMBER.  Returns a tree that is the type of the field represented \n-   by FIELD_NUMBER. If VOLATIL parameter is set to true then the returning\n-   field is set as volatile.  */\n-\n-tree\n-cilk_arrow (tree frame_ptr, int field_number, bool volatil)\n-{\n-  return cilk_dot (build_simple_mem_ref (frame_ptr), \n-\t\t   field_number, volatil);\n-}\n-\n-\n-/* This function will add FIELD of type TYPE to a defined built-in \n-   structure.  *NAME is the name of the field to be added.  */\n-\n-static tree\n-add_field (const char *name, tree type, tree fields)\n-{\n-  tree t = get_identifier (name);\n-  tree field = build_decl (BUILTINS_LOCATION, FIELD_DECL, t, type);\n-  TREE_CHAIN (field) = fields;\n-  return field;\n-}\n-\n-/* This function will define a built-in function of NAME, of type FNTYPE and\n-   register it under the built-in function code CODE.  If PUBLISH is set then\n-   the declaration is pushed into the declaration list.  CODE is the index\n-   to the cilk_trees array.  *NAME is the name of the function to be added.  */\n-\n-static tree\n-install_builtin (const char *name, tree fntype, enum built_in_function code,\n-                 bool publish)\n-{\n-  tree fndecl = build_fn_decl (name, fntype);\n-  DECL_BUILT_IN_CLASS (fndecl) = BUILT_IN_NORMAL;\n-  DECL_FUNCTION_CODE (fndecl) = code;\n-  if (publish)\n-    {\n-      tree t = lang_hooks.decls.pushdecl (fndecl);\n-      if (t)\n-        fndecl = t;\n-    }\n-  set_builtin_decl (code, fndecl, true);\n-  return fndecl;\n-}\n-\n-/* Returns a FUNCTION_DECL of type TYPE whose name is *NAME.  */\n-\n-static tree\n-declare_cilk_for_builtin (const char *name, tree type,\n-\t\t\t  enum built_in_function code)\n-{\n-  tree cb, ft, fn;\n-\n-  cb = build_function_type_list (void_type_node,\n-\t\t\t\t ptr_type_node, type, type,\n-\t\t\t\t NULL_TREE);\n-  cb = build_pointer_type (cb);\n-  ft = build_function_type_list (void_type_node,\n-\t\t\t\t cb, ptr_type_node, type,\n-\t\t\t\t integer_type_node, NULL_TREE);\n-  fn = install_builtin (name, ft, code, false);\n-  TREE_NOTHROW (fn) = 0;\n-\n-  return fn;\n-}\n-\n-/* Creates and initializes all the built-in Cilk keywords functions and three\n-   structures: __cilkrts_stack_frame, __cilkrts_pedigree and __cilkrts_worker.\n-   Detailed information about __cilkrts_stack_frame and\n-   __cilkrts_worker structures are given in libcilkrts/include/internal/abi.h.\n-   __cilkrts_pedigree is described in libcilkrts/include/cilk/common.h.  */\n-\n-void\n-cilk_init_builtins (void)\n-{\n-  /* Now build the following __cilkrts_pedigree struct:\n-     struct __cilkrts_pedigree {\n-        uint64_t rank;\n-        struct __cilkrts_pedigree *parent;\n-      }  */\n-\n-  tree pedigree_type = lang_hooks.types.make_type (RECORD_TYPE);\n-  tree pedigree_ptr  = build_pointer_type (pedigree_type);\n-  tree field = add_field (\"rank\", uint64_type_node, NULL_TREE);\n-  cilk_trees[CILK_TI_PEDIGREE_RANK] = field;\n-  field = add_field (\"parent\", pedigree_ptr, field);\n-  cilk_trees[CILK_TI_PEDIGREE_PARENT] = field;\n-  finish_builtin_struct (pedigree_type, \"__cilkrts_pedigree_GCC\", field,\n-\t\t\t NULL_TREE);\n-  lang_hooks.types.register_builtin_type (pedigree_type,\n-\t\t\t\t\t  \"__cilkrts_pedigree_t\");\n-  cilk_pedigree_type_decl = pedigree_type; \n-\n-  /* Build the Cilk Stack Frame:\n-     struct __cilkrts_stack_frame {\n-       uint32_t flags;\n-       uint32_t size;\n-       struct __cilkrts_stack_frame *call_parent;\n-       __cilkrts_worker *worker;\n-       void *except_data;\n-       void *ctx[4];\n-       uint32_t mxcsr;\n-       uint16_t fpcsr;\n-       uint16_t reserved;\n-       __cilkrts_pedigree pedigree;\n-     };  */\n-\n-  tree frame = lang_hooks.types.make_type (RECORD_TYPE);\n-  tree frame_ptr = build_pointer_type (frame);\n-  tree worker_type = lang_hooks.types.make_type (RECORD_TYPE);\n-  tree worker_ptr = build_pointer_type (worker_type);\n-  tree s_type_node = build_int_cst (size_type_node, 4);\n-\n-  tree flags = add_field (\"flags\", uint32_type_node, NULL_TREE);\n-  tree size = add_field (\"size\", uint32_type_node, flags);\n-  tree parent = add_field (\"call_parent\", frame_ptr, size);\n-  tree worker = add_field (\"worker\", worker_ptr, parent);\n-  tree except = add_field (\"except_data\", frame_ptr, worker);\n-  tree context = add_field (\"ctx\",\n-\t\t\t    build_array_type (ptr_type_node,\n-\t\t\t\t\t      build_index_type (s_type_node)),\n-\t\t\t    except);\n-  tree mxcsr = add_field (\"mxcsr\", uint32_type_node, context);\n-  tree fpcsr = add_field (\"fpcsr\", uint16_type_node, mxcsr);\n-  tree reserved = add_field (\"reserved\", uint16_type_node, fpcsr);\n-  tree pedigree = add_field (\"pedigree\", pedigree_type, reserved);\n-  \n-  /* Now add them to a common structure whose fields are #defined to something\n-     that is used at a later stage.  */\n-  cilk_trees[CILK_TI_FRAME_FLAGS] = flags;\n-  cilk_trees[CILK_TI_FRAME_PARENT] = parent;\n-  cilk_trees[CILK_TI_FRAME_WORKER] = worker;\n-  cilk_trees[CILK_TI_FRAME_EXCEPTION] = except;\n-  cilk_trees[CILK_TI_FRAME_CONTEXT] = context;\n-  /* We don't care about reserved, so no need to store it in cilk_trees.  */\n-  cilk_trees[CILK_TI_FRAME_PEDIGREE] = pedigree;\n-  TREE_ADDRESSABLE (frame) = 1;\n-\n-  finish_builtin_struct (frame, \"__cilkrts_st_frame_GCC\", pedigree, NULL_TREE);\n-  cilk_frame_type_decl = frame;\n-  lang_hooks.types.register_builtin_type (frame, \"__cilkrts_frame_t\");\n-\n-  cilk_frame_ptr_type_decl = build_qualified_type (frame_ptr,\n-\t\t\t\t\t\t   TYPE_QUAL_VOLATILE);\n-  /* Now let's do the following worker struct:\n-\n-     struct __cilkrts_worker {\n-       __cilkrts_stack_frame *volatile *volatile tail;\n-       __cilkrts_stack_frame *volatile *volatile head;\n-       __cilkrts_stack_frame *volatile *volatile exc;\n-       __cilkrts_stack_frame *volatile *volatile protected_tail;\n-       __cilkrts_stack_frame *volatile *ltq_limit;\n-       int32_t self;\n-       global_state_t *g;\n-       local_state *l;\n-       cilkred_map *reducer_map;\n-       __cilkrts_stack_frame *current_stack_frame;\n-       void *reserved;\n-       __cilkrts_worker_sysdep_state *sysdep;\n-       __cilkrts_pedigree pedigree;\n-    }   */\n-\n-  tree fptr_volatil_type = build_qualified_type (frame_ptr, TYPE_QUAL_VOLATILE);\n-  tree fptr_volatile_ptr = build_pointer_type (fptr_volatil_type);\n-  tree fptr_vol_ptr_vol = build_qualified_type (fptr_volatile_ptr,\n-\t\t\t\t\t\tTYPE_QUAL_VOLATILE);\n-  tree g = lang_hooks.types.make_type (RECORD_TYPE);\n-  finish_builtin_struct (g, \"__cilkrts_global_state\", NULL_TREE, NULL_TREE);\n-  tree l = lang_hooks.types.make_type (RECORD_TYPE);\n-  finish_builtin_struct (l, \"__cilkrts_local_state\", NULL_TREE, NULL_TREE);\n-  tree sysdep_t = lang_hooks.types.make_type (RECORD_TYPE);\n-  finish_builtin_struct (sysdep_t, \"__cilkrts_worker_sysdep_state\", NULL_TREE,\n-\t\t\t NULL_TREE);\n-\n-  field = add_field (\"tail\", fptr_vol_ptr_vol, NULL_TREE);\n-  cilk_trees[CILK_TI_WORKER_TAIL] = field;\n-  field = add_field (\"head\", fptr_vol_ptr_vol, field);\n-  field  = add_field (\"exc\", fptr_vol_ptr_vol, field);\n-  field = add_field (\"protected_tail\", fptr_vol_ptr_vol, field);\n-  field = add_field (\"ltq_limit\", fptr_volatile_ptr, field);\n-  field = add_field (\"self\", integer_type_node, field);\n-  field = add_field (\"g\", build_pointer_type (g), field);\n-  field = add_field (\"l\", build_pointer_type (g), field);\n-  field = add_field (\"reducer_map\", ptr_type_node, field);\n-  field = add_field (\"current_stack_frame\", frame_ptr, field);\n-  cilk_trees[CILK_TI_WORKER_CUR] = field;\n-  field = add_field (\"saved_protected_tail\", fptr_volatile_ptr, field);\n-  field = add_field (\"sysdep\", build_pointer_type (sysdep_t), field);\n-  field = add_field (\"pedigree\", pedigree_type, field);\n-  cilk_trees[CILK_TI_WORKER_PEDIGREE] = field;\n-  finish_builtin_struct (worker_type, \"__cilkrts_worker_GCC\", field,\n-\t\t\t NULL_TREE);\n-\n-  tree fptr_arglist = tree_cons (NULL_TREE, frame_ptr, void_list_node);\n-  tree fptr_fun = build_function_type (void_type_node, fptr_arglist);\n-\n-  /* void __cilkrts_enter_frame_1 (__cilkrts_stack_frame *);  */\n-  cilk_enter_fndecl = install_builtin (\"__cilkrts_enter_frame_1\", fptr_fun,\n-\t\t\t\t       BUILT_IN_CILK_ENTER_FRAME, false);\n-\n-  /* void __cilkrts_enter_frame_fast_1 (__cilkrts_stack_frame *);  */\n-  cilk_enter_fast_fndecl = \n-    install_builtin (\"__cilkrts_enter_frame_fast_1\", fptr_fun,\n-\t\t     BUILT_IN_CILK_ENTER_FRAME_FAST, false);\n-\n-  /* void __cilkrts_pop_frame (__cilkrts_stack_frame *);  */\n-  cilk_pop_fndecl = install_builtin (\"__cilkrts_pop_frame\", fptr_fun,\n-\t\t\t\t     BUILT_IN_CILK_POP_FRAME, false);\n-\n-  /* void __cilkrts_leave_frame (__cilkrts_stack_frame *);  */\n-  cilk_leave_fndecl = install_builtin (\"__cilkrts_leave_frame\", fptr_fun,\n-\t\t\t\t       BUILT_IN_CILK_LEAVE_FRAME, false);\n-\n-  /* void __cilkrts_sync (__cilkrts_stack_frame *);  */\n-  cilk_sync_fndecl = install_builtin (\"__cilkrts_sync\", fptr_fun,\n-\t\t\t\t      BUILT_IN_CILK_SYNC, false);\n-\n-  /* void __cilkrts_detach (__cilkrts_stack_frame *);  */\n-  cilk_detach_fndecl = install_builtin (\"__cilkrts_detach\", fptr_fun,\n-\t\t\t\t\tBUILT_IN_CILK_DETACH, false);\n-\n-  /* __cilkrts_rethrow (struct stack_frame *);  */\n-  cilk_rethrow_fndecl = install_builtin (\"__cilkrts_rethrow\", fptr_fun,\n-\t\t\t\t\t BUILT_IN_CILK_RETHROW, false);\n-  TREE_NOTHROW (cilk_rethrow_fndecl) = 0;\n-\n-  /* __cilkrts_save_fp_ctrl_state (__cilkrts_stack_frame *);  */\n-  cilk_save_fp_fndecl = install_builtin (\"__cilkrts_save_fp_ctrl_state\",\n-\t\t\t\t\t fptr_fun, BUILT_IN_CILK_SAVE_FP,\n-\t\t\t\t\t false);\n-  /* __cilkrts_cilk_for_32 (...);  */\n-  cilk_for_32_fndecl = declare_cilk_for_builtin (\"__cilkrts_cilk_for_32\",\n-\t\t\t\t\t\t unsigned_intSI_type_node,\n-\t\t\t\t\t\t BUILT_IN_CILK_FOR_32);\n-  /* __cilkrts_cilk_for_64 (...);  */\n-  cilk_for_64_fndecl = declare_cilk_for_builtin (\"__cilkrts_cilk_for_64\",\n-\t\t\t\t\t\t unsigned_intDI_type_node,\n-\t\t\t\t\t\t BUILT_IN_CILK_FOR_64);\n-}\n-\n-/* Get the appropriate frame arguments for CALL that is of type CALL_EXPR.  */\n-\n-static tree\n-get_frame_arg (tree call)\n-{\n-  tree arg, argtype;\n-\n-  gcc_assert (call_expr_nargs (call) >= 1);\n-    \n-  arg = CALL_EXPR_ARG (call, 0);\n-  argtype = TREE_TYPE (arg);\n-  gcc_assert (TREE_CODE (argtype) == POINTER_TYPE);\n-\n-  argtype = TREE_TYPE (argtype);\n-  \n-  /* If it is passed in as an address, then just use the value directly \n-     since the function is inlined.  */\n-  if (TREE_CODE (arg) == ADDR_EXPR)\n-    return TREE_OPERAND (arg, 0);\n-  return arg;\n-}\n-\n-/* Expands the __cilkrts_pop_frame function call stored in EXP.  */\n-\n-void\n-expand_builtin_cilk_pop_frame (tree exp)\n-{\n-  tree frame = get_frame_arg (exp);\n-  tree parent = cilk_dot (frame, CILK_TI_FRAME_PARENT, 0);\n-\n-  tree clear_parent = build2 (MODIFY_EXPR, void_type_node, parent,\n-\t\t\t      build_int_cst (TREE_TYPE (parent), 0));\n-  expand_expr (clear_parent, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* During LTO, the is_cilk_function flag gets cleared.\n-     If __cilkrts_pop_frame is called, then this definitely must be a\n-     cilk function.  */\n-  if (cfun)\n-    cfun->is_cilk_function = 1;\n-}\n-\n-/* Expands the cilk_detach function call stored in EXP.  */\n-\n-void\n-expand_builtin_cilk_detach (tree exp)\n-{\n-  rtx_insn *insn;\n-  tree fptr = get_frame_arg (exp);\n-\n-  if (fptr == NULL_TREE)\n-    return;\n-\n-  tree parent = cilk_dot (fptr, CILK_TI_FRAME_PARENT, 0);\n-  tree worker = cilk_dot (fptr, CILK_TI_FRAME_WORKER, 0);\n-  tree tail = cilk_arrow (worker, CILK_TI_WORKER_TAIL, 1);\n-\n-  tree faddr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, fptr);\n-  tree enter_frame = build_call_expr (cilk_enter_fast_fndecl, 1, faddr);\n-  expand_expr (enter_frame, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  tree pedigree = cilk_dot (fptr, CILK_TI_FRAME_PEDIGREE, 0);\n-  tree pedigree_rank = cilk_dot (pedigree, CILK_TI_PEDIGREE_RANK, 0);\n-  tree parent_pedigree = cilk_dot (pedigree, CILK_TI_PEDIGREE_PARENT, 0);\n-  tree pedigree_parent = cilk_arrow (parent, CILK_TI_FRAME_PEDIGREE, 0);\n-  tree pedigree_parent_rank = cilk_dot (pedigree_parent,\n-\t\t\t\t\tCILK_TI_PEDIGREE_RANK, 0);\n-  tree pedigree_parent_parent = cilk_dot (pedigree_parent,\n-\t\t\t\t     CILK_TI_PEDIGREE_PARENT, 0);\n-  tree worker_pedigree = cilk_arrow (worker, CILK_TI_WORKER_PEDIGREE, 1);\n-  tree w_pedigree_rank = cilk_dot (worker_pedigree, CILK_TI_PEDIGREE_RANK, 0);\n-  tree w_pedigree_parent = cilk_dot (worker_pedigree,\n-\t\t\t\t     CILK_TI_PEDIGREE_PARENT, 0);\n-\n-  rtx wreg = expand_expr (worker, NULL_RTX, Pmode, EXPAND_NORMAL);\n-  if (GET_CODE (wreg) != REG)\n-    wreg = copy_to_reg (wreg);\n-  rtx preg = expand_expr (parent, NULL_RTX, Pmode, EXPAND_NORMAL);\n-\n-  /* sf.pedigree.rank = worker->pedigree.rank.  */\n-  tree exp1 = build2 (MODIFY_EXPR, void_type_node, pedigree_rank,\n-\t\t     w_pedigree_rank);\n-  expand_expr (exp1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* sf.pedigree.parent = worker->pedigree.parent.  */\n-  exp1 = build2 (MODIFY_EXPR, void_type_node, parent_pedigree,\n-\t\t w_pedigree_parent);\n-  expand_expr (exp1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* sf.call_parent->pedigree.rank = worker->pedigree.rank.  */\n-  exp1 = build2 (MODIFY_EXPR, void_type_node, pedigree_parent_rank,\n-\t\t w_pedigree_rank);\n-  expand_expr (exp1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* sf.call_parent->pedigree.parent = worker->pedigree.parent.  */\n-  exp1 = build2 (MODIFY_EXPR, void_type_node, pedigree_parent_parent,\n-\t\t w_pedigree_parent);\n-  expand_expr (exp1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* sf->worker.pedigree.rank = 0.  */\n-  exp1 = build2 (MODIFY_EXPR, void_type_node, w_pedigree_rank,\n-\t\t build_zero_cst (uint64_type_node));\n-  expand_expr (exp1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* sf->pedigree.parent = &sf->pedigree.  */\n-  exp1 = build2 (MODIFY_EXPR, void_type_node, w_pedigree_parent,\n-\t\t build1 (ADDR_EXPR,\n-\t\t\t build_pointer_type (cilk_pedigree_type_decl),\n-\t\t\t pedigree));\n-  expand_expr (exp1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  /* TMP <- WORKER.TAIL\n-    *TMP <- PARENT\n-     TMP <- TMP + 1\n-     WORKER.TAIL <- TMP   */\n-\n-  HOST_WIDE_INT worker_tail_offset =\n-    tree_to_shwi (DECL_FIELD_OFFSET (cilk_trees[CILK_TI_WORKER_TAIL])) +\n-    tree_to_shwi (DECL_FIELD_BIT_OFFSET (cilk_trees[CILK_TI_WORKER_TAIL])) /\n-    BITS_PER_UNIT;\n-  rtx tmem0 = gen_rtx_MEM (Pmode,\n-\t\t\t   plus_constant (Pmode, wreg, worker_tail_offset));\n-  set_mem_attributes (tmem0, tail, 0);\n-  MEM_NOTRAP_P (tmem0) = 1;\n-  gcc_assert (MEM_VOLATILE_P (tmem0));\n-  rtx treg = copy_to_mode_reg (Pmode, tmem0);\n-  rtx tmem1 = gen_rtx_MEM (Pmode, treg);\n-  set_mem_attributes (tmem1, TREE_TYPE (TREE_TYPE (tail)), 0);\n-  MEM_NOTRAP_P (tmem1) = 1;\n-  emit_move_insn (tmem1, preg);\n-  emit_move_insn (treg, plus_constant (Pmode, treg, GET_MODE_SIZE (Pmode)));\n-\n-  /* There is a release barrier (st8.rel, membar #StoreStore,\n-     sfence, lwsync, etc.) between the two stores.  On x86\n-     normal volatile stores have proper semantics; the sfence\n-     would only be needed for nontemporal stores (which we\n-     could generate using the storent optab, for no benefit\n-     in this case).\n-\n-     The predicate may return false even for a REG if this is\n-     the limited release operation that only stores 0.  */\n-  enum insn_code icode = direct_optab_handler (sync_lock_release_optab, Pmode); \n-  if (icode != CODE_FOR_nothing\n-      && insn_data[icode].operand[1].predicate (treg, Pmode)\n-      && (insn = GEN_FCN (icode) (tmem0, treg)) != NULL_RTX)\n-    emit_insn (insn);\n-  else\n-    emit_move_insn (tmem0, treg);\n-\n-  /* The memory barrier inserted above should not prevent\n-     the load of flags from being moved before the stores,\n-     but in practice it does because it is implemented with\n-     unspec_volatile.  In-order RISC machines should\n-     explicitly load flags earlier.  */\n-\n-  tree flags = cilk_dot (fptr, CILK_TI_FRAME_FLAGS, 0);\n-  expand_expr (build2 (MODIFY_EXPR, void_type_node, flags,\n-\t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (flags), flags,\n-\t\t\t       build_int_cst (TREE_TYPE (flags),\n-\t\t\t\t\t      CILK_FRAME_DETACHED))),\n-\t       const0_rtx, VOIDmode, EXPAND_NORMAL);\n-}\n-\n-/* Returns a setjmp CALL_EXPR with FRAME->context as its parameter.  */\n-\n-tree\n-cilk_call_setjmp (tree frame)\n-{\n-  tree c = cilk_dot (frame, CILK_TI_FRAME_CONTEXT, false);\n-  c = build1 (ADDR_EXPR, build_pointer_type (ptr_type_node), c);\n-  return build_call_expr (builtin_decl_implicit (BUILT_IN_SETJMP), 1, c);\n-}\n-\n-/* This function will expand the _Cilk_sync keyword.  */\n-\n-static tree\n-expand_cilk_sync (void)\n-{\n-  tree frame = cfun->cilk_frame_decl;\n-\n-  /* Cilk_sync is converted to the following code:\n-\n-     sf.pedigree = sf.worker->pedigree;\n-     if (frame.flags & CILK_FRAME_UNSYNCHED)\n-     {\n-        __cilkrts_save_fp_state (&sf);\n-        if (!builtin_setjmp (sf.ctx) \n-\t    __cilkrts_sync (&sf); \n-\telse \n-\t   if (sf.flags & CILK_FRAME_EXCEPTING) \n-\t     __cilkrts_rethrow (&sf); \n-      }\n-      sf.worker->pedigree.rank = sf.worker->pedigree.rank + 1;  */\n-\n-  tree flags = cilk_dot (frame, CILK_TI_FRAME_FLAGS, false);\n-  \n-  tree unsynched = fold_build2 (BIT_AND_EXPR, TREE_TYPE (flags), flags,\n-\t\t\t\tbuild_int_cst (TREE_TYPE (flags),\n-\t\t\t\t\t       CILK_FRAME_UNSYNCHED));\n-\n-  unsynched = fold_build2 (NE_EXPR, TREE_TYPE (unsynched), unsynched,\n-\t\t\t   build_int_cst (TREE_TYPE (unsynched), 0));\n-\n-  tree frame_addr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, frame);\n-\n-  /* Check if exception (0x10) bit is set in the sf->flags.  */\n-  tree except_flag = fold_build2 (BIT_AND_EXPR, TREE_TYPE (flags), flags,\n-\t\t\t\t  build_int_cst (TREE_TYPE (flags),\n-\t\t\t\t\t\t CILK_FRAME_EXCEPTING));\n-  except_flag = fold_build2 (NE_EXPR, TREE_TYPE (except_flag), except_flag,\n-\t\t\t     build_int_cst (TREE_TYPE (except_flag), 0));\n-\n-  /* If the exception flag is set then call the __cilkrts_rethrow (&sf).  */\n-  tree except_cond = fold_build3 (COND_EXPR, void_type_node, except_flag,\n-\t\t\t\t  build_call_expr (cilk_rethrow_fndecl, 1,\n-\t\t\t\t\t\t   frame_addr),\n-\t\t\t\t  build_empty_stmt (EXPR_LOCATION (unsynched)));\n-  \n-  tree sync_expr = build_call_expr (cilk_sync_fndecl, 1, frame_addr);\n-  tree setjmp_expr = cilk_call_setjmp (frame);\n-  setjmp_expr = fold_build2 (EQ_EXPR, TREE_TYPE (setjmp_expr), setjmp_expr,\n-\t\t\t     build_int_cst (TREE_TYPE (setjmp_expr), 0));\n-  \n-  setjmp_expr = fold_build3 (COND_EXPR, void_type_node, setjmp_expr,\n-\t\t\t     sync_expr, except_cond);\n-  tree sync_list = alloc_stmt_list ();\n-  append_to_statement_list (build_call_expr (cilk_save_fp_fndecl, 1,\n-\t\t\t\t\t     frame_addr), &sync_list);\n-  append_to_statement_list (setjmp_expr, &sync_list);\n-  tree sync = fold_build3 (COND_EXPR, void_type_node, unsynched, sync_list,\n-\t\t\t   build_empty_stmt (EXPR_LOCATION (unsynched)));\n-  tree parent_pedigree = cilk_dot (frame, CILK_TI_FRAME_PEDIGREE, false);\n-  tree worker = cilk_dot (frame, CILK_TI_FRAME_WORKER, false);\n-  tree worker_pedigree = cilk_arrow (worker, CILK_TI_WORKER_PEDIGREE, false);\n-  tree assign_pedigree = fold_build2 (MODIFY_EXPR, void_type_node,\n-\t\t\t\t      parent_pedigree, worker_pedigree);\n-  tree w_ped_rank = cilk_dot (unshare_expr (worker_pedigree), \n-\t\t\t      CILK_TI_PEDIGREE_RANK, false);\n-  tree incr_ped_rank = fold_build2 (PLUS_EXPR, TREE_TYPE (w_ped_rank),\n-\t\t\t\t    w_ped_rank,\n-\t\t\t\t    build_one_cst (TREE_TYPE (w_ped_rank)));\n-  incr_ped_rank = fold_build2 (MODIFY_EXPR, void_type_node, w_ped_rank,\n-\t\t\t       incr_ped_rank);\n-  tree ret_sync_exp = alloc_stmt_list ();\n-  append_to_statement_list (assign_pedigree, &ret_sync_exp);\n-  append_to_statement_list (sync, &ret_sync_exp);\n-  append_to_statement_list (incr_ped_rank, &ret_sync_exp);\n-  return ret_sync_exp;\n-}\n-\n-/* Gimplifies the cilk_sync expression passed in *EXPR_P.  Returns GS_ALL_DONE \n-   when finished.  */\n-\n-void\n-gimplify_cilk_sync (tree *expr_p, gimple_seq *pre_p)\n-{\n-  tree sync_expr = expand_cilk_sync ();\n-  *expr_p = NULL_TREE;\n-  gimplify_and_add (sync_expr, pre_p);\n-}"}, {"sha": "27c2e0a63e9af89247ce8c8183ec4e3a55cdaedd", "filename": "gcc/cilk.h", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,109 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   This file contains Cilk Support files.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n-                  Intel Corporation\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_CILK_H\n-#define GCC_CILK_H\n-\n-/* Frame status bits known to compiler.  */\n-#define CILK_FRAME_UNSYNCHED 0x02\n-#define CILK_FRAME_DETACHED  0x04\n-#define CILK_FRAME_EXCEPTING 0x10\n-#define CILK_FRAME_VERSION   (1 << 24)\n-\n-enum cilk_tree_index  {\n-/* All the built-in functions for Cilk keywords.  */\n-  CILK_TI_F_WORKER = 0,               /* __cilkrts_get_worker ().  */\n-  CILK_TI_F_SYNC,                     /* __cilkrts_sync ().  */\n-  CILK_TI_F_DETACH,                   /* __cilkrts_detach (...).   */\n-  CILK_TI_F_ENTER,                    /* __cilkrts_enter_frame (...).  */\n-  CILK_TI_F_ENTER_FAST,               /* __cilkrts_enter_frame_fast (.).  */\n-  CILK_TI_F_LEAVE,                    /* __cilkrts_leave_frame (...).  */\n-  CILK_TI_F_POP,                      /* __cilkrts_pop_frame (...).  */\n-  CILK_TI_F_RETHROW,                  /* __cilkrts_rethrow (...).  */\n-  CILK_TI_F_SAVE_FP,                  /* __cilkrts_save_fp_ctrl_state (...).  */\n-  CILK_TI_F_LOOP_32,                  /* __cilkrts_cilk_for_32 (...).  */\n-  CILK_TI_F_LOOP_64,                  /* __cilkrts_cilk_for_64 (...).  */\n-\n-  /* __cilkrts_stack_frame struct fields.  */\n-  CILK_TI_FRAME_FLAGS,                /* stack_frame->flags.  */\n-  CILK_TI_FRAME_PARENT,               /* stack_frame->parent.  */\n-  CILK_TI_FRAME_WORKER,               /* stack_frame->worker.  */\n-  CILK_TI_FRAME_EXCEPTION,            /* stack_frame->except_data.  */\n-  CILK_TI_FRAME_CONTEXT,              /* stack_frame->context[4].  */\n-  CILK_TI_FRAME_PEDIGREE,             /* stack_frame->pedigree.  */\n-\n-  /* __cilkrts_worker struct fields.  */\n-  CILK_TI_WORKER_CUR,                 /* worker->current_stack_frame.  */\n-  CILK_TI_WORKER_TAIL,                /* worker->tail.  */\n-  CILK_TI_WORKER_PEDIGREE,            /* worker->pedigree.  */\n-\n-  /* __cilkrts_pedigree struct fields.  */\n-  CILK_TI_PEDIGREE_RANK,              /* pedigree->rank.  */\n-  CILK_TI_PEDIGREE_PARENT,            /* pedigree->parent.  */\n-  \n-  /* Types.  */\n-  CILK_TI_FRAME_TYPE,                 /* struct __cilkrts_stack_frame.  */\n-  CILK_TI_FRAME_PTR,                  /* __cilkrts_stack_frame *.  */\n-  CILK_TI_WORKER_TYPE,                /* struct __cilkrts_worker.  */\n-  CILK_TI_PEDIGREE_TYPE,              /* struct __cilkrts_pedigree.  */\n-  CILK_TI_MAX\n-};\n-\n-extern GTY (()) tree cilk_trees[CILK_TI_MAX];\n-\n-#define cilk_worker_fndecl            cilk_trees[CILK_TI_F_WORKER]\n-#define cilk_sync_fndecl              cilk_trees[CILK_TI_F_SYNC]\n-#define cilk_synched_fndecl           cilk_trees[CILK_TI_F_SYNCED]\n-#define cilk_detach_fndecl            cilk_trees[CILK_TI_F_DETACH]\n-#define cilk_enter_fndecl             cilk_trees[CILK_TI_F_ENTER]\n-#define cilk_enter_fast_fndecl        cilk_trees[CILK_TI_F_ENTER_FAST]\n-#define cilk_leave_fndecl             cilk_trees[CILK_TI_F_LEAVE]\n-#define cilk_rethrow_fndecl           cilk_trees[CILK_TI_F_RETHROW]\n-#define cilk_pop_fndecl               cilk_trees[CILK_TI_F_POP]\n-#define cilk_save_fp_fndecl           cilk_trees[CILK_TI_F_SAVE_FP]\n-#define cilk_for_32_fndecl            cilk_trees[CILK_TI_F_LOOP_32]\n-#define cilk_for_64_fndecl            cilk_trees[CILK_TI_F_LOOP_64]\n-\n-#define cilk_worker_type_fndecl       cilk_trees[CILK_TI_WORKER_TYPE]\n-#define cilk_frame_type_decl          cilk_trees[CILK_TI_FRAME_TYPE]\n-#define cilk_frame_ptr_type_decl      cilk_trees[CILK_TI_FRAME_PTR]\n-#define cilk_pedigree_type_decl       cilk_trees[CILK_TI_PEDIGREE_TYPE]\n-\n-extern void expand_builtin_cilk_detach (tree);\n-extern void expand_builtin_cilk_pop_frame (tree);\n-extern tree cilk_arrow (tree, int, bool);\n-extern tree cilk_dot (tree, int, bool);\n-extern void cilk_init_builtins (void);\n-extern void gimplify_cilk_sync (tree *, gimple_seq *);\n-extern tree cilk_call_setjmp (tree);\n-\n-/* Returns true if Cilk Plus is enabled and if F->cilk_frame_decl is not\n-   NULL_TREE.  */\n-\n-inline bool\n-fn_contains_cilk_spawn_p (function *f)\n-{\n-  return (flag_cilkplus \n-\t  && (f->calls_cilk_spawn || f->cilk_frame_decl != NULL_TREE));\n-}\n-\n-#endif"}, {"sha": "450ed173092f4b058cbe33452b30c05b678493a7", "filename": "gcc/cilkplus.def", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilkplus.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcilkplus.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilkplus.def?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,59 +0,0 @@\n-/* This file contains the definitions and documentation for the\n-   CilkPlus builtins used in the GNU compiler.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Before including this file, you should define a macro:\n-\n-     DEF_CILKPLUS_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n-\n-   See builtins.def for details.  */\n-\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ADD,\n-\t\t      \"__sec_reduce_add\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MUL,\n-\t\t      \"__sec_reduce_mul\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO,\n-\t\t      \"__sec_reduce_all_zero\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO,\n-\t\t      \"__sec_reduce_any_zero\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MAX,\n-\t\t      \"__sec_reduce_max\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MIN,\n-\t\t      \"__sec_reduce_min\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND,\n-\t\t      \"__sec_reduce_min_ind\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND,\n-\t\t      \"__sec_reduce_max_ind\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO,\n-\t\t      \"__sec_reduce_any_nonzero\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO,\n-\t\t      \"__sec_reduce_all_nonzero\", BT_FN_INT_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE,\n-\t\t      \"__sec_reduce\", BT_FN_INT_PTR_PTR_PTR, ATTR_NULL)\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING,\n-\t\t      \"__sec_reduce_mutating\", BT_FN_INT_PTR_PTR_PTR, ATTR_NULL)\n-// FIXME: This probably needs to be rewritten as a keyword.\n-DEF_CILKPLUS_BUILTIN (BUILT_IN_CILKPLUS_SEC_IMPLICIT_INDEX,\n-\t\t      \"__sec_implicit_index\", BT_FN_INT_INT, ATTR_NULL)\n-\n-/*\n-Local variables:\n-mode:c\n-End:\n-*/"}, {"sha": "d7dc2cded576cb4e05bd3e0d3ab1d50c8e022f3e", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -185,7 +185,6 @@ extern GTY(()) int darwin_ms_struct;\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n     %{fopenacc|fopenmp|%:gt(%{ftree-parallelize-loops=*:%*} 1): \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n-    %{fcilkplus:%:include(libcilkrts.spec)%(link_cilkrts)}\\\n     %{fgnu-tm: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libitm.a%s; : -litm } } \\\n     %{!nostdlib:%{!nodefaultlibs:\\"}, {"sha": "a93a901295806bd6687dec1a3d1ae57627263d72", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,52 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+            Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* Make-lang.in (cp/cp-array-notation.o, cp/cp-cilkplus.o): Delete.\n+\t* call.c (convert_for_arg_passing, build_cxx_call): Remove cilkplus.\n+\t* constexpr.c (potential_constant_expression_1): Ditto.\n+\t* cp-array-notation.c: Delete.\n+\t* cp-cilkplus.c: Ditto.\n+\t* cp-cilkplus.h: Ditto.\n+\t* cp-gimplify.c (cp_gimplify_expr, cp_fold_r, cp_genericize): Remove\n+\tcilkplus condition.\n+\t* cp-objcp-common.c (ARRAY_NOTATION_REF): Delete.\n+\t* cp-tree.h (cilkplus_an_triplet_types_ok_p): Delete.\n+\t* decl.c (grokfndecl, finish_function): Remove cilkplus condition.\n+\t* error.c (dump_decl, dump_expr): Remove ARRAY_NOTATION_REF condition.\n+\t* lambda.c (cp-cilkplus.h): Remove.\n+\t* parser.c (cp_parser_cilk_simd, cp_parser_cilk_for,\n+\tcp_parser_cilk_simd_vectorlength): Delete.\n+\t(cp_debug_parser, cp_parser_ctor_initializer_opt_and_function_body,\n+\tcp_parser_postfix_expression,\n+\tcp_parser_postfix_open_square_expression,\n+\tcp_parser_statement, cp_parser_jump_statement,\n+\tcp_parser_direct_declarator,\n+\tcp_parser_late_return_type_opt, cp_parser_gnu_attribute_list,\n+\tcp_parser_omp_clause_name, cp_parser_omp_clause_aligned,\n+\tcp_parser_omp_clause_linear, cp_parser_omp_all_clauses,\n+\tcp_parser_omp_flush,\n+\tcp_parser_omp_for_cond, cp_parser_omp_for_incr,\n+\tcp_parser_omp_for_loop_init,\n+\tcp_parser_omp_for_loop,\n+\tcp_parser_omp_declare_simd): Remove cilkplus support.\n+\t(CILK_SIMD_FN_CLAUSE_MASK, cp_parser_late_parsing_cilk_simd_fn_info,\n+\tcp_parser_cilk_grainsize): Remove.\n+\t(cp_parser_pragma, c_parse_file): Remove cilkplus support.\n+\t(cp_parser_cilk_simd_vectorlength, cp_parser_cilk_simd_linear,\n+\tcp_parser_cilk_simd_clause_name, cp_parser_cilk_simd_all_clauses,\n+\tcp_parser_cilk_simd, cp_parser_cilk_for): Remove.\n+\t* parser.h (IN_CILK_SIMD_FOR, IN_CILK_SPAWN): Remove.\n+\t* pt.c (tsubst_attribute, tsubst_expr, tsubst_copy_and_build): Remove\n+\tcilkplus support.\n+\t* semantics.c (finish_goto_stmt, begin_while_stmt, finish_do_body,\n+\tfinish_init_stmt, finish_switch_cond, simplify_aggr_init_expr,\n+\tfinish_omp_clauses, finish_omp_clauses, finish_omp_for): Remove\n+\tcilkplus\n+\tsupport.\n+\t* tree.c (lvalue_kind): Remove ARRAY_NOTATION_REF conditon.\n+\t* typeck.c (cp_build_array_ref, cp_build_compound_expr,\n+\tcheck_return_expr): Remove cilkplus support.\n+\n 2017-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cp-gimplify.c (genericize_switch_stmt): Build SWITCH_EXPR using"}, {"sha": "7871755b06d2047dafc484c53a844d88779e043a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -73,7 +73,7 @@ CXX_C_OBJS = attribs.o incpath.o \\\n # Language-specific object files for C++ and Objective C++.\n CXX_AND_OBJCXX_OBJS = \\\n \tcp/call.o cp/class.o cp/constexpr.o cp/constraint.o \\\n-\tcp/cp-array-notation.o cp/cp-cilkplus.o cp/cp-gimplify.o \\\n+\tcp/cp-gimplify.o \\\n \tcp/cp-objcp-common.o cp/cp-ubsan.o \\\n \tcp/cvt.o cp/cxx-pretty-print.o \\\n \tcp/decl.o cp/decl2.o cp/dump.o \\"}, {"sha": "45c811e828e0f611947da9f37bb1cde818c3690f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -7422,9 +7422,6 @@ convert_for_arg_passing (tree type, tree val, tsubst_flags_t complain)\n int\n magic_varargs_p (tree fn)\n {\n-  if (flag_cilkplus && is_cilkplus_reduce_builtin (fn) != BUILT_IN_NONE)\n-    return 2;\n-\n   if (DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL)\n     switch (DECL_FUNCTION_CODE (fn))\n       {\n@@ -8650,38 +8647,6 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n \tmaybe_warn_class_memaccess (loc, fndecl, argarray);\n     }\n \n-    /* If it is a built-in array notation function, then the return type of\n-     the function is the element type of the array passed in as array \n-     notation (i.e. the first parameter of the function).  */\n-  if (flag_cilkplus && TREE_CODE (fn) == CALL_EXPR) \n-    {\n-      enum built_in_function bif = \n-\tis_cilkplus_reduce_builtin (CALL_EXPR_FN (fn));\n-      if (bif == BUILT_IN_CILKPLUS_SEC_REDUCE_ADD\n-\t  || bif == BUILT_IN_CILKPLUS_SEC_REDUCE_MUL\n-\t  || bif == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX\n-\t  || bif == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN\n-\t  || bif == BUILT_IN_CILKPLUS_SEC_REDUCE\n-\t  || bif == BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-\t{ \n-\t  if (call_expr_nargs (fn) == 0)\n-\t    {\n-\t      error_at (EXPR_LOCATION (fn), \"Invalid builtin arguments\");\n-\t      return error_mark_node;\n-\t    }\n-\t  /* for bif == BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO or\n-\t     BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO or\n-\t     BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO or \n-\t     BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO or\n-\t     BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND or\n-             BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-\t     The pre-defined return-type is the correct one.  */\n-\t  tree array_ntn = CALL_EXPR_ARG (fn, 0); \n-\t  TREE_TYPE (fn) = TREE_TYPE (array_ntn); \n-\t  return fn;\n-\t}\n-    }\n-\n   if (VOID_TYPE_P (TREE_TYPE (fn)))\n     return fn;\n "}, {"sha": "f0370cc2afff07ca6fa9a43e02b23670330b7d00", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -5563,8 +5563,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n     case OACC_ENTER_DATA:\n     case OACC_EXIT_DATA:\n     case OACC_UPDATE:\n-    case CILK_SIMD:\n-    case CILK_FOR:\n       /* GCC internal stuff.  */\n     case VA_ARG_EXPR:\n     case OBJ_TYPE_REF:\n@@ -5849,11 +5847,6 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t  return false;\n       return true;\n \n-    case CILK_SYNC_STMT:\n-    case CILK_SPAWN_STMT:\n-    case ARRAY_NOTATION_REF:\n-      return false;\n-\n     case FMA_EXPR:\n     case VEC_PERM_EXPR:\n      for (i = 0; i < 3; ++i)"}, {"sha": "31be7d685ba76c78c7de650ee8add5f319e4d925", "filename": "gcc/cp/cp-array-notation.c", "status": "removed", "additions": 0, "deletions": 1470, "changes": 1470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcp%2Fcp-array-notation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcp%2Fcp-array-notation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-array-notation.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,1470 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   It contains routines to handle Array Notation expression\n-   handling routines in the C++ Compiler.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n-                  Intel Corporation\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* The Array Notation Transformation Technique:\n-\n-   An array notation expression has 4 major components:\n-   1. The array name\n-   2. Start Index\n-   3. Number of elements we need to access (we call it length)\n-   4. Stride\n-\n-   So, if we have something like A[0:5:2], we are accessing A[0], A[2], A[4],\n-   A[6] and A[8]. The user is responsible to make sure the access length does\n-   not step outside the array's size.\n-   \n-   In this section, I highlight the overall method on how array notations are\n-   broken up into C/C++ code.  Almost all the functions follows this step:\n-\n-   Let's say the user has used the array notation in a statement like this:\n-\n-   A[St1:Ln:Str1] = B[St2:Ln:Str2] + <NON ARRAY_NOT STMT>\n-\n-   where St{1,2} = Starting index, Ln = Number of elements we need to access,\n-   and Str{1,2} = the stride.\n-   Note: The length of both the array notation expressions must be the same.\n-   \n-   The above expression is broken into the following:\n-\n-   for (Tmp_Var = 0; Tmp_Var < Ln; Tmp_Var++)\n-     A[St1 + Tmp_Var * Str1] = B[St1 + Tmp_Var * Str2] + <NON_ARRAY_NOT_STMT>;\n-*/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"cp-tree.h\"\n-#include \"tree-iterator.h\"\n-\n-/* Creates a FOR_STMT with INIT, COND, INCR and BODY as the initializer,\n-   condition, increment expression and the loop-body, respectively.  */\n-\n-static void\n-create_an_loop (tree init, tree cond, tree incr, tree body)\n-{\n-  tree for_stmt;\n-\n-  finish_expr_stmt (init);\n-  for_stmt = begin_for_stmt (NULL_TREE, NULL_TREE);\n-  finish_init_stmt (for_stmt);\n-  finish_for_cond (cond, for_stmt, false);\n-  finish_for_expr (incr, for_stmt);\n-  finish_expr_stmt (body);\n-  finish_for_stmt (for_stmt);\n-}\n-\n-/* If *VALUE is not a constant integer, then this function replaces it with\n-   a variable to make it loop invariant for array notations.  */\n-\n-static inline void\n-make_triplet_val_inv (tree *value)\n-{\n-  if (TREE_CODE (*value) != INTEGER_CST\n-      && TREE_CODE (*value) != PARM_DECL\n-      && !VAR_P (*value))\n-    *value = get_temp_regvar (ptrdiff_type_node, *value);\n-}\n-\n-/* Returns a vector of size RANK that contains an ARRAY_REF.  This vector is\n-   created using array notation-triplet information stored in AN_INFO. The\n-   induction var is taken from AN_LOOP_INFO.\n-\n-   For example: For an array notation A[5:10:2], the vector start will be\n-   of size 1 holding '5', stride of same size as start but holding the value of\n-   as 2, and is_vector as true.   Let's assume VAR is 'x'\n-   This function returns a vector of size 1 with the following data:\n-   A[5 + (x * 2)] .\n-*/\n-\n-static vec<tree, va_gc> *\n-create_array_refs (location_t loc, vec<vec<an_parts> > an_info,\n-\t\t   vec<an_loop_parts> an_loop_info, size_t size,  size_t rank)\n-{\n-  tree ind_mult, ind_incr;\n-  vec<tree, va_gc> *array_operand = NULL;\n-\n-  for (size_t ii = 0; ii < size; ii++)\n-    if (an_info[ii][0].is_vector)\n-      {\n-\ttree array_opr = an_info[ii][rank - 1].value;\n-\tfor (int s_jj = rank -1; s_jj >= 0; s_jj--)\n-\t  {\n-\t    tree start = cp_fold_convert (ptrdiff_type_node, \n-\t\t\t\t\t  an_info[ii][s_jj].start);\n-\t    tree stride = cp_fold_convert (ptrdiff_type_node, \n-\t\t\t\t\t   an_info[ii][s_jj].stride);\n-\t    tree var = cp_fold_convert (ptrdiff_type_node, \n-\t\t\t\t\tan_loop_info[s_jj].var);\n-\n-\t    ind_mult = build2 (MULT_EXPR, TREE_TYPE (var), var, stride);\n-\t    ind_incr = build2 (PLUS_EXPR, TREE_TYPE (var), start, ind_mult);\n-\t    /* Array [ start_index + (induction_var * stride)]  */\n-\t    array_opr = grok_array_decl\t(loc, array_opr, ind_incr, false);\n-\t  }\n-\tvec_safe_push (array_operand, array_opr);\n-      }\n-    else\n-      vec_safe_push (array_operand, integer_one_node);\n-  return array_operand;\n-}\n-\n-/* Populates the INCR and CMP fields in *NODE with the increment\n-   (of type POSTINCREMENT) and comparison (of TYPE LT_EXPR) expressions, using \n-   data from AN_INFO.  */\n-\n-void\n-create_cmp_incr (location_t loc, vec <an_loop_parts> *node, size_t rank, \n-\t\t vec<vec<an_parts> > an_info, tsubst_flags_t complain)\n-{\n-  for (size_t ii = 0; ii < rank; ii++)\n-    {\n-      (*node)[ii].incr = build_x_unary_op (loc, POSTINCREMENT_EXPR, \n-\t\t\t\t\t   (*node)[ii].var, complain);\n-      (*node)[ii].cmp = build_x_binary_op (loc, LT_EXPR, (*node)[ii].var,\n-\t\t\t\t\t   TREE_CODE ((*node)[ii].var),\n-\t\t\t\t\t   an_info[0][ii].length,\n-\t\t\t\t\t   TREE_CODE (an_info[0][ii].length),\n-\t\t\t\t\t   NULL, complain);\n-    }\n-}\n-\n-/* Replaces all the scalar expressions in *NODE.  Returns a STATEMENT LIST that\n-   holds the NODE along with the variables that hold the results of the\n-   invariant expressions.  */\n-\n-static tree\n-replace_invariant_exprs (tree *node)\n-{\n-  size_t ix = 0;\n-  tree node_list = NULL_TREE;\n-  tree t = NULL_TREE, new_var = NULL_TREE;\n-  struct inv_list data;\n-\n-  data.list_values = NULL;\n-  data.replacement = NULL;\n-  data.additional_tcodes = NULL;\n-  cp_walk_tree (node, find_inv_trees, (void *) &data, NULL);\n-\n-  if (vec_safe_length (data.list_values))\n-    {\n-      node_list = push_stmt_list ();\n-      for (ix = 0; vec_safe_iterate (data.list_values, ix, &t); ix++)\n-\t{ \n-\t  /* Sometimes, when comma_expr has a function call in it, it will\n-\t     typecast it to void.  Find_inv_trees finds those nodes and so\n-\t     if it void type, then don't bother creating a new var to hold \n-\t     the return value.   */\n-\t  if (VOID_TYPE_P (TREE_TYPE (t)))\n-\t    {\n-\t      finish_expr_stmt (t);\n-\t      new_var = void_node;\n-\t    }\n-\t  else \n-\t    new_var = get_temp_regvar (TREE_TYPE (t), t); \n-\t  vec_safe_push (data.replacement, new_var);\n-\t}\n-      cp_walk_tree (node, replace_inv_trees, (void *) &data, NULL);\n-      node_list = pop_stmt_list (node_list);\n-    }\n-  return node_list;\n-}\n-\n-/* Replace array notation's built-in function passed in AN_BUILTIN_FN with\n-   the appropriate loop and computation (all stored in variable LOOP of type\n-   tree node).  The output of the function is always a scalar and that\n-   result is returned in *NEW_VAR.  *NEW_VAR is NULL_TREE if the function is\n-   __sec_reduce_mutating.  */\n-\n-static tree\n-expand_sec_reduce_builtin (tree an_builtin_fn, tree *new_var)\n-{\n-  tree new_var_type = NULL_TREE, func_parm, new_yes_expr, new_no_expr;\n-  tree array_ind_value = NULL_TREE, new_no_ind, new_yes_ind, new_no_list;\n-  tree new_yes_list, new_cond_expr, new_expr = NULL_TREE; \n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0, rank = 0, ii = 0;\n-  tree  body, an_init, loop_with_init = alloc_stmt_list ();\n-  tree array_op0, comp_node = NULL_TREE;\n-  tree call_fn = NULL_TREE, identity_value = NULL_TREE;\n-  tree init = NULL_TREE, cond_init = NULL_TREE;\n-  enum tree_code code = NOP_EXPR;\n-  location_t location = UNKNOWN_LOCATION;\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n-  enum built_in_function an_type =\n-    is_cilkplus_reduce_builtin (CALL_EXPR_FN (an_builtin_fn));\n-  vec <tree, va_gc> *func_args;\n-  \n-  if (an_type == BUILT_IN_NONE)\n-    return NULL_TREE;\n-\n-  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE\n-      && an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    func_parm = CALL_EXPR_ARG (an_builtin_fn, 0);\n-  else\n-    {\n-      call_fn = CALL_EXPR_ARG (an_builtin_fn, 2);\n-\n-      /* We need to do this because we are \"faking\" the builtin function types,\n-\t so the compiler does a bunch of typecasts and this will get rid of\n-\t all that!  */\n-      STRIP_NOPS (call_fn);\n-      if (TREE_CODE (call_fn) != OVERLOAD\n-\t  && TREE_CODE (call_fn) != FUNCTION_DECL)\n-\tcall_fn = TREE_OPERAND (call_fn, 0);\n-      identity_value = CALL_EXPR_ARG (an_builtin_fn, 0);\n-      func_parm = CALL_EXPR_ARG (an_builtin_fn, 1);\n-      STRIP_NOPS (identity_value);\n-    }\n-  STRIP_NOPS (func_parm);\n-  \n-  location = EXPR_LOCATION (an_builtin_fn);\n-  \n-  /* Note about using find_rank (): If find_rank returns false, then it must\n-     have already reported an error, thus we just return an error_mark_node\n-     without any doing any error emission.  */  \n-  if (!find_rank (location, an_builtin_fn, an_builtin_fn, true, &rank))\n-      return error_mark_node;\n-  if (rank == 0)\n-    {\n-      error_at (location, \"Invalid builtin arguments\");\n-      return error_mark_node;\n-    }\n-  else if (rank > 1 \n-\t   && (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-\t       || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND))\n-    { \n-      error_at (location, \"__sec_reduce_min_ind or __sec_reduce_max_ind cannot \"\n-\t\t\"have arrays with dimension greater than 1\");\n-      return error_mark_node;\n-    }\n-  \n-  extract_array_notation_exprs (func_parm, true, &array_list);\n-  list_size = vec_safe_length (array_list);\n-  switch (an_type)\n-    {\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      new_var_type = TREE_TYPE ((*array_list)[0]);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      new_var_type = boolean_type_node;\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      new_var_type = size_type_node;\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-      if (call_fn && identity_value)\n-\tnew_var_type = TREE_TYPE ((*array_list)[0]);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-      new_var_type = NULL_TREE;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-    \n-  if (new_var_type && TREE_CODE (new_var_type) == ARRAY_TYPE)\n-    new_var_type = TREE_TYPE (new_var_type);\n-  an_loop_info.safe_grow_cleared (rank);\n-\n-  an_init = push_stmt_list ();\n-\n-  /* Assign the array notation components to variable so that they can satisfy\n-     the exec-once rule.  */\n-  for (ii = 0; ii < list_size; ii++)\n-    if (TREE_CODE ((*array_list)[ii]) == ARRAY_NOTATION_REF)\n-      {\n-\ttree anode = (*array_list)[ii];\n-\tmake_triplet_val_inv (&ARRAY_NOTATION_START (anode));\n-\tmake_triplet_val_inv (&ARRAY_NOTATION_LENGTH (anode));\n-\tmake_triplet_val_inv (&ARRAY_NOTATION_STRIDE (anode));\n-      }\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree typ = ptrdiff_type_node;\n-\n-      /* In this place, we are using get_temp_regvar instead of \n-\t create_temporary_var if an_type is SEC_REDUCE_MAX/MIN_IND because\n-\t the array_ind_value depends on this value being initalized to 0.  */\n-      if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-\t  || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND) \n-\tan_loop_info[ii].var = get_temp_regvar (typ, build_zero_cst (typ));\n-      else\n-\t{\n-\t  an_loop_info[ii].var = create_temporary_var (typ);\n-\t  add_decl_expr (an_loop_info[ii].var);\n-\t}\n-      an_loop_info[ii].ind_init = \n-\tbuild_x_modify_expr (location, an_loop_info[ii].var, INIT_EXPR,\n-\t\t\t     build_zero_cst (typ), tf_warning_or_error);\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t      list_size, rank);\n-  replace_array_notations (&func_parm, true, array_list, array_operand);\n-  \n-  if (!TREE_TYPE (func_parm))      \n-    TREE_TYPE (func_parm) = TREE_TYPE ((*array_list)[0]);\n-  \n-  create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n-  if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND\n-      || an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND) \n-    array_ind_value = get_temp_regvar (TREE_TYPE (func_parm), func_parm);\n-\n-  array_op0 = (*array_operand)[0];\n-  if (INDIRECT_REF_P (array_op0))\n-    array_op0 = TREE_OPERAND (array_op0, 0);\n-  switch (an_type)\n-    {\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-      code = PLUS_EXPR;\n-      init = build_zero_cst (new_var_type);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:\n-      code = MULT_EXPR;\n-      init = build_one_cst (new_var_type);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      code = ((an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO) ? EQ_EXPR\n-\t: NE_EXPR);\n-      init = build_zero_cst (new_var_type);\n-      cond_init = build_one_cst (new_var_type);\n-      comp_node = build_zero_cst (TREE_TYPE (func_parm));\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-      code = ((an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO) ? NE_EXPR\n-\t: EQ_EXPR);\n-      init = build_one_cst (new_var_type);\n-      cond_init = build_zero_cst (new_var_type);\n-      comp_node = build_zero_cst (TREE_TYPE (func_parm));\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-      code = MAX_EXPR;\n-      init = (TYPE_MIN_VALUE (new_var_type) ? TYPE_MIN_VALUE (new_var_type)\n-\t: func_parm);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      code = MIN_EXPR;\n-      init = (TYPE_MAX_VALUE (new_var_type) ? TYPE_MAX_VALUE (new_var_type)\n-\t: func_parm);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-      code = (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND ? LE_EXPR\n-\t: GE_EXPR);\n-      init = an_loop_info[0].var;\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-      init = identity_value;\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-      init = NULL_TREE;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  if (an_type != BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING)\n-    *new_var = get_temp_regvar (new_var_type, init);\n-  else\n-    *new_var = NULL_TREE;\n-\n-  switch (an_type)\n-    {\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ADD:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUL:      \n-      new_expr = build_x_modify_expr (location, *new_var, code, func_parm,\n-\t\t\t\t      tf_warning_or_error);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ALL_NONZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_ZERO:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_ANY_NONZERO:\n-      /* In all these cases, assume the false case is true and as soon as\n-\t we find a true case,  set the true flag on and latch it in.  */\n-      new_yes_expr = build_x_modify_expr (location, *new_var, NOP_EXPR,\n-\t\t\t\t\t  cond_init, tf_warning_or_error);\n-      new_no_expr = build_x_modify_expr (location, *new_var, NOP_EXPR,\n-\t\t\t\t\t *new_var, tf_warning_or_error);\n-      new_cond_expr = build_x_binary_op\n-\t(location, code, func_parm, TREE_CODE (func_parm), comp_node,\n-\t TREE_CODE (comp_node), NULL, tf_warning_or_error);\n-      new_expr = build_x_conditional_expr (location, new_cond_expr,\n-\t\t\t\t\t   new_yes_expr, new_no_expr,\n-\t\t\t\t\t   tf_warning_or_error);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN:\n-      new_cond_expr = build_x_binary_op\n-\t(location, code, *new_var, TREE_CODE (*new_var), func_parm,\n-\t TREE_CODE (func_parm), NULL, tf_warning_or_error);\n-      new_expr = build_x_modify_expr (location, *new_var, NOP_EXPR, func_parm,\n-\t\t\t\t      tf_warning_or_error);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MAX_IND:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MIN_IND:\n-      new_yes_expr = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n-\t\t\t\t\t  func_parm, tf_warning_or_error);\n-      new_no_expr = build_x_modify_expr (location, array_ind_value, NOP_EXPR,\n-\t\t\t\t\t array_ind_value, tf_warning_or_error);\n-      if (list_size > 1)\n-\tnew_yes_ind = build_x_modify_expr (location, *new_var, NOP_EXPR,\n-\t\t\t\t\t   an_loop_info[0].var,\n-\t\t\t\t\t   tf_warning_or_error);\n-      else\n-\tnew_yes_ind = build_x_modify_expr (location, *new_var, NOP_EXPR,\n-\t\t\t\t\t   TREE_OPERAND (array_op0, 1),\n-\t\t\t\t\t   tf_warning_or_error);\n-      new_no_ind = build_x_modify_expr (location, *new_var, NOP_EXPR, *new_var,\n-\t\t\t\t\ttf_warning_or_error);\n-      new_yes_list = alloc_stmt_list ();\n-      append_to_statement_list (new_yes_ind, &new_yes_list);\n-      append_to_statement_list (new_yes_expr, &new_yes_list);\n-\n-      new_no_list = alloc_stmt_list ();\n-      append_to_statement_list (new_no_ind, &new_no_list);\n-      append_to_statement_list (new_no_expr, &new_no_list);\n-\n-      new_cond_expr = build_x_binary_op (location, code, array_ind_value,\n-\t\t\t\t\t TREE_CODE (array_ind_value), func_parm,\n-\t\t\t\t\t TREE_CODE (func_parm), NULL,\n-\t\t\t\t\t tf_warning_or_error);\n-      new_expr = build_x_conditional_expr (location, new_cond_expr,\n-\t\t\t\t\t   new_yes_list, new_no_list,\n-\t\t\t\t\t   tf_warning_or_error);\n-      break;\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE:\n-    case BUILT_IN_CILKPLUS_SEC_REDUCE_MUTATING:\n-      func_args = make_tree_vector ();\n-      if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE)\n-\tvec_safe_push (func_args, *new_var);\n-      else\n-\tvec_safe_push (func_args, identity_value);\n-      vec_safe_push (func_args, func_parm);\n-\n-      new_expr = finish_call_expr (call_fn, &func_args, false, true,\n-\t\t\t\t   tf_warning_or_error);\n-      if (an_type == BUILT_IN_CILKPLUS_SEC_REDUCE)\n-\tnew_expr = build_x_modify_expr (location, *new_var, NOP_EXPR, new_expr,\n-\t\t\t\t\ttf_warning_or_error);\n-      release_tree_vector (func_args);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-  an_init = pop_stmt_list (an_init);\n-  append_to_statement_list (an_init, &loop_with_init);\n-  body = new_expr;\n-\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      create_an_loop (an_loop_info[ii].ind_init, an_loop_info[ii].cmp,\n-\t\t      an_loop_info[ii].incr, body);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list (body, &loop_with_init);\n-\n-  release_vec_vec (an_info);\n-\n-  return loop_with_init;\n-}\n-\n-/* Returns a loop with ARRAY_REF inside it with an appropriate modify expr.\n-   The LHS and/or RHS will be array notation expressions that have a\n-   MODIFYCODE.  The location of the variable is specified by LOCATION. */\n-\n-static tree\n-expand_an_in_modify_expr (location_t location, tree lhs,\n-\t\t\t  enum tree_code modifycode, tree rhs,\n-\t\t\t  tsubst_flags_t complain)\n-{\n-  tree array_expr_lhs = NULL_TREE, array_expr_rhs = NULL_TREE;\n-  tree array_expr = NULL_TREE;\n-  tree body = NULL_TREE;\n-  auto_vec<tree> cond_expr;\n-  vec<tree, va_gc> *lhs_array_operand = NULL, *rhs_array_operand = NULL;\n-  size_t lhs_rank = 0, rhs_rank = 0, ii = 0;\n-  vec<tree, va_gc> *rhs_list = NULL, *lhs_list = NULL;\n-  size_t rhs_list_size = 0, lhs_list_size = 0;\n-  tree new_modify_expr, new_var = NULL_TREE, builtin_loop, scalar_mods;\n-  bool found_builtin_fn = false;\n-  tree an_init, loop_with_init = alloc_stmt_list ();\n-  vec<vec<an_parts> > lhs_an_info = vNULL, rhs_an_info = vNULL;\n-  auto_vec<an_loop_parts> lhs_an_loop_info, rhs_an_loop_info;\n-  tree lhs_len, rhs_len;\n-\n-  if (!find_rank (location, rhs, rhs, false, &rhs_rank))\n-    return error_mark_node;\n-  extract_array_notation_exprs (rhs, false, &rhs_list);\n-  rhs_list_size = vec_safe_length (rhs_list);\n-  an_init = push_stmt_list ();\n-  if (rhs_rank)\n-    {\n-      scalar_mods = replace_invariant_exprs (&rhs);\n-      if (scalar_mods)\n-\tfinish_expr_stmt (scalar_mods);\n-    }\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    {\n-      tree rhs_node = (*rhs_list)[ii];\n-      if (TREE_CODE (rhs_node) == CALL_EXPR)\n-\t{\n-\t  builtin_loop = expand_sec_reduce_builtin (rhs_node, &new_var);\n-\t  if (builtin_loop == error_mark_node)\n-\t    return error_mark_node;\n-\t  else if (builtin_loop)\n-\t    {\n-\t      finish_expr_stmt (builtin_loop);\n-\t      found_builtin_fn = true;\n-\t      if (new_var)\n-\t\t{\n-\t\t  vec <tree, va_gc> *rhs_sub_list = NULL, *new_var_list = NULL;\n-\t\t  vec_safe_push (rhs_sub_list, rhs_node);\n-\t\t  vec_safe_push (new_var_list, new_var);\n-\t\t  replace_array_notations (&rhs, false, rhs_sub_list,\n-\t\t\t\t\t   new_var_list);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  lhs_rank = 0;\n-  rhs_rank = 0;\n-  if (!find_rank (location, lhs, lhs, true, &lhs_rank)\n-      || !find_rank (location, rhs, rhs, true, &rhs_rank))\n-    {\n-      pop_stmt_list (an_init);\n-      return error_mark_node;\n-    }\n-\n-  /* If both are scalar, then the only reason why we will get this far is if\n-     there is some array notations inside it and was using a builtin array\n-     notation functions.  If so, we have already broken those guys up and now \n-     a simple build_x_modify_expr would do.  */\n-  if (lhs_rank == 0 && rhs_rank == 0)\n-    {\n-      if (found_builtin_fn)\n-\t{\n-\t  new_modify_expr = build_x_modify_expr (location, lhs,\n-\t\t\t\t\t\t modifycode, rhs, complain);\n-\t  finish_expr_stmt (new_modify_expr);\n-\t  pop_stmt_list (an_init);\n-\t  return an_init;\n-\t}\n-      else\n-\tgcc_unreachable ();\n-    }\n-\n-  /* If for some reason location is not set, then find if LHS or RHS has\n-     location info.  If so, then use that so we atleast have an idea.  */\n-  if (location == UNKNOWN_LOCATION)\n-    {\n-      if (EXPR_LOCATION (lhs) != UNKNOWN_LOCATION)\n-\tlocation = EXPR_LOCATION (lhs);\n-      else if (EXPR_LOCATION (rhs) != UNKNOWN_LOCATION)\n-\tlocation = EXPR_LOCATION (rhs);\n-    }\n-      \n-  /* We need this when we have a scatter issue.  */\n-  extract_array_notation_exprs (lhs, true, &lhs_list);\n-  rhs_list = NULL;\n-  extract_array_notation_exprs (rhs, true, &rhs_list);\n-  rhs_list_size = vec_safe_length (rhs_list);\n-  lhs_list_size = vec_safe_length (lhs_list);\n-    \n-  if (lhs_rank == 0 && rhs_rank != 0)\n-    {\n-      error_at (location, \"%qE cannot be scalar when %qE is not\", lhs, rhs);\n-      return error_mark_node;\n-    }\n-  if (lhs_rank != 0 && rhs_rank != 0 && lhs_rank != rhs_rank)\n-    {\n-      error_at (location, \"rank mismatch between %qE and %qE\", lhs, rhs);\n-      return error_mark_node;\n-    }\n-  \n-  /* Assign the array notation components to variable so that they can satisfy\n-     the execute-once rule.  */\n-  for (ii = 0; ii < lhs_list_size; ii++)\n-    {\n-      tree anode = (*lhs_list)[ii];\n-      make_triplet_val_inv (&ARRAY_NOTATION_START (anode));\n-      make_triplet_val_inv (&ARRAY_NOTATION_LENGTH (anode));\n-      make_triplet_val_inv (&ARRAY_NOTATION_STRIDE (anode));\n-    }\n-  for (ii = 0; ii < rhs_list_size; ii++)\n-    if ((*rhs_list)[ii] && TREE_CODE ((*rhs_list)[ii]) == ARRAY_NOTATION_REF)\n-      {\n-\ttree aa = (*rhs_list)[ii];\n-\tmake_triplet_val_inv (&ARRAY_NOTATION_START (aa));\n-\tmake_triplet_val_inv (&ARRAY_NOTATION_LENGTH (aa));\n-\tmake_triplet_val_inv (&ARRAY_NOTATION_STRIDE (aa));\n-      }\n-  lhs_an_loop_info.safe_grow_cleared (lhs_rank);\n-  \n-  if (rhs_rank)\n-    rhs_an_loop_info.safe_grow_cleared (rhs_rank);\n-\n-  cond_expr.safe_grow_cleared (MAX (lhs_rank, rhs_rank));\n-  cilkplus_extract_an_triplets (lhs_list, lhs_list_size, lhs_rank,\n-\t\t\t\t&lhs_an_info);\n-  if (rhs_list)\n-    cilkplus_extract_an_triplets (rhs_list, rhs_list_size, rhs_rank,\n-\t\t\t\t  &rhs_an_info);\n-  if (length_mismatch_in_expr_p (EXPR_LOCATION (lhs), lhs_an_info)\n-      || (rhs_list && length_mismatch_in_expr_p (EXPR_LOCATION (rhs),\n-\t\t\t\t\t\t rhs_an_info)))\n-    {\n-      pop_stmt_list (an_init);\n-      goto error;\n-    }\n-  rhs_len = ((rhs_list_size > 0 && rhs_rank > 0) ?\n-    rhs_an_info[0][0].length : NULL_TREE);\n-  lhs_len = ((lhs_list_size > 0 && lhs_rank > 0) ?\n-    lhs_an_info[0][0].length : NULL_TREE);\n-  if (lhs_list_size > 0 && rhs_list_size > 0 && lhs_rank > 0 && rhs_rank > 0\n-      && TREE_CODE (lhs_len) == INTEGER_CST && rhs_len\n-      && TREE_CODE (rhs_len) == INTEGER_CST \n-      && !tree_int_cst_equal (rhs_len, lhs_len))\n-    { \n-      error_at (location, \"length mismatch between LHS and RHS\"); \n-      pop_stmt_list (an_init); \n-      goto error;\n-    }\n-   for (ii = 0; ii < lhs_rank; ii++) \n-     {\n-       tree typ = ptrdiff_type_node; \n-       lhs_an_loop_info[ii].var = create_temporary_var (typ);\n-       add_decl_expr (lhs_an_loop_info[ii].var);\n-       lhs_an_loop_info[ii].ind_init = build_x_modify_expr \n-\t (location, lhs_an_loop_info[ii].var, INIT_EXPR, build_zero_cst (typ), \n-\t  complain);\n-     }\n-   \n-   if (rhs_list_size > 0)\n-     {\n-       rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n-\t\t\t\t\t\t  lhs_an_loop_info, lhs_rank,\n-\t\t\t\t\t\t  lhs); \n-       if (!rhs_array_operand)\n-\t goto error;\n-     }\n-  replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-  rhs_list_size = 0;\n-  rhs_list = NULL;\n-  extract_array_notation_exprs (rhs, true, &rhs_list);\n-  rhs_list_size = vec_safe_length (rhs_list);    \n-\n-  for (ii = 0; ii < rhs_rank; ii++)\n-    {\n-      tree typ = ptrdiff_type_node;\n-      rhs_an_loop_info[ii].var = create_temporary_var (typ);\n-      add_decl_expr (rhs_an_loop_info[ii].var);\n-      rhs_an_loop_info[ii].ind_init = build_x_modify_expr\n-\t(location, rhs_an_loop_info[ii].var, INIT_EXPR, build_zero_cst (typ), \n-\t complain);\n-    }\n-\n-  if (lhs_rank)\n-    {\n-      lhs_array_operand =\n-\tcreate_array_refs (location, lhs_an_info, lhs_an_loop_info,\n-\t\t\t    lhs_list_size, lhs_rank);\n-      replace_array_notations (&lhs, true, lhs_list, lhs_array_operand);\n-    }\n-  \n-  if (rhs_array_operand)\n-    vec_safe_truncate (rhs_array_operand, 0);\n-  if (rhs_rank)\n-    {\n-      rhs_array_operand = create_array_refs (location, rhs_an_info,\n-\t\t\t\t\t      rhs_an_loop_info, rhs_list_size,\n-\t\t\t\t\t      rhs_rank);\n-      /* Replace all the array refs created by the above function because this\n-\t variable is blown away by the fix_sec_implicit_args function below.  */\n-      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-      vec_safe_truncate (rhs_array_operand , 0);\n-      rhs_array_operand = fix_sec_implicit_args (location, rhs_list,\n-\t\t\t\t\t\t rhs_an_loop_info, rhs_rank,\n-\t\t\t\t\t\t rhs);\n-      if (!rhs_array_operand)\n-\tgoto error;\n-      replace_array_notations (&rhs, true, rhs_list, rhs_array_operand);\n-    }\n-\n-  array_expr_rhs = rhs;\n-  array_expr_lhs = lhs;\n-  \n-  array_expr = build_x_modify_expr (location, array_expr_lhs, modifycode,\n-\t\t\t\t    array_expr_rhs, complain);\n-  create_cmp_incr (location, &lhs_an_loop_info, lhs_rank, lhs_an_info,\n-\t\t   complain);\n-  if (rhs_rank) \n-    create_cmp_incr (location, &rhs_an_loop_info, rhs_rank, rhs_an_info, \n-\t\t     complain);\n-  for (ii = 0; ii < MAX (rhs_rank, lhs_rank); ii++)\n-    if (ii < lhs_rank && ii < rhs_rank)\n-      cond_expr[ii] = build_x_binary_op\n-\t(location, TRUTH_ANDIF_EXPR, lhs_an_loop_info[ii].cmp,\n-\t TREE_CODE (lhs_an_loop_info[ii].cmp), rhs_an_loop_info[ii].cmp,\n-\t TREE_CODE (rhs_an_loop_info[ii].cmp), NULL, complain);\n-    else if (ii < lhs_rank && ii >= rhs_rank)\n-      cond_expr[ii] = lhs_an_loop_info[ii].cmp;\n-    else\n-      /* No need to compare ii < rhs_rank && ii >= lhs_rank because in a valid \n-\t Array notation expression, rank of RHS cannot be greater than LHS.  */\n-      gcc_unreachable ();\n-  \n-  an_init = pop_stmt_list (an_init);\n-  append_to_statement_list (an_init, &loop_with_init);\n-  body = array_expr;\n-  for (ii = 0; ii < MAX (lhs_rank, rhs_rank); ii++)\n-    {\n-      tree incr_list = alloc_stmt_list ();\n-      tree init_list = alloc_stmt_list ();\n-      tree new_loop = push_stmt_list ();\n-\n-      if (lhs_rank)\n-\t{\n-\t  append_to_statement_list (lhs_an_loop_info[ii].ind_init, &init_list);\n-\t  append_to_statement_list (lhs_an_loop_info[ii].incr, &incr_list);\n-\t}\n-      if (rhs_rank)\n-\t{\n-\t  append_to_statement_list (rhs_an_loop_info[ii].ind_init, &init_list);\n-\t  append_to_statement_list (rhs_an_loop_info[ii].incr, &incr_list);\n-\t}\n-      create_an_loop (init_list, cond_expr[ii], incr_list, body);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list (body, &loop_with_init);\n-\n-  release_vec_vec (lhs_an_info);\n-  release_vec_vec (rhs_an_info);\n-\n-  return loop_with_init;\n-\n-error:\n-  release_vec_vec (lhs_an_info);\n-  release_vec_vec (rhs_an_info);\n-\n-  return error_mark_node;\n-}\n-\n-/* Helper function for expand_conditonal_array_notations.  Encloses the\n-   conditional statement passed in ORIG_STMT with a loop around it and\n-   replaces the condition in STMT with a ARRAY_REF tree-node to the array.  \n-   The condition must have a ARRAY_NOTATION_REF tree.  */\n-\n-static tree\n-cp_expand_cond_array_notations (tree orig_stmt)\n-{\n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0;\n-  size_t rank = 0, ii = 0;\n-  tree an_init, body, stmt = NULL_TREE;\n-  tree builtin_loop, new_var = NULL_TREE;\n-  tree loop_with_init = alloc_stmt_list ();\n-  location_t location = UNKNOWN_LOCATION;\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n-\n-  if (TREE_CODE (orig_stmt) == COND_EXPR)\n-    {\n-      size_t cond_rank = 0, yes_rank = 0, no_rank = 0;\n-      tree yes_expr = COND_EXPR_THEN (orig_stmt);\n-      tree no_expr = COND_EXPR_ELSE (orig_stmt);\n-      tree cond = COND_EXPR_COND (orig_stmt);\n-      if (!find_rank (EXPR_LOCATION (cond), cond, cond, true, &cond_rank)\n-\t  || !find_rank (EXPR_LOCATION (yes_expr), yes_expr, yes_expr, true,\n-\t\t\t &yes_rank)\n-\t  || !find_rank (EXPR_LOCATION (no_expr), no_expr, no_expr, true,\n-\t\t\t &no_rank))\n-\treturn error_mark_node;\n-      /* If the condition has a zero rank, then handle array notations in body\n-\t separately.  */\n-      if (cond_rank == 0)\n-\treturn orig_stmt;\n-      if (cond_rank != yes_rank && yes_rank != 0)\n-\t{\n-\t  error_at (EXPR_LOCATION (yes_expr), \"rank mismatch with controlling\"\n-\t\t    \" expression of parent if-statement\");\n-\t  return error_mark_node;\n-\t}\n-      else if (cond_rank != no_rank && no_rank != 0)\n-\t{\n-\t  error_at (EXPR_LOCATION (no_expr), \"rank mismatch with controlling \"\n-\t\t    \"expression of parent if-statement\");\n-\t  return error_mark_node;\n-\t}\n-    }\n-  else if (TREE_CODE (orig_stmt) == IF_STMT)\n-    {\n-      size_t cond_rank = 0, yes_rank = 0, no_rank = 0;\n-      tree yes_expr = THEN_CLAUSE (orig_stmt);\n-      tree no_expr = ELSE_CLAUSE (orig_stmt);\n-      tree cond = IF_COND (orig_stmt);\n-      if (!find_rank (EXPR_LOCATION (cond), cond, cond, true, &cond_rank)\n-\t  || (yes_expr\n-\t      && !find_rank (EXPR_LOCATION (yes_expr), yes_expr, yes_expr, true,\n-\t\t\t     &yes_rank))\n-\t  || (no_expr\n-\t      && !find_rank (EXPR_LOCATION (no_expr), no_expr, no_expr, true,\n-\t\t\t     &no_rank)))\n-\treturn error_mark_node;\n-\n-      /* Same reasoning as for COND_EXPR.  */\n-      if (cond_rank == 0)\n-\treturn orig_stmt;\n-      else if (cond_rank != yes_rank && yes_rank != 0)\n-\t{\n-\t  error_at (EXPR_LOCATION (yes_expr), \"rank mismatch with controlling\"\n-\t\t    \" expression of parent if-statement\");\n-\t  return error_mark_node;\n-\t}\n-      else if (cond_rank != no_rank && no_rank != 0)\n-\t{\n-\t  error_at (EXPR_LOCATION (no_expr), \"rank mismatch with controlling \"\n-\t\t    \"expression of parent if-statement\");\n-\t  return error_mark_node;\n-\t}\n-    }\n-  else if (truth_value_p (TREE_CODE (orig_stmt)))\n-    {\n-      size_t left_rank = 0, right_rank = 0;\n-      tree left_expr = TREE_OPERAND (orig_stmt, 0);\n-      tree right_expr = TREE_OPERAND (orig_stmt, 1);\n-      if (!find_rank (EXPR_LOCATION (left_expr), left_expr, left_expr, true,\n-\t\t      &left_rank)\n-\t  || !find_rank (EXPR_LOCATION (right_expr), right_expr, right_expr,\n-\t\t\t true, &right_rank))\n-\treturn error_mark_node;\n-      if (right_rank == 0 && left_rank == 0)\n-\treturn orig_stmt;\n-    }\n-\n-  if (!find_rank (EXPR_LOCATION (orig_stmt), orig_stmt, orig_stmt, true,\n-\t\t  &rank))\n-    return error_mark_node;\n-  if (rank == 0)\n-    return orig_stmt;\n-\n-  extract_array_notation_exprs (orig_stmt, false, &array_list);\n-  stmt = alloc_stmt_list ();\n-  for (ii = 0; ii < vec_safe_length (array_list); ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      if (TREE_CODE (array_node) == CALL_EXPR\n-\t  || TREE_CODE (array_node) == AGGR_INIT_EXPR)\n-\t{\n-\t  builtin_loop = expand_sec_reduce_builtin (array_node, &new_var);\n-\t  if (builtin_loop == error_mark_node)\n-\t    finish_expr_stmt (error_mark_node);\n-\t  else if (new_var)\n-\t    {\n-\t      vec<tree, va_gc> *sub_list = NULL, *new_var_list = NULL;\n-\t      vec_safe_push (sub_list, array_node);\n-\t      vec_safe_push (new_var_list, new_var);\n-\t      replace_array_notations (&orig_stmt, false, sub_list,\n-\t\t\t\t       new_var_list);\n-\t      append_to_statement_list (builtin_loop, &stmt);\n-\t    }\n-\t}\n-    }\n-  append_to_statement_list (orig_stmt, &stmt);\n-  rank = 0;\n-  array_list = NULL;\n-  if (!find_rank (EXPR_LOCATION (stmt), stmt, stmt, true, &rank))\n-    return error_mark_node;\n-  if (rank == 0)\n-    return stmt;\n-  \n-  extract_array_notation_exprs (stmt, true, &array_list);\n-  list_size = vec_safe_length (array_list);\n-  if (list_size == 0)\n-    return stmt;\n-\n-  location = EXPR_LOCATION (orig_stmt);\n-  list_size = vec_safe_length (array_list);\n-  an_loop_info.safe_grow_cleared (rank);\n-  \n-  an_init = push_stmt_list ();\n-\n-  /* Assign the array notation components to variable so that they can\n-     satisfy the exec-once rule.  */\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree anode = (*array_list)[ii];\n-      make_triplet_val_inv (&ARRAY_NOTATION_START (anode));\n-      make_triplet_val_inv (&ARRAY_NOTATION_LENGTH (anode));\n-      make_triplet_val_inv (&ARRAY_NOTATION_STRIDE (anode));\n-    }\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-\n-  for (ii = 0; ii < rank; ii++) \n-    {\n-      tree typ = ptrdiff_type_node;\n-      an_loop_info[ii].var = create_temporary_var (typ);\n-      add_decl_expr (an_loop_info[ii].var);\n-      an_loop_info[ii].ind_init =\n-\tbuild_x_modify_expr (location, an_loop_info[ii].var, INIT_EXPR,\n-\t\t\t     build_zero_cst (typ), tf_warning_or_error);\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t     list_size, rank);\n-  replace_array_notations (&stmt, true, array_list, array_operand);\n-  create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n-  \n-  an_init = pop_stmt_list (an_init);\n-  append_to_statement_list (an_init, &loop_with_init);\n-  body = stmt;\n-\n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      create_an_loop (an_loop_info[ii].ind_init, an_loop_info[ii].cmp,\n-\t\t      an_loop_info[ii].incr, body);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list (body, &loop_with_init);\n-\n-  release_vec_vec (an_info);\n-  \n-  return loop_with_init;\n-}\n-\n-/* Transforms array notations inside unary expression ORIG_STMT with an\n-   appropriate loop and ARRAY_REF (and returns all this as a super-tree called\n-   LOOP).  */\n-\n-static tree\n-expand_unary_array_notation_exprs (tree orig_stmt)\n-{\n-  vec<tree, va_gc> *array_list = NULL, *array_operand = NULL;\n-  size_t list_size = 0, rank = 0, ii = 0;\n-  tree body;\n-  tree builtin_loop, stmt = NULL_TREE, new_var = NULL_TREE;\n-  location_t location = EXPR_LOCATION (orig_stmt);\n-  tree an_init, loop_with_init = alloc_stmt_list ();\n-  vec<vec<an_parts> > an_info = vNULL;\n-  auto_vec<an_loop_parts> an_loop_info;\n-  \n-  if (!find_rank (location, orig_stmt, orig_stmt, true, &rank))\n-    return error_mark_node;\n-  if (rank == 0)\n-    return orig_stmt;  \n-  \n-  extract_array_notation_exprs (orig_stmt, false, &array_list);\n-  list_size = vec_safe_length (array_list);\n-  location = EXPR_LOCATION (orig_stmt);\n-  stmt = NULL_TREE;\n-  for (ii = 0; ii < list_size; ii++)\n-    if (TREE_CODE ((*array_list)[ii]) == CALL_EXPR\n-\t|| TREE_CODE ((*array_list)[ii]) == AGGR_INIT_EXPR)\n-      {\n-\ttree list_node = (*array_list)[ii];\n-\tbuiltin_loop = expand_sec_reduce_builtin (list_node, &new_var);\n-\tif (builtin_loop == error_mark_node)\n-\t  return error_mark_node;\n-\telse if (builtin_loop)\n-\t  {\n-\t    vec<tree, va_gc> *sub_list = NULL, *new_var_list = NULL;\n-\t    stmt = alloc_stmt_list ();\n-\t    append_to_statement_list (builtin_loop, &stmt);\n-\t    vec_safe_push (sub_list, list_node);\n-\t    vec_safe_push (new_var_list, new_var);\n-\t    replace_array_notations (&orig_stmt, false, sub_list, new_var_list);\n-\t  }\t\n-      }\n-  if (stmt != NULL_TREE)\n-    append_to_statement_list (finish_expr_stmt (orig_stmt), &stmt);\n-  else\n-    stmt = orig_stmt;\n-  rank = 0;\n-  list_size = 0;\n-  array_list = NULL;\n-  extract_array_notation_exprs (stmt, true, &array_list);\n-  list_size = vec_safe_length (array_list);\n-\n-  if (!find_rank (EXPR_LOCATION (stmt), stmt, stmt, true, &rank))\n-    return error_mark_node;\n-  if (rank == 0 || list_size == 0)\n-    return stmt;\n-  an_loop_info.safe_grow_cleared (rank);\n-  an_init = push_stmt_list ();  \n-    /* Assign the array notation components to variable so that they can satisfy\n-     the exec-once rule.  */\n-  for (ii = 0; ii < list_size; ii++)\n-    {\n-      tree array_node = (*array_list)[ii];\n-      make_triplet_val_inv (&ARRAY_NOTATION_START (array_node));\n-      make_triplet_val_inv (&ARRAY_NOTATION_LENGTH (array_node));\n-      make_triplet_val_inv (&ARRAY_NOTATION_STRIDE (array_node));\n-    }\n-  cilkplus_extract_an_triplets (array_list, list_size, rank, &an_info);\n-  \n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree typ = ptrdiff_type_node;\n-      an_loop_info[ii].var = create_temporary_var (typ);\n-      add_decl_expr (an_loop_info[ii].var);\n-      an_loop_info[ii].ind_init = build_x_modify_expr\n-\t(location, an_loop_info[ii].var, INIT_EXPR, build_zero_cst (typ), \n-\t tf_warning_or_error);\n-    }\n-  array_operand = create_array_refs (location, an_info, an_loop_info,\n-\t\t\t\t     list_size, rank);\n-  replace_array_notations (&stmt, true, array_list, array_operand);\n-  create_cmp_incr (location, &an_loop_info, rank, an_info, tf_warning_or_error);\n-  \n-  an_init = pop_stmt_list (an_init);\n-  append_to_statement_list (an_init, &loop_with_init);\n-  body = stmt;\n-  \n-  for (ii = 0; ii < rank; ii++)\n-    {\n-      tree new_loop = push_stmt_list ();\n-      create_an_loop (an_loop_info[ii].ind_init, an_loop_info[ii].cmp,\n-\t\t      an_loop_info[ii].incr, body);\n-      body = pop_stmt_list (new_loop);\n-    }\n-  append_to_statement_list (body, &loop_with_init);\n-\n-  release_vec_vec (an_info);\n-\n-  return loop_with_init;\n-}\n-\n-/* Expands the array notation's builtin reduction function in EXPR\n-   (of type RETURN_EXPR) and returns a STATEMENT_LIST that contains a loop\n-   with the builtin function expansion and a return statement at the end.  */\n-\n-static tree\n-expand_return_expr (tree expr)\n-{\n-  tree new_mod_list, new_var, new_mod, retval_expr;\n-  size_t rank  = 0;\n-  location_t loc = EXPR_LOCATION (expr);\n-  if (TREE_CODE (expr) != RETURN_EXPR)\n-    return expr;\n-      \n-  if (!find_rank (loc, expr, expr, false, &rank))\n-    return error_mark_node;\n-\n-  /* If the return expression contains array notations, then flag it as\n-     error.  */\n-  if (rank >= 1)\n-    {\n-      error_at (loc, \"array notation expression cannot be used as a return \"\n-\t\t\"value\");\n-      return error_mark_node;\n-    }\n-  \n-  new_mod_list = push_stmt_list ();\n-  retval_expr = TREE_OPERAND (expr, 0);\n-  new_var = create_temporary_var (TREE_TYPE (retval_expr));\n-  add_decl_expr (new_var);\n-  new_mod = expand_an_in_modify_expr (loc, new_var, NOP_EXPR,\n-\t\t\t\t      TREE_OPERAND (retval_expr, 1),\n-\t\t\t\t      tf_warning_or_error);\n-  TREE_OPERAND (retval_expr, 1) = new_var;\n-  TREE_OPERAND (expr, 0) = retval_expr;\n-  add_stmt (new_mod);\n-  add_stmt (expr);\n-  new_mod_list = pop_stmt_list (new_mod_list);\n-  return new_mod_list;\n-}\n-\n-/* Expands ARRAY_NOTATION_REF and builtin functions in a compound statement,\n-   STMT. Returns the STMT with expanded array notations.  */\n-\n-tree\n-expand_array_notation_exprs (tree t)\n-{\n-  enum tree_code code;\n-  bool is_expr;\n-  location_t loc = UNKNOWN_LOCATION;\n-  \n-  if (!t)\n-    return t;\n-\n-  loc = EXPR_LOCATION (t);\n-\n-  code = TREE_CODE (t); \n-  is_expr = IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code));\n-  switch (code)\n-    {\n-    case ERROR_MARK:\n-    case IDENTIFIER_NODE:\n-    case VOID_CST:\n-    case INTEGER_CST:\n-    case REAL_CST:\n-    case FIXED_CST:\n-    case STRING_CST:\n-    case BLOCK:\n-    case PLACEHOLDER_EXPR:\n-    case FIELD_DECL:\n-    case VOID_TYPE:\n-    case REAL_TYPE:\n-    case SSA_NAME:\n-    case LABEL_DECL:\n-    case RESULT_DECL:\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case NON_LVALUE_EXPR:\n-    case NOP_EXPR:\n-    case ADDR_EXPR:\n-    case ARRAY_REF:\n-    case BIT_FIELD_REF:\n-    case VECTOR_CST:\n-    case COMPLEX_CST:\n-      return t;\n-    case INIT_EXPR:\n-    case MODIFY_EXPR:\n-      if (contains_array_notation_expr (t))\n-\tt = expand_an_in_modify_expr (loc, TREE_OPERAND (t, 0), NOP_EXPR, \n-\t\t\t\t\t TREE_OPERAND (t, 1), \n-\t\t\t\t\t tf_warning_or_error);\n-      return t;\n-    case MODOP_EXPR:\n-      if (contains_array_notation_expr (t) && !processing_template_decl)\n-\tt = expand_an_in_modify_expr\n-\t  (loc, TREE_OPERAND (t, 0), TREE_CODE (TREE_OPERAND (t, 1)),\n-\t   TREE_OPERAND (t, 2), tf_warning_or_error);\n-      return t;\n-    case CONSTRUCTOR:\n-      return t;\n-    case BIND_EXPR:\n-      {\n-\tBIND_EXPR_BODY (t) =\n-\t  expand_array_notation_exprs  (BIND_EXPR_BODY (t));\n-\treturn t;\n-      }\n-    case DECL_EXPR:\n-      if (contains_array_notation_expr (t))\n-\t{\n-\t  tree x = DECL_EXPR_DECL (t);\n-\t  if (DECL_INITIAL (x))\n-\t    {\n-\t      location_t loc = DECL_SOURCE_LOCATION (x);\n-\t      tree lhs = x;\n-\t      tree rhs = DECL_INITIAL (x);\n-\t      DECL_INITIAL (x) = NULL;\n-\t      tree new_modify_expr = build_modify_expr (loc, lhs,\n-\t\t\t\t\t\t\tTREE_TYPE (lhs),\n-\t\t\t\t\t\t\tNOP_EXPR,\n-\t\t\t\t\t\t\tloc, rhs,\n-\t\t\t\t\t\t\tTREE_TYPE(rhs));\n-\t      t = expand_array_notation_exprs (new_modify_expr);\n-\t    }\n-\t}\n-      return t;\n-    case STATEMENT_LIST:\n-      {\n-\ttree_stmt_iterator i;\n-\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n-\t  *tsi_stmt_ptr (i) =\n-\t    expand_array_notation_exprs (*tsi_stmt_ptr (i));\n-\treturn t;\n-      }\n-\n-    case OMP_PARALLEL:\n-      OMP_PARALLEL_BODY (t)\n-\t= expand_array_notation_exprs (OMP_PARALLEL_BODY (t));\n-      return t;\n-\n-    case OMP_TASK:\n-    case OMP_FOR:\n-    case OMP_SINGLE:\n-    case OMP_SECTION:\n-    case OMP_SECTIONS:\n-    case OMP_MASTER:\n-    case OMP_TASKGROUP:\n-    case OMP_ORDERED:\n-    case OMP_CRITICAL:\n-    case OMP_ATOMIC:\n-    case OMP_CLAUSE:\n-    case TARGET_EXPR:\n-    case INTEGER_TYPE:\n-    case ENUMERAL_TYPE:\n-    case BOOLEAN_TYPE:\n-    case POINTER_TYPE:\n-    case ARRAY_TYPE:\n-    case RECORD_TYPE:\n-    case METHOD_TYPE:\n-      return t;\n-    case RETURN_EXPR:\n-      if (contains_array_notation_expr (t))\n-\tt = expand_return_expr (t);\n-      return t;\n-    case PREDECREMENT_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case AGGR_INIT_EXPR:\n-    case CALL_EXPR:\n-      t = expand_unary_array_notation_exprs (t);\n-      return t;\n-    case CONVERT_EXPR:\n-    case CLEANUP_POINT_EXPR:\n-    case EXPR_STMT:\n-      TREE_OPERAND (t, 0) = expand_array_notation_exprs (TREE_OPERAND (t, 0));\n-      /* It is not necessary to wrap error_mark_node in EXPR_STMT.  */\n-      if (TREE_OPERAND (t, 0) == error_mark_node)\n-\treturn TREE_OPERAND (t, 0); \n-      return t;\n-    case TRUTH_ANDIF_EXPR:\n-    case TRUTH_ORIF_EXPR:\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-    case TRUTH_NOT_EXPR:\n-    case COND_EXPR:\n-      t = cp_expand_cond_array_notations (t);\n-      if (TREE_CODE (t) == COND_EXPR)\n-\t{\n-\t  COND_EXPR_THEN (t) =\n-\t    expand_array_notation_exprs (COND_EXPR_THEN (t));\n-\t  COND_EXPR_ELSE (t) =\n-\t    expand_array_notation_exprs (COND_EXPR_ELSE (t));\n-\t}\n-      return t;\n-    case FOR_STMT:\n-      if (contains_array_notation_expr (FOR_COND (t)))\n-\t{\n-\t  error_at (EXPR_LOCATION (FOR_COND (t)),\n-\t\t    \"array notation cannot be used in a condition for \"\n-\t\t    \"a for-loop\");\n-\t  return error_mark_node;\n-\t}\n-      /* FIXME: Add a check for CILK_FOR_STMT here when we add Cilk tasking \n-\t keywords.  */\n-      if (TREE_CODE (t) == FOR_STMT)\n-\t{ \n-\t  FOR_BODY (t) = expand_array_notation_exprs (FOR_BODY (t));\n-\t  FOR_EXPR (t) = expand_array_notation_exprs (FOR_EXPR (t));\n-\t}\n-      else\n-\tt = expand_array_notation_exprs (t);\n-      return t;\n-    case IF_STMT:\n-      t = cp_expand_cond_array_notations (t);\n-      /* If the above function added some extra instructions above the original\n-\t if statement, then we can't assume it is still IF_STMT so we have to\n-\t check again.  */\n-      if (TREE_CODE (t) == IF_STMT)\n-\t{\n-\t  if (THEN_CLAUSE (t))\n-\t    THEN_CLAUSE (t) = expand_array_notation_exprs (THEN_CLAUSE (t));\n-\t  if (ELSE_CLAUSE (t))\n-\t    ELSE_CLAUSE (t) = expand_array_notation_exprs (ELSE_CLAUSE (t));\n-\t}\n-      else\n-\tt = expand_array_notation_exprs (t);\n-      return t;\n-    case SWITCH_STMT:\n-      if (contains_array_notation_expr (SWITCH_STMT_COND (t)))\n-\t{\n-\t  error_at (EXPR_LOCATION (SWITCH_STMT_COND (t)),\n-\t\t    \"array notation cannot be used as a condition for \"\n-\t\t    \"switch statement\");\n-\t  return error_mark_node;\n-\t}\n-      if (SWITCH_STMT_BODY (t))\n-\tSWITCH_STMT_BODY (t) =\n-\t  expand_array_notation_exprs (SWITCH_STMT_BODY (t));\n-      return t;\n-    case WHILE_STMT:\n-      if (contains_array_notation_expr (WHILE_COND (t)))\n-\t{\n-\t  if (EXPR_LOCATION (WHILE_COND (t)) != UNKNOWN_LOCATION)\n-\t    loc = EXPR_LOCATION (WHILE_COND (t));\n-\t  error_at (loc, \"array notation cannot be used as a condition for \"\n-\t\t    \"while statement\");\n-\t  return error_mark_node;\n-\t}\n-      if (WHILE_BODY (t))\n-\tWHILE_BODY (t) = expand_array_notation_exprs (WHILE_BODY (t));\n-      return t;\n-    case DO_STMT:\n-      if (contains_array_notation_expr (DO_COND (t)))\n-\t{\n-\t  error_at (EXPR_LOCATION (DO_COND (t)),\n-\t\t    \"array notation cannot be used as a condition for a \"\n-\t\t    \"do-while statement\");\n-\t  return error_mark_node;\n-\t}\n-      if (DO_BODY (t))\n-\tDO_BODY (t) = expand_array_notation_exprs (DO_BODY (t));\n-      return t;\n-    default:\n-      if (is_expr)\n-\t{\n-\t  int i, len;\n-\n-\t  /* Walk over all the sub-trees of this operand.  */\n-\t  len = TREE_CODE_LENGTH (code);\n-\n-\t  /* Go through the subtrees.  We need to do this in forward order so\n-\t     that the scope of a FOR_EXPR is handled properly.  */\n-\t  for (i = 0; i < len; ++i)\n-\t    TREE_OPERAND (t, i) =\n-\t      expand_array_notation_exprs (TREE_OPERAND (t, i));\n-\t}\n-      return t;\n-    }\n-  return t;\n-}\n-\n-/* Given the base of an array (ARRAY), the START (start_index), the number of \n-   elements to be accessed (LENGTH) and the STRIDE, construct an \n-   ARRAY_NOTATION_REF tree of type TYPE and return it.  Restrictions on START, \n-   LENGTH and STRIDE are the same as that of index field passed into ARRAY_REF. \n-   The only additional restriction is that, unlike index in ARRAY_REF, stride, \n-   length and start_index cannot contain array notations.  */\n-\n-tree\n-build_array_notation_ref (location_t loc, tree array, tree start, tree length, \n-\t\t\t  tree stride, tree type)\n-{\n-  tree array_ntn_expr = NULL_TREE;\n-\n-  /* If we enter the then-case of the if-statement below, we have hit a case \n-     like this: ARRAY [:].  */\n-  if (!start && !length)\n-    {\n-      if (TREE_CODE (type) != ARRAY_TYPE)\n-\t{\n-\t  error_at (loc, \"start-index and length fields necessary for \"\n-\t\t    \"using array notation in pointers or records\");\n-\t  return error_mark_node;\n-\t}\n-      tree domain = TYPE_DOMAIN (type);\n-      if (!domain)\n-\t{\n-\t  error_at (loc, \"start-index and length fields necessary for \"\n-\t\t    \"using array notation with array of unknown bound\");\n-\t  return error_mark_node;\n-\t}\n-      start = cp_fold_convert (ptrdiff_type_node, TYPE_MIN_VALUE (domain));\n-      length = size_binop (PLUS_EXPR, TYPE_MAX_VALUE (domain), size_one_node);\n-      length = cp_fold_convert (ptrdiff_type_node, length);\n-    }\n-    \n-  if (!stride) \n-    stride = build_one_cst (ptrdiff_type_node);\n-\n-  stride = maybe_constant_value (stride);\n-  length = maybe_constant_value (length);\n-  if (start)\n-    start = maybe_constant_value (start);\n-\n-  /* When dealing with templates, triplet type-checking will be done in pt.c \n-     after type substitution.  */\n-  if (processing_template_decl \n-      && (type_dependent_expression_p (array) \n-\t  || type_dependent_expression_p (length) \n-\t  || type_dependent_expression_p (start) \n-\t  || type_dependent_expression_p (stride))) \n-    array_ntn_expr = build_min_nt_loc (loc, ARRAY_NOTATION_REF, array, start, \n-\t\t\t\t       length, stride, NULL_TREE);\n-  else \n-    { \n-      if (!cilkplus_an_triplet_types_ok_p (loc, start, length, stride, type))\n-\treturn error_mark_node;\n-      array_ntn_expr = build4 (ARRAY_NOTATION_REF, NULL_TREE, array, start, \n-\t\t\t       length, stride);\n-    }\n-  if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == POINTER_TYPE)\n-    TREE_TYPE (array_ntn_expr) = TREE_TYPE (type);\n-  else\n-    {\n-      error_at (loc, \"base of array section must be pointer or array type\");\n-      return error_mark_node;\n-    }\n-\n-  SET_EXPR_LOCATION (array_ntn_expr, loc);\n-  return array_ntn_expr;\n-}\n-\n-/* Returns false if any of the Array notation triplet values: START_INDEX,\n-   LENGTH and STRIDE, are not of integral type and have a rank greater than\n-   zero.  */\n-\n-bool\n-cilkplus_an_triplet_types_ok_p (location_t loc, tree start_index, tree length,\n-\t\t\t\ttree stride, tree type)\n-{\n-  size_t stride_rank = 0, length_rank = 0, start_rank = 0;\n-  if (!TREE_TYPE (start_index) || !INTEGRAL_TYPE_P (TREE_TYPE (start_index)))\n-    {\n-      error_at (loc, \"start-index of array notation triplet is not an integer\");\n-      return false;\n-    }\n-  if (!TREE_TYPE (length) || !INTEGRAL_TYPE_P (TREE_TYPE (length)))\n-    {\n-      error_at (loc, \"length of array notation triplet is not an integer\");\n-      return false;\n-    }\n-  if (!TREE_TYPE (stride) || !INTEGRAL_TYPE_P (TREE_TYPE (stride)))\n-    {\n-      error_at (loc, \"stride of array notation triplet is not an integer\");\n-      return false;\n-    }\n-  if (TREE_CODE (type) == FUNCTION_TYPE)\n-    {\n-      error_at (loc, \"array notation cannot be used with function type\");\n-      return false;\n-    }\n-  if (!find_rank (loc, start_index, start_index, false, &start_rank)\n-      || !find_rank (loc, length, length, false, &length_rank)\n-      || !find_rank (loc, stride, stride, false, &stride_rank))\n-    return false;\n-\n-  if (start_rank != 0)\n-    {\n-      error_at (loc, \"rank of an array notation triplet%'s start-index is not \"\n-\t\t\"zero\");\n-      return false;\n-    }\n-  if (length_rank != 0)\n-    {\n-      error_at (loc, \"rank of an array notation triplet%'s length is not zero\");\n-      return false;\n-    }\n-  if (stride_rank != 0)\n-    {\n-      error_at (loc, \"rank of array notation triplet%'s stride is not zero\");\n-      return false;\n-    }\n-  return true;\n-}"}, {"sha": "5ccf5d3385dff08bf118a44541811804cb58ec82", "filename": "gcc/cp/cp-cilkplus.c", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcp%2Fcp-cilkplus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcp%2Fcp-cilkplus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-cilkplus.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,240 +0,0 @@\n-/* This file is part of the Intel(R) Cilk(TM) Plus support\n-   This file contains routines to handle Cilk Plus specific\n-   routines for the C++ Compiler.\n-   Copyright (C) 2013-2017 Free Software Foundation, Inc.\n-   Contributed by Aldy Hernandez <aldyh@redhat.com>.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"cp-tree.h\"\n-#include \"tree-iterator.h\"\n-#include \"cilk.h\"\n-#include \"c-family/c-common.h\"\n-\n-/* Return TRUE if T is a FUNCTION_DECL for a type-conversion operator.  */\n-\n-static bool\n-is_conversion_operator_function_decl_p (tree t)\n-{\n-  if (TREE_CODE (t) != FUNCTION_DECL)\n-    return false;\n-\n-  return DECL_CONV_FN_P (t);\n-}\n-\n-/* Recursively traverse EXP to search for a CILK_SPAWN_STMT subtree.\n-   Return the CILK_SPAWN_STMT subtree if found; otherwise, the last subtree\n-   searched.  */\n-\n-static tree\n-find_spawn (tree exp)\n-{\n-  /* Happens with C++ TARGET_EXPR.  */\n-  if (exp == NULL_TREE)\n-    return exp;\n-\n-  if (cilk_ignorable_spawn_rhs_op (exp))\n-    return find_spawn (TREE_OPERAND (exp, 0));\n-\n-  switch (TREE_CODE (exp))\n-    {\n-    case AGGR_INIT_EXPR:\n-      {\n-\t/* Check for initialization via a constructor call that represents\n-\t   implicit conversion.  */\n-\tif (AGGR_INIT_VIA_CTOR_P (exp) && aggr_init_expr_nargs (exp) == 2)\n-\t  return find_spawn (AGGR_INIT_EXPR_ARG (exp, 1));\n-\n-\t/* Check for initialization via a call to a type-conversion\n-\t   operator.  */\n-\ttree fn = AGGR_INIT_EXPR_FN (exp);\n-\tif (TREE_CODE (fn) == ADDR_EXPR\n-\t    && is_conversion_operator_function_decl_p (TREE_OPERAND (fn, 0))\n-\t    && aggr_init_expr_nargs (exp) == 1)\n-\t  return find_spawn (AGGR_INIT_EXPR_ARG (exp, 0));\n-      }\n-      break;\n-\n-    case CALL_EXPR:\n-      {\n-\t/* Check for a call to a type-conversion operator.  */\n-\ttree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n-\tif (is_conversion_operator_function_decl_p (fndecl)\n-\t    && call_expr_nargs (exp) == 1)\n-\t  return find_spawn (CALL_EXPR_ARG (exp, 0));\n-      }\n-      break;\n-\n-    case TARGET_EXPR:\n-      return find_spawn (TARGET_EXPR_INITIAL (exp));\n-\n-    case CLEANUP_POINT_EXPR:\n-    case COMPOUND_EXPR:\n-    case EXPR_STMT:\n-      return find_spawn (TREE_OPERAND (exp, 0));\n-\n-    default:\n-      break;\n-    }\n-\n-    return exp;\n-}\n-\n-/* Return true if *EXP0 is a recognized form of spawn.  Recognized forms\n-   are, after conversion to void, a call expression at outer level or an\n-   assignment at outer level with the right hand side being a spawned call.\n-   In addition to this, it also unwraps the CILK_SPAWN_STMT cover from the\n-   CALL_EXPR that is being spawned.\n-\n-   Note that `=' in C++ may turn into a CALL_EXPR rather than a\n-   MODIFY_EXPR.  */\n-\n-bool\n-cilk_cp_detect_spawn_and_unwrap (tree *exp0)\n-{\n-  tree exp = *exp0;\n-\n-  if (!TREE_SIDE_EFFECTS (exp))\n-    return false;\n-\n-  /* Strip off any conversion to void.  It does not affect whether spawn\n-     is supported here.  */\n-  if (TREE_CODE (exp) == CONVERT_EXPR && VOID_TYPE_P (TREE_TYPE (exp)))\n-    exp = TREE_OPERAND (exp, 0);\n-\n-  if (TREE_CODE (exp) == MODIFY_EXPR || TREE_CODE (exp) == INIT_EXPR)\n-    exp = TREE_OPERAND (exp, 1);\n-\n-  exp = find_spawn (exp);\n-  if (exp == NULL_TREE)\n-    return false;\n-\n-  /* Now we should have a CALL_EXPR with a CILK_SPAWN_STMT wrapper around\n-     it, or return false.  */\n-  return cilk_recognize_spawn (exp, exp0);\n-}\n-\n-/* Callback for cp_walk_tree to validate the body of a pragma simd loop\n-   or _cilk_for loop.\n-\n-   This function is passed in as a function pointer to walk_tree.  *TP is\n-   the current tree pointer, *WALK_SUBTREES is set to 0 by this function if\n-   recursing into TP's subtrees is unnecessary. *DATA is a bool variable that\n-   is set to false if an error has occurred.  */\n-\n-static tree\n-cpp_validate_cilk_plus_loop_aux (tree *tp, int *walk_subtrees, void *data)\n-{\n-  bool *valid = (bool *) data;\n-\n-  if (!tp || !*tp)\n-    return NULL_TREE;\n-\n-  location_t loc = EXPR_LOCATION (*tp);\n-  if (TREE_CODE (*tp) == THROW_EXPR)\n-    {\n-      error_at (loc, \"throw expressions are not allowed inside loops \"\n-\t\t\"marked with pragma simd\");\n-      *walk_subtrees = 0;\n-      *valid = false;\n-    }\n-  else if (TREE_CODE (*tp) == TRY_BLOCK)\n-    {\n-      error_at (loc, \"try statements are not allowed inside loops marked \"\n-\t\t\"with #pragma simd\");\n-      *valid = false;\n-      *walk_subtrees = 0;\n-    }\n-  return NULL_TREE;\n-}  \n-\n-\n-/* Walks through all the subtrees of BODY using walk_tree to make sure\n-   invalid statements/expressions are not found inside BODY.  Returns\n-   false if any invalid statements are found.  */\n-\n-bool\n-cpp_validate_cilk_plus_loop (tree body)\n-{\n-  bool valid = true;\n-  cp_walk_tree (&body, cpp_validate_cilk_plus_loop_aux,\n-\t\t(void *) &valid, NULL);\n-  return valid;\n-}\n-\n-/* Sets the EXCEPTION bit (0x10) in the FRAME.flags field.  */\n-\n-static tree\n-set_cilk_except_flag (tree frame)\n-{\n-  tree flags = cilk_dot (frame, CILK_TI_FRAME_FLAGS, 0);\n-\n-  flags = build2 (MODIFY_EXPR, void_type_node, flags,\n-\t\t  build2 (BIT_IOR_EXPR, TREE_TYPE (flags), flags,\n-\t\t\t  build_int_cst (TREE_TYPE (flags),\n-\t\t\t\t\t CILK_FRAME_EXCEPTING)));\n-  return flags;\n-}\n-\n-/* Sets the frame.EXCEPT_DATA field to the head of the exception pointer.  */\n-\n-static tree\n-set_cilk_except_data (tree frame)\n-{\n-  tree except_data = cilk_dot (frame, CILK_TI_FRAME_EXCEPTION, 0);\n-  tree uresume_fn = builtin_decl_implicit (BUILT_IN_EH_POINTER);\n-  tree ret_expr;\n-  uresume_fn  = build_call_expr (uresume_fn, 1,\n-\t\t\t\t build_int_cst (integer_type_node, 0));\n-  ret_expr = build2 (MODIFY_EXPR, void_type_node, except_data, uresume_fn);\n-  return ret_expr;\n-}\n-\n-/* Installs BODY into function FNDECL with appropriate exception handling\n-   code.  WD holds information of wrapper function used to pass into the\n-   outlining function, cilk_outline.  */\n-\n-void\n-cilk_install_body_with_frame_cleanup (tree fndecl, tree orig_body, void *wd)\n-{\n-  tree frame = make_cilk_frame (fndecl);\n-  tree dtor = create_cilk_function_exit (frame, false, false);\n-  add_local_decl (cfun, frame);\n-\n-  cfun->language = ggc_cleared_alloc<language_function> ();\n-  \n-  location_t loc = EXPR_LOCATION (orig_body);\n-  tree list = alloc_stmt_list ();\n-  DECL_SAVED_TREE (fndecl) = list;\n-  tree body = alloc_stmt_list ();\n-  cilk_outline (fndecl, &orig_body, (struct wrapper_data *) wd);\n-  append_to_statement_list (orig_body, &body);\n-  if (flag_exceptions)\n-    {\n-      tree except_flag = set_cilk_except_flag (frame);\n-      tree except_data = set_cilk_except_data (frame);\n-      tree catch_list = alloc_stmt_list ();\n-      append_to_statement_list (except_flag, &catch_list);\n-      append_to_statement_list (except_data, &catch_list);\n-      body = create_try_catch_expr (body, catch_list);\n-    }\n-  append_to_statement_list (build_stmt (loc, TRY_FINALLY_EXPR, body, dtor),\n-\t\t\t    &list);\n-}"}, {"sha": "bfefc5a79488a9e6670cbfdc890b9a8c63336b6a", "filename": "gcc/cp/cp-cilkplus.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcp%2Fcp-cilkplus.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Fcp%2Fcp-cilkplus.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-cilkplus.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,28 +0,0 @@\n-/* C++-specific tree lowering bits; see also c-gimplify.c and tree-gimple.c.\n-\n-   Copyright (C) 2002-2017 Free Software Foundation, Inc.\n-   Contributed by Jason Merrill <jason@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_CP_CILKPLUS_H\n-#define GCC_CP_CILKPLUS_H\n-\n-extern bool cilk_cp_detect_spawn_and_unwrap (tree *);\n-extern bool cpp_validate_cilk_plus_loop (tree);\n-\n-#endif /* ! GCC_CP_CILKPLUS_H */"}, {"sha": "49fdd05ee246d53dad4d235be649c61a35997a57", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -31,8 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"gimplify.h\"\n #include \"c-family/c-ubsan.h\"\n-#include \"cilk.h\"\n-#include \"cp-cilkplus.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"asan.h\"\n@@ -628,25 +626,13 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t LHS of an assignment might also be involved in the RHS, as in bug\n \t 25979.  */\n     case INIT_EXPR:\n-      if (fn_contains_cilk_spawn_p (cfun))\n-\t{\n-\t  if (cilk_cp_detect_spawn_and_unwrap (expr_p))\n-\t    return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n-\t  if (seen_error () && contains_cilk_spawn_stmt (*expr_p))\n-\t    return GS_ERROR;\n-\t}\n-\n       cp_gimplify_init_expr (expr_p);\n       if (TREE_CODE (*expr_p) != INIT_EXPR)\n \treturn GS_OK;\n       /* Fall through.  */\n     case MODIFY_EXPR:\n     modify_expr_case:\n       {\n-\tif (fn_contains_cilk_spawn_p (cfun)\n-\t    && cilk_cp_detect_spawn_and_unwrap (expr_p)\n-\t    && !seen_error ())\n-\t  return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n \t/* If the back end isn't clever enough to know that the lhs and rhs\n \t   types are the same, add an explicit conversion.  */\n \ttree op0 = TREE_OPERAND (*expr_p, 0);\n@@ -759,19 +745,7 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       }\n       break;\n \n-    case CILK_SPAWN_STMT:\n-      gcc_assert(fn_contains_cilk_spawn_p (cfun)\n-\t\t && cilk_cp_detect_spawn_and_unwrap (expr_p));\n-\n-      if (!seen_error ())\n-        return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n-      return GS_ERROR;\n-\n     case CALL_EXPR:\n-      if (fn_contains_cilk_spawn_p (cfun)\n-\t  && cilk_cp_detect_spawn_and_unwrap (expr_p)\n-\t  && !seen_error ())\n-        return (enum gimplify_status) gimplify_cilk_spawn (expr_p);\n       ret = GS_OK;\n       if (!CALL_EXPR_FN (*expr_p))\n \t/* Internal function call.  */;\n@@ -1001,8 +975,7 @@ cp_fold_r (tree *stmt_p, int *walk_subtrees, void *data)\n \n   code = TREE_CODE (stmt);\n   if (code == OMP_FOR || code == OMP_SIMD || code == OMP_DISTRIBUTE\n-      || code == OMP_TASKLOOP || code == CILK_FOR || code == CILK_SIMD\n-      || code == OACC_LOOP)\n+      || code == OMP_TASKLOOP || code == OACC_LOOP)\n     {\n       tree x;\n       int i, n;\n@@ -1682,12 +1655,6 @@ cp_genericize (tree fndecl)\n   bc_label[bc_break] = NULL_TREE;\n   bc_label[bc_continue] = NULL_TREE;\n \n-  /* Expand all the array notations here.  */\n-  if (flag_cilkplus \n-      && contains_array_notation_expr (DECL_SAVED_TREE (fndecl)))\n-    DECL_SAVED_TREE (fndecl)\n-      = expand_array_notation_exprs (DECL_SAVED_TREE (fndecl));\n-\n   /* We do want to see every occurrence of the parms, so we can't just use\n      walk_tree's hash functionality.  */\n   cp_genericize_tree (&DECL_SAVED_TREE (fndecl), true);"}, {"sha": "59087df64c9ec2dab9a496df505f1ce472fac022", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -468,7 +468,6 @@ cp_common_init_ts (void)\n   MARK_TS_TYPED (USING_STMT);\n   MARK_TS_TYPED (LAMBDA_EXPR);\n   MARK_TS_TYPED (CTOR_INITIALIZER);\n-  MARK_TS_TYPED (ARRAY_NOTATION_REF);\n   MARK_TS_TYPED (REQUIRES_EXPR);\n   MARK_TS_TYPED (UNARY_LEFT_FOLD_EXPR);\n   MARK_TS_TYPED (UNARY_RIGHT_FOLD_EXPR);"}, {"sha": "bdfe3fdc497642692f3c99b831b0173015679c6a", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -7358,11 +7358,6 @@ extern void vtv_save_class_info                 (tree);\n extern void vtv_recover_class_info              (void);\n extern void vtv_build_vtable_verify_fndecl      (void);\n \n-/* In cp/cp-array-notations.c */\n-extern tree expand_array_notation_exprs         (tree);\n-bool cilkplus_an_triplet_types_ok_p             (location_t, tree, tree, tree,\n-\t\t\t\t\t\t tree);\n-\n /* In constexpr.c */\n extern void fini_constexpr\t\t\t(void);\n extern bool literal_type_p                      (tree);"}, {"sha": "9f557b8d00f1d612531623803c16cc0fec965491", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -48,7 +48,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ubsan.h\"\n #include \"debug.h\"\n #include \"plugin.h\"\n-#include \"cilk.h\"\n #include \"builtins.h\"\n #include \"gimplify.h\"\n #include \"asan.h\"\n@@ -8751,7 +8750,7 @@ grokfndecl (tree ctype,\n   if (TYPE_NOTHROW_P (type) || nothrow_libfn_p (decl))\n     TREE_NOTHROW (decl) = 1;\n \n-  if (flag_openmp || flag_openmp_simd || flag_cilkplus)\n+  if (flag_openmp || flag_openmp_simd)\n     {\n       /* Adjust \"omp declare simd\" attributes.  */\n       tree ods = lookup_attribute (\"omp declare simd\", *attrlist);\n@@ -15468,9 +15467,6 @@ finish_function (bool inline_p)\n   /* If we're saving up tree structure, tie off the function now.  */\n   DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));\n \n-  if (fn_contains_cilk_spawn_p (cfun) && !processing_template_decl)\n-    cfun->cilk_frame_decl = insert_cilk_frame (fndecl);\n-\n   finish_fname_decls ();\n \n   /* If this function can't throw any exceptions, remember that.  */"}, {"sha": "b6a8f9ecef891129b25f40dff402dbaab3e73705", "filename": "gcc/cp/error.c", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1201,17 +1201,6 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n       pp_cxx_right_bracket (pp);\n       break;\n \n-    case ARRAY_NOTATION_REF:\n-      dump_decl (pp, ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_left_bracket (pp);\n-      dump_decl (pp, ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (pp);\n-      dump_decl (pp, ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (pp);\n-      dump_decl (pp, ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_bracket (pp);\n-      break;\n-\n       /* So that we can do dump_decl on an aggr type.  */\n     case RECORD_TYPE:\n     case UNION_TYPE:\n@@ -2305,17 +2294,6 @@ dump_expr (cxx_pretty_printer *pp, tree t, int flags)\n       pp_cxx_right_bracket (pp);\n       break;\n \n-    case ARRAY_NOTATION_REF:\n-      dump_expr (pp, ARRAY_NOTATION_ARRAY (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_left_bracket (pp);\n-      dump_expr (pp, ARRAY_NOTATION_START (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (pp);\n-      dump_expr (pp, ARRAY_NOTATION_LENGTH (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_colon (pp);\n-      dump_expr (pp, ARRAY_NOTATION_STRIDE (t), flags | TFF_EXPR_IN_PARENS);\n-      pp_cxx_right_bracket (pp);\n-      break;\n-\n     case UNARY_PLUS_EXPR:\n       dump_unary_op (pp, \"+\", t, flags);\n       break;"}, {"sha": "8b8c1274bc6263f8e517e85861d8de2a039662f7", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -30,7 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"toplev.h\"\n #include \"gimplify.h\"\n-#include \"cp-cilkplus.h\"\n \n /* Constructor for a lambda expression.  */\n "}, {"sha": "b2de440072747ec423001864a56b5f15ef2a3dab", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 801, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -41,7 +41,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-offload.h\"\n #include \"c-family/c-indentation.h\"\n #include \"context.h\"\n-#include \"cp-cilkplus.h\"\n #include \"gcc-rich-location.h\"\n #include \"tree-iterator.h\"\n #include \"c-family/name-hint.h\"\n@@ -251,14 +250,8 @@ static cp_token_cache *cp_token_cache_new\n static void cp_parser_initial_pragma\n   (cp_token *);\n \n-static void cp_parser_cilk_simd\n-  (cp_parser *, cp_token *, bool *);\n-static tree cp_parser_cilk_for\n-  (cp_parser *, tree, bool *);\n static bool cp_parser_omp_declare_reduction_exprs\n   (tree, cp_parser *);\n-static tree cp_parser_cilk_simd_vectorlength \n-  (cp_parser *, tree, bool);\n static void cp_finalize_oacc_routine\n   (cp_parser *, tree, bool);\n \n@@ -557,8 +550,6 @@ cp_debug_parser (FILE *file, cp_parser *parser)\n \t\t\t      parser->in_statement & IN_SWITCH_STMT);\n   cp_debug_print_flag (file, \"Parsing a structured OpenMP block\",\n \t\t\t      parser->in_statement & IN_OMP_BLOCK);\n-  cp_debug_print_flag (file, \"Parsing a Cilk Plus for loop\",\n-\t\t\t      parser->in_statement & IN_CILK_SIMD_FOR);\n   cp_debug_print_flag (file, \"Parsing a an OpenMP loop\",\n \t\t\t      parser->in_statement & IN_OMP_FOR);\n   cp_debug_print_flag (file, \"Parsing an if statement\",\n@@ -2265,9 +2256,6 @@ static void cp_parser_ctor_initializer_opt_and_function_body\n static tree cp_parser_late_parsing_omp_declare_simd\n   (cp_parser *, tree);\n \n-static tree cp_parser_late_parsing_cilk_simd_fn_info\n-  (cp_parser *, tree);\n-\n static tree cp_parser_late_parsing_oacc_routine\n   (cp_parser *, tree);\n \n@@ -6619,7 +6607,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   cp_id_kind idk = CP_ID_KIND_NONE;\n   cp_expr postfix_expression = NULL_TREE;\n   bool is_member_access = false;\n-  int saved_in_statement = -1;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n@@ -6796,69 +6783,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n       }\n       break;\n \n-    case RID_CILK_SPAWN:\n-      {\n-\tlocation_t cilk_spawn_loc\n-\t  = cp_lexer_peek_token (parser->lexer)->location;\n-\tcp_lexer_consume_token (parser->lexer);\n-\ttoken = cp_lexer_peek_token (parser->lexer);\n-\tif (token->type == CPP_SEMICOLON)\n-\t  {\n-\t    error_at (token->location, \"%<_Cilk_spawn%> must be followed by \"\n-\t\t      \"an expression\");\n-\t    postfix_expression = error_mark_node;\n-\t    break;\n-\t  }\n-\telse if (!current_function_decl)\n-\t  {\n-\t    error_at (token->location, \"%<_Cilk_spawn%> may only be used \"\n-\t\t      \"inside a function\");\n-\t    postfix_expression = error_mark_node;\n-\t    break;\n-\t  }\n-\telse\n-\t  {\n-\t    /* Consecutive _Cilk_spawns are not allowed in a statement.  */\n-\t    saved_in_statement = parser->in_statement;\n-\t    parser->in_statement |= IN_CILK_SPAWN;\n-\t  }\n-\tcfun->calls_cilk_spawn = 1;\n-\tpostfix_expression = \n-\t  cp_parser_postfix_expression (parser, false, false, \n-\t\t\t\t\tfalse, false, &idk);\n-\tif (!flag_cilkplus)\n-\t  {\n-\t    error_at (token->location, \"-fcilkplus must be enabled to use\"\n-\t\t      \" %<_Cilk_spawn%>\");\n-\t    cfun->calls_cilk_spawn = 0;\n-\t  }\n-\telse if (saved_in_statement & IN_CILK_SPAWN)\n-\t  {\n-\t    error_at (token->location, \"consecutive %<_Cilk_spawn%> keywords \"\n-\t\t      \"are not permitted\");\n-\t    postfix_expression = error_mark_node;\n-\t    cfun->calls_cilk_spawn = 0; \n-\t  }\n-\telse\n-\t  {\n-\t    location_t loc = postfix_expression.get_location ();\n-\t    postfix_expression = build_cilk_spawn (token->location, \n-\t\t\t\t\t\t   postfix_expression);\n-\t    /* Build a location of the form:\n-\t\t _Cilk_spawn expr\n-\t\t ~~~~~~~~~~~~^~~~\n-\t       with caret at the expr, ranging from the start of the\n-\t       _Cilk_spawn token to the end of the expression.  */\n-\t    location_t combined_loc =\n-\t      make_location (loc, cilk_spawn_loc, get_finish (loc));\n-\t    postfix_expression.set_location (combined_loc);\n-\t    if (postfix_expression != error_mark_node) \n-\t      SET_EXPR_LOCATION (postfix_expression, input_location);\n-\t    parser->in_statement = parser->in_statement & ~IN_CILK_SPAWN;\n-\t  }\n-\tbreak;\n-      }\n-\n     case RID_ADDRESSOF:\n     case RID_BUILTIN_SHUFFLE:\n     case RID_BUILTIN_LAUNDER:\n@@ -7320,92 +7244,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   return error_mark_node;\n }\n \n-/* This function parses Cilk Plus array notations.  If a normal array expr. is\n-   parsed then the array index is passed back to the caller through *INIT_INDEX \n-   and the function returns a NULL_TREE.  If array notation expr. is parsed, \n-   then *INIT_INDEX is ignored by the caller and the function returns \n-   a tree of type ARRAY_NOTATION_REF.  If some error occurred it returns \n-   error_mark_node.  */\n-\n-static tree\n-cp_parser_array_notation (location_t loc, cp_parser *parser, tree *init_index,\n-\t\t\t  tree array_value)\n-{\n-  cp_token *token = NULL;\n-  tree length_index, stride = NULL_TREE, value_tree, array_type;\n-  if (!array_value || array_value == error_mark_node)\n-    {\n-      cp_parser_skip_to_end_of_statement (parser);\n-      return error_mark_node;\n-    }\n-\n-  array_type = TREE_TYPE (array_value);\n-  \n-  bool saved_colon_corrects = parser->colon_corrects_to_scope_p;\n-  parser->colon_corrects_to_scope_p = false;\n-  token = cp_lexer_peek_token (parser->lexer);\n-  \n-  if (!token)\n-    {\n-      cp_parser_error (parser, \"expected %<:%> or numeral\");\n-      return error_mark_node;\n-    }\n-  else if (token->type == CPP_COLON)\n-    {\n-      /* Consume the ':'.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      \n-      /* If we are here, then we have a case like this A[:].  */\n-      if (cp_lexer_peek_token (parser->lexer)->type != CPP_CLOSE_SQUARE)\n-\t{\n-\t  cp_parser_error (parser, \"expected %<]%>\");\n-\t  cp_parser_skip_to_end_of_statement (parser);\n-\t  return error_mark_node;\n-\t}\n-      *init_index = NULL_TREE;\n-      stride = NULL_TREE;\n-      length_index = NULL_TREE;\n-    }\n-  else\n-    {\n-      /* If we are here, then there are three valid possibilities:\n-\t 1. ARRAY [ EXP ]\n-\t 2. ARRAY [ EXP : EXP ]\n-\t 3. ARRAY [ EXP : EXP : EXP ]  */\n-\n-      *init_index = cp_parser_expression (parser);\n-      if (cp_lexer_peek_token (parser->lexer)->type != CPP_COLON)\n-\t{  \n-\t  /* This indicates that we have a normal array expression.  */\n-\t  parser->colon_corrects_to_scope_p = saved_colon_corrects;\n-\t  return NULL_TREE;\n-\t}\n-      \n-      /* Consume the ':'.  */\n-      cp_lexer_consume_token (parser->lexer);\n-      length_index = cp_parser_expression (parser);\n-      if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  stride = cp_parser_expression (parser);\n-\t}\n-    }\n-  parser->colon_corrects_to_scope_p = saved_colon_corrects;\n-\n-  if (*init_index == error_mark_node || length_index == error_mark_node\n-      || stride == error_mark_node || array_type == error_mark_node)\n-    {\n-      if (cp_lexer_peek_token (parser->lexer)->type == CPP_CLOSE_SQUARE)\n-\tcp_lexer_consume_token (parser->lexer);\n-      return error_mark_node;\n-    }\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-\n-  value_tree = build_array_notation_ref (loc, array_value, *init_index, \n-\t\t\t\t\t length_index, stride, array_type);\n-  return value_tree;\n-}\n-\n /* A subroutine of cp_parser_postfix_expression that also gets hijacked\n    by cp_parser_builtin_offsetof.  We're looking for\n \n@@ -7449,27 +7287,6 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t  cp_lexer_set_source_position (parser->lexer);\n \t  maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n \t  index = cp_parser_braced_list (parser, &expr_nonconst_p);\n-\t  if (flag_cilkplus\n-\t      && cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-\t    {\n-\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\t\"braced list index is not allowed with array \"\n-\t\t\t\"notation\");\n-\t      cp_parser_skip_to_end_of_statement (parser);\n-\t      return error_mark_node;\n-\t    }\n-\t}\n-      else if (flag_cilkplus)\n-\t{\n-\t  /* Here are have these two options:\n-\t     ARRAY[EXP : EXP]        - Array notation expr with default\n-\t     stride of 1.\n-\t     ARRAY[EXP : EXP : EXP] - Array Notation with user-defined\n-\t     stride.  */\n-\t  tree an_exp = cp_parser_array_notation (loc, parser, &index, \n-\t\t\t\t\t\t  postfix_expression);\n-\t  if (an_exp)\n-\t    return an_exp;\n \t}\n       else\n \tindex = cp_parser_expression (parser);\n@@ -10881,43 +10698,13 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  statement = cp_parser_iteration_statement (parser, if_p, false);\n \t  break;\n \n-\tcase RID_CILK_FOR:\n-\t  if (!flag_cilkplus)\n-\t    {\n-\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\t\"-fcilkplus must be enabled to use %<_Cilk_for%>\");\n-\t      cp_lexer_consume_token (parser->lexer);\n-\t      statement = error_mark_node;\n-\t    }\n-\t  else\n-\t    statement = cp_parser_cilk_for (parser, integer_zero_node, if_p);\n-\t  break;\n-\n \tcase RID_BREAK:\n \tcase RID_CONTINUE:\n \tcase RID_RETURN:\n \tcase RID_GOTO:\n \t  statement = cp_parser_jump_statement (parser);\n \t  break;\n \n-\tcase RID_CILK_SYNC:\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  if (flag_cilkplus)\n-\t    {\n-\t      tree sync_expr = build_cilk_sync ();\n-\t      SET_EXPR_LOCATION (sync_expr,\n-\t\t\t\t token->location);\n-\t      statement = finish_expr_stmt (sync_expr);\n-\t    }\n-\t  else\n-\t    {\n-\t      error_at (token->location, \"-fcilkplus must be enabled to use\"\n-\t\t\t\" %<_Cilk_sync%>\");\n-\t      statement = error_mark_node;\n-\t    }\n-\t  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n-\t  break;\n-\n \t  /* Objective-C++ exception-handling constructs.  */\n \tcase RID_AT_TRY:\n \tcase RID_AT_CATCH:\n@@ -12433,9 +12220,6 @@ cp_parser_jump_statement (cp_parser* parser)\n \tcase IN_OMP_FOR:\n \t  error_at (token->location, \"break statement used with OpenMP for loop\");\n \t  break;\n-\tcase IN_CILK_SIMD_FOR:\n-\t  error_at (token->location, \"break statement used with Cilk Plus for loop\");\n-\t  break;\n \t}\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n       break;\n@@ -12446,9 +12230,6 @@ cp_parser_jump_statement (cp_parser* parser)\n \tcase 0:\n \t  error_at (token->location, \"continue statement not within a loop\");\n \t  break;\n-\tcase IN_CILK_SIMD_FOR:\n-\t  error_at (token->location,\n-\t\t    \"continue statement within %<#pragma simd%> loop body\");\n \t  /* Fall through.  */\n \tcase IN_ITERATION_STMT:\n \tcase IN_OMP_FOR:\n@@ -20072,21 +19853,6 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t     the function declaration.  For example:\n \t\t     void func (int x) __attribute__((vector(..)));  */\n \t\t  tree gnu_attrs = NULL_TREE;\n-\t\t  if (flag_cilkplus\n-\t\t      && cp_next_tokens_can_be_gnu_attribute_p (parser))\n-\t\t    {\n-\t\t      cp_parser_parse_tentatively (parser);\n-\t\t      tree attr = cp_parser_gnu_attributes_opt (parser);\n-\t\t      if (cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t\t      CPP_SEMICOLON)\n-\t\t\t  && cp_lexer_next_token_is_not (parser->lexer,\n-\t\t\t\t\t\t\t CPP_OPEN_BRACE))\n-\t\t\tcp_parser_abort_tentative_parse (parser);\n-\t\t      else if (!cp_parser_parse_definitely (parser))\n-\t\t\t;\n-\t\t      else\n-\t\t\tgnu_attrs = attr;\n-\t\t    }\n \t\t  tree requires_clause = NULL_TREE;\n \t\t  late_return = (cp_parser_late_return_type_opt\n \t\t\t\t (parser, declarator, requires_clause,\n@@ -20891,9 +20657,6 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n \t\t\t && declarator\n \t\t\t && declarator->kind == cdk_id);\n \n-  bool cilk_simd_fn_vector_p = (parser->cilk_simd_fn_info \n-\t\t\t\t&& declarator && declarator->kind == cdk_id);\n-\n   bool oacc_routine_p = (parser->oacc_routine\n \t\t\t && declarator\n \t\t\t && declarator->kind == cdk_id);\n@@ -20905,7 +20668,7 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n       && token->keyword != RID_REQUIRES\n       && !(token->type == CPP_NAME\n \t   && token->u.value == ridpointers[RID_REQUIRES])\n-      && !(declare_simd_p || cilk_simd_fn_vector_p || oacc_routine_p))\n+      && !(declare_simd_p || oacc_routine_p))\n     return NULL_TREE;\n \n   tree save_ccp = current_class_ptr;\n@@ -20928,10 +20691,6 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n      requires-clause.  */\n   requires_clause = cp_parser_requires_clause_opt (parser);\n \n-  if (cilk_simd_fn_vector_p)\n-    declarator->attributes\n-      = cp_parser_late_parsing_cilk_simd_fn_info (parser,\n-\t\t\t\t\t\t  declarator->attributes);\n   if (declare_simd_p)\n     declarator->attributes\n       = cp_parser_late_parsing_omp_declare_simd (parser,\n@@ -24995,57 +24754,6 @@ cp_parser_attributes_opt (cp_parser *parser)\n   return cp_parser_std_attribute_spec_seq (parser);\n }\n \n-#define CILK_SIMD_FN_CLAUSE_MASK\t\t\t\t  \\\n-\t((OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_VECTORLENGTH)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_LINEAR)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_UNIFORM)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_MASK)\t  \\\n-\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_NOMASK))\n-\n-/* Parses the Cilk Plus SIMD-enabled function's attribute.  Syntax:\n-   vector [(<clauses>)]  */\n-\n-static void\n-cp_parser_cilk_simd_fn_vector_attrs (cp_parser *parser, cp_token *v_token)\n-{  \n-  bool first_p = parser->cilk_simd_fn_info == NULL;\n-  cp_token *token = v_token;\n-  if (first_p)\n-    {\n-      parser->cilk_simd_fn_info = XNEW (cp_omp_declare_simd_data);\n-      parser->cilk_simd_fn_info->error_seen = false;\n-      parser->cilk_simd_fn_info->fndecl_seen = false;\n-      parser->cilk_simd_fn_info->tokens = vNULL;\n-      parser->cilk_simd_fn_info->clauses = NULL_TREE;\n-    }\n-  int paren_scope = 0;\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      v_token = cp_lexer_peek_token (parser->lexer);\n-      paren_scope++;\n-    }\n-  while (paren_scope > 0)\n-    {\n-      token = cp_lexer_peek_token (parser->lexer);\n-      if (token->type == CPP_OPEN_PAREN)\n-\tparen_scope++;\n-      else if (token->type == CPP_CLOSE_PAREN)\n-\tparen_scope--;\n-      /* Do not push the last ')'  */\n-      if (!(token->type == CPP_CLOSE_PAREN && paren_scope == 0))\n-\tcp_lexer_consume_token (parser->lexer);\n-    }\n-\n-  token->type = CPP_PRAGMA_EOL;\n-  parser->lexer->next_token = token;\n-  cp_lexer_consume_token (parser->lexer);\n-\n-  struct cp_token_cache *cp\n-    = cp_token_cache_new (v_token, cp_lexer_peek_token (parser->lexer));\n-  parser->cilk_simd_fn_info->tokens.safe_push (cp);\n-}\n-\n /* Parse an (optional) series of attributes.\n \n    attributes:\n@@ -25167,16 +24875,10 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t      vec<tree, va_gc> *vec;\n \t      int attr_flag = (attribute_takes_identifier_p (identifier)\n \t\t\t       ? id_attr : normal_attr);\n-\t      if (is_cilkplus_vector_p (identifier))\n-\t\t{\n-\t\t  cp_parser_cilk_simd_fn_vector_attrs (parser, id_token);\n-\t\t  continue;\n-\t\t}\n-\t      else\n-\t\tvec = cp_parser_parenthesized_expression_list \n-\t\t  (parser, attr_flag, /*cast_p=*/false, \n-\t\t   /*allow_expansion_p=*/false, \n-\t\t   /*non_constant_p=*/NULL);\n+\t      vec = cp_parser_parenthesized_expression_list \n+\t\t    (parser, attr_flag, /*cast_p=*/false, \n+\t\t    /*allow_expansion_p=*/false, \n+\t\t    /*non_constant_p=*/NULL);\n \t      if (vec == NULL)\n \t\targuments = error_mark_node;\n \t      else\n@@ -25187,11 +24889,6 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t      /* Save the arguments away.  */\n \t      TREE_VALUE (attribute) = arguments;\n \t    }\n-\t  else if (is_cilkplus_vector_p (identifier))\n-\t    {\n-\t      cp_parser_cilk_simd_fn_vector_attrs (parser, id_token);\n-\t      continue;\n-\t    }\n \n \t  if (arguments != error_mark_node)\n \t    {\n@@ -31301,8 +30998,6 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_MAP;\n \t  else if (!strcmp (\"mergeable\", p))\n \t    result = PRAGMA_OMP_CLAUSE_MERGEABLE;\n-\t  else if (flag_cilkplus && !strcmp (\"mask\", p))\n-\t    result = PRAGMA_CILK_CLAUSE_MASK;\n \t  break;\n \tcase 'n':\n \t  if (!strcmp (\"nogroup\", p))\n@@ -31311,8 +31006,6 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n-\t  else if (flag_cilkplus && !strcmp (\"nomask\", p))\n-\t    result = PRAGMA_CILK_CLAUSE_NOMASK;\n \t  else if (!strcmp (\"num_gangs\", p))\n \t    result = PRAGMA_OACC_CLAUSE_NUM_GANGS;\n \t  else if (!strcmp (\"num_tasks\", p))\n@@ -31399,8 +31092,6 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OACC_CLAUSE_VECTOR;\n \t  else if (!strcmp (\"vector_length\", p))\n \t    result = PRAGMA_OACC_CLAUSE_VECTOR_LENGTH;\n-\t  else if (flag_cilkplus && !strcmp (\"vectorlength\", p))\n-\t    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n \t  break;\n \tcase 'w':\n \t  if (!strcmp (\"wait\", p))\n@@ -33037,7 +32728,7 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n \n static tree\n cp_parser_omp_clause_linear (cp_parser *parser, tree list, \n-\t\t\t     bool is_cilk_simd_fn, bool declare_simd)\n+\t\t\t     bool declare_simd)\n {\n   tree nlist, c, step = integer_one_node;\n   bool colon;\n@@ -33047,8 +32738,7 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n   if (!parens.require_open (parser))\n     return list;\n \n-  if (!is_cilk_simd_fn\n-      && cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n     {\n       tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n       const char *p = IDENTIFIER_POINTER (id);\n@@ -33107,11 +32797,6 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n       if (!step)\n \tstep = cp_parser_expression (parser);\n \n-      if (is_cilk_simd_fn && TREE_CODE (step) == PARM_DECL)\n-\t{\n-\t  sorry (\"using parameters for %<linear%> step is not supported yet\");\n-\t  step = integer_one_node;\n-\t}\n       if (!parens.require_close (parser))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n@@ -33967,13 +33652,11 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"untied\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_INBRANCH:\n-\tcase PRAGMA_CILK_CLAUSE_MASK:\n \t  clauses = cp_parser_omp_clause_branch (parser, OMP_CLAUSE_INBRANCH,\n \t\t\t\t\t\t clauses, token->location);\n \t  c_name = \"inbranch\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOTINBRANCH:\n-\tcase PRAGMA_CILK_CLAUSE_NOMASK:\n \t  clauses = cp_parser_omp_clause_branch (parser,\n \t\t\t\t\t\t OMP_CLAUSE_NOTINBRANCH,\n \t\t\t\t\t\t clauses, token->location);\n@@ -34049,13 +33732,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINEAR:\n \t  {\n-\t    bool cilk_simd_fn = false, declare_simd = false;\n-\t    if (((mask >> PRAGMA_CILK_CLAUSE_VECTORLENGTH) & 1) != 0)\n-\t      cilk_simd_fn = true;\n-\t    else if (((mask >> PRAGMA_OMP_CLAUSE_UNIFORM) & 1) != 0)\n+\t    bool declare_simd = false;\n+\t    if (((mask >> PRAGMA_OMP_CLAUSE_UNIFORM) & 1) != 0)\n \t      declare_simd = true;\n-\t    clauses = cp_parser_omp_clause_linear (parser, clauses,\n-\t\t\t\t\t\t   cilk_simd_fn, declare_simd);\n+\t    clauses = cp_parser_omp_clause_linear (parser, clauses, declare_simd);\n \t  }\n \t  c_name = \"linear\";\n \t  break;\n@@ -34110,10 +33790,6 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\tclauses, token->location);\n \t  c_name = \"simd\";\n \t  break;\n-\tcase PRAGMA_CILK_CLAUSE_VECTORLENGTH:\n-\t  clauses = cp_parser_cilk_simd_vectorlength (parser, clauses, true);\n-\t  c_name = \"simdlen\";\n-\t  break;\n \tdefault:\n \t  cp_parser_error (parser, \"expected %<#pragma omp%> clause\");\n \t  goto saw_error;\n@@ -34130,10 +33806,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t}\n     }\n  saw_error:\n-  /* In Cilk Plus SIMD enabled functions there is no pragma_token, so\n-     no reason to skip to the end.  */\n-  if (!(flag_cilkplus && pragma_tok == NULL))\n-    cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n   if (finish_p)\n     {\n       if ((mask & (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_UNIFORM)) != 0)\n@@ -34692,7 +34365,7 @@ cp_parser_omp_flush (cp_parser *parser, cp_token *pragma_tok)\n /* Helper function, to parse omp for increment expression.  */\n \n static tree\n-cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n+cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n {\n   tree cond = cp_parser_binary_expression (parser, false, true,\n \t\t\t\t\t   PREC_NOT_OPERATOR, NULL);\n@@ -34711,8 +34384,6 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n     case LE_EXPR:\n       break;\n     case NE_EXPR:\n-      if (code == CILK_SIMD || code == CILK_FOR)\n-\tbreak;\n       /* Fall through: OpenMP disallows NE_EXPR.  */\n       gcc_fallthrough ();\n     default:\n@@ -34838,7 +34509,6 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \n static tree\n cp_parser_omp_for_loop_init (cp_parser *parser,\n-\t\t\t     enum tree_code code,\n \t\t\t     tree &this_pre_body,\n \t\t\t     vec<tree, va_gc> *for_block,\n \t\t\t     tree &init,\n@@ -34901,14 +34571,8 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t    {\n \t      if (cp_lexer_next_token_is (parser->lexer, \n \t\t\t\t\t  CPP_OPEN_PAREN))\n-\t\t{\n-\t\t  if (code != CILK_SIMD && code != CILK_FOR)\n-\t\t    error (\"parenthesized initialization is not allowed in \"\n-\t\t\t   \"OpenMP %<for%> loop\");\n-\t\t  else\n-\t\t    error (\"parenthesized initialization is \"\n-\t\t\t   \"not allowed in for-loop\");\n-\t\t}\n+\t        error (\"parenthesized initialization is not allowed in \"\n+\t\t       \"OpenMP %<for%> loop\");\n \t      else\n \t\t/* Trigger an error.  */\n \t\tcp_parser_require (parser, CPP_EQ, RT_EQ);\n@@ -35001,9 +34665,6 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n       cp_id_kind idk;\n       /* If parsing a type specifier sequence failed, then\n \t this MUST be a simple expression.  */\n-      if (code == CILK_FOR)\n-\terror (\"%<_Cilk_for%> allows expression instead of declaration only \"\n-\t       \"in C, not in C++\");\n       cp_parser_parse_tentatively (parser);\n       decl = cp_parser_primary_expression (parser, false, false,\n \t\t\t\t\t   false, &idk);\n@@ -35137,20 +34798,12 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       tree add_private_clause = NULL_TREE;\n       location_t loc;\n \n-      if (code != CILK_FOR\n-\t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n+      if (!cp_lexer_next_token_is_keyword (parser->lexer, RID_FOR))\n \t{\n \t  if (!collapse_err)\n \t    cp_parser_error (parser, \"for statement expected\");\n \t  return NULL;\n \t}\n-      if (code == CILK_FOR\n-\t  && !cp_lexer_next_token_is_keyword (parser->lexer, RID_CILK_FOR))\n-\t{\n-\t  if (!collapse_err)\n-\t    cp_parser_error (parser, \"_Cilk_for statement expected\");\n-\t  return NULL;\n-\t}\n       loc = cp_lexer_consume_token (parser->lexer)->location;\n \n       matching_parens parens;\n@@ -35161,8 +34814,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n       this_pre_body = push_stmt_list ();\n \n       add_private_clause\n-\t= cp_parser_omp_for_loop_init (parser, code,\n-\t\t\t\t       this_pre_body, for_block,\n+\t= cp_parser_omp_for_loop_init (parser, this_pre_body, for_block,\n \t\t\t\t       init, orig_init, decl, real_decl);\n \n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n@@ -35266,7 +34918,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n       cond = NULL;\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\tcond = cp_parser_omp_for_cond (parser, decl, code);\n+\tcond = cp_parser_omp_for_cond (parser, decl);\n       cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n       incr = NULL;\n@@ -35344,10 +34996,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \n   /* Note that we saved the original contents of this flag when we entered\n      the structured block, and so we don't need to re-save it here.  */\n-  if (code == CILK_SIMD || code == CILK_FOR)\n-    parser->in_statement = IN_CILK_SIMD_FOR;\n-  else\n-    parser->in_statement = IN_OMP_FOR;\n+  parser->in_statement = IN_OMP_FOR;\n \n   /* Note that the grammar doesn't call for a structured block here,\n      though the loop as a whole is a structured block.  */\n@@ -37272,67 +36921,6 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n     }\n }\n \n-/* Handles the delayed parsing of the Cilk Plus SIMD-enabled function.  \n-   This function is modelled similar to the late parsing of omp declare \n-   simd.  */\n-\n-static tree\n-cp_parser_late_parsing_cilk_simd_fn_info (cp_parser *parser, tree attrs)\n-{\n-  struct cp_token_cache *ce;\n-  cp_omp_declare_simd_data *info = parser->cilk_simd_fn_info;\n-  int ii = 0;\n-\n-  if (parser->omp_declare_simd != NULL\n-      || lookup_attribute (\"simd\", attrs))\n-    {\n-      error (\"%<#pragma omp declare simd%> or %<simd%> attribute cannot be \"\n-\t     \"used in the same function marked as a Cilk Plus SIMD-enabled \"\n-\t     \"function\");\n-      parser->cilk_simd_fn_info->tokens.release ();\n-      XDELETE (parser->cilk_simd_fn_info);\n-      parser->cilk_simd_fn_info = NULL;\n-      return attrs;\n-    }\n-  if (!info->error_seen && info->fndecl_seen)\n-    {\n-      error (\"vector attribute not immediately followed by a single function\"\n-\t     \" declaration or definition\");\n-      info->error_seen = true;\n-    }\n-  if (info->error_seen)\n-    return attrs;\n-\n-  FOR_EACH_VEC_ELT (info->tokens, ii, ce)\n-    {\n-      tree c, cl;\n-\n-      cp_parser_push_lexer_for_tokens (parser, ce);\n-      parser->lexer->in_pragma = true;\n-      cl = cp_parser_omp_all_clauses (parser, CILK_SIMD_FN_CLAUSE_MASK,\n-\t\t\t\t      \"SIMD-enabled functions attribute\", \n-\t\t\t\t      NULL);\n-      cp_parser_pop_lexer (parser);\n-      if (cl)\n-\tcl = tree_cons (NULL_TREE, cl, NULL_TREE);\n-\n-      c = build_tree_list (get_identifier (\"cilk simd function\"), NULL_TREE);\n-      TREE_CHAIN (c) = attrs;\n-      attrs = c;\n-\n-      c = build_tree_list (get_identifier (\"omp declare simd\"), cl);\n-      TREE_CHAIN (c) = attrs;\n-      if (processing_template_decl)\n-\tATTR_IS_DEPENDENT (c) = 1;\n-      attrs = c;\n-    }\n-  info->fndecl_seen = true;\n-  parser->cilk_simd_fn_info->tokens.release ();\n-  XDELETE (parser->cilk_simd_fn_info);\n-  parser->cilk_simd_fn_info = NULL;\n-  return attrs;\n-}\n-\n /* Finalize #pragma omp declare simd clauses after direct declarator has\n    been parsed, and put that into \"omp declare simd\" attribute.  */\n \n@@ -38720,36 +38308,6 @@ cp_parser_initial_pragma (cp_token *first_token)\n   cp_lexer_get_preprocessor_token (NULL, first_token);\n }\n \n-/* Parses the grainsize pragma for the _Cilk_for statement.\n-   Syntax:\n-   #pragma cilk grainsize = <VALUE>.  */\n-\n-static void\n-cp_parser_cilk_grainsize (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n-{\n-  if (cp_parser_require (parser, CPP_EQ, RT_EQ))\n-    {\n-      tree exp = cp_parser_binary_expression (parser, false, false,\n-\t\t\t\t\t      PREC_NOT_OPERATOR, NULL);\n-      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-      if (!exp || exp == error_mark_node)\n-\t{\n-\t  error_at (pragma_tok->location, \"invalid grainsize for _Cilk_for\");\n-\t  return;\n-\t}\n-\n-      /* Make sure the next token is _Cilk_for, it is invalid otherwise.  */\n-      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CILK_FOR))\n-\tcp_parser_cilk_for (parser, exp, if_p);\n-      else\n-\twarning_at (cp_lexer_peek_token (parser->lexer)->location, 0,\n-\t\t    \"%<#pragma cilk grainsize%> is not followed by \"\n-\t\t    \"%<_Cilk_for%>\");\n-      return;\n-    }\n-  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n-}\n-\n /* Normal parsing of a pragma token.  Here we can (and must) use the\n    regular lexer.  */\n \n@@ -39005,39 +38563,6 @@ cp_parser_pragma (cp_parser *parser, enum pragma_context context, bool *if_p)\n \treturn true;\n       }\n \n-    case PRAGMA_CILK_SIMD:\n-      if (context == pragma_external)\n-\t{\n-\t  error_at (pragma_tok->location,\n-\t\t    \"%<#pragma simd%> must be inside a function\");\n-\t  break;\n-\t}\n-      stmt = push_omp_privatization_clauses (false);\n-      cp_parser_cilk_simd (parser, pragma_tok, if_p);\n-      pop_omp_privatization_clauses (stmt);\n-      return true;\n-\n-    case PRAGMA_CILK_GRAINSIZE:\n-      if (context == pragma_external)\n-\t{\n-\t  error_at (pragma_tok->location,\n-\t\t    \"%<#pragma cilk grainsize%> must be inside a function\");\n-\t  break;\n-\t}\n-\n-      /* Ignore the pragma if Cilk Plus is not enabled.  */\n-      if (flag_cilkplus)\n-\t{\n-\t  cp_parser_cilk_grainsize (parser, pragma_tok, if_p);\n-\t  return true;\n-\t}\n-      else\n-\t{\n-\t  error_at (pragma_tok->location, \"-fcilkplus must be enabled to use \"\n-\t\t    \"%<#pragma cilk grainsize%>\");\n-\t  break;\n-\t}\n-\n     default:\n       gcc_assert (id >= PRAGMA_FIRST_EXTERNAL);\n       c_invoke_pragma_handler (id);\n@@ -39100,314 +38625,6 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n-/* Parses the Cilk Plus #pragma simd and SIMD-enabled function attribute's \n-   vectorlength clause:\n-   Syntax:\n-   vectorlength ( constant-expression )  */\n-\n-static tree\n-cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n-\t\t\t\t  bool is_simd_fn)\n-{\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-  tree expr;\n-  /* The vectorlength clause in #pragma simd behaves exactly like OpenMP's\n-     safelen clause.  Thus, vectorlength is represented as OMP 4.0\n-     safelen.  For SIMD-enabled function it is represented by OMP 4.0\n-     simdlen.  */\n-  if (!is_simd_fn)\n-    check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\", \n-\t\t\t       loc);\n-  else\n-    check_no_duplicate_clause (clauses, OMP_CLAUSE_SIMDLEN, \"vectorlength\",\n-\t\t\t       loc);\n-\n-  matching_parens parens;\n-  if (!parens.require_open (parser))\n-    return error_mark_node;\n-\n-  expr = cp_parser_constant_expression (parser);\n-  expr = maybe_constant_value (expr);\n-\n-  /* If expr == error_mark_node, then don't emit any errors nor\n-     create a clause.  if any of the above functions returns\n-     error mark node then they would have emitted an error message.  */\n-  if (expr == error_mark_node)\n-    ;\n-  else if (!TREE_TYPE (expr)\n-\t   || !TREE_CONSTANT (expr)\n-\t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n-    error_at (loc, \"vectorlength must be an integer constant\");\n-  else if (TREE_CONSTANT (expr)\n-\t   && !pow2p_hwi (TREE_INT_CST_LOW (expr)))\n-    error_at (loc, \"vectorlength must be a power of 2\");\n-  else \n-    {\n-      tree c;\n-      if (!is_simd_fn)\n-\t{ \n-\t  c = build_omp_clause (loc, OMP_CLAUSE_SAFELEN); \n-\t  OMP_CLAUSE_SAFELEN_EXPR (c) = expr; \n-\t  OMP_CLAUSE_CHAIN (c) = clauses; \n-\t  clauses = c;\n-\t}\n-      else\n-\t{\n-\t  c = build_omp_clause (loc, OMP_CLAUSE_SIMDLEN);\n-\t  OMP_CLAUSE_SIMDLEN_EXPR (c) = expr;\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-    }\n-\n-  if (!parens.require_close (parser))\n-    return error_mark_node;\n-  return clauses;\n-}\n-\n-/* Handles the Cilk Plus #pragma simd linear clause.\n-   Syntax:\n-   linear ( simd-linear-variable-list )\n-\n-   simd-linear-variable-list:\n-     simd-linear-variable\n-     simd-linear-variable-list , simd-linear-variable\n-\n-   simd-linear-variable:\n-     id-expression\n-     id-expression : simd-linear-step\n-\n-   simd-linear-step:\n-   conditional-expression */\n-\n-static tree\n-cp_parser_cilk_simd_linear (cp_parser *parser, tree clauses)\n-{\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n-    return clauses;\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n-    {\n-      cp_parser_error (parser, \"expected identifier\");\n-      cp_parser_skip_to_closing_parenthesis (parser, false, false, true);\n-      return error_mark_node;\n-    }\n-\n-  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n-  parser->colon_corrects_to_scope_p = false;\n-  while (1)\n-    {\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n-\t{\n-\t  cp_parser_error (parser, \"expected variable-name\");\n-\t  clauses = error_mark_node;\n-\t  break;\n-\t}\n-\n-      tree var_name = cp_parser_id_expression (parser, false, true, NULL,\n-\t\t\t\t\t       false, false);\n-      tree decl = cp_parser_lookup_name_simple (parser, var_name,\n-\t\t\t\t\t\ttoken->location);\n-      if (decl == error_mark_node)\n-\t{\n-\t  cp_parser_name_lookup_error (parser, var_name, decl, NLE_NULL,\n-\t\t\t\t       token->location);\n-\t  clauses = error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  tree e = NULL_TREE;\n-\t  tree step_size = integer_one_node;\n-\n-\t  /* If present, parse the linear step.  Otherwise, assume the default\n-\t     value of 1.  */\n-\t  if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n-\t    {\n-\t      cp_lexer_consume_token (parser->lexer);\n-\n-\t      e = cp_parser_assignment_expression (parser);\n-\t      e = maybe_constant_value (e);\n-\n-\t      if (e == error_mark_node)\n-\t\t{\n-\t\t  /* If an error has occurred,  then the whole pragma is\n-\t\t     considered ill-formed.  Thus, no reason to keep\n-\t\t     parsing.  */\n-\t\t  clauses = error_mark_node;\n-\t\t  break;\n-\t\t}\n-\t      else if (type_dependent_expression_p (e)\n-\t\t       || value_dependent_expression_p (e)\n-\t\t       || (TREE_TYPE (e)\n-\t\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (e))\n-\t\t\t   && (TREE_CONSTANT (e)\n-\t\t\t       || DECL_P (e))))\n-\t\tstep_size = e;\n-\t      else\n-\t\tcp_parser_error (parser,\n-\t\t\t\t \"step size must be an integer constant \"\n-\t\t\t\t \"expression or an integer variable\");\n-\t    }\n-\n-\t  /* Use the OMP_CLAUSE_LINEAR,  which has the same semantics.  */\n-\t  tree l = build_omp_clause (loc, OMP_CLAUSE_LINEAR);\n-\t  OMP_CLAUSE_DECL (l) = decl;\n-\t  OMP_CLAUSE_LINEAR_STEP (l) = step_size;\n-\t  OMP_CLAUSE_CHAIN (l) = clauses;\n-\t  clauses = l;\n-\t}\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n-      else if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n-\tbreak;\n-      else\n-\t{\n-\t  error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t    \"expected %<,%> or %<)%> after %qE\", decl);\n-\t  clauses = error_mark_node;\n-\t  break;\n-\t}\n-    }\n-  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n-  cp_parser_skip_to_closing_parenthesis (parser, false, false, true);\n-  return clauses;\n-}\n-\n-/* Returns the name of the next clause.  If the clause is not\n-   recognized, then PRAGMA_CILK_CLAUSE_NONE is returned and the next\n-   token is not consumed.  Otherwise, the appropriate enum from the\n-   pragma_simd_clause is returned and the token is consumed.  */\n-\n-static pragma_omp_clause\n-cp_parser_cilk_simd_clause_name (cp_parser *parser)\n-{\n-  pragma_omp_clause clause_type;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  if (token->keyword == RID_PRIVATE)\n-    clause_type = PRAGMA_CILK_CLAUSE_PRIVATE;\n-  else if (!token->u.value || token->type != CPP_NAME)\n-    return PRAGMA_CILK_CLAUSE_NONE;\n-  else if (id_equal (token->u.value, \"vectorlength\"))\n-    clause_type = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n-  else if (id_equal (token->u.value, \"linear\"))\n-    clause_type = PRAGMA_CILK_CLAUSE_LINEAR;\n-  else if (id_equal (token->u.value, \"firstprivate\"))\n-    clause_type = PRAGMA_CILK_CLAUSE_FIRSTPRIVATE;\n-  else if (id_equal (token->u.value, \"lastprivate\"))\n-    clause_type = PRAGMA_CILK_CLAUSE_LASTPRIVATE;\n-  else if (id_equal (token->u.value, \"reduction\"))\n-    clause_type = PRAGMA_CILK_CLAUSE_REDUCTION;\n-  else\n-    return PRAGMA_CILK_CLAUSE_NONE;\n-\n-  cp_lexer_consume_token (parser->lexer);\n-  return clause_type;\n-}\n-\n-/* Parses all the #pragma simd clauses.  Returns a list of clauses found.  */\n-\n-static tree\n-cp_parser_cilk_simd_all_clauses (cp_parser *parser, cp_token *pragma_token)\n-{\n-  tree clauses = NULL_TREE;\n-\n-  while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL)\n-\t && clauses != error_mark_node)\n-    {\n-      pragma_omp_clause c_kind;\n-      c_kind = cp_parser_cilk_simd_clause_name (parser);\n-      if (c_kind == PRAGMA_CILK_CLAUSE_VECTORLENGTH)\n-\tclauses = cp_parser_cilk_simd_vectorlength (parser, clauses, false);\n-      else if (c_kind == PRAGMA_CILK_CLAUSE_LINEAR)\n-\tclauses = cp_parser_cilk_simd_linear (parser, clauses);\n-      else if (c_kind == PRAGMA_CILK_CLAUSE_PRIVATE)\n-\t/* Use the OpenMP 4.0 equivalent function.  */\n-\tclauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_PRIVATE, clauses);\n-      else if (c_kind == PRAGMA_CILK_CLAUSE_FIRSTPRIVATE)\n-\t/* Use the OpenMP 4.0 equivalent function.  */\n-\tclauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_FIRSTPRIVATE,\n-\t\t\t\t\t  clauses);\n-      else if (c_kind == PRAGMA_CILK_CLAUSE_LASTPRIVATE)\n-\t/* Use the OMP 4.0 equivalent function.  */\n-\tclauses = cp_parser_omp_var_list (parser, OMP_CLAUSE_LASTPRIVATE,\n-\t\t\t\t\t  clauses);\n-      else if (c_kind == PRAGMA_CILK_CLAUSE_REDUCTION)\n-\t/* Use the OMP 4.0 equivalent function.  */\n-\tclauses = cp_parser_omp_clause_reduction (parser, clauses);\n-      else\n-\t{\n-\t  clauses = error_mark_node;\n-\t  cp_parser_error (parser, \"expected %<#pragma simd%> clause\");\n-\t  break;\n-\t}\n-    }\n-\n-  cp_parser_skip_to_pragma_eol (parser, pragma_token);\n-\n-  if (clauses == error_mark_node)\n-    return error_mark_node;\n-  else\n-    return finish_omp_clauses (clauses, C_ORT_CILK);\n-}\n-\n-/* Main entry-point for parsing Cilk Plus <#pragma simd> for loops.  */\n-\n-static void\n-cp_parser_cilk_simd (cp_parser *parser, cp_token *pragma_token, bool *if_p)\n-{\n-  tree clauses = cp_parser_cilk_simd_all_clauses (parser, pragma_token);\n-\n-  if (clauses == error_mark_node)\n-    return;\n-\n-  if (cp_lexer_next_token_is_not_keyword (parser->lexer, RID_FOR))\n-    {\n-      error_at (cp_lexer_peek_token (parser->lexer)->location,\n-\t\t\"for statement expected\");\n-      return;\n-    }\n-\n-  tree sb = begin_omp_structured_block ();\n-  int save = cp_parser_begin_omp_structured_block (parser);\n-  tree ret = cp_parser_omp_for_loop (parser, CILK_SIMD, clauses, NULL, if_p);\n-  if (ret)\n-    cpp_validate_cilk_plus_loop (OMP_FOR_BODY (ret));\n-  cp_parser_end_omp_structured_block (parser, save);\n-  add_stmt (finish_omp_structured_block (sb));\n-}\n-\n-/* Main entry-point for parsing Cilk Plus _Cilk_for\n-   loops.  The return value is error_mark_node\n-   when errors happen and CILK_FOR tree on success.  */\n-\n-static tree\n-cp_parser_cilk_for (cp_parser *parser, tree grain, bool *if_p)\n-{\n-  if (cp_lexer_next_token_is_not_keyword (parser->lexer, RID_CILK_FOR))\n-    gcc_unreachable ();\n-\n-  tree sb = begin_omp_structured_block ();\n-  int save = cp_parser_begin_omp_structured_block (parser);\n-\n-  tree clauses = build_omp_clause (EXPR_LOCATION (grain), OMP_CLAUSE_SCHEDULE);\n-  OMP_CLAUSE_SCHEDULE_KIND (clauses) = OMP_CLAUSE_SCHEDULE_CILKFOR;\n-  OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (clauses) = grain;\n-  clauses = finish_omp_clauses (clauses, C_ORT_CILK);\n-\n-  tree ret = cp_parser_omp_for_loop (parser, CILK_FOR, clauses, NULL, if_p);\n-  if (ret)\n-    cpp_validate_cilk_plus_loop (ret);\n-  else\n-    ret = error_mark_node;\n-\n-  cp_parser_end_omp_structured_block (parser, save);\n-  add_stmt (finish_omp_structured_block (sb));\n-  return ret;\n-}\n-\n /* Create an identifier for a generic parameter type (a synthesized\n    template parameter implied by `auto' or a concept identifier). */\n "}, {"sha": "872842a65651c8ec078f9c057a61aa2f74f8d1df", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -309,8 +309,6 @@ struct GTY(()) cp_parser {\n #define IN_OMP_BLOCK\t\t4\n #define IN_OMP_FOR\t\t8\n #define IN_IF_STMT             16\n-#define IN_CILK_SIMD_FOR       32\n-#define IN_CILK_SPAWN          64\n   unsigned char in_statement;\n \n   /* TRUE if we are presently parsing the body of a switch statement."}, {"sha": "706e3a972f668a11c0a7ee8f5656a4b1b812bdd3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -10135,7 +10135,7 @@ tsubst_attribute (tree t, tree *decl_p, tree args,\n   tree val = TREE_VALUE (t);\n   if (val == NULL_TREE)\n     /* Nothing to do.  */;\n-  else if ((flag_openmp || flag_openmp_simd || flag_cilkplus)\n+  else if ((flag_openmp || flag_openmp_simd)\n \t   && is_attribute_p (\"omp declare simd\",\n \t\t\t      get_attribute_name (t)))\n     {\n@@ -16418,8 +16418,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \n     case OMP_FOR:\n     case OMP_SIMD:\n-    case CILK_SIMD:\n-    case CILK_FOR:\n     case OMP_DISTRIBUTE:\n     case OMP_TASKLOOP:\n     case OACC_LOOP:\n@@ -16431,9 +16429,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \tenum c_omp_region_type ort = C_ORT_OMP;\n \tint i;\n \n-\tif (TREE_CODE (t) == CILK_SIMD || TREE_CODE (t) == CILK_FOR)\n-\t  ort = C_ORT_CILK;\n-\telse if (TREE_CODE (t) == OACC_LOOP)\n+\tif (TREE_CODE (t) == OACC_LOOP)\n \t  ort = C_ORT_ACC;\n \n \tr = push_omp_privatization_clauses (OMP_FOR_INIT (t) == NULL_TREE);\n@@ -16712,13 +16708,6 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       error (\"use %<...%> to expand argument pack\");\n       RETURN (error_mark_node);\n \n-    case CILK_SPAWN_STMT:\n-      cfun->calls_cilk_spawn = 1;\n-      RETURN (build_cilk_spawn (EXPR_LOCATION (t), RECUR (CILK_SPAWN_FN (t))));\n-\n-    case CILK_SYNC_STMT:\n-      RETURN (build_cilk_sync ());\n-\n     case COMPOUND_EXPR:\n       tmp = RECUR (TREE_OPERAND (t, 0));\n       if (tmp == NULL_TREE)\n@@ -17312,17 +17301,6 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t RECUR (TREE_OPERAND (t, 1)),\n \t\t\t\t complain|decltype_flag));\n \n-    case ARRAY_NOTATION_REF:\n-      {\n-\ttree start_index, length, stride;\n-\top1 = tsubst_non_call_postfix_expression (ARRAY_NOTATION_ARRAY (t),\n-\t\t\t\t\t\t  args, complain, in_decl);\n-\tstart_index = RECUR (ARRAY_NOTATION_START (t));\n-\tlength = RECUR (ARRAY_NOTATION_LENGTH (t));\n-\tstride = RECUR (ARRAY_NOTATION_STRIDE (t));\n-\tRETURN (build_array_notation_ref (EXPR_LOCATION (t), op1, start_index,\n-\t\t\t\t\t  length, stride, TREE_TYPE (op1)));\n-      }\n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0))\n \t  || ARGUMENT_PACK_P (TREE_OPERAND (t, 0)))"}, {"sha": "141921dcc61a3c7f56c5650ae1e7b1b8634ea337", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 178, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -614,10 +614,6 @@ finish_goto_stmt (tree destination)\n     TREE_USED (destination) = 1;\n   else\n     {\n-      if (check_no_cilk (destination,\n-\t \"Cilk array notation cannot be used as a computed goto expression\",\n-\t \"%<_Cilk_spawn%> statement cannot be used as a computed goto expression\"))\n-\tdestination = error_mark_node;\n       destination = mark_rvalue_use (destination);\n       if (!processing_template_decl)\n \t{\n@@ -804,10 +800,6 @@ begin_while_stmt (void)\n void\n finish_while_stmt_cond (tree cond, tree while_stmt, bool ivdep)\n {\n-  if (check_no_cilk (cond,\n-      \"Cilk array notation cannot be used as a condition for while statement\",\n-      \"%<_Cilk_spawn%> statement cannot be used as a condition for while statement\"))\n-    cond = error_mark_node;\n   cond = maybe_convert_cond (cond);\n   finish_cond (&WHILE_COND (while_stmt), cond);\n   begin_maybe_infinite_loop (cond);\n@@ -864,10 +856,6 @@ finish_do_body (tree do_stmt)\n void\n finish_do_stmt (tree cond, tree do_stmt, bool ivdep)\n {\n-  if (check_no_cilk (cond,\n-  \"Cilk array notation cannot be used as a condition for a do-while statement\",\n-  \"%<_Cilk_spawn%> statement cannot be used as a condition for a do-while statement\"))\n-    cond = error_mark_node;\n   cond = maybe_convert_cond (cond);\n   end_maybe_infinite_loop (cond);\n   if (ivdep && cond != error_mark_node)\n@@ -984,10 +972,6 @@ finish_init_stmt (tree for_stmt)\n void\n finish_for_cond (tree cond, tree for_stmt, bool ivdep)\n {\n-  if (check_no_cilk (cond,\n-\t \"Cilk array notation cannot be used in a condition for a for-loop\",\n-\t \"%<_Cilk_spawn%> statement cannot be used in a condition for a for-loop\"))\n-    cond = error_mark_node;\n   cond = maybe_convert_cond (cond);\n   finish_cond (&FOR_COND (for_stmt), cond);\n   begin_maybe_infinite_loop (cond);\n@@ -1152,11 +1136,6 @@ finish_switch_cond (tree cond, tree switch_stmt)\n {\n   tree orig_type = NULL;\n \n-  if (check_no_cilk (cond,\n-\t\"Cilk array notation cannot be used as a condition for switch statement\",\n-\t\"%<_Cilk_spawn%> statement cannot be used as a condition for switch statement\"))\n-    cond = error_mark_node;\n-\n   if (!processing_template_decl)\n     {\n       /* Convert the condition to an integer or enumeration type.  */\n@@ -4080,8 +4059,6 @@ simplify_aggr_init_expr (tree *tp)\n     = CALL_EXPR_OPERATOR_SYNTAX (aggr_init_expr);\n   CALL_EXPR_ORDERED_ARGS (call_expr) = CALL_EXPR_ORDERED_ARGS (aggr_init_expr);\n   CALL_EXPR_REVERSE_ARGS (call_expr) = CALL_EXPR_REVERSE_ARGS (aggr_init_expr);\n-  /* Preserve CILK_SPAWN flag.  */\n-  EXPR_CILK_SPAWN (call_expr) = EXPR_CILK_SPAWN (aggr_init_expr);\n \n   if (style == ctor)\n     {\n@@ -5910,20 +5887,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t}\n \t      if (TREE_CODE (type) == REFERENCE_TYPE)\n \t\ttype = TREE_TYPE (type);\n-\t      if (ort == C_ORT_CILK)\n-\t\t{\n-\t\t  if (!INTEGRAL_TYPE_P (type)\n-\t\t      && !SCALAR_FLOAT_TYPE_P (type)\n-\t\t      && TREE_CODE (type) != POINTER_TYPE)\n-\t\t    {\n-\t\t      error (\"linear clause applied to non-integral, \"\n-\t\t\t     \"non-floating, non-pointer variable with %qT type\",\n-\t\t\t     TREE_TYPE (t));\n-\t\t      remove = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      else if (OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_REF)\n+\t      if (OMP_CLAUSE_LINEAR_KIND (c) != OMP_CLAUSE_LINEAR_REF)\n \t\t{\n \t\t  if (!INTEGRAL_TYPE_P (type)\n \t\t      && TREE_CODE (type) != POINTER_TYPE)\n@@ -6347,8 +6311,6 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if (t == error_mark_node)\n \t    remove = true;\n \t  else if (!type_dependent_expression_p (t)\n-\t\t   && (OMP_CLAUSE_SCHEDULE_KIND (c)\n-\t\t       != OMP_CLAUSE_SCHEDULE_CILKFOR)\n \t\t   && !INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \t    {\n \t      error (\"schedule chunk size expression must be integral\");\n@@ -6359,27 +6321,14 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      t = mark_rvalue_use (t);\n \t      if (!processing_template_decl)\n \t\t{\n-\t\t  if (OMP_CLAUSE_SCHEDULE_KIND (c)\n-\t\t      == OMP_CLAUSE_SCHEDULE_CILKFOR)\n-\t\t    {\n-\t\t      t = convert_to_integer (long_integer_type_node, t);\n-\t\t      if (t == error_mark_node)\n-\t\t\t{\n-\t\t\t  remove = true;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      t = maybe_constant_value (t);\n-\t\t      if (TREE_CODE (t) == INTEGER_CST\n-\t\t\t  && tree_int_cst_sgn (t) != 1)\n-\t\t\t{\n-\t\t\t  warning_at (OMP_CLAUSE_LOCATION (c), 0,\n-\t\t\t\t      \"chunk size value must be positive\");\n-\t\t\t  t = integer_one_node;\n-\t\t\t}\n-\t\t    }\n+\t\t  t = maybe_constant_value (t);\n+\t\t  if (TREE_CODE (t) == INTEGER_CST\n+\t\t      && tree_int_cst_sgn (t) != 1)\n+\t\t  {\n+\t\t    warning_at (OMP_CLAUSE_LOCATION (c), 0,\n+\t\t\t      \"chunk size value must be positive\");\n+\t\t    t = integer_one_node;\n+\t\t  }\n \t\t  t = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n \t\t}\n \t      OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c) = t;\n@@ -7076,7 +7025,6 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \tcase OMP_CLAUSE_THREADS:\n \tcase OMP_CLAUSE_SIMD:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n-\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_AUTO:\n \tcase OMP_CLAUSE_INDEPENDENT:\n \tcase OMP_CLAUSE_SEQ:\n@@ -7998,7 +7946,7 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\ttree body, tree pre_body, vec<tree> *orig_inits, tree clauses)\n {\n   tree omp_for = NULL, orig_incr = NULL;\n-  tree decl = NULL, init, cond, incr, orig_decl = NULL_TREE, block = NULL_TREE;\n+  tree decl = NULL, init, cond, incr;\n   tree last = NULL_TREE;\n   location_t elocus;\n   int i;\n@@ -8164,8 +8112,6 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t\t\t\t\"iteration variable %qE\", decl);\n \t      return NULL;\n \t    }\n-\t  if (code == CILK_FOR && i == 0)\n-\t    orig_decl = decl;\n \t  if (handle_omp_for_class_iterator (i, locus, code, declv, orig_declv,\n \t\t\t\t\t     initv, condv, incrv, &body,\n \t\t\t\t\t     &pre_body, clauses, &last,\n@@ -8223,9 +8169,6 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n   if (IS_EMPTY_STMT (pre_body))\n     pre_body = NULL;\n \n-  if (code == CILK_FOR && !processing_template_decl)\n-    block = push_stmt_list ();\n-\n   omp_for = c_finish_omp_for (locus, code, declv, orig_declv, initv, condv,\n \t\t\t      incrv, body, pre_body);\n \n@@ -8235,8 +8178,6 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \n   if (omp_for == NULL)\n     {\n-      if (block)\n-\tpop_stmt_list (block);\n       return NULL;\n     }\n \n@@ -8338,115 +8279,6 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t    }\n \t}\n \n-  if (block)\n-    {\n-      tree omp_par = make_node (OMP_PARALLEL);\n-      TREE_TYPE (omp_par) = void_type_node;\n-      OMP_PARALLEL_CLAUSES (omp_par) = NULL_TREE;\n-      tree bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n-      TREE_SIDE_EFFECTS (bind) = 1;\n-      BIND_EXPR_BODY (bind) = pop_stmt_list (block);\n-      OMP_PARALLEL_BODY (omp_par) = bind;\n-      if (OMP_FOR_PRE_BODY (omp_for))\n-\t{\n-\t  add_stmt (OMP_FOR_PRE_BODY (omp_for));\n-\t  OMP_FOR_PRE_BODY (omp_for) = NULL_TREE;\n-\t}\n-      init = TREE_VEC_ELT (OMP_FOR_INIT (omp_for), 0);\n-      decl = TREE_OPERAND (init, 0);\n-      cond = TREE_VEC_ELT (OMP_FOR_COND (omp_for), 0);\n-      incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), 0);\n-      tree t = TREE_OPERAND (cond, 1), c, clauses, *pc;\n-      clauses = OMP_FOR_CLAUSES (omp_for);\n-      OMP_FOR_CLAUSES (omp_for) = NULL_TREE;\n-      for (pc = &clauses; *pc; )\n-\tif (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_SCHEDULE)\n-\t  {\n-\t    gcc_assert (OMP_FOR_CLAUSES (omp_for) == NULL_TREE);\n-\t    OMP_FOR_CLAUSES (omp_for) = *pc;\n-\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n-\t    OMP_CLAUSE_CHAIN (OMP_FOR_CLAUSES (omp_for)) = NULL_TREE;\n-\t  }\n-\telse\n-\t  {\n-\t    gcc_assert (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_FIRSTPRIVATE);\n-\t    pc = &OMP_CLAUSE_CHAIN (*pc);\n-\t  }\n-      if (TREE_CODE (t) != INTEGER_CST)\n-\t{\n-\t  TREE_OPERAND (cond, 1) = get_temp_regvar (TREE_TYPE (t), t);\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (cond, 1);\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      if (TREE_CODE (incr) == MODIFY_EXPR)\n-\t{\n-\t  t = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n-\t  if (TREE_CODE (t) != INTEGER_CST)\n-\t    {\n-\t      TREE_OPERAND (TREE_OPERAND (incr, 1), 1)\n-\t\t= get_temp_regvar (TREE_TYPE (t), t);\n-\t      c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t      OMP_CLAUSE_DECL (c) = TREE_OPERAND (TREE_OPERAND (incr, 1), 1);\n-\t      OMP_CLAUSE_CHAIN (c) = clauses;\n-\t      clauses = c;\n-\t    }\n-\t}\n-      t = TREE_OPERAND (init, 1);\n-      if (TREE_CODE (t) != INTEGER_CST)\n-\t{\n-\t  TREE_OPERAND (init, 1) = get_temp_regvar (TREE_TYPE (t), t);\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = TREE_OPERAND (init, 1);\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      if (orig_decl && orig_decl != decl)\n-\t{\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = orig_decl;\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      if (last)\n-\t{\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = last;\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      c = build_omp_clause (input_location, OMP_CLAUSE_PRIVATE);\n-      OMP_CLAUSE_DECL (c) = decl;\n-      OMP_CLAUSE_CHAIN (c) = clauses;\n-      clauses = c;\n-      c = build_omp_clause (input_location, OMP_CLAUSE__CILK_FOR_COUNT_);\n-      OMP_CLAUSE_OPERAND (c, 0)\n-\t= cilk_for_number_of_iterations (omp_for);\n-      OMP_CLAUSE_CHAIN (c) = clauses;\n-      OMP_PARALLEL_CLAUSES (omp_par) = finish_omp_clauses (c, C_ORT_CILK);\n-      add_stmt (omp_par);\n-      return omp_par;\n-    }\n-  else if (code == CILK_FOR && processing_template_decl)\n-    {\n-      tree c, clauses = OMP_FOR_CLAUSES (omp_for);\n-      if (orig_decl && orig_decl != decl)\n-\t{\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = orig_decl;\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      if (last)\n-\t{\n-\t  c = build_omp_clause (input_location, OMP_CLAUSE_FIRSTPRIVATE);\n-\t  OMP_CLAUSE_DECL (c) = last;\n-\t  OMP_CLAUSE_CHAIN (c) = clauses;\n-\t  clauses = c;\n-\t}\n-      OMP_FOR_CLAUSES (omp_for) = clauses;\n-    }\n   return omp_for;\n }\n "}, {"sha": "c76dea46479c06366df6291897106ca48de052fa", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -165,7 +165,6 @@ lvalue_kind (const_tree ref)\n     case INDIRECT_REF:\n     case ARROW_EXPR:\n     case ARRAY_REF:\n-    case ARRAY_NOTATION_REF:\n     case PARM_DECL:\n     case RESULT_DECL:\n     case PLACEHOLDER_EXPR:"}, {"sha": "8454719118efdccf7b579fde84645df645dcf591", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -3196,22 +3196,6 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n       return error_mark_node;\n     }\n \n-  /* If an array's index is an array notation, then its rank cannot be\n-     greater than one.  */ \n-  if (flag_cilkplus && contains_array_notation_expr (idx))\n-    {\n-      size_t rank = 0;\n-\n-      /* If find_rank returns false, then it should have reported an error,\n-\t thus it is unnecessary for repetition.  */\n-      if (!find_rank (loc, idx, idx, true, &rank))\n-\treturn error_mark_node;\n-      if (rank > 1)\n-\t{\n-\t  error_at (loc, \"rank of the array%'s index is greater than 1\");\n-\t  return error_mark_node;\n-\t}\n-    }\n   if (TREE_TYPE (array) == error_mark_node\n       || TREE_TYPE (idx) == error_mark_node)\n     return error_mark_node;\n@@ -6640,17 +6624,6 @@ cp_build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n \n-  if (flag_cilkplus\n-      && (TREE_CODE (lhs) == CILK_SPAWN_STMT\n-\t  || TREE_CODE (rhs) == CILK_SPAWN_STMT))\n-    {\n-      location_t loc = (EXPR_HAS_LOCATION (lhs) ? EXPR_LOCATION (lhs)\n-\t\t\t: EXPR_LOCATION (rhs));\n-      error_at (loc,\n-\t\t\"spawned function call cannot be part of a comma expression\");\n-      return error_mark_node;\n-    }\n-\n   if (TREE_CODE (rhs) == TARGET_EXPR)\n     {\n       /* If the rhs is a TARGET_EXPR, then build the compound\n@@ -8983,13 +8956,6 @@ check_return_expr (tree retval, bool *no_warning)\n \n   *no_warning = false;\n \n-  if (flag_cilkplus && retval && contains_cilk_spawn_stmt (retval))\n-    {\n-      error_at (EXPR_LOCATION (retval), \"use of %<_Cilk_spawn%> in a return \"\n-\t\t\"statement is not allowed\");\n-      return NULL_TREE;\n-    }\n-\n   /* A `volatile' function is one that isn't supposed to return, ever.\n      (This is a G++ extension, used to get better code for functions\n      that call the `volatile' function.)  */"}, {"sha": "bc20eb62543f4ec4705906e3d8c2558a22818d11", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -110,8 +110,6 @@ define_builtin_macros_for_compilation_flags (cpp_reader *pfile)\n \n   cpp_define_formatted (pfile, \"__FINITE_MATH_ONLY__=%d\",\n \t\t\tflag_finite_math_only);\n-  if (flag_cilkplus)\n-    cpp_define (pfile, \"__cilk=200\");\n \n   if (flag_check_pointer_bounds)\n     cpp_define (pfile, \"__CHKP__\");"}, {"sha": "30f89b09699d32384b996ddd1a3c127cedb3248e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -85,7 +85,6 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Object Size Checking:: Built-in functions for limited buffer overflow\n                         checking.\n * Pointer Bounds Checker builtins:: Built-in functions for Pointer Bounds Checker.\n-* Cilk Plus Builtins::  Built-in functions for the Cilk Plus language extension.\n * Other Builtins::      Other built-in functions.\n * Target Builtins::     Built-in functions specific to particular targets.\n * Target Format Checks:: Format checks specific to particular targets.\n@@ -3295,9 +3294,6 @@ The optional argument @var{mask} may have the value\n and instructs the compiler to generate non-masked or masked\n clones correspondingly. By default, all clones are generated.\n \n-The attribute should not be used together with Cilk Plus @code{vector}\n-attribute on the same function.\n-\n If the attribute is specified and @code{#pragma omp declare simd} is\n present on a declaration and the @option{-fopenmp} or @option{-fopenmp-simd}\n switch is specified, then the attribute is ignored.\n@@ -10935,32 +10931,6 @@ the built-in function returns -1.\n \n @end deftypefn\n \n-@node Cilk Plus Builtins\n-@section Cilk Plus C/C++ Language Extension Built-in Functions\n-\n-GCC provides support for the following built-in reduction functions if Cilk Plus\n-is enabled. Cilk Plus can be enabled using the @option{-fcilkplus} flag.\n-\n-@itemize @bullet\n-@item @code{__sec_implicit_index}\n-@item @code{__sec_reduce}\n-@item @code{__sec_reduce_add}\n-@item @code{__sec_reduce_all_nonzero}\n-@item @code{__sec_reduce_all_zero}\n-@item @code{__sec_reduce_any_nonzero}\n-@item @code{__sec_reduce_any_zero}\n-@item @code{__sec_reduce_max}\n-@item @code{__sec_reduce_min}\n-@item @code{__sec_reduce_max_ind}\n-@item @code{__sec_reduce_min_ind}\n-@item @code{__sec_reduce_mul}\n-@item @code{__sec_reduce_mutating}\n-@end itemize\n-\n-Further details and examples about these built-in functions are described \n-in the Cilk Plus language manual which can be found at \n-@uref{https://www.cilkplus.org}.\n-\n @node Other Builtins\n @section Other Built-in Functions Provided by GCC\n @cindex built-in functions"}, {"sha": "17f38df3d4c7c4172765350851a19d79f4fdabb2", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -3234,30 +3234,6 @@ several statements chained together.\n Used to represent a @code{break} statement.  There are no additional\n fields.\n \n-@item CILK_SPAWN_STMT\n-\n-Used to represent a spawning function in the Cilk Plus language extension.  \n-This tree has one field that holds the name of the spawning function.\n-@code{_Cilk_spawn} can be written in C in the following way:\n-\n-@smallexample\n-@code{_Cilk_spawn} <function_name> (<parameters>);\n-@end smallexample\n-\n-Detailed description for usage and functionality of @code{_Cilk_spawn} can be \n-found at @uref{https://www.cilkplus.org}.\n-\n-@item CILK_SYNC_STMT\n-\n-This statement is part of the Cilk Plus language extension.  It indicates that\n-the current function cannot continue in parallel with its spawned children.  \n-There are no additional fields.  @code{_Cilk_sync} can be written in C in the \n-following way:\n-\n-@smallexample\n-@code{_Cilk_sync};\n-@end smallexample\n-\n @item CLEANUP_STMT\n \n Used to represent an action that should take place upon exit from the"}, {"sha": "2de3db1fbc3721f9a0ad8bc114e37189723b1aff", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -2098,18 +2098,6 @@ Enable handling of OpenMP's SIMD directives with @code{#pragma omp}\n in C/C++ and @code{!$omp} in Fortran. Other OpenMP directives\n are ignored.\n \n-@item -fcilkplus\n-@opindex fcilkplus\n-@cindex Enable Cilk Plus\n-Enable the usage of Cilk Plus language extension features for C/C++.\n-When the option @option{-fcilkplus} is specified, enable the usage of\n-the Cilk Plus Language extension features for C/C++.  The present\n-implementation follows ABI version 1.2.  This is an experimental\n-feature that is only partially complete, and whose interface may\n-change in future versions of GCC as the official specification\n-changes.  Currently, all features but @code{_Cilk_for} have been\n-implemented.\n-\n @item -fgnu-tm\n @opindex fgnu-tm\n When the option @option{-fgnu-tm} is specified, the compiler"}, {"sha": "ef3c35cc2682ad0f6458b51e7af66a4c6fa10e86", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -18,7 +18,6 @@ where near complete.\n \n @menu\n * Parsing pass::         The language front end turns text into bits.\n-* Cilk Plus Transformation:: Transform Cilk Plus Code to equivalent C/C++.\n * Gimplification pass::  The bits are turned into something we can optimize.\n * Pass manager::         Sequencing the optimization passes.\n * Tree SSA passes::      Optimizations on a high-level representation.\n@@ -104,68 +103,6 @@ that is more descriptive than \"rest_of\".\n The middle-end will, at its option, emit the function and data\n definitions immediately or queue them for later processing.\n \n-@node Cilk Plus Transformation\n-@section Cilk Plus Transformation\n-@cindex CILK_PLUS\n-\n-If Cilk Plus generation (flag @option{-fcilkplus}) is enabled, all the Cilk \n-Plus code is transformed into equivalent C and C++ functions.  Majority of this \n-transformation occurs toward the end of the parsing and right before the \n-gimplification pass.  \n-\n-These are the major components to the Cilk Plus language extension:\n-@itemize @bullet\n-@item Array Notations:\n-During parsing phase, all the array notation specific information is stored in \n-@code{ARRAY_NOTATION_REF} tree using the function \n-@code{c_parser_array_notation}.  During the end of parsing, we check the entire\n-function to see if there are any array notation specific code (using the \n-function @code{contains_array_notation_expr}).  If this function returns \n-true, then we expand them using either @code{expand_array_notation_exprs} or\n-@code{build_array_notation_expr}.  For the cases where array notations are \n-inside conditions, they are transformed using the function \n-@code{fix_conditional_array_notations}.  The C language-specific routines are \n-located in @file{c/c-array-notation.c} and the equivalent C++ routines are in \n-the file @file{cp/cp-array-notation.c}.  Common routines such as functions to \n-initialize built-in functions are stored in @file{array-notation-common.c}.\n-\n-@item Cilk keywords:\n-@itemize @bullet \n-@item @code{_Cilk_spawn}:\n-The @code{_Cilk_spawn} keyword is parsed and the function it contains is marked \n-as a spawning function.  The spawning function is called the spawner.  At \n-the end of the parsing phase, appropriate built-in functions are \n-added to the spawner that are defined in the Cilk runtime.  The appropriate \n-locations of these functions, and the internal structures are detailed in \n-@code{cilk_init_builtins} in the file @file{cilk-common.c}.  The pointers to \n-Cilk functions and fields of internal structures are described \n-in @file{cilk.h}.  The built-in functions are described in \n-@file{cilk-builtins.def}.\n-\n-During gimplification, a new \"spawn-helper\" function is created.  \n-The spawned function is replaced with a spawn helper function in the spawner.  \n-The spawned function-call is moved into the spawn helper.  The main function\n-that does these transformations is @code{gimplify_cilk_spawn} in\n-@file{c-family/cilk.c}.  In the spawn-helper, the gimplification function \n-@code{gimplify_call_expr}, inserts a function call @code{__cilkrts_detach}.\n-This function is expanded by @code{builtin_expand_cilk_detach} located in\n-@file{c-family/cilk.c}.\n-\n-@item @code{_Cilk_sync}:\n-@code{_Cilk_sync} is parsed like a keyword.  During gimplification, \n-the function @code{gimplify_cilk_sync} in @file{c-family/cilk.c}, will replace\n-this keyword with a set of functions that are stored in the Cilk runtime.  \n-One of the internal functions inserted during gimplification, \n-@code{__cilkrts_pop_frame} must be expanded by the compiler and is \n-done by @code{builtin_expand_cilk_pop_frame} in @file{cilk-common.c}.\n-\n-@end itemize\n-@end itemize\n-\n-Documentation about Cilk Plus and language specification is provided under the\n-\"Learn\" section in @w{@uref{https://www.cilkplus.org}}.  It is worth mentioning\n-that the current implementation follows ABI 1.1.\n-\n @node Gimplification pass\n @section Gimplification pass\n "}, {"sha": "60b6b77abc6188dabd53bc5d1b31fe0861fd8638", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -2116,9 +2116,6 @@ Target supports wide characters.\n @item automatic_stack_alignment\n Target supports automatic stack alignment.\n \n-@item cilkplus_runtime\n-Target supports the Cilk Plus runtime library.\n-\n @item cxa_atexit\n Target uses @code{__cxa_atexit}.\n "}, {"sha": "f70755679f4c6cccd6aecac72d884b7b8026a1b0", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1041,7 +1041,6 @@ proper position among the other output files.  */\n     VTABLE_VERIFICATION_SPEC \" \" SANITIZER_EARLY_SPEC \" %o \" CHKP_SPEC \" \\\n     %{fopenacc|fopenmp|%:gt(%{ftree-parallelize-loops=*:%*} 1):\\\n \t%:include(libgomp.spec)%(link_gomp)}\\\n-    %{fcilkplus:%:include(libcilkrts.spec)%(link_cilkrts)}\\\n     %{fgnu-tm:%:include(libitm.spec)%(link_itm)}\\\n     %(mflib) \" STACK_SPLIT_SPEC \"\\\n     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \" SANITIZER_SPEC \" \\\n@@ -1216,15 +1215,9 @@ static const char *const multilib_defaults_raw[] = MULTILIB_DEFAULTS;\n #define GTM_SELF_SPECS \"%{fgnu-tm: -pthread}\"\n #endif\n \n-/* Likewise for -fcilkplus.  */\n-#ifndef CILK_SELF_SPECS\n-#define CILK_SELF_SPECS \"%{fcilkplus: -pthread}\"\n-#endif\n-\n static const char *const driver_self_specs[] = {\n   \"%{fdump-final-insns:-fdump-final-insns=.} %<fdump-final-insns\",\n-  DRIVER_SELF_SPECS, CONFIGURE_SPECS, GOMP_SELF_SPECS, GTM_SELF_SPECS,\n-  CILK_SELF_SPECS\n+  DRIVER_SELF_SPECS, CONFIGURE_SPECS, GOMP_SELF_SPECS, GTM_SELF_SPECS\n };\n \n #ifndef OPTION_DEFAULT_SPECS"}, {"sha": "aeca2628ec1fdf964a819ac78a255b28c49cfe5b", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1710,7 +1710,7 @@ open_base_files (void)\n       \"backend.h\", \"predict.h\", \"tree.h\",\n       \"rtl.h\", \"gimple.h\", \"fold-const.h\", \"insn-codes.h\", \"splay-tree.h\",\n       \"alias.h\", \"insn-config.h\", \"flags.h\", \"expmed.h\", \"dojump.h\",\n-      \"explow.h\", \"calls.h\", \"cilk.h\", \"memmodel.h\", \"emit-rtl.h\", \"varasm.h\",\n+      \"explow.h\", \"calls.h\", \"memmodel.h\", \"emit-rtl.h\", \"varasm.h\",\n       \"stmt.h\", \"expr.h\", \"alloc-pool.h\", \"cselib.h\", \"insn-addr.h\",\n       \"optabs.h\", \"libfuncs.h\", \"debug.h\", \"internal-fn.h\", \"gimple-fold.h\",\n       \"tree-eh.h\", \"gimple-iterator.h\", \"gimple-ssa.h\", \"tree-cfg.h\","}, {"sha": "e952f3378121f5e137aba94ef9a93fc8bd71434b", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1389,18 +1389,12 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc,\n \tcase GF_OMP_FOR_KIND_TASKLOOP:\n \t  kind = \" taskloop\";\n \t  break;\n-\tcase GF_OMP_FOR_KIND_CILKFOR:\n-\t  kind = \" _Cilk_for\";\n-\t  break;\n \tcase GF_OMP_FOR_KIND_OACC_LOOP:\n \t  kind = \" oacc_loop\";\n \t  break;\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  kind = \" simd\";\n \t  break;\n-\tcase GF_OMP_FOR_KIND_CILKSIMD:\n-\t  kind = \" cilksimd\";\n-\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -1432,36 +1426,25 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc,\n \tcase GF_OMP_FOR_KIND_TASKLOOP:\n \t  pp_string (buffer, \"#pragma omp taskloop\");\n \t  break;\n-\tcase GF_OMP_FOR_KIND_CILKFOR:\n-\t  break;\n \tcase GF_OMP_FOR_KIND_OACC_LOOP:\n \t  pp_string (buffer, \"#pragma acc loop\");\n \t  break;\n \tcase GF_OMP_FOR_KIND_SIMD:\n \t  pp_string (buffer, \"#pragma omp simd\");\n \t  break;\n-\tcase GF_OMP_FOR_KIND_CILKSIMD:\n-\t  pp_string (buffer, \"#pragma simd\");\n-\t  break;\n \tcase GF_OMP_FOR_KIND_GRID_LOOP:\n \t  pp_string (buffer, \"#pragma omp for grid_loop\");\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      if (gimple_omp_for_kind (gs) != GF_OMP_FOR_KIND_CILKFOR)\n-\tdump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n+      dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n       for (i = 0; i < gimple_omp_for_collapse (gs); i++)\n \t{\n \t  if (i)\n \t    spc += 2;\n-\t  if (gimple_omp_for_kind (gs) == GF_OMP_FOR_KIND_CILKFOR)\n-\t    pp_string (buffer, \"_Cilk_for (\");\n-\t  else\n-\t    {\n-\t      newline_and_indent (buffer, spc);\n-\t      pp_string (buffer, \"for (\");\n-\t    }\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_string (buffer, \"for (\");\n \t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n \t\t\t     flags, false);\n \t  pp_string (buffer, \" = \");\n@@ -1507,8 +1490,6 @@ dump_gimple_omp_for (pretty_printer *buffer, gomp_for *gs, int spc,\n \n       if (!gimple_seq_empty_p (gimple_omp_body (gs)))\n \t{\n-\t  if (gimple_omp_for_kind (gs) == GF_OMP_FOR_KIND_CILKFOR)\n-\t    dump_omp_clauses (buffer, gimple_omp_for_clauses (gs), spc, flags);\n \t  newline_and_indent (buffer, spc + 2);\n \t  pp_left_brace (buffer);\n \t  pp_newline (buffer);"}, {"sha": "0fcdd05aaba684f775954401152a817be66f1594", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -156,13 +156,11 @@ enum gf_mask {\n     GF_OMP_FOR_KIND_FOR\t\t= 0,\n     GF_OMP_FOR_KIND_DISTRIBUTE\t= 1,\n     GF_OMP_FOR_KIND_TASKLOOP\t= 2,\n-    GF_OMP_FOR_KIND_CILKFOR     = 3,\n     GF_OMP_FOR_KIND_OACC_LOOP\t= 4,\n     GF_OMP_FOR_KIND_GRID_LOOP = 5,\n     /* Flag for SIMD variants of OMP_FOR kinds.  */\n     GF_OMP_FOR_SIMD\t\t= 1 << 3,\n     GF_OMP_FOR_KIND_SIMD\t= GF_OMP_FOR_SIMD | 0,\n-    GF_OMP_FOR_KIND_CILKSIMD\t= GF_OMP_FOR_SIMD | 1,\n     GF_OMP_FOR_COMBINED\t\t= 1 << 4,\n     GF_OMP_FOR_COMBINED_INTO\t= 1 << 5,\n     /* The following flag must not be used on GF_OMP_FOR_KIND_GRID_LOOP loop"}, {"sha": "2c2abd76c0896afc9305cb0f1d321beb76f6aa47", "filename": "gcc/gimplify.c", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -56,7 +56,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-general.h\"\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n-#include \"cilk.h\"\n #include \"gomp-constants.h\"\n #include \"splay-tree.h\"\n #include \"gimple-walk.h\"\n@@ -1458,15 +1457,6 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n   if (ret_expr == error_mark_node)\n     return GS_ERROR;\n \n-  /* Implicit _Cilk_sync must be inserted right before any return statement \n-     if there is a _Cilk_spawn in the function.  If the user has provided a \n-     _Cilk_sync, the optimizer should remove this duplicate one.  */\n-  if (fn_contains_cilk_spawn_p (cfun))\n-    {\n-      tree impl_sync = build0 (CILK_SYNC_STMT, void_type_node);\n-      gimplify_and_add (impl_sync, pre_p);\n-    }\n-\n   if (!ret_expr\n       || TREE_CODE (ret_expr) == RESULT_DECL\n       || ret_expr == error_mark_node)\n@@ -3098,19 +3088,6 @@ maybe_fold_stmt (gimple_stmt_iterator *gsi)\n   return fold_stmt (gsi);\n }\n \n-/* Add a gimple call to __builtin_cilk_detach to GIMPLE sequence PRE_P,\n-   with the pointer to the proper cilk frame.  */\n-static void\n-gimplify_cilk_detach (gimple_seq *pre_p)\n-{\n-  tree frame = cfun->cilk_frame_decl;\n-  tree ptrf = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl,\n-\t\t      frame);\n-  gcall *detach = gimple_build_call (cilk_detach_fndecl, 1,\n-\t\t\t\t     ptrf);\n-  gimplify_seq_add_stmt(pre_p, detach);\n-}\n-\n /* Gimplify the CALL_EXPR node *EXPR_P into the GIMPLE sequence PRE_P.\n    WANT_VALUE is true if the result of the call is desired.  */\n \n@@ -3148,8 +3125,6 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n \t  vargs.quick_push (CALL_EXPR_ARG (*expr_p, i));\n \t}\n \n-      if (EXPR_CILK_SPAWN (*expr_p))\n-        gimplify_cilk_detach (pre_p);\n       gcall *call = gimple_build_call_internal_vec (ifn, vargs);\n       gimple_call_set_nothrow (call, TREE_NOTHROW (*expr_p));\n       gimplify_seq_add_stmt (pre_p, call);\n@@ -3380,8 +3355,6 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n       gimple_stmt_iterator gsi;\n       call = gimple_build_call_from_tree (*expr_p, fnptrtype);\n       notice_special_calls (call);\n-      if (EXPR_CILK_SPAWN (*expr_p))\n-        gimplify_cilk_detach (pre_p);\n       gimplify_seq_add_stmt (pre_p, call);\n       gsi = gsi_last (*pre_p);\n       maybe_fold_stmt (&gsi);\n@@ -5340,7 +5313,6 @@ is_gimple_stmt (tree t)\n     case OMP_PARALLEL:\n     case OMP_FOR:\n     case OMP_SIMD:\n-    case CILK_SIMD:\n     case OMP_DISTRIBUTE:\n     case OACC_LOOP:\n     case OMP_SECTIONS:\n@@ -5673,8 +5645,6 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t   ???  This doesn't make it a default-def.  */\n \tSSA_NAME_DEF_STMT (*to_p) = gimple_build_nop ();\n \n-      if (EXPR_CILK_SPAWN (*from_p))\n-        gimplify_cilk_detach (pre_p);\n       assign = call_stmt;\n     }\n   else\n@@ -8422,7 +8392,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n \tcase OMP_CLAUSE_HINT:\n-\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_NUM_GANGS:\n@@ -9225,7 +9194,6 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n \tcase OMP_CLAUSE_IS_DEVICE_PTR:\n-\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_INDEPENDENT:\n@@ -9520,7 +9488,6 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   switch (TREE_CODE (for_stmt))\n     {\n     case OMP_FOR:\n-    case CILK_FOR:\n     case OMP_DISTRIBUTE:\n       break;\n     case OACC_LOOP:\n@@ -9533,7 +9500,6 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tort = ORT_TASK;\n       break;\n     case OMP_SIMD:\n-    case CILK_SIMD:\n       ort = ORT_SIMD;\n       break;\n     default:\n@@ -10208,8 +10174,6 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n     {\n     case OMP_FOR: kind = GF_OMP_FOR_KIND_FOR; break;\n     case OMP_SIMD: kind = GF_OMP_FOR_KIND_SIMD; break;\n-    case CILK_SIMD: kind = GF_OMP_FOR_KIND_CILKSIMD; break;\n-    case CILK_FOR: kind = GF_OMP_FOR_KIND_CILKFOR; break;\n     case OMP_DISTRIBUTE: kind = GF_OMP_FOR_KIND_DISTRIBUTE; break;\n     case OMP_TASKLOOP: kind = GF_OMP_FOR_KIND_TASKLOOP; break;\n     case OACC_LOOP: kind = GF_OMP_FOR_KIND_OACC_LOOP; break;\n@@ -11805,8 +11769,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n \tcase OMP_FOR:\n \tcase OMP_SIMD:\n-\tcase CILK_SIMD:\n-\tcase CILK_FOR:\n \tcase OMP_DISTRIBUTE:\n \tcase OMP_TASKLOOP:\n \tcase OACC_LOOP:\n@@ -11994,22 +11956,6 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    break;\n \t  }\n \n-\tcase CILK_SYNC_STMT:\n-\t  {\n-\t    if (!fn_contains_cilk_spawn_p (cfun))\n-\t      {\n-\t\terror_at (EXPR_LOCATION (*expr_p),\n-\t\t\t  \"expected %<_Cilk_spawn%> before %<_Cilk_sync%>\");\n-\t\tret = GS_ERROR;\n-\t      }\n-\t    else\n-\t      {\n-\t\tgimplify_cilk_sync (expr_p, pre_p);\n-\t\tret = GS_ALL_DONE;\n-\t      }\n-\t    break;\n-\t  }\n-\t\n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {"}, {"sha": "9fb195a6973b3fe8ca303087cbfb4d1248964dec", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -79,7 +79,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"ipa-utils.h\"\n-#include \"cilk.h\"\n #include \"cfgexpand.h\"\n #include \"gimplify.h\"\n #include \"stringpool.h\"\n@@ -891,8 +890,6 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \" always_inline\");\n       if (s->inlinable)\n \tfprintf (f, \" inlinable\");\n-      if (s->contains_cilk_spawn)\n-\tfprintf (f, \" contains_cilk_spawn\");\n       if (s->fp_expressions)\n \tfprintf (f, \" fp_expression\");\n       fprintf (f, \"\\n  global time:     %f\\n\", s->time.to_double ());\n@@ -2439,8 +2436,6 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n        else\n \t info->inlinable = tree_inlinable_function_p (node->decl);\n \n-       info->contains_cilk_spawn = fn_contains_cilk_spawn_p (cfun);\n-\n        /* Type attributes can use parameter indices to describe them.  */\n        if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n \t node->local.can_change_signature = false;\n@@ -3263,7 +3258,6 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \n       bp = streamer_read_bitpack (&ib);\n       info->inlinable = bp_unpack_value (&bp, 1);\n-      info->contains_cilk_spawn = bp_unpack_value (&bp, 1);\n       info->fp_expressions = bp_unpack_value (&bp, 1);\n \n       count2 = streamer_read_uhwi (&ib);\n@@ -3417,7 +3411,7 @@ ipa_fn_summary_write (void)\n \t  info->time.stream_out (ob);\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, info->inlinable, 1);\n-\t  bp_pack_value (&bp, info->contains_cilk_spawn, 1);\n+\t  bp_pack_value (&bp, false, 1);\n \t  bp_pack_value (&bp, info->fp_expressions, 1);\n \t  streamer_write_bitpack (&bp);\n \t  streamer_write_uhwi (ob, vec_safe_length (info->conds));"}, {"sha": "ecf1d6012c51cc2d2ef644de750ceff98678bda2", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -98,9 +98,6 @@ struct GTY(()) ipa_fn_summary\n \n   /* False when there something makes inlining impossible (such as va_arg).  */\n   unsigned inlinable : 1;\n-  /* True when function contains cilk spawn (and thus we can not inline\n-     into it).  */\n-  unsigned contains_cilk_spawn : 1;\n   /* True wen there is only one caller of the function before small function\n      inlining.  */\n   unsigned int single_caller : 1;\n@@ -145,7 +142,7 @@ struct GTY(()) ipa_fn_summary\n      This is useful for debugging.  */\n   ipa_fn_summary ()\n     : estimated_self_stack_size (0), self_size (0), min_size (0),\n-      inlinable (false), contains_cilk_spawn (false), single_caller (false),\n+      inlinable (false), single_caller (false),\n       fp_expressions (false), estimated_stack_size (false),\n       stack_frame_offset (false), time (0), size (0), conds (NULL),\n       size_time_table (NULL), loop_iterations (NULL), loop_stride (NULL),"}, {"sha": "2acfe2a7460be42cbb161cdb82bc703ca5c7dfdc", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -47,7 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"ipa-utils.h\"\n-#include \"cilk.h\"\n #include \"cfgexpand.h\"\n #include \"gimplify.h\"\n "}, {"sha": "a9ed17ea308bbe0edff4dafdbacbfa5215569d74", "filename": "gcc/ira.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -2286,9 +2286,6 @@ ira_setup_eliminable_regset (void)\n \t   && cfun->can_throw_non_call_exceptions)\n        || crtl->accesses_prior_frames\n        || (SUPPORTS_STACK_ALIGNMENT && crtl->stack_realign_needed)\n-       /* We need a frame pointer for all Cilk Plus functions that use\n-\t  Cilk keywords.  */\n-       || (flag_cilkplus && cfun->is_cilk_function)\n        || targetm.frame_pointer_required ());\n \n     /* The chance that FRAME_POINTER_NEEDED is changed from inspecting"}, {"sha": "372d2dba86ce9d7861db648f0d10308c069d377d", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -282,7 +282,6 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \n \tcase OPT_fopenmp:\n \tcase OPT_fopenacc:\n-\tcase OPT_fcilkplus:\n \tcase OPT_fcheck_pointer_bounds:\n \t  /* For selected options we can merge conservatively.  */\n \t  for (j = 0; j < *decoded_options_count; ++j)\n@@ -292,7 +291,6 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t    append_option (decoded_options, decoded_options_count, foption);\n \t  /* -fopenmp > -fno-openmp,\n \t     -fopenacc > -fno-openacc,\n-\t     -fcilkplus > -fno-cilkplus,\n \t     -fcheck_pointer_bounds > -fcheck_pointer_bounds  */\n \t  else if (foption->value > (*decoded_options)[j].value)\n \t    (*decoded_options)[j] = *foption;\n@@ -549,7 +547,6 @@ append_compiler_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n \tcase OPT_fopenmp:\n \tcase OPT_fopenacc:\n \tcase OPT_fopenacc_dim_:\n-\tcase OPT_fcilkplus:\n \tcase OPT_foffload_abi_:\n \tcase OPT_O:\n \tcase OPT_Ofast:\n@@ -626,7 +623,6 @@ append_linker_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n \n \tcase OPT_fopenmp:\n \tcase OPT_fopenacc:\n-\tcase OPT_fcilkplus:\n \t  /* Ignore -fno-XXX form of these options, as otherwise\n \t     corresponding builtins will not be enabled.  */\n \t  if (option->value == 0)"}, {"sha": "c2ba3dc50c4235be56307ee46c974398325c3cb9", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -34,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"lto-tree.h\"\n #include \"lto.h\"\n-#include \"cilk.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n@@ -1262,9 +1261,6 @@ lto_init (void)\n \t\t\t   va_list_type_node);\n     }\n \n-  if (flag_cilkplus)\n-    cilk_init_builtins ();\n-\n   targetm.init_builtins ();\n   build_common_builtin_nodes ();\n "}, {"sha": "4aadc6f4170bb31718b92338057feb67b7aa7cb2", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 3, "deletions": 247, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -53,7 +53,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-offload.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"symbol-summary.h\"\n-#include \"cilk.h\"\n #include \"gomp-constants.h\"\n #include \"gimple-pretty-print.h\"\n #include \"hsa-common.h\"\n@@ -728,45 +727,6 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n     }\n }\n \n-/* Insert a function call whose name is FUNC_NAME with the information from\n-   ENTRY_STMT into the basic_block BB.  */\n-\n-static void\n-expand_cilk_for_call (basic_block bb, gomp_parallel *entry_stmt,\n-\t\t      vec <tree, va_gc> *ws_args)\n-{\n-  tree t, t1, t2;\n-  gimple_stmt_iterator gsi;\n-  vec <tree, va_gc> *args;\n-\n-  gcc_assert (vec_safe_length (ws_args) == 2);\n-  tree func_name = (*ws_args)[0];\n-  tree grain = (*ws_args)[1];\n-\n-  tree clauses = gimple_omp_parallel_clauses (entry_stmt);\n-  tree count = omp_find_clause (clauses, OMP_CLAUSE__CILK_FOR_COUNT_);\n-  gcc_assert (count != NULL_TREE);\n-  count = OMP_CLAUSE_OPERAND (count, 0);\n-\n-  gsi = gsi_last_bb (bb);\n-  t = gimple_omp_parallel_data_arg (entry_stmt);\n-  if (t == NULL)\n-    t1 = null_pointer_node;\n-  else\n-    t1 = build_fold_addr_expr (t);\n-  t2 = build_fold_addr_expr (gimple_omp_parallel_child_fn (entry_stmt));\n-\n-  vec_alloc (args, 4);\n-  args->quick_push (t2);\n-  args->quick_push (t1);\n-  args->quick_push (count);\n-  args->quick_push (grain);\n-  t = build_call_expr_loc_vec (UNKNOWN_LOCATION, func_name, args);\n-\n-  force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, false,\n-\t\t\t    GSI_CONTINUE_LINKING);\n-}\n-\n /* Build the function call to GOMP_task to actually\n    generate the task operation.  BB is the block where to insert the code.  */\n \n@@ -1161,18 +1121,7 @@ expand_omp_taskreg (struct omp_region *region)\n   else\n     exit_bb = region->exit;\n \n-  bool is_cilk_for\n-    = (flag_cilkplus\n-       && gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL\n-       && omp_find_clause (gimple_omp_parallel_clauses (entry_stmt),\n-\t\t\t   OMP_CLAUSE__CILK_FOR_COUNT_) != NULL_TREE);\n-\n-  if (is_cilk_for)\n-    /* If it is a _Cilk_for statement, it is modelled *like* a parallel for,\n-       and the inner statement contains the name of the built-in function\n-       and grain.  */\n-    ws_args = region->inner->ws_args;\n-  else if (is_combined_parallel (region))\n+  if (is_combined_parallel (region))\n     ws_args = region->ws_args;\n   else\n     ws_args = NULL;\n@@ -1430,11 +1379,7 @@ expand_omp_taskreg (struct omp_region *region)\n \t}\n     }\n \n-  /* Emit a library call to launch the children threads.  */\n-  if (is_cilk_for)\n-    expand_cilk_for_call (new_bb,\n-\t\t\t  as_a <gomp_parallel *> (entry_stmt), ws_args);\n-  else if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n+  if (gimple_code (entry_stmt) == GIMPLE_OMP_PARALLEL)\n     expand_parallel_call (region, new_bb,\n \t\t\t  as_a <gomp_parallel *> (entry_stmt), ws_args);\n   else\n@@ -4342,193 +4287,6 @@ expand_omp_for_static_chunk (struct omp_region *region,\n     }\n }\n \n-/* A subroutine of expand_omp_for.  Generate code for _Cilk_for loop.\n-   Given parameters:\n-   for (V = N1; V cond N2; V += STEP) BODY;\n-\n-   where COND is \"<\" or \">\" or \"!=\", we generate pseudocode\n-\n-   for (ind_var = low; ind_var < high; ind_var++)\n-     {\n-       V = n1 + (ind_var * STEP)\n-\n-       <BODY>\n-     }\n-\n-   In the above pseudocode, low and high are function parameters of the\n-   child function.  In the function below, we are inserting a temp.\n-   variable that will be making a call to two OMP functions that will not be\n-   found in the body of _Cilk_for (since OMP_FOR cannot be mixed\n-   with _Cilk_for).  These functions are replaced with low and high\n-   by the function that handles taskreg.  */\n-\n-\n-static void\n-expand_cilk_for (struct omp_region *region, struct omp_for_data *fd)\n-{\n-  bool broken_loop = region->cont == NULL;\n-  basic_block entry_bb = region->entry;\n-  basic_block cont_bb = region->cont;\n-\n-  gcc_assert (EDGE_COUNT (entry_bb->succs) == 2);\n-  gcc_assert (broken_loop\n-\t      || BRANCH_EDGE (entry_bb)->dest == FALLTHRU_EDGE (cont_bb)->dest);\n-  basic_block l0_bb = FALLTHRU_EDGE (entry_bb)->dest;\n-  basic_block l1_bb, l2_bb;\n-\n-  if (!broken_loop)\n-    {\n-      gcc_assert (BRANCH_EDGE (cont_bb)->dest == l0_bb);\n-      gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n-      l1_bb = split_block (cont_bb, last_stmt (cont_bb))->dest;\n-      l2_bb = BRANCH_EDGE (entry_bb)->dest;\n-    }\n-  else\n-    {\n-      BRANCH_EDGE (entry_bb)->flags &= ~EDGE_ABNORMAL;\n-      l1_bb = split_edge (BRANCH_EDGE (entry_bb));\n-      l2_bb = single_succ (l1_bb);\n-    }\n-  basic_block exit_bb = region->exit;\n-  basic_block l2_dom_bb = NULL;\n-\n-  gimple_stmt_iterator gsi = gsi_last_bb (entry_bb);\n-\n-  /* Below statements until the \"tree high_val = ...\" are pseudo statements\n-     used to pass information to be used by expand_omp_taskreg.\n-     low_val and high_val will be replaced by the __low and __high\n-     parameter from the child function.\n-\n-     The call_exprs part is a place-holder, it is mainly used\n-     to distinctly identify to the top-level part that this is\n-     where we should put low and high (reasoning given in header\n-     comment).  */\n-\n-  gomp_parallel *par_stmt\n-    = as_a <gomp_parallel *> (last_stmt (region->outer->entry));\n-  tree child_fndecl = gimple_omp_parallel_child_fn (par_stmt);\n-  tree t, low_val = NULL_TREE, high_val = NULL_TREE;\n-  for (t = DECL_ARGUMENTS (child_fndecl); t; t = TREE_CHAIN (t))\n-    {\n-      if (id_equal (DECL_NAME (t), \"__high\"))\n-\thigh_val = t;\n-      else if (id_equal (DECL_NAME (t), \"__low\"))\n-\tlow_val = t;\n-    }\n-  gcc_assert (low_val && high_val);\n-\n-  tree type = TREE_TYPE (low_val);\n-  tree ind_var = create_tmp_reg (type, \"__cilk_ind_var\");\n-  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n-\n-  /* Not needed in SSA form right now.  */\n-  gcc_assert (!gimple_in_ssa_p (cfun));\n-  if (l2_dom_bb == NULL)\n-    l2_dom_bb = l1_bb;\n-\n-  tree n1 = low_val;\n-  tree n2 = high_val;\n-\n-  gimple *stmt = gimple_build_assign (ind_var, n1);\n-\n-  /* Replace the GIMPLE_OMP_FOR statement.  */\n-  gsi_replace (&gsi, stmt, true);\n-\n-  if (!broken_loop)\n-    {\n-      /* Code to control the increment goes in the CONT_BB.  */\n-      gsi = gsi_last_bb (cont_bb);\n-      stmt = gsi_stmt (gsi);\n-      gcc_assert (gimple_code (stmt) == GIMPLE_OMP_CONTINUE);\n-      stmt = gimple_build_assign (ind_var, PLUS_EXPR, ind_var,\n-\t\t\t\t  build_one_cst (type));\n-\n-      /* Replace GIMPLE_OMP_CONTINUE.  */\n-      gsi_replace (&gsi, stmt, true);\n-    }\n-\n-  /* Emit the condition in L1_BB.  */\n-  gsi = gsi_after_labels (l1_bb);\n-  t = fold_build2 (MULT_EXPR, TREE_TYPE (fd->loop.step),\n-\t\t   fold_convert (TREE_TYPE (fd->loop.step), ind_var),\n-\t\t   fd->loop.step);\n-  if (POINTER_TYPE_P (TREE_TYPE (fd->loop.n1)))\n-    t = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (fd->loop.n1),\n-\t\t     fd->loop.n1, fold_convert (sizetype, t));\n-  else\n-    t = fold_build2 (PLUS_EXPR, TREE_TYPE (fd->loop.n1),\n-\t\t     fd->loop.n1, fold_convert (TREE_TYPE (fd->loop.n1), t));\n-  t = fold_convert (TREE_TYPE (fd->loop.v), t);\n-  expand_omp_build_assign (&gsi, fd->loop.v, t);\n-\n-  /* The condition is always '<' since the runtime will fill in the low\n-     and high values.  */\n-  stmt = gimple_build_cond (LT_EXPR, ind_var, n2, NULL_TREE, NULL_TREE);\n-  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n-\n-  /* Remove GIMPLE_OMP_RETURN.  */\n-  gsi = gsi_last_bb (exit_bb);\n-  gsi_remove (&gsi, true);\n-\n-  /* Connect the new blocks.  */\n-  remove_edge (FALLTHRU_EDGE (entry_bb));\n-\n-  edge e, ne;\n-  if (!broken_loop)\n-    {\n-      remove_edge (BRANCH_EDGE (entry_bb));\n-      make_edge (entry_bb, l1_bb, EDGE_FALLTHRU);\n-\n-      e = BRANCH_EDGE (l1_bb);\n-      ne = FALLTHRU_EDGE (l1_bb);\n-      e->flags = EDGE_TRUE_VALUE;\n-    }\n-  else\n-    {\n-      single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n-\n-      ne = single_succ_edge (l1_bb);\n-      e = make_edge (l1_bb, l0_bb, EDGE_TRUE_VALUE);\n-\n-    }\n-  ne->flags = EDGE_FALSE_VALUE;\n-  e->probability = profile_probability::guessed_always ().apply_scale (7, 8);\n-  ne->probability = e->probability.invert ();\n-\n-  set_immediate_dominator (CDI_DOMINATORS, l1_bb, entry_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, l2_bb, l2_dom_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, l0_bb, l1_bb);\n-\n-  if (!broken_loop)\n-    {\n-      struct loop *loop = alloc_loop ();\n-      loop->header = l1_bb;\n-      loop->latch = cont_bb;\n-      add_loop (loop, l1_bb->loop_father);\n-      loop->safelen = INT_MAX;\n-    }\n-\n-  /* Pick the correct library function based on the precision of the\n-     induction variable type.  */\n-  tree lib_fun = NULL_TREE;\n-  if (TYPE_PRECISION (type) == 32)\n-    lib_fun = cilk_for_32_fndecl;\n-  else if (TYPE_PRECISION (type) == 64)\n-    lib_fun = cilk_for_64_fndecl;\n-  else\n-    gcc_unreachable ();\n-\n-  gcc_assert (fd->sched_kind == OMP_CLAUSE_SCHEDULE_CILKFOR);\n-\n-  /* WS_ARGS contains the library function flavor to call:\n-     __libcilkrts_cilk_for_64 or __libcilkrts_cilk_for_32), and the\n-     user-defined grain value.  If the user does not define one, then zero\n-     is passed in by the parser.  */\n-  vec_alloc (region->ws_args, 2);\n-  region->ws_args->quick_push (lib_fun);\n-  region->ws_args->quick_push (fd->chunk_size);\n-}\n-\n /* A subroutine of expand_omp_for.  Generate code for a simd non-worksharing\n    loop.  Given parameters:\n \n@@ -5875,8 +5633,6 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n \n   if (gimple_omp_for_kind (fd.for_stmt) & GF_OMP_FOR_SIMD)\n     expand_omp_simd (region, &fd);\n-  else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_CILKFOR)\n-    expand_cilk_for (region, &fd);\n   else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n     {\n       gcc_assert (!inner_stmt);\n@@ -8221,7 +7977,7 @@ class pass_expand_omp : public gimple_opt_pass\n   /* opt_pass methods: */\n   virtual unsigned int execute (function *)\n     {\n-      bool gate = ((flag_cilkplus != 0 || flag_openacc != 0 || flag_openmp != 0\n+      bool gate = ((flag_openacc != 0 || flag_openmp != 0\n \t\t    || flag_openmp_simd != 0)\n \t\t   && !seen_error ());\n "}, {"sha": "0f53661e0cf525340da612a962efcc84e38f2948", "filename": "gcc/omp-general.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -143,8 +143,6 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->sched_modifiers = 0;\n   fd->chunk_size = NULL_TREE;\n   fd->simd_schedule = false;\n-  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_CILKFOR)\n-    fd->sched_kind = OMP_CLAUSE_SCHEDULE_CILKFOR;\n   collapse_iter = NULL;\n   collapse_count = NULL;\n \n@@ -252,9 +250,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \n       loop->cond_code = gimple_omp_for_cond (for_stmt, i);\n       loop->n2 = gimple_omp_for_final (for_stmt, i);\n-      gcc_assert (loop->cond_code != NE_EXPR\n-\t\t  || gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_CILKSIMD\n-\t\t  || gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_CILKFOR);\n+      gcc_assert (loop->cond_code != NE_EXPR);\n       omp_adjust_for_condition (loc, &loop->cond_code, &loop->n2);\n \n       t = gimple_omp_for_incr (for_stmt, i);"}, {"sha": "5076c63fd7346b866574cba7a947acaf777c1f30", "filename": "gcc/omp-low.c", "status": "modified", "additions": 5, "deletions": 85, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1174,7 +1174,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \tcase OMP_CLAUSE_PRIORITY:\n \tcase OMP_CLAUSE_GRAINSIZE:\n \tcase OMP_CLAUSE_NUM_TASKS:\n-\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_NUM_GANGS:\n \tcase OMP_CLAUSE_NUM_WORKERS:\n \tcase OMP_CLAUSE_VECTOR_LENGTH:\n@@ -1486,7 +1485,6 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n \tcase OMP_CLAUSE_NOGROUP:\n \tcase OMP_CLAUSE_DEFAULTMAP:\n \tcase OMP_CLAUSE_USE_DEVICE_PTR:\n-\tcase OMP_CLAUSE__CILK_FOR_COUNT_:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_NUM_GANGS:\n@@ -1529,41 +1527,15 @@ scan_sharing_clauses (tree clauses, omp_context *ctx,\n     }\n }\n \n-/* Create a new name for omp child function.  Returns an identifier.  If\n-   IS_CILK_FOR is true then the suffix for the child function is\n-   \"_cilk_for_fn.\"  */\n+/* Create a new name for omp child function.  Returns an identifier. */\n \n static tree\n-create_omp_child_function_name (bool task_copy, bool is_cilk_for)\n+create_omp_child_function_name (bool task_copy)\n {\n-  if (is_cilk_for)\n-    return clone_function_name (current_function_decl, \"_cilk_for_fn\");\n   return clone_function_name (current_function_decl,\n \t\t\t      task_copy ? \"_omp_cpyfn\" : \"_omp_fn\");\n }\n \n-/* Returns the type of the induction variable for the child function for\n-   _Cilk_for and the types for _high and _low variables based on TYPE.  */\n-\n-static tree\n-cilk_for_check_loop_diff_type (tree type)\n-{\n-  if (TYPE_PRECISION (type) <= TYPE_PRECISION (uint32_type_node))\n-    {\n-      if (TYPE_UNSIGNED (type))\n-\treturn uint32_type_node;\n-      else\n-\treturn integer_type_node;\n-    }\n-  else\n-    {\n-      if (TYPE_UNSIGNED (type))\n-\treturn uint64_type_node;\n-      else\n-\treturn long_long_integer_type_node;\n-    }\n-}\n-\n /* Return true if CTX may belong to offloaded code: either if current function\n    is offloaded, or any enclosing context corresponds to a target region.  */\n \n@@ -1586,24 +1558,10 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n {\n   tree decl, type, name, t;\n \n-  tree cilk_for_count\n-    = (flag_cilkplus && gimple_code (ctx->stmt) == GIMPLE_OMP_PARALLEL)\n-      ? omp_find_clause (gimple_omp_parallel_clauses (ctx->stmt),\n-\t\t\t OMP_CLAUSE__CILK_FOR_COUNT_) : NULL_TREE;\n-  tree cilk_var_type = NULL_TREE;\n-\n-  name = create_omp_child_function_name (task_copy,\n-\t\t\t\t\t cilk_for_count != NULL_TREE);\n+  name = create_omp_child_function_name (task_copy);\n   if (task_copy)\n     type = build_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\t     ptr_type_node, NULL_TREE);\n-  else if (cilk_for_count)\n-    {\n-      type = TREE_TYPE (OMP_CLAUSE_OPERAND (cilk_for_count, 0));\n-      cilk_var_type = cilk_for_check_loop_diff_type (type);\n-      type = build_function_type_list (void_type_node, ptr_type_node,\n-\t\t\t\t       cilk_var_type, cilk_var_type, NULL_TREE);\n-    }\n   else\n     type = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n \n@@ -1660,32 +1618,6 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   DECL_CONTEXT (t) = decl;\n   DECL_RESULT (decl) = t;\n \n-  /* _Cilk_for's child function requires two extra parameters called\n-     __low and __high that are set the by Cilk runtime when it calls this\n-     function.  */\n-  if (cilk_for_count)\n-    {\n-      t = build_decl (DECL_SOURCE_LOCATION (decl),\n-\t\t      PARM_DECL, get_identifier (\"__high\"), cilk_var_type);\n-      DECL_ARTIFICIAL (t) = 1;\n-      DECL_NAMELESS (t) = 1;\n-      DECL_ARG_TYPE (t) = ptr_type_node;\n-      DECL_CONTEXT (t) = current_function_decl;\n-      TREE_USED (t) = 1;\n-      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n-      DECL_ARGUMENTS (decl) = t;\n-\n-      t = build_decl (DECL_SOURCE_LOCATION (decl),\n-\t\t      PARM_DECL, get_identifier (\"__low\"), cilk_var_type);\n-      DECL_ARTIFICIAL (t) = 1;\n-      DECL_NAMELESS (t) = 1;\n-      DECL_ARG_TYPE (t) = ptr_type_node;\n-      DECL_CONTEXT (t) = current_function_decl;\n-      TREE_USED (t) = 1;\n-      DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n-      DECL_ARGUMENTS (decl) = t;\n-    }\n-\n   tree data_name = get_identifier (\".omp_data_i\");\n   t = build_decl (DECL_SOURCE_LOCATION (decl), PARM_DECL, data_name,\n \t\t  ptr_type_node);\n@@ -1695,8 +1627,6 @@ create_omp_child_function (omp_context *ctx, bool task_copy)\n   DECL_CONTEXT (t) = current_function_decl;\n   TREE_USED (t) = 1;\n   TREE_READONLY (t) = 1;\n-  if (cilk_for_count)\n-    DECL_CHAIN (t) = DECL_ARGUMENTS (decl);\n   DECL_ARGUMENTS (decl) = t;\n   if (!task_copy)\n     ctx->receiver_decl = t;\n@@ -8988,7 +8918,7 @@ execute_lower_omp (void)\n \n   /* This pass always runs, to provide PROP_gimple_lomp.\n      But often, there is nothing to do.  */\n-  if (flag_cilkplus == 0 && flag_openacc == 0 && flag_openmp == 0\n+  if (flag_openacc == 0 && flag_openmp == 0\n       && flag_openmp_simd == 0)\n     return 0;\n \n@@ -9080,16 +9010,6 @@ diagnose_sb_0 (gimple_stmt_iterator *gsi_p,\n \n   const char* kind = NULL;\n \n-  if (flag_cilkplus)\n-    {\n-      if ((branch_ctx\n-\t   && gimple_code (branch_ctx) == GIMPLE_OMP_FOR\n-\t   && gimple_omp_for_kind (branch_ctx) == GF_OMP_FOR_KIND_CILKSIMD)\n-\t  || (label_ctx\n-\t      && gimple_code (label_ctx) == GIMPLE_OMP_FOR\n-\t      && gimple_omp_for_kind (label_ctx) == GF_OMP_FOR_KIND_CILKSIMD))\n-\tkind = \"Cilk Plus\";\n-    }\n   if (flag_openacc)\n     {\n       if ((branch_ctx && is_gimple_omp_oacc (branch_ctx))\n@@ -9361,7 +9281,7 @@ class pass_diagnose_omp_blocks : public gimple_opt_pass\n   /* opt_pass methods: */\n   virtual bool gate (function *)\n   {\n-    return flag_cilkplus || flag_openacc || flag_openmp || flag_openmp_simd;\n+    return flag_openacc || flag_openmp || flag_openmp_simd;\n   }\n   virtual unsigned int execute (function *)\n     {"}, {"sha": "432c77d124fab05288a609e923682b7b4416ee66", "filename": "gcc/omp-simd-clone.c", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-simd-clone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Fomp-simd-clone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-simd-clone.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -112,19 +112,11 @@ simd_clone_clauses_extract (struct cgraph_node *node, tree clauses,\n   if (n > 0 && args.last () == void_type_node)\n     n--;\n \n-  /* To distinguish from an OpenMP simd clone, Cilk Plus functions to\n-     be cloned have a distinctive artificial label in addition to \"omp\n-     declare simd\".  */\n-  bool cilk_clone\n-    = (flag_cilkplus\n-       && lookup_attribute (\"cilk simd function\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)));\n-\n   /* Allocate one more than needed just in case this is an in-branch\n      clone which will require a mask argument.  */\n   struct cgraph_simd_clone *clone_info = simd_clone_struct_alloc (n + 1);\n   clone_info->nargs = n;\n-  clone_info->cilk_elemental = cilk_clone;\n+  clone_info->cilk_elemental = false;\n \n   if (!clauses)\n     goto out;"}, {"sha": "95bcafeb781880a33d0572ebba89a0920cf16986", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3", "patch": "@@ -1,3 +1,176 @@\n+2017-11-28  Julia Koval  <julia.koval@intel.com>\n+            Sebastian Peryt  <sebastian.peryt@intel.com>\n+\n+\t* c-c++-common/attr-simd-3.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/an-if.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/array_test1.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/array_test2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/array_test_ND.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/builtin_fn_custom.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/builtin_fn_mutating.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/builtin_func_double.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/builtin_func_double2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/comma_exp.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/conditional.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/decl-ptr-colon.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/dimensionless-arrays.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/exec-once.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/exec-once2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/fn_ptr-2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/fn_ptr.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/fp_triplet_values.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/gather-scatter-errors.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/gather_scatter.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/if_test.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/if_test_errors.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/misc.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/n-ptr-test.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/parser_errors.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/parser_errors2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/parser_errors3.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/parser_errors4.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr57457-2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr57457.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr57490.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr57541-2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr57541.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr57577.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr58942.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr61191.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr61455-2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr61455.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr61962.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr61963.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr62008.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/pr63884.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/rank_mismatch3.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/sec_implicit.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/sec_implicit2.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/sec_implicit_ex.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/sec_reduce_ind_same_value.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/sec_reduce_max_min_ind.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/sec_reduce_return.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/side-effects-1.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/test_builtin_return.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/test_sec_limits.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/tst_lngth.c: Delete.\n+\t* c-c++-common/cilk-plus/AN/vla.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/Wparentheses-1.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk-for-2.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk-for-3.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk-fors.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_errors.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_grain.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_grain_errors.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/cilk_for_ptr_iter.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/compound_cilk_spawn.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/concec_cilk_spawn.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/errors.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/fib.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/fib_init_expr_xy.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/fib_no_return.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/fib_no_sync.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/invalid_spawns.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/invalid_sync.c: Delete.c\n+\t* c-c++-common/cilk-plus/CK/nested_cilk_for.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/no_args_error.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr59631.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr60197-2.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr60197.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr60469.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr60586.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr63307.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr69826-1.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr69826-2.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr79428-4.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/pr79428-7.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/spawn_in_return.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/spawnee_inline.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/spawner_inline.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/spawning_arg.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/steal_check.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/sync_wo_spawn.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/test__cilk.c: Delete.\n+\t* c-c++-common/cilk-plus/CK/varargs_test.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/Wparentheses-1.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/body.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/clauses1.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/clauses2.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/clauses3.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/clauses4.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/for1.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/for2.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/for3.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/pr69363.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/reduction-1.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/reduction-2.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/reduction-3.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/run-1.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/safelen.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/vectorlength-2.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/vectorlength-3.c: Delete.\n+\t* c-c++-common/cilk-plus/PS/vectorlength.c: Delete.\n+\t* c-c++-common/cilk-plus/SE/ef_error.c: Delete.\n+\t* c-c++-common/cilk-plus/SE/ef_error2.c: Delete.\n+\t* c-c++-common/cilk-plus/SE/ef_error3.c: Delete.\n+\t* c-c++-common/cilk-plus/SE/ef_test.c: Delete.\n+\t* c-c++-common/cilk-plus/SE/ef_test2.c: Delete.\n+\t* c-c++-common/cilk-plus/SE/vlength_errors.c: Delete.\n+\t* g++.dg/cilk-plus/AN/array_function.c: Delete.\n+\t* g++.dg/cilk-plus/AN/array_test1_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/AN/array_test2_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/AN/array_test_ND_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/AN/braced_list.c: Delete.\n+\t* g++.dg/cilk-plus/AN/builtin_fn_custom_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/AN/builtin_fn_mutating_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/AN/fp_triplet_values_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/AN/postincr_test.c: Delete.\n+\t* g++.dg/cilk-plus/AN/preincr_test.c: Delete.\n+\t* g++.dg/cilk-plus/CK/catch_exc.c: Delete.\n+\t* g++.dg/cilk-plus/CK/cf3.c: Delete.\n+\t* g++.dg/cilk-plus/CK/cilk-for-tplt.c: Delete.\n+\t* g++.dg/cilk-plus/CK/const_spawn.c: Delete.\n+\t* g++.dg/cilk-plus/CK/fib-opr-overload.c: Delete.\n+\t* g++.dg/cilk-plus/CK/fib-tplt.c: Delete.\n+\t* g++.dg/cilk-plus/CK/for1.c: Delete.\n+\t* g++.dg/cilk-plus/CK/lambda_spawns.c: Delete.\n+\t* g++.dg/cilk-plus/CK/lambda_spawns_tplt.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr60586.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr66326.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr68001.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr68997.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr69024.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr69048.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr69267.c: Delete.\n+\t* g++.dg/cilk-plus/CK/pr80038.c: Delete.\n+\t* g++.dg/cilk-plus/CK/stl_iter.c: Delete.\n+\t* g++.dg/cilk-plus/CK/stl_rev_iter.c: Delete.\n+\t* g++.dg/cilk-plus/CK/stl_test.c: Delete.\n+\t* g++.dg/cilk-plus/cilk-plus.exp\n+\t* g++.dg/cilk-plus/ef_test.C: Delete.\n+\t* g++.dg/cilk-plus/for.C: Delete.\n+\t* g++.dg/cilk-plus/for2.C: Delete.\n+\t* g++.dg/cilk-plus/for3.C: Delete.\n+\t* g++.dg/cilk-plus/for4.C: Delete.\n+\t* g++.dg/cilk-plus/pr60967.C: Delete.\n+\t* g++.dg/cilk-plus/pr69028.C: Delete.\n+\t* g++.dg/cilk-plus/pr70565.C: Delete.\n+\t* g++.dg/pr57662.C: Delete.\n+\t* gcc.dg/cilk-plus/cilk-plus.exp\n+\t* gcc.dg/cilk-plus/for1.c: Delete.\n+\t* gcc.dg/cilk-plus/for2.c: Delete.\n+\t* gcc.dg/cilk-plus/jump-openmp.c: Delete.\n+\t* gcc.dg/cilk-plus/jump.c: Delete.\n+\t* gcc.dg/cilk-plus/pr69798-1.c: Delete.\n+\t* gcc.dg/cilk-plus/pr69798-2.c: Delete.\n+\t* gcc.dg/cilk-plus/pr78306.c: Delete.\n+\t* gcc.dg/cilk-plus/pr79116.c: Delete.\n+\t* gcc.dg/graphite/id-28.c: Delete.\n+\t* lib/cilk-plus-dg.exp: Delete.\n+\t* lib/target-supports.exp (cilkplus_runtime): Delete.\n+\n 2017-11-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/81020"}, {"sha": "56552bd7e0882079f2151e8cb38efec316c188bc", "filename": "gcc/testsuite/c-c++-common/attr-simd-3.c", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-simd-3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,5 +0,0 @@\n-/* { dg-do compile { target cilkplus } } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-prune-output \"undeclared here \\\\(not in a function\\\\)|\\[^\\n\\r\\]* was not declared in this scope\" } */\n-\n-void f () __attribute__((__simd__, __vector__)); /* { dg-error \"in the same function marked as a Cilk Plus\" \"PR68158\" } */"}, {"sha": "4ac46abc4048133d5dab7572d484bbb8b80dc58a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/an-if.c", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fan-if.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fan-if.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fan-if.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,51 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus -fdump-tree-original\" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-#include <assert.h>\n-\n-const int n = 8;\n-\n-float x[8], y[8], z[8];\n-\n-int main() {\n-    int i = 0;\n-    float x_sum =0;\n-    for(i=1; i<=5; i+=4 ) {\n-        x[0:n] = 3;\n-        y[0:n] = i;\n-        z[0:n] = 0;\n-#if HAVE_IO\n-        printf(\"x\\ty\\tz\\n\");\n-        for( size_t k=0; k<n; ++k ) {\n-            printf(\"%g\\t%g\\t%g\\n\",x[k],y[k],z[k]);\n-        }\n-\tx_sum = __sec_reduce_add (x[0:n]);\n-\tprintf(\"sec_reduce_add (x[0:n]) = %6.3f\\n\", x_sum);\n-#endif\n-        assert( __sec_reduce_add(x[0:n])==3*n );\n-        assert( __sec_reduce_add(y[0:n])==i*n );\n-        assert( __sec_reduce_add(z[0:n])==0 );\n-\n-        if (x[0:n] >= y[0:n]) {  \n-            z[0:n] = x[0:n] - y[0:n];\n-        } else {   \n-            z[0:n] = x[0:n] + y[0:n];\n-        }\n-#if HAVE_IO\n-        printf(\"x\\ty\\tz\\n\");\n-        for( size_t k=0; k<n; ++k ) {\n-            printf(\"%g\\t%g\\t%g\\n\",x[k],y[k],z[k]);\n-        }\n-#endif\n-        assert( __sec_reduce_add(x[0:n])==3*n );\n-        assert( __sec_reduce_add(y[0:n])==i*n );\n-        assert( __sec_reduce_add(z[0:n])==(3>=i?3-i:3+i)*n );\n-    }\n-    return 0;\n-}\n-\n-/* The C++ FE once emitted a bogus error_mark_node for this test case.  */\n-/* { dg-final { scan-tree-dump-not \"<<< error >>>\" \"original\" } } */"}, {"sha": "282a55d6fc6d6713c5559bd75db41f13ccb0fbf6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/array_test1.c", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,84 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-\n-int main2 (char **argv);\n-\n-int main(void)\n-{\n-  int x = 0; \n-  const char *array[] = {\"a.out\", \"5\"};\t     \n-  x = main2 ((char **)array);\n-  return x;\n-}\n-\n-int main2 (char **argv)\n-{\n-  int array[10], ii = 0, x = 2, z= 0 , y = 0 ;\n-  for (ii = 0; ii < 10; ii++)\n-    array[ii] = 10;\n-\n-  array[0:10:1] = 15;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array[ii] != 15)\n-      return 5;\n-  array[0:5:2] = 20;\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    if (array[ii] != 20)\n-      return 4;\n-\n-\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-\n-  array[x:5:z] = 50;\n-  \n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != 50)\n-      return 3;\n-\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-  \n-  array[x:y:z] = 505;\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != 505)\n-      return 4;\n-    \n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-  \n-  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = 25;\n-\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != 25)\n-      return 5;\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n- \n-  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n-    1400;\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != 1400)\n-      return 6;\n-  \n-\n-  array[atoi(\"5\"):5:1] = 5555;\n-  \n-  for (ii = atoi (\"5\"); ii < 10; ii++)\n-    if (array[ii] != 5555)\n-      return 7;\n-  \n-\n-  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = 9999;\n-  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n-    if (array[ii] != 9999)\n-      return 8;\n-  return 0;\n-}"}, {"sha": "60f2de2834a1a0869c8a94fc77e4bdc96c483731", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/array_test2.c", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,128 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-int main2 (char **argv);\n-int main(void)\n-{\n-  int x = 0; \n-  const char *array[] = {\"a.out\", \"5\"};\t     \n-  x = main2 ((char **)array);\n-  return x;\n-}\n-\n-\n-int main2(char **argv)\n-{\n-  int array[10], array2[10], ii = 0, x = 2, z= 0 , y = 0 ;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 10;\n-      array2[ii] = 5000000;\n-    }\n-\n-  array2[0:10:1] = array[0:10:1];\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array2[ii] != array[ii])\n-      return 1;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 10;\n-      array2[ii] = 5000000;\n-    }\n-  \n-  array2[0:5:2] = array[0:5:2];\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    if (array[ii] != array2[ii])\n-      return 2;\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 10;\n-      array2[ii] = 5000000;\n-    }\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n- \n-  array2[x:5:z] = array[x:5:z];\n-\n-  for (ii = x; ii < 5; ii += z)\n-    if (array2[ii] != array[ii])\n-      return 3;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 500;\n-      array2[ii] = 1000000;\n-    }\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-\n-  array2[x:y:z] = array[x:y:z];\n-  for (ii = x; ii < 10; ii = ii + z)\n-    if (array2[ii] != array[ii])\n-      return 4;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 500;\n-      array2[ii] = 1000000;\n-    }\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-\n-  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = \n-    array2[x:y:((10-atoi(argv[1]))/atoi(argv[1]))];\n-\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != array2[ii])\n-      return 5;\n-  \n-  \n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 500;\n-      array2[ii] = 1000000;\n-    }\n-  \n-  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n-    array2[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))];\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != array2[ii])\n-      return 6;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 4;\n-      array2[ii] = 2;\n-    }\n-\n-  array[atoi(\"5\"):5:1] = array2[atoi(\"5\"):5:1];\n-\n-  for (ii = atoi (\"5\"); ii < 10; ii++)\n-    if (array[ii] != array2[ii])\n-      return (7);\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 5;\n-      array2[ii] = 1;\n-    }\n-  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = array2[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")];\n-\n-  for (ii = 5; ii < 10; ii++)\n-    if (array2[ii] != array[ii])\n-      return 8;\n- \n-  return 0;\n-}"}, {"sha": "e89bbab268bb2a61a7ac828f6c501a883ebd4dba", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/array_test_ND.c", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test_ND.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test_ND.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Farray_test_ND.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,102 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-int main2(char **argv);\n-int main(void)\n-{\n-  int x = 0; \n-  const char *array[] = {\"a.out\", \"10\", \"15\"};\t     \n-  x = main2 ((char **)array);\n-  return x;\n-}\n-\n-int main2(char **argv)\n-{  \n-  int array[10][15], ii = 0, jj = 0,x = 0, z= 1 , y = 10 ;\n-  int array_2[10][15];\n-  int argc = 3;\n-  __asm volatile (\"\" : \"+r\" (argc));\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  array_2[0:5:2][0:5:3] = array[0:5:2][0:5:3] + 1 + 5 + array[0][5] + x;\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    {\n-      for (jj = 0; jj < 15; jj += 3)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + 1 + 5 + array[0][5] + x)\n-\t    return 2;\n-\t}\n-    }\n-\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  x = atoi(argv[1]);\n-  y = atoi(argv[2]);\n-  array_2[0:x:1][0:y:1] = array[0:x:1][0:y:1] + x + y + array[0:x:1][0:y:1];\n-\n-  for (ii = 0; ii < x; ii++)\n-    {\n-      for (jj = 0; jj < y; jj++)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + x + y + array[ii][jj])\n-\t    return 3;\n-\t}\n-    }\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  x = atoi(argv[1]);\n-  y = atoi(argv[2]);\n-  z = (20- atoi (argv[1]))/atoi(argv[1]);\n-  /* (20-10)/10 evaluates to 1 all the time :-). */\n-  array_2[0:x:z][0:y:z] = array[0:x:z][0:y:z] + array[0:x:z][0:y:z] + y + z;\n-  \n-  for (ii = 0; ii < x; ii += z)\n-    {\n-      for (jj = 0; jj < y; jj += z)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] + y + z)\n-\t    return 4;\n-\t}\n-    }\n-\n-\n- \n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  x = argc-3;\n-  y = 20-atoi(argv[1]);\n-  z = (20- atoi (argv[1]))/atoi(argv[1]);\n-  /* (20-10)/10 evaluates to 1 all the time :-). */\n-  array_2[(argc-3):(20-atoi(argv[1])):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): ((30-atoi(argv[2]))/atoi(argv[2]))] = array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] + array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] * array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])];\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      for (jj = 0; jj < 15; jj++)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] * array[ii][jj])\n-\t    return 5;\n-\t}\n-    }\n-  return 0;\n-}"}, {"sha": "8f6770b870e5da8128505908e99d63656704cc62", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_fn_custom.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,70 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-ffloat-store\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n-\n-#define NUMBER 100\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-/* #include <stdlib.h> */\n-\n-double my_func (double x, double y)\n-{\n-  if (x > y)\n-    return x;\n-  else\n-    return y;\n-}\n-\n-\n-/* char __sec_reduce_add (int *); */\n-int main(void)\n-{\n-  int ii,array[NUMBER], y = 0, y_int = 0, array2[NUMBER];\n-  double x, yy, array3[NUMBER], array4[NUMBER];\n-  double max_value = 0.000, min_value = 0.000, add_value, mul_value = 1.00;\n-  int max_index = 0, min_index = 0;\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      array[ii] = 1+ii;\n-      array2[ii]= 2; \n-    }\n-\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      if (ii%2 && ii)\n-\tarray3[ii] = (double)(1.0000/(double)ii);\n-      else\n-\tarray3[ii] = (double) ii + 0.10;\n-      array4[ii] = (double) (1.00000/ (double)(ii+1));\n-    }\n-\n-  /* array[:] = 5; */\n-  x = __sec_reduce (0, array3[:] * array4[:], my_func); \n-  y = __sec_reduce_max_ind ( array3[:] * array4[:]);\n-\n-  /* Initialize it to the first variable.  */\n-  max_value = array3[0] * array4[0];\n-  for (ii = 0; ii < NUMBER; ii++)\n-    if (array3[ii] * array4[ii] > max_value) {\n-      max_value = array3[ii] * array4[ii];\n-      max_index = ii;\n-    }\n-    \n-  \n-  \n-#if HAVE_IO\n-  for (ii = 0; ii < NUMBER; ii++) \n-    printf(\"%5.3f \", array3[ii] * array4[ii]);\n-  printf(\"\\n\");\n-  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", x, y);\n-#endif\n-\n-  if (x != max_value)\n-    return 1;\n-\n-  if (y != max_index)\n-    return 2;\n-\n-  return 0;\n-}"}, {"sha": "760d315d54ca9c586b27a87aa522e879267c7cc2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_fn_mutating.c", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,70 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-ffloat-store\" { target { { i?86-*-* x86_64-*-* } && ilp32 } } } */\n-\n-#define NUMBER 100\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-/* #include <stdlib.h> */\n-\n-void my_func (double *x, double y)\n-{\n-  if (*x < y)\n-    *x = y;\n-}\n-\n-\n-int main(void)\n-{\n-  int ii,array[NUMBER], y = 0, y_int = 0, array2[NUMBER];\n-  double x = 0.000, yy, array3[NUMBER], array4[NUMBER];\n-  double max_value = 0.000, min_value = 0.000, add_value, mul_value = 1.00;\n-  int max_index = 0, min_index = 0;\n-#if 1\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      array[ii] = 1+ii;\n-      array2[ii]= 2; \n-    }\n-\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      if (ii%2 && ii)\n-\tarray3[ii] = (double)(1.0000/(double)ii);\n-      else\n-\tarray3[ii] = (double) ii + 0.10;\n-      array4[ii] = (double) (1.00000/ (double)(ii+1));\n-    }\n-#endif \n-  /* array[:] = 5; */\n-  __sec_reduce_mutating (&x, array3[:] * array4[:], my_func); \n-#if  1\n-  y = __sec_reduce_max_ind ( array3[:] * array4[:]);\n-\n-  /* Initialize it to the first variable.  */\n-  max_value = array3[0] * array4[0];\n-  for (ii = 0; ii < NUMBER; ii++)\n-    if (array3[ii] * array4[ii] > max_value) {\n-      max_index = ii;\n-    }\n-    \n-  for (ii = 0; ii < NUMBER; ii++)\n-    my_func (&max_value, array3[ii] * array4[ii]);\n-  \n-#if HAVE_IO\n-  for (ii = 0; ii < NUMBER; ii++) \n-    printf(\"%5.3f \", array3[ii] * array4[ii]);\n-  printf(\"\\n\");\n-  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", x, y);\n-  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", max_value, max_index);\n-#endif\n-\n-  if (x != max_value)\n-    return 1;\n-\n-  if (y != max_index)\n-    return 2;\n-#endif\n-  return 0;\n-}"}, {"sha": "0c05994ee301c75b97954733bec50b241e32962d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_func_double.c", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,124 +0,0 @@\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-/* #include <stdlib.h> */\n-\n-/* char __sec_reduce_add (int *); */\n-int main(void)\n-{\n-  int ii,array[10], y = 0, y_int = 0, array2[10];\n-  double x, yy, array3[10], array4[10];\n-  double max_value = 0.000, min_value = 0.000, add_value, mul_value = 1.00;\n-  int max_index = 0, min_index = 0;\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 1+ii;\n-      array2[ii]= 2; \n-    }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      if (ii%2 && ii)\n-\tarray3[ii] = (double)(1.0000/(double)ii);\n-      else\n-\tarray3[ii] = (double) ii + 0.10;\n-      array4[ii] = (double) (1.00000/ (double)(ii+1));\n-    }\n-\n-  /* array[:] = 5; */\n-  x = __sec_reduce_max (array3[:] * array4[:]); \n-  y = __sec_reduce_max_ind ( array3[:] * array4[:]);\n-\n-  /* Initialize it to the first variable.  */\n-  max_value = array3[0] * array4[0];\n-  for (ii = 0; ii < 10; ii++)\n-    if (array3[ii] * array4[ii] > max_value) {\n-      max_value = array3[ii] * array4[ii];\n-      max_index = ii;\n-    }\n-    \n-  \n-  \n-#if HAVE_IO\n-  for (ii = 0; ii < 10; ii++) \n-    printf(\"%5.3f \", array3[ii] * array4[ii]);\n-  printf(\"\\n\");\n-  printf(\"Max = %5.3f\\t Max Index = %2d\\n\", x, y);\n-#endif\n-\n-  if (x != max_value)\n-    return 1;\n-\n-  if (y != max_index)\n-    return 2;\n-\n-  x = __sec_reduce_min (array3[:] * array4[:]); \n-  y = __sec_reduce_min_ind ( array3[:] * array4[:]); \n-#if HAVE_IO\n-  for (ii = 0; ii < 10; ii++) \n-    printf(\"%5.3f \", array3[ii] * array4[ii]);\n-  printf(\"\\n\");\n-  printf(\"Min = %5.3f\\t Min Index = %2d\\n\", x, y);\n-#endif\n-\n-  /* Initialize it to the first variable.  */\n-  min_value = array3[0] * array4[0];\n-  for (ii = 0; ii < 10; ii++)\n-    if (array3[ii] * array4[ii] < min_value) {\n-      min_value = array3[ii] * array4[ii];\n-      min_index = ii;\n-    }\n-\n-  if (x != min_value)\n-    return 3;\n-  if (y != min_index)\n-    return 4;\n-\n-  x = __sec_reduce_add (array3[:] * array4[:]); \n-  yy = __sec_reduce_mul ( array3[:] * array4[:]); \n-#if HAVE_IO\n-  for (ii = 0; ii < 10; ii++) \n-    printf(\"%5.3f \", array3[ii] * array4[ii]);\n-  printf(\"\\n\");\n-  printf(\"Add = %5.3f\\t Mul = %f\\n\", x, yy);\n-#endif\n-\n-   /* Initialize it to the first variable.  */\n-  add_value = 0.0000;\n-  mul_value = 1.0000;\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      add_value += (array3[ii] * array4[ii]);\n-      mul_value *= (array3[ii] * array4[ii]);\n-    }\n-\n-  if (x != add_value)\n-    return 5;\n-  if (yy != mul_value)\n-    return 6;\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      if (ii%2 && ii)\n-\tarray3[ii] = (double)(1.0000/(double)ii);\n-      else\n-\tarray3[ii] = (double) ii + 0.00;\n-      array4[ii] = (double) (1.00000/ (double)(ii+1));\n-    }\n-  y_int = __sec_reduce_any_zero (array3[:] * array4[:]); \n-  y = __sec_reduce_all_zero ( array3[:] * array4[:]);\n-\n-  if (y_int != 1)\n-    return 7;\n-\n-  if (y != 0)\n-    return 8;\n-  \n-#if HAVE_IO\n-  for (ii = 0; ii < 10; ii++) \n-    printf(\"%5.3f \", array3[ii] * array4[ii]);\n-  printf(\"\\n\");\n-  printf(\"Any Zeros = %d\\t All Zeros = %d\\n\", y_int, y);\n-#endif\n-  return 0;\n-}"}, {"sha": "65549121b192a1b1c6a7d8009141b90fed424f17", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/builtin_func_double2.c", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fbuiltin_func_double2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,77 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define NUMBER 100\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-int main(void)\n-{\n-  int argc = 1;\n-  int ii,array[NUMBER], y = 0, y_int = 0, array2[NUMBER], y_int2=0, y2=0;\n-  double x, yy, array3[NUMBER], array4[NUMBER];\n-  int all_zero, all_nonzero, any_zero, any_nonzero;\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      array[ii] = 0;\n-      array2[ii] = 5;\n-      if (ii%2 && ii)\n-\tarray3[ii] = (double)(1.0000/(double)ii);\n-      else\n-\tarray3[ii] = (double) ii + 0.00;\n-      array4[ii] = (double) (1.00000/ (double)(ii+1));\n-    }\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  y_int = __sec_reduce_any_nonzero (array3[:] + array[4]); \n-  y_int2 = __sec_reduce_any_zero (array3[:] + array[4]); \n-  y = __sec_reduce_all_nonzero ((array3[:] + array4[:]) * (argc-1)); \n-  y2 = __sec_reduce_all_zero ((array3[:] + array4[:]) * (argc-1));\n-\n-  any_zero = 0;\n-  any_nonzero = 0;\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      if ((array3[ii] + array[4]) == 0)\n-\tany_zero = 1;\n-      else\n-\tany_nonzero = 1;\n-    }\n-\n-  if (any_nonzero != y_int)\n-    return 1;\n-  if (any_zero != y_int2)\n-    return 2;\n-\n-\n-  all_zero = 0;\n-  all_nonzero = 0;\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      if (((array3[ii] + array4[ii]) * (argc-1)) == 0)\n-\tall_zero = 1;\n-      else\n-\tall_nonzero = 1;\n-    }\n-\n-  if (y != all_nonzero)\n-    return 3;\n-  if (all_zero != y2)\n-    return 4;\n- \n-\n-#if HAVE_IO\n-  for (ii = 0; ii < NUMBER; ii++) {\n-    printf(\"%5.3f \", array3[ii] +array4[ii]);\n-  }\n-  printf(\"\\n\");\n-  for (ii = 0; ii < NUMBER; ii++) {\n-    printf(\"%5.3f \", (array3[ii] + array4[ii]) * (argc-1));\n-  }\n-  printf(\"\\n\");\n-  printf(\"Any Non-zeros (1st line) = %d\\t All non-zeros (1st line) = %d\\n\", \n-\t y_int, y);\n-  printf(\"Any zeros (2nd line) = %d\\t All zeros (2nd line) = %d\\n\", y_int2, y2);\n-#endif\n-  return 0;\n-}"}, {"sha": "845d916ab96bd444928fbf902a60b8a703afb26f", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/comma_exp.c", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fcomma_exp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fcomma_exp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fcomma_exp.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,55 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-\n-int main2 (char **argv);\n-int main(void)\n-{\n-  int x = 0; \n-  const char *array[] = {\"a.out\", \"5\"};\t     \n-  x = main2 ((char **)array);\n-  return x;\n-}\n-\n-int main2 (char **argv)\n-{\n-  int argc = 2;\n-  int array[10], array2[10], ii = 0, x = 2, z= 0 , y = 0 ;\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  for (ii = 0; ii < 10; ii++)\n-    array[ii] = 10;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    array2[ii] = 1;\n-\n-  array[0:10:1] = (array[:], 15);\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array[ii] != 15)\n-      return 1;\n-  array[0:5:2] = (argc+2, 20);\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    if (array[ii] != 20)\n-      return 2;\n-\n-\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-\n-  array[x:5:z] = 50;\n-\n-  array[:]  = (atoi(argv[1]), (array2[0:10]+5));\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array[ii] != 6)\n-      return (3);\n-\n-  array[:] = (atoi(argv[1]), (array2[0:10]+array2[0:10]));\n-  for (ii = 0; ii < 10; ii++)\n-    if (array[ii] != 2)\n-      return 4;\n-  \n-  return 0;\n-}"}, {"sha": "07c50173bfb7abaf64514d8bb595d61631c45943", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/conditional.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fconditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fconditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fconditional.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,44 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-int main(void)\n-{\n-  int argc = 1;\n-  short array[1000], array2[1000], *array3, cond[1000], ii = 0;\n-\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  for (ii = 0; ii < 1000; ii++) {\n-    cond[ii] = 1;\n-    array[ii] = 1000;\n-    array2[ii] = 2000;\n-  }\n-  array2[:] = cond[:] ?  array[:] : array2[:];\n- \n-  for (ii = 0; ii < 1000; ii++) {\n-   if (array2[ii] != 1000)\n-     return 1;\n-  }\n-\n-  array2[0:500:2] = cond[0:500] ? array[0:500:1] : array2[0:500:2];\n-\n-  for (ii = 0; ii < 1000; ii++) {\n-   if (array2[ii] != 1000)\n-     return 2;\n-  }\n-\n-  for (ii = 0; ii < 1000; ii++) {\n-    cond[ii] = ii % 2; /* This should give 0, 1, 0, 1, 0, 1, 0,... */\n-    array2[ii] = 5;\n-    array[ii] = 3; \n-  }\n-  array3 = (short *) malloc (sizeof (short) * 1000);\n-  array3[0:1000:argc] = cond[:] ? array[0:(argc * 1000)] : array2[argc-1:1000];\n-  \n-  for (ii = 0; ii < 1000; ii++) {\n-    if ((cond[ii] == 0 && array3[ii] != 5) \n-        || (cond[ii] == 1 && array3[ii] != 3))\n-     return 3;\n-  }\n-  return 0;\n-}"}, {"sha": "4b54f4d06f729cc0a28d27d1d8a6f97cb65644a6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/decl-ptr-colon.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdecl-ptr-colon.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-do compile { target c } } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main(void)\n-{\n-  extern int func(int);\n-  int array3[:], x, q; /* { dg-error \"array notations cannot be used in declaration\" } */\n-  int  array3[1:2:x]; /* { dg-error \"array notations cannot be used in declaration\" } */\n-  extern char array3[1:func(x)]; /* { dg-error \"array notations cannot be used in declaration\" } */\n-  int *a, ***b;\n-  extern char *c;\n-  int array2[10];\n-\n-  a[:] = 5; /* { dg-error  \"start-index and length fields necessary for using array notations in pointers\" } */\n-  c[1:2] =  3; /* This is OK.  */\n-  (array2)[:] = 5; /* This is OK.  */\n-  b[1:2][1:func(x)][:] = 3; /*  { dg-error  \"start-index and length fields necessary for using array notations in pointers\" }  */\n-}\n-"}, {"sha": "690e89a27d78587650b168ebc4bc22ffb3893820", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/dimensionless-arrays.c", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fdimensionless-arrays.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,10 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-\n-extern int a[];\n-extern int *b;\n-\n-void foo()\n-{\n-  a[:] = 5;\t// { dg-error \"start-index and length fields necessary for using array notation\" }\n-  b[:] = 5;    // { dg-error \"start-index and length fields necessary for using\" }\n-}"}, {"sha": "00b018a2c858cb9d184742d51226d0f2b8ca9647", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/exec-once.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,44 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define NUMBER 1000\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-int func (int *x)\n-{\n-  int q = *x;\n-   q++;\n-   *x = q;\n-#if HAVE_IO\n-   printf(\"%d\\n\", (q));\n-#endif\n-   return *x;\n-}\n-int main (void)\n-{\n-  char array[NUMBER], array2[NUMBER];\n-  int ii, d = 2;\n-#if 1\n-  for (ii = 0; ii < NUMBER; ii++)  {\n-   array[ii] = 5;\n-   array2[ii]= 2;\n-  }\n-#endif\n-  d = func (&d);    /* d = 1 */\n-  array2[:] = d * array[:] + (char) func (&d); /* 3 * 5 + 4 */\n-#if HAVE_IO\n-  for (ii = 0; ii < NUMBER; ii++)\n-    printf(\"array2[%d] = %d\\n\", ii, array2[ii]);\n-#endif  \n-  for (ii = 0; ii < NUMBER; ii++)\n-    if (array2[ii] !=  (3 * 5 + 4))\n-      return 1;\n-  \n-  return 0;\n-}\n-  \n-\n-"}, {"sha": "d9f39dd66a8e7fa816e727c95cbc8da88cd94df7", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/exec-once2.c", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fexec-once2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,87 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#ifdef HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-\n-int func1(int x)\n-{\n-  /* If x == 2 then it should return 0.  */\n-  return (x - 2);\n-}\n-\n-int func2(int x)\n-{\n-  /* If x == 2 then it should return 1000.  */\n-  return (x * 500);\n-}\n-\n-int func3 (int x)\n-{\n-  /* If x == 2 then it should return 1.  */\n-  /* If x == 1 then it should return 0.  */\n-  return (x-1);\n-}\n-\n-int func4(int x)\n-{\n-  if (x > 0) \n-    return x;\n-  else \n-    return x--;\n-}\n-\n-\n-/* This program makes an assumption that argc == 1.  */\n-int main (void)\n-{\n-  int argc = 1;\n-  int array[2500];\n-\n-  /* This is done to make sure the compiler does not optimize out argc.  */\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  /* This should set array[0->999] to 5.  */\n-  array[argc-1:func2(++argc):1] = 5;\n-  array[1000:500:1] = 10; /* set all variables in array[1000-->1499] to 10.  */\n-  array[1500:500:1] = 15; /* set all variables in array[1500-->1999] to 15.  */\n-  array[2000:500:1] = 20; /* set all variables in array[2000-->2499] to 20.  */\n-  array[2000:500:1] = 25; /* set all variables in array[2500-->2999] to 25.  */\n-  array[2000:500:1] = 30; /* set all variables in array[3000-->3499] to 30.  */\n-  \n-  argc = func3 (argc); /* This will set argc back to 1.  */\n-#if HAVE_IO\n-  printf(\"argc = %d\\n\", argc);\n-#endif\n-  /* If the parameters inside the function get evaluated only once, then this\n-     if statement must work fine, i.e. the triplet values will be 0, 1000, 1.\n-\n-     Otherwise, the program should crash or give some uneasy value.  */\n-\n-  /* If done correctly, it should boil down to: array[0:1000:1].  */\n-  if (array[func3(argc):func2(++argc)] != 5) {\n-#ifdef HAVE_IO\n-    printf (\"Should not be there(1).\\n\");\n-#endif\n-    return 1;\n-  }\n-  \n-  /* If done correctly, it should boil down to: array[999:500:-1].  */\n-  if (func4(array[func2(argc)-1:func2(argc--):func1(argc)]) != 5) {\n-#ifdef HAVE_IO\n-    printf (\"Should not be there(2).\\n\");\n-#endif\n-    return 2;\n-  }\n-\n-  /* If done correctly, it should boil down to: array[1000:500:1].  */\n-  if (func4 (func4(array[func2(argc++):500: func1(argc--)])) != 5) {\n-#ifdef HAVE_IO\n-    printf (\"Should not be there(3).\\n\");\n-#endif\n-    return 3;\n-  }\n-\n-  return 0;\n-}"}, {"sha": "4e1990fcc3474715e1cae6e223549a3ed7fd106d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/fn_ptr-2.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,14 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-typedef void (*f) (void *);\n-f b[1024];\n-void *c[1024][1024];\n-\n-int\n-main (void)\n-{\n-  (b[:]) (c[:][:]); /* { dg-error \"rank mismatch\" \"\" { xfail *-*-* } } */\n-  return 0;\n-}\n-"}, {"sha": "fa6d9003a00a6c337e33acb065ba5ff8c0cdf60a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/fn_ptr.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffn_ptr.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,21 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-typedef int (*foo)(int);\n-\n-int main(void)\n-{\n-  int array[10], array2[10][10];\n-  foo func_array[10];\n-  foo func_array2[10][10];\n-  foo ***func_array_ptr;\n-  int argc = 5;\n-\n-  array[:] =  func_array[:](10); \n-  func_array[0:5](10); \n-  func_array2[0:5][:](10);\n-  array2[0:5][:] = func_array2[0:5][:](10);\n-  func_array_ptr[0:5][0:4][0:argc:2](argc); \n-\n-  return 0;\n-}"}, {"sha": "b2ac7bcc85aa79cf8e0f3bad6bb62c58bce6bb75", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/fp_triplet_values.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffp_triplet_values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffp_triplet_values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ffp_triplet_values.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-float q;\n-\n-void func (int *x)\n-{\n-  *x = 5;\n-}\n-\n-int main (void)\n-{\n-  int array[10], array2[10];\n-  array2[:] = array[1.5:2]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n-  array2[:] = array[1:2.32333333333]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[1:2:1.5] = array[:]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n-  func (&array2[1:2.34:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[1.43:9]++; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n-  array2[1:9.3]++; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[1:9:0.3]++; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n-  \n-  ++array2[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[:] = array[q:1:3]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n-  array2[:] = array[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[:] = array[1:3:q]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n-  func (&array2[1:q:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  return 0;\n-} "}, {"sha": "f425fbec0f5daa517e749f23f933c0382ebc6136", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/gather-scatter-errors.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather-scatter-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather-scatter-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather-scatter-errors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  extern int func (int);\n-  int array[10][10], array2[10];\n-  int argc = 1;\n-  array2[array[:][:]] = 5; /* { dg-error \"rank of the array's index is greater than 1\" } */\n-\n-  array2[array[:][:]] = 5; /* { dg-error \"rank of the array's index is greater than 1\" } */\n-  func (array2[array[:][:]]); /* { dg-error \"rank of the array's index is greater than 1\" } */\n-  func (array2[array[argc:func(5)][0:10:2]]); /* { dg-error \"rank of the array's index is greater than 1\" } */\n-  \n-  array[array2[:]][array2[:]] = 5; /* This is OK.  */\n-  array[array2[:]][array2[:]] = array2[array[:][:]]; /* { dg-error \"rank of the array's index is greater than 1\" }  */\n-  array[array2[:]][array2[:]] = array2[array[0:10:1][:]]; /* { dg-error \"rank of the array's index is greater than 1\" }  */\n-  array[array2[:]][array2[:]] = array2[array[:][argc:func (argc)]]; /* { dg-error \"rank of the array's index is greater than 1\" }  */\n-  return 0;\n-}"}, {"sha": "faee3fcebf665d5d708cb7272980d9eb17fc17a7", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/gather_scatter.c", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather_scatter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather_scatter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fgather_scatter.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,60 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define NUMBER 20\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-float array4[NUMBER][NUMBER][NUMBER][NUMBER];\n-int main(void)\n-{\n-  int array[NUMBER][NUMBER], array2[NUMBER], array3[NUMBER], x = 0, y;\n-  int x_correct, y_correct, ii, jj = 0, kk = 0, ll = 0;\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      for (jj = 0; jj < NUMBER; jj++)\n-\t{\n-\t  array[ii][jj] = 1+ii;\n-\t  array2[ii]= 2;\n-\t  array3[ii]= 3;\n-\t}\n-    }\n-  \n-  array[array2[:]][array3[:]] = 1000;\n-\n-  for (ii = 0; ii < NUMBER; ii++)\n-    if (array[array2[ii]][array3[ii]] != 1000)\n-      return 1;\n-  \n-#if HAVE_IO\n-  for (ii = 0; ii < NUMBER; ii++) {\n-    for (jj = 0; jj < NUMBER; jj++) {\n-      printf(\"%4d\\t\", array[ii][jj]);\n-    }\n-    printf(\"\\n\");\n-  }\n-#endif\n-\n-  array4[array2[:]][array3[0:NUMBER:1]][array2[0:NUMBER:1]][array3[0:NUMBER:1]] =\n-    (float)array[array2[:]][array3[:]]; \n-\n-  for (ii = 0; ii < NUMBER; ii++)\n-    if (array4[array2[ii]][array3[ii]][array2[ii]][array3[ii]] !=\n-\t(float)array[array2[ii]][array3[ii]])\n-      return 2;\n-  \n-#if HAVE_IO\n-  for (ii = 0; ii < NUMBER; ii++) {\n-      for (jj = 0; jj < NUMBER; jj++) {\n-\t  for (kk = 0; kk < NUMBER; kk++) {\n-\t      for (ll = 0; ll < NUMBER; ll++) {\n-\t\t  printf(\"%4d\\n\", array4[ii][jj][kk][ll]);\n-\t      }\n-\t  }\n-      }\n-  }\n-#endif\n-\n-  return 0;\n-}"}, {"sha": "4e5b1583778c9c1829b8a9a93f8309321692765a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/if_test.c", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,306 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-#include <stdlib.h>\n-int main2 (char **argv);\n-int main(int argc, char **argv)\n-{\n-  int x = 0; \n-  const char *array[] = {\"a.out\", \"10\", \"15\"};\t     \n-  x = main2 ((char **) array);\n-  return x;\n-}\n-\n-\n-int main2 (char **argv)\n-{\n-  int x = 3, y, z, array[10], array2[10], TwodArray[10][10], jj,kk,ll ;\n-  int array2_check[10], array2d_check[10][10], array2d[10][10];\n-  int FourDArray[10][10][10][10], array4[10][10][10][10];\n-  int array4_check[10][10][10][10];\n-  int ii = 0, argc = 3; \n-    \n-  __asm volatile (\"\" : \"+r\" (argc));\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = argc%3;\n-      array2[ii]= 10;\n-      array2_check[ii] = 10;\n-    }\n-\n-  if (!array[:])\n-    array2[:] = 5;\n-  else\n-    array2[:] = 10;\n-\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      if (!array[ii])\n-\tarray2_check[ii] = 5;\n-      else\n-\tarray2_check[ii] = 10;\n-    }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array2_check[ii] != array2[ii])\n-      return 2;\n-  \n-\n-  \n-  if (!(array[0:10:1] + array[0:10:1]))\n-    array2[:] = 5;\n-  else\n-    array2[:] = 10;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      if (!(array[ii]+ array[ii]))\n-\tarray2_check[ii] = 5;\n-      else\n-\tarray2_check[ii] = 10;\n-    }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array2_check[ii] != array2[ii])\n-      return 3;\n-  \n-  x = atoi (argv[1])-10;\n-  y = atoi (argv[1])/2;\n-  z = (atoi (argv[1]))/5;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      if (ii % 2)\n-\tarray[ii] = 0;\n-      else\n-\tarray[ii] = 1;\n-    }\n-\n-  /*printf(\"x = %2d y = %2d z = %2d\\n\", x, y, z); */\n-\n-  for (ii = 0; ii < 10; ii++)\n-    array[ii] = 10;\n-\n-  /* This if loop will change all the 10's to 5's */\n-  if (array[x:y:z] != 9)\n-    array2[:] = 5;\n-  else\n-    array2[:] = 10;\n-\n-  for (ii = x; ii < (x+y); ii += z)\n-    {\n-      if (array[ii] != 9)\n-\tarray2_check[ii] = 5;\n-      else\n-\tarray2_check[ii] = 10;\n-    }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array2_check[ii] != array2[ii])\n-      return 4;\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    array2[ii] = 10;\n-    array2_check[ii] = 10;\n-  }\n-\n-  /* This if loop will change all the 10's to 5's */\n-  if (array[atoi(argv[1])-10:atoi(argv[1])/2: atoi(argv[1])/5])\n-    array2[atoi(argv[1])-10: atoi (argv[1])/2: atoi(argv[1])/5] = 5;\n-  else\n-    array2[atoi(argv[1])-10: atoi (argv[1])/2: atoi(argv[1])/5] = 10;\n-\n-  for (ii = atoi(argv[1])-10; ii < atoi(argv[1]) + (atoi (argv[1])-10);\n-       ii +=atoi(argv[1])/5)\n-    if (array[ii])\n-      array2_check[ii] = 5;\n-    else\n-      array2_check[ii] = 10;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array2_check[ii] != array2[ii]) {\n-#if HAVE_IO\n-      printf(\"array2[%2d] = %2d array2_check[%2d] = %2d\\n\", ii, array2[ii],\n-\t     ii, array2_check[ii]);\n-#endif\n-      return 5;\n-    }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      TwodArray[ii][jj] = atoi(argv[1]);\n-\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (ii = 0; ii < 10; ii++) {\n-      array2d[ii][jj] = 10;\n-      array2d_check[ii][jj] = 10;\n-    }\n-\n-  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (TwodArray[:][:] != 10) \n-    array2d[:][:] = 10; \n-  else\n-    array2d[:][:] = 5;\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj < 10; jj++) {\n-      if (TwodArray[ii][jj] != 10)\n-\tarray2d_check[ii][jj] = 10;\n-      else\n-\tarray2d_check[ii][jj] = 5;\n-    }\n-  }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      if (array2d[ii][jj] != array2d_check[ii][jj])\n-\treturn 6;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++)\n-\t  {\n-\t    array4[ii][jj][kk][ll] = 10;\n-\t    array4_check[ii][jj][kk][ll] = 10;\n-\t  }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++) \n-\t  FourDArray[ii][jj][kk][ll] = atoi(argv[1]);\n-  \n-  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (FourDArray[:][:][:][:] != 10) \n-    array4[:][:][:][:] = 10; \n-  else\n-    array4[:][:][:][:] = 5;\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj < 10; jj++) {\n-      for (kk = 0; kk < 10; kk++) {\n-\tfor (ll = 0; ll < 10; ll++) {\n-\t  if (FourDArray[ii][jj][kk][ll] != 10)\n-\t    array4_check[ii][jj][kk][ll] = 10;\n-\t  else\n-\t    array4_check[ii][jj][kk][ll] = 5;\n-\t}\n-      }\n-    }\n-  }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++)\n-\t  if (array4_check[ii][jj][kk][ll] != array4[ii][jj][kk][ll])\n-\t    return 7;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++)\n-\t  {\n-\t    array4[ii][jj][kk][ll] = 10;\n-\t    array4_check[ii][jj][kk][ll] = 10;\n-\t  }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++) \n-\t  FourDArray[ii][jj][kk][ll] = atoi(argv[1]);\n-  \n-  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (FourDArray[0:10:1][0:5:2][9:10:-1][0:5:2] != 10) \n-    array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 10; \n-  else\n-    array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 5;\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj < 10; jj += 2) {\n-      for (kk = 9; kk >= 0; kk--) {\n-\tfor (ll = 0; ll < 10; ll += 2) {\n-\t  if (FourDArray[ii][jj][kk][ll] != 10)\n-\t    array4_check[ii][jj][kk][ll] = 10;\n-\t  else\n-\t    array4_check[ii][jj][kk][ll] = 5;\n-\t}\n-      }\n-    }\n-  }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++)\n-\t  if (array4_check[ii][jj][kk][ll] != array4[ii][jj][kk][ll]) {\n-#if HAVE_IO\n-\t      printf(\"array4_check[%d][%d][%d][%d] = %d\\n\",ii, jj, kk, ll,\n-\t\t     array4_check[ii][jj][kk][ll]);\n-\t      printf(\"array4[%d][%d][%d][%d] = %d\\n\",ii, jj, kk, ll,\n-\t\t     array4[ii][jj][kk][ll]);\n-#endif\n-\t    return 8;\n-\t  }\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++) \n-\t  FourDArray[ii][jj][kk][ll] = atoi(argv[1]);\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++)\n-\t  {\n-\t    array4[ii][jj][kk][ll] = 10;\n-\t    array4_check[ii][jj][kk][ll] = 10;\n-\t  }\n-\n-  \n-  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (FourDArray[0:10:1][0:5:2][9:10:-1][x:y:z] +\n-      FourDArray[0:10:1][0:5:2][9:10:-1][x:y:z]  != 20) \n-    array4[0:10:1][0:5:2][9:10:-1][x:y:z] = 10; \n-  else\n-    array4[0:10][0:5:2][9:10:-1][x:y:z] = 5;\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj < 10; jj += 2) {\n-      for (kk = 9; kk >= 0; kk--) {\n-\tfor (ll = 0; ll < 10; ll += 2) {\n-\t  if (FourDArray[ii][jj][kk][ll] != 10)\n-\t    array4_check[ii][jj][kk][ll] = 10;\n-\t  else\n-\t    array4_check[ii][jj][kk][ll] = 5;\n-\t}\n-      }\n-    }\n-  }\n-\n-  for (ii = 0; ii < 10; ii++)\n-    for (jj = 0; jj < 10; jj++)\n-      for (kk = 0; kk < 10; kk++)\n-\tfor (ll = 0; ll < 10; ll++)\n-\t  if (array4_check[ii][jj][kk][ll] != array4[ii][jj][kk][ll]) {\n-#if HAVE_IO\n-\t      printf(\"array4_check[%d][%d][%d][%d] = %d\\n\",ii, jj, kk, ll,\n-\t\t     array4_check[ii][jj][kk][ll]);\n-\t      printf(\"array4[%d][%d][%d][%d] = %d\\n\",ii, jj, kk, ll,\n-\t\t     array4[ii][jj][kk][ll]);\n-#endif\n-\t    return 9; \n-\t  }\n-\n-  \n-  return 0;\n-}"}, {"sha": "579d396948e7468f443bfeccff0b308c9da74ea3", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/if_test_errors.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fif_test_errors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,56 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-int main (void)\n-{\n-  int x = 3, y, z, array[10], array2[10], TwodArray[10][10], jj,kk,ll ;\n-  int array2_check[10], array2d_check[10][10], array2d[10][10];\n-  int FourDArray[10][10][10][10], array4[10][10][10][10];\n-  int array4_check[10][10][10][10];\n-  int ii = 0;\n-\n-  x = 5;\n-  y = 10;\n-  z = 2;\n-\n-  if (!array[:]) /* This is OK! */\n-    array2[:] = 5;\n-  else\n-    array2[:] = 10;\n-  if (!(array[0:10:1] + array[0:10:1])) /* { dg-error \"condition and the then-block\" \"\" { target c } } */\n-    array2d[:][:] = 5; /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n-  else\n-    array2[:] = 10;\n-\n-  if (!(array[0:10:1] + array[0:10:1])) /* { dg-error \"condition and the else-block\" \"\" { target c } } */\n-    array2[:] = 5;\n-  else\n-    array2d[:][:] = 10; /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n-\n-\n-  if (TwodArray[:][:] != 10) /* { dg-error \"condition and the then-block\" \"\" { target c } } */\n-    array2[:] = 10;  /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n-  else\n-    array2[:] = 5;\n-\n-  if (FourDArray[43][:][:][:] != 10) /* This is OK!  */ \n-    array4[45][:][:][:] = 10; \n-  else\n-    array4[32][:][:][:] = 5;\n-\n-  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (FourDArray[42][0:10:1][9:10:-1][0:5:2] != 10) /* { dg-error \"condition and the then-block\" \"\" { target c } } */\n-    array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 10;  /* { dg-error \"rank mismatch with controlling expression of parent\" \"\" { target c++ } } */\n-  else\n-    array4[0:10:1][0:5:2][9:10:-1][0:5:2] = 5;\n-\n-  /* atoi(argv[1]) == 10, so it will convert all 10's to 5's */\n-  if (FourDArray[0:10:1][0:5:2][9:10:-1][x:y:z] +\n-      FourDArray[0:10:1][0:5:2][9:-10:1][x:y:z]  != 20) \n-    array4[0:10:1][0:5:2][9:10:-1][x:y:z] = 10; \n-  else\n-    array4[0:10][0:5:2][9:10:-1][x:y:z] = 5;\n-\n-  return 0;\n-}"}, {"sha": "dcc414f1209aad31544c2525685d371985247170", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/misc.c", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fmisc.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,112 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10], array2[10][10];\n-  int x, ii, jj ;\n-\n-  switch (array[:]) {  /* { dg-error \"cannot be used as a condition for switch statement\" } */\n-  case 1:\n-    x = 5;\n-    break;\n-  case 2:\n-    x = 2;\n-    break;\n-  default:\n-    x = 9;\n-  }\n-\n-  switch (array2[:][:]) { /* { dg-error \"cannot be used as a condition for switch statement\" } */\n-  case 1:\n-    x = 5;\n-    break;\n-  case 2:\n-    x = 2;\n-    break;\n-  default:\n-    x = 9;\n-  }\n-\n-  switch (array[:] + x) { /* { dg-error \"cannot be used as a condition for switch statement\" } */\n-  case 1:\n-    x = 5;\n-    break;\n-  case 2:\n-    x = 2;\n-    break;\n-  default:\n-    x = 9;\n-  }\n-  \n-  switch (array2[:][1:x:4] + x) { /* { dg-error \"cannot be used as a condition for switch statement\" } */\n-  case 1:\n-    x = 5;\n-    break;\n-  case 2:\n-    x = 2;\n-    break;\n-  default:\n-    x = 9;\n-  }\n-\n-  for (ii = 0; ii < array[:]; ii++) /* { dg-error \"cannot be used in a condition for a for-loop\" } */\n-    {\n-      x = 2;\n-    }\n-\n-  for (ii = 0; ii < array2[:][:]; ii++) /* { dg-error \"cannot be used in a condition for a for-loop\" } */\n-    {\n-      x = 3;\n-    }\n-\n-  for (; array2[:][:] < 2;) /* { dg-error \"cannot be used in a condition for a for-loop\" } */\n-    x = 4;\n-\n-\n-  while (array2[:][:]) /* { dg-error \"cannot be used as a condition for while statement\" } */\n-    x = 3;\n-\n-  while (array[1:1:1]) /* { dg-error \"cannot be used as a condition for while statement\" } */\n-    x = 1;\n-\n-  while (ii != array2[1:x:3][1:2:1]) /* { dg-error \"cannot be used as a condition for while statement\"  } */\n-    x = 2;\n-\n-  do {\n-    x = 3;\n-  } while (ii != array2[:][:]); /* { dg-error \"cannot be used as a condition for a do-while statement\" } */\n-\n-  do {\n-    x = 2;\n-  } while (ii != (x + array2[:][1:x:2]) + 2); /* { dg-error \"cannot be used as a condition for a do-while statement\" } */\n-  \n-  do { \n-    x += 3;\n-    if (x == 5)\n-      return array2[:][:]; /* { dg-error \"array notation expression cannot be used as a return value\" } */\n-  } while (ii != 0);\n-\n-  for (ii = 0;  ii < 10; ii++)\n-    if (ii % 2)\n-      return array[1:x:ii]; /* { dg-error \"array notation expression cannot be used as a return value\" } */\n-\n-  for (ii = 0; ii < x; ii++)\n-    if (ii)\n-      return array2[:][:]; /* { dg-error \"array notation expression cannot be used as a return value\" } */\n-\n-  for (array[:] = 0; ii < x; ii++) /* This should be OK.  */\n-    x= 2;\n-\n-  for (ii = 0; ii < 10; array[:]++) /* This is OK.  */\n-    x = 5;\n-\n-  for (jj = 0; jj < 10; array2[:][:]++) /* This is OK.  */\n-    x = 3;\n-\n-  for (jj = 0; jj < 10; array2[:][1:x:4]++, jj++) /* This is OK.  */\n-    x = 3;\n-  \n-  return x;\n-}\n- "}, {"sha": "750446c87d239365625ecc215c4cc655e4f78ab2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/n-ptr-test.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fn-ptr-test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fn-ptr-test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fn-ptr-test.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,48 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define NUMBER 10\n-#include <stdlib.h>\n-\n-int ***func2 (int ***a1, int ***a2, int size)\n-{\n-  a1[0:size:1][0:size:1][0:size] += (a2[0:size][0:size][0:size:1]  + size);\n-  return a1;\n-}\n-\n-int main (void)\n-{\n-  int ii, jj, kk;\n-  int ***array3, ***array2 = NULL, ***array = NULL;\n-\n-  array = (int ***) malloc (sizeof (int **) * NUMBER);\n-  array2 = (int ***) malloc (sizeof (int **) * NUMBER);\n-  for (ii = 0; ii < NUMBER; ii++) {\n-    array[ii] = (int **) malloc (sizeof (int *) * NUMBER);\n-    array2[ii] = (int **) malloc (sizeof (int *) * NUMBER);\n-    for (jj = 0; jj < NUMBER; jj++) { \n-      array[ii][jj] = (int *) malloc (sizeof (int) * NUMBER);\n-      array2[ii][jj] = (int *) malloc (sizeof (int) * NUMBER);\n-    } \n-  }\n-\n-  for (ii = 0; ii < NUMBER; ii++) {\n-    for (jj = 0; jj < NUMBER; jj++) {\n-      for (kk = 0; kk < NUMBER; kk++) {\n-\tarray[ii][jj][kk] = 5;\n-\tarray2[ii][jj][kk]= 2;\n-      }\n-    }\n-  }\n-  array3 = func2 ((int ***)array, (int ***)array2, NUMBER);\n-  \n-  for (ii = 0; ii < NUMBER; ii++) {\n-    for (jj = 0; jj < NUMBER; jj++) {\n-      for (kk = 0; kk < NUMBER; kk++) {\n-\tif (array3[ii][jj][kk] != (7 + NUMBER))\n-          return 1;\n-      }\n-    }\n-  }\n-  return 0;\n-}"}, {"sha": "fd4fe5419b641b49ac6ab46a19643bd930f4fcc8", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10][10], array2[10];\n-  \n-  array2[:] = array2[: ;  /* { dg-error \"expected ']'\" } */\n-\n-  return 0; /* { dg-error \"expected ';' before\" \"\" { target c } } */\n-}"}, {"sha": "d003d7cc2bb3e5d7dc09ae2b8275d0c9843b114d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors2.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10][10], array2[10];\n-  \n-  array2[:] = array2[1:2:] ;  /* { dg-error \"expected expression before\" \"\" { target c } } */ \n-  /* { dg-error  \"expected primary-expression before\" \"\" { target c++ } .-1 } */\n-  /* { dg-error \"expected ';' before\" \"\" { target c } .-2 } */\n-\n-  return 0;\n-}"}, {"sha": "14256e9579ee7f4108779f4a85745dd976f15fda", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors3.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10][10], array2[10];\n-  \n-  array2[:] = array2[1: :] ;  /* { dg-error \"expected expression before\" \"\" { target c }  } */ \n-  /* { dg-error \"expected primary-expression before\" \"\" { target c++ }  .-1 } */\n-  /* { dg-error \"expected ';' before\" \"\" { target c } .-2 } */\n-\n-  return 0;\n-}"}, {"sha": "a0efc04d25e57690fa2ed347fba49e5ba084b6db", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/parser_errors4.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fparser_errors4.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10][10], array2[10];\n-  \n-  array2[:] = array2[ : : ] ;  /* { dg-error \" expected ']' before ':' token\" }  */\n-\n-  return 0;\n-}"}, {"sha": "ac11b9209b11c06f973b235ca6bc18229403a371", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57457-2.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57457-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57457-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57457-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,15 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-/* Test-case contains no array notation but is compiled with -fcilkplus.  \n-   It will still print the too few arguments func, thereby saying the\n-   if-statement after the for-loop to check for !flag_enable_cilkplus ||\n-   !is_cilkplus_reduce_function (fundecl) is not valid is always taken.  */\n-\n-int func (int, int); /* { dg-message \"declared here\" } */\n-\n-int main (void)\n-{\n-  int a = 5, b = 2;\n-  return func (a); /* { dg-error \"too few arguments to function\" } */\n-}"}, {"sha": "68a1fd8118500e18f1f2327224c371f19c50748f", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57457.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57457.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57457.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57457.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,39 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-/* This test has no array notation components in it and thus should compile\n-   fine without crashing.  */\n-\n-typedef unsigned int size_t;\n-typedef int (*__compar_fn_t) (const void *, const void *);\n-extern void *bsearch (const void *__key, const void *__base,\n-\t\t      size_t __nmemb, size_t __size, __compar_fn_t\n-\t\t      __compar)\n-  __attribute__ ((__nonnull__ (1, 2, 5))) ;\n-extern __inline __attribute__ ((__gnu_inline__)) void *\n-bsearch (const void *__key, const void *__base, size_t __nmemb, size_t\n-\t __size,\n-\t __compar_fn_t __compar)\n-{\n-  size_t __l, __u, __idx;\n-  const void *__p;\n-  int __comparison;\n-  __l = 0;\n-  __u = __nmemb;\n-  while (__l < __u)\n-    {\n-      __idx = (__l + __u) / 2;\n-      __p = (void *) (((const char *) __base) +\n-\t\t      (__idx * __size));\n-      __comparison = (*__compar) (__key,\n-\t\t\t\t  __p);\n-      if (__comparison < 0)\n-\t__u = __idx;\n-      else if (__comparison > 0)\n-\t__l = __idx + 1;\n-      else\n-\treturn (void *)\n-\t  __p;\n-    }\n-  return ((void *)0);\n-}"}, {"sha": "db38b30b5f3124b7b0f27d6b944d07a969e21294", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57490.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57490.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57490.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57490.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-const int n = 8;\n-float x[8], y[8], z[8];\n-int main() {\n-    int i = 0;\n-    float x_sum =0;\n-    for(i=1; i<=5; i+=4 ) {\n-        x[0:n] = 3;\n-        y[0:n] = i;\n-        z[0:n] = 0;\n-        (void)((__sec_reduce_add(x[0:n])==3*n) || (__builtin_abort (), 0));\n-        (void)((__sec_reduce_add(y[0:n])==i*n) || (__builtin_abort (), 0));\n-        (void)((__sec_reduce_add(z[0:n])==0) || (__builtin_abort (), 0));\n-\n-        if (x[0:n] >= y[0:n]) {\n-            z[0:n] = x[0:n] - y[0:n];\n-        } else {\n-            z[0:n] = x[0:n] + y[0:n];\n-        }\n-        (void)((__sec_reduce_add(x[0:n])==3*n) || (__builtin_abort (), 0));\n-        (void)((__sec_reduce_add(y[0:n])==i*n) || (__builtin_abort (), 0));\n-        (void)((__sec_reduce_add(z[0:n])==(3>=i?3-i:3+i)*n) \n-\t       || (__builtin_abort (), 0));\n-    }\n-    return 0;\n-}"}, {"sha": "89a3d57ebdd129aab2f638c10393be07a946d5b3", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57541-2.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,15 +0,0 @@\n-/* PR middle-end/57541 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-void foo1 ()\n-{\n-  int a;\n-  a = __sec_reduce_add (1); /* { dg-error \"Invalid builtin arguments\" } */\n-}\n-\n-void foo2 ()\n-{\n-  int a;\n-  a = __sec_reduce_add (); /* { dg-error \"Invalid builtin arguments\" } */\n-}"}, {"sha": "b47de1e7ebccd9a3611edc16669366d575fdd94b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57541.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57541.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,21 +0,0 @@\n-/* PR middle-end/57541 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int A[10];\n-\n-void foo () {\n-  /* C compiler uses the term \"undeclared\" whereas C++ compiler uses\n-    \"not declared\".  Thus, grepping for declared seem to be the easiest.  */\n-  char c = (char)N; /* { dg-error \"declared\" } */\n-  /* { dg-message \"note: each\" \"defined\" { target c } .-1 } */\n-  short s = (short)N;\n-  long l = (long)N;\n-  A[l:s:c];\n-}\n-\n-void foo1 (int N) {\n-  char c = (char)N;\n-  short s = (short)N;\n-  A[l:s:c]; /* { dg-error \"declared\" } */\n-}"}, {"sha": "98ab9e1665e053b0e88b235fa9362c99b77b95f4", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr57577.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57577.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57577.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr57577.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define NUMBER 100\n-int A[NUMBER], B[NUMBER][NUMBER];\n-int foo (int a);\n-\n-int main () {\n-  A[:] = foo (B[:][:]); /* { dg-error \"rank mismatch between\" } */\n-  A[0] = foo (B[:][:]); /* { dg-error \"cannot be scalar when\" } */\n-  return 0;\n-}"}, {"sha": "87903af3c8673a4a2c637ecb8d061ec6841e6052", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr58942.c", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr58942.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr58942.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr58942.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,8 +0,0 @@\n-/* PR c/58942 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int foo (int*p, int i)\n-{\n-  return __sec_reduce_max_ind(p[1:i]);\n-}"}, {"sha": "8c32ad9a267af3b05b7d8ef5618f5885fea9873d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr61191.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61191.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61191.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61191.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,11 +0,0 @@\n-/* PR c/61191 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-double f(double * A, double * B)\n-{\n-  return __sec_reduce_add((B[0:500])(; /* { dg-error \"called object\" \"\" { target c } } */\n-/* { dg-error \"expected expression before ';' token\" \"\" { target c } .-1 } */\n-/* { dg-error \"expected primary-expression before ';' token\" \"\" { target c++ } .-2 } */\n-/* { dg-error \"expected\" \"\" { target c } .-3 } */\n-}"}, {"sha": "60b424873d9ce6e330070e697f8b5dd9c3f7974b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455-2.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61455-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61455-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61455-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* PR c++/61455 */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int a[3] = {2, 3, 4};\n-\n-int main ()\n-{\n-  int c = 10;\n-  int b = __sec_reduce_add(a[:]);\n-  if (b+c != 19)\n-    __builtin_abort();\n-  return 0;\n-}"}, {"sha": "35a11b66c91177adc88bdd8938e553465e43267d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr61455.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61455.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61455.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61455.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,9 +0,0 @@\n-/* PR c++/61455 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-void foo ()\n-{\n-  int a[2];\n-  int b = a[:]; /* { dg-error \"cannot be scalar\" } */\n-}"}, {"sha": "08d4fe236286b0dff3d5e7f2af23d3ece9d1bee0", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr61962.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61962.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61962.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61962.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,14 +0,0 @@\n-/* PR other/61962 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-struct FloatStruct\n-{\n-    float *f;\n-};\n-\n-/* Either SRC or DST must be a struct, otherwise the bug does not occur.  */\n-void f (struct FloatStruct* dst, float *src, unsigned int length)\n-{\n-    dst->f[0:length] = src[0:length];\n-}"}, {"sha": "205671a5b501ea1b8a205520bb4edb7554ba530f", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr61963.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61963.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61963.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr61963.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,9 +0,0 @@\n-/* PR other/61963 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-void f (int * int *a) /* { dg-error \"expected\" } */\n-{\n-    a[0:64] = 0; /* { dg-error \"was not declared\" \"\" { target c++ } } */\n-    a[0:64] = 0;\n-}"}, {"sha": "eec57dc0359bbbda358e14ef0974812b2ef0bc18", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr62008.c", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr62008.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr62008.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr62008.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,10 +0,0 @@\n-/* PR other/62008 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-void f(int *a, int w, int h)\n-{\n-  int tmp[w][h];\n-  tmp[:][:] = a[0:w][0:h]; /* { dg-error \"base of array section must be pointer or array type\" } */\n-  /* { dg-error \"start-index and length fields necessary\" \"\" { target c } .-1 } */\n-}"}, {"sha": "c876a8dec00d480f3d0a580425bbab11bbc4bd79", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/pr63884.c", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr63884.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr63884.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fpr63884.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,10 +0,0 @@\n-/* PR middle-end/63884 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int\n-foo (int x, int y)\n-{\n-  int r;\n-  return __builtin_sadd_overflow (x, y, &r);\n-}"}, {"sha": "29dee80739683c8148b78f923d626efad66214ba", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,18 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -w\" } */\n-\n-/* We use -w because in the first error, there will be a warning of setting an\n-   integer to a pointer.  Just ignore it to expose the rank mismatch error.  */\n-\n-int main (void)\n-{\n-  int x = 0;\n-  int array[10][10], array2[10];\n-\n-  array[:][:] = array[:]; /* { dg-error \"rank mismatch between\" } */\n-  /* { dg-error \"invalid conversion\" \"\" { target c++ } .-1 } */\n-\n-  x = array2[:]; /* { dg-error \"cannot be scalar when\" } */\n-\n-  return 0;\n-}"}, {"sha": "4a4882dbae6af70fcf9c11b670189d5994cb507d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch2.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,27 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int function_call (int x);\n-int function_call (int x)\n-{\n-  return x;\n-}\n-\n-int main (void)\n-{\n-  int array[100], array2[100][100];\n-  int argc = 4;\n-  array[:] = array[:] + array2[:][:]; /* { dg-error \"rank mismatch between\" } */\n-\n-  if (array[:] + array2[:][:]) /* { dg-error \"rank mismatch between\" } */\n-    return argc == 5;\n-\n-  argc += function_call (array[:] + array2[5:10:2][:]); /* { dg-error \"rank mismatch between\" } */\n-\n-  argc += function_call (function_call (array[:] + array2[5:10:2][:])); /* { dg-error \"rank mismatch between\" } */\n-\n-   argc += __sec_reduce_add (array[:], array2[:][:]); /* { dg-error \"rank mismatch between\" } */\n-\n-   argc += __sec_reduce_add (array2[:][:]) + argc; /* This is OK.  */\n-  return argc;\n-}"}, {"sha": "de335922f8a5e0a38856ce107b2723bcaa1a4a07", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/rank_mismatch3.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Frank_mismatch3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int funct (int x, int y);\n-void funct_void (int x, int y, int z);\n-int main(void)\n-{\n-  int y, array[100], array2[100], array3[100][100], array4[100];\n-\n-  array[:] = ((array2[:] + array[:]) * array4[:]) + array3[:][:]; /* { dg-error \"rank mismatch between\" } */\n-  array[:] = funct (array2[:], array3[:][:]); /* { dg-error \"rank mismatch between\" } */\n-  array[:] = array3[:][:]; /* { dg-error \"rank mismatch between\" } */\n-  array3[:][:] = array[:]; /* { dg-error \"rank mismatch between\" } */\n-  array3[:][:] = array[5]; /* This is OK!  */\n-  funct_void (array2[:], array3[:][:], array[:]); /* { dg-error \"rank mismatch between\" } */\n-  funct_void (array2[:], array3[:][:], array[:]); /* { dg-error \"rank mismatch between\" } */\n-  funct_void (array3[:][:], array2[:], array[:]); /* { dg-error \"rank mismatch between\" }  */\n-  funct_void (array2[:], array[:], array3[:][0:10:1]); /* { dg-error \"rank mismatch between\" } */\n-  return 0;\n-}"}, {"sha": "bacbf3505667f43abc7a5a7db65f70504a97cad5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_implicit.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10][10], array2[10];\n-\n-  array[:][:] = __sec_implicit_index(5) + array[:][:]; /* { dg-error \"__sec_implicit_index argument\" } */\n-\n-  return 0;\n-}"}, {"sha": "0aef0c29aca5699f4b44f5fda850ac8afcc12ab3", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_implicit2.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int argc = 2;\n-  int array[10][10], array2[10];\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  array[:][:] = __sec_implicit_index(argc) + array[:][:]; /* { dg-error \"__sec_implicit_index parameter\" } */\n-  return 0;\n-}"}, {"sha": "419799a3b2b33e6930837a72f0e052bb9ad1b2b8", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_implicit_ex.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit_ex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit_ex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_implicit_ex.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,29 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define NUMBER 20\n-\n-int main(void)\n-{\n-  int jj, kk, array_3C[NUMBER][NUMBER][NUMBER];\n-  int ii,array[NUMBER], y = 0, y_int = 0, array2[NUMBER], \n-      array_3[NUMBER][NUMBER][NUMBER];\n-  double x, yy, array3[NUMBER], array4[NUMBER];\n-\n-  array[:] = __sec_implicit_index (0);\n-  array_3[:][:][:] = __sec_implicit_index (1) + __sec_implicit_index(0) +\n-    __sec_implicit_index (2);\n-\n-  for (ii = 0; ii < NUMBER; ii++)\n-    for (jj = 0; jj < NUMBER; jj++)\n-      for (kk = 0; kk < NUMBER; kk++)\n-\tarray_3C[ii][jj][kk] = ii+jj+kk;\n-\t\n-  for (ii = 0; ii < NUMBER; ii++)\n-    for (jj = 0; jj < NUMBER; jj++)\n-      for (kk = 0; kk < NUMBER; kk++)\n-\tif (array_3[ii][jj][kk] != array_3C[ii][jj][kk])\n-\t  return 1;\n-\t\n-  return 0;\n-}"}, {"sha": "34c6f12846de256491cd743b3ce0cab376664eef", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_reduce_ind_same_value.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_ind_same_value.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_ind_same_value.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_ind_same_value.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,21 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int A[256];\n-\n-int main () { \n-    A[:] = 2; \n-    int max_index = 0, min_index = 0;\n-  \n-    max_index = __sec_reduce_max_ind (A[:]);\n-  \n-    if (max_index != 255)\n-      return 1;\n-\n-    min_index = __sec_reduce_min_ind (A[:]);\n-    if (min_index != 255)\n-      return 2;\n-\n-    return 0;\n-}\n-"}, {"sha": "9652e1594b400a4be9ed7b6d591fc92773052478", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_reduce_max_min_ind.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_max_min_ind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_max_min_ind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_max_min_ind.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int array[10][10], array2[10];\n-  int x, y;\n-  x = __sec_reduce_max_ind (array[:][:]); /* { dg-error \"cannot have arrays with dimension greater than\" } */\n-\n-  y = __sec_reduce_max_ind (array2[:]); /* this should be OK. */\n-\n-  x = __sec_reduce_min_ind (array[:][:]); /* { dg-error \"cannot have arrays with dimension greater than\" } */\n-\n-  y = __sec_reduce_min_ind (array2[:]); /* this should be OK. */\n-\n-  return 0;\n-}"}, {"sha": "034017146f3b7479fe199a2257d0efd7b3918150", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/sec_reduce_return.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fsec_reduce_return.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,29 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int add_all (int *my_array, int size)\n-{\n-  return __sec_reduce_add (my_array[0:size]);\n-}\n-\n-int mult_all (int *my_array, int size)\n-{\n-  return __sec_reduce_mul (my_array[0:size]);\n-}\n-\n-int main (void)\n-{\n-  int argc = 1;\n-  int array[10000];\n-  \n-  __asm volatile (\"\" : \"+r\" (argc));\n-  array[:] = argc; /* All elements should be one.  */\n-\n-  if (add_all (array, 10000) != 10000)\n-    return 1;\n-\n-  if (mult_all (array, 10000) != 1)\n-    return 2;\n-\n-  return 0;\n-}"}, {"sha": "8b0034e727b808ffdce16084925e24e3a33e71a2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/side-effects-1.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fside-effects-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fside-effects-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fside-effects-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,26 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-/* Test that the array index, limit, and stride are evaluated only\n-   once.  */\n-\n-int array[1000];\n-\n-int func1_times = 0;\n-int func2_times = 0;\n-int func3_times = 0;\n-int func1() { func1_times++; return 0; }\n-int func2() { func2_times++; return 0; }\n-int func3() { func3_times++; return 0; }\n-\n-int main()\n-{\n-  array[func1() + 11 : func2() + 22 : func3() + 33] = 666;\n-\n-  if (func1_times != 1\n-      || func2_times != 1\n-      || func3_times != 1)\n-    return 1;\n-\n-  return 0;\n-}"}, {"sha": "b9f9f8d65073bd9ddb2807b59ff12cfc26f66d54", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/test_builtin_return.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_builtin_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_builtin_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_builtin_return.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,73 +0,0 @@\n-/* { dg-options \"-lm -fcilkplus\" } */\n-/* { dg-do run } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-#include <math.h>\n-#define NUMBER 5\n-\n-int func1 (int *a1, int *a2)\n-{\n-  return __sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER:1]);\n-}\n-\n-int func2 (int *a1, int *a2)\n-{\n-  return (__sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER]) + \n-\t  __sec_reduce_mul (a1[0:NUMBER] + a2[0:NUMBER]));\n-}\n-\n-int func3 (int *a1, int *a2)\n-{\n-  return (int) sqrt ((double)(__sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER]) +\n-\t\t\t      a2[0] + a2[1] + a2[3]));\n-}\n-\n-int func4 (int *a1, int *a2)\n-{\n-  return a1[NUMBER-1] * (__sec_reduce_add (a1[0:NUMBER] * a2[0:NUMBER]) + a2[0] + a2[1] + a2[3])/a1[NUMBER-2];\n-}\n-int main(void)\n-{\n-  int array[NUMBER], array2[NUMBER];\n-  int return_value = 0;\n-  int ii = 0;\n-  int argc = 1;\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  for (ii = 0; ii < NUMBER; ii++)\n-    {\n-      array[ii] = argc; /* This should calculate to 1.  */\n-      array2[ii]  = argc * argc + argc;  /* This should calculate to 2.  */\n-    }\n-\n-  return_value = func1 (array, array2);\n-#if HAVE_IO\n-  printf(\"Return_value = %d\\n\", return_value);\n-#endif\n-  if (return_value != (2+2+2+2+2))\n-    return 1;\n-\n-  return_value = func2 (array2, array);\n-#if HAVE_IO\n-  printf(\"Return_value = %d\\n\", return_value);\n-#endif\n-  if (return_value != (3*3*3*3*3) + (2+2+2+2+2))\n-    return 2;\n-\n-  return_value = func3 (array, array2);\n-#if HAVE_IO\n-  printf(\"Return_value = %d\\n\", return_value);\n-#endif\n-  if (return_value != 4)\n-    return 3;\n-\n-  return_value = func4 (array, array2);\n-#if HAVE_IO\n-  printf(\"Return_value = %d\\n\", return_value);\n-#endif\n-  if (return_value != 16)\n-    return 4;\n-\n-  return 0;\n-}"}, {"sha": "f4f3ca5a6bb0de0db091c935ae304b0a263a0d72", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/test_sec_limits.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_sec_limits.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_sec_limits.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftest_sec_limits.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,18 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <limits.h>\n-int A[16];\n-int a = 0;\n-\n-int main () {\n-      if (__sec_reduce_max(A[0:0:2]) != INT_MIN)\n-\t    a++;\n-\n-        if (__sec_reduce_min(A[0:0:2]) != INT_MAX)\n-\t      a++;\n-\n-\t  return a;\n-}\n-\n-"}, {"sha": "015a7eb737085484f1c13710873d5ffa52013704", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/tst_lngth.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftst_lngth.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftst_lngth.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Ftst_lngth.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \" -fcilkplus \" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-#define N 256\n-int A[N], B[N];\n-\n-int\n-main ()\n-{\n-    A[0:(N / 4)] = A[4]+ B[0:(N / 2):2]; /* { dg-error \"length mismatch between\" } */ \n-    A[0:(N / 4)] = B[0:(N / 2):2] + N; /* { dg-error \"length mismatch between\" } */\n-    A[0:(N / 4)] = B[0:(N / 2):2] + A[4]; /* { dg-error \"length mismatch between\" } */\n-    return 0;\n-}\n-"}, {"sha": "3b0777e0f3b25ef2d20fcdf90016c037470f208d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/AN/vla.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FAN%2Fvla.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,20 +0,0 @@\n-/* { dg-do compile { target c } } */\n-/* { dg-options \"-fcilkplus -std=c99 -w\" } */\n-\n-int func (int x)\n-{\n-  return x++;\n-}\n-int main(void)\n-{\n-  int argc = 1;\n-  __asm volatile (\"\" : \"+r\" (argc));\n-  int array[argc];\n-\n-  array[:] = 5; /* { dg-error \"start-index and length fields necessary for using array notations in variable-length arrays.\" }  */\n-  array[0:argc] = 5;               /* This is OK.  */\n-  array[0:5:2] = 5;                /* This is OK.  */\n-  array[0:argc:2] = 5;             /* This is OK.  */\n-  array[0:argc:func (argc-2)] = 5; /* This is OK.  */\n-  return 0;\n-}"}, {"sha": "f07b49a2775f7b8b8d6b98e682e5128266a230f9", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/Wparentheses-1.c", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2FWparentheses-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,69 +0,0 @@\n-/* PR c/70436 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wparentheses\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-int a, b, c;\n-void bar (void);\n-void baz (void);\n-\n-void\n-f1 (void)\n-{\n-  if (a) /* { dg-warning \"ambiguous\" } */\n-    _Cilk_for (int i = 0; i < 10; i++)\n-      if (b)\n-\tbar ();\n-      else\n-\tbaz ();\n-\n-  if (a)\n-    _Cilk_for (int i = 0; i < 10; i++)\n-      {\n-\tif (b)\n-\t  bar ();\n-\telse\n-\t  baz ();\n-      }\n-\n-  if (a)\n-    _Cilk_for (int i = 0; i < 10; i++)\n-      {\n-\tif (b)\n-\t  bar ();\n-      }\n-  else\n-    baz ();\n-}\n-\n-void\n-f2 (void)\n-{\n-  if (a) /* { dg-warning \"ambiguous\" } */\n-    #pragma cilk grainsize = 2\n-    _Cilk_for (int i = 0; i < 10; i++)\n-      if (b)\n-\tbar ();\n-      else\n-\tbaz ();\n-\n-  if (a)\n-    #pragma cilk grainsize = 2\n-    _Cilk_for (int i = 0; i < 10; i++)\n-      {\n-\tif (b)\n-\t  bar ();\n-\telse\n-\t  baz ();\n-      }\n-\n-  if (a)\n-    #pragma cilk grainsize = 2\n-    _Cilk_for (int i = 0; i < 10; i++)\n-      {\n-\tif (b)\n-\t  bar ();\n-      }\n-  else\n-    baz ();\n-}"}, {"sha": "32e4b9a57697fd0aafa17a86f1a213d7036e65c0", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk-for-2.c", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,393 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-int msk;\n-\n-#define BODY \\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    int j = (i >= 30U) ? 30 : i;\t\t\t\t\t\\\n-    if (__atomic_fetch_or (&msk, 1 << j, __ATOMIC_RELAXED) & (1 << j))\t\\\n-      __builtin_abort ();\t\t\t\t\t\t\\\n-  } while (0)\n-#define TEST(x) if (msk != (x)) __builtin_abort (); msk = 0\n-\n-__attribute__((noinline, noclone)) void\n-test (int seven, int three, int two, int minustwo, int ten,\n-      int zero, int eleven, int six, int one, int threealt,\n-      unsigned long int sevenUL, unsigned long int threeUL,\n-      unsigned long int twoUL, unsigned long int minustwoUL,\n-      unsigned long int tenUL, unsigned long int zeroUL,\n-      unsigned long int elevenUL, unsigned long int sixUL,\n-      unsigned long int oneUL, unsigned long int threealtUL)\n-{\n-  _Cilk_for (int i = seven; i < three; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = seven; i <= three; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i != threealt; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = seven; i < three; i += two)\n-    __builtin_abort ();\n-  _Cilk_for (int i = seven; i <= three; i += two)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i != threealt; i += two)\n-    __builtin_abort ();\n-  _Cilk_for (int i = seven; i < three; i -= minustwo)\n-    __builtin_abort ();\n-  _Cilk_for (int i = seven; i <= three; i -= minustwo)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i != threealt; i -= minustwo)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i > seven; --i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i >= seven; i--)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i != threealt; i--)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i > seven; i -= two)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i >= seven; i -= two)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i != threealt; i -= two)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i > seven; i += minustwo)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i >= seven; i += minustwo)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i != threealt; i += minustwo)\n-    __builtin_abort ();\n-  _Cilk_for (int i = three; i < seven; ++i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (int i = three; i <= seven; i++)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (int i = three; i != seven; i++)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (int i = zero; i < ten; i += two)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = zero; i <= ten; i += two)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (int i = zero; i != ten; i += two)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = zero; i < ten; i -= minustwo)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = zero; i <= ten; i -= minustwo)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (int i = zero; i != ten; i -= minustwo)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = six; i > two; --i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (int i = seven; i >= three; i--)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (int i = seven; i != three; i--)\n-    BODY;\n-  TEST (0xf0);\n-  _Cilk_for (int i = eleven; i > one; i += minustwo)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = eleven; i >= two; i += minustwo)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = eleven; i != one; i += minustwo)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = eleven; i > one; i -= two)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = eleven; i >= two; i -= two)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = eleven; i != one; i -= two)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = sevenUL; i < threeUL; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = sevenUL; i <= threeUL; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = sevenUL; i < threeUL; i += twoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = sevenUL; i <= threeUL; i += twoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i += twoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = sevenUL; i < threeUL; i -= minustwoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = sevenUL; i <= threeUL; i -= minustwoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i -= minustwoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i > sevenUL; --i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i >= sevenUL; i--)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i--)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i > sevenUL; i -= twoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i >= sevenUL; i -= twoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i -= twoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i > sevenUL; i += minustwoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i >= sevenUL; i += minustwoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i != threealtUL; i += minustwoUL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = threeUL; i < sevenUL; ++i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (unsigned long int i = threeUL; i <= sevenUL; i++)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (unsigned long int i = threeUL; i != sevenUL; i++)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (unsigned long int i = zeroUL; i < tenUL; i += twoUL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = zeroUL; i <= tenUL; i += twoUL)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (unsigned long int i = zeroUL; i != tenUL; i += twoUL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = zeroUL; i < tenUL; i -= minustwoUL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = zeroUL; i <= tenUL; i -= minustwoUL)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (unsigned long int i = zeroUL; i != tenUL; i -= minustwoUL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = sixUL; i > twoUL; --i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (unsigned long int i = sevenUL; i >= threeUL; i--)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (unsigned long int i = sevenUL; i != threeUL; i--)\n-    BODY;\n-  TEST (0xf0);\n-  _Cilk_for (unsigned long int i = elevenUL; i > oneUL; i += minustwoUL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = elevenUL; i >= twoUL; i += minustwoUL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = elevenUL; i != oneUL; i += minustwoUL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = elevenUL; i > oneUL; i -= twoUL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = elevenUL; i >= twoUL; i -= twoUL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = elevenUL; i != oneUL; i -= twoUL)\n-    BODY;\n-  TEST (0xaa8);\n-}\n-\n-int\n-main ()\n-{\n-  _Cilk_for (int i = 7; i < 3; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 7; i <= 3; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i != 3; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 7; i < 3; i += 2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 7; i <= 3; i += 2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i != 3; i += 2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 7; i < 3; i -= -2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 7; i <= 3; i -= -2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i != 3; i -= -2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i > 7; --i)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i >= 7; i--)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i != 3; i--)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i > 7; i -= 2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i >= 7; i -= 2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i != 3; i -= 2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i > 7; i += -2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i >= 7; i += -2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i != 3; i += -2)\n-    __builtin_abort ();\n-  _Cilk_for (int i = 3; i < 7; ++i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (int i = 3; i <= 7; i++)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (int i = 3; i != 7; i++)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (int i = 0; i < 10; i += 2)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = 0; i <= 10; i += 2)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (int i = 0; i != 10; i += 2)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = 0; i < 10; i -= -2)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = 0; i <= 10; i -= -2)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (int i = 0; i != 10; i -= -2)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (int i = 6; i > 2; --i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (int i = 7; i >= 3; i--)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (int i = 7; i != 3; i--)\n-    BODY;\n-  TEST (0xf0);\n-  _Cilk_for (int i = 11; i > 1; i += -2)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = 11; i >= 2; i += -2)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = 11; i != 1; i += -2)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = 11; i > 1; i -= 2)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = 11; i >= 2; i -= 2)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (int i = 11; i != 1; i -= 2)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = 7UL; i < 3UL; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 7UL; i <= 3UL; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i != 3UL; ++i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 7UL; i < 3UL; i += 2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 7UL; i <= 3UL; i += 2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i += 2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 7UL; i < 3UL; i -= -2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 7UL; i <= 3UL; i -= -2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i -= -2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i > 7UL; --i)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i >= 7UL; i--)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i--)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i > 7UL; i -= 2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i >= 7UL; i -= 2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i -= 2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i > 7UL; i += -2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i >= 7UL; i += -2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i != 3UL; i += -2UL)\n-    __builtin_abort ();\n-  _Cilk_for (unsigned long int i = 3UL; i < 7UL; ++i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (unsigned long int i = 3UL; i <= 7UL; i++)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (unsigned long int i = 3UL; i != 7UL; i++)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (unsigned long int i = 0UL; i < 10UL; i += 2UL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = 0UL; i <= 10UL; i += 2UL)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (unsigned long int i = 0UL; i != 10UL; i += 2UL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = 0UL; i < 10UL; i -= -2UL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = 0UL; i <= 10UL; i -= -2UL)\n-    BODY;\n-  TEST (0x555);\n-  _Cilk_for (unsigned long int i = 0UL; i != 10UL; i -= -2UL)\n-    BODY;\n-  TEST (0x155);\n-  _Cilk_for (unsigned long int i = 6UL; i > 2UL; --i)\n-    BODY;\n-  TEST (0x78);\n-  _Cilk_for (unsigned long int i = 7UL; i >= 3UL; i--)\n-    BODY;\n-  TEST (0xf8);\n-  _Cilk_for (unsigned long int i = 7UL; i != 3UL; i--)\n-    BODY;\n-  TEST (0xf0);\n-  _Cilk_for (unsigned long int i = 11UL; i > 1UL; i += -2UL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = 11UL; i >= 2UL; i += -2UL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = 11UL; i != 1UL; i += -2UL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = 11UL; i > 1UL; i -= 2UL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = 11UL; i >= 2UL; i -= 2UL)\n-    BODY;\n-  TEST (0xaa8);\n-  _Cilk_for (unsigned long int i = 11UL; i != 1UL; i -= 2UL)\n-    BODY;\n-  TEST (0xaa8);\n-  test (7, 3, 2, -2, 10, 0, 11, 6, 1, 3,\n-\t7UL, 3UL, 2UL, -2UL, 10UL, 0UL, 11UL, 6UL, 1UL, 3UL);\n-  return 0;\n-}"}, {"sha": "04c1635b012b1eb1c009dfa18f08e36c7ebd797a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk-for-3.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-for-3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,19 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-void bar (int *, int *, int *, int *);\n-void baz (char **, char **, char **, int *);\n-\n-void\n-foo ()\n-{\n-  int a, b, c;\n-  char *d, *e;\n-  bar (0, &a, &b, &c);\n-  _Cilk_for (int i = a; i < b; i += c)\n-    bar (&i, &a, &b, &c);\n-  baz (0, &d, &e, &c);\n-  _Cilk_for (char *p = d; p != e; p += c)\n-    baz (&p, &d, &e, &c);\n-}"}, {"sha": "6b2bbf779ae81d5d6432c5bd6e204132c108788c", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk-fors.c", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-fors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-fors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk-fors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,87 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-static void check (int *Array, int start, int end, int incr, int value)\n-{\n-  int ii = 0;\n-  for (ii = start;  ii < end; ii = ii + incr)\n-    if (Array[ii] != value)\n-      __builtin_abort ();\n-#if HAVE_IO\n-  printf (\"Passed\\n\");\n-#endif\n-}\n-\n-static void check_reverse (int *Array, int start, int end, int incr, int value)\n-{\n-  int ii = 0;\n-  for (ii = start; ii >= end; ii = ii - incr)\n-    if (Array[ii] != value)\n-      __builtin_abort ();\n-#if HAVE_IO\n-  printf (\"Passed\\n\");\n-#endif\n-}\n-\n-\n-int main (void)\n-{\n-  int Array[10];\n-  int x = 9, y = 0, z = 3;\n-\n-\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    Array[ii] = 1133;\n-  check (Array, 0, 10, 1, 1133);\n-\n-  _Cilk_for (int ii = 0; ii < 10; ++ii)\n-    Array[ii] = 3311;\n-  check (Array, 0, 10, 1, 3311);\n-\n-  _Cilk_for (int ii = 9; ii > -1; ii--)\n-    Array[ii] = 4433;\n-  check_reverse (Array, 9, 0, 1, 4433);\n-\n-  _Cilk_for (int ii = 9; ii > -1; --ii)\n-    Array[ii] = 9988;\n-  check_reverse (Array, 9, 0, 1, 9988);\n-\n-  _Cilk_for (int ii = 0; ii < 10; ++ii)\n-    Array[ii] = 3311;\n-  check (Array, 0, 10, 1, 3311);\n-\n-  _Cilk_for (int ii = 0; ii < 10; ii += 2)\n-    Array[ii] = 1328;\n-  check (Array, 0, 10, 2, 1328);\n-\n-  _Cilk_for (int ii = 9; ii >= 0; ii -= 2)\n-    Array[ii] = 1738;\n-  check_reverse (Array, 9, 0, 2, 1738);\n-\n-\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    {\n-      if (ii % 2)\n-\tArray[ii] = 1343;\n-      else\n-\tArray[ii] = 3413;\n-    }\n-\n-  check (Array, 1, 10, 2, 1343);\n-  check (Array, 0, 10, 2, 3413);\n-\n-  _Cilk_for (short cc = 0; cc < 10; cc++)\n-    Array[cc] = 1343;\n-  check (Array, 0, 10,  1,1343);\n-\n-  _Cilk_for (short cc = 9; cc >= 0; cc--)\n-    Array[cc] = 1348;\n-  check_reverse (Array, 9, 0, 1, 1348);\n-  return 0;\n-}"}, {"sha": "ca080c8f27aa730ef93e9327efea8b8c8df9824f", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_errors.c", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_errors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,53 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=c99\" { target c } } */\n-\n-\n-int main (void)\n-{\n-  int q = 0, ii = 0, jj = 0;\n-\n-  _Cilk_for (int ii; ii < 10; ii++) /* { dg-error \"is not initialized\" \"\" { target c } } */\n-    /* { dg-error \"expected\" \"\" { target c++ } .-1 } */\n-    q = 5;\n-\n-  _Cilk_for (; ii < 10; ii++) /* { dg-error \"expected iteration declaration\" } */\n-    q = 2;\n-\n-  _Cilk_for (int ii = 0; ; ii++) /* { dg-error \"missing controlling predicate\" } */\n-    q = 2;\n-\n-  _Cilk_for (int ii = 0; ii < 10, jj < 10; ii++)  /* { dg-error \"expected ';' before ',' token\" \"\" { target c } } */\n-    /* { dg-error \"invalid controlling predicate\" \"\" { target c++ }  .-1 } */\n-    q = 5;\n-\n-  _Cilk_for (int ii = 0; ii < 10; ) /* { dg-error \"missing increment\" } */\n-    q = 5;\n-\n-  _Cilk_for (int ii = 0, jj = 0; ii < 10; ii++) /* { dg-error \"expected|invalid\" } */\n-    q = 5;\n-\n-  _Cilk_for (volatile int vii = 0; vii < 10; vii++) /* { dg-error \"iteration variable cannot be volatile\" } */\n-    q = 5;\n-\n-  _Cilk_for (static int sii = 0; sii < 10; sii++) /* { dg-error \"static|expected|declared|expression\" } */\n-    q = 5;\n-\n-  _Cilk_for (float fii = 3.47; fii < 5.23; fii++) /* { dg-error \"invalid type for iteration variable\" } */\n-    q = 5;\n-\n-  _Cilk_for (int ii = 0; 10 > jj; ii++) /* { dg-error \"invalid controlling predicate\" } */\n-    q = 5;\n-\n-  _Cilk_for (int ii = 0; ii < 10; ii >> 1) /* { dg-error \"invalid increment expression\" } */\n-    q = 5;\n-\n-  _Cilk_for (int ii = 10; ii >= 0; ii--) /* This is OK!  */\n-    q = 5;\n-\n-  _Cilk_for (int ii; ii < 10; ii++) /* { dg-error \"is not initialized\" \"\" { target c } } */\n-    /* { dg-error \"expected\" \"\" { target c++ } .-1 } */\n-    q = 5;\n-\n-  return 0;\n-}"}, {"sha": "5a95a06274f8e016582438167136c3f4d8434b1d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_grain.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-\n-int grain_value = 2;\n-int main (void)\n-{\n-  int Array1[200], Array1_Serial[200];\n-\n-  for (int ii = 0; ii < 200; ii++)\n-    {\n-      Array1_Serial[ii] = 2;\n-      Array1[ii] = 1;\n-    }\n-\n-#pragma cilk grainsize = 2\n-  _Cilk_for (int ii = 0; ii < 200; ii++)\n-    Array1[ii] = 2;\n-\n-  for (int ii = 0; ii < 200; ii++)\n-    if (Array1[ii] != Array1_Serial[ii])\n-      return (ii+1);\n-\n-#pragma cilk grainsize = grain_value\n-  _Cilk_for (int ii = 0; ii < 200; ii++)\n-    Array1[ii] = 2;\n-\n-  for (int ii = 0; ii < 200; ii++)\n-    if (Array1[ii] != Array1_Serial[ii])\n-      return (ii+1);\n-\n-  return 0;\n-}"}, {"sha": "bb72281120266b6f6288f67dd45d369e314c8a15", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_grain_errors.c", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_grain_errors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,48 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wunknown-pragmas\" } */\n-/* { dg-additional-options \"-std=c99\" { target c } } */\n-\n-\n-char Array1[26];\n-\n-#pragma cilk grainsize = 2 /* { dg-error \"must be inside a function\" } */\n-\n-int main(int argc, char **argv)\n-{\n-/* This is OK.  */\n-#pragma cilk grainsize = 2\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    Array1[ii] = 0;\n-\n-#pragma cilk grainsize 2 /* { dg-error \"expected '=' before numeric constant\" } */\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    Array1[ii] = 0;\n-\n-#pragma cilk grainsiz = 2 /* { dg-warning \"-:ignoring #pragma cilk grainsiz\" } */\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    Array1[ii] = 0;\n-\n-\n-/* This is OK, it will do a type conversion to long int.  */\n-#pragma cilk grainsize = 0.5\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    Array1[ii] = 0;\n-\n-#pragma cilk grainsize = 1\n-  while (Array1[5] != 0) /* { dg-warning \"is not followed by\" } */\n-    {\n-    /* Blah */\n-    }\n-\n-#pragma cilk grainsize = 1\n-  int q = 0; /* { dg-warning \"is not followed by\" } */\n-  _Cilk_for (q = 0; q < 10; q++) /* { dg-error \"allows expression instead of declaration\" \"\" { target c++ } } */\n-    Array1[q] = 5;\n-\n-  while (Array1[5] != 0)\n-    {\n-    /* Blah */\n-    }\n-\n-  return 0;\n-}"}, {"sha": "1f8e84ee3d596268c8996a2a0bfe2a5890c29abe", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/cilk_for_ptr_iter.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_ptr_iter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_ptr_iter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcilk_for_ptr_iter.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,35 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-\n-\n-/* <feature> loop control variable must have integer, pointer or class type\n-   </feature>\n-*/\n-\n-#define ARRAY_SIZE 10000\n-int a[ARRAY_SIZE];\n-\n-int main(void)\n-{\n-  int ii = 0;\n-\n-  for (ii =0; ii < ARRAY_SIZE; ii++)\n-    a[ii] = 5;\n-  _Cilk_for(int *aa = a; aa < a + ARRAY_SIZE; aa++)\n-    *aa = 0;\n-  for (ii = 0; ii < ARRAY_SIZE; ii++)\n-    if (a[ii] != 0)\n-      __builtin_abort ();\n-\n-  _Cilk_for (int *aa = a; aa < a + ARRAY_SIZE; aa = aa + 2)\n-    *aa = 4;\n-\n-  for (ii = 0; ii < ARRAY_SIZE; ii = ii + 2)\n-    if (a[ii] != 4)\n-      __builtin_abort ();\n-\n-  return 0;\n-}"}, {"sha": "5e687bd0a0c8cd6dc1aac1555c8722bee5a7fc8a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/compound_cilk_spawn.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcompound_cilk_spawn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcompound_cilk_spawn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcompound_cilk_spawn.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,26 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-/* <feature>\n-   A program is considered ill formed if the _Cilk_spawn form of this\n-    expression appears other than in one of the following contexts:\n-    as the entire body of an expression statement,\n-    as the entire right hand side of an assignment expression that is the entire\n-    body of an expression statement, or as the entire initializer-clause in a \n-    simple declaration.\n-   </feature>\n-*/\n-\n-int spawn_func (int arg)\n-{\n-  return arg + 1;\n-}\n-\n-int check()\n-{\n-  int z;\n-  z = 23, _Cilk_spawn spawn_func (3), 3424; /* { dg-error \"spawned function call cannot be part of a comma expression\" } */\n-  23, spawn_func (5), _Cilk_spawn spawn_func (3); /* { dg-error \"spawned function call cannot be part of a comma expression\" } */\n-  _Cilk_spawn spawn_func (0), _Cilk_spawn spawn_func (3), 3, spawn_func (0); /* { dg-error \"spawned function call cannot be part of a comma expression\" } */\n-  return 23;\n-}"}, {"sha": "b93c9626d189e342100fd25c8ed6bc5f46ac43af", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/concec_cilk_spawn.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fconcec_cilk_spawn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fconcec_cilk_spawn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fconcec_cilk_spawn.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,20 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-/* <feature> Consecutive _Cilk_spawn tokens are not permitted\n-   </feature>\n-*/\n-\n-int spawn_func (int arg)\n-{\n-  return arg + 1;\n-}\n-\n-void func ()\n-{\n-  int a;\n-  a = _Cilk_spawn _Cilk_spawn spawn_func (4); /* { dg-error \"consecutive\" } */\n-  a = _Cilk_spawn _Cilk_spawn _Cilk_spawn spawn_func (4); /* { dg-error \"consecutive\" } */\n-  a = _Cilk_spawn _Cilk_spawn _Cilk_spawn _Cilk_spawn spawn_func (4); /* { dg-error \"consecutive\" } */\n-  return;\n-}"}, {"sha": "d637924e9e1596775326391c5635c1f8075d059c", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/errors.c", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ferrors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ferrors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ferrors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,56 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wno-return-type\" } */\n-\n-int func_2(void);\n-\n-int check_spawn(int v)\n-{\n-  if (_Cilk_spawn func_2()) /* { dg-error \"cannot contain\" \"\" { target c } } */\n-  /* XXX: no error in C++ */\n-    ;\n-  if (v + _Cilk_spawn func_2())  /* { dg-error \"cannot contain\" \"\" { target c } } */\n-  /* { dg-error \"invalid use\" \"\" { target c++ } .-1 } */\n-    ;\n-  if (v, _Cilk_spawn func_2()) /* { dg-error \"spawned function call cannot be part\" } */\n-    ;\n-  v, _Cilk_spawn func_2(); /* { dg-error \"spawned function call cannot be part\" } */\n-  while (_Cilk_spawn func_2())  /* { dg-error \"a condition for while statement\" } */\n-    ;\n-  while (v + _Cilk_spawn func_2())  /* { dg-error \"a condition for while statement\" } */\n-    ;\n-  for (; _Cilk_spawn func_2() ;)  /* { dg-error \"cannot be used\" } */\n-    ;\n-  for (; v + _Cilk_spawn func_2() ;)  /* { dg-error \"cannot be used\" } */\n-    ;\n-  v + _Cilk_spawn func_2(); /* { dg-error } */\n-  for (_Cilk_spawn func_2() ;;)\n-    ;\n-  for (;; _Cilk_spawn func_2())\n-    ;\n-  do {} while(_Cilk_spawn func_2());  /* { dg-error \"cannot be used\" } */\n-  do {} while(v + _Cilk_spawn func_2());  /* { dg-error \"cannot be used\" } */\n-  switch (_Cilk_spawn func_2())   /* { dg-error \"cannot be used\" } */\n-    {\n-    default: break;\n-    }\n-  goto *(_Cilk_spawn func_2()); /* { dg-error \"cannot be used\" } */\n-\n-  return _Cilk_spawn func_2(); /* { dg-error \"is not allowed\" } */\n-}\n-\n-int check_array_notation(int x[100], int y[100])\n-{\n-  x[0:100] = y[0:100];\n-  for (; x[0:100] = y[0:100]; )  /* { dg-error \"cannot be used\" } */\n-    ;\n-  while (x[0:100] = y[0:100])  /* { dg-error \"cannot be used\" } */\n-    ;\n-  switch (x[0:100] = y[0:100])  /* { dg-error \"cannot be used\" } */\n-    {\n-      default: break;\n-    }\n-  do {} while (x[0:100] = y[0:100]);  /* { dg-error \"cannot be used\" } */\n-  if (x[0:100] = y[0:100]) /* allowed */\n-    ;\n-  return x[0:100] = y[0:100]; /* { dg-error \"cannot be used\" } */\n-}"}, {"sha": "40e1cb48c256beeeaaad301e2ffbf46c05c0ea89", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,54 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-int fib        (int);\n-int fib_serial (int);\n-\n-#define FIB_ITERATION  30\n-\n-int main(void)\n-{\n-  int ii = 0;\n-  int fib_result[FIB_ITERATION+1], fib_serial_result[FIB_ITERATION+1];\n-#if HAVE_IO\n-\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    printf(\"fib (%2d) = %10d\\n\", ii, fib (ii));\n-#else\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      fib_result[ii]        = fib (ii);\n-    }\n-\n-  fib_serial_result[0] = 0;\n-  fib_serial_result[1] = 1;\n-  for (ii = 2; ii <= FIB_ITERATION; ii++)\n-    fib_serial_result[ii] = fib_serial_result[ii-1] + fib_serial_result[ii-2];\n-  \n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      if (fib_result[ii] != fib_serial_result[ii])\n-\t__builtin_abort ();\n-    }\n-#endif\n-  return 0;\n-}\n-\n-int fib(int n)\n-{\n-  int x = 0, y = 0;\n-  if (n < 2) \n-    return n;\n-  else\n-  {\n-    x = _Cilk_spawn fib(n-1);\n-    y = fib(n-2);\n-    _Cilk_sync;\n-    return (x+y);\n-  }\n-}"}, {"sha": "41fd0dbe1d6ffcab0d00e71efa67531d860a108c", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib_init_expr_xy.c", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_init_expr_xy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_init_expr_xy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_init_expr_xy.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-int fib        (int);\n-int fib_serial (int);\n-\n-#define FIB_ITERATION 30\n-\n-int main(void)\n-{\n-  int ii = 0;\n-  int fib_result[FIB_ITERATION+1], fib_serial_result[FIB_ITERATION+1];\n-#if HAVE_IO\n-\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    printf(\"fib (%2d) = %10d\\n\", ii, fib (ii));\n-#else\n-    for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      fib_result[ii]        = fib (ii);\n-    }\n-\n-  fib_serial_result[0] = 0;\n-  fib_serial_result[1] = 1;\n-  \n-  for (ii = 2; ii <= FIB_ITERATION; ii++)\n-    fib_serial_result[ii] = fib_serial_result[ii-1] + fib_serial_result[ii-2];\n-  \n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      if (fib_result[ii] != fib_serial_result[ii])\n-\t__builtin_abort ();\n-    }\n-\n-#endif\n-  return 0;\n-}\n-\n-int fib_serial (int n)\n-{\n-  int x = 0, y = 0;\n-  if (n < 2)\n-    return n;\n-  else\n-    {\n-      x = fib_serial (n-1);\n-      y = fib_serial (n-2);\n-      return (x+y);\n-    }\n-}\n-\n-int fib(int n)\n-{\n-  if (n < 2) \n-    return n;\n-  else\n-  {\n-    int x = _Cilk_spawn fib(n-1);\n-    int y = fib(n-2);\n-    _Cilk_sync;\n-    return (x+y);\n-  }\n-}"}, {"sha": "ccdbcfdce66bec859d8597e59c3d830ea24e79c8", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib_no_return.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_return.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,73 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-#define FIB_ITERATION 30\n-\n-void fib        (int *, int);\n-int fib_serial (int);\n-\n-int main(void)\n-{\n-  int ii = 0, error = 0;\n-  int fib_result[FIB_ITERATION+1], fib_serial_result[FIB_ITERATION+1];\n-\n-#if HAVE_IO\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      int result = 0;\n-      fib (&result, ii); \n-      printf(\"fib (%2d) = %10d\\n\", ii, result);\n-    }\n-#else\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      fib (&fib_result[ii], ii);\n-    }\n-  \n-  fib_serial_result[0] = 0;\n-  fib_serial_result[1] = 1;\n-  \n-  for (ii = 2; ii <= FIB_ITERATION; ii++)\n-    fib_serial_result[ii] = fib_serial_result[ii-1] + fib_serial_result[ii-2];\n-  \n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      if (fib_result[ii] != fib_serial_result[ii])\n-\t__builtin_abort ();\n-    }\n-#endif\n-  \n-  return 0;\n-}\n-\n-int fib_serial (int n)\n-{\n-  int x = 0, y = 0;\n-  if (n < 2)\n-    return n;\n-  else\n-    {\n-      x = fib_serial (n-1);\n-      y = fib_serial (n-2);\n-      return (x+y);\n-    }\n-}\n-\n-void fib(int *result, int n)\n-{\n-  int x = 0, y = 0;\n-  if (n < 2) \n-    x = n;\n-  else\n-  {\n-    _Cilk_spawn fib(&x, n-1);\n-    fib(&y, n-2);\n-    _Cilk_sync;\n-  } \n- *result = (x+y);\n-}"}, {"sha": "2c2a94b27a5331f44abd5f7b96692d4ad103833a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib_no_sync.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_sync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_sync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_sync.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,67 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-#define FIB_ITERATION 30\n-\n-int fib        (int);\n-int fib_serial (int);\n-\n-int main(void)\n-{\n-  int ii = 0;\n-  int fib_result[FIB_ITERATION+1], fib_serial_result[FIB_ITERATION+1];\n-#if HAVE_IO\n-\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    printf(\"fib (%2d) = %10d\\n\", ii, fib (ii));\n-#else\n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      fib_result[ii]        = fib (ii);\n-    }\n-\n-  fib_serial_result[0] = 0;\n-  fib_serial_result[1] = 1;\n-  \n-  for (ii = 2; ii <= FIB_ITERATION; ii++)\n-    fib_serial_result[ii] = fib_serial_result[ii-1] + fib_serial_result[ii-2];\n-  \n-  for (ii = 0; ii <= FIB_ITERATION; ii++)\n-    {\n-      if (fib_result[ii] != fib_serial_result[ii])\n-\t__builtin_abort ();\n-    }\n-\n-#endif\n-  return 0;\n-}\n-\n-int fib_serial (int n)\n-{\n-  int x = 0, y = 0;\n-  if (n < 2)\n-    return n;\n-  else\n-    {\n-      x = fib_serial (n-1);\n-      y = fib_serial (n-2);\n-      return (x+y);\n-    }\n-}\n-\n-int fib(int n)\n-{\n-  if (n < 2) \n-    return n;\n-  else\n-  {\n-    int x = _Cilk_spawn fib(n-1);\n-    int y = fib(n-2);\n-    return (x+y);\n-  }\n-}"}, {"sha": "5b43be76010b3674a54c29c18ace7f21e29d4d9d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/invalid_spawns.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_spawns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_spawns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_spawns.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,14 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-\n-extern int foo ();\n-int bar = _Cilk_spawn foo (); /* { dg-error \"may only be used inside a function\" } */\n-\n-\n-int main (void)\n-{\n-  int x; \n-\n-  _Cilk_spawn foo; /* { dg-error \"only function calls can be spawned\" } */\n-  _Cilk_spawn x; /* { dg-error \"only function calls can be spawned\" } */\n-  return x;\n-}"}, {"sha": "cf1caf12b31e62379aa2112cba3c1327db064f8b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/invalid_sync.cc", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_sync.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,9 +0,0 @@\n-/* PR c/60189 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-    _Cilk_sync return; /* { dg-error \" expected ';' before 'return'\" } */\n-    return 0;\n-}"}, {"sha": "8f080a112522306639ee16cb077b44ad208dd0aa", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/nested_cilk_for.c", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fnested_cilk_for.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fnested_cilk_for.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fnested_cilk_for.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,79 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-int main (void)\n-{\n-  int Array[10][10];\n-\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    for (int jj = 0; jj < 10; jj++)\n-\t{\n-\t  Array[ii][jj] = 0;\n-\t}\n-\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    _Cilk_for (int jj = 0; jj < 5; jj++)\n-      Array[ii][jj] = 5;\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    for (int jj = 0; jj < 5; jj++)\n-      if (Array[ii][jj] != 5)\n-#if HAVE_IO\n-\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n-#else\n-\t__builtin_abort ();\n-#endif\n-\n-\n-  /* One goes up and one goes down.  */\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    _Cilk_for (int jj = 9; jj >= 0; jj--)\n-      Array[ii][jj] = 7;\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    for (int jj = 9; jj >= 0; jj--)\n-      if (Array[ii][jj] != 7)\n-#if HAVE_IO\n-\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n-#else\n-\t__builtin_abort ();\n-#endif\n-\n-  /* different step sizes.  */\n-  _Cilk_for (int ii = 0; ii < 10; ii++)\n-    _Cilk_for (int jj = 0; jj < 10; jj += 2)\n-      Array[ii][jj] = 9;\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    for (int jj = 0; jj < 10; jj += 2)\n-      if (Array[ii][jj] != 9)\n-#if HAVE_IO\n-\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n-#else\n-\t__builtin_abort ();\n-#endif\n-\n-  /* different step sizes.  */\n-  _Cilk_for (int ii = 0; ii < 10; ii += 2)\n-    _Cilk_for (int jj = 5; jj < 9; jj++)\n-      Array[ii][jj] = 11;\n-\n-  for (int ii = 0; ii < 10; ii += 2)\n-    for (int jj = 5; jj < 9; jj++)\n-      if (Array[ii][jj] != 11)\n-#if HAVE_IO\n-\tprintf(\"Array[%d][%d] = %d\\n\", ii, jj, Array[ii][jj]);\n-#else\n-\t__builtin_abort ();\n-#endif\n-\n-  return 0;\n-}\n-"}, {"sha": "a2f20d22238832049eace81984ce8fdc2ae3a5a9", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/no_args_error.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fno_args_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fno_args_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fno_args_error.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,11 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int spawn_1 ();\n-typedef int(*func) (int);\n-\n-void check () {\n-      func var = spawn_1; /* { dg-error \"invalid conversion from\" \"\" { target c++ } } */\n-        _Cilk_spawn var (); /* { dg-error \"too few arguments to function\" } */ \n-}\n-"}, {"sha": "389ee7c5dab0792a520871aac8e073fd5b42ec7d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr59631.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr59631.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr59631.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr59631.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,15 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \" \" } */  \n-\n-/* Tests the errors when Cilk keywords are used without -fcilkplus.  */\n-\n-void foo()\n-{\n-    _Cilk_spawn foo(); /* { dg-error \"must be enabled to use\" } */\n-}\n-\n-void foo2 ()\n-{\n-  _Cilk_spawn foo (); /* { dg-error \"must be enabled to use\" } */\n-  _Cilk_sync; /* { dg-error \"must be enabled to use\" } */\n-}"}, {"sha": "1e5ca00a40b374fcae1e69179287d6bb5d1e8a33", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr60197-2.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60197-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60197-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60197-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,35 +0,0 @@\n-/* PR c/60197 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-extern int foo (void);\n-\n-int\n-fn1 (void)\n-{\n-  int i;\n-  i = (_Cilk_spawn foo ()) + 1; /* { dg-error \"invalid use of\" } */\n-  return i;\n-}\n-\n-int\n-fn2 (void)\n-{\n-  int i = (_Cilk_spawn foo ()) + 1; /* { dg-error \"invalid use of\" } */\n-  return i;\n-}\n-\n-int\n-fn3 (int j, int k, int l)\n-{\n-  int i = (((((_Cilk_spawn foo ()) + 1) - l) * k) / j); /* { dg-error \"invalid use of\" } */\n-  return i;\n-}\n-\n-int\n-fn4 (int j, int k, int l)\n-{\n-  int i;\n-  i = (((((_Cilk_spawn foo ()) + 1) - l) * k) / j); /* { dg-error \"invalid use of\" } */\n-  return i;\n-}"}, {"sha": "301a6f2e9d12c1587fc865283349e145f552cd6a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr60197.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60197.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60197.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60197.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,66 +0,0 @@\n-/* PR c/60197 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wno-return-type\" } */\n-\n-extern int foo (void);\n-extern int bar (int);\n-\n-int\n-fn1 (void)\n-{\n-  return (_Cilk_spawn foo ()) * 2; /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn2 (void)\n-{\n-  return (_Cilk_spawn foo ()) > 2; /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn3 (int i, int j, int k)\n-{\n-  return ((((((_Cilk_spawn foo () + i) - j) * k) / j) | i) ^ k) ; /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn4 (int i, int j, int k)\n-{\n-  return (((((i - _Cilk_spawn foo ()) * k) / j) | i) ^ k); /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn5 (void)\n-{\n-  return _Cilk_spawn foo (); /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn6 (void)\n-{\n-  return _Cilk_spawn foo () + _Cilk_spawn foo (); /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn7 (void)\n-{\n-  return 5 % _Cilk_spawn foo (); /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn8 (void)\n-{\n-  return !_Cilk_spawn foo (); /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn9 (void)\n-{\n-  return foo () && _Cilk_spawn foo (); /* { dg-error \"in a return statement is not allowed\" } */\n-}\n-\n-int\n-fn10 (void)\n-{\n-  return bar (_Cilk_spawn foo ()); /* { dg-error \"in a return statement is not allowed\" } */\n-}"}, {"sha": "670df17faa2c56b5268e5c05b2accd9453a78287", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr60469.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60469.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60469.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60469.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,18 +0,0 @@\n-/* PR middle-end/60469 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -fdump-tree-original\" } */\n-\n-void foo() {}\n-\n-#define ALEN 1024\n-\n-int main(int argc, char* argv[])\n-{\n-  int b[ALEN];\n-  b[:] = 100;\n-  _Cilk_spawn foo();\n-  return 0;\n-}\n-\n-/* The C++ FE once emitted a bogus error_mark_node for this test case.  */\n-/* { dg-final { scan-tree-dump-not \"<<< error >>>\" \"original\" } } */"}, {"sha": "e2dc7b0c9d57da24cf7e543065d3579981763aa6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr60586.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60586.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60586.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr60586.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus -O2\" } */\n-\n-int noop(int x)\n-{\n-  return x;\n-}\n-\n-int post_increment(int *x)\n-{\n-  return (*x)++;\n-}\n-\n-int main(int argc, char *argv[])\n-{\n-  int m = 5;\n-  int n = m;\n-  int r = _Cilk_spawn noop(post_increment(&n));\n-  int n2 = n;\n-  _Cilk_sync;\n-\n-  if (r != m || n2 != m + 1)\n-    return 1;\n-  else\n-    return 0;\n-}\n-"}, {"sha": "6db5386eaf0fc09d08c11468cdbd0a025ce37390", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr63307.c", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr63307.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr63307.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr63307.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,4 +0,0 @@\n-/* { dg-options \"-fcilkplus -fcompare-debug\" } */\n-/* { dg-do compile } */\n-\n-#include \"fib_no_return.c\""}, {"sha": "97775243ccda2c298b39a05f276850bb35b65bac", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr69826-1.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr69826-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr69826-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr69826-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,25 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-#define GRAINSIZE 2\n-\n-int\n-main ()\n-{\n-  int a[64];\n-  #pragma cilk grainsize=GRAINSIZE\n-  _Cilk_for (int i = 0; i < 64; i++)\n-    a[i] = 0;\n-  #pragma cilk grainsize =GRAINSIZE\n-  _Cilk_for (int i = 0; i < 64; i++)\n-    a[i]++;\n-  #pragma cilk grainsize = GRAINSIZE\n-  _Cilk_for (int i = 0; i < 64; i++)\n-    a[i]++;\n-  for (int i = 0; i < 64; i++)\n-    if (a[i] != 2)\n-      __builtin_abort ();\n-  return 0;\n-}"}, {"sha": "64d59291975cd534a16ffc7ee7cab320fe12086b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr69826-2.c", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr69826-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr69826-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr69826-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,6 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus -save-temps\" } */\n-/* { dg-additional-options \"-std=gnu99\" { target c } } */\n-\n-#include \"pr69826-1.c\""}, {"sha": "cd4d40686a5c879433e608e906e0d06e150efd6e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr79428-4.c", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr79428-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr79428-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr79428-4.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,3 +0,0 @@\n-/* PR c/79428 */\n-/* { dg-options \"-fcilkplus\" } */\n-#pragma cilk grainsize /* { dg-error \"must be inside a function\" } */"}, {"sha": "bc36f51d914b75cdd0ba5a0413896f55463d440e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/pr79428-7.c", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr79428-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr79428-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fpr79428-7.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,3 +0,0 @@\n-/* PR c/79428 */\n-/* { dg-options \"-fcilkplus\" } */\n-#pragma simd /* { dg-error \"must be inside a function\" } */"}, {"sha": "602971e02c9c021c24e76dd103de80edcaa0c872", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawn_in_return.c", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawn_in_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawn_in_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawn_in_return.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,8 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wno-return-type\" } */\n-\n-int main (void)\n-{\n-  extern int foo ();\n-  return _Cilk_spawn foo (); /* { dg-error \"return statement is not allowed\" } */\n-}"}, {"sha": "416d77abb11d456a1a6165c98d458c65917a57b6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawnee_inline.c", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawnee_inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawnee_inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawnee_inline.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,80 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus -w\" } */\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#define DEFAULT_VALUE \"30\"\n-\n-int fib (char *n_char)\n-{\n-  int n;\n-  char n_char_minus_one[20], n_char_minus_two[20];\n-  if (n_char)\n-    n = atoi (n_char);\n-  else\n-    n = atoi(DEFAULT_VALUE);\n-  \n-  if (n < 2)\n-    return n;\n-  else\n-    {\t   \n-      int x, y;\n-      sprintf (n_char_minus_one,\"%d\", n-1); \n-      sprintf (n_char_minus_two,\"%d\", n-2); \n-      x = _Cilk_spawn fib (n_char_minus_one);\n-      y = _Cilk_spawn fib (n_char_minus_two);\n-      _Cilk_sync;\n-      return (x+y);\n-    }\n-}\n-\n-int fib_serial (int n)\n-{\n-  int x, y;\n-  if (n < 2)\n-    return n;\n-  else\n-    {\n-      x = fib_serial (n-1);\n-      y = fib_serial (n-2);\n-      return (x+y);\n-    }\n-  return 0;\n-}\n-\n-int main2_parallel (int argc, char *argv[])\n-{\n-  int n, result_parallel = 0;\n-\n-  if (argc == 2)\n-    {\n-      result_parallel = _Cilk_spawn fib (argv[1]);\n-      _Cilk_sync; \n-    }\n-  else\n-    {\n-      result_parallel = _Cilk_spawn fib((char *)\"30\");\n-      _Cilk_sync; \n-    }\n-  return result_parallel;\n-}\n-\n-int main2_serial (int argc, char *argv[])\n-{\n-  int n, result_serial = 0;\n-  if (argc == 2) \n-    result_serial = fib_serial (atoi (argv[1]));\n-  else\n-    result_serial = fib_serial (atoi (DEFAULT_VALUE));\n-\n-  return result_serial;\n-}\n-\n-int main (void)\n-{\n-  if (main2_serial (1, 0) != main2_parallel (1,0))\n-    return 1;\n-  return 0;\n-}\n-"}, {"sha": "49592c9e979f4f5164711a6b44a70c8c6e1f83d5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawner_inline.c", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawner_inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawner_inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawner_inline.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,67 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdlib.h>\n-#define DEFAULT_VALUE 30\n-int fib (int n)\n-{\n-  if (n<2)\n-    return n;\n-  else\n-    {\n-      int x, y;\n-      x = _Cilk_spawn fib (n-1);\n-      y = _Cilk_spawn fib (n-2);\n-      _Cilk_sync;\n-      return (x+y);\n-      return 5;\n-    }\n-}\n-\n-int main_parallel (int argc, char *argv[])\n-{\n-  int n, result;\n-  if (argc == 2)\n-    n = atoi(argv[1]);\n-  else\n-    n = DEFAULT_VALUE;\n-  result = _Cilk_spawn fib(n);\n-  _Cilk_sync; \n-  return result;\n-}\n-\n-int fib_serial (int n)\n-{\n-  int x, y;\n-  if (n < 2)\n-    return n;\n-  else\n-    {\n-      x = fib (n-1);\n-      y = fib (n-2);\n-      return (x+y);\n-    }\n-}\n-  \n-int main_serial (int argc, char *argv[])\n-{\n-  int n, result;\n-\n-  if (argc == 2)\n-    n = atoi (argv[1]);\n-  else\n-    n = DEFAULT_VALUE;\n-  result = fib_serial (n);\n-\n-  return result;\n-}\n-\n-int main (void)\n-{\n-  if (main_serial (1, 0) != main_parallel (1,0))\n-    return 1;\n-  else \n-    return 0;\n-}\n-"}, {"sha": "f5f062c32b3076de963050f1e3eb71b80c3bf4b8", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawning_arg.c", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawning_arg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawning_arg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawning_arg.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,52 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern int __cilkrts_set_param (const char *, const char *);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-\n-void f0(volatile int *steal_flag)\n-{ \n-  int i = 0;\n-  /* Wait for steal_flag to be set */\n-  while (!*steal_flag) \n-    ;\n-}\n-\n-int f1()\n-{\n-\n-  volatile int steal_flag = 0;\n-  _Cilk_spawn f0(&steal_flag);\n-  steal_flag = 1;  // Indicate stolen\n-  _Cilk_sync; \n-  return 0;\n-}\n-\n-void f2(int q)\n-{\n-  q = 5;\n-}\n-\n-void f3()\n-{\n-   _Cilk_spawn f2(f1());\n-}\n-\n-int main()\n-{\n-  /* Ensure more than one worker.  */\n-  if (__cilkrts_set_param(\"nworkers\", \"2\") != 0)\n-    __builtin_abort();\n-\n-  f3();\n-  return 0;\n-}"}, {"sha": "00b3c7918333b7d63d704bdd3c31147e3e21b3d5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/steal_check.c", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsteal_check.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsteal_check.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsteal_check.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,54 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern int __cilkrts_set_param (const char *, const char *);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-\n-void foo(volatile int *);\n-\n-void main2(void);\n-\n-int main(void)\n-{\n-  /* Ensure more than one worker.  */\n-  if (__cilkrts_set_param(\"nworkers\", \"2\") != 0)\n-    __builtin_abort();\n-\n-  main2();\n-  return 0;\n-}\n-\n-\n-void main2(void)\n-{\n-  int some_var = 0;\n-\n-  _Cilk_spawn foo(&some_var);\n-\n-  some_var=1;\n-  some_var=5;\n-  some_var=3;\n-  some_var=4;\n-\n-  _Cilk_sync; \n-  return;\n-}\n-\n-void foo(volatile int *some_other_var)\n-{\n-  while (*some_other_var == 0)\n-  {\n-   ;\n-  }\n-}\n-\n-"}, {"sha": "51be796e562416116e2d43fda4c547af1e77df8a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/sync_wo_spawn.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsync_wo_spawn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsync_wo_spawn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsync_wo_spawn.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,9 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  _Cilk_sync; /* { dg-error \"expected '_Cilk_spawn' before '_Cilk_sync'\" } */\n-  return 0;\n-}\n-"}, {"sha": "3157473fff4ed235edef17dbcfc3fe1dddd24b6f", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/test__cilk.c", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ftest__cilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ftest__cilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ftest__cilk.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,10 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-do run { target cilkplus_runtime } } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  if (__cilk == 200)\n-   return 0; \n-  return 1;\n-}"}, {"sha": "d97280043de6be75072a15f99edd0b000aa77666", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/varargs_test.c", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fvarargs_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fvarargs_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fvarargs_test.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,47 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <stdarg.h>\n-#include <stdlib.h>\n-\n-\n-double compute_total (int no_elements, ...);\n-\n-int main(void)\n-{\n-  double array[5] = {5.0, 4.0, 9.0, 3.0, 4.0};\n-  double array2[5] = {5.0, 6.0, 8.0, 6.0};\n-  double yy=0, xx=0, xx_serial, yy_serial;\n-\n-  yy = _Cilk_spawn compute_total(5,array[0],array[1],array[2],\n-                                 array[3], array[4]);\n-  xx= compute_total(4,array2[0],array2[1],array2[2], array2[3]);\n-  \n-  _Cilk_sync;\n-\n-  yy_serial = compute_total(5,array[0],array[1],array[2], array[3], array[4]);\n-  xx_serial = compute_total(4,array2[0],array2[1],array2[2], array2[3]);\n-\n-  if ((xx + yy) != (xx_serial + yy_serial)) \n-    return 1;\n-  return 0;\n-  \n-}\n-\n-\n-double compute_total (int no_elements, ...)\n-{\n-  double total = 0;\n-  va_list args;\n-  va_start(args, no_elements);\n-  int ii = 0;\n-  for (ii = 0; ii < no_elements; ii++)\n-  {\n-    total += va_arg(args,double);\n-  }\n-  va_end(args);\n-\n-  return total;\n-}\n-"}, {"sha": "d391d7b1eed13a4d63e4eadaf4ee68c3ad9a61f0", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/Wparentheses-1.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2FWparentheses-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2FWparentheses-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2FWparentheses-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,41 +0,0 @@\n-/* PR c/70436 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wparentheses\" } */\n-\n-int a, b, c;\n-void bar (void);\n-void baz (void);\n-\n-void\n-f1 (void)\n-{\n-  int i;\n-\n-  if (a) /* { dg-warning \"ambiguous\" } */\n-    #pragma simd\n-    for (i = 0; i < 10; i++)\n-      if (b)\n-\tbar ();\n-      else\n-\tbaz ();\n-\n-  if (a)\n-    #pragma simd\n-    for (i = 0; i < 10; i++)\n-      {\n-\tif (b)\n-\t  bar ();\n-\telse\n-\t  baz ();\n-      }\n-\n-  if (a)\n-    #pragma simd\n-    for (i = 0; i < 10; i++)\n-      {\n-\tif (b)\n-\t  bar ();\n-      }\n-  else\n-    baz ();\n-}"}, {"sha": "ed85a7a65ebb61133eb91f1b42cbcf914f26b7ad", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/body.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fbody.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,34 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -fopenmp\" } */\n-/* { dg-require-effective-target fopenmp } */\n-\n-int *a, *b, c;\n-void *jmpbuf[10];\n-\n-void foo()\n-{\n-  int j;\n-\n-#pragma simd\n-  for (int i=0; i < 1000; ++i)\n-    {\n-      if (c == 6)\n-\t__builtin_setjmp (jmpbuf); /* { dg-error \"setjmp\" } */\n-      a[i] = b[i];\n-    }\n-\n-#pragma simd\n-  for (int i=0; i < 1000; ++i)\n-    {\n-      if (c==5)\n-\tbreak; /* { dg-error \"break statement \" } */\n-    }\n-\n-#pragma simd\n-  for (int i=0; i < 1000; ++i)\n-    {\n-#pragma omp for /* { dg-error \"OpenMP constructs other than\" } */\n-      for (j=0; j < 1000; ++j)\n-\ta[i] = b[i];\n-    }\n-}"}, {"sha": "332e01cbdded5df6e92b9a2f4833f3b3123bac51", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses1.c", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,80 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -Werror -Wunknown-pragmas -fcilkplus\" } */\n-\n-volatile int *a, *b;\n-\n-void foo()\n-{\n-  int i, j, k;\n-\n-#pragma simd assert /* { dg-error \"expected '#pragma simd' clause\" } */\n-  for (i=0; i < 100; ++i)\n-    a[i] = b[i];\n-\n-#pragma simd vectorlength /* { dg-error \"expected '\\\\('\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd vectorlength /* { dg-error \"expected '\\\\('\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd vectorlength(sizeof (a) == sizeof (float) ? 4 : 8)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd vectorlength(4,8) /* { dg-error \"expected '\\\\)'\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd vectorlength(i) /* { dg-error \"\\(vectorlength must be an integer\\|in a constant\\)\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(35) /* { dg-error \"expected identifier\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(blah) /* { dg-error \"'blah' \\(undeclared\\|has not been\\)\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(j, 36, k) /* { dg-error \"expected\" } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(i, j)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(i)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(i : 4)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(i : 2, j : 4, k)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(j : sizeof (a) == sizeof (float) ? 4 : 8)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-  // And now everyone in unison!\n-#pragma simd linear(j : 4) vectorlength(4)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(blah2, 36)\n-  /* { dg-error \"'blah2' \\(undeclared\\|has not been\\)\" \"undeclared\" { target *-*-* } .-1 } */\n-  /* { dg-error \"expected\" \"expected\" { target *-*-* } .-2 } */\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-\n-#pragma simd linear(j : k)\n-  for (int i=0; i < 1234; ++i)\n-    a[i] = b[j];\n-}"}, {"sha": "0f7b50062542b175def6053b471a3cb31ede3938", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses2.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,17 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-original -fcilkplus\" } */\n-\n-volatile int *a, *b;\n-\n-void foo()\n-{\n-  int j, k;\n-\n-#pragma simd linear(j : 4, k) vectorlength(4)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[j];\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"linear\\\\(j:4\\\\)\" 1 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"linear\\\\(k:1\\\\)\" 1 \"original\" } } */\n-/* { dg-final { scan-tree-dump-times \"safelen\\\\(4\\\\)\" 1 \"original\" } } */"}, {"sha": "0b5ace6a1a091fee6e5d2dbfade33471e2e03b87", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses3.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,39 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-#define N 1000\n-\n-int A[N], B[N], C[N];\n-int main (void)\n-{\n-#pragma simd private (B) linear(B:1) /* { dg-error \"applied to non-integral\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    {\n-      A[ii] = B[ii] + C[ii];\n-    }\n-\n-#pragma simd private (B, C) linear(B:1) /* { dg-error \"applied to non-integral\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    {\n-      A[ii] = B[ii] + C[ii];\n-    }\n-\n-#pragma simd private (B) linear(C:2, B:1) /* { dg-error \"applied to non-integral\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    {\n-      A[ii] = B[ii] + C[ii];\n-    }\n-\n-#pragma simd reduction (+:B) linear(B:1) /* { dg-error \"applied to non-integral\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    {\n-      A[ii] = B[ii] + C[ii];\n-    }\n-\n-#pragma simd reduction (+:B) linear(B) /* { dg-error \"applied to non-integral\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    {\n-      A[ii] = B[ii] + C[ii];\n-    }\n-  return 0;\n-}"}, {"sha": "45dcb9f606a072dceb8a4abd5ab8fd994a02fd90", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/clauses4.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fclauses4.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,36 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define N 1000\n-\n-int B, C;\n-double D;\n-\n-int main (void)\n-{\n-  #pragma simd linear (D:10)\n-  for (int ii = 0; ii < N; ii++)\n-    ;\n-\n-  #pragma simd private (B) linear(B:1) /* { dg-error \"more than once\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    ;\n-\n-  #pragma simd private (B, C) linear(B:1) /* { dg-error \"more than once\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    ;\n-\n-  #pragma simd private (B) linear(C:2, B:1) /* { dg-error \"more than once\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    ;\n-\n-  #pragma simd reduction (+:B) linear(B:1) /* { dg-error \"more than once\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    ;\n-\n-  #pragma simd reduction (+:B) linear(B) /* { dg-error \"more than once\" } */\n-  for (int ii = 0; ii < N; ii++)\n-    ;\n-\n-  return 0;\n-}"}, {"sha": "3b678952c7284ae8e2d73308197aa0c28b9a227a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/for1.c", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,132 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-int *a, *b, *c;\n-int something;\n-\n-void foo()\n-{\n-  int i, j;\n-\n-  // Declaration and initialization is allowed.\n-#pragma simd\n-  for (int i=0; i < 1000; i++)\n-    a[i] = b[j];\n-\n-  // Empty initialization is not allowed.\n-#pragma simd\n-  for (; i < 5; ++i)\t\t// { dg-error \"expected iteration\" }\n-    a[i] = i;\n-\n-  // Empty condition is not allowed.\n-#pragma simd\n-  for (int i=0; ; ++i)\t\t/* { dg-error \"missing controlling\" } */\n-    a[i] = i;\n-\n-  // Empty increment is not allowed.\n-#pragma simd\n-  for (int i=0; i < 1234; )\t\t/* { dg-error \"missing increment\" } */\n-    a[i] = i*2;\n-\n-#pragma simd\n-  i = 5; /* { dg-error \"for statement expected\" } */\n-\n-  // Initialization variables must be either integral or pointer types.\n-  struct S {\n-    int i;\n-  };\n-#pragma simd\n-  for (struct S ss = { 0 }; ss.i <= 1000; ++ss.i) /* { dg-error \"invalid controlling\\|invalid type for iteration\\|invalid increment\" } */\n-    a[ss.i] = b[ss.i];\n-\n-  #pragma simd\n-  for (float f=0.0; f < 15.0; ++f) /* { dg-error \"invalid type\" } */\n-    a[(int)f] = (int) f;\n-\n-  // Pointers are OK.\n-  #pragma simd\n-  for (int *i=c; i < &c[100]; ++i)\n-    *a = '5';\n-\n-  // Condition of '==' is not allowed.\n-#pragma simd\n-  for (int i=j; i == 5; ++i) /* { dg-error \"invalid controlling predicate\" } */\n-    a[i] = b[i];\n-\n-  // The LHS or RHS of the condition must be the initialization variable.\n-#pragma simd\n-  for (int i=0; i+j < 1234; ++i) /* { dg-error \"invalid controlling predicate\" } */\n-    a[i] = b[i];  \n-\n-  // Likewise.\n-#pragma simd\n-  for (int i=0; 1234 < i + j; ++i) /* { dg-error \"invalid controlling predicate\" } */\n-    a[i] = b[i];  \n-\n-  // Likewise, this is ok.\n-#pragma simd\n-  for (int i=0; 1234 + j < i; ++i)\n-    a[i] = b[i];\n-\n-  // According to the CilkPlus forum, casts are not allowed, even if\n-  // they are no-ops.\n-#pragma simd\n-  for (int i=0; (char)i < 1234; ++i) /* { dg-error \"invalid controlling predicate\" } */\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=255; i != something; --i)\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=100; i != 5; i += something)\n-    a[i] = b[i];\n-\n-  // Increment must be on the induction variable.\n-#pragma simd\n-  for (int i=0; i < 100; j++) /* { dg-error \"invalid increment expression\" } */\n-    a[i] = b[i];\n-\n-  // Likewise.\n-#pragma simd\n-  for (int i=0; i < 100; j = i + 1) /* { dg-error \"invalid increment expression\" } */\n-    a[i] = b[i];\n-\n-  // Likewise.\n-#pragma simd\n-  for (int i=0; i < 100; i = j + 1) /* { dg-error \"invalid increment expression\" } */\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=0; i < 100; i = i + 5)\n-    a[i] = b[i];\n-\n-  // Only PLUS and MINUS increments are allowed.\n-#pragma simd\n-  for (int i=0; i < 100; i *= 5) /* { dg-error \"invalid increment expression\" } */\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=0; i < 100; i -= j)\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=0; i < 100; i = i + j)\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=0; i < 100; i = j + i)\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int i=0; i < 100; ++i, ++j) /* { dg-error \"invalid increment expression\" } */\n-    a[i] = b[i];\n-\n-#pragma simd\n-  for (int *point=0; point < b; ++point)\n-    *point = 555;\n-\n-#pragma simd\n-  for (int *point=0; point > b; --point)\n-    *point = 555;\n-}"}, {"sha": "86606275ac47101763f09c936dd7837094c8d893", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/for2.c", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,8 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-#pragma simd\t\t/* { dg-error \"must be inside a function\" } */\n-\n-void foo()\n-{\n-}"}, {"sha": "2da8235f3194cdeb5f6fde11201f6b3238ca2d8d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/for3.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Ffor3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,14 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-int *a, *c;\n-\n-void foo()\n-{\n-  int i, j;\n-\n-  // Pointers are OK.\n-  #pragma simd\n-  for (int *i=c; i < c; ++i)\n-    *a = '5';\n-}"}, {"sha": "1d1bb048e4962e54dd8edd800d6ad922f99d8b01", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/pr69363.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fpr69363.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fpr69363.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fpr69363.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-double t1 (double *x, int N)\n-{\n-  double result = 0.0;\n-\n-  #pragma simd reduction (max: result)\n-  for (int i = 0; i < N; ++i)\n-    result = x[i] > result ? x[i] : result;\n-\n-  return result;\n-}"}, {"sha": "d8cec84f149e8d2340b23420f389a557e5249f1e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/reduction-1.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,38 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-/* FIXME: This test has been xfailed until reductions are fixed.  */\n-\n-int argc = 1;\n-\n-/* This is a simple vectorization test.  It tests if reduction works\n-   and if it can vectorize the loop in func correctly. */\n-#define N 1000\n-\n-int func (int *p, int *q) {\n-    int x = 0;\n-#pragma simd reduction (+:x)\n-    for (int ii = 0; ii < N; ii++) { \n-\tx += (q[ii] + p[ii]);\n-    }\n-    return x; \n-\n-}\n-\n-int main ()\n-{\n-  int ii = 0, x;\n-  int Array[N], Array2[N];\n-\n-  for (ii = 0; ii < N; ii++)\n-    {\n-      Array[ii] = 5 + argc;\n-      Array2[ii] = argc;\n-    }\n-  x = func (Array, Array2);\n-\n-  if (x != N * 7)\n-    return 1;\n-  return 0;\n-}\n-"}, {"sha": "f5554f6b1aea0fb16e21b8e6f6c2cd4159bbd894", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/reduction-2.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,36 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-/* FIXME: This test has been xfailed until reductions are fixed.  */\n-\n-#include <stdio.h>\n-\n-#define ARRAY_SIZE  (256)\n-int a[ARRAY_SIZE];\n-\n-__attribute__((noinline))\n-int addit (int *arr, int N)\n-{\n-  int s=0;\n-#pragma simd reduction (+:s)\n-  for (int i = 0; i < N; i++)\n-    s += arr[i];\n-  return s;\n-}\n-\n-int main () {\n-  int i, s = 0, r = 0;\n-  for (i = 0; i < ARRAY_SIZE; i++)\n-    {\n-      a[i] = i;\n-    }\n-\n-  s = addit (a, ARRAY_SIZE);\n-\n-  for (i = 0; i < ARRAY_SIZE; i++) \n-    r += i;\n-\n-  if (s == r)\n-    return 0;\n-  return 1;\n-}"}, {"sha": "35cb904a540f142c1cfa08a110a67b597dcf8fa1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/reduction-3.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Freduction-3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,41 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-#define N 256\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-#include <stdlib.h>\n-\n-int\n-reduction_simd (int *a)\n-{\n-  int s = 0;\n-\n-#pragma simd reduction (+:s)\n-  for (int i = 0; i < N; i++)\n-    {\n-      s += a[i];\n-    }\n-\n-  return s;\n-}\n-\n-int\n-main ()\n-{\n-  int *a = (int *) malloc (N * sizeof (int));\n-  int i, s = (N - 1) * N / 2;\n-\n-  for (i = 0; i < N; i++)\n-    {\n-      a[i] = i;\n-    }\n-#if HAVE_IO\n-  printf (\"%d, %d\\n\", s, reduction_simd (a));\n-#endif\n-  if (s == reduction_simd (a))\n-    return 0;\n-  else\n-    return 1;\n-}"}, {"sha": "c8fe1c762bc3223ea04697c2ec2215e0944fbca9", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/run-1.c", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Frun-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Frun-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Frun-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,28 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus -O3\" } */\n-\n-#include <stdlib.h>\n-\n-#define N 4\n-\n-float f1[] =  { 2.0, 3.0,  4.0,  5.0 };\n-float f2[] =  { 1.0, 6.0, -1.0, -2.0 };\n-float res[] = { 3.0, 9.0,  3.0,  3.0 };\n-\n-__attribute__((noinline))\n-void verify (float *sum)\n-{\n-  for (int i=0; i < N; ++i)\n-    if (sum[i] != res[i])\n-      abort ();\n-}\n-\n-int main()\n-{\n-  float sum[N];\n-#pragma simd\n-  for (int i=0; i < N; ++i)\n-    sum[i] = f1[i] + f2[i];\n-  verify (sum);\n-  return 0;\n-}"}, {"sha": "5af2909d2ececcdc78978ca0da7f6282e9167e18", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/safelen.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fsafelen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fsafelen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fsafelen.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-gimple -fcilkplus\" } */\n-\n-int *a, *b;\n-\n-void foo()\n-{\n-#pragma simd vectorlength(8)\n-  for (int i=0; i < 1000; ++i)\n-    a[i] = b[i];\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"safelen\\\\(8\\\\)\" 1 \"gimple\" } } */"}, {"sha": "d90397717ac1dc02ded7e48626ee086374a3b079", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/vectorlength-2.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,12 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fcilkplus\" } */\n-\n-#define vl(n) vectorlength(2*n)\n-void\n-foo (int *a, int *b, int *c)\n-{\n-  int i;\n-#pragma simd vl(4)\n-  for (i = 0; i < 64; i++)\n-    a[i] = b[i] * c[i];\n-}"}, {"sha": "d219a85acd570850151e079e535b0328524c641b", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/vectorlength-3.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength-3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O2 -fcilkplus -save-temps\" } */\n-\n-#define vl(n) vectorlength(2*n)\n-void\n-foo (int *a, int *b, int *c)\n-{\n-  int i;\n-#pragma simd vl(4)\n-  for (i = 0; i < 64; i++)\n-    a[i] = b[i] * c[i];\n-}\n-"}, {"sha": "9aa4a68290d56ee716705fadd80e81241145f935", "filename": "gcc/testsuite/c-c++-common/cilk-plus/PS/vectorlength.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FPS%2Fvectorlength.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,21 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fcilkplus\" } */\n-\n-volatile int *a, *b, N;\n-typedef int tint;\n-struct someclass {\n-  int a;\n-  char b;\n-  int *p;\n-};\n-\n-void foo()\n-{\n-#pragma simd vectorlength(4) vectorlength(8) /* { dg-error \"too many 'vectorlength' clauses\" } */\n-  for (int i=0; i < N; ++i)\n-    a[i] = b[i];\n-\n-#pragma simd vectorlength(3) /* { dg-error \"must be a power of 2\" } */\n-  for (int i=0; i < N; ++i)\n-    a[i] = b[i];\n-}"}, {"sha": "5312992ff6665e1d4a10c9ebc2767ae5a4b8b9e2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/ef_error.c", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,32 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -fopenmp-simd\" } */\n-\n-#pragma omp declare simd linear(y:1) simdlen(4) \n-__attribute__((vector (linear (y:1), vectorlength(4))))\n-int func (int x, int y) { /* { dg-error \"cannot be used in the same function marked as a Cilk Plus SIMD-enabled\" } */ \n-  return (x+y);\n-}\n-__attribute__((vector (linear (y:1), private (x)))) /* { dg-error \"is not valid for\" } */\n-int func2 (int x, int y) {\n-  return (x+y);\n-}\n-\n-__attribute__((vector (linear (y:1), simdlen (4)))) /* { dg-error \"is not valid for\" } */\n-int func2_1 (int x, int y) {\n-  return (x+y);\n-}\n-\n-__attribute__((vector (linear (y:1), inbranch))) /* { dg-error \"is not valid for\" } */\n-int func2_3 (int x, int y) {\n-  return (x+y);\n-}\n-\n-__attribute__((vector (notinbranch, vectorlength (4)))) /* { dg-error \"is not valid for\" } */\n-int func2_2 (int x, int y) {\n-  return (x+y);\n-}\n-\n-int main (void)\n-{\n-  return (func (5,6));\n-}"}, {"sha": "28c3c98741847e57f0d62aaa9c478b053446f76c", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/ef_error2.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,15 +0,0 @@\n-/* The warning is x86-only.  */\n-/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n-/* { dg-options \"-fcilkplus -Wall\" } */\n-\n-__attribute__((vector (vectorlength(128)))) \n-//#pragma omp simd simdlen (128)\n-int func2 (int x, int y)  /* { dg-warning \"unsupported simdlen\" } */\n-{\n-  return (x+y);\n-}\n-\n-int main (void)\n-{\n-  return (func2 (5,6));\n-}"}, {"sha": "789e2bc013d86fb6e2cbd3197ac536837ae03303", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/ef_error3.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error3.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wall\" } */\n-\n-__attribute__((vector (linear (x:y)))) /* { dg-message \"parameter\" \"\" { target c++ } } */\n-int func2 (int x, int y) \n-{ /* { dg-message \"using parameters for\" \"\" { target c } } */\n-  return (x+y);\n-}\n-\n-int main (void)\n-{\n-  return (func2 (5,6));\n-}"}, {"sha": "e606acac16f977fc40eca723337e68c8943deae2", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/ef_test.c", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_test.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,78 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wunknown-pragmas\" } */\n-\n-/* Tests the clauses in several combinations put in different locations.  */\n-/* This is mostly a parser test.  */\n-#define Q 4\n-\n-int z = Q;\n-\n- __attribute__ ((vector (uniform(x), linear (y:1), vectorlength (4) )))\n-int func (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n- __attribute__ ((__vector__ (uniform(x), vectorlength (2), linear (y:1) )))\n-int func2 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(y), linear (x), vectorlength (4) )))\n-int func3 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), linear (y:1), mask)))\n-int func4 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), linear (y:1), nomask)))\n-int func5 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), mask, linear (y:1)))) \n-int func6 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform (x), mask, linear (y:1)), vector))\n-int func7 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform (x), mask, linear (y:1)), vector (uniform (y), mask)))\n-int func8 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector, vector (uniform (y), mask)))\n-int func9 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-int main (int argc, char *argv[])\n-{\n-  int ii = 0, q = 5;\n-  for (ii = 0; ii < 10; ii++)\n-    q += func (argc, ii);\n-  return q;\n-}"}, {"sha": "7ec0578b4124d1e77be33457ba5e160fbaa10fc1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/ef_test2.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_test2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_test2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_test2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,16 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-void func (int x, int y) __attribute__((vector(linear(x:1), uniform (y)),\n-\t\t\t\t\tvector));\n-\n-int q;\n-int main (void)\n-{\n-  int ii = 0;\n-  q = 5; \n-  for (ii = 0; ii < 100; ii++) \n-    func (ii, q);\n-\n-  return 0;\n-}\n-"}, {"sha": "88e4678552b6eee2ec0a4f6c662ef8a3d380bdb4", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/vlength_errors.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fvlength_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fvlength_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fvlength_errors.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,59 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus -Wunknown-pragmas\" } */\n-\n-#define Q 4\n-\n-int z = Q;\n-\n-__attribute__ ((vector (uniform(x), vectorlength (), linear (y:1) ))) /* { dg-error \"expected expression\" \"\" { target c } } */ \n-     /* { dg-error \"expected primary-expression\" \"\" { target c++ }  .-1 } */ \n-int func2 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), linear (y:1), vectorlength (4.5) ))) /* { dg-error \"vectorlength must be an integer\" } */\n-int func3 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), linear (y:1), vectorlength (z) ))) /* { dg-error \"vectorlength must be an integer\" \"\" { target c } } */ \n-     /* { dg-error \"constant\" \"\" { target c++ } .-1 } */\n-int func4 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), linear (y:1), vectorlength (Q) ))) /* This is OK!  */\n-int func5 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), vectorlength (z), linear (y:1)))) /* { dg-error \"vectorlength must be an integer\" \"\"  { target c } } */ \n-     /* { dg-error \"constant\" \"\" { target c++ }  .-1 } */\n-int func6 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-__attribute__ ((vector (uniform(x), linear (y:1), vectorlength (sizeof (int)) ))) /* This is OK too!  */\n-int func7 (int x, int y)\n-{\n-  int zq = 5;\n-  return x + (y*zq);\n-}\n-\n-int main (void)\n-{\n-  int ii = 0, q = 5;\n-  for (ii = 0; ii < 10; ii++)\n-    q += func2 (z, ii);\n-  return q;\n-}"}, {"sha": "b111e217cfc6108b2fee502b9834b7aaf8f8deb4", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_function.cc", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_function.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,8 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-void f() { }\n-int main()\n-{\n-  f[0:1:1];  // { dg-error \"function type\" }\n-}"}, {"sha": "e9ee7ec638583b862505f02215ddd8d6fcb1ae91", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_test1_tplt.cc", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test1_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test1_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test1_tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,118 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <cstdlib>\n-#include <string.h>\n-#if HAVE_IO\n-#include <cstdio>\n-#endif\n-template <class T> int main2 (char **argv);\n-\n-int main (void)\n-{\n-  int x = 1, y = 1, z = 1;\n-  char *array[2];\n-  array[0] = strdup (\"a.out\");\n-  array[1] = strdup (\"5\");\n-  x  = main2<unsigned char> (array);\n-  x += main2<char> (array);\n-  y  = main2<short> (array);\n-  y += main2<unsigned short> (array);\n-  y += main2<int> (array);\n-  y += main2<unsigned int> (array);\n-  z  = main2<long> (array);\n-  z += main2<long long> (array);\n-  y += main2<float> (array);\n-  z += main2<double> (array);\n-      \n-  return x+y+z;\n-}\n-template <class T>\n-int main2 (char **argv)\n-{\n-  T array[10];\n-  int ii = 0, x = 2, z= 0 , y = 0;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    array[ii] = 10;\n-\n-  array[0:10:1] = (T)15;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array[ii] != (T)15)\n-      return 1;\n-  \n-\n-  array[0:5:2] = (T)20;\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    if (array[ii] != (T)20)\n-      return 2;\n-\n-\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-\n-  array[x:5:z] = (T)50;\n-  \n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != (T)50)\n-      return 3;\n-\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]); /* (10 - 5) / 5 = 1 */\n-  y = 10-atoi(argv[1]);\n-  \n-  array[x:y:z] = (T)52;\n-#if HAVE_IO\n-  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n-    std::printf(\"%d\\t\", (int)array[ii]);\n-  std::printf(\"\\n\");\n-#endif\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != (T)52)\n-      return 4;\n-    \n-\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-  \n-  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = (T)25;\n-\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != (T)25)\n-      return 5;\n-  \n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n- \n-  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n-    (T)14;\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != (T)14)\n-      return 6;\n-  \n-\n-  array[atoi(\"5\"):5:1] = (T)65;\n-  \n-  for (ii = atoi (\"5\"); ii < 10; ii++)\n-    if (array[ii] != (T)65)\n-      return 7;\n-  \n-\n-  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = 99;\n-\n-#if HAVE_IO\n-  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n-    std::printf(\"%d\\t\", (int)array[ii]);\n-  std::printf(\"\\n\");\n-#endif\n-\n-  for (ii = atoi (\"5\"); ii < (atoi (\"5\") + atoi (\"5\")); ii += atoi (\"1\"))\n-    if (array[ii] != (T)99)\n-      return 8;\n-\n-  return 0;\n-}"}, {"sha": "041c052897665228f133fa714edc8ef636baa153", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_test2_tplt.cc", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test2_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test2_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test2_tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,141 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus -Wno-overflow\" } */\n-\n-#include <cstdlib>\n-#include <string.h>\n-template <class T> int main2(char **argv);\n-int main(void)\n-{\n-  int x = 1, y = 1, z = 1, w = 1; \n-  char *array[2]; \n-  array[0] = strdup (\"a.out\"); \n-  array[1] = strdup (\"5\");\n-  w  = main2<short>(array);\n-  w += main2<unsigned short> (array);\n-  x  = main2<char> (array);\n-  x += main2<unsigned char> (array);\n-  y  = main2<int> (array);\n-  y += main2<unsigned int> (array);\n-  z = main2<long> (array);\n-  z += main2<unsigned long> (array);\n-  z += main2<long long> (array);\n-      \n-  return (w+x+y+z);\n-}\n-\n-template<class T>\n-int main2(char **argv)\n-{\n-  T array[10], array2[10]; \n-  int  ii = 0, x = 2, z= 0 , y = 0 ;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 10;\n-      array2[ii] = 5000000;\n-    }\n-\n-  array2[0:10:1] = array[0:10:1];\n-\n-  for (ii = 0; ii < 10; ii++)\n-    if (array2[ii] != array[ii])\n-      return 1; \n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 10;\n-      array2[ii] = 5000000;\n-    }\n-  \n-  array2[0:5:2] = array[0:5:2];\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    if (array[ii] != array2[ii])\n-      return 2;\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 10;\n-      array2[ii] = 5000000;\n-    }\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n- \n-  array2[x:5:z] = array[x:5:z];\n-\n-  for (ii = x; ii < 5; ii += z)\n-    if (array2[ii] != array[ii])\n-      return 3;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii] = 500;\n-      array2[ii] = 1000000;\n-    }\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-\n-  array2[x:y:z] = array[x:y:z];\n-  for (ii = x; ii < 10; ii = ii + z)\n-    if (array2[ii] != array[ii])\n-      return 4;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 500;\n-      array2[ii] = 1000000;\n-    }\n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-\n-  array[x:y:((10-atoi(argv[1]))/atoi(argv[1]))] = \n-    array2[x:y:((10-atoi(argv[1]))/atoi(argv[1]))];\n-\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != array2[ii])\n-      return 6;\n-  \n-  \n-  x = atoi(argv[1]);\n-  z = (10-atoi(argv[1]))/atoi(argv[1]);\n-  y = 10-atoi(argv[1]);\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 500;\n-      array2[ii] = 1000000;\n-    }\n-  \n-  array[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))] =\n-    array2[atoi(argv[1]):(10-atoi(argv[1])):((10-atoi(argv[1]))/atoi(argv[1]))];\n-  for (ii = x; ii < 10; ii += z)\n-    if (array[ii] != array2[ii])\n-      return 6;\n-\n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 4;\n-      array2[ii] = 2;\n-    }\n-\n-  array[atoi(\"5\"):5:1] = array2[atoi(\"5\"):5:1];\n-\n-  for (ii = atoi (\"5\"); ii < 10; ii++)\n-    if (array[ii] != array2[ii])\n-      return 7;\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      array[ii]  = 5;\n-      array2[ii] = 1;\n-    }\n-  array[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")] = array2[atoi(\"5\"):atoi(\"5\"):atoi(\"1\")];\n-\n-  for (ii = 5; ii < 10; ii++)\n-    if (array2[ii] != array[ii])\n-      return 8;\n- \n-  return 0;\n-}"}, {"sha": "479ba1348991005b8a615610a2869e4ea1533bff", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/array_test_ND_tplt.cc", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test_ND_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test_ND_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Farray_test_ND_tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,115 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <cstdlib>\n-#include<string.h>\n-template <class T> int main2(char **argv);\n-\n-int main(void)\n-{\n-  int x = 1, y=1, z=1, w = 1;\n-  char *array[3];\n-  array[0] = strdup (\"a.out\");\n-  array[1] = strdup (\"10\");\n-  array[2] = strdup (\"15\");\n-  w  = main2<char> (array);\n-  w += main2<unsigned char> (array);\n-  x  = main2<int> (array);\n-  x += main2<unsigned int> (array);\n-  y  = main2<long> (array);\n-  y += main2<unsigned long> (array);\n-  z  = main2<short> (array);\n-  z += main2<unsigned short> (array);\n-  return x+y+z;\n-}\n-\n-template <class T>\n-int main2(char **argv)\n-{  \n-  T array[10][15];\n-  T array_2[10][15];\n-  int ii = 0, jj = 0,x = 0, z= 1 , y = 10 ,argc = 3;\n- \n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  array_2[0:5:2][0:5:3] = array[0:5:2][0:5:3] + 1 + 5 + array[0][5] + x;\n-\n-  for (ii = 0; ii < 10; ii += 2)\n-    {\n-      for (jj = 0; jj < 15; jj += 3)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + 1 + 5 + array[0][5] + x)\n-\t    return 1;\n-\t}\n-    }\n-\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  x = atoi(argv[1]);\n-  y = atoi(argv[2]);\n-  array_2[0:x:1][0:y:1] = array[0:x:1][0:y:1] + x + y + array[0:x:1][0:y:1];\n-\n-  for (ii = 0; ii < x; ii++)\n-    {\n-      for (jj = 0; jj < y; jj++)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + x + y + array[ii][jj])\n-\t    return 2;\n-\t}\n-    }\n-\n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  x = atoi(argv[1]);\n-  y = atoi(argv[2]);\n-  z = (20- atoi (argv[1]))/atoi(argv[1]);\n-  /* (20-10)/10 evaluates to 1 all the time :-). */\n-  array_2[0:x:z][0:y:z] = array[0:x:z][0:y:z] + array[0:x:z][0:y:z] + y + z;\n-  \n-  for (ii = 0; ii < x; ii += z)\n-    {\n-      for (jj = 0; jj < y; jj += z)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] + y + z)\n-\t    return 3;\n-\t}\n-    }\n-\n-\n- \n-  for (ii = 0; ii < 10; ii++) {\n-    for (jj = 0; jj< 15; jj++) {\n-      array[ii][jj] = ii+jj;\n-      array_2[ii][jj] = 0;\n-    }\n-  }\n-  x = argc-3;\n-  y = 20-atoi(argv[1]);\n-  z = (20- atoi (argv[1]))/atoi(argv[1]);\n-  /* (20-10)/10 evaluates to 1 all the time :-). */\n-  array_2[(argc-3):(20-atoi(argv[1])):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): ((30-atoi(argv[2]))/atoi(argv[2]))] = array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] + array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])] * array[(argc-3):20-atoi(argv[1]):(20-atoi(argv[1]))/atoi(argv[1])][(argc-3):(30-atoi(argv[2])): (30-atoi(argv[2]))/atoi(argv[2])];\n-  \n-  for (ii = 0; ii < 10; ii++)\n-    {\n-      for (jj = 0; jj < 15; jj++)\n-\t{\n-\t  if (array_2[ii][jj] != array[ii][jj] + array[ii][jj] * array[ii][jj])\n-\t    return 4;\n-\t}\n-    }\n-  return 0;\n-}"}, {"sha": "3521f87258a13bcea25280d5f7de332338d456eb", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/braced_list.cc", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbraced_list.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbraced_list.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbraced_list.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,13 +0,0 @@\n-/* { dg-do compile { target c++11 } } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-int main (void)\n-{\n-  int Array[100], Array2[100];\n-\n-  Array[{1,2}:2] = 5; /* { dg-error \"braced list index is not allowed\" } */\n-  Array[1:{1,2}:2] = 5; /* { dg-error \"expected primary-expression before\" } */\n-  Array[1:10:{1,2}] = 5; /* { dg-error \"expected primary-expression before\" } */\n-\n-  return 0;\n-}"}, {"sha": "3d9e87bceb5f6b7a5d34e06ce75342b9b96d5379", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/builtin_fn_custom_tplt.cc", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_custom_tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,126 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus \" } */\n-\n-#if HAVE_IO \n-#include <cstdio>\n-#endif\n-\n-#include <cstdlib>\n-\n-template <class T>\n-T my_func (T x, T y)\n-{\n-  if (x > y)\n-    return x;\n-  else\n-    return y;\n-}\n-\n-template <class T>\n-T main_func (T  *array, T *array2, T identity_val, int size)\n-{\n-  T result;\n-\n-  result = __sec_reduce (identity_val, array[0:size:1] * array2[0:size:1],\n-\t\t\t my_func); // my_func (identity_val, array[5] * array2[5]);\n-  return result;\n-}\n-int main (void)\n-{\n-  int    i_index = 0, f_index = 0, d_index = 0, l_index = 0;\n-  int    iarray[10], iarray2[10], i_result, i_max;\n-  long   larray[10], larray2[10], l_result, l_max;\n-  float  farray[10], farray2[10], f_result, f_max;\n-  double darray[10], darray2[10], d_result, d_max;\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      if (ii%2 && ii)\n-\t{\n-\t  darray[ii] = (double)(1.0000/(double)ii);\n-\t  farray[ii] = (float)(1.00/(float)ii);\n-\t}\n-      else\n-\t{\n-\t  darray[ii] = (double) ii + 0.10;\n-\t  farray[ii] = (float) (1.00/((float)(ii+1.000)));\n-\t}\n-      darray2[ii] = (double) (1.00000/ (double)(ii+1));\n-      farray2[ii] = (float) (1.00/ (float)(ii+1));\n-    }\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      iarray[ii] = ii;\n-      larray[ii] = (long)ii;\n-    }\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      iarray2[ii] = (ii-5);\n-      larray2[ii] = long (ii-5);\n-    }\n-#if HAVE_IO\n-  printf(\"Int: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%2d \", iarray[ii] * iarray2[ii]);\n-    }\n-  printf(\"\\nfloat: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%4.3f \", farray[ii] * farray2[ii]);\n-    }\n-\n-  printf(\"\\nlong: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%2d \", larray[ii] * larray2[ii]);\n-    }\n-\n-  printf(\"\\ndouble: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%4.3f \", (float) (darray[ii] * darray2[ii]));\n-    }\n-  printf(\"\\n\");\n-#endif\n-\n-  i_result = main_func<int> (iarray, iarray2, iarray[0] * iarray2[0], 10);\n-  f_result = main_func<float>(farray, farray2, 0.00, 10);\n-  d_result = main_func<double>(darray, darray2, 0.0000, 10);\n-  l_result = main_func<long>(larray, larray2, 0, 10);\n-\n-#if HAVE_IO\n-  printf(\"int result    = %2d\\n\", i_result);\n-  printf (\"long result   = %2d\\n\", l_result);\n-  printf(\"float result  = %4.3f\\n\", f_result);\n-  printf(\"double result = %4.3lf\\n\", d_result);\n-#endif\n-    \n-  i_max = iarray[0] * iarray2[0];\n-  f_max = farray[0] * farray2[0];\n-  d_max = darray[0] * darray2[0];\n-  l_max = larray[0] * larray2[0];\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      if (i_max < iarray[ii] * iarray2[ii])\n-\ti_max = iarray[ii] * iarray2[ii];\n-      if (f_max < farray[ii] * farray2[ii])\n-\tf_max = farray[ii] * farray2[ii];\n-      if (d_max < darray[ii] * darray2[ii])\n-\td_max = darray[ii] * darray2[ii];\n-      if (l_max < larray[ii] * larray2[ii])\n-\tl_max = larray[ii] * larray2[ii];\n-    }\n-\n-  if (i_max != i_result)\n-    return 1;\n-  if (f_max != f_result)\n-    return 2;\n-  if (d_max != d_result)\n-    return 3;\n-  if (l_max != l_result)\n-    return 4;\n-  return 0;\n-}\n-"}, {"sha": "111a2a29686188d55b8b446ef2bfb43032f7ee4c", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/builtin_fn_mutating_tplt.cc", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fbuiltin_fn_mutating_tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,136 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" }  */\n-\n-#if HAVE_IO \n-#include <cstdio>\n-#include<iostream>\n-#endif\n-\n-#include <cstdlib>\n-\n-template <class T>\n-T my_func (T *x, T y)\n-{\n-  if (*x < y)\n-    *x = y;\n-  else\n-    *x = *x;\n-\n-  return T();\n-}\n-\n-template <class T> T my_func (T *x, T y);\n-template <class T>\n-T main_func (T  *array, T *array2, T identity_val, int size)\n-{\n-  T result = identity_val;\n-  \n-  __sec_reduce_mutating (&result, array[0:size] * array2[0:size:1], my_func);\n-  \n-#if HAVE_IO\n-  std::cout << \"Result = \" << result << std::endl;\n-#endif\n-  return result;\n-}\n-\n-int main (void)\n-{\n-  int    iarray[10], iarray2[10], i_result = 0, i_max;\n-  long   larray[10], larray2[10], l_result = 0, l_max;\n-  float  farray[10], farray2[10], f_result = 0, f_max;\n-  double darray[10], darray2[10], d_result = 0, d_max;\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      if (ii%2 && ii)\n-\t{\n-\t  darray[ii] = (double)(1.0000/(double)(ii));\n-\t  farray[ii] = (float)(1.00/(float)(ii));\n-\t}\n-      else\n-\t{\n-\t  darray[ii] = (double) ii + 0.10;\n-\t  farray[ii] = (float) (1.00/((float)(ii) + 0.10));\n-\t}\n-      darray2[ii] = (double) (1.00000/ (double)(ii+1));\n-      farray2[ii] = (float) (1.00/ (float)(ii+1));\n-    }\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      iarray[ii] = ii;\n-      larray[ii] = (long)ii;\n-    }\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      iarray2[ii] = (ii-5);\n-      larray2[ii] = (long)ii-5;\n-    }\n-#if HAVE_IO\n-  printf(\"\\nInt: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%2d \", iarray[ii] * iarray2[ii]);\n-    }\n-  printf(\"\\nfloat: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%3.2f \", farray[ii] * farray2[ii]);\n-    }\n-\n-  printf(\"\\nlong: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%2d \", larray[ii] * larray2[ii]);\n-    }\n-\n-  printf(\"\\ndouble: \");\n-  for (int ii=0; ii < 10; ii++)\n-    {\n-      printf(\"%4.3lf \", (float) (darray[ii] * darray2[ii]));\n-    }\n-  printf(\"\\n\");\n-#endif\n-\n-  i_result = main_func<int> (iarray, iarray2, 0, 10);\n-  l_result = main_func<long>(larray, larray2, 0, 10);\n-  f_result = main_func<float>(farray, farray2, 0.00, 10);\n-  d_result = main_func<double>(darray, darray2, 0.0000, 10);\n-  \n-  i_max = iarray[0] * iarray2[0];\n-  d_max = darray[0] * darray2[0];\n-  f_max = farray[0] * farray2[0];\n-  l_max = larray[0] * larray2[0];\n-  for (int ii = 0; ii < 10; ii++)\n-    {\n-      if (iarray[ii] * iarray2[ii] > i_max)\n-\ti_max = iarray[ii] * iarray2[ii];\n-      if (darray[ii] * darray2[ii] > d_max)\n-\td_max = darray[ii] * darray2[ii];\n-      if (farray[ii] * farray2[ii] > f_max)\n-\tf_max = farray[ii] * farray2[ii];\n-      if (larray[ii] * larray2[ii] > l_max)\n-\tl_max = larray[ii] * larray2[ii];\n-    }\n-#if HAVE_IO\n-  printf(\"int result    = %2d\\n\", i_max);\n-  printf(\"long result   = %2d\\n\", l_max);\n-  printf(\"float result  = %4.3f\\n\", f_max);\n-  printf(\"double result = %4.3lf\\n\", (float)d_max);\n-#endif\n-  \n- if (i_max != i_result)\n-   return 1;\n-\n- if (f_max != f_result)\n-   return 2;\n-\n- if (l_max != l_result)\n-   return 3;\n-\n- if (d_max != d_result)\n-   return 4;\n- \n-  return 0;\n-}\n-"}, {"sha": "1387558a83406066f24fc52dba303bea3998cea6", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/fp_triplet_values_tplt.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Ffp_triplet_values_tplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Ffp_triplet_values_tplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Ffp_triplet_values_tplt.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,36 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-float q;\n-\n-void func (int *x)\n-{\n-  *x = 5;\n-}\n-template <class T> int main2 (T x, T y, T z);\n-\n-int main (void)\n-{\n-  main2 <float> (1.5, 2.3, 3.443);\n-  main2 <double> (1.34393, 2.38383, 4.38383);\n-  return 0;\n-}\n-template <class T> \n-int main2 (T x, T y, T z)\n-{\n-  int array[10], array2[10];\n-  array2[:] = array[x:2]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n-  array2[:] = array[1:y]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[1:2:z] = array[:]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n-  func (&array2[1:x:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[y:9]++; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n-  array2[1:x]++; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[1:9:x]++; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n-  \n-  ++array2[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[:] = array[q:1:3]; /* { dg-error \"start-index of array notation triplet is not an integer\" } */\n-  array2[:] = array[1:q:3]; /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  array2[:] = array[1:3:q]; /* { dg-error \"stride of array notation triplet is not an integer\" } */\n-  func (&array2[1:q:3]); /* { dg-error \"length of array notation triplet is not an integer\" } */\n-  return 0;\n-} "}, {"sha": "b0952c71bca59681e87b2b6fa86faeb2663a2f01", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/postincr_test.cc", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpostincr_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpostincr_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpostincr_test.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,107 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define HAVE_IO 0\n-\n-#if HAVE_IO\n-#include <cstdio>\n-#endif\n-\n-#include <cstdlib>\n-template <class T> int main2(int argc);\n-\n-int main (void)\n-{\n-    return (main2<int>(1) + main2<long> (1) + main2<long long> (1));\n-}\n-\n-#if HAVE_IO\n-template <class T> int print_array (T *array, int size);\n-template <class T> int print_array (T *array, int size)\n-{\n-    for (int ii = 0; ii < size; ii++)\n-          printf(\"%d \", array[ii]);\n-      printf(\"\\n\");\n-        return 0;\n-}\n-#endif\n-\n-template <class T>\n-int main2(int argc)\n-{\n-  T array[10], array_serial[10];\n-\n-  for (int ii = 0; ii < 10; ii++) {\n-    array[ii] = 0;\n-    array_serial[ii] = 0;\n-  }\n-\n-  array[:] = 19383;\n-  for (int ii = 0; ii < 10; ii++)\n-    array_serial[ii] = 19383;\n-\n-  array[:]++;\n-  \n-  for (int ii = 0; ii < 10; ii++)\n-    array_serial[ii]++;\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-\n-  for (int ii  = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 1;\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    array[:]++;\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    for (int jj = 0; jj < 10; jj++)\n-      array_serial[jj]++;\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-\n-  for (int ii  = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 2;\n-\n-  if (argc == 2)\n-    array[0:10:1]++; \n-  \n-  if (argc == 2)\n-    {\n-      for (int ii = 0; ii < 10; ii++)\n-\tarray_serial[ii]++;\n-    }\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-\n-  for (int ii  = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 3;\n-\n-  array[0:10/argc:argc]++; \n-  \n-  for (int ii = 0; ii < 10; ii += argc) \n-    array_serial[ii]++;\n-\n-\n-  for (int ii  = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 4;\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-\n-  return 0;\n-}"}, {"sha": "f5552c7ed0e0a8b8bf726e238150d1c1e4c3504d", "filename": "gcc/testsuite/g++.dg/cilk-plus/AN/preincr_test.cc", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpreincr_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpreincr_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FAN%2Fpreincr_test.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,106 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-\n-#define HAVE_IO 0\n-\n-#if HAVE_IO\n-#include <cstdio>\n-#endif\n-\n-#include <cstdlib>\n-template <class T> int main2(int argc);\n-\n-int main (void)\n-{ \n-  return (main2<int>(1) + main2<long> (1) + main2<long long> (1));\n-}\n-\n-#if HAVE_IO\n-template <class T> int print_array (T *array, int size);\n-template <class T> int print_array (T *array, int size)\n-{\n-      for (int ii = 0; ii < size; ii++) \n-\tprintf(\"%d \", array[ii]); \n-      printf(\"\\n\"); \n-      return 0;\n-}\n-#endif\n-\n-template <class T>\n-int main2(int argc)\n-{\n-  int array[10], array_serial[10];\n-\n-  for (int ii = 0; ii < 10; ii++) {\n-    array[ii] = 0;\n-    array_serial[ii] = 0;\n-  }\n-\n-  array[:] = 19383;\n-  for (int ii = 0; ii < 10; ii++) \n-    array_serial[ii] = 19383;\n-\n-  ++array[:];\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    ++array_serial[ii];\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-  for (int ii = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 1;\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    ++array[:];\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    for (int jj = 0; jj < 10; jj++)\n-      ++array_serial[jj];\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-  for (int ii = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 2;\n-\n-  if (argc == 2)\n-    ++array[0:10:1]; \n-\n-  if (argc == 2)\n-    {\n-      for (int ii = 0; ii < 10; ii++)\n-\t++array_serial[ii];\n-    }\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-  for (int ii = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 3;\n-\n-  ++array[0:10/argc:argc]; \n-  \n-  for (int ii = 0; ii < 10; ii += argc)\n-    {\n-      ++array_serial[ii];\n-    }\n-\n-#if HAVE_IO\n-  print_array<T>(array, 10);\n-  print_array<T>(array_serial, 10);\n-#endif\n-\n-  for (int ii = 0; ii < 10; ii++)\n-    if (array_serial[ii] != array[ii])\n-      return 4;\n-\n-  return 0;\n-}"}, {"sha": "82b74886ded5fcb982e07f0c115874705c0ae7ac", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/catch_exc.cc", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcatch_exc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcatch_exc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcatch_exc.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,81 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-\n-#include <assert.h>\n-#include <unistd.h>\n-#if HAVE_IO\n-#include <cstdio>\n-#include <cilk/cilk_api.h>\n-#endif\n-#include <cstdlib>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern int __cilkrts_set_param (const char *, const char *);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-\n-void func(int volatile* steal_me) \n-{\n-  while (! (*steal_me)) \n-    {\n-      usleep(2000);\n-    }\n-#if HAVE_IO\n-  printf(\"Foo executing on %d\\n\", __cilkrts_get_worker_number());\n-#endif\n-  throw 5;\n-}\n-\n-void my_test() \n-{\n-  volatile int steal_me = 0;\n-\n-  try \n-    {\n-      _Cilk_spawn func(&steal_me);\n-#if HAVE_IO\n-      printf(\"Continuation executing on %d\\n\",\n-\t     __cilkrts_get_worker_number());\n-#endif\n-      steal_me = 1;\n-      _Cilk_sync;\n-      goto bad;\n-    }\n-\n-  catch (int x) \n-    {\n-#if HAVE_IO\n-      printf(\"We caught x = %d\\n\", x);\n-#endif\n-      assert(x == 5);\n-    }\n-  if (0) \n-    {\n-    bad:\n-#if HAVE_IO\n-      printf(\"We should not be here!\\n\");\n-#endif\n-      __builtin_abort ();\n-    }\n-}\n-\n-\n-int main() \n-{\n-  /* Ensure more than one worker.  */\n-  if (__cilkrts_set_param(\"nworkers\", \"2\") != 0)\n-    __builtin_abort();\n-\n-  my_test();\n-#if HAVE_IO\n-  printf(\"PASSED\\n\");\n-#endif\n-  return 0;\n-}"}, {"sha": "8d88c5f346ca254c38d1cdcc68056d7558c1a18e", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/cf3.cc", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcf3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcf3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcf3.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,96 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-\n-typedef __PTRDIFF_TYPE__ ptrdiff_t;\n-\n-template <typename T>\n-class I\n-{\n-public:\n-  typedef ptrdiff_t difference_type;\n-  I ();\n-  ~I ();\n-  I (T *);\n-  I (const I &);\n-  T &operator * ();\n-  T *operator -> ();\n-  T &operator [] (const difference_type &) const;\n-  I &operator = (const I &);\n-  I &operator ++ ();\n-  I operator ++ (int);\n-  I &operator -- ();\n-  I operator -- (int);\n-  I &operator += (const difference_type &);\n-  I &operator -= (const difference_type &);\n-  I operator + (const difference_type &) const;\n-  I operator - (const difference_type &) const;\n-  template <typename S> friend bool operator == (I<S> &, I<S> &);\n-  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator < (I<S> &, I<S> &);\n-  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n-  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator > (I<S> &, I<S> &);\n-  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n-  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n-  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n-  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n-  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n-private:\n-  T *p;\n-};\n-template <typename T> I<T>::I () : p (0) {}\n-template <typename T> I<T>::~I () {}\n-template <typename T> I<T>::I (T *x) : p (x) {}\n-template <typename T> I<T>::I (const I &x) : p (x.p) {}\n-template <typename T> T &I<T>::operator * () { return *p; }\n-template <typename T> T *I<T>::operator -> () { return p; }\n-template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n-template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n-template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n-template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n-template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n-template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n-template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n-template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n-template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n-template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n-template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n-template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n-template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n-template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n-template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n-template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n-template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n-template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n-template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n-template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n-template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n-template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n-template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n-template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n-template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n-\n-template <typename T>\n-class J\n-{\n-public:\n-  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n-  const I<T> &begin ();\n-  const I<T> &end ();\n-private:\n-  I<T> b, e;\n-};\n-\n-template <typename T> const I<T> &J<T>::begin () { return b; }\n-template <typename T> const I<T> &J<T>::end () { return e; }\n-\n-template <typename T>\n-void baz (I<T> &i);\n-\n-void\n-foo (J<int> j)\n-{\n-  _Cilk_for (I<int> i = j.begin (); i < j.end (); i += 2)\n-    baz (i);\n-}"}, {"sha": "9481dbef74ef3c8c93ca1c01cf83d6513a9a1af3", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/cilk-for-tplt.cc", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcilk-for-tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcilk-for-tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fcilk-for-tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,25 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define SIZE 100\n-#define CHECK_VALUE 5\n-\n-template <class T>\n-int func (T start, T end)\n-{\n-  int Array[SIZE];\n-  _Cilk_for (T ii = 0; ii < end; ii++)\n-    Array[ii] = CHECK_VALUE;\n-\n-  for (T ii = 0; ii < end; ii++)\n-    if (Array[ii] != CHECK_VALUE)\n-      __builtin_abort ();\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{\n-  return func <int> (0, 100) + func <long> (0, 100);\n-}"}, {"sha": "c654826b3d9422e7d9e31e48725e008eae2f7924", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/const_spawn.cc", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fconst_spawn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fconst_spawn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fconst_spawn.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,78 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-class Rectangle\n-{\n-  int area_val, h, w;\n-  public:\n-    Rectangle (int, int);\n-    Rectangle (int, int, int);\n-    ~Rectangle ();\n-    int area ();\n-};\n-Rectangle::~Rectangle ()\n-{\n-  h = 0;\n-  w = 0;\n-  area_val = 0;\n-}\n-Rectangle::Rectangle (int height, int width)\n-{\n-  h = height;\n-  w = width;\n-  area_val = 0;\n-}\n-\n-Rectangle::Rectangle (int height, int width, int area_orig)\n-{\n-  h = height;\n-  w = width;\n-  area_val = area_orig;\n-}\n-\n-int Rectangle::area()\n-{\n-  return (area_val += (h*w));\n-}\n-\n-/* Spawning constructor.  */\n-int main1 (void)\n-{\n-  Rectangle r = _Cilk_spawn Rectangle (4, 3);\n-  return r.area();\n-}\n- \n-/* Spawning constructor 2.  */\n-int main2 (void)\n-{\n-  Rectangle r (_Cilk_spawn Rectangle (4, 3));\n-  return r.area();\n-}\n-\n-/* Spawning copy constructor.  */\n-int main3 (void)\n-{\n-  Rectangle r = _Cilk_spawn Rectangle (4, 3, 2);\n-  return r.area ();\n-}\n-\n-/* Spawning copy constructor 2.  */\n-int main4 (void)\n-{\n-  Rectangle r ( _Cilk_spawn Rectangle (4, 3, 2));\n-  return r.area();\n-}\n-\n-int main (void)\n-{\n-  if (main1 () != 12)\n-    __builtin_abort ();\n-  if (main2 () != 12)\n-    __builtin_abort ();\n-  if (main3 () != 14)\n-    __builtin_abort ();\n-  if (main4() != 14)\n-    __builtin_abort ();\n-  return 0;\n-}"}, {"sha": "88ecff8d0ea7826270f01add873a42ce274ff6b6", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/fib-opr-overload.cc", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffib-opr-overload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffib-opr-overload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffib-opr-overload.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,94 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <iostream>\n-#endif\n-\n-class Some_Struct\n-{\n-  int calculated_value;\n-  short some_unused_value;\n-public:\n-  Some_Struct () {\n-      this->calculated_value = 0;\n-  }\n-  Some_Struct (int value) {\n-      this->calculated_value = value;\n-  }\n-  Some_Struct operator=(Some_Struct f) {\n-      this->calculated_value = f.calculated_value;\n-      return *this;\n-  }\n-  bool operator!=(Some_Struct f) {\n-      return (this->calculated_value != f.calculated_value);\n-  }\n-  Some_Struct operator+(Some_Struct &f) {\n-    Some_Struct z;\n-    z.calculated_value = this->calculated_value + f.calculated_value;\n-      return z;\n-  }\n-  Some_Struct operator-(int x) {\n-    Some_Struct z;\n-    z.calculated_value = this->calculated_value - x;\n-    return z;\n-  }\n-  bool operator<(int x) {\n-      return (this->calculated_value < x);\n-  }\n-  int get_calculated_value () {\n-      return this->calculated_value;\n-  }\n-};\n-\n-\n-template <class T>\n-T fibonacci_serial (T f)\n-{\n-  if (f < 2)\n-    return f;\n-  T a = fibonacci_serial (f-1);\n-  T b = fibonacci_serial (f-2);\n-  return (a+b);\n-}\n-\n-template <class T>\n-T fibonacci (T f)\n-{\n-  if (f < 2)\n-    return f;\n-  T a = _Cilk_spawn fibonacci (f-1);\n-  T b = fibonacci (f-2);\n-  _Cilk_sync; \n-  return (a+b);\n-}\n-\n-int main (void)\n-{\n-  Some_Struct f (32), f_serial(32);\n-  f = fibonacci (f);\n-  f_serial = fibonacci_serial (f_serial);\n-  \n-  if (f != f_serial)\n-    __builtin_abort ();\n-  \n-  int t = 32, t_serial = 32;\n-  t = fibonacci (t);\n-  t_serial = fibonacci_serial (t_serial);\n-  if (t != t_serial)\n-    __builtin_abort ();\n-\n-  short s = 20, s_serial = 20;\n-  s = fibonacci (s);\n-  s_serial = fibonacci_serial (s_serial);\n-  if (s != s_serial)\n-    __builtin_abort ();\n-\n-#if HAVE_IO\n-  std::cout << \"Fib_Parallel (32) = \" << f.get_calculated_value() << std::endl;\n-  std::cout << \"Fib_Serial   (32) = \" << f_serial.get_calculated_value() \n-    << std::endl;\n-#endif\n-  return 0;\n-}"}, {"sha": "66b1dfa9eb15e5c3f9579b520832721df8888b59", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/fib-tplt.cc", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffib-tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffib-tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffib-tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,53 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-struct fib_struct\n-{\n-  int x;\n-  int *y;\n-  int z[3];\n-  struct fib_struct *ptr_next;\n-  struct fib_struct operator+(struct fib_struct &other) {\n-    struct fib_struct z ;\n-     z.x = (*this).x + (other.x);\n-    return z; \n-  }\n-  struct fib_struct operator-(int other) {\n-    struct fib_struct z ;\n-    z.x = this->x - other;\n-    return z;\n-  }\n-  bool operator<(int number) {\n-   return (this->x < number);\n-  }\n-    \n-};\n-\n-template <typename T>\n-T fib (T z) {\n-    if (z < 2) return z;\n-    T a = _Cilk_spawn fib<T>(z - 1);\n-    T b = fib<T>(z - 2);\n-    T c = a + b;\n-    return (a+b);\n-}\n-\n-\n-int sfib(int x)\n-{\n-  if (x < 2) return x;\n-  int a = sfib(x-1);\n-  int b = sfib(x-2);\n-  return (a+b);\n-}\n-\n-int main () {\n-     int z = 30;\n-     int parallel_fib = fib<int>(z);\n-     int serial_fib = sfib(z);\n-    if (serial_fib != parallel_fib) \n-      __builtin_abort ();\n-    \n-    return 0;\n-}"}, {"sha": "b2f76c7019ff6628441972d884c04e4ed8d86b20", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/for1.cc", "status": "removed", "additions": 0, "deletions": 376, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffor1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffor1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Ffor1.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,376 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#if HAVE_IO\n-#include <cstdio>\n-#endif\n-\n-typedef __PTRDIFF_TYPE__ ptrdiff_t;\n-extern \"C\" void abort ();\n-\n-template <typename T>\n-class I\n-{\n-public:\n-  typedef ptrdiff_t difference_type;\n-  I ();\n-  ~I ();\n-  I (T *);\n-  I (const I &);\n-  T &operator * ();\n-  T *operator -> ();\n-  T &operator [] (const difference_type &) const;\n-  I &operator = (const I &);\n-  I &operator ++ ();\n-  I operator ++ (int);\n-  I &operator -- ();\n-  I operator -- (int);\n-  I &operator += (const difference_type &);\n-  I &operator -= (const difference_type &);\n-  I operator + (const difference_type &) const;\n-  I operator - (const difference_type &) const;\n-  template <typename S> friend bool operator == (I<S> &, I<S> &);\n-  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator < (I<S> &, I<S> &);\n-  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n-  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator > (I<S> &, I<S> &);\n-  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n-  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n-  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n-  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n-  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n-  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n-private:\n-  T *p;\n-};\n-template <typename T> I<T>::I () : p (0) {}\n-template <typename T> I<T>::~I () {}\n-template <typename T> I<T>::I (T *x) : p (x) {}\n-template <typename T> I<T>::I (const I &x) : p (x.p) {}\n-template <typename T> T &I<T>::operator * () { return *p; }\n-template <typename T> T *I<T>::operator -> () { return p; }\n-template <typename T> T &I<T>::operator [] (const difference_type &x) const { return p[x]; }\n-template <typename T> I<T> &I<T>::operator = (const I &x) { p = x.p; return *this; }\n-template <typename T> I<T> &I<T>::operator ++ () { ++p; return *this; }\n-template <typename T> I<T> I<T>::operator ++ (int) { return I (p++); }\n-template <typename T> I<T> &I<T>::operator -- () { --p; return *this; }\n-template <typename T> I<T> I<T>::operator -- (int) { return I (p--); }\n-template <typename T> I<T> &I<T>::operator += (const difference_type &x) { p += x; return *this; }\n-template <typename T> I<T> &I<T>::operator -= (const difference_type &x) { p -= x; return *this; }\n-template <typename T> I<T> I<T>::operator + (const difference_type &x) const { return I (p + x); }\n-template <typename T> I<T> I<T>::operator - (const difference_type &x) const { return I (p - x); }\n-template <typename T> bool operator == (I<T> &x, I<T> &y) { return x.p == y.p; }\n-template <typename T> bool operator == (const I<T> &x, const I<T> &y) { return x.p == y.p; }\n-template <typename T> bool operator != (I<T> &x, I<T> &y) { return !(x == y); }\n-template <typename T> bool operator != (const I<T> &x, const I<T> &y) { return !(x == y); }\n-template <typename T> bool operator < (I<T> &x, I<T> &y) { return x.p < y.p; }\n-template <typename T> bool operator < (const I<T> &x, const I<T> &y) { return x.p < y.p; }\n-template <typename T> bool operator <= (I<T> &x, I<T> &y) { return x.p <= y.p; }\n-template <typename T> bool operator <= (const I<T> &x, const I<T> &y) { return x.p <= y.p; }\n-template <typename T> bool operator > (I<T> &x, I<T> &y) { return x.p > y.p; }\n-template <typename T> bool operator > (const I<T> &x, const I<T> &y) { return x.p > y.p; }\n-template <typename T> bool operator >= (I<T> &x, I<T> &y) { return x.p >= y.p; }\n-template <typename T> bool operator >= (const I<T> &x, const I<T> &y) { return x.p >= y.p; }\n-template <typename T> typename I<T>::difference_type operator - (I<T> &x, I<T> &y) { return x.p - y.p; }\n-template <typename T> typename I<T>::difference_type operator - (const I<T> &x, const I<T> &y) { return x.p - y.p; }\n-template <typename T> I<T> operator + (typename I<T>::difference_type x, const I<T> &y) { return I<T> (x + y.p); }\n-\n-template <typename T>\n-class J\n-{\n-public:\n-  J(const I<T> &x, const I<T> &y) : b (x), e (y) {}\n-  const I<T> &begin ();\n-  const I<T> &end ();\n-private:\n-  I<T> b, e;\n-};\n-\n-template <typename T> const I<T> &J<T>::begin () { return b; }\n-template <typename T> const I<T> &J<T>::end () { return e; }\n-\n-int results[2000];\n-\n-template <typename T>\n-void\n-baz (I<T> &i)\n-{\n-  if (*i < 0 || *i >= 2000)\n-    {\n-#if HAVE_IO\n-      printf (\"*i(%d) is < 0 or >= 2000\\n\", *i);\n-      fflush (stdout);\n-#endif\n-     __builtin_abort ();\n-    }\n-  else\n-    results[*i]++;\n-}\n-\n-void\n-f1 (const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I<int> i = x; i <= y; i += 6)\n-    {\n-      baz (i);\n-    }\n-\n-#if HAVE_IO\n-  printf(\"===== Starting F1 =========\\n\");\n-  for (I<int> i = x; i <= y; i+= 6) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-}\n-\n-void\n-f2 (const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I<int> i = x; i < y - 1; i += 2)\n-    baz (i);\n-\n-#if HAVE_IO\n-  printf(\"===== Starting F2 =========\\n\");\n-  for (int ii = 0; ii < 1998; ii += 2) {\n-    printf(\"Result[%4d] = %2d\\n\", ii, results[ii]);\n-    fflush (stdout);\n-  }\n-#endif\n-}\n-\n-template <typename T>\n-void\n-f3 (const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I<int> i = x; i <= y; i += 1)\n-    baz (i);\n-#if HAVE_IO\n-  printf(\"===== Starting F3 =========\\n\");\n-  for (int ii = 20; ii < 1987; ii += 1) {\n-    printf(\"Result[%4d] = %2d\\n\", ii, results[ii]);\n-    fflush (stdout);\n-  }\n-\n-#endif\n-}\n-\n-template <typename T>\n-void\n-f4 (const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I<int> i = x + (2000 - 64); i > y + 10; --i)\n-    baz (i);\n-#if HAVE_IO\n-  printf(\"===== Starting F3 =========\\n\");\n-  for (I<int> i = x + (2000 - 64); i > y + 10; --i) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-}\n-void\n-f5 (const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)\n-    baz (i);\n-#if HAVE_IO\n-  for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-}\n-\n-template <int N>\n-void\n-f6 (const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I<int> i = x + 2000 - 64; i > y + 10; i -= 10)\n-    {\n-      I<int> j = i + N;\n-      baz (j);\n-    }\n-#if HAVE_IO\n-  for (I<int> i = x + 2000 - 64; i > y + 10; i = i - 12 + 2)\n-    {\n-      I<int> j = i + N;\n-      printf(\"Result[%4d] = %2d\\n\", *j, results[*j]);\n-      fflush (stdout);\n-    }\n-#endif\n-}\n-template <int N>\n-void\n-f7 (I<int> ii, const I<int> &x, const I<int> &y)\n-{\n-  _Cilk_for (I <int> i = x - 10; i <= y + 10; i += N)\n-    baz (i);\n-#if HAVE_IO\n-  for (I<int> i = x - 10; i <= y + 10; i += N)\n-    {\n-      printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-      fflush (stdout);\n-    }\n-#endif\n-}\n-\n-template <int N>\n-void\n-f8 (J<int> j)\n-{\n-  _Cilk_for (I<int> i = j.begin (); i <= j.end () + N; i += 2)\n-    baz (i);\n-#if HAVE_IO\n-  for (I<int> i = j.begin (); i <= j.end () + N; i += 2) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-\n-}\n-\n-template <typename T, int N>\n-void\n-f9 (const I<T> &x, const I<T> &y)\n-{\n-  _Cilk_for (I<T> i = x; i <= y; i += N)\n-    baz (i);\n-#if HAVE_IO\n-  for (I<T> i = x; i <= y;  i  = i + N)\n-    {\n-      printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-      fflush (stdout);\n-    }\n-#endif\n-}\n-\n-template <typename T, int N>\n-void\n-f10 (const I<T> &x, const I<T> &y)\n-{\n-  _Cilk_for (I<T> i = x; i > y; i += N)\n-    baz (i);\n-#if HAVE_IO\n-  for (I<T> i = x; i > y;  i  = i + N) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-}\n-\n-template <typename T>\n-void\n-f11 (const T &x, const T &y)\n-{\n-    _Cilk_for (T i = x; i <= y; i += 3)\n-      baz (i);\n-\n-#if HAVE_IO\n-  for (T i = x; i <= y;  i  += 3) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-      T j = y + 3;\n-      baz (j);\n-\n-}\n-\n-template <typename T>\n-void\n-f12 (const T &x, const T &y)\n-{\n-  _Cilk_for (T i = x; i > y; --i)\n-    baz (i);\n-#if HAVE_IO\n-  for (T i = x; i > y;  --i) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-}\n-template <int N>\n-struct K\n-{\n-  template <typename T>\n-  static void\n-  f13 (const T &x, const T &y)\n-  {\n-    _Cilk_for (T i = x; i <= y + N; i += N)\n-      baz (i);\n-#if HAVE_IO\n-  for (T i = x; i < y+N;  i += N) {\n-    printf(\"Result[%4d] = %2d\\n\", *i, results[*i]);\n-    fflush (stdout);\n-  }\n-#endif\n-  }\n-};\n-\n-#define check(expr) \\\n-  for (int i = 0; i < 2000; i++)\t\t\t\\\n-    if (expr)\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tif (results[i] != 1) {\t\t\t\t\\\n-\t  __builtin_abort ();\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-\tresults[i] = 0;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    else if (results[i])\t\t\t\t\\\n-      abort ()\n-\n-int\n-main ()\n-{\n-  int a[2000];\n-  long b[2000];\n-  for (int i = 0; i < 2000; i++)\n-    {\n-      a[i] = i;\n-      b[i] = i;\n-    }\n-  f1 (&a[10], &a[1990]);\n-  check (i >= 10 && i <= 1990 && (i - 10) % 6 == 0);\n-  f2 (&a[0], &a[1999]);\n-  check (i < 1998 && (i & 1) == 0);\n-  f3<int> (&a[20], &a[1837]);\n-  check (i >= 20 && i <= 1837);\n-  f4<int> (&a[0], &a[30]);\n-  check (i > 40 && i <= 2000 - 64);\n-\n-  f5 (&a[0], &a[100]);\n-  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n-  f6<-10> (&a[10], &a[110]);\n-  check (i >= 116 && i <= 2000 - 64 && (i - 116) % 10 == 0);\n-\n-  f7<6> (I<int> (), &a[12], &a[1800]);\n-  check (i >= 2 && i <= 1808 && (i - 2) % 6 == 0);\n-\n-  f8<121> (J<int> (&a[14], &a[1803]));\n-  check (i >= 14 && i <= 1924 && (i & 1) == 0);\n-  f9<int, 7> (&a[33], &a[1967]);\n-  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n-  f10<int, -7> (&a[1939], &a[17]);\n-  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n-  f11<I<int> > (&a[16], &a[1981]);\n-  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n-  f12<I<int> > (&a[1761], &a[37]);\n-  check (i > 37 && i <= 1761);\n-  K<5>::f13<I<int> > (&a[1], &a[1935]);\n-  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n-  f9<long, 7> (&b[33], &b[1967]);\n-  check (i >= 33 && i <= 1967 && (i - 33) % 7 == 0);\n-  f10<long, -7> (&b[1939], &b[17]);\n-  check (i >= 21 && i <= 1939 && (i - 21) % 7 == 0);\n-  f11<I<long> > (&b[16], &b[1981]);\n-  check (i >= 16 && i <= 1984 && (i - 16) % 3 == 0);\n-  f12<I<long> > (&b[1761], &b[37]);\n-  check (i > 37 && i <= 1761);\n-  K<5>::f13<I<long> > (&b[1], &b[1935]);\n-  check (i >= 1 && i <= 1936 && (i - 1) % 5 == 0);\n-  return 0;\n-}"}, {"sha": "96d2ea19c111bea787d51a0e3b365f25e65f2318", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/lambda_spawns.cc", "status": "removed", "additions": 0, "deletions": 238, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Flambda_spawns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Flambda_spawns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Flambda_spawns.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,238 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-require-effective-target c++11 } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define FIRST_NUMBER 5\n-#define SECOND_NUMBER 3\n-#define HAVE_IO 0\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-#include <stdlib.h>\n-\n-int global_var;\n-\n-void foo1(int *array, int size)\n-{\n-#if HAVE_IO\n-  for (int ii = 0; ii < size; ii++) \n-    printf(\"%2d\\t\", array[ii]);\n-  printf(\"\\n\");\n-  fflush (stdout);\n-#else\n-  if (size != 2)\n-    __builtin_abort ();\n-  if (array[0] != FIRST_NUMBER)\n-    __builtin_abort ();\n-  if (array[1] != SECOND_NUMBER)\n-    __builtin_abort ();\n-#endif\n-  global_var++;\n-}\n-void foo1_c(const int *array, int size)\n-{\n-#if HAVE_IO\n-  for (int ii = 0; ii < size; ii++) \n-    printf(\"%2d\\t\", array[ii]);\n-  printf(\"\\n\");\n-  fflush (stdout);\n-#else\n-  if (size != 2)\n-    __builtin_abort ();\n-  if (array[0] != FIRST_NUMBER)\n-    __builtin_abort ();\n-  if (array[1] != SECOND_NUMBER)\n-    __builtin_abort ();\n-#endif\n-  global_var++;\n-}\n-\n-\n-int main2 (int argc) {\n-  int A[2] = {FIRST_NUMBER, SECOND_NUMBER};\n-  int B[2] = {FIRST_NUMBER, SECOND_NUMBER};\n-  int main_size = argc+1; /* We know argc is 1, and so 1+1 = 2.  */\n-  int q = 0;\n-\n-  global_var = 0;\n-  auto func0 = [=](){ foo1_c(A, 2); };\n-  _Cilk_spawn func0();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func1 = [=](int *Aa){ foo1(Aa, 2); };\n-  _Cilk_spawn func1 (A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func2 = [=](int *Aa, int size){ foo1(Aa, size); };\n-  _Cilk_spawn func2 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func3 = [=](int *Aa, int size){ int new_size = (size % 2 + 2); \n-\t\t\t\t       foo1(Aa, size); };\n-  _Cilk_spawn func3 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func4 = [](int *Aa){ foo1(Aa, 2); };\n-  _Cilk_spawn func4 (A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func5 = [](int *Aa, int size){ foo1(Aa, size); };\n-  _Cilk_spawn func5 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func6 = [&](int *Aa){ foo1(Aa, 2); };\n-  _Cilk_spawn func6 (A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func7 = [&](int *Aa, int size){ foo1(Aa, size); };\n-  _Cilk_spawn func7 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func8 = [&](){ foo1(A, 2); };\n-  _Cilk_spawn func8 ();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  /* We ignore the first param here and pass in A from the outer fn.  */\n-  auto func9 = [&](int *Aa, int size){ foo1(A, size); };\n-  _Cilk_spawn func9 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func10 = [=](){ foo1_c(A, main_size); };\n-  _Cilk_spawn func10 ();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  auto func11 = [&](){ foo1(A, main_size); };\n-  _Cilk_spawn func11 ();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  /* We ignore the first & second param here and pass in A from the \n-     outer fn.  */\n-  auto func12 = [&](int *Aa, int size){ foo1(A, main_size); };\n-  _Cilk_spawn func12 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [&](int *Aa){ foo1(Aa, 2); }(A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [&](int *Aa, int size){ foo1(Aa, size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [=](int *Aa){ foo1(Aa, 2); }(A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [=](int *Aa, int size){ foo1(Aa, size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  /* We ignore the first param here.  */\n-  _Cilk_spawn [=](int *Aa, int size){ foo1_c(A, size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  /* We ignore the first and second param here.  */\n-  _Cilk_spawn [=](int *Aa, int size){ foo1_c(A, size); }(B, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [&](){ foo1(A, 2); }();\n-  [&](){ foo1(A, 2); }();\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [=](){ foo1_c (A, main_size); }();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  global_var = 0;\n-  _Cilk_spawn [&](){ foo1(A, main_size); }();\n-  [&](){ foo1(A, 2); }();\n-  _Cilk_sync;\n-  if (global_var != 2)\n-    return (++q);\n-\n-  return q;\n-}\n-\n-int main (void)\n-{\n-  return main2 (1);\n-}"}, {"sha": "1a36262dc6da2197a8ceac9f3256dcdf8ebe0eed", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/lambda_spawns_tplt.cc", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Flambda_spawns_tplt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Flambda_spawns_tplt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Flambda_spawns_tplt.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,174 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-require-effective-target c++11 } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#define FIRST_NUMBER 5\n-#define SECOND_NUMBER 3\n-#define HAVE_IO 0\n-#if HAVE_IO\n-#include <stdio.h>\n-#endif\n-\n-#include <stdlib.h>\n-\n-template <class T>\n-void foo1(T *array, int size)\n-{\n-#if HAVE_IO\n-  for (int ii = 0; ii < size; ii++) \n-    printf(\"%2d\\t\", (int)array[ii]);\n-  printf(\"\\n\");\n-  fflush (stdout);\n-#else\n-  if (size != 2)\n-    __builtin_abort ();\n-  if (array[0] != FIRST_NUMBER)\n-    __builtin_abort ();\n-  if (array[1] != SECOND_NUMBER)\n-    __builtin_abort ();\n-#endif\n-}\n-template <class T>\n-void foo1_c(const T *array, int size)\n-{\n-#if HAVE_IO\n-  for (int ii = 0; ii < size; ii++) \n-    printf(\"%2d\\t\", (int)array[ii]);\n-  printf(\"\\n\");\n-  fflush (stdout);\n-#else\n-  if (size != 2)\n-    __builtin_abort ();\n-  if (array[0] != FIRST_NUMBER)\n-    __builtin_abort ();\n-  if (array[1] != SECOND_NUMBER)\n-    __builtin_abort ();\n-#endif\n-}\n-template <class T>\n-int main2 (int argc, char **argv) {\n-  T A[2] = {FIRST_NUMBER, SECOND_NUMBER};\n-  int main_size = argc+1; /* We know argc is 1, and so 1+1 = 2.  */\n-  auto func0 = [=](){ foo1_c(A, 2); };\n-  _Cilk_spawn func0();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func1 = [=](T *Aa){ foo1(Aa, 2); };\n-  _Cilk_spawn func1 (A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func2 = [=](T *Aa, int size){ foo1(Aa, size); };\n-  _Cilk_spawn func2 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func3 = [=](T *Aa, int size){ int new_size = (size % 2 + 2); \n-\t\t\t\t       foo1(Aa, size); };\n-  _Cilk_spawn func3 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func4 = [](T *Aa){ foo1(Aa, 2); };\n-  _Cilk_spawn func4 (A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func5 = [](T *Aa, int size){ foo1(Aa, size); };\n-  _Cilk_spawn func5 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func6 = [&](T *Aa){ foo1(Aa, 2); };\n-  _Cilk_spawn func6 (A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func7 = [&](T *Aa, int size){ foo1(Aa, size); };\n-  _Cilk_spawn func7 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func8 = [&](){ foo1(A, 2); };\n-  _Cilk_spawn func8 ();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  /* We ignore the first param here and pass in A from the outer fn.  */\n-  auto func9 = [&](T *Aa, int size){ foo1(A, size); };\n-  _Cilk_spawn func9 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func10 = [=](){ foo1_c(A, main_size); };\n-  _Cilk_spawn func10 ();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  auto func11 = [&](){ foo1(A, main_size); };\n-  _Cilk_spawn func11 ();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  /* We ignore the first & second param here and pass in A from the \n-     outer fn.  */\n-  auto func12 = [&](T *Aa, int size){ foo1(A, main_size); };\n-  _Cilk_spawn func12 (A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  _Cilk_spawn [&](T *Aa){ foo1(Aa, 2); }(A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  _Cilk_spawn [&](T *Aa, int size){ foo1(Aa, size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  _Cilk_spawn [=](T *Aa){ foo1(Aa, 2); }(A);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  _Cilk_spawn [=](T *Aa, int size){ foo1(Aa, size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  /* We ignore the first param here.  */\n-  _Cilk_spawn [=](T *Aa, int size){ foo1_c(A, size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  /* We ignore the first and second param here.  */\n-  _Cilk_spawn [=](T *Aa, int size){ foo1_c(A, main_size); }(A, 2);\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\n-  _Cilk_spawn [&](){ foo1(A, 2); }();\n-  [&](){ foo1(A, 2); }();\n-  _Cilk_sync;\n-\n-  _Cilk_spawn [=](){ foo1_c(A, main_size); }();\n-  foo1 (A, 2);\n-  _Cilk_sync;\n-\t\n-  _Cilk_spawn [&](){ foo1(A, main_size); }();\n-  [&](){ foo1(A, 2); }();\n-  _Cilk_sync;\n-\n-  return 0;\n-}\n-\n-int main (void)\n-{\n-  int argc = 1;\n-  char **argv = NULL;\n-  int x = 1, y = 1, z = 1, q = 1, p = 1;\n-  x = main2<char>(argc,argv);\n-  y = main2<short>(argc,argv);\n-  z = main2<int>(argc,argv);\n-  p = main2<long>(argc,argv);\n-  q = main2<long long>(argc,argv);\n-  return (x+y+z+p+q);\n-}"}, {"sha": "47c7828130099e280ea9b65b9b1a1793b01737e3", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr60586.cc", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr60586.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr60586.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr60586.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,89 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-class Rectangle\n-{\n-  int area_val, h, w;\n-  public:\n-    Rectangle (int, int);\n-    Rectangle (int, int, int);\n-    ~Rectangle ();\n-    int area ();\n-};\n-Rectangle::~Rectangle ()\n-{\n-  h = 0;\n-  w = 0;\n-  area_val = 0;\n-}\n-Rectangle::Rectangle (int height, int width)\n-{\n-  h = height;\n-  w = width;\n-  area_val = 0;\n-}\n-\n-int some_func(int &x)\n-{\n-  x++;\n-  return x;\n-}\n-\n-Rectangle::Rectangle (int height, int width, int area_orig)\n-{\n-  h = height;\n-  w = width;\n-  area_val = area_orig;\n-}\n-\n-int Rectangle::area()\n-{\n-  return (area_val += (h*w));\n-}\n-\n-\n-int some_func (int &);\n-\n-/* Spawning constructor.  */\n-int main1 (void)\n-{\n-  int x = 3;\n-  Rectangle r = _Cilk_spawn Rectangle (some_func(x), 3);\n-  return r.area();\n-}\n- \n-/* Spawning constructor 2.  */\n-int main2 (void)\n-{\n-  Rectangle r (_Cilk_spawn Rectangle (4, 3));\n-  return r.area();\n-}\n-\n-/* Spawning copy constructor.  */\n-int main3 (void)\n-{\n-  int x = 3;\n-  Rectangle r = _Cilk_spawn Rectangle (some_func(x), 3, 2);\n-  return r.area ();\n-}\n-\n-/* Spawning copy constructor 2.  */\n-int main4 (void)\n-{\n-  Rectangle r ( _Cilk_spawn Rectangle (4, 3, 2));\n-  return r.area();\n-}\n-\n-int main (void)\n-{\n-  if (main1 () != 12)\n-    __builtin_abort ();\n-  if (main2 () != 12)\n-    __builtin_abort ();\n-  if (main3 () != 14)\n-    __builtin_abort ();\n-  if (main4() != 14)\n-    __builtin_abort ();\n-  return 0;\n-}"}, {"sha": "102b9734275a707fceaae02aa646a3d743c3b3f2", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr66326.cc", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr66326.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr66326.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr66326.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,32 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <vector>\n-#include <random>\n-\n-template <class T>\n-void do_not_optimize_away(T&& x) {\n-  asm volatile(\"\" : \"+r\"(x));\n-}\n-\n-const int N = 1'000'000;\n-\n-auto compute() {\n-  std::vector<double> v(N);\n-  auto rng = std::mt19937{std::random_device{}()};\n-  std::uniform_real_distribution<double> dist(0, 1);\n-  for (int i = 0; i < N; ++i) v[i] = std::log(std::sqrt(dist(rng)));\n-  return v;\n-}\n-\n-int main() {\n-  std::vector<double> v1, v2, v3;\n-  _Cilk_spawn [&] { v1 = compute(); }();\n-  _Cilk_spawn [&] { v2 = compute(); }();\n-  v3 = compute();\n-  do_not_optimize_away(v1.data());\n-  do_not_optimize_away(v2.data());\n-  do_not_optimize_away(v3.data());\n-  return 0;\n-}"}, {"sha": "bf2fefa03b4885383eadcfb4a7d7db412253fc7c", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr68001.cc", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr68001.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr68001.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr68001.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,18 +0,0 @@\n-/* PR middle-end/68001 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <vector>\n-\n-std::vector<double> f() {\n-  std::vector<double> v;\n-  return v;\n-}\n-\n-int main()\n-{\n-  std::vector<double> x = _Cilk_spawn f ();\n-  std::vector<double> y = f();\n-  _Cilk_sync;\n-  return 0;\n-}"}, {"sha": "a9a8a51ce7e8000679bdadca68240b317118cff4", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr68997.cc", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr68997.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr68997.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr68997.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-std=c++11 -fcilkplus\" } */\n-\n-struct A1 {\n-  A1 () {}\n-  A1 (const A1&) {}\n-};\n-\n-A1 fa1 () {\n-  return A1 ();\n-}\n-\n-struct A2 {\n-  A2 () {}\n-  A2 (A2&&) {}\n-};\n-\n-A2 fa2 () {\n-  return A2 ();\n-}\n-\n-struct B1 {\n-};\n-\n-B1 fb1 () {\n-  return B1 ();\n-}\n-\n-struct A3 {\n-  A3 (const B1&) {}\n-};\n-\n-struct A4 {\n-  A4 (B1) {}\n-};\n-\n-struct B2 {\n-  B2 () {}\n-  B2 (const B2&) {}\n-};\n-\n-B2 fb2 () {\n-  return B2 ();\n-}\n-\n-struct A5 {\n-  A5 (B2) {}\n-};\n-\n-void t1 () {\n-  A1 a1 = _Cilk_spawn fa1 ();\n-}\n-\n-void t2 () {\n-  A2 a2 = _Cilk_spawn fa2 ();\n-}\n-\n-void t3 () {\n-  A3 a3 = _Cilk_spawn fb1 ();\n-}\n-\n-void t4 () {\n-  A4 a4 = _Cilk_spawn fb1 ();\n-}\n-\n-void t5 () {\n-  A5 a5 = _Cilk_spawn fb2 ();\n-}"}, {"sha": "b87dc1ace8794c168cbfd590abd11320bab0cbd7", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr69024.cc", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69024.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69024.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69024.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,38 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-struct A1 {\n-};\n-\n-struct A2 {\n-  A2 () {}\n-  A2 (const A2&) {}\n-};\n-\n-struct B1 {\n-  operator A1 () {\n-    return A1 ();\n-  }\n-};\n-\n-B1 fb1 () {\n-  return B1 ();\n-}\n-\n-struct B2 {\n-  operator A2 () {\n-    return A2 ();\n-  }\n-};\n-\n-B2 fb2 () {\n-  return B2 ();\n-}\n-\n-void t1 () {\n-  A1 a1 = _Cilk_spawn fb1 ();\n-}\n-\n-void t2 () {\n-  A2 a2 = _Cilk_spawn fb2 ();\n-}"}, {"sha": "b6c57fca9a453b6555f9ac06bae35c6130d20e2f", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr69048.cc", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69048.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69048.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69048.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,14 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-struct A {\n-  ~A () {}\n-};\n-\n-A f () {\n-  return A ();\n-}\n-\n-void t1 () {\n-  _Cilk_spawn f ();\n-}"}, {"sha": "7d00e49bf38dda3cd522919ea0379030bf363e9c", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr69267.cc", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69267.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69267.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr69267.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,10 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-struct A {};\n-\n-void f (A) {}\n-\n-void g () {\n-  _Cilk_spawn f (A ());\n-}"}, {"sha": "85990e5a0076d75e152c625eba1d2bbe2abfd40b", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/pr80038.cc", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr80038.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr80038.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fpr80038.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,47 +0,0 @@\n-/* { dg-options \"-fcilkplus\" } */\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-\n-#include <unistd.h>\n-extern \"C\" {\n-  extern int __cilkrts_set_param (const char *, const char *);\n-}\n-\n-int objcnt = 0;\n-\n-struct foo\n-{\n-  int live;\n-  foo ()\n-    { objcnt++; }\n-  foo (const foo &)\n-    { objcnt++; }\n-  ~foo ()\n-    { objcnt--; }\n-};\n-\n-void\n-spawnee (foo f)\n-{\n-  usleep(2000);\n-  /* Now both my_test::f and spawnee::f should be alive.  */\n-  if (objcnt != 2)\n-    __builtin_abort ();\n-}\n-\n-void\n-my_test ()\n-{\n-  foo f;\n-  _Cilk_spawn spawnee (f);\n-  _Cilk_sync ;\n-}\n-\n-int\n-main ()\n-{\n-  if (__cilkrts_set_param (\"nworkers\", \"2\") != 0)\n-    __builtin_abort ();\n-\n-  my_test ();\n-}"}, {"sha": "ed489d8b00a485d546db0aced450c4a96729aa89", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/stl_iter.cc", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_iter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_iter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_iter.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,50 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-#include <vector>\n-#include <cstdio>\n-#include <iostream>\n-#include <algorithm>\n-\n-using namespace std;\n-\n-\n-int main(void)\n-{\n-vector <int> array;\n-vector <int> array_serial;\n-\n-for (int ii = -1; ii < 10; ii++)\n-{\n-  array.push_back(ii);\n-  array_serial.push_back (ii);\n-}\n-_Cilk_for (vector<int>::iterator iter = array.begin(); iter != array.end();\n-\t  iter++)\n-{\n-   if (*iter == 6)\n-     *iter = 13;\n-}\n-for (vector<int>::iterator iter = array_serial.begin();\n-     iter != array_serial.end(); iter++)\n-{\n-   if (*iter == 6)\n-     *iter = 13;\n-}\n-sort (array.begin(), array.end());\n-sort (array_serial.begin(), array_serial.end());\n-\n-vector <int>::iterator iter = array.begin ();\n-vector <int>::iterator iter_serial = array_serial.begin ();\n-\n-while (iter != array.end () && iter_serial != array_serial.end ())\n-{\n-  if (*iter != *iter_serial)\n-    __builtin_abort ();\n-  iter++;\n-  iter_serial++;\n-}\n-\n-return 0;\n-}"}, {"sha": "ddc96d1223dc659315ee39d7eb4e35aee84bcb04", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/stl_rev_iter.cc", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_rev_iter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_rev_iter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_rev_iter.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,68 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-\n-#include <vector>\n-#include <cstdio>\n-#include <iostream>\n-#include <algorithm>\n-\n-using namespace std;\n-\n-\n-int main(void)\n-{\n-vector <int> array,array_serial;\n-\n-for (int ii = -1; ii < 10; ii++)\n-{\n-  array.push_back(ii);\n-  array_serial.push_back(ii);\n-}\n-_Cilk_for (vector<int>::reverse_iterator iter4 = array.rbegin();\n-\t   iter4 != array.rend(); iter4++)\n-{\n-  if (*iter4 == 0x8) {\n-    *iter4 = 9;\n-  }\n-}\n-\n-_Cilk_for (vector<int>::reverse_iterator iter4 = array_serial.rbegin();\n-\t   iter4 != array_serial.rend(); iter4++)\n-{\n-  if (*iter4 == 0x8) {\n-    *iter4 = 9;\n-  }\n-}\n-_Cilk_for (vector<int>::reverse_iterator iter2 = array.rbegin();\n-\t   iter2 != array.rend();\n-\t  iter2 += 1)\n-{\n-   if ((*iter2 == 0x4) || (*iter2 == 0x7)) {\n-    *iter2 = 0x3;\n-   }\n-}\n-for (vector<int>::reverse_iterator iter2 = array_serial.rbegin();\n-     iter2 != array_serial.rend();\n-\t  iter2 += 1)\n-{\n-   if ((*iter2 == 0x4) || (*iter2 == 0x7)) {\n-    *iter2 = 0x3;\n-   }\n-}\n-sort (array.begin(), array.end());\n-sort (array_serial.begin(), array_serial.end());\n-\n-vector <int>::iterator iter = array.begin ();\n-vector <int>::iterator iter_serial = array_serial.begin ();\n-while (iter != array.end () && iter_serial != array_serial.end ())\n-{\n-  if (*iter != *iter_serial)\n-    __builtin_abort ();\n-  iter++;\n-  iter_serial++;\n-}\n-\n-return 0;\n-}"}, {"sha": "02b57c33a66ec75fc3504bec8ba08911af6de50e", "filename": "gcc/testsuite/g++.dg/cilk-plus/CK/stl_test.cc", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2FCK%2Fstl_test.cc?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda", "patch": "@@ -1,50 +0,0 @@\n-/* { dg-do run } */\n-/* { dg-require-effective-target cilkplus_runtime } */\n-/* { dg-options \"-fcilkplus\" } */\n-\n-\n-#include <iostream>\n-#include <cstdio>\n-#include <cstdlib>\n-#include <vector>\n-#include <algorithm>\n-#include <list>\n-\n-using namespace std;\n-\n-\n-int main(int argc, char **argv)\n-{\n-  vector <int> number_list, number_list_serial;\n-  int new_number = 0;\n-  int no_elements = 0;\n-\n-  if (argc != 2)\n-  {\n-    no_elements = 10;\n-  }\n-\n-\n-  number_list.clear();\n-  number_list_serial.clear();\n-  for (int ii = 0; ii < no_elements; ii++)\n-  {\n-    number_list.push_back(new_number);\n-    number_list_serial.push_back(new_number);\n-  }\n-\n-  _Cilk_for (int jj = 0; jj < no_elements; jj++)\n-  {\n-    number_list[jj] = jj + no_elements;\n-  }\n-  for (int jj = 0; jj < no_elements; jj++)\n-  {\n-    number_list_serial[jj] = jj + no_elements;\n-  }\n-\n-  for (int jj = 0; jj < no_elements; jj++)\n-    if (number_list_serial[jj] != number_list[jj])\n-      __builtin_abort ();\n-\n-  return 0;\n-}"}, {"sha": "bc6c18ee967a1b89c75b1c4ed583aa86f93db42c", "filename": "gcc/testsuite/g++.dg/cilk-plus/cilk-plus.exp", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "3e75cbd925388c6ac3ed54a100cbc68c99f069f5", "filename": "gcc/testsuite/g++.dg/cilk-plus/ef_test.C", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fef_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fef_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fef_test.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "6e16cfcd1d1775c5ff444f2e81e9d8736a1c12f6", "filename": "gcc/testsuite/g++.dg/cilk-plus/for.C", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "345e54236f8ef04d3b31c1a003fd63839b7c4ae6", "filename": "gcc/testsuite/g++.dg/cilk-plus/for2.C", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor2.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "28dbdee4339e995e5686598a26fb3c1a0598afbd", "filename": "gcc/testsuite/g++.dg/cilk-plus/for3.C", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor3.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "5b86b9f7db556c44b4052202d051a0153c7dbf85", "filename": "gcc/testsuite/g++.dg/cilk-plus/for4.C", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Ffor4.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "1724424ff0a0000b5844e82cbb19e7bf9cd5396a", "filename": "gcc/testsuite/g++.dg/cilk-plus/pr60967.C", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr60967.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr60967.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr60967.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "31542f34e9a024dcc1cecda4687b57f0fb18fdd1", "filename": "gcc/testsuite/g++.dg/cilk-plus/pr69028.C", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr69028.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr69028.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr69028.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "781ce2c16491f1b550fa43f5edeb80f1b07cdab1", "filename": "gcc/testsuite/g++.dg/cilk-plus/pr70565.C", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr70565.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr70565.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fpr70565.C?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "2180914ce4650f6fdcecce4a966c626daf3f6f79", "filename": "gcc/testsuite/g++.dg/pr57662.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57662.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57662.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr57662.C?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "447ed04f0285fc46d7d59198cf5c159cd2fb60e6", "filename": "gcc/testsuite/gcc.dg/cilk-plus/cilk-plus.exp", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "4fb534286d9a636dd91e13e6e74260b4ac9378b2", "filename": "gcc/testsuite/gcc.dg/cilk-plus/for1.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "285f35a5079a94341d808efaabf7a6037ea81651", "filename": "gcc/testsuite/gcc.dg/cilk-plus/for2.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Ffor2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "6adabf4ae067b7202f31879acb0ac265cf6fb12f", "filename": "gcc/testsuite/gcc.dg/cilk-plus/jump-openmp.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump-openmp.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "1ca886a645f2aa4d51b61fdd8fbdf4748ffe394b", "filename": "gcc/testsuite/gcc.dg/cilk-plus/jump.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fjump.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "c5a37a86a21ecd91b7a29b6e6d75e21bd8ef1fe3", "filename": "gcc/testsuite/gcc.dg/cilk-plus/pr69798-1.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr69798-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr69798-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr69798-1.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "6719225dd7a6fc22100258130cd14b19575fe81f", "filename": "gcc/testsuite/gcc.dg/cilk-plus/pr69798-2.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr69798-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr69798-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr69798-2.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "4604271441c1e5b115d1404129344ab8ad7eb51f", "filename": "gcc/testsuite/gcc.dg/cilk-plus/pr78306.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr78306.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr78306.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr78306.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "9206aaf3a1fb3331b93925e379171a8b2b32452e", "filename": "gcc/testsuite/gcc.dg/cilk-plus/pr79116.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr79116.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr79116.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fpr79116.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "dd5fb9f70e24631264055401a685d1319f957478", "filename": "gcc/testsuite/gcc.dg/graphite/id-28.c", "status": "removed", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fid-28.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "04b4f21843156432c0d7344fa1d8252c19cdc843", "filename": "gcc/testsuite/lib/cilk-plus-dg.exp", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Flib%2Fcilk-plus-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/gcc%2Ftestsuite%2Flib%2Fcilk-plus-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fcilk-plus-dg.exp?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "6242ce9546910d177906b24b47d607f982f013a1", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "5f900b8fe5907c8f146695258463ae8b3e447c49", "filename": "gcc/tree-core.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "6cbae7b97cc729bc6665a395fa3caa6d325603f6", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "ab4b2f705c8009ac0327c99dad5aa5fd4ac463c0", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 43, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "28970dfcc850542693c7d98ed84a20da0aa2cfb4", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "3029dab3e2efdfc7e88c0cb095320d1cd64ce0c1", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "d8912821ad51482ef92e5ec47bc49e551c805b69", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5e9d6aa4c2fd245837ec26de1d01ee8eb7786af3"}, {"sha": "2f81d09545a662609add0980f4ee975f72f1d1ea", "filename": "libcilkrts/ChangeLog", "status": "removed", "additions": 0, "deletions": 471, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FChangeLog?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "2a0fcad4c896c01568d6d50dffd06aaa3ca11fd6", "filename": "libcilkrts/Makefile.am", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FMakefile.am?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "a89960d51e0f4949c6728074f30e8b124a8efe77", "filename": "libcilkrts/Makefile.in", "status": "removed", "additions": 0, "deletions": 1201, "changes": 1201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FMakefile.in?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "54f8b0442947699eb6a2f82b8047841f690fa86b", "filename": "libcilkrts/README", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2FREADME?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "4bb1d43a5e57a94c69bda3bfdd97e4608bd710b5", "filename": "libcilkrts/aclocal.m4", "status": "removed", "additions": 0, "deletions": 1000, "changes": 1000, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Faclocal.m4?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "3cc8c999733c3df495a68c355539a8db60ec10e8", "filename": "libcilkrts/configure", "status": "removed", "additions": 0, "deletions": 17913, "changes": 17913, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "9cf9052f340bf99af2680a33ac45ad3e304cc5b3", "filename": "libcilkrts/configure.ac", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure.ac?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "71f69b0840a3aedabe12a1867ab7ac825ae5b0c2", "filename": "libcilkrts/configure.tgt", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fconfigure.tgt?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "86038ac1adc1126553ecc1247fbe39a6dd4d892c", "filename": "libcilkrts/include/cilk/cilk.h", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "6cc62c994b73505e3c0ea7f580e01e618ec28459", "filename": "libcilkrts/include/cilk/cilk_api.h", "status": "removed", "additions": 0, "deletions": 436, "changes": 436, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_api.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "0ebd57cba21734586c2b6c449f135ffc34d6e847", "filename": "libcilkrts/include/cilk/cilk_api_linux.h", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_api_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_api_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_api_linux.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "b4a54f37c9bdf6ca0c0931fe9f595dc00f244a76", "filename": "libcilkrts/include/cilk/cilk_stub.h", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_stub.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_stub.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_stub.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "71a51ec52d6b4a89b19382eec7fa7248db91360e", "filename": "libcilkrts/include/cilk/cilk_undocumented.h", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_undocumented.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcilk_undocumented.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcilk_undocumented.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "91b2928e7e62a61013b8f1a843004c9445c4646b", "filename": "libcilkrts/include/cilk/common.h", "status": "removed", "additions": 0, "deletions": 385, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fcommon.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "66899a25bc9fe6a1cbf367b5e0f2eccb66d697ba", "filename": "libcilkrts/include/cilk/holder.h", "status": "removed", "additions": 0, "deletions": 1011, "changes": 1011, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fholder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fholder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fholder.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "dd7ccfd90202eba00c3672936cc0ffd1b3fa707f", "filename": "libcilkrts/include/cilk/hyperobject_base.h", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fhyperobject_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fhyperobject_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fhyperobject_base.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "2df7cf6467ccff69cb15d372c73f7bebdf86462d", "filename": "libcilkrts/include/cilk/metaprogramming.h", "status": "removed", "additions": 0, "deletions": 621, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fmetaprogramming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Fmetaprogramming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Fmetaprogramming.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "09c2e196903c1abed22dc4b8cb30b6e545236cdf", "filename": "libcilkrts/include/cilk/reducer.h", "status": "removed", "additions": 0, "deletions": 2002, "changes": 2002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "a372cee7cda2b668c7aba0335ab90456ed86c20e", "filename": "libcilkrts/include/cilk/reducer_file.h", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_file.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_file.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_file.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "80204af1d9e0482024ac563d855057dde0fbd028", "filename": "libcilkrts/include/cilk/reducer_list.h", "status": "removed", "additions": 0, "deletions": 1150, "changes": 1150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_list.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "3982cb11c2ac474b87d4866c98aaa62298c7e671", "filename": "libcilkrts/include/cilk/reducer_max.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_max.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_max.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_max.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "912979d7229ee1bf7b7ff0ce1e977a4d51e0a059", "filename": "libcilkrts/include/cilk/reducer_min.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_min.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_min.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_min.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "641aa8239013a4f0a02f916db0b9f06c0c345c6d", "filename": "libcilkrts/include/cilk/reducer_min_max.h", "status": "removed", "additions": 0, "deletions": 3741, "changes": 3741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_min_max.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_min_max.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_min_max.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "46d4b6e9b57b9d6a486f3d7481fc5cc4f43e1122", "filename": "libcilkrts/include/cilk/reducer_opadd.h", "status": "removed", "additions": 0, "deletions": 701, "changes": 701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opadd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opadd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opadd.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "44d537d4f36911a4de63ea6f6cd00081df7c72ad", "filename": "libcilkrts/include/cilk/reducer_opand.h", "status": "removed", "additions": 0, "deletions": 614, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opand.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "8a3e2d2a2a56858f6054ff8716e021ca7eba3977", "filename": "libcilkrts/include/cilk/reducer_opmul.h", "status": "removed", "additions": 0, "deletions": 453, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opmul.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opmul.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opmul.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "8d6d52024888e400a95d8be85c6861251679778e", "filename": "libcilkrts/include/cilk/reducer_opor.h", "status": "removed", "additions": 0, "deletions": 609, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opor.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "cb6560f9c5739dfdd4966c4c59c853b5fadda1f5", "filename": "libcilkrts/include/cilk/reducer_opxor.h", "status": "removed", "additions": 0, "deletions": 608, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opxor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_opxor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_opxor.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "793c3c5020cdf79df0a558018de930e3c83eebae", "filename": "libcilkrts/include/cilk/reducer_ostream.h", "status": "removed", "additions": 0, "deletions": 517, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_ostream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_ostream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_ostream.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "9af65d553417c311b549d0417a54c06764e5305e", "filename": "libcilkrts/include/cilk/reducer_string.h", "status": "removed", "additions": 0, "deletions": 763, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_string.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "fa53eee1d24383ea939a5082576d98ecf4daa7e8", "filename": "libcilkrts/include/cilk/reducer_vector.h", "status": "removed", "additions": 0, "deletions": 533, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilk%2Freducer_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilk%2Freducer_vector.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "1e26c450ebed3577fa16b24679813b3e7ed3cebb", "filename": "libcilkrts/include/cilktools/cilkscreen.h", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Fcilkscreen.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Fcilkscreen.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Fcilkscreen.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "e98489368af8b79b9a2603212027c5c065aacea5", "filename": "libcilkrts/include/cilktools/cilkview.h", "status": "removed", "additions": 0, "deletions": 289, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Fcilkview.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Fcilkview.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Fcilkview.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "b7facf83f6d7b776406dbb467355eff1b5e8e236", "filename": "libcilkrts/include/cilktools/fake_mutex.h", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Ffake_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Ffake_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Ffake_mutex.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "e2e16382b753284d5754adcac0ea6caacd11027e", "filename": "libcilkrts/include/cilktools/lock_guard.h", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Flock_guard.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Fcilktools%2Flock_guard.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Fcilktools%2Flock_guard.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "3f38485d26b03c7c970b42bf62ff4916304f7283", "filename": "libcilkrts/include/internal/abi.h", "status": "removed", "additions": 0, "deletions": 664, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fabi.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "7d09de29c1e88dd29abfdbfcac34aab657e2fd87", "filename": "libcilkrts/include/internal/cilk_fake.h", "status": "removed", "additions": 0, "deletions": 488, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fcilk_fake.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fcilk_fake.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fcilk_fake.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "c997b026f9d1b653f1fd484915422a3e0a0e9811", "filename": "libcilkrts/include/internal/cilk_version.h", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fcilk_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fcilk_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fcilk_version.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "00aa0f1598a5869b99b52544a94c20d6d452f8e9", "filename": "libcilkrts/include/internal/metacall.h", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fmetacall.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Fmetacall.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Fmetacall.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "cd78865739b5f03bae252186653ef62334f99bff", "filename": "libcilkrts/include/internal/rev.mk", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Frev.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Finclude%2Finternal%2Frev.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Finclude%2Finternal%2Frev.mk?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "b98cce9382bc519499beba0af3c311d87c96b923", "filename": "libcilkrts/libcilkrts.spec.in", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Flibcilkrts.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Flibcilkrts.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Flibcilkrts.spec.in?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "49f524a68093a4749fa74dcc6bf3e79fea205089", "filename": "libcilkrts/mk/cilk-version.mk", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fmk%2Fcilk-version.mk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fmk%2Fcilk-version.mk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fmk%2Fcilk-version.mk?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "7f6271ccafa98be2c8552ddbfb52873de008dd0f", "filename": "libcilkrts/runtime/acknowledgements.dox", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Facknowledgements.dox", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Facknowledgements.dox", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Facknowledgements.dox?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "f2109852a5739257adf62e682bb52c9fa88831d6", "filename": "libcilkrts/runtime/bug.cpp", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fbug.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fbug.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fbug.cpp?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "3b5493bace6bc7e2b8527286e1d3e79c78edacd3", "filename": "libcilkrts/runtime/bug.h", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fbug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fbug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fbug.h?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "f99ecbe6dd3e6593c69d07e937fb2f5cd27dd296", "filename": "libcilkrts/runtime/c_reducers.c", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fc_reducers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fc_reducers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fc_reducers.c?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}, {"sha": "6e7c08a08af172771843c13eaab61017cd51bcb0", "filename": "libcilkrts/runtime/cilk-abi-cilk-for.cpp", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fcilk-abi-cilk-for.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1be49a38e45a80d1ee6854f262c94abeb621dfda/libcilkrts%2Fruntime%2Fcilk-abi-cilk-for.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcilkrts%2Fruntime%2Fcilk-abi-cilk-for.cpp?ref=1be49a38e45a80d1ee6854f262c94abeb621dfda"}]}