{"sha": "e408261123697a82b5965c700fa2465999f0fd62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwODI2MTEyMzY5N2E4MmI1OTY1YzcwMGZhMjQ2NTk5OWYwZmQ2Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-08-08T09:00:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-08-08T09:00:51Z"}, "message": "P0595R1 - is_constant_evaluated\n\n\tP0595R1 - is_constant_evaluated\ncp/\n\t* cp-tree.h (enum cp_built_in_function): New.\n\t(maybe_constant_init): Add pretend_const_required argument.\n\t* typeck2.c (store_init_value): Pass true as new argument to\n\tmaybe_constant_init.\n\t* constexpr.c (constexpr_fn_retval): Check also DECL_BUILT_IN_CLASS\n\tfor BUILT_IN_UNREACHABLE.\n\t(struct constexpr_ctx): Add pretend_const_required field.\n\t(cxx_eval_builtin_function_call): Use DECL_IS_BUILTIN_CONSTANT_P\n\tmacro.  Handle CP_BUILT_IN_IS_CONSTANT_EVALUATED.  Check also\n\tDECL_BUILT_IN_CLASS for BUILT_IN_UNREACHABLE.\n\t(cxx_eval_outermost_constant_expr): Add pretend_const_required\n\targument, initialize pretend_const_required field in ctx.  If the\n\tresult is TREE_CONSTANT and non_constant_p, retry with\n\tpretend_const_required false if it was true.\n\t(is_sub_constant_expr): Initialize pretend_const_required_field in\n\tctx.\n\t(cxx_constant_value): Pass true as pretend_const_required to\n\tcxx_eval_outermost_constant_expr.\n\t(maybe_constant_value): Pass false as pretend_const_required to\n\tcxx_eval_outermost_constant_expr.\n\t(fold_non_dependent_expr): Likewise.\n\t(maybe_constant_init_1): Add pretend_const_required argument, pass it\n\tdown to cxx_eval_outermost_constant_expr.  Pass !allow_non_constant\n\tinstead of false as strict to cxx_eval_outermost_constant_expr.\n\t(maybe_constant_init): Add pretend_const_required argument, pass it\n\tdown to maybe_constant_init_1.\n\t(cxx_constant_init): Pass true as pretend_const_required to\n\tmaybe_constant_init_1.\n\t* cp-gimplify.c (cp_gimplify_expr): Handle CALL_EXPRs to\n\tCP_BUILT_IN_IS_CONSTANT_EVALUATED.\n\t(cp_fold): Don't fold CP_BUILT_IN_IS_CONSTANT_EVALUATED calls.\n\t* decl.c: Include langhooks.h.\n\t(cxx_init_decl_processing): Register __builtin_is_constant_evaluated\n\tbuilt-in.\n\t* tree.c (builtin_valid_in_constant_expr_p): Return true for\n\tCP_BUILT_IN_IS_CONSTANT_EVALUATED.\n\t* pt.c (declare_integer_pack): Initialize DECL_FUNCTION_CODE.\ntestsuite/\n\t* g++.dg/cpp2a/is-constant-evaluated1.C: New test.\n\nFrom-SVN: r263392", "tree": {"sha": "22ed906d9f15d60555219787db1ca461460a6741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22ed906d9f15d60555219787db1ca461460a6741"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e408261123697a82b5965c700fa2465999f0fd62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e408261123697a82b5965c700fa2465999f0fd62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e408261123697a82b5965c700fa2465999f0fd62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e408261123697a82b5965c700fa2465999f0fd62/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5e539332c47faa6d6df728d27fae5d02805ca5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e539332c47faa6d6df728d27fae5d02805ca5ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e539332c47faa6d6df728d27fae5d02805ca5ec"}], "stats": {"total": 225, "additions": 206, "deletions": 19}, "files": [{"sha": "8a3e15077040a92698026b23f16c6d5850657c56", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -1,5 +1,44 @@\n 2018-08-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\tP0595R1 - is_constant_evaluated\n+\t* cp-tree.h (enum cp_built_in_function): New.\n+\t(maybe_constant_init): Add pretend_const_required argument.\n+\t* typeck2.c (store_init_value): Pass true as new argument to\n+\tmaybe_constant_init.\n+\t* constexpr.c (constexpr_fn_retval): Check also DECL_BUILT_IN_CLASS\n+\tfor BUILT_IN_UNREACHABLE.\n+\t(struct constexpr_ctx): Add pretend_const_required field.\n+\t(cxx_eval_builtin_function_call): Use DECL_IS_BUILTIN_CONSTANT_P\n+\tmacro.  Handle CP_BUILT_IN_IS_CONSTANT_EVALUATED.  Check also\n+\tDECL_BUILT_IN_CLASS for BUILT_IN_UNREACHABLE.\n+\t(cxx_eval_outermost_constant_expr): Add pretend_const_required\n+\targument, initialize pretend_const_required field in ctx.  If the\n+\tresult is TREE_CONSTANT and non_constant_p, retry with\n+\tpretend_const_required false if it was true.\n+\t(is_sub_constant_expr): Initialize pretend_const_required_field in\n+\tctx.\n+\t(cxx_constant_value): Pass true as pretend_const_required to\n+\tcxx_eval_outermost_constant_expr.\n+\t(maybe_constant_value): Pass false as pretend_const_required to\n+\tcxx_eval_outermost_constant_expr.\n+\t(fold_non_dependent_expr): Likewise.\n+\t(maybe_constant_init_1): Add pretend_const_required argument, pass it\n+\tdown to cxx_eval_outermost_constant_expr.  Pass !allow_non_constant\n+\tinstead of false as strict to cxx_eval_outermost_constant_expr.\n+\t(maybe_constant_init): Add pretend_const_required argument, pass it\n+\tdown to maybe_constant_init_1.\n+\t(cxx_constant_init): Pass true as pretend_const_required to\n+\tmaybe_constant_init_1.\n+\t* cp-gimplify.c (cp_gimplify_expr): Handle CALL_EXPRs to\n+\tCP_BUILT_IN_IS_CONSTANT_EVALUATED.\n+\t(cp_fold): Don't fold CP_BUILT_IN_IS_CONSTANT_EVALUATED calls.\n+\t* decl.c: Include langhooks.h.\n+\t(cxx_init_decl_processing): Register __builtin_is_constant_evaluated\n+\tbuilt-in.\n+\t* tree.c (builtin_valid_in_constant_expr_p): Return true for\n+\tCP_BUILT_IN_IS_CONSTANT_EVALUATED.\n+\t* pt.c (declare_integer_pack): Initialize DECL_FUNCTION_CODE.\n+\n \tPR c++/86836\n \t* pt.c (tsubst_expr): For structured bindings, call tsubst_decomp_names\n \tbefore tsubst_init, not after it."}, {"sha": "ece2c8a92d996502547431a26f597063fd8b45c5", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 52, "deletions": 14, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -713,6 +713,7 @@ constexpr_fn_retval (tree body)\n \t{\n \t  tree fun = get_function_named_in_call (body);\n \t  if (fun != NULL_TREE\n+\t      && DECL_BUILT_IN_CLASS (fun) == BUILT_IN_NORMAL\n \t      && DECL_FUNCTION_CODE (fun) == BUILT_IN_UNREACHABLE)\n \t    return NULL_TREE;\n \t}\n@@ -1007,6 +1008,8 @@ struct constexpr_ctx {\n   /* Whether we are strictly conforming to constant expression rules or\n      trying harder to get a constant value.  */\n   bool strict;\n+  /* Whether __builtin_is_constant_evaluated () should be true.  */\n+  bool pretend_const_required;\n };\n \n /* A table of all constexpr calls that have been evaluated by the\n@@ -1171,7 +1174,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n   int i;\n \n   /* Don't fold __builtin_constant_p within a constexpr function.  */\n-  bool bi_const_p = (DECL_FUNCTION_CODE (fun) == BUILT_IN_CONSTANT_P);\n+  bool bi_const_p = DECL_IS_BUILTIN_CONSTANT_P (fun);\n \n   /* If we aren't requiring a constant expression, defer __builtin_constant_p\n      in a constexpr function until we have values for the parameters.  */\n@@ -1184,6 +1187,19 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n       return t;\n     }\n \n+  /* For __builtin_is_constant_evaluated, defer it if not\n+     ctx->pretend_const_required, otherwise fold it to true.  */\n+  if (DECL_BUILT_IN_CLASS (fun) == BUILT_IN_FRONTEND\n+      && (int) DECL_FUNCTION_CODE (fun) == CP_BUILT_IN_IS_CONSTANT_EVALUATED)\n+    {\n+      if (!ctx->pretend_const_required)\n+\t{\n+\t  *non_constant_p = true;\n+\t  return t;\n+\t}\n+      return boolean_true_node;\n+    }\n+\n   /* Be permissive for arguments to built-ins; __builtin_constant_p should\n      return constant false for a non-constant argument.  */\n   constexpr_ctx new_ctx = *ctx;\n@@ -1217,7 +1233,8 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n \t  /* Do not allow__builtin_unreachable in constexpr function.\n \t     The __builtin_unreachable call with BUILTINS_LOCATION\n \t     comes from cp_maybe_instrument_return.  */\n-\t  if (DECL_FUNCTION_CODE (fun) == BUILT_IN_UNREACHABLE\n+\t  if (DECL_BUILT_IN_CLASS (fun) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (fun) == BUILT_IN_UNREACHABLE\n \t      && EXPR_LOCATION (t) == BUILTINS_LOCATION)\n \t    error (\"%<constexpr%> call flows off the end of the function\");\n \t  else\n@@ -4897,9 +4914,15 @@ instantiate_constexpr_fns (tree t)\n   input_location = loc;\n }\n \n+/* ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n+   PRETEND_CONST_REQUIRED is true if T is required to be const-evaluated as\n+   per P0595 even when ALLOW_NON_CONSTANT is true.  */\n+\n static tree\n cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n-\t\t\t\t  bool strict = true, tree object = NULL_TREE)\n+\t\t\t\t  bool strict = true,\n+\t\t\t\t  bool pretend_const_required = false,\n+\t\t\t\t  tree object = NULL_TREE)\n {\n   auto_timevar time (TV_CONSTEXPR);\n \n@@ -4908,7 +4931,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   hash_map<tree,tree> map;\n \n   constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, NULL,\n-\t\t\tallow_non_constant, strict };\n+\t\t\tallow_non_constant, strict,\n+\t\t\tpretend_const_required || !allow_non_constant };\n \n   tree type = initialized_type (t);\n   tree r = t;\n@@ -4997,6 +5021,12 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n     return error_mark_node;\n   else if (non_constant_p && TREE_CONSTANT (r))\n     {\n+      /* If __builtin_is_constant_evaluated () was evaluated to true\n+\t and the result is not a valid constant expression, we need to\n+\t punt.  */\n+      if (pretend_const_required)\n+\treturn cxx_eval_outermost_constant_expr (t, true, strict,\n+\t\t\t\t\t\t false, object);\n       /* This isn't actually constant, so unset TREE_CONSTANT.\n \t Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires\n \t it to be set if it is invariant address, even when it is not\n@@ -5042,7 +5072,8 @@ is_sub_constant_expr (tree t)\n   bool overflow_p = false;\n   hash_map <tree, tree> map;\n \n-  constexpr_ctx ctx = { NULL, &map, NULL, NULL, NULL, NULL, true, true };\n+  constexpr_ctx ctx\n+    = { NULL, &map, NULL, NULL, NULL, NULL, true, true, false };\n \n   instantiate_constexpr_fns (t);\n   cxx_eval_constant_expression (&ctx, t, false, &non_constant_p,\n@@ -5057,7 +5088,7 @@ is_sub_constant_expr (tree t)\n tree\n cxx_constant_value (tree t, tree decl)\n {\n-  return cxx_eval_outermost_constant_expr (t, false, true, decl);\n+  return cxx_eval_outermost_constant_expr (t, false, true, true, decl);\n }\n \n /* Helper routine for fold_simple function.  Either return simplified\n@@ -5163,7 +5194,7 @@ maybe_constant_value (tree t, tree decl)\n   if (tree *cached = cv_cache->get (t))\n     return *cached;\n \n-  r = cxx_eval_outermost_constant_expr (t, true, true, decl);\n+  r = cxx_eval_outermost_constant_expr (t, true, true, false, decl);\n   gcc_checking_assert (r == t\n \t\t       || CONVERT_EXPR_P (t)\n \t\t       || TREE_CODE (t) == VIEW_CONVERT_EXPR\n@@ -5237,7 +5268,8 @@ fold_non_dependent_expr (tree t,\n \t      return t;\n \t    }\n \n-\t  tree r = cxx_eval_outermost_constant_expr (t, true, true, NULL_TREE);\n+\t  tree r = cxx_eval_outermost_constant_expr (t, true, true, false,\n+\t\t\t\t\t\t     NULL_TREE);\n \t  /* cp_tree_equal looks through NOPs, so allow them.  */\n \t  gcc_checking_assert (r == t\n \t\t\t       || CONVERT_EXPR_P (t)\n@@ -5258,10 +5290,14 @@ fold_non_dependent_expr (tree t,\n }\n \n /* Like maybe_constant_value, but returns a CONSTRUCTOR directly, rather\n-   than wrapped in a TARGET_EXPR.  */\n+   than wrapped in a TARGET_EXPR.\n+   ALLOW_NON_CONSTANT is false if T is required to be a constant expression.\n+   PRETEND_CONST_REQUIRED is true if T is required to be const-evaluated as\n+   per P0595 even when ALLOW_NON_CONSTANT is true.  */\n \n static tree\n-maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant)\n+maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant,\n+\t\t       bool pretend_const_required)\n {\n   if (!t)\n     return t;\n@@ -5279,7 +5315,9 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant)\n   else if (CONSTANT_CLASS_P (t) && allow_non_constant)\n     /* No evaluation needed.  */;\n   else\n-    t = cxx_eval_outermost_constant_expr (t, allow_non_constant, false, decl);\n+    t = cxx_eval_outermost_constant_expr (t, allow_non_constant,\n+\t\t\t\t\t  !allow_non_constant,\n+\t\t\t\t\t  pretend_const_required, decl);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n       tree init = TARGET_EXPR_INITIAL (t);\n@@ -5292,17 +5330,17 @@ maybe_constant_init_1 (tree t, tree decl, bool allow_non_constant)\n /* Wrapper for maybe_constant_init_1 which permits non constants.  */\n \n tree\n-maybe_constant_init (tree t, tree decl)\n+maybe_constant_init (tree t, tree decl, bool pretend_const_required)\n {\n-  return maybe_constant_init_1 (t, decl, true);\n+  return maybe_constant_init_1 (t, decl, true, pretend_const_required);\n }\n \n /* Wrapper for maybe_constant_init_1 which does not permit non constants.  */\n \n tree\n cxx_constant_init (tree t, tree decl)\n {\n-  return maybe_constant_init_1 (t, decl, false);\n+  return maybe_constant_init_1 (t, decl, false, true);\n }\n \n #if 0"}, {"sha": "7db4accb5043332af01f1c45b67b8ec44ce50759", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -793,6 +793,15 @@ cp_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n \t\tret = GS_ERROR;\n \t    }\n \t}\n+      if (ret != GS_ERROR)\n+\t{\n+\t  tree decl = cp_get_callee_fndecl_nofold (*expr_p);\n+\t  if (decl\n+\t      && DECL_BUILT_IN_CLASS (decl) == BUILT_IN_FRONTEND\n+\t      && ((int) DECL_FUNCTION_CODE (decl)\n+\t\t  == CP_BUILT_IN_IS_CONSTANT_EVALUATED))\n+\t    *expr_p = boolean_false_node;\n+\t}\n       break;\n \n     case RETURN_EXPR:\n@@ -2483,6 +2492,13 @@ cp_fold (tree x)\n \t    && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n \t  nw = 1;\n \n+\t/* Defer folding __builtin_is_constant_evaluated.  */\n+\tif (callee\n+\t    && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_FRONTEND\n+\t    && ((int) DECL_FUNCTION_CODE (callee)\n+\t\t== CP_BUILT_IN_IS_CONSTANT_EVALUATED))\n+\t  break;\n+\n \tx = copy_node (x);\n \n \tm = call_expr_nargs (x);"}, {"sha": "94a85b72d2b3f219dc1c7149124fb118fdae5214", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -5966,6 +5966,13 @@ struct GTY((chain_next (\"%h.next\"))) tinst_level {\n   static const unsigned short refcount_infinity = (unsigned short) ~0;\n };\n \n+/* BUILT_IN_FRONTEND function codes.  */\n+enum cp_built_in_function {\n+  CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n+  CP_BUILT_IN_INTEGER_PACK,\n+  CP_BUILT_IN_LAST\n+};\n+\n bool decl_spec_seq_has_spec_p (const cp_decl_specifier_seq *, cp_decl_spec);\n \n /* Return the type of the `this' parameter of FNTYPE.  */\n@@ -7572,7 +7579,7 @@ extern bool require_potential_rvalue_constant_expression (tree);\n extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);\n-extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE);\n+extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE, bool = false);\n extern tree fold_non_dependent_expr\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern tree fold_simple\t\t\t\t(tree);\n extern bool is_sub_constant_expr                (tree);"}, {"sha": "78ebbde61a33ac2a71bc246cd5e48cf4ae75de87", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -52,6 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimplify.h\"\n #include \"asan.h\"\n #include \"gcc-rich-location.h\"\n+#include \"langhooks.h\"\n \n /* Possible cases of bad specifiers type used by bad_specifiers. */\n enum bad_spec_place {\n@@ -4172,6 +4173,13 @@ cxx_init_decl_processing (void)\n \n   c_common_nodes_and_builtins ();\n \n+  tree bool_ftype = build_function_type_list (boolean_type_node, NULL_TREE);\n+  tree decl\n+    = add_builtin_function (\"__builtin_is_constant_evaluated\",\n+\t\t\t    bool_ftype, CP_BUILT_IN_IS_CONSTANT_EVALUATED,\n+\t\t\t    BUILT_IN_FRONTEND, NULL, NULL_TREE);\n+  set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);\n+\n   integer_two_node = build_int_cst (NULL_TREE, 2);\n \n   /* Guess at the initial static decls size.  */"}, {"sha": "7fcf5d6b2d3f734de3560071cf06d25bd50b9b9f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -27538,6 +27538,8 @@ declare_integer_pack (void)\n \t\t\t       NULL_TREE, ECF_CONST);\n   DECL_DECLARED_CONSTEXPR_P (ipfn) = true;\n   DECL_BUILT_IN_CLASS (ipfn) = BUILT_IN_FRONTEND;\n+  DECL_FUNCTION_CODE (ipfn)\n+    = (enum built_in_function) (int) CP_BUILT_IN_INTEGER_PACK;\n }\n \n /* Set up the hash tables for template instantiations.  */"}, {"sha": "1cf3269d88064d95aae6c820fe3dfa4dda4fcd3d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -415,10 +415,18 @@ cp_stabilize_reference (tree ref)\n bool\n builtin_valid_in_constant_expr_p (const_tree decl)\n {\n-  if (!(TREE_CODE (decl) == FUNCTION_DECL\n-\t&& DECL_BUILT_IN_CLASS (decl) == BUILT_IN_NORMAL))\n-    /* Not a built-in.  */\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    /* Not a function.  */\n     return false;\n+  if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL)\n+    {\n+      if (DECL_BUILT_IN_CLASS (decl) == BUILT_IN_FRONTEND\n+\t  && ((int) DECL_FUNCTION_CODE (decl)\n+\t      == CP_BUILT_IN_IS_CONSTANT_EVALUATED))\n+\treturn true;\n+      /* Not a built-in.  */\n+      return false;\n+    }\n   switch (DECL_FUNCTION_CODE (decl))\n     {\n       /* These always have constant results like the corresponding"}, {"sha": "7763d53ee65d6bbe2c5dc211269a3721d760f77f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -837,7 +837,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n \t    value = cxx_constant_init (value, decl);\n \t}\n       else\n-\tvalue = maybe_constant_init (value, decl);\n+\tvalue = maybe_constant_init (value, decl, true);\n       if (TREE_CODE (value) == CONSTRUCTOR && cp_has_mutable_p (type))\n \t/* Poison this CONSTRUCTOR so it can't be copied to another\n \t   constexpr variable.  */"}, {"sha": "c729af8687e14cbdfc462a873ea48c305ec53a36", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -1,5 +1,8 @@\n 2018-08-08  Jakub Jelinek  <jakub@redhat.com>\n \n+\tP0595R1 - is_constant_evaluated\n+\t* g++.dg/cpp2a/is-constant-evaluated1.C: New test.\n+\n \tPR c++/86836\n \t* g++.dg/cpp1z/decomp46.C: New test.\n "}, {"sha": "3b988845e416bb7a8ce19e0733b36a197038d778", "filename": "gcc/testsuite/g++.dg/cpp2a/is-constant-evaluated1.C", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e408261123697a82b5965c700fa2465999f0fd62/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fis-constant-evaluated1.C?ref=e408261123697a82b5965c700fa2465999f0fd62", "patch": "@@ -0,0 +1,66 @@\n+// P0595R1\n+// { dg-do compile { target c++14 } }\n+\n+template<int N> struct X { int v = N; };\n+X<__builtin_is_constant_evaluated ()> x; // type X<true>\n+int y = 4;\n+int a = __builtin_is_constant_evaluated () ? y : 1; // initializes a to 1\n+int b = __builtin_is_constant_evaluated () ? 2 : y; // initializes b to 2\n+int c = y + (__builtin_is_constant_evaluated () ? 2 : y); // initializes c to 2*y\n+int d = __builtin_is_constant_evaluated (); // initializes d to 1\n+int e = d + __builtin_is_constant_evaluated (); // initializes e to 0\n+\n+struct false_type { static constexpr bool value = false; };\n+struct true_type { static constexpr bool value = true; };\n+template<class T, class U>\n+struct is_same : false_type {};\n+template<class T>\n+struct is_same<T, T> : true_type {};\n+\n+constexpr int\n+foo (int x)\n+{\n+  const int n = __builtin_is_constant_evaluated () ? 13 : 17; // n == 13\n+  int m = __builtin_is_constant_evaluated () ? 13 : 17; // m might be 13 or 17 (see below)\n+  char arr[n] = {}; // char[13]\n+  return m + sizeof (arr) + x;\n+}\n+\n+constexpr int\n+bar ()\n+{\n+  const int n = __builtin_is_constant_evaluated() ? 13 : 17;\n+  X<n> x1;\n+  X<__builtin_is_constant_evaluated() ? 13 : 17> x2;\n+  static_assert (is_same<decltype (x1), decltype (x2)>::value, \"x1/x2's type\");\n+  return x1.v + x2.v;\n+}\n+\n+int p = foo (0); // m == 13; initialized to 26\n+int q = p + foo (0); // m == 17 for this call; initialized to 56\n+static_assert (bar () == 26, \"bar\");\n+\n+struct S { int a, b; };\n+\n+S s = { __builtin_is_constant_evaluated () ? 2 : 3, y };\n+S t = { __builtin_is_constant_evaluated () ? 2 : 3, 4 };\n+\n+static_assert (is_same<decltype (x), X<true> >::value, \"x's type\");\n+\n+int\n+main ()\n+{\n+  if (a != 1 || b != 2 || c != 8 || d != 1 || e != 0 || p != 26 || q != 56)\n+    __builtin_abort ();\n+  if (s.a != 3 || s.b != 4 || t.a != 2 || t.b != 4)\n+    __builtin_abort ();\n+  if (foo (y) != 34)\n+    __builtin_abort ();\n+#if __cplusplus >= 201703L\n+  if constexpr (foo (0) != 26)\n+    __builtin_abort ();\n+#endif\n+  constexpr int w = foo (0);\n+  if (w != 26)\n+    __builtin_abort ();\n+}"}]}