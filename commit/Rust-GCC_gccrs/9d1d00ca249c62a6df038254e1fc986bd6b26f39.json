{"sha": "9d1d00ca249c62a6df038254e1fc986bd6b26f39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQxZDAwY2EyNDljNjJhNmRmMDM4MjU0ZTFmYzk4NmJkNmIyNmYzOQ==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2016-07-04T10:05:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-07-04T10:05:53Z"}, "message": "einfo.adb (Has_Pragma_Unused): Create this function as a setter for a new flag294 (Set_Has_Pragma_Unused):...\n\n2016-07-04  Justin Squirek  <squirek@adacore.com>\n\n\t* einfo.adb (Has_Pragma_Unused): Create this function as a setter\n\tfor a new flag294 (Set_Has_Pragma_Unused): Create this procedure\n\tas a getter for flag294 (Write_Entity_Flags): Register the new\n\tflag with an alias\n\t* einfo.ads Add comment documenting Has_Pragma_Unused (flag294)\n\tand subsequent getter and setter declarations.\n\t* lib-xref.adb (Generate_Reference): Recognize Has_Pragma_Unused\n\tflag to print appropriate warning messages.\n\t* par-prag.adb (Prag): Classify Pragma_Unused into \"All Other\n\tPragmas.\"\n\t* snames.ads-tmpl Add a new name to the name constants and a\n\tnew pramga to Pragma_Id for pramga Unused.\n\t* sem_prag.adb (Analyze_Pragma): Create case for Pragma_Unused\n\tand move the block for Pragma_Unmodified and Pragma_Unreferenced\n\tout and into local subprograms.\n\t(Analyze_Unmodified, Analyze_Unreferenced): From the old pragma blocks\n\tthat have been separated in to local subprograms add a parameter to\n\tindicate the if they are being called in the context of Pragma_Unused\n\tand handle it accordingly.\n\t(Is_Non_Significant_Pragma_Reference): Add an entry for Pragma_Unused\n\tand correct the position of Pragma_Unevaluated_Use_Of_Old.\n\t* sem_util.adb (Note_Possible_Modification): Recognize\n\tHas_Pragma_Unused flag to print appropriate warning messages.\n\nFrom-SVN: r237961", "tree": {"sha": "25af1b866b524676e9f0ea23b0dd95a5dde8b87a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25af1b866b524676e9f0ea23b0dd95a5dde8b87a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d1d00ca249c62a6df038254e1fc986bd6b26f39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1d00ca249c62a6df038254e1fc986bd6b26f39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1d00ca249c62a6df038254e1fc986bd6b26f39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1d00ca249c62a6df038254e1fc986bd6b26f39/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "002e3d16cbf86f160bc6467983ca515471c4156d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/002e3d16cbf86f160bc6467983ca515471c4156d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/002e3d16cbf86f160bc6467983ca515471c4156d"}], "stats": {"total": 649, "additions": 399, "deletions": 250}, "files": [{"sha": "bbd98c4229a4ba5c1fc3a86c6f6032a3385e1ea0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -1,3 +1,29 @@\n+2016-07-04  Justin Squirek  <squirek@adacore.com>\n+\n+\t* einfo.adb (Has_Pragma_Unused): Create this function as a setter\n+\tfor a new flag294 (Set_Has_Pragma_Unused): Create this procedure\n+\tas a getter for flag294 (Write_Entity_Flags): Register the new\n+\tflag with an alias\n+\t* einfo.ads Add comment documenting Has_Pragma_Unused (flag294)\n+\tand subsequent getter and setter declarations.\n+\t* lib-xref.adb (Generate_Reference): Recognize Has_Pragma_Unused\n+\tflag to print appropriate warning messages.\n+\t* par-prag.adb (Prag): Classify Pragma_Unused into \"All Other\n+\tPragmas.\"\n+\t* snames.ads-tmpl Add a new name to the name constants and a\n+\tnew pramga to Pragma_Id for pramga Unused.\n+\t* sem_prag.adb (Analyze_Pragma): Create case for Pragma_Unused\n+\tand move the block for Pragma_Unmodified and Pragma_Unreferenced\n+\tout and into local subprograms.\n+\t(Analyze_Unmodified, Analyze_Unreferenced): From the old pragma blocks\n+\tthat have been separated in to local subprograms add a parameter to\n+\tindicate the if they are being called in the context of Pragma_Unused\n+\tand handle it accordingly.\n+\t(Is_Non_Significant_Pragma_Reference): Add an entry for Pragma_Unused\n+\tand correct the position of Pragma_Unevaluated_Use_Of_Old.\n+\t* sem_util.adb (Note_Possible_Modification): Recognize\n+\tHas_Pragma_Unused flag to print appropriate warning messages.\n+\n 2016-07-04  Ed Schonberg  <schonberg@adacore.com>\n \n \t* freeze.adb (Check_Inherited_Conditions): Perform two passes over"}, {"sha": "ae4a3bb2c6e166c9eaf95b7668df9dab8c13cc78", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -608,8 +608,8 @@ package body Einfo is\n    --    Has_Inherited_Invariants        Flag291\n    --    Is_Partial_Invariant_Procedure  Flag292\n    --    Is_Actual_Subtype               Flag293\n+   --    Has_Pragma_Unused               Flag294\n \n-   --    (unused)                        Flag294\n    --    (unused)                        Flag295\n    --    (unused)                        Flag296\n    --    (unused)                        Flag297\n@@ -1761,6 +1761,11 @@ package body Einfo is\n       return Flag212 (Id);\n    end Has_Pragma_Unreferenced_Objects;\n \n+   function Has_Pragma_Unused (Id : E) return B is\n+   begin\n+      return Flag294 (Id);\n+   end Has_Pragma_Unused;\n+\n    function Has_Predicates (Id : E) return B is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -4768,6 +4773,11 @@ package body Einfo is\n       Set_Flag212 (Id, V);\n    end Set_Has_Pragma_Unreferenced_Objects;\n \n+   procedure Set_Has_Pragma_Unused (Id : E; V : B := True) is\n+   begin\n+      Set_Flag294 (Id, V);\n+   end Set_Has_Pragma_Unused;\n+\n    procedure Set_Has_Predicates (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Type (Id) or else Ekind (Id) = E_Void);\n@@ -9162,6 +9172,7 @@ package body Einfo is\n       W (\"Has_Pragma_Unmodified\",           Flag233 (Id));\n       W (\"Has_Pragma_Unreferenced\",         Flag180 (Id));\n       W (\"Has_Pragma_Unreferenced_Objects\", Flag212 (Id));\n+      W (\"Has_Pragma_Unused\",               Flag294 (Id));\n       W (\"Has_Predicates\",                  Flag250 (Id));\n       W (\"Has_Primitive_Operations\",        Flag120 (Id));\n       W (\"Has_Private_Ancestor\",            Flag151 (Id));"}, {"sha": "3a2d382f7639a92f2db610f4d4e2c11018004890", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -1902,12 +1902,19 @@ package Einfo is\n --       that clients should generally not test this flag directly, but instead\n --       use function Has_Unreferenced.\n \n+--  ??? this real description was clobbered\n+\n --    Has_Pragma_Unreferenced_Objects (Flag212)\n---       Defined in type and subtype entities. Set if a valid pragma\n---       Unreferenced_Objects applies to the type, indicating that no warning\n---       should be given for objects of such a type for being unreferenced\n---       (but unlike the case with pragma Unreferenced, it is ok to reference\n---       such an object and no warning is generated.\n+--       Defined in all entities. Set if a valid pragma Unused applies to an\n+--       entity, indicating that warnings should be given if the entity is\n+--       modified or referenced. This pragma is equivalent to a pair of\n+--       Unmodified and Unreferenced pragmas.\n+\n+--    Has_Pragma_Unused (Flag294)\n+--       Defined in all entries. Set if a valid pragma Unused applies to a\n+--       variable or entity, indicating that warnings should not be given if\n+--       it is never modified or referenced. Note: This pragma is exactly\n+--       equivalent Unmodified and Unreference combined.\n \n --    Has_Predicates (Flag250)\n --       Defined in type and subtype entities. Set if a pragma Predicate or\n@@ -5397,6 +5404,7 @@ package Einfo is\n    --    Has_Pragma_Thread_Local_Storage     (Flag169)\n    --    Has_Pragma_Unmodified               (Flag233)\n    --    Has_Pragma_Unreferenced             (Flag180)\n+   --    Has_Pragma_Unused                   (Flag294)\n    --    Has_Private_Declaration             (Flag155)\n    --    Has_Qualified_Name                  (Flag161)\n    --    Has_Stream_Size_Clause              (Flag184)\n@@ -6976,6 +6984,7 @@ package Einfo is\n    function Has_Pragma_Unmodified               (Id : E) return B;\n    function Has_Pragma_Unreferenced             (Id : E) return B;\n    function Has_Pragma_Unreferenced_Objects     (Id : E) return B;\n+   function Has_Pragma_Unused                   (Id : E) return B;\n    function Has_Predicates                      (Id : E) return B;\n    function Has_Primitive_Operations            (Id : E) return B;\n    function Has_Private_Ancestor                (Id : E) return B;\n@@ -7649,6 +7658,7 @@ package Einfo is\n    procedure Set_Has_Pragma_Unmodified           (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Unreferenced         (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Unreferenced_Objects (Id : E; V : B := True);\n+   procedure Set_Has_Pragma_Unused               (Id : E; V : B := True);\n    procedure Set_Has_Predicates                  (Id : E; V : B := True);\n    procedure Set_Has_Primitive_Operations        (Id : E; V : B := True);\n    procedure Set_Has_Private_Ancestor            (Id : E; V : B := True);\n@@ -8439,6 +8449,7 @@ package Einfo is\n    pragma Inline (Has_Pragma_Unmodified);\n    pragma Inline (Has_Pragma_Unreferenced);\n    pragma Inline (Has_Pragma_Unreferenced_Objects);\n+   pragma Inline (Has_Pragma_Unused);\n    pragma Inline (Has_Predicates);\n    pragma Inline (Has_Primitive_Operations);\n    pragma Inline (Has_Private_Ancestor);"}, {"sha": "b1d5978549e9d4e58745baee8e27a5541a86c686", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -841,6 +841,8 @@ package body Lib.Xref is\n \n          --  Check for pragma Unreferenced given and reference is within\n          --  this source unit (occasion for possible warning to be issued).\n+         --  Note that the entity may be marked as unreferenced by pragma\n+         --  Unused.\n \n          if Has_Unreferenced (E)\n            and then In_Same_Extended_Unit (E, N)\n@@ -875,8 +877,13 @@ package body Lib.Xref is\n                   BE := First_Entity (Current_Scope);\n                   while Present (BE) loop\n                      if Chars (BE) = Chars (E) then\n-                        Error_Msg_NE -- CODEFIX\n-                          (\"??pragma Unreferenced given for&!\", N, BE);\n+                        if Has_Pragma_Unused (E) then\n+                           Error_Msg_NE -- CODEFIX\n+                             (\"??pragma Unused given for&!\", N, BE);\n+                        else\n+                           Error_Msg_NE -- CODEFIX\n+                             (\"??pragma Unreferenced given for&!\", N, BE);\n+                        end if;\n                         exit;\n                      end if;\n \n@@ -886,6 +893,9 @@ package body Lib.Xref is\n \n             --  Here we issue the warning, since this is a real reference\n \n+            elsif Has_Pragma_Unused (E) then\n+               Error_Msg_NE -- CODEFIX\n+                 (\"??pragma Unused given for&!\", N, E);\n             else\n                Error_Msg_NE -- CODEFIX\n                  (\"??pragma Unreferenced given for&!\", N, E);"}, {"sha": "900d96a866f99425421471c048021cde0e0753f0", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -1487,6 +1487,7 @@ begin\n            Pragma_Unreferenced_Objects           |\n            Pragma_Unreserve_All_Interrupts       |\n            Pragma_Unsuppress                     |\n+           Pragma_Unused                         |\n            Pragma_Use_VADS_Size                  |\n            Pragma_Volatile                       |\n            Pragma_Volatile_Components            |"}, {"sha": "999ae352de4fe0c00ab8afd1fffb89ab9611fe03", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 319, "deletions": 240, "changes": 559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -3502,6 +3502,16 @@ package body Sem_Prag is\n       --  related subprogram. Body_Id is the entity of the subprogram body.\n       --  Flag Legal is set when the pragma is legal.\n \n+      procedure Analyze_Unmodified_Or_Unused (Is_Unused : Boolean := False);\n+      --  Perform full analysis of pragma Unmodified and the write aspect of\n+      --  pragma Unused. Flag Is_Unused should be set when verifying the\n+      --  semantics of pragma Unused.\n+\n+      procedure Analyze_Unreferenced_Or_Unused (Is_Unused : Boolean := False);\n+      --  Perform full analysis of pragma Unreferenced and the read aspect of\n+      --  pragma Unused. Flag Is_Unused should be set when verifying the\n+      --  semantics of pragma Unused.\n+\n       procedure Check_Ada_83_Warning;\n       --  Issues a warning message for the current pragma if operating in Ada\n       --  83 mode (used for language pragmas that are not a standard part of\n@@ -4465,6 +4475,274 @@ package body Sem_Prag is\n          end if;\n       end Analyze_Refined_Depends_Global_Post;\n \n+      ----------------------------------\n+      -- Analyze_Unmodified_Or_Unused --\n+      ----------------------------------\n+\n+      procedure Analyze_Unmodified_Or_Unused (Is_Unused : Boolean := False) is\n+         Arg      : Node_Id;\n+         Arg_Expr : Node_Id;\n+         Arg_Id   : Entity_Id;\n+\n+         Ghost_Error_Posted : Boolean := False;\n+         --  Flag set when an error concerning the illegal mix of Ghost and\n+         --  non-Ghost variables is emitted.\n+\n+         Ghost_Id : Entity_Id := Empty;\n+         --  The entity of the first Ghost variable encountered while\n+         --  processing the arguments of the pragma.\n+\n+      begin\n+         GNAT_Pragma;\n+         Check_At_Least_N_Arguments (1);\n+\n+         --  Loop through arguments\n+\n+         Arg := Arg1;\n+         while Present (Arg) loop\n+            Check_No_Identifier (Arg);\n+\n+            --  Note: the analyze call done by Check_Arg_Is_Local_Name will\n+            --  in fact generate reference, so that the entity will have a\n+            --  reference, which will inhibit any warnings about it not\n+            --  being referenced, and also properly show up in the ali file\n+            --  as a reference. But this reference is recorded before the\n+            --  Has_Pragma_Unreferenced flag is set, so that no warning is\n+            --  generated for this reference.\n+\n+            Check_Arg_Is_Local_Name (Arg);\n+            Arg_Expr := Get_Pragma_Arg (Arg);\n+\n+            if Is_Entity_Name (Arg_Expr) then\n+               Arg_Id := Entity (Arg_Expr);\n+\n+               --  Skip processing the argument if already flagged\n+\n+               if Is_Assignable (Arg_Id)\n+                 and then not Has_Pragma_Unmodified (Arg_Id)\n+                 and then not Has_Pragma_Unused (Arg_Id)\n+               then\n+                  Set_Has_Pragma_Unmodified (Arg_Id);\n+\n+                  if Is_Unused then\n+                     Set_Has_Pragma_Unused (Arg_Id);\n+                  end if;\n+\n+                  --  A pragma that applies to a Ghost entity becomes Ghost for\n+                  --  the purposes of legality checks and removal of ignored\n+                  --  Ghost code.\n+\n+                  Mark_Pragma_As_Ghost (N, Arg_Id);\n+\n+                  --  Capture the entity of the first Ghost variable being\n+                  --  processed for error detection purposes.\n+\n+                  if Is_Ghost_Entity (Arg_Id) then\n+                     if No (Ghost_Id) then\n+                        Ghost_Id := Arg_Id;\n+                     end if;\n+\n+                  --  Otherwise the variable is non-Ghost. It is illegal to mix\n+                  --  references to Ghost and non-Ghost entities\n+                  --  (SPARK RM 6.9).\n+\n+                  elsif Present (Ghost_Id)\n+                    and then not Ghost_Error_Posted\n+                  then\n+                     Ghost_Error_Posted := True;\n+\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_N\n+                       (\"pragma % cannot mention ghost and non-ghost \"\n+                        & \"variables\", N);\n+\n+                     Error_Msg_Sloc := Sloc (Ghost_Id);\n+                     Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                     Error_Msg_Sloc := Sloc (Arg_Id);\n+                     Error_Msg_NE (\"\\& # declared as non-ghost\", N, Arg_Id);\n+                  end if;\n+\n+               --  Warn if already flagged as Unused or Unmodified\n+\n+               elsif Has_Pragma_Unmodified (Arg_Id) then\n+                  if Has_Pragma_Unused (Arg_Id) then\n+                     Error_Msg_NE\n+                       (\"??pragma Unused given for &!\", Arg_Expr, Arg_Id);\n+                  else\n+                     Error_Msg_NE\n+                       (\"??pragma Unmodified given for &!\", Arg_Expr, Arg_Id);\n+                  end if;\n+\n+               --  Otherwise the pragma referenced an illegal entity\n+\n+               else\n+                  Error_Pragma_Arg\n+                    (\"pragma% can only be applied to a variable\", Arg_Expr);\n+               end if;\n+            end if;\n+\n+            Next (Arg);\n+         end loop;\n+      end Analyze_Unmodified_Or_Unused;\n+\n+      -----------------------------------\n+      -- Analyze_Unreference_Or_Unused --\n+      -----------------------------------\n+\n+      procedure Analyze_Unreferenced_Or_Unused\n+        (Is_Unused : Boolean := False)\n+      is\n+         Arg      : Node_Id;\n+         Arg_Expr : Node_Id;\n+         Arg_Id   : Entity_Id;\n+         Citem    : Node_Id;\n+\n+         Ghost_Error_Posted : Boolean := False;\n+         --  Flag set when an error concerning the illegal mix of Ghost and\n+         --  non-Ghost names is emitted.\n+\n+         Ghost_Id : Entity_Id := Empty;\n+         --  The entity of the first Ghost name encountered while processing\n+         --  the arguments of the pragma.\n+\n+      begin\n+         GNAT_Pragma;\n+         Check_At_Least_N_Arguments (1);\n+\n+         --  Check case of appearing within context clause\n+\n+         if not Is_Unused and then Is_In_Context_Clause then\n+\n+            --  The arguments must all be units mentioned in a with clause in\n+            --  the same context clause. Note that Par.Prag already checked\n+            --  that the arguments are either identifiers or selected\n+            --  components.\n+\n+            Arg := Arg1;\n+            while Present (Arg) loop\n+               Citem := First (List_Containing (N));\n+               while Citem /= N loop\n+                  Arg_Expr := Get_Pragma_Arg (Arg);\n+\n+                  if Nkind (Citem) = N_With_Clause\n+                    and then Same_Name (Name (Citem), Arg_Expr)\n+                  then\n+                     Set_Has_Pragma_Unreferenced\n+                       (Cunit_Entity\n+                         (Get_Source_Unit\n+                           (Library_Unit (Citem))));\n+                     Set_Elab_Unit_Name (Arg_Expr, Name (Citem));\n+                     exit;\n+                  end if;\n+\n+                  Next (Citem);\n+               end loop;\n+\n+               if Citem = N then\n+                  Error_Pragma_Arg\n+                    (\"argument of pragma% is not withed unit\", Arg);\n+               end if;\n+\n+               Next (Arg);\n+            end loop;\n+\n+         --  Case of not in list of context items\n+\n+         else\n+            Arg := Arg1;\n+            while Present (Arg) loop\n+               Check_No_Identifier (Arg);\n+\n+               --  Note: the analyze call done by Check_Arg_Is_Local_Name will\n+               --  in fact generate reference, so that the entity will have a\n+               --  reference, which will inhibit any warnings about it not\n+               --  being referenced, and also properly show up in the ali file\n+               --  as a reference. But this reference is recorded before the\n+               --  Has_Pragma_Unreferenced flag is set, so that no warning is\n+               --  generated for this reference.\n+\n+               Check_Arg_Is_Local_Name (Arg);\n+               Arg_Expr := Get_Pragma_Arg (Arg);\n+\n+               if Is_Entity_Name (Arg_Expr) then\n+                  Arg_Id := Entity (Arg_Expr);\n+\n+                  --  Warn if already flagged as Unused or Unreferenced and\n+                  --  skip processing the argument.\n+\n+                  if Has_Pragma_Unreferenced (Arg_Id) then\n+                     if Has_Pragma_Unused (Arg_Id) then\n+                        Error_Msg_NE\n+                          (\"??pragma Unused given for &!\", Arg_Expr, Arg_Id);\n+                     else\n+                        Error_Msg_NE\n+                          (\"??pragma Unreferenced given for &!\", Arg_Expr,\n+                           Arg_Id);\n+                     end if;\n+\n+                  --  Apply Unreferenced to the entity\n+\n+                  else\n+                     --  If the entity is overloaded, the pragma applies to the\n+                     --  most recent overloading, as documented. In this case,\n+                     --  name resolution does not generate a reference, so it\n+                     --  must be done here explicitly.\n+\n+                     if Is_Overloaded (Arg_Expr) then\n+                        Generate_Reference (Arg_Id, N);\n+                     end if;\n+\n+                     Set_Has_Pragma_Unreferenced (Arg_Id);\n+\n+                     if Is_Unused then\n+                        Set_Has_Pragma_Unused (Arg_Id);\n+                     end if;\n+\n+                     --  A pragma that applies to a Ghost entity becomes Ghost\n+                     --  for the purposes of legality checks and removal of\n+                     --  ignored Ghost code.\n+\n+                     Mark_Pragma_As_Ghost (N, Arg_Id);\n+\n+                     --  Capture the entity of the first Ghost name being\n+                     --  processed for error detection purposes.\n+\n+                     if Is_Ghost_Entity (Arg_Id) then\n+                        if No (Ghost_Id) then\n+                           Ghost_Id := Arg_Id;\n+                        end if;\n+\n+                     --  Otherwise the name is non-Ghost. It is illegal to mix\n+                     --  references to Ghost and non-Ghost entities\n+                     --  (SPARK RM 6.9).\n+\n+                     elsif Present (Ghost_Id)\n+                       and then not Ghost_Error_Posted\n+                     then\n+                        Ghost_Error_Posted := True;\n+\n+                        Error_Msg_Name_1 := Pname;\n+                        Error_Msg_N\n+                          (\"pragma % cannot mention ghost and non-ghost \"\n+                           & \"names\", N);\n+\n+                        Error_Msg_Sloc := Sloc (Ghost_Id);\n+                        Error_Msg_NE\n+                          (\"\\& # declared as ghost\", N, Ghost_Id);\n+\n+                        Error_Msg_Sloc := Sloc (Arg_Id);\n+                        Error_Msg_NE\n+                          (\"\\& # declared as non-ghost\", N, Arg_Id);\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Next (Arg);\n+            end loop;\n+         end if;\n+      end Analyze_Unreferenced_Or_Unused;\n+\n       --------------------------\n       -- Check_Ada_83_Warning --\n       --------------------------\n@@ -22270,6 +22548,30 @@ package body Sem_Prag is\n             Set_Is_Unchecked_Union  (Base_Type (Typ));\n          end Unchecked_Union;\n \n+         ----------------------------\n+         -- Unevaluated_Use_Of_Old --\n+         ----------------------------\n+\n+         --  pragma Unevaluated_Use_Of_Old (Error | Warn | Allow);\n+\n+         when Pragma_Unevaluated_Use_Of_Old =>\n+            GNAT_Pragma;\n+            Check_Arg_Count (1);\n+            Check_No_Identifiers;\n+            Check_Arg_Is_One_Of (Arg1, Name_Error, Name_Warn, Name_Allow);\n+\n+            --  Suppress/Unsuppress can appear as a configuration pragma, or in\n+            --  a declarative part or a package spec.\n+\n+            if not Is_Configuration_Pragma then\n+               Check_Is_In_Decl_Part_Or_Package_Spec;\n+            end if;\n+\n+            --  Store proper setting of Uneval_Old\n+\n+            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n+            Uneval_Old := Fold_Upper (Name_Buffer (1));\n+\n          ------------------------\n          -- Unimplemented_Unit --\n          ------------------------\n@@ -22281,10 +22583,9 @@ package body Sem_Prag is\n          --  body, not in the spec).\n \n          when Pragma_Unimplemented_Unit => Unimplemented_Unit : declare\n-            Cunitent : constant Entity_Id :=\n+            Cunitent : constant Entity_Id   :=\n                          Cunit_Entity (Get_Source_Unit (Loc));\n-            Ent_Kind : constant Entity_Kind :=\n-                         Ekind (Cunitent);\n+            Ent_Kind : constant Entity_Kind := Ekind (Cunitent);\n \n          begin\n             GNAT_Pragma;\n@@ -22350,92 +22651,8 @@ package body Sem_Prag is\n \n          --  pragma Unmodified (LOCAL_NAME {, LOCAL_NAME});\n \n-         when Pragma_Unmodified => Unmodified : declare\n-            Arg      : Node_Id;\n-            Arg_Expr : Node_Id;\n-            Arg_Id   : Entity_Id;\n-\n-            Ghost_Error_Posted : Boolean := False;\n-            --  Flag set when an error concerning the illegal mix of Ghost and\n-            --  non-Ghost variables is emitted.\n-\n-            Ghost_Id : Entity_Id := Empty;\n-            --  The entity of the first Ghost variable encountered while\n-            --  processing the arguments of the pragma.\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_At_Least_N_Arguments (1);\n-\n-            --  Loop through arguments\n-\n-            Arg := Arg1;\n-            while Present (Arg) loop\n-               Check_No_Identifier (Arg);\n-\n-               --  Note: the analyze call done by Check_Arg_Is_Local_Name will\n-               --  in fact generate reference, so that the entity will have a\n-               --  reference, which will inhibit any warnings about it not\n-               --  being referenced, and also properly show up in the ali file\n-               --  as a reference. But this reference is recorded before the\n-               --  Has_Pragma_Unreferenced flag is set, so that no warning is\n-               --  generated for this reference.\n-\n-               Check_Arg_Is_Local_Name (Arg);\n-               Arg_Expr := Get_Pragma_Arg (Arg);\n-\n-               if Is_Entity_Name (Arg_Expr) then\n-                  Arg_Id := Entity (Arg_Expr);\n-\n-                  if Is_Assignable (Arg_Id) then\n-                     Set_Has_Pragma_Unmodified (Arg_Id);\n-\n-                     --  A pragma that applies to a Ghost entity becomes Ghost\n-                     --  for the purposes of legality checks and removal of\n-                     --  ignored Ghost code.\n-\n-                     Mark_Pragma_As_Ghost (N, Arg_Id);\n-\n-                     --  Capture the entity of the first Ghost variable being\n-                     --  processed for error detection purposes.\n-\n-                     if Is_Ghost_Entity (Arg_Id) then\n-                        if No (Ghost_Id) then\n-                           Ghost_Id := Arg_Id;\n-                        end if;\n-\n-                     --  Otherwise the variable is non-Ghost. It is illegal\n-                     --  to mix references to Ghost and non-Ghost entities\n-                     --  (SPARK RM 6.9).\n-\n-                     elsif Present (Ghost_Id)\n-                       and then not Ghost_Error_Posted\n-                     then\n-                        Ghost_Error_Posted := True;\n-\n-                        Error_Msg_Name_1 := Pname;\n-                        Error_Msg_N\n-                          (\"pragma % cannot mention ghost and non-ghost \"\n-                           & \"variables\", N);\n-\n-                        Error_Msg_Sloc := Sloc (Ghost_Id);\n-                        Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n-\n-                        Error_Msg_Sloc := Sloc (Arg_Id);\n-                        Error_Msg_NE (\"\\& # declared as non-ghost\", N, Arg_Id);\n-                     end if;\n-\n-                  --  Otherwise the pragma referenced an illegal entity\n-\n-                  else\n-                     Error_Pragma_Arg\n-                       (\"pragma% can only be applied to a variable\", Arg_Expr);\n-                  end if;\n-               end if;\n-\n-               Next (Arg);\n-            end loop;\n-         end Unmodified;\n+         when Pragma_Unmodified =>\n+            Analyze_Unmodified_Or_Unused;\n \n          ------------------\n          -- Unreferenced --\n@@ -22447,133 +22664,8 @@ package body Sem_Prag is\n \n          --  pragma Unreferenced (library_unit_NAME {, library_unit_NAME}\n \n-         when Pragma_Unreferenced => Unreferenced : declare\n-            Arg      : Node_Id;\n-            Arg_Expr : Node_Id;\n-            Arg_Id   : Entity_Id;\n-            Citem    : Node_Id;\n-\n-            Ghost_Error_Posted : Boolean := False;\n-            --  Flag set when an error concerning the illegal mix of Ghost and\n-            --  non-Ghost names is emitted.\n-\n-            Ghost_Id : Entity_Id := Empty;\n-            --  The entity of the first Ghost name encountered while processing\n-            --  the arguments of the pragma.\n-\n-         begin\n-            GNAT_Pragma;\n-            Check_At_Least_N_Arguments (1);\n-\n-            --  Check case of appearing within context clause\n-\n-            if Is_In_Context_Clause then\n-\n-               --  The arguments must all be units mentioned in a with clause\n-               --  in the same context clause. Note we already checked (in\n-               --  Par.Prag) that the arguments are either identifiers or\n-               --  selected components.\n-\n-               Arg := Arg1;\n-               while Present (Arg) loop\n-                  Citem := First (List_Containing (N));\n-                  while Citem /= N loop\n-                     Arg_Expr := Get_Pragma_Arg (Arg);\n-\n-                     if Nkind (Citem) = N_With_Clause\n-                       and then Same_Name (Name (Citem), Arg_Expr)\n-                     then\n-                        Set_Has_Pragma_Unreferenced\n-                          (Cunit_Entity\n-                             (Get_Source_Unit\n-                                (Library_Unit (Citem))));\n-                        Set_Elab_Unit_Name (Arg_Expr, Name (Citem));\n-                        exit;\n-                     end if;\n-\n-                     Next (Citem);\n-                  end loop;\n-\n-                  if Citem = N then\n-                     Error_Pragma_Arg\n-                       (\"argument of pragma% is not withed unit\", Arg);\n-                  end if;\n-\n-                  Next (Arg);\n-               end loop;\n-\n-            --  Case of not in list of context items\n-\n-            else\n-               Arg := Arg1;\n-               while Present (Arg) loop\n-                  Check_No_Identifier (Arg);\n-\n-                  --  Note: the analyze call done by Check_Arg_Is_Local_Name\n-                  --  will in fact generate reference, so that the entity will\n-                  --  have a reference, which will inhibit any warnings about\n-                  --  it not being referenced, and also properly show up in the\n-                  --  ali file as a reference. But this reference is recorded\n-                  --  before the Has_Pragma_Unreferenced flag is set, so that\n-                  --  no warning is generated for this reference.\n-\n-                  Check_Arg_Is_Local_Name (Arg);\n-                  Arg_Expr := Get_Pragma_Arg (Arg);\n-\n-                  if Is_Entity_Name (Arg_Expr) then\n-                     Arg_Id := Entity (Arg_Expr);\n-\n-                     --  If the entity is overloaded, the pragma applies to the\n-                     --  most recent overloading, as documented. In this case,\n-                     --  name resolution does not generate a reference, so it\n-                     --  must be done here explicitly.\n-\n-                     if Is_Overloaded (Arg_Expr) then\n-                        Generate_Reference (Arg_Id, N);\n-                     end if;\n-\n-                     Set_Has_Pragma_Unreferenced (Arg_Id);\n-\n-                     --  A pragma that applies to a Ghost entity becomes Ghost\n-                     --  for the purposes of legality checks and removal of\n-                     --  ignored Ghost code.\n-\n-                     Mark_Pragma_As_Ghost (N, Arg_Id);\n-\n-                     --  Capture the entity of the first Ghost name being\n-                     --  processed for error detection purposes.\n-\n-                     if Is_Ghost_Entity (Arg_Id) then\n-                        if No (Ghost_Id) then\n-                           Ghost_Id := Arg_Id;\n-                        end if;\n-\n-                     --  Otherwise the name is non-Ghost. It is illegal to mix\n-                     --  references to Ghost and non-Ghost entities\n-                     --  (SPARK RM 6.9).\n-\n-                     elsif Present (Ghost_Id)\n-                       and then not Ghost_Error_Posted\n-                     then\n-                        Ghost_Error_Posted := True;\n-\n-                        Error_Msg_Name_1 := Pname;\n-                        Error_Msg_N\n-                          (\"pragma % cannot mention ghost and non-ghost names\",\n-                           N);\n-\n-                        Error_Msg_Sloc := Sloc (Ghost_Id);\n-                        Error_Msg_NE (\"\\& # declared as ghost\", N, Ghost_Id);\n-\n-                        Error_Msg_Sloc := Sloc (Arg_Id);\n-                        Error_Msg_NE (\"\\& # declared as non-ghost\", N, Arg_Id);\n-                     end if;\n-                  end if;\n-\n-                  Next (Arg);\n-               end loop;\n-            end if;\n-         end Unreferenced;\n+         when Pragma_Unreferenced =>\n+            Analyze_Unreferenced_Or_Unused;\n \n          --------------------------\n          -- Unreferenced_Objects --\n@@ -22681,29 +22773,15 @@ package body Sem_Prag is\n             Ada_2005_Pragma;\n             Process_Suppress_Unsuppress (Suppress_Case => False);\n \n-         ----------------------------\n-         -- Unevaluated_Use_Of_Old --\n-         ----------------------------\n-\n-         --  pragma Unevaluated_Use_Of_Old (Error | Warn | Allow);\n-\n-         when Pragma_Unevaluated_Use_Of_Old =>\n-            GNAT_Pragma;\n-            Check_Arg_Count (1);\n-            Check_No_Identifiers;\n-            Check_Arg_Is_One_Of (Arg1, Name_Error, Name_Warn, Name_Allow);\n-\n-            --  Suppress/Unsuppress can appear as a configuration pragma, or in\n-            --  a declarative part or a package spec.\n-\n-            if not Is_Configuration_Pragma then\n-               Check_Is_In_Decl_Part_Or_Package_Spec;\n-            end if;\n+         ------------\n+         -- Unused --\n+         ------------\n \n-            --  Store proper setting of Uneval_Old\n+         --  pragma Unused (LOCAL_NAME {, LOCAL_NAME});\n \n-            Get_Name_String (Chars (Get_Pragma_Arg (Arg1)));\n-            Uneval_Old := Fold_Upper (Name_Buffer (1));\n+         when Pragma_Unused =>\n+            Analyze_Unmodified_Or_Unused   (Is_Unused => True);\n+            Analyze_Unreferenced_Or_Unused (Is_Unused => True);\n \n          -------------------\n          -- Use_VADS_Size --\n@@ -26386,8 +26464,8 @@ package body Sem_Prag is\n                then\n                   Error_Msg_N\n                     (\"cannot modify inherited condition (SPARK RM 6.1.1(1))\",\n-                      Parent (Subp));\n-                  Error_Msg_Sloc := Sloc (New_E);\n+                     Parent (Subp));\n+                  Error_Msg_Sloc   := Sloc (New_E);\n                   Error_Msg_Node_2 := Subp;\n                   Error_Msg_NE\n                     (\"\\overriding of&# forces overriding of&\",\n@@ -28378,6 +28456,7 @@ package body Sem_Prag is\n       Pragma_Type_Invariant                 => -1,\n       Pragma_Type_Invariant_Class           => -1,\n       Pragma_Unchecked_Union                =>  0,\n+      Pragma_Unevaluated_Use_Of_Old         =>  0,\n       Pragma_Unimplemented_Unit             =>  0,\n       Pragma_Universal_Aliasing             =>  0,\n       Pragma_Universal_Data                 =>  0,\n@@ -28386,7 +28465,7 @@ package body Sem_Prag is\n       Pragma_Unreferenced_Objects           =>  0,\n       Pragma_Unreserve_All_Interrupts       =>  0,\n       Pragma_Unsuppress                     =>  0,\n-      Pragma_Unevaluated_Use_Of_Old         =>  0,\n+      Pragma_Unused                         =>  0,\n       Pragma_Use_VADS_Size                  =>  0,\n       Pragma_Validity_Checks                =>  0,\n       Pragma_Volatile                       =>  0,"}, {"sha": "94e97b4e28a31aaf3e615231b50cdcbae1229527", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -17618,11 +17618,20 @@ package body Sem_Util is\n                if Comes_From_Source (Exp)\n                  or else Modification_Comes_From_Source\n                then\n-                  --  Give warning if pragma unmodified given and we are\n+                  --  Give warning if pragma unmodified is given and we are\n                   --  sure this is a modification.\n \n                   if Has_Pragma_Unmodified (Ent) and then Sure then\n-                     Error_Msg_NE (\"??pragma Unmodified given for &!\", N, Ent);\n+\n+                     --  Note that the entity may be present only as a result\n+                     --  of pragma Unused.\n+\n+                     if Has_Pragma_Unused (Ent) then\n+                        Error_Msg_NE (\"??pragma Unused given for &!\", N, Ent);\n+                     else\n+                        Error_Msg_NE\n+                          (\"??pragma Unmodified given for &!\", N, Ent);\n+                     end if;\n                   end if;\n \n                   Set_Never_Set_In_Source (Ent, False);"}, {"sha": "920b24ef12e3e112dc3c12d88c6a0085d64ee7ca", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d1d00ca249c62a6df038254e1fc986bd6b26f39/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=9d1d00ca249c62a6df038254e1fc986bd6b26f39", "patch": "@@ -653,6 +653,7 @@ package Snames is\n    Name_Unreferenced                   : constant Name_Id := N + $; -- GNAT\n    Name_Unreferenced_Objects           : constant Name_Id := N + $; -- GNAT\n    Name_Unreserve_All_Interrupts       : constant Name_Id := N + $; -- GNAT\n+   Name_Unused                         : constant Name_Id := N + $; -- GNAT\n    Name_Volatile                       : constant Name_Id := N + $;\n    Name_Volatile_Components            : constant Name_Id := N + $;\n    Name_Volatile_Full_Access           : constant Name_Id := N + $; -- GNAT\n@@ -1965,6 +1966,7 @@ package Snames is\n       Pragma_Unreferenced,\n       Pragma_Unreferenced_Objects,\n       Pragma_Unreserve_All_Interrupts,\n+      Pragma_Unused,\n       Pragma_Volatile,\n       Pragma_Volatile_Components,\n       Pragma_Volatile_Full_Access,"}]}