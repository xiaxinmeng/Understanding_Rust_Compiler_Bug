{"sha": "1d87d70dd03280f2bf8d30a2695a3828152607cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ4N2Q3MGRkMDMyODBmMmJmOGQzMGEyNjk1YTM4MjgxNTI2MDdjYw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-05-01T17:51:21Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-05-01T17:51:21Z"}, "message": "gmon-sol2.c (size_t): New type.\n\n\t* config/i386/gmon-sol2.c (size_t): New type.\n\t(intptr_t): Likewise.\n\t(s_textsize): Declare as size_t.\n\t(sbrk): Declare.\n\t(monstartup): Use size_t for sizes.\n\t(_mcount): Save and restore registers.\n\t(internal_mcount): Pass 0 as the first argument to monstartup\n\tin 64-bit mode.\n\t(moncontrol): Convert pointer to appropriately sized integer\n\tbefore passing to profil.\n\nFrom-SVN: r124333", "tree": {"sha": "28f26db33d85551f46433ba7361eeed92d0b7208", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28f26db33d85551f46433ba7361eeed92d0b7208"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d87d70dd03280f2bf8d30a2695a3828152607cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d87d70dd03280f2bf8d30a2695a3828152607cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d87d70dd03280f2bf8d30a2695a3828152607cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d87d70dd03280f2bf8d30a2695a3828152607cc/comments", "author": null, "committer": null, "parents": [{"sha": "b26941b46a82ddb2915de92469ce4d2126fb0ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26941b46a82ddb2915de92469ce4d2126fb0ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26941b46a82ddb2915de92469ce4d2126fb0ef9"}], "stats": {"total": 90, "additions": 81, "deletions": 9}, "files": [{"sha": "d28442991bc1315508d8df9de7d40ec755d2332b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d87d70dd03280f2bf8d30a2695a3828152607cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d87d70dd03280f2bf8d30a2695a3828152607cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d87d70dd03280f2bf8d30a2695a3828152607cc", "patch": "@@ -1,3 +1,16 @@\n+2007-05-01  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* config/i386/gmon-sol2.c (size_t): New type.\n+\t(intptr_t): Likewise.\n+\t(s_textsize): Declare as size_t.\n+\t(sbrk): Declare.\n+\t(monstartup): Use size_t for sizes.\n+\t(_mcount): Save and restore registers.\n+\t(internal_mcount): Pass 0 as the first argument to monstartup\n+\tin 64-bit mode.\n+\t(moncontrol): Convert pointer to appropriately sized integer\n+\tbefore passing to profil.\n+\n 2007-05-01  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/darwin-ldouble.c (__gcc_qunord): Define if"}, {"sha": "d20762156a6aa4e6314252533c50377aae091f75", "filename": "gcc/config/i386/gmon-sol2.c", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d87d70dd03280f2bf8d30a2695a3828152607cc/gcc%2Fconfig%2Fi386%2Fgmon-sol2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d87d70dd03280f2bf8d30a2695a3828152607cc/gcc%2Fconfig%2Fi386%2Fgmon-sol2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgmon-sol2.c?ref=1d87d70dd03280f2bf8d30a2695a3828152607cc", "patch": "@@ -64,7 +64,13 @@\n static void moncontrol (int);\n extern void monstartup (char *, char *);\n extern void _mcleanup (void);\n-extern void internal_mcount (void);\n+extern void internal_mcount (\n+#ifdef __x86_64__\n+\t\t\t     char *, unsigned short *\n+#else\n+\t\t\t     void\n+#endif\n+\t\t\t     );\n \n \n struct phdr {\n@@ -98,6 +104,9 @@ struct rawarc {\n \n /* char *minbrk; */\n \n+typedef __SIZE_TYPE__ size_t;\n+typedef __PTRDIFF_TYPE__ intptr_t;\n+\n     /*\n      *\tfroms is actually a bunch of unsigned shorts indexing tos\n      */\n@@ -107,7 +116,7 @@ static struct tostruct\t*tos = 0;\n static long\t\ttolimit = 0;\n static char\t\t*s_lowpc = 0;\n static char\t\t*s_highpc = 0;\n-static unsigned long\ts_textsize = 0;\n+static size_t\t\ts_textsize = 0;\n \n static int\tssiz;\n static char\t*sbuf;\n@@ -119,22 +128,24 @@ static int\ts_scale;\n \n extern int errno;\n \n+extern void *sbrk (intptr_t);\n+\n void\n monstartup(char *lowpc, char *highpc)\n {\n-    int\t\t\tmonsize;\n+    size_t\t\tmonsize;\n     char\t\t*buffer;\n-    register int\to;\n+    register size_t\to;\n \n \t/*\n \t *\tround lowpc and highpc to multiples of the density we're using\n \t *\tso the rest of the scaling (here and in gprof) stays in ints.\n \t */\n     lowpc = (char *)\n-\t    ROUNDDOWN((unsigned long)lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+\t    ROUNDDOWN((size_t)lowpc, HISTFRACTION*sizeof(HISTCOUNTER));\n     s_lowpc = lowpc;\n     highpc = (char *)\n-\t    ROUNDUP((unsigned long)highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n+\t    ROUNDUP((size_t)highpc, HISTFRACTION*sizeof(HISTCOUNTER));\n     s_highpc = highpc;\n     s_textsize = highpc - lowpc;\n     monsize = (s_textsize / HISTFRACTION) + sizeof(struct phdr);\n@@ -237,21 +248,65 @@ _mcleanup (void)\n     close( fd );\n }\n \n+#ifdef __x86_64__\n+/* See GLIBC for additional information about this technique.  */\n+asm(\".globl _mcount\\n\" \n+    \"\\t.type\\t_mcount, @function\\n\"\n+    \"_mcount:\\n\"\n+    /* The compiler calls _mcount after the prologue, and does not\n+       save any of the registers.  Therefore we must preserve all\n+       seven registers which may contain function arguments.  */\n+    \"\\tsubq\\t$0x38,%rsp\\n\"\n+    \"\\tmovq\\t%rax,(%rsp)\\n\"\n+    \"\\tmovq\\t%rcx,0x08(%rsp)\\n\"\n+    \"\\tmovq\\t%rdx,0x10(%rsp)\\n\"\n+    \"\\tmovq\\t%rsi,0x18(%rsp)\\n\"\n+    \"\\tmovq\\t%rdi,0x20(%rsp)\\n\"\n+    \"\\tmovq\\t%r8,0x28(%rsp)\\n\"\n+    \"\\tmovq\\t%r9,0x30(%rsp)\\n\"\n+    /* Get SELFPC (pushed by the call to this function) and\n+       FROMPCINDEX (via the frame pointer.  */\n+    \"\\tmovq\\t0x38(%rsp),%rdi\\n\"\n+    \"\\tmovq\\t0x8(%rbp),%rsi\\n\"\n+    \"\\tcallq\\tinternal_mcount\\n\"\n+    /* Restore the saved registers.  */\n+    \"\\tmovq\\t0x30(%rsp),%r9\\n\"\n+    \"\\tmovq\\t0x28(%rsp),%r8\\n\"\n+    \"\\tmovq\\t0x20(%rsp),%rdi\\n\"\n+    \"\\tmovq\\t0x18(%rsp),%rsi\\n\"\n+    \"\\tmovq\\t0x10(%rsp),%rdx\\n\"\n+    \"\\tmovq\\t0x08(%rsp),%rdx\\n\"\n+    \"\\tmovq\\t(%rsp),%rax\\n\"\n+    \"\\taddq\\t$0x38,%rsp\\n\"\n+    \"\\tretq\\n\"\n+    );\n+#else\n /* Solaris 2 libraries use _mcount.  */\n asm(\".globl _mcount; _mcount: jmp internal_mcount\");\n /* This is for compatibility with old versions of gcc which used mcount.  */\n asm(\".globl mcount; mcount: jmp internal_mcount\");\n+#endif\n \n void\n-internal_mcount (void)\n+internal_mcount (\n+#ifdef __x86_64__\n+\t\t char *selfpc,\n+\t\t unsigned short *frompcindex\n+#else\n+\t\t void\n+#endif\n+\t\t )\n {\n+#ifndef __x86_64__\n \tregister char\t\t\t*selfpc;\n \tregister unsigned short\t\t*frompcindex;\n+#endif\n \tregister struct tostruct\t*top;\n \tregister struct tostruct\t*prevtop;\n \tregister long\t\t\ttoindex;\n \tstatic char already_setup;\n \n+#ifndef __x86_64__\n \t/*\n \t *\tfind the return address for mcount,\n \t *\tand the return address for mcount's caller.\n@@ -263,12 +318,16 @@ internal_mcount (void)\n \t/* frompcindex = pc in preceding frame.\n \t   This identifies the caller of the function just entered.  */\n \tfrompcindex = (void *) __builtin_return_address (1);\n+#endif\n \n \tif(!already_setup) {\n           extern char etext[];\n \t  already_setup = 1;\n-/*\t  monstartup(0, etext); */\n+#ifdef __x86_64__\n+\t  monstartup(0, etext);\n+#else\n \t  monstartup((char*)0x08040000, etext);\n+#endif\n #ifdef USE_ONEXIT\n \t  on_exit(_mcleanup, 0);\n #else\n@@ -389,7 +448,7 @@ moncontrol(int mode)\n       /* start */\n       profil((unsigned short *)(sbuf + sizeof(struct phdr)),\n \t     ssiz - sizeof(struct phdr),\n-\t     (long)s_lowpc, s_scale);\n+\t     (size_t)s_lowpc, s_scale);\n       \n       profiling = 0;\n     } else {"}]}