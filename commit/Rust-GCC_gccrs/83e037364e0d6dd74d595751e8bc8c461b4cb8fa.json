{"sha": "83e037364e0d6dd74d595751e8bc8c461b4cb8fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNlMDM3MzY0ZTBkNmRkNzRkNTk1NzUxZThiYzhjNDYxYjRjYjhmYQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2020-09-19T14:32:35Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2020-09-19T20:54:16Z"}, "message": "Use C-style loop lowering instead of C++-style.\n\nThe C and C++ front ends used to use the same strategy of lowering\nloops to gotos with the end test canonicalized to the bottom of the\nloop.  In 2014 the C++ front end was changed to emit LOOP_EXPRs\ninstead (commit 1a45860e7757ee054f6bf98bee4ebe5c661dfb90).\n\nAs part of the unification of the C and C++ loop handling, it's\ndesirable to use the same lowering strategy for both languages.\nApplying the C++ strategy to C caused a number of regressions in C\noptimization tests, related to flipping the sense of the COND_EXPR for\nthe exit test and changes in block ordering in the output code.  Many\nof these regressions just require updating regexps in the test cases\nbut a few appear to be genuine optimization failures.  Since it\nappears the optimizers handle the C code better than C++ code, let's\ngo back to using the C strategy for both languages.  The rationale for\nthe 2014 C++ patch (support for constexpr evaluation) has been solved\nin other ways meanwhile.\n\n2020-08-12  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/c-family/\n\t* c-gimplify.c (genericize_c_loop): Rewrite to match\n\tc_finish_loop in c-typeck.c.", "tree": {"sha": "d066e45803a7fe9fbbb3d26813c0ef8f014ed9c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d066e45803a7fe9fbbb3d26813c0ef8f014ed9c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83e037364e0d6dd74d595751e8bc8c461b4cb8fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e037364e0d6dd74d595751e8bc8c461b4cb8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e037364e0d6dd74d595751e8bc8c461b4cb8fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e037364e0d6dd74d595751e8bc8c461b4cb8fa/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba079f354a55363916759f6f186f92c5616b98a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba079f354a55363916759f6f186f92c5616b98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba079f354a55363916759f6f186f92c5616b98a"}], "stats": {"total": 110, "additions": 62, "deletions": 48}, "files": [{"sha": "8b326c99d487b61da830c862ed2396c81a56a7da", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e037364e0d6dd74d595751e8bc8c461b4cb8fa/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e037364e0d6dd74d595751e8bc8c461b4cb8fa/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=83e037364e0d6dd74d595751e8bc8c461b4cb8fa", "patch": "@@ -217,9 +217,10 @@ genericize_c_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,\n \t\t   void *data, walk_tree_fn func, walk_tree_lh lh)\n {\n   tree blab, clab;\n-  tree exit = NULL;\n+  tree entry = NULL, exit = NULL, t;\n   tree stmt_list = NULL;\n-  tree debug_begin = NULL;\n+  location_t cond_locus = expr_loc_or_loc (cond, start_locus);\n+  location_t incr_locus = expr_loc_or_loc (incr, start_locus);\n \n   protected_set_expr_location_if_unset (incr, start_locus);\n \n@@ -232,71 +233,84 @@ genericize_c_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,\n   walk_tree_1 (&body, func, data, NULL, lh);\n   *walk_subtrees = 0;\n \n-  if (MAY_HAVE_DEBUG_MARKER_STMTS\n-      && (!cond || !integer_zerop (cond)))\n+  /* If condition is zero don't generate a loop construct.  */\n+  if (cond && integer_zerop (cond))\n     {\n-      debug_begin = build0 (DEBUG_BEGIN_STMT, void_type_node);\n-      SET_EXPR_LOCATION (debug_begin, expr_loc_or_loc (cond, start_locus));\n+      if (cond_is_first)\n+\t{\n+\t  t = build1_loc (start_locus, GOTO_EXPR, void_type_node,\n+\t\t\t  get_bc_label (bc_break));\n+\t  append_to_statement_list (t, &stmt_list);\n+\t}\n     }\n-\n-  if (cond && TREE_CODE (cond) != INTEGER_CST)\n+  else\n     {\n-      /* If COND is constant, don't bother building an exit.  If it's false,\n-\t we won't build a loop.  If it's true, any exits are in the body.  */\n-      location_t cloc = expr_loc_or_loc (cond, start_locus);\n-      exit = build1_loc (cloc, GOTO_EXPR, void_type_node,\n-\t\t\t get_bc_label (bc_break));\n-      exit = fold_build3_loc (cloc, COND_EXPR, void_type_node, cond,\n-\t\t\t      build_empty_stmt (cloc), exit);\n-    }\n+      /* Expand to gotos.  */\n+      tree top = build1 (LABEL_EXPR, void_type_node,\n+\t\t\t create_artificial_label (start_locus));\n \n-  if (exit && cond_is_first)\n-    {\n-      append_to_statement_list (debug_begin, &stmt_list);\n-      debug_begin = NULL_TREE;\n-      append_to_statement_list (exit, &stmt_list);\n+      /* If we have an exit condition, then we build an IF with gotos either\n+\t out of the loop, or to the top of it.  If there's no exit condition,\n+\t then we just build a jump back to the top.  */\n+      exit = build1 (GOTO_EXPR, void_type_node, LABEL_EXPR_LABEL (top));\n+\n+      if (cond && !integer_nonzerop (cond))\n+\t{\n+\t  /* Canonicalize the loop condition to the end.  This means\n+\t     generating a branch to the loop condition.  Reuse the\n+\t     continue label, if there is no incr expression.  */\n+\t  if (cond_is_first)\n+\t    {\n+\t      if (incr)\n+\t\t{\n+\t\t  entry = build1 (LABEL_EXPR, void_type_node,\n+\t\t\t\t  create_artificial_label (start_locus));\n+\t\t  t = build1_loc (start_locus, GOTO_EXPR, void_type_node,\n+\t\t\t\t  LABEL_EXPR_LABEL (entry));\n+\t\t}\n+\t      else\n+\t\tt = build1_loc (start_locus, GOTO_EXPR, void_type_node,\n+\t\t\t\tget_bc_label (bc_continue));\n+\t      append_to_statement_list (t, &stmt_list);\n+\t    }\n+\n+\t  t = build1 (GOTO_EXPR, void_type_node, get_bc_label (bc_break));\n+\t  exit = fold_build3_loc (cond_locus,\n+\t\t\t\t  COND_EXPR, void_type_node, cond, exit, t);\n+\t}\n+      else\n+\t{\n+\t  /* For the backward-goto's location of an unconditional loop\n+\t     use the beginning of the body, or, if there is none, the\n+\t     top of the loop.  */\n+\t  location_t loc = expr_loc_or_loc (expr_first (body),\n+\t\t\t\t\t    start_locus);\n+\t  SET_EXPR_LOCATION (exit, loc);\n+\t}\n+      append_to_statement_list (top, &stmt_list);\n     }\n+\n   append_to_statement_list (body, &stmt_list);\n   finish_bc_block (&stmt_list, bc_continue, clab);\n   if (incr)\n     {\n-      if (MAY_HAVE_DEBUG_MARKER_STMTS)\n+      if (MAY_HAVE_DEBUG_MARKER_STMTS && incr_locus != UNKNOWN_LOCATION)\n \t{\n \t  tree d = build0 (DEBUG_BEGIN_STMT, void_type_node);\n \t  SET_EXPR_LOCATION (d, expr_loc_or_loc (incr, start_locus));\n \t  append_to_statement_list (d, &stmt_list);\n \t}\n       append_to_statement_list (incr, &stmt_list);\n     }\n-  append_to_statement_list (debug_begin, &stmt_list);\n-  if (exit && !cond_is_first)\n-    append_to_statement_list (exit, &stmt_list);\n+  append_to_statement_list (entry, &stmt_list);\n \n-  if (!stmt_list)\n-    stmt_list = build_empty_stmt (start_locus);\n-\n-  tree loop;\n-  if (cond && integer_zerop (cond))\n+  if (MAY_HAVE_DEBUG_MARKER_STMTS && cond_locus != UNKNOWN_LOCATION)\n     {\n-      if (cond_is_first)\n-\tloop = fold_build3_loc (start_locus, COND_EXPR,\n-\t\t\t\tvoid_type_node, cond, stmt_list,\n-\t\t\t\tbuild_empty_stmt (start_locus));\n-      else\n-\tloop = stmt_list;\n-    }\n-  else\n-    {\n-      location_t loc = start_locus;\n-      if (!cond || integer_nonzerop (cond))\n-\tloc = EXPR_LOCATION (expr_first (body));\n-      if (loc == UNKNOWN_LOCATION)\n-\tloc = start_locus;\n-      loop = build1_loc (loc, LOOP_EXPR, void_type_node, stmt_list);\n+      tree d = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+      SET_EXPR_LOCATION (d, cond_locus);\n+      append_to_statement_list (d, &stmt_list);\n     }\n-\n-  stmt_list = NULL;\n-  append_to_statement_list (loop, &stmt_list);\n+  append_to_statement_list (exit, &stmt_list);\n   finish_bc_block (&stmt_list, bc_break, blab);\n   if (!stmt_list)\n     stmt_list = build_empty_stmt (start_locus);"}]}