{"sha": "d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDc0NzMyZjVjZDg3YjY4YWVkMTBlYTNmY2ZjYjI0MTcxYjlmNWQ2Nw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-10-01T03:46:43Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-10-01T03:46:43Z"}, "message": "ObjectInputStream.java (resolveProxyClass): New method from Classpath.\n\n\t* java/io/ObjectInputStream.java (resolveProxyClass): New method\n\tfrom Classpath.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (rmi_java_source_files): Added new files.\n\t* gnu/java/rmi/RMIMarshalledObjectInputStream.java,\n\tgnu/java/rmi/RMIMarshalledObjectOutputStream.java,\n\tgnu/java/rmi/server/ConnectionRunnerPool.java: New files from\n\tClasspath.\n\t* gnu/java/rmi/dgc/DGCImpl.java,\n\tgnu/java/rmi/dgc/DGCImpl_Skel.java,\n\tgnu/java/rmi/dgc/DGCImpl_Stub.java,\n\tgnu/java/rmi/registry/RegistryImpl_Skel.java,\n\tgnu/java/rmi/registry/RegistryImpl_Stub.java,\n\tgnu/java/rmi/server/RMIHashes.java,\n\tgnu/java/rmi/server/RMIObjectInputStream.java,\n\tgnu/java/rmi/server/RMIObjectOutputStream.java,\n\tgnu/java/rmi/server/UnicastConnection.java,\n\tgnu/java/rmi/server/UnicastConnectionManager.java,\n\tgnu/java/rmi/server/UnicastRef.java,\n\tgnu/java/rmi/server/UnicastServer.java,\n\tgnu/java/rmi/server/UnicastServerRef.java,\n\tjava/rmi/MarshalledObject.java,\n\tjava/rmi/server/RMIClassLoader.java,\n\tjava/rmi/server/RemoteObject.java,\n\tjava/rmi/server/UnicastRemoteObject.java,\n\tjava/security/SecureClassLoader.java: Merged from Classpath.\n\nFrom-SVN: r57675", "tree": {"sha": "bf757dbbf21b52fd568fba72014b0347b815ecdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf757dbbf21b52fd568fba72014b0347b815ecdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/comments", "author": null, "committer": null, "parents": [{"sha": "e3e3815b7f9fdb2868f93840d6872336d871c29b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3e3815b7f9fdb2868f93840d6872336d871c29b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3e3815b7f9fdb2868f93840d6872336d871c29b"}], "stats": {"total": 1337, "additions": 1178, "deletions": 159}, "files": [{"sha": "8c2ab3e243ae1bde2f85f4e884af6719894515eb", "filename": "libjava/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,3 +1,32 @@\n+2002-09-30  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/io/ObjectInputStream.java (resolveProxyClass): New method\n+\tfrom Classpath.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (rmi_java_source_files): Added new files.\n+\t* gnu/java/rmi/RMIMarshalledObjectInputStream.java,\n+\tgnu/java/rmi/RMIMarshalledObjectOutputStream.java,\n+\tgnu/java/rmi/server/ConnectionRunnerPool.java: New files from\n+\tClasspath.\n+\t* gnu/java/rmi/dgc/DGCImpl.java,\n+\tgnu/java/rmi/dgc/DGCImpl_Skel.java,\n+\tgnu/java/rmi/dgc/DGCImpl_Stub.java,\n+\tgnu/java/rmi/registry/RegistryImpl_Skel.java,\n+\tgnu/java/rmi/registry/RegistryImpl_Stub.java,\n+\tgnu/java/rmi/server/RMIHashes.java,\n+\tgnu/java/rmi/server/RMIObjectInputStream.java,\n+\tgnu/java/rmi/server/RMIObjectOutputStream.java,\n+\tgnu/java/rmi/server/UnicastConnection.java,\n+\tgnu/java/rmi/server/UnicastConnectionManager.java,\n+\tgnu/java/rmi/server/UnicastRef.java,\n+\tgnu/java/rmi/server/UnicastServer.java,\n+\tgnu/java/rmi/server/UnicastServerRef.java,\n+\tjava/rmi/MarshalledObject.java,\n+\tjava/rmi/server/RMIClassLoader.java,\n+\tjava/rmi/server/RemoteObject.java,\n+\tjava/rmi/server/UnicastRemoteObject.java,\n+\tjava/security/SecureClassLoader.java: Merged from Classpath.\n+\n 2002-09-29  Anthony Green  <green@redhat.com>\n \n \t* java/lang/reflect/UndeclaredThrowableException.java: New file."}, {"sha": "a1ea9e0c64acc07b267fe4ad614c4049a31eb146", "filename": "libjava/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1284,6 +1284,8 @@ java/rmi/server/SocketSecurityException.java \\\n java/rmi/server/UID.java \\\n java/rmi/server/UnicastRemoteObject.java \\\n java/rmi/server/Unreferenced.java \\\n+gnu/java/rmi/RMIMarshalledObjectInputStream.java \\\n+gnu/java/rmi/RMIMarshalledObjectOutputStream.java \\\n gnu/java/rmi/dgc/DGCImpl.java \\\n gnu/java/rmi/dgc/DGCImpl_Skel.java \\\n gnu/java/rmi/dgc/DGCImpl_Stub.java \\\n@@ -1295,6 +1297,7 @@ gnu/java/rmi/rmic/Compiler.java\t\\\n gnu/java/rmi/rmic/CompilerProcess.java \\\n gnu/java/rmi/rmic/RMIC.java \\\n gnu/java/rmi/rmic/TabbedWriter.java \\\n+gnu/java/rmi/server/ConnectionRunnerPool.java \\\n gnu/java/rmi/server/ProtocolConstants.java \\\n gnu/java/rmi/server/RMIDefaultSocketFactory.java \\\n gnu/java/rmi/server/RMIHashes.java \\"}, {"sha": "4bdfe199ea7d23f82dcfdea315ab7f2180caafa8", "filename": "libjava/Makefile.in", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -1042,6 +1042,8 @@ java/rmi/server/SocketSecurityException.java \\\n java/rmi/server/UID.java \\\n java/rmi/server/UnicastRemoteObject.java \\\n java/rmi/server/Unreferenced.java \\\n+gnu/java/rmi/RMIMarshalledObjectInputStream.java \\\n+gnu/java/rmi/RMIMarshalledObjectOutputStream.java \\\n gnu/java/rmi/dgc/DGCImpl.java \\\n gnu/java/rmi/dgc/DGCImpl_Skel.java \\\n gnu/java/rmi/dgc/DGCImpl_Stub.java \\\n@@ -1053,6 +1055,7 @@ gnu/java/rmi/rmic/Compiler.java\t\\\n gnu/java/rmi/rmic/CompilerProcess.java \\\n gnu/java/rmi/rmic/RMIC.java \\\n gnu/java/rmi/rmic/TabbedWriter.java \\\n+gnu/java/rmi/server/ConnectionRunnerPool.java \\\n gnu/java/rmi/server/ProtocolConstants.java \\\n gnu/java/rmi/server/RMIDefaultSocketFactory.java \\\n gnu/java/rmi/server/RMIHashes.java \\\n@@ -2462,8 +2465,10 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_HK.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_SG.P \\\n .deps/gnu/java/locale/LocaleInformation_zh_TW.P \\\n-.deps/gnu/java/math/MPN.P .deps/gnu/java/rmi/dgc/DGCImpl.P \\\n-.deps/gnu/java/rmi/dgc/DGCImpl_Skel.P \\\n+.deps/gnu/java/math/MPN.P \\\n+.deps/gnu/java/rmi/RMIMarshalledObjectInputStream.P \\\n+.deps/gnu/java/rmi/RMIMarshalledObjectOutputStream.P \\\n+.deps/gnu/java/rmi/dgc/DGCImpl.P .deps/gnu/java/rmi/dgc/DGCImpl_Skel.P \\\n .deps/gnu/java/rmi/dgc/DGCImpl_Stub.P \\\n .deps/gnu/java/rmi/registry/RegistryImpl.P \\\n .deps/gnu/java/rmi/registry/RegistryImpl_Skel.P \\\n@@ -2472,6 +2477,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/java/rmi/rmic/Compiler.P \\\n .deps/gnu/java/rmi/rmic/CompilerProcess.P \\\n .deps/gnu/java/rmi/rmic/RMIC.P .deps/gnu/java/rmi/rmic/TabbedWriter.P \\\n+.deps/gnu/java/rmi/server/ConnectionRunnerPool.P \\\n .deps/gnu/java/rmi/server/ProtocolConstants.P \\\n .deps/gnu/java/rmi/server/RMIDefaultSocketFactory.P \\\n .deps/gnu/java/rmi/server/RMIHashes.P \\\n@@ -3785,7 +3791,7 @@ maintainer-clean-recursive:\n \tdot_seen=no; \\\n \trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n \t  rev=\"$$subdir $$rev\"; \\\n-\t  test \"$$subdir\" != \".\" || dot_seen=yes; \\\n+\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n \tdone; \\\n \ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\"}, {"sha": "201722f80ca2f2ea64709d3139d68c982f7a25df", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "8835280a0e012057890638961e192af964469384", "filename": "libjava/gnu/java/rmi/RMIMarshalledObjectInputStream.java", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectInputStream.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -0,0 +1,70 @@\n+/* gnu.java.rmi.RMIMarshalledObjectInputStream\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.rmi;\n+\n+import gnu.java.rmi.server.RMIObjectInputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+import java.io.ByteArrayInputStream;\n+\n+/**\n+ * This class is only for java.rmi.MarshalledObject to deserialize object from \n+ * objBytes and locBytes\n+ */\n+\n+public class RMIMarshalledObjectInputStream extends RMIObjectInputStream\n+{\n+  private ObjectInputStream locStream;\n+  \n+  public RMIMarshalledObjectInputStream(byte[] objBytes, byte[] locBytes) throws IOException\n+  {\n+    super(new ByteArrayInputStream(objBytes));\n+    if(locBytes != null)\n+      locStream = new ObjectInputStream(new ByteArrayInputStream(locBytes));\n+  }\n+  \n+  //This method overrides RMIObjectInputStream's\n+  protected Object getAnnotation() throws IOException, ClassNotFoundException\n+  {\n+    if(locStream == null)\n+      return null;\n+    return locStream.readObject();\n+  }\n+  \n+} // End of RMIMarshalledObjectInputStream"}, {"sha": "66392919868bbf8a7c9834532743f42a91e21e52", "filename": "libjava/gnu/java/rmi/RMIMarshalledObjectOutputStream.java", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectOutputStream.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -0,0 +1,103 @@\n+/* gnu.java.rmi.RMIMarshalledObjectOutputStream\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.rmi;\n+\n+import java.io.OutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.rmi.Remote;\n+import java.rmi.server.ObjID;\n+import java.rmi.server.RemoteStub;\n+\n+import gnu.java.rmi.server.RMIObjectOutputStream;\n+import gnu.java.rmi.server.UnicastServerRef;\n+\n+/**\n+ * This class is only for java.rmi.MarshalledObject to serialize object and \n+ * got objBytes and locBytes\n+ */\n+public class RMIMarshalledObjectOutputStream extends RMIObjectOutputStream\n+{\n+  private ObjectOutputStream locStream;\n+  private ByteArrayOutputStream locBytesStream;\n+  \n+  public RMIMarshalledObjectOutputStream(OutputStream objStream) throws IOException\n+  {\n+    super(objStream);\n+  }\n+  \n+  //This method overrides RMIObjectOutputStream's.\n+  protected void setAnnotation(String annotation) throws IOException{\n+    synchronized(this){\n+      if(locStream == null){\n+\tlocBytesStream = new ByteArrayOutputStream();\n+\tlocStream = new ObjectOutputStream(locBytesStream);\n+      }\n+    }\n+    locStream.writeObject(annotation);\n+  }\n+  \n+  //This method overrides ObjectOutputStream's to replace Remote to RemoteStub \n+  protected Object replaceObject(Object obj) throws IOException\n+  {\n+    if((obj instanceof Remote) && !(obj instanceof RemoteStub))\n+      {\n+\tUnicastServerRef ref = new UnicastServerRef(new ObjID(), 0, null);\n+\ttry{\n+\t  return ref.exportObject((Remote)obj);\n+\t}catch(Exception e){}\n+      }\n+    return obj;\n+  }\n+  \n+  public void flush() throws IOException {\n+    super.flush();\n+    if(locStream != null)\n+      locStream.flush();\n+  }\n+  \n+  public byte[] getLocBytes(){\n+    if(locStream != null)\n+      return locBytesStream.toByteArray();\n+    return null;\n+  }\n+  \n+} // End of RMIMarshalledObjectOutputStream\n+"}, {"sha": "fba18c1715d53d4bced16420060b689d31f31a10", "filename": "libjava/gnu/java/rmi/dgc/DGCImpl.java", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -49,12 +49,16 @@\n public class DGCImpl\n \textends UnicastRemoteObject implements DGC {\n \n+private static final long leaseValue = 600000L;\n+\n public DGCImpl() throws RemoteException {\n \tsuper(new UnicastServerRef(new ObjID(ObjID.DGC_ID), 0, RMISocketFactory.getSocketFactory()));\n }\n \n public Lease dirty(ObjID[] ids, long sequenceNum, Lease lease) throws RemoteException {\n-\tSystem.out.println(\"DGCImpl.dirty - not implemented\");\n+\tVMID vmid = lease.getVMID();\n+    lease = new Lease(vmid, leaseValue);\n+\tSystem.out.println(\"DGCImpl.dirty - not completely implemented\");\n \treturn (lease);\n }\n "}, {"sha": "545ebc7bdea1a51c59328e963854c8159eb8d87a", "filename": "libjava/gnu/java/rmi/dgc/DGCImpl_Skel.java", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl_Skel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl_Skel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl_Skel.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,3 +1,41 @@\n+/* DGCImpl_Skel.java\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n // Skel class generated by rmic - DO NOT EDIT!\n \n package gnu.java.rmi.dgc;"}, {"sha": "bffde5280cd88e08b45776b11593ed5740296845", "filename": "libjava/gnu/java/rmi/dgc/DGCImpl_Stub.java", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl_Stub.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,3 +1,41 @@\n+/* DGCImpl_Stub.java\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n // Stub class generated by rmic - DO NOT EDIT!\n \n package gnu.java.rmi.dgc;"}, {"sha": "de6b9e426049a685d59ee7625f81c060242b22f3", "filename": "libjava/gnu/java/rmi/registry/RegistryImpl_Skel.java", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Skel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Skel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Skel.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,3 +1,41 @@\n+/* RegistryImpl_Skel.java\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n // Skel class generated by rmic - DO NOT EDIT!\n \n package gnu.java.rmi.registry;"}, {"sha": "33cb06a4b6892348e6d93eb76069711e88045db5", "filename": "libjava/gnu/java/rmi/registry/RegistryImpl_Stub.java", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Stub.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,3 +1,41 @@\n+/* RegistryImpl_Stub.java\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n // Stub class generated by rmic - DO NOT EDIT!\n \n package gnu.java.rmi.registry;"}, {"sha": "df6363bdcb6a58f1de34e8a22dfc837f721fd010", "filename": "libjava/gnu/java/rmi/server/ConnectionRunnerPool.java", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FConnectionRunnerPool.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FConnectionRunnerPool.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FConnectionRunnerPool.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -0,0 +1,154 @@\n+/* gnu.java.rmi.server.ConnectionRunnerPool\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.rmi.server;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+//Should I generalize this class?\n+\n+class ConnectionRunnerPool\n+{\n+  \n+  public static \n+    class ConnectionRunner extends Thread{\n+      private UnicastConnection conn;\n+      private volatile boolean exiting = false;\n+      \n+      public ConnectionRunner(ThreadGroup group, String id){\n+        super(group, id);\n+      }\n+      \n+      public synchronized void run(){\n+        while(!exiting){\n+\t  if(conn == null)\n+\t    try{\n+\t      wait();\n+\t    }catch(InterruptedException e){\n+\t      continue;\n+\t    }\n+\t  else{\n+\t    conn.run();\n+\t    conn = null;\n+\t    synchronized(ConnectionRunnerPool.class){\n+\t      freelist.add(this);\n+\t      if(freelist.size() == 1)\n+\t\tConnectionRunnerPool.class.notifyAll();\n+\t    }\n+\t  }    \n+        }\n+      }\n+      \n+      public synchronized void dispatch(UnicastConnection conn){\n+        this.conn = conn;\n+        notify();\n+      }\n+      \n+      void exit(){\n+        exiting = true;\n+        if(conn != null)\n+\t  try{\n+\t    join(500);\n+\t  }catch(InterruptedException e){}\n+        interrupt();\n+      }\n+      \n+    }\n+  \n+  private static int size = 5;\n+  private static int max_size = 10;\n+  \n+  private static ArrayList freelist;\n+  \n+  private static ThreadGroup group = new ThreadGroup(\"pool\");\n+  \n+  static {\n+    ConnectionRunner[] pools = new ConnectionRunner[size];\n+    for(int i = 0; i < pools.length; i++){\n+      pools[i] = new ConnectionRunner(group, new Integer(i).toString());\n+      pools[i].setContextClassLoader(Thread.currentThread().getContextClassLoader());\n+      pools[i].start();\n+    }\n+    freelist = new ArrayList(Arrays.asList(pools));\n+  }\n+  \n+  public static void setSize(int size_){\n+    size = size_;\n+  }\n+  \n+  public static void setMaxSize(int size){\n+    max_size = size;\n+  }\n+  \n+  private synchronized static ConnectionRunner getConnectionRunner()\n+  {\n+    if(freelist.size() == 0){\n+      if(size < max_size){\n+\t++size;\n+\tConnectionRunner a = new ConnectionRunner(group, new Integer(size).toString());\n+\ta.start();\n+\tfreelist.add(a);\n+      }else\n+\twhile(freelist.size() == 0)\n+\t  try{\n+\t    ConnectionRunnerPool.class.wait();\n+\t  }catch(InterruptedException e){}\n+    }\n+    \n+    // always let the first in pool most busy or other scheduling plan??\n+    ConnectionRunner a = (ConnectionRunner)freelist.get(0);\n+    freelist.remove(a);\n+    return a;\n+  }\n+  \n+  public static void dispatchConnection(UnicastConnection conn)\n+  {\n+    ConnectionRunner r = getConnectionRunner();\n+    r.dispatch(conn);\n+  }\n+  \n+  public static void exit()\n+  {\n+    Thread[] list = new Thread[group.activeCount()];\n+    group.enumerate(list);\n+    for(int i = 0; i < list.length; i++)\n+      ((ConnectionRunner)list[i]).exit();\n+  }\n+  \n+}"}, {"sha": "6e32724d50a4b11c46b653cdebb95cdc376e58cf", "filename": "libjava/gnu/java/rmi/server/RMIHashes.java", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIHashes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIHashes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIHashes.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -39,17 +39,61 @@\n \n import java.lang.reflect.Method;\n import java.lang.Class;\n-import gnu.java.security.provider.SHA;\n+import gnu.java.io.NullOutputStream;\n+import gnu.java.lang.reflect.TypeSignature;\n+import java.security.MessageDigest;\n+import java.security.DigestOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.ByteArrayOutputStream;\n \n public class RMIHashes\n {\n+  //There're other places using DigestOutputStream to generate hash in classpath, but I think the way I used\n+  //here is more efficient, anyway, you can switch to DigestOutputStream by doing like \"//or:\" comments say.\n+  \n+  //or:add this statement: private static final NullOutputStream nullOutputStream = new NullOutputStream ();\n   public static long getMethodHash(Method meth)\n   {\n-    return meth.hashCode ();\n+    //Object Serialization Spec 8.3\n+    try\n+    {\n+        MessageDigest md = MessageDigest.getInstance (\"SHA\");\n+        //or:remove this statement: DigestOutputStream digest_out = new DigestOutputStream (nullOutputStream, md);\n+        ByteArrayOutputStream digest_out = new ByteArrayOutputStream();\n+        DataOutputStream data_out = new DataOutputStream (digest_out);\n+        \n+        StringBuffer sbuf = new StringBuffer();\n+        sbuf.append(meth.getName());\n+        sbuf.append('(');\n+        Class params[] = meth.getParameterTypes();\n+        for(int i = 0; i < params.length; i++)\n+            sbuf.append(TypeSignature.getEncodingOfClass(params[i]));\n+        sbuf.append(')');\n+        Class rcls = meth.getReturnType();\n+        if(rcls != Void.TYPE)\n+            sbuf.append(TypeSignature.getEncodingOfClass(rcls));\n+        else\n+            sbuf.append('V');\n+        \n+        data_out.writeUTF (sbuf.toString());\n+        data_out.flush();\n+        data_out.close ();\n+\n+        md.update(digest_out.toByteArray()); //or:remove this statement\n+        byte[] sha = md.digest ();\n+        long result = 0;\n+        int len = sha.length < 8 ? sha.length : 8;\n+        for (int i=0; i < len; i++)\n+            result += (long)(sha[i] & 0xFF) << (8 * i);\n+        return result;\n+    }catch(Exception _){\n+        return -1L;\n+        }\n   }\n \n   public static long getInterfaceHash(Class clazz)\n   {\n     return clazz.hashCode ();\n   }\n }\n+"}, {"sha": "5913e9221bf28ff935c9a8ef35705cb42c510ca7", "filename": "libjava/gnu/java/rmi/server/RMIObjectInputStream.java", "status": "modified", "additions": 73, "deletions": 11, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectInputStream.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -44,6 +44,8 @@\n import java.net.URL;\n import java.net.MalformedURLException;\n import java.rmi.server.RMIClassLoader;\n+import java.lang.ClassNotFoundException;\n+import java.lang.reflect.Proxy;\n \n public class RMIObjectInputStream\n \textends ObjectInputStream {\n@@ -56,20 +58,80 @@ public RMIObjectInputStream(InputStream strm, UnicastConnectionManager man) thro\n \tenableResolveObject(true);\n }\n \n+public RMIObjectInputStream(InputStream strm) throws IOException {\n+\tthis(strm, UnicastConnectionManager.getInstance(0, null));\n+}\n+\n protected Class resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n-//System.out.println(\"Resolving class: \" + desc.getName());\n-\tString annotation = (String)readObject();\n-\tif (annotation == null) {\n-\t\treturn (super.resolveClass(desc));\n+\tString annotation = (String)getAnnotation();\n+\ttry{\n+\t\treturn super.resolveClass(desc);\n+\t}catch(ClassNotFoundException _){};\n+\t\n+\ttry {\n+\t\tif(annotation == null)\n+\t\t    return (RMIClassLoader.loadClass(desc.getName()));\n+\t\telse\n+\t\t    return (RMIClassLoader.loadClass(annotation, desc.getName()));\n \t}\n-\telse {\n-\t\ttry {\n-\t\t\treturn (RMIClassLoader.loadClass(new URL(annotation), desc.getName()));\n-\t\t}\n-\t\tcatch (MalformedURLException _) {\n-\t\t\tthrow new ClassNotFoundException(desc.getName());\n-\t\t}\n+\tcatch (MalformedURLException _) {\n+\t\tthrow new ClassNotFoundException(desc.getName());\n \t}\n }\n \n+//Separate it for override by MarshalledObject\n+protected Object getAnnotation()\n+\t    throws IOException, ClassNotFoundException\n+{\n+    return readObject();\n+}\n+\t\n+protected Class resolveProxyClass(String intfs[])\n+        throws IOException, ClassNotFoundException\n+{\n+    String annotation = (String)getAnnotation();\n+    try{\n+\t\treturn super.resolveProxyClass(intfs);\n+\t}catch(ClassNotFoundException _){};\n+\t\n+    Class clss[] = new Class[intfs.length];\n+    if(annotation == null)\n+        clss[0] = RMIClassLoader.loadClass(intfs[0]);\n+    else\n+        clss[0] = RMIClassLoader.loadClass(annotation, intfs[0]);\n+    //assume all interfaces can be loaded by the same classloader\n+    ClassLoader loader = clss[0].getClassLoader();\n+    if(loader == null)\n+        for(int i = 1; i < intfs.length; i++)\n+            clss[i] = Class.forName(intfs[i]);    \n+    else\n+        for(int i = 1; i < intfs.length; i++)\n+            clss[i] = loader.loadClass(intfs[i]);    \n+    return Proxy.getProxyClass(loader, clss);\n+}\n+\n+protected Object readValue(Class valueClass) throws IOException, ClassNotFoundException {\n+    if(valueClass.isPrimitive()){\n+        if(valueClass == Boolean.TYPE)\n+            return new Boolean(readBoolean());\n+        if(valueClass == Byte.TYPE)\n+            return new Byte(readByte());\n+        if(valueClass == Character.TYPE)\n+            return new Character(readChar());\n+        if(valueClass == Short.TYPE)\n+            return new Short(readShort());\n+        if(valueClass == Integer.TYPE)\n+            return new Integer(readInt());\n+        if(valueClass == Long.TYPE)\n+            return new Long(readLong());\n+        if(valueClass == Float.TYPE)\n+            return new Float(readFloat());\n+        if(valueClass == Double.TYPE)\n+            return new Double(readDouble());\n+        else\n+            throw new Error(\"Unsupported primitive class: \" + valueClass);\n+    } else\n+        return readObject();\n }\n+\n+}\n\\ No newline at end of file"}, {"sha": "71a2bac9dede74d3166d5758b300bce615f864ce", "filename": "libjava/gnu/java/rmi/server/RMIObjectOutputStream.java", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectOutputStream.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -41,17 +41,74 @@\n import java.io.OutputStream;\n import java.io.IOException;\n import java.rmi.server.RMIClassLoader;\n+import java.rmi.Remote;\n+import java.rmi.server.RemoteStub;\n+import java.rmi.server.ObjID;\n \n public class RMIObjectOutputStream\n \textends ObjectOutputStream {\n \n public RMIObjectOutputStream(OutputStream strm) throws IOException {\n \tsuper(strm);\n+\tenableReplaceObject(true);\n+}\n+\n+//Separate it for override by MarshalledObject\n+protected void setAnnotation(String annotation) throws IOException{\n+    writeObject(annotation);\n }\n \n protected void annotateClass(Class cls) throws IOException {\n-//System.out.println(\"Annotating class: \" + cls);\n-\twriteObject(RMIClassLoader.getClassAnnotation(cls));\n+\tsetAnnotation(RMIClassLoader.getClassAnnotation(cls));\n+}\n+\n+protected void annotateProxyClass(Class cls)\n+        throws IOException\n+{\n+    annotateClass(cls);\n+}\n+    \n+protected Object replaceObject(Object obj)\n+        throws IOException\n+{\n+    if((obj instanceof Remote) && !(obj instanceof RemoteStub)){\n+\t    UnicastServerRef ref = new UnicastServerRef(new ObjID(), 0, null);\n+\t\ttry{\n+\t\t    return ref.exportObject((Remote)obj);\n+\t\t}catch(Exception e){}\n+    }\n+    return obj;\n+}\n+\n+protected void writeValue(Object value, Class valueClass) throws IOException{\n+    if(valueClass.isPrimitive()){\n+        if(valueClass == Boolean.TYPE)\n+            writeBoolean(((Boolean)value).booleanValue());\n+        else\n+        if(valueClass == Byte.TYPE)\n+            writeByte(((Byte)value).byteValue());\n+        else\n+        if(valueClass == Character.TYPE)\n+            writeChar(((Character)value).charValue());\n+        else\n+        if(valueClass == Short.TYPE)\n+            writeShort(((Short)value).shortValue());\n+        else\n+        if(valueClass == Integer.TYPE)\n+            writeInt(((Integer)value).intValue());\n+        else\n+        if(valueClass == Long.TYPE)\n+            writeLong(((Long)value).longValue());\n+        else\n+        if(valueClass == Float.TYPE)\n+            writeFloat(((Float)value).floatValue());\n+        else\n+        if(valueClass == Double.TYPE)\n+            writeDouble(((Double)value).doubleValue());\n+        else\n+            throw new Error(\"Unsupported primitive class: \" + valueClass);\n+    } else\n+        writeObject(value);\n }\n \n }"}, {"sha": "e13bb6862299ae3d456cf04974793e3a01ad513a", "filename": "libjava/gnu/java/rmi/server/UnicastConnection.java", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnection.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -44,6 +44,8 @@\n import java.io.DataOutputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n import java.io.ObjectOutput;\n import java.io.ObjectInput;\n import java.io.IOException;\n@@ -65,9 +67,10 @@ public class UnicastConnection\n }\n \n void acceptConnection() throws IOException {\n-//System.out.println(\"Accepting connection on \" + lport);\n-\tdin = new DataInputStream(sock.getInputStream());\n-\tdout = new DataOutputStream(sock.getOutputStream());\n+//System.out.println(\"Accepting connection on \" + sock);\n+    //Use BufferedXXXStream would be more efficient\n+\tdin = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n+\tdout = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n \n \tint sig = din.readInt();\n \tif (sig != PROTOCOL_HEADER) {\n@@ -85,6 +88,7 @@ void acceptConnection() throws IOException {\n \t\t// Send my hostname and port\n \t\tdout.writeUTF(manager.serverName);\n \t\tdout.writeInt(manager.serverPort);\n+\t\tdout.flush();\n \n \t\t// Read their hostname and port\n \t\tString rhost = din.readUTF();\n@@ -94,15 +98,16 @@ void acceptConnection() throws IOException {\n }\n \n void makeConnection(int protocol) throws IOException {\n-\tdout = new DataOutputStream(sock.getOutputStream());\n-\tdin = new DataInputStream(sock.getInputStream());\n+    //Use BufferedXXXStream would be more efficient\n+\tdin = new DataInputStream(new BufferedInputStream(sock.getInputStream()));\n+\tdout = new DataOutputStream(new BufferedOutputStream(sock.getOutputStream()));\n \n \t// Send header\n \tdout.writeInt(PROTOCOL_HEADER);\n \tdout.writeShort(PROTOCOL_VERSION);\n \tdout.writeByte(protocol);\n-\tdout.flush();\n-\n+    dout.flush();\n+    \n \tif (protocol != SINGLE_OP_PROTOCOL) {\n \t\t// Get back ack.\n \t\tint ack = din.readUnsignedByte();\n@@ -117,6 +122,7 @@ void makeConnection(int protocol) throws IOException {\n \t\t// Send them my endpoint\n \t\tdout.writeUTF(manager.serverName);\n \t\tdout.writeInt(manager.serverPort);\n+\t\tdout.flush();\n \t}\n \t// Okay, ready to roll ...\n }\n@@ -144,13 +150,15 @@ ObjectOutputStream getObjectOutputStream() throws IOException {\n }\n \n void disconnect() {\n-\toin = null;\n-\toout = null;\n \ttry {\n-\t\tsock.close();\n+\t    if(oout != null)\n+\t        oout.close();\n \t}\n \tcatch (IOException _) {\n-\t}\n+    }\n+\n+\toin = null;\n+    oout = null;\n \tdin = null;\n \tdout = null;\n \tsock = null;"}, {"sha": "64fecdce2a047777691037b2df62b917da7d581f", "filename": "libjava/gnu/java/rmi/server/UnicastConnectionManager.java", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnectionManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnectionManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnectionManager.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -57,9 +57,12 @@\n \timplements Runnable, ProtocolConstants {\n \n private static String localhost;\n+// use different maps for server/client type UnicastConnectionManager\n private static Hashtable servers = new Hashtable();\n+private static Hashtable clients = new Hashtable();\n \n-private Thread serverThread;\n+// make serverThread volatile for poll\n+private volatile Thread serverThread;\n private ServerSocket ssock;\n String serverName;\n int serverPort;\n@@ -68,7 +71,9 @@\n \n static {\n         try {\n-                localhost = InetAddress.getLocalHost().getHostName();\n+                //Use host address instead of host name to avoid name resolving issues\n+                //localhost = InetAddress.getLocalHost().getHostName();\n+                localhost = InetAddress.getLocalHost().getHostAddress();\n         }\n         catch (UnknownHostException _) {\n                 localhost = \"localhost\";\n@@ -112,11 +117,16 @@ public static synchronized UnicastConnectionManager getInstance(String host, int\n \tif (csf == null) {\n \t\tcsf = RMISocketFactory.getSocketFactory();\n \t}\n+\t// change host name to host address to avoid name resolving issues\n+\ttry{\n+    \thost = InetAddress.getByName(host).getHostAddress();\n+    }catch(Exception _){}\n+    \n \tTripleKey key = new TripleKey(host, port, csf);\n-\tUnicastConnectionManager man = (UnicastConnectionManager)servers.get(key);\n+\tUnicastConnectionManager man = (UnicastConnectionManager)clients.get(key);\n \tif (man == null) {\n \t\tman = new UnicastConnectionManager(host, port, csf);\n-\t\tservers.put(key, man);\n+\t\tclients.put(key, man);\n \t}\n \treturn (man);\n }\n@@ -198,18 +208,34 @@ public void startServer() {\n \tserverThread.start();\n }\n \n+/**\n+ * Stop a server on this manager\n+ */\n+public void stopServer() {\n+    synchronized(this) {\n+    \tif(serverThread != null){\n+    \t    serverThread = null;\n+    \t    try{\n+    \t        ssock.close();\n+    \t    }catch(Exception _){}\n+    \t}\n+    }\n+}\n+\n /**\n  * Server thread for connection manager.\n  */\n public void run() {\n-\tfor (;;) {\n+\tfor (;serverThread != null;) { // if serverThread==null, then exit thread\n \t\ttry {\n //System.out.println(\"Waiting for connection on \" + serverPort);\n \t\t\tUnicastConnection conn = getServerConnection();\n-\t\t\t(new Thread(conn)).start();\n+\t\t\t// use a thread pool to improve performance\n+\t\t\t// (new Thread(conn)).start();\n+\t\t\tConnectionRunnerPool.dispatchConnection(conn);\n \t\t}\n \t\tcatch (Exception e) {\n-\t\t\te.printStackTrace();\n+\t\t\t// e.printStackTrace();\n \t\t}\n \t}\n }"}, {"sha": "d6cda49c600f8933d1b93edb44416f927c37b7b7", "filename": "libjava/gnu/java/rmi/server/UnicastRef.java", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -107,6 +107,7 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n \t\tobjid.write(out);\n \t\tout.writeInt(opnum);\n \t\tout.writeLong(hash);\n+\t\t/*\n \t\tif (params != null) {\n \t\t\tfor (int i = 0; i < params.length; i++) {\n \t\t\t\tif (params[i] instanceof UnicastRemoteObject) {\n@@ -117,6 +118,11 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\t*/\n+\t\t// must handle primitive class and their wrapper classes\n+\t\tClass clss[] = method.getParameterTypes();\n+\t    for(int i = 0; i < clss.length; i++)\n+\t        ((RMIObjectOutputStream)out).writeValue(params[i], clss[i]);\n \n \t\tout.flush();\n \t}\n@@ -139,12 +145,25 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n \n \t\treturncode = in.readUnsignedByte();\n \t\tack = UID.read(in);\n-\t\treturnval = in.readObject();\n+\t\t//returnval = in.readObject();\n+\t\tClass cls = method.getReturnType();\n+        if(cls == Void.TYPE){\n+            returnval = null;\n+        }else\n+            returnval = ((RMIObjectInputStream)in).readValue(cls);\n \t}\n \tcatch (IOException e3) {\n \t\tthrow new RemoteException(\"call return failed: \", e3);\n \t}\n \n+    /* if DGCAck is necessary\n+    //According to RMI wire protocol, send a DGCAck \n+    // to indicate receiving return value\n+    dout.writeByte(MESSAGE_DGCACK);\n+    ack.write(dout);\n+    out.flush();\n+    */\n+    \n \tmanager.discardConnection(conn);\n \n \tif (returncode != RETURN_ACK) {\n@@ -183,13 +202,16 @@ public void writeExternal(ObjectOutput out) throws IOException {\n \t}\n \tmanager.write(out);\n \tobjid.write(out);\n-\tout.writeByte(RETURN_ACK);\n+\t// This byte is somewhat confusing when interoperating with JDK\n+\tout.writeByte(0); //RETURN_ACK);\n }\n \n public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n \tmanager = UnicastConnectionManager.read(in);\n \tobjid = ObjID.read(in);\n-\tif (in.readByte() != RETURN_ACK) {\n+\tbyte ack = in.readByte();\n+\t// This byte is somewhat confusing when interoperating with JDK\n+\tif (ack != RETURN_ACK && ack != 0/*jdk ack value*/) {\n \t\tthrow new IOException(\"no ack found\");\n \t}\n }"}, {"sha": "15c622f48bc4e3c1ec9e347f72a49e9e404c3c13", "filename": "libjava/gnu/java/rmi/server/UnicastServer.java", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServer.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -65,6 +65,13 @@ public static void exportObject(UnicastServerRef obj) {\n \tobj.manager.startServer();\n }\n \n+// FIX ME: I haven't handle force parameter\n+public static boolean unexportObject(UnicastServerRef obj, boolean force) {\n+\tobjects.remove(obj.objid);\n+\tobj.manager.stopServer();\n+\treturn true;\n+}\n+\n private static synchronized void startDGC() {\n \tif (dgc == null) {\n \t\ttry {\n@@ -100,10 +107,14 @@ private static void incomingMessageCall(UnicastConnection conn) throws IOExcepti\n \tUnicastServerRef uref = (UnicastServerRef)objects.get(objid);\n \tObject returnval;\n \tint returncode = RETURN_ACK;\n+\t// returnval is from Method.invoke(), so we must check the return class to see\n+\t// if it's primitive type\n+\tClass returncls = null;\n \tif (uref != null) {\n \t\ttry {\n \t\t\t// Dispatch the call to it.\n \t\t\treturnval = uref.incomingMessageCall(conn, method, hash);\n+\t\t\treturncls = uref.getMethodReturnType(method, hash);\n \t\t}\n \t\tcatch (Exception e) {\n \t\t\treturnval = e;\n@@ -121,7 +132,10 @@ private static void incomingMessageCall(UnicastConnection conn) throws IOExcepti\n \n \tout.writeByte(returncode);\n \t(new UID()).write(out);\n-\tout.writeObject(returnval);\n+\tif(returnval != null && returncls != null)\n+\t    ((RMIObjectOutputStream)out).writeValue(returnval, returncls);\n+\telse\n+\t    out.writeObject(returnval);\n \n \tout.flush();\n }"}, {"sha": "196f969d292609afddb950283cc987342a7f3c68", "filename": "libjava/gnu/java/rmi/server/UnicastServerRef.java", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServerRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServerRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServerRef.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -66,14 +66,15 @@\n import java.util.Hashtable;\n \n public class UnicastServerRef\n-\textends UnicastRef {\n+\textends UnicastRef \n+\timplements ServerRef{ //SHOULD implement ServerRef\n \n final static private Class[] stubprototype = new Class[] { RemoteRef.class };\n \n Remote myself;\n private Skeleton skel;\n private RemoteStub stub;\n-private Hashtable methods;\n+private Hashtable methods = new Hashtable();\n \n public UnicastServerRef(ObjID id, int port, RMIServerSocketFactory ssf) {\n \tsuper(id);\n@@ -95,7 +96,7 @@ public RemoteStub exportObject(Remote obj) throws RemoteException {\n \t\tskel = (Skeleton)getHelperClass(cls, \"_Skel\");\n \n \t\t// Build hash of methods which may be called.\n-\t\tbuildMethodHash(obj.getClass());\n+\t\tbuildMethodHash(obj.getClass(), true);\n \n \t\t// Export it.\n \t\tUnicastServer.exportObject(this);\n@@ -104,10 +105,25 @@ public RemoteStub exportObject(Remote obj) throws RemoteException {\n \treturn (stub);\n }\n \n+public RemoteStub exportObject(Remote remote, Object obj)\n+        throws RemoteException\n+{\n+    //FIX ME\n+\treturn exportObject(remote);\n+}\n+\n+\n+public boolean unexportObject(Remote obj, boolean force) throws RemoteException {\n+    // Remove all hashes of methods which may be called.\n+    buildMethodHash(obj.getClass(), false);\n+    return UnicastServer.unexportObject(this, force);\n+}\n+\n private Object getHelperClass(Class cls, String type) {\n \ttry {   \n-\t\tString classname = cls.getName();\n-\t\tClass scls = Class.forName(classname + type);\n+\t    String classname = cls.getName();\n+\t\tClassLoader cl = cls.getClassLoader(); //DONT use \"Class scls = Class.forName(classname + type);\"\n+\t\tClass scls = cl.loadClass(classname + type);\n \t\tif (type.equals(\"_Stub\")) {\n \t\t\ttry {\n \t\t\t\t// JDK 1.2 stubs\n@@ -147,20 +163,31 @@ public String getClientHost() throws ServerNotActiveException {\n \tthrow new Error(\"Not implemented\");\n }\n \n-private void buildMethodHash(Class cls) {\n-\tmethods = new Hashtable();\n+private void buildMethodHash(Class cls, boolean build) {\n \tMethod[] meths = cls.getMethods();\n \tfor (int i = 0; i < meths.length; i++) {\n \t\t/* Don't need to include any java.xxx related stuff */\n \t\tif (meths[i].getDeclaringClass().getName().startsWith(\"java.\")) {\n \t\t\tcontinue;\n \t\t}\n \t\tlong hash = RMIHashes.getMethodHash(meths[i]);\n-\t\tmethods.put(new Long (hash), meths[i]);\n+\t\tif(build)\n+\t\t    methods.put(new Long (hash), meths[i]);\n+\t\telse\n+\t\t    methods.remove(new Long (hash));\n //System.out.println(\"meth = \" + meths[i] + \", hash = \" + hash);\n \t}\n }\n \n+Class getMethodReturnType(int method, long hash) throws Exception\n+{\n+    if (method == -1) {\n+        Method meth = (Method)methods.get(new Long (hash));\n+        return meth.getReturnType();\n+    }else\n+        return null;\n+}\n+\n public Object incomingMessageCall(UnicastConnection conn, int method, long hash) throws Exception {\n //System.out.println(\"method = \" + method + \", hash = \" + hash);\n \t// If method is -1 then this is JDK 1.2 RMI - so use the hash\n@@ -189,7 +216,15 @@ public Object incomingMessageCall(UnicastConnection conn, int method, long hash)\n \t\t\t\tthrow t;\n \t\t\t}\n \t\t}\n-\t\treturn (meth.invoke(myself, args));\n+\t\t//We must reinterpret the exception thrown by meth.invoke()\n+\t\t//return (meth.invoke(myself, args));\n+\t\tObject ret = null;\n+\t\ttry{\n+\t\t    ret = meth.invoke(myself, args);\n+\t\t}catch(InvocationTargetException e){\n+\t\t    throw (Exception)(e.getTargetException());\n+\t\t}\n+\t\treturn ret;\n \t}\n \t// Otherwise this is JDK 1.1 style RMI - we find the skeleton\n \t// and invoke it using the method number.  We wrap up our"}, {"sha": "1deb2b46dc3c4b357e7b2e62236971c3dccc32c2", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}, {"sha": "08ce401fad822bc0337545aae9012376ad1d23bf", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,5 +1,5 @@\n /* ObjectInputStream.java -- Class used to read serialized objects\n-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -42,6 +42,7 @@\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Modifier;\n+import java.lang.reflect.Proxy;\n import java.util.Arrays;\n import java.util.Hashtable;\n import java.util.Vector;\n@@ -527,6 +528,32 @@ protected Object resolveObject (Object obj) throws IOException\n   }\n \n \n+  protected Class resolveProxyClass (String[] intfs)\n+    throws IOException, ClassNotFoundException\n+  {\n+    SecurityManager sm = System.getSecurityManager ();\n+    \n+    if (sm == null)\n+      sm = new SecurityManager () {};\n+    \n+    ClassLoader cl = currentClassLoader (sm);\n+    \n+    Class[] clss = new Class[intfs.length];\n+    if(cl == null){\n+      for (int i = 0; i < intfs.length; i++)\n+\tclss[i] = Class.forName(intfs[i]);\n+      cl = ClassLoader.getSystemClassLoader();\n+    }\n+    else\n+      for (int i = 0; i < intfs.length; i++)\n+\tclss[i] = cl.loadClass(intfs[i]);\n+    try {\n+      return Proxy.getProxyClass(cl, clss);\n+    } catch (IllegalArgumentException e) {\n+      throw new ClassNotFoundException(null, e);\n+    }\n+  }\n+  \n   /**\n      If <code>enable</code> is <code>true</code> and this object is\n      trusted, then <code>resolveObject (Object)</code> will be called"}, {"sha": "4c9a9ccdb403da2a21a0759e5e4adb230f2ca531", "filename": "libjava/java/rmi/MarshalledObject.java", "status": "modified", "additions": 66, "deletions": 17, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2FMarshalledObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2FMarshalledObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2FMarshalledObject.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -38,24 +38,73 @@\n package java.rmi;\n \n import java.io.Serializable;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import gnu.java.rmi.RMIMarshalledObjectInputStream;\n+import gnu.java.rmi.RMIMarshalledObjectOutputStream;\n \n+/**\n+ * FIXME - doc missing\n+ */\n public final class MarshalledObject\n-\textends Object implements Serializable {\n-\n-public MarshalledObject(Object obj) {\n-\tthrow new Error(\"Not implemented\");\n-}\n-\n-public boolean equals(Object obj) {\n-\tthrow new Error(\"Not implemented\");\n-}\n-\n-public Object get() {\n-\tthrow new Error(\"Not implemented\");\n-}\n-\n-public int hashCode() {\n-\tthrow new Error(\"Not implemented\");\n+  extends Object implements Serializable \n+{\n+  \n+  //The following fields are from Java API Documentation \"Serialized form\"\n+  private static final long serialVersionUID = 8988374069173025854L;\n+  byte[] objBytes;\n+  byte[] locBytes;\n+  int hash;\n+  \n+  public MarshalledObject(Object obj) throws java.io.IOException\n+  {\n+    ByteArrayOutputStream objStream = new ByteArrayOutputStream();\n+    RMIMarshalledObjectOutputStream stream = new RMIMarshalledObjectOutputStream(objStream);\n+    stream.writeObject(obj);\n+    stream.flush();\n+    objBytes = objStream.toByteArray();\n+    locBytes = stream.getLocBytes();\n+    \n+    //The following algorithm of calculating hashCode is similar to String\n+    hash = 0;\n+    for (int i = 0; i < objBytes.length; i++)\n+      hash = hash * 31 + objBytes[i];\n+    if(locBytes != null)\n+      for (int i = 0; i < locBytes.length; i++)\n+\thash = hash * 31 + locBytes[i];\n+  }\n+  \n+  public boolean equals(Object obj) \n+  {\n+    if(obj == null || !(obj instanceof MarshalledObject) )\n+      return false;\n+    \n+    MarshalledObject aobj = (MarshalledObject)obj;\n+    if (objBytes == null || aobj.objBytes == null)\n+      return objBytes == aobj.objBytes;\n+    if (objBytes.length != aobj.objBytes.length)\n+      return false;\n+    for (int i = 0; i < objBytes.length; i++) \n+      {\n+\tif (objBytes[i] != aobj.objBytes[i])\n+\t  return false;\n+      }\n+    // Ignore comparison of locBytes(annotation)\n+    return true;\n+  }\n+  \n+public Object get() \n+  throws java.io.IOException, java.lang.ClassNotFoundException\n+{\n+  if(objBytes == null)\n+    return null;\n+  RMIMarshalledObjectInputStream stream = \n+    new RMIMarshalledObjectInputStream(objBytes, locBytes);\n+  return stream.readObject();\n }\n-\n+  \n+  public int hashCode() {\n+    return hash;\n+  }\n+  \n }"}, {"sha": "da8f52c7ce97bbcc5c1b54767993949c39c0e0e9", "filename": "libjava/java/rmi/server/RMIClassLoader.java", "status": "modified", "additions": 114, "deletions": 35, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2Fserver%2FRMIClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2Fserver%2FRMIClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2Fserver%2FRMIClassLoader.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -39,21 +39,25 @@\n \n import java.net.URL;\n import java.net.URLConnection;\n+import java.net.URLClassLoader;\n import java.io.IOException;\n import java.io.DataInputStream;\n import java.net.MalformedURLException;\n import java.util.StringTokenizer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.ArrayList;\n \n public class RMIClassLoader\n {\n \n-  static private class MyClassLoader extends ClassLoader\n+  static private class MyClassLoader extends URLClassLoader\n   {\n-    /**\n-     * Non-private constructor to reduce bytecode emitted.\n-     */\n-    MyClassLoader()\n+    private MyClassLoader(URL[] urls, ClassLoader parent)\n     {\n+      super (urls, parent);\n     }\n \n     Class defineClass(String name, byte[] data)\n@@ -62,58 +66,133 @@ Class defineClass(String name, byte[] data)\n     }\n   }\n \n-  static private MyClassLoader loader = new MyClassLoader();\n-\n+  private static Map cacheLoaders; //map annotations to loaders\n+  private static Map cacheClasses; //map loader to classes that the loader loaded+\n+  private static String defaultAnnotation;\n+  private static URL defaultCodebase;\n+  private static MyClassLoader defaultLoader;\n+  \n+  static\n+  {\n+    cacheLoaders = Collections.synchronizedMap(new WeakHashMap(5)); \n+    cacheClasses = Collections.synchronizedMap(new WeakHashMap(5));\n+    defaultAnnotation = System.getProperty(\"java.rmi.server.defaultAnnotation\");\n+    try \n+      {\n+\tif (defaultAnnotation != null)\n+\t  defaultCodebase = new URL(defaultAnnotation);\n+      }\n+    catch(Exception _)\n+      {\n+\tdefaultCodebase = null;\n+      }\n+    if (defaultCodebase != null)\n+      {\n+        defaultLoader = new MyClassLoader(new URL[]{ defaultCodebase },\n+\t\t\t\t\t  Thread.currentThread().getContextClassLoader());\n+        cacheLoaders.put(defaultAnnotation, defaultLoader);\n+        cacheClasses.put(defaultLoader, Collections.synchronizedMap(new WeakHashMap())); \n+      }\n+  }\n+  \n   /**\n    * @deprecated\n    */\n   public static Class loadClass(String name)\n     throws MalformedURLException, ClassNotFoundException\n   {\n-    return loadClass(System.getProperty(\"java.rmi.server.codebase\"), name);\n+    return (loadClass(\"\", name));\n   }\n \n-  public static Class loadClass(URL codebase, String name)\n-    throws MalformedURLException, ClassNotFoundException\n+  public static Class loadClass(URL codebase, String name) \n+    throws MalformedURLException, ClassNotFoundException \n   {\n     URL u = new URL(codebase, name + \".class\");\n-    try\n+    try \n       {\n-        URLConnection conn = u.openConnection();\n-        DataInputStream strm = new DataInputStream(conn.getInputStream());\n-        byte data[] = new byte[conn.getContentLength()];\n-        strm.readFully(data);\n-        return loader.defineClass(name, data);\n+\tURLConnection conn = u.openConnection();\n+\tDataInputStream strm = new DataInputStream(conn.getInputStream());\n+\tbyte data[] = new byte[conn.getContentLength()];\n+\tstrm.readFully(data);\n+\treturn (defaultLoader.defineClass(name, data));\n       }\n-    catch (IOException _)\n+    catch (IOException _) \n       {\n-        throw new ClassNotFoundException(name);\n+\tthrow new ClassNotFoundException(name);\n       }\n   }\n-\n-  public static Class loadClass(String codebase, String name)\n-    throws MalformedURLException, ClassNotFoundException\n+  \n+  public static Class loadClass(String codebases, String name) \n+    throws MalformedURLException, ClassNotFoundException \n   {\n-    StringTokenizer tok = new StringTokenizer(codebase, \":\");\n-    while (tok.hasMoreTokens())\n+    ClassLoader loader = (ClassLoader)cacheLoaders.get(codebases);\n+    if (loader == null)\n       {\n-        try\n-          {\n-            return loadClass(new URL(tok.nextToken()), name);\n-          }\n-        catch (ClassNotFoundException _)\n-          {\n-            // Ignore - try the next one.\n-          }\n+\tif (codebases != \"\")\n+\t  {\n+\t    //codebases are separated by \" \"\n+\t    StringTokenizer tok = new StringTokenizer(codebases, \" \"); \n+\t    ArrayList urls = new ArrayList();\n+\t    while (tok.hasMoreTokens())\n+\t      urls.add(new URL(tok.nextToken()));\n+\t    \n+\t    loader = new MyClassLoader((URL[])urls.toArray(new URL[urls.size()]),\n+\t\t\t\t       Thread.currentThread().getContextClassLoader());\n+\t    cacheLoaders.put(codebases, loader);\n+\t    cacheClasses.put(loader, Collections.synchronizedMap(new WeakHashMap())); \n+\t  }\n+\telse\n+\t  {\n+\t    //if codebases is empty, construct a classloader \n+\t    // based on current context classloader,\n+\t    // and we won't cache classloader for empty codebases\n+\t    loader = new MyClassLoader(new URL[]{ defaultCodebase },\n+\t\t\t\t       Thread.currentThread().getContextClassLoader());\n+\t  }\n       }\n-    throw new ClassNotFoundException(name);\n-  }\n \n+    Class c = null;\n+    Map classes = (Map)cacheClasses.get(loader);\n+    if (classes != null)\n+      {\n+        c = (Class)classes.get(name);\n+        if (c == null)\n+\t  {\n+            c = loader.loadClass(name);\n+            classes.put(name, c); \n+\t  }\n+      }else\n+        c = loader.loadClass(name);\n+    \n+    return c;\n+  }\n+  \n   public static String getClassAnnotation(Class cl)\n   {\n-    return null; // We don't yet do this.\n+    ClassLoader loader = cl.getClassLoader();\n+    if (loader == null)\n+      {\n+\tif (defaultCodebase != null)\n+\t  return defaultCodebase.toExternalForm();\n+\telse\n+\t  return null;\n+      }\n+    if (loader instanceof URLClassLoader)\n+      {\n+\tURL[] urls = ((URLClassLoader)loader).getURLs();\n+\tif(urls.length == 0)\n+\t  return null;\n+\tStringBuffer annotation = new StringBuffer(urls[0].toExternalForm());\n+\tfor(int i = 1; i < urls.length; i++)\n+\t  {\n+\t    annotation.append(' ');\n+\t    annotation.append(urls[i].toExternalForm());\n+\t  }\n+\treturn annotation.toString();\n+      }\n+    return null;\n   }\n-\n+  \n   /**\n    * @deprecated\n    */"}, {"sha": "8ae93ff8844c6ec253b7bb6976b45b72852eb21b", "filename": "libjava/java/rmi/server/RemoteObject.java", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2Fserver%2FRemoteObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2Fserver%2FRemoteObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2Fserver%2FRemoteObject.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -48,6 +48,7 @@\n import java.lang.ClassNotFoundException;\n import java.lang.InstantiationException;\n import java.lang.IllegalAccessException;\n+import java.lang.reflect.Constructor;\n \n public abstract class RemoteObject\n \timplements Remote, Serializable {\n@@ -68,9 +69,22 @@ public RemoteRef getRef() {\n \treturn (ref);\n }\n \n-public static Remote toStub(Remote obj) throws NoSuchObjectException {\n-\tthrow new Error(\"Not implemented\");\n-}\n+  public static Remote toStub(Remote obj) throws NoSuchObjectException \n+  {\n+    Class cls = obj.getClass();\n+    String classname = cls.getName();\n+    ClassLoader cl = cls.getClassLoader();\n+    try \n+      {\n+\tClass scls = cl.loadClass(classname + \"_Stub\");\n+\t// JDK 1.2 stubs\n+\tClass[] stubprototype = new Class[] { RemoteRef.class };\n+\tConstructor con = scls.getConstructor(stubprototype);\n+\treturn (Remote)(con.newInstance(new Object[]{obj}));\n+      }\n+    catch (Exception e) {}\n+    throw new NoSuchObjectException(obj.getClass().getName());\n+  }\n \n public int hashCode() {\n \tif (ref == null) {\n@@ -86,30 +100,46 @@ public boolean equals(Object obj) {\n \treturn (this == obj);\n }\n \n-public String toString() {\n-\treturn (ref.toString());\n-}\n-\n-private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-\tString cname = in.readUTF();\n-\tif (!cname.equals(\"\")) {\n-\t\tcname = RemoteRef.packagePrefix + '.' + cname;\n-\t\ttry {\n-\t\t\tClass cls = Class.forName(cname);\n-\t\t\tref = (RemoteRef)cls.newInstance();\n-\t\t}\n-\t\tcatch (InstantiationException e1) {\n-\t\t\tthrow new UnmarshalException(\"failed to create ref\");\n-\t\t}\n-\t\tcatch (IllegalAccessException e2) {\n-\t\t\tthrow new UnmarshalException(\"failed to create ref\");\n-\t\t}\n-\t\tref.readExternal(in);\n-\t}\n-\telse {\n-\t\tref = (RemoteRef)in.readObject();\n-\t}\n-}\n+  public String toString() \n+  {\n+    if (ref == null)\n+      return getClass ().toString ();\n+    return (ref.toString ());\n+  }\n+  \n+  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException \n+  {\n+    String cname = in.readUTF();\n+    if (!cname.equals(\"\")) \n+      {\n+\tif (cname.equals (\"UnicastRef2\"))\n+\t  { \n+\t    // hack for interoperating with JDK\n+\t    cname = \"UnicastRef\";\n+\t    in.read (); //some unknown UnicastRef2 field\n+\t  }\n+\n+\tcname = RemoteRef.packagePrefix + '.' + cname;\n+\ttry \n+\t  {\n+\t    Class cls = Class.forName(cname);\n+\t    ref = (RemoteRef)cls.newInstance();\n+\t  }\n+\tcatch (InstantiationException e1) \n+\t  {\n+\t    throw new UnmarshalException(\"failed to create ref\");\n+\t  }\n+\tcatch (IllegalAccessException e2) \n+\t  {\n+\t    throw new UnmarshalException(\"failed to create ref\");\n+\t  }\n+\tref.readExternal(in);\n+      }\n+    else \n+      {\n+\tref = (RemoteRef)in.readObject();\n+      }\n+  }\n \n private void writeObject(ObjectOutputStream out) throws IOException, ClassNotFoundException {\n \tif (ref == null) {"}, {"sha": "a9c4f35099c487601397ca4e0e2bf4ed933b4a28", "filename": "libjava/java/rmi/server/UnicastRemoteObject.java", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2Fserver%2FUnicastRemoteObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Frmi%2Fserver%2FUnicastRemoteObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2Fserver%2FUnicastRemoteObject.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -42,10 +42,17 @@\n import java.rmi.server.RemoteRef;\n import java.rmi.NoSuchObjectException;\n import gnu.java.rmi.server.UnicastServerRef;\n+import gnu.java.rmi.server.UnicastServer;\n \n public class UnicastRemoteObject\n \textends RemoteServer {\n \n+private static final long serialVersionUID = 4974527148936298033L;\n+//The following serialized fields are from Java API Documentation \"Serialized form\"\n+private int port = 0;\n+private RMIClientSocketFactory csf = null;\n+private RMIServerSocketFactory ssf = null;\n+\n protected UnicastRemoteObject() throws RemoteException {\n \tthis(0);\n }\n@@ -55,11 +62,21 @@ protected UnicastRemoteObject(int port) throws RemoteException {\n }\n \n protected UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf) throws RemoteException {\n-\tsuper(new UnicastServerRef(new ObjID(), port, ssf));\n+  this.port = port;\n+  //Is RMIXXXSocketFactory serializable\n+  //this.csf = csf;\n+  //this.ssf = ssf;\n+  this.ref = new UnicastServerRef(new ObjID(), port, ssf);\n+  //Should we export it here?\n+  // if we export, we got infinite recursive call:\n+  //  UnicastRemoteObject.<init>->...->UnicastServer.startDGC()->UnicastRemoteObject.<init>->...\n+  //exportObject(this);\n }\n \n protected UnicastRemoteObject(RemoteRef ref) throws RemoteException {\n \tsuper((UnicastServerRef)ref);\n+       //Should we export it here?\n+       //exportObject(this);\n }\n \n public Object clone() throws CloneNotSupportedException {\n@@ -71,16 +88,46 @@ public static RemoteStub exportObject(Remote obj) throws RemoteException {\n \treturn (sref.exportObject(obj));\n }\n \n-public static Remote exportObject(Remote obj, int port) throws RemoteException {\n-\treturn (exportObject(obj));\n-}\n-\n-public static Remote exportObject(Remote obj, int port, RMIClientSocketFactory csf, RMIServerSocketFactory ssf) throws RemoteException {\n-\treturn (exportObject(obj));\n-}\n-\n-public static boolean unexportObject(Remote obj, boolean force) throws NoSuchObjectException {\n-\tthrow new Error(\"Not implemented\");\n-}\n+  public static Remote exportObject(Remote obj, int port) throws RemoteException \n+  {\n+    return exportObject(obj, port, null);\n+  }\n+  \n+  protected static Remote exportObject(Remote obj, int port, RMIServerSocketFactory ssf) \n+    throws RemoteException \n+  {\n+    UnicastServerRef sref = null;\n+    if (obj instanceof RemoteObject)\n+      sref = (UnicastServerRef)((RemoteObject)obj).getRef ();\n+    if(sref == null)\n+      {\n+\tsref = new UnicastServerRef(new ObjID (), port, ssf);\n+      }\n+    return (sref.exportObject (obj)); \n+  }\n+\n+  /**\n+   * FIX ME\n+   */\n+  public static Remote exportObject(Remote obj, int port, RMIClientSocketFactory csf, \n+\t\t\t\t    RMIServerSocketFactory ssf) \n+    throws RemoteException \n+  {\n+    return (exportObject(obj, port, ssf));\n+  }\n+\n+  public static boolean unexportObject(Remote obj, boolean force) \n+    throws RemoteException, NoSuchObjectException \n+  {\n+    if (obj instanceof RemoteObject)\n+      {\n+\tUnicastServerRef sref = (UnicastServerRef)((RemoteObject)obj).getRef();\n+\treturn sref.unexportObject(obj, force);\n+      }\n+    else\n+      //FIX ME\n+      ;\n+    return true;\n+  }\n \n }"}, {"sha": "7adba1a9bbc79340db8e45898ce6c3353c922954", "filename": "libjava/java/security/SecureClassLoader.java", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Fsecurity%2FSecureClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Fjava%2Fsecurity%2FSecureClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fsecurity%2FSecureClassLoader.java?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -71,7 +71,7 @@ protected SecureClassLoader()\n      @param b the data representing the classfile, in classfile format.\n      @param off the offset into the data where the classfile starts.\n      @param len the length of the classfile data in the array.\n-     @param cs the CodeSource for the class\n+     @param cs the CodeSource for the class or null when unknown.\n \n      @return the class that was defined and optional CodeSource.\n \n@@ -81,16 +81,14 @@ protected final Class defineClass(String name, byte[] b, int off, int len,\n \t\t\t\t    CodeSource cs)\n   {\n     // FIXME: Need to cache ProtectionDomains according to 1.3 docs.\n-    ProtectionDomain protectionDomain =\n-      new ProtectionDomain(cs, getPermissions(cs));\n-    try\n+    if (cs != null)\n       {\n+\tProtectionDomain protectionDomain\n+\t\t= new ProtectionDomain(cs, getPermissions(cs));\n \treturn super.defineClass(name, b, off, len, protectionDomain);\n-      }\n-    catch (ClassFormatError cfe)\n-      {\n-\treturn null;\n-      }\n+      } \n+    else\n+      return super.defineClass(name, b, off, len);\n   }\n \n   /**"}, {"sha": "e5ed97687638605aa70490f115b566add7a66e70", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d74732f5cd87b68aed10ea3fcfcb24171b9f5d67/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=d74732f5cd87b68aed10ea3fcfcb24171b9f5d67", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved."}]}