{"sha": "5eaad4813d632efa8213ad4f262a44f824fb0f6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVhYWQ0ODEzZDYzMmVmYTgyMTNhZDRmMjYyYTQ0ZjgyNGZiMGY2YQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-05-12T08:32:00Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-05-12T08:32:00Z"}, "message": "Replace several arrays with a struct of arrays.\n\n2004-05-12  Paolo Bonzini  <bonzini@gnu.org>\n\n\tReplace several arrays with a struct of arrays.\n        * combine.c (struct reg_stat): New.\n        (init_reg_last_arrays): Renamed to...\n        (init_reg_last): ...this.  Callers adjusted.\n        (reg_stat): New.\n        (combine_instructions): Allocate it and use it.\n        (reg_last_death, reg_last_set, reg_last_set_value,\n        reg_last_set_label, reg_last_set_table_tick,\n        reg_last_set_invalid, reg_nonzero_bits, reg_sign_bit_copies,\n        reg_last_set_mode, reg_last_set_nonzero_bits,\n        reg_last_set_sign_bit_copies): Replace throughout\n        with items of reg_stat.\n\nFrom-SVN: r81740", "tree": {"sha": "79cfceb3da6051a8284f4437cc16da4d2dd1a6d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79cfceb3da6051a8284f4437cc16da4d2dd1a6d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5eaad4813d632efa8213ad4f262a44f824fb0f6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eaad4813d632efa8213ad4f262a44f824fb0f6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eaad4813d632efa8213ad4f262a44f824fb0f6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eaad4813d632efa8213ad4f262a44f824fb0f6a/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f5657d6742d33882cf7228af5a558d5b0db97281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5657d6742d33882cf7228af5a558d5b0db97281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5657d6742d33882cf7228af5a558d5b0db97281"}], "stats": {"total": 439, "additions": 214, "deletions": 225}, "files": [{"sha": "5891803f9a80eed312d20ec9166adbe05c181d4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eaad4813d632efa8213ad4f262a44f824fb0f6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eaad4813d632efa8213ad4f262a44f824fb0f6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5eaad4813d632efa8213ad4f262a44f824fb0f6a", "patch": "@@ -1,3 +1,18 @@\n+2004-05-12  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tReplace several arrays with a struct of arrays.\n+        * combine.c (struct reg_stat): New.\n+        (init_reg_last_arrays): Renamed to...\n+        (init_reg_last): ...this.  Callers adjusted.\n+        (reg_stat): New.\n+        (combine_instructions): Allocate it and use it.\n+        (reg_last_death, reg_last_set, reg_last_set_value,\n+        reg_last_set_label, reg_last_set_table_tick,\n+        reg_last_set_invalid, reg_nonzero_bits, reg_sign_bit_copies,\n+        reg_last_set_mode, reg_last_set_nonzero_bits,\n+        reg_last_set_sign_bit_copies): Replace throughout\n+        with items of reg_stat.\n+\n 2004-05-11  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR optimization/15100"}, {"sha": "7765374489535cc735d896091d450c2e3a8e63a9", "filename": "gcc/combine.c", "status": "modified", "additions": 199, "deletions": 225, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5eaad4813d632efa8213ad4f262a44f824fb0f6a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5eaad4813d632efa8213ad4f262a44f824fb0f6a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=5eaad4813d632efa8213ad4f262a44f824fb0f6a", "patch": "@@ -143,13 +143,103 @@ static int max_uid_cuid;\n \n static unsigned int combine_max_regno;\n \n-/* Record last point of death of (hard or pseudo) register n.  */\n+struct reg_stat {\n+  /* Record last point of death of (hard or pseudo) register n.  */\n+  rtx\t\t\t\tlast_death;\n \n-static rtx *reg_last_death;\n+  /* Record last point of modification of (hard or pseudo) register n.  */\n+  rtx\t\t\t\tlast_set;\n \n-/* Record last point of modification of (hard or pseudo) register n.  */\n+  /* The next group of fields allows the recording of the last value assigned\n+     to (hard or pseudo) register n.  We use this information to see if an\n+     operation being processed is redundant given a prior operation performed\n+     on the register.  For example, an `and' with a constant is redundant if\n+     all the zero bits are already known to be turned off.\n \n-static rtx *reg_last_set;\n+     We use an approach similar to that used by cse, but change it in the\n+     following ways:\n+\n+     (1) We do not want to reinitialize at each label.\n+     (2) It is useful, but not critical, to know the actual value assigned\n+         to a register.  Often just its form is helpful.\n+\n+     Therefore, we maintain the following fields:\n+\n+     last_set_value\t\tthe last value assigned\n+     last_set_label\t\trecords the value of label_tick when the\n+\t\t\t\tregister was assigned\n+     last_set_table_tick\trecords the value of label_tick when a\n+\t\t\t\tvalue using the register is assigned\n+     last_set_invalid\t\tset to nonzero when it is not valid\n+\t\t\t\tto use the value of this register in some\n+\t\t\t\tregister's value\n+\n+     To understand the usage of these tables, it is important to understand\n+     the distinction between the value in last_set_value being valid and\n+     the register being validly contained in some other expression in the\n+     table.\n+\n+     (The next two parameters are out of date).\n+\n+     reg_stat[i].last_set_value is valid if it is nonzero, and either\n+     reg_n_sets[i] is 1 or reg_stat[i].last_set_label == label_tick.\n+\n+     Register I may validly appear in any expression returned for the value\n+     of another register if reg_n_sets[i] is 1.  It may also appear in the\n+     value for register J if reg_stat[j].last_set_invalid is zero, or\n+     reg_stat[i].last_set_label < reg_stat[j].last_set_label.\n+\n+     If an expression is found in the table containing a register which may\n+     not validly appear in an expression, the register is replaced by\n+     something that won't match, (clobber (const_int 0)).  */\n+\n+  /* Record last value assigned to (hard or pseudo) register n.  */\n+\n+  rtx\t\t\t\tlast_set_value;\n+\n+  /* Record the value of label_tick when an expression involving register n\n+     is placed in last_set_value.  */\n+\n+  int\t\t\t\tlast_set_table_tick;\n+\n+  /* Record the value of label_tick when the value for register n is placed in\n+     last_set_value.  */\n+\n+  int\t\t\t\tlast_set_label;\n+\n+  /* These fields are maintained in parallel with last_set_value and are\n+     used to store the mode in which the register was last set, te bits\n+     that were known to be zero when it was last set, and the number of\n+     sign bits copies it was known to have when it was last set.  */\n+\n+  unsigned HOST_WIDE_INT\tlast_set_nonzero_bits;\n+  char\t\t\t\tlast_set_sign_bit_copies;\n+  ENUM_BITFIELD(machine_mode)\tlast_set_mode : 8; \n+\n+  /* Set nonzero if references to register n in expressions should not be\n+     used.  last_set_invalid is set nonzero when this register is being\n+     assigned to and last_set_table_tick == label_tick.  */\n+\n+  char\t\t\t\tlast_set_invalid;\n+\n+  /* Some registers that are set more than once and used in more than one\n+     basic block are nevertheless always set in similar ways.  For example,\n+     a QImode register may be loaded from memory in two places on a machine\n+     where byte loads zero extend.\n+\n+     We record in the following fields if a register has some leading bits\n+     that are always equal to the sign bit, and what we know about the\n+     nonzero bits of a register, specifically which bits are known to be\n+     zero.\n+\n+     If an entry is zero, it means that we don't know anything special.  */\n+\n+  unsigned char\t\t\tsign_bit_copies;\n+\n+  unsigned HOST_WIDE_INT\tnonzero_bits;\n+};\n+\n+static struct reg_stat *reg_stat;\n \n /* Record the cuid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n@@ -197,110 +287,23 @@ static basic_block this_basic_block;\n    those blocks as starting points.  */\n static sbitmap refresh_blocks;\n \f\n-/* The next group of arrays allows the recording of the last value assigned\n-   to (hard or pseudo) register n.  We use this information to see if an\n-   operation being processed is redundant given a prior operation performed\n-   on the register.  For example, an `and' with a constant is redundant if\n-   all the zero bits are already known to be turned off.\n-\n-   We use an approach similar to that used by cse, but change it in the\n-   following ways:\n-\n-   (1) We do not want to reinitialize at each label.\n-   (2) It is useful, but not critical, to know the actual value assigned\n-       to a register.  Often just its form is helpful.\n-\n-   Therefore, we maintain the following arrays:\n-\n-   reg_last_set_value\t\tthe last value assigned\n-   reg_last_set_label\t\trecords the value of label_tick when the\n-\t\t\t\tregister was assigned\n-   reg_last_set_table_tick\trecords the value of label_tick when a\n-\t\t\t\tvalue using the register is assigned\n-   reg_last_set_invalid\t\tset to nonzero when it is not valid\n-\t\t\t\tto use the value of this register in some\n-\t\t\t\tregister's value\n-\n-   To understand the usage of these tables, it is important to understand\n-   the distinction between the value in reg_last_set_value being valid\n-   and the register being validly contained in some other expression in the\n-   table.\n-\n-   Entry I in reg_last_set_value is valid if it is nonzero, and either\n-   reg_n_sets[i] is 1 or reg_last_set_label[i] == label_tick.\n-\n-   Register I may validly appear in any expression returned for the value\n-   of another register if reg_n_sets[i] is 1.  It may also appear in the\n-   value for register J if reg_last_set_label[i] < reg_last_set_label[j] or\n-   reg_last_set_invalid[j] is zero.\n-\n-   If an expression is found in the table containing a register which may\n-   not validly appear in an expression, the register is replaced by\n-   something that won't match, (clobber (const_int 0)).\n-\n-   reg_last_set_invalid[i] is set nonzero when register I is being assigned\n-   to and reg_last_set_table_tick[i] == label_tick.  */\n-\n-/* Record last value assigned to (hard or pseudo) register n.  */\n-\n-static rtx *reg_last_set_value;\n-\n-/* Record the value of label_tick when the value for register n is placed in\n-   reg_last_set_value[n].  */\n-\n-static int *reg_last_set_label;\n-\n-/* Record the value of label_tick when an expression involving register n\n-   is placed in reg_last_set_value.  */\n-\n-static int *reg_last_set_table_tick;\n-\n-/* Set nonzero if references to register n in expressions should not be\n-   used.  */\n-\n-static char *reg_last_set_invalid;\n-\n /* Incremented for each label.  */\n \n static int label_tick;\n \n-/* Some registers that are set more than once and used in more than one\n-   basic block are nevertheless always set in similar ways.  For example,\n-   a QImode register may be loaded from memory in two places on a machine\n-   where byte loads zero extend.\n-\n-   We record in the following array what we know about the nonzero\n-   bits of a register, specifically which bits are known to be zero.\n-\n-   If an entry is zero, it means that we don't know anything special.  */\n-\n-static unsigned HOST_WIDE_INT *reg_nonzero_bits;\n-\n-/* Mode used to compute significance in reg_nonzero_bits.  It is the largest\n-   integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n+/* Mode used to compute significance in reg_stat[].nonzero_bits.  It is the\n+   largest integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n static enum machine_mode nonzero_bits_mode;\n \n-/* Nonzero if we know that a register has some leading bits that are always\n-   equal to the sign bit.  */\n-\n-static unsigned char *reg_sign_bit_copies;\n-\n-/* Nonzero when reg_nonzero_bits and reg_sign_bit_copies can be safely used.\n-   It is zero while computing them and after combine has completed.  This\n-   former test prevents propagating values based on previously set values,\n-   which can be incorrect if a variable is modified in a loop.  */\n+/* Nonzero when reg_stat[].nonzero_bits and reg_stat[].sign_bit_copies can\n+   be safely used.  It is zero while computing them and after combine has\n+   completed.  This former test prevents propagating values based on\n+   previously set values, which can be incorrect if a variable is modified\n+   in a loop.  */\n \n static int nonzero_sign_valid;\n \n-/* These arrays are maintained in parallel with reg_last_set_value\n-   and are used to store the mode in which the register was last set,\n-   the bits that were known to be zero when it was last set, and the\n-   number of sign bits copies it was known to have when it was last set.  */\n-\n-static enum machine_mode *reg_last_set_mode;\n-static unsigned HOST_WIDE_INT *reg_last_set_nonzero_bits;\n-static char *reg_last_set_sign_bit_copies;\n \f\n /* Record one modification to rtl structure\n    to be undone by storing old_contents into *where.\n@@ -336,7 +339,7 @@ static int n_occurrences;\n \n static void do_SUBST (rtx *, rtx);\n static void do_SUBST_INT (int *, int);\n-static void init_reg_last_arrays (void);\n+static void init_reg_last (void);\n static void setup_incoming_promotions (void);\n static void set_nonzero_bits_and_sign_copies (rtx, rtx, void *);\n static int cant_combine_insn_p (rtx);\n@@ -523,20 +526,7 @@ combine_instructions (rtx f, unsigned int nregs)\n      See comments in gen_lowpart_for_combine.  */\n   gen_lowpart = gen_lowpart_for_combine;\n \n-  reg_nonzero_bits = xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT));\n-  reg_sign_bit_copies = xcalloc (nregs, sizeof (unsigned char));\n-\n-  reg_last_death = xmalloc (nregs * sizeof (rtx));\n-  reg_last_set = xmalloc (nregs * sizeof (rtx));\n-  reg_last_set_value = xmalloc (nregs * sizeof (rtx));\n-  reg_last_set_table_tick = xmalloc (nregs * sizeof (int));\n-  reg_last_set_label = xmalloc (nregs * sizeof (int));\n-  reg_last_set_invalid = xmalloc (nregs * sizeof (char));\n-  reg_last_set_mode = xmalloc (nregs * sizeof (enum machine_mode));\n-  reg_last_set_nonzero_bits = xmalloc (nregs * sizeof (HOST_WIDE_INT));\n-  reg_last_set_sign_bit_copies = xmalloc (nregs * sizeof (char));\n-\n-  init_reg_last_arrays ();\n+  reg_stat = xcalloc (nregs, sizeof (struct reg_stat));\n \n   init_recog_no_volatile ();\n \n@@ -551,8 +541,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n-  /* Don't use reg_nonzero_bits when computing it.  This can cause problems\n-     when, for example, we have j <<= 1 in a loop.  */\n+  /* Don't use reg_stat[].nonzero_bits when computing it.  This can cause\n+     problems when, for example, we have j <<= 1 in a loop.  */\n \n   nonzero_sign_valid = 0;\n \n@@ -605,7 +595,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n-  init_reg_last_arrays ();\n+  init_reg_last ();\n   setup_incoming_promotions ();\n \n   FOR_EACH_BB (this_basic_block)\n@@ -768,17 +758,7 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   /* Clean up.  */\n   sbitmap_free (refresh_blocks);\n-  free (reg_nonzero_bits);\n-  free (reg_sign_bit_copies);\n-  free (reg_last_death);\n-  free (reg_last_set);\n-  free (reg_last_set_value);\n-  free (reg_last_set_table_tick);\n-  free (reg_last_set_label);\n-  free (reg_last_set_invalid);\n-  free (reg_last_set_mode);\n-  free (reg_last_set_nonzero_bits);\n-  free (reg_last_set_sign_bit_copies);\n+  free (reg_stat);\n   free (uid_cuid);\n \n   {\n@@ -805,22 +785,14 @@ combine_instructions (rtx f, unsigned int nregs)\n   return new_direct_jump_p;\n }\n \n-/* Wipe the reg_last_xxx arrays in preparation for another pass.  */\n+/* Wipe the last_xxx fields of reg_stat in preparation for another pass.  */\n \n static void\n-init_reg_last_arrays (void)\n+init_reg_last (void)\n {\n-  unsigned int nregs = combine_max_regno;\n-\n-  memset (reg_last_death, 0, nregs * sizeof (rtx));\n-  memset (reg_last_set, 0, nregs * sizeof (rtx));\n-  memset (reg_last_set_value, 0, nregs * sizeof (rtx));\n-  memset (reg_last_set_table_tick, 0, nregs * sizeof (int));\n-  memset (reg_last_set_label, 0, nregs * sizeof (int));\n-  memset (reg_last_set_invalid, 0, nregs * sizeof (char));\n-  memset (reg_last_set_mode, 0, nregs * sizeof (enum machine_mode));\n-  memset (reg_last_set_nonzero_bits, 0, nregs * sizeof (HOST_WIDE_INT));\n-  memset (reg_last_set_sign_bit_copies, 0, nregs * sizeof (char));\n+  unsigned int i;\n+  for (i = 0; i < combine_max_regno; i++)\n+    memset (reg_stat + i, 0, offsetof (struct reg_stat, sign_bit_copies));\n }\n \f\n /* Set up any promoted values for incoming argument registers.  */\n@@ -878,8 +850,8 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n \t{\n-\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_sign_bit_copies[REGNO (x)] = 1;\n+\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n \t  return;\n \t}\n \n@@ -901,7 +873,7 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n \t  /* If X is narrower than a word and SRC is a non-negative\n \t     constant that would appear negative in the mode of X,\n-\t     sign-extend it for use in reg_nonzero_bits because some\n+\t     sign-extend it for use in reg_stat[].nonzero_bits because some\n \t     machines (maybe most) will actually do the sign-extension\n \t     and this is the conservative approach.\n \n@@ -920,18 +892,18 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n #endif\n \n \t  /* Don't call nonzero_bits if it cannot change anything.  */\n-\t  if (reg_nonzero_bits[REGNO (x)] != ~(unsigned HOST_WIDE_INT) 0)\n-\t    reg_nonzero_bits[REGNO (x)]\n+\t  if (reg_stat[REGNO (x)].nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n+\t    reg_stat[REGNO (x)].nonzero_bits\n \t      |= nonzero_bits (src, nonzero_bits_mode);\n \t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n-\t  if (reg_sign_bit_copies[REGNO (x)] == 0\n-\t      || reg_sign_bit_copies[REGNO (x)] > num)\n-\t    reg_sign_bit_copies[REGNO (x)] = num;\n+\t  if (reg_stat[REGNO (x)].sign_bit_copies == 0\n+\t      || reg_stat[REGNO (x)].sign_bit_copies > num)\n+\t    reg_stat[REGNO (x)].sign_bit_copies = num;\n \t}\n       else\n \t{\n-\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_sign_bit_copies[REGNO (x)] = 1;\n+\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n \t}\n     }\n }\n@@ -1101,7 +1073,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t does not use any registers whose values alter in between.  However,\n \t If the insns are adjacent, a use can't cross a set even though we\n \t think it might (this can happen for a sequence of insns each setting\n-\t the same destination; reg_last_set of that register might point to\n+\t the same destination; last_set of that register might point to\n \t a NOTE).  If INSN has a REG_EQUIV note, the register is always\n \t equivalent to the memory so the substitution is valid even if there\n \t are intervening stores.  Also, don't move a volatile asm or\n@@ -2331,18 +2303,18 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (GET_CODE (temp) == REG\n-\t\t  && reg_nonzero_bits[REGNO (temp)] != 0\n+\t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t  && (reg_nonzero_bits[REGNO (temp)]\n+\t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (GET_CODE (temp) == REG\n-\t\t      && reg_nonzero_bits[REGNO (temp)] != 0\n+\t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t      && (reg_nonzero_bits[REGNO (temp)]\n+\t\t      && (reg_stat[REGNO (temp)].nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -2783,9 +2755,10 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  REG_N_SETS (regno)--;\n       }\n \n-    /* Update reg_nonzero_bits et al for any changes that may have been made\n-       to this insn.  The order of set_nonzero_bits_and_sign_copies() is\n-       important.  Because newi2pat can affect nonzero_bits of newpat */\n+    /* Update reg_stat[].nonzero_bits et al for any changes that may have\n+       been made to this insn.  The order of\n+       set_nonzero_bits_and_sign_copies() is important.  Because newi2pat\n+       can affect nonzero_bits of newpat */\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n     note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n@@ -8171,17 +8144,17 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n \t value.  Otherwise, use the previously-computed global nonzero bits\n \t for this register.  */\n \n-      if (reg_last_set_value[REGNO (x)] != 0\n-\t  && (reg_last_set_mode[REGNO (x)] == mode\n-\t      || (GET_MODE_CLASS (reg_last_set_mode[REGNO (x)]) == MODE_INT\n+      if (reg_stat[REGNO (x)].last_set_value != 0\n+\t  && (reg_stat[REGNO (x)].last_set_mode == mode\n+\t      || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n \t\t  && GET_MODE_CLASS (mode) == MODE_INT))\n-\t  && (reg_last_set_label[REGNO (x)] == label_tick\n+\t  && (reg_stat[REGNO (x)].last_set_label == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n \t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n-\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n-\treturn reg_last_set_nonzero_bits[REGNO (x)] & nonzero;\n+\t  && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n+\treturn reg_stat[REGNO (x)].last_set_nonzero_bits & nonzero;\n \n       tem = get_last_value (x);\n \n@@ -8190,8 +8163,8 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n \t  /* If X is narrower than MODE and TEM is a non-negative\n \t     constant that would appear negative in the mode of X,\n-\t     sign-extend it for use in reg_nonzero_bits because some\n-\t     machines (maybe most) will actually do the sign-extension\n+\t     sign-extend it for use in reg_stat[].nonzero_bits because\n+\t     some machines (maybe most) will actually do the sign-extension\n \t     and this is the conservative approach.\n \n \t     ??? For 2.5, try to tighten up the MD files in this regard\n@@ -8209,9 +8182,9 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n #endif\n \t  return nonzero_bits_with_known (tem, mode) & nonzero;\n \t}\n-      else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n+      else if (nonzero_sign_valid && reg_stat[REGNO (x)].nonzero_bits)\n \t{\n-\t  unsigned HOST_WIDE_INT mask = reg_nonzero_bits[REGNO (x)];\n+\t  unsigned HOST_WIDE_INT mask = reg_stat[REGNO (x)].nonzero_bits;\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) < mode_width)\n \t    /* We don't know anything about the upper bits.  */\n@@ -8667,23 +8640,23 @@ num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,\n \treturn GET_MODE_BITSIZE (Pmode) - GET_MODE_BITSIZE (ptr_mode) + 1;\n #endif\n \n-      if (reg_last_set_value[REGNO (x)] != 0\n-\t  && reg_last_set_mode[REGNO (x)] == mode\n-\t  && (reg_last_set_label[REGNO (x)] == label_tick\n+      if (reg_stat[REGNO (x)].last_set_value != 0\n+\t  && reg_stat[REGNO (x)].last_set_mode == mode\n+\t  && (reg_stat[REGNO (x)].last_set_label == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n \t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n-\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n-\treturn reg_last_set_sign_bit_copies[REGNO (x)];\n+\t  && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n+\treturn reg_stat[REGNO (x)].last_set_sign_bit_copies;\n \n       tem = get_last_value (x);\n       if (tem != 0)\n \treturn num_sign_bit_copies_with_known (tem, mode);\n \n-      if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0\n+      if (nonzero_sign_valid && reg_stat[REGNO (x)].sign_bit_copies != 0\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) == bitwidth)\n-\treturn reg_sign_bit_copies[REGNO (x)];\n+\treturn reg_stat[REGNO (x)].sign_bit_copies;\n       break;\n \n     case MEM:\n@@ -11367,7 +11340,7 @@ reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n }\n \f\n /* Utility function for following routine.  Called when X is part of a value\n-   being stored into reg_last_set_value.  Sets reg_last_set_table_tick\n+   being stored into last_set_value.  Sets last_set_table_tick\n    for each register mentioned.  Similar to mention_regs in cse.c  */\n \n static void\n@@ -11386,7 +11359,7 @@ update_table_tick (rtx x)\n       unsigned int r;\n \n       for (r = regno; r < endregno; r++)\n-\treg_last_set_table_tick[r] = label_tick;\n+\treg_stat[r].last_set_table_tick = label_tick;\n \n       return;\n     }\n@@ -11434,8 +11407,9 @@ update_table_tick (rtx x)\n \n /* Record that REG is set to VALUE in insn INSN.  If VALUE is zero, we\n    are saying that the register is clobbered and we no longer know its\n-   value.  If INSN is zero, don't update reg_last_set; this is only permitted\n-   with VALUE also zero and is used to invalidate the register.  */\n+   value.  If INSN is zero, don't update reg_stat[].last_set; this is\n+   only permitted with VALUE also zero and is used to invalidate the\n+   register.  */\n \n static void\n record_value_for_reg (rtx reg, rtx insn, rtx value)\n@@ -11479,13 +11453,13 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   for (i = regno; i < endregno; i++)\n     {\n       if (insn)\n-\treg_last_set[i] = insn;\n+\treg_stat[i].last_set = insn;\n \n-      reg_last_set_value[i] = 0;\n-      reg_last_set_mode[i] = 0;\n-      reg_last_set_nonzero_bits[i] = 0;\n-      reg_last_set_sign_bit_copies[i] = 0;\n-      reg_last_death[i] = 0;\n+      reg_stat[i].last_set_value = 0;\n+      reg_stat[i].last_set_mode = 0;\n+      reg_stat[i].last_set_nonzero_bits = 0;\n+      reg_stat[i].last_set_sign_bit_copies = 0;\n+      reg_stat[i].last_death = 0;\n     }\n \n   /* Mark registers that are being referenced in this value.  */\n@@ -11501,40 +11475,40 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n   for (i = regno; i < endregno; i++)\n     {\n-      reg_last_set_label[i] = label_tick;\n-      if (value && reg_last_set_table_tick[i] == label_tick)\n-\treg_last_set_invalid[i] = 1;\n+      reg_stat[i].last_set_label = label_tick;\n+      if (value && reg_stat[i].last_set_table_tick == label_tick)\n+\treg_stat[i].last_set_invalid = 1;\n       else\n-\treg_last_set_invalid[i] = 0;\n+\treg_stat[i].last_set_invalid = 0;\n     }\n \n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n   if (value && ! get_last_value_validate (&value, insn,\n-\t\t\t\t\t  reg_last_set_label[regno], 0))\n+\t\t\t\t\t  reg_stat[regno].last_set_label, 0))\n     {\n       value = copy_rtx (value);\n       if (! get_last_value_validate (&value, insn,\n-\t\t\t\t     reg_last_set_label[regno], 1))\n+\t\t\t\t     reg_stat[regno].last_set_label, 1))\n \tvalue = 0;\n     }\n \n   /* For the main register being modified, update the value, the mode, the\n      nonzero bits, and the number of sign bit copies.  */\n \n-  reg_last_set_value[regno] = value;\n+  reg_stat[regno].last_set_value = value;\n \n   if (value)\n     {\n       enum machine_mode mode = GET_MODE (reg);\n       subst_low_cuid = INSN_CUID (insn);\n-      reg_last_set_mode[regno] = mode;\n+      reg_stat[regno].last_set_mode = mode;\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \tmode = nonzero_bits_mode;\n-      reg_last_set_nonzero_bits[regno] = nonzero_bits (value, mode);\n-      reg_last_set_sign_bit_copies[regno]\n+      reg_stat[regno].last_set_nonzero_bits = nonzero_bits (value, mode);\n+      reg_stat[regno].last_set_sign_bit_copies\n \t= num_sign_bit_copies (value, GET_MODE (reg));\n     }\n }\n@@ -11579,11 +11553,11 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n    for the things done by INSN.  This is the last thing done in processing\n    INSN in the combiner loop.\n \n-   We update reg_last_set, reg_last_set_value, reg_last_set_mode,\n-   reg_last_set_nonzero_bits, reg_last_set_sign_bit_copies, reg_last_death,\n-   and also the similar information mem_last_set (which insn most recently\n-   modified memory) and last_call_cuid (which insn was the most recent\n-   subroutine call).  */\n+   We update reg_stat[], in particular fields last_set, last_set_value,\n+   last_set_mode, last_set_nonzero_bits, last_set_sign_bit_copies,\n+   last_death, and also the similar information mem_last_set (which insn\n+   most recently modified memory) and last_call_cuid (which insn was the\n+   most recent subroutine call).  */\n \n static void\n record_dead_and_set_regs (rtx insn)\n@@ -11603,7 +11577,7 @@ record_dead_and_set_regs (rtx insn)\n \t\t       : 1);\n \n \t  for (i = regno; i < endregno; i++)\n-\t    reg_last_death[i] = insn;\n+\t    reg_stat[i].last_death = insn;\n \t}\n       else if (REG_NOTE_KIND (link) == REG_INC)\n \trecord_value_for_reg (XEXP (link, 0), insn, NULL_RTX);\n@@ -11614,11 +11588,11 @@ record_dead_and_set_regs (rtx insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  {\n-\t    reg_last_set_value[i] = 0;\n-\t    reg_last_set_mode[i] = 0;\n-\t    reg_last_set_nonzero_bits[i] = 0;\n-\t    reg_last_set_sign_bit_copies[i] = 0;\n-\t    reg_last_death[i] = 0;\n+\t    reg_stat[i].last_set_value = 0;\n+\t    reg_stat[i].last_set_mode = 0;\n+\t    reg_stat[i].last_set_nonzero_bits = 0;\n+\t    reg_stat[i].last_set_sign_bit_copies = 0;\n+\t    reg_stat[i].last_death = 0;\n \t  }\n \n       last_call_cuid = mem_last_set = INSN_CUID (insn);\n@@ -11666,10 +11640,10 @@ record_promoted_value (rtx insn, rtx subreg)\n \t  continue;\n \t}\n \n-      if (reg_last_set[regno] == insn)\n+      if (reg_stat[regno].last_set == insn)\n \t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n-\t    reg_last_set_nonzero_bits[regno] &= GET_MODE_MASK (mode);\n+\t    reg_stat[regno].last_set_nonzero_bits &= GET_MODE_MASK (mode);\n \t}\n \n       if (GET_CODE (SET_SRC (set)) == REG)\n@@ -11739,14 +11713,14 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n       unsigned int j;\n \n       for (j = regno; j < endregno; j++)\n-\tif (reg_last_set_invalid[j]\n+\tif (reg_stat[j].last_set_invalid\n \t    /* If this is a pseudo-register that was only set once and not\n \t       live at the beginning of the function, it is always valid.  */\n \t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n \t\t   && (! REGNO_REG_SET_P\n \t\t       (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))\n-\t\t&& reg_last_set_label[j] > tick))\n+\t\t&& reg_stat[j].last_set_label > tick))\n \t  {\n \t    if (replace)\n \t      *loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n@@ -11838,7 +11812,7 @@ get_last_value (rtx x)\n     return 0;\n \n   regno = REGNO (x);\n-  value = reg_last_set_value[regno];\n+  value = reg_stat[regno].last_set_value;\n \n   /* If we don't have a value, or if it isn't for this basic block and\n      it's either a hard register, set more than once, or it's a live\n@@ -11851,7 +11825,7 @@ get_last_value (rtx x)\n      block.  */\n \n   if (value == 0\n-      || (reg_last_set_label[regno] != label_tick\n+      || (reg_stat[regno].last_set_label != label_tick\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || (REGNO_REG_SET_P\n@@ -11860,20 +11834,20 @@ get_last_value (rtx x)\n \n   /* If the value was set in a later insn than the ones we are processing,\n      we can't use it even if the register was only set once.  */\n-  if (INSN_CUID (reg_last_set[regno]) >= subst_low_cuid)\n+  if (INSN_CUID (reg_stat[regno].last_set) >= subst_low_cuid)\n     return 0;\n \n   /* If the value has all its registers valid, return it.  */\n-  if (get_last_value_validate (&value, reg_last_set[regno],\n-\t\t\t       reg_last_set_label[regno], 0))\n+  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n+\t\t\t       reg_stat[regno].last_set_label, 0))\n     return value;\n \n   /* Otherwise, make a copy and replace any invalid register with\n      (clobber (const_int 0)).  If that fails for some reason, return 0.  */\n \n   value = copy_rtx (value);\n-  if (get_last_value_validate (&value, reg_last_set[regno],\n-\t\t\t       reg_last_set_label[regno], 1))\n+  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n+\t\t\t       reg_stat[regno].last_set_label, 1))\n     return value;\n \n   return 0;\n@@ -11902,8 +11876,8 @@ use_crosses_set_p (rtx x, int from_cuid)\n \treturn 1;\n #endif\n       for (; regno < endreg; regno++)\n-\tif (reg_last_set[regno]\n-\t    && INSN_CUID (reg_last_set[regno]) > from_cuid)\n+\tif (reg_stat[regno].last_set\n+\t    && INSN_CUID (reg_stat[regno].last_set) > from_cuid)\n \t  return 1;\n       return 0;\n     }\n@@ -12163,7 +12137,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      rtx where_dead = reg_last_death[regno];\n+      rtx where_dead = reg_stat[regno].last_death;\n       rtx before_dead, after_dead;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n@@ -12190,7 +12164,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t  rtx note = remove_death (regno, where_dead);\n \n \t  /* It is possible for the call above to return 0.  This can occur\n-\t     when reg_last_death points to I2 or I1 that we combined with.\n+\t     when last_death points to I2 or I1 that we combined with.\n \t     In that case make a new note.\n \n \t     We must also check for the case where X is a hard register\n@@ -12803,14 +12777,14 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))\n \t\t{\n \t\t  /* Unless the register previously died in PLACE, clear\n-\t\t     reg_last_death.  [I no longer understand why this is\n+\t\t     last_death.  [I no longer understand why this is\n \t\t     being done.] */\n-\t\t  if (reg_last_death[regno] != place)\n-\t\t    reg_last_death[regno] = 0;\n+\t\t  if (reg_stat[regno].last_death != place)\n+\t\t    reg_stat[regno].last_death = 0;\n \t\t  place = 0;\n \t\t}\n \t      else\n-\t\treg_last_death[regno] = place;\n+\t\treg_stat[regno].last_death = place;\n \n \t      /* If this is a death note for a hard reg that is occupying\n \t\t multiple registers, ensure that we are still using all"}]}