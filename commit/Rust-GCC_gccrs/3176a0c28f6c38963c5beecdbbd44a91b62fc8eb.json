{"sha": "3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE3NmEwYzI4ZjZjMzg5NjNjNWJlZWNkYmJkNDRhOTFiNjJmYzhlYg==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2005-06-28T19:33:23Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2005-06-28T19:33:23Z"}, "message": "c-decl.c (pop_scope): Move warning control into warning call.\n\n* c-decl.c (pop_scope): Move warning control into warning call.\n(diagnose_mismatched_decls): Likewise.\n(pushdecl): Likewise.\n(start_decl): Likewise.\n(grokparms): Likewise.\n(start_function): Likewise.\n(store_parm_decls_newstyle): Likewise.\n(store_parm_decls_oldstyle): Likewise.\n(finish_function): Likewise.\n(declspecs_add_scspec): Likewise.\n* c-format.c (decode_format_attr): Likewise.\n(maybe_read_dollar_number): Likewise.\n(avoid_dollar_number): Likewise.\n(finish_dollar_format_checking): Likewise.\n(check_format_info): Likewise.\n(check_format_info_main): Likewise.\n(check_format_types): Likewise.\n(format_type_warning): Likewise.\n* c-typeck.c (function_types_compatible_p): Likewise.\n(build_array_ref): Likewise.\n(convert_arguments): Likewise.\n(build_c_cast): Likewise.\n(store_init_value): Likewise.\n(process_init_element): Likewise.\n(c_start_case): Likewise.\n* stor-layout.c (finalize_record_size): Likewise.\n* tree-cfg.c (execute_warn_function_noreturn): Likewise.\n* tree-inline.c (expand_call_inline): Likewise.\n\nFrom-SVN: r101384", "tree": {"sha": "4f329fdddb0353188ddf7618481f6dfb4b14591c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f329fdddb0353188ddf7618481f6dfb4b14591c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/comments", "author": null, "committer": null, "parents": [{"sha": "cec471db31969b339e4d6a7782ec398f9ccdbf28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cec471db31969b339e4d6a7782ec398f9ccdbf28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cec471db31969b339e4d6a7782ec398f9ccdbf28"}], "stats": {"total": 316, "additions": 188, "deletions": 128}, "files": [{"sha": "29c1e4f478e51891327030e7457ad79d98362506", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -1,3 +1,34 @@\n+2005-06-28  DJ Delorie  <dj@redhat.com>\n+\n+\t* c-decl.c (pop_scope): Move warning control into warning call.\n+\t(diagnose_mismatched_decls): Likewise.\n+\t(pushdecl): Likewise.\n+\t(start_decl): Likewise.\n+\t(grokparms): Likewise.\n+\t(start_function): Likewise.\n+\t(store_parm_decls_newstyle): Likewise.\n+\t(store_parm_decls_oldstyle): Likewise.\n+\t(finish_function): Likewise.\n+\t(declspecs_add_scspec): Likewise.\n+\t* c-format.c (decode_format_attr): Likewise.\n+\t(maybe_read_dollar_number): Likewise.\n+\t(avoid_dollar_number): Likewise.\n+\t(finish_dollar_format_checking): Likewise.\n+\t(check_format_info): Likewise.\n+\t(check_format_info_main): Likewise.\n+\t(check_format_types): Likewise.\n+\t(format_type_warning): Likewise.\n+\t* c-typeck.c (function_types_compatible_p): Likewise.\n+\t(build_array_ref): Likewise.\n+\t(convert_arguments): Likewise.\n+\t(build_c_cast): Likewise.\n+\t(store_init_value): Likewise.\n+\t(process_init_element): Likewise.\n+\t(c_start_case): Likewise.\n+\t* stor-layout.c (finalize_record_size): Likewise.\n+\t* tree-cfg.c (execute_warn_function_noreturn): Likewise.\n+\t* tree-inline.c (expand_call_inline): Likewise.\n+\n 2005-06-28  Uros Bizjak  <uros@kss-loka.si>\n \n \tPR target/22134"}, {"sha": "728383fb2b37a623bdb75b9aa4fe9afa6255d32b", "filename": "gcc/c-decl.c", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -801,14 +801,13 @@ pop_scope (void)\n \n \tcase VAR_DECL:\n \t  /* Warnings for unused variables.  */\n-\t  if (warn_unused_variable\n-\t      && !TREE_USED (p)\n+\t  if (!TREE_USED (p)\n \t      && !DECL_IN_SYSTEM_HEADER (p)\n \t      && DECL_NAME (p)\n \t      && !DECL_ARTIFICIAL (p)\n \t      && scope != file_scope\n \t      && scope != external_scope) \n-\t    warning (0, \"%Junused variable %qD\", p, p);\n+\t    warning (OPT_Wunused_variable, \"%Junused variable %qD\", p, p);\n \n \t  if (b->inner_comp)\n \t    {\n@@ -1392,8 +1391,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t    }\n \t  else if (warn_traditional)\n \t    {\n-\t      warning (0, \"%Jnon-static declaration of %qD follows \"\n-\t\t       \"static declaration\", newdecl, newdecl);\n+\t      warning (OPT_Wtraditional, \"%Jnon-static declaration of %qD \"\n+\t\t       \"follows static declaration\", newdecl, newdecl);\n \t      warned = true;\n \t    }\n \t}\n@@ -1445,8 +1444,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t\t}\n \t      else if (warn_traditional)\n \t\t{\n-\t\t  warning (0, \"%Jnon-static declaration of %qD follows \"\n-\t\t\t   \"static declaration\", newdecl, newdecl);\n+\t\t  warning (OPT_Wtraditional, \"%Jnon-static declaration of %qD \"\n+\t\t\t   \"follows static declaration\", newdecl, newdecl);\n \t\t  warned = true;\n \t\t}\n \t    }\n@@ -1577,7 +1576,8 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n       && !(TREE_CODE (newdecl) == PARM_DECL\n \t   && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl)))\n     {\n-      warning (0, \"%Jredundant redeclaration of %qD\", newdecl, newdecl);\n+      warning (OPT_Wredundant_decls, \"%Jredundant redeclaration of %qD\",\n+\t       newdecl, newdecl);\n       warned = true;\n     }\n \n@@ -2121,10 +2121,9 @@ pushdecl (tree x)\n \t  visdecl = b->decl;\n \t  vistype = TREE_TYPE (visdecl);\n \t}\n-      if (warn_nested_externs\n-\t  && scope != file_scope\n+      if (scope != file_scope\n \t  && !DECL_IN_SYSTEM_HEADER (x))\n-\twarning (0, \"nested extern declaration of %qD\", x);\n+\twarning (OPT_Wnested_externs, \"nested extern declaration of %qD\", x);\n \n       while (b && !B_IN_EXTERNAL_SCOPE (b))\n \t{\n@@ -3102,7 +3101,7 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && MAIN_NAME_P (DECL_NAME (decl)))\n-    warning (0, \"%J%qD is usually a function\", decl, decl);\n+    warning (OPT_Wmain, \"%J%qD is usually a function\", decl, decl);\n \n   if (initialized)\n     /* Is it valid for this decl to have an initializer at all?\n@@ -4742,9 +4741,9 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n {\n   tree arg_types = arg_info->types;\n \n-  if (warn_strict_prototypes && arg_types == 0 && !funcdef_flag\n-      && !in_system_header)\n-    warning (0, \"function declaration isn%'t a prototype\");\n+  if (arg_types == 0 && !funcdef_flag && !in_system_header)\n+    warning (OPT_Wstrict_prototypes,\n+\t     \"function declaration isn%'t a prototype\");\n \n   if (arg_types == error_mark_node)\n     return 0;  /* don't set TYPE_ARG_TYPES in this case */\n@@ -5893,37 +5892,42 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n       && old_decl != error_mark_node\n       && TYPE_ARG_TYPES (TREE_TYPE (decl1)) == 0\n       && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (0, \"function declaration isn%'t a prototype\");\n+    warning (OPT_Wstrict_prototypes,\n+\t     \"function declaration isn%'t a prototype\");\n   /* Optionally warn of any global def with no previous prototype.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != error_mark_node\n \t   && TREE_PUBLIC (decl1)\n \t   && !MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n-    warning (0, \"%Jno previous prototype for %qD\", decl1, decl1);\n+    warning (OPT_Wmissing_prototypes, \"%Jno previous prototype for %qD\",\n+\t     decl1, decl1);\n   /* Optionally warn of any def with no previous prototype\n      if the function has already been used.  */\n   else if (warn_missing_prototypes\n \t   && old_decl != 0\n \t   && old_decl != error_mark_node\n \t   && TREE_USED (old_decl)\n \t   && TYPE_ARG_TYPES (TREE_TYPE (old_decl)) == 0)\n-    warning (0, \"%J%qD was used with no prototype before its definition\",\n+    warning (OPT_Wmissing_prototypes,\n+\t     \"%J%qD was used with no prototype before its definition\",\n \t     decl1, decl1);\n   /* Optionally warn of any global def with no previous declaration.  */\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n \t   && !MAIN_NAME_P (DECL_NAME (decl1)))\n-    warning (0, \"%Jno previous declaration for %qD\", decl1, decl1);\n+    warning (OPT_Wmissing_declarations, \"%Jno previous declaration for %qD\",\n+\t     decl1, decl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n   else if (warn_missing_declarations\n \t   && old_decl != 0\n \t   && old_decl != error_mark_node\n \t   && TREE_USED (old_decl)\n \t   && C_DECL_IMPLICIT (old_decl))\n-    warning (0, \"%J%qD was used with no declaration before its definition\",\n+    warning (OPT_Wmissing_declarations,\n+\t     \"%J%qD was used with no declaration before its definition\",\n \t     decl1, decl1);\n \n   /* This is a definition, not a reference.\n@@ -6059,9 +6063,10 @@ store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n      warning if we got here because ARG_INFO_TYPES was error_mark_node\n      (this happens when a function definition has just an ellipsis in\n      its parameter list).  */\n-  else if (warn_traditional && !in_system_header && !current_function_scope\n+  else if (!in_system_header && !current_function_scope\n \t   && arg_info->types != error_mark_node)\n-    warning (0, \"%Jtraditional C rejects ISO C style function definitions\",\n+    warning (OPT_Wtraditional,\n+\t     \"%Jtraditional C rejects ISO C style function definitions\",\n \t     fndecl);\n \n   /* Now make all the parameter declarations visible in the function body.\n@@ -6163,7 +6168,8 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  if (flag_isoc99)\n \t    pedwarn (\"%Jtype of %qD defaults to %<int%>\", decl, decl);\n \t  else if (extra_warnings)\n-\t    warning (0, \"%Jtype of %qD defaults to %<int%>\", decl, decl);\n+\t    warning (OPT_Wextra, \"%Jtype of %qD defaults to %<int%>\",\n+\t\t     decl, decl);\n \t}\n \n       TREE_PURPOSE (parm) = decl;\n@@ -6518,7 +6524,8 @@ finish_function (void)\n \t inline function, as we might never be compiled separately.  */\n       && DECL_INLINE (fndecl))\n     {\n-      warning (0, \"no return statement in function returning non-void\");\n+      warning (OPT_Wreturn_type,\n+\t       \"no return statement in function returning non-void\");\n       TREE_NO_WARNING (fndecl) = 1;\n     }\n \n@@ -6527,7 +6534,7 @@ finish_function (void)\n   if (extra_warnings\n       && current_function_returns_value\n       && current_function_returns_null)\n-    warning (0, \"this function may return with or without a value\");\n+    warning (OPT_Wextra, \"this function may return with or without a value\");\n \n   /* Store the end of the function, so that we get good line number\n      info for the epilogue.  */\n@@ -7265,7 +7272,7 @@ declspecs_add_scspec (struct c_declspecs *specs, tree scspec)\n \t      && C_IS_RESERVED_WORD (scspec));\n   i = C_RID_CODE (scspec);\n   if (extra_warnings && specs->non_sc_seen_p)\n-    warning (0, \"%qE is not at beginning of declaration\", scspec);\n+    warning (OPT_Wextra, \"%qE is not at beginning of declaration\", scspec);\n   switch (i)\n     {\n     case RID_INLINE:"}, {"sha": "28eefd95a45e4adb2cb58b13be20c8b35287f8e2", "filename": "gcc/c-format.c", "status": "modified", "additions": 75, "deletions": 61, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -194,7 +194,7 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n       if (info->format_type == format_type_error)\n \t{\n \t  gcc_assert (!validated_p);\n-\t  warning (0, \"%qE is an unrecognized format function type\",\n+\t  warning (OPT_Wformat, \"%qE is an unrecognized format function type\",\n \t\t   format_type_id);\n \t  return false;\n \t}\n@@ -925,7 +925,7 @@ maybe_read_dollar_number (const char **format,\n     {\n       if (dollar_needed)\n \t{\n-\t  warning (0, \"missing $ operand number in format\");\n+\t  warning (OPT_Wformat, \"missing $ operand number in format\");\n \t  return -1;\n \t}\n       else\n@@ -946,7 +946,7 @@ maybe_read_dollar_number (const char **format,\n     {\n       if (dollar_needed)\n \t{\n-\t  warning (0, \"missing $ operand number in format\");\n+\t  warning (OPT_Wformat, \"missing $ operand number in format\");\n \t  return -1;\n \t}\n       else\n@@ -955,14 +955,14 @@ maybe_read_dollar_number (const char **format,\n   *format = fcp + 1;\n   if (pedantic && !dollar_format_warned)\n     {\n-      warning (0, \"%s does not support %%n$ operand number formats\",\n+      warning (OPT_Wformat, \"%s does not support %%n$ operand number formats\",\n \t       C_STD_NAME (STD_EXT));\n       dollar_format_warned = 1;\n     }\n   if (overflow_flag || argnum == 0\n       || (dollar_first_arg_num && argnum > dollar_arguments_count))\n     {\n-      warning (0, \"operand number out of range in format\");\n+      warning (OPT_Wformat, \"operand number out of range in format\");\n       return -1;\n     }\n   if (argnum > dollar_max_arg_used)\n@@ -985,7 +985,7 @@ maybe_read_dollar_number (const char **format,\n       && dollar_arguments_used[argnum - 1] == 1)\n     {\n       dollar_arguments_used[argnum - 1] = 2;\n-      warning (0, \"format argument %d used more than once in %s format\",\n+      warning (OPT_Wformat, \"format argument %d used more than once in %s format\",\n \t       argnum, fki->name);\n     }\n   else\n@@ -1017,7 +1017,7 @@ avoid_dollar_number (const char *format)\n     format++;\n   if (*format == '$')\n     {\n-      warning (0, \"$ operand number used after format without operand number\");\n+      warning (OPT_Wformat, \"$ operand number used after format without operand number\");\n       return true;\n     }\n   return false;\n@@ -1047,7 +1047,8 @@ finish_dollar_format_checking (format_check_results *res, int pointer_gap_ok)\n \t\t\t\t || dollar_arguments_pointer_p[i]))\n \t    found_pointer_gap = true;\n \t  else\n-\t    warning (0, \"format argument %d unused before used argument %d in $-style format\",\n+\t    warning (OPT_Wformat,\n+\t\t     \"format argument %d unused before used argument %d in $-style format\",\n \t\t     i + 1, dollar_max_arg_used);\n \t}\n     }\n@@ -1175,21 +1176,21 @@ check_format_info (function_format_info *info, tree params)\n      If the format is an empty string, this should be counted similarly to the\n      case of extra format arguments.  */\n   if (res.number_extra_args > 0 && res.number_non_literal == 0\n-      && res.number_other == 0 && warn_format_extra_args)\n-    warning (0, \"too many arguments for format\");\n+      && res.number_other == 0)\n+    warning (OPT_Wformat_extra_args, \"too many arguments for format\");\n   if (res.number_dollar_extra_args > 0 && res.number_non_literal == 0\n-      && res.number_other == 0 && warn_format_extra_args)\n-    warning (0, \"unused arguments in $-style format\");\n+      && res.number_other == 0)\n+    warning (OPT_Wformat_extra_args, \"unused arguments in $-style format\");\n   if (res.number_empty > 0 && res.number_non_literal == 0\n-      && res.number_other == 0 && warn_format_zero_length)\n-    warning (0, \"zero-length %s format string\",\n+      && res.number_other == 0)\n+    warning (OPT_Wformat_zero_length, \"zero-length %s format string\",\n \t     format_types[info->format_type].name);\n \n   if (res.number_wide > 0)\n-    warning (0, \"format is a wide character string\");\n+    warning (OPT_Wformat, \"format is a wide character string\");\n \n   if (res.number_unterminated > 0)\n-    warning (0, \"unterminated format string\");\n+    warning (OPT_Wformat, \"unterminated format string\");\n }\n \n /* Callback from check_function_arguments_recurse to check a\n@@ -1403,7 +1404,7 @@ check_format_info_main (format_check_results *res,\n       if (*format_chars == 0)\n \t{\n \t  if (format_chars - orig_format_chars != format_length)\n-\t    warning (0, \"embedded %<\\\\0%> in format\");\n+\t    warning (OPT_Wformat, \"embedded %<\\\\0%> in format\");\n \t  if (info->first_arg_num != 0 && params != 0\n \t      && has_operand_number <= 0)\n \t    {\n@@ -1418,7 +1419,7 @@ check_format_info_main (format_check_results *res,\n \tcontinue;\n       if (*format_chars == 0)\n \t{\n-\t  warning (0, \"spurious trailing %<%%%> in format\");\n+\t  warning (OPT_Wformat, \"spurious trailing %<%%%> in format\");\n \t  continue;\n \t}\n       if (*format_chars == '%')\n@@ -1462,7 +1463,7 @@ check_format_info_main (format_check_results *res,\n \t\t\t\t\t\t     *format_chars, NULL);\n \t  if (strchr (flag_chars, *format_chars) != 0)\n \t    {\n-\t      warning (0, \"repeated %s in format\", _(s->name));\n+\t      warning (OPT_Wformat, \"repeated %s in format\", _(s->name));\n \t    }\n \t  else\n \t    {\n@@ -1475,7 +1476,7 @@ check_format_info_main (format_check_results *res,\n \t      ++format_chars;\n \t      if (*format_chars == 0)\n \t\t{\n-\t\t  warning (0, \"missing fill character at end of strfmon format\");\n+\t\t  warning (OPT_Wformat, \"missing fill character at end of strfmon format\");\n \t\t  return;\n \t\t}\n \t    }\n@@ -1519,7 +1520,7 @@ check_format_info_main (format_check_results *res,\n \t\t{\n \t\t  if (params == 0)\n \t\t    {\n-\t\t      warning (0, \"too few arguments for format\");\n+\t\t      warning (OPT_Wformat, \"too few arguments for format\");\n \t\t      return;\n \t\t    }\n \t\t  cur_param = TREE_VALUE (params);\n@@ -1560,7 +1561,7 @@ check_format_info_main (format_check_results *res,\n \t\t}\n \t      if (found_width && !non_zero_width_char &&\n \t\t  (fki->flags & (int) FMT_FLAG_ZERO_WIDTH_BAD))\n-\t\twarning (0, \"zero width in %s format\", fki->name);\n+\t\twarning (OPT_Wformat, \"zero width in %s format\", fki->name);\n \t      if (found_width)\n \t\t{\n \t\t  i = strlen (flag_chars);\n@@ -1578,7 +1579,7 @@ check_format_info_main (format_check_results *res,\n \t  flag_chars[i++] = fki->left_precision_char;\n \t  flag_chars[i] = 0;\n \t  if (!ISDIGIT (*format_chars))\n-\t    warning (0, \"empty left precision in %s format\", fki->name);\n+\t    warning (OPT_Wformat, \"empty left precision in %s format\", fki->name);\n \t  while (ISDIGIT (*format_chars))\n \t    ++format_chars;\n \t}\n@@ -1621,7 +1622,7 @@ check_format_info_main (format_check_results *res,\n \t\t{\n \t\t  if (params == 0)\n \t\t    {\n-\t\t      warning (0, \"too few arguments for format\");\n+\t\t      warning (OPT_Wformat, \"too few arguments for format\");\n \t\t      return;\n \t\t    }\n \t\t  cur_param = TREE_VALUE (params);\n@@ -1651,7 +1652,7 @@ check_format_info_main (format_check_results *res,\n \t    {\n \t      if (!(fki->flags & (int) FMT_FLAG_EMPTY_PREC_OK)\n \t\t  && !ISDIGIT (*format_chars))\n-\t\twarning (0, \"empty precision in %s format\", fki->name);\n+\t\twarning (OPT_Wformat, \"empty precision in %s format\", fki->name);\n \t      while (ISDIGIT (*format_chars))\n \t\t++format_chars;\n \t    }\n@@ -1690,7 +1691,8 @@ check_format_info_main (format_check_results *res,\n \t    {\n \t      /* Warn if the length modifier is non-standard.  */\n \t      if (ADJ_STD (length_chars_std) > C_STD_VER)\n-\t\twarning (0, \"%s does not support the %qs %s length modifier\",\n+\t\twarning (OPT_Wformat,\n+\t\t\t \"%s does not support the %qs %s length modifier\",\n \t\t\t C_STD_NAME (length_chars_std), length_chars,\n \t\t\t fki->name);\n \t    }\n@@ -1706,7 +1708,7 @@ check_format_info_main (format_check_results *res,\n \t\t{\n \t\t  const format_flag_spec *s = get_flag_spec (flag_specs,\n \t\t\t\t\t\t\t     *format_chars, NULL);\n-\t\t  warning (0, \"repeated %s in format\", _(s->name));\n+\t\t  warning (OPT_Wformat, \"repeated %s in format\", _(s->name));\n \t\t}\n \t      else\n \t\t{\n@@ -1740,7 +1742,7 @@ check_format_info_main (format_check_results *res,\n \t  || (!(fki->flags & (int) FMT_FLAG_FANCY_PERCENT_OK)\n \t      && format_char == '%'))\n \t{\n-\t  warning (0, \"conversion lacks type at end of format\");\n+\t  warning (OPT_Wformat, \"conversion lacks type at end of format\");\n \t  continue;\n \t}\n       format_chars++;\n@@ -1751,17 +1753,17 @@ check_format_info_main (format_check_results *res,\n       if (fci->format_chars == 0)\n \t{\n           if (ISGRAPH (format_char))\n-\t    warning (0, \"unknown conversion type character %qc in format\",\n+\t    warning (OPT_Wformat, \"unknown conversion type character %qc in format\",\n \t\t     format_char);\n \t  else\n-\t    warning (0, \"unknown conversion type character 0x%x in format\",\n+\t    warning (OPT_Wformat, \"unknown conversion type character 0x%x in format\",\n \t\t     format_char);\n \t  continue;\n \t}\n       if (pedantic)\n \t{\n \t  if (ADJ_STD (fci->std) > C_STD_VER)\n-\t    warning (0, \"%s does not support the %<%%%c%> %s format\",\n+\t    warning (OPT_Wformat, \"%s does not support the %<%%%c%> %s format\",\n \t\t     C_STD_NAME (fci->std), format_char, fki->name);\n \t}\n \n@@ -1777,7 +1779,7 @@ check_format_info_main (format_check_results *res,\n \t      continue;\n \t    if (strchr (fci->flag_chars, flag_chars[i]) == 0)\n \t      {\n-\t\twarning (0, \"%s used with %<%%%c%> %s format\",\n+\t\twarning (OPT_Wformat, \"%s used with %<%%%c%> %s format\",\n \t\t\t _(s->name), format_char, fki->name);\n \t\td++;\n \t\tcontinue;\n@@ -1786,7 +1788,7 @@ check_format_info_main (format_check_results *res,\n \t      {\n \t\tconst format_flag_spec *t;\n \t\tif (ADJ_STD (s->std) > C_STD_VER)\n-\t\t  warning (0, \"%s does not support %s\",\n+\t\t  warning (OPT_Wformat, \"%s does not support %s\",\n \t\t\t   C_STD_NAME (s->std), _(s->long_name));\n \t\tt = get_flag_spec (flag_specs, flag_chars[i], fci->flags2);\n \t\tif (t != NULL && ADJ_STD (t->std) > ADJ_STD (s->std))\n@@ -1795,7 +1797,8 @@ check_format_info_main (format_check_results *res,\n \t\t\t\t\t     ? t->long_name\n \t\t\t\t\t     : s->long_name);\n \t\t    if (ADJ_STD (t->std) > C_STD_VER)\n-\t\t      warning (0, \"%s does not support %s with the %<%%%c%> %s format\",\n+\t\t      warning (OPT_Wformat,\n+\t\t\t       \"%s does not support %s with the %<%%%c%> %s format\",\n \t\t\t       C_STD_NAME (t->std), _(long_name),\n \t\t\t       format_char, fki->name);\n \t\t  }\n@@ -1828,21 +1831,23 @@ check_format_info_main (format_check_results *res,\n \t  if (bad_flag_pairs[i].ignored)\n \t    {\n \t      if (bad_flag_pairs[i].predicate != 0)\n-\t\twarning (0, \"%s ignored with %s and %<%%%c%> %s format\",\n+\t\twarning (OPT_Wformat,\n+\t\t\t \"%s ignored with %s and %<%%%c%> %s format\",\n \t\t\t _(s->name), _(t->name), format_char,\n \t\t\t fki->name);\n \t      else\n-\t\twarning (0, \"%s ignored with %s in %s format\",\n+\t\twarning (OPT_Wformat, \"%s ignored with %s in %s format\",\n \t\t\t _(s->name), _(t->name), fki->name);\n \t    }\n \t  else\n \t    {\n \t      if (bad_flag_pairs[i].predicate != 0)\n-\t\twarning (0, \"use of %s and %s together with %<%%%c%> %s format\",\n+\t\twarning (OPT_Wformat,\n+\t\t\t \"use of %s and %s together with %<%%%c%> %s format\",\n \t\t\t _(s->name), _(t->name), format_char,\n \t\t\t fki->name);\n \t      else\n-\t\twarning (0, \"use of %s and %s together in %s format\",\n+\t\twarning (OPT_Wformat, \"use of %s and %s together in %s format\",\n \t\t\t _(s->name), _(t->name), fki->name);\n \t    }\n \t}\n@@ -1861,10 +1866,11 @@ check_format_info_main (format_check_results *res,\n \t  else if (strchr (fci->flags2, '2') != 0)\n \t    y2k_level = 2;\n \t  if (y2k_level == 3)\n-\t    warning (0, \"%<%%%c%> yields only last 2 digits of year in some locales\",\n-\t\t     format_char);\n+\t    warning (OPT_Wformat_y2k, \"%<%%%c%> yields only last 2 digits of \"\n+\t\t     \"year in some locales\", format_char);\n \t  else if (y2k_level == 2)\n-\t    warning (0, \"%<%%%c%> yields only last 2 digits of year\", format_char);\n+\t    warning (OPT_Wformat_y2k, \"%<%%%c%> yields only last 2 digits of \"\n+\t\t     \"year\", format_char);\n \t}\n \n       if (strchr (fci->flags2, '[') != 0)\n@@ -1880,7 +1886,7 @@ check_format_info_main (format_check_results *res,\n \t    ++format_chars;\n \t  if (*format_chars != ']')\n \t    /* The end of the format string was reached.  */\n-\t    warning (0, \"no closing %<]%> for %<%%[%> format\");\n+\t    warning (OPT_Wformat, \"no closing %<]%> for %<%%[%> format\");\n \t}\n \n       wanted_type = 0;\n@@ -1893,14 +1899,15 @@ check_format_info_main (format_check_results *res,\n \t  wanted_type_std = fci->types[length_chars_val].std;\n \t  if (wanted_type == 0)\n \t    {\n-\t      warning (0, \"use of %qs length modifier with %qc type character\",\n+\t      warning (OPT_Wformat,\n+\t\t       \"use of %qs length modifier with %qc type character\",\n \t\t       length_chars, format_char);\n \t      /* Heuristic: skip one argument when an invalid length/type\n \t\t combination is encountered.  */\n \t      arg_num++;\n \t      if (params == 0)\n \t\t{\n-\t\t  warning (0, \"too few arguments for format\");\n+\t\t  warning (OPT_Wformat, \"too few arguments for format\");\n \t\t  return;\n \t\t}\n \t      params = TREE_CHAIN (params);\n@@ -1914,7 +1921,8 @@ check_format_info_main (format_check_results *res,\n \t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n \t    {\n \t      if (ADJ_STD (wanted_type_std) > C_STD_VER)\n-\t\twarning (0, \"%s does not support the %<%%%s%c%> %s format\",\n+\t\twarning (OPT_Wformat,\n+\t\t\t \"%s does not support the %<%%%s%c%> %s format\",\n \t\t\t C_STD_NAME (wanted_type_std), length_chars,\n \t\t\t format_char, fki->name);\n \t    }\n@@ -1931,9 +1939,11 @@ check_format_info_main (format_check_results *res,\n \t  if (main_arg_num != 0)\n \t    {\n \t      if (suppressed)\n-\t\twarning (0, \"operand number specified with suppressed assignment\");\n+\t\twarning (OPT_Wformat, \"operand number specified with \"\n+\t\t\t \"suppressed assignment\");\n \t      else\n-\t\twarning (0, \"operand number specified for format taking no argument\");\n+\t\twarning (OPT_Wformat, \"operand number specified for format \"\n+\t\t\t \"taking no argument\");\n \t    }\n \t}\n       else\n@@ -1950,7 +1960,7 @@ check_format_info_main (format_check_results *res,\n \t      ++arg_num;\n \t      if (has_operand_number > 0)\n \t\t{\n-\t\t  warning (0, \"missing $ operand number in format\");\n+\t\t  warning (OPT_Wformat, \"missing $ operand number in format\");\n \t\t  return;\n \t\t}\n \t      else\n@@ -1962,7 +1972,7 @@ check_format_info_main (format_check_results *res,\n \t    {\n \t      if (params == 0)\n \t\t{\n-\t\t  warning (0, \"too few arguments for format\");\n+\t\t  warning (OPT_Wformat, \"too few arguments for format\");\n \t\t  return;\n \t\t}\n \n@@ -2075,16 +2085,16 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t\t  && i == 0\n \t\t  && cur_param != 0\n \t\t  && integer_zerop (cur_param))\n-\t\twarning (0, \"writing through null pointer (argument %d)\",\n-\t\t\t arg_num);\n+\t\twarning (OPT_Wformat, \"writing through null pointer \"\n+\t\t\t \"(argument %d)\", arg_num);\n \n \t      /* Check for reading through a NULL pointer.  */\n \t      if (types->reading_from_flag\n \t\t  && i == 0\n \t\t  && cur_param != 0\n \t\t  && integer_zerop (cur_param))\n-\t\twarning (0, \"reading through null pointer (argument %d)\",\n-\t\t\t arg_num);\n+\t\twarning (OPT_Wformat, \"reading through null pointer \"\n+\t\t\t \"(argument %d)\", arg_num);\n \n \t      if (cur_param != 0 && TREE_CODE (cur_param) == ADDR_EXPR)\n \t\tcur_param = TREE_OPERAND (cur_param, 0);\n@@ -2103,8 +2113,8 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t\t\t  && (CONSTANT_CLASS_P (cur_param)\n \t\t\t      || (DECL_P (cur_param)\n \t\t\t\t  && TREE_READONLY (cur_param))))))\n-\t\twarning (0, \"writing into constant object (argument %d)\",\n-\t\t\t arg_num);\n+\t\twarning (OPT_Wformat, \"writing into constant object \"\n+\t\t\t \"(argument %d)\", arg_num);\n \n \t      /* If there are extra type qualifiers beyond the first\n \t\t indirection, then this makes the types technically\n@@ -2114,8 +2124,8 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t\t  && (TYPE_READONLY (cur_type)\n \t\t      || TYPE_VOLATILE (cur_type)\n \t\t      || TYPE_RESTRICT (cur_type)))\n-\t\twarning (0, \"extra type qualifiers in format argument \"\n-\t\t\t \"(argument %d)\",\n+\t\twarning (OPT_Wformat, \"extra type qualifiers in format \"\n+\t\t\t \"argument (argument %d)\",\n \t\t\t arg_num);\n \n \t    }\n@@ -2225,20 +2235,24 @@ format_type_warning (const char *descr, const char *format_start,\n   if (wanted_type_name)\n     {\n       if (descr)\n-\twarning (0, \"%s should have type %<%s%s%>, but argument %d has type %qT\",\n+\twarning (OPT_Wformat, \"%s should have type %<%s%s%>, \"\n+\t\t \"but argument %d has type %qT\",\n \t\t descr, wanted_type_name, p, arg_num, arg_type);\n       else\n-\twarning (0, \"format %q.*s expects type %<%s%s%>, but argument %d has type %qT\",\n+\twarning (OPT_Wformat, \"format %q.*s expects type %<%s%s%>, \"\n+\t\t \"but argument %d has type %qT\",\n \t\t format_length, format_start, wanted_type_name, p,\n \t\t arg_num, arg_type);\n     }\n   else\n     {\n       if (descr)\n-\twarning (0, \"%s should have type %<%T%s%>, but argument %d has type %qT\",\n+\twarning (OPT_Wformat, \"%s should have type %<%T%s%>, \"\n+\t\t \"but argument %d has type %qT\",\n \t\t descr, wanted_type, p, arg_num, arg_type);\n       else\n-\twarning (0, \"format %q.*s expects type %<%T%s%>, but argument %d has type %qT\",\n+\twarning (OPT_Wformat, \"format %q.*s expects type %<%T%s%>, \"\n+\t\t \"but argument %d has type %qT\",\n \t\t format_length, format_start, wanted_type, p, arg_num, arg_type);\n     }\n }"}, {"sha": "da826d4411464c483f02e3dc3506d4dcf9160415", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -1064,7 +1064,7 @@ function_types_compatible_p (tree f1, tree f2)\n \treturn 0;\n       /* If one of these types comes from a non-prototype fn definition,\n \t compare that with the other type's arglist.\n-\t If they don't match, ask for a warning (0, but no error).  */\n+\t If they don't match, ask for a warning (but no error).  */\n       if (TYPE_ACTUAL_ARG_TYPES (f1)\n \t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1)))\n \tval = 2;\n@@ -1721,9 +1721,9 @@ build_array_ref (tree array, tree index)\n      deliberately.  ??? Existing practice has also been to warn only\n      when the char index is syntactically the index, not for\n      char[array].  */\n-  if (warn_char_subscripts && !swapped\n+  if (!swapped\n       && TYPE_MAIN_VARIANT (TREE_TYPE (index)) == char_type_node)\n-    warning (0, \"array subscript has type %<char%>\");\n+    warning (OPT_Wchar_subscripts, \"array subscript has type %<char%>\");\n \n   /* Apply default promotions *after* noticing character types.  */\n   index = default_conversion (index);\n@@ -2234,8 +2234,9 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t\t\t   and the actual arg is that enum type.  */\n \t\t\t;\n \t\t      else if (formal_prec != TYPE_PRECISION (type1))\n-\t\t\twarning (0, \"passing argument %d of %qE with different \"\n-\t\t\t\t \"width due to prototype\", argnum, rname);\n+\t\t\twarning (OPT_Wconversion, \"passing argument %d of %qE \"\n+\t\t\t\t \"with different width due to prototype\",\n+\t\t\t\t argnum, rname);\n \t\t      else if (TYPE_UNSIGNED (type) == TYPE_UNSIGNED (type1))\n \t\t\t;\n \t\t      /* Don't complain if the formal parameter type\n@@ -2256,11 +2257,12 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t\t\t       && TYPE_UNSIGNED (TREE_TYPE (val)))\n \t\t\t;\n \t\t      else if (TYPE_UNSIGNED (type))\n-\t\t\twarning (0, \"passing argument %d of %qE as unsigned \"\n-\t\t\t\t \"due to prototype\", argnum, rname);\n+\t\t\twarning (OPT_Wconversion, \"passing argument %d of %qE \"\n+\t\t\t\t \"as unsigned due to prototype\",\n+\t\t\t\t argnum, rname);\n \t\t      else\n-\t\t\twarning (0, \"passing argument %d of %qE as signed \"\n-\t\t\t\t \"due to prototype\", argnum, rname);\n+\t\t\twarning (OPT_Wconversion, \"passing argument %d of %qE \"\n+\t\t\t\t \"as signed due to prototype\", argnum, rname);\n \t\t    }\n \t\t}\n \n@@ -3249,7 +3251,7 @@ build_c_cast (tree type, tree expr)\n \t}\n \n       /* Warn about possible alignment problems.  */\n-      if (STRICT_ALIGNMENT && warn_cast_align\n+      if (STRICT_ALIGNMENT\n \t  && TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (otype)) != VOID_TYPE\n@@ -3260,28 +3262,28 @@ build_c_cast (tree type, tree expr)\n \t\t|| TREE_CODE (TREE_TYPE (otype)) == RECORD_TYPE)\n \t       && TYPE_MODE (TREE_TYPE (otype)) == VOIDmode)\n \t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (otype)))\n-\twarning (0, \"cast increases required alignment of target type\");\n+\twarning (OPT_Wcast_align,\n+\t\t \"cast increases required alignment of target type\");\n \n-      if (warn_pointer_to_int_cast\n-\t  && TREE_CODE (type) == INTEGER_TYPE\n+      if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n \t  && !TREE_CONSTANT (value))\n-\twarning (0, \"cast from pointer to integer of different size\");\n+\twarning (OPT_Wpointer_to_int_cast,\n+\t\t \"cast from pointer to integer of different size\");\n \n-      if (warn_bad_function_cast\n-\t  && TREE_CODE (value) == CALL_EXPR\n+      if (TREE_CODE (value) == CALL_EXPR\n \t  && TREE_CODE (type) != TREE_CODE (otype))\n-\twarning (0, \"cast from function call of type %qT to non-matching \"\n-\t\t \"type %qT\", otype, type);\n+\twarning (OPT_Wbad_function_cast, \"cast from function call of type %qT \"\n+\t\t \"to non-matching type %qT\", otype, type);\n \n-      if (warn_int_to_pointer_cast\n-\t  && TREE_CODE (type) == POINTER_TYPE\n+      if (TREE_CODE (type) == POINTER_TYPE\n \t  && TREE_CODE (otype) == INTEGER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype)\n \t  /* Don't warn about converting any constant.  */\n \t  && !TREE_CONSTANT (value))\n-\twarning (0, \"cast to pointer from integer of different size\");\n+\twarning (OPT_Wint_to_pointer_cast, \"cast to pointer from integer \"\n+\t\t \"of different size\");\n \n       if (flag_strict_aliasing && warn_strict_aliasing\n \t  && TREE_CODE (type) == POINTER_TYPE\n@@ -3294,17 +3296,20 @@ build_c_cast (tree type, tree expr)\n \t  /* Casting the address of an object to non void pointer. Warn\n \t     if the cast breaks type based aliasing.  */\n \t  if (!COMPLETE_TYPE_P (TREE_TYPE (type)))\n-\t    warning (0, \"type-punning to incomplete type might break strict-aliasing rules\");\n+\t    warning (OPT_Wstrict_aliasing, \"type-punning to incomplete type \"\n+\t\t     \"might break strict-aliasing rules\");\n \t  else\n \t    {\n \t      HOST_WIDE_INT set1 = get_alias_set (TREE_TYPE (TREE_OPERAND (expr, 0)));\n \t      HOST_WIDE_INT set2 = get_alias_set (TREE_TYPE (type));\n \n \t      if (!alias_sets_conflict_p (set1, set2))\n-\t\twarning (0, \"dereferencing type-punned pointer will break strict-aliasing rules\");\n+\t\twarning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t\t \"pointer will break strict-aliasing rules\");\n \t      else if (warn_strict_aliasing > 1\n \t\t       && !alias_sets_might_conflict_p (set1, set2))\n-\t\twarning (0, \"dereferencing type-punned pointer might break strict-aliasing rules\");\n+\t\twarning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t\t \"pointer might break strict-aliasing rules\");\n \t    }\n \t}\n \n@@ -3998,9 +4003,10 @@ store_init_value (tree decl, tree init)\n \n   /* Store the expression if valid; else report error.  */\n \n-  if (warn_traditional && !in_system_header\n+  if (!in_system_header\n       && AGGREGATE_TYPE_P (TREE_TYPE (decl)) && !TREE_STATIC (decl))\n-    warning (0, \"traditional C rejects automatic aggregate initialization\");\n+    warning (OPT_Wtraditional, \"traditional C rejects automatic \"\n+\t     \"aggregate initialization\");\n \n   DECL_INITIAL (decl) = value;\n \n@@ -6240,10 +6246,11 @@ process_init_element (struct c_expr value)\n \t     again on the assumption that this must be conditional on\n \t     __STDC__ anyway (and we've already complained about the\n \t     member-designator already).  */\n-\t  if (warn_traditional && !in_system_header && !constructor_designated\n+\t  if (!in_system_header && !constructor_designated\n \t      && !(value.value && (integer_zerop (value.value)\n \t\t\t\t   || real_zerop (value.value))))\n-\t    warning (0, \"traditional C rejects initialization of unions\");\n+\t    warning (OPT_Wtraditional, \"traditional C rejects initialization \"\n+\t\t     \"of unions\");\n \n \t  /* Accept a string constant to initialize a subarray.  */\n \t  if (value.value != 0\n@@ -6751,11 +6758,11 @@ c_start_case (tree exp)\n \t{\n \t  type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n-\t  if (warn_traditional && !in_system_header\n+\t  if (!in_system_header\n \t      && (type == long_integer_type_node\n \t\t  || type == long_unsigned_type_node))\n-\t    warning (0, \"%<long%> switch expression not converted to \"\n-\t\t     \"%<int%> in ISO C\");\n+\t    warning (OPT_Wtraditional, \"%<long%> switch expression not \"\n+\t\t     \"converted to %<int%> in ISO C\");\n \n \t  exp = default_conversion (exp);\n \t  type = TREE_TYPE (exp);"}, {"sha": "50228b71e1da0682ed5ea1db1e450f506e6fa3cd", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -1266,9 +1266,9 @@ finalize_record_size (record_layout_info rli)\n   TYPE_SIZE_UNIT (rli->t)\n     = round_up (unpadded_size_unit, TYPE_ALIGN_UNIT (rli->t));\n \n-  if (warn_padded && TREE_CONSTANT (unpadded_size)\n+  if (TREE_CONSTANT (unpadded_size)\n       && simple_cst_equal (unpadded_size, TYPE_SIZE (rli->t)) == 0)\n-    warning (0, \"padding struct size to alignment boundary\");\n+    warning (OPT_Wpadded, \"padding struct size to alignment boundary\");\n \n   if (warn_packed && TREE_CODE (rli->t) == RECORD_TYPE\n       && TYPE_PACKED (rli->t) && ! rli->packed_maybe_necessary\n@@ -1298,19 +1298,19 @@ finalize_record_size (record_layout_info rli)\n \t\tname = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (rli->t)));\n \n \t      if (STRICT_ALIGNMENT)\n-\t\twarning (OPT_Wattributes, \"packed attribute causes inefficient \"\n+\t\twarning (OPT_Wpacked, \"packed attribute causes inefficient \"\n \t\t\t \"alignment for %qs\", name);\n \t      else\n-\t\twarning (OPT_Wattributes,\n+\t\twarning (OPT_Wpacked,\n \t\t\t \"packed attribute is unnecessary for %qs\", name);\n \t    }\n \t  else\n \t    {\n \t      if (STRICT_ALIGNMENT)\n-\t\twarning (OPT_Wattributes,\n+\t\twarning (OPT_Wpacked,\n \t\t\t \"packed attribute causes inefficient alignment\");\n \t      else\n-\t\twarning (OPT_Wattributes, \"packed attribute is unnecessary\");\n+\t\twarning (OPT_Wpacked, \"packed attribute is unnecessary\");\n \t    }\n \t}\n     }"}, {"sha": "0a9defdfdd028e6e6dafdcab865e4c5b14526eb3", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -5130,8 +5130,8 @@ execute_warn_function_noreturn (void)\n       && !TREE_THIS_VOLATILE (cfun->decl)\n       && EDGE_COUNT (EXIT_BLOCK_PTR->preds) == 0\n       && !lang_hooks.function.missing_noreturn_ok_p (cfun->decl))\n-    warning (0, \"%Jfunction might be possible candidate for \"\n-\t     \"attribute %<noreturn%>\",\n+    warning (OPT_Wmissing_noreturn, \"%Jfunction might be possible candidate \"\n+\t     \"for attribute %<noreturn%>\",\n \t     cfun->decl);\n }\n "}, {"sha": "16f61648c26a2edad0efc481299c2522996496ef", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3176a0c28f6c38963c5beecdbbd44a91b62fc8eb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=3176a0c28f6c38963c5beecdbbd44a91b62fc8eb", "patch": "@@ -1973,8 +1973,9 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n \t       /* Avoid warnings during early inline pass. */\n \t       && (!flag_unit_at_a_time || cgraph_global_info_ready))\n \t{\n-\t  warning (0, \"%Jinlining failed in call to %qF: %s\", fn, fn, reason);\n-\t  warning (0, \"called from here\");\n+\t  warning (OPT_Winline, \"%Jinlining failed in call to %qF: %s\",\n+\t\t   fn, fn, reason);\n+\t  warning (OPT_Winline, \"called from here\");\n \t}\n       goto egress;\n     }"}]}