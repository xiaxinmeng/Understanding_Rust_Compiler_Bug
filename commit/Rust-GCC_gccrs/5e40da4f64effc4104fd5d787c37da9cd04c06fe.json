{"sha": "5e40da4f64effc4104fd5d787c37da9cd04c06fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU0MGRhNGY2NGVmZmM0MTA0ZmQ1ZDc4N2MzN2RhOWNkMDRjMDZmZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-10-23T16:19:17Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-10-23T16:19:17Z"}, "message": "re PR tree-optimization/58775 (reassoc1 causes an ICE with some bool arithmetic)\n\n\tPR tree-optimization/58775\n\tPR tree-optimization/58791\n\t* tree-ssa-reassoc.c (reassoc_stmt_dominates_stmt_p): New function.\n\t(insert_stmt_after): Rewritten, don't move the stmt, but really\n\tinsert it.\n\t(get_stmt_uid_with_default): Remove.\n\t(build_and_add_sum): Use insert_stmt_after and\n\treassoc_stmt_dominates_stmt_p.  Fix up uid if bb contains only\n\tlabels.\n\t(update_range_test): Set uid on stmts added by\n\tforce_gimple_operand_gsi.  Don't immediately modify statements\n\tin inter-bb optimization, just update oe->op values.\n\t(optimize_range_tests): Return bool whether any changed have\n\tbeen made.\n\t(update_ops): New function.\n\t(struct inter_bb_range_test_entry): New type.\n\t(maybe_optimize_range_tests): Perform statement changes here.\n\t(not_dominated_by, appears_later_in_bb, get_def_stmt,\n\tensure_ops_are_available): Remove.\n\t(find_insert_point): Rewritten.\n\t(rewrite_expr_tree): Remove MOVED argument, add CHANGED argument,\n\treturn LHS of the (new resp. old) stmt.  Don't call\n\tensure_ops_are_available, don't reuse SSA_NAMEs, recurse first\n\tinstead of last, move new stmt at the right place.\n\t(linearize_expr, repropagate_negates): Don't reuse SSA_NAMEs.\n\t(negate_value): Likewise.  Set uids.\n\t(break_up_subtract_bb): Initialize uids.\n\t(reassociate_bb): Adjust rewrite_expr_tree caller.\n\t(do_reassoc): Don't call renumber_gimple_stmt_uids.\n\n\t* gcc.dg/guality/pr58791-1.c: New test.\n\t* gcc.dg/guality/pr58791-2.c: New test.\n\t* gcc.dg/guality/pr58791-3.c: New test.\n\t* gcc.dg/guality/pr58791-4.c: New test.\n\t* gcc.dg/guality/pr58791-5.c: New test.\n\t* gcc.c-torture/compile/pr58775.c: New test.\n\t* gcc.dg/tree-ssa/reassoc-28.c: Don't scan reassoc1 dump.\n\nFrom-SVN: r203979", "tree": {"sha": "34ae5eaab26f3dd03c67f7a71c93a091959e8933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34ae5eaab26f3dd03c67f7a71c93a091959e8933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e40da4f64effc4104fd5d787c37da9cd04c06fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e40da4f64effc4104fd5d787c37da9cd04c06fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e40da4f64effc4104fd5d787c37da9cd04c06fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e40da4f64effc4104fd5d787c37da9cd04c06fe/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "66caf47a508ded59e309951acee220081bc98afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66caf47a508ded59e309951acee220081bc98afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66caf47a508ded59e309951acee220081bc98afc"}], "stats": {"total": 1028, "additions": 659, "deletions": 369}, "files": [{"sha": "26b02e8d1acb2a600523bcccf0551fc798e1bf1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -1,3 +1,35 @@\n+2013-10-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/58775\n+\tPR tree-optimization/58791\n+\t* tree-ssa-reassoc.c (reassoc_stmt_dominates_stmt_p): New function.\n+\t(insert_stmt_after): Rewritten, don't move the stmt, but really\n+\tinsert it.\n+\t(get_stmt_uid_with_default): Remove.\n+\t(build_and_add_sum): Use insert_stmt_after and\n+\treassoc_stmt_dominates_stmt_p.  Fix up uid if bb contains only\n+\tlabels.\n+\t(update_range_test): Set uid on stmts added by\n+\tforce_gimple_operand_gsi.  Don't immediately modify statements\n+\tin inter-bb optimization, just update oe->op values.\n+\t(optimize_range_tests): Return bool whether any changed have\n+\tbeen made.\n+\t(update_ops): New function.\n+\t(struct inter_bb_range_test_entry): New type.\n+\t(maybe_optimize_range_tests): Perform statement changes here.\n+\t(not_dominated_by, appears_later_in_bb, get_def_stmt,\n+\tensure_ops_are_available): Remove.\n+\t(find_insert_point): Rewritten.\n+\t(rewrite_expr_tree): Remove MOVED argument, add CHANGED argument,\n+\treturn LHS of the (new resp. old) stmt.  Don't call\n+\tensure_ops_are_available, don't reuse SSA_NAMEs, recurse first\n+\tinstead of last, move new stmt at the right place.\n+\t(linearize_expr, repropagate_negates): Don't reuse SSA_NAMEs.\n+\t(negate_value): Likewise.  Set uids.\n+\t(break_up_subtract_bb): Initialize uids.\n+\t(reassociate_bb): Adjust rewrite_expr_tree caller.\n+\t(do_reassoc): Don't call renumber_gimple_stmt_uids.\n+\n 2013-10-23  David Edelsohn  <dje.gcc@gmail.com>\n \n \tPR target/58838"}, {"sha": "9276a1153fe8db94cc802bea9529bccca67a35c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -1,3 +1,15 @@\n+2013-10-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/58775\n+\tPR tree-optimization/58791\n+\t* gcc.dg/guality/pr58791-1.c: New test.\n+\t* gcc.dg/guality/pr58791-2.c: New test.\n+\t* gcc.dg/guality/pr58791-3.c: New test.\n+\t* gcc.dg/guality/pr58791-4.c: New test.\n+\t* gcc.dg/guality/pr58791-5.c: New test.\n+\t* gcc.c-torture/compile/pr58775.c: New test.\n+\t* gcc.dg/tree-ssa/reassoc-28.c: Don't scan reassoc1 dump.\n+\n 2013-10-23  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/58805"}, {"sha": "8de06ddc05ca3c7c31e77d08ac7c136a79867267", "filename": "gcc/testsuite/gcc.c-torture/compile/pr58775.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58775.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58775.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr58775.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -0,0 +1,26 @@\n+/* PR tree-optimization/58775 */\n+\n+void bar (void);\n+\n+void\n+foo (char *x)\n+{\n+  char a;\n+  _Bool b, c, d, e, f, g, h, i, j, k, l, m;\n+\n+  a = *x;\n+  b = a == 100;\n+  c = a == 105;\n+  d = b | c;\n+  e = a != 111;\n+  f = !d;\n+  g = e & f;\n+  h = a != 117;\n+  i = g & h;\n+  j = a != 120;\n+  k = i & j;\n+  l = a != 88;\n+  m = k & l;\n+  if (m == 0)\n+    bar ();\n+}"}, {"sha": "62ce881bfc240a6f45481355d760bb4fc23fa543", "filename": "gcc/testsuite/gcc.dg/guality/pr58791-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-1.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -0,0 +1,34 @@\n+/* PR tree-optimization/58791 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"../nop.h\"\n+\n+__attribute__((noinline, noclone)) int\n+foo (int x, int y)\n+{\n+  _Bool a = x != 0;\n+  _Bool b = y != 2;\n+  _Bool c = a & b;\n+  _Bool d = !c;\n+  int ret;\n+  if (c)\n+    {\n+      if (y < 3 || y > 4)\n+\tret = 1;\n+      else\n+\tret = 0;\n+    }\n+  else\n+    ret = 0;\n+  asm volatile (NOP : : : \"memory\");\t/* { dg-final { gdb-test pr58791-1.c:25 \"c & 1\" \"1\" } } */\n+  asm volatile (NOP : : : \"memory\");\t/* { dg-final { gdb-test pr58791-1.c:25 \"d & 1\" \"0\" } } */\n+  return ret;\n+}\n+\n+int\n+main ()\n+{\n+  foo (1, 3);\n+  return 0;\n+}"}, {"sha": "d7da69b48c4b392fe82b9428cfc260b4b53c98ba", "filename": "gcc/testsuite/gcc.dg/guality/pr58791-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-2.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -0,0 +1,36 @@\n+/* PR tree-optimization/58791 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"../nop.h\"\n+\n+__attribute__((noinline, noclone)) int\n+foo (unsigned char c)\n+{\n+  int ret;\n+  _Bool a, b, d, e, f;\n+\n+  a = c == 34;\n+  b = c == 32;\n+  d = a | b;\n+  f = !d;\n+  if (d)\n+    ret = 1;\n+  else\n+    {\n+      e = c <= 31;\n+      ret = e;\n+    }\n+\n+  asm volatile (NOP : : : \"memory\");     /* { dg-final { gdb-test pr58791-2.c:27 \"d & 1\" \"1\" } } */\n+  asm volatile (NOP : : : \"memory\");     /* { dg-final { gdb-test pr58791-2.c:27 \"f & 1\" \"0\" } } */\n+  return ret;\n+}\n+\n+\n+int\n+main ()\n+{\n+  foo (32);\n+  return 0;\n+}"}, {"sha": "6316ace5667f5e0a0776df11c2cc688fa8dbb8f5", "filename": "gcc/testsuite/gcc.dg/guality/pr58791-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-3.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -0,0 +1,28 @@\n+/* PR tree-optimization/58791 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"../nop.h\"\n+\n+__attribute__((noinline, noclone)) unsigned\n+foo (unsigned a, unsigned b, unsigned c, unsigned d, unsigned e)\n+{\n+  unsigned f = b + c;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"f\" \"5\" } } */\n+  unsigned g = a - f;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"g\" \"24\" } } */\n+  unsigned h = d + e;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"h\" \"9\" } } */\n+  unsigned i = g - h;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"i\" \"15\" } } */\n+  unsigned j = f + 1;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"j\" \"6\" } } */\n+  unsigned k = g + 1;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"k\" \"25\" } } */\n+  unsigned l = h + 1;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"l\" \"10\" } } */\n+  unsigned m = i + 1;\t\t/* { dg-final { gdb-test pr58791-3.c:19 \"m\" \"16\" } } */\n+  asm volatile (NOP : : : \"memory\");\n+  asm volatile (NOP : : : \"memory\");\n+  return i;\n+}\n+\n+int\n+main ()\n+{\n+  foo (29, 2, 3, 4, 5);\n+  return 0;\n+}"}, {"sha": "d988a9cfbbe017a7e5ef835a66025209839b1e9a", "filename": "gcc/testsuite/gcc.dg/guality/pr58791-4.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-4.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -0,0 +1,41 @@\n+/* PR tree-optimization/58791 */\n+/* { dg-do run } */\n+/* { dg-options \"-g -ffast-math\" } */\n+\n+#include \"../nop.h\"\n+\n+__attribute__((noinline, noclone)) double\n+foo (float a, float b, float c, float d, float l, double u)\n+{\n+  float e = a * d;\n+  float f = d * e;\n+  double g = (double) f;\n+  double h = (double) b;\n+  double i = g * h;\t\t\t/* { dg-final { gdb-test pr58791-4.c:32 \"i\" \"486\" { target { x86_64-*-* && lp64 } } } } */\n+  double i2 = i + 1.0;\t\t\t/* { dg-final { gdb-test pr58791-4.c:32 \"i2\" \"487\" { target { x86_64-*-* && lp64 } } } } */\n+  double j = i * 3.25;\n+  double k = h + j;\n+  float m = l * 8.75;\n+  double n = (double) m;\n+  double o = (double) a;\n+  double p = n * o;\n+  double q = h * p;\n+  double r = q * 2.5;\n+  double s = k - r;\n+  double t = (double) c;\n+  double v = o * u;\n+  double w = o * v;\n+  double x = h * w;\n+  double y = h * x;\n+  double z = y * 8.5;\n+  asm volatile (NOP : : : \"memory\");\n+  asm volatile (NOP : : : \"memory\");\n+  return s - z;\n+}\n+\n+int\n+main ()\n+{\n+  foo (3.0f, 2.0f, -1.0f, 9.0f, 1.0f, 2.0);\n+  return 0;\n+}"}, {"sha": "c237769194085adaab9d7112679767ab71a36aae", "filename": "gcc/testsuite/gcc.dg/guality/pr58791-5.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr58791-5.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -0,0 +1,29 @@\n+/* PR tree-optimization/58791 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+#include \"../nop.h\"\n+\n+__attribute__((noinline, noclone)) unsigned int\n+foo (unsigned int a0, unsigned int a1, unsigned int a2,\n+     unsigned int a3, unsigned int a4)\n+{\n+  unsigned int b0, b1, b2, b3, b4, e;\n+  /* this can be optimized to four additions... */\n+  b4 = a4 + a3 + a2 + a1 + a0;\t\t/* { dg-final { gdb-test pr58791-5.c:20 \"b4\" \"4681\" } } */\n+  b3 = a3 + a2 + a1 + a0;\t\t/* { dg-final { gdb-test pr58791-5.c:20 \"b3\" \"585\" } } */\n+  b2 = a2 + a1 + a0;\t\t\t/* { dg-final { gdb-test pr58791-5.c:20 \"b2\" \"73\" } } */\n+  b1 = a1 + a0;\t\t\t\t/* { dg-final { gdb-test pr58791-5.c:20 \"b1\" \"9\" } } */\n+  /* This is actually 0 */\n+  e = b4 - b3 + b2 - b1 - a4 - a2;\t/* { dg-final { gdb-test pr58791-5.c:20 \"e\" \"0\" } } */\n+  asm volatile (NOP : : : \"memory\");\n+  asm volatile (NOP : : : \"memory\");\n+  return e;\n+}\n+\n+int\n+main ()\n+{\n+  foo (1, 8, 64, 512, 4096);\n+  return 0;\n+}"}, {"sha": "2e9998601485a986e14c94250c200cfee235a851", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-28.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-28.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do run} */\n-/* { dg-options \"-O2 -fdump-tree-reassoc1-details\" } */\n+/* { dg-options \"-O2\" } */\n \n #define LENGTH 4\n void abort (void);\n@@ -30,8 +30,3 @@ int main() {\n     abort ();\n   return 0;\n }\n-\n-/* Verify one stmt has been moved to another BB to ensure correct dependences.  */\n-/* { dg-final { scan-tree-dump-times \"to a different BB\" 1 \"reassoc1\"} }*/\n-/* { dg-final { scan-tree-dump-times \"within same BB\" 2 \"reassoc1\"} }*/\n-/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "ef41317d7b4adc0e3d9d88db66e6f1937a83b24b", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 420, "deletions": 363, "changes": 783, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e40da4f64effc4104fd5d787c37da9cd04c06fe/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=5e40da4f64effc4104fd5d787c37da9cd04c06fe", "patch": "@@ -1150,12 +1150,94 @@ zero_one_operation (tree *def, enum tree_code opcode, tree op)\n   while (1);\n }\n \n-/* Returns the UID of STMT if it is non-NULL. Otherwise return 1.  */\n+/* Returns true if statement S1 dominates statement S2.  Like\n+   stmt_dominates_stmt_p, but uses stmt UIDs to optimize.  */\n \n-static inline unsigned\n-get_stmt_uid_with_default (gimple stmt)\n+static bool\n+reassoc_stmt_dominates_stmt_p (gimple s1, gimple s2)\n {\n-  return stmt ? gimple_uid (stmt) : 1;\n+  basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);\n+\n+  /* If bb1 is NULL, it should be a GIMPLE_NOP def stmt of an (D)\n+     SSA_NAME.  Assume it lives at the beginning of function and\n+     thus dominates everything.  */\n+  if (!bb1 || s1 == s2)\n+    return true;\n+\n+  /* If bb2 is NULL, it doesn't dominate any stmt with a bb.  */\n+  if (!bb2)\n+    return false;\n+\n+  if (bb1 == bb2)\n+    {\n+      /* PHIs in the same basic block are assumed to be\n+\t executed all in parallel, if only one stmt is a PHI,\n+\t it dominates the other stmt in the same basic block.  */\n+      if (gimple_code (s1) == GIMPLE_PHI)\n+\treturn true;\n+\n+      if (gimple_code (s2) == GIMPLE_PHI)\n+\treturn false;\n+\n+      gcc_assert (gimple_uid (s1) && gimple_uid (s2));\n+\n+      if (gimple_uid (s1) < gimple_uid (s2))\n+\treturn true;\n+\n+      if (gimple_uid (s1) > gimple_uid (s2))\n+\treturn false;\n+\n+      gimple_stmt_iterator gsi = gsi_for_stmt (s1);\n+      unsigned int uid = gimple_uid (s1);\n+      for (gsi_next (&gsi); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  gimple s = gsi_stmt (gsi);\n+\t  if (gimple_uid (s) != uid)\n+\t    break;\n+\t  if (s == s2)\n+\t    return true;\n+\t}\n+\n+      return false;\n+    }\n+\n+  return dominated_by_p (CDI_DOMINATORS, bb2, bb1);\n+}\n+\n+/* Insert STMT after INSERT_POINT.  */\n+\n+static void\n+insert_stmt_after (gimple stmt, gimple insert_point)\n+{\n+  gimple_stmt_iterator gsi;\n+  basic_block bb;\n+\n+  if (gimple_code (insert_point) == GIMPLE_PHI)\n+    bb = gimple_bb (insert_point);\n+  else if (!stmt_ends_bb_p (insert_point))\n+    {\n+      gsi = gsi_for_stmt (insert_point);\n+      gimple_set_uid (stmt, gimple_uid (insert_point));\n+      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);\n+      return;\n+    }\n+  else\n+    /* We assume INSERT_POINT is a SSA_NAME_DEF_STMT of some SSA_NAME,\n+       thus if it must end a basic block, it should be a call that can\n+       throw, or some assignment that can throw.  If it throws, the LHS\n+       of it will not be initialized though, so only valid places using\n+       the SSA_NAME should be dominated by the fallthru edge.  */\n+    bb = find_fallthru_edge (gimple_bb (insert_point)->succs)->dest;\n+  gsi = gsi_after_labels (bb);\n+  if (gsi_end_p (gsi))\n+    {\n+      gimple_stmt_iterator gsi2 = gsi_last_bb (bb);\n+      gimple_set_uid (stmt,\n+\t\t      gsi_end_p (gsi2) ? 1 : gimple_uid (gsi_stmt (gsi2)));\n+    }\n+  else\n+    gimple_set_uid (stmt, gimple_uid (gsi_stmt (gsi)));\n+  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n }\n \n /* Builds one statement performing OP1 OPCODE OP2 using TMPVAR for\n@@ -1183,64 +1265,27 @@ build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)\n       && (!op2def || gimple_nop_p (op2def)))\n     {\n       gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR));\n-      gimple_set_uid (sum, get_stmt_uid_with_default (gsi_stmt (gsi)));\n-      gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n-    }\n-  else if ((!op1def || gimple_nop_p (op1def))\n-\t   || (op2def && !gimple_nop_p (op2def)\n-\t       && stmt_dominates_stmt_p (op1def, op2def)))\n-    {\n-      if (gimple_code (op2def) == GIMPLE_PHI)\n+      if (gsi_end_p (gsi))\n \t{\n-\t  gsi = gsi_after_labels (gimple_bb (op2def));\n-          gimple_set_uid (sum, get_stmt_uid_with_default (gsi_stmt (gsi)));\n-\t  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n+\t  gimple_stmt_iterator gsi2\n+\t    = gsi_last_bb (single_succ (ENTRY_BLOCK_PTR));\n+\t  gimple_set_uid (sum,\n+\t\t\t  gsi_end_p (gsi2) ? 1 : gimple_uid (gsi_stmt (gsi2)));\n \t}\n       else\n-\t{\n-\t  if (!stmt_ends_bb_p (op2def))\n-\t    {\n-\t      gsi = gsi_for_stmt (op2def);\n-              gimple_set_uid (sum, gimple_uid (op2def));\n-\t      gsi_insert_after (&gsi, sum, GSI_NEW_STMT);\n-\t    }\n-\t  else\n-\t    {\n-\t      edge e;\n-\t      edge_iterator ei;\n-\n-\t      FOR_EACH_EDGE (e, ei, gimple_bb (op2def)->succs)\n-\t\tif (e->flags & EDGE_FALLTHRU)\n-\t\t  gsi_insert_on_edge_immediate (e, sum);\n-\t    }\n-\t}\n+\tgimple_set_uid (sum, gimple_uid (gsi_stmt (gsi)));\n+      gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n     }\n   else\n     {\n-      if (gimple_code (op1def) == GIMPLE_PHI)\n-\t{\n-\t  gsi = gsi_after_labels (gimple_bb (op1def));\n-          gimple_set_uid (sum, get_stmt_uid_with_default (gsi_stmt (gsi)));\n-\t  gsi_insert_before (&gsi, sum, GSI_NEW_STMT);\n-\t}\n+      gimple insert_point;\n+      if ((!op1def || gimple_nop_p (op1def))\n+\t   || (op2def && !gimple_nop_p (op2def)\n+\t       && reassoc_stmt_dominates_stmt_p (op1def, op2def)))\n+\tinsert_point = op2def;\n       else\n-\t{\n-\t  if (!stmt_ends_bb_p (op1def))\n-\t    {\n-\t      gsi = gsi_for_stmt (op1def);\n-              gimple_set_uid (sum, gimple_uid (op1def));\n-\t      gsi_insert_after (&gsi, sum, GSI_NEW_STMT);\n-\t    }\n-\t  else\n-\t    {\n-\t      edge e;\n-\t      edge_iterator ei;\n-\n-\t      FOR_EACH_EDGE (e, ei, gimple_bb (op1def)->succs)\n-\t\tif (e->flags & EDGE_FALLTHRU)\n-\t\t  gsi_insert_on_edge_immediate (e, sum);\n-\t    }\n-\t}\n+\tinsert_point = op1def;\n+      insert_stmt_after (sum, insert_point);\n     }\n   update_stmt (sum);\n \n@@ -1961,8 +2006,8 @@ range_entry_cmp (const void *a, const void *b)\n    true if the range merge has been successful.\n    If OPCODE is ERROR_MARK, this is called from within\n    maybe_optimize_range_tests and is performing inter-bb range optimization.\n-   Changes should be then performed right away, and whether an op is\n-   BIT_AND_EXPR or BIT_IOR_EXPR is found in oe->rank.  */\n+   In that case, whether an op is BIT_AND_EXPR or BIT_IOR_EXPR is found in\n+   oe->rank.  */\n \n static bool\n update_range_test (struct range_entry *range, struct range_entry *otherrange,\n@@ -2018,36 +2063,12 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n   gsi = gsi_for_stmt (stmt);\n   tem = force_gimple_operand_gsi (&gsi, tem, true, NULL_TREE, true,\n \t\t\t\t  GSI_SAME_STMT);\n+  for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    if (gimple_uid (gsi_stmt (gsi)))\n+      break;\n+    else\n+      gimple_set_uid (gsi_stmt (gsi), gimple_uid (stmt));\n \n-  /* If doing inter-bb range test optimization, update the\n-     stmts immediately.  Start with changing the first range test\n-     immediate use to the new value (TEM), or, if the first range\n-     test is a GIMPLE_COND stmt, change that condition.  */\n-  if (opcode == ERROR_MARK)\n-    {\n-      if (op)\n-\t{\n-\t  imm_use_iterator iter;\n-\t  use_operand_p use_p;\n-\t  gimple use_stmt;\n-\n-\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, op)\n-\t    {\n-\t      if (is_gimple_debug (use_stmt))\n-\t\tcontinue;\n-\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\tSET_USE (use_p, tem);\n-\t      update_stmt (use_stmt);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  gimple_cond_set_code (stmt, NE_EXPR);\n-\t  gimple_cond_set_lhs (stmt, tem);\n-\t  gimple_cond_set_rhs (stmt, boolean_false_node);\n-\t  update_stmt (stmt);\n-\t}\n-    }\n   oe->op = tem;\n   range->exp = exp;\n   range->low = low;\n@@ -2063,78 +2084,14 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n       if (opcode == ERROR_MARK)\n \t{\n \t  if (oe->op)\n-\t    {\n-\t      imm_use_iterator iter;\n-\t      use_operand_p use_p;\n-\t      gimple use_stmt;\n-\n-\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, oe->op)\n-\t\t{\n-\t\t  if (is_gimple_debug (use_stmt))\n-\t\t    continue;\n-\t\t  /* If imm use of _8 is a statement like _7 = _8 | _9;,\n-\t\t     adjust it into _7 = _9;.  */\n-\t\t  if (is_gimple_assign (use_stmt)\n-\t\t      && gimple_assign_rhs_code (use_stmt) == oe->rank)\n-\t\t    {\n-\t\t      tree expr = NULL_TREE;\n-\t\t      if (oe->op == gimple_assign_rhs1 (use_stmt))\n-\t\t\texpr = gimple_assign_rhs2 (use_stmt);\n-\t\t      else if (oe->op == gimple_assign_rhs2 (use_stmt))\n-\t\t\texpr = gimple_assign_rhs1 (use_stmt);\n-\t\t      if (expr\n-\t\t\t  && expr != oe->op\n-\t\t\t  && TREE_CODE (expr) == SSA_NAME)\n-\t\t\t{\n-\t\t\t  gimple_stmt_iterator gsi2 = gsi_for_stmt (use_stmt);\n-\t\t\t  gimple_assign_set_rhs_with_ops (&gsi2, SSA_NAME,\n-\t\t\t\t\t\t\t  expr, NULL_TREE);\n-\t\t\t  update_stmt (use_stmt);\n-\t\t\t  continue;\n-\t\t\t}\n-\t\t    }\n-\t\t  /* If imm use of _8 is a statement like _7 = (int) _8;,\n-\t\t     adjust it into _7 = 0; or _7 = 1;.  */\n-\t\t  if (gimple_assign_cast_p (use_stmt)\n-\t\t      && oe->op == gimple_assign_rhs1 (use_stmt))\n-\t\t    {\n-\t\t      tree lhs = gimple_assign_lhs (use_stmt);\n-\t\t      if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n-\t\t\t{\n-\t\t\t  gimple_stmt_iterator gsi2\n-\t\t\t    = gsi_for_stmt (use_stmt);\n-\t\t\t  tree expr = build_int_cst (TREE_TYPE (lhs),\n-\t\t\t\t\t\t     oe->rank == BIT_IOR_EXPR\n-\t\t\t\t\t\t     ? 0 : 1);\n-\t\t\t  gimple_assign_set_rhs_with_ops (&gsi2,\n-\t\t\t\t\t\t\t  INTEGER_CST,\n-\t\t\t\t\t\t\t  expr, NULL_TREE);\n-\t\t\t  update_stmt (use_stmt);\n-\t\t\t  continue;\n-\t\t\t}\n-\t\t    }\n-\t\t  /* Otherwise replace the use with 0 or 1.  */\n-\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\t    SET_USE (use_p,\n-\t\t\t     build_int_cst (TREE_TYPE (oe->op),\n-\t\t\t\t\t    oe->rank == BIT_IOR_EXPR\n-\t\t\t\t\t    ? 0 : 1));\n-\t\t  update_stmt (use_stmt);\n-\t\t}\n-\t    }\n+\t    oe->op = build_int_cst (TREE_TYPE (oe->op),\n+\t\t\t\t    oe->rank == BIT_IOR_EXPR ? 0 : 1);\n \t  else\n-\t    {\n-\t      /* If range test was a GIMPLE_COND, simply change it\n-\t\t into an always false or always true condition.  */\n-\t      stmt = last_stmt (BASIC_BLOCK (oe->id));\n-\t      if (oe->rank == BIT_IOR_EXPR)\n-\t\tgimple_cond_make_false (stmt);\n-\t      else\n-\t\tgimple_cond_make_true (stmt);\n-\t      update_stmt (stmt);\n-\t    }\n+\t    oe->op = (oe->rank == BIT_IOR_EXPR\n+\t\t      ? boolean_false_node : boolean_true_node);\n \t}\n-      oe->op = error_mark_node;\n+      else\n+\toe->op = error_mark_node;\n       range->exp = NULL_TREE;\n     }\n   return true;\n@@ -2295,7 +2252,7 @@ optimize_range_tests_1 (enum tree_code opcode, int first, int length,\n    GIMPLE_COND is && or ||ed into the test, and oe->rank says\n    the actual opcode.  */\n \n-static void\n+static bool\n optimize_range_tests (enum tree_code opcode,\n \t\t      vec<operand_entry_t> *ops)\n {\n@@ -2305,7 +2262,7 @@ optimize_range_tests (enum tree_code opcode,\n   bool any_changes = false;\n \n   if (length == 1)\n-    return;\n+    return false;\n \n   ranges = XNEWVEC (struct range_entry, length);\n   for (i = 0; i < length; i++)\n@@ -2385,6 +2342,7 @@ optimize_range_tests (enum tree_code opcode,\n     }\n \n   XDELETEVEC (ranges);\n+  return any_changes;\n }\n \n /* Return true if STMT is a cast like:\n@@ -2631,6 +2589,60 @@ get_ops (tree var, enum tree_code code, vec<operand_entry_t> *ops,\n   return true;\n }\n \n+/* Find the ops that were added by get_ops starting from VAR, see if\n+   they were changed during update_range_test and if yes, create new\n+   stmts.  */\n+\n+static tree\n+update_ops (tree var, enum tree_code code, vec<operand_entry_t> ops,\n+\t    unsigned int *pidx, struct loop *loop)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (var);\n+  tree rhs[4];\n+  int i;\n+\n+  if (!is_reassociable_op (stmt, code, loop))\n+    return NULL;\n+\n+  rhs[0] = gimple_assign_rhs1 (stmt);\n+  rhs[1] = gimple_assign_rhs2 (stmt);\n+  rhs[2] = rhs[0];\n+  rhs[3] = rhs[1];\n+  for (i = 0; i < 2; i++)\n+    if (TREE_CODE (rhs[i]) == SSA_NAME)\n+      {\n+\trhs[2 + i] = update_ops (rhs[i], code, ops, pidx, loop);\n+\tif (rhs[2 + i] == NULL_TREE)\n+\t  {\n+\t    if (has_single_use (rhs[i]))\n+\t      rhs[2 + i] = ops[(*pidx)++]->op;\n+\t    else\n+\t      rhs[2 + i] = rhs[i];\n+\t  }\n+      }\n+  if ((rhs[2] != rhs[0] || rhs[3] != rhs[1])\n+      && (rhs[2] != rhs[1] || rhs[3] != rhs[0]))\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+      var = make_ssa_name (TREE_TYPE (var), NULL);\n+      gimple g = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t       var, rhs[2], rhs[3]);\n+      gimple_set_uid (g, gimple_uid (stmt));\n+      gimple_set_visited (g, true);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+    }\n+  return var;\n+}\n+\n+/* Structure to track the initial value passed to get_ops and\n+   the range in the ops vector for each basic block.  */\n+\n+struct inter_bb_range_test_entry\n+{\n+  tree op;\n+  unsigned int first_idx, last_idx;\n+};\n+\n /* Inter-bb range test optimization.  */\n \n static void\n@@ -2643,6 +2655,7 @@ maybe_optimize_range_tests (gimple stmt)\n   edge_iterator ei;\n   edge e;\n   vec<operand_entry_t> ops = vNULL;\n+  vec<inter_bb_range_test_entry> bbinfo = vNULL;\n \n   /* Consider only basic blocks that end with GIMPLE_COND or\n      a cast statement satisfying final_range_test_p.  All\n@@ -2744,7 +2757,11 @@ maybe_optimize_range_tests (gimple stmt)\n     {\n       enum tree_code code;\n       tree lhs, rhs;\n+      inter_bb_range_test_entry bb_ent;\n \n+      bb_ent.op = NULL_TREE;\n+      bb_ent.first_idx = ops.length ();\n+      bb_ent.last_idx = bb_ent.first_idx;\n       e = find_edge (bb, other_bb);\n       stmt = last_stmt (bb);\n       gimple_set_visited (stmt, true);\n@@ -2801,7 +2818,12 @@ maybe_optimize_range_tests (gimple stmt)\n \t      oe->id = 0;\n \t      oe->count = 1;\n \t      ops.safe_push (oe);\n+\t      bb_ent.last_idx++;\n \t    }\n+\t  else\n+\t    bb_ent.last_idx = ops.length ();\n+\t  bb_ent.op = rhs;\n+\t  bbinfo.safe_push (bb_ent);\n \t  continue;\n \t}\n       /* Otherwise stmt is GIMPLE_COND.  */\n@@ -2834,12 +2856,107 @@ maybe_optimize_range_tests (gimple stmt)\n \t  oe->id = bb->index;\n \t  oe->count = 1;\n \t  ops.safe_push (oe);\n+\t  bb_ent.op = NULL;\n+\t  bb_ent.last_idx++;\n \t}\n+      else if (ops.length () > bb_ent.first_idx)\n+\t{\n+\t  bb_ent.op = lhs;\n+\t  bb_ent.last_idx = ops.length ();\n+\t}\n+      bbinfo.safe_push (bb_ent);\n       if (bb == first_bb)\n \tbreak;\n     }\n   if (ops.length () > 1)\n-    optimize_range_tests (ERROR_MARK, &ops);\n+    {\n+      unsigned int idx;\n+      bool any_changes = optimize_range_tests (ERROR_MARK, &ops);\n+      for (bb = last_bb, idx = 0; any_changes; bb = single_pred (bb), idx++)\n+\t{\n+\t  if (bbinfo[idx].first_idx < bbinfo[idx].last_idx)\n+\t    {\n+\t      gimple stmt = last_stmt (bb);\n+\t      tree new_op;\n+\n+\t      if (bbinfo[idx].op == NULL_TREE)\n+\t\t{\n+\t\t  if (ops[bbinfo[idx].first_idx]->op != NULL_TREE)\n+\t\t    {\n+\t\t      if (integer_zerop (ops[bbinfo[idx].first_idx]->op))\n+\t\t\tgimple_cond_make_false (stmt);\n+\t\t      else if (integer_onep (ops[bbinfo[idx].first_idx]->op))\n+\t\t\tgimple_cond_make_true (stmt);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  gimple_cond_set_code (stmt, NE_EXPR);\n+\t\t\t  gimple_cond_set_lhs (stmt,\n+\t\t\t\t\t       ops[bbinfo[idx].first_idx]->op);\n+\t\t\t  gimple_cond_set_rhs (stmt, boolean_false_node);\n+\t\t\t}\n+\t\t      update_stmt (stmt);\n+\t\t    }\n+\t\t  bbinfo[idx].op = new_op = boolean_false_node;\n+\t\t}\n+\t      else\n+\t\tnew_op = update_ops (bbinfo[idx].op,\n+\t\t\t\t     (enum tree_code)\n+\t\t\t\t     ops[bbinfo[idx].first_idx]->rank,\n+\t\t\t\t     ops, &bbinfo[idx].first_idx,\n+\t\t\t\t     loop_containing_stmt (stmt));\n+\t      if (new_op == NULL_TREE)\n+\t\t{\n+\t\t  gcc_assert (bb == last_bb);\n+\t\t  new_op = ops[bbinfo[idx].first_idx++]->op;\n+\t\t}\n+\t      if (bbinfo[idx].op != new_op)\n+\t\t{\n+\t\t  imm_use_iterator iter;\n+\t\t  use_operand_p use_p;\n+\t\t  gimple use_stmt, cast_stmt = NULL;\n+\n+\t\t  FOR_EACH_IMM_USE_STMT (use_stmt, iter, bbinfo[idx].op)\n+\t\t    if (is_gimple_debug (use_stmt))\n+\t\t      continue;\n+\t\t    else if (gimple_code (use_stmt) == GIMPLE_COND\n+\t\t\t     || gimple_code (use_stmt) == GIMPLE_PHI)\n+\t\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t\tSET_USE (use_p, new_op);\n+\t\t    else if (gimple_assign_cast_p (use_stmt))\n+\t\t      cast_stmt = use_stmt;\n+\t\t    else\n+\t\t      gcc_unreachable ();\n+\t\t  if (cast_stmt)\n+\t\t    {\n+\t\t      gcc_assert (bb == last_bb);\n+\t\t      tree lhs = gimple_assign_lhs (cast_stmt);\n+\t\t      tree new_lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t\t      enum tree_code rhs_code\n+\t\t\t= gimple_assign_rhs_code (cast_stmt);\n+\t\t      gimple g\n+\t\t\t= gimple_build_assign_with_ops (rhs_code, new_lhs,\n+\t\t\t\t\t\t\tnew_op, NULL_TREE);\n+\t\t      gimple_stmt_iterator gsi = gsi_for_stmt (cast_stmt);\n+\t\t      gimple_set_uid (g, gimple_uid (cast_stmt));\n+\t\t      gimple_set_visited (g, true);\n+\t\t      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+\t\t\tif (is_gimple_debug (use_stmt))\n+\t\t\t  continue;\n+\t\t\telse if (gimple_code (use_stmt) == GIMPLE_COND\n+\t\t\t\t || gimple_code (use_stmt) == GIMPLE_PHI)\n+\t\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t\t    SET_USE (use_p, new_lhs);\n+\t\t\telse\n+\t\t\t  gcc_unreachable ();\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (bb == first_bb)\n+\t    break;\n+\t}\n+    }\n+  bbinfo.release ();\n   ops.release ();\n }\n \n@@ -2948,175 +3065,36 @@ swap_ops_for_binary_stmt (vec<operand_entry_t> ops,\n       oe2->op = oe1->op;\n       oe2->rank = oe1->rank;\n       oe1->op = temp.op;\n-      oe1->rank= temp.rank;\n-    }\n-}\n-\n-/* Determine if stmt A is not dominated by stmt B. If A and B are in\n-   same basic block, then A's UID has to be less than B. If they are\n-   in different BB's, then A's BB must not be dominated by B's BB.  */\n-\n-static inline bool\n-not_dominated_by (gimple a, gimple b)\n-{\n-  basic_block bb_a, bb_b;\n-  bb_a = gimple_bb (a);\n-  bb_b = gimple_bb (b);\n-  return ((bb_a == bb_b && gimple_uid (a) < gimple_uid (b))\n-          || (bb_a != bb_b\n-              && !dominated_by_p (CDI_DOMINATORS, bb_a, bb_b)));\n-\n-}\n-\n-/* Among STMT1 and STMT2, return the statement that appears later. Both\n-   statements are in same BB and have the same UID.  */\n-\n-static gimple\n-appears_later_in_bb (gimple stmt1, gimple stmt2)\n-{\n-  unsigned uid = gimple_uid (stmt1);\n-  gimple_stmt_iterator gsi = gsi_for_stmt (stmt1);\n-  for (gsi_next (&gsi); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-\n-      /* If STMT has a different UID than STMT1 and we haven't seen\n-         STMT2 during traversal, we know STMT1 appears later.  */\n-      if (gimple_uid (stmt) != uid)\n-        return stmt1;\n-      else if (stmt == stmt2)\n-        return stmt2;\n-    }\n-  return stmt1;\n-}\n-\n-/* Find the statement after which STMT must be moved so that the\n-   dependency from DEP_STMT to STMT is maintained.  */\n-\n-static gimple\n-find_insert_point (gimple stmt, gimple dep_stmt)\n-{\n-  gimple insert_stmt = stmt;\n-  if (dep_stmt == NULL)\n-    return stmt;\n-  if (gimple_uid (insert_stmt) == gimple_uid (dep_stmt)\n-      && gimple_bb (insert_stmt) == gimple_bb (dep_stmt)\n-      && insert_stmt != dep_stmt)\n-    insert_stmt = appears_later_in_bb (insert_stmt, dep_stmt);\n-  else if (not_dominated_by (insert_stmt, dep_stmt))\n-    insert_stmt = dep_stmt;\n-  return insert_stmt;\n-}\n-\n-/* Insert STMT after INSERT_POINT.  */\n-\n-static void\n-insert_stmt_after (gimple stmt, gimple insert_point)\n-{\n-  imm_use_iterator iter;\n-  tree lhs;\n-  gimple use_stmt;\n-  gimple_stmt_iterator gsistmt = gsi_for_stmt (stmt), gsi_insert;\n-  basic_block insert_bb = gimple_bb (insert_point);\n-  bool insert_bb_different = (insert_bb != gimple_bb (stmt));\n-  lhs = gimple_assign_lhs (stmt);\n-  /* If there are any debug uses of LHS, reset them.  */\n-  FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-    {\n-      if (is_gimple_debug (use_stmt)\n-          && not_dominated_by (use_stmt, insert_point))\n-        {\n-          gimple_debug_bind_reset_value (use_stmt);\n-          update_stmt (use_stmt);\n-        }\n-    }\n-  /* If INSERT_STMT is a phi node, then do not insert just after that statement.\n-     Instead, find the first non-label gimple statement in BB and insert before\n-     that.  */\n-  if (gimple_code (insert_point) == GIMPLE_PHI)\n-    {\n-      gsi_insert = gsi_after_labels (insert_bb);\n-      gsi_move_before (&gsistmt, &gsi_insert);\n-    }\n-  /* Statements marked for throw can not be in the middle of a basic block. So\n-     we can not insert a statement (not marked for throw) immediately after.  */\n-  else if (stmt_ends_bb_p (insert_point))\n-    {\n-      edge succ_edge = find_fallthru_edge (insert_bb->succs);\n-      insert_bb = succ_edge->dest;\n-      insert_bb_different = (insert_bb != gimple_bb (stmt));\n-      /* Insert STMT at the beginning of the successor basic block.  */\n-      gsi_insert = gsi_after_labels (insert_bb);\n-      gsi_move_before (&gsistmt, &gsi_insert);\n-    }\n-  else\n-    {\n-      gsi_insert = gsi_for_stmt (insert_point);\n-      gsi_move_after (&gsistmt, &gsi_insert);\n+      oe1->rank = temp.rank;\n     }\n-  /* Set the UID of STMT to that of INSERT_POINT so that subsequent comparisons\n-     of UIDs to determine dominance within a basic block works.  */\n-  gimple_set_uid (stmt, gimple_uid (insert_point));\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Moved stmt \");\n-      print_gimple_stmt (dump_file, stmt, 0, 0);\n-      fprintf (dump_file, \" %s to satisfy dependences\\n\",\n-               insert_bb_different ? \"to a different BB\" : \"within same BB\");\n-    }\n-\n }\n \n-/* If OP is a SSA variable and is not the default definition, return the\n-   gimple statement that defines OP. Else return NULL.  */\n+/* If definition of RHS1 or RHS2 dominates STMT, return the later of those\n+   two definitions, otherwise return STMT.  */\n \n static inline gimple\n-get_def_stmt (tree op)\n+find_insert_point (gimple stmt, tree rhs1, tree rhs2)\n {\n-  if (TREE_CODE (op) == SSA_NAME\n-      && !SSA_NAME_IS_DEFAULT_DEF (op))\n-    return SSA_NAME_DEF_STMT (op);\n-  else\n-    return NULL;\n-}\n-\n-/* Ensure that operands in the OPS vector are available for STMT and all\n-   gimple statements on which STMT depends.  */\n-\n-static void\n-ensure_ops_are_available (gimple stmt, vec<operand_entry_t> ops, int opindex)\n-{\n-  unsigned int len = ops.length ();\n-  gimple insert_stmt = stmt;\n-  gimple dep_stmts[2];\n-  dep_stmts[0] = get_def_stmt (ops[opindex]->op);\n-  if (len - opindex == 2)\n-    {\n-      dep_stmts[1] = get_def_stmt (ops[opindex + 1]->op);\n-    }\n-  else\n-    {\n-      gimple stmt1 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n-      ensure_ops_are_available (stmt1, ops, opindex + 1);\n-      dep_stmts[1] = stmt1;\n-    }\n-  for (int i = 0; i < 2; i++)\n-    insert_stmt = find_insert_point (insert_stmt, dep_stmts[i]);\n-\n-  if (insert_stmt != stmt)\n-    insert_stmt_after (stmt, insert_stmt);\n+  if (TREE_CODE (rhs1) == SSA_NAME\n+      && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs1)))\n+    stmt = SSA_NAME_DEF_STMT (rhs1);\n+  if (TREE_CODE (rhs2) == SSA_NAME\n+      && reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs2)))\n+    stmt = SSA_NAME_DEF_STMT (rhs2);\n+  return stmt;\n }\n \n /* Recursively rewrite our linearized statements so that the operators\n    match those in OPS[OPINDEX], putting the computation in rank\n-   order.  */\n+   order.  Return new lhs.  */\n \n-static void\n+static tree\n rewrite_expr_tree (gimple stmt, unsigned int opindex,\n-\t\t   vec<operand_entry_t> ops, bool moved)\n+\t\t   vec<operand_entry_t> ops, bool changed)\n {\n   tree rhs1 = gimple_assign_rhs1 (stmt);\n   tree rhs2 = gimple_assign_rhs2 (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n   operand_entry_t oe;\n \n   /* The final recursion case for this function is that you have\n@@ -3133,15 +3111,38 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \n       if (rhs1 != oe1->op || rhs2 != oe2->op)\n \t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t  unsigned int uid = gimple_uid (stmt);\n+\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n \t      fprintf (dump_file, \"Transforming \");\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t    }\n \n-\t  gimple_assign_set_rhs1 (stmt, oe1->op);\n-\t  gimple_assign_set_rhs2 (stmt, oe2->op);\n-\t  update_stmt (stmt);\n+\t  if (changed)\n+\t    {\n+\t      gimple insert_point = find_insert_point (stmt, oe1->op, oe2->op);\n+\t      lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t      stmt\n+\t\t= gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t\tlhs, oe1->op, oe2->op);\n+\t      gimple_set_uid (stmt, uid);\n+\t      gimple_set_visited (stmt, true);\n+\t      if (insert_point == gsi_stmt (gsi))\n+\t\tgsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t      else\n+\t\tinsert_stmt_after (stmt, insert_point);\n+\t    }\n+\t  else\n+\t    {\n+\t      gcc_checking_assert (find_insert_point (stmt, oe1->op, oe2->op)\n+\t\t\t\t   == stmt);\n+\t      gimple_assign_set_rhs1 (stmt, oe1->op);\n+\t      gimple_assign_set_rhs2 (stmt, oe2->op);\n+\t      update_stmt (stmt);\n+\t    }\n+\n \t  if (rhs1 != oe1->op && rhs1 != oe2->op)\n \t    remove_visited_stmt_chain (rhs1);\n \n@@ -3151,7 +3152,7 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t      print_gimple_stmt (dump_file, stmt, 0, 0);\n \t    }\n \t}\n-      return;\n+      return lhs;\n     }\n \n   /* If we hit here, we should have 3 or more ops left.  */\n@@ -3160,32 +3161,59 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n   /* Rewrite the next operator.  */\n   oe = ops[opindex];\n \n-  if (oe->op != rhs2)\n-    {\n-      if (!moved)\n-\t{\n-          ensure_ops_are_available (stmt, ops, opindex);\n-\t  moved = true;\n-\t}\n+  /* Recurse on the LHS of the binary operator, which is guaranteed to\n+     be the non-leaf side.  */\n+  tree new_rhs1\n+    = rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), opindex + 1, ops,\n+\t\t\t changed || oe->op != rhs2);\n \n+  if (oe->op != rhs2 || new_rhs1 != rhs1)\n+    {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Transforming \");\n \t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t}\n \n-      gimple_assign_set_rhs2 (stmt, oe->op);\n-      update_stmt (stmt);\n+      /* If changed is false, this is either opindex == 0\n+\t or all outer rhs2's were equal to corresponding oe->op,\n+\t and powi_result is NULL.\n+\t That means lhs is equivalent before and after reassociation.\n+\t Otherwise ensure the old lhs SSA_NAME is not reused and\n+\t create a new stmt as well, so that any debug stmts will be\n+\t properly adjusted.  */\n+      if (changed)\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t  unsigned int uid = gimple_uid (stmt);\n+\t  gimple insert_point = find_insert_point (stmt, new_rhs1, oe->op);\n+\n+\t  lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+\t  stmt = gimple_build_assign_with_ops (gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t       lhs, new_rhs1, oe->op);\n+\t  gimple_set_uid (stmt, uid);\n+\t  gimple_set_visited (stmt, true);\n+\t  if (insert_point == gsi_stmt (gsi))\n+\t    gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\t  else\n+\t    insert_stmt_after (stmt, insert_point);\n+\t}\n+      else\n+\t{\n+\t  gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe->op)\n+\t\t\t       == stmt);\n+\t  gimple_assign_set_rhs1 (stmt, new_rhs1);\n+\t  gimple_assign_set_rhs2 (stmt, oe->op);\n+\t  update_stmt (stmt);\n+\t}\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \" into \");\n \t  print_gimple_stmt (dump_file, stmt, 0, 0);\n \t}\n     }\n-  /* Recurse on the LHS of the binary operator, which is guaranteed to\n-     be the non-leaf side.  */\n-  rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), opindex + 1, ops, moved);\n+  return lhs;\n }\n \n /* Find out how many cycles we need to compute statements chain.\n@@ -3267,7 +3295,7 @@ get_reassociation_width (int ops_num, enum tree_code opc,\n \n static void\n rewrite_expr_tree_parallel (gimple stmt, int width,\n-\t\t\t    vec<operand_entry_t>  ops)\n+\t\t\t    vec<operand_entry_t> ops)\n {\n   enum tree_code opcode = gimple_assign_rhs_code (stmt);\n   int op_num = ops.length ();\n@@ -3363,24 +3391,28 @@ rewrite_expr_tree_parallel (gimple stmt, int width,\n static void\n linearize_expr (gimple stmt)\n {\n-  gimple_stmt_iterator gsinow, gsirhs;\n+  gimple_stmt_iterator gsi;\n   gimple binlhs = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n   gimple binrhs = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n+  gimple oldbinrhs = binrhs;\n   enum tree_code rhscode = gimple_assign_rhs_code (stmt);\n   gimple newbinrhs = NULL;\n   struct loop *loop = loop_containing_stmt (stmt);\n+  tree lhs = gimple_assign_lhs (stmt);\n \n   gcc_assert (is_reassociable_op (binlhs, rhscode, loop)\n \t      && is_reassociable_op (binrhs, rhscode, loop));\n \n-  gsinow = gsi_for_stmt (stmt);\n-  gsirhs = gsi_for_stmt (binrhs);\n-  gsi_move_before (&gsirhs, &gsinow);\n-  gimple_set_uid (binrhs, gimple_uid (stmt));\n+  gsi = gsi_for_stmt (stmt);\n \n   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));\n-  gimple_assign_set_rhs1 (binrhs, gimple_assign_lhs (binlhs));\n+  binrhs = gimple_build_assign_with_ops (gimple_assign_rhs_code (binrhs),\n+\t\t\t\t\t make_ssa_name (TREE_TYPE (lhs), NULL),\n+\t\t\t\t\t gimple_assign_lhs (binlhs),\n+\t\t\t\t\t gimple_assign_rhs2 (binrhs));\n   gimple_assign_set_rhs1 (stmt, gimple_assign_lhs (binrhs));\n+  gsi_insert_before (&gsi, binrhs, GSI_SAME_STMT);\n+  gimple_set_uid (binrhs, gimple_uid (stmt));\n \n   if (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME)\n     newbinrhs = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n@@ -3392,10 +3424,12 @@ linearize_expr (gimple stmt)\n     }\n \n   reassociate_stats.linearized++;\n-  update_stmt (binrhs);\n-  update_stmt (binlhs);\n   update_stmt (stmt);\n \n+  gsi = gsi_for_stmt (oldbinrhs);\n+  gsi_remove (&gsi, true);\n+  release_defs (oldbinrhs);\n+\n   gimple_set_visited (stmt, true);\n   gimple_set_visited (binlhs, true);\n   gimple_set_visited (binrhs, true);\n@@ -3432,10 +3466,12 @@ get_single_immediate_use (tree lhs)\n    transform b_3 + b_4 into a_5 = -b_3 + -b_4.  */\n \n static tree\n-negate_value (tree tonegate, gimple_stmt_iterator *gsi)\n+negate_value (tree tonegate, gimple_stmt_iterator *gsip)\n {\n-  gimple negatedefstmt= NULL;\n+  gimple negatedefstmt = NULL;\n   tree resultofnegate;\n+  gimple_stmt_iterator gsi;\n+  unsigned int uid;\n \n   /* If we are trying to negate a name, defined by an add, negate the\n      add operands instead.  */\n@@ -3447,25 +3483,38 @@ negate_value (tree tonegate, gimple_stmt_iterator *gsi)\n       && has_single_use (gimple_assign_lhs (negatedefstmt))\n       && gimple_assign_rhs_code (negatedefstmt) == PLUS_EXPR)\n     {\n-      gimple_stmt_iterator gsi;\n       tree rhs1 = gimple_assign_rhs1 (negatedefstmt);\n       tree rhs2 = gimple_assign_rhs2 (negatedefstmt);\n+      tree lhs = gimple_assign_lhs (negatedefstmt);\n+      gimple g;\n \n       gsi = gsi_for_stmt (negatedefstmt);\n       rhs1 = negate_value (rhs1, &gsi);\n-      gimple_assign_set_rhs1 (negatedefstmt, rhs1);\n \n       gsi = gsi_for_stmt (negatedefstmt);\n       rhs2 = negate_value (rhs2, &gsi);\n-      gimple_assign_set_rhs2 (negatedefstmt, rhs2);\n \n-      update_stmt (negatedefstmt);\n-      return gimple_assign_lhs (negatedefstmt);\n+      gsi = gsi_for_stmt (negatedefstmt);\n+      lhs = make_ssa_name (TREE_TYPE (lhs), NULL);\n+      gimple_set_visited (negatedefstmt, true);\n+      g = gimple_build_assign_with_ops (PLUS_EXPR, lhs, rhs1, rhs2);\n+      gimple_set_uid (g, gimple_uid (negatedefstmt));\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      return lhs;\n     }\n \n   tonegate = fold_build1 (NEGATE_EXPR, TREE_TYPE (tonegate), tonegate);\n-  resultofnegate = force_gimple_operand_gsi (gsi, tonegate, true,\n+  resultofnegate = force_gimple_operand_gsi (gsip, tonegate, true,\n \t\t\t\t\t     NULL_TREE, true, GSI_SAME_STMT);\n+  gsi = *gsip;\n+  uid = gimple_uid (gsi_stmt (gsi));\n+  for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (gimple_uid (stmt) != 0)\n+\tbreak;\n+      gimple_set_uid (stmt, uid);\n+    }\n   return resultofnegate;\n }\n \n@@ -3771,16 +3820,18 @@ repropagate_negates (void)\n \t\t plus_negates vector.  */\n \t      gimple feed = SSA_NAME_DEF_STMT (negate);\n \t      tree a = gimple_assign_rhs1 (feed);\n-\t      tree rhs2 = gimple_assign_rhs2 (user);\n-\t      gimple_stmt_iterator gsi = gsi_for_stmt (feed), gsi2;\n-\t      gimple_replace_ssa_lhs (feed, negate);\n-\t      gimple_assign_set_rhs_with_ops (&gsi, PLUS_EXPR, a, rhs2);\n-\t      update_stmt (gsi_stmt (gsi));\n-\t      gsi2 = gsi_for_stmt (user);\n-\t      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, negate, NULL);\n-\t      update_stmt (gsi_stmt (gsi2));\n-\t      gsi_move_before (&gsi, &gsi2);\n-\t      plus_negates.safe_push (gimple_assign_lhs (gsi_stmt (gsi2)));\n+\t      tree b = gimple_assign_rhs2 (user);\n+\t      gimple_stmt_iterator gsi = gsi_for_stmt (feed);\n+\t      gimple_stmt_iterator gsi2 = gsi_for_stmt (user);\n+\t      tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)), NULL);\n+\t      gimple g = gimple_build_assign_with_ops (PLUS_EXPR, x, a, b);\n+\t      gsi_insert_before (&gsi2, g, GSI_SAME_STMT);\n+\t      gimple_assign_set_rhs_with_ops (&gsi2, NEGATE_EXPR, x, NULL);\n+\t      user = gsi_stmt (gsi2);\n+\t      update_stmt (user);\n+\t      gsi_remove (&gsi, true);\n+\t      release_defs (feed);\n+\t      plus_negates.safe_push (gimple_assign_lhs (user));\n \t    }\n \t  else\n \t    {\n@@ -3827,18 +3878,21 @@ can_reassociate_p (tree op)\n    we want to break up k = t - q, but we won't until we've transformed q\n    = b - r, which won't be broken up until we transform b = c - d.\n \n-   En passant, clear the GIMPLE visited flag on every statement.  */\n+   En passant, clear the GIMPLE visited flag on every statement\n+   and set UIDs within each basic block.  */\n \n static void\n break_up_subtract_bb (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block son;\n+  unsigned int uid = 1;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n       gimple_set_visited (stmt, false);\n+      gimple_set_uid (stmt, uid++);\n \n       if (!is_gimple_assign (stmt)\n \t  || !can_reassociate_p (gimple_assign_lhs (stmt)))\n@@ -4374,6 +4428,7 @@ reassociate_bb (basic_block bb)\n \t\t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));\n \t\t  int ops_num = ops.length ();\n \t\t  int width = get_reassociation_width (ops_num, rhs_code, mode);\n+\t\t  tree new_lhs = lhs;\n \n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file,\n@@ -4391,20 +4446,23 @@ reassociate_bb (basic_block bb)\n                       if (len >= 3)\n                         swap_ops_for_binary_stmt (ops, len - 3, stmt);\n \n-\t\t      rewrite_expr_tree (stmt, 0, ops, false);\n+\t\t      new_lhs = rewrite_expr_tree (stmt, 0, ops,\n+\t\t\t\t\t\t   powi_result != NULL);\n                     }\n \n \t\t  /* If we combined some repeated factors into a \n \t\t     __builtin_powi call, multiply that result by the\n \t\t     reassociated operands.  */\n \t\t  if (powi_result)\n \t\t    {\n-\t\t      gimple mul_stmt;\n-\t\t      tree type = TREE_TYPE (gimple_get_lhs (stmt));\n+\t\t      gimple mul_stmt, lhs_stmt = SSA_NAME_DEF_STMT (lhs);\n+\t\t      tree type = TREE_TYPE (lhs);\n \t\t      tree target_ssa = make_temp_ssa_name (type, NULL,\n \t\t\t\t\t\t\t    \"reassocpow\");\n-\t\t      gimple_set_lhs (stmt, target_ssa);\n-\t\t      update_stmt (stmt);\n+\t\t      gimple_set_lhs (lhs_stmt, target_ssa);\n+\t\t      update_stmt (lhs_stmt);\n+\t\t      if (lhs != new_lhs)\n+\t\t\ttarget_ssa = new_lhs;\n \t\t      mul_stmt = gimple_build_assign_with_ops (MULT_EXPR, lhs,\n \t\t\t\t\t\t\t       powi_result,\n \t\t\t\t\t\t\t       target_ssa);\n@@ -4453,7 +4511,6 @@ static void\n do_reassoc (void)\n {\n   break_up_subtract_bb (ENTRY_BLOCK_PTR);\n-  renumber_gimple_stmt_uids ();\n   reassociate_bb (EXIT_BLOCK_PTR);\n }\n "}]}