{"sha": "c3c3e2c9e88e25a410a2fe089782b094e911bb39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNjM2UyYzllODhlMjVhNDEwYTJmZTA4OTc4MmIwOTRlOTExYmIzOQ==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-02T07:34:50Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2020-11-02T07:34:50Z"}, "message": "arm: Improve handling of relocations with small offsets with -mpure-code on v6m (PR96770)\n\nWith -mpure-code on v6m (thumb-1), we can use small offsets with\nupper/lower relocations to avoid the extra addition of the\noffset.\n\nThis patch accepts expressions symbol+offset as legitimate constants\nwhen the literal pool is disabled, making sure that the offset is\nwithin the range supported by thumb-1 [0..255] as described in the\nAAELF32 documentation.\n\nIt also makes sure that thumb1_movsi_insn emits an error in case we\ntry to use it with an unsupported RTL construct.\n\n2020-09-28  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\tPR target/96770\n\t* config/arm/arm.c (thumb_legitimate_constant_p): Accept\n\t(symbol_ref + addend) when literal pool is disabled.\n\t(arm_valid_symbolic_address_p): Add support for thumb-1 without\n\tMOVT/MOVW.\n\t* config/arm/thumb1.md (*thumb1_movsi_insn): Accept (symbol_ref +\n\taddend) in the pure-code alternative.\n\n\tgcc/testsuite/\n\tPR target/96770\n\t* gcc.target/arm/pure-code/pr96770.c: New test.", "tree": {"sha": "cc599d3f1f27e0a044f7d9ac74490aacb5131139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc599d3f1f27e0a044f7d9ac74490aacb5131139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3c3e2c9e88e25a410a2fe089782b094e911bb39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c3e2c9e88e25a410a2fe089782b094e911bb39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3c3e2c9e88e25a410a2fe089782b094e911bb39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c3e2c9e88e25a410a2fe089782b094e911bb39/comments", "author": null, "committer": null, "parents": [{"sha": "4d9af90d6a216822fe117337fb9836ba656dc3af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9af90d6a216822fe117337fb9836ba656dc3af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d9af90d6a216822fe117337fb9836ba656dc3af"}], "stats": {"total": 43, "additions": 38, "deletions": 5}, "files": [{"sha": "ae05891451a95625b1d8033ebfbf9cae46010c20", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c3e2c9e88e25a410a2fe089782b094e911bb39/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c3e2c9e88e25a410a2fe089782b094e911bb39/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c3c3e2c9e88e25a410a2fe089782b094e911bb39", "patch": "@@ -9504,7 +9504,8 @@ thumb_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \t     we build the symbol address with upper/lower\n \t     relocations.  */\n \t  || (TARGET_THUMB1\n-\t      && GET_CODE (x) == SYMBOL_REF\n+\t      && !label_mentioned_p (x)\n+\t      && arm_valid_symbolic_address_p (x)\n \t      && arm_disable_literal_pool)\n \t  || flag_pic);\n }\n@@ -31659,7 +31660,12 @@ arm_emit_coreregs_64bit_shift (enum rtx_code code, rtx out, rtx in,\n    According to the ARM ELF ABI, the initial addend of REL-type relocations\n    processing MOVW and MOVT instructions is formed by interpreting the 16-bit\n    literal field of the instruction as a 16-bit signed value in the range\n-   -32768 <= A < 32768.  */\n+   -32768 <= A < 32768.\n+\n+   In Thumb-1 mode, we use upper/lower relocations which have an 8-bit\n+   unsigned range of 0 <= A < 256 as described in the AAELF32\n+   relocation handling documentation: REL-type relocations are encoded\n+   as unsigned in this case.  */\n \n bool\n arm_valid_symbolic_address_p (rtx addr)\n@@ -31683,7 +31689,12 @@ arm_valid_symbolic_address_p (rtx addr)\n       xop1 = XEXP (tmp, 1);\n \n       if (GET_CODE (xop0) == SYMBOL_REF && CONST_INT_P (xop1))\n-\t  return IN_RANGE (INTVAL (xop1), -0x8000, 0x7fff);\n+\t{\n+\t  if (TARGET_THUMB1 && !TARGET_HAVE_MOVT)\n+\t    return IN_RANGE (INTVAL (xop1), 0, 0xff);\n+\t  else\n+\t    return IN_RANGE (INTVAL (xop1), -0x8000, 0x7fff);\n+\t}\n     }\n \n   return false;"}, {"sha": "320e78d116134a45844f0ec3c5a102aaf657df3d", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c3e2c9e88e25a410a2fe089782b094e911bb39/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c3e2c9e88e25a410a2fe089782b094e911bb39/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=c3c3e2c9e88e25a410a2fe089782b094e911bb39", "patch": "@@ -675,7 +675,7 @@\n       case 7:\n       /* pure-code alternative: build the constant byte by byte,\n \t instead of loading it from a constant pool.  */\n-\tif (GET_CODE (operands[1]) == SYMBOL_REF)\n+\tif (arm_valid_symbolic_address_p (operands[1]))\n \t  {\n \t    output_asm_insn (\\\"movs\\\\t%0, #:upper8_15:%1\\\", operands);\n \t    output_asm_insn (\\\"lsls\\\\t%0, #8\\\", operands);\n@@ -686,7 +686,7 @@\n \t    output_asm_insn (\\\"adds\\\\t%0, #:lower0_7:%1\\\", operands);\n \t    return \\\"\\\";\n \t  }\n-\telse\n+\telse if (GET_CODE (operands[1]) == CONST_INT)\n \t  {\n \t    int i;\n \t    HOST_WIDE_INT op1 = INTVAL (operands[1]);\n@@ -721,6 +721,7 @@\n \t      output_asm_insn (\"adds\\t%0, %1\", ops);\n \t    return \"\";\n \t  }\n+\t  gcc_unreachable ();\n \n       case 8: return \"ldr\\t%0, %1\";\n       case 9: return \"str\\t%1, %0\";"}, {"sha": "a43d71f05235c159c9cd6dbe077c155c6480df96", "filename": "gcc/testsuite/gcc.target/arm/pure-code/pr96770.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3c3e2c9e88e25a410a2fe089782b094e911bb39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96770.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3c3e2c9e88e25a410a2fe089782b094e911bb39/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96770.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpure-code%2Fpr96770.c?ref=c3c3e2c9e88e25a410a2fe089782b094e911bb39", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mpure-code\" } */\n+\n+int arr[1000];\n+int *f4 (void) { return &arr[1]; }\n+\n+/* For cortex-m0 (thumb-1/v6m), we generate 4 movs with upper/lower:#arr+4.  */\n+/* { dg-final { scan-assembler-times \"\\\\+4\" 4 { target { { ! arm_thumb1_movt_ok } && { ! arm_thumb2_ok } } } } } */\n+\n+/* For cortex-m with movt/movw (thumb-1/v8m.base or thumb-2), we\n+   generate a movt/movw pair with upper/lower:#arr+4.  */\n+/* { dg-final { scan-assembler-times \"\\\\+4\" 2 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */\n+\n+int *f5 (void) { return &arr[80]; }\n+\n+/* For cortex-m0 (thumb-1/v6m), we generate 1 ldr from rodata pointer to arr+320.  */\n+/* { dg-final { scan-assembler-times \"\\\\+320\" 1 { target { { ! arm_thumb1_movt_ok } && { ! arm_thumb2_ok } } } } } */\n+\n+/* For cortex-m with movt/movw (thumb-1/v8m.base or thumb-2), we\n+   generate a movt/movw pair with upper/lower:arr+320.  */\n+/* { dg-final { scan-assembler-times \"\\\\+320\" 2 { target { arm_thumb1_movt_ok || arm_thumb2_ok } } } } */"}]}