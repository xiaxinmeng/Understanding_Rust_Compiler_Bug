{"sha": "ced2ad76877637601a852871803d1dbba8e6d55a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VkMmFkNzY4Nzc2Mzc2MDFhODUyODcxODAzZDFkYmJhOGU2ZDU1YQ==", "commit": {"author": {"name": "Matt Kraai", "email": "kraai@alumni.cmu.edu", "date": "2003-04-19T15:53:44Z"}, "committer": {"name": "Matt Kraai", "email": "kraai@gcc.gnu.org", "date": "2003-04-19T15:53:44Z"}, "message": "README.Portability: Move to a new section and obsolete K+R portability issues.\n\n\t* README.Portability: Move to a new section and obsolete K+R\n\tportability issues.\n\nFrom-SVN: r65818", "tree": {"sha": "fc3b1875bfd34dfbc7f7190854abe00eb82686c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc3b1875bfd34dfbc7f7190854abe00eb82686c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ced2ad76877637601a852871803d1dbba8e6d55a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced2ad76877637601a852871803d1dbba8e6d55a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ced2ad76877637601a852871803d1dbba8e6d55a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ced2ad76877637601a852871803d1dbba8e6d55a/comments", "author": null, "committer": null, "parents": [{"sha": "070154442e8c3011007ae6f5e8f7dc87f90719d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/070154442e8c3011007ae6f5e8f7dc87f90719d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/070154442e8c3011007ae6f5e8f7dc87f90719d2"}], "stats": {"total": 411, "additions": 213, "deletions": 198}, "files": [{"sha": "4c22e8fcd67de943a908717a3e53f3e843f0bd96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced2ad76877637601a852871803d1dbba8e6d55a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced2ad76877637601a852871803d1dbba8e6d55a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ced2ad76877637601a852871803d1dbba8e6d55a", "patch": "@@ -1,3 +1,8 @@\n+2003-04-19  Matt Kraai  <kraai@alumni.cmu.edu>\n+\n+\t* README.Portability: Move to a new section and obsolete K+R\n+\tportability issues.\n+\n Sat Apr 19 14:56:17 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* rtlanal.c (subreg_offset_representable_p):  Fix call of"}, {"sha": "d50947a4349217e1366b96b386fa670d997e19d4", "filename": "gcc/README.Portability", "status": "modified", "additions": 208, "deletions": 198, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ced2ad76877637601a852871803d1dbba8e6d55a/gcc%2FREADME.Portability", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ced2ad76877637601a852871803d1dbba8e6d55a/gcc%2FREADME.Portability", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.Portability?ref=ced2ad76877637601a852871803d1dbba8e6d55a", "patch": "@@ -1,4 +1,4 @@\n-Copyright (C) 2000 Free Software Foundation, Inc.\n+Copyright (C) 2000, 2003 Free Software Foundation, Inc.\n \n This file is intended to contain a few notes about writing C code\n within GCC so that it compiles without error on the full range of\n@@ -15,17 +15,198 @@ probably what most people code to naturally.  Obviously using\n constructs introduced after that is not a good idea.\n \n The first section of this file deals strictly with portability issues,\n-the second with common coding pitfalls.\n+the second with common coding pitfalls, and the third with obsolete\n+K+R portability issues.\n \n \n \t\t\tPortability Issues\n \t\t\t==================\n \n+String literals\n+---------------\n+\n+Some SGI compilers choke on the parentheses in:-\n+\n+const char string[] = (\"A string\");\n+\n+This is unfortunate since this is what the GNU gettext macro N_\n+produces.  You need to find a different way to code it.\n+\n+Some compilers like MSVC++ have fairly low limits on the maximum\n+length of a string literal; 509 is the lowest we've come across.  You\n+may need to break up a long printf statement into many smaller ones.\n+\n+\n+Empty macro arguments\n+---------------------\n+\n+ISO C (6.8.3 in the 1990 standard) specifies the following:\n+\n+If (before argument substitution) any argument consists of no\n+preprocessing tokens, the behavior is undefined.\n+\n+This was relaxed by ISO C99, but some older compilers emit an error,\n+so code like\n+\n+#define foo(x, y) x y\n+foo (bar, )\n+\n+needs to be coded in some other way.\n+\n+\n+free and realloc\n+----------------\n+\n+Some implementations crash upon attempts to free or realloc the null\n+pointer.  Thus if mem might be null, you need to write\n+\n+  if (mem)\n+    free (mem);\n+\n+\n+Trigraphs\n+---------\n+\n+You weren't going to use them anyway, but some otherwise ISO C\n+compliant compilers do not accept trigraphs.\n+\n+\n+Suffixes on Integer Constants\n+-----------------------------\n+\n+You should never use a 'l' suffix on integer constants ('L' is fine),\n+since it can easily be confused with the number '1'.\n+\n+\n+\t\t\tCommon Coding Pitfalls\n+\t\t\t======================\n+\n+errno\n+-----\n+\n+errno might be declared as a macro.\n+\n+\n+Implicit int\n+------------\n+\n+In C, the 'int' keyword can often be omitted from type declarations.\n+For instance, you can write\n+\n+  unsigned variable;\n+\n+as shorthand for\n+\n+  unsigned int variable;\n+\n+There are several places where this can cause trouble.  First, suppose\n+'variable' is a long; then you might think\n+\n+  (unsigned) variable\n+\n+would convert it to unsigned long.  It does not.  It converts to\n+unsigned int.  This mostly causes problems on 64-bit platforms, where\n+long and int are not the same size.\n+\n+Second, if you write a function definition with no return type at\n+all:\n+\n+  operate (int a, int b)\n+  {\n+    ...\n+  }\n+\n+that function is expected to return int, *not* void.  GCC will warn\n+about this.\n+\n+Implicit function declarations always have return type int.  So if you\n+correct the above definition to\n+\n+  void\n+  operate (int a, int b)\n+  ...\n+\n+but operate() is called above its definition, you will get an error\n+about a \"type mismatch with previous implicit declaration\".  The cure\n+is to prototype all functions at the top of the file, or in an\n+appropriate header.\n+\n+Char vs unsigned char vs int\n+----------------------------\n+\n+In C, unqualified 'char' may be either signed or unsigned; it is the\n+implementation's choice.  When you are processing 7-bit ASCII, it does\n+not matter.  But when your program must handle arbitrary binary data,\n+or fully 8-bit character sets, you have a problem.  The most obvious\n+issue is if you have a look-up table indexed by characters.\n+\n+For instance, the character '\\341' in ISO Latin 1 is SMALL LETTER A\n+WITH ACUTE ACCENT.  In the proper locale, isalpha('\\341') will be\n+true.  But if you read '\\341' from a file and store it in a plain\n+char, isalpha(c) may look up character 225, or it may look up\n+character -31.  And the ctype table has no entry at offset -31, so\n+your program will crash.  (If you're lucky.)\n+\n+It is wise to use unsigned char everywhere you possibly can.  This\n+avoids all these problems.  Unfortunately, the routines in <string.h>\n+take plain char arguments, so you have to remember to cast them back\n+and forth - or avoid the use of strxxx() functions, which is probably\n+a good idea anyway.\n+\n+Another common mistake is to use either char or unsigned char to\n+receive the result of getc() or related stdio functions.  They may\n+return EOF, which is outside the range of values representable by\n+char.  If you use char, some legal character value may be confused\n+with EOF, such as '\\377' (SMALL LETTER Y WITH UMLAUT, in Latin-1).\n+The correct choice is int.\n+\n+A more subtle version of the same mistake might look like this:\n+\n+  unsigned char pushback[NPUSHBACK];\n+  int pbidx;\n+  #define unget(c) (assert(pbidx < NPUSHBACK), pushback[pbidx++] = (c))\n+  #define get(c) (pbidx ? pushback[--pbidx] : getchar())\n+  ...\n+  unget(EOF);\n+\n+which will mysteriously turn a pushed-back EOF into a SMALL LETTER Y\n+WITH UMLAUT.\n+\n+\n+Other common pitfalls\n+---------------------\n+\n+o Expecting 'plain' char to be either sign or unsigned extending\n+\n+o Shifting an item by a negative amount or by greater than or equal to\n+  the number of bits in a type (expecting shifts by 32 to be sensible\n+  has caused quite a number of bugs at least in the early days).\n+\n+o Expecting ints shifted right to be sign extended.\n+\n+o Modifying the same value twice within one sequence point.\n+\n+o Host vs. target floating point representation, including emitting NaNs\n+  and Infinities in a form that the assembler handles.\n+\n+o qsort being an unstable sort function (unstable in the sense that\n+  multiple items that sort the same may be sorted in different orders\n+  by different qsort functions).\n+\n+o Passing incorrect types to fprintf and friends.\n+\n+o Adding a function declaration for a module declared in another file to\n+  a .c file instead of to a .h file.\n+\n+\n+\t\t\tK+R Portability Issues\n+\t\t\t======================\n+\n Unary +\n -------\n \n K+R C compilers and preprocessors have no notion of unary '+'.  Thus\n-the following code snippet contains 2 portability problems.\n+the following code snippet contained 2 portability problems.\n \n int x = +2;  /* int x = 2;  */\n #if +1       /* #if 1  */\n@@ -42,62 +223,34 @@ a K+R one.  Thus\n \n   free ((void *) h->value.expansion);\n \n-should be written\n+should have been written\n \n   free ((PTR) h->value.expansion);\n \n Further, an initial investigation indicates that pointers to functions\n-returning void are okay.  Thus the example given by \"Calling functions\n-through pointers to functions\" below appears not to cause a problem.\n+returning void were okay.  Thus the example given by \"Calling\n+functions through pointers to functions\" below appeared not to cause a\n+problem.\n \n \n String literals\n ---------------\n \n-Some SGI compilers choke on the parentheses in:-\n-\n-const char string[] = (\"A string\");\n-\n-This is unfortunate since this is what the GNU gettext macro N_\n-produces.  You need to find a different way to code it.\n-\n K+R C did not allow concatenation of string literals like\n \n   \"This is a \" \"single string literal\".\n \n-Moreover, some compilers like MSVC++ have fairly low limits on the\n-maximum length of a string literal; 509 is the lowest we've come\n-across.  You may need to break up a long printf statement into many\n-smaller ones.\n-\n-\n-Empty macro arguments\n----------------------\n-\n-ISO C (6.8.3 in the 1990 standard) specifies the following:\n-\n-If (before argument substitution) any argument consists of no\n-preprocessing tokens, the behavior is undefined.\n-\n-This was relaxed by ISO C99, but some older compilers emit an error,\n-so code like\n-\n-#define foo(x, y) x y\n-foo (bar, )\n-\n-needs to be coded in some other way.\n-\n \n signed keyword\n --------------\n \n The signed keyword did not exist in K+R compilers; it was introduced\n-in ISO C89, so you cannot use it.  In both K+R and standard C,\n+in ISO C89, so you could not use it.  In both K+R and standard C,\n unqualified char and bitfields may be signed or unsigned.  There is no\n way to portably declare signed chars or signed bitfields.\n \n All other arithmetic types are signed unless you use the 'unsigned'\n-qualifier.  For instance, it is safe to write\n+qualifier.  For instance, it was safe to write\n \n   short paramc;\n \n@@ -106,18 +259,18 @@ instead of\n   signed short paramc;\n \n If you have an algorithm that depends on signed char or signed\n-bitfields, you must find another way to write it before it can be\n+bitfields, you had to find another way to write it before it could be\n integrated into GCC.\n \n \n Function prototypes\n -------------------\n \n You need to provide a function prototype for every function before you\n-use it, and functions must be defined K+R style.  The function\n-prototype should use the PARAMS macro, which takes a single argument.\n-Therefore the parameter list must be enclosed in parentheses.  For\n-example,\n+use it, and functions had to be defined K+R style.  The function\n+prototype should have used the PARAMS macro, which takes a single\n+argument.  Therefore the parameter list had to be enclosed in\n+parentheses.  For example,\n \n int myfunc PARAMS ((double, int *));\n \n@@ -129,7 +282,7 @@ myfunc (var1, var2)\n   ...\n }\n \n-This implies that if the function takes no arguments, it should be\n+This implies that if the function takes no arguments, it had to be\n declared and defined as follows:\n \n int myfunc PARAMS ((void));\n@@ -140,7 +293,7 @@ myfunc ()\n   ...\n }\n \n-You also need to use PARAMS when referring to function protypes in\n+You also had to use PARAMS when referring to function protypes in\n other circumstances, for example see \"Calling functions through\n pointers to functions\" below.\n \n@@ -161,7 +314,7 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n \n See ansidecl.h for the definitions of the above macros and more.\n \n-One aspect of using K+R style function declarations, is you cannot\n+One aspect of using K+R style function declarations, is you could not\n have arguments whose types are char, short, or float, since without\n prototypes (ie, K+R rules), these types are promoted to int, int, and\n double respectively.\n@@ -176,7 +329,7 @@ example\n typedef void (* cl_directive_handler) PARAMS ((cpp_reader *, const char *));\n       *p->handler (pfile, p->arg);\n \n-needs to become\n+had to become\n \n       (*p->handler) (pfile, p->arg);\n \n@@ -202,16 +355,17 @@ compilers x should not have spaces around it.\n Passing structures by value\n ---------------------------\n \n-Avoid passing structures by value, either to or from functions.  It\n-seems some K+R compilers handle this differently or not at all.\n+You had to avoid passing structures by value, either to or from\n+functions.  It seems some K+R compilers handle this differently or not\n+at all.\n \n \n Enums\n -----\n \n-In K+R C, you have to cast enum types to use them as integers, and\n-some compilers in particular give lots of warnings for using an enum\n-as an array index.\n+In K+R C, you had to cast enum types to use them as integers, and some\n+compilers in particular give lots of warnings for using an enum as an\n+array index.\n \n \n Bitfields\n@@ -222,20 +376,10 @@ were defined (i.e. unsigned char, unsigned short, unsigned long.\n Using plain int/short/long was not allowed).\n \n \n-free and realloc\n-----------------\n-\n-Some implementations crash upon attempts to free or realloc the null\n-pointer.  Thus if mem might be null, you need to write\n-\n-  if (mem)\n-    free (mem);\n-\n-\n Reserved Keywords\n -----------------\n \n-K+R C has \"entry\" as a reserved keyword, so you should not use it for\n+K+R C has \"entry\" as a reserved keyword, so you had to not use it for\n your variable names.\n \n \n@@ -248,144 +392,10 @@ int is done as an unsigned comparison in K+R (since unsigned char\n promotes to unsigned) while it is signed in ISO (since all of the\n values in unsigned char fit in an int, it promotes to int).\n \n-Trigraphs\n----------\n-\n-You weren't going to use them anyway, but trigraphs were not defined\n-in K+R C, and some otherwise ISO C compliant compilers do not accept\n-them.\n-\n \n Suffixes on Integer Constants\n -----------------------------\n \n-K+R C did not accept a 'u' suffix on integer constants.  If you want\n-to declare a constant to be be unsigned, you must use an explicit\n+K+R C did not accept a 'u' suffix on integer constants.  If you wanted\n+to declare a constant to be be unsigned, you had to use an explicit\n cast.\n-\n-You should never use a 'l' suffix on integer constants ('L' is fine),\n-since it can easily be confused with the number '1'.\n-\n-\n-\t\t\tCommon Coding Pitfalls\n-\t\t\t======================\n-\n-errno\n------\n-\n-errno might be declared as a macro.\n-\n-\n-Implicit int\n-------------\n-\n-In C, the 'int' keyword can often be omitted from type declarations.\n-For instance, you can write\n-\n-  unsigned variable;\n-\n-as shorthand for\n-\n-  unsigned int variable;\n-\n-There are several places where this can cause trouble.  First, suppose\n-'variable' is a long; then you might think\n-\n-  (unsigned) variable\n-\n-would convert it to unsigned long.  It does not.  It converts to\n-unsigned int.  This mostly causes problems on 64-bit platforms, where\n-long and int are not the same size.\n-\n-Second, if you write a function definition with no return type at\n-all:\n-\n-  operate (a, b)\n-       int a, b;\n-  {\n-    ...\n-  }\n-\n-that function is expected to return int, *not* void.  GCC will warn\n-about this.  K+R C has no problem with 'void' as a return type, so you\n-need not worry about that.\n-\n-Implicit function declarations always have return type int.  So if you\n-correct the above definition to\n-\n-  void\n-  operate (a, b)\n-       int a, b;\n-  ...\n-\n-but operate() is called above its definition, you will get an error\n-about a \"type mismatch with previous implicit declaration\".  The cure\n-is to prototype all functions at the top of the file, or in an\n-appropriate header.\n-\n-Char vs unsigned char vs int\n-----------------------------\n-\n-In C, unqualified 'char' may be either signed or unsigned; it is the\n-implementation's choice.  When you are processing 7-bit ASCII, it does\n-not matter.  But when your program must handle arbitrary binary data,\n-or fully 8-bit character sets, you have a problem.  The most obvious\n-issue is if you have a look-up table indexed by characters.\n-\n-For instance, the character '\\341' in ISO Latin 1 is SMALL LETTER A\n-WITH ACUTE ACCENT.  In the proper locale, isalpha('\\341') will be\n-true.  But if you read '\\341' from a file and store it in a plain\n-char, isalpha(c) may look up character 225, or it may look up\n-character -31.  And the ctype table has no entry at offset -31, so\n-your program will crash.  (If you're lucky.)\n-\n-It is wise to use unsigned char everywhere you possibly can.  This\n-avoids all these problems.  Unfortunately, the routines in <string.h>\n-take plain char arguments, so you have to remember to cast them back\n-and forth - or avoid the use of strxxx() functions, which is probably\n-a good idea anyway.\n-\n-Another common mistake is to use either char or unsigned char to\n-receive the result of getc() or related stdio functions.  They may\n-return EOF, which is outside the range of values representable by\n-char.  If you use char, some legal character value may be confused\n-with EOF, such as '\\377' (SMALL LETTER Y WITH UMLAUT, in Latin-1).\n-The correct choice is int.\n-\n-A more subtle version of the same mistake might look like this:\n-\n-  unsigned char pushback[NPUSHBACK];\n-  int pbidx;\n-  #define unget(c) (assert(pbidx < NPUSHBACK), pushback[pbidx++] = (c))\n-  #define get(c) (pbidx ? pushback[--pbidx] : getchar())\n-  ...\n-  unget(EOF);\n-\n-which will mysteriously turn a pushed-back EOF into a SMALL LETTER Y\n-WITH UMLAUT.\n-\n-\n-Other common pitfalls\n----------------------\n-\n-o Expecting 'plain' char to be either sign or unsigned extending\n-\n-o Shifting an item by a negative amount or by greater than or equal to\n-  the number of bits in a type (expecting shifts by 32 to be sensible\n-  has caused quite a number of bugs at least in the early days).\n-\n-o Expecting ints shifted right to be sign extended.\n-\n-o Modifying the same value twice within one sequence point.\n-\n-o Host vs. target floating point representation, including emitting NaNs\n-  and Infinities in a form that the assembler handles.\n-\n-o qsort being an unstable sort function (unstable in the sense that\n-  multiple items that sort the same may be sorted in different orders\n-  by different qsort functions).\n-\n-o Passing incorrect types to fprintf and friends.\n-\n-o Adding a function declaration for a module declared in another file to\n-  a .c file instead of to a .h file."}]}