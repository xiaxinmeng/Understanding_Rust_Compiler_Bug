{"sha": "79f5e442625680fbd5c12517419e990609bb2810", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlmNWU0NDI2MjU2ODBmYmQ1YzEyNTE3NDE5ZTk5MDYwOWJiMjgxMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-06-10T20:39:22Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-06-10T20:39:22Z"}, "message": "tree-data-ref.c (dr_analyze_alias): Handle case smt is NULL.\n\n\t* tree-data-ref.c (dr_analyze_alias): Handle case smt is NULL.\n\t* tree-predcom.c (mark_virtual_ops_for_renaming): Exported.\n\t* tree-ssa-loop-prefetch.c: Include optabs.h.\n\t(FENCE_FOLLOWING_MOVNT): New macro.\n\t(struct mem_ref): Add independent_p and storent_p fields.\n\t(record_ref): Initalize the new fields.\n\t(gather_memory_references_ref): Return true if the reference\n\tcould be analysed.\n\t(gather_memory_references): Check whether all memory accesses\n\tin loop were recorded.\n\t(should_issue_prefetch_p): Return false for nontemporal stores.\n\t(nontemporal_store_p, mark_nontemporal_store, emit_mfence_after_loop,\n\tmay_use_storent_in_loop_p, mark_nontemporal_stores): New functions.\n\t(determine_loop_nest_reuse): Detect independent memory references.\n\t(loop_prefetch_arrays): Call mark_nontemporal_stores.\n\t* tree-flow.h (mark_virtual_ops_for_renaming): Declare.\n\t* Makefile.in (tree-ssa-loop-prefetch.o): Add OPTABS_H dependency.\n\t* config/i386/i386.h (x86_mfence): Declare.\n\t(FENCE_FOLLOWING_MOVNT): Return x86_mfence.\n\t* config/i386/i386.c (x86_mfence): New variable.\n\t(ix86_init_mmx_sse_builtins): Initialize x86_mfence.\n\n\t* tree-pretty-print.c (dump_generic_node): Mark nontemporal stores.\n\t* optabs.c (init_optabs): Initialize storent_optab.\n\t* optabs.h (enum optab_index): Add OTI_storent.\n\t(storent_optab): Declare.\n\t* genopinit.c (optabs): Add initialization for storent_optab.\n\t* tree.h (MOVE_NONTEMPORAL): New macro.\n\t* expr.c (expand_assignment, store_expr, store_constructor_field,\n\tstore_constructor, store_field, expand_expr_real_1): Propagate\n\tnontemporality of the expanded store.\n\t(emit_storent_insn): New function.\n\t* expr.h (expand_assignment, store_expr): Declaration changed.\n\t* function.c (assign_parm_setup_reg): Pass false as nontemporality\n\tto expand_assignment.\n\t* stmt.c (expand_asm_expr): Ditto.\n\t* calls.c (initialize_argument_information): Pass false as\n\tnontemporality to store_expr.\n\t* config/i386/sse.md (storentv4sf, storentv2df, storentv2di,\n\tstorentsi): New.\n\n\t* gcc.dg/tree-ssa/prefetch-7.c: New test.\n\nFrom-SVN: r125604", "tree": {"sha": "aa6fde364b39cc3fab0e7d98faf468b947ade3d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa6fde364b39cc3fab0e7d98faf468b947ade3d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79f5e442625680fbd5c12517419e990609bb2810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f5e442625680fbd5c12517419e990609bb2810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79f5e442625680fbd5c12517419e990609bb2810", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79f5e442625680fbd5c12517419e990609bb2810/comments", "author": null, "committer": null, "parents": [{"sha": "6bdff197e6b8397129441e85a53fbb3c738c3d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdff197e6b8397129441e85a53fbb3c738c3d57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdff197e6b8397129441e85a53fbb3c738c3d57"}], "stats": {"total": 526, "additions": 466, "deletions": 60}, "files": [{"sha": "aaeeaac4ca2788fd672987d146d28c84ea9e2bd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1,3 +1,46 @@\n+2007-06-10  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-data-ref.c (dr_analyze_alias): Handle case smt is NULL.\n+\t* tree-predcom.c (mark_virtual_ops_for_renaming): Exported.\n+\t* tree-ssa-loop-prefetch.c: Include optabs.h.\n+\t(FENCE_FOLLOWING_MOVNT): New macro.\n+\t(struct mem_ref): Add independent_p and storent_p fields.\n+\t(record_ref): Initalize the new fields.\n+\t(gather_memory_references_ref): Return true if the reference\n+\tcould be analysed.\n+\t(gather_memory_references): Check whether all memory accesses\n+\tin loop were recorded.\n+\t(should_issue_prefetch_p): Return false for nontemporal stores.\n+\t(nontemporal_store_p, mark_nontemporal_store, emit_mfence_after_loop,\n+\tmay_use_storent_in_loop_p, mark_nontemporal_stores): New functions.\n+\t(determine_loop_nest_reuse): Detect independent memory references.\n+\t(loop_prefetch_arrays): Call mark_nontemporal_stores.\n+\t* tree-flow.h (mark_virtual_ops_for_renaming): Declare.\n+\t* Makefile.in (tree-ssa-loop-prefetch.o): Add OPTABS_H dependency.\n+\t* config/i386/i386.h (x86_mfence): Declare.\n+\t(FENCE_FOLLOWING_MOVNT): Return x86_mfence.\n+\t* config/i386/i386.c (x86_mfence): New variable.\n+\t(ix86_init_mmx_sse_builtins): Initialize x86_mfence.\n+\n+\t* tree-pretty-print.c (dump_generic_node): Mark nontemporal stores.\n+\t* optabs.c (init_optabs): Initialize storent_optab.\n+\t* optabs.h (enum optab_index): Add OTI_storent.\n+\t(storent_optab): Declare.\n+\t* genopinit.c (optabs): Add initialization for storent_optab.\n+\t* tree.h (MOVE_NONTEMPORAL): New macro.\n+\t* expr.c (expand_assignment, store_expr, store_constructor_field,\n+\tstore_constructor, store_field, expand_expr_real_1): Propagate\n+\tnontemporality of the expanded store.\n+\t(emit_storent_insn): New function.\n+\t* expr.h (expand_assignment, store_expr): Declaration changed.\n+\t* function.c (assign_parm_setup_reg): Pass false as nontemporality\n+\tto expand_assignment.\n+\t* stmt.c (expand_asm_expr): Ditto.\n+\t* calls.c (initialize_argument_information): Pass false as\n+\tnontemporality to store_expr.\n+\t* config/i386/sse.md (storentv4sf, storentv2df, storentv2di,\n+\tstorentsi): New.\n+\n 2007-06-09  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-structalias.c (set_uids_in_ptset): Add is_deref'd"}, {"sha": "4e7570130afb2cff8fa55e615a616f67af88dab5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -2085,7 +2085,8 @@ tree-ssa-loop-prefetch.o: tree-ssa-loop-prefetch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(GGC_H) $(RECOG_H) insn-config.h $(HASHTAB_H) $(SCEV_H) \\\n    $(CFGLOOP_H) $(PARAMS_H) langhooks.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-   tree-chrec.h toplev.h langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H)\n+   tree-chrec.h toplev.h langhooks.h $(TREE_INLINE_H) $(TREE_DATA_REF_H) \\\n+   $(OPTABS_H)\n tree-predcom.o: tree-predcom.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_P_H) \\\n    $(CFGLOOP_H) $(TREE_FLOW_H) $(GGC_H) $(TREE_DATA_REF_H) $(SCEV_H) \\\n    $(PARAMS_H) $(DIAGNOSTIC_H) tree-pass.h $(TM_H) coretypes.h tree-affine.h \\"}, {"sha": "32ca3ef38be8ee591d925123940c5a6b10f8ff22", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1080,7 +1080,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t      else\n \t\tcopy = assign_temp (type, 0, 1, 0);\n \n-\t      store_expr (args[i].tree_value, copy, 0);\n+\t      store_expr (args[i].tree_value, copy, 0, false);\n \n \t      if (callee_copies)\n \t\t*ecf_flags &= ~(ECF_CONST | ECF_LIBCALL_BLOCK);"}, {"sha": "f8019bde0f907dfd211ae15df7fe2f476fa210eb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1500,6 +1500,9 @@ int ix86_section_threshold = 65536;\n char internal_label_prefix[16];\n int internal_label_prefix_len;\n \n+/* Fence to use after loop using movnt.  */\n+tree x86_mfence;\n+\n /* Register class used for passing given 64bit part of the argument.\n    These represent classes as documented by the PS ABI, with the exception\n    of SSESF, SSEDF classes, that are basically SSE class, just gcc will\n@@ -18120,7 +18123,7 @@ ix86_init_mmx_sse_builtins (void)\n \n   def_builtin (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_clflush\", void_ftype_pcvoid, IX86_BUILTIN_CLFLUSH);\n   def_builtin (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_lfence\", void_ftype_void, IX86_BUILTIN_LFENCE);\n-  def_builtin (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_mfence\", void_ftype_void, IX86_BUILTIN_MFENCE);\n+  x86_mfence = def_builtin (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_mfence\", void_ftype_void, IX86_BUILTIN_MFENCE);\n \n   def_builtin (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_loaddqu\", v16qi_ftype_pcchar, IX86_BUILTIN_LOADDQU);\n   def_builtin (OPTION_MASK_ISA_SSE2, \"__builtin_ia32_storedqu\", void_ftype_pchar_v16qi, IX86_BUILTIN_STOREDQU);"}, {"sha": "693f8ee2df7abc3567d92075ea493ca607bb72f7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -386,6 +386,11 @@ extern int ix86_isa_flags;\n #define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT 0\n #endif\n \n+/* Fence to use after loop using storent.  */\n+\n+extern tree x86_mfence;\n+#define FENCE_FOLLOWING_MOVNT x86_mfence\n+\n /* Once GDB has been enhanced to deal with functions without frame\n    pointers, we can change this to allow for elimination of\n    the frame pointer in leaf functions.  */"}, {"sha": "a7a56490cabdf5cb6d578b8ff543517776c4541e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -317,6 +317,38 @@\n    (set_attr \"prefix_rep\" \"1\")\n    (set_attr \"mode\" \"TI\")])\n \n+; Expand patterns for non-temporal stores.  At the moment, only those\n+; that directly map to insns are defined; it would be possible to\n+; define patterns for other modes that would expand to several insns.\n+\n+(define_expand \"storentv4sf\"\n+  [(set (match_operand:V4SF 0 \"memory_operand\" \"=m\")\n+\t(unspec:V4SF [(match_operand:V4SF 1 \"register_operand\" \"x\")]\n+\t\t     UNSPEC_MOVNT))]\n+  \"TARGET_SSE\"\n+  \"\")\n+\n+(define_expand \"storentv2df\"\n+  [(set (match_operand:V2DF 0 \"memory_operand\" \"=m\")\n+\t(unspec:V2DF [(match_operand:V2DF 1 \"register_operand\" \"x\")]\n+\t\t     UNSPEC_MOVNT))]\n+  \"TARGET_SSE2\"\n+  \"\")\n+\n+(define_expand \"storentv2di\"\n+  [(set (match_operand:V2DI 0 \"memory_operand\" \"=m\")\n+\t(unspec:V2DI [(match_operand:V2DI 1 \"register_operand\" \"x\")]\n+\t\t     UNSPEC_MOVNT))]\n+  \"TARGET_SSE2\"\n+  \"\")\n+\n+(define_expand \"storentsi\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")]\n+\t\t   UNSPEC_MOVNT))]\n+  \"TARGET_SSE2\"\n+  \"\")\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel single-precision floating point arithmetic"}, {"sha": "9c5056b3f13146c75358869a77701d4e7904fe64", "filename": "gcc/expr.c", "status": "modified", "additions": 90, "deletions": 30, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -142,7 +142,7 @@ static void store_constructor_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t\t     tree, tree, int, int);\n static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,\n-\t\t\ttree, tree, int);\n+\t\t\ttree, tree, int, bool);\n \n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (tree, tree);\n \n@@ -4074,10 +4074,11 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n }\n \n \n-/* Expand an assignment that stores the value of FROM into TO.  */\n+/* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL\n+   is true, try generating a nontemporal store.  */\n \n void\n-expand_assignment (tree to, tree from)\n+expand_assignment (tree to, tree from, bool nontemporal)\n {\n   rtx to_rtx = 0;\n   rtx result;\n@@ -4164,12 +4165,13 @@ expand_assignment (tree to, tree from)\n \t  if (TREE_CODE (TREE_TYPE (from)) == COMPLEX_TYPE)\n \t    {\n \t      gcc_assert (bitpos == 0);\n-\t      result = store_expr (from, to_rtx, false);\n+\t      result = store_expr (from, to_rtx, false, nontemporal);\n \t    }\n \t  else\n \t    {\n \t      gcc_assert (bitpos == 0 || bitpos == GET_MODE_BITSIZE (mode1));\n-\t      result = store_expr (from, XEXP (to_rtx, bitpos != 0), false);\n+\t      result = store_expr (from, XEXP (to_rtx, bitpos != 0), false,\n+\t\t\t\t   nontemporal);\n \t    }\n \t}\n       else\n@@ -4195,7 +4197,8 @@ expand_assignment (tree to, tree from)\n \t    result = NULL;\n \t  else\n \t    result = store_field (to_rtx, bitsize, bitpos, mode1, from,\n-\t\t\t\t  TREE_TYPE (tem), get_alias_set (to));\n+\t\t\t\t  TREE_TYPE (tem), get_alias_set (to),\n+\t\t\t\t  nontemporal);\n \t}\n \n       if (result)\n@@ -4302,13 +4305,46 @@ expand_assignment (tree to, tree from)\n   /* Compute FROM and store the value in the rtx we got.  */\n \n   push_temp_slots ();\n-  result = store_expr (from, to_rtx, 0);\n+  result = store_expr (from, to_rtx, 0, nontemporal);\n   preserve_temp_slots (result);\n   free_temp_slots ();\n   pop_temp_slots ();\n   return;\n }\n \n+/* Emits nontemporal store insn that moves FROM to TO.  Returns true if this\n+   succeeded, false otherwise.  */\n+\n+static bool\n+emit_storent_insn (rtx to, rtx from)\n+{\n+  enum machine_mode mode = GET_MODE (to), imode;\n+  enum insn_code code = storent_optab->handlers[mode].insn_code;\n+  rtx pattern;\n+\n+  if (code == CODE_FOR_nothing)\n+    return false;\n+\n+  imode = insn_data[code].operand[0].mode;\n+  if (!insn_data[code].operand[0].predicate (to, imode))\n+    return false;\n+\n+  imode = insn_data[code].operand[1].mode;\n+  if (!insn_data[code].operand[1].predicate (from, imode))\n+    {\n+      from = copy_to_mode_reg (imode, from);\n+      if (!insn_data[code].operand[1].predicate (from, imode))\n+\treturn false;\n+    }\n+\n+  pattern = GEN_FCN (code) (to, from);\n+  if (pattern == NULL_RTX)\n+    return false;\n+\n+  emit_insn (pattern);\n+  return true;\n+}\n+\n /* Generate code for computing expression EXP,\n    and storing the value into TARGET.\n \n@@ -4320,10 +4356,12 @@ expand_assignment (tree to, tree from)\n    be more thorough?\n \n    If CALL_PARAM_P is nonzero, this is a store into a call param on the\n-   stack, and block moves may need to be treated specially.  */\n+   stack, and block moves may need to be treated specially.\n+ \n+   If NONTEMPORAL is true, try using a nontemporal store instruction.  */\n \n rtx\n-store_expr (tree exp, rtx target, int call_param_p)\n+store_expr (tree exp, rtx target, int call_param_p, bool nontemporal)\n {\n   rtx temp;\n   rtx alt_rtl = NULL_RTX;\n@@ -4344,7 +4382,8 @@ store_expr (tree exp, rtx target, int call_param_p)\n \t part.  */\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n \t\t   call_param_p ? EXPAND_STACK_PARM : EXPAND_NORMAL);\n-      return store_expr (TREE_OPERAND (exp, 1), target, call_param_p);\n+      return store_expr (TREE_OPERAND (exp, 1), target, call_param_p,\n+\t\t\t nontemporal);\n     }\n   else if (TREE_CODE (exp) == COND_EXPR && GET_MODE (target) == BLKmode)\n     {\n@@ -4358,11 +4397,13 @@ store_expr (tree exp, rtx target, int call_param_p)\n       do_pending_stack_adjust ();\n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n-      store_expr (TREE_OPERAND (exp, 1), target, call_param_p);\n+      store_expr (TREE_OPERAND (exp, 1), target, call_param_p,\n+\t\t  nontemporal);\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n-      store_expr (TREE_OPERAND (exp, 2), target, call_param_p);\n+      store_expr (TREE_OPERAND (exp, 2), target, call_param_p,\n+\t\t  nontemporal);\n       emit_label (lab2);\n       OK_DEFER_POP;\n \n@@ -4433,7 +4474,12 @@ store_expr (tree exp, rtx target, int call_param_p)\n     }\n   else\n     {\n-      temp = expand_expr_real (exp, target, GET_MODE (target),\n+      rtx tmp_target;\n+\n+      /* If we want to use a nontemporal store, force the value to\n+\t register first.  */\n+      tmp_target = nontemporal ? NULL_RTX : target;\n+      temp = expand_expr_real (exp, tmp_target, GET_MODE (target),\n \t\t\t       (call_param_p\n \t\t\t\t? EXPAND_STACK_PARM : EXPAND_NORMAL),\n \t\t\t       &alt_rtl);\n@@ -4591,6 +4637,11 @@ store_expr (tree exp, rtx target, int call_param_p)\n \temit_block_move (target, temp, expr_size (exp),\n \t\t\t (call_param_p\n \t\t\t  ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));\n+      else if (nontemporal\n+\t       && emit_storent_insn (target, temp))\n+\t/* If we managed to emit a nontemporal store, there is nothing else to\n+\t   do.  */\n+\t;\n       else\n \t{\n \t  temp = force_operand (temp, target);\n@@ -4941,7 +4992,7 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n       store_constructor (exp, target, cleared, bitsize / BITS_PER_UNIT);\n     }\n   else\n-    store_field (target, bitsize, bitpos, mode, exp, type, alias_set);\n+    store_field (target, bitsize, bitpos, mode, exp, type, alias_set, false);\n }\n \n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -5291,7 +5342,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t      = gen_reg_rtx (promote_mode (domain, DECL_MODE (index),\n \t\t\t\t\t\t   &unsignedp, 0));\n \t\t    SET_DECL_RTL (index, index_r);\n-\t\t    store_expr (lo_index, index_r, 0);\n+\t\t    store_expr (lo_index, index_r, 0, false);\n \n \t\t    /* Build the head of the loop.  */\n \t\t    do_pending_stack_adjust ();\n@@ -5318,7 +5369,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t      store_constructor (value, xtarget, cleared,\n \t\t\t\t\t bitsize / BITS_PER_UNIT);\n \t\t    else\n-\t\t      store_expr (value, xtarget, 0);\n+\t\t      store_expr (value, xtarget, 0, false);\n \n \t\t    /* Generate a conditional jump to exit the loop.  */\n \t\t    exit_cond = build2 (LT_EXPR, integer_type_node,\n@@ -5329,7 +5380,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t       the loop.  */\n \t\t    expand_assignment (index,\n \t\t\t\t       build2 (PLUS_EXPR, TREE_TYPE (index),\n-\t\t\t\t\t       index, integer_one_node));\n+\t\t\t\t\t       index, integer_one_node),\n+\t\t\t\t       false);\n \n \t\t    emit_jump (loop_start);\n \n@@ -5360,7 +5412,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t\t\t\t\t  expand_normal (position),\n \t\t\t\t\t  highest_pow2_factor (position));\n \t\txtarget = adjust_address (xtarget, mode, 0);\n-\t\tstore_expr (value, xtarget, 0);\n+\t\tstore_expr (value, xtarget, 0, false);\n \t      }\n \t    else\n \t      {\n@@ -5522,11 +5574,14 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n    ALIAS_SET is the alias set for the destination.  This value will\n    (in general) be different from that for TARGET, since TARGET is a\n-   reference to the containing structure.  */\n+   reference to the containing structure.\n+   \n+   If NONTEMPORAL is true, try generating a nontemporal store.  */\n \n static rtx\n store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n-\t     enum machine_mode mode, tree exp, tree type, int alias_set)\n+\t     enum machine_mode mode, tree exp, tree type, int alias_set,\n+\t     bool nontemporal)\n {\n   HOST_WIDE_INT width_mask = 0;\n \n@@ -5561,7 +5616,8 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (bitsize != (HOST_WIDE_INT) GET_MODE_BITSIZE (GET_MODE (target)))\n \temit_move_insn (object, target);\n \n-      store_field (blk_object, bitsize, bitpos, mode, exp, type, alias_set);\n+      store_field (blk_object, bitsize, bitpos, mode, exp, type, alias_set,\n+\t\t   nontemporal);\n \n       emit_move_insn (target, object);\n \n@@ -5574,7 +5630,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       /* We're storing into a struct containing a single __complex.  */\n \n       gcc_assert (!bitpos);\n-      return store_expr (exp, target, 0);\n+      return store_expr (exp, target, 0, nontemporal);\n     }\n \n   /* If the structure is in a register or if the component\n@@ -5675,7 +5731,7 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n       if (!MEM_KEEP_ALIAS_SET_P (to_rtx) && MEM_ALIAS_SET (to_rtx) != 0)\n \tset_mem_alias_set (to_rtx, alias_set);\n \n-      return store_expr (exp, to_rtx, 0);\n+      return store_expr (exp, to_rtx, 0, nontemporal);\n     }\n }\n \f\n@@ -7831,7 +7887,8 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    /* Store data into beginning of memory target.  */\n \t    store_expr (TREE_OPERAND (exp, 0),\n \t\t\tadjust_address (target, TYPE_MODE (valtype), 0),\n-\t\t\tmodifier == EXPAND_STACK_PARM);\n+\t\t\tmodifier == EXPAND_STACK_PARM,\n+\t\t\tfalse);\n \n \t  else\n \t    {\n@@ -7844,7 +7901,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t\t * BITS_PER_UNIT),\n \t\t\t\t(HOST_WIDE_INT) GET_MODE_BITSIZE (mode)),\n \t\t\t   0, TYPE_MODE (valtype), TREE_OPERAND (exp, 0),\n-\t\t\t   type, 0);\n+\t\t\t   type, 0, false);\n \t    }\n \n \t  /* Return the entire union.  */\n@@ -8760,13 +8817,15 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n        op1 = gen_label_rtx ();\n        jumpifnot (TREE_OPERAND (exp, 0), op0);\n        store_expr (TREE_OPERAND (exp, 1), temp,\n- \t\t  modifier == EXPAND_STACK_PARM);\n+ \t\t  modifier == EXPAND_STACK_PARM,\n+\t\t  false);\n \n        emit_jump_insn (gen_jump (op1));\n        emit_barrier ();\n        emit_label (op0);\n        store_expr (TREE_OPERAND (exp, 2), temp,\n- \t\t  modifier == EXPAND_STACK_PARM);\n+ \t\t  modifier == EXPAND_STACK_PARM,\n+\t\t  false);\n \n        emit_label (op1);\n        OK_DEFER_POP;\n@@ -8781,7 +8840,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttree lhs = TREE_OPERAND (exp, 0);\n \ttree rhs = TREE_OPERAND (exp, 1);\n \tgcc_assert (ignore);\n-\texpand_assignment (lhs, rhs);\n+\texpand_assignment (lhs, rhs, false);\n \treturn const0_rtx;\n       }\n \n@@ -8813,13 +8872,14 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    do_jump (TREE_OPERAND (rhs, 1),\n \t\t     value ? label : 0,\n \t\t     value ? 0 : label);\n-\t    expand_assignment (lhs, build_int_cst (TREE_TYPE (rhs), value));\n+\t    expand_assignment (lhs, build_int_cst (TREE_TYPE (rhs), value),\n+\t\t\t       MOVE_NONTEMPORAL (exp));\n \t    do_pending_stack_adjust ();\n \t    emit_label (label);\n \t    return const0_rtx;\n \t  }\n \n-\texpand_assignment (lhs, rhs);\n+\texpand_assignment (lhs, rhs, MOVE_NONTEMPORAL (exp));\n \treturn const0_rtx;\n       }\n "}, {"sha": "064a574f9b9de5c664dc8bbd262f43d4f7720ca2", "filename": "gcc/expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -477,13 +477,13 @@ extern void emit_push_insn (rtx, enum machine_mode, tree, rtx, unsigned int,\n \t\t\t    int, rtx, int, rtx, rtx, int, rtx);\n \n /* Expand an assignment that stores the value of FROM into TO.  */\n-extern void expand_assignment (tree, tree);\n+extern void expand_assignment (tree, tree, bool);\n \n /* Generate code for computing expression EXP,\n    and storing the value into TARGET.\n    If SUGGEST_REG is nonzero, copy the value through a register\n    and return that register, if that is possible.  */\n-extern rtx store_expr (tree, rtx, int);\n+extern rtx store_expr (tree, rtx, int, bool);\n \n /* Given an rtx that may include add and multiply operations,\n    generate them as insns and return a pseudo-reg containing the value."}, {"sha": "7d2063c3a22e08d192f0f265095c2a5e6dc1136c", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -2723,7 +2723,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n \n       /* TREE_USED gets set erroneously during expand_assignment.  */\n       save_tree_used = TREE_USED (parm);\n-      expand_assignment (parm, make_tree (data->nominal_type, tempreg));\n+      expand_assignment (parm, make_tree (data->nominal_type, tempreg), false);\n       TREE_USED (parm) = save_tree_used;\n       all->first_conversion_insn = get_insns ();\n       all->last_conversion_insn = get_last_insn ();"}, {"sha": "0838058fdcbcc12a8cc4193d5127ff27f38baf38", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -164,6 +164,7 @@ static const char * const optabs[] =\n   \"mov_optab->handlers[$A].insn_code = CODE_FOR_$(mov$a$)\",\n   \"movstrict_optab->handlers[$A].insn_code = CODE_FOR_$(movstrict$a$)\",\n   \"movmisalign_optab->handlers[$A].insn_code = CODE_FOR_$(movmisalign$a$)\",\n+  \"storent_optab->handlers[$A].insn_code = CODE_FOR_$(storent$a$)\",\n   \"cmp_optab->handlers[$A].insn_code = CODE_FOR_$(cmp$a$)\",\n   \"tst_optab->handlers[$A].insn_code = CODE_FOR_$(tst$a$)\",\n   \"addcc_optab->handlers[$A].insn_code = CODE_FOR_$(add$acc$)\","}, {"sha": "cfd2934ddc79f659315f2f819d79436935442b01", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -5492,6 +5492,8 @@ init_optabs (void)\n   movstrict_optab = init_optab (STRICT_LOW_PART);\n   cmp_optab = init_optab (COMPARE);\n \n+  storent_optab = init_optab (UNKNOWN);\n+\n   ucmp_optab = init_optab (UNKNOWN);\n   tst_optab = init_optab (UNKNOWN);\n "}, {"sha": "c344b657378cea71fdb8eb1eb471991930ae27d8", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -151,6 +151,8 @@ enum optab_index\n   OTI_movstrict,\n   /* Move, with a misaligned memory.  */\n   OTI_movmisalign,\n+  /* Nontemporal store.  */\n+  OTI_storent,\n \n   /* Unary operations */\n   /* Negation */\n@@ -367,6 +369,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define mov_optab (optab_table[OTI_mov])\n #define movstrict_optab (optab_table[OTI_movstrict])\n #define movmisalign_optab (optab_table[OTI_movmisalign])\n+#define storent_optab (optab_table[OTI_storent])\n \n #define neg_optab (optab_table[OTI_neg])\n #define negv_optab (optab_table[OTI_negv])"}, {"sha": "fa18f088c2035f2ff689d8e14d1cbfee5f0fdd68", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1114,7 +1114,7 @@ expand_asm_expr (tree exp)\n     {\n       if (o[i] != TREE_VALUE (tail))\n \t{\n-\t  expand_assignment (o[i], TREE_VALUE (tail));\n+\t  expand_assignment (o[i], TREE_VALUE (tail), false);\n \t  free_temp_slots ();\n \n \t  /* Restore the original value so that it's correct the next"}, {"sha": "c9bdc4a069fb862d042fdcc1b0534fe64e21e049", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1,3 +1,7 @@\n+2007-06-10  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/prefetch-7.c: New test.\n+\n 2007-06-09  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/loop-28.c: New testcase."}, {"sha": "510dee0459893aa3888165e94ac8fe4a7c4a690a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-7.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-7.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -msse2 -mfpmath=sse --param simultaneous-prefetches=100 --param max-unrolled-insns=1 -fdump-tree-aprefetch-details -fdump-tree-final_cleanup\" } */\n+\n+#define K 1000000\n+int a[K], b[K];\n+\n+void test(int *p)\n+{\n+  unsigned i;\n+\n+  /* Nontemporal store should be used for a.  */\n+  for (i = 0; i < K; i++)\n+    a[i] = 0;\n+\n+  /* Nontemporal store should be used for a, nontemporal prefetch for b.  */\n+  for (i = 0; i < K; i++)\n+    a[i] = b[i];\n+\n+  /* Nontemporal store should not be used here (only write and read temporal\n+     prefetches).  */\n+  for (i = 0; i < K - 10000; i++)\n+    a[i + 10000] = a[i];\n+\n+  /* Nontemporal store should not be used here (only write and read nontemporal\n+     prefetches).  */\n+  for (i = 0; i < K - 100000; i++)\n+    a[i + 100000] = a[i];\n+\n+  /* Nontemporal store should be used neither for a nor for p, as we do not know\n+     whether they alias or not.  */\n+  for (i = 0; i < K; i++)\n+    {\n+      a[i] = 0;\n+      *p++ = 1;\n+    }\n+\n+  /* Nontemporal store should not be used for a, as we do not know whether its\n+     value will be reused or not.  */\n+  for (i = 0; i < 1000; i++)\n+    a[i] = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Issued prefetch\" 5 \"aprefetch\" } } */\n+/* { dg-final { scan-tree-dump-times \"Issued nontemporal prefetch\" 3 \"aprefetch\" } } */\n+/* { dg-final { scan-tree-dump-times \"nontemporal store\" 2 \"aprefetch\" } } */\n+\n+/* { dg-final { scan-tree-dump-times \"builtin_prefetch\" 8 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"=\\\\{nt\\\\}\" 2 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_ia32_mfence\" 2 \"final_cleanup\" } } */\n+\n+/* { dg-final { scan-assembler-times \"prefetchw\" 5 } } */\n+/* { dg-final { scan-assembler-times \"prefetcht\" 1 } } */\n+/* { dg-final { scan-assembler-times \"prefetchnta\" 2 } } */\n+/* { dg-final { scan-assembler-times \"movnti\" 2 } } */\n+/* { dg-final { scan-assembler-times \"mfence\" 2 } } */\n+\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "e0223c326f7805634183ae3a3af4c34683415452", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -729,7 +729,7 @@ dr_analyze_alias (struct data_reference *dr)\n     }\n \n   DR_SYMBOL_TAG (dr) = smt;\n-  if (var_can_have_subvars (smt))\n+  if (smt && var_can_have_subvars (smt))\n     DR_SUBVARS (dr) = get_subvars_for_var (smt);\n \n   vops = BITMAP_ALLOC (NULL);"}, {"sha": "a61700b30643a0c08aa9efe731eeda2b0f12a8f6", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1019,6 +1019,7 @@ void tree_transform_and_unroll_loop (struct loop *, unsigned,\n \t\t\t\t     transform_callback, void *);\n bool contains_abnormal_ssa_name_p (tree);\n bool stmt_dominates_stmt_p (tree, tree);\n+void mark_virtual_ops_for_renaming (tree);\n \n /* In tree-ssa-threadedge.c */\n extern bool potentially_threadable_block (basic_block);"}, {"sha": "3c9164db2c7762c5fe9ea491b8461bae07781326", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1378,7 +1378,7 @@ get_init_expr (chain_p chain, unsigned index)\n \n /* Marks all virtual operands of statement STMT for renaming.  */\n \n-static void\n+void\n mark_virtual_ops_for_renaming (tree stmt)\n {\n   ssa_op_iter iter;"}, {"sha": "7cfd4b51a148bd8a951251c9a7b23ce898abea7e", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -1063,6 +1063,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  \t\t false);\n       pp_space (buffer);\n       pp_character (buffer, '=');\n+      if (TREE_CODE (node) == GIMPLE_MODIFY_STMT\n+\t  && MOVE_NONTEMPORAL (node))\n+\tpp_string (buffer, \"{nt}\");\n       pp_space (buffer);\n       dump_generic_node (buffer, GENERIC_TREE_OPERAND (node, 1), spc, flags,\n \t  \t\t false);"}, {"sha": "2424c4a1832ddaf12eccfb0cd3af80bda1c6faf9", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 204, "deletions": 21, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -47,6 +47,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"tree-inline.h\"\n #include \"tree-data-ref.h\"\n+#include \"optabs.h\"\n \n /* This pass inserts prefetch instructions to optimize cache usage during\n    accesses to arrays in loops.  It processes loops sequentially and:\n@@ -177,6 +178,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    is accessed several times in a single iteration of the loop.  */\n #define NONTEMPORAL_FRACTION 16\n \n+/* In case we have to emit a memory fence instruction after the loop that\n+   uses nontemporal stores, this defines the builtin to use.  */\n+\n+#ifndef FENCE_FOLLOWING_MOVNT\n+#define FENCE_FOLLOWING_MOVNT NULL_TREE\n+#endif\n+\n /* The group of references between that reuse may occur.  */\n \n struct mem_ref_group\n@@ -198,7 +206,6 @@ struct mem_ref\n   tree stmt;\t\t\t/* Statement in that the reference appears.  */\n   tree mem;\t\t\t/* The reference.  */\n   HOST_WIDE_INT delta;\t\t/* Constant offset of the reference.  */\n-  bool write_p;\t\t\t/* Is it a write?  */\n   struct mem_ref_group *group;\t/* The group of references it belongs to.  */\n   unsigned HOST_WIDE_INT prefetch_mod;\n \t\t\t\t/* Prefetch only each PREFETCH_MOD-th\n@@ -208,8 +215,13 @@ struct mem_ref\n \t\t\t\t   iterations.  */\n   unsigned reuse_distance;\t/* The amount of data accessed before the first\n \t\t\t\t   reuse of this value.  */\n-  bool issue_prefetch_p;\t/* Should we really issue the prefetch?  */\n   struct mem_ref *next;\t\t/* The next reference in the group.  */\n+  unsigned write_p : 1;\t\t/* Is it a write?  */\n+  unsigned independent_p : 1;\t/* True if the reference is independent on\n+\t\t\t\t   all other references inside the loop.  */\n+  unsigned issue_prefetch_p : 1;\t/* Should we really issue the prefetch?  */\n+  unsigned storent_p : 1;\t/* True if we changed the store to a\n+\t\t\t\t   nontemporal one.  */\n };\n \n /* Dumps information about reference REF to FILE.  */\n@@ -302,6 +314,8 @@ record_ref (struct mem_ref_group *group, tree stmt, tree mem,\n   (*aref)->issue_prefetch_p = false;\n   (*aref)->group = group;\n   (*aref)->next = NULL;\n+  (*aref)->independent_p = false;\n+  (*aref)->storent_p = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_mem_ref (dump_file, *aref);\n@@ -434,9 +448,10 @@ analyze_ref (struct loop *loop, tree *ref_p, tree *base,\n }\n \n /* Record a memory reference REF to the list REFS.  The reference occurs in\n-   LOOP in statement STMT and it is write if WRITE_P.  */\n+   LOOP in statement STMT and it is write if WRITE_P.  Returns true if the\n+   reference was recorded, false otherwise.  */\n \n-static void\n+static bool\n gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n \t\t\t      tree ref, bool write_p, tree stmt)\n {\n@@ -445,26 +460,31 @@ gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n   struct mem_ref_group *agrp;\n \n   if (!analyze_ref (loop, &ref, &base, &step, &delta, stmt))\n-    return;\n+    return false;\n \n   /* Now we know that REF = &BASE + STEP * iter + DELTA, where DELTA and STEP\n      are integer constants.  */\n   agrp = find_or_create_group (refs, base, step);\n   record_ref (agrp, stmt, ref, delta, write_p);\n+\n+  return true;\n }\n \n-/* Record the suitable memory references in LOOP.  */\n+/* Record the suitable memory references in LOOP.  NO_OTHER_REFS is set to\n+   true if there are no other memory references inside the loop.  */\n \n static struct mem_ref_group *\n-gather_memory_references (struct loop *loop)\n+gather_memory_references (struct loop *loop, bool *no_other_refs)\n {\n   basic_block *body = get_loop_body_in_dom_order (loop);\n   basic_block bb;\n   unsigned i;\n   block_stmt_iterator bsi;\n-  tree stmt, lhs, rhs;\n+  tree stmt, lhs, rhs, call;\n   struct mem_ref_group *refs = NULL;\n \n+  *no_other_refs = true;\n+\n   /* Scan the loop body in order, so that the former references precede the\n      later ones.  */\n   for (i = 0; i < loop->num_nodes; i++)\n@@ -476,16 +496,26 @@ gather_memory_references (struct loop *loop)\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t{\n \t  stmt = bsi_stmt (bsi);\n+\t  call = get_call_expr_in (stmt);\n+\t  if (call && !(call_expr_flags (call) & ECF_CONST))\n+\t    *no_other_refs = false;\n+\n \t  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n-\t    continue;\n+\t    {\n+\t      if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+\t\t*no_other_refs = false;\n+\t      continue;\n+\t    }\n \n \t  lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n \t  rhs = GIMPLE_STMT_OPERAND (stmt, 1);\n \n \t  if (REFERENCE_CLASS_P (rhs))\n-\t    gather_memory_references_ref (loop, &refs, rhs, false, stmt);\n+\t    *no_other_refs &= gather_memory_references_ref (loop, &refs,\n+\t\t\t\t\t\t\t    rhs, false, stmt);\n \t  if (REFERENCE_CLASS_P (lhs))\n-\t    gather_memory_references_ref (loop, &refs, lhs, true, stmt);\n+\t    *no_other_refs &= gather_memory_references_ref (loop, &refs,\n+\t\t\t\t\t\t\t    lhs, true, stmt);\n \t}\n     }\n   free (body);\n@@ -746,6 +776,10 @@ should_issue_prefetch_p (struct mem_ref *ref)\n   if (ref->prefetch_before != PREFETCH_ALL)\n     return false;\n \n+  /* Do not prefetch nontemporal stores.  */\n+  if (ref->storent_p)\n+    return false;\n+\n   return true;\n }\n \n@@ -884,6 +918,130 @@ issue_prefetches (struct mem_ref_group *groups,\n \tissue_prefetch_ref (ref, unroll_factor, ahead);\n }\n \n+/* Returns true if REF is a memory write for that a nontemporal store insn\n+   can be used.  */\n+\n+static bool\n+nontemporal_store_p (struct mem_ref *ref)\n+{\n+  enum machine_mode mode;\n+  enum insn_code code;\n+\n+  /* REF must be a write that is not reused.  We require it to be independent\n+     on all other memory references in the loop, as the nontemporal stores may\n+     be reordered with respect to other memory references.  */\n+  if (!ref->write_p\n+      || !ref->independent_p\n+      || ref->reuse_distance < L2_CACHE_SIZE_BYTES)\n+    return false;\n+\n+  /* Check that we have the storent instruction for the mode.  */\n+  mode = TYPE_MODE (TREE_TYPE (ref->mem));\n+  if (mode == BLKmode)\n+    return false;\n+\n+  code = storent_optab->handlers[mode].insn_code;\n+  return code != CODE_FOR_nothing;\n+}\n+\n+/* If REF is a nontemporal store, we mark the corresponding modify statement\n+   and return true.  Otherwise, we return false.  */\n+\n+static bool\n+mark_nontemporal_store (struct mem_ref *ref)\n+{\n+  if (!nontemporal_store_p (ref))\n+    return false;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Marked reference %p as a nontemporal store.\\n\",\n+\t     (void *) ref);\n+\n+  MOVE_NONTEMPORAL (ref->stmt) = true;\n+  ref->storent_p = true;\n+\n+  return true;\n+}\n+\n+/* Issue a memory fence instruction after LOOP.  */\n+\n+static void\n+emit_mfence_after_loop (struct loop *loop)\n+{\n+  VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+  edge exit;\n+  tree call;\n+  block_stmt_iterator bsi;\n+  unsigned i;\n+\n+  for (i = 0; VEC_iterate (edge, exits, i, exit); i++)\n+    {\n+      call = build_function_call_expr (FENCE_FOLLOWING_MOVNT, NULL_TREE);\n+\n+      if (!single_pred_p (exit->dest)\n+\t  /* If possible, we prefer not to insert the fence on other paths\n+\t     in cfg.  */\n+\t  && !(exit->flags & EDGE_ABNORMAL))\n+\tsplit_loop_exit_edge (exit);\n+      bsi = bsi_after_labels (exit->dest);\n+\n+      bsi_insert_before (&bsi, call, BSI_NEW_STMT);\n+      mark_virtual_ops_for_renaming (call);\n+    }\n+\n+  VEC_free (edge, heap, exits);\n+  update_ssa (TODO_update_ssa_only_virtuals);\n+}\n+\n+/* Returns true if we can use storent in loop, false otherwise.  */\n+\n+static bool\n+may_use_storent_in_loop_p (struct loop *loop)\n+{\n+  bool ret = true;\n+\n+  if (loop->inner != NULL)\n+    return false;\n+\n+  /* If we must issue a mfence insn after using storent, check that there\n+     is a suitable place for it at each of the loop exits.  */\n+  if (FENCE_FOLLOWING_MOVNT != NULL_TREE)\n+    {\n+      VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n+      unsigned i;\n+      edge exit;\n+\n+      for (i = 0; VEC_iterate (edge, exits, i, exit); i++)\n+\tif ((exit->flags & EDGE_ABNORMAL)\n+\t    && exit->dest == EXIT_BLOCK_PTR)\n+\t  ret = false;\n+\n+      VEC_free (edge, heap, exits);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Marks nontemporal stores in LOOP.  GROUPS contains the description of memory\n+   references in the loop.  */\n+\n+static void\n+mark_nontemporal_stores (struct loop *loop, struct mem_ref_group *groups)\n+{\n+  struct mem_ref *ref;\n+  bool any = false;\n+\n+  if (!may_use_storent_in_loop_p (loop))\n+    return;\n+\n+  for (; groups; groups = groups->next)\n+    for (ref = groups->refs; ref; ref = ref->next)\n+      any |= mark_nontemporal_store (ref);\n+\n+  if (any && FENCE_FOLLOWING_MOVNT != NULL_TREE)\n+    emit_mfence_after_loop (loop);\n+}\n+\n /* Determines whether we can profitably unroll LOOP FACTOR times, and if\n    this is the case, fill in DESC by the description of number of\n    iterations.  */\n@@ -1115,16 +1273,18 @@ self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n }\n \n /* Determines the distance till the first reuse of each reference in REFS\n-   in the loop nest of LOOP.  */\n+   in the loop nest of LOOP.  NO_OTHER_REFS is true if there are no other\n+   memory references in the loop.  */\n \n static void\n-determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n+determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n+\t\t\t   bool no_other_refs)\n {\n   struct loop *nest, *aloop;\n   VEC (data_reference_p, heap) *datarefs = NULL;\n   VEC (ddr_p, heap) *dependences = NULL;\n   struct mem_ref_group *gr;\n-  struct mem_ref *ref;\n+  struct mem_ref *ref, *refb;\n   VEC (loop_p, heap) *vloops = NULL;\n   unsigned *loop_data_size;\n   unsigned i, j, n;\n@@ -1188,6 +1348,8 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n \t    dr->aux = ref;\n \t    VEC_safe_push (data_reference_p, heap, datarefs, dr);\n \t  }\n+\telse\n+\t  no_other_refs = false;\n       }\n \n   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n@@ -1196,6 +1358,9 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n       ref = dr->aux;\n       if (ref->reuse_distance > dist)\n \tref->reuse_distance = dist;\n+\n+      if (no_other_refs)\n+\tref->independent_p = true;\n     }\n \n   compute_all_dependences (datarefs, &dependences, vloops, true);\n@@ -1205,12 +1370,18 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n       if (DDR_ARE_DEPENDENT (dep) == chrec_known)\n \tcontinue;\n \n+      ref = DDR_A (dep)->aux;\n+      refb = DDR_B (dep)->aux;\n+\n       if (DDR_ARE_DEPENDENT (dep) == chrec_dont_know\n \t  || DDR_NUM_DIST_VECTS (dep) == 0)\n \t{\n \t  /* If the dependence cannot be analysed, assume that there might be\n \t     a reuse.  */\n \t  dist = 0;\n+      \n+\t  ref->independent_p = false;\n+\t  refb->independent_p = false;\n \t}\n       else\n \t{\n@@ -1228,6 +1399,18 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n \t      adist = volume_of_dist_vector (DDR_DIST_VECT (dep, j),\n \t\t\t\t\t     loop_data_size, n);\n \n+\t      /* If this is a dependence in the innermost loop (i.e., the\n+\t\t distances in all superloops are zero) and it is not\n+\t\t the trivial self-dependence with distance zero, record that\n+\t\t the references are not completely independent.  */\n+\t      if (lambda_vector_zerop (DDR_DIST_VECT (dep, j), n - 1)\n+\t\t  && (ref != refb\n+\t\t      || DDR_DIST_VECT (dep, j)[n-1] != 0))\n+\t\t{\n+\t\t  ref->independent_p = false;\n+\t\t  refb->independent_p = false;\n+\t\t}\n+\n \t      /* Ignore accesses closer than\n \t\t L1_CACHE_SIZE_BYTES / NONTEMPORAL_FRACTION,\n \t      \t so that we use nontemporal prefetches e.g. if single memory\n@@ -1241,12 +1424,10 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs)\n \t    }\n \t}\n \n-      ref = DDR_A (dep)->aux;\n-      if (ref->reuse_distance > dist)\n-\tref->reuse_distance = dist;\n-      ref = DDR_B (dep)->aux;\n       if (ref->reuse_distance > dist)\n \tref->reuse_distance = dist;\n+      if (refb->reuse_distance > dist)\n+\trefb->reuse_distance = dist;\n     }\n \n   free_dependence_relations (dependences);\n@@ -1273,7 +1454,7 @@ loop_prefetch_arrays (struct loop *loop)\n   unsigned ahead, ninsns, time, unroll_factor;\n   HOST_WIDE_INT est_niter;\n   struct tree_niter_desc desc;\n-  bool unrolled = false;\n+  bool unrolled = false, no_other_refs;\n \n   if (!maybe_hot_bb_p (loop->header))\n     {\n@@ -1283,15 +1464,15 @@ loop_prefetch_arrays (struct loop *loop)\n     }\n \n   /* Step 1: gather the memory references.  */\n-  refs = gather_memory_references (loop);\n+  refs = gather_memory_references (loop, &no_other_refs);\n \n   /* Step 2: estimate the reuse effects.  */\n   prune_by_reuse (refs);\n \n   if (!anything_to_prefetch_p (refs))\n     goto fail;\n \n-  determine_loop_nest_reuse (loop, refs);\n+  determine_loop_nest_reuse (loop, refs, no_other_refs);\n \n   /* Step 3: determine the ahead and unroll factor.  */\n \n@@ -1313,6 +1494,8 @@ loop_prefetch_arrays (struct loop *loop)\n       goto fail;\n     }\n \n+  mark_nontemporal_stores (loop, refs);\n+\n   ninsns = tree_num_loop_insns (loop, &eni_size_weights);\n   unroll_factor = determine_unroll_factor (loop, refs, ninsns, &desc,\n \t\t\t\t\t   est_niter);"}, {"sha": "bd6232d42ef25abce0b3af13af540accacbbe254", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79f5e442625680fbd5c12517419e990609bb2810/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=79f5e442625680fbd5c12517419e990609bb2810", "patch": "@@ -447,6 +447,8 @@ struct gimple_stmt GTY(())\n        EH_FILTER_MUST_NOT_THROW in EH_FILTER_EXPR\n        TYPE_REF_CAN_ALIAS_ALL in\n            POINTER_TYPE, REFERENCE_TYPE\n+       MOVE_NONTEMPORAL in\n+\t   GIMPLE_MODIFY_STMT\n        CASE_HIGH_SEEN in CASE_LABEL_EXPR\n \n    public_flag:\n@@ -1159,6 +1161,10 @@ extern void omp_clause_range_check_failed (const tree, const char *, int,\n #define TYPE_REF_CAN_ALIAS_ALL(NODE) \\\n   (PTR_OR_REF_CHECK (NODE)->base.static_flag)\n \n+/* In a MODIFY_EXPR, means that the store in the expression is nontemporal.  */\n+#define MOVE_NONTEMPORAL(NODE) \\\n+  (GIMPLE_MODIFY_STMT_CHECK (NODE)->base.static_flag)\n+\n /* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n    there was an overflow in folding.  */\n "}]}