{"sha": "ee93527368e112d1f2a9b0e739fc513eff3e048e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MzUyNzM2OGUxMTJkMWYyYTliMGU3MzlmYzUxM2VmZjNlMDQ4ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T13:01:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-05-22T13:01:37Z"}, "message": "[multiple changes]\n\n2015-05-22  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads: Minor comment updates.\n\t* exp_unst.adb: Move Subps table to spec Don't remove old entries\n\tfrom table Add Last field to record last entry used.\n\t* exp_unst.ads: Move Subps table here from body So that Cprint\n\tcan access saved values.\n\n2015-05-22  Bob Duff  <duff@adacore.com>\n\n\t* a-cdlili.adb, a-cdlili.ads, a-cohama.adb, a-cohama.ads,\n\t* a-cohase.adb, a-cohase.ads, a-convec.adb, a-convec.ads,\n\t* a-coorma.adb, a-coorma.ads, a-coorse.adb, a-coorse.ads:\n\t(Pseudo_Reference, Element_Access, Get_Element_Access): New\n\tdeclarations added for use by performance improvements in exp_ch5.adb.\n\t* snames.ads-tmpl: New names referenced by exp_ch5.adb.\n\t* exp_ch5.adb: Speed up \"for ... of\" loops for predefined containers.\n\tInstead of doing literally what the RM calls for, we do something\n\tequivalent that avoids expensive operations inside the loop. If the\n\tcontainer package has appropriate Next, Pseudo_Reference,\n\tElement_Access, Get_Element_Access declarations, we invoke the\n\toptimization.\n\t* snames.ads-tmpl: Note speed improvement.\n\nFrom-SVN: r223563", "tree": {"sha": "8b36160fdde6190f5222ddb6061d762b8c0ecc3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b36160fdde6190f5222ddb6061d762b8c0ecc3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee93527368e112d1f2a9b0e739fc513eff3e048e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee93527368e112d1f2a9b0e739fc513eff3e048e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee93527368e112d1f2a9b0e739fc513eff3e048e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee93527368e112d1f2a9b0e739fc513eff3e048e/comments", "author": null, "committer": null, "parents": [{"sha": "5c0c1090a714cb4b89f11d5333efd61dea5267f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c0c1090a714cb4b89f11d5333efd61dea5267f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c0c1090a714cb4b89f11d5333efd61dea5267f2"}], "stats": {"total": 1716, "additions": 1136, "deletions": 580}, "files": [{"sha": "863e3d9d26e029761e98f46387397dfe713f98a2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -1,3 +1,27 @@\n+2015-05-22  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads: Minor comment updates.\n+\t* exp_unst.adb: Move Subps table to spec Don't remove old entries\n+\tfrom table Add Last field to record last entry used.\n+\t* exp_unst.ads: Move Subps table here from body So that Cprint\n+\tcan access saved values.\n+\n+2015-05-22  Bob Duff  <duff@adacore.com>\n+\n+\t* a-cdlili.adb, a-cdlili.ads, a-cohama.adb, a-cohama.ads,\n+\t* a-cohase.adb, a-cohase.ads, a-convec.adb, a-convec.ads,\n+\t* a-coorma.adb, a-coorma.ads, a-coorse.adb, a-coorse.ads:\n+\t(Pseudo_Reference, Element_Access, Get_Element_Access): New\n+\tdeclarations added for use by performance improvements in exp_ch5.adb.\n+\t* snames.ads-tmpl: New names referenced by exp_ch5.adb.\n+\t* exp_ch5.adb: Speed up \"for ... of\" loops for predefined containers.\n+\tInstead of doing literally what the RM calls for, we do something\n+\tequivalent that avoids expensive operations inside the loop. If the\n+\tcontainer package has appropriate Next, Pseudo_Reference,\n+\tElement_Access, Get_Element_Access declarations, we invoke the\n+\toptimization.\n+\t* snames.ads-tmpl: Note speed improvement.\n+\n 2015-05-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* einfo.ads (Is_Atomic_Or_VFA): Move to XEINFO INLINES section."}, {"sha": "e003cfc7c3d9a80d24c5cddf0b7d9bdd79b3bcf7", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -923,6 +923,16 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n    end Generic_Sorting;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1384,6 +1394,25 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       end if;\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased List'Class) return Reference_Control_Type\n+   is\n+      C : constant List_Access := Container'Unrestricted_Access;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+   begin\n+      return R : constant Reference_Control_Type :=\n+        (Controlled with C)\n+      do\n+         B := B + 1;\n+         L := L + 1;\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "35aaf9f60990aad8ea914eb5cfa30d088d984c4b", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -362,6 +362,24 @@ private\n \n    for Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased List'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_List : constant List := (Controlled with null, null, 0, 0, 0);\n \n    No_Element : constant Cursor := Cursor'(null, null);"}, {"sha": "6fe9bfd576b3fa42b3f5277fbff8c363ad85c5cd", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -555,6 +555,16 @@ package body Ada.Containers.Hashed_Maps is\n       end if;\n    end Free;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -858,6 +868,25 @@ package body Ada.Containers.Hashed_Maps is\n       return Next (Position);\n    end Next;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type\n+   is\n+      C : constant Map_Access := Container'Unrestricted_Access;\n+      B : Natural renames C.HT.Busy;\n+      L : Natural renames C.HT.Lock;\n+   begin\n+      return R : constant Reference_Control_Type :=\n+        (Controlled with C)\n+      do\n+         B := B + 1;\n+         L := L + 1;\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "12c352962de90396631c6178373c965c8c79ba05", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -300,7 +300,7 @@ package Ada.Containers.Hashed_Maps is\n    --  Calls Process for each node in the map\n \n    function Iterate\n-     (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'class;\n+     (Container : Map) return Map_Iterator_Interfaces.Forward_Iterator'Class;\n \n private\n    pragma Inline (\"=\");\n@@ -428,6 +428,24 @@ private\n \n    for Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Map : constant Map := (Controlled with HT => (null, 0, 0, 0));\n \n    No_Element : constant Cursor := (Container => null, Node => null);"}, {"sha": "1ce5c4a50b968560edcf6c3ac255e1d6f8b52f55", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -722,6 +722,16 @@ package body Ada.Containers.Hashed_Sets is\n       end if;\n    end Free;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1154,6 +1164,25 @@ package body Ada.Containers.Hashed_Sets is\n       return False;\n    end Overlap;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type\n+   is\n+      C : constant Set_Access := Container'Unrestricted_Access;\n+      B : Natural renames C.HT.Busy;\n+      L : Natural renames C.HT.Lock;\n+   begin\n+      return R : constant Reference_Control_Type :=\n+        (Controlled with C)\n+      do\n+         B := B + 1;\n+         L := L + 1;\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "7e5671edfb4e26c5873863707a6297d497ac5233", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -573,6 +573,24 @@ private\n \n    for Constant_Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Set : constant Set := (Controlled with HT => (null, 0, 0, 0));\n \n    No_Element : constant Cursor := (Container => null, Node => null);"}, {"sha": "5eb82fe739d8f4be6d3726fa237252c162c4a6bf", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1269,6 +1269,16 @@ package body Ada.Containers.Vectors is\n \n    end Generic_Sorting;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Container.Elements.EA (Position.Index)'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -2673,6 +2683,25 @@ package body Ada.Containers.Vectors is\n       end if;\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Vector'Class) return Reference_Control_Type\n+   is\n+      C : constant Vector_Access := Container'Unrestricted_Access;\n+      B : Natural renames C.Busy;\n+      L : Natural renames C.Lock;\n+   begin\n+      return R : constant Reference_Control_Type :=\n+        (Controlled with C)\n+      do\n+         B := B + 1;\n+         L := L + 1;\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "cb1bce17507ef31c99943b934938fae1055f751a", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -475,6 +475,24 @@ private\n \n    for Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Vector'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    No_Element   : constant Cursor := Cursor'(null, Index_Type'First);\n \n    Empty_Vector : constant Vector := (Controlled with null, No_Index, 0, 0);"}, {"sha": "c217a4f6d68783f2db96e296fd62dbb022f05b73", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -677,6 +677,16 @@ package body Ada.Containers.Ordered_Maps is\n       Deallocate (X);\n    end Free;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1198,6 +1208,25 @@ package body Ada.Containers.Ordered_Maps is\n       return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type\n+   is\n+      C : constant Map_Access := Container'Unrestricted_Access;\n+      B : Natural renames C.Tree.Busy;\n+      L : Natural renames C.Tree.Lock;\n+   begin\n+      return R : constant Reference_Control_Type :=\n+        (Controlled with C)\n+      do\n+         B := B + 1;\n+         L := L + 1;\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "56a98fbc0e4b6cf3226c2ddc12408b8dfa917c78", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -352,6 +352,24 @@ private\n \n    for Reference_Type'Write use Write;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions.  See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Map'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Map : constant Map :=\n                  (Controlled with Tree => (First  => null,\n                                            Last   => null,"}, {"sha": "fde98bf5f2df2b8bcfd3ffb0cbbf96302b1aaab8", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1087,6 +1087,16 @@ package body Ada.Containers.Ordered_Sets is\n \n    end Generic_Keys;\n \n+   ------------------------\n+   -- Get_Element_Access --\n+   ------------------------\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access is\n+   begin\n+      return Position.Node.Element'Access;\n+   end Get_Element_Access;\n+\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -1616,6 +1626,25 @@ package body Ada.Containers.Ordered_Sets is\n       return Previous (Position);\n    end Previous;\n \n+   ----------------------\n+   -- Pseudo_Reference --\n+   ----------------------\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type\n+   is\n+      C : constant Set_Access := Container'Unrestricted_Access;\n+      B : Natural renames C.Tree.Busy;\n+      L : Natural renames C.Tree.Lock;\n+   begin\n+      return R : constant Reference_Control_Type :=\n+        (Controlled with C)\n+      do\n+         B := B + 1;\n+         L := L + 1;\n+      end return;\n+   end Pseudo_Reference;\n+\n    -------------------\n    -- Query_Element --\n    -------------------"}, {"sha": "f574f3c92ca2d8cba95c2a1350ad236e35076656", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -413,6 +413,24 @@ private\n \n    for Constant_Reference_Type'Read use Read;\n \n+   --  Three operations are used to optimize in the expansion of \"for ... of\"\n+   --  loops: the Next(Cursor) procedure in the visible part, and the following\n+   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  details.\n+\n+   function Pseudo_Reference\n+     (Container : aliased Set'Class) return Reference_Control_Type;\n+   pragma Inline (Pseudo_Reference);\n+   --  Creates an object of type Reference_Control_Type pointing to the\n+   --  container, and increments the Lock. Finalization of this object will\n+   --  decrement the Lock.\n+\n+   type Element_Access is access all Element_Type;\n+\n+   function Get_Element_Access\n+     (Position : Cursor) return not null Element_Access;\n+   --  Returns a pointer to the element designated by Position.\n+\n    Empty_Set : constant Set :=\n                  (Controlled with Tree => (First  => null,\n                                            Last   => null,"}, {"sha": "5d876551f1e2a2b580fb749cb9b89ded50c310c6", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -4201,8 +4201,11 @@ package Einfo is\n --       names to access entries in this list.\n \n --    Subps_Index (Uint24)\n---       Used during Exp_Inst.Unnest_Subprogram to hold the index in the Subps\n---       table for a subprogram. See processing in this procedure for details.\n+--       Present in subprogram entries. Set if the subprogram contains nested\n+--       subprograms, or is a subprogram nested within such a subprogram. Holds\n+--       the index in the Exp_Unst.Subps table for the subprogram. Note that\n+--       for the outer level subprogram, this is the starting index in the Subp\n+--       table for the entries for this subprogram.\n \n --    Suppress_Elaboration_Warnings (Flag148)\n --       Defined in all entities, can be set only for subprogram entities and"}, {"sha": "a27fc2cae3d008bfd5aadc5fbb149847fa752f4b", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 553, "deletions": 402, "changes": 955, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -132,6 +132,17 @@ package body Exp_Ch5 is\n    procedure Expand_Iterator_Loop_Over_Array (N : Node_Id);\n    --  Expand loop over arrays that uses the form \"for X of C\"\n \n+   procedure Expand_Iterator_Loop_Over_Container\n+     (N             : Node_Id;\n+      Isc           : Node_Id;\n+      I_Spec        : Node_Id;\n+      Container     : Node_Id;\n+      Container_Typ : Entity_Id);\n+   --  Expand loop over containers that uses the form \"for X of C\" with an\n+   --  optional subtype mark, or \"for Y in C\". Isc is the iteration scheme.\n+   --  I_Spec is the iterator specification and Container is either the\n+   --  Container (for OF) or the iterator (for IN).\n+\n    procedure Expand_Predicated_Loop (N : Node_Id);\n    --  Expand for loop over predicated subtype\n \n@@ -3231,23 +3242,16 @@ package body Exp_Ch5 is\n    procedure Expand_Iterator_Loop (N : Node_Id) is\n       Isc    : constant Node_Id    := Iteration_Scheme (N);\n       I_Spec : constant Node_Id    := Iterator_Specification (Isc);\n-      Id     : constant Entity_Id  := Defining_Identifier (I_Spec);\n-      Loc    : constant Source_Ptr := Sloc (N);\n \n       Container     : constant Node_Id     := Name (I_Spec);\n       Container_Typ : constant Entity_Id   := Base_Type (Etype (Container));\n-      I_Kind        : constant Entity_Kind := Ekind (Id);\n-      Cursor        : Entity_Id;\n-      Iterator      : Entity_Id;\n-      New_Loop      : Node_Id;\n-      Stats         : List_Id := Statements (N);\n \n    begin\n       --  Processing for arrays\n \n       if Is_Array_Type (Container_Typ) then\n+         pragma Assert (Of_Present (I_Spec));\n          Expand_Iterator_Loop_Over_Array (N);\n-         return;\n \n       elsif Has_Aspect (Container_Typ, Aspect_Iterable) then\n          if Of_Present (I_Spec) then\n@@ -3256,402 +3260,12 @@ package body Exp_Ch5 is\n             Expand_Formal_Container_Loop (N);\n          end if;\n \n-         return;\n-      end if;\n-\n       --  Processing for containers\n \n-      --  For an \"of\" iterator the name is a container expression, which\n-      --  is transformed into a call to the default iterator.\n-\n-      --  For an iterator of the form \"in\" the name is a function call\n-      --  that delivers an iterator type.\n-\n-      --  In both cases, analysis of the iterator has introduced an object\n-      --  declaration to capture the domain, so that Container is an entity.\n-\n-      --  The for loop is expanded into a while loop which uses a container\n-      --  specific cursor to desgnate each element.\n-\n-      --    Iter : Iterator_Type := Container.Iterate;\n-      --    Cursor : Cursor_type := First (Iter);\n-      --    while Has_Element (Iter) loop\n-      --       declare\n-      --       --  The block is added when Element_Type is controlled\n-\n-      --          Obj : Pack.Element_Type := Element (Cursor);\n-      --          --  for the \"of\" loop form\n-      --       begin\n-      --          <original loop statements>\n-      --       end;\n-\n-      --       Cursor := Iter.Next (Cursor);\n-      --    end loop;\n-\n-      --  If \"reverse\" is present, then the initialization of the cursor\n-      --  uses Last and the step becomes Prev. Pack is the name of the\n-      --  scope where the container package is instantiated.\n-\n-      declare\n-         Element_Type : constant Entity_Id := Etype (Id);\n-         Iter_Type    : Entity_Id;\n-         Pack         : Entity_Id;\n-         Decl         : Node_Id;\n-         Name_Init    : Name_Id;\n-         Name_Step    : Name_Id;\n-\n-      begin\n-         --  The type of the iterator is the return type of the Iterate\n-         --  function used. For the \"of\" form this is the default iterator\n-         --  for the type, otherwise it is the type of the explicit\n-         --  function used in the iterator specification. The most common\n-         --  case will be an Iterate function in the container package.\n-\n-         --  The primitive operations of the container type may not be\n-         --  use-visible, so we introduce the name of the enclosing package\n-         --  in the declarations below. The Iterator type is declared in a\n-         --  an instance within the container package itself.\n-\n-         --  If the container type is a derived type, the cursor type is\n-         --  found in the package of the parent type.\n-\n-         if Is_Derived_Type (Container_Typ) then\n-            Pack := Scope (Root_Type (Container_Typ));\n-         else\n-            Pack := Scope (Container_Typ);\n-         end if;\n-\n-         Iter_Type := Etype (Name (I_Spec));\n-\n-         --  The \"of\" case uses an internally generated cursor whose type\n-         --  is found in the container package. The domain of iteration\n-         --  is expanded into a call to the default Iterator function, but\n-         --  this expansion does not take place in quantified expressions\n-         --  that are analyzed with expansion disabled, and in that case the\n-         --  type of the iterator must be obtained from the aspect.\n-\n-         if Of_Present (I_Spec) then\n-            Handle_Of : declare\n-               Default_Iter  : Entity_Id;\n-               Container_Arg : Node_Id;\n-               Ent           : Entity_Id;\n-\n-               function Get_Default_Iterator\n-                 (T : Entity_Id) return Entity_Id;\n-               --  If the container is a derived type, the aspect holds the\n-               --  parent operation. The required one is a primitive of the\n-               --  derived type and is either inherited or overridden.\n-\n-               --------------------------\n-               -- Get_Default_Iterator --\n-               --------------------------\n-\n-               function Get_Default_Iterator\n-                 (T : Entity_Id) return Entity_Id\n-               is\n-                  Iter : constant Entity_Id :=\n-                    Entity (Find_Value_Of_Aspect (T, Aspect_Default_Iterator));\n-                  Prim : Elmt_Id;\n-                  Op   : Entity_Id;\n-\n-               begin\n-                  Container_Arg := New_Copy_Tree (Container);\n-\n-                  --  A previous version of GNAT allowed indexing aspects to\n-                  --  be redefined on derived container types, while the\n-                  --  default iterator was inherited from the aprent type.\n-                  --  This non-standard extension is preserved temporarily for\n-                  --  use by the modelling project under debug flag d.X.\n-\n-                  if Debug_Flag_Dot_XX then\n-                     if Base_Type (Etype (Container)) /=\n-                        Base_Type (Etype (First_Formal (Iter)))\n-                     then\n-                        Container_Arg :=\n-                          Make_Type_Conversion (Loc,\n-                            Subtype_Mark =>\n-                              New_Occurrence_Of\n-                                (Etype (First_Formal (Iter)), Loc),\n-                            Expression   => Container_Arg);\n-                     end if;\n-\n-                     return Iter;\n-\n-                  elsif Is_Derived_Type (T) then\n-\n-                     --  The default iterator must be a primitive operation\n-                     --  of the type, at the same dispatch slot position.\n-\n-                     Prim := First_Elmt (Primitive_Operations (T));\n-                     while Present (Prim) loop\n-                        Op := Node (Prim);\n-\n-                        if Chars (Op) = Chars (Iter)\n-                          and then DT_Position (Op) = DT_Position (Iter)\n-                        then\n-                           return Op;\n-                        end if;\n-\n-                        Next_Elmt (Prim);\n-                     end loop;\n-\n-                     --  Default iterator must exist\n-\n-                     pragma Assert (False);\n-\n-                  else              --  not a derived type\n-                     return Iter;\n-                  end if;\n-               end Get_Default_Iterator;\n-\n-            --  Start of processing for Handle_Of\n-\n-            begin\n-               if Is_Class_Wide_Type (Container_Typ) then\n-                  Default_Iter :=\n-                    Get_Default_Iterator (Etype (Base_Type (Container_Typ)));\n-\n-               else\n-                  Default_Iter := Get_Default_Iterator (Etype (Container));\n-               end if;\n-\n-               Cursor := Make_Temporary (Loc, 'C');\n-\n-               --  For an container element iterator, the iterator type\n-               --  is obtained from the corresponding aspect, whose return\n-               --  type is descended from the corresponding interface type\n-               --  in some instance of Ada.Iterator_Interfaces. The actuals\n-               --  of that instantiation are Cursor and Has_Element.\n-\n-               Iter_Type := Etype (Default_Iter);\n-\n-               --  The iterator type, which is a class_wide type,  may itself\n-               --  be derived locally, so the desired instantiation is the\n-               --  scope of the root type of the iterator type.\n-\n-               Pack := Scope (Root_Type (Etype (Iter_Type)));\n-\n-               --  Rewrite domain of iteration as a call to the default\n-               --  iterator for the container type.\n-\n-               Rewrite (Name (I_Spec),\n-                 Make_Function_Call (Loc,\n-                   Name => New_Occurrence_Of (Default_Iter, Loc),\n-                   Parameter_Associations =>\n-                     New_List (Container_Arg)));\n-               Analyze_And_Resolve (Name (I_Spec));\n-\n-               --  Find cursor type in proper iterator package, which is an\n-               --  instantiation of Iterator_Interfaces.\n-\n-               Ent := First_Entity (Pack);\n-               while Present (Ent) loop\n-                  if Chars (Ent) = Name_Cursor then\n-                     Set_Etype (Cursor, Etype (Ent));\n-                     exit;\n-                  end if;\n-                  Next_Entity (Ent);\n-               end loop;\n-\n-               --  Generate:\n-               --    Id : Element_Type renames Container (Cursor);\n-               --  This assumes that the container type has an indexing\n-               --  operation with Cursor. The check that this operation\n-               --  exists is performed in Check_Container_Indexing.\n-\n-               Decl :=\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Id,\n-                   Subtype_Mark        =>\n-                     New_Occurrence_Of (Element_Type, Loc),\n-                   Name                =>\n-                     Make_Indexed_Component (Loc,\n-                       Prefix      => Relocate_Node (Container_Arg),\n-                       Expressions =>\n-                         New_List (New_Occurrence_Of (Cursor, Loc))));\n-\n-               --  The defining identifier in the iterator is user-visible\n-               --  and must be visible in the debugger.\n-\n-               Set_Debug_Info_Needed (Id);\n-\n-               --  If the container does not have a variable indexing aspect,\n-               --  the element is a constant in the loop.\n-\n-               if No (Find_Value_Of_Aspect\n-                        (Container_Typ, Aspect_Variable_Indexing))\n-               then\n-                  Set_Ekind (Id, E_Constant);\n-               end if;\n-\n-               --  If the container holds controlled objects, wrap the loop\n-               --  statements and element renaming declaration with a block.\n-               --  This ensures that the result of Element (Cusor) is\n-               --  cleaned up after each iteration of the loop.\n-\n-               if Needs_Finalization (Element_Type) then\n-\n-                  --  Generate:\n-                  --    declare\n-                  --       Id : Element_Type := Element (curosr);\n-                  --    begin\n-                  --       <original loop statements>\n-                  --    end;\n-\n-                  Stats := New_List (\n-                    Make_Block_Statement (Loc,\n-                      Declarations               => New_List (Decl),\n-                      Handled_Statement_Sequence =>\n-                        Make_Handled_Sequence_Of_Statements (Loc,\n-                           Statements => Stats)));\n-\n-               --  Elements do not need finalization\n-\n-               else\n-                  Prepend_To (Stats, Decl);\n-               end if;\n-            end Handle_Of;\n-\n-         --  X in Iterate (S) : type of iterator is type of explicitly\n-         --  given Iterate function, and the loop variable is the cursor.\n-         --  It will be assigned in the loop and must be a variable.\n-\n-         else\n-            Cursor := Id;\n-         end if;\n-\n-         Iterator := Make_Temporary (Loc, 'I');\n-\n-         --  Determine the advancement and initialization steps for the\n-         --  cursor.\n-\n-         --  Analysis of the expanded loop will verify that the container\n-         --  has a reverse iterator.\n-\n-         if Reverse_Present (I_Spec) then\n-            Name_Init := Name_Last;\n-            Name_Step := Name_Previous;\n-\n-         else\n-            Name_Init := Name_First;\n-            Name_Step := Name_Next;\n-         end if;\n-\n-         --  For both iterator forms, add a call to the step operation to\n-         --  advance the cursor. Generate:\n-\n-         --     Cursor := Iterator.Next (Cursor);\n-\n-         --   or else\n-\n-         --     Cursor := Next (Cursor);\n-\n-         declare\n-            Rhs : Node_Id;\n-\n-         begin\n-            Rhs :=\n-              Make_Function_Call (Loc,\n-                Name                   =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix        => New_Occurrence_Of (Iterator, Loc),\n-                    Selector_Name => Make_Identifier (Loc, Name_Step)),\n-                Parameter_Associations => New_List (\n-                   New_Occurrence_Of (Cursor, Loc)));\n-\n-            Append_To (Stats,\n-              Make_Assignment_Statement (Loc,\n-                 Name       => New_Occurrence_Of (Cursor, Loc),\n-                 Expression => Rhs));\n-            Set_Assignment_OK (Name (Last (Stats)));\n-         end;\n-\n-         --  Generate:\n-         --    while Iterator.Has_Element loop\n-         --       <Stats>\n-         --    end loop;\n-\n-         --   Has_Element is the second actual in the iterator package\n-\n-         New_Loop :=\n-           Make_Loop_Statement (Loc,\n-             Iteration_Scheme =>\n-               Make_Iteration_Scheme (Loc,\n-                 Condition =>\n-                   Make_Function_Call (Loc,\n-                     Name                   =>\n-                       New_Occurrence_Of (\n-                        Next_Entity (First_Entity (Pack)), Loc),\n-                     Parameter_Associations =>\n-                       New_List (New_Occurrence_Of (Cursor, Loc)))),\n-\n-             Statements => Stats,\n-             End_Label  => Empty);\n-\n-         --  If present, preserve identifier of loop, which can be used in\n-         --  an exit statement in the body.\n-\n-         if Present (Identifier (N)) then\n-            Set_Identifier (New_Loop, Relocate_Node (Identifier (N)));\n-         end if;\n-\n-         --  Create the declarations for Iterator and cursor and insert them\n-         --  before the source loop. Given that the domain of iteration is\n-         --  already an entity, the iterator is just a renaming of that\n-         --  entity. Possible optimization ???\n-         --  Generate:\n-\n-         --    I : Iterator_Type renames Container;\n-         --    C : Cursor_Type := Container.[First | Last];\n-\n-         Insert_Action (N,\n-           Make_Object_Renaming_Declaration (Loc,\n-             Defining_Identifier => Iterator,\n-             Subtype_Mark  => New_Occurrence_Of (Iter_Type, Loc),\n-             Name          => Relocate_Node (Name (I_Spec))));\n-\n-         --  Create declaration for cursor\n-\n-         declare\n-            Decl : Node_Id;\n-\n-         begin\n-            Decl :=\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => Cursor,\n-                Object_Definition   =>\n-                  New_Occurrence_Of (Etype (Cursor), Loc),\n-                Expression          =>\n-                  Make_Selected_Component (Loc,\n-                    Prefix        => New_Occurrence_Of (Iterator, Loc),\n-                    Selector_Name =>\n-                      Make_Identifier (Loc, Name_Init)));\n-\n-            --  The cursor is only modified in expanded code, so it appears\n-            --  as unassigned to the warning machinery. We must suppress\n-            --  this spurious warning explicitly. The cursor's kind is that of\n-            --  the original loop parameter (it is a constant if the domain of\n-            --  iteration is constant).\n-\n-            Set_Warnings_Off (Cursor);\n-            Set_Assignment_OK (Decl);\n-\n-            Insert_Action (N, Decl);\n-            Set_Ekind (Cursor, I_Kind);\n-         end;\n-\n-         --  If the range of iteration is given by a function call that\n-         --  returns a container, the finalization actions have been saved\n-         --  in the Condition_Actions of the iterator. Insert them now at\n-         --  the head of the loop.\n-\n-         if Present (Condition_Actions (Isc)) then\n-            Insert_List_Before (N, Condition_Actions (Isc));\n-         end if;\n-      end;\n-\n-      Rewrite (N, New_Loop);\n-      Analyze (N);\n+      else\n+         Expand_Iterator_Loop_Over_Container\n+           (N, Isc, I_Spec, Container, Container_Typ);\n+      end if;\n    end Expand_Iterator_Loop;\n \n    -------------------------------------\n@@ -3813,6 +3427,543 @@ package body Exp_Ch5 is\n       Analyze (N);\n    end Expand_Iterator_Loop_Over_Array;\n \n+   -----------------------------------------\n+   -- Expand_Iterator_Loop_Over_Container --\n+   -----------------------------------------\n+\n+   --  For a 'for ... in' loop, such as:\n+\n+   --      for Cursor in Iterator_Function (...) loop\n+   --          ...\n+   --      end loop;\n+\n+   --  we generate:\n+\n+   --    Iter : Iterator_Type := Iterator_Function (...);\n+   --    Cursor : Cursor_type := First (Iter); -- or Last for \"reverse\"\n+   --    while Has_Element (Cursor) loop\n+   --       ...\n+   --\n+   --       Cursor := Iter.Next (Cursor); -- or Prev for \"reverse\"\n+   --    end loop;\n+\n+   --  For a 'for ... of' loop, such as:\n+\n+   --      for X of Container loop\n+   --          ...\n+   --      end loop;\n+\n+   --  the RM implies the generation of:\n+\n+   --    Iter : Iterator_Type := Container.Iterate; -- the Default_Iterator\n+   --    Cursor : Cursor_Type := First (Iter); -- or Last for \"reverse\"\n+   --    while Has_Element (Cursor) loop\n+   --       declare\n+   --          X : Element_Type renames Element (Cursor).Element.all;\n+   --          --  or Constant_Element\n+   --       begin\n+   --          ...\n+   --       end;\n+   --       Cursor := Iter.Next (Cursor); -- or Prev for \"reverse\"\n+   --    end loop;\n+\n+   --  In the general case, we do what the RM says. However, the operations\n+   --  Element and Iter.Next are slow, which is bad inside a loop, because they\n+   --  involve dispatching via interfaces, secondary stack manipulation,\n+   --  Busy/Lock incr/decr, and adjust/finalization/at-end handling. So for the\n+   --  predefined containers, we use an equivalent but optimized expansion.\n+\n+   --  In the optimized case, we make use of these:\n+\n+   --     procedure Next (Position : in out Cursor); -- instead of Iter.Next\n+\n+   --     function Pseudo_Reference\n+   --       (Container : aliased Vector'Class) return Reference_Control_Type;\n+\n+   --     type Element_Access is access all Element_Type;\n+\n+   --     function Get_Element_Access\n+   --       (Position : Cursor) return not null Element_Access;\n+\n+   --  Next is declared in the visible part of the container packages.\n+   --  The other three are added in the private part. (We're not supposed to\n+   --  pollute the namespace for clients. The compiler has no trouble breaking\n+   --  privacy to call things in the private part of an instance.)\n+\n+   --  Source:\n+\n+   --      for X of My_Vector loop\n+   --          X.Count := X.Count + 1;\n+   --          ...\n+   --      end loop;\n+\n+   --  The compiler will generate:\n+\n+   --      Iter : Reversible_Iterator'Class := Iterate (My_Vector);\n+   --      --  Reversible_Iterator is an interface. Iterate is the\n+   --      --  Default_Iterator aspect of Vector. This increments Lock,\n+   --      --  disallowing tampering with cursors. Unfortunately, it does not\n+   --      --  increment Busy. The result of Iterate is Limited_Controlled;\n+   --      --  finalization will decrement Lock.  This is a build-in-place\n+   --      --  dispatching call to Iterate.\n+\n+   --      Cur : Cursor := First (Iter); -- or Last\n+   --      --  Dispatching call via interface.\n+\n+   --      Control : Reference_Control_Type := Pseudo_Reference (My_Vector);\n+   --      --  Pseudo_Reference increments Busy, to detect tampering with\n+   --      --  elements, as required by RM. Also redundantly increment\n+   --      --  Lock. Finalization of Control will decrement both Busy and\n+   --      --  Lock. Pseudo_Reference returns a record containing a pointer to\n+   --      --  My_Vector, used by Finalize.\n+   --      --\n+   --      --  Control is not used below, except to finalize it -- it's purely\n+   --      --  an RAII thing. This is needed because we are eliminating the\n+   --      --  call to Reference within the loop.\n+\n+   --      while Has_Element (Cur) loop\n+   --          declare\n+   --              X : My_Element renames Get_Element_Access (Cur).all;\n+   --              --  Get_Element_Access returns a pointer to the element\n+   --              --  designated by Cur. No dispatching here, and no horsing\n+   --              --  around with access discriminants. This is instead of the\n+   --              --  existing\n+   --              --\n+   --              --    X : My_Element renames Reference (Cur).Element.all;\n+   --              --\n+   --              --  which creates a controlled object.\n+   --          begin\n+   --              --  Any attempt to tamper with My_Vector here in the loop\n+   --              --  will correctly raise Program_Error, because of the\n+   --              --  Control.\n+   --\n+   --              X.Count := X.Count + 1;\n+   --              ...\n+   --\n+   --              Next (Cur); -- or Prev\n+   --              --  This is instead of \"Cur := Next (Iter, Cur);\"\n+   --          end;\n+   --          --  No finalization here\n+   --      end loop;\n+   --      Finalize Iter and Control here, decrementing Lock twice and Busy\n+   --      once.\n+\n+   --  This optimization makes \"for ... of\" loops over 30 times faster in cases\n+   --  measured.\n+\n+   procedure Expand_Iterator_Loop_Over_Container\n+     (N             : Node_Id;\n+      Isc           : Node_Id;\n+      I_Spec        : Node_Id;\n+      Container     : Node_Id;\n+      Container_Typ : Entity_Id)\n+   is\n+      Id  : constant Entity_Id  := Defining_Identifier (I_Spec);\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      I_Kind   : constant Entity_Kind := Ekind (Id);\n+      Cursor   : Entity_Id;\n+      Iterator : Entity_Id;\n+      New_Loop : Node_Id;\n+      Stats    : constant List_Id := Statements (N);\n+\n+      Element_Type : constant Entity_Id := Etype (Id);\n+      Iter_Type    : Entity_Id;\n+      Pack         : Entity_Id;\n+      Decl         : Node_Id;\n+      Name_Init    : Name_Id;\n+      Name_Step    : Name_Id;\n+\n+      Fast_Element_Access_Op, Fast_Step_Op : Entity_Id := Empty;\n+      --  Only for optimized version of \"for ... of\"\n+\n+   begin\n+      --  Determine the advancement and initialization steps for the cursor.\n+      --  Analysis of the expanded loop will verify that the container has a\n+      --  reverse iterator.\n+\n+      if Reverse_Present (I_Spec) then\n+         Name_Init := Name_Last;\n+         Name_Step := Name_Previous;\n+      else\n+         Name_Init := Name_First;\n+         Name_Step := Name_Next;\n+      end if;\n+\n+      --  The type of the iterator is the return type of the Iterate function\n+      --  used. For the \"of\" form this is the default iterator for the type,\n+      --  otherwise it is the type of the explicit function used in the\n+      --  iterator specification. The most common case will be an Iterate\n+      --  function in the container package.\n+\n+      --  The Iterator type is declared in an instance within the container\n+      --  package itself, for example:\n+\n+      --    package Vector_Iterator_Interfaces is new\n+      --      Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n+      --  If the container type is a derived type, the cursor type is found in\n+      --  the package of the ultimate ancestor type.\n+\n+      if Is_Derived_Type (Container_Typ) then\n+         Pack := Scope (Root_Type (Container_Typ));\n+      else\n+         Pack := Scope (Container_Typ);\n+      end if;\n+\n+      Iter_Type := Etype (Name (I_Spec));\n+\n+      if Of_Present (I_Spec) then\n+         Handle_Of : declare\n+            Container_Arg : Node_Id;\n+\n+            function Get_Default_Iterator\n+              (T : Entity_Id) return Entity_Id;\n+            --  If the container is a derived type, the aspect holds the parent\n+            --  operation. The required one is a primitive of the derived type\n+            --  and is either inherited or overridden. Also sets Container_Arg.\n+\n+            --------------------------\n+            -- Get_Default_Iterator --\n+            --------------------------\n+\n+            function Get_Default_Iterator\n+              (T : Entity_Id) return Entity_Id\n+            is\n+               Iter : constant Entity_Id :=\n+                 Entity (Find_Value_Of_Aspect (T, Aspect_Default_Iterator));\n+               Prim : Elmt_Id;\n+               Op   : Entity_Id;\n+\n+            begin\n+               Container_Arg := New_Copy_Tree (Container);\n+\n+               --  A previous version of GNAT allowed indexing aspects to\n+               --  be redefined on derived container types, while the\n+               --  default iterator was inherited from the parent type.\n+               --  This non-standard extension is preserved temporarily for\n+               --  use by the modelling project under debug flag d.X.\n+\n+               if Debug_Flag_Dot_XX then\n+                  if Base_Type (Etype (Container)) /=\n+                     Base_Type (Etype (First_Formal (Iter)))\n+                  then\n+                     Container_Arg :=\n+                       Make_Type_Conversion (Loc,\n+                         Subtype_Mark =>\n+                           New_Occurrence_Of\n+                             (Etype (First_Formal (Iter)), Loc),\n+                         Expression   => Container_Arg);\n+                  end if;\n+\n+                  return Iter;\n+\n+               elsif Is_Derived_Type (T) then\n+\n+                  --  The default iterator must be a primitive operation of the\n+                  --  type, at the same dispatch slot position.\n+\n+                  Prim := First_Elmt (Primitive_Operations (T));\n+                  while Present (Prim) loop\n+                     Op := Node (Prim);\n+\n+                     if Chars (Op) = Chars (Iter)\n+                       and then DT_Position (Op) = DT_Position (Iter)\n+                     then\n+                        return Op;\n+                     end if;\n+\n+                     Next_Elmt (Prim);\n+                  end loop;\n+\n+                  --  Default iterator must exist\n+\n+                  pragma Assert (False);\n+\n+               --  Otherwise not a derived type\n+\n+               else\n+                  return Iter;\n+               end if;\n+            end Get_Default_Iterator;\n+\n+            Default_Iter : Entity_Id;\n+            Ent          : Entity_Id;\n+\n+            Reference_Control_Type : Entity_Id := Empty;\n+            Pseudo_Reference       : Entity_Id := Empty;\n+\n+         --  Start of processing for Handle_Of\n+\n+         begin\n+            if Is_Class_Wide_Type (Container_Typ) then\n+               Default_Iter :=\n+                 Get_Default_Iterator (Etype (Base_Type (Container_Typ)));\n+            else\n+               Default_Iter := Get_Default_Iterator (Etype (Container));\n+            end if;\n+\n+            Cursor := Make_Temporary (Loc, 'C');\n+\n+            --  For a container element iterator, the iterator type is obtained\n+            --  from the corresponding aspect, whose return type is descended\n+            --  from the corresponding interface type in some instance of\n+            --  Ada.Iterator_Interfaces. The actuals of that instantiation\n+            --  are Cursor and Has_Element.\n+\n+            Iter_Type := Etype (Default_Iter);\n+\n+            --  Find declarations needed for \"for ... of\" optimization\n+\n+            Ent := First_Entity (Pack);\n+            while Present (Ent) loop\n+               if Chars (Ent) = Name_Get_Element_Access then\n+                  Fast_Element_Access_Op := Ent;\n+\n+               elsif Chars (Ent) = Name_Step\n+                 and then Ekind (Ent) = E_Procedure\n+               then\n+                  Fast_Step_Op := Ent;\n+\n+               elsif Chars (Ent) = Name_Reference_Control_Type then\n+                  Reference_Control_Type := Ent;\n+\n+               elsif Chars (Ent) = Name_Pseudo_Reference then\n+                  Pseudo_Reference := Ent;\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+\n+            if Present (Reference_Control_Type)\n+              and then Present (Pseudo_Reference)\n+            then\n+               Insert_Action (N,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Make_Temporary (Loc, 'D'),\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Reference_Control_Type, Loc),\n+                   Expression          =>\n+                     Make_Function_Call (Loc,\n+                       Name                   =>\n+                         New_Occurrence_Of (Pseudo_Reference, Loc),\n+                       Parameter_Associations =>\n+                         New_List (New_Copy_Tree (Container_Arg)))));\n+            end if;\n+\n+            --  The iterator type, which is a class-wide type, may itself be\n+            --  derived locally, so the desired instantiation is the scope of\n+            --  the root type of the iterator type. Currently, Pack is the\n+            --  container instance; this overwrites it with the iterator\n+            --  package.\n+\n+            Pack := Scope (Root_Type (Etype (Iter_Type)));\n+\n+            --  Rewrite domain of iteration as a call to the default iterator\n+            --  for the container type.\n+\n+            Rewrite (Name (I_Spec),\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (Default_Iter, Loc),\n+                Parameter_Associations => New_List (Container_Arg)));\n+            Analyze_And_Resolve (Name (I_Spec));\n+\n+            --  Find cursor type in proper iterator package, which is an\n+            --  instantiation of Iterator_Interfaces.\n+\n+            Ent := First_Entity (Pack);\n+            while Present (Ent) loop\n+               if Chars (Ent) = Name_Cursor then\n+                  Set_Etype (Cursor, Etype (Ent));\n+                  exit;\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n+\n+            if Present (Fast_Element_Access_Op) then\n+               Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Id,\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (Element_Type, Loc),\n+                   Name                =>\n+                     Make_Explicit_Dereference (Loc,\n+                       Prefix =>\n+                         Make_Function_Call (Loc,\n+                           Name                   =>\n+                             New_Occurrence_Of (Fast_Element_Access_Op, Loc),\n+                           Parameter_Associations =>\n+                             New_List (New_Occurrence_Of (Cursor, Loc)))));\n+\n+            else\n+               Decl :=\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Id,\n+                   Subtype_Mark        =>\n+                     New_Occurrence_Of (Element_Type, Loc),\n+                   Name                =>\n+                     Make_Indexed_Component (Loc,\n+                       Prefix      => Relocate_Node (Container_Arg),\n+                       Expressions =>\n+                         New_List (New_Occurrence_Of (Cursor, Loc))));\n+            end if;\n+\n+            --  The defining identifier in the iterator is user-visible\n+            --  and must be visible in the debugger.\n+\n+            Set_Debug_Info_Needed (Id);\n+\n+            --  If the container does not have a variable indexing aspect,\n+            --  the element is a constant in the loop.\n+\n+            if No (Find_Value_Of_Aspect\n+                     (Container_Typ, Aspect_Variable_Indexing))\n+            then\n+               Set_Ekind (Id, E_Constant);\n+            end if;\n+\n+            Prepend_To (Stats, Decl);\n+         end Handle_Of;\n+\n+      --  X in Iterate (S) : type of iterator is type of explicitly\n+      --  given Iterate function, and the loop variable is the cursor.\n+      --  It will be assigned in the loop and must be a variable.\n+\n+      else\n+         Cursor := Id;\n+      end if;\n+\n+      Iterator := Make_Temporary (Loc, 'I');\n+\n+      --  For both iterator forms, add a call to the step operation to\n+      --  advance the cursor. Generate:\n+\n+      --     Cursor := Iterator.Next (Cursor);\n+\n+      --   or else\n+\n+      --     Cursor := Next (Cursor);\n+\n+      if Present (Fast_Element_Access_Op) and then Present (Fast_Step_Op) then\n+         declare\n+            Step_Call : Node_Id;\n+            Curs_Name : constant Node_Id := New_Occurrence_Of (Cursor, Loc);\n+         begin\n+            Step_Call :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (Fast_Step_Op, Loc),\n+                Parameter_Associations => New_List (Curs_Name));\n+\n+            Append_To (Stats, Step_Call);\n+            Set_Assignment_OK (Curs_Name);\n+         end;\n+\n+      else\n+         declare\n+            Rhs : Node_Id;\n+\n+         begin\n+            Rhs :=\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix        => New_Occurrence_Of (Iterator, Loc),\n+                    Selector_Name => Make_Identifier (Loc, Name_Step)),\n+                Parameter_Associations => New_List (\n+                   New_Occurrence_Of (Cursor, Loc)));\n+\n+            Append_To (Stats,\n+              Make_Assignment_Statement (Loc,\n+                 Name       => New_Occurrence_Of (Cursor, Loc),\n+                 Expression => Rhs));\n+            Set_Assignment_OK (Name (Last (Stats)));\n+         end;\n+      end if;\n+\n+      --  Generate:\n+      --    while Has_Element (Cursor) loop\n+      --       <Stats>\n+      --    end loop;\n+\n+      --   Has_Element is the second actual in the iterator package\n+\n+      New_Loop :=\n+        Make_Loop_Statement (Loc,\n+          Iteration_Scheme =>\n+            Make_Iteration_Scheme (Loc,\n+              Condition =>\n+                Make_Function_Call (Loc,\n+                  Name                   =>\n+                    New_Occurrence_Of (\n+                     Next_Entity (First_Entity (Pack)), Loc),\n+                  Parameter_Associations =>\n+                    New_List (New_Occurrence_Of (Cursor, Loc)))),\n+\n+          Statements => Stats,\n+          End_Label  => Empty);\n+\n+      --  If present, preserve identifier of loop, which can be used in\n+      --  an exit statement in the body.\n+\n+      if Present (Identifier (N)) then\n+         Set_Identifier (New_Loop, Relocate_Node (Identifier (N)));\n+      end if;\n+\n+      --  Create the declarations for Iterator and cursor and insert them\n+      --  before the source loop. Given that the domain of iteration is already\n+      --  an entity, the iterator is just a renaming of that entity. Possible\n+      --  optimization ???\n+\n+      Insert_Action (N,\n+        Make_Object_Renaming_Declaration (Loc,\n+          Defining_Identifier => Iterator,\n+          Subtype_Mark  => New_Occurrence_Of (Iter_Type, Loc),\n+          Name          => Relocate_Node (Name (I_Spec))));\n+\n+      --  Create declaration for cursor\n+\n+      declare\n+         Cursor_Decl : constant Node_Id :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Cursor,\n+             Object_Definition   =>\n+               New_Occurrence_Of (Etype (Cursor), Loc),\n+             Expression          =>\n+               Make_Selected_Component (Loc,\n+                 Prefix        => New_Occurrence_Of (Iterator, Loc),\n+                 Selector_Name =>\n+                   Make_Identifier (Loc, Name_Init)));\n+\n+      begin\n+         --  The cursor is only modified in expanded code, so it appears\n+         --  as unassigned to the warning machinery. We must suppress this\n+         --  spurious warning explicitly. The cursor's kind is that of the\n+         --  original loop parameter (it is a constant if the domain of\n+         --  iteration is constant).\n+\n+         Set_Warnings_Off (Cursor);\n+         Set_Assignment_OK (Cursor_Decl);\n+\n+         Insert_Action (N, Cursor_Decl);\n+         Set_Ekind (Cursor, I_Kind);\n+      end;\n+\n+      --  If the range of iteration is given by a function call that returns\n+      --  a container, the finalization actions have been saved in the\n+      --  Condition_Actions of the iterator. Insert them now at the head of\n+      --  the loop.\n+\n+      if Present (Condition_Actions (Isc)) then\n+         Insert_List_Before (N, Condition_Actions (Isc));\n+      end if;\n+\n+      Rewrite (N, New_Loop);\n+      Analyze (N);\n+   end Expand_Iterator_Loop_Over_Container;\n+\n    -----------------------------\n    -- Expand_N_Loop_Statement --\n    -----------------------------"}, {"sha": "872a35fda67e0c199717653af5bd38874b6ab6d2", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 105, "deletions": 161, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -42,138 +42,19 @@ with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n-with Table;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n package body Exp_Unst is\n \n-   ---------------------------\n-   -- Terminology for Calls --\n-   ---------------------------\n-\n-   --  The level of a subprogram in the nest being analyzed is defined to be\n-   --  the level of nesting, so the outer level subprogram (the one passed to\n-   --  Unnest_Subprogram) is 1, subprograms immediately nested within this\n-   --  outer level subprogram have a level of 2, etc.\n-\n-   --  Calls within the nest being analyzed are of three types:\n-\n-   --    Downward call: this is a call from a subprogram to a subprogram that\n-   --    is immediately nested with in the caller, and thus has a level that\n-   --    is one greater than the caller. It is a fundamental property of the\n-   --    nesting structure and visibility that it is not possible to make a\n-   --    call from level N to level M, where M is greater than N + 1.\n-\n-   --    Parallel call: this is a call from a nested subprogram to another\n-   --    nested subprogram that is at the same level.\n-\n-   --    Upward call: this is a call from a subprogram to a subprogram that\n-   --    encloses the caller. The level of the callee is less than the level\n-   --    of the caller, and there is no limit on the difference, e.g. for an\n-   --    uplevel call, a subprogram at level 5 can call one at level 2 or even\n-   --    the outer level subprogram at level 1.\n-\n-   -----------\n-   -- Subps --\n-   -----------\n-\n-   --  Table to record subprograms within the nest being currently analyzed\n-\n-   type Subp_Entry is record\n-      Ent : Entity_Id;\n-      --  Entity of the subprogram\n-\n-      Bod : Node_Id;\n-      --  Subprogram_Body node for this subprogram\n-\n-      Lev : Nat;\n-      --  Subprogram level (1 = outer subprogram (Subp argument), 2 = nested\n-      --  immediately within this outer subprogram etc.)\n-\n-      Reachable : Boolean;\n-      --  This flag is set True if there is a call path from the outer level\n-      --  subprogram to this subprogram. If Reachable is False, it means that\n-      --  the subprogram is declared but not actually referenced. We remove\n-      --  such subprograms from the tree, which simplifies our task, because\n-      --  we don't have to worry about e.g. uplevel references from such an\n-      --  unreferenced subpogram, which might require (useless) activation\n-      --  records to be created. This is computed by setting the outer level\n-      --  subprogram (Subp itself) as reachable, and then doing a transitive\n-      --  closure following all calls.\n-\n-      Uplevel_Ref : Nat;\n-      --  The outermost level which defines entities which this subprogram\n-      --  references either directly or indirectly via a call. This cannot\n-      --  be greater than Lev. If it is equal to Lev, then it means that the\n-      --  subprogram does not make any uplevel references and that thus it\n-      --  does not need an activation record pointer passed. If it is less than\n-      --  Lev, then an activation record pointer is needed, since there is at\n-      --  least one uplevel reference. This is computed by initially setting\n-      --  Uplevel_Ref to Lev for all subprograms. Then on the initial tree\n-      --  traversal, decreasing Uplevel_Ref for an explicit uplevel reference,\n-      --  and finally by doing a transitive closure that follows calls (if A\n-      --  calls B and B has an uplevel reference to level X, then A references\n-      --  level X indirectly).\n-\n-      Declares_AREC : Boolean;\n-      --  This is set True for a subprogram which include the declarations\n-      --  for a local activation record to be passed on downward calls. It\n-      --  is set True for the target level of an uplevel reference, and for\n-      --  all intervening nested subprograms. For example, if a subprogram X\n-      --  at level 5 makes an uplevel reference to an entity declared in a\n-      --  level 2 subprogram, then the subprograms at levels 4,3,2 enclosing\n-      --  the level 5 subprogram will have this flag set True.\n-\n-      Uents : Elist_Id;\n-      --  This is a list of entities declared in this subprogram which are\n-      --  uplevel referenced. It contains both objects (which will be put in\n-      --  the corresponding AREC activation record), and types. The types are\n-      --  not put in the AREC activation record, but referenced bounds (i.e.\n-      --  generated _FIRST and _LAST entites, and formal parameters) will be\n-      --  in the list in their own right.\n-\n-      ARECnF : Entity_Id;\n-      --  This entity is defined for all subprograms which need an extra formal\n-      --  that contains a pointer to the activation record needed for uplevel\n-      --  references. ARECnF must be defined for any subprogram which has a\n-      --  direct or indirect uplevel reference (i.e. Reference_Level < Lev).\n-\n-      ARECn   : Entity_Id;\n-      ARECnT  : Entity_Id;\n-      ARECnPT : Entity_Id;\n-      ARECnP  : Entity_Id;\n-      --  These AREC entities are defined only for subprograms for which we\n-      --  generate an activation record declaration, i.e. for subprograms for\n-      --  which the Declares_AREC flag is set True.\n-\n-      ARECnU : Entity_Id;\n-      --  This AREC entity is the uplink component. It is other than Empty only\n-      --  for nested subprograms that declare an activation record as indicated\n-      --  by Declares_AREC being Ture, and which have uplevel references (Lev\n-      --  greater than Uplevel_Ref). It is the additional component in the\n-      --  activation record that references the ARECnF pointer (which points\n-      --  the activation record one level higher, thus forming the chain).\n-\n-   end record;\n-\n-   subtype SI_Type is Nat;\n-\n-   package Subps is new Table.Table (\n-     Table_Component_Type => Subp_Entry,\n-     Table_Index_Type     => SI_Type,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 100,\n-     Table_Increment      => 200,\n-     Table_Name           => \"Unnest_Subps\");\n-   --  Records the subprograms in the nest whose outer subprogram is Subp\n-\n    -----------\n    -- Calls --\n    -----------\n \n    --  Table to record calls within the nest being analyzed. These are the\n-   --  calls which may need to have an AREC actual added.\n+   --  calls which may need to have an AREC actual added. This table is built\n+   --  new for each subprogram nest and cleared at the end of processing each\n+   --  subprogram nest.\n \n    type Call_Entry is record\n       N : Node_Id;\n@@ -207,7 +88,9 @@ package body Exp_Unst is\n    --  constants, formal parameters). These are the references that will\n    --  need rewriting to use the activation table (AREC) pointers. Also\n    --  included are implicit and explicit uplevel references to types, but\n-   --  these do not get rewritten by the front end.\n+   --  these do not get rewritten by the front end. This table is built new\n+   --  for each subprogram nest and cleared at the end of processing each\n+   --  subprogram nest.\n \n    type Uref_Entry is record\n       Ref : Node_Id;\n@@ -257,6 +140,10 @@ package body Exp_Unst is\n       function Subp_Index (Sub : Entity_Id) return SI_Type;\n       --  Given the entity for a subprogram, return corresponding Subps index\n \n+      function Suffixed_Name (Ent : Entity_Id) return Name_Id;\n+      --  Given an entity Ent, return its name (Char (Ent)) suffixed with\n+      --  two underscores and the entity number, to ensure a unique name.\n+\n       function Upref_Name (Ent : Entity_Id; Clist : List_Id) return Name_Id;\n       --  This function returns the name to be used in the activation record to\n       --  reference the variable uplevel. Clist is the list of components that\n@@ -299,7 +186,6 @@ package body Exp_Unst is\n       function Get_Level (Sub : Entity_Id) return Nat is\n          Lev : Nat;\n          S   : Entity_Id;\n-\n       begin\n          Lev := 1;\n          S   := Sub;\n@@ -323,25 +209,31 @@ package body Exp_Unst is\n          return SI_Type (UI_To_Int (Subps_Index (Sub)));\n       end Subp_Index;\n \n+      -------------------\n+      -- Suffixed_Name --\n+      -------------------\n+\n+      function Suffixed_Name (Ent : Entity_Id) return Name_Id is\n+      begin\n+         Get_Name_String (Chars (Ent));\n+         Add_Str_To_Name_Buffer (\"__\");\n+         Add_Nat_To_Name_Buffer (Nat (Ent));\n+         return Name_Enter;\n+      end Suffixed_Name;\n+\n       ----------------\n       -- Upref_Name --\n       ----------------\n \n       function Upref_Name (Ent : Entity_Id; Clist : List_Id) return Name_Id is\n          C : Node_Id;\n-\n       begin\n          C := First (Clist);\n          loop\n             if No (C) then\n                return Chars (Ent);\n-\n             elsif Chars (Defining_Identifier (C)) = Chars (Ent) then\n-               Get_Name_String (Chars (Ent));\n-               Add_Str_To_Name_Buffer (\"__\");\n-               Add_Nat_To_Name_Buffer (Nat (Ent));\n-               return Name_Enter;\n-\n+               return Suffixed_Name (Ent);\n             else\n                Next (C);\n             end if;\n@@ -383,7 +275,7 @@ package body Exp_Unst is\n \n       --  First populate the above tables\n \n-      Subps.Init;\n+      Subps_First := Subps.Last + 1;\n       Calls.Init;\n       Urefs.Init;\n \n@@ -637,6 +529,7 @@ package body Exp_Unst is\n                       Uplevel_Ref   => L,\n                       Declares_AREC => False,\n                       Uents         => No_Elist,\n+                      Last          => 0,\n                       ARECnF        => Empty,\n                       ARECn         => Empty,\n                       ARECnT        => Empty,\n@@ -907,7 +800,7 @@ package body Exp_Unst is\n \n       begin\n          New_SI := 0;\n-         for J in Subps.First .. Subps.Last loop\n+         for J in Subps_First .. Subps.Last loop\n             declare\n                STJ  : Subp_Entry renames Subps.Table (J);\n                Spec : Node_Id;\n@@ -1040,11 +933,16 @@ package body Exp_Unst is\n          end;\n       end loop;\n \n+      --  The tables are now complete, so we can record the last index in the\n+      --  Subps table for later reference in Cprint.\n+\n+      Subps.Table (Subps_First).Last := Subps.Last;\n+\n       --  Next step, create the entities for code we will insert. We do this\n       --  at the start so that all the entities are defined, regardless of the\n       --  order in which we do the code insertions.\n \n-      Create_Entities : for J in Subps.First .. Subps.Last loop\n+      Create_Entities : for J in Subps_First .. Subps.Last loop\n          declare\n             STJ : Subp_Entry renames Subps.Table (J);\n             Loc : constant Source_Ptr := Sloc (STJ.Bod);\n@@ -1093,7 +991,7 @@ package body Exp_Unst is\n          Addr : constant Entity_Id := RTE (RE_Address);\n \n       begin\n-         for J in Subps.First .. Subps.Last loop\n+         for J in Subps_First .. Subps.Last loop\n             declare\n                STJ : Subp_Entry renames Subps.Table (J);\n \n@@ -1193,37 +1091,47 @@ package body Exp_Unst is\n                      Comp  : Entity_Id;\n \n                      Decl_ARECnT  : Node_Id;\n-                     Decl_ARECn   : Node_Id;\n                      Decl_ARECnPT : Node_Id;\n+                     Decl_ARECn   : Node_Id;\n                      Decl_ARECnP  : Node_Id;\n                      --  Declaration nodes for the AREC entities we build\n \n+                     Decl_Assign : Node_Id;\n+                     --  Assigment to set uplink, Empty if none\n+\n+                     Decls : List_Id;\n+                     --  List of new declarations we create\n+\n                   begin\n+                     --  Suffix the ARECnT and ARECnPT names to make sure that\n+                     --  they are unique when Cprint moves the declarations to\n+                     --  the outer level.\n+\n+                     Set_Chars (STJ.ARECnT,  Suffixed_Name (STJ.ARECnT));\n+                     Set_Chars (STJ.ARECnPT, Suffixed_Name (STJ.ARECnPT));\n+\n                      --  Build list of component declarations for ARECnT\n \n                      Clist := Empty_List;\n \n                      --  If we are in a subprogram that has a static link that\n                      --  is passed in (as indicated by ARECnF being defined),\n-                     --  then include ARECnU : ARECnPT := ARECnF where n is\n-                     --  one less than the current level and the entity ARECnPT\n-                     --  comes from the enclosing subprogram.\n+                     --  then include ARECnU : ARECmPT where m is one less than\n+                     --  the current level and the entity ARECnPT comes from\n+                     --  the enclosing subprogram.\n \n                      if Present (STJ.ARECnF) then\n                         declare\n                            STJE : Subp_Entry\n                                     renames Subps.Table (Enclosing_Subp (J));\n-\n                         begin\n                            Append_To (Clist,\n                              Make_Component_Declaration (Loc,\n                                Defining_Identifier  => STJ.ARECnU,\n                                Component_Definition =>\n                                  Make_Component_Definition (Loc,\n                                    Subtype_Indication =>\n-                                     New_Occurrence_Of (STJE.ARECnPT, Loc)),\n-                               Expression           =>\n-                                 New_Occurrence_Of (STJ.ARECnF, Loc)));\n+                                     New_Occurrence_Of (STJE.ARECnPT, Loc))));\n                         end;\n                      end if;\n \n@@ -1271,15 +1179,7 @@ package body Exp_Unst is\n                              Component_List =>\n                                Make_Component_List (Loc,\n                                  Component_Items => Clist)));\n-\n-                     --  ARECn : aliased ARECnT;\n-\n-                     Decl_ARECn :=\n-                       Make_Object_Declaration (Loc,\n-                         Defining_Identifier => STJ.ARECn,\n-                           Aliased_Present   => True,\n-                           Object_Definition =>\n-                             New_Occurrence_Of (STJ.ARECnT, Loc));\n+                     Decls := New_List (Decl_ARECnT);\n \n                      --  type ARECnPT is access all ARECnT;\n \n@@ -1291,6 +1191,17 @@ package body Exp_Unst is\n                              All_Present        => True,\n                              Subtype_Indication =>\n                                New_Occurrence_Of (STJ.ARECnT, Loc)));\n+                     Append_To (Decls, Decl_ARECnPT);\n+\n+                     --  ARECn : aliased ARECnT;\n+\n+                     Decl_ARECn :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => STJ.ARECn,\n+                           Aliased_Present   => True,\n+                           Object_Definition =>\n+                             New_Occurrence_Of (STJ.ARECnT, Loc));\n+                     Append_To (Decls, Decl_ARECn);\n \n                      --  ARECnP : constant ARECnPT := ARECn'Access;\n \n@@ -1305,10 +1216,31 @@ package body Exp_Unst is\n                              Prefix           =>\n                                New_Occurrence_Of (STJ.ARECn, Loc),\n                              Attribute_Name => Name_Access));\n+                     Append_To (Decls, Decl_ARECnP);\n \n-                     Prepend_List_To (Declarations (STJ.Bod),\n-                       New_List\n-                         (Decl_ARECnT, Decl_ARECn, Decl_ARECnPT, Decl_ARECnP));\n+                     --  If we are in a subprogram that has a static link that\n+                     --  is passed in (as indicated by ARECnF being defined),\n+                     --  then generate ARECn.ARECmU := ARECmF where m is\n+                     --  one less than the current level to set the uplink.\n+\n+                     if Present (STJ.ARECnF) then\n+                        Decl_Assign :=\n+                          Make_Assignment_Statement (Loc,\n+                            Name       =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix        =>\n+                                  New_Occurrence_Of (STJ.ARECn, Loc),\n+                                Selector_Name =>\n+                                  New_Occurrence_Of (STJ.ARECnU, Loc)),\n+                            Expression =>\n+                              New_Occurrence_Of (STJ.ARECnF, Loc));\n+                        Append_To (Decls, Decl_Assign);\n+\n+                     else\n+                        Decl_Assign := Empty;\n+                     end if;\n+\n+                     Prepend_List_To (Declarations (STJ.Bod), Decls);\n \n                      --  Analyze the newly inserted declarations. Note that we\n                      --  do not need to establish the whole scope stack, since\n@@ -1322,9 +1254,14 @@ package body Exp_Unst is\n \n                      Push_Scope (STJ.Ent);\n                      Analyze (Decl_ARECnT,  Suppress => All_Checks);\n-                     Analyze (Decl_ARECn,   Suppress => All_Checks);\n                      Analyze (Decl_ARECnPT, Suppress => All_Checks);\n+                     Analyze (Decl_ARECn,   Suppress => All_Checks);\n                      Analyze (Decl_ARECnP,  Suppress => All_Checks);\n+\n+                     if Present (Decl_Assign) then\n+                        Analyze (Decl_Assign,  Suppress => All_Checks);\n+                     end if;\n+\n                      Pop_Scope;\n \n                      --  Mark the types as needing typedefs\n@@ -1521,15 +1458,22 @@ package body Exp_Unst is\n \n                --     (((AREC5F.AREC4U).AREC3U).AREC2U).X\n \n-               Pfx := New_Occurrence_Of (STJR.ARECnF, Loc);\n+               --  In the above, ARECnF and ARECnU are pointers, so there are\n+               --  explicit dereferences required for these occurrences.\n+\n+               Pfx :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => New_Occurrence_Of (STJR.ARECnF, Loc));\n                SI := RS_Caller;\n                for L in STJE.Lev .. STJR.Lev - 2 loop\n                   SI := Enclosing_Subp (SI);\n                   Pfx :=\n-                    Make_Selected_Component (Loc,\n-                      Prefix        => Pfx,\n-                      Selector_Name =>\n-                        New_Occurrence_Of (Subps.Table (SI).ARECnU, Loc));\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix        => Pfx,\n+                          Selector_Name =>\n+                            New_Occurrence_Of (Subps.Table (SI).ARECnU, Loc)));\n                end loop;\n \n                --  Get activation record component (must exist)"}, {"sha": "7b92dcd4b0961e235a66d43234002c1713d2f079", "filename": "gcc/ada/exp_unst.ads", "status": "modified", "additions": 156, "deletions": 7, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -25,6 +25,7 @@\n \n --  Expand routines for unnesting subprograms\n \n+with Table;\n with Types; use Types;\n \n package Exp_Unst is\n@@ -175,9 +176,9 @@ package Exp_Unst is\n    --         rv : Address;\n    --      end record;\n \n-   --      AREC1 : aliased AREC1T;\n-\n    --      type AREC1PT is access all AREC1T;\n+\n+   --      AREC1  : aliased AREC1T;\n    --      AREC1P : constant AREC1PT := AREC1'Access;\n \n    --   The fields of AREC1 are set at the point the corresponding entity\n@@ -213,8 +214,9 @@ package Exp_Unst is\n    --             rv : Address;\n    --          end record;\n    --\n-   --          AREC1 : aliased AREC1T;\n    --          type AREC1PT is access all AREC1T;\n+   --\n+   --          AREC1 : aliased AREC1T;\n    --          AREC1P : constant AREC1PT := AREC1'Access;\n    --\n    --          AREC1.b := b'Address;\n@@ -362,8 +364,9 @@ package Exp_Unst is\n    --             dynam_LAST : Address;\n    --          end record;\n    --\n-   --          AREC1 : aliased AREC1T;\n    --          type AREC1PT is access all AREC1T;\n+   --\n+   --          AREC1 : aliased AREC1T;\n    --          AREC1P : constant AREC1PT := AREC1'Access;\n    --\n    --          AREC1.x := x'Address;\n@@ -422,23 +425,27 @@ package Exp_Unst is\n    --           v1 : Address;\n    --        end record;\n    --\n-   --        AREC1 : aliased AREC1T;\n    --        type AREC1PT is access all AREC1T;\n+   --\n+   --        AREC1 : aliased AREC1T;\n    --        AREC1P : constant AREC1PT := AREC1'Access;\n    --\n    --        v1 : integer := x;\n    --        AREC1.v1 := v1'Address;\n    --\n    --        function inner1 (y : integer; AREC1F : AREC1PT) return integer is\n    --           type AREC2T is record\n-   --              AREC1U : AREC1PT := AREC1F;\n+   --              AREC1U : AREC1PT;\n    --              v2     : Address;\n    --           end record;\n    --\n-   --           AREC2 : aliased AREC2T;\n    --           type AREC2PT is access all AREC2T;\n+   --\n+   --           AREC2 : aliased AREC2T;\n    --           AREC2P : constant AREC2PT := AREC2'Access;\n    --\n+   --           AREC2.AREC1U := AREC1F;\n+   --\n    --           v2 : integer := Integer'Deref (AREC1F.v1) {+} 1;\n    --           AREC2.v2 := v2'Address;\n    --\n@@ -525,6 +532,148 @@ package Exp_Unst is\n    --  with the issue of clashing names (mnames__inner, mnames__inner__inner),\n    --  and with overloading (mnames__f, mnames__f__2).\n \n+   --  In addition, the declarations of ARECnT and ARECnPT get moved to the\n+   --  outer level when we actually generate C code, so we suffix these names\n+   --  with the corresponding entity name to make sure they are unique.\n+\n+   ---------------------------\n+   -- Terminology for Calls --\n+   ---------------------------\n+\n+   --  The level of a subprogram in the nest being analyzed is defined to be\n+   --  the level of nesting, so the outer level subprogram (the one passed to\n+   --  Unnest_Subprogram) is 1, subprograms immediately nested within this\n+   --  outer level subprogram have a level of 2, etc.\n+\n+   --  Calls within the nest being analyzed are of three types:\n+\n+   --    Downward call: this is a call from a subprogram to a subprogram that\n+   --    is immediately nested with in the caller, and thus has a level that\n+   --    is one greater than the caller. It is a fundamental property of the\n+   --    nesting structure and visibility that it is not possible to make a\n+   --    call from level N to level M, where M is greater than N + 1.\n+\n+   --    Parallel call: this is a call from a nested subprogram to another\n+   --    nested subprogram that is at the same level.\n+\n+   --    Upward call: this is a call from a subprogram to a subprogram that\n+   --    encloses the caller. The level of the callee is less than the level\n+   --    of the caller, and there is no limit on the difference, e.g. for an\n+   --    uplevel call, a subprogram at level 5 can call one at level 2 or even\n+   --    the outer level subprogram at level 1.\n+\n+   -----------\n+   -- Subps --\n+   -----------\n+\n+   --  Table to record subprograms within the nest being currently analyzed.\n+   --  Entries in this table are made for each subprogram expanded, and do not\n+   --  get cleared as we complete the expansion, since we want the table info\n+   --  around in Cprint for the actual unnesting operation. Subps_First in this\n+   --  unit records the starting entry in the table for the entries for Subp\n+   --  and this is also recorded in the Subps_Index field of the outer level\n+   --  subprogram in the nest. The last subps index for the nest can be found\n+   --  in the Subp_Entry Last field of this first entry.\n+\n+   subtype SI_Type is Nat;\n+   --  Index type for the table\n+\n+   Subps_First : SI_Type;\n+   --  Record starting index for entries in the current nest (this is the table\n+   --  index of the entry for Subp itself, and is recorded in the Subps_Index\n+   --  field of the entity for this subprogram).\n+\n+   type Subp_Entry is record\n+      Ent : Entity_Id;\n+      --  Entity of the subprogram\n+\n+      Bod : Node_Id;\n+      --  Subprogram_Body node for this subprogram\n+\n+      Lev : Nat;\n+      --  Subprogram level (1 = outer subprogram (Subp argument), 2 = nested\n+      --  immediately within this outer subprogram etc.)\n+\n+      Reachable : Boolean;\n+      --  This flag is set True if there is a call path from the outer level\n+      --  subprogram to this subprogram. If Reachable is False, it means that\n+      --  the subprogram is declared but not actually referenced. We remove\n+      --  such subprograms from the tree, which simplifies our task, because\n+      --  we don't have to worry about e.g. uplevel references from such an\n+      --  unreferenced subpogram, which might require (useless) activation\n+      --  records to be created. This is computed by setting the outer level\n+      --  subprogram (Subp itself) as reachable, and then doing a transitive\n+      --  closure following all calls.\n+\n+      Uplevel_Ref : Nat;\n+      --  The outermost level which defines entities which this subprogram\n+      --  references either directly or indirectly via a call. This cannot\n+      --  be greater than Lev. If it is equal to Lev, then it means that the\n+      --  subprogram does not make any uplevel references and that thus it\n+      --  does not need an activation record pointer passed. If it is less than\n+      --  Lev, then an activation record pointer is needed, since there is at\n+      --  least one uplevel reference. This is computed by initially setting\n+      --  Uplevel_Ref to Lev for all subprograms. Then on the initial tree\n+      --  traversal, decreasing Uplevel_Ref for an explicit uplevel reference,\n+      --  and finally by doing a transitive closure that follows calls (if A\n+      --  calls B and B has an uplevel reference to level X, then A references\n+      --  level X indirectly).\n+\n+      Declares_AREC : Boolean;\n+      --  This is set True for a subprogram which include the declarations\n+      --  for a local activation record to be passed on downward calls. It\n+      --  is set True for the target level of an uplevel reference, and for\n+      --  all intervening nested subprograms. For example, if a subprogram X\n+      --  at level 5 makes an uplevel reference to an entity declared in a\n+      --  level 2 subprogram, then the subprograms at levels 4,3,2 enclosing\n+      --  the level 5 subprogram will have this flag set True.\n+\n+      Uents : Elist_Id;\n+      --  This is a list of entities declared in this subprogram which are\n+      --  uplevel referenced. It contains both objects (which will be put in\n+      --  the corresponding AREC activation record), and types. The types are\n+      --  not put in the AREC activation record, but referenced bounds (i.e.\n+      --  generated _FIRST and _LAST entites, and formal parameters) will be\n+      --  in the list in their own right.\n+\n+      Last : SI_Type;\n+      --  This field is set only in the entry for the outer level subprogram\n+      --  in a nest, and records the last index in the Subp table for all the\n+      --  entries for subprograms in this nest.\n+\n+      ARECnF : Entity_Id;\n+      --  This entity is defined for all subprograms which need an extra formal\n+      --  that contains a pointer to the activation record needed for uplevel\n+      --  references. ARECnF must be defined for any subprogram which has a\n+      --  direct or indirect uplevel reference (i.e. Reference_Level < Lev).\n+\n+      ARECn   : Entity_Id;\n+      ARECnT  : Entity_Id;\n+      ARECnPT : Entity_Id;\n+      ARECnP  : Entity_Id;\n+      --  These AREC entities are defined only for subprograms for which we\n+      --  generate an activation record declaration, i.e. for subprograms for\n+      --  which the Declares_AREC flag is set True.\n+\n+      ARECnU : Entity_Id;\n+      --  This AREC entity is the uplink component. It is other than Empty only\n+      --  for nested subprograms that declare an activation record as indicated\n+      --  by Declares_AREC being Ture, and which have uplevel references (Lev\n+      --  greater than Uplevel_Ref). It is the additional component in the\n+      --  activation record that references the ARECnF pointer (which points\n+      --  the activation record one level higher, thus forming the chain).\n+\n+   end record;\n+\n+   package Subps is new Table.Table (\n+     Table_Component_Type => Subp_Entry,\n+     Table_Index_Type     => SI_Type,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 1000,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Unnest_Subps\");\n+   --  Records the subprograms in the nest whose outer subprogram is Subp\n+\n    -----------------\n    -- Subprograms --\n    -----------------"}, {"sha": "907455278539951c875732281ea6affce96ec672", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee93527368e112d1f2a9b0e739fc513eff3e048e/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=ee93527368e112d1f2a9b0e739fc513eff3e048e", "patch": "@@ -120,7 +120,7 @@ package Snames is\n    Name_uY : constant Name_Id := First_Name_Id + Character'Pos ('Y');\n    Name_uZ : constant Name_Id := First_Name_Id + Character'Pos ('Z');\n \n-   --  Note: the following table is read by the utility program XSNAMES, and\n+   --  Note: the following table is read by the utility program 'xsnamest', and\n    --  its format should not be changed without coordinating with this program.\n \n    N : constant Name_Id := First_Name_Id + 256;\n@@ -1411,6 +1411,9 @@ package Snames is\n    Name_Forward_Iterator                 : constant Name_Id := N + $;\n    Name_Reversible_Iterator              : constant Name_Id := N + $;\n    Name_Previous                         : constant Name_Id := N + $;\n+   Name_Pseudo_Reference                 : constant Name_Id := N + $;\n+   Name_Reference_Control_Type           : constant Name_Id := N + $;\n+   Name_Get_Element_Access               : constant Name_Id := N + $;\n \n    --  Ada 2005 reserved words\n "}]}