{"sha": "70d539ce3a777b83d929c6de70b14a6eb7f3a100", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBkNTM5Y2UzYTc3N2I4M2Q5MjljNmRlNzBiMTRhNmViN2YzYTEwMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-08-21T01:42:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-08-21T01:42:39Z"}, "message": "re PR middle-end/28071 (A file that can not be compiled in reasonable time/space)\n\n\tPR rtl-optimization/28071\n\t* tree-optimize.c (tree_rest_of_compilation): Do not remove edges\n\ttwice.\n\t* tree-inline.c (copy_bb): Use cgraph_set_call_stmt.\n\t* ipa-inline.c (cgraph_check_inline_limits): Add one_only argument.\n\t(cgraph_decide_inlining, cgraph_decide_inlining_of_small_function,\n\tcgraph_decide_inlining_incrementally): Update use of\n\tcgraph_check_inline_limits.\n\t* cgraph.c (edge_hash, edge_eq): New function.\n\t(cgraph_edge, cgraph_set_call_stmt, cgraph_create_edge,\n\tcgraph_edge_remove_caller, cgraph_node_remove_callees,\n\tcgraph_remove_node): Maintain call site hash.\n\t* cgraph.h (struct cgraph_node): Add call_site_hash.\n\t(cgraph_set_call_stmt): New function.\n\nFrom-SVN: r116284", "tree": {"sha": "a12516abd37107b901b016eeb00d8d3bf4e3660f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a12516abd37107b901b016eeb00d8d3bf4e3660f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70d539ce3a777b83d929c6de70b14a6eb7f3a100", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d539ce3a777b83d929c6de70b14a6eb7f3a100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d539ce3a777b83d929c6de70b14a6eb7f3a100", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d539ce3a777b83d929c6de70b14a6eb7f3a100/comments", "author": null, "committer": null, "parents": [{"sha": "76395e081fd157eea5646a1dc4add10415d8b330", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76395e081fd157eea5646a1dc4add10415d8b330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76395e081fd157eea5646a1dc4add10415d8b330"}], "stats": {"total": 156, "additions": 135, "deletions": 21}, "files": [{"sha": "08ca50e788626dac0a811255b407fc25d8050ae6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70d539ce3a777b83d929c6de70b14a6eb7f3a100", "patch": "@@ -1,3 +1,20 @@\n+2006-08-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR rtl-optimization/28071\n+\t* tree-optimize.c (tree_rest_of_compilation): Do not remove edges\n+\ttwice.\n+\t* tree-inline.c (copy_bb): Use cgraph_set_call_stmt.\n+\t* ipa-inline.c (cgraph_check_inline_limits): Add one_only argument.\n+\t(cgraph_decide_inlining, cgraph_decide_inlining_of_small_function,\n+\tcgraph_decide_inlining_incrementally): Update use of\n+\tcgraph_check_inline_limits.\n+\t* cgraph.c (edge_hash, edge_eq): New function.\n+\t(cgraph_edge, cgraph_set_call_stmt, cgraph_create_edge,\n+\tcgraph_edge_remove_caller, cgraph_node_remove_callees,\n+\tcgraph_remove_node): Maintain call site hash.\n+\t* cgraph.h (struct cgraph_node): Add call_site_hash.\n+\t(cgraph_set_call_stmt): New function.\n+\n 2006-08-20  Jan Hubicka  <jh@suse.cz>\n \n \tPR rtl-optimization/28071"}, {"sha": "dc98ccf09583ff728feb220e716572544ac49d22", "filename": "gcc/cgraph.c", "status": "modified", "additions": 89, "deletions": 3, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=70d539ce3a777b83d929c6de70b14a6eb7f3a100", "patch": "@@ -293,23 +293,84 @@ cgraph_node_for_asm (tree asmname)\n   return NULL;\n }\n \n+/* Returns a hash value for X (which really is a die_struct).  */\n+\n+static hashval_t\n+edge_hash (const void *x)\n+{\n+  return htab_hash_pointer (((struct cgraph_edge *) x)->call_stmt);\n+}\n+\n+/* Return nonzero if decl_id of die_struct X is the same as UID of decl *Y.  */\n+\n+static int\n+edge_eq (const void *x, const void *y)\n+{\n+  return ((struct cgraph_edge *) x)->call_stmt == y;\n+}\n+\n /* Return callgraph edge representing CALL_EXPR statement.  */\n struct cgraph_edge *\n cgraph_edge (struct cgraph_node *node, tree call_stmt)\n {\n-  struct cgraph_edge *e;\n+  struct cgraph_edge *e, *e2;\n+  int n = 0;\n+\n+  if (node->call_site_hash)\n+    return htab_find_with_hash (node->call_site_hash, call_stmt,\n+      \t\t\t\thtab_hash_pointer (call_stmt));\n \n   /* This loop may turn out to be performance problem.  In such case adding\n      hashtables into call nodes with very many edges is probably best\n      solution.  It is not good idea to add pointer into CALL_EXPR itself\n      because we want to make possible having multiple cgraph nodes representing\n      different clones of the same body before the body is actually cloned.  */\n   for (e = node->callees; e; e= e->next_callee)\n-    if (e->call_stmt == call_stmt)\n-      break;\n+    {\n+      if (e->call_stmt == call_stmt)\n+\tbreak;\n+      n++;\n+    }\n+  if (n > 100)\n+    {\n+      node->call_site_hash = htab_create_ggc (120, edge_hash, edge_eq, NULL);\n+      for (e2 = node->callees; e2; e2 = e2->next_callee)\n+\t{\n+          void **slot;\n+\t  slot = htab_find_slot_with_hash (node->call_site_hash,\n+\t\t\t\t\t   e2->call_stmt,\n+\t\t\t\t\t   htab_hash_pointer (e2->call_stmt),\n+\t\t\t\t\t   INSERT);\n+\t  gcc_assert (!*slot);\n+\t  *slot = e2;\n+\t}\n+    }\n   return e;\n }\n \n+/* Change call_smtt of edge E to NEW_STMT.  */\n+void\n+cgraph_set_call_stmt (struct cgraph_edge *e, tree new_stmt)\n+{\n+  if (e->caller->call_site_hash)\n+    {\n+      htab_remove_elt_with_hash (e->caller->call_site_hash,\n+\t\t\t\t e->call_stmt,\n+\t\t\t\t htab_hash_pointer (e->call_stmt));\n+    }\n+  e->call_stmt = new_stmt;\n+  if (e->caller->call_site_hash)\n+    {\n+      void **slot;\n+      slot = htab_find_slot_with_hash (e->caller->call_site_hash,\n+\t\t\t\t       e->call_stmt,\n+\t\t\t\t       htab_hash_pointer\n+\t\t\t\t       (e->call_stmt), INSERT);\n+      gcc_assert (!*slot);\n+      *slot = e;\n+    }\n+}\n+\n /* Create edge from CALLER to CALLEE in the cgraph.  */\n \n struct cgraph_edge *\n@@ -353,6 +414,17 @@ cgraph_create_edge (struct cgraph_node *caller, struct cgraph_node *callee,\n   callee->callers = edge;\n   edge->count = count;\n   edge->loop_nest = nest;\n+  if (caller->call_site_hash)\n+    {\n+      void **slot;\n+      slot = htab_find_slot_with_hash (caller->call_site_hash,\n+\t\t\t\t       edge->call_stmt,\n+\t\t\t\t       htab_hash_pointer\n+\t\t\t\t\t (edge->call_stmt),\n+\t\t\t\t       INSERT);\n+      gcc_assert (!*slot);\n+      *slot = edge;\n+    }\n   return edge;\n }\n \n@@ -380,6 +452,10 @@ cgraph_edge_remove_caller (struct cgraph_edge *e)\n     e->next_callee->prev_callee = e->prev_callee;\n   if (!e->prev_callee)\n     e->caller->callees = e->next_callee;\n+  if (e->caller->call_site_hash)\n+    htab_remove_elt_with_hash (e->caller->call_site_hash,\n+\t\t\t       e->call_stmt,\n+\t  \t\t       htab_hash_pointer (e->call_stmt));\n }\n \n /* Remove the edge E in the cgraph.  */\n@@ -425,6 +501,11 @@ cgraph_node_remove_callees (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     cgraph_edge_remove_callee (e);\n   node->callees = NULL;\n+  if (node->call_site_hash)\n+    {\n+      htab_delete (node->call_site_hash);\n+      node->call_site_hash = NULL;\n+    }\n }\n \n /* Remove all callers from the node.  */\n@@ -521,6 +602,11 @@ cgraph_remove_node (struct cgraph_node *node)\n       DECL_INITIAL (node->decl) = error_mark_node;\n     }\n   node->decl = NULL;\n+  if (node->call_site_hash)\n+    {\n+      htab_delete (node->call_site_hash);\n+      node->call_site_hash = NULL;\n+    }\n   cgraph_n_nodes--;\n   /* Do not free the structure itself so the walk over chain can continue.  */\n }"}, {"sha": "668d7a7b08b827c393a57a50637ce2f5e31ce239", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=70d539ce3a777b83d929c6de70b14a6eb7f3a100", "patch": "@@ -133,6 +133,9 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   /* Pointer to a single unique cgraph node for this function.  If the\n      function is to be output, this is the copy that will survive.  */\n   struct cgraph_node *master_clone;\n+  /* For functions with many calls sites it holds map from call expression\n+     to the edge to speed up cgraph_edge function.  */\n+  htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n \n   PTR GTY ((skip)) aux;\n \n@@ -266,6 +269,7 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n struct cgraph_node *cgraph_node (tree);\n struct cgraph_node *cgraph_node_for_asm (tree asmname);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);\n+void cgraph_set_call_stmt (struct cgraph_edge *, tree);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);"}, {"sha": "638fdefb8c8cd53560649e6c664bf66b6fd5d8ad", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=70d539ce3a777b83d929c6de70b14a6eb7f3a100", "patch": "@@ -243,20 +243,27 @@ cgraph_estimate_growth (struct cgraph_node *node)\n }\n \n /* Return false when inlining WHAT into TO is not good idea\n-   as it would cause too large growth of function bodies.  */\n+   as it would cause too large growth of function bodies.  \n+   When ONE_ONLY is true, assume that only one call site is going\n+   to be inlined, otherwise figure out how many call sites in\n+   TO calls WHAT and verify that all can be inlined.\n+   */\n \n static bool\n cgraph_check_inline_limits (struct cgraph_node *to, struct cgraph_node *what,\n-\t\t\t    const char **reason)\n+\t\t\t    const char **reason, bool one_only)\n {\n   int times = 0;\n   struct cgraph_edge *e;\n   int newsize;\n   int limit;\n \n-  for (e = to->callees; e; e = e->next_callee)\n-    if (e->callee == what)\n-      times++;\n+  if (one_only)\n+    times = 1;\n+  else\n+    for (e = to->callees; e; e = e->next_callee)\n+      if (e->callee == what)\n+\ttimes++;\n \n   if (to->global.inlined_to)\n     to = to->global.inlined_to;\n@@ -836,7 +843,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t{\n \t  struct cgraph_node *callee;\n \t  if (!cgraph_check_inline_limits (edge->caller, edge->callee,\n-\t\t\t\t\t   &edge->inline_failed))\n+\t\t\t\t\t   &edge->inline_failed, true))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \" Not inlining into %s:%s.\\n\",\n@@ -1037,7 +1044,7 @@ cgraph_decide_inlining (void)\n \t\t  old_insns = overall_insns;\n \n \t\t  if (cgraph_check_inline_limits (node->callers->caller, node,\n-\t\t\t\t\t  \t  NULL))\n+\t\t\t\t\t  \t  NULL, false))\n \t\t    {\n \t\t      cgraph_mark_inline (node->callers);\n \t\t      if (dump_file)\n@@ -1109,7 +1116,8 @@ cgraph_decide_inlining_incrementally (struct cgraph_node *node, bool early)\n \t  && (!early\n \t      || (cgraph_estimate_size_after_inlining (1, e->caller, e->callee)\n \t          <= e->caller->global.insns))\n-\t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed)\n+\t  && cgraph_check_inline_limits (node, e->callee, &e->inline_failed,\n+\t    \t\t\t\t false)\n \t  && (DECL_SAVED_TREE (e->callee->decl) || e->callee->inline_decl))\n \t{\n \t  if (cgraph_default_inline_p (e->callee, &failed_reason))"}, {"sha": "78526e50bc8a0884fb23a23558d318c57f0755f3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=70d539ce3a777b83d929c6de70b14a6eb7f3a100", "patch": "@@ -737,14 +737,14 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale, int count_scal\n \t\t    {\n \t\t      edge = cgraph_edge (node, orig_stmt);\n \t\t      gcc_assert (edge);\n-\t\t      edge->call_stmt = stmt;\n+\t\t      cgraph_set_call_stmt (edge, stmt);\n \t\t    }\n \t\t  /* FALLTHRU */\n \n \t\tcase CB_CGE_MOVE:\n \t\t  edge = cgraph_edge (id->dst_node, orig_stmt);\n \t\t  if (edge)\n-\t\t    edge->call_stmt = stmt;\n+\t\t    cgraph_set_call_stmt (edge, stmt);\n \t\t  break;\n \n \t\tdefault:"}, {"sha": "3f4471a468cca1caa335c474833ecec5fb05b22a", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70d539ce3a777b83d929c6de70b14a6eb7f3a100/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=70d539ce3a777b83d929c6de70b14a6eb7f3a100", "patch": "@@ -393,15 +393,14 @@ tree_rest_of_compilation (tree fndecl)\n \t  timevar_pop (TV_INTEGRATION);\n \t}\n     }\n-  /* We are not going to maintain the cgraph edges up to date.\n-     Kill it so it won't confuse us.  */\n-  while (node->callees)\n+  /* In non-unit-at-a-time we must mark all referenced functions as needed.\n+     */\n+  if (!flag_unit_at_a_time)\n     {\n-      /* In non-unit-at-a-time we must mark all referenced functions as needed.\n-         */\n-      if (node->callees->callee->analyzed && !flag_unit_at_a_time)\n-        cgraph_mark_needed_node (node->callees->callee);\n-      cgraph_remove_edge (node->callees);\n+      struct cgraph_edge *e;\n+      for (e = node->callees; e; e = e->next_callee)\n+\tif (e->callee->analyzed)\n+          cgraph_mark_needed_node (e->callee);\n     }\n \n   /* We are not going to maintain the cgraph edges up to date."}]}