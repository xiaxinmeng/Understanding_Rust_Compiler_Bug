{"sha": "98f29f5638f73d8e55590eba8098a537ba746287", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThmMjlmNTYzOGY3M2Q4ZTU1NTkwZWJhODA5OGE1MzdiYTc0NjI4Nw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-03-18T00:23:39Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-03-18T00:23:39Z"}, "message": "libstdc++: Fix type-erasure in experimental::net::executor (PR 94203)\n\nThe _Tgt and _TgtImpl types that implement type-erasure didn't agree on\nthe virtual interface, so failed as soon as they were instantiated. With\nClang they failed even sooner. The interface was also dependent on\nwhether RTTI was enabled or not.\n\nThis patch fixes the broken virtual functions and makes the type work\nwithout RTTI, by using a pointer to a specialization of a function\ntemplate (similar to the approaches in std::function and std::any).\n\nThe changes to the virtual functions would be an ABI change, except that\nthe previous code didn't even compile if instantiated. This is\nexperimental TS material anyway.\n\n\tPR libstdc++/94203\n\t* include/experimental/executor (executor::executor(Executor)): Call\n\tmake_shared directly instead of _M_create. Create _Tgt1 object.\n\t(executor::executor(allocator_arg_t, const ProtoAlloc&, Executor)):\n\tCall allocate_shared directly instead of _M_create. Create _Tgt2\n\tobject.\n\t(executor::target_type): Add cast needed for new _Tgt interface.\n\t(executor::target): Define when RTTI is disabled. Use _Tgt::_M_func.\n\t(executor::_Tgt): Define the same interface whether RTTI is enabled or\n\tnot.\n\t(executor::_Tgt::target_type, executor::_Tgt::target): Do not use\n\tstd::type_info in the interface.\n\t(executor::_Tgt::_M_func): Add data member.\n\t(executor::_TgtImpl): Replace with _Tgt1 and _Tgt2 class templates.\n\t(executor::_Tgt1::_S_func): Define function to access target without\n\tdepending on RTTI.\n\t(executor::_M_create): Remove.\n\t(operator==, operator!=): Simplify comparisons for executor.\n\t* include/experimental/socket (is_error_code_enum<socket_errc>):\n\tDefine specialization before use.\n\t* testsuite/experimental/net/executor/1.cc: New test.", "tree": {"sha": "9989825d505ad09d40b1c7f23c3730c4564d2920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9989825d505ad09d40b1c7f23c3730c4564d2920"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98f29f5638f73d8e55590eba8098a537ba746287", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f29f5638f73d8e55590eba8098a537ba746287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98f29f5638f73d8e55590eba8098a537ba746287", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98f29f5638f73d8e55590eba8098a537ba746287/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b2cc34369ae1a774f0c910454999613c320bfe6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b2cc34369ae1a774f0c910454999613c320bfe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b2cc34369ae1a774f0c910454999613c320bfe6"}], "stats": {"total": 361, "additions": 284, "deletions": 77}, "files": [{"sha": "b874bb25b9e1733245a6a357dd5d052f7c655553", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=98f29f5638f73d8e55590eba8098a537ba746287", "patch": "@@ -1,3 +1,27 @@\n+2020-03-18  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/94203\n+\t* include/experimental/executor (executor::executor(Executor)): Call\n+\tmake_shared directly instead of _M_create. Create _Tgt1 object.\n+\t(executor::executor(allocator_arg_t, const ProtoAlloc&, Executor)):\n+\tCall allocate_shared directly instead of _M_create. Create _Tgt2\n+\tobject.\n+\t(executor::target_type): Add cast needed for new _Tgt interface.\n+\t(executor::target): Define when RTTI is disabled. Use _Tgt::_M_func.\n+\t(executor::_Tgt): Define the same interface whether RTTI is enabled or\n+\tnot.\n+\t(executor::_Tgt::target_type, executor::_Tgt::target): Do not use\n+\tstd::type_info in the interface.\n+\t(executor::_Tgt::_M_func): Add data member.\n+\t(executor::_TgtImpl): Replace with _Tgt1 and _Tgt2 class templates.\n+\t(executor::_Tgt1::_S_func): Define function to access target without\n+\tdepending on RTTI.\n+\t(executor::_M_create): Remove.\n+\t(operator==, operator!=): Simplify comparisons for executor.\n+\t* include/experimental/socket (is_error_code_enum<socket_errc>):\n+\tDefine specialization before use.\n+\t* testsuite/experimental/net/executor/1.cc: New test.\n+\n 2020-03-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/94199"}, {"sha": "b5c6e18a19a1ed8d112bcc557d82cb3be6193a33", "filename": "libstdc++-v3/include/experimental/executor", "status": "modified", "additions": 153, "deletions": 73, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fexecutor?ref=98f29f5638f73d8e55590eba8098a537ba746287", "patch": "@@ -295,26 +295,22 @@ inline namespace v1\n   class executor;\n \n   bool\n-  operator==(const executor& __a, const executor& __b) noexcept;\n+  operator==(const executor&, const executor&) noexcept;\n \n   bool\n-  operator==(const executor& __e, nullptr_t) noexcept;\n+  operator==(const executor&, nullptr_t) noexcept;\n \n-  inline bool\n-  operator==(nullptr_t, const executor& __e) noexcept\n-  { return __e == nullptr; }\n+  bool\n+  operator==(nullptr_t, const executor&) noexcept;\n \n-  inline bool\n-  operator!=(const executor& __a, const executor& __b) noexcept\n-  { return !(__a == __b); }\n+  bool\n+  operator!=(const executor&, const executor&) noexcept;\n \n-  inline bool\n-  operator!=(const executor& __e, nullptr_t) noexcept\n-  { return !(__e == nullptr); }\n+  bool\n+  operator!=(const executor&, nullptr_t) noexcept;\n \n-  inline bool\n-  operator!=(nullptr_t, const executor& __e) noexcept\n-  { return !(__e == nullptr); }\n+  bool\n+  operator!=(nullptr_t, const executor&) noexcept;\n \n   void swap(executor&, executor&) noexcept;\n \n@@ -999,12 +995,13 @@ inline namespace v1\n \n     template<typename _Executor>\n       executor(_Executor __e)\n-      : _M_target(_M_create(std::move(__e)))\n+      : _M_target(make_shared<_Tgt1<_Executor>>(std::move(__e)))\n       { }\n \n     template<typename _Executor, typename _ProtoAlloc>\n       executor(allocator_arg_t, const _ProtoAlloc& __a, _Executor __e)\n-      : _M_target(_M_create(std::move(__e), __a))\n+      : _M_target(allocate_shared<_Tgt2<_Executor, _ProtoAlloc>>(__a,\n+\t    std::move(__e), __a))\n       { }\n \n     executor& operator=(const executor&) noexcept = default;\n@@ -1101,28 +1098,46 @@ inline namespace v1\n #if __cpp_rtti\n     const type_info&\n     target_type() const noexcept\n-    { return _M_target ? _M_target->target_type() : typeid(void); }\n+    {\n+      if (_M_target)\n+\treturn *static_cast<const type_info*>(_M_target->target_type());\n+      return typeid(void);\n+    }\n+#endif\n \n     template<typename _Executor>\n       _Executor*\n       target() noexcept\n       {\n+\tvoid* __p = nullptr;\n \tif (_M_target)\n-\t  if (const auto* __p = _M_target->target(typeid(_Executor)))\n-\t    return const_cast<_Executor*>(static_cast<const _Executor>(__p));\n-\treturn nullptr;\n+\t  {\n+\t    if (_M_target->_M_func == &_Tgt1<remove_cv_t<_Executor>>::_S_func)\n+\t      __p = _M_target->_M_func(_M_target.get(), nullptr);\n+#if __cpp_rtti\n+\t    else\n+\t      __p = _M_target->target(&typeid(_Executor));\n+#endif\n+\t  }\n+\treturn static_cast<_Executor*>(__p);\n       }\n \n     template<typename _Executor>\n       const _Executor*\n       target() const noexcept\n       {\n+\tconst void* __p = nullptr;\n \tif (_M_target)\n-\t  if (const auto* __p = _M_target->target(typeid(_Executor)))\n-\t    return static_cast<const _Executor*>(__p);\n-\treturn nullptr;\n-      }\n+\t  {\n+\t    if (_M_target->_M_func == &_Tgt1<remove_cv_t<_Executor>>::_S_func)\n+\t      return (_Executor*)_M_target->_M_func(_M_target.get(), nullptr);\n+#if __cpp_rtti\n+\t    else\n+\t      __p = _M_target->target(&typeid(_Executor));\n #endif\n+\t  }\n+\treturn static_cast<const _Executor*>(__p);\n+      }\n \n   private:\n     struct _Tgt\n@@ -1133,85 +1148,134 @@ inline namespace v1\n       virtual void dispatch(std::function<void()>) const = 0;\n       virtual void post(std::function<void()>) const = 0;\n       virtual void defer(std::function<void()>) const = 0;\n-#if __cpp_rtti\n-      virtual const type_info& target_type() const = 0;\n-      virtual void* target(const std::type_info&) const = 0;\n+      virtual const void* target_type() const noexcept = 0;\n+      virtual void* target(const void*) noexcept = 0;\n       virtual bool _M_equals(_Tgt*) const noexcept = 0;\n-      virtual const void* _M_get_executor() const noexcept = 0;\n-#endif\n+\n+      using _Func = void* (_Tgt*, const _Tgt*);\n+      _Func* _M_func; // Provides access to target without RTTI\n     };\n \n-    template<typename _Ex, typename _Alloc>\n-      struct _TgtImpl : _Tgt\n+    template<typename _Ex>\n+      struct _Tgt1 : _Tgt\n       {\n \texplicit\n-\t_TgtImpl(_Ex&& __ex, const _Alloc& __a)\n-\t: _M_impl(std::move(__ex), __a) { }\n+\t_Tgt1(_Ex&& __ex)\n+\t: _M_ex(std::move(__ex))\n+\t{ this->_M_func = &_S_func; }\n+\n+\tvoid\n+\ton_work_started() const noexcept override\n+\t{ _M_ex.on_work_started(); }\n \n-\tvoid on_work_started() const noexcept { _M_ex().on_work_started(); }\n-\tvoid on_work_finished() const noexcept { _M_ex().on_work_finished(); }\n-\texecution_context& context() const noexcept { return _M_ex().context(); }\n \tvoid\n-\tdispatch(std::function<void()> __f) const\n-\t{ _M_ex().dispatch(std::move(__f), _M_alloc()); }\n+\ton_work_finished() const noexcept override\n+\t{ _M_ex.on_work_finished(); }\n+\n+\texecution_context&\n+\tcontext() const noexcept override\n+\t{ return _M_ex.context(); }\n+\n \tvoid\n-\tpost(std::function<void()> __f) const\n-\t{ _M_ex().post(std::move(__f), _M_alloc()); }\n+\tdispatch(std::function<void()> __f) const override\n+\t{ _M_ex.dispatch(std::move(__f), allocator<void>()); }\n+\n+\tvoid\n+\tpost(std::function<void()> __f) const override\n+\t{ _M_ex.post(std::move(__f), allocator<void>()); }\n+\n \tvoid\n-\tdefer(std::function<void()> __f) const\n-\t{ _M_ex().defer(std::move(__f), _M_alloc()); }\n+\tdefer(std::function<void()> __f) const override\n+\t{ _M_ex.defer(std::move(__f), allocator<void>()); }\n \n+\tconst void*\n+\ttarget_type() const noexcept override\n+\t{\n #if __cpp_rtti\n-\tvirtual const type_info&\n-\ttarget_type() const\n-\t{ return typeid(_Ex); }\n+\t  return &typeid(_Ex);\n+#else\n+\t  return nullptr;\n+#endif\n+\t}\n \n-\tvirtual const void*\n-\ttarget(const std::type_info& __ti) const\n+\tvoid*\n+\ttarget(const void* __ti) noexcept override\n \t{\n-\t  if (__ti == typeid(_Ex))\n-\t    return std::addressof(_M_ex());\n+#if __cpp_rtti\n+\t  if (*static_cast<const type_info*>(__ti) == typeid(_Ex))\n+\t    return std::__addressof(_M_ex);\n+#endif\n \t  return nullptr;\n \t}\n \n-\tvirtual bool\n-\t_M_equals(const _Tgt* __tgt) const noexcept\n+\tbool\n+\t_M_equals(_Tgt* __tgt) const noexcept override\n \t{\n-\t  if (__tgt->target_type() == typeid(_Ex))\n-\t    *static_cast<const _Ex*>(__tgt->_M_get_executor()) == _M_ex();\n+#if __cpp_rtti\n+\t  if (const void* __p = __tgt->target(&typeid(_Ex)))\n+\t    return *static_cast<const _Ex*>(__p) == _M_ex;\n+#endif\n \t  return false;\n \t}\n \n-\tvirtual const void*\n-\t_M_get_executor() const noexcept\n-\t{ return std::addressof(_M_ex()); }\n-#endif\n+\t_Ex _M_ex [[__no_unique_address__]];\n \n-\t_Ex& _M_ex() { return std::get<0>(_M_impl); }\n-\t_Alloc& _M_alloc() { return std::get<1>(_M_impl); }\n-\tstd::tuple<_Ex, _Alloc> _M_impl;\n+\tstatic void*\n+\t_S_func(_Tgt* __p, const _Tgt* __q) noexcept\n+\t{\n+\t  auto& __ex = static_cast<_Tgt1*>(__p)->_M_ex;\n+\t  if (__q)\n+\t    {\n+\t      if (__ex == static_cast<const _Tgt1*>(__q)->_M_ex)\n+\t\treturn __p;\n+\t      else\n+\t\treturn nullptr;\n+\t    }\n+\t  else\n+\t    return std::__addressof(__ex);\n+\t}\n       };\n \n-    template<typename _Ex, typename _Alloc = std::allocator<void>>\n-      shared_ptr<_Tgt>\n-      _M_create(_Ex&& __ex, const _Alloc& __a = _Alloc())\n+    template<typename _Ex, typename _Alloc>\n+      struct _Tgt2 : _Tgt1<_Ex>\n       {\n-\treturn allocate_shared<_TgtImpl<_Ex, _Alloc>>(__a, std::move(__ex),\n-\t\t\t\t\t\t      __a);\n-      }\n+\texplicit\n+\t_Tgt2(_Ex&& __ex, const _Alloc& __a)\n+\t: _Tgt1<_Ex>(std::move(__ex)), _M_alloc(__a) { }\n+\n+\tvoid\n+\tdispatch(std::function<void()> __f) const override\n+\t{ this->_M_ex.dispatch(std::move(__f), _M_alloc); }\n+\n+\tvoid\n+\tpost(std::function<void()> __f) const override\n+\t{ this->_M_ex.post(std::move(__f), _M_alloc); }\n+\n+\tvoid\n+\tdefer(std::function<void()> __f) const override\n+\t{ this->_M_ex.defer(std::move(__f), _M_alloc); }\n+\n+\t_Alloc _M_alloc [[__no_unique_address__]];\n+      };\n+\n+    // Partial specialization for std::allocator<T>.\n+    // Don't store the allocator.\n+    template<typename _Ex, typename _Tp>\n+      struct _Tgt2<_Ex, std::allocator<_Tp>> : _Tgt1<_Ex>\n+      { };\n \n     friend bool\n     operator==(const executor& __a, const executor& __b) noexcept\n     {\n-      if (__a._M_target == __b._M_target)\n+      _Tgt* __ta = __a._M_target.get();\n+      _Tgt* __tb = __b._M_target.get();\n+      if (__ta == __tb)\n \treturn true;\n-      if (!__a._M_target || !__b._M_target)\n+      if (!__ta || !__tb)\n \treturn false;\n-#if __cpp_rtti\n-      return __a._M_target->_M_equals(__b._M_target.get());\n-#else\n-      return false; // XXX can we do better?\n-#endif\n+      if (__ta->_M_func == __tb->_M_func)\n+\treturn __ta->_M_func(__ta, __tb);\n+      return __ta->_M_equals(__tb);\n     }\n \n     shared_ptr<_Tgt> _M_target;\n@@ -1224,6 +1288,22 @@ inline namespace v1\n   operator==(const executor& __e, nullptr_t) noexcept\n   { return !__e; }\n \n+  inline bool\n+  operator==(nullptr_t, const executor& __e) noexcept\n+  { return !__e; }\n+\n+  inline bool\n+  operator!=(const executor& __a, const executor& __b) noexcept\n+  { return !(__a == __b); }\n+\n+  inline bool\n+  operator!=(const executor& __e, nullptr_t) noexcept\n+  { return (bool)__e; }\n+\n+  inline bool\n+  operator!=(nullptr_t, const executor& __e) noexcept\n+  { return (bool)__e; }\n+\n   /// Swap two executor objects.\n   inline void swap(executor& __a, executor& __b) noexcept { __a.swap(__b); }\n "}, {"sha": "81b1d15b654fd3740a3926c849b8e1914a6a254a", "filename": "libstdc++-v3/include/experimental/socket", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fsocket?ref=98f29f5638f73d8e55590eba8098a537ba746287", "patch": "@@ -79,6 +79,20 @@ inline namespace v1\n     not_found = 4\n   };\n \n+} // namespace v1\n+} // namespace net\n+} // namespace experimental\n+\n+  template<>\n+    struct is_error_code_enum<experimental::net::v1::socket_errc>\n+    : public true_type {};\n+\n+namespace experimental\n+{\n+namespace net\n+{\n+inline namespace v1\n+{\n   const error_category& socket_category() noexcept\n   {\n     struct __cat : error_category\n@@ -2602,10 +2616,6 @@ inline namespace v1\n } // namespace net\n } // namespace experimental\n \n-  template<>\n-    struct is_error_code_enum<experimental::net::v1::socket_errc>\n-    : public true_type {};\n-\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n "}, {"sha": "456d620e193885164c58693982ed14fa8e5ffd22", "filename": "libstdc++-v3/testsuite/experimental/net/executor/1.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecutor%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98f29f5638f73d8e55590eba8098a537ba746287/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecutor%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fnet%2Fexecutor%2F1.cc?ref=98f29f5638f73d8e55590eba8098a537ba746287", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++14 } }\n+\n+#include <experimental/executor>\n+#include <testsuite_hooks.h>\n+\n+namespace net = std::experimental::net;\n+\n+void\n+test01()\n+{\n+  net::executor e;\n+  VERIFY( !e );\n+  VERIFY( e == nullptr );\n+  VERIFY( nullptr == e );\n+  VERIFY( e == e );\n+  VERIFY( e == e );\n+  net::executor e2;\n+  VERIFY( e == e2 );\n+  swap(e, e2);\n+  VERIFY( e == e2 );\n+  e = e2;\n+  VERIFY( e == e2 );\n+}\n+\n+void\n+test02()\n+{\n+  struct E\n+  {\n+    void on_work_started() const noexcept { }\n+    void on_work_finished() const noexcept { }\n+    net::execution_context& context() const noexcept { return c; }\n+    void dispatch(std::function<void()>, std::allocator<void>) const { }\n+    void post(std::function<void()>, std::allocator<void>) const { }\n+    void defer(std::function<void()>, std::allocator<void>) const { }\n+\n+    net::execution_context& c;\n+\n+    bool operator==(const E& rhs) const noexcept\n+    { return &c == &rhs.c; }\n+  };\n+\n+  net::execution_context c;\n+  E d{c};\n+  net::executor e(d);\n+  VERIFY( e == e );\n+  VERIFY( e != nullptr );\n+  VERIFY( nullptr != e );\n+\n+  VERIFY( &e.context() == &c );\n+#if __cpp_rtti\n+  VERIFY( e.target_type() == typeid(E) );\n+#endif\n+  VERIFY( *e.target<E>() == d );\n+  VERIFY( *e.target<const E>() == d );\n+  VERIFY( *const_cast<const net::executor&>(e).target<E>() == d );\n+  VERIFY( *const_cast<const net::executor&>(e).target<const E>() == d );\n+\n+  net::executor f = e;\n+  VERIFY( f == e );\n+  e = nullptr;\n+  VERIFY( f != e );\n+  swap(e, f);\n+  VERIFY( f == nullptr );\n+  VERIFY( nullptr != e );\n+\n+  net::executor g(E{c});\n+  VERIFY( e == g );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}]}