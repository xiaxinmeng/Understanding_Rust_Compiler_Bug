{"sha": "69c32ec801a7b3b42778231b8187e77b8c63d0f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjljMzJlYzgwMWE3YjNiNDI3NzgyMzFiODE4N2U3N2I4YzYzZDBmMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-04-15T19:37:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-04-15T19:37:22Z"}, "message": "gengtype.c (write_root): Param_is argument is OK.\n\n\n\t* gengtype.c (write_root): Param_is argument is OK.\n\t* expr.c (expand_expr_real_1): Update call of get_exception_*.\n\t* function.h: Include varray.h\n\t(rtl_eh): New stucture based on except.c one.\n\t(call_site_record): New forward declaration and vector type.\n\t* calls.c (emit_call_1): Do not call\n\tnote_current_region_may_contain_throw.\n\t* except.c (eh_status): Remove cur_region, try_region since they are\n\tunused.\n\tMove filter, exc_ptr, ttype_data, ehspec_data, action_record_data and\n\texception_handler_label_map, ehr_stackadj, ehr_handler, ehr_label,\n\tsjlj_fc, sjlj_exit_after to rth_eh in function.h. \n\tRemove call_site_data_used, call_site_data_size.\n\tTurn call_site_record into vector in function.h.\n\t(note_current_region_may_contain_throw): Remove.\n\t(get_exception_pointer, get_exception_filter): Do not take struct\n\tfunction argument; update.\n\t(add_ehl_entry, find_exception_handler_labels, ehspec_filter_hash,\n\tadd_ttypes_entry, add_ehspec_entry, assign_filter_values,\n\tbuild_post_landing_pads, dw2_build_landing_pads,\n\tsjlj_assign_call_site_values, sjlj_mark_call_sites,\n\tsjlj_emit_function_enter, sjlj_emit_function_enter, \n\tsjlj_emit_function_exit, sjlj_emit_dispatch_table,\n\tsjlj_build_landing_pads, finish_eh_generation,\n\tremove_exception_handler_label, remove_eh_handler,\n\tmaybe_remove_eh_handler, add_reachable_handler,\n\treachable_handlers, expand_builtin_eh_return,\n\texpand_eh_return, add_action_record, collect_one_action_chain,\n\tadd_call_site, convert_to_eh_region_ranges, sjlj_size_of_call_site_table,\n\tsjlj_output_call_site_table, output_function_exception_table,\n\t* except.h (note_current_region_may_contain_throw): Remove\n\t(get_exception_pointer, get_exception_filter): Do not take struct\n\tfunction argument.\n\t* Makefile.in (GTFILES): Put varargs before struct function.\n\nFrom-SVN: r134328", "tree": {"sha": "b5b860ce15d89be1abf23b2800803eee715cd37e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b860ce15d89be1abf23b2800803eee715cd37e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69c32ec801a7b3b42778231b8187e77b8c63d0f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69c32ec801a7b3b42778231b8187e77b8c63d0f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69c32ec801a7b3b42778231b8187e77b8c63d0f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69c32ec801a7b3b42778231b8187e77b8c63d0f2/comments", "author": null, "committer": null, "parents": [{"sha": "b48a653174158c79c24c1e347859e924a5c9a4ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b48a653174158c79c24c1e347859e924a5c9a4ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b48a653174158c79c24c1e347859e924a5c9a4ac"}], "stats": {"total": 337, "additions": 176, "deletions": 161}, "files": [{"sha": "903ae6dd57ea990b051f8a543be7d8106b9caa22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -1,3 +1,40 @@\n+2008-04-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gengtype.c (write_root): Param_is argument is OK.\n+\t* expr.c (expand_expr_real_1): Update call of get_exception_*.\n+\t* function.h: Include varray.h\n+\t(rtl_eh): New stucture based on except.c one.\n+\t(call_site_record): New forward declaration and vector type.\n+\t* calls.c (emit_call_1): Do not call\n+\tnote_current_region_may_contain_throw.\n+\t* except.c (eh_status): Remove cur_region, try_region since they are\n+\tunused.\n+\tMove filter, exc_ptr, ttype_data, ehspec_data, action_record_data and\n+\texception_handler_label_map, ehr_stackadj, ehr_handler, ehr_label,\n+\tsjlj_fc, sjlj_exit_after to rth_eh in function.h. \n+\tRemove call_site_data_used, call_site_data_size.\n+\tTurn call_site_record into vector in function.h.\n+\t(note_current_region_may_contain_throw): Remove.\n+\t(get_exception_pointer, get_exception_filter): Do not take struct\n+\tfunction argument; update.\n+\t(add_ehl_entry, find_exception_handler_labels, ehspec_filter_hash,\n+\tadd_ttypes_entry, add_ehspec_entry, assign_filter_values,\n+\tbuild_post_landing_pads, dw2_build_landing_pads,\n+\tsjlj_assign_call_site_values, sjlj_mark_call_sites,\n+\tsjlj_emit_function_enter, sjlj_emit_function_enter, \n+\tsjlj_emit_function_exit, sjlj_emit_dispatch_table,\n+\tsjlj_build_landing_pads, finish_eh_generation,\n+\tremove_exception_handler_label, remove_eh_handler,\n+\tmaybe_remove_eh_handler, add_reachable_handler,\n+\treachable_handlers, expand_builtin_eh_return,\n+\texpand_eh_return, add_action_record, collect_one_action_chain,\n+\tadd_call_site, convert_to_eh_region_ranges, sjlj_size_of_call_site_table,\n+\tsjlj_output_call_site_table, output_function_exception_table,\n+\t* except.h (note_current_region_may_contain_throw): Remove\n+\t(get_exception_pointer, get_exception_filter): Do not take struct\n+\tfunction argument.\n+\t* Makefile.in (GTFILES): Put varargs before struct function.\n+\n 2008-04-15  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-structalias.c (get_constraint_for_component_ref): Do not"}, {"sha": "dc73bc59f68a9766965c9a93e158534a3435b05d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -3107,8 +3107,8 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n   $(srcdir)/alias.h $(srcdir)/coverage.c $(srcdir)/rtl.h \\\n-  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/function.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n-  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n+  $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/varray.h $(srcdir)/libfuncs.h $(SYMTAB_H) \\\n+  $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n   $(srcdir)/ipa-reference.h $(srcdir)/output.h $(srcdir)/cfgloop.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\"}, {"sha": "8ae65a5f6e3d4862f066b68697d63ae916349576", "filename": "gcc/calls.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -389,7 +389,6 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n       if (rn > 0)\n \tREG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_EH_REGION, GEN_INT (rn),\n \t\t\t\t\t\t   REG_NOTES (call_insn));\n-      note_current_region_may_contain_throw ();\n     }\n \n   if (ecf_flags & ECF_NORETURN)"}, {"sha": "b1f233207e5c37921a1d42beb840e1947bd7e729", "filename": "gcc/except.c", "status": "modified", "additions": 100, "deletions": 153, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -84,7 +84,6 @@ along with GCC; see the file COPYING3.  If not see\n #define EH_RETURN_DATA_REGNO(N) INVALID_REGNUM\n #endif\n \n-\n /* Protect cleanup actions with must-not-throw regions, with a call\n    to the given failure handler.  */\n tree (*lang_protect_cleanup_actions) (void);\n@@ -218,37 +217,8 @@ struct eh_status GTY(())\n \n   /* The same information as an indexable array.  */\n   VEC(eh_region,gc) *region_array;\n-\n-  /* The most recently open region.  */\n-  struct eh_region *cur_region;\n-\n-  /* This is the region for which we are processing catch blocks.  */\n-  struct eh_region *try_region;\n-\n-  rtx filter;\n-  rtx exc_ptr;\n-\n-  int built_landing_pads;\n   int last_region_number;\n \n-  VEC(tree,gc) *ttype_data;\n-  varray_type ehspec_data;\n-  varray_type action_record_data;\n-\n-  htab_t GTY ((param_is (struct ehl_map_entry))) exception_handler_label_map;\n-\n-  struct call_site_record * GTY ((length (\"%h.call_site_data_used\")))\n-    call_site_data;\n-  int call_site_data_used;\n-  int call_site_data_size;\n-\n-  rtx ehr_stackadj;\n-  rtx ehr_handler;\n-  rtx ehr_label;\n-\n-  rtx sjlj_fc;\n-  rtx sjlj_exit_after;\n-\n   htab_t GTY((param_is (struct throw_stmt_node))) throw_stmt_table;\n };\n \f\n@@ -587,41 +557,27 @@ note_eh_region_may_contain_throw (struct eh_region *region)\n     }\n }\n \n-void\n-note_current_region_may_contain_throw (void)\n-{\n-  note_eh_region_may_contain_throw (cfun->eh->cur_region);\n-}\n-\n \n /* Return an rtl expression for a pointer to the exception object\n    within a handler.  */\n \n rtx\n-get_exception_pointer (struct function *fun)\n+get_exception_pointer (void)\n {\n-  rtx exc_ptr = fun->eh->exc_ptr;\n-  if (fun == cfun && ! exc_ptr)\n-    {\n-      exc_ptr = gen_reg_rtx (ptr_mode);\n-      fun->eh->exc_ptr = exc_ptr;\n-    }\n-  return exc_ptr;\n+  if (! crtl->eh.exc_ptr)\n+    crtl->eh.exc_ptr = gen_reg_rtx (ptr_mode);\n+  return crtl->eh.exc_ptr;\n }\n \n /* Return an rtl expression for the exception dispatch filter\n    within a handler.  */\n \n rtx\n-get_exception_filter (struct function *fun)\n+get_exception_filter (void)\n {\n-  rtx filter = fun->eh->filter;\n-  if (fun == cfun && ! filter)\n-    {\n-      filter = gen_reg_rtx (targetm.eh_return_filter_mode ());\n-      fun->eh->filter = filter;\n-    }\n-  return filter;\n+  if (! crtl->eh.filter)\n+    crtl->eh.filter = gen_reg_rtx (targetm.eh_return_filter_mode ());\n+  return crtl->eh.filter;\n }\n \f\n /* This section is for the exception handling specific optimization pass.  */\n@@ -783,13 +739,13 @@ add_ehl_entry (rtx label, struct eh_region *region)\n   entry->region = region;\n \n   slot = (struct ehl_map_entry **)\n-    htab_find_slot (cfun->eh->exception_handler_label_map, entry, INSERT);\n+    htab_find_slot (crtl->eh.exception_handler_label_map, entry, INSERT);\n \n   /* Before landing pad creation, each exception handler has its own\n      label.  After landing pad creation, the exception handlers may\n      share landing pads.  This is ok, since maybe_remove_eh_handler\n      only requires the 1-1 mapping before landing pad creation.  */\n-  gcc_assert (!*slot || cfun->eh->built_landing_pads);\n+  gcc_assert (!*slot || crtl->eh.built_landing_pads);\n \n   *slot = entry;\n }\n@@ -799,13 +755,13 @@ find_exception_handler_labels (void)\n {\n   int i;\n \n-  if (cfun->eh->exception_handler_label_map)\n-    htab_empty (cfun->eh->exception_handler_label_map);\n+  if (crtl->eh.exception_handler_label_map)\n+    htab_empty (crtl->eh.exception_handler_label_map);\n   else\n     {\n       /* ??? The expansion factor here (3/2) must be greater than the htab\n \t occupancy factor (4/3) to avoid unnecessary resizing.  */\n-      cfun->eh->exception_handler_label_map\n+      crtl->eh.exception_handler_label_map\n         = htab_create_ggc (cfun->eh->last_region_number * 3 / 2,\n \t\t\t   ehl_hash, ehl_eq, NULL);\n     }\n@@ -821,7 +777,7 @@ find_exception_handler_labels (void)\n       region = VEC_index (eh_region, cfun->eh->region_array, i);\n       if (! region || region->region_number != i)\n \tcontinue;\n-      if (cfun->eh->built_landing_pads)\n+      if (crtl->eh.built_landing_pads)\n \tlab = region->landing_pad;\n       else\n \tlab = region->label;\n@@ -832,7 +788,7 @@ find_exception_handler_labels (void)\n \n   /* For sjlj exceptions, need the return label to remain live until\n      after landing pad generation.  */\n-  if (USING_SJLJ_EXCEPTIONS && ! cfun->eh->built_landing_pads)\n+  if (USING_SJLJ_EXCEPTIONS && ! crtl->eh.built_landing_pads)\n     add_ehl_entry (return_label, NULL);\n }\n \n@@ -1227,7 +1183,7 @@ ehspec_filter_hash (const void *pentry)\n   return h;\n }\n \n-/* Add TYPE (which may be NULL) to cfun->eh->ttype_data, using TYPES_HASH\n+/* Add TYPE (which may be NULL) to crtl->eh.ttype_data, using TYPES_HASH\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n@@ -1244,16 +1200,16 @@ add_ttypes_entry (htab_t ttypes_hash, tree type)\n \n       n = XNEW (struct ttypes_filter);\n       n->t = type;\n-      n->filter = VEC_length (tree, cfun->eh->ttype_data) + 1;\n+      n->filter = VEC_length (tree, crtl->eh.ttype_data) + 1;\n       *slot = n;\n \n-      VEC_safe_push (tree, gc, cfun->eh->ttype_data, type);\n+      VEC_safe_push (tree, gc, crtl->eh.ttype_data, type);\n     }\n \n   return n->filter;\n }\n \n-/* Add LIST to cfun->eh->ehspec_data, using EHSPEC_HASH and TYPES_HASH\n+/* Add LIST to crtl->eh.ehspec_data, using EHSPEC_HASH and TYPES_HASH\n    to speed up the search.  Return the filter value to be used.  */\n \n static int\n@@ -1272,26 +1228,26 @@ add_ehspec_entry (htab_t ehspec_hash, htab_t ttypes_hash, tree list)\n \n       n = XNEW (struct ttypes_filter);\n       n->t = list;\n-      n->filter = -(VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) + 1);\n+      n->filter = -(VARRAY_ACTIVE_SIZE (crtl->eh.ehspec_data) + 1);\n       *slot = n;\n \n       /* Generate a 0 terminated list of filter values.  */\n       for (; list ; list = TREE_CHAIN (list))\n \t{\n \t  if (targetm.arm_eabi_unwinder)\n-\t    VARRAY_PUSH_TREE (cfun->eh->ehspec_data, TREE_VALUE (list));\n+\t    VARRAY_PUSH_TREE (crtl->eh.ehspec_data, TREE_VALUE (list));\n \t  else\n \t    {\n \t      /* Look up each type in the list and encode its filter\n \t\t value as a uleb128.  */\n-\t      push_uleb128 (&cfun->eh->ehspec_data,\n+\t      push_uleb128 (&crtl->eh.ehspec_data,\n \t\t  add_ttypes_entry (ttypes_hash, TREE_VALUE (list)));\n \t    }\n \t}\n       if (targetm.arm_eabi_unwinder)\n-\tVARRAY_PUSH_TREE (cfun->eh->ehspec_data, NULL_TREE);\n+\tVARRAY_PUSH_TREE (crtl->eh.ehspec_data, NULL_TREE);\n       else\n-\tVARRAY_PUSH_UCHAR (cfun->eh->ehspec_data, 0);\n+\tVARRAY_PUSH_UCHAR (crtl->eh.ehspec_data, 0);\n     }\n \n   return n->filter;\n@@ -1308,11 +1264,11 @@ assign_filter_values (void)\n   int i;\n   htab_t ttypes, ehspec;\n \n-  cfun->eh->ttype_data = VEC_alloc (tree, gc, 16);\n+  crtl->eh.ttype_data = VEC_alloc (tree, gc, 16);\n   if (targetm.arm_eabi_unwinder)\n-    VARRAY_TREE_INIT (cfun->eh->ehspec_data, 64, \"ehspec_data\");\n+    VARRAY_TREE_INIT (crtl->eh.ehspec_data, 64, \"ehspec_data\");\n   else\n-    VARRAY_UCHAR_INIT (cfun->eh->ehspec_data, 64, \"ehspec_data\");\n+    VARRAY_UCHAR_INIT (crtl->eh.ehspec_data, 64, \"ehspec_data\");\n \n   ttypes = htab_create (31, ttypes_filter_hash, ttypes_filter_eq, free);\n   ehspec = htab_create (31, ehspec_filter_hash, ehspec_filter_eq, free);\n@@ -1457,7 +1413,7 @@ build_post_landing_pads (void)\n \t\t    for (; tp_node; )\n \t\t      {\n \t\t\temit_cmp_and_jump_insns\n-\t\t\t  (cfun->eh->filter,\n+\t\t\t  (crtl->eh.filter,\n \t\t\t   GEN_INT (tree_low_cst (TREE_VALUE (flt_node), 0)),\n \t\t\t   EQ, NULL_RTX,\n \t\t\t   targetm.eh_return_filter_mode (), 0, c->label);\n@@ -1490,7 +1446,7 @@ build_post_landing_pads (void)\n \n \t  emit_label (region->post_landing_pad);\n \n-\t  emit_cmp_and_jump_insns (cfun->eh->filter,\n+\t  emit_cmp_and_jump_insns (crtl->eh.filter,\n \t\t\t\t   GEN_INT (region->u.allowed.filter),\n \t\t\t\t   EQ, NULL_RTX,\n \t\t\t\t   targetm.eh_return_filter_mode (), 0, region->label);\n@@ -1573,7 +1529,7 @@ connect_post_landing_pads (void)\n       else\n \t{\n \t  emit_library_call (unwind_resume_libfunc, LCT_THROW,\n-\t\t\t     VOIDmode, 1, cfun->eh->exc_ptr, ptr_mode);\n+\t\t\t     VOIDmode, 1, crtl->eh.exc_ptr, ptr_mode);\n \n \t  /* What we just emitted was a throwing libcall, so it got a\n \t     barrier automatically added after it.  If the last insn in\n@@ -1643,9 +1599,9 @@ dw2_build_landing_pads (void)\n #endif\n \t  { /* Nothing */ }\n \n-      emit_move_insn (cfun->eh->exc_ptr,\n+      emit_move_insn (crtl->eh.exc_ptr,\n \t\t      gen_rtx_REG (ptr_mode, EH_RETURN_DATA_REGNO (0)));\n-      emit_move_insn (cfun->eh->filter,\n+      emit_move_insn (crtl->eh.filter,\n \t\t      gen_rtx_REG (targetm.eh_return_filter_mode (),\n \t\t\t\t   EH_RETURN_DATA_REGNO (1)));\n \n@@ -1724,7 +1680,7 @@ sjlj_assign_call_site_values (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n \n   /* First task: build the action table.  */\n \n-  VARRAY_UCHAR_INIT (cfun->eh->action_record_data, 64, \"action_record_data\");\n+  VARRAY_UCHAR_INIT (crtl->eh.action_record_data, 64, \"action_record_data\");\n   ar_hash = htab_create (31, action_record_hash, action_record_eq, free);\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n@@ -1830,7 +1786,7 @@ sjlj_mark_call_sites (struct sjlj_lp_info *lp_info)\n \tbefore = find_first_parameter_load (insn, NULL_RTX);\n \n       start_sequence ();\n-      mem = adjust_address (cfun->eh->sjlj_fc, TYPE_MODE (integer_type_node),\n+      mem = adjust_address (crtl->eh.sjlj_fc, TYPE_MODE (integer_type_node),\n \t\t\t    sjlj_fc_call_site_ofs);\n       emit_move_insn (mem, GEN_INT (this_call_site));\n       p = get_insns ();\n@@ -1849,7 +1805,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n   rtx fn_begin, fc, mem, seq;\n   bool fn_begin_outside_block;\n \n-  fc = cfun->eh->sjlj_fc;\n+  fc = crtl->eh.sjlj_fc;\n \n   start_sequence ();\n \n@@ -1923,7 +1879,7 @@ sjlj_emit_function_enter (rtx dispatch_label)\n void\n sjlj_emit_function_exit_after (rtx after)\n {\n-  cfun->eh->sjlj_exit_after = after;\n+  crtl->eh.sjlj_exit_after = after;\n }\n \n static void\n@@ -1936,7 +1892,7 @@ sjlj_emit_function_exit (void)\n   start_sequence ();\n \n   emit_library_call (unwind_sjlj_unregister_libfunc, LCT_NORMAL, VOIDmode,\n-\t\t     1, XEXP (cfun->eh->sjlj_fc, 0), Pmode);\n+\t\t     1, XEXP (crtl->eh.sjlj_fc, 0), Pmode);\n \n   seq = get_insns ();\n   end_sequence ();\n@@ -1958,7 +1914,7 @@ sjlj_emit_function_exit (void)\n       gcc_assert (e->src->next_bb == EXIT_BLOCK_PTR);\n       for (insn = BB_HEAD (e->src); ; insn = NEXT_INSN (insn))\n \t{\n-\t  if (insn == cfun->eh->sjlj_exit_after)\n+\t  if (insn == crtl->eh.sjlj_exit_after)\n \t    {\n \t      if (LABEL_P (insn))\n \t\tinsn = NEXT_INSN (insn);\n@@ -1981,7 +1937,7 @@ sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n   basic_block bb;\n   edge e;\n \n-  fc = cfun->eh->sjlj_fc;\n+  fc = crtl->eh.sjlj_fc;\n \n   start_sequence ();\n \n@@ -2006,10 +1962,10 @@ sjlj_emit_dispatch_table (rtx dispatch_label, struct sjlj_lp_info *lp_info)\n       mem = convert_to_mode (ptr_mode, mem, 0);\n #endif\n     }\n-  emit_move_insn (cfun->eh->exc_ptr, mem);\n+  emit_move_insn (crtl->eh.exc_ptr, mem);\n \n   mem = adjust_address (fc, word_mode, sjlj_fc_data_ofs + UNITS_PER_WORD);\n-  emit_move_insn (cfun->eh->filter, mem);\n+  emit_move_insn (crtl->eh.filter, mem);\n \n   /* Jump to one of the directly reachable regions.  */\n   /* ??? This really ought to be using a switch statement.  */\n@@ -2055,7 +2011,7 @@ sjlj_build_landing_pads (void)\n     {\n       rtx dispatch_label = gen_label_rtx ();\n \n-      cfun->eh->sjlj_fc\n+      crtl->eh.sjlj_fc\n \t= assign_stack_local (TYPE_MODE (sjlj_fc_type_node),\n \t\t\t      int_size_in_bytes (sjlj_fc_type_node),\n \t\t\t      TYPE_ALIGN (sjlj_fc_type_node));\n@@ -2091,8 +2047,8 @@ finish_eh_generation (void)\n \n   /* These registers are used by the landing pads.  Make sure they\n      have been generated.  */\n-  get_exception_pointer (cfun);\n-  get_exception_filter (cfun);\n+  get_exception_pointer ();\n+  get_exception_filter ();\n \n   /* Construct the landing pads.  */\n \n@@ -2104,7 +2060,7 @@ finish_eh_generation (void)\n   else\n     dw2_build_landing_pads ();\n \n-  cfun->eh->built_landing_pads = 1;\n+  crtl->eh.built_landing_pads = 1;\n \n   /* We've totally changed the CFG.  Start over.  */\n   find_exception_handler_labels ();\n@@ -2166,15 +2122,15 @@ remove_exception_handler_label (rtx label)\n \n   /* If exception_handler_label_map was not built yet,\n      there is nothing to do.  */\n-  if (cfun->eh->exception_handler_label_map == NULL)\n+  if (crtl->eh.exception_handler_label_map == NULL)\n     return;\n \n   tmp.label = label;\n   slot = (struct ehl_map_entry **)\n-    htab_find_slot (cfun->eh->exception_handler_label_map, &tmp, NO_INSERT);\n+    htab_find_slot (crtl->eh.exception_handler_label_map, &tmp, NO_INSERT);\n   gcc_assert (slot);\n \n-  htab_clear_slot (cfun->eh->exception_handler_label_map, (void **) slot);\n+  htab_clear_slot (crtl->eh.exception_handler_label_map, (void **) slot);\n }\n \n /* Splice REGION from the region tree etc.  */\n@@ -2213,7 +2169,7 @@ remove_eh_handler (struct eh_region *region)\n       bitmap_set_bit (outer->aka, region->region_number);\n     }\n \n-  if (cfun->eh->built_landing_pads)\n+  if (crtl->eh.built_landing_pads)\n     lab = region->landing_pad;\n   else\n     lab = region->label;\n@@ -2281,12 +2237,12 @@ maybe_remove_eh_handler (rtx label)\n      if the region data is completely unused.  One must examine the\n      landing pad and the post landing pad, and whether an inner try block\n      is referencing the catch handlers directly.  */\n-  if (cfun->eh->built_landing_pads)\n+  if (crtl->eh.built_landing_pads)\n     return;\n \n   tmp.label = label;\n   slot = (struct ehl_map_entry **)\n-    htab_find_slot (cfun->eh->exception_handler_label_map, &tmp, NO_INSERT);\n+    htab_find_slot (crtl->eh.exception_handler_label_map, &tmp, NO_INSERT);\n   if (! slot)\n     return;\n   region = (*slot)->region;\n@@ -2299,7 +2255,7 @@ maybe_remove_eh_handler (rtx label)\n      are no more contained calls, which we don't see here.  */\n   if (region->type == ERT_MUST_NOT_THROW)\n     {\n-      htab_clear_slot (cfun->eh->exception_handler_label_map, (void **) slot);\n+      htab_clear_slot (crtl->eh.exception_handler_label_map, (void **) slot);\n       region->label = NULL_RTX;\n     }\n   else\n@@ -2312,7 +2268,7 @@ maybe_remove_eh_handler (rtx label)\n void\n for_each_eh_label (void (*callback) (rtx))\n {\n-  htab_traverse (cfun->eh->exception_handler_label_map, for_each_eh_label_1,\n+  htab_traverse (crtl->eh.exception_handler_label_map, for_each_eh_label_1,\n \t\t (void *) &callback);\n }\n \n@@ -2396,7 +2352,7 @@ add_reachable_handler (struct reachable_info *info,\n \n   info->saw_any_handlers = true;\n \n-  if (cfun->eh->built_landing_pads)\n+  if (crtl->eh.built_landing_pads)\n     info->callback (lp_region, info->callback_data);\n   else\n     info->callback (region, info->callback_data);\n@@ -2658,7 +2614,7 @@ reachable_handlers (rtx insn)\n     }\n \n   foreach_reachable_handler (region_number, is_resx,\n-\t\t\t     (cfun->eh->built_landing_pads\n+\t\t\t     (crtl->eh.built_landing_pads\n \t\t\t      ? arh_to_landing_pad\n \t\t\t      : arh_to_label),\n \t\t\t     &handlers);\n@@ -2966,34 +2922,34 @@ expand_builtin_eh_return (tree stackadj_tree ATTRIBUTE_UNUSED,\n   rtx tmp;\n \n #ifdef EH_RETURN_STACKADJ_RTX\n-  tmp = expand_expr (stackadj_tree, cfun->eh->ehr_stackadj,\n+  tmp = expand_expr (stackadj_tree, crtl->eh.ehr_stackadj,\n \t\t     VOIDmode, EXPAND_NORMAL);\n   tmp = convert_memory_address (Pmode, tmp);\n-  if (!cfun->eh->ehr_stackadj)\n-    cfun->eh->ehr_stackadj = copy_to_reg (tmp);\n-  else if (tmp != cfun->eh->ehr_stackadj)\n-    emit_move_insn (cfun->eh->ehr_stackadj, tmp);\n+  if (!crtl->eh.ehr_stackadj)\n+    crtl->eh.ehr_stackadj = copy_to_reg (tmp);\n+  else if (tmp != crtl->eh.ehr_stackadj)\n+    emit_move_insn (crtl->eh.ehr_stackadj, tmp);\n #endif\n \n-  tmp = expand_expr (handler_tree, cfun->eh->ehr_handler,\n+  tmp = expand_expr (handler_tree, crtl->eh.ehr_handler,\n \t\t     VOIDmode, EXPAND_NORMAL);\n   tmp = convert_memory_address (Pmode, tmp);\n-  if (!cfun->eh->ehr_handler)\n-    cfun->eh->ehr_handler = copy_to_reg (tmp);\n-  else if (tmp != cfun->eh->ehr_handler)\n-    emit_move_insn (cfun->eh->ehr_handler, tmp);\n+  if (!crtl->eh.ehr_handler)\n+    crtl->eh.ehr_handler = copy_to_reg (tmp);\n+  else if (tmp != crtl->eh.ehr_handler)\n+    emit_move_insn (crtl->eh.ehr_handler, tmp);\n \n-  if (!cfun->eh->ehr_label)\n-    cfun->eh->ehr_label = gen_label_rtx ();\n-  emit_jump (cfun->eh->ehr_label);\n+  if (!crtl->eh.ehr_label)\n+    crtl->eh.ehr_label = gen_label_rtx ();\n+  emit_jump (crtl->eh.ehr_label);\n }\n \n void\n expand_eh_return (void)\n {\n   rtx around_label;\n \n-  if (! cfun->eh->ehr_label)\n+  if (! crtl->eh.ehr_label)\n     return;\n \n   current_function_calls_eh_return = 1;\n@@ -3005,21 +2961,21 @@ expand_eh_return (void)\n   around_label = gen_label_rtx ();\n   emit_jump (around_label);\n \n-  emit_label (cfun->eh->ehr_label);\n+  emit_label (crtl->eh.ehr_label);\n   clobber_return_register ();\n \n #ifdef EH_RETURN_STACKADJ_RTX\n-  emit_move_insn (EH_RETURN_STACKADJ_RTX, cfun->eh->ehr_stackadj);\n+  emit_move_insn (EH_RETURN_STACKADJ_RTX, crtl->eh.ehr_stackadj);\n #endif\n \n #ifdef HAVE_eh_return\n   if (HAVE_eh_return)\n-    emit_insn (gen_eh_return (cfun->eh->ehr_handler));\n+    emit_insn (gen_eh_return (crtl->eh.ehr_handler));\n   else\n #endif\n     {\n #ifdef EH_RETURN_HANDLER_RTX\n-      emit_move_insn (EH_RETURN_HANDLER_RTX, cfun->eh->ehr_handler);\n+      emit_move_insn (EH_RETURN_HANDLER_RTX, crtl->eh.ehr_handler);\n #else\n       error (\"__builtin_eh_return not supported on this target\");\n #endif\n@@ -3093,7 +3049,7 @@ add_action_record (htab_t ar_hash, int filter, int next)\n   if ((new = *slot) == NULL)\n     {\n       new = xmalloc (sizeof (*new));\n-      new->offset = VARRAY_ACTIVE_SIZE (cfun->eh->action_record_data) + 1;\n+      new->offset = VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data) + 1;\n       new->filter = filter;\n       new->next = next;\n       *slot = new;\n@@ -3103,10 +3059,10 @@ add_action_record (htab_t ar_hash, int filter, int next)\n \t that there is no next record.  So convert the absolute 1 based\n \t indices we've been carrying around into a displacement.  */\n \n-      push_sleb128 (&cfun->eh->action_record_data, filter);\n+      push_sleb128 (&crtl->eh.action_record_data, filter);\n       if (next)\n-\tnext -= VARRAY_ACTIVE_SIZE (cfun->eh->action_record_data) + 1;\n-      push_sleb128 (&cfun->eh->action_record_data, next);\n+\tnext -= VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data) + 1;\n+      push_sleb128 (&crtl->eh.action_record_data, next);\n     }\n \n   return new->offset;\n@@ -3226,24 +3182,15 @@ collect_one_action_chain (htab_t ar_hash, struct eh_region *region)\n static int\n add_call_site (rtx landing_pad, int action)\n {\n-  struct call_site_record *data = cfun->eh->call_site_data;\n-  int used = cfun->eh->call_site_data_used;\n-  int size = cfun->eh->call_site_data_size;\n+  call_site_record record;\n+  \n+  record = ggc_alloc (sizeof (struct call_site_record));\n+  record->landing_pad = landing_pad;\n+  record->action = action;\n \n-  if (used >= size)\n-    {\n-      size = (size ? size * 2 : 64);\n-      data = ggc_realloc (data, sizeof (*data) * size);\n-      cfun->eh->call_site_data = data;\n-      cfun->eh->call_site_data_size = size;\n-    }\n+  VEC_safe_push (call_site_record, gc, crtl->eh.call_site_record, record);\n \n-  data[used].landing_pad = landing_pad;\n-  data[used].action = action;\n-\n-  cfun->eh->call_site_data_used = used + 1;\n-\n-  return used + call_site_base;\n+  return call_site_base + VEC_length (call_site_record, crtl->eh.call_site_record) - 1;\n }\n \n /* Turn REG_EH_REGION notes back into NOTE_INSN_EH_REGION notes.\n@@ -3264,7 +3211,7 @@ convert_to_eh_region_ranges (void)\n   if (USING_SJLJ_EXCEPTIONS || cfun->eh->region_tree == NULL)\n     return 0;\n \n-  VARRAY_UCHAR_INIT (cfun->eh->action_record_data, 64, \"action_record_data\");\n+  VARRAY_UCHAR_INIT (crtl->eh.action_record_data, 64, \"action_record_data\");\n \n   ar_hash = htab_create (31, action_record_hash, action_record_eq, free);\n \n@@ -3466,12 +3413,12 @@ sjlj_size_of_call_site_table (void)\n static void\n dw2_output_call_site_table (void)\n {\n-  int n = cfun->eh->call_site_data_used;\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record *cs = &cfun->eh->call_site_data[i];\n+      struct call_site_record *cs = VEC_index (call_site_record, crtl->eh.call_site_record, i);\n       char reg_start_lab[32];\n       char reg_end_lab[32];\n       char landing_pad_lab[32];\n@@ -3520,12 +3467,12 @@ dw2_output_call_site_table (void)\n static void\n sjlj_output_call_site_table (void)\n {\n-  int n = cfun->eh->call_site_data_used;\n+  int n = VEC_length (call_site_record, crtl->eh.call_site_record);\n   int i;\n \n   for (i = 0; i < n; ++i)\n     {\n-      struct call_site_record *cs = &cfun->eh->call_site_data[i];\n+      struct call_site_record *cs = VEC_index (call_site_record, crtl->eh.call_site_record, i);\n \n       dw2_asm_output_data_uleb128 (INTVAL (cs->landing_pad),\n \t\t\t\t   \"region %d landing pad\", i);\n@@ -3672,8 +3619,8 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n   /* If the target wants a label to begin the table, emit it here.  */\n   targetm.asm_out.except_table_label (asm_out_file);\n \n-  have_tt_data = (VEC_length (tree, cfun->eh->ttype_data) > 0\n-\t\t  || VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) > 0);\n+  have_tt_data = (VEC_length (tree, crtl->eh.ttype_data) > 0\n+\t\t  || VARRAY_ACTIVE_SIZE (crtl->eh.ehspec_data) > 0);\n \n   /* Indicate the format of the @TType entries.  */\n   if (! have_tt_data)\n@@ -3734,8 +3681,8 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n       before_disp = 1 + 1;\n       after_disp = (1 + size_of_uleb128 (call_site_len)\n \t\t    + call_site_len\n-\t\t    + VARRAY_ACTIVE_SIZE (cfun->eh->action_record_data)\n-\t\t    + (VEC_length (tree, cfun->eh->ttype_data)\n+\t\t    + VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data)\n+\t\t    + (VEC_length (tree, crtl->eh.ttype_data)\n \t\t       * tt_format_size));\n \n       disp = after_disp;\n@@ -3789,18 +3736,18 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n #endif\n \n   /* ??? Decode and interpret the data for flag_debug_asm.  */\n-  n = VARRAY_ACTIVE_SIZE (cfun->eh->action_record_data);\n+  n = VARRAY_ACTIVE_SIZE (crtl->eh.action_record_data);\n   for (i = 0; i < n; ++i)\n-    dw2_asm_output_data (1, VARRAY_UCHAR (cfun->eh->action_record_data, i),\n+    dw2_asm_output_data (1, VARRAY_UCHAR (crtl->eh.action_record_data, i),\n \t\t\t (i ? NULL : \"Action record table\"));\n \n   if (have_tt_data)\n     assemble_align (tt_format_size * BITS_PER_UNIT);\n \n-  i = VEC_length (tree, cfun->eh->ttype_data);\n+  i = VEC_length (tree, crtl->eh.ttype_data);\n   while (i-- > 0)\n     {\n-      tree type = VEC_index (tree, cfun->eh->ttype_data, i);\n+      tree type = VEC_index (tree, crtl->eh.ttype_data, i);\n       output_ttype (type, tt_format, tt_format_size);\n     }\n \n@@ -3810,16 +3757,16 @@ output_function_exception_table (const char * ARG_UNUSED (fnname))\n #endif\n \n   /* ??? Decode and interpret the data for flag_debug_asm.  */\n-  n = VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data);\n+  n = VARRAY_ACTIVE_SIZE (crtl->eh.ehspec_data);\n   for (i = 0; i < n; ++i)\n     {\n       if (targetm.arm_eabi_unwinder)\n \t{\n-\t  tree type = VARRAY_TREE (cfun->eh->ehspec_data, i);\n+\t  tree type = VARRAY_TREE (crtl->eh.ehspec_data, i);\n \t  output_ttype (type, tt_format, tt_format_size);\n \t}\n       else\n-\tdw2_asm_output_data (1, VARRAY_UCHAR (cfun->eh->ehspec_data, i),\n+\tdw2_asm_output_data (1, VARRAY_UCHAR (crtl->eh.ehspec_data, i),\n \t\t\t     (i ? NULL : \"Exception specification table\"));\n     }\n "}, {"sha": "ba6f5929dd2da08a9df40fef4922e5a57a78fac5", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -35,7 +35,6 @@ extern int doing_eh (int);\n /* Note that the current EH region (if any) may contain a throw, or a\n    call to a function which itself may contain a throw.  */\n extern void note_eh_region_may_contain_throw (struct eh_region *);\n-extern void note_current_region_may_contain_throw (void);\n \n /* Invokes CALLBACK for every exception handler label.  Only used by old\n    loop hackery; should not be used by new code.  */\n@@ -78,8 +77,8 @@ extern rtx expand_builtin_dwarf_sp_column (void);\n extern void expand_builtin_eh_return (tree, tree);\n extern void expand_eh_return (void);\n extern rtx expand_builtin_extend_pointer (tree);\n-extern rtx get_exception_pointer (struct function *);\n-extern rtx get_exception_filter (struct function *);\n+extern rtx get_exception_pointer (void);\n+extern rtx get_exception_filter (void);\n typedef tree (*duplicate_eh_regions_map) (tree, void *);\n extern int duplicate_eh_regions (struct function *, duplicate_eh_regions_map,\n \t\t\t\t void *, int, int);"}, {"sha": "71b356be2bd5dfdb7c4ca473e9612e67a7605825", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -9180,10 +9180,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return const0_rtx;\n \n     case EXC_PTR_EXPR:\n-      return get_exception_pointer (cfun);\n+      return get_exception_pointer ();\n \n     case FILTER_EXPR:\n-      return get_exception_filter (cfun);\n+      return get_exception_filter ();\n \n     case FDESC_EXPR:\n       /* Function descriptors are not valid except for as"}, {"sha": "1fe6d6a51eabe4c87cc05e0b743768aabf0bf6ed", "filename": "gcc/function.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"tree.h\"\n #include \"hashtab.h\"\n+#include \"varray.h\"\n \n /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n    Each element describes one pending sequence.\n@@ -136,6 +137,34 @@ struct expr_status GTY(())\n   rtx x_forced_labels;\n };\n \n+typedef struct call_site_record *call_site_record;\n+DEF_VEC_P(call_site_record);\n+DEF_VEC_ALLOC_P(call_site_record, gc);\n+\n+/* RTL representation of exception handling.  */\n+struct rtl_eh GTY(())\n+{\n+  rtx filter;\n+  rtx exc_ptr;\n+\n+  int built_landing_pads;\n+\n+  rtx ehr_stackadj;\n+  rtx ehr_handler;\n+  rtx ehr_label;\n+\n+  rtx sjlj_fc;\n+  rtx sjlj_exit_after;\n+\n+  htab_t GTY ((param_is (struct ehl_map_entry))) exception_handler_label_map;\n+\n+  VEC(tree,gc) *ttype_data;\n+  varray_type ehspec_data;\n+  varray_type action_record_data;\n+\n+  VEC(call_site_record,gc) *call_site_record;\n+};\n+\n #define pending_stack_adjust (crtl->expr.x_pending_stack_adjust)\n #define inhibit_defer_pop (crtl->expr.x_inhibit_defer_pop)\n #define saveregs_value (crtl->expr.x_saveregs_value)\n@@ -146,6 +175,7 @@ struct expr_status GTY(())\n struct gimple_df;\n struct temp_slot;\n typedef struct temp_slot *temp_slot_p;\n+struct call_site_record;\n \n DEF_VEC_P(temp_slot_p);\n DEF_VEC_ALLOC_P(temp_slot_p,gc);\n@@ -227,6 +257,7 @@ struct rtl_data GTY(())\n   struct varasm_status varasm;\n   struct incoming_args args;\n   struct function_subsections subsections;\n+  struct rtl_eh eh;\n \n   /* For function.c  */\n "}, {"sha": "bce0c3df79fd2884c5d341fbc65f64e55f01cd4b", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69c32ec801a7b3b42778231b8187e77b8c63d0f2/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=69c32ec801a7b3b42778231b8187e77b8c63d0f2", "patch": "@@ -2980,6 +2980,8 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \t\tskip_p = 1;\n \t      else if (strcmp (o->name, \"desc\") == 0)\n \t\tdesc = o->info;\n+\t      else if (strcmp (o->name, \"param_is\") == 0)\n+\t\t;\n \t      else\n \t\terror_at_line (line,\n \t\t       \"field `%s' of global `%s' has unknown option `%s'\","}]}