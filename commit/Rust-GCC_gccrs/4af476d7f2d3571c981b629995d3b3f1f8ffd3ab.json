{"sha": "4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmNDc2ZDdmMmQzNTcxYzk4MWI2Mjk5OTVkM2IzZjFmOGZmZDNhYg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2010-10-14T09:12:50Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2010-10-14T09:12:50Z"}, "message": "mn10300.h (CONSTANT_ALIGNMENT): Define.\n\n        * config/mn10300/mn10300.h (CONSTANT_ALIGNMENT): Define.\n        (DATA_ALIGNMENT, LOCAL_ALIGNMENT): Define.\n        (FIRST_PSEUDO_REGISTER): Increase by one.\n        (FIXED_REGISTERS, CALL_USED_REGISTERS): Update with CC_REG.\n        (HARD_REGNO_MODE_OK): Call mn10300_hard_regno_mode_ok.\n        (MODES_TIEABLE): Call mn10300_modes_tieable.\n        (REG_CLASS_NAMES, REG_CLASS_CONTENTS, REGNO_REG_CLASS): Add\n        CC_REGS.\n        (LEGITIMATE_CONSTANT_P): Call mn10300_legitimate_constant_p.\n        (CC_OVERFLOW_UNUSABLE, CC_NO_CARRY, NOTICE_UPDATE_CC)\n        (SELECT_CC_MODE, REVERSIBLE_CC_MODE): Delete.\n        (REGISTER_NAMES, ADDITIONAL_REGISTER_NAMES): Add CC register.\n        (ASM_OUTPUT_REG_PUSH, ASM_OUTPUT_REG_POP): Delete.\n        (mn10300_cc_status_mdep): Delete.\n        (CC_STATUS_MDEP, CC_STATUS_MDEP_INIT): Delete.\n        * config/mn10300/mn10300 (mn10300_option_override): Stop disabling\n        the combine-stack-adjust pass.\n        (print_operand): Use the mode of the comparison operation to\n        select the comparison suffix.\n        (notice_update_cc): Delete.\n        (mn10300_secondary_reload_class): Remove test for stack pointer\n        based arithmetic.\n        (output_tst): Rename to mn10300_output_cmp.\n        (impossible_plus_operand): Move into predicates.md.\n        (mn10300_legitimize_address): Make static.\n        (mn10300_legitimate_address_p): Make static.  Only allow SI sized\n        constant pic operands.\n        (mn10300_legitimate_constant_p): New function.\n        (mn10300_case_values_threshold): Make static.\n        (mn10300_hard_regno_mode_ok): New function.\n        (mn10300_modes_tieable): New function.\n        (mn10300_select_cc_mode): New function.\n        * config/mn10300/predicates.md (impossible_plus_operand): Define.\n        * config/mn10300/mn10300-protos.h: Tidy.\n        (mn10300_legitimate_constant_p, mn10300_modes_tieable)\n        (mn10300_hard_regno_mode_ok, mn10300_select_cc_mode): Prototype.\n        * config/mn10300/mn10300.md (cc attribute): Delete.  Replace\n        with clobbers or sets of CC_REG.\n        (CC_REG): Define.\n        (mov*): Remove use of CLR instruction.\n        (cbranch_si4_<code>): New pattern/split.\n        (integer_conditional_branch): New pattern.\n        (cbranch_sf4_<code>): New pattern/split.\n        (float_conditional_branch): New pattern.\n        (casesi): Use addsi3 pattern instead of movsi pattern to add and\n        move a value at the same time.\n        (cc0 peepholes): Remove.\n\nFrom-SVN: r165459", "tree": {"sha": "f5a7e3c93c53f2ffc4de04c342a01a3a31818c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5a7e3c93c53f2ffc4de04c342a01a3a31818c9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6203e21acbf78549af3d0884b8ad611b8e41891e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6203e21acbf78549af3d0884b8ad611b8e41891e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6203e21acbf78549af3d0884b8ad611b8e41891e"}], "stats": {"total": 1904, "additions": 1074, "deletions": 830}, "files": [{"sha": "470849bbc75938b6a38357b9f1d0f5977949919a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "patch": "@@ -1,3 +1,53 @@\n+2010-10-14  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/mn10300/mn10300.h (CONSTANT_ALIGNMENT): Define.\n+\t(DATA_ALIGNMENT, LOCAL_ALIGNMENT): Define.\n+\t(FIRST_PSEUDO_REGISTER): Increase by one.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Update with CC_REG.\n+\t(HARD_REGNO_MODE_OK): Call mn10300_hard_regno_mode_ok.\n+\t(MODES_TIEABLE): Call mn10300_modes_tieable.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS, REGNO_REG_CLASS): Add\n+\tCC_REGS.\n+\t(LEGITIMATE_CONSTANT_P): Call mn10300_legitimate_constant_p.\n+\t(CC_OVERFLOW_UNUSABLE, CC_NO_CARRY, NOTICE_UPDATE_CC)\n+\t(SELECT_CC_MODE, REVERSIBLE_CC_MODE): Delete.\n+\t(REGISTER_NAMES, ADDITIONAL_REGISTER_NAMES): Add CC register.\n+\t(ASM_OUTPUT_REG_PUSH, ASM_OUTPUT_REG_POP): Delete.\n+\t(mn10300_cc_status_mdep): Delete.\n+\t(CC_STATUS_MDEP, CC_STATUS_MDEP_INIT): Delete.\n+\t* config/mn10300/mn10300 (mn10300_option_override): Stop disabling\n+\tthe combine-stack-adjust pass.\n+\t(print_operand): Use the mode of the comparison operation to\n+\tselect the comparison suffix.\n+\t(notice_update_cc): Delete.\n+\t(mn10300_secondary_reload_class): Remove test for stack pointer\n+\tbased arithmetic.\n+\t(output_tst): Rename to mn10300_output_cmp.\n+\t(impossible_plus_operand): Move into predicates.md.\n+\t(mn10300_legitimize_address): Make static.\n+\t(mn10300_legitimate_address_p): Make static.  Only allow SI sized\n+\tconstant pic operands.\n+\t(mn10300_legitimate_constant_p): New function.\n+\t(mn10300_case_values_threshold): Make static.\n+\t(mn10300_hard_regno_mode_ok): New function.\n+\t(mn10300_modes_tieable): New function.\n+\t(mn10300_select_cc_mode): New function.\n+\t* config/mn10300/predicates.md (impossible_plus_operand): Define.\n+\t* config/mn10300/mn10300-protos.h: Tidy.\n+\t(mn10300_legitimate_constant_p, mn10300_modes_tieable)\n+\t(mn10300_hard_regno_mode_ok, mn10300_select_cc_mode): Prototype.\n+\t* config/mn10300/mn10300.md (cc attribute): Delete.  Replace\n+\twith clobbers or sets of CC_REG.\n+\t(CC_REG): Define.\n+\t(mov*): Remove use of CLR instruction.\n+\t(cbranch_si4_<code>): New pattern/split.\n+\t(integer_conditional_branch): New pattern.\n+\t(cbranch_sf4_<code>): New pattern/split.\n+\t(float_conditional_branch): New\tpattern.\n+\t(casesi): Use addsi3 pattern instead of movsi pattern to add and\n+\tmove a value at the same time.\n+\t(cc0 peepholes): Remove.\n+\n 2010-10-14  Andrey Belevantsev  <abel@ispras.ru>\n \n \t* sel-sched-ir.c (init_global_and_expr_for_insn): Set CANT_MOVE"}, {"sha": "1e0f18e6b736cb159d1d7022d534b6a4d52e4aac", "filename": "gcc/config/mn10300/mn10300-protos.h", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300-protos.h?ref=4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "patch": "@@ -19,35 +19,40 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-#ifdef RTX_CODE\n+#define Mmode enum machine_mode\n+#define Cstar const char *\n+#define Rclas enum reg_class\n \n-extern rtx legitimize_pic_address (rtx, rtx);\n-extern int legitimate_pic_operand_p (rtx);\n-extern void print_operand (FILE *, rtx, int);\n-extern void print_operand_address (FILE *, rtx);\n-extern void mn10300_print_reg_list (FILE *, int);\n-extern int mn10300_get_live_callee_saved_regs (void);\n-extern void mn10300_gen_multiple_store (int);\n-extern void notice_update_cc (rtx, rtx);\n-extern enum reg_class mn10300_secondary_reload_class (enum reg_class,\n-\t\t\t\t\t\t      enum machine_mode, rtx);\n-extern const char *output_tst (rtx, rtx);\n-extern int store_multiple_operation (rtx, enum machine_mode);\n-extern int symbolic_operand (rtx, enum machine_mode);\n-extern int impossible_plus_operand (rtx, enum machine_mode);\n-\n-extern bool mn10300_wide_const_load_uses_clr (rtx operands[2]);\n-\n-extern bool mn10300_function_value_regno_p (const unsigned int);\n+#ifdef RTX_CODE\n+extern rtx   legitimize_pic_address (rtx, rtx);\n+extern int   legitimate_pic_operand_p (rtx);\n+extern bool  mn10300_function_value_regno_p (const unsigned int);\n+extern void  mn10300_gen_multiple_store (int);\n+extern int   mn10300_get_live_callee_saved_regs (void);\n+extern bool  mn10300_hard_regno_mode_ok (unsigned int, Mmode);\n+extern bool  mn10300_legitimate_constant_p (rtx);\n+extern bool  mn10300_modes_tieable (Mmode, Mmode);\n+extern Cstar mn10300_output_cmp (rtx, rtx);\n+extern void  mn10300_print_reg_list (FILE *, int);\n+extern Rclas mn10300_secondary_reload_class (Rclas, Mmode, rtx);\n+extern Mmode mn10300_select_cc_mode (rtx);\n+extern bool  mn10300_wide_const_load_uses_clr (rtx operands[2]);\n+extern void  print_operand (FILE *, rtx, int);\n+extern void  print_operand_address (FILE *, rtx);\n+extern int   store_multiple_operation (rtx, Mmode);\n+extern int   symbolic_operand (rtx, Mmode);\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern struct rtx_def *function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t     enum machine_mode, tree, int);\n+extern struct rtx_def *function_arg (CUMULATIVE_ARGS *, Mmode, tree, int);\n #endif /* TREE_CODE */\n \n-extern void expand_prologue (void);\n-extern void expand_epilogue (void);\n-extern int initial_offset (int, int);\n-extern int can_use_return_insn (void);\n-extern int mask_ok_for_mem_btst (int, int);\n+extern int   can_use_return_insn (void);\n+extern void  expand_prologue (void);\n+extern void  expand_epilogue (void);\n+extern int   initial_offset (int, int);\n+extern int   mask_ok_for_mem_btst (int, int);\n+\n+#undef Mmode\n+#undef Cstar\n+#undef Rclas"}, {"sha": "5e420a53d505fc7b6b44933f87ea292c2fa777b1", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 109, "deletions": 88, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"df.h\"\n \n /* This is used by GOTaddr2picreg to uniquely identify\n    UNSPEC_INT_LABELs.  */\n@@ -190,12 +191,6 @@ mn10300_option_override (void)\n {\n   if (TARGET_AM33)\n     target_flags &= ~MASK_MULT_BUG;\n-\n-  /* FIXME: The combine stack adjustments pass is breaking\n-     cc0-setter/cc0-user relationship by inserting a jump\n-     instruction.  This should be investigated, but for now\n-     just disable the pass.  */\n-  flag_combine_stack_adjustments = 0;\n }\n \n static void\n@@ -220,7 +215,7 @@ print_operand (FILE *file, rtx x, int code)\n     {\n       case 'b':\n       case 'B':\n-\tif (cc_status.mdep.fpCC)\n+\tif (GET_MODE (XEXP (x, 0)) == CC_FLOATmode)\n \t  {\n \t    switch (code == 'b' ? GET_CODE (x)\n \t\t    : reverse_condition_maybe_unordered (GET_CODE (x)))\n@@ -1008,7 +1003,7 @@ expand_epilogue (void)\n   /* SIZE includes the fixed stack space needed for function calls.  */\n   size = get_frame_size () + crtl->outgoing_args_size;\n   size += (crtl->outgoing_args_size ? 4 : 0);\n-\n+  \n   if (TARGET_AM33_2 && fp_regs_to_save ())\n     {\n       int num_regs_to_save = fp_regs_to_save (), i;\n@@ -1236,59 +1231,6 @@ expand_epilogue (void)\n     emit_jump_insn (gen_return_internal ());\n }\n \n-/* Update the condition code from the insn.  */\n-\n-void\n-notice_update_cc (rtx body, rtx insn)\n-{\n-  switch (get_attr_cc (insn))\n-    {\n-    case CC_NONE:\n-      /* Insn does not affect CC at all.  */\n-      break;\n-\n-    case CC_NONE_0HIT:\n-      /* Insn does not change CC, but the 0'th operand has been changed.  */\n-      if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n-\tcc_status.value1 = 0;\n-      break;\n-\n-    case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n-\t V,C are unusable.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_CARRY | CC_OVERFLOW_UNUSABLE;\n-      cc_status.value1 = recog_data.operand[0];\n-      break;\n-\n-    case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n-\t C is unusable.  */\n-      CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_CARRY;\n-      cc_status.value1 = recog_data.operand[0];\n-      break;\n-\n-    case CC_COMPARE:\n-      /* The insn is a compare instruction.  */\n-      CC_STATUS_INIT;\n-      cc_status.value1 = SET_SRC (body);\n-      if (GET_CODE (SET_SRC (body)) == COMPARE\n-\t  && GET_MODE (XEXP (SET_SRC (body), 0)) == SFmode)\n-\tcc_status.mdep.fpCC = 1;\n-      break;\n-\n-    case CC_CLOBBER:\n-      /* Insn doesn't leave CC in a usable state.  */\n-      CC_STATUS_INIT;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n /* Recognize the PARALLEL rtx generated by mn10300_gen_multiple_store().\n    This function is for MATCH_PARALLEL and so assumes OP is known to be\n    parallel.  If OP is a multiple store, return a mask indicating which\n@@ -1413,27 +1355,22 @@ mn10300_secondary_reload_class (enum reg_class rclass, enum machine_mode mode,\n \t\t  || XEXP (in, 1) == stack_pointer_rtx))))\n     return ADDRESS_REGS;\n \n-  if (GET_CODE (in) == PLUS\n-      && (XEXP (in, 0) == stack_pointer_rtx\n-\t  || XEXP (in, 1) == stack_pointer_rtx))\n-    return GENERAL_REGS;\n-\n   if (TARGET_AM33_2\n       && rclass == FP_REGS)\n     {\n       /* We can't load directly into an FP register from a\t\n \t constant address.  */\n       if (GET_CODE (in) == MEM\n \t  && CONSTANT_ADDRESS_P (XEXP (in, 0)))\n-\treturn (TARGET_AM33 ? DATA_OR_EXTENDED_REGS : DATA_REGS);\n+\treturn DATA_OR_EXTENDED_REGS;\n \n       /* Handle case were a pseudo may not get a hard register\n \t but has an equivalent memory location defined.  */\n       if (GET_CODE (inner) == REG\n \t  && REGNO (inner) >= FIRST_PSEUDO_REGISTER\n \t  && reg_equiv_mem [REGNO (inner)]\n \t  && CONSTANT_ADDRESS_P (XEXP (reg_equiv_mem [REGNO (inner)], 0)))\n-\treturn (TARGET_AM33 ? DATA_OR_EXTENDED_REGS : DATA_REGS);\n+\treturn DATA_OR_EXTENDED_REGS;\n     }\n \n   /* Otherwise assume no secondary reloads are needed.  */\n@@ -1696,9 +1633,10 @@ mn10300_function_value_regno_p (const unsigned int regno)\n  return (regno == FIRST_DATA_REGNUM || regno == FIRST_ADDRESS_REGNUM);\n }\n \n-/* Output a tst insn.  */\n+/* Output a compare insn.  */\n+\n const char *\n-output_tst (rtx operand, rtx insn)\n+mn10300_output_cmp (rtx operand, rtx insn)\n {\n   rtx temp;\n   int past_call = 0;\n@@ -1786,19 +1724,6 @@ output_tst (rtx operand, rtx insn)\n   return \"cmp 0,%0\";\n }\n \n-int\n-impossible_plus_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != PLUS)\n-    return 0;\n-\n-  if (XEXP (op, 0) == stack_pointer_rtx\n-      || XEXP (op, 1) == stack_pointer_rtx)\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* Similarly, but when using a zero_extract pattern for a btst where\n    the source operand might end up in memory.  */\n int\n@@ -1853,7 +1778,7 @@ symbolic_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \n    But on a few ports with segmented architectures and indexed addressing\n    (mn10300, hppa) it is used to rewrite certain problematical addresses.  */\n-rtx\n+static rtx\n mn10300_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n \t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n@@ -1941,7 +1866,7 @@ legitimate_pic_operand_p (rtx x)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (! legitimate_pic_operand_p (XVECEXP (x, i, j)))\n@@ -1968,7 +1893,7 @@ legitimate_pic_operand_p (rtx x)\n    workaround and solution, see the comments in pa.c before the\n    function record_unscaled_index_insn_codes.  */\n \n-bool\n+static bool\n mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n {\n   if (CONSTANT_ADDRESS_P (x)\n@@ -2009,14 +1934,64 @@ mn10300_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n \t  if (GET_CODE (index) == CONST\n \t      && GET_CODE (XEXP (index, 0)) != PLUS\n \t      && (! flag_pic\n- \t\t  || legitimate_pic_operand_p (index)))\n+ \t\t  || (legitimate_pic_operand_p (index)\n+\t\t      && GET_MODE_SIZE (mode) == 4)))\n \t    return TRUE;\n \t}\n     }\n \n   return FALSE;\n }\n \n+/* Used by LEGITIMATE_CONSTANT_P().  Returns TRUE if X is a valid\n+   constant.  Note that some \"constants\" aren't valid, such as TLS\n+   symbols and unconverted GOT-based references, so we eliminate\n+   those here.  */\n+\n+bool\n+mn10300_legitimate_constant_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      x = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\t    return false;\n+\t  x = XEXP (x, 0);\n+\t}\n+\n+      /* Only some unspecs are valid as \"constants\".  */\n+      if (GET_CODE (x) == UNSPEC)\n+\t{\n+\t  rtx sym = XVECEXP (x, 0, 0);\n+\t  switch (XINT (x, 1))\n+\t    {\n+\t    case UNSPEC_INT_LABEL:\n+\t    case UNSPEC_PIC:\n+\t    case UNSPEC_GOT:\n+\t    case UNSPEC_GOTOFF:\n+\t    case UNSPEC_PLT:\n+\t      return true;\n+\t    default:\n+\t      return false;\n+\t    }\n+\t}\n+\n+      /* We must have drilled down to a symbol.  */\n+      if (!symbolic_operand (x, Pmode))\n+\treturn false;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n static int\n mn10300_address_cost_1 (rtx x, int *unsig)\n {\n@@ -2215,7 +2190,8 @@ mn10300_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)\n    were solely optimizing for space, but we keep it \"reasonable\" to avoid\n    serious code efficiency lossage.  */\n \n-unsigned int mn10300_case_values_threshold (void)\n+static unsigned int\n+mn10300_case_values_threshold (void)\n {\n   return 6;\n }\n@@ -2310,3 +2286,48 @@ mn10300_can_output_mi_thunk (const_tree    thunk_fndecl ATTRIBUTE_UNUSED,\n {\n   return true;\n }\n+\n+bool\n+mn10300_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n+{\n+  if (REGNO_REG_CLASS (regno) == FP_REGS\n+      || REGNO_REG_CLASS (regno) == FP_ACC_REGS)\n+    /* Do not store integer values in FP registers.  */\n+    return GET_MODE_CLASS (mode) == MODE_FLOAT && ((regno & 1) == 0);\n+  \n+  if (((regno) & 1) == 0 || GET_MODE_SIZE (mode) == 4)\n+    return true;\n+\n+  if (REGNO_REG_CLASS (regno) == DATA_REGS\n+      || (TARGET_AM33 && REGNO_REG_CLASS (regno) == ADDRESS_REGS)\n+      || REGNO_REG_CLASS (regno) == EXTENDED_REGS)\n+    return GET_MODE_SIZE (mode) <= 4;\n+  \n+  return false;\n+}\n+\n+bool\n+mn10300_modes_tieable (enum machine_mode mode1, enum machine_mode mode2)\n+{\n+  if (GET_MODE_CLASS (mode1) == MODE_FLOAT\n+      && GET_MODE_CLASS (mode2) != MODE_FLOAT)\n+    return false;\n+\n+  if (GET_MODE_CLASS (mode2) == MODE_FLOAT\n+      && GET_MODE_CLASS (mode1) != MODE_FLOAT)\n+    return false;\n+\n+  if (TARGET_AM33\n+      || mode1 == mode2\n+      || (GET_MODE_SIZE (mode1) <= 4 && GET_MODE_SIZE (mode2) <= 4))\n+    return true;\n+\n+  return false;\n+}\n+\n+enum machine_mode\n+mn10300_select_cc_mode (rtx x)\n+{\n+  return (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT) ? CC_FLOATmode : CCmode;\n+}\n+\f"}, {"sha": "82f3e04e3de564d9d82943d358ee7c82ddb588b4", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 77, "deletions": 100, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "patch": "@@ -117,44 +117,48 @@ extern enum processor_type mn10300_processor;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n \n-#define FIRST_PSEUDO_REGISTER 51\n-\n-/* Specify machine-specific register numbers.  */\n-#define FIRST_DATA_REGNUM 0\n-#define LAST_DATA_REGNUM 3\n-#define FIRST_ADDRESS_REGNUM 4\n-#define LAST_ADDRESS_REGNUM 8\n+#define FIRST_PSEUDO_REGISTER 52\n+\n+/* Specify machine-specific register numbers.  The commented out entries\n+   are defined in mn10300.md.  */\n+#define FIRST_DATA_REGNUM      0\n+#define LAST_DATA_REGNUM       3\n+#define FIRST_ADDRESS_REGNUM   4\n+/* #define PIC_REG             6 */\n+#define LAST_ADDRESS_REGNUM    8\n+/* #define SP_REG              9 */\n #define FIRST_EXTENDED_REGNUM 10\n-#define LAST_EXTENDED_REGNUM 17\n-#define FIRST_FP_REGNUM 18\n-#define LAST_FP_REGNUM 49\n-#define MDR_REGNUM 50\n-#define FIRST_ARGUMENT_REGNUM 0\n+#define LAST_EXTENDED_REGNUM  17\n+#define FIRST_FP_REGNUM       18\n+#define LAST_FP_REGNUM        49\n+#define MDR_REGNUM            50\n+/* #define CC_REG             51 */\n+#define FIRST_ARGUMENT_REGNUM  0\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n /* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM (LAST_ADDRESS_REGNUM+1)\n+#define STACK_POINTER_REGNUM (LAST_ADDRESS_REGNUM + 1)\n \n /* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM (LAST_ADDRESS_REGNUM-1)\n+#define FRAME_POINTER_REGNUM (LAST_ADDRESS_REGNUM - 1)\n \n /* Base register for access to arguments of the function.  This\n    is a fake register and will be eliminated into either the frame\n    pointer or stack pointer.  */\n #define ARG_POINTER_REGNUM LAST_ADDRESS_REGNUM\n \n /* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM (FIRST_ADDRESS_REGNUM+1)\n+#define STATIC_CHAIN_REGNUM (FIRST_ADDRESS_REGNUM + 1)\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n \n #define FIXED_REGISTERS \\\n   { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 \\\n-  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n-  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 \\\n+  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t \\\n+  , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1 \\\n   }\n \n /* 1 for registers not available across function calls.\n@@ -167,8 +171,8 @@ extern enum processor_type mn10300_processor;\n \n #define CALL_USED_REGISTERS \\\n   { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 \\\n-  , 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 \\\n-  , 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \\\n+  , 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t \\\n+  , 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 \\\n   }\n \n /* Note: The definition of CALL_REALLY_USED_REGISTERS is not\n@@ -181,7 +185,7 @@ extern enum processor_type mn10300_processor;\n #define REG_ALLOC_ORDER \\\n   { 0, 1, 4, 5, 2, 3, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 8, 9 \\\n   , 42, 43, 44, 45, 46, 47, 48, 49, 34, 35, 36, 37, 38, 39, 40, 41 \\\n-  , 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33 \\\n+  , 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 51 \\\n   }\n \n #define CONDITIONAL_REGISTER_USAGE \\\n@@ -197,8 +201,7 @@ extern enum processor_type mn10300_processor;\n   if (!TARGET_AM33_2)\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n       for (i = FIRST_FP_REGNUM;\t\t\t\\\n-\t   i <= LAST_FP_REGNUM; \t\t\\\n-           i++) \t\t\t\t\\\n+\t   i <= LAST_FP_REGNUM; i++) \t\t\\\n \tfixed_regs[i] = call_used_regs[i] = 1;\t\\\n     }\t\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\\\n@@ -217,22 +220,15 @@ extern enum processor_type mn10300_processor;\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n    MODE.  */\n-\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- ((REGNO_REG_CLASS (REGNO) == DATA_REGS \\\n-   || (TARGET_AM33 && REGNO_REG_CLASS (REGNO) == ADDRESS_REGS) \\\n-   || REGNO_REG_CLASS (REGNO) == EXTENDED_REGS) \\\n-  ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4\t\\\n-  : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) == 4)\n+  mn10300_hard_regno_mode_ok ((REGNO), (MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (TARGET_AM33  \\\n-   || MODE1 == MODE2 \\\n-   || (GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4))\n+  mn10300_modes_tieable ((MODE1), (MODE2))\n \n /* 4 data, and effectively 3 address registers is small as far as I'm\n    concerned.  */\n@@ -263,43 +259,44 @@ enum reg_class {\n   DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS,\n   EXTENDED_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n   SP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS,\n-  FP_REGS, FP_ACC_REGS,\n+  FP_REGS, FP_ACC_REGS, CC_REGS,\n   GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.  */\n \n-#define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n-  \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"SP_OR_ADDRESS_REGS\", \\\n-  \"EXTENDED_REGS\", \\\n-  \"DATA_OR_EXTENDED_REGS\", \"ADDRESS_OR_EXTENDED_REGS\", \\\n-  \"SP_OR_EXTENDED_REGS\", \"SP_OR_ADDRESS_OR_EXTENDED_REGS\", \\\n-  \"FP_REGS\", \"FP_ACC_REGS\", \\\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\\\n+{ \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\",\t\t\t\\\n+  \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"SP_OR_ADDRESS_REGS\",\t\\\n+  \"EXTENDED_REGS\",\t\t\t\t\t\t\\\n+  \"DATA_OR_EXTENDED_REGS\", \"ADDRESS_OR_EXTENDED_REGS\",\t\t\\\n+  \"SP_OR_EXTENDED_REGS\", \"SP_OR_ADDRESS_OR_EXTENDED_REGS\",\t\\\n+  \"FP_REGS\", \"FP_ACC_REGS\", \"CC_REGS\",\t\t\t\t\\\n   \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n \n-#define REG_CLASS_CONTENTS  \t\t\t\\\n-{  { 0,\t0 },\t\t/* No regs      */\t\\\n- { 0x0000f, 0 },\t/* DATA_REGS */\t\t\\\n- { 0x001f0, 0 },\t/* ADDRESS_REGS */\t\\\n- { 0x00200, 0 },\t/* SP_REGS */\t\t\\\n- { 0x001ff, 0 },\t/* DATA_OR_ADDRESS_REGS */\\\n- { 0x003f0, 0 },\t/* SP_OR_ADDRESS_REGS */\\\n- { 0x3fc00, 0 },\t/* EXTENDED_REGS */\t\\\n- { 0x3fc0f, 0 },\t/* DATA_OR_EXTENDED_REGS */\t\\\n- { 0x3fdf0, 0 },\t/* ADDRESS_OR_EXTENDED_REGS */\t\\\n- { 0x3fe00, 0 },\t/* SP_OR_EXTENDED_REGS */\t\\\n- { 0x3fff0, 0 },\t/* SP_OR_ADDRESS_OR_EXTENDED_REGS */\t\\\n- { 0xfffc0000, 0x3ffff }, /* FP_REGS */\t\t\\\n- { 0x03fc0000, 0 },\t/* FP_ACC_REGS */\t\\\n- { 0x3fdff, 0 }, \t/* GENERAL_REGS */\t\\\n- { 0xffffffff, 0x7ffff } /* ALL_REGS \t*/\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\\\n+{ { 0,\t        0 },\t  /* No regs      */\t\t\t\\\n+  { 0x0000000f, 0 },\t  /* DATA_REGS */\t\t\t\\\n+  { 0x000001f0, 0 },\t  /* ADDRESS_REGS */\t\t\t\\\n+  { 0x00000200, 0 },\t  /* SP_REGS */\t\t\t\t\\\n+  { 0x000001ff, 0 },\t  /* DATA_OR_ADDRESS_REGS */\t\t\\\n+  { 0x000003f0, 0 },\t  /* SP_OR_ADDRESS_REGS */\t\t\\\n+  { 0x0003fc00, 0 },\t  /* EXTENDED_REGS */\t\t\t\\\n+  { 0x0003fc0f, 0 },\t  /* DATA_OR_EXTENDED_REGS */\t\t\\\n+  { 0x0003fdf0, 0 },\t  /* ADDRESS_OR_EXTENDED_REGS */\t\\\n+  { 0x0003fe00, 0 },\t  /* SP_OR_EXTENDED_REGS */\t\t\\\n+  { 0x0003fff0, 0 },\t  /* SP_OR_ADDRESS_OR_EXTENDED_REGS */\t\\\n+  { 0xfffc0000, 0x3ffff },/* FP_REGS */\t\t\t\t\\\n+  { 0x03fc0000, 0 },\t  /* FP_ACC_REGS */\t\t\t\\\n+  { 0x00000000, 0x80000 },/* CC_REGS */\t\t\t\t\\\n+  { 0x0003fdff, 0 }, \t  /* GENERAL_REGS */\t\t\t\\\n+  { 0xffffffff, 0xfffff } /* ALL_REGS \t*/\t\t\t\\\n }\n \n /* The following macro defines cover classes for Integrated Register\n@@ -326,6 +323,7 @@ enum reg_class {\n    (REGNO) == STACK_POINTER_REGNUM ? SP_REGS : \\\n    (REGNO) <= LAST_EXTENDED_REGNUM ? EXTENDED_REGS : \\\n    (REGNO) <= LAST_FP_REGNUM ? FP_REGS : \\\n+   (REGNO) == CC_REG ? CC_REGS : \\\n    NO_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -496,10 +494,11 @@ enum reg_class {\n #define REG_PARM_STACK_SPACE(DECL) 8\n #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1\n #define ACCUMULATE_OUTGOING_ARGS 1\n-\n+#if 1\n /* So we can allocate space for return pointers once for the function\n    instead of around every call.  */\n #define STACK_POINTER_OFFSET 4\n+#endif\n \n /* 1 if N is a possible register number for function argument passing.\n    On the MN10300, d0 and d1 are used in this way.  */\n@@ -611,8 +610,7 @@ struct cum_arg {int nbytes; };\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n+#define LEGITIMATE_CONSTANT_P(X) mn10300_legitimate_constant_p (X)\n \n /* Zero if this needs fixing up to become PIC.  */\n \n@@ -675,20 +673,9 @@ struct cum_arg {int nbytes; };\n       goto FAIL;\t\t\t\t\t\t\t\\\n   while (0)\n \f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the VAX.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-#define CC_OVERFLOW_UNUSABLE 0x200\n-#define CC_NO_CARRY CC_NO_OVERFLOW\n-#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)\n-\n+#define SELECT_CC_MODE(OP, X, Y)  mn10300_select_cc_mode (X)\n+#define REVERSIBLE_CC_MODE(MODE)  0\n+\f\n #define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) \\\n   ((CLASS1 == CLASS2 && (CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS)) ? 2 :\\\n    ((CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS) && \\\n@@ -762,24 +749,26 @@ struct cum_arg {int nbytes; };\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-#define REGISTER_NAMES \\\n-{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"ap\", \"sp\", \\\n-  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\" \\\n-, \"fs0\", \"fs1\", \"fs2\", \"fs3\", \"fs4\", \"fs5\", \"fs6\", \"fs7\" \\\n-, \"fs8\", \"fs9\", \"fs10\", \"fs11\", \"fs12\", \"fs13\", \"fs14\", \"fs15\" \\\n-, \"fs16\", \"fs17\", \"fs18\", \"fs19\", \"fs20\", \"fs21\", \"fs22\", \"fs23\" \\\n-    , \"fs24\", \"fs25\", \"fs26\", \"fs27\", \"fs28\", \"fs29\", \"fs30\", \"fs31\", \"mdr\"\t\\\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"ap\", \"sp\",\t\t\\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\"\t\t\t\\\n+, \"fs0\", \"fs1\", \"fs2\", \"fs3\", \"fs4\", \"fs5\", \"fs6\", \"fs7\"\t\t\\\n+, \"fs8\", \"fs9\", \"fs10\", \"fs11\", \"fs12\", \"fs13\", \"fs14\", \"fs15\"\t\t\\\n+, \"fs16\", \"fs17\", \"fs18\", \"fs19\", \"fs20\", \"fs21\", \"fs22\", \"fs23\"\t\\\n+, \"fs24\", \"fs25\", \"fs26\", \"fs27\", \"fs28\", \"fs29\", \"fs30\", \"fs31\"\t\\\n+, \"mdr\", \"EPSW\"\t\t\t\t\t\t\t\t\\\n }\n \n-#define ADDITIONAL_REGISTER_NAMES \\\n-{ {\"r8\",  4}, {\"r9\",  5}, {\"r10\", 6}, {\"r11\", 7}, \\\n-  {\"r12\", 0}, {\"r13\", 1}, {\"r14\", 2}, {\"r15\", 3}, \\\n-  {\"e0\", 10}, {\"e1\", 11}, {\"e2\", 12}, {\"e3\", 13}, \\\n-  {\"e4\", 14}, {\"e5\", 15}, {\"e6\", 16}, {\"e7\", 17} \\\n-, {\"fd0\", 18}, {\"fd2\", 20}, {\"fd4\", 22}, {\"fd6\", 24} \\\n-, {\"fd8\", 26}, {\"fd10\", 28}, {\"fd12\", 30}, {\"fd14\", 32} \\\n-, {\"fd16\", 34}, {\"fd18\", 36}, {\"fd20\", 38}, {\"fd22\", 40} \\\n-, {\"fd24\", 42}, {\"fd26\", 44}, {\"fd28\", 46}, {\"fd30\", 48} \\\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\\\n+{ {\"r8\",  4}, {\"r9\",  5}, {\"r10\", 6}, {\"r11\", 7},\t\t\\\n+  {\"r12\", 0}, {\"r13\", 1}, {\"r14\", 2}, {\"r15\", 3},\t\t\\\n+  {\"e0\", 10}, {\"e1\", 11}, {\"e2\", 12}, {\"e3\", 13},\t\t\\\n+  {\"e4\", 14}, {\"e5\", 15}, {\"e6\", 16}, {\"e7\", 17}\t\t\\\n+, {\"fd0\", 18}, {\"fd2\", 20}, {\"fd4\", 22}, {\"fd6\", 24}\t\t\\\n+, {\"fd8\", 26}, {\"fd10\", 28}, {\"fd12\", 30}, {\"fd14\", 32}\t\t\\\n+, {\"fd16\", 34}, {\"fd18\", 36}, {\"fd20\", 38}, {\"fd22\", 40}\t\\\n+, {\"fd24\", 42}, {\"fd26\", 44}, {\"fd28\", 46}, {\"fd30\", 48}\t\\\n+, {\"cc\", CC_REG}\t\t\t\t\t\t\\\n }\n \n /* Print an instruction operand X on file FILE.\n@@ -792,9 +781,6 @@ struct cum_arg {int nbytes; };\n \n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n \n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\n-\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n@@ -883,12 +869,3 @@ struct cum_arg {int nbytes; };\n \n #define FILE_ASM_OP \"\\t.file\\n\"\n \n-typedef struct mn10300_cc_status_mdep\n-  {\n-    int fpCC;\n-  }\n-cc_status_mdep;\n-\n-#define CC_STATUS_MDEP cc_status_mdep\n-\n-#define CC_STATUS_MDEP_INIT (cc_status.mdep.fpCC = 0)"}, {"sha": "199617a3b693ac9aa3f78690e04a701720f704b3", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 800, "deletions": 616, "changes": 1416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "patch": "@@ -1,6 +1,7 @@\n ;; GCC machine description for Matsushita MN10300\n-;; Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-;; 2007, 2008 Free Software Foundation, Inc.\n+;; Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+;; 2005, 2006, 2007, 2008, 2009, 2010\n+;; Free Software Foundation, Inc.\n ;; Contributed by Jeff Law (law@cygnus.com).\n \n ;; This file is part of GCC.\n@@ -24,21 +25,10 @@\n \n ;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n-;; Condition code settings.\n-;; none - insn does not affect cc\n-;; none_0hit - insn does not affect cc but it does modify operand 0\n-;;\tThis attribute is used to keep track of when operand 0 changes.\n-;; \tSee the description of NOTICE_UPDATE_CC for more info.\n-;; set_znv - insn sets z,n,v to usable values; c is unusable.\n-;; set_zn  - insn sets z,n to usable values; v,c are unusable.\n-;; compare - compare instruction\n-;; clobber - value of cc is unknown\n-(define_attr \"cc\" \"none,none_0hit,set_znv,set_zn,compare,clobber\"\n-  (const_string \"clobber\"))\n-\n (define_constants [\n-  (PIC_REG\t6)\n-  (SP_REG\t9)\n+  (PIC_REG 6)\n+  (SP_REG  9)\n+  (CC_REG 51)\n \n   (UNSPEC_INT_LABEL\t0)\n   (UNSPEC_PIC\t\t1)\n@@ -58,20 +48,20 @@\n ;; movqi\n \n (define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:QI 0 \"general_operand\")\n+\t(match_operand:QI 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n+  /* One of the ops has to be in a register.  */\n   if (!register_operand (operand0, QImode)\n       && !register_operand (operand1, QImode))\n     operands[1] = copy_to_mode_reg (QImode, operand1);\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x,d*x*a,d*x*a,m,*f,d*x*a\")\n-\t(match_operand:QI 1 \"general_operand\" \"0,I,d*xai,m,d*xa,d*xa*f,*f\"))]\n+(define_insn \"*am33_movqi\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x*a,d*x*a,m,*f,d*x*a\")\n+\t(match_operand:QI 1 \"general_operand\"      \"0,d*xai,m,d*xa,d*xa*f,*f\"))]\n   \"TARGET_AM33\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n@@ -82,8 +72,6 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      return \\\"clr %0\\\";\n-    case 2:\n       if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \t{\n \t  rtx xoperands[2];\n@@ -103,19 +91,19 @@\n \t    return \\\"movu %1,%0\\\";\n \t}\n       return \\\"mov %1,%0\\\";\n+    case 2:\n     case 3:\n-    case 4:\n       return \\\"movbu %1,%0\\\";\n+    case 4:\n     case 5:\n-    case 6:\n       return \\\"fmov %1,%0\\\";\n     default:\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_movqi\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d*a,d,d,!*a,d*a,d,m\")\n \t(match_operand:QI 1 \"general_operand\" \"0,I,i,i,da,m,d\"))]\n   \"register_operand (operands[0], QImode)\n@@ -127,7 +115,6 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      return \\\"clr %0\\\";\n     case 2:\n     case 3:\n     case 4:\n@@ -148,25 +135,25 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+)\n \n ;; movhi\n \n (define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:HI 0 \"general_operand\")\n+\t(match_operand:HI 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n+  /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, HImode)\n       && !register_operand (operand0, HImode))\n     operands[1] = copy_to_mode_reg (HImode, operand1);\n }\")\n \n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x,d*x*a,d*x*a,m,*f,d*x*a\")\n-\t(match_operand:HI 1 \"general_operand\" \"0,I,d*x*ai,m,d*x*a,d*x*a*f,*f\"))]\n+(define_insn \"*am33_movhi\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*x*a*f,d*x*a,d*x*a,m,*f,d*x*a\")\n+\t(match_operand:HI 1 \"general_operand\"      \"0,d*x*ai,m,d*x*a,d*x*a*f,*f\"))]\n   \"TARGET_AM33\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n@@ -177,8 +164,6 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      return \\\"clr %0\\\";\n-    case 2:\n       if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \t{\n \t  rtx xoperands[2];\n@@ -198,19 +183,19 @@\n \t    return \\\"movu %1,%0\\\";\n \t}\n       return \\\"mov %1,%0\\\";\n+    case 2:\n     case 3:\n-    case 4:\n       return \\\"movhu %1,%0\\\";\n+    case 4:\n     case 5:\n-    case 6:\n       return \\\"fmov %1,%0\\\";\n     default:\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_movhi\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=d*a,d,d,!*a,d*a,d,m\")\n \t(match_operand:HI 1 \"general_operand\" \"0,I,i,i,da,m,d\"))]\n   \"register_operand (operands[0], HImode)\n@@ -222,7 +207,6 @@\n     case 0:\n       return \\\"nop\\\";\n     case 1:\n-      return \\\"clr %0\\\";\n     case 2:\n     case 3:\n     case 4:\n@@ -242,20 +226,22 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+)\n \n ;; movsi and helpers\n \n ;; We use this to handle addition of two values when one operand is the\n ;; stack pointer and the other is a memory reference of some kind.  Reload\n ;; does not handle them correctly without this expander.\n (define_expand \"reload_insi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(match_operand:SI 1 \"impossible_plus_operand\" \"\"))\n+  [(set (match_operand:SI     0 \"register_operand\" \"=a\")\n+\t(match_operand:SI     1 \"impossible_plus_operand\" \"\"))\n    (clobber (match_operand:SI 2 \"register_operand\" \"=&r\"))]\n   \"\"\n   \"\n {\n+  gcc_assert (REGNO (operands[0]) != REGNO (operands[2]));\n+\n   if (XEXP (operands[1], 0) == stack_pointer_rtx)\n     {\n       if (GET_CODE (XEXP (operands[1], 1)) == SUBREG\n@@ -293,12 +279,12 @@\n   \"movm (sp),[a2]\")\n \n (define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:SI 0 \"general_operand\")\n+\t(match_operand:SI 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n+  /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, SImode)\n       && !register_operand (operand0, SImode))\n     operands[1] = copy_to_mode_reg (SImode, operand1);\n@@ -334,7 +320,7 @@\n     }\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movsi_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\"\n \t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,axR,!*y,*f,*f,dxaQ\")\n \t(match_operand:SI 1 \"general_operand\"\n@@ -349,7 +335,6 @@\n     case 1:\n       return \\\"nop\\\";\n     case 2:\n-      return \\\"clr %0\\\";\n     case 3:\n     case 4:\n     case 5:\n@@ -389,23 +374,23 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none,none_0hit,none_0hit\")])\n+)\n \n (define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:SF 0 \"general_operand\")\n+\t(match_operand:SF 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n+  /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, SFmode)\n       && !register_operand (operand0, SFmode))\n     operands[1] = copy_to_mode_reg (SFmode, operand1);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movsf_internal\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,dx,ax,dx,a,f,dxaQ,daxm,dax\")\n-\t(match_operand:SF 1 \"general_operand\" \"0,0,0,G,G,fdxaQF,f,dax,daxFm\"))]\n+\t(match_operand:SF 1 \"general_operand\"       \"0,0,0,G,G,fdxaQF,f,dax,daxFm\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n   \"*\n@@ -416,12 +401,11 @@\n     case 1:\n     case 2:\n       return \\\"nop\\\";\n-    case 3:\n-      return \\\"clr %0\\\";\n-    /* case 4: below */\n+    /* Cases 3 & 4: below.  */\n     case 5:\n     case 6:\n       return \\\"fmov %1, %0\\\";\n+    case 3:\n     case 4:\n     case 7:\n     case 8:\n@@ -439,21 +423,21 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"none,none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+)\n \n (define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DI 0 \"general_operand\")\n+\t(match_operand:DI 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n+  /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, DImode)\n       && !register_operand (operand0, DImode))\n     operands[1] = copy_to_mode_reg (DImode, operand1);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movdi_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\"\n \t\t\t\t\"=dx,ax,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax,*f,*f,*f,dxa,*f,Q\")\n \t(match_operand:DI 1 \"general_operand\"\n@@ -472,7 +456,7 @@\n \treturn \\\"nop\\\";\n \n       case 2:\n-\treturn \\\"clr %L0\\;clr %H0\\\";\n+\treturn \\\"mov 0, %L0\\;mov 0, %H0\\\";\n \n       case 3:\n \tif (rtx_equal_p (operands[0], operands[1]))\n@@ -546,7 +530,7 @@\n \t\t&& val[0] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"clr %L0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n@@ -565,7 +549,7 @@\n \t\t&& val[1] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"clr %H0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n@@ -608,47 +592,30 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set (attr \"cc\")\n-\t(cond\n-\t [\n-\t (ior (lt (symbol_ref \"which_alternative\") (const_int 2))\n-\t      (eq (symbol_ref \"which_alternative\") (const_int 12))\n-\t      ) (const_string \"none\")\n-\t (eq (symbol_ref \"which_alternative\") (const_int 2)\n-\t     ) (const_string \"clobber\")\n-\t (eq (symbol_ref \"which_alternative\") (const_int 3)\n-\t     ) (if_then_else\n-\t\t(ne (symbol_ref \"rtx_equal_p (operands[0], operands[1])\")\n-\t\t    (const_int 0)) (const_string \"clobber\")\n-\t\t    (const_string \"none_0hit\"))\n-\t (ior (eq (symbol_ref \"which_alternative\") (const_int 8))\n-\t      (eq (symbol_ref \"which_alternative\") (const_int 9))\n-\t      ) (if_then_else\n-\t\t (ne (symbol_ref \"mn10300_wide_const_load_uses_clr\n-\t\t\t\t  (operands)\")\n-\t\t     (const_int 0)) (const_string \"clobber\")\n-\t\t     (const_string \"none_0hit\"))\n-\t ] (const_string \"none_0hit\")))])\n+)\n \n (define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  [(set (match_operand:DF 0 \"general_operand\")\n+\t(match_operand:DF 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n-  /* One of the ops has to be in a register */\n+  /* One of the ops has to be in a register.  */\n   if (!register_operand (operand1, DFmode)\n       && !register_operand (operand0, DFmode))\n     operands[1] = copy_to_mode_reg (DFmode, operand1);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_2_movdf\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\"\n+\t\t\t  ;;      0 1  2  3  4 5 6   7 8 9 10  11  12  13  14 15 16 17\n \t\t\t\t\"=f,dx,ax,dx,f,f,dxa,f,Q,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n \t(match_operand:DF 1 \"general_operand\"\n+\t\t\t  ;;     0 1 2 3 4 5    6 7 8 9 10 11 12 13 14   15   16   17\n \t\t\t\t\"0,0,0,G,f,dxaF,f,Q,f,G,dx,ax,dx,ax,dxFm,axFm,dxFm,axFm\"))]\n-  \"register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode)\"\n+  \"TARGET_AM33_2\n+\t&& (register_operand (operands[0], DFmode)\n+   \t|| register_operand (operands[1], DFmode))\"\n   \"*\n {\n   long val[2];\n@@ -662,7 +629,7 @@\n \treturn \\\"nop\\\";\n \n       case 3:\n-\treturn \\\"clr %L0\\;clr %H0\\\";\n+\treturn \\\"mov 0, %L0\\;mov 0, %H0\\\";\n \n       case 4:\n       case 5:\n@@ -757,7 +724,7 @@\n \t\t&& val[0] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"clr %L0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n@@ -776,7 +743,7 @@\n \t\t&& val[1] == 0)\n \t      {\n \t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n-\t\t  output_asm_insn (\\\"clr %H0\\\", operands);\n+\t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n \t\telse\n \t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t      }\n@@ -799,119 +766,167 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set (attr \"cc\")\n-\t(cond\n-\t [\n-\t (lt (symbol_ref \"which_alternative\") (const_int 3)\n-\t     ) (const_string \"none\")\n-\t (eq (symbol_ref \"which_alternative\") (const_int 3)\n-\t     ) (const_string \"clobber\")\n-\t (eq (symbol_ref \"which_alternative\") (const_int 9)\n-\t     ) (if_then_else\n-\t\t(ne (symbol_ref \"rtx_equal_p (operands[0], operands[1])\")\n-\t\t    (const_int 0)) (const_string \"clobber\")\n-\t\t    (const_string \"none_0hit\"))\n-\t (ior (eq (symbol_ref \"which_alternative\") (const_int 14))\n-\t      (eq (symbol_ref \"which_alternative\") (const_int 15))\n-\t      ) (if_then_else\n-\t\t (ne (symbol_ref \"mn10300_wide_const_load_uses_clr\n-\t\t\t\t  (operands)\")\n-\t\t     (const_int 0)) (const_string \"clobber\")\n-\t\t     (const_string \"none_0hit\"))\n-\t ] (const_string \"none_0hit\")))])\n+)\n \n+(define_insn \"*mn10300_movdf\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\"\n+\t\t\t  ;;     0    1  2 3   4   5   6   7  8  9  10\n+\t\t\t\t\"=dxa,dx,a,dxm,dxm,axm,axm,dx,dx,ax,ax\")\n+\t(match_operand:DF 1 \"general_operand\"\n+\t\t\t  ;;        0 1 2 3  4  5  6  7    8    9    10\n+\t\t\t\t   \"0,G,G,dx,ax,dx,ax,dxFm,axFm,dxFm,axFm\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"*\n+{\n+  long val[2];\n+  REAL_VALUE_TYPE rv;\n \n-\f\n-;; ----------------------------------------------------------------------\n-;; TEST INSTRUCTIONS\n-;; ----------------------------------------------------------------------\n+  switch (which_alternative)\n+    {\n+      case 0:\n+\treturn \\\"nop\\\";\n \n-(define_insn \"*tst_extqisi_am33\"\n-  [(set (cc0) (compare\n-\t       (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx,!a\"))\n-\t       (const_int 0)))]\n-  \"TARGET_AM33\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+      case 1:\n+\treturn \\\"mov 0, %L0\\;mov 0, %H0\\\";\n \n-(define_insn \"*tst_extqisi\"\n-  [(set (cc0) (compare\n-\t       (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx\"))\n-\t       (const_int 0)))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+      case 2:\n+\t if (rtx_equal_p (operands[0], operands[1]))\n+\t   return \\\"sub %L1,%L0\\;mov %L0,%H0\\\";\n+\t else\n+\t   return \\\"mov %1,%L0\\;mov %L0,%H0\\\";\n+      case 3:\n+      case 4:\n+      case 5:\n+      case 6:\n+      case 7:\n+      case 8:\n+      case 9:\n+      case 10:\n+\tif (GET_CODE (operands[1]) == CONST_INT)\n+\t  {\n+\t    rtx low, high;\n+\t    split_double (operands[1], &low, &high);\n+\t    val[0] = INTVAL (low);\n+\t    val[1] = INTVAL (high);\n+\t  }\n+\tif (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t  {\n+\t    if (GET_MODE (operands[1]) == DFmode)\n+\t      {\n+\t\tREAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n+\t\tREAL_VALUE_TO_TARGET_DOUBLE (rv, val);\n+\t      }\n+\t    else if (GET_MODE (operands[1]) == VOIDmode\n+\t\t     || GET_MODE (operands[1]) == DImode)\n+\t      {\n+\t\tval[0] = CONST_DOUBLE_LOW (operands[1]);\n+\t\tval[1] = CONST_DOUBLE_HIGH (operands[1]);\n+\t      }\n+\t  }\n \n-(define_insn \"*tst_exthisi_am33\"\n-  [(set (cc0) (compare\n-\t       (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx,!a\"))\n-\t       (const_int 0)))]\n-  \"TARGET_AM33\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+\tif (GET_CODE (operands[1]) == MEM\n+\t    && reg_overlap_mentioned_p (operands[0], XEXP (operands[1], 0)))\n+\t  {\n+\t    rtx temp = operands[0];\n \n-(define_insn \"*tst_exthisi\"\n-  [(set (cc0) (compare\n-\t       (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx\"))\n-\t       (const_int 0)))]\n-  \"\"\n-  \"* return output_tst (operands[0], insn);\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+\t    while (GET_CODE (temp) == SUBREG)\n+\t      temp = SUBREG_REG (temp);\n \n-;; Ordinarily, the cmp instruction will set the Z bit of cc0 to 1 if\n-;; its operands hold equal values, but the operands of a cmp\n-;; instruction must be distinct registers.  In the case where we'd\n-;; like to compare a register to itself, we can achieve this effect\n-;; with a btst 0,d0 instead.  (This will not alter the contents of d0\n-;; but will have the proper effect on cc0.  Using d0 is arbitrary; any\n-;; data register would work.)\n+\t    gcc_assert (GET_CODE (temp) == REG);\n \n-;; Even though the first alternative would be preferable if it can\n-;; possibly match, reload must not be given the opportunity to attempt\n-;; to use it.  It assumes that such matches can only occur when one of\n-;; the operands is used for input and the other for output.  Since\n-;; this is not the case, it abort()s.  Indeed, such a reload cannot be\n-;; possibly satisfied, so just mark the alternative with a `!', so\n-;; that it is not considered by reload.\n+\t    if (reg_overlap_mentioned_p (gen_rtx_REG (SImode, REGNO (temp)),\n+\t\t\t\t\t XEXP (operands[1], 0)))\n+\t      return \\\"mov %H1,%H0\\;mov %L1,%L0\\\";\n+\t    else\n+\t      return \\\"mov %L1,%L0\\;mov %H1,%H0\\\";\n \n-(define_insn \"*cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax,dax\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"*0,I,daxi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"btst 0,d0\\\";\n-  if (which_alternative == 1)\n-    return output_tst (operands[0], insn);\n-  return \\\"cmp %1,%0\\\";\n-}\"\n-  [(set_attr \"cc\" \"compare,set_znv,compare\")])\n+\t  }\n+\telse if (GET_CODE (operands[1]) == MEM\n+\t\t && CONSTANT_ADDRESS_P (XEXP (operands[1], 0))\n+\t\t && REGNO_REG_CLASS (REGNO (operands[0])) == ADDRESS_REGS)\n+\t  {\n+\t    rtx xoperands[2];\n \n-(define_insn \"*cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"register_operand\" \"f,f\")\n-\t\t (match_operand:SF 1 \"nonmemory_operand\" \"f,F\")))]\n-  \"TARGET_AM33_2\"\n-  \"fcmp %1,%0\"\n-  [(set_attr \"cc\" \"compare,compare\")])\n+\t    xoperands[0] = operands[0];\n+\t    xoperands[1] = XEXP (operands[1], 0);\n+\n+\t    output_asm_insn (\\\"mov %1,%L0\\;mov (4,%L0),%H0\\;mov (%L0),%L0\\\",\n+\t\t\t     xoperands);\n+\t    return \\\"\\\";\n+\t  }\n+\telse\n+\t  {\n+\t    if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t&& val[0] == 0)\n+\t      {\n+\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t\t  output_asm_insn (\\\"mov 0, %L0\\\", operands);\n+\t\telse\n+\t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\t      }\n+\t    else if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n+\t\t\t == EXTENDED_REGS)\n+\t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n+\t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n+\t      output_asm_insn (\\\"movu %L1,%L0\\\", operands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n+\n+\t    if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t&& val[1] == 0)\n+\t      {\n+\t\tif (REGNO_REG_CLASS (REGNO (operands[0])) == DATA_REGS)\n+\t\t  output_asm_insn (\\\"mov 0, %H0\\\", operands);\n+\t\telse\n+\t\t  output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t      }\n+\t    else if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t     && val[0] == val[1])\n+\t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n+\t    else if ((GET_CODE (operands[1]) == CONST_INT\n+\t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t\t     && (REGNO_REG_CLASS (true_regnum (operands[0]))\n+\t\t\t == EXTENDED_REGS)\n+\t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n+\t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n+\t      output_asm_insn (\\\"movu %H1,%H0\\\", operands);\n+\t    else\n+\t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n+\t    return \\\"\\\";\n+\t  }\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\"\n+)\n+\t\n \f\n ;; ----------------------------------------------------------------------\n ;; ADD INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n+\t\t   (plus:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t    (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,a,x,a,dax,!*y,!dax\")\n+(define_insn \"*am33_addsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=dx,a,x,a,dax,!*y,!dax\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,dax\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,L,daxi,i,dax\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,L,daxi,i,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -985,12 +1000,14 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"set_zn,none_0hit,set_zn,none_0hit,set_zn,none_0hit,set_zn\")])\n+)\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,a,a,dax,!*y,!dax\")\n+(define_insn \"*mn10300_addsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=dx,a,a,dax,!*y,!dax\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,dax\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,daxi,i,dax\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,daxi,i,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"*\n {\n@@ -1027,20 +1044,23 @@\n       gcc_unreachable ();\n     }\n }\"\n-  [(set_attr \"cc\" \"set_zn,none_0hit,none_0hit,set_zn,none_0hit,set_zn\")])\n+)\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI           0 \"register_operand\")\n+\t\t   (minus:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t     (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_subsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dax,!dax\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,dax\")\n \t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi,dax\")))]\n@@ -1068,19 +1088,21 @@\n       return \\\"sub %2,%1,%0\\\";\n     }\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dax\")\n+(define_insn \"*mn10300_subsi3\"\n+  [(set (match_operand:SI           0 \"register_operand\" \"=dax\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi\")))]\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"sub %2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n (define_expand \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-        (neg:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:SI         0 \"register_operand\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\")))]\n   \"\"\n   \"\n {\n@@ -1099,30 +1121,39 @@\n (define_insn \"mulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=dax\")\n         (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n-                 (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))]\n+                 (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"mul %1,%2,%H0,%L0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n (define_insn \"umulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=dax\")\n         (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n-                 (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))]\n+                 (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"mulu %1,%2,%H0,%L0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n (define_expand \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI          0 \"register_operand\")\n+\t\t   (mult:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+(define_insn \"*am33_mulsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=dx,!dax\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dx,daxi\")))]\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dx,daxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -1131,12 +1162,14 @@\n   else\n     return \\\"mul %2,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n+(define_insn \"*mn10300_mulsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=dx\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"dx\")))]\n+\t\t (match_operand:SI 2 \"register_operand\" \"dx\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"*\n {\n@@ -1145,14 +1178,34 @@\n   else\n     return \\\"mul %2,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n-\n-(define_insn \"udivmodsi4\"\n+)\n+\n+(define_expand \"udivmodsi4\"\n+  [(parallel [(set (match_operand:SI          0 \"nonimmediate_operand\")\n+\t\t   (udiv:SI (match_operand:SI 1 \"general_operand\")\n+\t\t\t    (match_operand:SI 2 \"general_operand\")))\n+\t      (set (match_operand:SI          3 \"nonimmediate_operand\")\n+\t\t   (umod:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n+  \"\"\n+  \"{\n+    if (!register_operand (operands[1], SImode))\n+      operands[1] = copy_to_mode_reg (SImode, operands[1]);\n+    if (!register_operand (operands[2], SImode))\n+      operands[2] = copy_to_mode_reg (SImode, operands[2]);\n+   }\"\n+)\n+\n+(define_insn \"*udivmodsi4_insn\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dx\")))\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"dx\")))\n    (set (match_operand:SI 3 \"nonimmediate_operand\" \"=&d\")\n-\t(umod:SI (match_dup 1) (match_dup 2)))]\n+\t(umod:SI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"*\n {\n@@ -1163,14 +1216,16 @@\n   else\n     return \\\"divu %2,%0\\;mov mdr,%3\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n (define_insn \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dx\")))\n-   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=d\")\n-\t(mod:SI (match_dup 1) (match_dup 2)))]\n+  [(set (match_operand:SI          0 \"nonimmediate_operand\" \"=dx\")\n+\t(div:SI (match_operand:SI  1 \"general_operand\"       \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\"       \"dx\")))\n+   (set (match_operand:SI          3 \"nonimmediate_operand\" \"=d\")\n+\t(mod:SI (match_dup 1) (match_dup 2)))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"*\n {\n@@ -1179,24 +1234,29 @@\n   else\n     return \\\"ext %0\\;div %2,%0\\;mov mdr,%3\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n \f\n ;; ----------------------------------------------------------------------\n ;; AND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n+\t\t   (and:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,!dax\")\n+(define_insn \"*am33_andsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx,dx,!dax\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,dax\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi,dax\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -1236,27 +1296,14 @@\n     return \\\"and %1,%0\\\";\n   return \\\"and %2,%0\\\";\n }\"\n-  [(set (attr \"cc\")\n-\t(cond\n-\t [\n-\t (eq (symbol_ref \"which_alternative\") (const_int 0)\n-\t     ) (const_string \"none_0hit\")\n-\t (ne (symbol_ref \"GET_CODE (operands[2]) == CONST_INT\n-\t\t\t  && (INTVAL (operands[2]) == 0x7fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0x3fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0x1fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0x0fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffffe\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffffc\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffff8\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffff0)\")\n-\t     (const_int 0)) (const_string \"set_zn\")\n-\t  ] (const_string \"set_znv\")))])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"*\n {\n@@ -1282,43 +1329,28 @@\n     return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n   return \\\"and %2,%0\\\";\n }\"\n-  [(set (attr \"cc\")\n-\t(cond\n-\t [\n-\t (eq (symbol_ref \"which_alternative\") (const_int 0)\n-\t     ) (const_string \"none_0hit\")\n-\t ;; Shifts don't set the V flag, but bitwise operations clear\n-\t ;; it (which correctly reflects the absence of overflow in a\n-\t ;; compare-with-zero that might follow).  As for the\n-\t ;; 0xfffffffe case, the add may overflow, so we can't use the\n-\t ;; V flag.\n-\t (ne (symbol_ref \"GET_CODE (operands[2]) == CONST_INT\n-\t\t\t  && (INTVAL (operands[2]) == 0x7fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0x3fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0x1fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0x0fffffff\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffffe\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffffc\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffff8\n-\t\t\t      || INTVAL (operands[2]) == 0xfffffff0)\")\n-\t     (const_int 0)) (const_string \"set_zn\")\n-\t  ] (const_string \"set_znv\")))])\n+)\n \n ;; ----------------------------------------------------------------------\n ;; OR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n+\t\t   (ior:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -1338,31 +1370,38 @@\n     return \\\"or %1,%0\\\";\n   return \\\"or %2,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"or %2,%0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+)\n \n ;; ----------------------------------------------------------------------\n ;; XOR INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n+\t\t   (xor:SI (match_operand:SI 1 \"register_operand\")\n+\t\t\t   (match_operand:SI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -1382,39 +1421,48 @@\n     return \\\"xor %1,%0\\\";\n   return \\\"xor %2,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))]\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"xor %2,%0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+)\n \n ;; ----------------------------------------------------------------------\n ;; NOT INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI         0 \"register_operand\")\n+\t\t   (not:SI (match_operand:SI 1 \"register_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n+(define_insn \"*am33_cmplsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx,!dax\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"0,0\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"not %0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+)\n \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n+(define_insn \"*mn10300_cmplsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=dx\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"not %0\"\n-  [(set_attr \"cc\" \"set_znv\")])\n+)\n \f\n ;; -----------------------------------------------------------------\n ;; BIT FIELDS\n@@ -1426,95 +1474,112 @@\n ;; They are no smaller/faster than loading the value into a register\n ;; and storing the register, but they don't need a scratch register\n ;; which may allow for better code generation.\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int 0))]\n-  \"\"\n+(define_insn \"*byte_clear\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int 0))\n+   (clobber (reg:CC CC_REG))\n+   ]\n+  \"GET_CODE (operands[0]) != MEM || (! MEM_VOLATILE_P (operands[0]) && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n   \"@\n   bclr 255,%A0\n   clr %0\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int -1))]\n-  \"\"\n+(define_insn \"*byte_set\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,d\") (const_int -1))\n+   (clobber (reg:CC CC_REG))\n+  ]\n+  \"GET_CODE (operands[0]) != MEM || (! MEM_VOLATILE_P (operands[0]) && GET_CODE (XEXP (operands[0], 0)) != PLUS)\"\n   \"@\n   bset 255,%A0\n   mov -1,%0\"\n-  [(set_attr \"cc\" \"clobber,none_0hit\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*bit_clear1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"+R,d\")\n \t(subreg:QI\n \t  (and:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))]\n+\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"@\n   bclr %N1,%A0\n   and %1,%0\"\n-  [(set_attr \"cc\" \"clobber,set_znv\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*bit_clear2\"\n   [(set (match_operand:QI 0 \"memory_operand\" \"=R,T\")\n \t(and:QI\n \t (match_dup 0)\n-\t (not:QI (match_operand:QI 1 \"nonmemory_operand\" \"i,d\"))))]\n+\t (not:QI (match_operand:QI 1 \"nonmemory_operand\" \"i,d\"))))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"@\n   bclr %U1,%A0\n   bclr %1,%0\"\n-  [(set_attr \"cc\" \"clobber,clobber\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*bit_set\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"+R,d\")\n \t(subreg:QI\n \t  (ior:SI (subreg:SI (match_dup 0) 0)\n-\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))]\n+\t\t  (match_operand:SI 1 \"const_int_operand\" \"i,i\")) 0))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"@\n   bset %U1,%A0\n   or %1,%0\"\n-  [(set_attr \"cc\" \"clobber,set_znv\")])\n+)\n \n (define_expand \"iorqi3\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"\")\n-\t\t(match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:QI         0 \"nonimmediate_operand\")\n+\t\t   (ior:QI (match_operand:QI 1 \"nonimmediate_operand\")\n+\t\t\t   (match_operand:QI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_iorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,T,r\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n \t\t;; This constraint should really be nonmemory_operand,\n \t\t;; but making it general_operand, along with the\n \t\t;; condition that not both input operands are MEMs, it\n \t\t;; here helps combine do a better job.\n-\t\t(match_operand:QI 2 \"general_operand\" \"i,d,ir\")))]\n+\t\t(match_operand:QI 2 \"general_operand\" \"i,d,ir\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33 &&\n    (GET_CODE (operands[2]) != MEM || GET_CODE (operands[1]) != MEM)\"\n   \"@\n   bset %U2,%A0\n   bset %2,%0\n   or %2,%0\"\n-  [(set_attr \"cc\" \"clobber,clobber,set_znv\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_iorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=R,T,d\")\n \t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n \t\t;; This constraint should really be nonmemory_operand,\n \t\t;; but making it general_operand, along with the\n \t\t;; condition that not both input operands are MEMs, it\n \t\t;; here helps combine do a better job.\n-\t\t(match_operand:QI 2 \"general_operand\" \"i,d,id\")))]\n+\t\t(match_operand:QI 2 \"general_operand\" \"i,d,id\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"GET_CODE (operands[2]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"@\n   bset %U2,%A0\n   bset %2,%0\n   or %2,%0\"\n-  [(set_attr \"cc\" \"clobber,clobber,set_znv\")])\n+)\n \n-(define_insn \"\"\n-  [(set (cc0)\n+(define_insn \"*test_int_bitfield\"\n+  [(set (reg:CC CC_REG)\n      (compare (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n \t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n \t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n@@ -1539,10 +1604,10 @@\n   output_asm_insn (\\\"btst %1,%0\\\", xoperands);\n   return \\\"\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n-(define_insn \"\"\n-  [(set (cc0)\n+(define_insn \"*test_byte_bitfield\"\n+  [(set (reg:CC CC_REG)\n      (compare (zero_extract:SI (match_operand:QI 0 \"general_operand\" \"R,dx\")\n \t\t\t       (match_operand 1 \"const_int_operand\" \"\")\n \t\t\t       (match_operand 2 \"const_int_operand\" \"\"))\n@@ -1585,18 +1650,20 @@\n     output_asm_insn (\\\"btst %U1,%A0\\\", xoperands);\n   return \\\"\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n-(define_insn \"\"\n-  [(set (cc0) (compare (and:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t\t       (match_operand:SI 1 \"const_int_operand\" \"\"))\n-\t\t       (const_int 0)))]\n+(define_insn \"*bit_test\"\n+  [(set (reg:CC CC_REG)\n+\t(compare (and:SI (match_operand:SI 0 \"register_operand\" \"dx\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t\t (const_int 0)))\n+  ]\n   \"\"\n   \"btst %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n-(define_insn \"\"\n-  [(set (cc0)\n+(define_insn \"*subreg_bit_test\"\n+  [(set (reg:CC CC_REG)\n      (compare (and:SI\n \t       (subreg:SI (match_operand:QI 0 \"general_operand\" \"R,dx\") 0)\n \t       (match_operand:SI 1 \"const_8bit_operand\" \"\"))\n@@ -1605,83 +1672,144 @@\n   \"@\n   btst %U1,%A0\n   btst %1,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n \f\n ;; ----------------------------------------------------------------------\n-;; JUMP INSTRUCTIONS\n+;; COMPARE AND BRANCH INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+;; We expand the comparison into a single insn so that it will not be split\n+;; up by reload.\n (define_expand \"cbranchsi4\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-   (set (pc)\n-      (if_then_else\n-            (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n-\t                                                     (const_int 0)])\n-              (label_ref (match_operand 3 \"\" \"\"))\n+  [(set (pc)\n+\t(if_then_else\n+\t      (match_operator                    0 \"ordered_comparison_operator\"\n+\t\t\t      [(match_operand:SI 1 \"register_operand\")\n+\t\t\t       (match_operand:SI 2 \"nonmemory_operand\")])\n+              (label_ref (match_operand          3 \"\"))\n               (pc)))]\n   \"\"\n-  \"\")\n+  \"\"\n+)\n \n-(define_expand \"cbranchsf4\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t (match_operand:SF 2 \"nonmemory_operand\" \"\")))\n-   (set (pc)\n-      (if_then_else\n-            (match_operator 0 \"ordered_comparison_operator\" [(cc0)\n-\t                                                     (const_int 0)])\n-              (label_ref (match_operand 3 \"\" \"\"))\n-              (pc)))]\n-  \"TARGET_AM33_2\"\n-  \"\")\n+(define_insn_and_split \"*cbranchsi4_post_reload\"\n+  [(set (pc)\n+\t(if_then_else (match_operator           3 \"ordered_comparison_operator\"\n+                       [(match_operand:SI       0 \"register_operand\"  \"dax\")\n+\t\t        (match_operand:SI       1 \"nonmemory_operand\" \"daxi\")])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))\n+   ]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  /* We construct the split by hand as otherwise the JUMP_LABEL\n+     attribute is not set correctly on the jump insn.  */\n+  emit_insn (gen_cmpsi (operands[0], operands[1]));\n+  \n+  emit_jump_insn (gen_integer_conditional_branch (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n+\t\t\t\t\t\t \t\t CCmode,\n+\t\t\t\t \t\t \t\t gen_rtx_REG (CCmode, CC_REG),\n+\t\t\t\t\t\t\t\t const0_rtx),\n+\t\t\t\t\t          operands[2]));\n+  \"\n+)\n+\n+;; Ordinarily, the cmp instruction will set the Z bit of cc0 to 1 if\n+;; its operands hold equal values, but the operands of a cmp\n+;; instruction must be distinct registers.  In the case where we'd\n+;; like to compare a register to itself, we can achieve this effect\n+;; with a btst 0,d0 instead.  (This will not alter the contents of d0\n+;; but will have the proper effect on cc0.  Using d0 is arbitrary; any\n+;; data register would work.)\n \n+;; Even though the first alternative would be preferable if it can\n+;; possibly match, reload must not be given the opportunity to attempt\n+;; to use it.  It assumes that such matches can only occur when one of\n+;; the operands is used for input and the other for output.  Since\n+;; this is not the case, it abort()s.  Indeed, such a reload cannot be\n+;; possibly satisfied, so just mark the alternative with a `!', so\n+;; that it is not considered by reload.\n \n-;; Conditional jump instructions\n+(define_insn \"cmpsi\"\n+  [(set (reg:CC CC_REG)\n+\t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax,dax\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"*0,I,daxi\")))]\n+  \"\"\n+  {\n+    if (which_alternative == 0)\n+      return \\\"btst 0,d0\\\";\n+    if (which_alternative == 1)\n+      return mn10300_output_cmp (operands[0], insn);\n+    return \\\"cmp %1,%0\\\";\n+  }\n+)\n \n-(define_insn \"\"\n+(define_insn \"integer_conditional_branch\"\n   [(set (pc)\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t(if_then_else (match_operator 0 \"comparison_operator\" [(reg:CC CC_REG) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"*\n-{\n-  if (cc_status.mdep.fpCC)\n-    return \\\"fb%b1 %0\\\";\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n-      && (GET_CODE (operands[1]) == GT\n-\t  || GET_CODE (operands[1]) == GE\n-\t  || GET_CODE (operands[1]) == LE\n-\t  || GET_CODE (operands[1]) == LT))\n-    return 0;\n-  return \\\"b%b1 %0\\\";\n-}\"\n- [(set_attr \"cc\" \"none\")])\n+  \"b%b0 %1\"\n+)\n \n-(define_insn \"\"\n+(define_expand \"cbranchsf4\"\n   [(set (pc)\n-\t(if_then_else (match_operator 1 \"comparison_operator\"\n-\t\t\t\t      [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+      (if_then_else\n+            (match_operator                    0 \"ordered_comparison_operator\"\n+\t\t\t    [(match_operand:SF 1 \"register_operand\")\n+\t\t\t     (match_operand:SF 2 \"nonmemory_operand\")])\n+\t    (label_ref (match_operand          3 \"\"))\n+\t    (pc)))]\n+  \"TARGET_AM33_2\"\n   \"\"\n-  \"*\n-{\n-  if (cc_status.mdep.fpCC)\n-    return \\\"fb%B1 %0\\\";\n-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0\n-      && (GET_CODE (operands[1]) == GT\n-\t  || GET_CODE (operands[1]) == GE\n-\t  || GET_CODE (operands[1]) == LE\n-\t  || GET_CODE (operands[1]) == LT))\n-    return 0;\n-  return \\\"b%B1 %0\\\";\n-}\"\n- [(set_attr \"cc\" \"none\")])\n+)\n+\n+(define_insn_and_split \"*cbranchsf4_post_reload\"\n+  [(set (pc)\n+\t(if_then_else (match_operator            3 \"ordered_comparison_operator\"\n+\t\t\t[(match_operand:SF       0 \"register_operand\"  \"f\")\n+\t\t\t (match_operand:SF       1 \"nonmemory_operand\" \"fF\")])\n+\t\t      (label_ref (match_operand  2 \"\" \"\"))\n+\t\t      (pc)))\n+   ]\n+  \"TARGET_AM33_2\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  \"\n+  /* We construct the split by hand as otherwise the JUMP_LABEL\n+     attribute is not set correctly on the jump insn.  */\n+  emit_insn (gen_am33_cmpsf (operands[0], operands[1]));\n+  \n+  emit_jump_insn (gen_float_conditional_branch (gen_rtx_fmt_ee (GET_CODE (operands[3]),\n+  \t\t \t\t\t       \t\t       CC_FLOATmode,\n+ \t\t \t\t \t       \t\t       gen_rtx_REG (CC_FLOATmode, CC_REG),\n+\t\t\t\t\t\t\t       const0_rtx),\n+\t\t\t\t\t\toperands[2]));\n+  \"\n+)\n+\n+(define_insn \"am33_cmpsf\"\n+  [(set (reg:CC_FLOAT CC_REG)\n+\t(compare:CC_FLOAT (match_operand:SF 0 \"register_operand\"  \"f\")\n+\t\t\t  (match_operand:SF 1 \"nonmemory_operand\" \"fF\")))]\n+  \"TARGET_AM33_2\"\n+  \"fcmp %1, %0\"\n+)\n+\n+(define_insn \"float_conditional_branch\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\" [(reg:CC_FLOAT CC_REG) (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_AM33_2\"\n+  \"fb%b0 %1\"\n+)\n \n ;; Unconditional and other jump instructions.\n \n@@ -1690,13 +1818,13 @@\n \t(label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"jmp %l0\"\n- [(set_attr \"cc\" \"none\")])\n+)\n \n (define_insn \"indirect_jump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))]\n   \"\"\n   \"jmp (%0)\"\n-  [(set_attr \"cc\" \"none\")])\n+)\n \n (define_expand \"builtin_setjmp_receiver\"\n   [(match_operand 0 \"\" \"\")]\n@@ -1710,10 +1838,10 @@\n }\")\n \n (define_expand \"casesi\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\n-   (match_operand:SI 1 \"immediate_operand\" \"\")\n-   (match_operand:SI 2 \"immediate_operand\" \"\")\n-   (match_operand 3 \"\" \"\") (match_operand 4 \"\" \"\")]\n+  [(match_operand:SI 0 \"register_operand\")\n+   (match_operand:SI 1 \"immediate_operand\")\n+   (match_operand:SI 2 \"immediate_operand\")\n+   (match_operand 3 \"\" \"\") (match_operand 4 \"\")]\n   \"\"\n   \"\n {\n@@ -1723,15 +1851,15 @@\n   rtx test;\n \n   emit_move_insn (table, gen_rtx_LABEL_REF (VOIDmode, operands[3]));\n-  emit_move_insn (index, plus_constant (operands[0], - INTVAL (operands[1])));\n+  emit_insn (gen_addsi3 (index, operands[0], GEN_INT (- INTVAL (operands[1]))));\n   test = gen_rtx_fmt_ee (GTU, VOIDmode, index, operands[2]);\n   emit_jump_insn (gen_cbranchsi4 (test, index, operands[2], operands[4]));\n  \n-  emit_move_insn (index, gen_rtx_ASHIFT (SImode, index, const2_rtx));\n+  emit_insn (gen_ashlsi3 (index, index, const2_rtx));\n   emit_move_insn (addr, gen_rtx_MEM (SImode,\n \t\t\t\t     gen_rtx_PLUS (SImode, table, index)));\n   if (flag_pic)\n-    emit_move_insn (addr, gen_rtx_PLUS (SImode, addr, table));\n+    emit_insn (gen_addsi3 (addr, addr, table));\n \n   emit_jump_insn (gen_tablejump (addr, operands[3]));\n   DONE;\n@@ -1742,13 +1870,13 @@\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"jmp (%0)\"\n-  [(set_attr \"cc\" \"none\")])\n+)\n \n ;; Call subroutine with no return value.\n \n (define_expand \"call\"\n-  [(call (match_operand:QI 0 \"general_operand\" \"\")\n-\t (match_operand:SI 1 \"general_operand\" \"\"))]\n+  [(call (match_operand:QI 0 \"general_operand\")\n+\t (match_operand:SI 1 \"general_operand\"))]\n   \"\"\n   \"\n {\n@@ -1785,15 +1913,15 @@\n   else\n     return \\\"call %C0,[],0\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n \n (define_expand \"call_value\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (match_operand:QI 1 \"general_operand\" \"\")\n-\t      (match_operand:SI 2 \"general_operand\" \"\")))]\n+  [(set (match_operand 0 \"\")\n+\t(call (match_operand:QI 1 \"general_operand\")\n+\t      (match_operand:SI 2 \"general_operand\")))]\n   \"\"\n   \"\n {\n@@ -1833,13 +1961,13 @@\n   else\n     return \\\"call %C1,[],0\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n (define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n+  [(parallel [(call (match_operand 0 \"\")\n                     (const_int 0))\n-              (match_operand 1 \"\" \"\")\n-              (match_operand 2 \"\" \"\")])]\n+              (match_operand 1 \"\")\n+              (match_operand 2 \"\")])]\n   \"\"\n   \"\n {\n@@ -1859,16 +1987,16 @@\n   [(const_int 0)]\n   \"\"\n   \"nop\"\n-  [(set_attr \"cc\" \"none\")])\n+)\n \f\n ;; ----------------------------------------------------------------------\n ;; EXTEND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+  [(set (match_operand:SI 0 \"general_operand\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"\")))]\n+\t (match_operand:QI 1 \"general_operand\")))]\n   \"\"\n   \"\")\n \n@@ -1884,7 +2012,7 @@\n   extbu %0\n   mov %1,%0\\;extbu %0\n   movbu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,dx\")\n@@ -1895,12 +2023,12 @@\n   extbu %0\n   mov %1,%0\\;extbu %0\n   movbu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+  [(set (match_operand:SI 0 \"general_operand\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"\")))]\n+\t (match_operand:HI 1 \"general_operand\")))]\n   \"\"\n   \"\")\n \n@@ -1916,7 +2044,7 @@\n   exthu %0\n   mov %1,%0\\;exthu %0\n   movhu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx,dx\")\n@@ -1927,14 +2055,14 @@\n   exthu %0\n   mov %1,%0\\;exthu %0\n   movhu %1,%0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n ;;- sign extension instructions\n \n (define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+  [(set (match_operand:SI 0 \"general_operand\")\n \t(sign_extend:SI\n-\t (match_operand:QI 1 \"general_operand\" \"\")))]\n+\t (match_operand:QI 1 \"general_operand\")))]\n   \"\"\n   \"\")\n \n@@ -1948,7 +2076,7 @@\n   mov %1,%0\\;extb %0\n   extb %0\n   mov %1,%0\\;extb %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx\")\n@@ -1958,12 +2086,12 @@\n   \"@\n   extb %0\n   mov %1,%0\\;extb %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_expand \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+  [(set (match_operand:SI 0 \"general_operand\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"general_operand\" \"\")))]\n+\t (match_operand:HI 1 \"general_operand\")))]\n   \"\"\n   \"\")\n \n@@ -1977,7 +2105,7 @@\n   mov %1,%0\\;exth %0\n   exth %0\n   mov %1,%0\\;exth %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dx,dx\")\n@@ -1987,25 +2115,30 @@\n   \"@\n   exth %0\n   mov %1,%0\\;exth %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \f\n ;; ----------------------------------------------------------------------\n ;; SHIFTS\n ;; ----------------------------------------------------------------------\n \n (define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI\n-\t (match_operand:SI 1 \"register_operand\" \"\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n+\t\t   (ashift:SI\n+\t\t    (match_operand:SI 1 \"register_operand\")\n+\t\t    (match_operand:QI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,!dax\")\n \t(ashift:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0,dax\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"J,dxi,dax\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"J,dxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -2032,35 +2165,42 @@\n     return \\\"mov %1,%0\\;asl %S2,%0\\\";\n   return \\\"asl %2,%1,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,dx,dx,dx\")\n \t(ashift:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,0,0,0,0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"J,K,M,L,dxi\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"J,K,M,L,dxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"@\n   add %0,%0\n   asl2 %0\n   asl2 %0\\;add %0,%0\n   asl2 %0\\;asl2 %0\n   asl %S2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n (define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n+\t\t   (lshiftrt:SI\n+\t\t    (match_operand:SI 1 \"register_operand\")\n+\t\t    (match_operand:QI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n \t(lshiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,dax\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -2073,30 +2213,37 @@\n     return \\\"mov %1,%0\\;lsr %S2,%0\\\";\n   return \\\"lsr %2,%1,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(lshiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"lsr %S2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n (define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI\n-\t (match_operand:SI 1 \"register_operand\" \"\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\")\n+\t\t   (ashiftrt:SI\n+\t\t    (match_operand:SI 1 \"register_operand\")\n+\t\t    (match_operand:QI 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n-(define_insn \"\"\n+(define_insn \"*am33_ashrisi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n \t(ashiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0,dax\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"TARGET_AM33\"\n   \"*\n {\n@@ -2109,16 +2256,18 @@\n     return \\\"mov %1,%0\\;asr %S2,%0\\\";\n   return \\\"asr %2,%1,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n-(define_insn \"\"\n+(define_insn \"*mn10300_ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(ashiftrt:SI\n \t (match_operand:SI 1 \"register_operand\" \"0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))]\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi\")))\n+   (clobber (reg:CC CC_REG))\n+  ]\n   \"\"\n   \"asr %S2,%0\"\n-  [(set_attr \"cc\" \"set_zn\")])\n+)\n \n ;; ----------------------------------------------------------------------\n ;; FP INSTRUCTIONS\n@@ -2132,8 +2281,8 @@\n ;;\n \n (define_expand \"absdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (abs:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:DF         0 \"register_operand\")\n+        (abs:DF (match_operand:DF 1 \"register_operand\")))]\n   \"\"\n   \"\n {\n@@ -2161,8 +2310,8 @@\n }\")\n \n (define_expand \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-        (abs:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:SF         0 \"register_operand\")\n+        (abs:SF (match_operand:SF 1 \"register_operand\")))]\n   \"\"\n   \"\n {\n@@ -2191,17 +2340,17 @@\n \n \n (define_insn \"abssf2_am33_2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:SF         0 \"register_operand\" \"=f,f\")\n \t(abs:SF (match_operand:SF 1 \"register_operand\" \"0,?f\")))]\n   \"TARGET_AM33_2\"\n   \"@\n    fabs %0\n    fabs %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_expand \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-        (neg:DF (match_operand:DF 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:DF         0 \"register_operand\")\n+        (neg:DF (match_operand:DF 1 \"register_operand\")))]\n   \"\"\n   \"\n {\n@@ -2230,8 +2379,8 @@\n }\")\n \n (define_expand \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-        (neg:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:SF         0 \"register_operand\")\n+        (neg:SF (match_operand:SF 1 \"register_operand\")))]\n   \"\"\n   \"\n {\n@@ -2260,17 +2409,17 @@\n }\")\n \n (define_insn \"negsf2_am33_2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+  [(set (match_operand:SF         0 \"register_operand\" \"=f,f\")\n \t(neg:SF (match_operand:SF 1 \"register_operand\" \"0,?f\")))]\n   \"TARGET_AM33_2\"\n   \"@\n    fneg %0\n    fneg %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_expand \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"\")))]\n+  [(set (match_operand:SF          0 \"register_operand\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\")))]\n   \"TARGET_AM33_2 && flag_unsafe_math_optimizations\"\n   \"\n {\n@@ -2282,91 +2431,138 @@\n }\")\n \n (define_insn \"rsqrtsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(div:SF (match_operand:SF 2 \"const_1f_operand\" \"F,F\")\n-\t\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0,?f\"))))]\n+  [(set (match_operand:SF                  0 \"register_operand\" \"=f,f\")\n+\t(div:SF (match_operand:SF          2 \"const_1f_operand\" \"F,F\")\n+\t\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"0,?f\"))))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"@\n    frsqrt %0\n    frsqrt %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n+\n+(define_expand \"addsf3\"\n+  [(parallel [(set (match_operand:SF          0 \"register_operand\")\n+\t\t   (plus:SF (match_operand:SF 1 \"register_operand\")\n+\t\t\t    (match_operand:SF 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC_FLOAT CC_REG))])\n+  ]\n+  \"TARGET_AM33_2\"\n+  \"\"\n+)\n \n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+(define_insn \"*addsf3_internal\"\n+  [(set (match_operand:SF          0 \"register_operand\" \"=f,f\")\n \t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0,f\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"@\n    fadd %2, %0\n    fadd %2, %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n+\n+(define_expand \"subsf3\"\n+  [(parallel [(set (match_operand:SF           0 \"register_operand\")\n+\t\t   (minus:SF (match_operand:SF 1 \"register_operand\")\n+\t\t\t     (match_operand:SF 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC_FLOAT CC_REG))])\n+  ]\n+  \"TARGET_AM33_2\"\n+  \"\"\n+)\n \n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+(define_insn \"*subsf3_internal\"\n+  [(set (match_operand:SF           0 \"register_operand\" \"=f,f\")\n \t(minus:SF (match_operand:SF 1 \"register_operand\" \"0,f\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+\t\t  (match_operand:SF 2 \"general_operand\" \"f,?fF\")))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"@\n    fsub %2, %0\n    fsub %2, %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n+\n+(define_expand \"mulsf3\"\n+  [(parallel [(set (match_operand:SF          0 \"register_operand\")\n+\t\t   (mult:SF (match_operand:SF 1 \"register_operand\")\n+\t\t\t    (match_operand:SF 2 \"nonmemory_operand\")))\n+\t      (clobber (reg:CC_FLOAT CC_REG))])\n+  ]\n+  \"TARGET_AM33_2\"\n+  \"\"\n+)\n \n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+(define_insn \"*mulsf3_internal\"\n+  [(set (match_operand:SF          0 \"register_operand\" \"=f,f\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0,f\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+\t\t (match_operand:SF 2 \"general_operand\" \"f,?fF\")))\n+  (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"@\n    fmul %2, %0\n    fmul %2, %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"0,f\")\n-\t\t(match_operand:SF 2 \"general_operand\" \"f,?fF\")))]\n+  [(set (match_operand:SF         0 \"register_operand\" \"=f,f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\"  \"0,f\")\n+\t\t(match_operand:SF 2 \"nonmemory_operand\" \"f,?fF\")))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"@\n    fdiv %2, %0\n    fdiv %2, %1, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"fmaddsf4\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+  [(set (match_operand:SF                   0 \"register_operand\" \"=A\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"register_operand\" \"f\"))\n-\t\t (match_operand:SF 3 \"register_operand\" \"f\")))]\n+\t\t (match_operand:SF          3 \"register_operand\" \"f\")))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"fmadd %1, %2, %3, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"fmsubsf4\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+  [(set (match_operand:SF                    0 \"register_operand\" \"=A\")\n \t(minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n \t\t\t   (match_operand:SF 2 \"register_operand\" \"f\"))\n-\t\t  (match_operand:SF 3 \"register_operand\" \"f\")))]\n+\t\t  (match_operand:SF          3 \"register_operand\" \"f\")))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"fmsub %1, %2, %3, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"fnmaddsf4\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n-\t(minus:SF (match_operand:SF 3 \"register_operand\" \"f\")\n+  [(set (match_operand:SF                    0 \"register_operand\" \"=A\")\n+\t(minus:SF (match_operand:SF          3 \"register_operand\" \"f\")\n \t\t  (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n-\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\"))))]\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\"))))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"fnmadd %1, %2, %3, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n+)\n \n (define_insn \"fnmsubsf4\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=A\")\n+  [(set (match_operand:SF                            0 \"register_operand\" \"=A\")\n \t(minus:SF (neg:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n \t\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\")))\n-\t\t  (match_operand:SF 3 \"register_operand\" \"f\")))]\n+\t\t  (match_operand:SF                  3 \"register_operand\" \"f\")))\n+   (clobber (reg:CC_FLOAT CC_REG))\n+  ]\n   \"TARGET_AM33_2\"\n   \"fnmsub %1, %2, %3, %0\"\n-  [(set_attr \"cc\" \"none_0hit\")])\n-\n+)\n \n ;; ----------------------------------------------------------------------\n ;; PROLOGUE/EPILOGUE\n@@ -2390,7 +2586,7 @@\n    (return)]\n   \"\"\n   \"rets\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n ;; This insn restores the callee saved registers and does a return, it\n ;; can also deallocate stack space.\n@@ -2406,12 +2602,12 @@\n   fprintf (asm_out_file, \\\",%d\\\\n\\\", (int) INTVAL (operands[0]));\n   return \\\"\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n ;; This instruction matches one generated by mn10300_gen_multiple_store()\n (define_insn \"store_movm\"\n   [(match_parallel 0 \"store_multiple_operation\"\n-    [(set (reg:SI 9) (plus:SI (reg:SI 9) (match_operand 1 \"\" \"\")))])]\n+    [(set (reg:SI SP_REG) (plus:SI (reg:SI SP_REG) (match_operand 1 \"\" \"\")))])]\n   \"\"\n   \"*\n {\n@@ -2421,7 +2617,7 @@\n   fprintf (asm_out_file, \\\",(sp)\\\\n\\\");\n   return \\\"\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n (define_insn \"return\"\n   [(return)]\n@@ -2437,73 +2633,29 @@\n   else\n     return \\\"rets\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n ;; Try to combine consecutive updates of the stack pointer (or any\n ;; other register for that matter).\n (define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=dxay\")\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand 1 \"const_int_operand\" \"\")))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (match_operand 2 \"const_int_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=dxay\")\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand 1 \"const_int_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (match_operand 2 \"const_int_operand\" \"\")))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"*\n {\n   operands[1] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[1]));\n   return \\\"add %1,%0\\\";\n }\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-;;\n-;; We had patterns to check eq/ne, but the they don't work because\n-;; 0x80000000 + 0x80000000 = 0x0 with a carry out.\n-;;\n-;; The Z flag and C flag would be set, and we have no way to\n-;; check for the Z flag set and C flag clear.\n-;;\n-;; This will work on the mn10200 because we can check the ZX flag\n-;; if the comparison is in HImode.\n-(define_peephole\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t       (const_int 0)))\n-   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (match_operand 1 \"\" \"\")\n-\t\t\t   (pc)))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcc %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t       (const_int 0)))\n-   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (match_operand 1 \"\" \"\")\n-\t\t\t   (pc)))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcs %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t       (const_int 0)))\n-   (set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (match_operand 1 \"\" \"\")))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcs %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n-\n-(define_peephole\n-  [(set (cc0) (compare (match_operand:SI 0 \"register_operand\" \"dx\")\n-\t\t       (const_int 0)))\n-   (set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (pc)\n-\t\t\t   (match_operand 1 \"\" \"\")))]\n-  \"dead_or_set_p (ins1, operands[0]) && REG_OK_FOR_INDEX_P (operands[0])\"\n-  \"add %0,%0\\;bcc %1\"\n-  [(set_attr \"cc\" \"clobber\")])\n+)\n \n (define_expand \"int_label\"\n   [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_INT_LABEL)]\n@@ -2531,35 +2683,34 @@\n     [(set (reg:SI PIC_REG) (pc))\n      (use (match_operand 0 \"\" \"\"))])]\n   \"TARGET_AM33\"\n-  \"%0:\\;mov pc,a2\")\n-\n+  \"%0:\\;mov pc,a2\"\n+)\n \n (define_insn_and_split \"mn10300_loadPC\"\n   [(parallel\n     [(set (reg:SI PIC_REG) (pc))\n      (use (match_operand 0 \"\" \"\"))])]\n-  \"\"\n+  \"! TARGET_AM33\"\n   \"#\"\n-  \"reload_completed\"\n+  \"&& reload_completed\"\n   [(match_operand 0 \"\" \"\")]\n-  \"\n-{\n-  rtx sp_reg = gen_rtx_REG (SImode, SP_REG);\n-  int need_stack_space = (get_frame_size () == 0\n-\t\t\t  && crtl->outgoing_args_size == 0);\n+  {\n+    rtx sp_reg = gen_rtx_REG (SImode, SP_REG);\n+    int need_stack_space = (get_frame_size () == 0\n+\t                    && crtl->outgoing_args_size == 0);\n \n-  if (need_stack_space)\n-    emit_move_insn (sp_reg, plus_constant (sp_reg, -4));\n+    if (need_stack_space)\n+      emit_insn (gen_addsi3 (sp_reg, sp_reg, GEN_INT (-4)));\n \n-  emit_insn (gen_call_next_insn (operands[0]));\n+    emit_insn (gen_call_next_insn (operands[0]));\n \n-  if (need_stack_space)\n-    emit_insn (gen_pop_pic_reg ());\n-  else\n-    emit_move_insn (pic_offset_table_rtx, gen_rtx_MEM (SImode, sp_reg));\n-\n-  DONE;\n-}\")\n+    if (need_stack_space)\n+      emit_insn (gen_pop_pic_reg ());\n+    else\n+      emit_move_insn (pic_offset_table_rtx, gen_rtx_MEM (SImode, sp_reg));\n+    DONE;\n+  }\n+)\n \n (define_insn \"call_next_insn\"\n   [(parallel\n@@ -2569,16 +2720,44 @@\n   \"calls %0\\;%0:\")\n \n (define_expand \"add_GOT_to_pic_reg\"\n-  [(set (reg:SI PIC_REG)\n-\t(plus:SI\n-\t (reg:SI PIC_REG)\n-\t (const:SI\n-\t  (unspec:SI [(match_operand:SI 0 \"\" \"\")] UNSPEC_GOTSYM_OFF))))]\n-  \"\")\n+  [(parallel [(set (reg:SI PIC_REG)\n+\t\t   (plus:SI\n+\t\t    (reg:SI PIC_REG)\n+\t\t    (const:SI\n+\t\t     (unspec:SI [(minus:SI\n+\t\t\t       (match_dup 1)\n+\t\t\t       (const (minus:SI\n+\t\t\t\t       (const (match_operand:SI 0 \"\" \"\"))\n+\t\t\t\t       (pc))))\n+\t\t\t      ] UNSPEC_PIC))))\n+\t      (clobber (reg:CC CC_REG))\n+\t      ])\n+  ]\n+  \"\"\n+  \"operands[1] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\"\n+)\n+\n+(define_expand \"add_GOT_to_any_reg\"\n+  [(parallel [(set (match_operand:SI 0 \"\" \"\")\n+\t\t   (plus:SI\n+\t\t    (match_operand:SI 1 \"\" \"\")\n+\t\t    (const\n+\t\t     (unspec [(minus:SI\n+\t\t\t       (match_dup 3)\n+\t\t\t       (const (minus:SI\n+\t\t\t\t       (const (match_operand:SI 2 \"\" \"\"))\n+\t\t\t\t       (pc))))\n+\t\t\t      ] UNSPEC_PIC))))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n+  \"\"\n+  \"operands[3] = gen_rtx_SYMBOL_REF (VOIDmode, GOT_SYMBOL_NAME);\"\n+)\n \n (define_expand \"symGOT2reg\"\n-  [(match_operand:SI 0 \"\" \"\")\n-   (match_operand:SI 1 \"\" \"\")]\n+  [(match_operand:SI 0 \"\")\n+   (match_operand:SI 1 \"\")]\n   \"\"\n   \"\n {\n@@ -2592,15 +2771,15 @@\n }\")\n \n (define_expand \"symGOT2reg_i\"\n-  [(set (match_operand:SI 0 \"\" \"\")\n+  [(set (match_operand:SI 0 \"\")\n \t(mem:SI (plus:SI (reg:SI PIC_REG)\n-\t\t\t (const (unspec [(match_operand:SI 1 \"\" \"\")]\n+\t\t\t (const (unspec [(match_operand:SI 1 \"\")]\n \t\t\t\t\tUNSPEC_GOT)))))]\n   \"\"\n   \"\")\n \n (define_expand \"symGOTOFF2reg\"\n-  [(match_operand:SI 0 \"\" \"\") (match_operand:SI 1 \"\" \"\")]\n+  [(match_operand:SI 0 \"\") (match_operand:SI 1 \"\")]\n   \"\"\n   \"\n {\n@@ -2612,16 +2791,21 @@\n }\")\n \n (define_expand \"symGOTOFF2reg_i\"\n-  [(set (match_operand:SI 0 \"\" \"\")\n-\t(const (unspec [(match_operand:SI 1 \"\" \"\")] UNSPEC_GOTOFF)))\n-  (set (match_dup 0) (plus:SI (match_dup 0) (reg:SI PIC_REG)))]\n+  [(set (match_operand:SI 0 \"\")\n+\t(const (unspec [(match_operand:SI 1 \"\")] UNSPEC_GOTOFF)))\n+   (parallel [(set (match_dup 0)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (reg:SI PIC_REG)))\n+\t      (clobber (reg:CC CC_REG))\n+\t     ])\n+  ]\n   \"\"\n   \"\")\n \n (define_expand \"sym2PIC\"\n-  [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_PIC)]\n+  [(unspec [(match_operand:SI 0 \"\")] UNSPEC_PIC)]\n   \"\" \"\")\n \n (define_expand \"sym2PLT\"\n-  [(unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_PLT)]\n+  [(unspec [(match_operand:SI 0 \"\")] UNSPEC_PLT)]\n   \"\" \"\")"}, {"sha": "0f76a49be74ed1a893e374590c29010a47fe72b7", "filename": "gcc/config/mn10300/predicates.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af476d7f2d3571c981b629995d3b3f1f8ffd3ab/gcc%2Fconfig%2Fmn10300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fpredicates.md?ref=4af476d7f2d3571c981b629995d3b3f1f8ffd3ab", "patch": "@@ -47,3 +47,10 @@\n \n   return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);\n })\n+\n+(define_predicate \"impossible_plus_operand\"\n+  (match_code \"plus\")\n+{\n+  return XEXP (op, 0) == stack_pointer_rtx\n+      || XEXP (op, 1) == stack_pointer_rtx;\n+})"}]}