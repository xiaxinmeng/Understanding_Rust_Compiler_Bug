{"sha": "bc8dd50fe4cddc779349ef79f55e9e623c3c215f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM4ZGQ1MGZlNGNkZGM3NzkzNDllZjc5ZjU1ZTllNjIzYzNjMjE1Zg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-10-18T19:02:28Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-10-18T19:02:28Z"}, "message": "[arm] Remove redundant DImode subtract patterns\n\nNow that we early split DImode subtracts, the patterns to emit the\noriginal and to match zero-extend with subtraction or negation are\nno-longer useful.\n\n\t* config/arm/arm.md (arm_subdi3): Delete insn.\n\t(zextendsidi_negsi, negdi_extendsidi): Delete insn_and_split.\n\nFrom-SVN: r277170", "tree": {"sha": "05af0c7ac02f5301fab199969f13dd4a3de07353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05af0c7ac02f5301fab199969f13dd4a3de07353"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc8dd50fe4cddc779349ef79f55e9e623c3c215f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8dd50fe4cddc779349ef79f55e9e623c3c215f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8dd50fe4cddc779349ef79f55e9e623c3c215f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8dd50fe4cddc779349ef79f55e9e623c3c215f/comments", "author": null, "committer": null, "parents": [{"sha": "da0e6bd3d347117e928a92841e8ed6da202e1426", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da0e6bd3d347117e928a92841e8ed6da202e1426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da0e6bd3d347117e928a92841e8ed6da202e1426"}], "stats": {"total": 107, "additions": 5, "deletions": 102}, "files": [{"sha": "0051bbbeb32f380843891076d0abc427e3c451ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc8dd50fe4cddc779349ef79f55e9e623c3c215f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc8dd50fe4cddc779349ef79f55e9e623c3c215f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc8dd50fe4cddc779349ef79f55e9e623c3c215f", "patch": "@@ -1,3 +1,8 @@\n+2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.md (arm_subdi3): Delete insn.\n+\t(zextendsidi_negsi, negdi_extendsidi): Delete insn_and_split.\n+\n 2019-10-18  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/arm-modes.def (CC_RSB): New CC mode."}, {"sha": "f597a277c177050d96d9f495c10aa4d207e2df02", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc8dd50fe4cddc779349ef79f55e9e623c3c215f/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc8dd50fe4cddc779349ef79f55e9e623c3c215f/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=bc8dd50fe4cddc779349ef79f55e9e623c3c215f", "patch": "@@ -1161,18 +1161,6 @@\n   \"\n )\n \n-(define_insn \"*arm_subdi3\"\n-  [(set (match_operand:DI 0 \"arm_general_register_operand\" \"=&r,&r,&r\")\n-\t(minus:DI (match_operand:DI 1 \"arm_general_register_operand\" \"0,r,0\")\n-\t\t  (match_operand:DI 2 \"arm_general_register_operand\" \"r,0,0\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT\"\n-  \"subs\\\\t%Q0, %Q1, %Q2\\;sbc\\\\t%R0, %R1, %R2\"\n-  [(set_attr \"conds\" \"clob\")\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n (define_expand \"subsi3\"\n   [(set (match_operand:SI           0 \"s_register_operand\")\n \t(minus:SI (match_operand:SI 1 \"reg_or_int_operand\")\n@@ -3866,96 +3854,6 @@\n   \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP_DOUBLE\"\n   \"\")\n \n-(define_insn_and_split \"*zextendsidi_negsi\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=r\")\n-        (zero_extend:DI (neg:SI (match_operand:SI 1 \"s_register_operand\" \"r\"))))]\n-   \"TARGET_32BIT\"\n-   \"#\"\n-   \"\"\n-   [(set (match_dup 2)\n-         (neg:SI (match_dup 1)))\n-    (set (match_dup 3)\n-         (const_int 0))]\n-   {\n-      operands[2] = gen_lowpart (SImode, operands[0]);\n-      operands[3] = gen_highpart (SImode, operands[0]);\n-   }\n- [(set_attr \"length\" \"8\")\n-  (set_attr \"type\" \"multiple\")]\n-)\n-\n-;; Negate an extended 32-bit value.\n-(define_insn_and_split \"*negdi_extendsidi\"\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"=l,r\")\n-\t(neg:DI (sign_extend:DI\n-\t\t (match_operand:SI 1 \"s_register_operand\" \"l,r\"))))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_32BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-  {\n-    rtx low = gen_lowpart (SImode, operands[0]);\n-    rtx high = gen_highpart (SImode, operands[0]);\n-\n-    if (reg_overlap_mentioned_p (low, operands[1]))\n-      {\n-\t/* Input overlaps the low word of the output.  Use:\n-\t\tasr\tRhi, Rin, #31\n-\t\trsbs\tRlo, Rin, #0\n-\t\trsc\tRhi, Rhi, #0 (thumb2: sbc Rhi, Rhi, Rhi, lsl #1).  */\n-\trtx cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n-\n-\temit_insn (gen_rtx_SET (high,\n-\t\t\t\tgen_rtx_ASHIFTRT (SImode, operands[1],\n-\t\t\t\t\t\t  GEN_INT (31))));\n-\n-\temit_insn (gen_subsi3_compare (low, const0_rtx, operands[1]));\n-\tif (TARGET_ARM)\n-\t  emit_insn (gen_rtx_SET (high,\n-\t\t\t\t  gen_rtx_MINUS (SImode,\n-\t\t\t\t\t\t gen_rtx_MINUS (SImode,\n-\t\t\t\t\t\t\t\tconst0_rtx,\n-\t\t\t\t\t\t\t\thigh),\n-\t\t\t\t\t\t gen_rtx_LTU (SImode,\n-\t\t\t\t\t\t\t      cc_reg,\n-\t\t\t\t\t\t\t      const0_rtx))));\n-\telse\n-\t  {\n-\t    rtx two_x = gen_rtx_ASHIFT (SImode, high, GEN_INT (1));\n-\t    emit_insn (gen_rtx_SET (high,\n-\t\t\t\t    gen_rtx_MINUS (SImode,\n-\t\t\t\t\t\t   gen_rtx_MINUS (SImode,\n-\t\t\t\t\t\t\t\t  high,\n-\t\t\t\t\t\t\t\t  two_x),\n-\t\t\t\t\t\t   gen_rtx_LTU (SImode,\n-\t\t\t\t\t\t\t\tcc_reg,\n-\t\t\t\t\t\t\t\tconst0_rtx))));\n-\t  }\n-      }\n-    else\n-      {\n-\t/* No overlap, or overlap on high word.  Use:\n-\t\trsb\tRlo, Rin, #0\n-\t\tbic\tRhi, Rlo, Rin\n-\t\tasr\tRhi, Rhi, #31\n-\t   Flags not needed for this sequence.  */\n-\temit_insn (gen_rtx_SET (low, gen_rtx_NEG (SImode, operands[1])));\n-\temit_insn (gen_rtx_SET (high,\n-\t\t\t\tgen_rtx_AND (SImode,\n-\t\t\t\t\t     gen_rtx_NOT (SImode, operands[1]),\n-\t\t\t\t\t     low)));\n-\temit_insn (gen_rtx_SET (high,\n-\t\t\t\tgen_rtx_ASHIFTRT (SImode, high,\n-\t\t\t\t\t\t  GEN_INT (31))));\n-      }\n-    DONE;\n-  }\n-  [(set_attr \"length\" \"12\")\n-   (set_attr \"arch\" \"t2,*\")\n-   (set_attr \"type\" \"multiple\")]\n-)\n-\n ;; abssi2 doesn't really clobber the condition codes if a different register\n ;; is being set.  To keep things simple, assume during rtl manipulations that\n ;; it does, but tell the final scan operator the truth.  Similarly for"}]}