{"sha": "78d21f929b421db5a72ffa7decf34b420c495ecb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhkMjFmOTI5YjQyMWRiNWE3MmZmYTdkZWNmMzRiNDIwYzQ5NWVjYg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-19T14:55:23Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-19T14:55:23Z"}, "message": "parse.y (obtain_incomplete_type): Don't wrap unknown types in TREE_LIST - just chain the POINTER_TYPEs together.\n\nd\n\t* parse.y (obtain_incomplete_type):  Don't wrap unknown types\n\tin TREE_LIST - just chain the POINTER_TYPEs together.\n\t(resolve_class):  If type already resolved, return decl.\n\tAfter resolving, update TREE_TYPE(class_type), and name (if array).\n\t* parse.h (do_resolve_class), parse.y:  Make non-static.\n\t* class.c (maybe_layout_super_class):  Take this_class argument.\n\tDo do_resolve_class if necessary.\n\t(layout_class, layout_class_methods): Adjust calls appropriately.\n\t* parse.h (JDEP_TO_RESOLVE, JDEP_RESOLVED_DECL, JDEP_RESOLVED,\n\tJDEP_RESOLVED_P):  Redefined for new TREE_LIST-less convention.\n\t* typeck.c (build_java_array_type):  Don't call layout_class.\n\nFrom-SVN: r25324", "tree": {"sha": "5ea05eac7742fd5a17301884eeb9665a639b6b04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ea05eac7742fd5a17301884eeb9665a639b6b04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78d21f929b421db5a72ffa7decf34b420c495ecb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d21f929b421db5a72ffa7decf34b420c495ecb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d21f929b421db5a72ffa7decf34b420c495ecb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d21f929b421db5a72ffa7decf34b420c495ecb/comments", "author": null, "committer": null, "parents": [{"sha": "846b0eb83dc79b5dcbed7c3ab5dd5c493f563a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/846b0eb83dc79b5dcbed7c3ab5dd5c493f563a2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/846b0eb83dc79b5dcbed7c3ab5dd5c493f563a2c"}], "stats": {"total": 115, "additions": 86, "deletions": 29}, "files": [{"sha": "74530c3b675d7dbab9ec4f3583b457d2a471f103", "filename": "gcc/java/parse.c", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d21f929b421db5a72ffa7decf34b420c495ecb/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d21f929b421db5a72ffa7decf34b420c495ecb/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=78d21f929b421db5a72ffa7decf34b420c495ecb", "patch": "@@ -175,7 +175,6 @@ static int check_pkg_class_access PROTO ((tree, tree));\n static tree resolve_package PROTO ((tree, tree *));\n static tree lookup_package_type PROTO ((char *, int));\n static tree resolve_class PROTO ((tree, tree, tree));\n-static tree do_resolve_class PROTO ((tree, tree, tree));\n static void declare_local_variables PROTO ((int, tree, tree));\n static void source_start_java_method PROTO ((tree));\n static void source_end_java_method PROTO ((void));\n@@ -315,6 +314,7 @@ static int array_constructor_check_entry PROTO ((tree, tree));\n static char *purify_type_name PROTO ((char *));\n static tree patch_initialized_static_field PROTO ((tree));\n static tree fold_constant_for_init PROTO ((tree, tree));\n+static tree strip_out_static_field_access_decl PROTO ((tree));\n \n /* Number of error found so far. */\n int java_error_count; \n@@ -6407,16 +6407,14 @@ obtain_incomplete_type (type_name)\n     fatal (\"invalid type name - obtain_incomplete_type\");\n \n   for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))\n-    if (TYPE_NAME (TREE_PURPOSE (ptr)) == name)\n+    if (TYPE_NAME (ptr) == name)\n       break;\n \n   if (!ptr)\n     {\n-      tree core;\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n-      BUILD_PTR_FROM_NAME (core, name);\n-      layout_type (core);\n-      ptr = build_tree_list (core, NULL_TREE);\n+      BUILD_PTR_FROM_NAME (ptr, name);\n+      layout_type (ptr);\n       pop_obstacks ();\n       TREE_CHAIN (ptr) = ctxp->incomplete_class;\n       ctxp->incomplete_class = ptr;\n@@ -6678,8 +6676,22 @@ resolve_class (class_type, decl, cl)\n {\n   char *name = IDENTIFIER_POINTER (TYPE_NAME (class_type));\n   char *base = name;\n-  tree resolved_type, resolved_type_decl;\n+  tree resolved_type = TREE_TYPE (class_type);\n+  tree resolved_type_decl;\n   \n+  if (resolved_type != NULL_TREE)\n+    {\n+      tree resolved_type_decl = TYPE_NAME (resolved_type);\n+      if (resolved_type_decl == NULL_TREE\n+\t  || TREE_CODE (resolved_type_decl) == IDENTIFIER_NODE)\n+\t{\n+\t  resolved_type_decl = build_decl (TYPE_DECL,\n+\t\t\t\t\t   TYPE_NAME (class_type),\n+\t\t\t\t\t   resolved_type);\n+\t}\n+      return resolved_type_decl;\n+    }\n+\n   /* 1- Check to see if we have an array. If true, find what we really\n      want to resolve  */\n   while (name[0] == '[')\n@@ -6710,14 +6722,16 @@ resolve_class (class_type, decl, cl)\n       /* Figure how those two things are important for error report. FIXME */\n       DECL_SOURCE_LINE (resolved_type_decl) = 0;\n       DECL_SOURCE_FILE (resolved_type_decl) = input_filename;\n+      TYPE_NAME (class_type) = TYPE_NAME (resolved_type);\n     }\n+  TREE_TYPE (class_type) = resolved_type;\n   return resolved_type_decl;\n }\n \n /* Effectively perform the resolution of class CLASS_TYPE. DECL or CL\n    are used to report error messages.  */\n \n-static tree\n+tree\n do_resolve_class (class_type, decl, cl)\n      tree class_type;\n      tree decl;\n@@ -7808,6 +7822,13 @@ check_pkg_class_access (class_name, cl)\n \n   if (!CLASS_PUBLIC (TYPE_NAME (type)))\n     {\n+      /* Access to a private class within the same package is\n+         allowed. */\n+      tree l, r;\n+      breakdown_qualified (&l, &r, class_name);\n+      if (l == ctxp->package)\n+\treturn 0;\n+\n       parse_error_context \n \t(cl, \"Can't access %s `%s'. Only public classes and interfaces in \"\n \t \"other packages can be accessed\",\n@@ -8760,6 +8781,30 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n   return field_ref;\n }\n \n+/* If NODE is an access to f static field, strip out the class\n+   initialization part and return the field decl, otherwise, return\n+   NODE. */\n+\n+static tree\n+strip_out_static_field_access_decl (node)\n+    tree node;\n+{\n+  if (TREE_CODE (node) == COMPOUND_EXPR)\n+    {\n+      tree op1 = TREE_OPERAND (node, 1);\n+      if (TREE_CODE (op1) == COMPOUND_EXPR)\n+\t {\n+\t   tree call = TREE_OPERAND (op1, 0);\n+\t   if (TREE_CODE (call) == CALL_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (call, 0)) == ADDR_EXPR\n+\t       && TREE_OPERAND (TREE_OPERAND (call, 0), 0)\n+\t       == soft_initclass_node)\n+\t     return TREE_OPERAND (op1, 1);\n+\t }\n+    }\n+  return node;\n+}\n+\n /* 6.5.5.2: Qualified Expression Names */\n \n static int\n@@ -12095,7 +12140,7 @@ patch_unaryop (node, wfl_op)\n {\n   tree op = TREE_OPERAND (node, 0);\n   tree op_type = TREE_TYPE (op);\n-  tree prom_type, value;\n+  tree prom_type, value, decl;\n   int code = TREE_CODE (node);\n   int error_found = 0;\n \n@@ -12111,9 +12156,11 @@ patch_unaryop (node, wfl_op)\n     case PREINCREMENT_EXPR:\n       /* 15.14.2 Prefix Decrement Operator -- */\n     case PREDECREMENT_EXPR:\n-      if (!JDECL_P (op) && !((TREE_CODE (op) == INDIRECT_REF \n-\t\t\t      || TREE_CODE (op) == COMPONENT_REF) \n-\t\t\t     && JPRIMITIVE_TYPE_P (TREE_TYPE (op))))\n+      decl = strip_out_static_field_access_decl (op);\n+      if (!JDECL_P (decl) \n+\t  && !((TREE_CODE (decl) == INDIRECT_REF \n+\t\t|| TREE_CODE (decl) == COMPONENT_REF) \n+\t       && JPRIMITIVE_TYPE_P (TREE_TYPE (decl))))\n \t{\n \t  tree lvalue;\n \t  /* Before screaming, check that we're not in fact trying to"}, {"sha": "aa35bd6d58db5d79ba6fec40beb69fa17512104d", "filename": "gcc/java/parse.h", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d21f929b421db5a72ffa7decf34b420c495ecb/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d21f929b421db5a72ffa7decf34b420c495ecb/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=78d21f929b421db5a72ffa7decf34b420c495ecb", "patch": "@@ -381,15 +381,11 @@ typedef struct _jdep {\n #define JDEP_APPLY_PATCH(J,P) (*(J)->patch = (P))\n #define JDEP_GET_PATCH(J)     ((J)->patch)\n #define JDEP_CHAIN(J)         ((J)->next)\n-#define JDEP_TO_RESOLVE(J)    (TREE_PURPOSE ((J)->solv))\n-#define JDEP_RESOLVED_DECL(J) ((J)->solv ? TREE_PURPOSE ((J)->solv):NULL_TREE)\n-#define JDEP_RESOLVED(J, D)\t\t\t\\\n-  {\t\t\t\t\t\t\\\n-    TREE_PURPOSE ((J)->solv) = D;\t\t\\\n-    TREE_VALUE ((J)->solv) = (J)->solv;\t\t\\\n-  }\n-#define JDEP_RESOLVED_P(J)    (!(J)->solv || \t\t\t\t\\\n-\t\t\t       TREE_VALUE ((J)->solv) == (J)->solv)\n+#define JDEP_TO_RESOLVE(J)    ((J)->solv)\n+#define JDEP_RESOLVED_DECL(J) ((J)->solv)\n+#define JDEP_RESOLVED(J, D)   ((J)->solv = D)\n+#define JDEP_RESOLVED_P(J)    \\\n+\t(!(J)->solv || TREE_CODE ((J)->solv) != POINTER_TYPE)\n \n typedef struct _jdeplist {\n   jdep *first;\n@@ -667,6 +663,7 @@ tree java_method_add_stmt PROTO ((tree, tree));\n char *java_get_line_col PROTO ((char *, int, int));\n void java_expand_switch PROTO ((tree));\n int java_report_errors PROTO (());\n+extern tree do_resolve_class PROTO ((tree, tree, tree));\n #endif\n \n /* Always in use, no matter what you compile */"}, {"sha": "7e5eeca6d2f9c989af7eabd84bf37ebba78c8163", "filename": "gcc/java/parse.y", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d21f929b421db5a72ffa7decf34b420c495ecb/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d21f929b421db5a72ffa7decf34b420c495ecb/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=78d21f929b421db5a72ffa7decf34b420c495ecb", "patch": "@@ -99,7 +99,6 @@ static int check_pkg_class_access PROTO ((tree, tree));\n static tree resolve_package PROTO ((tree, tree *));\n static tree lookup_package_type PROTO ((char *, int));\n static tree resolve_class PROTO ((tree, tree, tree));\n-static tree do_resolve_class PROTO ((tree, tree, tree));\n static void declare_local_variables PROTO ((int, tree, tree));\n static void source_start_java_method PROTO ((tree));\n static void source_end_java_method PROTO ((void));\n@@ -3806,16 +3805,14 @@ obtain_incomplete_type (type_name)\n     fatal (\"invalid type name - obtain_incomplete_type\");\n \n   for (ptr = ctxp->incomplete_class; ptr; ptr = TREE_CHAIN (ptr))\n-    if (TYPE_NAME (TREE_PURPOSE (ptr)) == name)\n+    if (TYPE_NAME (ptr) == name)\n       break;\n \n   if (!ptr)\n     {\n-      tree core;\n       push_obstacks (&permanent_obstack, &permanent_obstack);\n-      BUILD_PTR_FROM_NAME (core, name);\n-      layout_type (core);\n-      ptr = build_tree_list (core, NULL_TREE);\n+      BUILD_PTR_FROM_NAME (ptr, name);\n+      layout_type (ptr);\n       pop_obstacks ();\n       TREE_CHAIN (ptr) = ctxp->incomplete_class;\n       ctxp->incomplete_class = ptr;\n@@ -4077,8 +4074,22 @@ resolve_class (class_type, decl, cl)\n {\n   char *name = IDENTIFIER_POINTER (TYPE_NAME (class_type));\n   char *base = name;\n-  tree resolved_type, resolved_type_decl;\n+  tree resolved_type = TREE_TYPE (class_type);\n+  tree resolved_type_decl;\n   \n+  if (resolved_type != NULL_TREE)\n+    {\n+      tree resolved_type_decl = TYPE_NAME (resolved_type);\n+      if (resolved_type_decl == NULL_TREE\n+\t  || TREE_CODE (resolved_type_decl) == IDENTIFIER_NODE)\n+\t{\n+\t  resolved_type_decl = build_decl (TYPE_DECL,\n+\t\t\t\t\t   TYPE_NAME (class_type),\n+\t\t\t\t\t   resolved_type);\n+\t}\n+      return resolved_type_decl;\n+    }\n+\n   /* 1- Check to see if we have an array. If true, find what we really\n      want to resolve  */\n   while (name[0] == '[')\n@@ -4109,14 +4120,16 @@ resolve_class (class_type, decl, cl)\n       /* Figure how those two things are important for error report. FIXME */\n       DECL_SOURCE_LINE (resolved_type_decl) = 0;\n       DECL_SOURCE_FILE (resolved_type_decl) = input_filename;\n+      TYPE_NAME (class_type) = TYPE_NAME (resolved_type);\n     }\n+  TREE_TYPE (class_type) = resolved_type;\n   return resolved_type_decl;\n }\n \n /* Effectively perform the resolution of class CLASS_TYPE. DECL or CL\n    are used to report error messages.  */\n \n-static tree\n+tree\n do_resolve_class (class_type, decl, cl)\n      tree class_type;\n      tree decl;"}]}