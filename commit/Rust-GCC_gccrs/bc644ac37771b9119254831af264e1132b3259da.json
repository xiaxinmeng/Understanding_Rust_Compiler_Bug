{"sha": "bc644ac37771b9119254831af264e1132b3259da", "node_id": "C_kwDOANBUbNoAKGJjNjQ0YWMzNzc3MWI5MTE5MjU0ODMxYWYyNjRlMTEzMmIzMjU5ZGE", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-21T19:47:19Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2023-02-21T19:47:19Z"}, "message": "Merge commit 'ae113080a9f98e807db239f3ad2157c64324542f' into HEAD", "tree": {"sha": "37123bbb3c81fff06974b7a2008d99ef1abe3e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37123bbb3c81fff06974b7a2008d99ef1abe3e02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc644ac37771b9119254831af264e1132b3259da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc644ac37771b9119254831af264e1132b3259da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc644ac37771b9119254831af264e1132b3259da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc644ac37771b9119254831af264e1132b3259da/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87e7c9dedacd4d12636e6c626aab14bcecf686f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e7c9dedacd4d12636e6c626aab14bcecf686f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e7c9dedacd4d12636e6c626aab14bcecf686f2"}, {"sha": "ae113080a9f98e807db239f3ad2157c64324542f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae113080a9f98e807db239f3ad2157c64324542f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae113080a9f98e807db239f3ad2157c64324542f"}], "stats": {"total": 1113, "additions": 899, "deletions": 214}, "files": [{"sha": "219a2e22e4be839359dfca8610d77bf1c0564ff2", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,7 @@\n+2023-02-17  Petr Sumbera  <petr.sumbera@oracle.com>\n+\n+\t* make_sunver.pl: Escape brace.\n+\n 2023-02-10  Flavio Cruz  <flaviocruz@gmail.com>\n \n \t* config-list.mk: Add x86_64-gnu to list of archs."}, {"sha": "9d9b31a35d9f18aa9d38210a24cc84e62d2fbfaa", "filename": "fixincludes/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/fixincludes%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/fixincludes%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,8 @@\n+2023-02-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* inclhack.def (solaris_math_12): Add bypass.\n+\t* fixincl.x: Regenerate.\n+\n 2023-01-21  Iain Sandoe  <iain@sandoe.co.uk>\n \n \t* fixincl.x: Regenerate."}, {"sha": "a473929844b6df432e7115abe43ce489c3b2e3c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,250 @@\n+2023-02-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108819\n+\t* tree-ssa-reassoc.cc (update_ops): Fold new stmt in place.\n+\n+2023-02-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/108832\n+\t* config/i386/i386-protos.h (ix86_replace_reg_with_reg): Declare.\n+\t* config/i386/i386-expand.cc (ix86_replace_reg_with_reg): New\n+\tfunction.\n+\t* config/i386/i386.md: Replace replace_rtx calls in all peephole2s\n+\twith ix86_replace_reg_with_reg.\n+\n+2023-02-18  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/invoke.texi (AVR Options): Update link to AVR-LibC.\n+\n+2023-02-18  Xi Ruoyao  <xry111@xry111.site>\n+\n+\t* config.gcc (triplet_abi): Set its value based on $with_abi,\n+\tinstead of $target.\n+\t(la_canonical_triplet): Set it after $triplet_abi is set\n+\tcorrectly.\n+\t* config/loongarch/t-linux (MULTILIB_OSDIRNAMES): Make the\n+\tmultiarch tuple for lp64d \"loongarch64-linux-gnu\" (without\n+\t\"f64\" suffix).\n+\n+2023-02-18  Andrew Pinski  <apinski@marvell.com>\n+\n+\t* match.pd: Remove #if GIMPLE around the\n+\t\"1 - a\" pattern\n+\n+2023-02-18  Andrew Pinski  <apinski@marvell.com>\n+\n+\t* value-query.h (get_range_query): Return the global ranges\n+\tfor a nullptr func.\n+\n+2023-02-17  Siddhesh Poyarekar  <siddhesh@gotplt.org>\n+\n+\t* doc/invoke.texi (@item -Wall): Fix typo in\n+\t-Wuse-after-free.\n+\n+2023-02-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/108831\n+\t* config/i386/predicates.md\n+\t(nonimm_x64constmem_operand): New predicate.\n+\t* config/i386/i386.md (*addqi_ext<mode>_0): New insn pattern.\n+\t(*subqi_ext<mode>_0): Ditto.\n+\t(*andqi_ext<mode>_0): Ditto.\n+\t(*<any_or:code>qi_ext<mode>_0): Ditto.\n+\n+2023-02-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/108805\n+\t* simplify-rtx.cc (simplify_context::simplify_subreg): Use\n+\tint_outermode instead of GET_MODE (tem) to prevent\n+\tVOIDmode from entering simplify_gen_subreg.\n+\n+2023-02-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108821\n+\t* tree-ssa-loop-im.cc (sm_seq_valid_bb): We can also not\n+\tmove volatile accesses.\n+\n+2023-02-17  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa.cc (ssa_undefined_value_p): Assert we are not\n+\tcalled on virtual operands.\n+\t* tree-ssa-sccvn.cc (vn_phi_lookup): Guard\n+\tssa_undefined_value_p calls.\n+\t(vn_phi_insert): Likewise.\n+\t(set_ssa_val_to): Likewise.\n+\t(visit_phi): Avoid extra work with equivalences for\n+\tvirtual operand PHIs.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-bases.cc (class mask_logic): New\n+\tclass.\n+\t(class mask_nlogic): Ditto.\n+\t(class mask_notlogic): Ditto.\n+\t(class vmmv): Ditto.\n+\t(class vmclr): Ditto.\n+\t(class vmset): Ditto.\n+\t(class vmnot): Ditto.\n+\t(class vcpop): Ditto.\n+\t(class vfirst): Ditto.\n+\t(class mask_misc): Ditto.\n+\t(class viota): Ditto.\n+\t(class vid): Ditto.\n+\t(BASE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-bases.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins-functions.def (vmand): Ditto.\n+\t(vmnand): Ditto.\n+\t(vmandn): Ditto.\n+\t(vmxor): Ditto.\n+\t(vmor): Ditto.\n+\t(vmnor): Ditto.\n+\t(vmorn): Ditto.\n+\t(vmxnor): Ditto.\n+\t(vmmv): Ditto.\n+\t(vmclr): Ditto.\n+\t(vmset): Ditto.\n+\t(vmnot): Ditto.\n+\t(vcpop): Ditto.\n+\t(vfirst): Ditto.\n+\t(vmsbf): Ditto.\n+\t(vmsif): Ditto.\n+\t(vmsof): Ditto.\n+\t(viota): Ditto.\n+\t(vid): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.cc (struct alu_def): Ditto.\n+\t(struct mask_alu_def): Ditto.\n+\t(SHAPE): Ditto.\n+\t* config/riscv/riscv-vector-builtins-shapes.h: Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc: Ditto.\n+\t* config/riscv/riscv-vsetvl.cc (pass_vsetvl::cleanup_insns): Fix bug\n+\tfor dest it scalar RVV intrinsics.\n+\t* config/riscv/vector-iterators.md (sof): New iterator.\n+\t* config/riscv/vector.md (@pred_<optab>n<mode>): New pattern.\n+\t(@pred_<optab>not<mode>): New pattern.\n+\t(@pred_popcount<VB:mode><P:mode>): New pattern.\n+\t(@pred_ffs<VB:mode><P:mode>): New pattern.\n+\t(@pred_<misc_op><mode>): New pattern.\n+\t(@pred_iota<mode>): New pattern.\n+\t(@pred_series<mode>): New pattern.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-functions.def (vadc): Rename.\n+\t(vsbc): Ditto.\n+\t(vmerge): Ditto.\n+\t(vmv_v): Ditto.\n+\t* config/riscv/riscv-vector-builtins.cc: Ditto.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\t    kito-cheng  <kito.cheng@sifive.com>\n+\n+\t* config/riscv/riscv-protos.h (sew64_scalar_helper): New function.\n+\t* config/riscv/riscv-v.cc (has_vi_variant_p): Adjust.\n+\t(sew64_scalar_helper): New function.\n+\t* config/riscv/vector.md: Normalization.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-vector-builtins-functions.def (vsetvlmax): Rearrange.\n+\t(vsm): Ditto.\n+\t(vsse): Ditto.\n+\t(vsoxei64): Ditto.\n+\t(vsub): Ditto.\n+\t(vand): Ditto.\n+\t(vor): Ditto.\n+\t(vxor): Ditto.\n+\t(vsll): Ditto.\n+\t(vsra): Ditto.\n+\t(vsrl): Ditto.\n+\t(vmin): Ditto.\n+\t(vmax): Ditto.\n+\t(vminu): Ditto.\n+\t(vmaxu): Ditto.\n+\t(vmul): Ditto.\n+\t(vmulh): Ditto.\n+\t(vmulhu): Ditto.\n+\t(vmulhsu): Ditto.\n+\t(vdiv): Ditto.\n+\t(vrem): Ditto.\n+\t(vdivu): Ditto.\n+\t(vremu): Ditto.\n+\t(vnot): Ditto.\n+\t(vsext): Ditto.\n+\t(vzext): Ditto.\n+\t(vwadd): Ditto.\n+\t(vwsub): Ditto.\n+\t(vwmul): Ditto.\n+\t(vwmulu): Ditto.\n+\t(vwmulsu): Ditto.\n+\t(vwaddu): Ditto.\n+\t(vwsubu): Ditto.\n+\t(vsbc): Ditto.\n+\t(vmsbc): Ditto.\n+\t(vnsra): Ditto.\n+\t(vmerge): Ditto.\n+\t(vmv_v): Ditto.\n+\t(vmsne): Ditto.\n+\t(vmslt): Ditto.\n+\t(vmsgt): Ditto.\n+\t(vmsle): Ditto.\n+\t(vmsge): Ditto.\n+\t(vmsltu): Ditto.\n+\t(vmsgtu): Ditto.\n+\t(vmsleu): Ditto.\n+\t(vmsgeu): Ditto.\n+\t(vnmsac): Ditto.\n+\t(vmadd): Ditto.\n+\t(vnmsub): Ditto.\n+\t(vwmacc): Ditto.\n+\t(vsadd): Ditto.\n+\t(vssub): Ditto.\n+\t(vssubu): Ditto.\n+\t(vaadd): Ditto.\n+\t(vasub): Ditto.\n+\t(vasubu): Ditto.\n+\t(vsmul): Ditto.\n+\t(vssra): Ditto.\n+\t(vssrl): Ditto.\n+\t(vnclip): Ditto.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/vector.md (@pred_<optab><mode>): Rearrange.\n+\t(@pred_<optab><mode>_scalar): Ditto.\n+\t(*pred_<optab><mode>_scalar): Ditto.\n+\t(*pred_<optab><mode>_extended_scalar): Ditto.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-protos.h (riscv_run_selftests): Remove 'extern'.\n+\t(init_builtins): Ditto.\n+\t(mangle_builtin_type): Ditto.\n+\t(verify_type_context): Ditto.\n+\t(handle_pragma_vector):  Ditto.\n+\t(builtin_decl): Ditto.\n+\t(expand_builtin): Ditto.\n+\t(const_vec_all_same_in_range_p): Ditto.\n+\t(legitimize_move): Ditto.\n+\t(emit_vlmax_op): Ditto.\n+\t(emit_nonvlmax_op): Ditto.\n+\t(get_vlmul): Ditto.\n+\t(get_ratio): Ditto.\n+\t(get_ta): Ditto.\n+\t(get_ma): Ditto.\n+\t(get_avl_type): Ditto.\n+\t(calculate_ratio): Ditto.\n+\t(enum vlmul_type): Ditto.\n+\t(simm5_p): Ditto.\n+\t(neg_simm5_p): Ditto.\n+\t(has_vi_variant_p): Ditto.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* config/riscv/riscv-protos.h (simm32_p): Remove.\n+\t* config/riscv/riscv-v.cc (simm32_p): Ditto.\n+\t* config/riscv/vector.md: Use immediate_operand\n+\tinstead of riscv_vector::simm32_p.\n+\n 2023-02-16  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/invoke.texi (Optimize Options): Reword the explanation"}, {"sha": "09ddb49ab8a30c816cd6ea8764ae955aa822e136", "filename": "gcc/DATESTAMP", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2FDATESTAMP", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2FDATESTAMP", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FDATESTAMP?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1 +1 @@\n-20230217\n+20230220"}, {"sha": "41977aac2e22763ef27e975d25b2aaf7d7726a4c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,11 @@\n+2023-02-18  Martin Uecker  <uecker@tugraz.at>\n+\n+\tPR c/105660\n+\t* c-attribs.cc (append_access_attr): Use order of arguments when\n+\tconstruction string.\n+\t(append_access_attr_idxs): Rename and make static.\n+\t* c-warn.cc (warn_parm_array_mismatch): Add assertion.\n+\n 2023-02-16  Patrick Palka  <ppalka@redhat.com>\n \n \t* c-common.h: Mechanically drop static from static inline"}, {"sha": "072cfb69147bd6b314459c0bd48a0c1fb92d3e4d", "filename": "gcc/c-family/c-attribs.cc", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc-family%2Fc-attribs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc-family%2Fc-attribs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -4728,30 +4728,34 @@ append_access_attr (tree node[3], tree attrs, const char *attrstr,\n   rdwr_map cur_idxs;\n   init_attr_rdwr_indices (&cur_idxs, attrs);\n \n+  tree args = TYPE_ARG_TYPES (node[0]);\n+  int argpos = 0;\n   std::string spec;\n-  for (auto it = new_idxs.begin (); it != new_idxs.end (); ++it)\n+  for (tree arg = args; arg; arg = TREE_CHAIN (arg), argpos++)\n     {\n-      const auto &newaxsref = *it;\n+      const attr_access* const newa = new_idxs.get (argpos);\n+\n+      if (!newa)\n+\tcontinue;\n \n       /* The map has two equal entries for each pointer argument that\n \t has an associated size argument.  Process just the entry for\n \t the former.  */\n-      if ((unsigned)newaxsref.first != newaxsref.second.ptrarg)\n+      if ((unsigned)argpos != newa->ptrarg)\n \tcontinue;\n \n-      const attr_access* const cura = cur_idxs.get (newaxsref.first);\n+      const attr_access* const cura = cur_idxs.get (argpos);\n       if (!cura)\n \t{\n \t  /* The new attribute needs to be added.  */\n-\t  tree str = newaxsref.second.to_internal_string ();\n+\t  tree str = newa->to_internal_string ();\n \t  spec += TREE_STRING_POINTER (str);\n \t  continue;\n \t}\n \n       /* The new access spec refers to an array/pointer argument for\n \t which an access spec already exists.  Check and diagnose any\n \t conflicts.  If no conflicts are found, merge the two.  */\n-      const attr_access* const newa = &newaxsref.second;\n \n       if (!attrstr)\n \t{\n@@ -4886,7 +4890,7 @@ append_access_attr (tree node[3], tree attrs, const char *attrstr,\n \tcontinue;\n \n       /* Merge the CURA and NEWA.  */\n-      attr_access merged = newaxsref.second;\n+      attr_access merged = *newa;\n \n       /* VLA seen in a declaration takes precedence.  */\n       if (cura->minsize == HOST_WIDE_INT_M1U)\n@@ -4912,9 +4916,9 @@ append_access_attr (tree node[3], tree attrs, const char *attrstr,\n \n /* Convenience wrapper for the above.  */\n \n-tree\n-append_access_attr (tree node[3], tree attrs, const char *attrstr,\n-\t\t    char code, HOST_WIDE_INT idxs[2])\n+static tree\n+append_access_attr_idxs (tree node[3], tree attrs, const char *attrstr,\n+\t\t\t char code, HOST_WIDE_INT idxs[2])\n {\n   char attrspec[80];\n   int n = sprintf (attrspec, \"%c%u\", code, (unsigned) idxs[0] - 1);\n@@ -5204,7 +5208,7 @@ handle_access_attribute (tree node[3], tree name, tree args, int flags,\n      attributes specified on previous declarations of the same type\n      and if not, concatenate the two.  */\n   const char code = attr_access::mode_chars[mode];\n-  tree new_attrs = append_access_attr (node, attrs, attrstr, code, idxs);\n+  tree new_attrs = append_access_attr_idxs (node, attrs, attrstr, code, idxs);\n   if (!new_attrs)\n     return NULL_TREE;\n \n@@ -5217,7 +5221,7 @@ handle_access_attribute (tree node[3], tree name, tree args, int flags,\n     {\n       /* Repeat for the previously declared type.  */\n       attrs = TYPE_ATTRIBUTES (TREE_TYPE (node[1]));\n-      new_attrs = append_access_attr (node, attrs, attrstr, code, idxs);\n+      new_attrs = append_access_attr_idxs (node, attrs, attrstr, code, idxs);\n       if (!new_attrs)\n \treturn NULL_TREE;\n "}, {"sha": "a6fb95b1e808b3ba7d962787ac73fad113ea25b4", "filename": "gcc/c-family/c-warn.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc-family%2Fc-warn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc-family%2Fc-warn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-warn.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -3617,6 +3617,8 @@ warn_parm_array_mismatch (location_t origloc, tree fndecl, tree newparms)\n       for (tree newvbl = newa->size, curvbl = cura->size; newvbl;\n \t   newvbl = TREE_CHAIN (newvbl), curvbl = TREE_CHAIN (curvbl))\n \t{\n+\t  gcc_assert (curvbl);\n+\n \t  tree newpos = TREE_PURPOSE (newvbl);\n \t  tree curpos = TREE_PURPOSE (curvbl);\n "}, {"sha": "d3cd60bd9091284d6c9f707843d713d9d1ce8205", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,24 @@\n+2023-02-18  Martin Uecker  <uecker@tugraz.at>\n+\n+\tPR c/108375\n+\t* c-decl.cc (decl_jump_unsafe): Use c_type_variably_modified_p.\n+\t(diagnose_mismatched_decl): Dito.\n+\t(warn_about_goto): Dito:\n+\t(c_check_switch_jump_warnings): Dito.\n+\t(finish_decl): Dito.\n+\t(finish_struct): Dito.\n+\t(grokdeclarator): Set C_TYPE_VARIABLY_MODIFIED.\n+\t(finish_struct): Set C_TYPE_VARIABLY_MODIFIED.\n+\t* c-objc-common.cc (c_var_mod_p): New function.\n+\t(c_var_unspec_p): Remove.\n+\t* c-objc-common.h: Set lang hook.\n+\t* c-parser.cc (c_parser_declararion_or_fndef): Use c_type_variably_modified_p.\n+\t(c_parser_typeof_specifier): Dito.\n+\t(c_parser_has_attribute_expression): Dito.\n+\t(c_parser_generic_selection): Dito.\n+\t* c-tree.h: Define C_TYPE_VARIABLY_MODIFIED and define c_var_mode_p.\n+\t* c-typeck.cc: Remove c_vla_mod_p and use C_TYPE_VARIABLY_MODIFIED.\n+\n 2023-02-16  Patrick Palka  <ppalka@redhat.com>\n \n \t* c-parser.h: Mechanically drop static from static inline"}, {"sha": "08078eadeb88047a8b5261fb1b815c613ce73ec3", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -683,7 +683,7 @@ decl_jump_unsafe (tree decl)\n \n   /* Always warn about crossing variably modified types.  */\n   if ((VAR_P (decl) || TREE_CODE (decl) == TYPE_DECL)\n-      && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+      && c_type_variably_modified_p (TREE_TYPE (decl)))\n     return true;\n \n   /* Otherwise, only warn if -Wgoto-misses-init and this is an\n@@ -2247,7 +2247,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \t  || warning_suppressed_p (olddecl, OPT_Wpedantic))\n \treturn true;  /* Allow OLDDECL to continue in use.  */\n \n-      if (variably_modified_type_p (newtype, NULL))\n+      if (c_type_variably_modified_p (newtype))\n \t{\n \t  error (\"redefinition of typedef %q+D with variably modified type\",\n \t\t newdecl);\n@@ -3975,7 +3975,7 @@ static void\n warn_about_goto (location_t goto_loc, tree label, tree decl)\n {\n   auto_diagnostic_group d;\n-  if (variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+  if (c_type_variably_modified_p (TREE_TYPE (decl)))\n     error_at (goto_loc,\n \t      \"jump into scope of identifier with variably modified type\");\n   else\n@@ -4249,7 +4249,7 @@ c_check_switch_jump_warnings (struct c_spot_bindings *switch_bindings,\n \t    {\n \t      auto_diagnostic_group d;\n \t      bool emitted;\n-\t      if (variably_modified_type_p (TREE_TYPE (b->decl), NULL_TREE))\n+\t      if (c_type_variably_modified_p (TREE_TYPE (b->decl)))\n \t\t{\n \t\t  saw_error = true;\n \t\t  error_at (case_loc,\n@@ -5862,7 +5862,7 @@ finish_decl (tree decl, location_t init_loc, tree init,\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       if (!DECL_FILE_SCOPE_P (decl)\n-\t  && variably_modified_type_p (TREE_TYPE (decl), NULL_TREE))\n+\t  && c_type_variably_modified_p (TREE_TYPE (decl)))\n \tadd_stmt (build_stmt (DECL_SOURCE_LOCATION (decl), DECL_EXPR, decl));\n \n       rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl), 0);\n@@ -6682,7 +6682,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n   if ((decl_context == NORMAL || decl_context == FIELD)\n       && current_scope == file_scope\n-      && variably_modified_type_p (type, NULL_TREE))\n+      && c_type_variably_modified_p (type))\n     {\n       if (name)\n \terror_at (loc, \"variably modified %qE at file scope\", name);\n@@ -6928,6 +6928,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t  array_parm_static = false;\n \t}\n \n+      bool varmod = C_TYPE_VARIABLY_MODIFIED (type);\n+\n       switch (declarator->kind)\n \t{\n \tcase cdk_attrs:\n@@ -7282,8 +7284,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       variable size, so the enclosing shared array type\n \t\t       must too.  */\n \t\t    if (size && TREE_CODE (size) == INTEGER_CST)\n-\t\t      type\n-\t\t\t= build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n+\t\t      type = build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n \t\t    C_TYPE_VARIABLE_SIZE (type) = 1;\n \t\t  }\n \n@@ -7493,7 +7494,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       the size evaluation prior to the side effects.  We therefore\n \t       use BIND_EXPRs in TYPENAME contexts too.  */\n \t    if (!TYPE_NAME (type)\n-\t\t&& variably_modified_type_p (type, NULL_TREE))\n+\t\t&& c_type_variably_modified_p (type))\n \t      {\n \t\ttree bind = NULL_TREE;\n \t\tif (decl_context == TYPENAME || decl_context == PARM)\n@@ -7534,6 +7535,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+      if (type != error_mark_node)\n+\tC_TYPE_VARIABLY_MODIFIED (type) = varmod || size_varies;\n     }\n   *decl_attrs = chainon (returned_attrs, *decl_attrs);\n   *decl_attrs = chainon (decl_id_attrs, *decl_attrs);\n@@ -7728,7 +7731,7 @@ grokdeclarator (const struct c_declarator *declarator,\n     }\n \n   if (pedantic && decl_context == FIELD\n-      && variably_modified_type_p (type, NULL_TREE))\n+      && c_type_variably_modified_p (type))\n     {\n       /* C99 6.7.2.1p8 */\n       pedwarn (loc, OPT_Wpedantic, \"a member of a structure or union cannot \"\n@@ -7996,7 +7999,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       have a member with such a qualifier.  const\n \t       qualification is implicitly added, and, at file scope,\n \t       has internal linkage.  */\n-\t    if (variably_modified_type_p (type, NULL_TREE))\n+\t    if (c_type_variably_modified_p (type))\n \t      error_at (loc, \"%<constexpr%> object has variably modified \"\n \t\t\t\"type\");\n \t    if (type_quals\n@@ -8078,7 +8081,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t || (storage_class == csc_none\n \t     && TREE_CODE (type) == FUNCTION_TYPE\n \t     && !funcdef_flag))\n-\t&& variably_modified_type_p (type, NULL_TREE))\n+\t&& c_type_variably_modified_p (type))\n       {\n \t/* C99 6.7.5.2p2 */\n \tif (TREE_CODE (type) == FUNCTION_TYPE)\n@@ -9233,6 +9236,10 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       if (C_DECL_VARIABLE_SIZE (x))\n \tC_TYPE_VARIABLE_SIZE (t) = 1;\n \n+      /* If any field is variably modified, record this fact. */\n+      if (C_TYPE_VARIABLY_MODIFIED (TREE_TYPE (x)))\n+\tC_TYPE_VARIABLY_MODIFIED (t) = 1;\n+\n       if (DECL_C_BIT_FIELD (x))\n \t{\n \t  unsigned HOST_WIDE_INT width = tree_to_uhwi (DECL_INITIAL (x));\n@@ -9431,6 +9438,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n       C_TYPE_FIELDS_VOLATILE (x) = C_TYPE_FIELDS_VOLATILE (t);\n       C_TYPE_FIELDS_NON_CONSTEXPR (x) = C_TYPE_FIELDS_NON_CONSTEXPR (t);\n       C_TYPE_VARIABLE_SIZE (x) = C_TYPE_VARIABLE_SIZE (t);\n+      C_TYPE_VARIABLY_MODIFIED (x) = C_TYPE_VARIABLY_MODIFIED (t);\n       C_TYPE_INCOMPLETE_VARS (x) = NULL_TREE;\n     }\n \n@@ -9447,7 +9455,7 @@ finish_struct (location_t loc, tree t, tree fieldlist, tree attributes,\n   /* If we're inside a function proper, i.e. not file-scope and not still\n      parsing parameters, then arrange for the size of a variable sized type\n      to be bound now.  */\n-  if (building_stmt_list_p () && variably_modified_type_p (t, NULL_TREE))\n+  if (building_stmt_list_p () && c_type_variably_modified_p(t))\n     add_stmt (build_stmt (loc,\n \t\t\t  DECL_EXPR, build_decl (loc, TYPE_DECL, NULL, t)));\n "}, {"sha": "e4aed61ed007ce507009c2f31f437f77398d8c7e", "filename": "gcc/c/c-objc-common.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-objc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-objc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -371,12 +371,12 @@ c_types_compatible_p (tree x, tree y)\n   return comptypes (TYPE_MAIN_VARIANT (x), TYPE_MAIN_VARIANT (y));\n }\n \n-/* Determine if the type is a vla type for the backend.  */\n+/* Determine if the type is a variably modified type for the backend.  */\n \n bool\n-c_vla_unspec_p (tree x, tree fn ATTRIBUTE_UNUSED)\n+c_var_mod_p (tree x, tree fn ATTRIBUTE_UNUSED)\n {\n-  return c_vla_type_p (x);\n+  return C_TYPE_VARIABLY_MODIFIED (x);\n }\n \n /* Special routine to get the alias set of T for C.  */"}, {"sha": "d31dacb9dd47bf46b0c36d9c791b2fad92656d72", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -123,5 +123,5 @@ along with GCC; see the file COPYING3.  If not see\n #define LANG_HOOKS_OMP_CLAUSE_ASSIGN_OP c_omp_clause_copy_ctor\n \n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P\n-#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_vla_unspec_p\n+#define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_var_mod_p\n #endif /* GCC_C_OBJC_COMMON */"}, {"sha": "21bc3167ce224823c214efc064be399f2da9c787", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -2494,8 +2494,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t\t  init = convert_lvalue_to_rvalue (init_loc, init, true, true,\n \t\t\t\t\t\t   true);\n \t\t  tree init_type = TREE_TYPE (init.value);\n-\t\t  bool vm_type = variably_modified_type_p (init_type,\n-\t\t\t\t\t\t\t   NULL_TREE);\n+\t\t  bool vm_type = c_type_variably_modified_p (init_type);\n \t\t  if (vm_type)\n \t\t    init.value = save_expr (init.value);\n \t\t  finish_init ();\n@@ -4143,7 +4142,7 @@ c_parser_typeof_specifier (c_parser *parser)\n       if (type != NULL)\n \t{\n \t  ret.spec = groktypename (type, &ret.expr, &ret.expr_const_operands);\n-\t  pop_maybe_used (variably_modified_type_p (ret.spec, NULL_TREE));\n+\t  pop_maybe_used (c_type_variably_modified_p (ret.spec));\n \t}\n     }\n   else\n@@ -4158,7 +4157,7 @@ c_parser_typeof_specifier (c_parser *parser)\n \terror_at (here, \"%<typeof%> applied to a bit-field\");\n       mark_exp_read (expr.value);\n       ret.spec = TREE_TYPE (expr.value);\n-      was_vm = variably_modified_type_p (ret.spec, NULL_TREE);\n+      was_vm = c_type_variably_modified_p (ret.spec);\n       /* This is returned with the type so that when the type is\n \t evaluated, this can be evaluated.  */\n       if (was_vm)\n@@ -9058,7 +9057,7 @@ c_parser_has_attribute_expression (c_parser *parser)\n       if (tname)\n \t{\n \t  oper = groktypename (tname, NULL, NULL);\n-\t  pop_maybe_used (variably_modified_type_p (oper, NULL_TREE));\n+\t  pop_maybe_used (c_type_variably_modified_p (oper));\n \t}\n     }\n   else\n@@ -9071,7 +9070,7 @@ c_parser_has_attribute_expression (c_parser *parser)\n \t  mark_exp_read (cexpr.value);\n \t  oper = cexpr.value;\n \t  tree etype = TREE_TYPE (oper);\n-\t  bool was_vm = variably_modified_type_p (etype, NULL_TREE);\n+\t  bool was_vm = c_type_variably_modified_p (etype);\n \t  /* This is returned with the type so that when the type is\n \t     evaluated, this can be evaluated.  */\n \t  if (was_vm)\n@@ -9320,7 +9319,7 @@ c_parser_generic_selection (c_parser *parser)\n \t    error_at (assoc.type_location,\n \t\t      \"%<_Generic%> association has incomplete type\");\n \n-\t  if (variably_modified_type_p (assoc.type, NULL_TREE))\n+\t  if (c_type_variably_modified_p (assoc.type))\n \t    error_at (assoc.type_location,\n \t\t      \"%<_Generic%> association has \"\n \t\t      \"variable length type\");"}, {"sha": "e6b6fe9a40e7cd94df73af4bd283c72fcd8e5175", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -59,6 +59,10 @@ along with GCC; see the file COPYING3.  If not see\n #define C_TYPE_VARIABLE_SIZE(TYPE) TYPE_LANG_FLAG_1 (TYPE)\n #define C_DECL_VARIABLE_SIZE(TYPE) DECL_LANG_FLAG_0 (TYPE)\n \n+/* Record whether a type is variably modified. */\n+#define C_TYPE_VARIABLY_MODIFIED(TYPE) TYPE_LANG_FLAG_6 (TYPE)\n+\n+\n /* Record whether a type is defined inside a struct or union type.\n    This is used for -Wc++-compat. */\n #define C_TYPE_DEFINED_IN_STRUCT(TYPE) TYPE_LANG_FLAG_2 (TYPE)\n@@ -714,7 +718,7 @@ extern bool c_objc_common_init (void);\n extern bool c_missing_noreturn_ok_p (tree);\n extern bool c_warn_unused_global_decl (const_tree);\n extern void c_initialize_diagnostics (diagnostic_context *);\n-extern bool c_vla_unspec_p (tree x, tree fn);\n+extern bool c_var_mod_p (tree x, tree fn);\n extern alias_set_type c_get_alias_set (tree);\n \n /* in c-typeck.cc */\n@@ -729,14 +733,22 @@ extern location_t c_last_sizeof_loc;\n extern struct c_switch *c_switch_stack;\n \n extern bool null_pointer_constant_p (const_tree);\n+\n+\n+inline\n+bool c_type_variably_modified_p (tree t)\n+{\n+  return error_mark_node != t && C_TYPE_VARIABLY_MODIFIED (t);\n+}\n+\n+\n extern bool char_type_p (tree);\n extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (location_t, tree);\n extern bool same_translation_unit_p (const_tree, const_tree);\n extern int comptypes (tree, tree);\n extern int comptypes_check_different_types (tree, tree, bool *);\n extern int comptypes_check_enum_int (tree, tree, bool *);\n-extern bool c_vla_type_p (const_tree);\n extern bool c_mark_addressable (tree, bool = false);\n extern void c_incomplete_type_error (location_t, const_tree, const_tree);\n extern tree c_type_promotes_to (tree);"}, {"sha": "45bacc06c474f75144386c387cbd59d70fbaf37d", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -356,16 +356,6 @@ qualify_type (tree type, tree like)\n \t\t\t\t | ENCODE_QUAL_ADDR_SPACE (as_common));\n }\n \n-/* Return true iff the given tree T is a variable length array.  */\n-\n-bool\n-c_vla_type_p (const_tree t)\n-{\n-  if (TREE_CODE (t) == ARRAY_TYPE\n-      && C_TYPE_VARIABLE_SIZE (t))\n-    return true;\n-  return false;\n-}\n \n /* If NTYPE is a type of a non-variadic function with a prototype\n    and OTYPE is a type of a function without a prototype and ATTRS\n@@ -471,8 +461,8 @@ composite_type (tree t1, tree t2)\n \td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n-\td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n-\td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n+\td1_variable = d1_variable || (d1_zero && C_TYPE_VARIABLE_SIZE (t1));\n+\td2_variable = d2_variable || (d2_zero && C_TYPE_VARIABLE_SIZE (t2));\n \n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1)\n@@ -1248,8 +1238,8 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n \td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n-\td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n-\td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n+\td1_variable = d1_variable || (d1_zero && C_TYPE_VARIABLE_SIZE (t1));\n+\td2_variable = d2_variable || (d2_zero && C_TYPE_VARIABLE_SIZE (t2));\n \n \tif (different_types_p != NULL\n \t    && d1_variable != d2_variable)\n@@ -3346,7 +3336,7 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n   /* In this improbable scenario, a nested function returns a VM type.\n      Create a TARGET_EXPR so that the call always has a LHS, much as\n      what the C++ FE does for functions returning non-PODs.  */\n-  if (variably_modified_type_p (TREE_TYPE (fntype), NULL_TREE))\n+  if (C_TYPE_VARIABLY_MODIFIED (TREE_TYPE (fntype)))\n     {\n       tree tmp = create_tmp_var_raw (TREE_TYPE (fntype));\n       result = build4 (TARGET_EXPR, TREE_TYPE (fntype), tmp, result,"}, {"sha": "f56482c0f018fa042dd29e3eb3d646cfbb5ef1b5", "filename": "gcc/config.gcc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -4936,20 +4936,16 @@ case \"${target}\" in\n \t\tcase ${target} in\n \t\tloongarch64-*-*-*f64)\n \t\t\tabi_pattern=\"lp64d\"\n-\t\t\ttriplet_abi=\"f64\"\n \t\t\t;;\n \t\tloongarch64-*-*-*f32)\n \t\t\tabi_pattern=\"lp64f\"\n-\t\t\ttriplet_abi=\"f32\"\n \t\t\t;;\n \t\tloongarch64-*-*-*sf)\n \t\t\tabi_pattern=\"lp64s\"\n-\t\t\ttriplet_abi=\"sf\"\n \t\t\t;;\n \t\tloongarch64-*-*-*)\n \t\t\tabi_pattern=\"lp64[dfs]\"\n \t\t\tabi_default=\"lp64d\"\n-\t\t\ttriplet_abi=\"\"\n \t\t\t;;\n \t\t*)\n \t\t\techo \"Unsupported target ${target}.\" 1>&2\n@@ -4970,9 +4966,6 @@ case \"${target}\" in\n \t\t\t  ;;\n \t\tesac\n \n-\t\tla_canonical_triplet=\"loongarch64-${triplet_os}${triplet_abi}\"\n-\n-\n \t\t# Perform initial sanity checks on --with-* options.\n \t\tcase ${with_arch} in\n \t\t\"\" | loongarch64 | la464) ;; # OK, append here.\n@@ -5043,6 +5036,13 @@ case \"${target}\" in\n \t\t\t;;\n \t\tesac\n \n+\t\tcase ${with_abi} in\n+\t\t  \"lp64d\") triplet_abi=\"\";;\n+\t\t  \"lp64f\") triplet_abi=\"f32\";;\n+\t\t  \"lp64s\") triplet_abi=\"sf\";;\n+\t\tesac\n+\t\tla_canonical_triplet=\"loongarch64-${triplet_os}${triplet_abi}\"\n+\n \t\t# Set default value for with_abiext (internal)\n \t\tcase ${with_abiext} in\n \t\t\"\")"}, {"sha": "1094ece8b6d9c04dbe0f3e0e213cbe283e64cbe4", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -7093,6 +7093,37 @@ ix86_expand_v1ti_ashiftrt (rtx operands[])\n     }\n }\n \n+/* Replace all occurrences of REG FROM with REG TO in X, including\n+   occurrences with different modes.  */\n+\n+rtx\n+ix86_replace_reg_with_reg (rtx x, rtx from, rtx to)\n+{\n+  gcc_checking_assert (REG_P (from)\n+\t\t       && REG_P (to)\n+\t\t       && GET_MODE (from) == GET_MODE (to));\n+  if (!reg_overlap_mentioned_p (from, x))\n+    return x;\n+  rtx ret = copy_rtx (x);\n+  subrtx_ptr_iterator::array_type array;\n+  FOR_EACH_SUBRTX_PTR (iter, array, &ret, NONCONST)\n+    {\n+      rtx *loc = *iter;\n+      x = *loc;\n+      if (REG_P (x) && REGNO (x) == REGNO (from))\n+\t{\n+\t  if (x == from)\n+\t    *loc = to;\n+\t  else\n+\t    {\n+\t      gcc_checking_assert (REG_NREGS (x) == 1);\n+\t      *loc = gen_rtx_REG (GET_MODE (x), REGNO (to));\n+\t    }\n+\t}\n+    }\n+  return ret;\n+}\n+\n /* Return mode for the memcpy/memset loop counter.  Prefer SImode over\n    DImode for constant loop counts.  */\n "}, {"sha": "bfb2198265ae597de7469d16203d649849df7b72", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -168,6 +168,7 @@ extern void ix86_split_lshr (rtx *, rtx, machine_mode);\n extern void ix86_expand_v1ti_shift (enum rtx_code, rtx[]);\n extern void ix86_expand_v1ti_rotate (enum rtx_code, rtx[]);\n extern void ix86_expand_v1ti_ashiftrt (rtx[]);\n+extern rtx ix86_replace_reg_with_reg (rtx, rtx, rtx);\n extern rtx ix86_find_base_term (rtx);\n extern bool ix86_check_movabs (rtx, int);\n extern bool ix86_check_no_addr_space (rtx);"}, {"sha": "6382cfbce21cd3c82b12251ca9d0734b7a497fa4", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -22101,8 +22101,10 @@\n \t\t\t\t\t  (match_dup 0)))]\n {\n   operands[7] = SET_DEST (XVECEXP (PATTERN (peep2_next_insn (1)), 0, 0));\n-  operands[8] = replace_rtx (operands[5], operands[0], operands[1], true);\n-  operands[9] = replace_rtx (operands[6], operands[0], operands[1], true);\n+  operands[8]\n+    = ix86_replace_reg_with_reg (operands[5], operands[0], operands[1]);\n+  operands[9]\n+    = ix86_replace_reg_with_reg (operands[6], operands[0], operands[1]);\n })\n \n ;; Eliminate a reg-reg mov by inverting the condition of a cmov (#2).\n@@ -22134,8 +22136,10 @@\n \t\t\t\t\t  (match_dup 0)))]\n {\n   operands[7] = SET_DEST (XVECEXP (PATTERN (peep2_next_insn (2)), 0, 0));\n-  operands[8] = replace_rtx (operands[5], operands[0], operands[1], true);\n-  operands[9] = replace_rtx (operands[6], operands[0], operands[1], true);\n+  operands[8]\n+    = ix86_replace_reg_with_reg (operands[5], operands[0], operands[1]);\n+  operands[9]\n+    = ix86_replace_reg_with_reg (operands[6], operands[0], operands[1]);\n })\n \n (define_insn \"movhf_mask\"\n@@ -23274,7 +23278,10 @@\n    (parallel [(set (match_dup 0)\n \t\t   (match_op_dup 3 [(match_dup 0) (match_dup 1)]))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[4] = replace_rtx (operands[2], operands[0], operands[1], true);\")\n+{\n+  operands[4]\n+    = ix86_replace_reg_with_reg (operands[2], operands[0], operands[1]);\n+})\n \n (define_peephole2\n   [(set (match_operand 0 \"mmx_reg_operand\")"}, {"sha": "e40da179203a0435eb4b91a64e43d5c47e5d5681", "filename": "gcc/config/loongarch/t-linux", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Floongarch%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fconfig%2Floongarch%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Floongarch%2Ft-linux?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -40,7 +40,7 @@ ifeq ($(filter LA_DISABLE_MULTILIB,$(tm_defines)),)\n \n     MULTILIB_OSDIRNAMES = \\\n       mabi.lp64d=../lib64$\\\n-      $(call if_multiarch,:loongarch64-linux-gnuf64)\n+      $(call if_multiarch,:loongarch64-linux-gnu)\n \n     MULTILIB_OSDIRNAMES += \\\n       mabi.lp64f=../lib64/f32$\\"}, {"sha": "20b2fe561487bdcaf0de34584f0de1e828fc0545", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,72 @@\n+2023-02-18  Jason Merrill  <jason@redhat.com>\n+\n+\tDR 2518\n+\tPR c++/52809\n+\tPR c++/53638\n+\tPR c++/87389\n+\tPR c++/89741\n+\tPR c++/92099\n+\tPR c++/104041\n+\tPR c++/104691\n+\t* semantics.cc (finish_static_assert): Don't diagnose in\n+\ttemplate context.\n+\n+2023-02-17  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/108243\n+\tPR c++/97553\n+\t* cp-gimplify.cc (enum fold_flags): Define.\n+\t(fold_flags_t): Declare.\n+\t(cp_fold_data::genericize): Replace this data member with ...\n+\t(cp_fold_data::fold_flags): ... this.\n+\t(cp_fold_r): Adjust use of cp_fold_data and calls to cp_fold.\n+\t(cp_fold_function): Likewise.\n+\t(cp_fold_maybe_rvalue): Add an internal overload that\n+\tadditionally takes and propagates a fold_flags_t parameter, and\n+\tdefine the existing public overload in terms of it.\n+\t(cp_fold_rvalue): Likewise.\n+\t(cp_fully_fold_init): Adjust use of cp_fold_data.\n+\t(fold_cache): Replace with ...\n+\t(fold_caches): ... this 2-element array of caches.\n+\t(get_fold_cache): Define.\n+\t(clear_fold_cache): Adjust.\n+\t(cp_fold): Add fold_flags_t parameter.  Use get_fold_cache.\n+\tPass flags to calls to cp_fold, cp_fold_rvalue and\n+\tcp_fold_maybe_rvalue.\n+\t<case CALL_EXPR>: If ff_mce_false is set, fold\n+\t__builtin_is_constant_evaluated to false and pass mce_false to\n+\tmaybe_constant_value.\n+\n+2023-02-17  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* constexpr.cc (constexpr_call::manifestly_const_eval): Give\n+\tit type int instead of bool.\n+\t(constexpr_ctx::manifestly_const_eval): Give it type mce_value\n+\tinstead of bool.\n+\t(cxx_eval_builtin_function_call): Adjust after making\n+\tmanifestly_const_eval tri-state.\n+\t(cxx_eval_call_expression): Likewise.\n+\t(cxx_eval_binary_expression): Likewise.\n+\t(cxx_eval_conditional_expression): Likewise.\n+\t(cxx_eval_constant_expression): Likewise.\n+\t(cxx_eval_outermost_constant_expr): Likewise.\n+\t(cxx_constant_value): Likewise.\n+\t(cxx_constant_dtor): Likewise.\n+\t(maybe_constant_value): Give manifestly_const_eval parameter\n+\ttype mce_value instead of bool and adjust accordingly.\n+\t(fold_non_dependent_expr_template): Adjust call\n+\tto cxx_eval_outermost_constant_expr.\n+\t(fold_non_dependent_expr): Likewise.\n+\t(maybe_constant_init_1): Likewise.\n+\t* constraint.cc (satisfy_atom): Adjust call to\n+\tmaybe_constant_value.\n+\t* cp-tree.h (enum class mce_value): Define.\n+\t(maybe_constant_value): Adjust manifestly_const_eval parameter\n+\ttype and default argument.\n+\t* decl.cc (compute_array_index_type_loc): Adjust call to\n+\tmaybe_constant_value.\n+\t* pt.cc (convert_nontype_argument): Likewise.\n+\n 2023-02-16  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/107773"}, {"sha": "79b7cc72f212cef780a3eea65af2b883bb4ec3c8", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -11232,14 +11232,16 @@ finish_static_assert (tree condition, tree message, location_t location,\n   if (check_for_bare_parameter_packs (condition))\n     condition = error_mark_node;\n \n+  /* Save the condition in case it was a concept check.  */\n+  tree orig_condition = condition;\n+\n   if (instantiation_dependent_expression_p (condition))\n     {\n       /* We're in a template; build a STATIC_ASSERT and put it in\n          the right place. */\n-      tree assertion;\n-\n-      assertion = make_node (STATIC_ASSERT);\n-      STATIC_ASSERT_CONDITION (assertion) = condition;\n+    defer:\n+      tree assertion = make_node (STATIC_ASSERT);\n+      STATIC_ASSERT_CONDITION (assertion) = orig_condition;\n       STATIC_ASSERT_MESSAGE (assertion) = message;\n       STATIC_ASSERT_SOURCE_LOCATION (assertion) = location;\n \n@@ -11253,9 +11255,6 @@ finish_static_assert (tree condition, tree message, location_t location,\n       return;\n     }\n \n-  /* Save the condition in case it was a concept check.  */\n-  tree orig_condition = condition;\n-\n   /* Fold the expression and convert it to a boolean value. */\n   condition = contextual_conv_bool (condition, complain);\n   condition = fold_non_dependent_expr (condition, complain,\n@@ -11270,6 +11269,10 @@ finish_static_assert (tree condition, tree message, location_t location,\n \n       if (integer_zerop (condition))\n \t{\n+\t  /* CWG2518: static_assert failure in a template is not IFNDR.  */\n+\t  if (processing_template_decl)\n+\t    goto defer;\n+\n \t  int sz = TREE_INT_CST_LOW (TYPE_SIZE_UNIT\n \t\t\t\t     (TREE_TYPE (TREE_TYPE (message))));\n \t  int len = TREE_STRING_LENGTH (message) / sz - 1;"}, {"sha": "078d29d5313871a9e06b9a3ed71d29afe90f651f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -22888,7 +22888,7 @@ points to.\n The startup code from libgcc never sets @code{EIND}.\n Notice that startup code is a blend of code from libgcc and AVR-LibC.\n For the impact of AVR-LibC on @code{EIND}, see the\n-@w{@uref{http://nongnu.org/avr-libc/user-manual/,AVR-LibC user manual}}.\n+@w{@uref{https://www.nongnu.org/avr-libc/user-manual/,AVR-LibC user manual}}.\n \n @item\n It is legitimate for user-specific startup code to set up @code{EIND}"}, {"sha": "e352bd422f52338d5deea38820c8287d9622b29e", "filename": "gcc/match.pd", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1732,7 +1732,6 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n  (if (!FIXED_POINT_TYPE_P (type))\n  (plus @0 (negate @1))))\n \n-#if GIMPLE\n /* 1 - a is a ^ 1 if a had a bool range. */\n /* This is only enabled for gimple as sometimes\n    cfun is not set for the function which contains\n@@ -1743,7 +1742,6 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (if (INTEGRAL_TYPE_P (type)\n        && ssa_name_has_boolean_range (@1))\n    (bit_xor @1 @0)))\n-#endif\n \n /* Other simplifications of negation (c.f. fold_negate_expr_1).  */\n (simplify"}, {"sha": "6c6d7f9d8c93b66b12679f1d8b4f0e76a7351d7f", "filename": "gcc/rust/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Frust%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Frust%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,7 @@\n+2023-02-17  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\t* backend/rust-tree.cc: '#include \"tm_p.h\"'.\n+\n 2023-01-31  Philip Herron  <philip.herron@embecosm.com>\n \n \t* Make-lang.in: Remove `rust-hir-typecheck-toplevel` object and add"}, {"sha": "fcef7d879becf3ab231f24f68bafc862ced22d8d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,85 @@\n+2023-02-18  Jason Merrill  <jason@redhat.com>\n+\n+\tDR 2518\n+\tPR c++/52809\n+\tPR c++/53638\n+\tPR c++/87389\n+\tPR c++/89741\n+\tPR c++/92099\n+\tPR c++/104041\n+\tPR c++/104691\n+\t* g++.dg/DRs/dr2518.C: New test.\n+\n+2023-02-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/108819\n+\t* gcc.dg/pr108819.c: New test.\n+\n+2023-02-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR target/108832\n+\t* gcc.target/i386/pr108832.c: New test.\n+\n+2023-02-18  Martin Uecker  <uecker@tugraz.at>\n+\n+\tPR c/108375\n+\t* gcc.dg/pr108375-1.c: New test.\n+\t* gcc.dg/pr108375-2.c: New test.\n+\n+2023-02-18  Martin Uecker  <uecker@tugraz.at>\n+\n+\tPR c/105660\n+\tPR c/105660\n+\t* gcc.dg/pr105660-1.c: New test.\n+\t* gcc.dg/pr105660-2.c: New test.\n+\n+2023-02-17  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/108243\n+\tPR c++/97553\n+\t* g++.dg/opt/is_constant_evaluated1.C: New test.\n+\t* g++.dg/opt/is_constant_evaluated2.C: New test.\n+\n+2023-02-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/108831\n+\t* gcc.target/i386/pr108831-1.c: New test.\n+\t* gcc.target/i386/pr108831-2.c: Ditto.\n+\n+2023-02-17  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/108805\n+\t* gcc.dg/pr108805.c: New test.\n+\n+2023-02-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/108821\n+\t* gcc.dg/tree-ssa/ssa-lim-24.c: New testcase.\n+\n+2023-02-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\t* gfortran.dg/ISO_Fortran_binding_14.f90: Change example function to\n+\tCLOCK which is available on mingw as well as other platforms.\n+\t* gfortran.dg/pr96486.f90: Change variable to PATH likewise.\n+\n+2023-02-17  Ju-Zhe Zhong  <juzhe.zhong@rivai.ai>\n+\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-148.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-149.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-150.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-151.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-152.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-153.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-156.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-157.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-159.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-160.c: Change vmnot.mm to vmnot.m.\n+\t* gcc.target/riscv/rvv/base/binop_vx_constraint-161.c: Change vmnot.mm to vmnot.m.\n+\n+2023-02-17  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\t* gfortran.dg/bind_c_array_params_2.f90: Add *-*-ming* to dg-final.\n+\n 2023-02-16  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR analyzer/108806"}, {"sha": "240186211e6af82ef25d5bb182ed2eb5a3fd540d", "filename": "gcc/testsuite/g++.dg/DRs/dr2518.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FDRs%2Fdr2518.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FDRs%2Fdr2518.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FDRs%2Fdr2518.C?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,7 @@\n+// CWG 2518\n+// { dg-do compile { target c++11 } }\n+\n+template <class T> void f()\n+{\n+  static_assert (false, \"\");\n+}"}, {"sha": "d4454f04c43eee0ddf7268115715b887e40b3ca5", "filename": "gcc/testsuite/gcc.dg/pr105660-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr105660-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr105660-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr105660-1.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,13 @@\n+/* PR105660\n+ * { dg-do compile }\n+ * { dg-options \"-std=c17\" }\n+ */\n+\n+void gatherConservativeVars(int, int, int, int, int, int, int Hnvar, int,\n+                            int Hnyt, int Hnxyt, int, int Hstep, double[Hnyt],\n+                            double[Hnvar][Hstep][Hnxyt]);\n+void gatherConservativeVars(int, int, int, int, int, int, int Hnvar, int, int Hnyt,\n+                            int Hnxyt, int, int Hstep, double[Hnyt],\n+                            double[Hnvar][Hstep][Hnxyt]);\n+\n+"}, {"sha": "29fd82f923b829e46dd7c3f3916505af3328be7c", "filename": "gcc/testsuite/gcc.dg/pr105660-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr105660-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr105660-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr105660-2.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,12 @@\n+/* PR105660\n+ * { dg-do compile }\n+ * { dg-options \"-Wall -std=c17\" }\n+ */\n+\n+\n+struct bat_gen_conf_s;\n+void batch_generator_create2(struct bat_gen_conf_s* config, int D, int N, const long bat_dims[D][N], const long tot_dims[D][N], const long tot_strs[D][N], const _Complex float* data[D]);\n+void batch_generator_create2(struct bat_gen_conf_s* config, int D, int N, const long bat_dims[D][N], const long tot_dims[D][N], const long tot_strs[D][N], const _Complex float* data[D]);\n+\n+\n+"}, {"sha": "1cbb05b03ce82a572915e487d6bca4629fca8b13", "filename": "gcc/testsuite/gcc.dg/pr108375-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-1.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,14 @@\n+/* PR 108375\n+ * { dg-do compile }\n+ * { dg-options \"\" }\n+ * */\n+\n+void\n+f (int a)\n+{\n+  goto x;\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+  struct { char (*p)[a]; } B;\n+  x : ;\n+}\n+\n+"}, {"sha": "0401ead5b2143e40516068d239d7b33fe6dc1b89", "filename": "gcc/testsuite/gcc.dg/pr108375-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108375-2.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,15 @@\n+/* PR 108375\n+ * { dg-do compile }\n+ * { dg-options \"\" }\n+ * */\n+\n+void\n+f (int a)\n+{\n+  typedef int A[a];\n+  goto x;\t/* { dg-error \"jump into scope of identifier with variably modified type\" } */\n+  A *p[2];\n+  x : ;\n+}\n+\n+"}, {"sha": "28fa558b26024c3107d7f0b3ea4bd100c7114d62", "filename": "gcc/testsuite/gcc.dg/pr108819.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108819.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108819.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108819.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,19 @@\n+/* PR tree-optimization/108819 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-tree-ccp -fno-tree-forwprop\" } */\n+\n+int a, b;\n+\n+int\n+main ()\n+{\n+  int d = 1;\n+  for (; b; b++)\n+    if (a < 1)\n+      while (d <= a && a <= 0UL)\n+\t{\n+\t  int *e = &d;\n+\t  *e = 0;\n+\t}\n+  return 0;\n+}"}, {"sha": "ada2da8605469710ddc155ee276551a6fc046bb9", "filename": "gcc/testsuite/gcc.dg/torture/pr108825.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr108825.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr108825.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr108825.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+int safe_mul_func_uint8_t_u_u_ui2, g_231, g_277_1, g_568, func_35___trans_tmp_10;\n+int g_81[7];\n+extern int g_96[];\n+char func_35___trans_tmp_11;\n+static inline int safe_add_func_int32_t_s_s(int si1, int si2)\n+{ return si1 > 647 - si2 ?: si1; }\n+void func_35() {\n+  for (; g_277_1; g_277_1 += 1) {\n+    g_231 = 0;\n+    for (; g_231 <= 6; g_231 += 1) {\n+      func_35___trans_tmp_10 =\n+          safe_add_func_int32_t_s_s(g_81[g_231], g_568 || g_96[1]);\n+      func_35___trans_tmp_11 =\n+          func_35___trans_tmp_10 * safe_mul_func_uint8_t_u_u_ui2;\n+      g_81[g_231] = func_35___trans_tmp_11;\n+    }\n+  }\n+}"}, {"sha": "b6d4731ccb9953e63636edc399100faec02f44b6", "filename": "gcc/testsuite/gcc.target/i386/pr108832.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108832.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108832.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr108832.c?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -0,0 +1,19 @@\n+/* PR target/108832 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funroll-loops\" } */\n+\n+unsigned int m;\n+short int n;\n+\n+long int\n+bar (unsigned int x)\n+{\n+  return x ? x : 1;\n+}\n+\n+__attribute__ ((simd)) void\n+foo (void)\n+{\n+  int a = m / bar (3);\n+  n = 1 % bar (a << 1);\n+}"}, {"sha": "09acc1c94cce4100f91338934b2acbc9e23e2476", "filename": "gcc/tree-ssa-loop-manip.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftree-ssa-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftree-ssa-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -681,15 +681,15 @@ verify_loop_closed_ssa (bool verify_ssa_p, class loop *loop)\n   if (number_of_loops (cfun) <= 1)\n     return;\n \n-  if (verify_ssa_p)\n-    verify_ssa (false, true);\n-\n   timevar_push (TV_VERIFY_LOOP_CLOSED);\n \n   if (loop == NULL)\n     {\n       basic_block bb;\n \n+      if (verify_ssa_p)\n+\tverify_ssa (false, true);\n+\n       FOR_EACH_BB_FN (bb, cfun)\n \tif (bb->loop_father && bb->loop_father->num > 0)\n \t  check_loop_closed_ssa_bb (bb);\n@@ -698,6 +698,11 @@ verify_loop_closed_ssa (bool verify_ssa_p, class loop *loop)\n     {\n       basic_block *bbs = get_loop_body (loop);\n \n+      /* We do not have loop-local SSA verification so just\n+\t check there's no update queued.  */\n+      if (verify_ssa_p)\n+\tgcc_assert (!need_ssa_update_p (cfun));\n+\n       for (unsigned i = 0; i < loop->num_nodes; ++i)\n \tcheck_loop_closed_ssa_bb (bbs[i]);\n "}, {"sha": "1ce5e736ce39a39ad8f3138f2174cfcca9ee0d01", "filename": "gcc/tree-ssa-loop-niter.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftree-ssa-loop-niter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftree-ssa-loop-niter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -2354,7 +2354,8 @@ number_of_iterations_cltz (loop_p loop, edge exit,\n       gimple *and_stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (cond_stmt));\n       if (!is_gimple_assign (and_stmt)\n \t  || gimple_assign_rhs_code (and_stmt) != BIT_AND_EXPR\n-\t  || !integer_pow2p (gimple_assign_rhs2 (and_stmt)))\n+\t  || !integer_pow2p (gimple_assign_rhs2 (and_stmt))\n+\t  || TREE_CODE (gimple_assign_rhs1 (and_stmt)) != SSA_NAME)\n \treturn false;\n \n       checked_bit = tree_log2 (gimple_assign_rhs2 (and_stmt));\n@@ -2382,7 +2383,8 @@ number_of_iterations_cltz (loop_p loop, edge exit,\n \t     precision.  */\n \t  iv_2 = gimple_assign_rhs1 (test_value_stmt);\n \t  tree rhs_type = TREE_TYPE (iv_2);\n-\t  if (TREE_CODE (rhs_type) != INTEGER_TYPE\n+\t  if (TREE_CODE (iv_2) != SSA_NAME\n+\t      || TREE_CODE (rhs_type) != INTEGER_TYPE\n \t      || (TYPE_PRECISION (rhs_type)\n \t\t  != TYPE_PRECISION (test_value_type)))\n \t    return false;"}, {"sha": "8fd22591f557b18c71aa214efb65382bc4a1a10a", "filename": "gcc/tree-ssa-reassoc.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftree-ssa-reassoc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Ftree-ssa-reassoc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -4687,6 +4687,9 @@ update_ops (tree var, enum tree_code code, const vec<operand_entry *> &ops,\n       gimple_set_uid (g, gimple_uid (stmt));\n       gimple_set_visited (g, true);\n       gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      gimple_stmt_iterator gsi2 = gsi_for_stmt (g);\n+      if (fold_stmt_inplace (&gsi2))\n+\tupdate_stmt (g);\n     }\n   return var;\n }"}, {"sha": "2d7bf8fcf33e67c5dd99043a3ecd11431a137796", "filename": "gcc/value-query.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -140,7 +140,7 @@ get_global_range_query ()\n ATTRIBUTE_RETURNS_NONNULL inline range_query *\n get_range_query (const struct function *fun)\n {\n-  return fun->x_range_query ? fun->x_range_query : &global_ranges;\n+  return (fun && fun->x_range_query) ? fun->x_range_query : &global_ranges;\n }\n \n // Query the global range of NAME in function F.  Default to cfun."}, {"sha": "611a98097e819ccd112349bfb8f3cf4da0be4294", "filename": "libgm2/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/libgm2%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/libgm2%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,10 @@\n+2023-02-19  Gaius Mulley  <gaiusmod2@gmail.com>\n+\n+\tPR testsuite/108835\n+\t* libm2iso/RTco.cc: Re-implementation using a single lock\n+\tmutex and inlined wait/signal implementation within\n+\ttransfer.\n+\n 2023-02-13  Gaius Mulley  <gaiusmod2@gmail.com>\n \n \t* libm2iso/RTco.cc (tprintf): Replace definition."}, {"sha": "8b8a4dcea6dd153c4b9ea63964947b95d3f2d027", "filename": "libgm2/libm2iso/RTco.cc", "status": "modified", "additions": 176, "deletions": 127, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/libgm2%2Flibm2iso%2FRTco.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/libgm2%2Flibm2iso%2FRTco.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgm2%2Flibm2iso%2FRTco.cc?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,4 +1,4 @@\n-/* RTco.c provides minimal access to thread primitives.\n+/* RTco.cc provides minimal access to thread primitives.\n \n Copyright (C) 2019-2022 Free Software Foundation, Inc.\n Contributed by Gaius Mulley <gaius.mulley@southwales.ac.uk>.\n@@ -30,8 +30,19 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <sys/select.h>\n #include <stdlib.h>\n #include <m2rts.h>\n+#include <cstdio>\n \n-// #define TRACEON\n+#define EXPORT(FUNC) RTco_ ## FUNC\n+#define M2EXPORT(FUNC) _M2_RTco_ ## FUNC\n+\n+/* This implementation of RTco.cc uses a single lock for mutex across\n+   the whole module.  It also forces context switching between threads\n+   in transfer by combining an implementation of wait and signal.\n+\n+   All semaphores are implemented using the same mutex lock and\n+   separate condition variables.  */\n+\n+#undef TRACEON\n \n #define POOL\n #define SEM_POOL 10000\n@@ -63,19 +74,22 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define tprintf(...)\n #endif\n \n+\n typedef struct threadCB_s\n {\n   void (*proc) (void);\n-  int execution;\n   pthread_t p;\n-  int tid;\n+  int tid;   /* The thread id.  */\n   unsigned int interruptLevel;\n+  __gthread_cond_t run_counter;  /* Used to block the thread and force\n+\t\t\t\t    a context switch.  */\n+  int value;    /* Count 0 or 1.  */\n+  bool waiting; /* Is this thread waiting on the run_counter?  */\n } threadCB;\n \n \n typedef struct threadSem_s\n {\n-  __gthread_mutex_t mutex;\n   __gthread_cond_t counter;\n   int waiting;\n   int sem_value;\n@@ -87,25 +101,27 @@ static unsigned int nSemaphores = 0;\n static threadSem **semArray = NULL;\n \n /* These are used to lock the above module data structures.  */\n-static threadSem lock;\n+static __gthread_mutex_t lock;  /* This is the only mutex for\n+\t\t\t\t   the whole module.  */\n static int initialized = FALSE;\n+static int currentThread = 0;\n \n \n-extern \"C\" int RTco_init (void);\n+extern \"C\" int EXPORT(init) (void);\n \n \n extern \"C\" void\n-_M2_RTco_dep (void)\n+M2EXPORT(dep) (void)\n {\n }\n \n extern \"C\" void\n-_M2_RTco_init (int argc, char *argv[], char *envp[])\n+M2EXPORT(init) (int argc, char *argv[], char *envp[])\n {\n }\n \n extern \"C\" void\n-_M2_RTco_fini (int argc, char *argv[], char *envp[])\n+M2EXPORT(fini) (int argc, char *argv[], char *envp[])\n {\n }\n \n@@ -114,51 +130,48 @@ static void\n initSem (threadSem *sem, int value)\n {\n   __GTHREAD_COND_INIT_FUNCTION (&sem->counter);\n-  __GTHREAD_MUTEX_INIT_FUNCTION (&sem->mutex);\n   sem->waiting = FALSE;\n   sem->sem_value = value;\n }\n \n static void\n waitSem (threadSem *sem)\n {\n-  __gthread_mutex_lock (&sem->mutex);\n+  __gthread_mutex_lock (&lock);\n   if (sem->sem_value == 0)\n     {\n       sem->waiting = TRUE;\n-      __gthread_cond_wait (&sem->counter, &sem->mutex);\n+      __gthread_cond_wait (&sem->counter, &lock);\n       sem->waiting = FALSE;\n     }\n   else\n     sem->sem_value--;\n-  __gthread_mutex_unlock (&sem->mutex);\n+  __gthread_mutex_unlock (&lock);\n }\n \n static void\n signalSem (threadSem *sem)\n {\n-  __gthread_mutex_unlock (&sem->mutex);\n+  __gthread_mutex_lock (&lock);\n   if (sem->waiting)\n     __gthread_cond_signal (&sem->counter);\n   else\n     sem->sem_value++;\n-  __gthread_mutex_unlock (&sem->mutex);\n+  __gthread_mutex_unlock (&lock);\n }\n \n-void stop (void) {}\n-\n extern \"C\" void\n-RTco_wait (int sid)\n+EXPORT(wait) (int sid)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n   tprintf (\"wait %d\\n\", sid);\n   waitSem (semArray[sid]);\n }\n \n extern \"C\" void\n-RTco_signal (int sid)\n+EXPORT(signal) (int sid)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n   tprintf (\"signal %d\\n\", sid);\n   signalSem (semArray[sid]);\n }\n@@ -207,90 +220,58 @@ initSemaphore (int value)\n }\n \n extern \"C\" int\n-RTco_initSemaphore (int value)\n+EXPORT(initSemaphore) (int value)\n {\n   int sid;\n \n-  RTco_init ();\n-  waitSem (&lock);\n+  tprintf (\"initSemaphore (%d) called\\n\", value);\n+  EXPORT(init) ();\n+  tprintf (\"about to access lock\\n\");\n+  __gthread_mutex_lock (&lock);\n   sid = initSemaphore (value);\n-  signalSem (&lock);\n+  __gthread_mutex_unlock (&lock);\n   return sid;\n }\n \n-/* signalThread signal the semaphore associated with thread tid.  */\n-\n-extern \"C\" void\n-RTco_signalThread (int tid)\n-{\n-  int sem;\n-  RTco_init ();\n-  tprintf (\"signalThread %d\\n\", tid);\n-  waitSem (&lock);\n-  sem = threadArray[tid].execution;\n-  signalSem (&lock);\n-  RTco_signal (sem);\n-}\n-\n-/* waitThread wait on the semaphore associated with thread tid.  */\n-\n-extern \"C\" void\n-RTco_waitThread (int tid)\n-{\n-  RTco_init ();\n-  tprintf (\"waitThread %d\\n\", tid);\n-  RTco_wait (threadArray[tid].execution);\n-}\n-\n-extern \"C\" int\n-currentThread (void)\n-{\n-  int tid;\n-\n-  for (tid = 0; tid < nThreads; tid++)\n-    if (pthread_self () == threadArray[tid].p)\n-      return tid;\n-  M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-\t       \"failed to find currentThread\");\n-}\n-\n extern \"C\" int\n-RTco_currentThread (void)\n+EXPORT(currentThread) (void)\n {\n   int tid;\n \n-  RTco_init ();\n-  waitSem (&lock);\n-  tid = currentThread ();\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n+  tid = currentThread;\n   tprintf (\"currentThread %d\\n\", tid);\n-  signalSem (&lock);\n+  __gthread_mutex_unlock (&lock);\n   return tid;\n }\n \n /* currentInterruptLevel returns the interrupt level of the current thread.  */\n \n extern \"C\" unsigned int\n-RTco_currentInterruptLevel (void)\n+EXPORT(currentInterruptLevel) (void)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n   tprintf (\"currentInterruptLevel %d\\n\",\n-           threadArray[RTco_currentThread ()].interruptLevel);\n-  return threadArray[RTco_currentThread ()].interruptLevel;\n+           threadArray[currentThread].interruptLevel);\n+  int level = threadArray[currentThread].interruptLevel;\n+  __gthread_mutex_unlock (&lock);\n+  return level;\n }\n \n /* turninterrupts returns the old interrupt level and assigns the\n    interrupt level to newLevel.  */\n \n extern \"C\" unsigned int\n-RTco_turnInterrupts (unsigned int newLevel)\n+EXPORT(turnInterrupts) (unsigned int newLevel)\n {\n-  int tid = RTco_currentThread ();\n-  unsigned int old = RTco_currentInterruptLevel ();\n-\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n+  unsigned int old = threadArray[currentThread].interruptLevel;\n   tprintf (\"turnInterrupts from %d to %d\\n\", old, newLevel);\n-  waitSem (&lock);\n-  threadArray[tid].interruptLevel = newLevel;\n-  signalSem (&lock);\n+  threadArray[currentThread].interruptLevel = newLevel;\n+  __gthread_mutex_unlock (&lock);\n   return old;\n }\n \n@@ -306,12 +287,30 @@ execThread (void *t)\n {\n   threadCB *tp = (threadCB *)t;\n \n+  tprintf (\"exec thread tid = %d coming to life\\n\", tp->tid);\n+  __gthread_mutex_lock (&lock);\n   tprintf (\"exec thread tid = %d  function = 0x%p  arg = 0x%p\\n\", tp->tid,\n            tp->proc, t);\n-  RTco_waitThread (\n-      tp->tid); /* Forcing this thread to block, waiting to be scheduled.  */\n-  tprintf (\"  exec thread [%d]  function = 0x%p  arg = 0x%p\\n\", tp->tid,\n+  /* Has the thread been signalled?  */\n+  if (tp->value == 0)\n+    {\n+      /* Not been signalled therefore we force ourselves to block.  */\n+      tprintf (\"%s: forcing thread tid = %d to wait\\n\",\n+\t       __FUNCTION__, tp->tid);\n+      tp->waiting = true;  /* We are waiting.  */\n+      __gthread_cond_wait (&tp->run_counter, &lock);\n+      tp->waiting = false; /* Running again.  */\n+    }\n+  else\n+    {\n+      /* Yes signalled, therefore just take the recorded signal and continue.  */\n+      tprintf (\"%s: no need for thread tid = %d to wait\\n\",\n+\t       __FUNCTION__, tp->tid);\n+      tp->value--;\n+    }\n+  tprintf (\"  running exec thread [%d]  function = 0x%p  arg = 0x%p\\n\", tp->tid,\n            tp->proc, t);\n+  __gthread_mutex_unlock (&lock);\n   tp->proc (); /* Now execute user procedure.  */\n #if 0\n   M2RTS_CoroutineException ( __FILE__, __LINE__, __COLUMN__, __FUNCTION__, \"coroutine finishing\");\n@@ -356,21 +355,24 @@ initThread (void (*proc) (void), unsigned int stackSize,\n \n   threadArray[tid].proc = proc;\n   threadArray[tid].tid = tid;\n-  threadArray[tid].execution = initSemaphore (0);\n+  /* Initialize the thread run_counter used to force a context switch.  */\n+  __GTHREAD_COND_INIT_FUNCTION (&threadArray[tid].run_counter);\n   threadArray[tid].interruptLevel = interrupt;\n+  threadArray[tid].waiting = false;     /* The thread is running.  */\n+  threadArray[tid].value = 0;  /* No signal has been seen yet.  */\n \n-  /* set thread creation attributes.  */\n+  /* Set thread creation attributes.  */\n   result = pthread_attr_init (&attr);\n   if (result != 0)\n     M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-                \"failed to create thread attribute\");\n+\t\t \"failed to create thread attribute\");\n \n   if (stackSize > 0)\n     {\n       result = pthread_attr_setstacksize (&attr, stackSize);\n       if (result != 0)\n         M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-                    \"failed to set stack size attribute\");\n+\t\t     \"failed to set stack size attribute\");\n     }\n \n   tprintf (\"initThread [%d]  function = 0x%p  (arg = 0x%p)\\n\", tid, proc,\n@@ -385,85 +387,132 @@ initThread (void (*proc) (void), unsigned int stackSize,\n }\n \n extern \"C\" int\n-RTco_initThread (void (*proc) (void), unsigned int stackSize,\n-                 unsigned int interrupt)\n+EXPORT(initThread) (void (*proc) (void), unsigned int stackSize,\n+\t\t    unsigned int interrupt)\n {\n   int tid;\n \n-  RTco_init ();\n-  waitSem (&lock);\n+  EXPORT(init) ();\n+  __gthread_mutex_lock (&lock);\n   tid = initThread (proc, stackSize, interrupt);\n-  signalSem (&lock);\n+  __gthread_mutex_unlock (&lock);\n   return tid;\n }\n \n /* transfer unlocks thread p2 and locks the current thread.  p1 is\n-   updated with the current thread id.  */\n+   updated with the current thread id.\n+   The implementation of transfer uses a combined wait/signal.  */\n \n extern \"C\" void\n-RTco_transfer (int *p1, int p2)\n+EXPORT(transfer) (int *p1, int p2)\n {\n-  int tid = currentThread ();\n-\n-  if (!initialized)\n-    M2RTS_HaltC (\n-        __FILE__, __LINE__, __FUNCTION__,\n-        \"cannot transfer to a process before the process has been created\");\n-  if (tid == p2)\n-    {\n-      /* error.  */\n+  __gthread_mutex_lock (&lock);\n+  {\n+    if (!initialized)\n       M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n-\t\t   \"attempting to transfer to ourself\");\n-    }\n-  else\n-    {\n-      *p1 = tid;\n-      tprintf (\"start, context switching from: %d to %d\\n\", tid, p2);\n-      RTco_signalThread (p2);\n-      RTco_waitThread (tid);\n-      tprintf (\"end, context back to %d\\n\", tid);\n+\t\t   \"cannot transfer to a process before the process has been created\");\n+    if (currentThread == p2)\n+      {\n+\t/* Error.  */\n+\tM2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n+\t\t     \"attempting to transfer to ourself\");\n     }\n+    else\n+      {\n+\t*p1 = currentThread;\n+\tint old = currentThread;\n+\ttprintf (\"start, context switching from: %d to %d\\n\", currentThread, p2);\n+\t/* Perform signal (p2 sem).  Without the mutex lock as we have\n+\t   already obtained it above.  */\n+\tif (threadArray[p2].waiting)\n+\t  {\n+\t    /* p2 is blocked on the condition variable, release it.  */\n+\t    tprintf (\"p1 = %d cond_signal to p2 (%d)\\n\", currentThread, p2);\n+\t  __gthread_cond_signal (&threadArray[p2].run_counter);\n+\t  tprintf (\"after p1 = %d cond_signal to p2 (%d)\\n\", currentThread, p2);\n+\t  }\n+\telse\n+\t  {\n+\t    /* p2 hasn't reached the condition variable, so bump value\n+\t       ready for p2 to test.  */\n+\t    tprintf (\"no need for thread %d to cond_signal - bump %d value (pre) = %d\\n\",\n+\t\t     currentThread, p2, threadArray[p2].value);\n+\t    threadArray[p2].value++;\n+\t  }\n+\t/* Perform wait (old sem).  Again without obtaining mutex as\n+\t   we've already claimed it.  */\n+\tif (threadArray[old].value == 0)\n+\t  {\n+\t    currentThread = p2;\n+\t    /* Record we are about to wait on the condition variable.  */\n+\t    threadArray[old].waiting = true;\n+\t    __gthread_cond_wait (&threadArray[old].run_counter, &lock);\n+\t    threadArray[old].waiting = false;\n+\t    /* We are running again.  */\n+\t    currentThread = old;\n+\t  }\n+\telse\n+\t  {\n+\t    tprintf (\"(currentThread = %d) no need for thread %d to cond_wait - taking value (pre) = %d\\n\",\n+\t\t     currentThread, old, threadArray[old].value);\n+\t    /* No need to block as we have been told a signal has\n+               effectively already been recorded.  We remove the signal\n+               notification without blocking.  */\n+\t    threadArray[old].value--;\n+\t  }\n+\ttprintf (\"end, context back to %d\\n\", currentThread);\n+\tif (currentThread != old)\n+\t  M2RTS_HaltC (__FILE__, __LINE__, __FUNCTION__,\n+\t\t       \"wrong process id\");\n+      }\n+  }\n+  __gthread_mutex_unlock (&lock);\n }\n \n extern \"C\" int\n-RTco_select (int p1, fd_set *p2, fd_set *p3, fd_set *p4, const timespec *p5)\n+EXPORT(select) (int p1, fd_set *p2, fd_set *p3, fd_set *p4, const timespec *p5)\n {\n-  RTco_init ();\n+  EXPORT(init) ();\n   tprintf (\"[%x]  RTco.select (...)\\n\", pthread_self ());\n   return pselect (p1, p2, p3, p4, p5, NULL);\n }\n \n extern \"C\" int\n-RTco_init (void)\n+EXPORT(init) (void)\n {\n+  tprintf (\"checking init\\n\");\n   if (! initialized)\n     {\n-      int tid;\n+      initialized = TRUE;\n \n       tprintf (\"RTco initialized\\n\");\n-      initSem (&lock, 0);\n+      __GTHREAD_MUTEX_INIT_FUNCTION (&lock);\n+      __gthread_mutex_lock (&lock);\n       /* Create initial thread container.  */\n #if defined(POOL)\n       threadArray = (threadCB *)malloc (sizeof (threadCB) * THREAD_POOL);\n       semArray = (threadSem **)malloc (sizeof (threadSem *) * SEM_POOL);\n #endif\n-      tid = newThread ();  /* For the current initial thread.  */\n-      threadArray[tid].tid = tid;\n-      threadArray[tid].execution = initSemaphore (0);\n-      threadArray[tid].p = pthread_self ();\n-      threadArray[tid].interruptLevel = 0;\n-      threadArray[tid].proc\n-          = never;  /* This shouldn't happen as we are already running.  */\n-      initialized = TRUE;\n+      /* Create a thread control block for the main program (or process).  */\n+      currentThread = newThread ();  /* For the current initial thread.  */\n+      threadArray[currentThread].p = pthread_self ();\n+      threadArray[currentThread].tid = currentThread;\n+      __GTHREAD_COND_INIT_FUNCTION (&threadArray[currentThread].run_counter);\n+      threadArray[currentThread].interruptLevel = 0;\n+      /* The line below shouldn't be necessary as we are already running.  */\n+      threadArray[currentThread].proc = never;\n+      threadArray[currentThread].waiting = false;   /* We are running.  */\n+      threadArray[currentThread].value = 0;   /* No signal from anyone yet.  */\n       tprintf (\"RTco initialized completed\\n\");\n-      signalSem (&lock);\n+      __gthread_mutex_unlock (&lock);\n     }\n   return 0;\n }\n \n extern \"C\" void __attribute__((__constructor__))\n-_M2_RTco_ctor (void)\n+M2EXPORT(ctor) (void)\n {\n-  M2RTS_RegisterModule (\"RTco\", _M2_RTco_init, _M2_RTco_fini,\n-\t\t\t_M2_RTco_dep);\n+  M2RTS_RegisterModule (\"RTco\",\n+\t\t\tM2EXPORT(init), M2EXPORT(fini),\n+\t\t\tM2EXPORT(dep));\n }"}, {"sha": "7eb41dfd28556106f390536fcabfd47da0509eb3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -1,3 +1,8 @@\n+2023-02-18  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* doc/xml/faq.xml: Switch two links to www.open-std.org to https.\n+\t* doc/html/faq.html: Regenerate.\n+\n 2023-02-16  Matthias Kretz  <m.kretz@gsi.de>\n \n \t* include/experimental/bits/simd_math.h (__hypot): Bitcasting"}, {"sha": "965aa91d0312ed752f51fcfbb522df08e8ac7539", "filename": "libstdc++-v3/doc/html/faq.html", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Ffaq.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Ffaq.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fhtml%2Ffaq.html?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -541,7 +541,7 @@\n     For those people who are not part of the ISO Library Group\n     (i.e., nearly all of us needing to read this page in the first\n     place), a public list of the library defects is occasionally\n-    published on <a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/\" target=\"_top\">the WG21\n+    published on <a class=\"link\" href=\"https://www.open-std.org/jtc1/sc22/wg21/\" target=\"_top\">the WG21\n     website</a>.\n     Many of these issues have resulted in\n     <a class=\"link\" href=\"manual/bugs.html#manual.intro.status.bugs.iso\" title=\"Standard Bugs\">code changes in libstdc++</a>.\n@@ -825,7 +825,7 @@\n     Yes.\n     </p><p>\n     The C++ Standard Library\n-    <a class=\"link\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\" target=\"_top\">\n+    <a class=\"link\" href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\" target=\"_top\">\n     Technical Report 1</a> added many new features to the library.\n     </p><p>\n     The implementation status of TR1 in libstdc++ can be tracked"}, {"sha": "b38091acdc8f8d64ce3cc7aba3f69babae9f3918", "filename": "libstdc++-v3/doc/xml/faq.xml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc644ac37771b9119254831af264e1132b3259da/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Ffaq.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc644ac37771b9119254831af264e1132b3259da/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Ffaq.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Ffaq.xml?ref=bc644ac37771b9119254831af264e1132b3259da", "patch": "@@ -754,7 +754,7 @@\n     (i.e., nearly all of us needing to read this page in the first\n     place), a public list of the library defects is occasionally\n     published on <link xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n-    xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/\">the WG21\n+    xlink:href=\"https://www.open-std.org/jtc1/sc22/wg21/\">the WG21\n     website</link>.\n     Many of these issues have resulted in\n     <link linkend=\"manual.intro.status.bugs.iso\">code changes in libstdc++</link>.\n@@ -1181,7 +1181,7 @@\n     </para>\n     <para>\n     The C++ Standard Library\n-    <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\">\n+    <link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf\">\n     Technical Report 1</link> added many new features to the library.\n     </para>\n     <para>"}]}