{"sha": "2f55f4aa6c403c58480cc9040b1c17238c17a54f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY1NWY0YWE2YzQwM2M1ODQ4MGNjOTA0MGIxYzE3MjM4YzE3YTU0Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-05-09T21:49:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-05-09T21:49:47Z"}, "message": "go/build, cmd/go: update to match recent changes to gc\n    \n    Several recent changes to the gc version of cmd/go improve the\n    gofrontend support. These changes are partially copies of existing\n    gofrontend differences, and partially new code. This CL makes the\n    gofrontend match the upstream code.\n    \n    The changes included here come from:\n        https://golang.org/cl/111575\n        https://golang.org/cl/111595\n        https://golang.org/cl/111635\n        https://golang.org/cl/111636\n    \n    For the record, the following recent gc changes are based on code\n    already present in the gofrontend repo:\n        https://golang.org/cl/110915\n        https://golang.org/cl/111615\n    \n    For the record, a gc change, partially based on earlier gofrontend\n    work, also with new gc code, was already copied to gofrontend repo in\n    CL 111099:\n        https://golang.org/cl/111097\n    \n    This moves the generated list of standard library packages from\n    cmd/go/internal/load to go/build.\n    \n    Reviewed-on: https://go-review.googlesource.com/112475\n\ngotools/:\n\t* Makefile.am (check-go-tool): Don't copy zstdpkglist.go.\n\t* Makefile.in: Rebuild.\n\nFrom-SVN: r260097", "tree": {"sha": "db15ce3c24c21d5a4a060f2342339882ef0cc014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db15ce3c24c21d5a4a060f2342339882ef0cc014"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f55f4aa6c403c58480cc9040b1c17238c17a54f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f55f4aa6c403c58480cc9040b1c17238c17a54f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f55f4aa6c403c58480cc9040b1c17238c17a54f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f55f4aa6c403c58480cc9040b1c17238c17a54f/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f2410266a00a3ebd6db07007aa82333b4f6ee6c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2410266a00a3ebd6db07007aa82333b4f6ee6c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2410266a00a3ebd6db07007aa82333b4f6ee6c2"}], "stats": {"total": 239, "additions": 179, "deletions": 60}, "files": [{"sha": "319d2f5a49c86aa5b01f88a4a831821987d9e823", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -1,4 +1,4 @@\n-6b0355769edd9543e6c5f2270b26b140bb96e9aa\n+290c93f08f4456f0552b0764e28573164e47f259\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0e671860435e87eaabd58b46e2d5d235225db32b", "filename": "gotools/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -1,3 +1,8 @@\n+2018-05-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (check-go-tool): Don't copy zstdpkglist.go.\n+\t* Makefile.in: Rebuild.\n+\n 2018-05-04  Ian Lance Taylor  <iant@golang.org>\n \n \tPR go/85630"}, {"sha": "06be89d582a8afceaecf5c5f2221bb4132967ec7", "filename": "gotools/Makefile.am", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -232,7 +232,6 @@ check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \t$(MKDIR_P) check-go-dir/src/cmd/go\n \tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n \tcp -r $(cmdsrcdir)/go/internal check-go-dir/src/cmd/go/\n-\tcp $(libgodir)/zstdpkglist.go check-go-dir/src/cmd/go/internal/load/\n \tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n \tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n \tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/"}, {"sha": "503ec4eb446ea2bb8bb790f64801ce33435030f6", "filename": "gotools/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -637,8 +637,8 @@ distclean-generic:\n maintainer-clean-generic:\n \t@echo \"This command is intended for maintainers to use\"\n \t@echo \"it deletes files that may require special tools to rebuild.\"\n-@NATIVE_FALSE@install-exec-local:\n @NATIVE_FALSE@uninstall-local:\n+@NATIVE_FALSE@install-exec-local:\n clean: clean-am\n \n clean-am: clean-binPROGRAMS clean-generic clean-noinstPROGRAMS \\\n@@ -811,7 +811,6 @@ mostlyclean-local:\n @NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/cmd/go\n @NATIVE_TRUE@\tcp $(cmdsrcdir)/go/*.go check-go-dir/src/cmd/go/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/internal check-go-dir/src/cmd/go/\n-@NATIVE_TRUE@\tcp $(libgodir)/zstdpkglist.go check-go-dir/src/cmd/go/internal/load/\n @NATIVE_TRUE@\tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/"}, {"sha": "d847413d94cb31fb091705997f8d234b36bcef19", "filename": "libgo/Makefile.am", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -602,13 +602,13 @@ s-runtime-inc: runtime.lo Makefile\n \t$(SHELL) $(srcdir)/mvifdiff.sh tmp-runtime.inc runtime.inc\n \t$(STAMP) $@\n \n-noinst_DATA += zstdpkglist.go zdefaultcc.go\n+noinst_DATA += zdefaultcc.go\n \n # Generate the list of go std packages that were included in libgo\n zstdpkglist.go: s-zstdpkglist; @true\n s-zstdpkglist: Makefile\n \trm -f zstdpkglist.go.tmp\n-\techo 'package load' > zstdpkglist.go.tmp\n+\techo 'package build' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n \techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n@@ -960,6 +960,9 @@ runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n \n+extra_go_files_go_build = zstdpkglist.go\n+go/build.lo.dep: $(extra_go_files_go_build)\n+\n extra_go_files_go_types = gccgosizes.go\n go/types.lo.dep: $(extra_go_files_go_types)\n \n@@ -969,9 +972,6 @@ cmd/internal/objabi.lo.dep: $(extra_go_files_cmd_internal_objabi)\n extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n \n-extra_go_files_cmd_go_internal_load = zstdpkglist.go\n-cmd/go/internal/load.lo.dep: $(extra_go_files_cmd_go_internal_load)\n-\n extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a"}, {"sha": "6b3c59787018cc24d2a63537d6bca2aed39f391c", "filename": "libgo/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -759,7 +759,7 @@ noinst_DATA = golang_org/x/net/internal/nettest.gox \\\n \tgolang_org/x/net/nettest.gox internal/testenv.gox \\\n \tinternal/trace.gox net/internal/socktest.gox \\\n \tos/signal/internal/pty.gox runtime/pprof/internal/profile.gox \\\n-\tzstdpkglist.go zdefaultcc.go\n+\tzdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n @LIBGO_IS_AIX_FALSE@@LIBGO_IS_DARWIN_FALSE@@LIBGO_IS_FREEBSD_FALSE@@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@@LIBGO_IS_SOLARIS_FALSE@runtime_getncpu_file = runtime/getncpu-none.c\n@@ -999,10 +999,10 @@ runtime_internal_sys_lo_check_GOCFLAGS = -fgo-compiling-runtime\n # Also use -fno-inline to get better results from the memory profiler.\n runtime_pprof_check_GOCFLAGS = -static-libgo -fno-inline\n extra_go_files_runtime_internal_sys = version.go\n+extra_go_files_go_build = zstdpkglist.go\n extra_go_files_go_types = gccgosizes.go\n extra_go_files_cmd_internal_objabi = objabi.go\n extra_go_files_cmd_go_internal_cfg = zdefaultcc.go\n-extra_go_files_cmd_go_internal_load = zstdpkglist.go\n extra_check_libs_cmd_go_internal_cache = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_generate = $(abs_builddir)/libgotool.a\n extra_check_libs_cmd_go_internal_get = $(abs_builddir)/libgotool.a\n@@ -2816,7 +2816,7 @@ s-runtime-inc: runtime.lo Makefile\n zstdpkglist.go: s-zstdpkglist; @true\n s-zstdpkglist: Makefile\n \trm -f zstdpkglist.go.tmp\n-\techo 'package load' > zstdpkglist.go.tmp\n+\techo 'package build' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n \techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n@@ -2943,10 +2943,10 @@ $(foreach package,$(GOTOOL_PACKAGES),$(eval $(call PACKAGE_template,$(package)))\n runtime.lo.dep: $(extra_go_files_runtime)\n syscall.lo.dep: $(extra_go_files_syscall)\n runtime/internal/sys.lo.dep: $(extra_go_files_runtime_internal_sys)\n+go/build.lo.dep: $(extra_go_files_go_build)\n go/types.lo.dep: $(extra_go_files_go_types)\n cmd/internal/objabi.lo.dep: $(extra_go_files_cmd_internal_objabi)\n cmd/go/internal/cfg.lo.dep: $(extra_go_files_cmd_go_internal_cfg)\n-cmd/go/internal/load.lo.dep: $(extra_go_files_cmd_go_internal_load)\n \n # FIXME: The following C files may as well move to the runtime\n # directory and be treated like other C files."}, {"sha": "b2a757a7fc3d77a4edaca1ff6374a57ce47d730b", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -223,9 +223,6 @@ func (p *Package) copyBuild(pp *build.Package) {\n \t// TODO? Target\n \tp.Goroot = pp.Goroot\n \tp.Standard = p.Goroot && p.ImportPath != \"\" && isStandardImportPath(p.ImportPath)\n-\tif cfg.BuildToolchainName == \"gccgo\" {\n-\t\tp.Standard = stdpkg[p.ImportPath]\n-\t}\n \tp.GoFiles = pp.GoFiles\n \tp.CgoFiles = pp.CgoFiles\n \tp.IgnoredGoFiles = pp.IgnoredGoFiles\n@@ -894,13 +891,6 @@ var foldPath = make(map[string]string)\n func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \tp.copyBuild(bp)\n \n-\t// When using gccgo the go/build package will not be able to\n-\t// find a standard package. It would be nicer to not get that\n-\t// error, but go/build doesn't know stdpkg.\n-\tif cfg.BuildToolchainName == \"gccgo\" && err != nil && p.Standard {\n-\t\terr = nil\n-\t}\n-\n \t// Decide whether p was listed on the command line.\n \t// Given that load is called while processing the command line,\n \t// you might think we could simply pass a flag down into load\n@@ -1096,9 +1086,6 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t\tcontinue\n \t\t}\n \t\tp1 := LoadImport(path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], UseVendor)\n-\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n-\t\t\tcontinue\n-\t\t}\n \t\tif p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n@@ -1610,9 +1597,6 @@ func GetTestPackagesFor(p *Package, forceTest bool) (ptest, pxtest *Package, err\n \trawTestImports := str.StringList(p.TestImports)\n \tfor i, path := range p.TestImports {\n \t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], UseVendor)\n-\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n-\t\t\tcontinue\n-\t\t}\n \t\tif p1.Error != nil {\n \t\t\treturn nil, nil, p1.Error\n \t\t}\n@@ -1641,9 +1625,6 @@ func GetTestPackagesFor(p *Package, forceTest bool) (ptest, pxtest *Package, err\n \trawXTestImports := str.StringList(p.XTestImports)\n \tfor i, path := range p.XTestImports {\n \t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], UseVendor)\n-\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n-\t\t\tcontinue\n-\t\t}\n \t\tif p1.Error != nil {\n \t\t\treturn nil, nil, p1.Error\n \t\t}"}, {"sha": "dbf6eea8a9239d59742274b90ba8693192e8d202", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -633,6 +633,8 @@ func runTest(cmd *base.Command, args []string) {\n \t\ta := &work.Action{Mode: \"go test -i\"}\n \t\tfor _, p := range load.PackagesForBuild(all) {\n \t\t\tif cfg.BuildToolchainName == \"gccgo\" && p.Standard {\n+\t\t\t\t// gccgo's standard library packages\n+\t\t\t\t// can not be reinstalled.\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\ta.Deps = append(a.Deps, b.CompileAction(work.ModeInstall, work.ModeInstall, p))\n@@ -862,9 +864,6 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n \t\t} else {\n \t\t\tp1 := load.LoadImport(dep, \"\", nil, &stk, nil, 0)\n-\t\t\tif cfg.BuildToolchainName == \"gccgo\" && p1.Standard {\n-\t\t\t\tcontinue\n-\t\t\t}\n \t\t\tif p1.Error != nil {\n \t\t\t\treturn nil, nil, nil, p1.Error\n \t\t\t}"}, {"sha": "6150bbb81a6a567bdfd9760944458d2285b20b59", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -234,18 +234,9 @@ func (b *Builder) gccgoToolID(name, language string) (string, error) {\n \t// compile an empty file on standard input.\n \tcmdline := str.StringList(cfg.BuildToolexec, name, \"-###\", \"-x\", language, \"-c\", \"-\")\n \tcmd := exec.Command(cmdline[0], cmdline[1:]...)\n-\n-\t// Strip any LANG or LC_ environment variables, and force\n-\t// LANG=C, so that we get the untranslated output.\n-\tvar env []string\n-\tfor _, e := range os.Environ() {\n-\t\tif !strings.HasPrefix(e, \"LANG=\") && !strings.HasPrefix(e, \"LC_\") {\n-\t\t\tenv = append(env, e)\n-\t\t}\n-\t}\n-\tenv = append(env, \"LANG=C\")\n-\n-\tcmd.Env = base.EnvForDir(cmd.Dir, env)\n+\tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n+\t// Force untranslated output so that we see the string \"version\".\n+\tcmd.Env = append(cmd.Env, \"LC_ALL=C\")\n \tout, err := cmd.CombinedOutput()\n \tif err != nil {\n \t\treturn \"\", fmt.Errorf(\"%s: %v; output: %q\", name, err, out)"}, {"sha": "85bdff8fb0c697c0308dde02742b5f8252a681a8", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -1545,6 +1545,8 @@ func joinUnambiguously(a []string) string {\n \t\t\tbuf.WriteByte(' ')\n \t\t}\n \t\tq := strconv.Quote(s)\n+\t\t// A gccgo command line can contain -( and -).\n+\t\t// Make sure we quote them since they are special to the shell.\n \t\tif s == \"\" || strings.ContainsAny(s, \" ()\") || len(q) > len(s)+2 {\n \t\t\tbuf.WriteString(q)\n \t\t} else {\n@@ -1585,13 +1587,17 @@ func (b *Builder) Mkdir(dir string) error {\n \n // symlink creates a symlink newname -> oldname.\n func (b *Builder) Symlink(oldname, newname string) error {\n+\t// It's not an error to try to recreate an existing symlink.\n+\tif link, err := os.Readlink(newname); err == nil && link == oldname {\n+\t\treturn nil\n+\t}\n+\n \tif cfg.BuildN || cfg.BuildX {\n-\t\tb.Showcmd(\"\", \"ln -sf %s %s\", oldname, newname)\n+\t\tb.Showcmd(\"\", \"ln -s %s %s\", oldname, newname)\n \t\tif cfg.BuildN {\n \t\t\treturn nil\n \t\t}\n \t}\n-\tos.Remove(newname)\n \treturn os.Symlink(oldname, newname)\n }\n "}, {"sha": "9df4930dbcf69d6496ebd1f5406b08ac775c80b8", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -238,7 +238,7 @@ func (ctxt *Context) gopath() []string {\n // that do not exist.\n func (ctxt *Context) SrcDirs() []string {\n \tvar all []string\n-\tif ctxt.GOROOT != \"\" {\n+\tif ctxt.GOROOT != \"\" && ctxt.Compiler != \"gccgo\" {\n \t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\")\n \t\tif ctxt.isDir(dir) {\n \t\t\tall = append(all, dir)\n@@ -540,7 +540,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\tinTestdata := func(sub string) bool {\n \t\t\treturn strings.Contains(sub, \"/testdata/\") || strings.HasSuffix(sub, \"/testdata\") || strings.HasPrefix(sub, \"testdata/\") || sub == \"testdata\"\n \t\t}\n-\t\tif ctxt.GOROOT != \"\" {\n+\t\tif ctxt.GOROOT != \"\" && ctxt.Compiler != \"gccgo\" {\n \t\t\troot := ctxt.joinPath(ctxt.GOROOT, \"src\")\n \t\t\tif sub, ok := ctxt.hasSubdir(root, p.Dir); ok && !inTestdata(sub) {\n \t\t\t\tp.Goroot = true\n@@ -557,7 +557,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t\t\t// We found a potential import path for dir,\n \t\t\t\t// but check that using it wouldn't find something\n \t\t\t\t// else first.\n-\t\t\t\tif ctxt.GOROOT != \"\" {\n+\t\t\t\tif ctxt.GOROOT != \"\" && ctxt.Compiler != \"gccgo\" {\n \t\t\t\t\tif dir := ctxt.joinPath(ctxt.GOROOT, \"src\", sub); ctxt.isDir(dir) {\n \t\t\t\t\t\tp.ConflictDir = dir\n \t\t\t\t\t\tgoto Found\n@@ -622,7 +622,7 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t\t\t}\n \t\t\t\treturn false\n \t\t\t}\n-\t\t\tif searchVendor(ctxt.GOROOT, true) {\n+\t\t\tif ctxt.Compiler != \"gccgo\" && searchVendor(ctxt.GOROOT, true) {\n \t\t\t\tgoto Found\n \t\t\t}\n \t\t\tfor _, root := range gopath {\n@@ -635,16 +635,24 @@ func (ctxt *Context) Import(path string, srcDir string, mode ImportMode) (*Packa\n \t\t// Determine directory from import path.\n \t\tif ctxt.GOROOT != \"\" {\n \t\t\tdir := ctxt.joinPath(ctxt.GOROOT, \"src\", path)\n-\t\t\tisDir := ctxt.isDir(dir)\n-\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && pkga != \"\" && ctxt.isFile(ctxt.joinPath(ctxt.GOROOT, pkga))\n-\t\t\tif isDir || binaryOnly {\n-\t\t\t\tp.Dir = dir\n-\t\t\t\tp.Goroot = true\n-\t\t\t\tp.Root = ctxt.GOROOT\n-\t\t\t\tgoto Found\n+\t\t\tif ctxt.Compiler != \"gccgo\" {\n+\t\t\t\tisDir := ctxt.isDir(dir)\n+\t\t\t\tbinaryOnly = !isDir && mode&AllowBinary != 0 && pkga != \"\" && ctxt.isFile(ctxt.joinPath(ctxt.GOROOT, pkga))\n+\t\t\t\tif isDir || binaryOnly {\n+\t\t\t\t\tp.Dir = dir\n+\t\t\t\t\tp.Goroot = true\n+\t\t\t\t\tp.Root = ctxt.GOROOT\n+\t\t\t\t\tgoto Found\n+\t\t\t\t}\n \t\t\t}\n \t\t\ttried.goroot = dir\n \t\t}\n+\t\tif ctxt.Compiler == \"gccgo\" && isStandardPackage(path) {\n+\t\t\tp.Dir = ctxt.joinPath(ctxt.GOROOT, \"src\", path)\n+\t\t\tp.Goroot = true\n+\t\t\tp.Root = ctxt.GOROOT\n+\t\t\tgoto Found\n+\t\t}\n \t\tfor _, root := range gopath {\n \t\t\tdir := ctxt.joinPath(root, \"src\", path)\n \t\t\tisDir := ctxt.isDir(dir)\n@@ -708,6 +716,11 @@ Found:\n \t\treturn p, pkgerr\n \t}\n \n+\tif ctxt.Compiler == \"gccgo\" && p.Goroot {\n+\t\t// gccgo has no sources for GOROOT packages.\n+\t\treturn p, nil\n+\t}\n+\n \tdirs, err := ctxt.readDir(p.Dir)\n \tif err != nil {\n \t\treturn p, err"}, {"sha": "e2be2cbb1d18ff158849714caa3f19725a8ffc8f", "filename": "libgo/go/go/build/gc.go", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fgo%2Fbuild%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fgo%2Fbuild%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fgc.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -7,11 +7,131 @@\n package build\n \n import (\n+\t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n )\n \n // getToolDir returns the default value of ToolDir.\n func getToolDir() string {\n \treturn filepath.Join(runtime.GOROOT(), \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n }\n+\n+// isStandardPackage is not used for the gc toolchain.\n+// However, this function may be called when using `go build -compiler=gccgo`.\n+func isStandardPackage(path string) bool {\n+\treturn gccgoSearch.isStandard(path)\n+}\n+\n+// gccgoSearch holds the gccgo search directories.\n+type gccgoDirs struct {\n+\tonce sync.Once\n+\tdirs []string\n+}\n+\n+// gccgoSearch is used to check whether a gccgo package exists in the\n+// standard library.\n+var gccgoSearch gccgoDirs\n+\n+// init finds the gccgo search directories. If this fails it leaves dirs == nil.\n+func (gd *gccgoDirs) init() {\n+\tgccgo := os.Getenv(\"GCCGO\")\n+\tif gccgo == \"\" {\n+\t\tgccgo = \"gccgo\"\n+\t}\n+\tbin, err := exec.LookPath(gccgo)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tallDirs, err := exec.Command(bin, \"-print-search-dirs\").Output()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tversionB, err := exec.Command(bin, \"-dumpversion\").Output()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tversion := strings.TrimSpace(string(versionB))\n+\tmachineB, err := exec.Command(bin, \"-dumpmachine\").Output()\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tmachine := strings.TrimSpace(string(machineB))\n+\n+\tdirsEntries := strings.Split(string(allDirs), \"\\n\")\n+\tconst prefix = \"libraries: =\"\n+\tvar dirs []string\n+\tfor _, dirEntry := range dirsEntries {\n+\t\tif strings.HasPrefix(dirEntry, prefix) {\n+\t\t\tdirs = filepath.SplitList(strings.TrimPrefix(dirEntry, prefix))\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif len(dirs) == 0 {\n+\t\treturn\n+\t}\n+\n+\tvar lastDirs []string\n+\tfor _, dir := range dirs {\n+\t\tgoDir := filepath.Join(dir, \"go\", version)\n+\t\tif fi, err := os.Stat(goDir); err == nil && fi.IsDir() {\n+\t\t\tgd.dirs = append(gd.dirs, goDir)\n+\t\t\tgoDir = filepath.Join(goDir, machine)\n+\t\t\tif fi, err = os.Stat(goDir); err == nil && fi.IsDir() {\n+\t\t\t\tgd.dirs = append(gd.dirs, goDir)\n+\t\t\t}\n+\t\t}\n+\t\tif fi, err := os.Stat(dir); err == nil && fi.IsDir() {\n+\t\t\tlastDirs = append(lastDirs, dir)\n+\t\t}\n+\t}\n+\tgd.dirs = append(gd.dirs, lastDirs...)\n+}\n+\n+// isStandard returns whether path is a standard library for gccgo.\n+func (gd *gccgoDirs) isStandard(path string) bool {\n+\t// Quick check: if the first path component has a '.', it's not\n+\t// in the standard library. This skips most GOPATH directories.\n+\ti := strings.Index(path, \"/\")\n+\tif i < 0 {\n+\t\ti = len(path)\n+\t}\n+\tif strings.Contains(path[:i], \".\") {\n+\t\treturn false\n+\t}\n+\n+\tif path == \"unsafe\" {\n+\t\t// Special case.\n+\t\treturn true\n+\t}\n+\n+\tgd.once.Do(gd.init)\n+\tif gd.dirs == nil {\n+\t\t// We couldn't find the gccgo search directories.\n+\t\t// Best guess, since the first component did not contain\n+\t\t// '.', is that this is a standard library package.\n+\t\treturn true\n+\t}\n+\n+\tfor _, dir := range gd.dirs {\n+\t\tfull := filepath.Join(dir, path)\n+\t\tpkgdir, pkg := filepath.Split(full)\n+\t\tfor _, p := range [...]string{\n+\t\t\tfull,\n+\t\t\tfull + \".gox\",\n+\t\t\tpkgdir + \"lib\" + pkg + \".so\",\n+\t\t\tpkgdir + \"lib\" + pkg + \".a\",\n+\t\t\tfull + \".o\",\n+\t\t} {\n+\t\t\tif fi, err := os.Stat(p); err == nil && !fi.IsDir() {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn false\n+}"}, {"sha": "59e089d69db2cee93077b7ea20d075389ae836c0", "filename": "libgo/go/go/build/gccgo.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fgo%2Fbuild%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f55f4aa6c403c58480cc9040b1c17238c17a54f/libgo%2Fgo%2Fgo%2Fbuild%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fgccgo.go?ref=2f55f4aa6c403c58480cc9040b1c17238c17a54f", "patch": "@@ -12,3 +12,9 @@ import \"runtime\"\n func getToolDir() string {\n \treturn envOr(\"GCCGOTOOLDIR\", runtime.GCCGOTOOLDIR)\n }\n+\n+// isStandardPackage returns whether path names a standard library package.\n+// This uses a list generated at build time.\n+func isStandardPackage(path string) bool {\n+\treturn stdpkg[path]\n+}"}]}