{"sha": "42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmZGM4NWJmYmYzYjdlYWI4Yjg2MGMyZmNmZGMzYjc2OTZhY2IyZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-04-25T10:13:14Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-25T10:13:14Z"}, "message": "einfo.ads, einfo.adb: Remove with and use clauses for Namet.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.ads, einfo.adb: Remove with and use clauses for Namet.\n\t(Find_Pragma): New routine.\n\t* sem_util.ads, sem_util.adb (Find_Pragma): Moved to einfo.\n\n2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch13.adb (Add_Call): Do not capture the nature of the inherited\n\tpredicate.\n\t(Add_Predicates): Save the static predicate for diagnostics and error\n\treporting purposes.\n\t(Process_PPCs): Remove local variables Dynamic_Predicate_Present and\n\tStatic_Predicate_Present. Add local variable Static_Pred. Ensure that\n\tthe expression of a static predicate is static.\n\nFrom-SVN: r198283", "tree": {"sha": "3977c15587116896b00f1879f3e75814b6a198d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3977c15587116896b00f1879f3e75814b6a198d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "99a71c65ab06b6f960b80fd02879c003701eab41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99a71c65ab06b6f960b80fd02879c003701eab41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99a71c65ab06b6f960b80fd02879c003701eab41"}], "stats": {"total": 123, "additions": 62, "deletions": 61}, "files": [{"sha": "71295d84178eb4eb423a8ac04aeecf4ebe14a8fd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "patch": "@@ -1,3 +1,19 @@\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.ads, einfo.adb: Remove with and use clauses for Namet.\n+\t(Find_Pragma): New routine.\n+\t* sem_util.ads, sem_util.adb (Find_Pragma): Moved to einfo.\n+\n+2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch13.adb (Add_Call): Do not capture the nature of the inherited\n+\tpredicate.\n+\t(Add_Predicates): Save the static predicate for diagnostics and error\n+\treporting purposes.\n+\t(Process_PPCs): Remove local variables Dynamic_Predicate_Present and\n+\tStatic_Predicate_Present. Add local variable Static_Pred. Ensure that\n+\tthe expression of a static predicate is static.\n+\n 2013-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* einfo.adb (Is_Ghost_Subprogram): Remove useless code."}, {"sha": "81b35f7754ce4c91f9d58b3e325190efc461aacb", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "patch": "@@ -33,7 +33,6 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering, not used for this unit\n \n with Atree;   use Atree;\n-with Namet;   use Namet;\n with Nlists;  use Nlists;\n with Output;  use Output;\n with Sinfo;   use Sinfo;\n@@ -6102,6 +6101,26 @@ package body Einfo is\n       return Etype (Discrete_Subtype_Definition (Parent (Id)));\n    end Entry_Index_Type;\n \n+   -----------------\n+   -- Find_Pragma --\n+   -----------------\n+\n+   function Find_Pragma (Id : Entity_Id; Name : Name_Id) return Node_Id is\n+      Item : Node_Id;\n+\n+   begin\n+      Item := First_Rep_Item (Id);\n+      while Present (Item) loop\n+         if Nkind (Item) = N_Pragma and then Pragma_Name (Item) = Name then\n+            return Item;\n+         end if;\n+\n+         Item := Next_Rep_Item (Item);\n+      end loop;\n+\n+      return Empty;\n+   end Find_Pragma;\n+\n    ---------------------\n    -- First_Component --\n    ---------------------"}, {"sha": "38d4f22c6a5cee5cb01d06149b88b0ee5499849f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "patch": "@@ -29,6 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Namet;  use Namet;\n with Snames; use Snames;\n with Types;  use Types;\n with Uintp;  use Uintp;\n@@ -7351,6 +7352,11 @@ package Einfo is\n    --  expression is deferred to the freeze point. For further details see\n    --  Sem_Ch13.Analyze_Aspect_Specifications.\n \n+   function Find_Pragma (Id : Entity_Id; Name : Name_Id) return Node_Id;\n+   --  Given entity Id and pragma name Name, attempt to find the corresponding\n+   --  pragma in Id's chain of representation items. The function returns Empty\n+   --  if no such pragma has been found.\n+\n    function Get_Attribute_Definition_Clause\n      (E  : Entity_Id;\n       Id : Attribute_Id) return Node_Id;"}, {"sha": "e6f39f5b84409c45c1910725d87abd818e28d1f6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "patch": "@@ -5741,6 +5741,9 @@ package body Sem_Ch13 is\n       Raise_Expression_Present : Boolean := False;\n       --  Set True if Expr has at least one Raise_Expression\n \n+      Static_Predic : Node_Id := Empty;\n+      --  Set to N_Pragma node for a static predicate if one is encountered\n+\n       procedure Add_Call (T : Entity_Id);\n       --  Includes a call to the predicate function for type T in Expr if T\n       --  has predicates and Predicate_Function (T) is non-empty.\n@@ -5765,13 +5768,6 @@ package body Sem_Ch13 is\n       procedure Process_REs is new Traverse_Proc (Process_RE);\n       --  Marks any raise expressions in Expr_M to return False\n \n-      Dynamic_Predicate_Present : Boolean := False;\n-      --  Set True if a dynamic predicate is present, results in the entire\n-      --  predicate being considered dynamic even if it looks static.\n-\n-      Static_Predicate_Present : Node_Id := Empty;\n-      --  Set to N_Pragma node for a static predicate if one is encountered\n-\n       --------------\n       -- Add_Call --\n       --------------\n@@ -5783,12 +5779,6 @@ package body Sem_Ch13 is\n          if Present (T) and then Present (Predicate_Function (T)) then\n             Set_Has_Predicates (Typ);\n \n-            --  Capture the nature of the inherited ancestor predicate\n-\n-            if Has_Dynamic_Predicate_Aspect (T) then\n-               Dynamic_Predicate_Present := True;\n-            end if;\n-\n             --  Build the call to the predicate function of T\n \n             Exp :=\n@@ -5872,17 +5862,14 @@ package body Sem_Ch13 is\n             if Nkind (Ritem) = N_Pragma\n               and then Pragma_Name (Ritem) = Name_Predicate\n             then\n-               --  Capture the nature of the predicate\n-\n-               if Present (Corresponding_Aspect (Ritem)) then\n-                  case Chars (Identifier (Corresponding_Aspect (Ritem))) is\n-                     when Name_Dynamic_Predicate =>\n-                        Dynamic_Predicate_Present := True;\n-                     when Name_Static_Predicate =>\n-                        Static_Predicate_Present := Ritem;\n-                     when others =>\n-                        null;\n-                  end case;\n+               --  Save the static predicate of the type for diagnostics and\n+               --  error reporting purposes.\n+\n+               if Present (Corresponding_Aspect (Ritem))\n+                 and then Chars (Identifier (Corresponding_Aspect (Ritem))) =\n+                            Name_Static_Predicate\n+               then\n+                  Static_Predic := Ritem;\n                end if;\n \n                --  Acquire arguments\n@@ -6211,7 +6198,9 @@ package body Sem_Ch13 is\n \n             --  Attempt to build a static predicate for a discrete or a real\n             --  subtype. This action may fail because the actual expression may\n-            --  not be static.\n+            --  not be static. Note that the presence of an inherited or\n+            --  explicitly declared dynamic predicate is orthogonal to this\n+            --  check because we are only interested in the static predicate.\n \n             if Ekind_In (Typ, E_Decimal_Fixed_Point_Subtype,\n                               E_Enumeration_Subtype,\n@@ -6222,30 +6211,26 @@ package body Sem_Ch13 is\n             then\n                Build_Static_Predicate (Typ, Expr, Object_Name);\n \n-               --  The predicate is categorized as static but its expression is\n-               --  dynamic. Note that the predicate may become non-static when\n-               --  inherited dynamic predicates are involved.\n+               --  Emit an error when the predicate is categorized as static\n+               --  but its expression is dynamic.\n \n-               if Present (Static_Predicate_Present)\n+               if Present (Static_Predic)\n                  and then No (Static_Predicate (Typ))\n-                 and then not Dynamic_Predicate_Present\n                then\n                   Error_Msg_F\n                     (\"expression does not have required form for \"\n                      & \"static predicate\",\n                      Next (First (Pragma_Argument_Associations\n-                                   (Static_Predicate_Present))));\n+                                   (Static_Predic))));\n                end if;\n             end if;\n \n-         --  If a Static_Predicate applies on other types, that's an error:\n+         --  If a static predicate applies on other types, that's an error:\n          --  either the type is scalar but non-static, or it's not even a\n          --  scalar type. We do not issue an error on generated types, as\n          --  these may be duplicates of the same error on a source type.\n \n-         elsif Present (Static_Predicate_Present)\n-           and then Comes_From_Source (Typ)\n-         then\n+         elsif Present (Static_Predic) and then Comes_From_Source (Typ) then\n             if Is_Scalar_Type (Typ) then\n                Error_Msg_FE\n                  (\"static predicate not allowed for non-static type&\","}, {"sha": "095510e1eb0cdede2f1c23e0a6526fd8593c2c01", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "patch": "@@ -4882,26 +4882,6 @@ package body Sem_Util is\n       end if;\n    end Find_Parameter_Type;\n \n-   -----------------\n-   -- Find_Pragma --\n-   -----------------\n-\n-   function Find_Pragma (Id : Entity_Id; Name : Name_Id) return Node_Id is\n-      Item : Node_Id;\n-\n-   begin\n-      Item := First_Rep_Item (Id);\n-      while Present (Item) loop\n-         if Nkind (Item) = N_Pragma and then Pragma_Name (Item) = Name then\n-            return Item;\n-         end if;\n-\n-         Item := Next_Rep_Item (Item);\n-      end loop;\n-\n-      return Empty;\n-   end Find_Pragma;\n-\n    -----------------------------\n    -- Find_Static_Alternative --\n    -----------------------------"}, {"sha": "fa5b6e392b0eb44bc3646f15235dca64d795e3be", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=42fdc85bfbf3b7eab8b860c2fcfdc3b7696acb2e", "patch": "@@ -494,11 +494,6 @@ package Sem_Util is\n    --  Return the type of formal parameter Param as determined by its\n    --  specification.\n \n-   function Find_Pragma (Id : Entity_Id; Name : Name_Id) return Node_Id;\n-   --  Given entity Id and pragma name Name, attempt to find the corresponding\n-   --  pragma in Id's chain of representation items. The function returns Empty\n-   --  if no such pragma has been found.\n-\n    function Find_Static_Alternative (N : Node_Id) return Node_Id;\n    --  N is a case statement whose expression is a compile-time value.\n    --  Determine the alternative chosen, so that the code of non-selected"}]}