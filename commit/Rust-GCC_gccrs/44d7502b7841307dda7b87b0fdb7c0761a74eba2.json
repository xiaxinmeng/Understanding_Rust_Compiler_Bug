{"sha": "44d7502b7841307dda7b87b0fdb7c0761a74eba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRkNzUwMmI3ODQxMzA3ZGRhN2I4N2IwZmRiN2MwNzYxYTc0ZWJhMg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@cygnus.com", "date": "1999-06-21T09:18:50Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "1999-06-21T09:18:50Z"}, "message": "except.c (find_handler_in_range): The upper limit for exception ranges is exclusive, not inclusive...\n\n1999-06-21  Andrew Haley  <aph@cygnus.com>\n        * except.c (find_handler_in_range): The upper limit for exception\n        ranges is exclusive, not inclusive: (start <= pc < end).\n        (link_handler): find child pointer which points to outer by\n        searching sibling list: previous code incorrectly assumed that\n        outer->outer->first_child must point to outer.\n        * verify.c (verify_jvm_instructions): FIXME added to code for\n        `athrow'.\n        (verify_jvm_instructions): Do not assume that the last block\n        processed in a subroutine is a block which ends with a `ret'\n        instruction.  With some control flows it is possible that the last\n        block ends with an `athrow'.\n\nFrom-SVN: r27658", "tree": {"sha": "8136a21782174edaf0486712f17e806c1fad5567", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8136a21782174edaf0486712f17e806c1fad5567"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44d7502b7841307dda7b87b0fdb7c0761a74eba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d7502b7841307dda7b87b0fdb7c0761a74eba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d7502b7841307dda7b87b0fdb7c0761a74eba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d7502b7841307dda7b87b0fdb7c0761a74eba2/comments", "author": null, "committer": null, "parents": [{"sha": "60d0536b1edb935829a92be6526393e7c3a31896", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60d0536b1edb935829a92be6526393e7c3a31896", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60d0536b1edb935829a92be6526393e7c3a31896"}], "stats": {"total": 65, "additions": 52, "deletions": 13}, "files": [{"sha": "4136698a65eef0d3549dfa12f6ab705379eccf6d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d7502b7841307dda7b87b0fdb7c0761a74eba2/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d7502b7841307dda7b87b0fdb7c0761a74eba2/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=44d7502b7841307dda7b87b0fdb7c0761a74eba2", "patch": "@@ -1,3 +1,17 @@\n+1999-06-21  Andrew Haley  <aph@cygnus.com>\n+\n+        * except.c (find_handler_in_range): The upper limit for exception\n+        ranges is exclusive, not inclusive: (start <= pc < end).  \n+        (link_handler): find child pointer which points to outer by\n+        searching sibling list: previous code incorrectly assumed that\n+        outer->outer->first_child must point to outer.\n+        * verify.c (verify_jvm_instructions): FIXME added to code for\n+        `athrow'.\n+        (verify_jvm_instructions): Do not assume that the last block\n+        processed in a subroutine is a block which ends with a `ret'\n+        instruction.  With some control flows it is possible that the last\n+        block ends with an `athrow'.\n+\n Mon Jun 14 13:13:39 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (qualify_ambiguous_name): Reorganized the post"}, {"sha": "46d98df162c7b2bc828be8b50a610da7f4a2b171", "filename": "gcc/java/except.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d7502b7841307dda7b87b0fdb7c0761a74eba2/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d7502b7841307dda7b87b0fdb7c0761a74eba2/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=44d7502b7841307dda7b87b0fdb7c0761a74eba2", "patch": "@@ -72,7 +72,7 @@ find_handler_in_range (pc, range, child)\n     {\n       if (pc < child->start_pc)\n \tbreak;\n-      if (pc <= child->end_pc)\n+      if (pc < child->end_pc)\n \treturn find_handler_in_range (pc, child, child->first_child);\n     }\n   cache_range = range;\n@@ -129,7 +129,12 @@ link_handler (range, outer)\n       range->outer = outer->outer;\n       range->next_sibling = NULL;\n       range->first_child = outer;\n-      outer->outer->first_child = range;\n+      {\n+\tstruct eh_range **pr = &(outer->outer->first_child);\n+\twhile (*pr != outer)\n+\t  pr = &(*pr)->next_sibling;\n+\t*pr = range;\n+      }\n       outer->outer = range;\n       return;\n     }"}, {"sha": "ead4ea6ec1fd6225093e2b95450c1368cea369c5", "filename": "gcc/java/verify.c", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44d7502b7841307dda7b87b0fdb7c0761a74eba2/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44d7502b7841307dda7b87b0fdb7c0761a74eba2/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=44d7502b7841307dda7b87b0fdb7c0761a74eba2", "patch": "@@ -999,6 +999,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  break;\n \n \tcase OPCODE_athrow:\n+\t  // FIXME: athrow also empties the stack.\n \t  pop_type (throwable_type_node);\n \t  INVALIDATE_PC;\n \t  break;\n@@ -1197,21 +1198,46 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t\t    }\n \t\t}\n \n+\n+            }\n+          break;\n+        case OPCODE_jsr_w:        \n+        case OPCODE_ret_w:\n+        default:\n+          error (\"unknown opcode %d@pc=%d during verification\", op_code, PC-1);\n+          return 0;\n+        }\n+\n \t      /* Check if there are any more pending blocks in this subroutine.\n \t\t Because we push pending blocks in a last-in-first-out order,\n \t\t and because we don't push anything from our caller until we\n \t\t are done with this subroutine or anything nested in it,\n \t\t then we are done if the top of the pending_blocks stack is\n \t\t not in a subroutine, or it is in our caller. */\n+      if (current_subr \n+\t  && PC == INVALID_PC)\n+\t{\n+\t  tree caller = LABEL_SUBR_CONTEXT (current_subr);\n+\n \t      if (pending_blocks == NULL_TREE\n \t\t  || ! LABEL_IN_SUBR (pending_blocks)\n \t\t  || LABEL_SUBR_START (pending_blocks) == caller)\n \t\t{\n-\t\t  /* Since we are done with this subroutine (i.e. this is the\n-\t\t     last ret from it), set up the (so far known) return\n-\t\t     address as pending - with the merged type state. */\n-\t\t  tmp = LABEL_RETURN_LABELS (current_subr);\n-\t\t  current_subr = caller;\n+\t      int size = DECL_MAX_LOCALS(current_function_decl)+stack_pointer;\n+\t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n+\t      tmp = LABEL_RETURN_LABELS (current_subr);\n+\t      \n+\t      /* FIXME: If we exit a subroutine via a throw, we might\n+\t\t have returned to an earlier caller.  Obviously a\n+\t\t \"ret\" can only return one level, but a throw may\n+\t\t return many levels.*/\n+\t      current_subr = caller;\n+\n+\t      if (RETURN_MAP_ADJUSTED (ret_map))\n+\t\t{\n+\t\t  /* Since we are done with this subroutine , set up\n+\t\t     the (so far known) return address as pending -\n+\t\t     with the merged type state. */\n \t\t  for ( ; tmp != NULL_TREE;  tmp = TREE_CHAIN (tmp))\n \t\t    {\n \t\t      tree return_label = TREE_VALUE (tmp);\n@@ -1241,12 +1267,6 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t\t    }\n \t\t}\n \t    }\n-\t  break;\n-\tcase OPCODE_jsr_w:\t  \n-\tcase OPCODE_ret_w:\n-        default:\n-\t  error (\"unknown opcode %d@pc=%d during verification\", op_code, PC-1);\n-\t  return 0;\n \t}\n \n       prevpc = oldpc;"}]}