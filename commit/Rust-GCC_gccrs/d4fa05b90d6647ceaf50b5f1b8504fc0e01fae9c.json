{"sha": "d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRmYTA1YjkwZDY2NDdjZWFmNTBiNWYxYjg1MDRmYzBlMDFmYWU5Yw==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-05-15T17:31:32Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-05-15T17:31:32Z"}, "message": "re PR fortran/13702 (When preprocessing Fortran files (.F, .F90 and .F95) cpp should emit line numbers.)\n\nPR fortran/13702\n(Port from g95)\n* gfortran.h (gfc_linebuf): New typedef.\n(linebuf): Remove.\n(gfc_file): Revamped, use new gfc_linebuf.\n(locus): Revamped, use new types.\n(gfc_current_file): Remove.\n(gfc_current_form, gfc_source_file): New global variables.\n* match.c (gfc_match_space, gfc_match_strings): Use\ngfc_current_form to find source form.\n* module.c (gfc_dump_module): Use gfc_source_file when printing\nmodule header.\n* error.c (show_locus, show_loci) Use new data structures to print\nlocus.\n* scanner.c (first_file, first_duplicated_file, gfc_current_file):\nRemove.\n(file_head, current_file, gfc_current_form, line_head, line_tail,\ngfc_current_locus1, gfc_source_file): New global variables.\n(gfc_scanner_init1): Set new global variables.\n(gfc_scanner_done1): Free new data structures.\n(gfc_current_locus): Return pointer to gfc_current_locus1.\n(gfc_set_locus): Set gfc_current_locus1.\n(gfc_at_eof): Set new variables.\n(gfc_at_bol, gfc_at_eol, gfc_advance_line, gfc_next_char): Adapt\nto new locus structure.\n(gfc_check_include): Remove.\n(skip_free_comments, skip_fixed_comments): Use gfc_current_locus1.\n(gfc_skip_comments): Use gfc_current_form, find locus with\ngfc_current_locus1.\n(gfc_next_char): Use gfc_current_form.\n(gfc_peek_char, gfc_gobble_whitespace): Use gfc_current_locus1.\n(load_line): Use gfc_current_form. Recognize ^Z as EOF. Fix\ncomment formatting.\n(get_file): New function.\n(preprocessor_line, include_line): New functions.\n(load_file): Move down, rewrite to match new data structures.\n(gfc_new_file): Rewrite to match new data structures.\n* parse.c (next_statement): Remove code which is now useless. Use\ngfc_source_form and gfc_source_file where appropriate.\n* trans-decl.c (gfc_get_label_decl): adapt to new data structures\nwhen determining locus of frontend code.\n* trans-io.c (set_error_locus): Same.\n* trans.c (gfc_get_backend_locus, gfc_set_backend_locus): Likewise.\n* lang-specs.h (@f77-cpp-input, @f95-cpp-input): Remove '-P' from\npreprocessor flags.\n(all): Add missing initializers.\n\nFrom-SVN: r81888", "tree": {"sha": "78eca888e2f4be9f6b0c5e4db6a69c5180d050c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78eca888e2f4be9f6b0c5e4db6a69c5180d050c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39ae2b013af4a6a8fbdd8bc2ee72cdda174e0d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39ae2b013af4a6a8fbdd8bc2ee72cdda174e0d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39ae2b013af4a6a8fbdd8bc2ee72cdda174e0d95"}], "stats": {"total": 798, "additions": 451, "deletions": 347}, "files": [{"sha": "a1542b5db3ef256b0ec1420cab0992950bfdd4d7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -1,3 +1,53 @@\n+2004-05-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/13702 \n+\t(Port from g95)\n+\t* gfortran.h (gfc_linebuf): New typedef.\n+\t(linebuf): Remove.\n+\t(gfc_file): Revamped, use new gfc_linebuf.\n+\t(locus): Revamped, use new types.\n+\t(gfc_current_file): Remove.\n+\t(gfc_current_form, gfc_source_file): New global variables.\n+\t* match.c (gfc_match_space, gfc_match_strings): Use\n+\tgfc_current_form to find source form.\n+\t* module.c (gfc_dump_module): Use gfc_source_file when printing\n+\tmodule header.\n+\t* error.c (show_locus, show_loci) Use new data structures to print\n+\tlocus.\n+\t* scanner.c (first_file, first_duplicated_file, gfc_current_file):\n+\tRemove.\n+\t(file_head, current_file, gfc_current_form, line_head, line_tail,\n+\tgfc_current_locus1, gfc_source_file): New global variables.\n+\t(gfc_scanner_init1): Set new global variables.\n+\t(gfc_scanner_done1): Free new data structures.\n+\t(gfc_current_locus): Return pointer to gfc_current_locus1.\n+\t(gfc_set_locus): Set gfc_current_locus1.\n+\t(gfc_at_eof): Set new variables.\n+\t(gfc_at_bol, gfc_at_eol, gfc_advance_line, gfc_next_char): Adapt\n+\tto new locus structure.\n+\t(gfc_check_include): Remove.\n+\t(skip_free_comments, skip_fixed_comments): Use gfc_current_locus1.\n+\t(gfc_skip_comments): Use gfc_current_form, find locus with\n+\tgfc_current_locus1.\n+\t(gfc_next_char): Use gfc_current_form.\n+\t(gfc_peek_char, gfc_gobble_whitespace): Use gfc_current_locus1.\n+\t(load_line): Use gfc_current_form. Recognize ^Z as EOF. Fix\n+\tcomment formatting.\n+\t(get_file): New function.\n+\t(preprocessor_line, include_line): New functions.\n+\t(load_file): Move down, rewrite to match new data structures.\n+\t(gfc_new_file): Rewrite to match new data structures.\n+\t* parse.c (next_statement): Remove code which is now useless. Use\n+\tgfc_source_form and gfc_source_file where appropriate.\n+\t* trans-decl.c (gfc_get_label_decl): adapt to new data structures\n+\twhen determining locus of frontend code.\n+\t* trans-io.c (set_error_locus): Same.\n+\t* trans.c (gfc_get_backend_locus, gfc_set_backend_locus): Likewise.\n+\t* lang-specs.h (@f77-cpp-input, @f95-cpp-input): Remove '-P' from\n+\tpreprocessor flags.\n+\t(all): Add missing initializers.\n+\n+\n 2004-05-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* Make-lang.in (trans-common.o): Remove redundant dependency."}, {"sha": "b7b0fdb1bf6d9a37c53bc065de12c12a34767b9b", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -118,29 +118,35 @@ error_string (const char *p)\n static void error_printf (const char *, ...) ATTRIBUTE_PRINTF_1;\n \n static void\n-show_locus (int offset, locus * l)\n+show_locus (int offset, locus * loc)\n {\n+  gfc_linebuf *lb;\n   gfc_file *f;\n   char c, *p;\n   int i, m;\n \n   /* TODO: Either limit the total length and number of included files\n      displayed or add buffering of arbitrary number of characters in\n      error messages.  */\n-  f = l->file;\n-  error_printf (\"In file %s:%d\\n\", f->filename, l->lp->start_line + l->line);\n \n-  f = f->included_by;\n-  while (f != NULL)\n+  lb = loc->lb;\n+  f = lb->file;\n+  error_printf (\"In file %s:%d\\n\", f->filename, lb->linenum);\n+\n+  for (;;)\n     {\n-      error_printf (\"    Included at %s:%d\\n\", f->filename,\n-\t\t    f->loc.lp->start_line + f->loc.line);\n+      i = f->inclusion_line;\n+\n       f = f->included_by;\n+      if (f == NULL) break;\n+\n+      error_printf (\"    Included at %s:%d\\n\", f->filename, i);\n     }\n \n   /* Show the line itself, taking care not to print more than what can\n      show up on the terminal.  Tabs are converted to spaces.  */\n-  p = l->lp->line[l->line] + offset;\n+\n+  p = lb->line + offset;\n   i = strlen (p);\n   if (i > terminal_width)\n     i = terminal_width - 1;\n@@ -190,20 +196,20 @@ show_loci (locus * l1, locus * l2)\n       return;\n     }\n \n-  c1 = l1->nextc - l1->lp->line[l1->line];\n+  c1 = l1->nextc - l1->lb->line;\n   c2 = 0;\n   if (l2 == NULL)\n     goto separate;\n \n-  c2 = l2->nextc - l2->lp->line[l2->line];\n+  c2 = l2->nextc - l2->lb->line;\n \n   if (c1 < c2)\n     m = c2 - c1;\n   else\n     m = c1 - c2;\n \n \n-  if (l1->lp != l2->lp || l1->line != l2->line || m > terminal_width - 10)\n+  if (l1->lb != l2->lb || m > terminal_width - 10)\n     goto separate;\n \n   offset = 0;"}, {"sha": "498e63b6c9bb95b86b37f7bfe0461da3aec42ced", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -413,35 +413,40 @@ typedef struct\n symbol_attribute;\n \n \n-typedef struct\n-{\n-  char *nextc;\n-  int line;\t\t\t/* line within the lp structure */\n-  struct linebuf *lp;\n-  struct gfc_file *file;\n-}\n-locus;\n+/* The following three structures are used to identify a location in\n+   the sources. \n+   \n+   gfc_file is used to maintain a tree of the source files and how\n+   they include each other\n \n-/* The linebuf structure deserves some explanation.  This is the\n-   primary structure for holding lines.  A source file is stored in a\n-   singly linked list of these structures.  Each structure holds an\n-   integer number of lines.  The line[] member is actually an array of\n-   pointers that point to the NULL-terminated lines.  This list grows\n-   upwards, and the actual lines are stored at the top of the\n-   structure and grow downward.  Each structure is packed with as many\n-   lines as it can hold, then another linebuf is allocated.  */\n+   gfc_linebuf holds a single line of source code and information\n+   which file it resides in\n \n-/* Chosen so that sizeof(linebuf) = 4096 on most machines */\n-#define LINEBUF_SIZE 4080\n+   locus point to the sourceline and the character in the source\n+   line.  \n+*/\n \n-typedef struct linebuf\n+typedef struct gfc_file \n {\n-  int start_line, lines;\n-  struct linebuf *next;\n-  char *line[1];\n-  char buf[LINEBUF_SIZE];\n-}\n-linebuf;\n+  struct gfc_file *included_by, *next, *up;\n+  int inclusion_line, line;\n+  char *filename;\n+} gfc_file;\n+\n+typedef struct gfc_linebuf \n+{\n+  int linenum;\n+  struct gfc_file *file;\n+  struct gfc_linebuf *next;\n+\n+  char line[];\n+} gfc_linebuf;\n+  \n+typedef struct \n+{\n+  char *nextc;\n+  gfc_linebuf *lb;\n+} locus;\n \n \n #include <limits.h>\n@@ -451,17 +456,6 @@ linebuf;\n #endif\n \n \n-typedef struct gfc_file\n-{\n-  char filename[PATH_MAX + 1];\n-  gfc_source_form form;\n-  struct gfc_file *included_by, *next;\n-  locus loc;\n-  struct linebuf *start;\n-}\n-gfc_file;\n-\n-\n extern int gfc_suppress_error;\n \n \n@@ -1308,7 +1302,9 @@ void gfc_error_recovery (void);\n void gfc_gobble_whitespace (void);\n try gfc_new_file (const char *, gfc_source_form);\n \n-extern gfc_file *gfc_current_file;\n+extern gfc_source_form gfc_current_form;\n+extern char *gfc_source_file;\n+/* extern locus gfc_current_locus; */\n \n /* misc.c */\n void *gfc_getmem (size_t) ATTRIBUTE_MALLOC;"}, {"sha": "b18483f5c2338eed5b5773c6ec71b5be0c1aeb7a", "filename": "gcc/fortran/lang-specs.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang-specs.h?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -7,29 +7,29 @@ This file is licensed under the GPL.  */\n /* This is the contribution to the `default_compilers' array in gcc.c\n    for the f95 language.  */\n \n-{\".F\",   \"@f77-cpp-input\", 0},\n-{\".fpp\", \"@f77-cpp-input\", 0},\n-{\".FPP\", \"@f77-cpp-input\", 0},\n+{\".F\",   \"@f77-cpp-input\", 0, 0, 0},\n+{\".fpp\", \"@f77-cpp-input\", 0, 0, 0},\n+{\".FPP\", \"@f77-cpp-input\", 0, 0, 0},\n {\"@f77-cpp-input\",\n-  \"cc1 -P -E -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n+  \"cc1 -E -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n       %{E|M|MM:%(cpp_debug_options)}\\\n       %{!M:%{!MM:%{!E: -o %|.f |\\n\\\n     f951 %|.f %{!ffree-form:-ffixed-form} %(cc1_options) %{J*} %{I*}\\\n-      %{!fsyntax-only:%(invoke_as)}}}}\", 0},\n-{\".F90\", \"@f95-cpp-input\", 0},\n-{\".F95\", \"@f95-cpp-input\", 0},\n+      %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n+{\".F90\", \"@f95-cpp-input\", 0, 0, 0},\n+{\".F95\", \"@f95-cpp-input\", 0, 0, 0},\n {\"@f95-cpp-input\",\n-  \"cc1 -P -E -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n+  \"cc1 -E -traditional-cpp -D_LANGUAGE_FORTRAN %(cpp_options) \\\n       %{E|M|MM:%(cpp_debug_options)}\\\n       %{!M:%{!MM:%{!E: -o %|.f95 |\\n\\\n     f951 %|.f95 %(cc1_options) %{J*} %{I*}\\\n-      %{!fsyntax-only:%(invoke_as)}}}}\", 0},\n-{\".f90\", \"@f95\", 0},\n-{\".f95\", \"@f95\", 0},\n+      %{!fsyntax-only:%(invoke_as)}}}}\", 0, 0, 0},\n+{\".f90\", \"@f95\", 0, 0, 0},\n+{\".f95\", \"@f95\", 0, 0, 0},\n {\"@f95\", \"%{!E:f951 %i %(cc1_options) %{J*} %{I*}\\\n-         %{!fsyntax-only:%(invoke_as)}}\", 0},\n-{\".f\",   \"@f77\", 0},\n-{\".for\", \"@f77\", 0},\n-{\".FOR\", \"@f77\", 0},\n+         %{!fsyntax-only:%(invoke_as)}}\", 0, 0, 0},\n+{\".f\",   \"@f77\", 0, 0, 0},\n+{\".for\", \"@f77\", 0, 0, 0},\n+{\".FOR\", \"@f77\", 0, 0, 0},\n {\"@f77\", \"%{!E:f951 %i %{!ffree-form:-ffixed-form} %(cc1_options) %{J*} %{I*}\\\n-         %{!fsyntax-only:%(invoke_as)}}\", 0},\n+         %{!fsyntax-only:%(invoke_as)}}\", 0, 0, 0},"}, {"sha": "dc8dc3e73335fcec353d0b92f6cd040c5ad8b79a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -77,7 +77,7 @@ gfc_match_space (void)\n   locus old_loc;\n   int c;\n \n-  if (gfc_current_file->form == FORM_FIXED)\n+  if (gfc_current_form == FORM_FIXED)\n     return MATCH_YES;\n \n   old_loc = *gfc_current_locus ();\n@@ -337,7 +337,7 @@ gfc_match_strings (mstring * a)\n \t  if (*p->mp == ' ')\n \t    {\n \t      /* Space matches 1+ whitespace(s).  */\n-\t      if ((gfc_current_file->form == FORM_FREE)\n+\t      if ((gfc_current_form == FORM_FREE)\n \t\t  && gfc_is_whitespace (c))\n \t\tcontinue;\n "}, {"sha": "1143705a1d9b7d3434aa85a9d9883b8a5fa9d8de", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -3338,7 +3338,6 @@ void\n gfc_dump_module (const char *name, int dump_flag)\n {\n   char filename[PATH_MAX], *p;\n-  gfc_file *g;\n   time_t now;\n \n   filename[0] = '\\0';\n@@ -3359,17 +3358,13 @@ gfc_dump_module (const char *name, int dump_flag)\n     gfc_fatal_error (\"Can't open module file '%s' for writing: %s\",\n \t\t     filename, strerror (errno));\n \n-  /* Find the top level filename.  */\n-  g = gfc_current_file;\n-  while (g->next)\n-    g = g->next;\n-\n   now = time (NULL);\n   p = ctime (&now);\n \n   *strchr (p, '\\n') = '\\0';\n \n-  fprintf (module_fp, \"GFORTRAN module created from %s on %s\\n\", g->filename, p);\n+  fprintf (module_fp, \"GFORTRAN module created from %s on %s\\n\", \n+\t   gfc_source_file, p);\n   fputs (\"If you edit this, you'll get what you deserve.\\n\\n\", module_fp);\n \n   iomode = IO_OUTPUT;"}, {"sha": "dea613bce77d59da732449793492d0561ed80d7e", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -483,24 +483,15 @@ next_statement (void)\n \n       gfc_skip_comments ();\n \n-      if (gfc_at_bol () && gfc_check_include ())\n-\tcontinue;\n-\n-      if (gfc_at_eof () && gfc_current_file->included_by != NULL)\n-\t{\n-\t  gfc_current_file = gfc_current_file->included_by;\n-\t  gfc_advance_line ();\n-\t  continue;\n-\t}\n-\n       if (gfc_at_end ())\n \t{\n \t  st = ST_NONE;\n \t  break;\n \t}\n \n       st =\n-\t(gfc_current_file->form == FORM_FIXED) ? next_fixed () : next_free ();\n+\t(gfc_current_form == FORM_FIXED) ? next_fixed () : next_free ();\n+\n       if (st != ST_NONE)\n \tbreak;\n     }\n@@ -1268,7 +1259,7 @@ unexpected_eof (void)\n {\n   gfc_state_data *p;\n \n-  gfc_error (\"Unexpected end of file in '%s'\", gfc_current_file->filename);\n+  gfc_error (\"Unexpected end of file in '%s'\", gfc_source_file);\n \n   /* Memory cleanup.  Move to \"second to last\".  */\n   for (p = gfc_state_stack; p && p->previous && p->previous->previous;"}, {"sha": "a16c2749ce8daae35408e3ead0b7f102ccec1c7a", "filename": "gcc/fortran/scanner.c", "status": "modified", "additions": 318, "deletions": 253, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -60,21 +60,26 @@ gfc_directorylist;\n /* List of include file search directories.  */\n static gfc_directorylist *include_dirs;\n \n-static gfc_file *first_file, *first_duplicated_file;\n-static int continue_flag, end_flag;\n+static gfc_file *file_head, *current_file;\n \n-gfc_file *gfc_current_file;\n+static int continue_flag, end_flag;\n \n+gfc_source_form gfc_current_form;\n+static gfc_linebuf *line_head, *line_tail;\n+       \n+locus gfc_current_locus1;\n+char *gfc_source_file;\n+      \n \n /* Main scanner initialization.  */\n \n void\n gfc_scanner_init_1 (void)\n {\n+  file_head = NULL;\n+  line_head = NULL;\n+  line_tail = NULL;\n \n-  gfc_current_file = NULL;\n-  first_file = NULL;\n-  first_duplicated_file = NULL;\n   end_flag = 0;\n }\n \n@@ -84,36 +89,24 @@ gfc_scanner_init_1 (void)\n void\n gfc_scanner_done_1 (void)\n {\n+  gfc_linebuf *lb;\n+  gfc_file *f;\n \n-  linebuf *lp, *lp2;\n-  gfc_file *fp, *fp2;\n-\n-  for (fp = first_file; fp; fp = fp2)\n+  while(line_head != NULL) \n     {\n-\n-      if (fp->start != NULL)\n-\t{\n-\t  /* Free linebuf blocks */\n-\t  for (fp2 = fp->next; fp2; fp2 = fp2->next)\n-\t    if (fp->start == fp2->start)\n-\t      fp2->start = NULL;\n-\n-\t  for (lp = fp->start; lp; lp = lp2)\n-\t    {\n-\t      lp2 = lp->next;\n-\t      gfc_free (lp);\n-\t    }\n-\t}\n-\n-      fp2 = fp->next;\n-      gfc_free (fp);\n+      lb = line_head->next;\n+      gfc_free(line_head);\n+      line_head = lb;\n     }\n-\n-  for (fp = first_duplicated_file; fp; fp = fp2)\n+     \n+  while(file_head != NULL) \n     {\n-      fp2 = fp->next;\n-      gfc_free (fp);\n+      f = file_head->next;\n+      gfc_free(file_head->filename);\n+      gfc_free(file_head);\n+      file_head = f;    \n     }\n+\n }\n \n \n@@ -168,7 +161,6 @@ gfc_release_include_path (void)\n     }\n }\n \n-\n /* Opens file for reading, searching through the include directories\n    given if necessary.  */\n \n@@ -206,19 +198,18 @@ locus *\n gfc_current_locus (void)\n {\n \n-  if (gfc_current_file == NULL)\n-    return NULL;\n-  return &gfc_current_file->loc;\n+  return &gfc_current_locus1;\n }\n \n \n+\n /* Let a caller move the current read pointer (backwards).  */\n \n void\n gfc_set_locus (locus * lp)\n {\n \n-  gfc_current_file->loc = *lp;\n+  gfc_current_locus1 = *lp;\n }\n \n \n@@ -241,10 +232,10 @@ gfc_at_eof (void)\n   if (gfc_at_end ())\n     return 1;\n \n-  if (gfc_current_file->start->lines == 0)\n+  if (line_head == NULL)\n     return 1;\t\t\t/* Null file */\n \n-  if (gfc_current_file->loc.lp == NULL)\n+  if (gfc_current_locus1.lb == NULL)\n     return 1;\n \n   return 0;\n@@ -256,14 +247,10 @@ gfc_at_eof (void)\n int\n gfc_at_bol (void)\n {\n-  int i;\n-\n   if (gfc_at_eof ())\n     return 1;\n \n-  i = gfc_current_file->loc.line;\n-\n-  return gfc_current_file->loc.nextc == gfc_current_file->loc.lp->line[i];\n+  return (gfc_current_locus1.nextc == gfc_current_locus1.lb->line);\n }\n \n \n@@ -276,7 +263,7 @@ gfc_at_eol (void)\n   if (gfc_at_eof ())\n     return 1;\n \n-  return *gfc_current_file->loc.nextc == '\\0';\n+  return (*gfc_current_locus1.nextc == '\\0');\n }\n \n \n@@ -285,27 +272,24 @@ gfc_at_eol (void)\n void\n gfc_advance_line (void)\n {\n-  locus *locp;\n-  linebuf *lp;\n-\n   if (gfc_at_end ())\n     return;\n \n-  locp = &gfc_current_file->loc;\n-  lp = locp->lp;\n-  if (lp == NULL)\n-    return;\n-\n-  if (++locp->line >= lp->lines)\n+  if (gfc_current_locus1.lb == NULL) \n     {\n-      locp->lp = lp = lp->next;\n-      if (lp == NULL)\n-\treturn;\t  /* End of this file */\n+      end_flag = 1;\n+      return;\n+    } \n \n-      locp->line = 0;\n-    }\n+  gfc_current_locus1.lb = gfc_current_locus1.lb->next;\n \n-  locp->nextc = lp->line[locp->line];\n+  if (gfc_current_locus1.lb != NULL)         \n+    gfc_current_locus1.nextc = gfc_current_locus1.lb->line;\n+  else \n+    {\n+      gfc_current_locus1.nextc = NULL;\n+      end_flag = 1;\n+    }       \n }\n \n \n@@ -321,104 +305,21 @@ gfc_advance_line (void)\n static int\n next_char (void)\n {\n-  locus *locp;\n   int c;\n-\n-  /* End the current include level, but not if we're in the middle\n-     of processing a continuation. */\n-  if (gfc_at_eof ())\n-    {\n-      if (continue_flag != 0 || gfc_at_end ())\n-\treturn '\\n';\n-\n-      if (gfc_current_file->included_by == NULL)\n-\tend_flag = 1;\n-\n-      return '\\n';\n-    }\n-\n-  locp = &gfc_current_file->loc;\n-  if (locp->nextc == NULL)\n+  \n+  if (gfc_current_locus1.nextc == NULL)\n     return '\\n';\n \n-  c = *locp->nextc++;\n+  c = *gfc_current_locus1.nextc++;\n   if (c == '\\0')\n     {\n-      locp->nextc--;\t/* Stay stuck on this line */\n+      gfc_current_locus1.nextc--; /* Remain on this line.  */\n       c = '\\n';\n     }\n \n   return c;\n }\n \n-\n-/* Checks the current line buffer to see if it is an include line.  If\n-   so, we load the new file and prepare to read from it.  Include\n-   lines happen at a lower level than regular parsing because the\n-   string-matching subroutine is far simpler than the normal one.\n-\n-   We never return a syntax error because a statement like \"include = 5\"\n-   is perfectly legal.  We return zero if no include was processed or\n-   nonzero if we matched an include.  */\n-\n-int\n-gfc_check_include (void)\n-{\n-  char c, quote, path[PATH_MAX + 1];\n-  const char *include;\n-  locus start;\n-  int i;\n-\n-  include = \"include\";\n-\n-  start = *gfc_current_locus ();\n-  gfc_gobble_whitespace ();\n-\n-  /* Match the 'include' */\n-  while (*include != '\\0')\n-    if (*include++ != gfc_next_char ())\n-      goto no_include;\n-\n-  gfc_gobble_whitespace ();\n-\n-  quote = next_char ();\n-  if (quote != '\"' && quote != '\\'')\n-    goto no_include;\n-\n-  /* Copy the filename */\n-  for (i = 0;;)\n-    {\n-      c = next_char ();\n-      if (c == '\\n')\n-\tgoto no_include;\t/* No close quote */\n-      if (c == quote)\n-\tbreak;\n-\n-  /* This shouldn't happen-- PATH_MAX should be way longer than the\n-     max line length.  */\n-\n-      if (i >= PATH_MAX)\n-\tgfc_internal_error (\"Pathname of include file is too long at %C\");\n-\n-      path[i++] = c;\n-    }\n-\n-  path[i] = '\\0';\n-  if (i == 0)\n-    goto no_include;\t/* No filename! */\n-\n-  /* At this point, we've got a filename to be included.  The rest\n-     of the include line is ignored */\n-\n-  gfc_new_file (path, gfc_current_file->form);\n-  return 1;\n-\n-no_include:\n-  gfc_set_locus (&start);\n-  return 0;\n-}\n-\n-\n /* Skip a comment.  When we come here the parse pointer is positioned\n    immediately after the comment character.  If we ever implement\n    compiler directives withing comments, here is where we parse the\n@@ -450,7 +351,7 @@ skip_free_comments (void)\n \n   for (;;)\n     {\n-      start = *gfc_current_locus ();\n+      start = gfc_current_locus1;\n       if (gfc_at_eof ())\n \tbreak;\n \n@@ -492,7 +393,7 @@ skip_fixed_comments (void)\n \n   for (;;)\n     {\n-      start = *gfc_current_locus ();\n+      start = gfc_current_locus1;\n       if (gfc_at_eof ())\n \tbreak;\n \n@@ -543,7 +444,7 @@ void\n gfc_skip_comments (void)\n {\n \n-  if (!gfc_at_bol () || gfc_current_file->form == FORM_FREE)\n+  if (!gfc_at_bol () || gfc_current_form == FORM_FREE)\n     skip_free_comments ();\n   else\n     skip_fixed_comments ();\n@@ -570,7 +471,7 @@ gfc_next_char_literal (int in_string)\n   if (gfc_at_end ())\n     return c;\n \n-  if (gfc_current_file->form == FORM_FREE)\n+  if (gfc_current_form == FORM_FREE)\n     {\n \n       if (!in_string && c == '!')\n@@ -590,7 +491,7 @@ gfc_next_char_literal (int in_string)\n \n       /* If the next nonblank character is a ! or \\n, we've got a\n          continuation line. */\n-      old_loc = gfc_current_file->loc;\n+      old_loc = gfc_current_locus1;\n \n       c = next_char ();\n       while (gfc_is_whitespace (c))\n@@ -701,7 +602,7 @@ gfc_next_char (void)\n     {\n       c = gfc_next_char_literal (0);\n     }\n-  while (gfc_current_file->form == FORM_FIXED && gfc_is_whitespace (c));\n+  while (gfc_current_form == FORM_FIXED && gfc_is_whitespace (c));\n \n   return TOLOWER (c);\n }\n@@ -713,7 +614,7 @@ gfc_peek_char (void)\n   locus old_loc;\n   int c;\n \n-  old_loc = *gfc_current_locus ();\n+  old_loc = gfc_current_locus1;\n   c = gfc_next_char ();\n   gfc_set_locus (&old_loc);\n \n@@ -783,7 +684,7 @@ gfc_gobble_whitespace (void)\n \n   do\n     {\n-      old_loc = *gfc_current_locus ();\n+      old_loc = gfc_current_locus1;\n       c = gfc_next_char_literal (0);\n     }\n   while (gfc_is_whitespace (c));\n@@ -798,12 +699,13 @@ gfc_gobble_whitespace (void)\n    character in the source region.  */\n \n static void\n-load_line (FILE * input, gfc_source_form form, char *buffer,\n-\t   char *filename, int linenum)\n+load_line (FILE * input, char *buffer, char *filename, int linenum)\n {\n   int c, maxlen, i, trunc_flag;\n \n-  maxlen = (form == FORM_FREE) ? 132 : gfc_option.fixed_line_length;\n+  maxlen = (gfc_current_form == FORM_FREE) \n+    ? 132 \n+    : gfc_option.fixed_line_length;\n \n   i = 0;\n \n@@ -817,12 +719,19 @@ load_line (FILE * input, gfc_source_form form, char *buffer,\n \tbreak;\n \n       if (c == '\\r')\n-\tcontinue;\t\t/* Gobble characters */\n+\tcontinue;\t\t/* Gobble characters.  */\n       if (c == '\\0')\n \tcontinue;\n \n-      if (form == FORM_FIXED && c == '\\t' && i <= 6)\n-\t{\t\t\t/* Tab expandsion */\n+      if (c == '\\032')\n+\t{\n+\t  /* Ctrl-Z ends the file.  */\n+\t  while (fgetc (input) != EOF);\n+\t  break;\n+\t}\n+\n+      if (gfc_current_form == FORM_FIXED && c == '\\t' && i <= 6)\n+\t{\t\t\t/* Tab expandsion.  */\n \t  while (i <= 6)\n \t    {\n \t      *buffer++ = ' ';\n@@ -836,7 +745,7 @@ load_line (FILE * input, gfc_source_form form, char *buffer,\n       i++;\n \n       if (i >= maxlen)\n-\t{\t\t\t/* Truncate the rest of the line */\n+\t{\t\t\t/* Truncate the rest of the line.  */\n \t  trunc_flag = 1;\n \n \t  for (;;)\n@@ -863,51 +772,247 @@ load_line (FILE * input, gfc_source_form form, char *buffer,\n }\n \n \n-/* Load a file into memory by calling load_line until the file ends.  */\n+/* Get a gfc_file structure, initialize it and add it to\n+   the file stack.  */\n+\n+static gfc_file *\n+get_file (char *name)\n+{\n+  gfc_file *f;\n+\n+  f = gfc_getmem (sizeof (gfc_file));\n+\n+  f->filename = gfc_getmem (strlen (name) + 1);\n+  strcpy (f->filename, name);\n+\n+  f->next = file_head;\n+  file_head = f;\n+\n+  f->included_by = current_file;\n+  if (current_file != NULL)\n+    f->inclusion_line = current_file->line;\n+\n+  return f;\n+}\n+\n+/* Deal with a line from the C preprocessor. The\n+   initial octothorp has already been seen.  */\n \n static void\n-load_file (FILE * input, gfc_file * fp)\n+preprocessor_line (char *c)\n {\n-  char *linep, line[GFC_MAX_LINE + 1];\n-  int len, linenum;\n-  linebuf *lp;\n+  bool flag[5];\n+  int i, line;\n+  char *filename;\n+  gfc_file *f;\n \n-  fp->start = lp = gfc_getmem (sizeof (linebuf));\n+  c++;\n+  while (*c == ' ' || *c == '\\t')\n+    c++;\n \n-  linenum = 1;\n-  lp->lines = 0;\n-  lp->start_line = 1;\n-  lp->next = NULL;\n+  if (*c < '0' || *c > '9')\n+    {\n+      gfc_warning_now (\"%s:%d Unknown preprocessor directive\", \n+\t\t       current_file->filename, current_file->line);\n+      current_file->line++;\n+      return;\n+    }\n \n-  linep = (char *) (lp + 1);\n+  line = atoi (c);\n+\n+  c = strchr (c, ' ') + 2; /* Skip space and quote.  */\n+  filename = c;\n+\n+  c = strchr (c, '\"'); /* Make filename end at quote.  */\n+  *c++ = '\\0';\n+\n+  /* Get flags.  */\n+  \n+  flag[1] = flag[2] = flag[3] = flag[4] = flag[5] = false;\n \n-  /* Load the file.  */\n   for (;;)\n     {\n-      load_line (input, fp->form, line, fp->filename, linenum);\n-      linenum++;\n+      c = strchr (c, ' ');\n+      if (c == NULL)\n+\tbreak;\n \n-      len = strlen (line);\n+      c++;\n+      i = atoi (c);\n \n+      if (1 <= i && i <= 4)\n+\tflag[i] = true;\n+    }\n+     \n+  /* Interpret flags.  */\n+  \n+  if (flag[1] || flag[3]) /* Starting new file.  */\n+    {\n+      f = get_file (filename);\n+      f->up = current_file;\n+      current_file = f;\n+    }\n+  \n+  if (flag[2]) /* Ending current file.  */\n+    {\n+      current_file = current_file->up;\n+    }\n+  \n+  current_file->line = line;\n+  \n+  /* The name of the file can be a temporary file produced by\n+     cpp. Replace the name if it is different.  */\n+  \n+  if (strcmp (current_file->filename, filename) != 0)\n+    {\n+      gfc_free (current_file->filename);\n+      current_file->filename = gfc_getmem (strlen (filename) + 1);\n+      strcpy (current_file->filename, filename);\n+    }\n+}\n+\n+\n+static try load_file (char *, bool);\n+\n+/* include_line()-- Checks a line buffer to see if it is an include\n+   line.  If so, we call load_file() recursively to load the included\n+   file.  We never return a syntax error because a statement like\n+   \"include = 5\" is perfectly legal.  We return false if no include was\n+   processed or true if we matched an include.  */\n+\n+static bool\n+include_line (char *line)\n+{\n+  char quote, *c, *begin, *stop;\n+  \n+  c = line;\n+  while (*c == ' ' || *c == '\\t')\n+    c++;\n+\n+  if (strncasecmp (c, \"include\", 7))\n+      return false;\n+\n+  c += 7;\n+  while (*c == ' ' || *c == '\\t')\n+    c++;\n+\n+  /* Find filename between quotes.  */\n+  \n+  quote = *c++;\n+  if (quote != '\"' && quote != '\\'')\n+    return false;\n+\n+  begin = c;\n+\n+  while (*c != quote && *c != '\\0')\n+    c++;\n+\n+  if (*c == '\\0')\n+    return false;\n+\n+  stop = c++;\n+  \n+  while (*c == ' ' || *c == '\\t')\n+    c++;\n+\n+  if (*c != '\\0' && *c != '!')\n+    return false;\n+\n+  /* We have an include line at this point. */\n+\n+  *stop = '\\0'; /* It's ok to trash the buffer, as this line won't be\n+\t\t   read by anything else.  */\n+\n+  load_file (begin, false);\n+  return true;\n+}\n+\n+/* Load a file into memory by calling load_line until the file ends.  */\n+\n+static try\n+load_file (char *filename, bool initial)\n+{\n+  char line[GFC_MAX_LINE+1];\n+  gfc_linebuf *b;\n+  gfc_file *f;\n+  FILE *input;\n+  int len;\n+\n+  for (f = current_file; f; f = f->up)\n+    if (strcmp (filename, f->filename) == 0)\n+      {\n+\tgfc_error_now (\"File '%s' is being included recursively\", filename);\n+\treturn FAILURE;\n+      }\n+\n+  if (initial)\n+    {\n+      input = gfc_open_file (filename);\n+      if (input == NULL)\n+\t{\n+\t  gfc_error_now (\"Can't open file '%s'\", filename);\n+\t  return FAILURE;\n+\t}\n+    }\n+  else\n+    {\n+      input = gfc_open_included_file (filename);\n+      if (input == NULL)\n+\t{\n+\t  gfc_error_now (\"Can't open included file '%s'\", filename);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n+  /* Load the file.  */\n+\n+  f = get_file (filename);\n+  f->up = current_file;\n+  current_file = f;\n+  current_file->line = 1;\n+\n+  for (;;) \n+    {\n+      load_line (input, line, filename, current_file->line);\n+\n+      len = strlen (line);\n       if (feof (input) && len == 0)\n \tbreak;\n \n-      /* See if we need another linebuf.  */\n-      if (((char *) &lp->line[lp->lines + 2]) > linep - len - 1)\n-\t{\n-\t  lp->next = gfc_getmem (sizeof (linebuf));\n+      /* There are three things this line can be: a line of Fortran\n+\t source, an include line or a C preprocessor directive.  */\n \n-\t  lp->next->start_line = lp->start_line + lp->lines;\n-\t  lp = lp->next;\n-\t  lp->lines = 0;\n+      if (line[0] == '#')\n+\t{\n+\t  preprocessor_line (line);\n+\t  continue;\n+\t}\n \n-\t  linep = (char *) (lp + 1);\n+      if (include_line (line))\n+\t{\n+\t  current_file->line++;\n+\t  continue;\n \t}\n \n-      linep = linep - len - 1;\n-      lp->line[lp->lines++] = linep;\n-      strcpy (linep, line);\n+      /* Add line.  */\n+\n+      b = gfc_getmem (sizeof (gfc_linebuf) + len + 1);\n+\n+      b->linenum = current_file->line++;\n+      b->file = current_file;\n+      strcpy (b->line, line);\n+\n+      if (line_head == NULL)\n+\tline_head = b;\n+      else\n+\tline_tail->next = b;\n+\n+      line_tail = b;\n     }\n+\n+  fclose (input);\n+\n+  current_file = current_file->up;\n+  return SUCCESS;\n }\n \n \n@@ -982,92 +1087,52 @@ form_from_filename (const char *filename)\n }\n \n \n-/* Open a new file and start scanning from that file.  Every new file\n-   gets a gfc_file node, even if it is a duplicate file.  Returns SUCCESS\n-   if everything went OK, FAILURE otherwise.  */\n+/* Open a new file and start scanning from that file. Returns SUCCESS\n+   if everything went OK, FAILURE otherwise.  If form == FORM_UKNOWN\n+   it tries to determine the source form from the filename, defaulting\n+   to free form.  */\n \n try\n gfc_new_file (const char *filename, gfc_source_form form)\n {\n-  gfc_file *fp, *fp2;\n-  FILE *input;\n-  int len;\n+  try result;\n \n-  len = strlen (filename);\n-  if (len > PATH_MAX)\n+  if (filename != NULL)\n     {\n-      gfc_error_now (\"Filename '%s' is too long- ignoring it\", filename);\n-      return FAILURE;\n+      gfc_source_file = gfc_getmem (strlen (filename) + 1);\n+      strcpy (gfc_source_file, filename);\n     }\n-\n-  fp = gfc_getmem (sizeof (gfc_file));\n-\n-  /* Make sure this file isn't being included recursively.  */\n-  for (fp2 = gfc_current_file; fp2; fp2 = fp2->included_by)\n-    if (strcmp (filename, fp2->filename) == 0)\n-      {\n-\tgfc_error_now (\"Recursive inclusion of file '%s' at %C- ignoring it\",\n-\t\t       filename);\n-\tgfc_free (fp);\n-\treturn FAILURE;\n-      }\n-\n-  /* See if the file has already been included.  */\n-  for (fp2 = first_file; fp2; fp2 = fp2->next)\n-    if (strcmp (filename, fp2->filename) == 0)\n-      {\n-\t*fp = *fp2;\n-\tfp->next = first_duplicated_file;\n-\tfirst_duplicated_file = fp;\n-\tgoto init_fp;\n-      }\n-\n-  strcpy (fp->filename, filename);\n-\n-  if (gfc_current_file == NULL)\n-    input = gfc_open_file (filename);\n   else\n-    input = gfc_open_included_file (filename);\n-\n-  if (input == NULL)\n-    {\n-      if (gfc_current_file == NULL)\n-\tgfc_error_now (\"Can't open file '%s'\", filename);\n-      else\n-\tgfc_error_now (\"Can't open file '%s' included at %C\", filename);\n-\n-      gfc_free (fp);\n-      return FAILURE;\n-    }\n+    gfc_source_file = NULL;\n \n   /* Decide which form the file will be read in as.  */\n+\n   if (form != FORM_UNKNOWN)\n-    fp->form = form;\n+    gfc_current_form = form;\n   else\n     {\n-      fp->form = form_from_filename (filename);\n+      gfc_current_form = form_from_filename (filename);\n \n-      if (fp->form == FORM_UNKNOWN)\n+      if (gfc_current_form == FORM_UNKNOWN)\n \t{\n-\t  fp->form = FORM_FREE;\n-\t  gfc_warning_now (\"Reading file %s as free form\", filename);\n+\t  gfc_current_form = FORM_FREE;\n+\t  gfc_warning_now (\"Reading file '%s' as free form.\", \n+\t\t\t   (filename[0] == '\\0') ? \"<stdin>\" : filename); \n \t}\n     }\n \n-  fp->next = first_file;\n-  first_file = fp;\n+  result = load_file (gfc_source_file, true);\n \n-  load_file (input, fp);\n-  fclose (input);\n+  gfc_current_locus1.lb = line_head;\n+  gfc_current_locus1.nextc = (line_head == NULL) ? NULL : line_head->line;\n \n-init_fp:\n-  fp->included_by = gfc_current_file;\n-  gfc_current_file = fp;\n+#if 0 /* Debugging aid.  */\n+  for (; line_head; line_head = line_head->next)\n+    gfc_status (\"%s:%3d %s\\n\", line_head->file->filename, \n+\t\tline_head->linenum, line_head->line);\n \n-  fp->loc.line = 0;\n-  fp->loc.lp = fp->start;\n-  fp->loc.nextc = fp->start->line[0];\n-  fp->loc.file = fp;\n+  exit (0);\n+#endif\n \n-  return SUCCESS;\n+  return result;\n }"}, {"sha": "e4f564cbf6791e0f042a2a3b1ba5a319cbfbeb22", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -244,8 +244,8 @@ gfc_get_label_decl (gfc_st_label * lp)\n       /* Tell the debugger where the label came from.  */\n       if (lp->value <= MAX_LABEL_VALUE)\t/* An internal label */\n \t{\n-\t  DECL_SOURCE_LINE (label_decl) = lp->where.line;\n-\t  DECL_SOURCE_FILE (label_decl) = lp->where.file->filename;\n+\t  DECL_SOURCE_LINE (label_decl) = lp->where.lb->linenum;\n+\t  DECL_SOURCE_FILE (label_decl) = lp->where.lb->file->filename;\n \t}\n       else\n \tDECL_ARTIFICIAL (label_decl) = 1;"}, {"sha": "c0570fc8575b97abbb15abbfbfa9a495d2cf8a02", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -500,13 +500,13 @@ set_error_locus (stmtblock_t * block, locus * where)\n   tree tmp;\n   int line;\n \n-  f = where->file;\n+  f = where->lb->file;\n   tmp = gfc_build_string_const (strlen (f->filename) + 1, f->filename);\n \n   tmp = gfc_build_addr_expr (pchar_type_node, tmp);\n   gfc_add_modify_expr (block, locus_file, tmp);\n \n-  line = where->lp->start_line + where->line;\n+  line = where->lb->linenum;\n   gfc_add_modify_expr (block, locus_line, build_int_2 (line, 0));\n }\n "}, {"sha": "267391c1c38b4200135c42908b0370c409882df2", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=d4fa05b90d6647ceaf50b5f1b8504fc0e01fae9c", "patch": "@@ -414,8 +414,9 @@ gfc_add_block_to_block (stmtblock_t * block, stmtblock_t * append)\n void\n gfc_get_backend_locus (locus * loc)\n {\n-  loc->line = input_line - 1;\n-  loc->file = gfc_current_backend_file;\n+  loc->lb = gfc_getmem (sizeof (gfc_linebuf));    \n+  loc->lb->linenum = input_line - 1;\n+  loc->lb->file = gfc_current_backend_file;\n }\n \n \n@@ -424,9 +425,9 @@ gfc_get_backend_locus (locus * loc)\n void\n gfc_set_backend_locus (locus * loc)\n {\n-  input_line = loc->line + 1;\n-  gfc_current_backend_file = loc->file;\n-  input_filename = loc->file->filename;\n+  input_line = loc->lb->linenum;\n+  gfc_current_backend_file = loc->lb->file;\n+  input_filename = loc->lb->file->filename;\n }\n \n "}]}