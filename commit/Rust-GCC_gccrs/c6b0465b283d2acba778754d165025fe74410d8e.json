{"sha": "c6b0465b283d2acba778754d165025fe74410d8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZiMDQ2NWIyODNkMmFjYmE3Nzg3NTRkMTY1MDI1ZmU3NDQxMGQ4ZQ==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-07-13T16:53:32Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-07-13T16:53:32Z"}, "message": "sparc.c, [...]: New trampoline code.\n\nMon Jul 13 16:15:10 1998  John Carr  <jfc@mit.edu>\n\t* sparc.c, sparc.h, sparc.md: New trampoline code.\n\tAllow integer operand 1 to V8+ DImode shift instructions.\n\tFix bugs in V8+ wide multiply patterns.\n\tIn 32 bit mode, split DImode register moves and logical instructions.\n\tWrite V9 branch prediction flag.\n\tUse V9 conditional move more often for scc.\n\t* print-rtl.c (print_rtx): Use HOST_PTR_PRINTF to print pointer.\n\nFrom-SVN: r21108", "tree": {"sha": "42512669ff0ee8332e567f8e852ef50163e5c353", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42512669ff0ee8332e567f8e852ef50163e5c353"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6b0465b283d2acba778754d165025fe74410d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6b0465b283d2acba778754d165025fe74410d8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6b0465b283d2acba778754d165025fe74410d8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6b0465b283d2acba778754d165025fe74410d8e/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e69fd6e52f9a342c40cc065c93a86b0f292a3005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e69fd6e52f9a342c40cc065c93a86b0f292a3005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e69fd6e52f9a342c40cc065c93a86b0f292a3005"}], "stats": {"total": 393, "additions": 216, "deletions": 177}, "files": [{"sha": "5904eb685d73d2c0f6d60767c5c0d93340d15c5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6b0465b283d2acba778754d165025fe74410d8e", "patch": "@@ -1,3 +1,12 @@\n+Mon Jul 13 16:15:10 1998  John Carr  <jfc@mit.edu>\n+\n+\t* sparc.c, sparc.h, sparc.md: New trampoline code.\n+\tAllow integer operand 1 to V8+ DImode shift instructions.\n+\tFix bugs in V8+ wide multiply patterns.\n+\tIn 32 bit mode, split DImode register moves and logical instructions. \n+\tWrite V9 branch prediction flag.\n+\tUse V9 conditional move more often for scc.\n+\n Mon Jul 13 15:10:09 1998  Philippe De Muyter  <phdm@macqel.be>\n \n \t* invoke.texi(-fno-builtin): Explain that the names of built-in"}, {"sha": "d45295f4068bcfb1ba893b96ea49e77645e653b5", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 102, "deletions": 89, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=c6b0465b283d2acba778754d165025fe74410d8e", "patch": "@@ -2480,7 +2480,7 @@ output_move_quad (operands)\n \t      int fix = offset - i * 4;\n \n \t      /* Back up to the appropriate place. */\n-\t      temp[1] = gen_rtx_CONST_INT (VOIDmode, -fix);\n+\t      temp[1] = GEN_INT (-fix);\n \t      if (addreg0)\n \t\t{\n \t\t  temp[0] = addreg0;\n@@ -2495,7 +2495,7 @@ output_move_quad (operands)\n \t\t\t       wordpart[i]);\n \t      /* Don't modify the register that's the destination of the\n \t\t move. */\n-\t      temp[0] = gen_rtx_CONST_INT (VOIDmode, -(offset - fix));\n+\t      temp[0] = GEN_INT (-(offset - fix));\n \t      if (addreg0 && REGNO (addreg0) != REGNO (wordpart[i][0]))\n \t\t{\n \t\t  temp[1] = addreg0;\n@@ -2512,7 +2512,7 @@ output_move_quad (operands)\n \t}\n       if (offset)\n \t{\n-\t  temp[1] = gen_rtx_CONST_INT (VOIDmode, -offset);\n+\t  temp[1] = GEN_INT (-offset);\n \t  /* Undo the adds we just did.  */\n \t  if (addreg0)\n \t    {\n@@ -2712,6 +2712,17 @@ output_scc_insn (operands, insn)\n   rtx label = 0, next = insn;\n   int need_label = 0;\n \n+  /* This code used to be called with final_sequence nonzero (for fpcc\n+     delay slots), but that is no longer allowed.  */\n+  if (final_sequence)\n+    abort ();\n+\n+  /* On UltraSPARC a conditional moves blocks until 3 cycles after prior loads\n+     complete.  It might be beneficial here to use branches if any recent\n+     instructions were loads.  */\n+  if (TARGET_V9 && REGNO (operands[1]) == SPARC_ICC_REG)\n+    return \"mov 0,%0\\n\\tmov%C2 %x1,1,%0\";\n+\n   /* Try doing a jump optimization which jump.c can't do for us\n      because we did not expose that setcc works by using branches.\n \n@@ -2724,21 +2735,12 @@ output_scc_insn (operands, insn)\n       if (GET_CODE (next) == CODE_LABEL)\n \tlabel = next;\n       next = NEXT_INSN (next);\n-      if (next == 0)\n-\tbreak;\n     }\n-  while (GET_CODE (next) == NOTE || GET_CODE (next) == CODE_LABEL);\n+  while (next && GET_CODE (next) == NOTE || GET_CODE (next) == CODE_LABEL);\n \n-  /* If we are in a sequence, and the following insn is a sequence also,\n-     then just following the current insn's next field will take us to the\n-     first insn of the next sequence, which is the wrong place.  We don't\n-     want to optimize with a branch that has had its delay slot filled.\n-     Avoid this by verifying that NEXT_INSN (PREV_INSN (next)) == next\n-     which fails only if NEXT is such a branch.  */\n-\n-  if (next && GET_CODE (next) == JUMP_INSN && simplejump_p (next)\n-      && (! final_sequence || NEXT_INSN (PREV_INSN (next)) == next))\n+  if (next && GET_CODE (next) == JUMP_INSN && simplejump_p (next))\n     label = JUMP_LABEL (next);\n+\n   /* If not optimizing, jump label fields are not set.  To be safe, always\n      check here to whether label is still zero.  */\n   if (label == 0)\n@@ -2752,35 +2754,8 @@ output_scc_insn (operands, insn)\n   /* operands[3] is an unused slot.  */\n   operands[3] = label;\n \n-  /* If we are in a delay slot, assume it is the delay slot of an fpcc\n-     insn since our type isn't allowed anywhere else.  */\n-\n-  /* ??? Fpcc instructions no longer have delay slots, so this code is\n-     probably obsolete.  */\n-\n-  /* The fastest way to emit code for this is an annulled branch followed\n-     by two move insns.  This will take two cycles if the branch is taken,\n-     and three cycles if the branch is not taken.\n-\n-     However, if we are in the delay slot of another branch, this won't work,\n-     because we can't put a branch in the delay slot of another branch.\n-     The above sequence would effectively take 3 or 4 cycles respectively\n-     since a no op would have be inserted between the two branches.\n-     In this case, we want to emit a move, annulled branch, and then the\n-     second move.  This sequence always takes 3 cycles, and hence is faster\n-     when we are in a branch delay slot.  */\n-\n-  if (final_sequence)\n-    {\n-      strcpy (string, \"mov 0,%0\\n\\t\");\n-      strcat (string, output_cbranch (operands[2], 3, 0, 1, 0));\n-      strcat (string, \"\\n\\tmov 1,%0\");\n-    }\n-  else\n-    {\n-      strcpy (string, output_cbranch (operands[2], 3, 0, 1, 0));\n-      strcat (string, \"\\n\\tmov 1,%0\\n\\tmov 0,%0\");\n-    }\n+  strcpy (string, output_cbranch (operands[2], 3, 0, 1, 0));\n+  strcat (string, \"\\n\\tmov 1,%0\\n\\tmov 0,%0\");\n \n   if (need_label)\n     strcat (string, \"\\n%l3:\");\n@@ -4380,13 +4355,16 @@ sparc_builtin_saveregs (arglist)\n \n    ANNUL is non-zero if we should generate an annulling branch.\n \n-   NOOP is non-zero if we have to follow this branch by a noop.  */\n+   NOOP is non-zero if we have to follow this branch by a noop.\n+\n+   INSN, if set, is the insn.  */\n \n char *\n-output_cbranch (op, label, reversed, annul, noop)\n+output_cbranch (op, label, reversed, annul, noop, insn)\n      rtx op;\n      int label;\n      int reversed, annul, noop;\n+     rtx insn;\n {\n   static char string[20];\n   enum rtx_code code = GET_CODE (op);\n@@ -4506,15 +4484,18 @@ output_cbranch (op, label, reversed, annul, noop)\n   if (annul)\n     strcat (string, \",a\");\n \n-  /* ??? If v9, optional prediction bit \",pt\" or \",pf\" goes here.  */\n-\n   if (! TARGET_V9)\n     {\n       labeloff = 3;\n       labelno = v8_labelno;\n     }\n   else\n     {\n+      rtx note;\n+\n+      if (insn && (note = find_reg_note (insn, REG_BR_PRED, NULL_RTX)))\n+\tstrcat (string, INTVAL (XEXP (note, 0)) & ATTR_FLAG_likely ? \",pt\" : \",pn\");\n+\n       labeloff = 9;\n       if (mode == CCFPmode || mode == CCFPEmode)\n \t{\n@@ -5372,34 +5353,49 @@ void\n sparc_initialize_trampoline (tramp, fnaddr, cxt)\n      rtx tramp, fnaddr, cxt;\n {\n-  rtx high_cxt = expand_shift (RSHIFT_EXPR, SImode, cxt,\n-\t\t\t      size_int (10), 0, 1);\n-  rtx high_fn = expand_shift (RSHIFT_EXPR, SImode, fnaddr,\n-\t\t\t     size_int (10), 0, 1);\n-  rtx low_cxt = expand_and (cxt, GEN_INT (0x3ff), 0);\n-  rtx low_fn = expand_and (fnaddr, GEN_INT (0x3ff), 0);\n-  rtx g1_sethi = gen_rtx_HIGH (SImode, GEN_INT (0x03000000));\n-  rtx g2_sethi = gen_rtx_HIGH (SImode, GEN_INT (0x05000000));\n-  rtx g1_ori = gen_rtx_HIGH (SImode, GEN_INT (0x82106000));\n-  rtx g2_ori = gen_rtx_HIGH (SImode, GEN_INT (0x8410A000));\n-  rtx tem = gen_reg_rtx (SImode);\n-  emit_move_insn (tem, g1_sethi);\n-  emit_insn (gen_iorsi3 (high_fn, high_fn, tem));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 0)), high_fn);\n-  emit_move_insn (tem, g1_ori);\n-  emit_insn (gen_iorsi3 (low_fn, low_fn, tem));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 4)), low_fn);\n-  emit_move_insn (tem, g2_sethi);\n-  emit_insn (gen_iorsi3 (high_cxt, high_cxt, tem));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 8)), high_cxt);\n-  emit_move_insn (tem, g2_ori);\n-  emit_insn (gen_iorsi3 (low_cxt, low_cxt, tem));\n-  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 16)), low_cxt);\n+  /* SPARC 32 bit trampoline:\n+\n+ \tsethi %hi(fn),%g1\n+ \tsethi %hi(static),%g2\n+ \tjmp %g1+%lo(fn)\n+ \tor %g2,%lo(static),%g2\n+\n+    SETHI i,r  = 00rr rrr1 00ii iiii iiii iiii iiii iiii\n+    JMPL r+i,d = 10dd ddd1 1100 0rrr rr1i iiii iiii iiii\n+   */\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 0)),\n+\t\t  expand_binop (SImode, ior_optab,\n+\t\t\t\texpand_shift (RSHIFT_EXPR, SImode, fnaddr,\n+\t\t\t\t\t      size_int (10), 0, 1),\n+\t\t\t\tGEN_INT (0x03000000),\n+\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT));\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 4)),\n+\t\t  expand_binop (SImode, ior_optab,\n+\t\t\t\texpand_shift (RSHIFT_EXPR, SImode, cxt,\n+\t\t\t\t\t      size_int (10), 0, 1),\n+\t\t\t\tGEN_INT (0x05000000),\n+\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT));\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 8)),\n+\t\t  expand_binop (SImode, ior_optab,\n+\t\t\t\texpand_and (fnaddr, GEN_INT (0x3ff), NULL_RTX),\n+\t\t\t\tGEN_INT (0x81c06000),\n+\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT));\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 12)),\n+\t\t  expand_binop (SImode, ior_optab,\n+\t\t\t\texpand_and (cxt, GEN_INT (0x3ff), NULL_RTX),\n+\t\t\t\tGEN_INT (0x8410a000),\n+\t\t\t\tNULL_RTX, 1, OPTAB_DIRECT));\n+\n   emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode, tramp))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode,\n-\t\t\t\t\t       plus_constant (tramp, 8)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode,\n-\t\t\t\t\t       plus_constant (tramp, 16)))));\n+  /* On UltraSPARC a flush flushes an entire cache line.  The trampoline is\n+     aligned on a 16 byte boundary so one flush clears it all.  */\n+  if (sparc_cpu != PROCESSOR_ULTRASPARC)\n+    emit_insn (gen_flush (validize_mem (gen_rtx_MEM (SImode,\n+\t\t\t\t\t\t     plus_constant (tramp, 8)))));\n }\n \n /* The 64 bit version is simpler because it makes more sense to load the\n@@ -5410,17 +5406,27 @@ void\n sparc64_initialize_trampoline (tramp, fnaddr, cxt)\n      rtx tramp, fnaddr, cxt;\n {\n-  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 24)), cxt);\n-  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 32)), fnaddr);\n+  /*\n+\trd %pc,%g1\n+\tldx [%g1+24],%g5\n+\tjmp %g5\n+\tldx [%g1+16],%g5\n+\t+16 bytes data\n+   */\n+\n+  emit_move_insn (gen_rtx_MEM (SImode, tramp),\n+\t\t  GEN_INT (0x83414000));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 4)),\n+\t\t  GEN_INT (0xca586018));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 8)),\n+\t\t  GEN_INT (0x81c04000));\n+  emit_move_insn (gen_rtx_MEM (SImode, plus_constant (tramp, 12)),\n+\t\t  GEN_INT (0xca586010));\n+  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 16)), cxt);\n+  emit_move_insn (gen_rtx_MEM (DImode, plus_constant (tramp, 20)), fnaddr);\n   emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode, tramp))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n-\t\t\t\t\t       plus_constant (tramp, 8)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n-\t\t\t\t\t       plus_constant (tramp, 16)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n-\t\t\t\t\t       plus_constant (tramp, 24)))));\n-  emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode,\n-\t\t\t\t\t       plus_constant (tramp, 32)))));\n+  if (sparc_cpu != PROCESSOR_ULTRASPARC)\n+    emit_insn (gen_flush (validize_mem (gen_rtx_MEM (DImode, plus_constant (tramp, 8)))));\n }\n \f\n /* Subroutines to support a flat (single) register window calling\n@@ -6438,10 +6444,17 @@ sparc_v8plus_shift (operands, insn, opcode)\n \n   if (GET_CODE (operands[3]) == SCRATCH)\n     operands[3] = operands[0];\n-  output_asm_insn (\"sllx %H1,32,%3\", operands);\n-  if (sparc_check_64 (operands[1], insn) <= 0)\n-    output_asm_insn (\"srl %L1,0,%L1\", operands);\n-  output_asm_insn (\"or %L1,%3,%3\", operands);\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      output_asm_insn (\"mov %1,%3\", operands);\n+    }\n+  else\n+    {\n+      output_asm_insn (\"sllx %H1,32,%3\", operands);\n+      if (sparc_check_64 (operands[1], insn) <= 0)\n+\toutput_asm_insn (\"srl %L1,0,%L1\", operands);\n+      output_asm_insn (\"or %L1,%3,%3\", operands);\n+    }\n \n   strcpy(asm_code, opcode);\n   if (which_alternative != 2)"}, {"sha": "1f21659178a421d7f676aac682803c862798ca96", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=c6b0465b283d2acba778754d165025fe74410d8e", "patch": "@@ -2099,54 +2099,11 @@ extern union tree_node *current_function_decl;\n #define EPILOGUE_USES(REGNO) \\\n   (!TARGET_FLAT && REGNO == 31)\n \f\n-/* Output assembler code for a block containing the constant parts\n-   of a trampoline, leaving space for the variable parts.  */\n-\n-/* On 32 bit sparcs, the trampoline contains five instructions:\n-     sethi #TOP_OF_FUNCTION,%g1\n-     or #BOTTOM_OF_FUNCTION,%g1,%g1\n-     sethi #TOP_OF_STATIC,%g2\n-     jmp g1\n-     or #BOTTOM_OF_STATIC,%g2,%g2\n-\n-  On 64 bit sparcs, the trampoline contains 4 insns and two pseudo-immediate\n-  constants (plus some padding):\n-     rd %pc,%g1\n-     ldx[%g1+20],%g5\n-     ldx[%g1+28],%g1\n-     jmp %g1\n-     nop\n-     nop\n-     .xword context\n-     .xword function  */\n-/* ??? Stack is execute-protected in v9.  */\n-\n-#define TRAMPOLINE_TEMPLATE(FILE) \\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_ARCH64)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\trd %%pc,%%g1\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tldx [%%g1+24],%%g5\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tldx [%%g1+32],%%g1\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tjmp %%g1\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\t\\\n-      /* -mmedlow shouldn't generate .xwords, so don't use them at all */ \\\n-      fprintf (FILE, \"\\t.word 0,0,0,0\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n-      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n-      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n-      ASM_OUTPUT_INT (FILE, GEN_INT (0x81C04000));\t\\\n-      ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-} while (0)\n-\n /* Length in units of the trampoline for entering a nested function.  */\n \n-#define TRAMPOLINE_SIZE (TARGET_ARCH64 ? 40 : 20)\n+#define TRAMPOLINE_SIZE (TARGET_ARCH64 ? 32 : 16)\n+\n+#define TRAMPOLINE_ALIGNMENT 128 /* 16 bytes */\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -2155,12 +2112,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n void sparc_initialize_trampoline ();\n void sparc64_initialize_trampoline ();\n #define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-  do {\t\t\t\t\t\t\t\t\\\n     if (TARGET_ARCH64)\t\t\t\t\t\t\\\n       sparc64_initialize_trampoline (TRAMP, FNADDR, CXT);\t\\\n     else\t\t\t\t\t\t\t\\\n-      sparc_initialize_trampoline (TRAMP, FNADDR, CXT);\t\t\\\n-  } while (0)\n+      sparc_initialize_trampoline (TRAMP, FNADDR, CXT)\n \f\n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */"}, {"sha": "156c086abda8cfe56cfc73ba3ac6eef22bf18228", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 100, "deletions": 37, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=c6b0465b283d2acba778754d165025fe74410d8e", "patch": "@@ -1308,6 +1308,22 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"3\")])\n \n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_operator:SI 2 \"noov_compare_op\"\n+\t\t\t   [(match_operand 1 \"icc_or_fcc_reg_operand\" \"\")\n+\t\t\t    (const_int 0)]))]\n+  ;; 32 bit LTU/GEU are better implemented using addx/subx\n+  \"TARGET_V9 && REGNO (operands[1]) == SPARC_ICC_REG\n+   && (GET_MODE (operands[1]) == CCXmode\n+       || (GET_CODE (operands[2]) != LTU && GET_CODE (operands[2]) != GEU))\"\n+  [(set (match_dup 0) (const_int 0))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_op_dup:SI 2 [(match_dup 1) (const_int 0)])\n+\t\t\t (const_int 1)\n+\t\t\t (match_dup 0)))]\n+  \"\")\n+\n (define_insn \"*scc_di\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(match_operator:DI 2 \"noov_compare_op\"\n@@ -1521,7 +1537,7 @@\n {\n   return output_cbranch (operands[0], 1, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence);\n+\t\t\t ! final_sequence, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -1536,7 +1552,7 @@\n {\n   return output_cbranch (operands[0], 1, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence);\n+\t\t\t ! final_sequence, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -1552,7 +1568,7 @@\n {\n   return output_cbranch (operands[1], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence);\n+\t\t\t ! final_sequence, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -1568,7 +1584,7 @@\n {\n   return output_cbranch (operands[1], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence);\n+\t\t\t ! final_sequence, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -1584,7 +1600,7 @@\n {\n   return output_cbranch (operands[1], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence);\n+\t\t\t ! final_sequence, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -1600,7 +1616,7 @@\n {\n   return output_cbranch (operands[1], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence);\n+\t\t\t ! final_sequence, insn);\n }\"\n   [(set_attr \"type\" \"branch\")])\n \n@@ -2240,6 +2256,20 @@\n    operands[2] = copy_rtx (operands[0]);\n    PUT_MODE (operands[2], SImode);\")\n \n+;; Split register to register moves.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(match_operand:DI 1 \"arith_double_operand\" \"rIN\"))]\n+  \"! TARGET_ARCH64 && GET_CODE (operands[1]) == REG && REGNO (operands[0]) < 32\n+   && (GET_CODE (operands[1]) != REG || REGNO (operands[1]) < 32)\n+   && ! reg_overlap_mentioned_p (operands[0], operands[1])\"\n+  [(set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 5))]\n+  \"operands[2] = gen_highpart (SImode, operands[0]);\n+   operands[3] = gen_lowpart (SImode, operands[0]);\n+   operands[4] = gen_highpart (SImode, operands[1]);\n+   operands[5] = gen_lowpart (SImode, operands[1]);\")\n+\n (define_insn \"*movdi_sp32\"\n   [(set (match_operand:DI 0 \"reg_or_nonsymb_mem_operand\" \"=r,T,U,Q,r,r,?f,?f,?Q\")\n \t(match_operand:DI 1 \"general_operand\" \"r,U,T,r,Q,i,f,Q,f\"))]\n@@ -3217,7 +3247,7 @@\n if (which_alternative == 1)\n   return \\\"st %1,%0\\\";\n if (sparc_check_64 (operands[1], insn) > 0)\n-  return \\\"nop\\\";\n+  return final_sequence ? \\\"nop\\\" : \\\"\\\";\n return \\\"srl %1,0,%0\\\";\n \"\n   [(set_attr \"type\" \"shift,store\")])\n@@ -3639,7 +3669,7 @@ return \\\"srl %1,0,%0\\\";\n \t\t\t\t   gen_rtx_PLUS (DImode, operands[1],\n \t\t\t\t\t\t operands[2])),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_REG (SImode, SPARC_ICC_REG)))));\n+\t\t\t\t   gen_rtx_REG (CCmode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -3648,7 +3678,7 @@ return \\\"srl %1,0,%0\\\";\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n@@ -3681,7 +3711,7 @@ return \\\"srl %1,0,%0\\\";\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(plus:DI (match_operand:DI 1 \"arith_double_operand\" \"%r\")\n \t\t (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64 && reload_completed\"\n   [(parallel [(set (reg:CC_NOOV 100)\n \t\t   (compare:CC_NOOV (plus:SI (match_dup 4)\n@@ -3698,16 +3728,13 @@ return \\\"srl %1,0,%0\\\";\n    operands[5] = gen_lowpart (SImode, operands[2]);\n    operands[6] = gen_highpart (SImode, operands[0]);\n    operands[7] = gen_highpart (SImode, operands[1]);\n-   if (GET_CODE (operands[2]) == CONST_INT)\n-     operands[8] = INTVAL (operands[2]) < 0 ? constm1_rtx : const0_rtx;\n-   else\n-     operands[8] = gen_highpart (SImode, operands[2]);\")\n+   operands[8] = gen_highpart (SImode, operands[2]);\")\n \n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"arith_double_operand\" \"r\")\n \t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64 && reload_completed\"\n   [(parallel [(set (reg:CC_NOOV 100)\n \t\t   (compare:CC_NOOV (minus:SI (match_dup 4)\n@@ -3749,7 +3776,7 @@ return \\\"srl %1,0,%0\\\";\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n       (plus:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n                (match_operand:DI 2 \"register_operand\" \"r\")))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n   \"addcc %L2,%1,%L0\\;addx %H2,0,%H0\"\n   [(set_attr \"type\" \"multi\")])\n@@ -3823,7 +3850,7 @@ return \\\"srl %1,0,%0\\\";\n \t\t\t\t   gen_rtx_MINUS (DImode, operands[1],\n \t\t\t\t\t\t  operands[2])),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_REG (SImode, SPARC_ICC_REG)))));\n+\t\t\t\t   gen_rtx_REG (CCmode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n@@ -3832,7 +3859,7 @@ return \\\"srl %1,0,%0\\\";\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t  (match_operand:DI 2 \"arith_double_operand\" \"rHI\")))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n@@ -3862,7 +3889,7 @@ return \\\"srl %1,0,%0\\\";\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n       (minus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n                 (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n   \"subcc %L1,%2,%L0\\;addx %H1,0,%H0\"\n   [(set_attr \"type\" \"multi\")])\n@@ -4113,11 +4140,27 @@ return \\\"srl %1,0,%0\\\";\n    smul %1,%2,%4\\;srlx %4,%3,%0\"\n   [(set_attr \"length\" \"2\")])\n \n+;; The combiner changes TRUNCATE in the previous pattern to SUBREG.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n+\t(subreg:SI\n+\t (lshiftrt:DI\n+\t  (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n+\t\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r\")))\n+\t  (match_operand:SI 3 \"const_int_operand\" \"i,i\"))\n+\t 1))\n+   (clobber (match_scratch:SI 4 \"=X,&h\"))]\n+  \"TARGET_V8PLUS\"\n+  \"@\n+   smul %1,%2,%0\\;srlx %0,%3,%0\n+   smul %1,%2,%4\\;srlx %4,%3,%0\"\n+  [(set_attr \"length\" \"2\")])\n+\n (define_insn \"const_smulsi3_highpart_v8plus\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=h,r\")\n \t(truncate:SI\n \t (lshiftrt:DI (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r\"))\n-\t\t\t       (match_operand:SI 2 \"register_operand\" \"r,r\"))\n+\t\t\t       (match_operand 2 \"small_int\" \"i,i\"))\n \t\t      (match_operand:SI 3 \"const_int_operand\" \"i,i\"))))\n    (clobber (match_scratch:SI 4 \"=X,&h\"))]\n   \"TARGET_V8PLUS\"\n@@ -4510,6 +4553,23 @@ return \\\"srl %1,0,%0\\\";\n   operands[4] = GEN_INT (~INTVAL (operands[2]) & 0xffffffff);\n }\")\n \n+;; Split DImode logical operations requiring two instructions.\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operator:DI 1 \"cc_arithop\"\t; AND, IOR, XOR\n+\t\t\t   [(match_operand:DI 2 \"register_operand\" \"\")\n+\t\t\t    (match_operand:DI 3 \"arith_double_operand\" \"\")]))]\n+  \"! TARGET_ARCH64 && reload_completed\n+   && GET_CODE (operands[0]) == REG && REGNO (operands[0]) < 32\"\n+  [(set (match_dup 4) (match_op_dup:SI 1 [(match_dup 6) (match_dup 8)]))\n+   (set (match_dup 5) (match_op_dup:SI 1 [(match_dup 7) (match_dup 9)]))]\n+  \"operands[4] = gen_highpart (SImode, operands[0]);\n+   operands[5] = gen_lowpart (SImode, operands[0]);\n+   operands[6] = gen_highpart (SImode, operands[2]);\n+   operands[7] = gen_lowpart (SImode, operands[2]);\n+   operands[8] = gen_highpart (SImode, operands[3]);\n+   operands[9] = gen_lowpart (SImode, operands[3]);\")\n+\n (define_insn \"*and_not_di_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,b\")\n \t(and:DI (not:DI (match_operand:DI 1 \"register_operand\" \"r,b\"))\n@@ -4899,15 +4959,15 @@ return \\\"srl %1,0,%0\\\";\n \t\t\t  gen_rtx_SET (VOIDmode, operand0,\n \t\t\t\t   gen_rtx_NEG (DImode, operand1)),\n \t\t\t  gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t   gen_rtx_REG (SImode, SPARC_ICC_REG)))));\n+\t\t\t\t   gen_rtx_REG (CCmode, SPARC_ICC_REG)))));\n       DONE;\n     }\n }\")\n \n (define_insn \"*negdi2_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:SI 100))]\n+   (clobber (reg:CC 100))]\n   \"! TARGET_ARCH64\"\n   \"*\n {\n@@ -5331,13 +5391,28 @@ return \\\"srl %1,0,%0\\\";\n \n (define_insn \"ashldi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&h,&h,r\")\n-\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r,0,r\")\n+\t(ashift:DI (match_operand:DI 1 \"arith_operand\" \"rI,0,rI\")\n \t\t   (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n   \"TARGET_V8PLUS\"\n   \"*return sparc_v8plus_shift (operands, insn, \\\"sllx\\\");\"\n   [(set_attr \"length\" \"5,5,6\")])\n \n+;; Optimize (1LL<<x)-1\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=h\")\n+\t(plus:DI (ashift:DI (const_int 1)\n+\t\t\t    (match_operand:SI 2 \"arith_operand\" \"rI\"))\n+\t\t (const_int -1)))]\n+  \"TARGET_V8PLUS\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == REG && REGNO (operands[2]) == REGNO (operands[0]))\n+    return \\\"mov 1,%L0\\;sllx %L0,%2,%L0\\;sub %L0,1,%L0\\;srlx %L0,32,%H0\\\";\n+  return \\\"mov 1,%H0\\;sllx %H0,%2,%L0\\;sub %L0,1,%L0\\;srlx %L0,32,%H0\\\";\n+}\"\n+  [(set_attr \"length\" \"4\")])\n+\n (define_insn \"*cmp_cc_ashift_1\"\n   [(set (reg:CC_NOOV 100)\n \t(compare:CC_NOOV (ashift:SI (match_operand:SI 0 \"register_operand\" \"r\")\n@@ -5402,7 +5477,7 @@ if (! TARGET_ARCH64)\n \n (define_insn \"ashrdi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&h,&h,r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,0,r\")\n+\t(ashiftrt:DI (match_operand:DI 1 \"arith_operand\" \"rI,0,rI\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n   \"TARGET_V8PLUS\"\n@@ -5454,7 +5529,7 @@ if (! TARGET_ARCH64)\n \n (define_insn \"lshrdi3_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&h,&h,r\")\n-\t(lshiftrt:DI (match_operand:DI 1 \"register_operand\" \"r,0,r\")\n+\t(lshiftrt:DI (match_operand:DI 1 \"arith_operand\" \"rI,0,rI\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n   \"TARGET_V8PLUS\"\n@@ -6605,18 +6680,6 @@ if (! TARGET_ARCH64)\n   \"TARGET_ARCH64 && short_branch (INSN_UID (insn), INSN_UID (operands[2])) && in_same_eh_region (insn, operands[2]) && in_same_eh_region (insn, ins1)\"\n   \"call %a0,%1\\;add %%o7,(%l2-.-4),%%o7\")\n \n-;; Other miscellaneous peepholes.\n-\n-;; (reg:SI 100) is created by the {add,neg,sub}di patterns.\n-(define_peephole\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t\t   (minus:SI (match_operand:SI 1 \"reg_or_0_operand\" \"rJ\")\n-\t\t\t     (reg:SI 100)))\n-\t      (clobber (reg:CC 100))])\n-   (set (reg:CC 100) (compare (match_dup 0) (const_int 0)))]\n-  \"\"\n-  \"subxcc %r1,0,%0\")\n-\n ;; After a nonlocal goto, we need to restore the PIC register, but only\n ;; if we need it.  So do nothing much here, but we'll check for this in\n ;; finalize_pic."}, {"sha": "947a9b767c8767b0cd3b07a549a070704fdf81b4", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6b0465b283d2acba778754d165025fe74410d8e/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=c6b0465b283d2acba778754d165025fe74410d8e", "patch": "@@ -253,8 +253,7 @@ print_rtx (in_rtx)\n \n       case 't':\n \tputc (' ', outfile);\n-\tfprintf (outfile, HOST_WIDE_INT_PRINT_HEX,\n-\t\t (HOST_WIDE_INT) XTREE (in_rtx, i));\n+\tfprintf (outfile, HOST_PTR_PRINTF, (char *) XTREE (in_rtx, i));\n \tbreak;\n \n       case '*':"}]}