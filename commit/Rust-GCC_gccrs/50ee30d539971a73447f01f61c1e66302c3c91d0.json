{"sha": "50ee30d539971a73447f01f61c1e66302c3c91d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBlZTMwZDUzOTk3MWE3MzQ0N2YwMWY2MWMxZTY2MzAyYzNjOTFkMA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-05-25T15:47:28Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-05-25T15:47:28Z"}, "message": "lto-wrapper.c (nr, [...]): Globalize.\n\n2010-05-25  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-wrapper.c (nr, input_names, output_names, makefile): Globalize.\n\t(lto_wrapper_exit): Unlink all LTRANS temporary files on error.\n\t(run_gcc): Re-organize to make cleanup easier.\n\nFrom-SVN: r159823", "tree": {"sha": "8828a2971eda33069c25d73980748614f48b829c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8828a2971eda33069c25d73980748614f48b829c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50ee30d539971a73447f01f61c1e66302c3c91d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ee30d539971a73447f01f61c1e66302c3c91d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50ee30d539971a73447f01f61c1e66302c3c91d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50ee30d539971a73447f01f61c1e66302c3c91d0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca1930ce8b3dfa6965b2c6991232139e43420dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1930ce8b3dfa6965b2c6991232139e43420dab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1930ce8b3dfa6965b2c6991232139e43420dab"}], "stats": {"total": 134, "additions": 81, "deletions": 53}, "files": [{"sha": "3a7e80c1a8e55c1f5ca0e74397a727d1e0aefb6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ee30d539971a73447f01f61c1e66302c3c91d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ee30d539971a73447f01f61c1e66302c3c91d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50ee30d539971a73447f01f61c1e66302c3c91d0", "patch": "@@ -1,3 +1,9 @@\n+2010-05-25  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-wrapper.c (nr, input_names, output_names, makefile): Globalize.\n+\t(lto_wrapper_exit): Unlink all LTRANS temporary files on error.\n+\t(run_gcc): Re-organize to make cleanup easier.\n+\n 2010-05-25  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/s390.c (optimization_options): Fix and move the"}, {"sha": "536ca092f7186a869a65cad14abb393c364add8f", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 75, "deletions": 53, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50ee30d539971a73447f01f61c1e66302c3c91d0/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50ee30d539971a73447f01f61c1e66302c3c91d0/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=50ee30d539971a73447f01f61c1e66302c3c91d0", "patch": "@@ -60,6 +60,10 @@ static enum lto_mode_d lto_mode = LTO_MODE_NONE;\n static char *ltrans_output_file;\n static char *flto_out;\n static char *args_name;\n+static unsigned int nr;\n+static char **input_names;\n+static char **output_names;\n+static char *makefile;\n \n static void maybe_unlink_file (const char *);\n \n@@ -71,6 +75,8 @@ lto_wrapper_exit (int status)\n   static bool cleanup_done = false;\n   if (!cleanup_done)\n     {\n+      unsigned int i;\n+\n       /* Setting cleanup_done prevents an infinite loop if one of the\n          calls to maybe_unlink_file fails. */\n       cleanup_done = true;\n@@ -81,6 +87,14 @@ lto_wrapper_exit (int status)\n         maybe_unlink_file (flto_out);\n       if (args_name)\n         maybe_unlink_file (args_name);\n+      if (makefile)\n+\tmaybe_unlink_file (makefile);\n+      for (i = 0; i < nr; ++i)\n+\t{\n+\t  maybe_unlink_file (input_names[i]);\n+\t  if (output_names[i])\n+\t    maybe_unlink_file (output_names[i]);\n+\t}\n     }\n   exit (status);\n }\n@@ -428,27 +442,17 @@ run_gcc (unsigned argc, char *argv[])\n   else if (lto_mode == LTO_MODE_WHOPR)\n     {\n       FILE *stream = fopen (ltrans_output_file, \"r\");\n-      unsigned int nr = 0;\n-      char **input_names = NULL;\n-      char **output_names = NULL;\n-      char *makefile = NULL;\n       FILE *mstream = NULL;\n \n       if (!stream)\n \tfatal_perror (\"fopen: %s\", ltrans_output_file);\n \n-      argv_ptr[1] = \"-fltrans\";\n-\n-      if (parallel)\n-\t{\n-\t  makefile = make_temp_file (\".mk\");\n-\t  mstream = fopen (makefile, \"w\");\n-\t}\n-\n+      /* Parse the list of LTRANS inputs from the WPA stage.  */\n+      nr = 0;\n       for (;;)\n \t{\n \t  const unsigned piece = 32;\n-\t  char *output_name;\n+\t  char *output_name = NULL;\n \t  char *buf, *input_name = (char *)xmalloc (piece);\n \t  size_t len;\n \n@@ -467,51 +471,69 @@ run_gcc (unsigned argc, char *argv[])\n \n \t  if (input_name[0] == '*')\n \t    output_name = &input_name[1];\n-\t  else\n-\t    {\n-\t      /* Otherwise, add FILES[I] to lto_execute_ltrans command line\n-\t\t and add the resulting file to LTRANS output list.  */\n-\n-\t      /* Replace the .o suffix with a .ltrans.o suffix and write\n-\t\t the resulting name to the LTRANS output list.  */\n-\t      obstack_init (&env_obstack);\n-\t      obstack_grow (&env_obstack, input_name, strlen (input_name) - 2);\n-\t      obstack_grow (&env_obstack, \".ltrans.o\", sizeof (\".ltrans.o\"));\n-\t      output_name = XOBFINISH (&env_obstack, char *);\n-\n-\t      if (linker_output)\n-\t\t{\n-\t\t  char *dumpbase\n-\t\t    = (char *) xmalloc (strlen (linker_output)\n-\t\t\t\t\t+ sizeof(DUMPBASE_SUFFIX) + 1);\n-\t\t  snprintf (dumpbase,\n-\t\t\t    strlen (linker_output) + sizeof(DUMPBASE_SUFFIX),\n-\t\t\t    \"%s.ltrans%u\", linker_output, nr);\n-\t\t  argv_ptr[0] = dumpbase;\n-\t\t}\n-\n-\t      argv_ptr[2] = \"-o\";\n-\t      argv_ptr[3] = output_name;\n-\t      argv_ptr[4] = input_name;\n-\t      argv_ptr[5] = NULL;\n-\n-\t      if (parallel)\n-\t\t{\n-\t\t  fprintf (mstream, \"%s:\\n\\t@%s \", output_name, new_argv[0]);\n-\t\t  for (i = 1; new_argv[i] != NULL; ++i)\n-\t\t    fprintf (mstream, \" '%s'\", new_argv[i]);\n-\t\t  fprintf (mstream, \"\\n\");\n-\t\t}\n-\t      else\n-\t\tfork_execute (CONST_CAST (char **, new_argv));\n-\t    }\n \n \t  nr++;\n \t  input_names = (char **)xrealloc (input_names, nr * sizeof (char *));\n \t  output_names = (char **)xrealloc (output_names, nr * sizeof (char *));\n \t  input_names[nr-1] = input_name;\n \t  output_names[nr-1] = output_name;\n \t}\n+      fclose (stream);\n+      maybe_unlink_file (ltrans_output_file);\n+      ltrans_output_file = NULL;\n+\n+      if (parallel)\n+\t{\n+\t  makefile = make_temp_file (\".mk\");\n+\t  mstream = fopen (makefile, \"w\");\n+\t}\n+\n+      /* Execute the LTRANS stage for each input file (or prepare a\n+\t makefile to invoke this in parallel).  */\n+      for (i = 0; i < nr; ++i)\n+\t{\n+\t  char *output_name;\n+\t  char *input_name = input_names[i];\n+\t  /* If it's a pass-through file do nothing.  */\n+\t  if (output_names[i])\n+\t    continue;\n+\n+\t  /* Replace the .o suffix with a .ltrans.o suffix and write\n+\t     the resulting name to the LTRANS output list.  */\n+\t  obstack_init (&env_obstack);\n+\t  obstack_grow (&env_obstack, input_name, strlen (input_name) - 2);\n+\t  obstack_grow (&env_obstack, \".ltrans.o\", sizeof (\".ltrans.o\"));\n+\t  output_name = XOBFINISH (&env_obstack, char *);\n+\n+\t  /* Adjust the dumpbase if the linker output file was seen.  */\n+\t  if (linker_output)\n+\t    {\n+\t      char *dumpbase\n+\t\t  = (char *) xmalloc (strlen (linker_output)\n+\t\t\t\t      + sizeof(DUMPBASE_SUFFIX) + 1);\n+\t      snprintf (dumpbase,\n+\t\t\tstrlen (linker_output) + sizeof(DUMPBASE_SUFFIX),\n+\t\t\t\"%s.ltrans%u\", linker_output, nr);\n+\t      argv_ptr[0] = dumpbase;\n+\t    }\n+\n+\t  argv_ptr[1] = \"-fltrans\";\n+\t  argv_ptr[2] = \"-o\";\n+\t  argv_ptr[3] = output_name;\n+\t  argv_ptr[4] = input_name;\n+\t  argv_ptr[5] = NULL;\n+\t  if (parallel)\n+\t    {\n+\t      fprintf (mstream, \"%s:\\n\\t@%s \", output_name, new_argv[0]);\n+\t      for (j = 1; new_argv[j] != NULL; ++j)\n+\t\tfprintf (mstream, \" '%s'\", new_argv[j]);\n+\t      fprintf (mstream, \"\\n\");\n+\t    }\n+\t  else\n+\t    fork_execute (CONST_CAST (char **, new_argv));\n+\n+\t  output_names[i] = output_name;\n+\t}\n       if (parallel)\n \t{\n \t  struct pex_obj *pex;\n@@ -536,6 +558,7 @@ run_gcc (unsigned argc, char *argv[])\n \t  pex = collect_execute (CONST_CAST (char **, new_argv));\n \t  collect_wait (new_argv[0], pex);\n \t  maybe_unlink_file (makefile);\n+\t  makefile = NULL;\n \t}\n       for (i = 0; i < nr; ++i)\n \t{\n@@ -544,10 +567,9 @@ run_gcc (unsigned argc, char *argv[])\n \t  maybe_unlink_file (input_names[i]);\n \t  free (input_names[i]);\n \t}\n+      nr = 0;\n       free (output_names);\n       free (input_names);\n-      fclose (stream);\n-      maybe_unlink_file (ltrans_output_file);\n       free (list_option_full);\n     }\n   else"}]}