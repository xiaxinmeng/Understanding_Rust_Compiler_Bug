{"sha": "5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQyZDNlNDNiOTE3Zjg3Y2U0ZTgzNzgwNzY4ODhkZDAzZTRjN2NjMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-07-16T13:52:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-07-16T13:52:22Z"}, "message": "read-md.h (message_with_line, [...]): Delete.\n\ngcc/\n\t* read-md.h (message_with_line, error_with_line): Delete.\n\t* read-md.c (message_with_line, error_with_line): Delete.\n\t* gensupport.h: Include read-md.h.\n\t(md_rtx_info): New structure.\n\t(read_md_rtx): Use it.  Return a bool success value.\n\t* gensupport.c (read_md_rtx): Likewise.\n\t* genattr-common.c (gen_attr): Take an md_rtx_info rather than an rtx.\n\t(main): Update after interface changes.\n\t* genattr.c (gen_attr): Take an md_rtx_info rather than an rtx.\n\t(main): Update after interface changes.\n\t* genattrtab.c (insn_code_number): Delete.\n\t(optimize_attrs): Add a max_insn_code parameter and use it instead\n\tof insn_code_number.\n\t(gen_attr): Take an md_rtx_info rather than an rtx and lineno.\n\tUse *_at rather than *_with_line functions.\n\t(gen_insn): Likewise.\n\t(gen_delay): Likewise.\n\t(gen_insn_reserv): Likewise.\n\t(gen_bypass): Take an md_rtx_info rather than an rtx.\n\t(main): Update after interface changes.  Use a local max_insn_code\n\tvariable instead of insn_code_number.\n\t* genautomata.c (gen_cpu_unit): Take an md_rtx_info rather than\n\tan rtx.  Use fatal_at rather than fatal.\n\t(gen_query_cpu_unit, gen_bypass, gen_excl_set)\n\t(gen_presence_absence_set, gen_presence_set, gen_final_presence_set)\n\t(gen_absence_set, gen_final_absence_set, gen_automaton)\n\t(gen_automata_option, gen_reserv, gen_insn_reserv): Likewise.\n\t(main): Update after interface changes.\n\t* gencodes.c (gen_insn): Take an md_rtx_info rather than an rtx\n\tand code number.\n\t(main): Update after interface changes.\n\t* genconditions.c (main): Use new read_md_rtx interface.\n\t* genconfig.c (gen_insn): Take an md_rtx_info rather than an rtx.\n\t(gen_expand, gen_split, gen_peephole, gen_peephole2): Likewise.\n\t(main): Update after interface changes.\n\t* genemit.c (insn_code_number, insn_index_number): Delete.\n\t(gen_insn): Take an md_rtx_info rather than an rtx and lineno.\n\tUse fatal_at rather than fatal.\n\t(gen_expand): Take an md_rtx_info rather than an rtx.  Use fatal_at\n\trather than fatal.\n\t(gen_split): Likewise.\n\t(main): Update after interface changes.\n\t* genextract.c (line_no): Delete.\n\t(gen_insn): Take an md_rtx_info rather than an rtx and lineno.\n\tUpdate call to walk_rtx.\n\t(VEC_safe_set_locstr): Add an md_rtx_info argument.  Use message_at\n\trather than message_with_line.\n\t(walk_rtx): Add an md_rtx_info argument.  Update call to\n\tVEC_safe_set_locstr.\n\t(main): Update after interface changes.\n\t* genflags.c (gen_insn): Take an md_rtx_info rather than an rtx\n\tand lineno.  Use error_at rather than separate message_with_line\n\tcalls and have_error assignments.\n\t(main): Update after interface changes.\n\t* genmddump.c (main): Use new read_md_rtx interface.\n\t* genopinit.c (insn): Take an md_rtx_info rather than an rtx.\n\t(main): Update after interface changes.\n\t* genoutput.c (next_code_number): Delete.\n\t(gen_insn): Take an md_rtx_info rather than an rtx and lineno.\n\t(gen_peephole, gen_expand, gen_split): Likewise.\n\t(note_constraint): Likewise.  Use *_at rather than *_with_line\n\tfunctions.\n\t(main): Update after interface changes.\n\t* genpeep.c (gen_peephole): Take an md_rtx_info rather than an\n\trtx and lineno.\n\t(main): Update after interface changes.\n\t* genpreds.c (process_define_predicate): Take an md_rtx_info rather\n\tthan an rtx and lineno.\n\t(process_define_constraint): Likewise.\n\t(process_define_register_constraint): Likewise.\n\t(main): Update after interface changes.\n\t* genrecog.c (next_insn_code, pattern_lineno): Delete.\n\t(validate_pattern): Replace top-level rtx with an md_rtx_info.\n\tUse *_at rather than *_with_line functions.\n\t(match_pattern_2): Likewise.\n\t(match_pattern_1, match_pattern): Add an md_rtx_info parameter.\n\t(get_peephole2_pattern): Take an md_rtx_info rather than an rtvec.\n\tUse *_at rather than *_with_line functions.\n\t* gentarget-def.c (add_insn): New function.\n\t(main): Use it.  Use new read_md_rtx interface.\n\nFrom-SVN: r225883", "tree": {"sha": "9d8586f4a5e07a89b18a2e4fb2c2f801fafb90b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d8586f4a5e07a89b18a2e4fb2c2f801fafb90b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c9f84f2e1d697a8d6a6e696bd26933ca4a858da0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f84f2e1d697a8d6a6e696bd26933ca4a858da0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f84f2e1d697a8d6a6e696bd26933ca4a858da0"}], "stats": {"total": 1406, "additions": 702, "deletions": 704}, "files": [{"sha": "11cddf2e52fe6e32048a2f2cff1b8d5ad47a3477", "filename": "gcc/ChangeLog", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -1,3 +1,86 @@\n+2015-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* read-md.h (message_with_line, error_with_line): Delete.\n+\t* read-md.c (message_with_line, error_with_line): Delete.\n+\t* gensupport.h: Include read-md.h.\n+\t(md_rtx_info): New structure.\n+\t(read_md_rtx): Use it.  Return a bool success value.\n+\t* gensupport.c (read_md_rtx): Likewise.\n+\t* genattr-common.c (gen_attr): Take an md_rtx_info rather than an rtx.\n+\t(main): Update after interface changes.\n+\t* genattr.c (gen_attr): Take an md_rtx_info rather than an rtx.\n+\t(main): Update after interface changes.\n+\t* genattrtab.c (insn_code_number): Delete.\n+\t(optimize_attrs): Add a max_insn_code parameter and use it instead\n+\tof insn_code_number.\n+\t(gen_attr): Take an md_rtx_info rather than an rtx and lineno.\n+\tUse *_at rather than *_with_line functions.\n+\t(gen_insn): Likewise.\n+\t(gen_delay): Likewise.\n+\t(gen_insn_reserv): Likewise.\n+\t(gen_bypass): Take an md_rtx_info rather than an rtx.\n+\t(main): Update after interface changes.  Use a local max_insn_code\n+\tvariable instead of insn_code_number.\n+\t* genautomata.c (gen_cpu_unit): Take an md_rtx_info rather than\n+\tan rtx.  Use fatal_at rather than fatal.\n+\t(gen_query_cpu_unit, gen_bypass, gen_excl_set)\n+\t(gen_presence_absence_set, gen_presence_set, gen_final_presence_set)\n+\t(gen_absence_set, gen_final_absence_set, gen_automaton)\n+\t(gen_automata_option, gen_reserv, gen_insn_reserv): Likewise.\n+\t(main): Update after interface changes.\n+\t* gencodes.c (gen_insn): Take an md_rtx_info rather than an rtx\n+\tand code number.\n+\t(main): Update after interface changes.\n+\t* genconditions.c (main): Use new read_md_rtx interface.\n+\t* genconfig.c (gen_insn): Take an md_rtx_info rather than an rtx.\n+\t(gen_expand, gen_split, gen_peephole, gen_peephole2): Likewise.\n+\t(main): Update after interface changes.\n+\t* genemit.c (insn_code_number, insn_index_number): Delete.\n+\t(gen_insn): Take an md_rtx_info rather than an rtx and lineno.\n+\tUse fatal_at rather than fatal.\n+\t(gen_expand): Take an md_rtx_info rather than an rtx.  Use fatal_at\n+\trather than fatal.\n+\t(gen_split): Likewise.\n+\t(main): Update after interface changes.\n+\t* genextract.c (line_no): Delete.\n+\t(gen_insn): Take an md_rtx_info rather than an rtx and lineno.\n+\tUpdate call to walk_rtx.\n+\t(VEC_safe_set_locstr): Add an md_rtx_info argument.  Use message_at\n+\trather than message_with_line.\n+\t(walk_rtx): Add an md_rtx_info argument.  Update call to\n+\tVEC_safe_set_locstr.\n+\t(main): Update after interface changes.\n+\t* genflags.c (gen_insn): Take an md_rtx_info rather than an rtx\n+\tand lineno.  Use error_at rather than separate message_with_line\n+\tcalls and have_error assignments.\n+\t(main): Update after interface changes.\n+\t* genmddump.c (main): Use new read_md_rtx interface.\n+\t* genopinit.c (insn): Take an md_rtx_info rather than an rtx.\n+\t(main): Update after interface changes.\n+\t* genoutput.c (next_code_number): Delete.\n+\t(gen_insn): Take an md_rtx_info rather than an rtx and lineno.\n+\t(gen_peephole, gen_expand, gen_split): Likewise.\n+\t(note_constraint): Likewise.  Use *_at rather than *_with_line\n+\tfunctions.\n+\t(main): Update after interface changes.\n+\t* genpeep.c (gen_peephole): Take an md_rtx_info rather than an\n+\trtx and lineno.\n+\t(main): Update after interface changes.\n+\t* genpreds.c (process_define_predicate): Take an md_rtx_info rather\n+\tthan an rtx and lineno.\n+\t(process_define_constraint): Likewise.\n+\t(process_define_register_constraint): Likewise.\n+\t(main): Update after interface changes.\n+\t* genrecog.c (next_insn_code, pattern_lineno): Delete.\n+\t(validate_pattern): Replace top-level rtx with an md_rtx_info.\n+\tUse *_at rather than *_with_line functions.\n+\t(match_pattern_2): Likewise.\n+\t(match_pattern_1, match_pattern): Add an md_rtx_info parameter.\n+\t(get_peephole2_pattern): Take an md_rtx_info rather than an rtvec.\n+\tUse *_at rather than *_with_line functions.\n+\t* gentarget-def.c (add_insn): New function.\n+\t(main): Use it.  Use new read_md_rtx interface.\n+\n 2015-07-16  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gensupport.h (compute_test_codes): Take a file_location rather"}, {"sha": "0ff8da984dd7f7c030658877528cd22e3f138056", "filename": "gcc/genattr-common.c", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenattr-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenattr-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr-common.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -37,10 +37,11 @@ write_upcase (const char *str)\n }\n \n static void\n-gen_attr (rtx attr)\n+gen_attr (md_rtx_info *info)\n {\n   const char *p, *tag;\n \n+  rtx attr = info->def;\n   p = XSTR (attr, 1);\n   if (*p != '\\0')\n     {\n@@ -62,7 +63,6 @@ gen_attr (rtx attr)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   bool have_delay = false;\n   bool have_sched = false;\n \n@@ -78,34 +78,33 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no, insn_code_number;\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_ATTR:\n+\tgen_attr (&info);\n+\tbreak;\n \n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+      case DEFINE_DELAY:\n+\tif (!have_delay)\n+\t  {\n+\t    printf (\"#define DELAY_SLOTS\\n\");\n+\t    have_delay = true;\n+\t  }\n \tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_ATTR)\n-\tgen_attr (desc);\n+      case DEFINE_INSN_RESERVATION:\n+\tif (!have_sched)\n+\t  {\n+\t    printf (\"#define INSN_SCHEDULING\\n\");\n+\t    have_sched = true;\n+\t  }\n+\tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_DELAY)\n-        {\n-\t  if (!have_delay)\n-\t    {\n-\t      printf (\"#define DELAY_SLOTS\\n\");\n-\t      have_delay = true;\n-\t    }\n-\t}\n-      else if (GET_CODE (desc) == DEFINE_INSN_RESERVATION)\n-\t{\n-\t  if (!have_sched)\n-\t    {\n-\t      printf (\"#define INSN_SCHEDULING\\n\");\n-\t      have_sched = true;\n-\t    }\n-\t}\n-    }\n+      default:\n+\tbreak;\n+      }\n   puts (\"\\n#endif /* GCC_INSN_ATTR_COMMON_H */\");\n \n   if (ferror (stdout) || fflush (stdout) || fclose (stdout))"}, {"sha": "d31f00733d945d6cf6e0ff198875db75798a0450", "filename": "gcc/genattr.c", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -29,15 +29,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gensupport.h\"\n \n \n-static void gen_attr (rtx);\n-\n static vec<rtx> const_attrs, reservations;\n \n \n static void\n-gen_attr (rtx attr)\n+gen_attr (md_rtx_info *info)\n {\n   const char *p;\n+  rtx attr = info->def;\n   int is_const = GET_CODE (XEXP (attr, 2)) == CONST;\n \n   if (is_const)\n@@ -141,7 +140,6 @@ find_tune_attr (rtx exp)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   int have_delay = 0;\n   int have_annul_true = 0;\n   int have_annul_false = 0;\n@@ -162,20 +160,18 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while (1)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n     {\n-      int line_no, insn_code_number;\n-\n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n-\tbreak;\n-\n-      if (GET_CODE (desc) == DEFINE_ATTR\n-\t  || GET_CODE (desc) == DEFINE_ENUM_ATTR)\n-\tgen_attr (desc);\n+      rtx def = info.def;\n+      switch (GET_CODE (def))\n+\t{\n+\tcase DEFINE_ATTR:\n+\tcase DEFINE_ENUM_ATTR:\n+\t  gen_attr (&info);\n+\t  break;\n \n-      else if (GET_CODE (desc) == DEFINE_DELAY)\n-        {\n+\tcase DEFINE_DELAY:\n \t  if (! have_delay)\n \t    {\n \t      printf (\"extern int num_delay_slots (rtx_insn *);\\n\");\n@@ -184,28 +180,31 @@ main (int argc, char **argv)\n \t      have_delay = 1;\n \t    }\n \n-\t  for (i = 0; i < XVECLEN (desc, 1); i += 3)\n+\t  for (i = 0; i < XVECLEN (def, 1); i += 3)\n \t    {\n-\t      if (XVECEXP (desc, 1, i + 1) && ! have_annul_true)\n+\t      if (XVECEXP (def, 1, i + 1) && ! have_annul_true)\n \t\t{\n \t\t  printf (\"#define ANNUL_IFTRUE_SLOTS\\n\");\n \t\t  printf (\"extern int eligible_for_annul_true (rtx_insn *, int, rtx_insn *, int);\\n\");\n \t\t  have_annul_true = 1;\n \t\t}\n \n-\t      if (XVECEXP (desc, 1, i + 2) && ! have_annul_false)\n+\t      if (XVECEXP (def, 1, i + 2) && ! have_annul_false)\n \t\t{\n \t\t  printf (\"#define ANNUL_IFFALSE_SLOTS\\n\");\n \t\t  printf (\"extern int eligible_for_annul_false (rtx_insn *, int, rtx_insn *, int);\\n\");\n \t\t  have_annul_false = 1;\n \t\t}\n \t    }\n-        }\n+\t  break;\n \n-      else if (GET_CODE (desc) == DEFINE_INSN_RESERVATION)\n-\t{\n+\tcase DEFINE_INSN_RESERVATION:\n \t  num_insn_reservations++;\n-\t  reservations.safe_push (desc);\n+\t  reservations.safe_push (def);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n \t}\n     }\n "}, {"sha": "c41c6b273d770c9a814ada671280294524cbc9ca", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -211,7 +211,6 @@ struct attr_value_list **insn_code_values;\n \n /* Other variables.  */\n \n-static int insn_code_number;\n static int insn_index_number;\n static int got_define_asm_attributes;\n static int must_extract;\n@@ -1016,7 +1015,7 @@ check_attr_value (rtx exp, struct attr_desc *attr)\n \tstruct attr_desc *attr2 = find_attr (&XSTR (exp, 0), 0);\n \tif (attr2 == NULL)\n \t  error_at (attr->loc, \"unknown attribute `%s' in ATTR\",\n-\t\t\t   XSTR (exp, 0));\n+\t\t    XSTR (exp, 0));\n \telse if (attr->is_const && ! attr2->is_const)\n \t  error_at (attr->loc,\n \t\t    \"non-constant attribute `%s' referenced from `%s'\",\n@@ -2950,10 +2949,11 @@ get_attr_order (struct attr_desc ***ret)\n \n /* Optimize the attribute lists by seeing if we can determine conditional\n    values from the known values of other attributes.  This will save subroutine\n-   calls during the compilation.  */\n+   calls during the compilation.  MAX_INSN_CODE is the number of unique\n+   instruction codes.  */\n \n static void\n-optimize_attrs (void)\n+optimize_attrs (int max_insn_code)\n {\n   struct attr_desc *attr;\n   struct attr_value *av;\n@@ -2972,7 +2972,7 @@ optimize_attrs (void)\n     return;\n \n   /* Make 2 extra elements, for \"code\" values -2 and -1.  */\n-  insn_code_values = XCNEWVEC (struct attr_value_list *, insn_code_number + 2);\n+  insn_code_values = XCNEWVEC (struct attr_value_list *, max_insn_code + 2);\n \n   /* Offset the table address so we can index by -2 or -1.  */\n   insn_code_values += 2;\n@@ -3000,7 +3000,7 @@ optimize_attrs (void)\n   gcc_assert (iv == ivbuf + num_insn_ents);\n \n   /* Process one insn code at a time.  */\n-  for (i = -2; i < insn_code_number; i++)\n+  for (i = -2; i < max_insn_code; i++)\n     {\n       /* Clear the ATTR_CURR_SIMPLIFIED_P flag everywhere relevant.\n \t We use it to mean \"already simplified for this insn\".  */\n@@ -3126,63 +3126,64 @@ add_attr_value (struct attr_desc *attr, const char *name)\n /* Create table entries for DEFINE_ATTR or DEFINE_ENUM_ATTR.  */\n \n static void\n-gen_attr (rtx exp, int lineno)\n+gen_attr (md_rtx_info *info)\n {\n   struct enum_type *et;\n   struct enum_value *ev;\n   struct attr_desc *attr;\n   const char *name_ptr;\n   char *p;\n+  rtx def = info->def;\n \n   /* Make a new attribute structure.  Check for duplicate by looking at\n      attr->default_val, since it is initialized by this routine.  */\n-  attr = find_attr (&XSTR (exp, 0), 1);\n+  attr = find_attr (&XSTR (def, 0), 1);\n   if (attr->default_val)\n     {\n-      error_with_line (lineno, \"duplicate definition for attribute %s\",\n-\t\t       attr->name);\n+      error_at (info->loc, \"duplicate definition for attribute %s\",\n+\t\tattr->name);\n       message_at (attr->loc, \"previous definition\");\n       return;\n     }\n-  attr->loc = file_location (read_md_filename, lineno);\n+  attr->loc = info->loc;\n \n-  if (GET_CODE (exp) == DEFINE_ENUM_ATTR)\n+  if (GET_CODE (def) == DEFINE_ENUM_ATTR)\n     {\n-      attr->enum_name = XSTR (exp, 1);\n-      et = lookup_enum_type (XSTR (exp, 1));\n+      attr->enum_name = XSTR (def, 1);\n+      et = lookup_enum_type (XSTR (def, 1));\n       if (!et || !et->md_p)\n-\terror_with_line (lineno, \"No define_enum called `%s' defined\",\n-\t\t\t attr->name);\n+\terror_at (info->loc, \"No define_enum called `%s' defined\",\n+\t\t  attr->name);\n       if (et)\n \tfor (ev = et->values; ev; ev = ev->next)\n \t  add_attr_value (attr, ev->name);\n     }\n-  else if (*XSTR (exp, 1) == '\\0')\n+  else if (*XSTR (def, 1) == '\\0')\n     attr->is_numeric = 1;\n   else\n     {\n-      name_ptr = XSTR (exp, 1);\n+      name_ptr = XSTR (def, 1);\n       while ((p = next_comma_elt (&name_ptr)) != NULL)\n \tadd_attr_value (attr, p);\n     }\n \n-  if (GET_CODE (XEXP (exp, 2)) == CONST)\n+  if (GET_CODE (XEXP (def, 2)) == CONST)\n     {\n       attr->is_const = 1;\n       if (attr->is_numeric)\n-\terror_with_line (lineno,\n-\t\t\t \"constant attributes may not take numeric values\");\n+\terror_at (info->loc,\n+\t\t  \"constant attributes may not take numeric values\");\n \n       /* Get rid of the CONST node.  It is allowed only at top-level.  */\n-      XEXP (exp, 2) = XEXP (XEXP (exp, 2), 0);\n+      XEXP (def, 2) = XEXP (XEXP (def, 2), 0);\n     }\n \n   if (! strcmp_check (attr->name, length_str) && ! attr->is_numeric)\n-    error_with_line (lineno, \"`length' attribute must take numeric values\");\n+    error_at (info->loc, \"`length' attribute must take numeric values\");\n \n   /* Set up the default value.  */\n-  XEXP (exp, 2) = check_attr_value (XEXP (exp, 2), attr);\n-  attr->default_val = get_attr_value (XEXP (exp, 2), attr, -2);\n+  XEXP (def, 2) = check_attr_value (XEXP (def, 2), attr);\n+  attr->default_val = get_attr_value (XEXP (def, 2), attr, -2);\n }\n \n /* Given a pattern for DEFINE_PEEPHOLE or DEFINE_INSN, return the number of\n@@ -3258,31 +3259,32 @@ compares_alternatives_p (rtx exp)\n /* Process DEFINE_PEEPHOLE, DEFINE_INSN, and DEFINE_ASM_ATTRIBUTES.  */\n \n static void\n-gen_insn (rtx exp, int lineno)\n+gen_insn (md_rtx_info *info)\n {\n   struct insn_def *id;\n+  rtx def = info->def;\n \n   id = oballoc (struct insn_def);\n   id->next = defs;\n   defs = id;\n-  id->def = exp;\n-  id->loc = file_location (read_md_filename, lineno);\n+  id->def = def;\n+  id->loc = info->loc;\n \n-  switch (GET_CODE (exp))\n+  switch (GET_CODE (def))\n     {\n     case DEFINE_INSN:\n-      id->insn_code = insn_code_number;\n+      id->insn_code = info->index;\n       id->insn_index = insn_index_number;\n-      id->num_alternatives = count_alternatives (exp);\n+      id->num_alternatives = count_alternatives (def);\n       if (id->num_alternatives == 0)\n \tid->num_alternatives = 1;\n       id->vec_idx = 4;\n       break;\n \n     case DEFINE_PEEPHOLE:\n-      id->insn_code = insn_code_number;\n+      id->insn_code = info->index;\n       id->insn_index = insn_index_number;\n-      id->num_alternatives = count_alternatives (exp);\n+      id->num_alternatives = count_alternatives (def);\n       if (id->num_alternatives == 0)\n \tid->num_alternatives = 1;\n       id->vec_idx = 3;\n@@ -3305,16 +3307,16 @@ gen_insn (rtx exp, int lineno)\n    true or annul false is specified, and make a `struct delay_desc'.  */\n \n static void\n-gen_delay (rtx def, int lineno)\n+gen_delay (md_rtx_info *info)\n {\n   struct delay_desc *delay;\n   int i;\n \n+  rtx def = info->def;\n   if (XVECLEN (def, 1) % 3 != 0)\n     {\n-      error_with_line (lineno,\n-\t\t       \"number of elements in DEFINE_DELAY must\"\n-\t\t       \" be multiple of three\");\n+      error_at (info->loc, \"number of elements in DEFINE_DELAY must\"\n+\t\t\" be multiple of three\");\n       return;\n     }\n \n@@ -3330,7 +3332,7 @@ gen_delay (rtx def, int lineno)\n   delay->def = def;\n   delay->num = ++num_delays;\n   delay->next = delays;\n-  delay->loc = file_location (read_md_filename, lineno);\n+  delay->loc = info->loc;\n   delays = delay;\n }\n \n@@ -4723,14 +4725,14 @@ static size_t n_insn_reservs;\n /* Store information from a DEFINE_INSN_RESERVATION for future\n    attribute generation.  */\n static void\n-gen_insn_reserv (rtx def, int lineno)\n+gen_insn_reserv (md_rtx_info *info)\n {\n   struct insn_reserv *decl = oballoc (struct insn_reserv);\n-  file_location loc (read_md_filename, lineno);\n+  rtx def = info->def;\n \n   decl->name            = DEF_ATTR_STRING (XSTR (def, 0));\n   decl->default_latency = XINT (def, 1);\n-  decl->condexp         = check_attr_test (XEXP (def, 2), 0, loc);\n+  decl->condexp         = check_attr_test (XEXP (def, 2), 0, info->loc);\n   decl->insn_num        = n_insn_reservs;\n   decl->bypassed\t= false;\n   decl->next            = 0;\n@@ -4776,10 +4778,11 @@ gen_bypass_1 (const char *s, size_t len)\n }\n \n static void\n-gen_bypass (rtx def)\n+gen_bypass (md_rtx_info *info)\n {\n   const char *p, *base;\n \n+  rtx def = info->def;\n   for (p = base = XSTR (def, 1); *p; p++)\n     if (*p == ',')\n       {\n@@ -5150,11 +5153,10 @@ handle_arg (const char *arg)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   struct attr_desc *attr;\n   struct insn_def *id;\n-  rtx tem;\n   int i;\n+  int max_insn_code = 0;\n \n   progname = \"genattrtab\";\n \n@@ -5184,72 +5186,71 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while (1)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n     {\n-      int lineno;\n-\n-      desc = read_md_rtx (&lineno, &insn_code_number);\n-      if (desc == NULL)\n-\tbreak;\n-\n-      switch (GET_CODE (desc))\n+      switch (GET_CODE (info.def))\n \t{\n \tcase DEFINE_INSN:\n \tcase DEFINE_PEEPHOLE:\n \tcase DEFINE_ASM_ATTRIBUTES:\n-\t  gen_insn (desc, lineno);\n+\t  gen_insn (&info);\n \t  break;\n \n \tcase DEFINE_ATTR:\n \tcase DEFINE_ENUM_ATTR:\n-\t  gen_attr (desc, lineno);\n+\t  gen_attr (&info);\n \t  break;\n \n \tcase DEFINE_DELAY:\n-\t  gen_delay (desc, lineno);\n+\t  gen_delay (&info);\n \t  break;\n \n \tcase DEFINE_INSN_RESERVATION:\n-\t  gen_insn_reserv (desc, lineno);\n+\t  gen_insn_reserv (&info);\n \t  break;\n \n \tcase DEFINE_BYPASS:\n-\t  gen_bypass (desc);\n+\t  gen_bypass (&info);\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n-      if (GET_CODE (desc) != DEFINE_ASM_ATTRIBUTES)\n+      if (GET_CODE (info.def) != DEFINE_ASM_ATTRIBUTES)\n \tinsn_index_number++;\n+      max_insn_code = info.index;\n     }\n \n   if (have_error)\n     return FATAL_EXIT_CODE;\n \n-  insn_code_number++;\n+  max_insn_code++;\n \n   /* If we didn't have a DEFINE_ASM_ATTRIBUTES, make a null one.  */\n   if (! got_define_asm_attributes)\n     {\n-      tem = rtx_alloc (DEFINE_ASM_ATTRIBUTES);\n-      XVEC (tem, 0) = rtvec_alloc (0);\n-      gen_insn (tem, 0);\n+      md_rtx_info info;\n+      info.def = rtx_alloc (DEFINE_ASM_ATTRIBUTES);\n+      XVEC (info.def, 0) = rtvec_alloc (0);\n+      info.loc = file_location (\"<internal>\", 0);\n+      info.index = -1;\n+      gen_insn (&info);\n     }\n \n   /* Expand DEFINE_DELAY information into new attribute.  */\n   if (num_delays)\n     expand_delays ();\n \n   /* Make `insn_alternatives'.  */\n-  insn_alternatives = oballocvec (uint64_t, insn_code_number);\n+  insn_alternatives = oballocvec (uint64_t, max_insn_code);\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_alternatives[id->insn_code]\n \t= (((uint64_t) 1) << id->num_alternatives) - 1;\n \n   /* Make `insn_n_alternatives'.  */\n-  insn_n_alternatives = oballocvec (int, insn_code_number);\n+  insn_n_alternatives = oballocvec (int, max_insn_code);\n   for (id = defs; id; id = id->next)\n     if (id->insn_code >= 0)\n       insn_n_alternatives[id->insn_code] = id->num_alternatives;\n@@ -5278,7 +5279,7 @@ main (int argc, char **argv)\n   make_length_attrs ();\n \n   /* Perform any possible optimizations to speed up compilation.  */\n-  optimize_attrs ();\n+  optimize_attrs (max_insn_code);\n \n   /* Now write out all the `gen_attr_...' routines.  Do these before the\n      special routines so that they get defined before they are used.  */"}, {"sha": "5196d6800d1b3b1ca581541bb86ce53eff0425d4", "filename": "gcc/genautomata.c", "status": "modified", "additions": 100, "deletions": 103, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -1243,16 +1243,18 @@ get_str_vect (const char *str, int *els_num, int sep, int paren_p)\n    This gives information about a unit contained in CPU.  We fill a\n    struct unit_decl with information used later by `expand_automata'.  */\n static void\n-gen_cpu_unit (rtx def)\n+gen_cpu_unit (md_rtx_info *info)\n {\n   decl_t decl;\n   char **str_cpu_units;\n   int vect_length;\n   int i;\n \n+  rtx def = info->def;\n   str_cpu_units = get_str_vect (XSTR (def, 0), &vect_length, ',', FALSE);\n   if (str_cpu_units == NULL)\n-    fatal (\"invalid string `%s' in define_cpu_unit\", XSTR (def, 0));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 0), GET_RTX_NAME (GET_CODE (def)));\n   for (i = 0; i < vect_length; i++)\n     {\n       decl = XCREATENODE (struct decl);\n@@ -1272,17 +1274,19 @@ gen_cpu_unit (rtx def)\n    This gives information about a unit contained in CPU.  We fill a\n    struct unit_decl with information used later by `expand_automata'.  */\n static void\n-gen_query_cpu_unit (rtx def)\n+gen_query_cpu_unit (md_rtx_info *info)\n {\n   decl_t decl;\n   char **str_cpu_units;\n   int vect_length;\n   int i;\n \n+  rtx def = info->def;\n   str_cpu_units = get_str_vect (XSTR (def, 0), &vect_length, ',',\n \t\t\t\tFALSE);\n   if (str_cpu_units == NULL)\n-    fatal (\"invalid string `%s' in define_query_cpu_unit\", XSTR (def, 0));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 0), GET_RTX_NAME (GET_CODE (def)));\n   for (i = 0; i < vect_length; i++)\n     {\n       decl = XCREATENODE (struct decl);\n@@ -1301,7 +1305,7 @@ gen_query_cpu_unit (rtx def)\n    in a struct bypass_decl with information used later by\n    `expand_automata'.  */\n static void\n-gen_bypass (rtx def)\n+gen_bypass (md_rtx_info *info)\n {\n   decl_t decl;\n   char **out_patterns;\n@@ -1310,12 +1314,15 @@ gen_bypass (rtx def)\n   int in_length;\n   int i, j;\n \n+  rtx def = info->def;\n   out_patterns = get_str_vect (XSTR (def, 1), &out_length, ',', FALSE);\n   if (out_patterns == NULL)\n-    fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 1));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 1), GET_RTX_NAME (GET_CODE (def)));\n   in_patterns = get_str_vect (XSTR (def, 2), &in_length, ',', FALSE);\n   if (in_patterns == NULL)\n-    fatal (\"invalid string `%s' in define_bypass\", XSTR (def, 2));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 2), GET_RTX_NAME (GET_CODE (def)));\n   for (i = 0; i < out_length; i++)\n     for (j = 0; j < in_length; j++)\n       {\n@@ -1336,7 +1343,7 @@ gen_bypass (rtx def)\n    struct excl_rel_decl (excl) with information used later by\n    `expand_automata'.  */\n static void\n-gen_excl_set (rtx def)\n+gen_excl_set (md_rtx_info *info)\n {\n   decl_t decl;\n   char **first_str_cpu_units;\n@@ -1345,16 +1352,20 @@ gen_excl_set (rtx def)\n   int length;\n   int i;\n \n+  rtx def = info->def;\n   first_str_cpu_units\n     = get_str_vect (XSTR (def, 0), &first_vect_length, ',', FALSE);\n   if (first_str_cpu_units == NULL)\n-    fatal (\"invalid first string `%s' in exclusion_set\", XSTR (def, 0));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 0), GET_RTX_NAME (GET_CODE (def)));\n   second_str_cpu_units = get_str_vect (XSTR (def, 1), &length, ',',\n \t\t\t\t       FALSE);\n   if (second_str_cpu_units == NULL)\n-    fatal (\"invalid second string `%s' in exclusion_set\", XSTR (def, 1));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 1), GET_RTX_NAME (GET_CODE (def)));\n   length += first_vect_length;\n-  decl = XCREATENODEVAR (struct decl, sizeof (struct decl) + (length - 1) * sizeof (char *));\n+  decl = XCREATENODEVAR (struct decl, (sizeof (struct decl)\n+\t\t\t\t       + (length - 1) * sizeof (char *)));\n   decl->mode = dm_excl;\n   decl->pos = 0;\n   DECL_EXCL (decl)->all_names_num = length;\n@@ -1375,7 +1386,7 @@ gen_excl_set (rtx def)\n    We fill a struct unit_pattern_rel_decl with information used later\n    by `expand_automata'.  */\n static void\n-gen_presence_absence_set (rtx def, int presence_p, int final_p)\n+gen_presence_absence_set (md_rtx_info *info, int presence_p, int final_p)\n {\n   decl_t decl;\n   char **str_cpu_units;\n@@ -1386,27 +1397,17 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n   int patterns_length;\n   int i;\n \n+  rtx def = info->def;\n   str_cpu_units = get_str_vect (XSTR (def, 0), &cpu_units_length, ',',\n \t\t\t\tFALSE);\n   if (str_cpu_units == NULL)\n-    fatal ((presence_p\n-\t    ? (final_p\n-\t       ? \"invalid first string `%s' in final_presence_set\"\n-\t       : \"invalid first string `%s' in presence_set\")\n-\t    : (final_p\n-\t       ? \"invalid first string `%s' in final_absence_set\"\n-\t       : \"invalid first string `%s' in absence_set\")),\n-\t   XSTR (def, 0));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 0), GET_RTX_NAME (GET_CODE (def)));\n   str_pattern_lists = get_str_vect (XSTR (def, 1),\n \t\t\t\t    &patterns_length, ',', FALSE);\n   if (str_pattern_lists == NULL)\n-    fatal ((presence_p\n-\t    ? (final_p\n-\t       ? \"invalid second string `%s' in final_presence_set\"\n-\t       : \"invalid second string `%s' in presence_set\")\n-\t    : (final_p\n-\t       ? \"invalid second string `%s' in final_absence_set\"\n-\t       : \"invalid second string `%s' in absence_set\")), XSTR (def, 1));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 1), GET_RTX_NAME (GET_CODE (def)));\n   str_patterns = XOBNEWVEC (&irp, char **, patterns_length);\n   for (i = 0; i < patterns_length; i++)\n     {\n@@ -1439,13 +1440,13 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n \n /* Process a PRESENCE_SET.\n \n-    This gives information about a cpu unit reservation requirements.\n+   This gives information about a cpu unit reservation requirements.\n    We fill a struct unit_pattern_rel_decl (presence) with information\n    used later by `expand_automata'.  */\n static void\n-gen_presence_set (rtx def)\n+gen_presence_set (md_rtx_info *info)\n {\n-  gen_presence_absence_set (def, TRUE, FALSE);\n+  gen_presence_absence_set (info, TRUE, FALSE);\n }\n \n /* Process a FINAL_PRESENCE_SET.\n@@ -1454,9 +1455,9 @@ gen_presence_set (rtx def)\n    We fill a struct unit_pattern_rel_decl (presence) with information\n    used later by `expand_automata'.  */\n static void\n-gen_final_presence_set (rtx def)\n+gen_final_presence_set (md_rtx_info *info)\n {\n-  gen_presence_absence_set (def, TRUE, TRUE);\n+  gen_presence_absence_set (info, TRUE, TRUE);\n }\n \n /* Process an ABSENCE_SET.\n@@ -1465,9 +1466,9 @@ gen_final_presence_set (rtx def)\n    We fill a struct unit_pattern_rel_decl (absence) with information\n    used later by `expand_automata'.  */\n static void\n-gen_absence_set (rtx def)\n+gen_absence_set (md_rtx_info *info)\n {\n-  gen_presence_absence_set (def, FALSE, FALSE);\n+  gen_presence_absence_set (info, FALSE, FALSE);\n }\n \n /* Process a FINAL_ABSENCE_SET.\n@@ -1476,9 +1477,9 @@ gen_absence_set (rtx def)\n    We fill a struct unit_pattern_rel_decl (absence) with information\n    used later by `expand_automata'.  */\n static void\n-gen_final_absence_set (rtx def)\n+gen_final_absence_set (md_rtx_info *info)\n {\n-  gen_presence_absence_set (def, FALSE, TRUE);\n+  gen_presence_absence_set (info, FALSE, TRUE);\n }\n \n /* Process a DEFINE_AUTOMATON.\n@@ -1487,16 +1488,18 @@ gen_final_absence_set (rtx def)\n    recognizing pipeline hazards.  We fill a struct automaton_decl\n    with information used later by `expand_automata'.  */\n static void\n-gen_automaton (rtx def)\n+gen_automaton (md_rtx_info *info)\n {\n   decl_t decl;\n   char **str_automata;\n   int vect_length;\n   int i;\n \n+  rtx def = info->def;\n   str_automata = get_str_vect (XSTR (def, 0), &vect_length, ',', FALSE);\n   if (str_automata == NULL)\n-    fatal (\"invalid string `%s' in define_automaton\", XSTR (def, 0));\n+    fatal_at (info->loc, \"invalid string `%s' in %s\",\n+\t      XSTR (def, 0), GET_RTX_NAME (GET_CODE (def)));\n   for (i = 0; i < vect_length; i++)\n     {\n       decl = XCREATENODE (struct decl);\n@@ -1512,28 +1515,30 @@ gen_automaton (rtx def)\n    This gives information how to generate finite state automaton used\n    for recognizing pipeline hazards.  */\n static void\n-gen_automata_option (rtx def)\n+gen_automata_option (md_rtx_info *info)\n {\n-  if (strcmp (XSTR (def, 0), NO_MINIMIZATION_OPTION + 1) == 0)\n+  const char *option = XSTR (info->def, 0);\n+  if (strcmp (option, NO_MINIMIZATION_OPTION + 1) == 0)\n     no_minimization_flag = 1;\n-  else if (strcmp (XSTR (def, 0), TIME_OPTION + 1) == 0)\n+  else if (strcmp (option, TIME_OPTION + 1) == 0)\n     time_flag = 1;\n-  else if (strcmp (XSTR (def, 0), STATS_OPTION + 1) == 0)\n+  else if (strcmp (option, STATS_OPTION + 1) == 0)\n     stats_flag = 1;\n-  else if (strcmp (XSTR (def, 0), V_OPTION + 1) == 0)\n+  else if (strcmp (option, V_OPTION + 1) == 0)\n     v_flag = 1;\n-  else if (strcmp (XSTR (def, 0), W_OPTION + 1) == 0)\n+  else if (strcmp (option, W_OPTION + 1) == 0)\n     w_flag = 1;\n-  else if (strcmp (XSTR (def, 0), NDFA_OPTION + 1) == 0)\n+  else if (strcmp (option, NDFA_OPTION + 1) == 0)\n     ndfa_flag = 1;\n-  else if (strcmp (XSTR (def, 0), COLLAPSE_OPTION + 1) == 0)\n+  else if (strcmp (option, COLLAPSE_OPTION + 1) == 0)\n     collapse_flag = 1;\n-  else if (strcmp (XSTR (def, 0), NO_COMB_OPTION + 1) == 0)\n+  else if (strcmp (option, NO_COMB_OPTION + 1) == 0)\n     no_comb_flag = 1;\n-  else if (strcmp (XSTR (def, 0), PROGRESS_OPTION + 1) == 0)\n+  else if (strcmp (option, PROGRESS_OPTION + 1) == 0)\n     progress_flag = 1;\n   else\n-    fatal (\"invalid option `%s' in automata_option\", XSTR (def, 0));\n+    fatal_at (info->loc, \"invalid option `%s' in %s\",\n+\t      option, GET_RTX_NAME (GET_CODE (info->def)));\n }\n \n /* Name in reservation to denote absence reservation.  */\n@@ -1703,10 +1708,11 @@ gen_regexp (const char *str)\n    in a struct reserv_decl with information used later by\n    `expand_automata'.  */\n static void\n-gen_reserv (rtx def)\n+gen_reserv (md_rtx_info *info)\n {\n   decl_t decl;\n \n+  rtx def = info->def;\n   decl = XCREATENODE (struct decl);\n   decl->mode = dm_reserv;\n   decl->pos = 0;\n@@ -1721,10 +1727,11 @@ gen_reserv (rtx def)\n    insn.  We fill a struct insn_reserv_decl with information used\n    later by `expand_automata'.  */\n static void\n-gen_insn_reserv (rtx def)\n+gen_insn_reserv (md_rtx_info *info)\n {\n   decl_t decl;\n \n+  rtx def = info->def;\n   decl = XCREATENODE (struct decl);\n   decl->mode = dm_insn_reserv;\n   decl->pos = 0;\n@@ -9587,77 +9594,67 @@ write_automata (void)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-\n   progname = \"genautomata\";\n \n   if (!init_rtx_reader_args_cb (argc, argv, parse_automata_opt))\n     return (FATAL_EXIT_CODE);\n \n   initiate_automaton_gen (argv);\n-  while (1)\n-    {\n-      int lineno;\n-      int insn_code_number;\n-\n-      desc = read_md_rtx (&lineno, &insn_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_CPU_UNIT:\n+\tgen_cpu_unit (&info);\n \tbreak;\n \n-      switch (GET_CODE (desc))\n-\t{\n-\tcase DEFINE_CPU_UNIT:\n-\t  gen_cpu_unit (desc);\n-\t  break;\n-\n-\tcase DEFINE_QUERY_CPU_UNIT:\n-\t  gen_query_cpu_unit (desc);\n-\t  break;\n+      case DEFINE_QUERY_CPU_UNIT:\n+\tgen_query_cpu_unit (&info);\n+\tbreak;\n \n-\tcase DEFINE_BYPASS:\n-\t  gen_bypass (desc);\n-\t  break;\n+      case DEFINE_BYPASS:\n+\tgen_bypass (&info);\n+\tbreak;\n \n-\tcase EXCLUSION_SET:\n-\t  gen_excl_set (desc);\n-\t  break;\n+      case EXCLUSION_SET:\n+\tgen_excl_set (&info);\n+\tbreak;\n \n-\tcase PRESENCE_SET:\n-\t  gen_presence_set (desc);\n-\t  break;\n+      case PRESENCE_SET:\n+\tgen_presence_set (&info);\n+\tbreak;\n \n-\tcase FINAL_PRESENCE_SET:\n-\t  gen_final_presence_set (desc);\n-\t  break;\n+      case FINAL_PRESENCE_SET:\n+\tgen_final_presence_set (&info);\n+\tbreak;\n \n-\tcase ABSENCE_SET:\n-\t  gen_absence_set (desc);\n-\t  break;\n+      case ABSENCE_SET:\n+\tgen_absence_set (&info);\n+\tbreak;\n \n-\tcase FINAL_ABSENCE_SET:\n-\t  gen_final_absence_set (desc);\n-\t  break;\n+      case FINAL_ABSENCE_SET:\n+\tgen_final_absence_set (&info);\n+\tbreak;\n \n-\tcase DEFINE_AUTOMATON:\n-\t  gen_automaton (desc);\n-\t  break;\n+      case DEFINE_AUTOMATON:\n+\tgen_automaton (&info);\n+\tbreak;\n \n-\tcase AUTOMATA_OPTION:\n-\t  gen_automata_option (desc);\n-\t  break;\n+      case AUTOMATA_OPTION:\n+\tgen_automata_option (&info);\n+\tbreak;\n \n-\tcase DEFINE_RESERVATION:\n-\t  gen_reserv (desc);\n-\t  break;\n+      case DEFINE_RESERVATION:\n+\tgen_reserv (&info);\n+\tbreak;\n \n-\tcase DEFINE_INSN_RESERVATION:\n-\t  gen_insn_reserv (desc);\n-\t  break;\n+      case DEFINE_INSN_RESERVATION:\n+\tgen_insn_reserv (&info);\n+\tbreak;\n \n-\tdefault:\n-\t  break;\n-\t}\n-    }\n+      default:\n+\tbreak;\n+      }\n \n   if (have_error)\n     return FATAL_EXIT_CODE;"}, {"sha": "b9d65a2c8bc7d9e0f61ab6e5188f9fa2ce3e1d3e", "filename": "gcc/gencodes.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgencodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgencodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencodes.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -29,10 +29,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gensupport.h\"\n \n static void\n-gen_insn (rtx insn, int code)\n+gen_insn (md_rtx_info *info)\n {\n-  const char *name = XSTR (insn, 0);\n-  int truth = maybe_eval_c_test (XSTR (insn, 2));\n+  const char *name = XSTR (info->def, 0);\n+  int truth = maybe_eval_c_test (XSTR (info->def, 2));\n \n   /* Don't mention instructions whose names are the null string\n      or begin with '*'.  They are in the machine description just\n@@ -42,14 +42,13 @@ gen_insn (rtx insn, int code)\n       if (truth == 0)\n \tprintf (\"#define CODE_FOR_%s CODE_FOR_nothing\\n\", name);\n       else\n-\tprintf (\"  CODE_FOR_%s = %d,\\n\", name, code);\n+\tprintf (\"  CODE_FOR_%s = %d,\\n\", name, info->index);\n     }\n }\n \n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   int last = 1;\n \n   progname = \"gencodes\";\n@@ -73,20 +72,18 @@ enum insn_code {\\n\\\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no;\n-      int insn_code_number;\n-\n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+      case DEFINE_EXPAND:\n+\tgen_insn (&info);\n+\tlast = info.index + 1;\n \tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n-\t{\n-\t  gen_insn (desc, insn_code_number);\n-\t  last = insn_code_number + 1;\n-\t}\n+      default:\n+\tbreak;\n     }\n \n   printf (\"  LAST_INSN_CODE = %d\\n\\"}, {"sha": "23109eeb595c6258d5c1e375edb3ddcecadf9670", "filename": "gcc/genconditions.c", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -212,42 +212,36 @@ write_writer (void)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-  int pattern_lineno; /* not used */\n-  int code;\n-\n   progname = \"genconditions\";\n \n   if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   /* Read the machine description.  */\n-  while (1)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n     {\n-      desc = read_md_rtx (&pattern_lineno, &code);\n-      if (desc == NULL)\n-\tbreak;\n-\n+      rtx def = info.def;\n       /* N.B. define_insn_and_split, define_cond_exec are handled\n \t entirely within read_md_rtx; we never see them.  */\n-      switch (GET_CODE (desc))\n+      switch (GET_CODE (def))\n \t{\n-\tdefault:\n-\t  break;\n-\n \tcase DEFINE_INSN:\n \tcase DEFINE_EXPAND:\n-\t  add_c_test (XSTR (desc, 2), -1);\n+\t  add_c_test (XSTR (def, 2), -1);\n \t  /* except.h needs to know whether there is an eh_return\n \t     pattern in the machine description.  */\n-\t  if (!strcmp (XSTR (desc, 0), \"eh_return\"))\n+\t  if (!strcmp (XSTR (def, 0), \"eh_return\"))\n \t    saw_eh_return = 1;\n \t  break;\n \n \tcase DEFINE_SPLIT:\n \tcase DEFINE_PEEPHOLE:\n \tcase DEFINE_PEEPHOLE2:\n-\t  add_c_test (XSTR (desc, 1), -1);\n+\t  add_c_test (XSTR (def, 1), -1);\n+\t  break;\n+\n+\tdefault:\n \t  break;\n \t}\n     }"}, {"sha": "ac16c5ba8b297d149b89296122b9a0e86c794d0f", "filename": "gcc/genconfig.c", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -51,11 +51,6 @@ static int clobbers_seen_this_insn;\n static int dup_operands_seen_this_insn;\n \n static void walk_insn_part (rtx, int, int);\n-static void gen_insn (rtx);\n-static void gen_expand (rtx);\n-static void gen_split (rtx);\n-static void gen_peephole (rtx);\n-static void gen_peephole2 (rtx);\n \n /* RECOG_P will be nonzero if this pattern was seen in a context where it will\n    be used to recognize, rather than just generate an insn.\n@@ -179,11 +174,12 @@ walk_insn_part (rtx part, int recog_p, int non_pc_set_src)\n }\n \n static void\n-gen_insn (rtx insn)\n+gen_insn (md_rtx_info *info)\n {\n   int i;\n \n   /* Walk the insn pattern to gather the #define's status.  */\n+  rtx insn = info->def;\n   clobbers_seen_this_insn = 0;\n   dup_operands_seen_this_insn = 0;\n   if (XVEC (insn, 1) != 0)\n@@ -199,14 +195,15 @@ gen_insn (rtx insn)\n /* Similar but scan a define_expand.  */\n \n static void\n-gen_expand (rtx insn)\n+gen_expand (md_rtx_info *info)\n {\n   int i;\n \n   /* Walk the insn pattern to gather the #define's status.  */\n \n   /* Note that we don't bother recording the number of MATCH_DUPs\n      that occur in a gen_expand, because only reload cares about that.  */\n+  rtx insn = info->def;\n   if (XVEC (insn, 1) != 0)\n     for (i = 0; i < XVECLEN (insn, 1); i++)\n       {\n@@ -225,12 +222,13 @@ gen_expand (rtx insn)\n /* Similar but scan a define_split.  */\n \n static void\n-gen_split (rtx split)\n+gen_split (md_rtx_info *info)\n {\n   int i;\n \n   /* Look through the patterns that are matched\n      to compute the maximum operand number.  */\n+  rtx split = info->def;\n   for (i = 0; i < XVECLEN (split, 0); i++)\n     walk_insn_part (XVECEXP (split, 0, i), 1, 0);\n   /* Look at the number of insns this insn could split into.  */\n@@ -239,23 +237,25 @@ gen_split (rtx split)\n }\n \n static void\n-gen_peephole (rtx peep)\n+gen_peephole (md_rtx_info *info)\n {\n   int i;\n \n   /* Look through the patterns that are matched\n      to compute the maximum operand number.  */\n+  rtx peep = info->def;\n   for (i = 0; i < XVECLEN (peep, 0); i++)\n     walk_insn_part (XVECEXP (peep, 0, i), 1, 0);\n }\n \n static void\n-gen_peephole2 (rtx peep)\n+gen_peephole2 (md_rtx_info *info)\n {\n   int i, n;\n \n   /* Look through the patterns that are matched\n      to compute the maximum operand number.  */\n+  rtx peep = info->def;\n   for (i = XVECLEN (peep, 0) - 1; i >= 0; --i)\n     walk_insn_part (XVECEXP (peep, 0, i), 1, 0);\n \n@@ -271,8 +271,6 @@ gen_peephole2 (rtx peep)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-\n   progname = \"genconfig\";\n \n   if (!init_rtx_reader_args (argc, argv))\n@@ -291,42 +289,35 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no, insn_code_number = 0;\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+\tgen_insn (&info);\n+\tbreak;\n \n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+      case DEFINE_EXPAND:\n+\tgen_expand (&info);\n \tbreak;\n \n-      switch (GET_CODE (desc))\n-\t{\n-  \t  case DEFINE_INSN:\n-\t    gen_insn (desc);\n-\t    break;\n-\n-\t  case DEFINE_EXPAND:\n-\t    gen_expand (desc);\n-\t    break;\n-\n-\t  case DEFINE_SPLIT:\n-\t    gen_split (desc);\n-\t    break;\n-\n-\t  case DEFINE_PEEPHOLE2:\n-\t    have_peephole2_flag = 1;\n-\t    gen_peephole2 (desc);\n-\t    break;\n-\n-\t  case DEFINE_PEEPHOLE:\n-\t    have_peephole_flag = 1;\n-\t    gen_peephole (desc);\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t}\n-    }\n+      case DEFINE_SPLIT:\n+\tgen_split (&info);\n+\tbreak;\n+\n+      case DEFINE_PEEPHOLE2:\n+\thave_peephole2_flag = 1;\n+\tgen_peephole2 (&info);\n+\tbreak;\n+\n+      case DEFINE_PEEPHOLE:\n+\thave_peephole_flag = 1;\n+\tgen_peephole (&info);\n+\tbreak;\n+\n+      default:\n+\tbreak;\n+      }\n \n   printf (\"#define MAX_RECOG_OPERANDS %d\\n\", max_recog_operands + 1);\n   printf (\"#define MAX_DUP_OPERANDS %d\\n\", max_dup_operands);"}, {"sha": "2d2fb629023b46926472906ad7ba2a3f1b5ebb71", "filename": "gcc/genemit.c", "status": "modified", "additions": 44, "deletions": 55, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -28,9 +28,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gensupport.h\"\n \n \n-static int insn_code_number;\n-static int insn_index_number;\n-\n /* Data structure for recording the patterns of insns that have CLOBBERs.\n    We use this to output a function that adds these CLOBBERs to a\n    previously-allocated PARALLEL expression.  */\n@@ -299,7 +296,7 @@ gen_emit_seq (rtvec vec, char *used)\n /* Generate the `gen_...' function for a DEFINE_INSN.  */\n \n static void\n-gen_insn (rtx insn, int lineno)\n+gen_insn (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n   int i;\n@@ -308,6 +305,7 @@ gen_insn (rtx insn, int lineno)\n      registers or MATCH_SCRATCHes.  If so, store away the information for\n      later.  */\n \n+  rtx insn = info->def;\n   if (XVEC (insn, 1))\n     {\n       int has_hard_reg = 0;\n@@ -329,7 +327,7 @@ gen_insn (rtx insn, int lineno)\n \t  struct clobber_ent *link = XNEW (struct clobber_ent);\n \t  int j;\n \n-\t  link->code_number = insn_code_number;\n+\t  link->code_number = info->index;\n \n \t  /* See if any previous CLOBBER_LIST entry is the same as this\n \t     one.  */\n@@ -383,12 +381,12 @@ gen_insn (rtx insn, int lineno)\n   if (XSTR (insn, 0)[0] == 0 || XSTR (insn, 0)[0] == '*')\n     return;\n \n-  printf (\"/* %s:%d */\\n\", read_md_filename, lineno);\n+  printf (\"/* %s:%d */\\n\", info->loc.filename, info->loc.lineno);\n \n   /* Find out how many operands this function has.  */\n   get_pattern_stats (&stats, XVEC (insn, 1));\n   if (stats.max_dup_opno > stats.max_opno)\n-    fatal (\"match_dup operand number has no match_operand\");\n+    fatal_at (info->loc, \"match_dup operand number has no match_operand\");\n \n   /* Output the function name and argument declarations.  */\n   printf (\"rtx\\ngen_%s (\", XSTR (insn, 0));\n@@ -419,16 +417,18 @@ gen_insn (rtx insn, int lineno)\n /* Generate the `gen_...' function for a DEFINE_EXPAND.  */\n \n static void\n-gen_expand (rtx expand)\n+gen_expand (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n   int i;\n   char *used;\n \n+  rtx expand = info->def;\n   if (strlen (XSTR (expand, 0)) == 0)\n-    fatal (\"define_expand lacks a name\");\n+    fatal_at (info->loc, \"define_expand lacks a name\");\n   if (XVEC (expand, 1) == 0)\n-    fatal (\"define_expand for %s lacks a pattern\", XSTR (expand, 0));\n+    fatal_at (info->loc, \"define_expand for %s lacks a pattern\",\n+\t      XSTR (expand, 0));\n \n   /* Find out how many operands this function has.  */\n   get_pattern_stats (&stats, XVEC (expand, 1));\n@@ -517,21 +517,22 @@ gen_expand (rtx expand)\n /* Like gen_expand, but generates insns resulting from splitting SPLIT.  */\n \n static void\n-gen_split (rtx split)\n+gen_split (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n   int i;\n+  rtx split = info->def;\n   const char *const name =\n     ((GET_CODE (split) == DEFINE_PEEPHOLE2) ? \"peephole2\" : \"split\");\n   const char *unused;\n   char *used;\n \n   if (XVEC (split, 0) == 0)\n-    fatal (\"define_%s (definition %d) lacks a pattern\", name,\n-\t   insn_index_number);\n+    fatal_at (info->loc, \"%s lacks a pattern\",\n+\t      GET_RTX_NAME (GET_CODE (split)));\n   else if (XVEC (split, 2) == 0)\n-    fatal (\"define_%s (definition %d) lacks a replacement pattern\", name,\n-\t   insn_index_number);\n+    fatal_at (info->loc, \"%s lacks a replacement pattern\",\n+\t      GET_RTX_NAME (GET_CODE (split)));\n \n   /* Find out how many operands this function has.  */\n \n@@ -543,17 +544,18 @@ gen_split (rtx split)\n   if (GET_CODE (split) == DEFINE_PEEPHOLE2)\n     {\n       printf (\"extern rtx_insn *gen_%s_%d (rtx_insn *, rtx *);\\n\",\n-\t      name, insn_code_number);\n-      printf (\"rtx_insn *\\ngen_%s_%d (rtx_insn *curr_insn ATTRIBUTE_UNUSED, rtx *operands%s)\\n\",\n-\t      name, insn_code_number, unused);\n+\t      name, info->index);\n+      printf (\"rtx_insn *\\ngen_%s_%d (rtx_insn *curr_insn ATTRIBUTE_UNUSED,\"\n+\t      \" rtx *operands%s)\\n\",\n+\t      name, info->index, unused);\n     }\n   else\n     {\n       printf (\"extern rtx_insn *gen_split_%d (rtx_insn *, rtx *);\\n\",\n-\t      insn_code_number);\n+\t      info->index);\n       printf (\"rtx_insn *\\ngen_split_%d \"\n \t      \"(rtx_insn *curr_insn ATTRIBUTE_UNUSED, rtx *operands%s)\\n\",\n-\t      insn_code_number, unused);\n+\t      info->index, unused);\n     }\n   printf (\"{\\n\");\n \n@@ -567,7 +569,7 @@ gen_split (rtx split)\n \n   printf (\"  if (dump_file)\\n\");\n   printf (\"    fprintf (dump_file, \\\"Splitting with gen_%s_%d\\\\n\\\");\\n\",\n-\t  name, insn_code_number);\n+\t  name, info->index);\n \n   printf (\"  start_sequence ();\\n\");\n \n@@ -725,8 +727,6 @@ output_peephole2_scratches (rtx split)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-\n   progname = \"genemit\";\n \n   if (!init_rtx_reader_args (argc, argv))\n@@ -735,9 +735,6 @@ main (int argc, char **argv)\n   /* Assign sequential codes to all entries in the machine description\n      in parallel with the tables in insn-output.c.  */\n \n-  insn_code_number = 0;\n-  insn_index_number = 0;\n-\n   printf (\"/* Generated automatically by the program `genemit'\\n\\\n from the machine description file `md'.  */\\n\\n\");\n \n@@ -780,40 +777,32 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no;\n-\n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+\tgen_insn (&info);\n \tbreak;\n \n-      switch (GET_CODE (desc))\n-\t{\n-\tcase DEFINE_INSN:\n-\t  gen_insn (desc, line_no);\n-\t  break;\n-\n-\tcase DEFINE_EXPAND:\n-\t  printf (\"/* %s:%d */\\n\", read_md_filename, line_no);\n-\t  gen_expand (desc);\n-\t  break;\n+      case DEFINE_EXPAND:\n+\tprintf (\"/* %s:%d */\\n\", info.loc.filename, info.loc.lineno);\n+\tgen_expand (&info);\n+\tbreak;\n \n-\tcase DEFINE_SPLIT:\n-\t  printf (\"/* %s:%d */\\n\", read_md_filename, line_no);\n-\t  gen_split (desc);\n-\t  break;\n+      case DEFINE_SPLIT:\n+\tprintf (\"/* %s:%d */\\n\", info.loc.filename, info.loc.lineno);\n+\tgen_split (&info);\n+\tbreak;\n \n-\tcase DEFINE_PEEPHOLE2:\n-\t  printf (\"/* %s:%d */\\n\", read_md_filename, line_no);\n-\t  gen_split (desc);\n-\t  break;\n+      case DEFINE_PEEPHOLE2:\n+\tprintf (\"/* %s:%d */\\n\", info.loc.filename, info.loc.lineno);\n+\tgen_split (&info);\n+\tbreak;\n \n-\tdefault:\n-\t  break;\n-\t}\n-      ++insn_index_number;\n-    }\n+      default:\n+\tbreak;\n+      }\n \n   /* Write out the routines to add CLOBBERs to a pattern and say whether they\n      clobber a hard reg.  */"}, {"sha": "fe97701472909c47af77ef963d8f2d0385a8d4fd", "filename": "gcc/genextract.c", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -75,13 +75,11 @@ struct accum_extract\n   vec<char> pathstr;\n };\n \n-int line_no;\n-\n /* Forward declarations.  */\n-static void walk_rtx (rtx, struct accum_extract *);\n+static void walk_rtx (md_rtx_info *, rtx, struct accum_extract *);\n \n static void\n-gen_insn (rtx insn, int insn_code_number)\n+gen_insn (md_rtx_info *info)\n {\n   int i;\n   unsigned int op_count, dup_count, j;\n@@ -97,18 +95,19 @@ gen_insn (rtx insn, int insn_code_number)\n   /* Walk the insn's pattern, remembering at all times the path\n      down to the walking point.  */\n \n+  rtx insn = info->def;\n   if (XVECLEN (insn, 1) == 1)\n-    walk_rtx (XVECEXP (insn, 1, 0), &acc);\n+    walk_rtx (info, XVECEXP (insn, 1, 0), &acc);\n   else\n     for (i = XVECLEN (insn, 1) - 1; i >= 0; i--)\n       {\n \tacc.pathstr.safe_push ('a' + i);\n-\twalk_rtx (XVECEXP (insn, 1, i), &acc);\n+\twalk_rtx (info, XVECEXP (insn, 1, i), &acc);\n \tacc.pathstr.pop ();\n       }\n \n   link = XNEW (struct code_ptr);\n-  link->insn_code = insn_code_number;\n+  link->insn_code = info->index;\n \n   /* See if we find something that already had this extraction method.  */\n \n@@ -178,15 +177,17 @@ gen_insn (rtx insn, int insn_code_number)\n /* Helper subroutine of walk_rtx: given a vec<locstr>, an index, and a\n    string, insert the string at the index, which should either already\n    exist and be NULL, or not yet exist within the vector.  In the latter\n-   case the vector is enlarged as appropriate.  */\n+   case the vector is enlarged as appropriate.  INFO describes the\n+   containing define_* expression.  */\n static void\n-VEC_safe_set_locstr (vec<locstr> *vp, unsigned int ix, char *str)\n+VEC_safe_set_locstr (md_rtx_info *info, vec<locstr> *vp,\n+\t\t     unsigned int ix, char *str)\n {\n   if (ix < (*vp).length ())\n     {\n       if ((*vp)[ix])\n \t{\n-\t  message_with_line (line_no, \"repeated operand number %d\", ix);\n+\t  message_at (info->loc, \"repeated operand number %d\", ix);\n \t  have_error = 1;\n \t}\n       else\n@@ -213,7 +214,7 @@ VEC_char_to_string (vec<char> v)\n }\n \n static void\n-walk_rtx (rtx x, struct accum_extract *acc)\n+walk_rtx (md_rtx_info *info, rtx x, struct accum_extract *acc)\n {\n   RTX_CODE code;\n   int i, len, base;\n@@ -233,20 +234,20 @@ walk_rtx (rtx x, struct accum_extract *acc)\n \n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n-      VEC_safe_set_locstr (&acc->oplocs, XINT (x, 0),\n+      VEC_safe_set_locstr (info, &acc->oplocs, XINT (x, 0),\n \t\t\t   VEC_char_to_string (acc->pathstr));\n       break;\n \n     case MATCH_OPERATOR:\n     case MATCH_PARALLEL:\n-      VEC_safe_set_locstr (&acc->oplocs, XINT (x, 0),\n+      VEC_safe_set_locstr (info, &acc->oplocs, XINT (x, 0),\n \t\t\t   VEC_char_to_string (acc->pathstr));\n \n       base = (code == MATCH_OPERATOR ? '0' : 'a');\n       for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n \t{\n \t  acc->pathstr.safe_push (base + i);\n-\t  walk_rtx (XVECEXP (x, 2, i), acc);\n+\t  walk_rtx (info, XVECEXP (x, 2, i), acc);\n \t  acc->pathstr.pop ();\n         }\n       return;\n@@ -264,7 +265,7 @@ walk_rtx (rtx x, struct accum_extract *acc)\n       for (i = XVECLEN (x, 1) - 1; i >= 0; i--)\n         {\n \t  acc->pathstr.safe_push (base + i);\n-\t  walk_rtx (XVECEXP (x, 1, i), acc);\n+\t  walk_rtx (info, XVECEXP (x, 1, i), acc);\n \t  acc->pathstr.pop ();\n         }\n       return;\n@@ -280,7 +281,7 @@ walk_rtx (rtx x, struct accum_extract *acc)\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n \t{\n \t  acc->pathstr.safe_push ('0' + i);\n-\t  walk_rtx (XEXP (x, i), acc);\n+\t  walk_rtx (info, XEXP (x, i), acc);\n \t  acc->pathstr.pop ();\n \t}\n       else if (fmt[i] == 'E')\n@@ -289,7 +290,7 @@ walk_rtx (rtx x, struct accum_extract *acc)\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n \t      acc->pathstr.safe_push ('a' + j);\n-\t      walk_rtx (XVECEXP (x, i, j), acc);\n+\t      walk_rtx (info, XVECEXP (x, i, j), acc);\n \t      acc->pathstr.pop ();\n \t    }\n \t}\n@@ -394,12 +395,10 @@ insn_extract (rtx_insn *insn)\\n{\\n\\\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   unsigned int i;\n   struct extraction *p;\n   struct code_ptr *link;\n   const char *name;\n-  int insn_code_number;\n \n   progname = \"genextract\";\n \n@@ -408,19 +407,26 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while ((desc = read_md_rtx (&line_no, &insn_code_number)) != NULL)\n-    {\n-       if (GET_CODE (desc) == DEFINE_INSN)\n-\t gen_insn (desc, insn_code_number);\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+\tgen_insn (&info);\n+\tbreak;\n \n-      else if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n+      case DEFINE_PEEPHOLE:\n \t{\n \t  struct code_ptr *link = XNEW (struct code_ptr);\n \n-\t  link->insn_code = insn_code_number;\n+\t  link->insn_code = info.index;\n \t  link->next = peepholes;\n \t  peepholes = link;\n \t}\n+\tbreak;\n+\n+      default:\n+\tbreak;\n     }\n \n   if (have_error)"}, {"sha": "e67a48ba83f126a62ca19fd2f61706a2bb70d487", "filename": "gcc/genflags.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -43,7 +43,6 @@ static void max_operand_1 (rtx);\n static int num_operands (rtx);\n static void gen_proto (rtx);\n static void gen_macro (const char *, int, int);\n-static void gen_insn (int, rtx);\n \n /* Count the number of match_operand's found.  */\n \n@@ -187,8 +186,9 @@ gen_proto (rtx insn)\n }\n \n static void\n-gen_insn (int line_no, rtx insn)\n+gen_insn (md_rtx_info *info)\n {\n+  rtx insn = info->def;\n   const char *name = XSTR (insn, 0);\n   const char *p;\n   const char *lt, *gt;\n@@ -198,18 +198,15 @@ gen_insn (int line_no, rtx insn)\n   lt = strchr (name, '<');\n   if (lt && strchr (lt + 1, '>'))\n     {\n-      message_with_line (line_no, \"unresolved iterator\");\n-      have_error = 1;\n+      error_at (info->loc, \"unresolved iterator\");\n       return;\n     }\n \n   gt = strchr (name, '>');\n   if (lt || gt)\n     {\n-      message_with_line (line_no,\n-\t\t\t \"unmatched angle brackets, likely \"\n-\t\t\t \"an error in iterator syntax\");\n-      have_error = 1;\n+      error_at (info->loc, \"unmatched angle brackets, likely \"\n+\t\t\"an error in iterator syntax\");\n       return;\n     }\n \n@@ -249,7 +246,6 @@ gen_insn (int line_no, rtx insn)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   rtx dummy;\n   rtx *insns;\n   rtx *insn_ptr;\n@@ -271,16 +267,18 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no, insn_code_number = 0;\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+      case DEFINE_EXPAND:\n+\tgen_insn (&info);\n+\tbreak;\n \n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+      default:\n \tbreak;\n-      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n-\tgen_insn (line_no, desc);\n-    }\n+      }\n \n   /* Print out the prototypes now.  */\n   dummy = (rtx) 0;"}, {"sha": "606d3906efbf4813a915b8dc5df5427b71d2b12e", "filename": "gcc/genmddump.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenmddump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenmddump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmddump.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -40,22 +40,17 @@ extern int main (int, char **);\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-  int pattern_lineno;\n-  int code; /* not used */\n   progname = \"genmddump\";\n \n   if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n   /* Read the machine description.  */\n-  while (1)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n     {\n-      desc = read_md_rtx (&pattern_lineno, &code);\n-      if (desc == NULL)\n-\tbreak;\n-      printf (\";; %s: %d\\n\", read_md_filename, pattern_lineno);\n-      print_inline_rtx (stdout, desc, 0);\n+      printf (\";; %s: %d\\n\", info.loc.filename, info.loc.lineno);\n+      print_inline_rtx (stdout, info.def, 0);\n       printf (\"\\n\\n\");\n     }\n "}, {"sha": "3ff1894ec4f23002d637956286715e3b17d6bc3d", "filename": "gcc/genopinit.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -243,8 +243,9 @@ match_pattern (pattern *p, const char *name, const char *pat)\n }\n \n static void\n-gen_insn (rtx insn)\n+gen_insn (md_rtx_info *info)\n {\n+  rtx insn = info->def;\n   const char *name = XSTR (insn, 0);\n   pattern p;\n   unsigned pindex;\n@@ -346,15 +347,18 @@ main (int argc, char **argv)\n   s_file = open_outfile (source_file_name);\n \n   /* Read the machine description.  */\n-  while (1)\n-    {\n-      int line_no, insn_code_number = 0;\n-      rtx desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+      case DEFINE_EXPAND:\n+\tgen_insn (&info);\n \tbreak;\n-      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n-\tgen_insn (desc);\n-    }\n+\n+      default:\n+\tbreak;\n+      }\n \n   /* Sort the collected patterns.  */\n   patterns.qsort (pattern_cmp);"}, {"sha": "cd7f12906b515ae006fcf5e3b9c6b2f5f0f2d0d6", "filename": "gcc/genoutput.c", "status": "modified", "additions": 57, "deletions": 73, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -103,12 +103,6 @@ static char general_mem[] = { TARGET_MEM_CONSTRAINT, 0 };\n static int n_occurrences\t\t(int, const char *);\n static const char *strip_whitespace\t(const char *);\n \n-/* insns in the machine description are assigned sequential code numbers\n-   that are used by insn-recog.c (produced by genrecog) to communicate\n-   to insn-output.c (produced by this program).  */\n-\n-static int next_code_number;\n-\n /* This counts all operands used in the md file.  The first is null.  */\n \n static int next_operand_number = 1;\n@@ -184,10 +178,6 @@ static void place_operands (struct data *);\n static void process_template (struct data *, const char *);\n static void validate_insn_alternatives (struct data *);\n static void validate_insn_operands (struct data *);\n-static void gen_insn (rtx, int);\n-static void gen_peephole (rtx, int);\n-static void gen_expand (rtx, int);\n-static void gen_split (rtx, int);\n \n struct constraint_data\n {\n@@ -205,7 +195,7 @@ static struct constraint_data *\n constraints_by_letter_table[1 << CHAR_BIT];\n \n static int mdep_constraint_len (const char *, file_location, int);\n-static void note_constraint (rtx, int);\n+static void note_constraint (md_rtx_info *);\n \f\n static void\n output_prologue (void)\n@@ -861,14 +851,15 @@ validate_optab_operands (struct data *d)\n    a hairy output action, output a function for now.  */\n \n static void\n-gen_insn (rtx insn, int lineno)\n+gen_insn (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n+  rtx insn = info->def;\n   data *d = new data;\n   int i;\n \n-  d->code_number = next_code_number;\n-  d->loc = file_location (read_md_filename, lineno);\n+  d->code_number = info->index;\n+  d->loc = info->loc;\n   if (XSTR (insn, 0)[0])\n     d->name = XSTR (insn, 0);\n   else\n@@ -902,14 +893,14 @@ gen_insn (rtx insn, int lineno)\n    If the insn has a hairy output action, output it now.  */\n \n static void\n-gen_peephole (rtx peep, int lineno)\n+gen_peephole (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n   data *d = new data;\n   int i;\n \n-  d->code_number = next_code_number;\n-  d->loc = file_location (read_md_filename, lineno);\n+  d->code_number = info->index;\n+  d->loc = info->loc;\n   d->name = 0;\n \n   /* Build up the list in the same order as the insns are seen\n@@ -923,6 +914,7 @@ gen_peephole (rtx peep, int lineno)\n   /* Get the number of operands by scanning all the patterns of the\n      peephole optimizer.  But ignore all the rest of the information\n      thus obtained.  */\n+  rtx peep = info->def;\n   for (i = 0; i < XVECLEN (peep, 0); i++)\n     scan_operands (d, XVECEXP (peep, 0, i), 0, 0);\n \n@@ -940,14 +932,15 @@ gen_peephole (rtx peep, int lineno)\n    only for the purposes of `insn_gen_function'.  */\n \n static void\n-gen_expand (rtx insn, int lineno)\n+gen_expand (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n+  rtx insn = info->def;\n   data *d = new data;\n   int i;\n \n-  d->code_number = next_code_number;\n-  d->loc = file_location (read_md_filename, lineno);\n+  d->code_number = info->index;\n+  d->loc = info->loc;\n   if (XSTR (insn, 0)[0])\n     d->name = XSTR (insn, 0);\n   else\n@@ -984,14 +977,14 @@ gen_expand (rtx insn, int lineno)\n    only for reasons of consistency and to simplify genrecog.  */\n \n static void\n-gen_split (rtx split, int lineno)\n+gen_split (md_rtx_info *info)\n {\n   struct pattern_stats stats;\n   data *d = new data;\n   int i;\n \n-  d->code_number = next_code_number;\n-  d->loc = file_location (read_md_filename, lineno);\n+  d->code_number = info->index;\n+  d->loc = info->loc;\n   d->name = 0;\n \n   /* Build up the list in the same order as the insns are seen\n@@ -1005,6 +998,7 @@ gen_split (rtx split, int lineno)\n   /* Get the number of operands by scanning all the patterns of the\n      split patterns.  But ignore all the rest of the information thus\n      obtained.  */\n+  rtx split = info->def;\n   for (i = 0; i < XVECLEN (split, 0); i++)\n     scan_operands (d, XVECEXP (split, 0, i), 0, 0);\n \n@@ -1034,8 +1028,6 @@ extern int main (int, char **);\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-\n   progname = \"genoutput\";\n \n   init_insn_for_nothing ();\n@@ -1047,44 +1039,37 @@ main (int argc, char **argv)\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no;\n-\n-      desc = read_md_rtx (&line_no, &next_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+\tgen_insn (&info);\n \tbreak;\n \n-      switch (GET_CODE (desc))\n-\t{\n-\tcase DEFINE_INSN:\n-\t  gen_insn (desc, line_no);\n-\t  break;\n-\n-\tcase DEFINE_PEEPHOLE:\n-\t  gen_peephole (desc, line_no);\n-\t  break;\n+      case DEFINE_PEEPHOLE:\n+\tgen_peephole (&info);\n+\tbreak;\n \n-\tcase DEFINE_EXPAND:\n-\t  gen_expand (desc, line_no);\n-\t  break;\n+      case DEFINE_EXPAND:\n+\tgen_expand (&info);\n+\tbreak;\n \n-\tcase DEFINE_SPLIT:\n-\tcase DEFINE_PEEPHOLE2:\n-\t  gen_split (desc, line_no);\n-\t  break;\n+      case DEFINE_SPLIT:\n+      case DEFINE_PEEPHOLE2:\n+\tgen_split (&info);\n+\tbreak;\n \n-\tcase DEFINE_CONSTRAINT:\n-\tcase DEFINE_REGISTER_CONSTRAINT:\n-\tcase DEFINE_ADDRESS_CONSTRAINT:\n-\tcase DEFINE_MEMORY_CONSTRAINT:\n-\t  note_constraint (desc, line_no);\n-\t  break;\n+      case DEFINE_CONSTRAINT:\n+      case DEFINE_REGISTER_CONSTRAINT:\n+      case DEFINE_ADDRESS_CONSTRAINT:\n+      case DEFINE_MEMORY_CONSTRAINT:\n+\tnote_constraint (&info);\n+\tbreak;\n \n-\tdefault:\n-\t  break;\n-\t}\n-    }\n+      default:\n+\tbreak;\n+      }\n \n   printf (\"\\n\\n\");\n   output_operand_data ();\n@@ -1134,15 +1119,14 @@ strip_whitespace (const char *s)\n   return q;\n }\n \n-/* Record just enough information about a constraint to allow checking\n-   of operand constraint strings above, in validate_insn_alternatives.\n-   Does not validate most properties of the constraint itself; does\n-   enforce no duplicate names, no overlap with MI constraints, and no\n-   prefixes.  EXP is the define_*constraint form, LINENO the line number\n-   reported by the reader.  */\n+/* Record just enough information about the constraint in *INFO to allow\n+   checking of operand constraint strings above, in validate_insn_alternatives.\n+   Does not validate most properties of the constraint itself; does enforce\n+   no duplicate names, no overlap with MI constraints, and no prefixes.  */\n static void\n-note_constraint (rtx exp, int lineno)\n+note_constraint (md_rtx_info *info)\n {\n+  rtx exp = info->def;\n   const char *name = XSTR (exp, 0);\n   struct constraint_data **iter, **slot, *new_cdata;\n \n@@ -1153,12 +1137,12 @@ note_constraint (rtx exp, int lineno)\n   if (strchr (indep_constraints, name[0]))\n     {\n       if (name[1] == '\\0')\n-\terror_with_line (lineno, \"constraint letter '%s' cannot be \"\n-\t\t\t \"redefined by the machine description\", name);\n+\terror_at (info->loc, \"constraint letter '%s' cannot be \"\n+\t\t  \"redefined by the machine description\", name);\n       else\n-\terror_with_line (lineno, \"constraint name '%s' cannot be defined by \"\n-\t\t\t \"the machine description, as it begins with '%c'\",\n-\t\t\t name, name[0]);\n+\terror_at (info->loc, \"constraint name '%s' cannot be defined by \"\n+\t\t  \"the machine description, as it begins with '%c'\",\n+\t\t  name, name[0]);\n       return;\n     }\n \n@@ -1175,20 +1159,20 @@ note_constraint (rtx exp, int lineno)\n \n       if (!strcmp ((*iter)->name, name))\n \t{\n-\t  error_with_line (lineno, \"redefinition of constraint '%s'\", name);\n+\t  error_at (info->loc, \"redefinition of constraint '%s'\", name);\n \t  message_at ((*iter)->loc, \"previous definition is here\");\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, (*iter)->namelen))\n \t{\n-\t  error_with_line (lineno, \"defining constraint '%s' here\", name);\n+\t  error_at (info->loc, \"defining constraint '%s' here\", name);\n \t  message_at ((*iter)->loc, \"renders constraint '%s' \"\n \t\t      \"(defined here) a prefix\", (*iter)->name);\n \t  return;\n \t}\n       else if (!strncmp ((*iter)->name, name, namelen))\n \t{\n-\t  error_with_line (lineno, \"constraint '%s' is a prefix\", name);\n+\t  error_at (info->loc, \"constraint '%s' is a prefix\", name);\n \t  message_at ((*iter)->loc, \"of constraint '%s' \"\n \t\t      \"(defined here)\", (*iter)->name);\n \t  return;\n@@ -1199,7 +1183,7 @@ note_constraint (rtx exp, int lineno)\n   new (new_cdata) constraint_data ();\n   strcpy (CONST_CAST (char *, new_cdata->name), name);\n   new_cdata->namelen = namelen;\n-  new_cdata->loc = file_location (read_md_filename, lineno);\n+  new_cdata->loc = info->loc;\n   new_cdata->next_this_letter = *slot;\n   *slot = new_cdata;\n }"}, {"sha": "a1707b16ab85e368be2355279505d26faa3ceb67", "filename": "gcc/genpeep.c", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -46,14 +46,14 @@ static int max_opno;\n \n static int n_operands;\n \n-static void gen_peephole (rtx, int);\n static void match_rtx (rtx, struct link *, int);\n static void print_path (struct link *);\n static void print_code (RTX_CODE);\n \f\n static void\n-gen_peephole (rtx peep, int insn_code_number)\n+gen_peephole (md_rtx_info *info)\n {\n+  rtx peep = info->def;\n   int ninsns = XVECLEN (peep, 0);\n   int i;\n \n@@ -66,32 +66,30 @@ gen_peephole (rtx peep, int insn_code_number)\n       if (i > 0)\n \t{\n \t  printf (\"  do { insn = NEXT_INSN (insn);\\n\");\n-\t  printf (\"       if (insn == 0) goto L%d; }\\n\",\n-\t\t  insn_code_number);\n+\t  printf (\"       if (insn == 0) goto L%d; }\\n\", info->index);\n \t  printf (\"  while (NOTE_P (insn)\\n\");\n \t  printf (\"\\t || (NONJUMP_INSN_P (insn)\\n\");\n \t  printf (\"\\t     && (GET_CODE (PATTERN (insn)) == USE\\n\");\n \t  printf (\"\\t\\t || GET_CODE (PATTERN (insn)) == CLOBBER)));\\n\");\n \n \t  printf (\"  if (LABEL_P (insn)\\n\\\n-      || BARRIER_P (insn))\\n    goto L%d;\\n\",\n-\t\t  insn_code_number);\n+      || BARRIER_P (insn))\\n    goto L%d;\\n\", info->index);\n \t}\n \n       printf (\"  pat = PATTERN (insn);\\n\");\n \n       /* Walk the insn's pattern, remembering at all times the path\n \t down to the walking point.  */\n \n-      match_rtx (XVECEXP (peep, 0, i), NULL, insn_code_number);\n+      match_rtx (XVECEXP (peep, 0, i), NULL, info->index);\n     }\n \n   /* We get this far if the pattern matches.\n      Now test the extra condition.  */\n \n   if (XSTR (peep, 1) && XSTR (peep, 1)[0])\n     printf (\"  if (! (%s)) goto L%d;\\n\",\n-\t    XSTR (peep, 1), insn_code_number);\n+\t    XSTR (peep, 1), info->index);\n \n   /* If that matches, construct new pattern and put it in the first insn.\n      This new pattern will never be matched.\n@@ -103,8 +101,7 @@ gen_peephole (rtx peep, int insn_code_number)\n \n   /* Record this define_peephole's insn code in the insn,\n      as if it had been recognized to match this.  */\n-  printf (\"  INSN_CODE (ins1) = %d;\\n\",\n-\t  insn_code_number);\n+  printf (\"  INSN_CODE (ins1) = %d;\\n\", info->index);\n \n   /* Delete the remaining insns.  */\n   if (ninsns > 1)\n@@ -114,7 +111,7 @@ gen_peephole (rtx peep, int insn_code_number)\n      cannot be zero.  */\n   printf (\"  return NEXT_INSN (insn);\\n\");\n \n-  printf (\" L%d:\\n\\n\", insn_code_number);\n+  printf (\" L%d:\\n\\n\", info->index);\n }\n \f\n static void\n@@ -348,8 +345,6 @@ extern int main (int, char **);\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n-\n   max_opno = -1;\n \n   progname = \"genpeep\";\n@@ -394,18 +389,17 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* Read the machine description.  */\n \n-  while (1)\n-    {\n-      int line_no;\n-      int insn_code_number;\n-\n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_PEEPHOLE:\n+\tgen_peephole (&info);\n \tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n-\tgen_peephole (desc, insn_code_number);\n-    }\n+      default:\n+\tbreak;\n+      }\n \n   printf (\"  return 0;\\n}\\n\\n\");\n "}, {"sha": "eac2180e246f9b1d6d4544e91786af34d01abbd2", "filename": "gcc/genpreds.c", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -91,10 +91,9 @@ validate_exp (rtx exp, const char *name, file_location loc)\n /* Predicates are defined with (define_predicate) or\n    (define_special_predicate) expressions in the machine description.  */\n static void\n-process_define_predicate (rtx defn, int lineno)\n+process_define_predicate (md_rtx_info *info)\n {\n-  validate_exp (XEXP (defn, 1), XSTR (defn, 0),\n-\t\tfile_location (read_md_filename, lineno));\n+  validate_exp (XEXP (info->def, 1), XSTR (info->def, 0), info->loc);\n }\n \n /* Given a predicate, if it has an embedded C block, write the block\n@@ -936,20 +935,20 @@ add_constraint (const char *name, const char *regclass,\n /* Process a DEFINE_CONSTRAINT, DEFINE_MEMORY_CONSTRAINT, or\n    DEFINE_ADDRESS_CONSTRAINT expression, C.  */\n static void\n-process_define_constraint (rtx c, int lineno)\n+process_define_constraint (md_rtx_info *info)\n {\n-  add_constraint (XSTR (c, 0), 0, XEXP (c, 2),\n-\t\t  GET_CODE (c) == DEFINE_MEMORY_CONSTRAINT,\n-\t\t  GET_CODE (c) == DEFINE_ADDRESS_CONSTRAINT,\n-\t\t  file_location (read_md_filename, lineno));\n+  add_constraint (XSTR (info->def, 0), 0, XEXP (info->def, 2),\n+\t\t  GET_CODE (info->def) == DEFINE_MEMORY_CONSTRAINT,\n+\t\t  GET_CODE (info->def) == DEFINE_ADDRESS_CONSTRAINT,\n+\t\t  info->loc);\n }\n \n /* Process a DEFINE_REGISTER_CONSTRAINT expression, C.  */\n static void\n-process_define_register_constraint (rtx c, int lineno)\n+process_define_register_constraint (md_rtx_info *info)\n {\n-  add_constraint (XSTR (c, 0), XSTR (c, 1), 0, false, false,\n-\t\t  file_location (read_md_filename, lineno));\n+  add_constraint (XSTR (info->def, 0), XSTR (info->def, 1),\n+\t\t  0, false, false, info->loc);\n }\n \n /* Put the constraints into enum order.  We want to keep constraints\n@@ -1584,31 +1583,29 @@ parse_option (const char *opt)\n int\n main (int argc, char **argv)\n {\n-  rtx defn;\n-  int pattern_lineno, next_insn_code = 0;\n-\n   progname = argv[0];\n   if (argc <= 1)\n     fatal (\"no input file name\");\n   if (!init_rtx_reader_args_cb (argc, argv, parse_option))\n     return FATAL_EXIT_CODE;\n \n-  while ((defn = read_md_rtx (&pattern_lineno, &next_insn_code)) != 0)\n-    switch (GET_CODE (defn))\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n       {\n       case DEFINE_PREDICATE:\n       case DEFINE_SPECIAL_PREDICATE:\n-\tprocess_define_predicate (defn, pattern_lineno);\n+\tprocess_define_predicate (&info);\n \tbreak;\n \n       case DEFINE_CONSTRAINT:\n       case DEFINE_MEMORY_CONSTRAINT:\n       case DEFINE_ADDRESS_CONSTRAINT:\n-\tprocess_define_constraint (defn, pattern_lineno);\n+\tprocess_define_constraint (&info);\n \tbreak;\n \n       case DEFINE_REGISTER_CONSTRAINT:\n-\tprocess_define_register_constraint (defn, pattern_lineno);\n+\tprocess_define_register_constraint (&info);\n \tbreak;\n \n       default:"}, {"sha": "4275bd2e6415853c5c5f73d297f31b8e3ed817f6", "filename": "gcc/genrecog.c", "status": "modified", "additions": 90, "deletions": 109, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -250,12 +250,6 @@ enum routine_type {\n   SUBPATTERN, RECOG, SPLIT, PEEPHOLE2\n };\n \n-/* Next number to use as an insn_code.  */\n-static int next_insn_code;\n-\n-/* The line number of the start of the pattern currently being processed.  */\n-static int pattern_lineno;\n-\n /* The root position (x0).  */\n static struct position root_pos;\n \n@@ -469,12 +463,13 @@ constraints_supported_in_insn_p (rtx insn)\n \t   || GET_CODE (insn) == DEFINE_PEEPHOLE2);\n }\n \n-/* Check for various errors in patterns.  SET is nonnull for a destination,\n-   and is the complete set pattern.  SET_CODE is '=' for normal sets, and\n-   '+' within a context that requires in-out constraints.  */\n+/* Check for various errors in PATTERN, which is part of INFO.\n+   SET is nonnull for a destination, and is the complete set pattern.\n+   SET_CODE is '=' for normal sets, and '+' within a context that\n+   requires in-out constraints.  */\n \n static void\n-validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n+validate_pattern (rtx pattern, md_rtx_info *info, rtx set, int set_code)\n {\n   const char *fmt;\n   RTX_CODE code;\n@@ -488,13 +483,12 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n       {\n \tconst char constraints0 = XSTR (pattern, 1)[0];\n \n-\tif (!constraints_supported_in_insn_p (insn))\n+\tif (!constraints_supported_in_insn_p (info->def))\n \t  {\n \t    if (constraints0)\n \t      {\n-\t\terror_with_line (pattern_lineno,\n-\t\t\t\t \"constraints not supported in %s\",\n-\t\t\t\t rtx_name[GET_CODE (insn)]);\n+\t\terror_at (info->loc, \"constraints not supported in %s\",\n+\t\t\t  GET_RTX_NAME (GET_CODE (info->def)));\n \t      }\n \t    return;\n \t  }\n@@ -506,19 +500,17 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t    && constraints0 != '='\n \t    && constraints0 != '+')\n \t  {\n-\t    error_with_line (pattern_lineno,\n-\t\t\t     \"operand %d missing output reload\",\n-\t\t\t     XINT (pattern, 0));\n+\t    error_at (info->loc, \"operand %d missing output reload\",\n+\t\t      XINT (pattern, 0));\n \t  }\n \treturn;\n       }\n     case MATCH_DUP:\n     case MATCH_OP_DUP:\n     case MATCH_PAR_DUP:\n-      if (find_operand (insn, XINT (pattern, 0), pattern) == pattern)\n-\terror_with_line (pattern_lineno,\n-\t\t\t \"operand %i duplicated before defined\",\n-\t\t\t XINT (pattern, 0));\n+      if (find_operand (info->def, XINT (pattern, 0), pattern) == pattern)\n+\terror_at (info->loc, \"operand %i duplicated before defined\",\n+\t\t  XINT (pattern, 0));\n       break;\n     case MATCH_OPERAND:\n     case MATCH_OPERATOR:\n@@ -527,17 +519,16 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \tconst struct pred_data *pred;\n \tconst char *c_test;\n \n-\tif (GET_CODE (insn) == DEFINE_INSN)\n-\t  c_test = XSTR (insn, 2);\n+\tif (GET_CODE (info->def) == DEFINE_INSN)\n+\t  c_test = XSTR (info->def, 2);\n \telse\n-\t  c_test = XSTR (insn, 1);\n+\t  c_test = XSTR (info->def, 1);\n \n \tif (pred_name[0] != 0)\n \t  {\n \t    pred = lookup_predicate (pred_name);\n \t    if (!pred)\n-\t      error_with_line (pattern_lineno, \"unknown predicate '%s'\",\n-\t\t\t       pred_name);\n+\t      error_at (info->loc, \"unknown predicate '%s'\", pred_name);\n \t  }\n \telse\n \t  pred = 0;\n@@ -547,13 +538,12 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t    const char *constraints = XSTR (pattern, 2);\n \t    const char constraints0 = constraints[0];\n \n-\t    if (!constraints_supported_in_insn_p (insn))\n+\t    if (!constraints_supported_in_insn_p (info->def))\n \t      {\n \t\tif (constraints0)\n \t\t  {\n-\t\t    error_with_line (pattern_lineno,\n-\t\t\t\t     \"constraints not supported in %s\",\n-\t\t\t\t     rtx_name[GET_CODE (insn)]);\n+\t\t    error_at (info->loc, \"constraints not supported in %s\",\n+\t\t\t      GET_RTX_NAME (GET_CODE (info->def)));\n \t\t  }\n \t      }\n \n@@ -567,17 +557,16 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t\t    /* If we've only got an output reload for this operand,\n \t\t       we'd better have a matching input operand.  */\n \t\t    else if (constraints0 == '='\n-\t\t\t     && find_matching_operand (insn, XINT (pattern, 0)))\n+\t\t\t     && find_matching_operand (info->def,\n+\t\t\t\t\t\t       XINT (pattern, 0)))\n \t\t      ;\n \t\t    else\n-\t\t      error_with_line (pattern_lineno,\n-\t\t\t\t       \"operand %d missing in-out reload\",\n-\t\t\t\t       XINT (pattern, 0));\n+\t\t      error_at (info->loc, \"operand %d missing in-out reload\",\n+\t\t\t\tXINT (pattern, 0));\n \t\t  }\n \t\telse if (constraints0 != '=' && constraints0 != '+')\n-\t\t  error_with_line (pattern_lineno,\n-\t\t\t\t   \"operand %d missing output reload\",\n-\t\t\t\t   XINT (pattern, 0));\n+\t\t  error_at (info->loc, \"operand %d missing output reload\",\n+\t\t\t    XINT (pattern, 0));\n \t      }\n \n \t    /* For matching constraint in MATCH_OPERAND, the digit must be a\n@@ -597,10 +586,9 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \n \t\t    sscanf (constraints, \"%d\", &val);\n \t\t    if (val >= XINT (pattern, 0))\n-\t\t      error_with_line (pattern_lineno,\n-\t\t\t\t       \"constraint digit %d is not smaller than\"\n-\t\t\t\t       \" operand %d\",\n-\t\t\t\t       val, XINT (pattern, 0));\n+\t\t      error_at (info->loc, \"constraint digit %d is not\"\n+\t\t\t\t\" smaller than operand %d\",\n+\t\t\t\tval, XINT (pattern, 0));\n \t\t  }\n \n \t\twhile (constraints[0] && constraints[0] != ',')\n@@ -612,9 +600,8 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t   while not likely to occur at runtime, results in less efficient\n \t   code from insn-recog.c.  */\n \tif (set && pred && pred->allows_non_lvalue)\n-\t  error_with_line (pattern_lineno,\n-\t\t\t   \"destination operand %d allows non-lvalue\",\n-\t\t\t   XINT (pattern, 0));\n+\t  error_at (info->loc, \"destination operand %d allows non-lvalue\",\n+\t\t    XINT (pattern, 0));\n \n \t/* A modeless MATCH_OPERAND can be handy when we can check for\n \t   multiple modes in the c_test.  In most other cases, it is a\n@@ -626,17 +613,16 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \n \tif (GET_MODE (pattern) == VOIDmode\n \t    && code == MATCH_OPERAND\n-\t    && GET_CODE (insn) == DEFINE_INSN\n+\t    && GET_CODE (info->def) == DEFINE_INSN\n \t    && pred\n \t    && !pred->special\n \t    && pred->allows_non_const\n \t    && strstr (c_test, \"operands\") == NULL\n \t    && ! (set\n \t\t  && GET_CODE (set) == SET\n \t\t  && GET_CODE (SET_SRC (set)) == CALL))\n-\t  message_with_line (pattern_lineno,\n-\t\t\t     \"warning: operand %d missing mode?\",\n-\t\t\t     XINT (pattern, 0));\n+\t  message_at (info->loc, \"warning: operand %d missing mode?\",\n+\t\t      XINT (pattern, 0));\n \treturn;\n       }\n \n@@ -658,12 +644,12 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \tif (GET_CODE (dest) == MATCH_DUP\n \t    || GET_CODE (dest) == MATCH_OP_DUP\n \t    || GET_CODE (dest) == MATCH_PAR_DUP)\n-\t  dest = find_operand (insn, XINT (dest, 0), NULL);\n+\t  dest = find_operand (info->def, XINT (dest, 0), NULL);\n \n \tif (GET_CODE (src) == MATCH_DUP\n \t    || GET_CODE (src) == MATCH_OP_DUP\n \t    || GET_CODE (src) == MATCH_PAR_DUP)\n-\t  src = find_operand (insn, XINT (src, 0), NULL);\n+\t  src = find_operand (info->def, XINT (src, 0), NULL);\n \n \tdmode = GET_MODE (dest);\n \tsmode = GET_MODE (src);\n@@ -677,9 +663,8 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n         /* The operands of a SET must have the same mode unless one\n \t   is VOIDmode.  */\n         else if (dmode != VOIDmode && smode != VOIDmode && dmode != smode)\n-\t  error_with_line (pattern_lineno,\n-\t\t\t   \"mode mismatch in set: %smode vs %smode\",\n-\t\t\t   GET_MODE_NAME (dmode), GET_MODE_NAME (smode));\n+\t  error_at (info->loc, \"mode mismatch in set: %smode vs %smode\",\n+\t\t    GET_MODE_NAME (dmode), GET_MODE_NAME (smode));\n \n \t/* If only one of the operands is VOIDmode, and PC or CC0 is\n \t   not involved, it's probably a mistake.  */\n@@ -694,36 +679,34 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t  {\n \t    const char *which;\n \t    which = (dmode == VOIDmode ? \"destination\" : \"source\");\n-\t    message_with_line (pattern_lineno,\n-\t\t\t       \"warning: %s missing a mode?\", which);\n+\t    message_at (info->loc, \"warning: %s missing a mode?\", which);\n \t  }\n \n \tif (dest != SET_DEST (pattern))\n-\t  validate_pattern (dest, insn, pattern, '=');\n-\tvalidate_pattern (SET_DEST (pattern), insn, pattern, '=');\n-        validate_pattern (SET_SRC (pattern), insn, NULL_RTX, 0);\n+\t  validate_pattern (dest, info, pattern, '=');\n+\tvalidate_pattern (SET_DEST (pattern), info, pattern, '=');\n+        validate_pattern (SET_SRC (pattern), info, NULL_RTX, 0);\n         return;\n       }\n \n     case CLOBBER:\n-      validate_pattern (SET_DEST (pattern), insn, pattern, '=');\n+      validate_pattern (SET_DEST (pattern), info, pattern, '=');\n       return;\n \n     case ZERO_EXTRACT:\n-      validate_pattern (XEXP (pattern, 0), insn, set, set ? '+' : 0);\n-      validate_pattern (XEXP (pattern, 1), insn, NULL_RTX, 0);\n-      validate_pattern (XEXP (pattern, 2), insn, NULL_RTX, 0);\n+      validate_pattern (XEXP (pattern, 0), info, set, set ? '+' : 0);\n+      validate_pattern (XEXP (pattern, 1), info, NULL_RTX, 0);\n+      validate_pattern (XEXP (pattern, 2), info, NULL_RTX, 0);\n       return;\n \n     case STRICT_LOW_PART:\n-      validate_pattern (XEXP (pattern, 0), insn, set, set ? '+' : 0);\n+      validate_pattern (XEXP (pattern, 0), info, set, set ? '+' : 0);\n       return;\n \n     case LABEL_REF:\n       if (GET_MODE (LABEL_REF_LABEL (pattern)) != VOIDmode)\n-\terror_with_line (pattern_lineno,\n-\t\t\t \"operand to label_ref %smode not VOIDmode\",\n-\t\t\t GET_MODE_NAME (GET_MODE (LABEL_REF_LABEL (pattern))));\n+\terror_at (info->loc, \"operand to label_ref %smode not VOIDmode\",\n+\t\t  GET_MODE_NAME (GET_MODE (LABEL_REF_LABEL (pattern))));\n       break;\n \n     default:\n@@ -737,12 +720,12 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n       switch (fmt[i])\n \t{\n \tcase 'e': case 'u':\n-\t  validate_pattern (XEXP (pattern, i), insn, NULL_RTX, 0);\n+\t  validate_pattern (XEXP (pattern, i), info, NULL_RTX, 0);\n \t  break;\n \n \tcase 'E':\n \t  for (j = 0; j < XVECLEN (pattern, i); j++)\n-\t    validate_pattern (XVECEXP (pattern, i, j), insn, NULL_RTX, 0);\n+\t    validate_pattern (XVECEXP (pattern, i, j), info, NULL_RTX, 0);\n \t  break;\n \n \tcase 'i': case 'r': case 'w': case '0': case 's':\n@@ -3823,7 +3806,7 @@ predicate_name (rtx match_rtx)\n    TOP_PATTERN is the overall pattern, as passed to match_pattern_1.  */\n \n static state *\n-match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n+match_pattern_2 (state *s, md_rtx_info *info, position *pos, rtx pattern)\n {\n   auto_vec <pattern_pos, 32> worklist;\n   auto_vec <pattern_pos, 32> pred_and_mode_tests;\n@@ -3848,7 +3831,7 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t  dup_tests.safe_push (pattern_pos (pattern, pos));\n \n \t  /* Use the same code check as the original operand.  */\n-\t  pattern = find_operand (top_pattern, XINT (pattern, 0), NULL_RTX);\n+\t  pattern = find_operand (info->def, XINT (pattern, 0), NULL_RTX);\n \t  /* Fall through.  */\n \n \tcase MATCH_PARALLEL:\n@@ -3865,16 +3848,13 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n \t\tif (code == GET_CODE (pattern))\n \t\t  {\n \t\t    if (!pred)\n-\t\t      error_with_line (pattern_lineno,\n-\t\t\t\t       \"unknown predicate '%s'\"\n-\t\t\t\t       \" in '%s' expression\",\n-\t\t\t\t       pred_name, GET_RTX_NAME (code));\n+\t\t      error_at (info->loc, \"unknown predicate '%s' used in %s\",\n+\t\t\t\tpred_name, GET_RTX_NAME (code));\n \t\t    else if (code == MATCH_PARALLEL\n \t\t\t     && pred->singleton != PARALLEL)\n-\t\t      error_with_line (pattern_lineno,\n-\t\t\t\t       \"predicate '%s' used in match_parallel\"\n-\t\t\t\t       \" does not allow only PARALLEL\",\n-\t\t\t\t       pred->name);\n+\t\t      error_at (info->loc, \"predicate '%s' used in\"\n+\t\t\t\t\" match_parallel does not allow only PARALLEL\",\n+\t\t\t\tpred->name);\n \t\t  }\n \t      }\n \n@@ -4106,23 +4086,23 @@ match_pattern_2 (state *s, rtx top_pattern, position *pos, rtx pattern)\n    to match, otherwise it is a single instruction pattern.  */\n \n static void\n-match_pattern_1 (state *s, rtx top_pattern, const char *c_test,\n+match_pattern_1 (state *s, md_rtx_info *info, rtx pattern, const char *c_test,\n \t\t acceptance_type acceptance)\n {\n   if (acceptance.type == PEEPHOLE2)\n     {\n       /* Match each individual instruction.  */\n       position **subpos_ptr = &peep2_insn_pos_list;\n       int count = 0;\n-      for (int i = 0; i < XVECLEN (top_pattern, 0); ++i)\n+      for (int i = 0; i < XVECLEN (pattern, 0); ++i)\n \t{\n-\t  rtx x = XVECEXP (top_pattern, 0, i);\n+\t  rtx x = XVECEXP (pattern, 0, i);\n \t  position *subpos = next_position (subpos_ptr, &root_pos,\n \t\t\t\t\t    POS_PEEP2_INSN, count);\n \t  if (count > 0)\n \t    s = add_decision (s, rtx_test::peep2_count (count + 1),\n \t\t\t      true, false);\n-\t  s = match_pattern_2 (s, top_pattern, subpos, x);\n+\t  s = match_pattern_2 (s, info, subpos, x);\n \t  subpos_ptr = &subpos->next;\n \t  count += 1;\n \t}\n@@ -4131,7 +4111,7 @@ match_pattern_1 (state *s, rtx top_pattern, const char *c_test,\n   else\n     {\n       /* Make the rtx itself.  */\n-      s = match_pattern_2 (s, top_pattern, &root_pos, top_pattern);\n+      s = match_pattern_2 (s, info, &root_pos, pattern);\n \n       /* If the match is only valid when extra clobbers are added,\n \t make sure we're able to pass that information to the caller.  */\n@@ -4152,19 +4132,19 @@ match_pattern_1 (state *s, rtx top_pattern, const char *c_test,\n    backtracking.  */\n \n static void\n-match_pattern (state *s, rtx top_pattern, const char *c_test,\n+match_pattern (state *s, md_rtx_info *info, rtx pattern, const char *c_test,\n \t       acceptance_type acceptance)\n {\n   if (merge_states_p)\n     {\n       state root;\n       /* Add the decisions to a fresh state and then merge the full tree\n \t into the existing one.  */\n-      match_pattern_1 (&root, top_pattern, c_test, acceptance);\n+      match_pattern_1 (&root, info, pattern, c_test, acceptance);\n       merge_into_state (s, &root);\n     }\n   else\n-    match_pattern_1 (s, top_pattern, c_test, acceptance);\n+    match_pattern_1 (s, info, pattern, c_test, acceptance);\n }\n \n /* Begin the output file.  */\n@@ -5178,9 +5158,10 @@ print_subroutine_group (output_state *os, routine_type type, state *root)\n /* Return the rtx pattern for the list of rtxes in a define_peephole2.  */\n \n static rtx\n-get_peephole2_pattern (rtvec vec)\n+get_peephole2_pattern (md_rtx_info *info)\n {\n   int i, j;\n+  rtvec vec = XVEC (info->def, 0);\n   rtx pattern = rtx_alloc (SEQUENCE);\n   XVEC (pattern, 0) = rtvec_alloc (GET_NUM_ELEM (vec));\n   for (i = j = 0; i < GET_NUM_ELEM (vec); i++)\n@@ -5195,7 +5176,7 @@ get_peephole2_pattern (rtvec vec)\n     }\n   XVECLEN (pattern, 0) = j;\n   if (j == 0)\n-    error_with_line (pattern_lineno, \"empty define_peephole2\");\n+    error_at (info->loc, \"empty define_peephole2\");\n   return pattern;\n }\n \n@@ -5245,72 +5226,72 @@ remove_clobbers (acceptance_type *acceptance_ptr, rtx *pattern_ptr)\n int\n main (int argc, char **argv)\n {\n-  rtx desc;\n   state insn_root, split_root, peephole2_root;\n \n   progname = \"genrecog\";\n \n   if (!init_rtx_reader_args (argc, argv))\n     return (FATAL_EXIT_CODE);\n \n-  next_insn_code = 0;\n-\n   write_header ();\n \n   /* Read the machine description.  */\n \n-  while (1)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n     {\n-      desc = read_md_rtx (&pattern_lineno, &next_insn_code);\n-      if (desc == NULL)\n-\tbreak;\n+      rtx def = info.def;\n \n       acceptance_type acceptance;\n       acceptance.partial_p = false;\n-      acceptance.u.full.code = next_insn_code;\n+      acceptance.u.full.code = info.index;\n \n       rtx pattern;\n-      switch (GET_CODE (desc))\n+      switch (GET_CODE (def))\n \t{\n \tcase DEFINE_INSN:\n \t  {\n \t    /* Match the instruction in the original .md form.  */\n \t    acceptance.type = RECOG;\n \t    acceptance.u.full.u.num_clobbers = 0;\n-\t    pattern = add_implicit_parallel (XVEC (desc, 1));\n-\t    validate_pattern (pattern, desc, NULL_RTX, 0);\n-\t    match_pattern (&insn_root, pattern, XSTR (desc, 2), acceptance);\n+\t    pattern = add_implicit_parallel (XVEC (def, 1));\n+\t    validate_pattern (pattern, &info, NULL_RTX, 0);\n+\t    match_pattern (&insn_root, &info, pattern,\n+\t\t\t   XSTR (def, 2), acceptance);\n \n \t    /* If the pattern is a PARALLEL with trailing CLOBBERs,\n \t       allow recog_for_combine to match without the clobbers.  */\n \t    if (GET_CODE (pattern) == PARALLEL\n \t\t&& remove_clobbers (&acceptance, &pattern))\n-\t      match_pattern (&insn_root, pattern, XSTR (desc, 2), acceptance);\n+\t      match_pattern (&insn_root, &info, pattern,\n+\t\t\t     XSTR (def, 2), acceptance);\n \t    break;\n \t  }\n \n \tcase DEFINE_SPLIT:\n \t  acceptance.type = SPLIT;\n-\t  pattern = add_implicit_parallel (XVEC (desc, 0));\n-\t  validate_pattern (pattern, desc, NULL_RTX, 0);\n-\t  match_pattern (&split_root, pattern, XSTR (desc, 1), acceptance);\n+\t  pattern = add_implicit_parallel (XVEC (def, 0));\n+\t  validate_pattern (pattern, &info, NULL_RTX, 0);\n+\t  match_pattern (&split_root, &info, pattern,\n+\t\t\t XSTR (def, 1), acceptance);\n \n \t  /* Declare the gen_split routine that we'll call if the\n \t     pattern matches.  The definition comes from insn-emit.c.  */\n \t  printf (\"extern rtx_insn *gen_split_%d (rtx_insn *, rtx *);\\n\",\n-\t\t  next_insn_code);\n+\t\t  info.index);\n \t  break;\n \n \tcase DEFINE_PEEPHOLE2:\n \t  acceptance.type = PEEPHOLE2;\n-\t  pattern = get_peephole2_pattern (XVEC (desc, 0));\n-\t  validate_pattern (pattern, desc, NULL_RTX, 0);\n-\t  match_pattern (&peephole2_root, pattern, XSTR (desc, 1), acceptance);\n+\t  pattern = get_peephole2_pattern (&info);\n+\t  validate_pattern (pattern, &info, NULL_RTX, 0);\n+\t  match_pattern (&peephole2_root, &info, pattern,\n+\t\t\t XSTR (def, 1), acceptance);\n \n \t  /* Declare the gen_peephole2 routine that we'll call if the\n \t     pattern matches.  The definition comes from insn-emit.c.  */\n \t  printf (\"extern rtx_insn *gen_peephole2_%d (rtx_insn *, rtx *);\\n\",\n-\t\t  next_insn_code);\n+\t\t  info.index);\n \t  break;\n \n \tdefault:"}, {"sha": "b7681a234c159e61249ada9c50f546a1d63fb3b8", "filename": "gcc/gensupport.c", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -2533,14 +2533,11 @@ init_rtx_reader_args (int argc, char **argv)\n   return init_rtx_reader_args_cb (argc, argv, 0);\n }\n \f\n-/* The entry point for reading a single rtx from an md file.  Return\n-   the rtx, or NULL if the md file has been fully processed.\n-   Return the line where the rtx was found in LINENO.\n-   Return the number of code generating rtx'en read since the start\n-   of the md file in SEQNR.  */\n+/* Try to read a single rtx from the file.  Return true on success,\n+   describing it in *INFO.  */\n \n-rtx\n-read_md_rtx (int *lineno, int *seqnr)\n+bool\n+read_md_rtx (md_rtx_info *info)\n {\n   struct queue_elem **queue, *elem;\n   rtx desc;\n@@ -2557,14 +2554,13 @@ read_md_rtx (int *lineno, int *seqnr)\n   else if (other_queue != NULL)\n     queue = &other_queue;\n   else\n-    return NULL_RTX;\n+    return false;\n \n   elem = *queue;\n   *queue = elem->next;\n-  desc = elem->data;\n-  read_md_filename = elem->loc.filename;\n-  *lineno = elem->loc.lineno;\n-  *seqnr = sequence_num;\n+  info->def = elem->data;\n+  info->loc = elem->loc;\n+  info->index = sequence_num;\n \n   free (elem);\n \n@@ -2574,6 +2570,7 @@ read_md_rtx (int *lineno, int *seqnr)\n      elided patterns are never counted by the sequence numbering; it\n      is the caller's responsibility, when insn_elision is false, not\n      to use elided pattern numbers for anything.  */\n+  desc = info->def;\n   switch (GET_CODE (desc))\n     {\n     case DEFINE_INSN:\n@@ -2584,9 +2581,9 @@ read_md_rtx (int *lineno, int *seqnr)\n       else if (insn_elision)\n \tgoto discard;\n \n-      /* *seqnr is used here so the name table will match caller's\n+      /* info->index is used here so the name table will match caller's\n \t idea of insn numbering, whether or not elision is active.  */\n-      record_insn_name (*seqnr, XSTR (desc, 0));\n+      record_insn_name (info->index, XSTR (desc, 0));\n       break;\n \n     case DEFINE_SPLIT:\n@@ -2595,14 +2592,14 @@ read_md_rtx (int *lineno, int *seqnr)\n       if (maybe_eval_c_test (XSTR (desc, 1)) != 0)\n \tsequence_num++;\n       else if (insn_elision)\n-\t    goto discard;\n+\tgoto discard;\n       break;\n \n     default:\n       break;\n     }\n \n-  return desc;\n+  return true;\n }\n \n /* Helper functions for insn elision.  */"}, {"sha": "8fbdb364bcdbf50b069bc60e69ef762373594990", "filename": "gcc/gensupport.h", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -20,13 +20,29 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GENSUPPORT_H\n #define GCC_GENSUPPORT_H\n \n+#include \"read-md.h\"\n+\n struct obstack;\n extern struct obstack *rtl_obstack;\n \n+/* Information about an .md define_* rtx.  */\n+struct md_rtx_info {\n+  /* The rtx itself.  */\n+  rtx def;\n+\n+  /* The location of the first line of the rtx.  */\n+  file_location loc;\n+\n+  /* The unique number attached to the rtx.  Currently all define_insns,\n+     define_expands, define_splits, define_peepholes and define_peephole2s\n+     share the same insn_code index space.  */\n+  int index;\n+};\n+\n extern rtx add_implicit_parallel (rtvec);\n extern bool init_rtx_reader_args_cb (int, char **, bool (*)(const char *));\n extern bool init_rtx_reader_args (int, char **);\n-extern rtx read_md_rtx (int *, int *);\n+extern bool read_md_rtx (md_rtx_info *);\n \n /* Set this to 0 to disable automatic elision of insn patterns which\n    can never be used in this configuration.  See genconditions.c."}, {"sha": "e5e291ecfd7daec2bb3ad107a7553117be2ccd50", "filename": "gcc/gentarget-def.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgentarget-def.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fgentarget-def.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgentarget-def.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -198,11 +198,27 @@ def_target_insn (const char *name, const char *prototype)\n     printf (\"CODE_FOR_%s\\n\", name);\n }\n \n+/* Record the DEFINE_INSN or DEFINE_EXPAND described by INFO.  */\n+\n+static void\n+add_insn (md_rtx_info *info)\n+{\n+  rtx def = info->def;\n+  const char *name = XSTR (def, 0);\n+  if (name[0] == 0 || name[0] == '*')\n+    return;\n+\n+  hashval_t hash = htab_hash_string (name);\n+  rtx *slot = insns->find_slot_with_hash (name, hash, INSERT);\n+  if (*slot)\n+    error_at (info->loc, \"duplicate definition of '%s'\", name);\n+  else\n+    *slot = def;\n+}\n+\n int\n main (int argc, char **argv)\n {\n-  int insn_code_number = 0;\n-\n   progname = \"gentarget-def\";\n \n   if (!init_rtx_reader_args (argc, argv))\n@@ -212,30 +228,18 @@ main (int argc, char **argv)\n   stubs = new hash_table <nofree_string_hash> (31);\n   have_funcs = new hash_map <nofree_string_hash, const char *>;\n \n-  while (1)\n-    {\n-      int line_no;\n-      rtx desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n+  md_rtx_info info;\n+  while (read_md_rtx (&info))\n+    switch (GET_CODE (info.def))\n+      {\n+      case DEFINE_INSN:\n+      case DEFINE_EXPAND:\n+\tadd_insn (&info);\n \tbreak;\n-      if (GET_CODE (desc) == DEFINE_INSN || GET_CODE (desc) == DEFINE_EXPAND)\n-\t{\n-\t  const char *name = XSTR (desc, 0);\n-\t  if (name[0] != 0 && name[0] != '*')\n-\t    {\n-\t      hashval_t hash = htab_hash_string (name);\n-\t      rtx *slot = insns->find_slot_with_hash (name, hash, INSERT);\n-\t      if (*slot)\n-\t\t{\n-\t\t  message_with_line (line_no, \"duplicate definition of '%s'\",\n-\t\t\t\t     name);\n-\t\t  have_error = 1;\n-\t\t}\n-\t      else\n-\t\t*slot = desc;\n-\t    }\n-\t}\n-    }\n+\n+      default:\n+\tbreak;\n+      }\n \n   printf (\"/* Generated automatically by the program `gentarget-def'.  */\\n\");\n   printf (\"#ifndef GCC_INSN_TARGET_DEF_H\\n\");"}, {"sha": "9f158ec2b7f30dfb31329cffb29b09216ca5283a", "filename": "gcc/read-md.c", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -290,32 +290,6 @@ fatal_at (file_location loc, const char *msg, ...)\n   exit (1);\n }\n \n-/* A printf-like function for reporting an error against line LINENO\n-   in the current MD file.  */\n-\n-void\n-message_with_line (int lineno, const char *msg, ...)\n-{\n-  va_list ap;\n-\n-  va_start (ap, msg);\n-  message_at_1 (file_location (read_md_filename, lineno), msg, ap);\n-  va_end (ap);\n-}\n-\n-/* Like message_with_line, but treat the condition as an error.  */\n-\n-void\n-error_with_line (int lineno, const char *msg, ...)\n-{\n-  va_list ap;\n-\n-  va_start (ap, msg);\n-  message_at_1 (file_location (read_md_filename, lineno), msg, ap);\n-  va_end (ap);\n-  have_error = 1;\n-}\n-\n /* A printf-like function for reporting an error against the current\n    position in the MD file.  */\n "}, {"sha": "231e5893d29846495792bf435574d9dbb24a1015", "filename": "gcc/read-md.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2d3e43b917f87ce4e8378076888dd03e4c7cc2/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=5d2d3e43b917f87ce4e8378076888dd03e4c7cc2", "patch": "@@ -137,8 +137,6 @@ extern void fprint_c_condition (FILE *, const char *);\n extern void message_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void error_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void fatal_at (file_location, const char *, ...) ATTRIBUTE_PRINTF_2;\n-extern void message_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n-extern void error_with_line (int, const char *, ...) ATTRIBUTE_PRINTF_2;\n extern void fatal_with_file_and_line (const char *, ...)\n   ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n extern void fatal_expected_char (int, int) ATTRIBUTE_NORETURN;"}]}