{"sha": "9b1549b8116df3026cc8b885ad84ad62c123b805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIxNTQ5YjgxMTZkZjMwMjZjYzhiODg1YWQ4NGFkNjJjMTIzYjgwNQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "1999-12-13T06:51:09Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-13T06:51:09Z"}, "message": "cse.c (struct cse_reg_info): Add hash_next member, reorder rest of struct for better packing on 64-bit hosts.\n\n\t* cse.c (struct cse_reg_info): Add hash_next member,\n\treorder rest of struct for better packing on 64-bit\n\thosts.\n\t(cse_reg_info_tree): Kill.\n\t(REGHASH_SHIFT, REGHASH_SIZE, REGHASH_MASK, reg_hash,\n\tREGHASH_FN): New custom pow2 hash mechanism.\n\t(NBUCKETS): Kill.\n\t(HASH_SHIFT, HASH_SIZE, HASH_MASK, HASH, table): Rework to\n\tuse a pow2 hash table.\n\t(get_cse_reg_info): Rework to use new REGHASH.\n\t(new_basic_block): Likewise, use HASH_SIZE, and inline\n\tfree_element call.\n\t(remove_from_table): Rework to use HASH_SIZE/HASH_MASK,\n\tand inline free_element call.\n\t(lookup_as_function, insert, flush_hash_table, invalidate,\n\tremove_invalid_refs, remove_invalid_subreg_refs, rehash_using_reg,\n\tinvalidate_for_call, use_related_value, find_comparison_args,\n\tfold_rtx, equiv_constant, cse_insn, invalidate_memory): Likewise.\n\t(hash_cse_reg_info, cse_reg_info_equal_p, free_element,\n\tget_element): Kill.\n\nFrom-SVN: r30883", "tree": {"sha": "acca6f4e33239b5fd3566ec4d5e85181bd7cb465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acca6f4e33239b5fd3566ec4d5e85181bd7cb465"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b1549b8116df3026cc8b885ad84ad62c123b805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1549b8116df3026cc8b885ad84ad62c123b805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b1549b8116df3026cc8b885ad84ad62c123b805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b1549b8116df3026cc8b885ad84ad62c123b805/comments", "author": null, "committer": null, "parents": [{"sha": "fa0933ba25d5657d079bff30cf58a6bfc79ce483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa0933ba25d5657d079bff30cf58a6bfc79ce483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa0933ba25d5657d079bff30cf58a6bfc79ce483"}], "stats": {"total": 258, "additions": 134, "deletions": 124}, "files": [{"sha": "4c8613c7cddc2b624543c49f8cb8029f411940fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1549b8116df3026cc8b885ad84ad62c123b805/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1549b8116df3026cc8b885ad84ad62c123b805/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b1549b8116df3026cc8b885ad84ad62c123b805", "patch": "@@ -1,3 +1,26 @@\n+1999-12-12  David S. Miller  <davem@redhat.com>\n+\n+\t* cse.c (struct cse_reg_info): Add hash_next member,\n+\treorder rest of struct for better packing on 64-bit\n+\thosts.\n+\t(cse_reg_info_tree): Kill.\n+\t(REGHASH_SHIFT, REGHASH_SIZE, REGHASH_MASK, reg_hash,\n+\tREGHASH_FN): New custom pow2 hash mechanism.\n+\t(NBUCKETS): Kill.\n+\t(HASH_SHIFT, HASH_SIZE, HASH_MASK, HASH, table): Rework to\n+\tuse a pow2 hash table.\n+\t(get_cse_reg_info): Rework to use new REGHASH.\n+\t(new_basic_block): Likewise, use HASH_SIZE, and inline\n+\tfree_element call.\n+\t(remove_from_table): Rework to use HASH_SIZE/HASH_MASK,\n+\tand inline free_element call.\n+\t(lookup_as_function, insert, flush_hash_table, invalidate,\n+\tremove_invalid_refs, remove_invalid_subreg_refs, rehash_using_reg,\n+\tinvalidate_for_call, use_related_value, find_comparison_args,\n+\tfold_rtx, equiv_constant, cse_insn, invalidate_memory): Likewise.\n+\t(hash_cse_reg_info, cse_reg_info_equal_p, free_element,\n+\tget_element): Kill.\n+\t\n Sun Dec 12 21:31:44 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* cse.c (cse_basic_block): Free qty_table consistently."}, {"sha": "33191b59c2b912beba2416422a89d8c93c2a6699", "filename": "gcc/cse.c", "status": "modified", "additions": 111, "deletions": 124, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b1549b8116df3026cc8b885ad84ad62c123b805/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b1549b8116df3026cc8b885ad84ad62c123b805/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=9b1549b8116df3026cc8b885ad84ad62c123b805", "patch": "@@ -295,24 +295,27 @@ static struct reg_eqv_elem *reg_eqv_table;\n \n struct cse_reg_info\n {\n-  /* The number of times the register has been altered in the current\n-     basic block.  */\n-  int reg_tick;\n+  /* Next in hash chain.  */\n+  struct cse_reg_info *hash_next;\n \n   /* The next cse_reg_info structure in the free or used list.  */\n   struct cse_reg_info *next;\n \n+  /* Search key */\n+  int regno;\n+\n+  /* The quantity number of the register's current contents.  */\n+  int reg_qty;\n+\n+  /* The number of times the register has been altered in the current\n+     basic block.  */\n+  int reg_tick;\n+\n   /* The REG_TICK value at which rtx's containing this register are\n      valid in the hash table.  If this does not equal the current\n      reg_tick value, such expressions existing in the hash table are\n      invalid.  */\n   int reg_in_table;\n-\n-  /* The quantity number of the register's current contents.  */\n-  int reg_qty;\n-\n-  /* Search key */\n-  int regno;\n };\n \n /* A free list of cse_reg_info entries.  */\n@@ -323,7 +326,13 @@ static struct cse_reg_info *cse_reg_info_used_list;\n static struct cse_reg_info *cse_reg_info_used_list_end;\n \n /* A mapping from registers to cse_reg_info data structures.  */\n-static hash_table_t cse_reg_info_tree;\n+#define REGHASH_SHIFT\t7\n+#define REGHASH_SIZE\t(1 << REGHASH_SHIFT)\n+#define REGHASH_MASK\t(REGHASH_SIZE - 1)\n+static struct cse_reg_info *reg_hash[REGHASH_SIZE];\n+\n+#define REGHASH_FN(REGNO)\t\\\n+\t(((REGNO) ^ ((REGNO) >> REGHASH_SHIFT)) & REGHASH_MASK)\n \n /* The last lookup we did into the cse_reg_info_tree.  This allows us\n    to cache repeated lookups.  */\n@@ -449,15 +458,17 @@ struct table_elt\n /* We don't want a lot of buckets, because we rarely have very many\n    things stored in the hash table, and a lot of buckets slows\n    down a lot of loops that happen frequently.  */\n-#define NBUCKETS 31\n+#define HASH_SHIFT\t5\n+#define HASH_SIZE\t(1 << HASH_SHIFT)\n+#define HASH_MASK\t(HASH_SIZE - 1)\n \n /* Compute hash code of X in mode M.  Special-case case where X is a pseudo\n    register (hard registers may require `do_not_record' to be set).  */\n \n #define HASH(X, M)\t\\\n- (GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n-  ? (((unsigned) REG << 7) + (unsigned) REG_QTY (REGNO (X))) % NBUCKETS\t\\\n-  : canon_hash (X, M) % NBUCKETS)\n+ ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+  ? (((unsigned) REG << 7) + (unsigned) REG_QTY (REGNO (X)))\t\\\n+  : canon_hash (X, M)) & HASH_MASK)\n \n /* Determine whether register number N is considered a fixed register for CSE.\n    It is desirable to replace other regs with fixed regs, to reduce need for\n@@ -527,7 +538,7 @@ struct table_elt\n    ? -1 : ADDRESS_COST(RTX))\n #endif \n \n-static struct table_elt *table[NBUCKETS];\n+static struct table_elt *table[HASH_SIZE];\n \n /* Chain of `struct table_elt's made so far for this function\n    but currently removed from the table.  */\n@@ -836,63 +847,45 @@ static struct cse_reg_info *\n get_cse_reg_info (regno)\n      int regno;\n {\n-  struct cse_reg_info *cri;\n-  struct cse_reg_info **entry;\n-  struct cse_reg_info temp;\n-\n-  /* See if we already have this entry.  */\n-  temp.regno = regno;\n-  entry = (struct cse_reg_info **) find_hash_table_entry (cse_reg_info_tree,\n-\t\t\t\t\t\t\t  &temp, TRUE);\n-\n-  if (*entry)\n-    cri = *entry;\n-  else \n+  struct cse_reg_info **hash_head = &reg_hash[REGHASH_FN (regno)];\n+  struct cse_reg_info *p;\n+\n+  for (p = *hash_head ; p != NULL; p = p->hash_next)\n+    if (p->regno == regno)\n+      break;\n+\n+  if (p == NULL)\n     {\n       /* Get a new cse_reg_info structure.  */\n-      if (cse_reg_info_free_list) \n+      if (cse_reg_info_free_list)\n \t{\n-\t  cri = cse_reg_info_free_list;\n-\t  cse_reg_info_free_list = cri->next;\n+\t  p = cse_reg_info_free_list;\n+\t  cse_reg_info_free_list = p->next;\n \t}\n       else\n-\tcri = (struct cse_reg_info *) xmalloc (sizeof (struct cse_reg_info));\n+\tp = (struct cse_reg_info *) xmalloc (sizeof (struct cse_reg_info));\n+\n+      /* Insert into hash table.  */\n+      p->hash_next = *hash_head;\n+      *hash_head = p;\n \n       /* Initialize it.  */\n-      cri->reg_tick = 0;\n-      cri->reg_in_table = -1;\n-      cri->reg_qty = regno;\n-      cri->regno = regno;\n-      cri->next = cse_reg_info_used_list;\n-      cse_reg_info_used_list = cri;\n+      p->reg_tick = 1;\n+      p->reg_in_table = -1;\n+      p->reg_qty = regno;\n+      p->regno = regno;\n+      p->next = cse_reg_info_used_list;\n+      cse_reg_info_used_list = p;\n       if (!cse_reg_info_used_list_end)\n-\tcse_reg_info_used_list_end = cri;\n-      \n-      *entry = cri;\n+\tcse_reg_info_used_list_end = p;\n     }\n \n   /* Cache this lookup; we tend to be looking up information about the\n      same register several times in a row.  */\n   cached_regno = regno;\n-  cached_cse_reg_info = cri;\n-\n-  return cri;\n-}\n+  cached_cse_reg_info = p;\n \n-static unsigned int\n-hash_cse_reg_info (el_ptr)\n-     hash_table_entry_t el_ptr;\n-{\n-  return ((const struct cse_reg_info *) el_ptr)->regno;\n-}\n-\n-static int\n-cse_reg_info_equal_p (el_ptr1, el_ptr2)\n-     hash_table_entry_t el_ptr1;\n-     hash_table_entry_t el_ptr2;\n-{\n-  return (((const struct cse_reg_info *) el_ptr1)->regno\n-\t  == ((const struct cse_reg_info *) el_ptr2)->regno);\n+  return p;\n }\n \n /* Clear the hash table and initialize each register with its own quantity,\n@@ -905,38 +898,45 @@ new_basic_block ()\n \n   next_qty = max_reg;\n \n-  if (cse_reg_info_tree) \n+  /* Clear out hash table state for this pass.  */\n+\n+  bzero ((char *) reg_hash, sizeof reg_hash);\n+\n+  if (cse_reg_info_used_list)\n     {\n-      delete_hash_table (cse_reg_info_tree);\n-      if (cse_reg_info_used_list)\n-\t{\n-\t  cse_reg_info_used_list_end->next = cse_reg_info_free_list;\n-\t  cse_reg_info_free_list = cse_reg_info_used_list;\n-\t  cse_reg_info_used_list = cse_reg_info_used_list_end = 0;\n-\t}\n-      cached_cse_reg_info = 0;\n+      cse_reg_info_used_list_end->next = cse_reg_info_free_list;\n+      cse_reg_info_free_list = cse_reg_info_used_list;\n+      cse_reg_info_used_list = cse_reg_info_used_list_end = 0;\n     }\n-\n-  cse_reg_info_tree = create_hash_table (0, hash_cse_reg_info,\n-\t\t\t\t\t cse_reg_info_equal_p);\n+  cached_cse_reg_info = 0;\n \n   CLEAR_HARD_REG_SET (hard_regs_in_table);\n \n   /* The per-quantity values used to be initialized here, but it is\n      much faster to initialize each as it is made in `make_new_qty'.  */\n \n-  for (i = 0; i < NBUCKETS; i++)\n+  for (i = 0; i < HASH_SIZE; i++)\n     {\n-      register struct table_elt *this, *next;\n-      for (this = table[i]; this; this = next)\n+      struct table_elt *first;\n+\n+      first = table[i];\n+      if (first != NULL)\n \t{\n-\t  next = this->next_same_hash;\n-\t  free_element (this);\n+\t  struct table_elt *last = first;\n+\n+\t  table[i] = NULL;\n+\n+\t  while (last->next_same_hash != NULL)\n+\t    last = last->next_same_hash;\n+\n+\t  /* Now relink this hash entire chain into\n+\t     the free element list.  */\n+\n+\t  last->next_same_hash = free_element_chain;\n+\t  free_element_chain = first;\n \t}\n     }\n \n-  bzero ((char *) table, sizeof table);\n-\n   prev_insn = 0;\n \n #ifdef HAVE_cc0\n@@ -1258,31 +1258,6 @@ insert_regs (x, classp, modified)\n \f\n /* Look in or update the hash table.  */\n \n-/* Put the element ELT on the list of free elements.  */\n-\n-static void\n-free_element (elt)\n-     struct table_elt *elt;\n-{\n-  elt->next_same_hash = free_element_chain;\n-  free_element_chain = elt;\n-}\n-\n-/* Return an element that is free for use.  */\n-\n-static struct table_elt *\n-get_element ()\n-{\n-  struct table_elt *elt = free_element_chain;\n-  if (elt)\n-    {\n-      free_element_chain = elt->next_same_hash;\n-      return elt;\n-    }\n-  n_elements_made++;\n-  return (struct table_elt *) oballoc (sizeof (struct table_elt));\n-}\n-\n /* Remove table element ELT from use in the table.\n    HASH is its hash code, made using the HASH macro.\n    It's an argument because often that is known in advance\n@@ -1338,7 +1313,7 @@ remove_from_table (elt, hash)\n \t   when two classes were merged by `merge_equiv_classes'.  Search\n \t   for the hash bucket that it heads.  This happens only very\n \t   rarely, so the cost is acceptable.  */\n-\tfor (hash = 0; hash < NBUCKETS; hash++)\n+\tfor (hash = 0; hash < HASH_SIZE; hash++)\n \t  if (table[hash] == elt)\n \t    table[hash] = next;\n       }\n@@ -1356,7 +1331,9 @@ remove_from_table (elt, hash)\n \tp->related_value = 0;\n     }\n \n-  free_element (elt);\n+  /* Now add it to the free element chain.  */\n+  elt->next_same_hash = free_element_chain;\n+  free_element_chain = elt;\n }\n \n /* Look up X in the hash table and return its table element,\n@@ -1423,7 +1400,7 @@ lookup_as_function (x, code)\n      rtx x;\n      enum rtx_code code;\n {\n-  register struct table_elt *p = lookup (x, safe_hash (x, VOIDmode) % NBUCKETS,\n+  register struct table_elt *p = lookup (x, safe_hash (x, VOIDmode) & HASH_MASK,\n \t\t\t\t\t GET_MODE (x));\n   /* If we are looking for a CONST_INT, the mode doesn't really matter, as\n      long as we are narrowing.  So if we looked in vain for a mode narrower\n@@ -1433,7 +1410,7 @@ lookup_as_function (x, code)\n     {\n       x = copy_rtx (x);\n       PUT_MODE (x, word_mode);\n-      p = lookup (x, safe_hash (x, VOIDmode) % NBUCKETS, word_mode);\n+      p = lookup (x, safe_hash (x, VOIDmode) & HASH_MASK, word_mode);\n     }\n \n   if (p == 0)\n@@ -1509,7 +1486,17 @@ insert (x, classp, hash, mode)\n \n   /* Put an element for X into the right hash bucket.  */\n \n-  elt = get_element ();\n+  elt = free_element_chain;\n+  if (elt)\n+    {\n+      free_element_chain = elt->next_same_hash;\n+    }\n+  else\n+    {\n+      n_elements_made++;\n+      elt = (struct table_elt *) oballoc (sizeof (struct table_elt));\n+    }\n+\n   elt->exp = x;\n   elt->cost = COST (x);\n   elt->next_same_value = 0;\n@@ -1628,7 +1615,7 @@ insert (x, classp, hash, mode)\n       if (subexp != 0)\n \t{\n \t  /* Get the integer-free subexpression in the hash table.  */\n-\t  subhash = safe_hash (subexp, mode) % NBUCKETS;\n+\t  subhash = safe_hash (subexp, mode) & HASH_MASK;\n \t  subelt = lookup (subexp, subhash, mode);\n \t  if (subelt == 0)\n \t    subelt = insert (subexp, NULL_PTR, subhash, mode);\n@@ -1713,7 +1700,7 @@ flush_hash_table ()\n   int i;\n   struct table_elt *p;\n \n-  for (i = 0; i < NBUCKETS; i++)\n+  for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = table[i])\n       {\n \t/* Note that invalidate can remove elements\n@@ -1796,7 +1783,7 @@ invalidate (x, full_mode)\n \t      }\n \n \t    if (in_table)\n-\t      for (hash = 0; hash < NBUCKETS; hash++)\n+\t      for (hash = 0; hash < HASH_SIZE; hash++)\n \t\tfor (p = table[hash]; p; p = next)\n \t\t  {\n \t\t    next = p->next_same_hash;\n@@ -1836,7 +1823,7 @@ invalidate (x, full_mode)\n       if (full_mode == VOIDmode)\n \tfull_mode = GET_MODE (x);\n \n-      for (i = 0; i < NBUCKETS; i++)\n+      for (i = 0; i < HASH_SIZE; i++)\n \t{\n \t  register struct table_elt *next;\n \n@@ -1869,7 +1856,7 @@ remove_invalid_refs (regno)\n   register int i;\n   register struct table_elt *p, *next;\n \n-  for (i = 0; i < NBUCKETS; i++)\n+  for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n       {\n \tnext = p->next_same_hash;\n@@ -1890,7 +1877,7 @@ remove_invalid_subreg_refs (regno, word, mode)\n   register struct table_elt *p, *next;\n   int end = word + (GET_MODE_SIZE (mode) - 1) / UNITS_PER_WORD;\n \n-  for (i = 0; i < NBUCKETS; i++)\n+  for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n       {\n \trtx exp;\n@@ -1938,13 +1925,13 @@ rehash_using_reg (x)\n      If we find one and it is in the wrong hash chain, move it.  We can skip\n      objects that are registers, since they are handled specially.  */\n \n-  for (i = 0; i < NBUCKETS; i++)\n+  for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n       {\n \tnext = p->next_same_hash;\n \tif (GET_CODE (p->exp) != REG && reg_mentioned_p (x, p->exp)\n \t    && exp_equiv_p (p->exp, p->exp, 1, 0)\n-\t    && i != (hash = safe_hash (p->exp, p->mode) % NBUCKETS))\n+\t    && i != (hash = safe_hash (p->exp, p->mode) & HASH_MASK))\n \t  {\n \t    if (p->next_same_hash)\n \t      p->next_same_hash->prev_same_hash = p->prev_same_hash;\n@@ -1995,7 +1982,7 @@ invalidate_for_call ()\n      entry that overlaps a call-clobbered register.  */\n \n   if (in_table)\n-    for (hash = 0; hash < NBUCKETS; hash++)\n+    for (hash = 0; hash < HASH_SIZE; hash++)\n       for (p = table[hash]; p; p = next)\n \t{\n \t  next = p->next_same_hash;\n@@ -2042,7 +2029,7 @@ use_related_value (x, elt)\n       rtx subexp = get_related_value (x);\n       if (subexp != 0)\n \trelt = lookup (subexp,\n-\t\t       safe_hash (subexp, GET_MODE (subexp)) % NBUCKETS,\n+\t\t       safe_hash (subexp, GET_MODE (subexp)) & HASH_MASK,\n \t\t       GET_MODE (subexp));\n     }\n \n@@ -2942,7 +2929,7 @@ find_comparison_args (code, parg1, parg2, pmode1, pmode2)\n       if (x == 0)\n \t/* Look up ARG1 in the hash table and see if it has an equivalence\n \t   that lets us see what is being compared.  */\n-\tp = lookup (arg1, safe_hash (arg1, GET_MODE (arg1)) % NBUCKETS,\n+\tp = lookup (arg1, safe_hash (arg1, GET_MODE (arg1)) & HASH_MASK,\n \t\t    GET_MODE (arg1));\n       if (p) p = p->first_same_value;\n \n@@ -3712,10 +3699,10 @@ fold_rtx (x, insn)\n \t\t\t      == REG_QTY (REGNO (folded_arg1))))\n \t\t      || ((p0 = lookup (folded_arg0,\n \t\t\t\t\t(safe_hash (folded_arg0, mode_arg0)\n-\t\t\t\t\t % NBUCKETS), mode_arg0))\n+\t\t\t\t\t & HASH_MASK), mode_arg0))\n \t\t\t  && (p1 = lookup (folded_arg1,\n \t\t\t\t\t   (safe_hash (folded_arg1, mode_arg0)\n-\t\t\t\t\t    % NBUCKETS), mode_arg0))\n+\t\t\t\t\t    & HASH_MASK), mode_arg0))\n \t\t\t  && p0->first_same_value == p1->first_same_value)))\n \t\treturn ((code == EQ || code == LE || code == GE\n \t\t\t || code == LEU || code == GEU)\n@@ -3881,7 +3868,7 @@ fold_rtx (x, insn)\n \t    {\n \t      rtx new_const = GEN_INT (- INTVAL (const_arg1));\n \t      struct table_elt *p\n-\t\t= lookup (new_const, safe_hash (new_const, mode) % NBUCKETS,\n+\t\t= lookup (new_const, safe_hash (new_const, mode) & HASH_MASK,\n \t\t\t  mode);\n \n \t      if (p)\n@@ -4067,7 +4054,7 @@ equiv_constant (x)\n       if (CONSTANT_P (x))\n \treturn x;\n \n-      elt = lookup (x, safe_hash (x, GET_MODE (x)) % NBUCKETS, GET_MODE (x));\n+      elt = lookup (x, safe_hash (x, GET_MODE (x)) & HASH_MASK, GET_MODE (x));\n       if (elt == 0)\n \treturn 0;\n \n@@ -5694,7 +5681,7 @@ cse_insn (insn, libcall_insn)\n \t      /* We used to rely on all references to a register becoming\n \t\t inaccessible when a register changes to a new quantity,\n \t\t since that changes the hash code.  However, that is not\n-\t\t safe, since after NBUCKETS new quantities we get a\n+\t\t safe, since after HASH_SIZE new quantities we get a\n \t\t hash 'collision' of a register with its own invalid\n \t\t entries.  And since SUBREGs have been changed not to\n \t\t change their hash code with the hash code of the register,\n@@ -5997,7 +5984,7 @@ invalidate_memory ()\n   register int i;\n   register struct table_elt *p, *next;\n \n-  for (i = 0; i < NBUCKETS; i++)\n+  for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n       {\n \tnext = p->next_same_hash;"}]}