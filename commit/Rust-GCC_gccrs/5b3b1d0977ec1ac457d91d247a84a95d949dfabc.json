{"sha": "5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIzYjFkMDk3N2VjMWFjNDU3ZDkxZDI0N2E4NGE5NWQ5NDlkZmFiYw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-20T21:56:49Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-01-20T21:56:49Z"}, "message": "re PR fortran/38907 (ICE when contained function has same name as module function and used in expression)\n\n2009-01-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38907\n\t* resolve.c (check_host_association): Remove the matching to\n\tcorrect an incorrect host association and use manipulation of\n\tthe expression instead.\n\n2009-01-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38907\n\t* gfortran.dg/host_assoc_function_7.f90: New test.\n\nFrom-SVN: r143530", "tree": {"sha": "a53a17597b9653c8a7384ee21f6da92bd631bcee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a53a17597b9653c8a7384ee21f6da92bd631bcee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/comments", "author": null, "committer": null, "parents": [{"sha": "53f506ed164d3a6f5b9b2f38b62fbb55902a3b0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53f506ed164d3a6f5b9b2f38b62fbb55902a3b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53f506ed164d3a6f5b9b2f38b62fbb55902a3b0b"}], "stats": {"total": 143, "additions": 112, "deletions": 31}, "files": [{"sha": "7c56c004cd6c760bcb968b03de3151f499ed2061", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "patch": "@@ -1,3 +1,10 @@\n+2009-01-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38907\n+\t* resolve.c (check_host_association): Remove the matching to\n+\tcorrect an incorrect host association and use manipulation of\n+\tthe expression instead.\n+\n 2009-01-20  Tobias Burnus  <burnus@net-b.de>\n \n \t* invoke.texi (RANGE): RANGE also takes INTEGER arguments."}, {"sha": "433f380868be49f3a37ab19c03aedbadd82ff2d1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "patch": "@@ -4289,15 +4289,17 @@ resolve_variable (gfc_expr *e)\n /* Checks to see that the correct symbol has been host associated.\n    The only situation where this arises is that in which a twice\n    contained function is parsed after the host association is made.\n-   Therefore, on detecting this, the line is rematched, having got\n-   rid of the existing references and actual_arg_list.  */\n+   Therefore, on detecting this, change the symbol in the expression\n+   and convert the array reference into an actual arglist if the old\n+   symbol is a variable.  */\n static bool\n check_host_association (gfc_expr *e)\n {\n   gfc_symbol *sym, *old_sym;\n-  locus temp_locus;\n-  gfc_expr *expr;\n+  gfc_symtree *st;\n   int n;\n+  gfc_ref *ref;\n+  gfc_actual_arglist *arg, *tail;\n   bool retval = e->expr_type == EXPR_FUNCTION;\n \n   /*  If the expression is the result of substitution in\n@@ -4313,26 +4315,16 @@ check_host_association (gfc_expr *e)\n   if (gfc_current_ns->parent\n \t&& old_sym->ns != gfc_current_ns)\n     {\n+      /* Use the 'USE' name so that renamed module symbols are\n+\t correctly handled.  */\n       gfc_find_symbol (e->symtree->name, gfc_current_ns, 1, &sym);\n+\n       if (sym && old_sym != sym\n \t      && sym->ts.type == old_sym->ts.type\n \t      && sym->attr.flavor == FL_PROCEDURE\n \t      && sym->attr.contained)\n \t{\n-\t  temp_locus = gfc_current_locus;\n-\t  gfc_current_locus = e->where;\n-\n-\t  gfc_buffer_error (1);\n-\n-\t  gfc_free_ref_list (e->ref);\n-\t  e->ref = NULL;\n-\n-\t  if (retval)\n-\t    {\n-\t      gfc_free_actual_arglist (e->value.function.actual);\n-\t      e->value.function.actual = NULL;\n-\t    }\n-\n+\t  /* Clear the shape, since it might not be valid.  */\n \t  if (e->shape != NULL)\n \t    {\n \t      for (n = 0; n < e->rank; n++)\n@@ -4341,22 +4333,58 @@ check_host_association (gfc_expr *e)\n \t      gfc_free (e->shape);\n \t    }\n \n-/* TODO - Replace this gfc_match_rvalue with a straight replacement of\n-   actual arglists for function to function substitutions and with a\n-   conversion of the reference list to an actual arglist in the case of\n-   a variable to function replacement.  This should be quite easy since\n-   only integers and vectors can be involved.  */\t    \n-\t  gfc_match_rvalue (&expr);\n-\t  gfc_clear_error ();\n-\t  gfc_buffer_error (0);\n+\t  /* Give the symbol a symtree in the right place!  */\n+\t  gfc_get_sym_tree (sym->name, gfc_current_ns, &st);\n+\t  st->n.sym = sym;\n \n-\t  gcc_assert (expr && sym == expr->symtree->n.sym);\n+\t  if (old_sym->attr.flavor == FL_PROCEDURE)\n+\t    {\n+\t      /* Original was function so point to the new symbol, since\n+\t\t the actual argument list is already attached to the\n+\t\t expression. */\n+\t      e->value.function.esym = NULL;\n+\t      e->symtree = st;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Original was variable so convert array references into\n+\t\t an actual arglist. This does not need any checking now\n+\t\t since gfc_resolve_function will take care of it.  */\n+\t      e->value.function.actual = NULL;\n+\t      e->expr_type = EXPR_FUNCTION;\n+\t      e->symtree = st;\n \n-\t  *e = *expr;\n-\t  gfc_free (expr);\n-\t  sym->refs++;\n+\t      /* Ambiguity will not arise if the array reference is not\n+\t\t the last reference.  */\n+\t      for (ref = e->ref; ref; ref = ref->next)\n+\t\tif (ref->type == REF_ARRAY && ref->next == NULL)\n+\t\t  break;\n \n-\t  gfc_current_locus = temp_locus;\n+\t      gcc_assert (ref->type == REF_ARRAY);\n+\n+\t      /* Grab the start expressions from the array ref and\n+\t\t copy them into actual arguments.  */\n+\t      for (n = 0; n < ref->u.ar.dimen; n++)\n+\t\t{\n+\t\t  arg = gfc_get_actual_arglist ();\n+\t\t  arg->expr = gfc_copy_expr (ref->u.ar.start[n]);\n+\t\t  if (e->value.function.actual == NULL)\n+\t\t    tail = e->value.function.actual = arg;\n+\t          else\n+\t\t    {\n+\t\t      tail->next = arg;\n+\t\t      tail = arg;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Dump the reference list and set the rank.  */\n+\t      gfc_free_ref_list (e->ref);\n+\t      e->ref = NULL;\n+\t      e->rank = sym->as ? sym->as->rank : 0;\n+\t    }\n+\n+\t  gfc_resolve_expr (e);\n+\t  sym->refs++;\n \t}\n     }\n   /* This might have changed!  */"}, {"sha": "8b2d31da084412c3e32aa0d2f15677939d44e2ee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "patch": "@@ -1,3 +1,8 @@\n+2009-01-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38907\n+\t* gfortran.dg/host_assoc_function_7.f90: New test\n+\n 2009-01-20  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "15684438a9f7825a6e73eb5ba5a6bc8a44f6de92", "filename": "gcc/testsuite/gfortran.dg/host_assoc_function_7.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_function_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b3b1d0977ec1ac457d91d247a84a95d949dfabc/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_function_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fhost_assoc_function_7.f90?ref=5b3b1d0977ec1ac457d91d247a84a95d949dfabc", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+! Tests the fix for PR38907, in which any expressions, including unary plus,\n+! in front of the call to S_REAL_SUM_I (marked) would throw the mechanism\n+! for correcting invalid host association.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+module sa0054_stuff\n+  REAL :: S_REAL_SUM_2(10) = [(REAL (I), I = 1, 10)]\n+contains\n+  ELEMENTAL FUNCTION S_REAL_SUM_I (A)\n+    REAL  ::  S_REAL_SUM_I\n+    REAL, INTENT(IN)  ::  A\n+    X = 1.0\n+    S_REAL_SUM_I = X\n+  END FUNCTION S_REAL_SUM_I\n+  SUBROUTINE SA0054 (RDA)\n+    REAL RDA(:)\n+    RDA =  + S_REAL_SUM_I (RDA)          ! Reported problem => ICE\n+    RDA = RDA + S_REAL_SUM_2 (INT (RDA)) ! Also failed\n+  CONTAINS\n+    ELEMENTAL FUNCTION S_REAL_SUM_I (A)\n+      REAL  ::  S_REAL_SUM_I\n+      REAL, INTENT(IN)  ::  A\n+      S_REAL_SUM_I = 2.0 * A\n+    END FUNCTION S_REAL_SUM_I\n+    ELEMENTAL FUNCTION S_REAL_SUM_2 (A)\n+      REAL  ::  S_REAL_SUM_2\n+      INTEGER, INTENT(IN)  ::  A\n+      S_REAL_SUM_2 = 2.0 * A\n+    END FUNCTION S_REAL_SUM_2\n+  END SUBROUTINE\n+end module sa0054_stuff\n+\n+  use sa0054_stuff\n+  REAL :: RDA(10) = [(REAL(I), I = 1, 10)]\n+  call SA0054 (RDA)\n+  IF (ANY (INT (RDA) .ne. [(6 * I, I = 1, 10)])) print *, rda\n+END\n+\n+! { dg-final { cleanup-modules \"sa0054_stuff\" } }"}]}