{"sha": "81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "node_id": "C_kwDOANBUbNoAKDgxZmQ2MmQxMzc4YjdkZGMxZmEwOTY3Y2JkZGNkY2RjZGQyZDhkOGM", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2023-03-12T18:42:04Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2023-03-12T18:42:04Z"}, "message": "middle-end: Implement preferred_div_as_shifts_over_mult [PR108583]\n\nThis now implements a hook\npreferred_div_as_shifts_over_mult that indicates whether a target prefers that\nthe vectorizer decomposes division as shifts rather than multiplication when\npossible.\n\nIn order to be able to use this we need to check whether the current precision\nhas enough bits to do the operation without any of the additions overflowing.\n\nWe use range information to determine this and only do the operation if we're\nsure am overflow won't occur. This now uses ranger to do this range check.\n\nThis seems to work better than vect_get_range_info which uses range_query, but I\nhave not switched the interface of vect_get_range_info over in this PR fix.\n\nAs Andy said before initializing a ranger instance is cheap but not free, and if\nthe intention is to call it often during a pass it should be instantiated at\npass startup and passed along to the places that need it.  This is a big\nrefactoring and doesn't seem right to do in this PR.  But we should in GCC 14.\n\nCurrently we only instantiate it after a long series of much cheaper checks.\n\ngcc/ChangeLog:\n\n\tPR target/108583\n\t* target.def (preferred_div_as_shifts_over_mult): New.\n\t* doc/tm.texi.in: Document it.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.cc (default_preferred_div_as_shifts_over_mult): New.\n\t* targhooks.h (default_preferred_div_as_shifts_over_mult): New.\n\t* tree-vect-patterns.cc (vect_recog_divmod_pattern): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\tPR target/108583\n\t* gcc.dg/vect/vect-div-bitmask-4.c: New test.\n\t* gcc.dg/vect/vect-div-bitmask-5.c: New test.", "tree": {"sha": "3a6881be284bf7e9dbcb377959334cc7f2caeed4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a6881be284bf7e9dbcb377959334cc7f2caeed4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b3c630fcc44063a61f6131af48a4171b1de2b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3c630fcc44063a61f6131af48a4171b1de2b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3c630fcc44063a61f6131af48a4171b1de2b37"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "c4a92a5ebee90473dc633db586bba30747d9260e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -6146,6 +6146,12 @@ instruction pattern.  There is no need for the hook to handle these two\n implementation approaches itself.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_VECTORIZE_PREFERRED_DIV_AS_SHIFTS_OVER_MULT (const_tree @var{type})\n+Sometimes it is possible to implement a vector division using a sequence\n+of two addition-shift pairs, giving four instructions in total.\n+Return true if taking this approach for @var{vectype} is likely\n+to be better than using a sequence involving highpart multiplication.\n+Default is false if @code{can_mult_highpart_p}, otherwise true.\n @end deftypefn\n \n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION (unsigned @var{code}, tree @var{vec_type_out}, tree @var{vec_type_in})"}, {"sha": "4075e71624c04cb8167314efdf27264f4d8c1f3f", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -4175,6 +4175,7 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_VEC_PERM_CONST\n \n+@hook TARGET_VECTORIZE_PREFERRED_DIV_AS_SHIFTS_OVER_MULT\n \n @hook TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION\n "}, {"sha": "f401fe148ee2ddf138359fa1b462cfebc9c88691", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -1868,6 +1868,18 @@ correct for most targets.\",\n  poly_uint64, (const_tree type),\n  default_preferred_vector_alignment)\n \n+/* Returns whether the target has a preference for decomposing divisions using\n+   shifts rather than multiplies.  */\n+DEFHOOK\n+(preferred_div_as_shifts_over_mult,\n+ \"Sometimes it is possible to implement a vector division using a sequence\\n\\\n+of two addition-shift pairs, giving four instructions in total.\\n\\\n+Return true if taking this approach for @var{vectype} is likely\\n\\\n+to be better than using a sequence involving highpart multiplication.\\n\\\n+Default is false if @code{can_mult_highpart_p}, otherwise true.\",\n+ bool, (const_tree type),\n+ default_preferred_div_as_shifts_over_mult)\n+\n /* Return true if vector alignment is reachable (by peeling N\n    iterations) for the given scalar type.  */\n DEFHOOK"}, {"sha": "51bf3fb7a82ff83ca4c16e93f5f2472dfba71511", "filename": "gcc/targhooks.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftarghooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftarghooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.cc?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -1488,6 +1488,15 @@ default_preferred_vector_alignment (const_tree type)\n   return TYPE_ALIGN (type);\n }\n \n+/* The default implementation of\n+   TARGET_VECTORIZE_PREFERRED_DIV_AS_SHIFTS_OVER_MULT.  */\n+\n+bool\n+default_preferred_div_as_shifts_over_mult (const_tree type)\n+{\n+  return !can_mult_highpart_p (TYPE_MODE (type), TYPE_UNSIGNED (type));\n+}\n+\n /* By default assume vectors of element TYPE require a multiple of the natural\n    alignment of TYPE.  TYPE is naturally aligned if IS_PACKED is false.  */\n bool"}, {"sha": "cf3d3107a0db0ab79065a92e3af720f17bd78bf1", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -53,6 +53,8 @@ extern scalar_int_mode default_unwind_word_mode (void);\n extern unsigned HOST_WIDE_INT default_shift_truncation_mask\n   (machine_mode);\n extern unsigned int default_min_divisions_for_recip_mul (machine_mode);\n+extern bool default_preferred_div_as_shifts_over_mult\n+  (const_tree);\n extern int default_mode_rep_extended (scalar_int_mode, scalar_int_mode);\n \n extern tree default_stack_protect_guard (void);"}, {"sha": "c81f8946922250234bf759e0a0a04ea8c1f73e3c", "filename": "gcc/testsuite/gcc.dg/vect/vect-div-bitmask-4.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-div-bitmask-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-div-bitmask-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-div-bitmask-4.c?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdint.h>\n+#include \"tree-vect.h\"\n+\n+typedef unsigned __attribute__((__vector_size__ (16))) V;\n+\n+static __attribute__((__noinline__)) __attribute__((__noclone__)) V\n+foo (V v, unsigned short i)\n+{\n+  v /= i;\n+  return v;\n+}\n+\n+int\n+main (void)\n+{\n+  V v = foo ((V) { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff }, 0xffff);\n+  for (unsigned i = 0; i < sizeof (v) / sizeof (v[0]); i++)\n+    if (v[i] != 0x00010001)\n+      __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"vect_recog_divmod_pattern: detected\" \"vect\" { target aarch64*-*-* } } } */"}, {"sha": "b4eb1a4dacba481e6306b49914d2a29b933de625", "filename": "gcc/testsuite/gcc.dg/vect/vect-div-bitmask-5.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-div-bitmask-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-div-bitmask-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-div-bitmask-5.c?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdint.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 50\n+#define TYPE uint8_t \n+\n+#ifndef DEBUG\n+#define DEBUG 0\n+#endif\n+\n+#define BASE ((TYPE) -1 < 0 ? -126 : 4)\n+\n+\n+__attribute__((noipa, noinline, optimize(\"O1\")))\n+void fun1(TYPE* restrict pixel, TYPE level, int n)\n+{\n+  for (int i = 0; i < n; i+=1)\n+    pixel[i] = (pixel[i] + level) / 0xff;\n+}\n+\n+__attribute__((noipa, noinline, optimize(\"O3\")))\n+void fun2(TYPE* restrict pixel, TYPE level, int n)\n+{\n+  for (int i = 0; i < n; i+=1)\n+    pixel[i] = (pixel[i] + level) / 0xff;\n+}\n+\n+int main ()\n+{\n+  TYPE a[N];\n+  TYPE b[N];\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = BASE + i * 13;\n+      b[i] = BASE + i * 13;\n+      if (DEBUG)\n+        printf (\"%d: 0x%x\\n\", i, a[i]);\n+    }\n+\n+  fun1 (a, N / 2, N);\n+  fun2 (b, N / 2, N);\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      if (DEBUG)\n+        printf (\"%d = 0x%x == 0x%x\\n\", i, a[i], b[i]);\n+\n+      if (a[i] != b[i])\n+        __builtin_abort ();\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"divmod pattern recognized\" \"vect\" { target aarch64*-*-* } } } */"}, {"sha": "887f02bf336da890fd93ec069a4c8d98d9f80b92", "filename": "gcc/tree-vect-patterns.cc", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftree-vect-patterns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c/gcc%2Ftree-vect-patterns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.cc?ref=81fd62d1378b7ddc1fa0967cbddcdcdcdd2d8d8c", "patch": "@@ -3934,6 +3934,83 @@ vect_recog_divmod_pattern (vec_info *vinfo,\n       return pattern_stmt;\n     }\n \n+  if ((cst = uniform_integer_cst_p (oprnd1))\n+      && TYPE_UNSIGNED (itype)\n+      && rhs_code == TRUNC_DIV_EXPR\n+      && vectype\n+      && targetm.vectorize.preferred_div_as_shifts_over_mult (vectype))\n+    {\n+      /* We can use the relationship:\n+\n+\t   x // N == ((x+N+2) // (N+1) + x) // (N+1)  for 0 <= x < N(N+3)\n+\n+\t to optimize cases where N+1 is a power of 2, and where // (N+1)\n+\t is therefore a shift right.  When operating in modes that are\n+\t multiples of a byte in size, there are two cases:\n+\n+\t (1) N(N+3) is not representable, in which case the question\n+\t     becomes whether the replacement expression overflows.\n+\t     It is enough to test that x+N+2 does not overflow,\n+\t     i.e. that x < MAX-(N+1).\n+\n+\t (2) N(N+3) is representable, in which case it is the (only)\n+\t     bound that we need to check.\n+\n+\t ??? For now we just handle the case where // (N+1) is a shift\n+\t right by half the precision, since some architectures can\n+\t optimize the associated addition and shift combinations\n+\t into single instructions.  */\n+\n+      auto wcst = wi::to_wide (cst);\n+      int pow = wi::exact_log2 (wcst + 1);\n+      if (pow == prec / 2)\n+\t{\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (oprnd0);\n+\n+\t  gimple_ranger ranger;\n+\t  int_range_max r;\n+\n+\t  /* Check that no overflow will occur.  If we don't have range\n+\t     information we can't perform the optimization.  */\n+\n+\t  if (ranger.range_of_expr (r, oprnd0, stmt))\n+\t    {\n+\t      wide_int max = r.upper_bound ();\n+\t      wide_int one = wi::shwi (1, prec);\n+\t      wide_int adder = wi::add (one, wi::lshift (one, pow));\n+\t      wi::overflow_type ovf;\n+\t      wi::add (max, adder, UNSIGNED, &ovf);\n+\t      if (ovf == wi::OVF_NONE)\n+\t\t{\n+\t\t  *type_out = vectype;\n+\t\t  tree tadder = wide_int_to_tree (itype, adder);\n+\t\t  tree rshift = wide_int_to_tree (itype, pow);\n+\n+\t\t  tree new_lhs1 = vect_recog_temp_ssa_var (itype, NULL);\n+\t\t  gassign *patt1\n+\t\t    = gimple_build_assign (new_lhs1, PLUS_EXPR, oprnd0, tadder);\n+\t\t  append_pattern_def_seq (vinfo, stmt_vinfo, patt1, vectype);\n+\n+\t\t  tree new_lhs2 = vect_recog_temp_ssa_var (itype, NULL);\n+\t\t  patt1 = gimple_build_assign (new_lhs2, RSHIFT_EXPR, new_lhs1,\n+\t\t\t\t\t       rshift);\n+\t\t  append_pattern_def_seq (vinfo, stmt_vinfo, patt1, vectype);\n+\n+\t\t  tree new_lhs3 = vect_recog_temp_ssa_var (itype, NULL);\n+\t\t  patt1 = gimple_build_assign (new_lhs3, PLUS_EXPR, new_lhs2,\n+\t\t\t\t\t       oprnd0);\n+\t\t  append_pattern_def_seq (vinfo, stmt_vinfo, patt1, vectype);\n+\n+\t\t  tree new_lhs4 = vect_recog_temp_ssa_var (itype, NULL);\n+\t\t  pattern_stmt = gimple_build_assign (new_lhs4, RSHIFT_EXPR,\n+\t\t\t\t\t\t      new_lhs3, rshift);\n+\n+\t\t  return pattern_stmt;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   if (prec > HOST_BITS_PER_WIDE_INT\n       || integer_zerop (oprnd1))\n     return NULL;"}]}