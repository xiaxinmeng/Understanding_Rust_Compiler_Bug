{"sha": "0eaee4abb1d99f6165769a8ad2bfbf818860f40b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGVhZWU0YWJiMWQ5OWY2MTY1NzY5YThhZDJiZmJmODE4ODYwZjQwYg==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2019-09-05T06:59:55Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2019-09-05T06:59:55Z"}, "message": "Improve PRNG jumping when using threads\n\nCurrently, when a new thread needs to use the RANDOM_NUMBER intrinsic,\nthe per-thread PRNG state is initialized by copying the master state\nand then jumping forwards N*2**128 entries in the stream so that the\nPRNG streams for different threads don't alias each other, where N is\nthe number of threads that have so far initialized the PRNG.\n\nWith this patch the master state itself is jumped forwards once each\ntime a new thread initializes the PRNG, thus obviating the need to\njump through all the N-1 previous streams. Effectively turning an O(N)\nalgorithm into an O(1) one.\n\nRegtested on x86_64-pc-linux-gnu.\n\nlibgfortran/ChangeLog:\n\n2019-09-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\t* intrinsics/random.c (master_init): Replace with\n\tmaster_state.init.\n\t(njumps): Remove variable.\n\t(master_state): Make instance of struct prng_state.\n\t(init_rand_state): When jumping, update the master_state once\n\tinstead of keeping track of how many jumps need to be done.\n\t(SZU64): Modify to handle new master_state.\n\t(SZ): Likewise.\n\t(random_seed_i4): Likewise.\n\t(random_seed_i8): Likewise.\n\nFrom-SVN: r275397", "tree": {"sha": "00b19c147fb98d452597b2fdbda9432eb4395450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00b19c147fb98d452597b2fdbda9432eb4395450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0eaee4abb1d99f6165769a8ad2bfbf818860f40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eaee4abb1d99f6165769a8ad2bfbf818860f40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eaee4abb1d99f6165769a8ad2bfbf818860f40b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eaee4abb1d99f6165769a8ad2bfbf818860f40b/comments", "author": null, "committer": null, "parents": [{"sha": "f44526e367a99b8699fbdc31bb9bcc0618dbe072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44526e367a99b8699fbdc31bb9bcc0618dbe072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f44526e367a99b8699fbdc31bb9bcc0618dbe072"}], "stats": {"total": 59, "additions": 32, "deletions": 27}, "files": [{"sha": "8833c3049670b3f6cc22151a4d25017028cfd25c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eaee4abb1d99f6165769a8ad2bfbf818860f40b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eaee4abb1d99f6165769a8ad2bfbf818860f40b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=0eaee4abb1d99f6165769a8ad2bfbf818860f40b", "patch": "@@ -1,3 +1,16 @@\n+2019-09-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\t* intrinsics/random.c (master_init): Replace with\n+\tmaster_state.init.\n+\t(njumps): Remove variable.\n+\t(master_state): Make instance of struct prng_state.\n+\t(init_rand_state): When jumping, update the master_state once\n+\tinstead of keeping track of how many jumps need to be done.\n+\t(SZU64): Modify to handle new master_state.\n+\t(SZ): Likewise.\n+\t(random_seed_i4): Likewise.\n+\t(random_seed_i8): Likewise.\n+\n 2019-08-17  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR fortran/68401"}, {"sha": "bdad208bd981b2072ef77adf2c20de4190be4584", "filename": "libgfortran/intrinsics/random.c", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0eaee4abb1d99f6165769a8ad2bfbf818860f40b/libgfortran%2Fintrinsics%2Frandom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0eaee4abb1d99f6165769a8ad2bfbf818860f40b/libgfortran%2Fintrinsics%2Frandom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Frandom.c?ref=0eaee4abb1d99f6165769a8ad2bfbf818860f40b", "patch": "@@ -194,13 +194,10 @@ typedef struct\n prng_state;\n \n \n-/* master_init, njumps, and master_state are the only variables\n-   protected by random_lock.  */\n-static bool master_init;\n-static unsigned njumps; /* How many times we have jumped.  */\n-static uint64_t master_state[] = {\n-  0xad63fa1ed3b55f36ULL, 0xd94473e78978b497ULL, 0xbc60592a98172477ULL,\n-  0xa3de7c6e81265301ULL\n+/* master_state is the only variable protected by random_lock.  */\n+static prng_state master_state = { .init = false, .s = {\n+    0xad63fa1ed3b55f36ULL, 0xd94473e78978b497ULL, 0xbc60592a98172477ULL,\n+    0xa3de7c6e81265301ULL }\n };\n \n \n@@ -353,24 +350,21 @@ init_rand_state (prng_state* rs, const bool locked)\n {\n   if (!locked)\n     __gthread_mutex_lock (&random_lock);\n-  if (!master_init)\n+  if (!master_state.init)\n     {\n       uint64_t os_seed;\n       getosrandom (&os_seed, sizeof (os_seed));\n-      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)\n+      for (uint64_t i = 0; i < sizeof (master_state.s) / sizeof (uint64_t); i++)\n \t{\n           os_seed = splitmix64 (os_seed);\n-          master_state[i] = os_seed;\n+          master_state.s[i] = os_seed;\n         }\n-      njumps = 0;\n-      master_init = true;\n+      master_state.init = true;\n     }\n-  memcpy (&rs->s, master_state, sizeof (master_state));\n-  unsigned n = njumps++;\n+  memcpy (&rs->s, master_state.s, sizeof (master_state.s));\n+  jump (&master_state);\n   if (!locked)\n     __gthread_mutex_unlock (&random_lock);\n-  for (unsigned i = 0; i < n; i++)\n-    jump (rs);\n   rs->init = true;\n }\n \n@@ -727,7 +721,7 @@ arandom_r16 (gfc_array_r16 *x)\n \n \n /* Number of elements in master_state array.  */\n-#define SZU64 (sizeof (master_state) / sizeof (uint64_t))\n+#define SZU64 (sizeof (master_state.s) / sizeof (uint64_t))\n \n \n /* Keys for scrambling the seed in order to avoid poor seeds.  */\n@@ -757,7 +751,7 @@ void\n random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n {\n   uint64_t seed[SZU64];\n-#define SZ (sizeof (master_state) / sizeof (GFC_INTEGER_4))\n+#define SZ (sizeof (master_state.s) / sizeof (GFC_INTEGER_4))\n \n   /* Check that we only have one argument present.  */\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n@@ -800,7 +794,7 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n      a processor-dependent value to the seed.\"  */\n   if (size == NULL && put == NULL && get == NULL)\n     {\n-      master_init = false;\n+      master_state.init = false;\n       init_rand_state (rs, true);\n     }\n \n@@ -822,9 +816,8 @@ random_seed_i4 (GFC_INTEGER_4 *size, gfc_array_i4 *put, gfc_array_i4 *get)\n \n       /* We put it after scrambling the bytes, to paper around users who\n \t provide seeds with quality only in the lower or upper part.  */\n-      scramble_seed (master_state, seed);\n-      njumps = 0;\n-      master_init = true;\n+      scramble_seed (master_state.s, seed);\n+      master_state.init = true;\n       init_rand_state (rs, true);\n     }\n \n@@ -844,7 +837,7 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n   if ((size ? 1 : 0) + (put ? 1 : 0) + (get ? 1 : 0) > 1)\n     runtime_error (\"RANDOM_SEED should have at most one argument present.\");\n \n-#define SZ (sizeof (master_state) / sizeof (GFC_INTEGER_8))\n+#define SZ (sizeof (master_state.s) / sizeof (GFC_INTEGER_8))\n   if (size != NULL)\n     *size = SZ;\n \n@@ -881,7 +874,7 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n      a processor-dependent value to the seed.\"  */\n   if (size == NULL && put == NULL && get == NULL)\n     {\n-      master_init = false;\n+      master_state.init = false;\n       init_rand_state (rs, true);\n     }\n \n@@ -900,9 +893,8 @@ random_seed_i8 (GFC_INTEGER_8 *size, gfc_array_i8 *put, gfc_array_i8 *get)\n \tmemcpy (&seed[i], &(put->base_addr[i * GFC_DESCRIPTOR_STRIDE(put,0)]),\n \t\tsizeof (GFC_UINTEGER_8));\n \n-      scramble_seed (master_state, seed);\n-      njumps = 0;\n-      master_init = true;\n+      scramble_seed (master_state.s, seed);\n+      master_state.init = true;\n       init_rand_state (rs, true);\n      }\n "}]}