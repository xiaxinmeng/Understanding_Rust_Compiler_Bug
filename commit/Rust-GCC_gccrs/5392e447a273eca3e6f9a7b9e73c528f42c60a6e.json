{"sha": "5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM5MmU0NDdhMjczZWNhM2U2ZjlhN2I5ZTczYzUyOGY0MmM2MGE2ZQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-09-10T07:18:52Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-09-10T07:18:52Z"}, "message": "re PR middle-end/37385 (ICE in set_mem_alias_set with the vectorizer and function pointers)\n\n\tPR tree-optimization/37385\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Add a new argument,\n\tand use it as a vector type if not NULL.\n\t(vectorizable_store): Call vect_create_data_ref_ptr with the type of\n\tvectorized rhs.\n\t(vect_setup_realignment): Call vect_create_data_ref_ptr with additional\n\targument.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r140195", "tree": {"sha": "6ce0f40db009a81a6024584a71b687b32f611a99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ce0f40db009a81a6024584a71b687b32f611a99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/comments", "author": null, "committer": null, "parents": [{"sha": "4e7f50e5e4100546f2579cc0a8779a5cad4061e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e7f50e5e4100546f2579cc0a8779a5cad4061e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e7f50e5e4100546f2579cc0a8779a5cad4061e2"}], "stats": {"total": 53, "additions": 47, "deletions": 6}, "files": [{"sha": "93421f7153276d54b98ed083d5417f9ea37e1c27", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "patch": "@@ -1,3 +1,14 @@\n+2008-09-10  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37385\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Add a new argument,\n+\tand use it as a vector type if not NULL.\n+\t(vectorizable_store): Call vect_create_data_ref_ptr with the type of \n+\tvectorized rhs.\n+\t(vect_setup_realignment): Call vect_create_data_ref_ptr with additional\n+\targument.\n+\t(vectorizable_load): Likewise.\n+\n 2008-09-10  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.md (SWI32): New mode iterator."}, {"sha": "b9e444298aafd51f6d3d5a1d416db579b649ffa9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "patch": "@@ -1,3 +1,9 @@\n+2008-09-10  Martin Michlmayr <tbm@cyrius.com>\n+\t    Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37385\n+\t* gcc.dg/vect/pr37385.c: New test.\n+\n 2008-09-09  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR rtl-optimization/37435"}, {"sha": "d6a477e634c7a5865171343b8cd374a24e95bdbd", "filename": "gcc/testsuite/gcc.dg/vect/pr37385.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37385.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37385.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr37385.c?ref=5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "patch": "@@ -0,0 +1,20 @@\n+/* Testcase by Martin Michlmayr <tbm@cyrius.com> */\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+typedef int int_t;\n+typedef void (*fun_t) (int);\n+fun_t fun_tab[400] __attribute__ ((__aligned__(16)));\n+\n+void foo (int_t a);\n+\n+void\n+bar ()\n+{\n+  int i;\n+\n+  for (i = 0; i < 400; i++)\n+      fun_tab[i] = foo;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a25960b58ec4c77c2c530bcebb667111c46d95ea", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5392e447a273eca3e6f9a7b9e73c528f42c60a6e/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5392e447a273eca3e6f9a7b9e73c528f42c60a6e", "patch": "@@ -50,7 +50,7 @@ static bool vect_transform_stmt (gimple, gimple_stmt_iterator *, bool *,\n \t\t\t\t slp_tree, slp_instance);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n-  (gimple, struct loop*, tree, tree *, gimple *, bool, bool *);\n+  (gimple, struct loop*, tree, tree *, gimple *, bool, bool *, tree);\n static tree vect_create_addr_base_for_vector_ref \n   (gimple, gimple_seq *, tree, struct loop *);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n@@ -981,6 +981,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n         by the data-ref in STMT.\n    4. ONLY_INIT: indicate if vp is to be updated in the loop, or remain\n         pointing to the initial address.\n+   5. TYPE: if not NULL indicates the required type of the data-ref.\n \n    Output:\n    1. Declare a new ptr to vector_type, and have it point to the base of the\n@@ -1010,7 +1011,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n static tree\n vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n \t\t\t  tree offset, tree *initial_address, gimple *ptr_incr,\n-\t\t\t  bool only_init, bool *inv_p)\n+\t\t\t  bool only_init, bool *inv_p, tree type)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1069,7 +1070,10 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop,\n     }\n \n   /** (1) Create the new vector-pointer variable:  **/\n-  vect_ptr_type = build_pointer_type (vectype);\n+  if (type)\n+    vect_ptr_type = build_pointer_type (type);\n+  else\n+    vect_ptr_type = build_pointer_type (vectype);\n \n   vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                     get_name (base_name));\n@@ -5372,7 +5376,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n \t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, NULL, NULL_TREE, \n \t\t\t\t\t\t  &dummy, &ptr_incr, false, \n-\t\t\t\t\t\t  &inv_p);\n+\t\t\t\t\t\t  &inv_p, TREE_TYPE (vec_oprnd));\n \t  gcc_assert (!inv_p);\n \t}\n       else \n@@ -5610,7 +5614,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n       pe = loop_preheader_edge (loop_for_initial_load);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       ptr = vect_create_data_ref_ptr (stmt, loop_for_initial_load, NULL_TREE,\n-\t\t\t\t      &init_addr, &inc, true, &inv_p);\n+\t\t                  &init_addr, &inc, true, &inv_p, NULL_TREE);\n       data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n       new_stmt = gimple_build_assign (vec_dest, data_ref);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n@@ -6578,7 +6582,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n         dataref_ptr = vect_create_data_ref_ptr (first_stmt,\n \t\t\t\t\t        at_loop, offset, \n \t\t\t\t\t\t&dummy, &ptr_incr, false, \n-\t\t\t\t\t\t&inv_p);\n+\t\t\t\t\t\t&inv_p, NULL_TREE);\n       else\n         dataref_ptr = \n \t\tbump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt, NULL_TREE);"}]}