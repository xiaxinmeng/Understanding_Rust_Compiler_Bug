{"sha": "8b26c5492bf1d4c7acab18eff1e78a239af779a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIyNmM1NDkyYmYxZDRjN2FjYWIxOGVmZjFlNzhhMjM5YWY3NzlhMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-09T15:16:42Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-09T15:16:42Z"}, "message": "Add vect_perm3_* target selectors\n\nSLP load permutation fails if any individual permutation requires more\nthan two vector inputs.  For 128-bit vectors, it's possible to permute\n3 contiguous loads of 32-bit and 8-bit elements, but not 16-bit elements\nor 64-bit elements.  The results are reversed for 256-bit vectors,\nand so on for wider vectors.\n\nThis patch adds a routine that tests whether a permute will require\nthree vectors for a given vector count and element size, then adds\nvect_perm3_* target selectors for the cases that we currently use.\n\n2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/sourcebuild.texi (vect_perm_short, vect_perm_byte): Document\n\tpreviously undocumented selectors.\n\t(vect_perm3_byte, vect_perm3_short, vect_perm3_int): Document.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (vect_perm_supported): New proc.\n\t(check_effective_target_vect_perm3_int): Likewise.\n\t(check_effective_target_vect_perm3_short): Likewise.\n\t(check_effective_target_vect_perm3_byte): Likewise.\n\t* gcc.dg/vect/slp-perm-1.c: Expect SLP load permutation to\n\tsucceed if vect_perm3_int.\n\t* gcc.dg/vect/slp-perm-5.c: Likewise.\n\t* gcc.dg/vect/slp-perm-6.c: Likewise.\n\t* gcc.dg/vect/slp-perm-7.c: Likewise.\n\t* gcc.dg/vect/slp-perm-8.c: Likewise vect_perm3_byte.\n\t* gcc.dg/vect/slp-perm-9.c: Likewise vect_perm3_short.\n\tUse vect_perm_short instead of vect_perm.  Add a scan-tree-dump-not\n\ttest for vect_perm3_short targets.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r254592", "tree": {"sha": "2c159c59da94cd3e852865056a6b8f108912306a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c159c59da94cd3e852865056a6b8f108912306a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b26c5492bf1d4c7acab18eff1e78a239af779a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b26c5492bf1d4c7acab18eff1e78a239af779a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b26c5492bf1d4c7acab18eff1e78a239af779a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b26c5492bf1d4c7acab18eff1e78a239af779a1/comments", "author": null, "committer": null, "parents": [{"sha": "83f15782dde23b068a806b3f7e0c253c49d148a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83f15782dde23b068a806b3f7e0c253c49d148a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83f15782dde23b068a806b3f7e0c253c49d148a2"}], "stats": {"total": 171, "additions": 156, "deletions": 15}, "files": [{"sha": "9bb6826365c8e7ee7e62ffd6decc7115ba3417e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -1,3 +1,11 @@\n+2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/sourcebuild.texi (vect_perm_short, vect_perm_byte): Document\n+\tpreviously undocumented selectors.\n+\t(vect_perm3_byte, vect_perm3_short, vect_perm3_int): Document.\n+\n 2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* doc/rtl.texi (const_vector): Say that elements can be"}, {"sha": "b36c8129690a94a0cf05f5521815285273de2322", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -1448,6 +1448,32 @@ element types.\n @item vect_perm\n Target supports vector permutation.\n \n+@item vect_perm_byte\n+Target supports permutation of vectors with 8-bit elements.\n+\n+@item vect_perm_short\n+Target supports permutation of vectors with 16-bit elements.\n+\n+@item vect_perm3_byte\n+Target supports permutation of vectors with 8-bit elements, and for the\n+default vector length it is possible to permute:\n+@example\n+@{ a0, a1, a2, b0, b1, b2, @dots{} @}\n+@end example\n+to:\n+@example\n+@{ a0, a0, a0, b0, b0, b0, @dots{} @}\n+@{ a1, a1, a1, b1, b1, b1, @dots{} @}\n+@{ a2, a2, a2, b2, b2, b2, @dots{} @}\n+@end example\n+using only two-vector permutes, regardless of how long the sequence is.\n+\n+@item vect_perm3_int\n+Like @code{vect_perm3_byte}, but for 32-bit elements.\n+\n+@item vect_perm3_short\n+Like @code{vect_perm3_byte}, but for 16-bit elements.\n+\n @item vect_shift\n Target supports a hardware vector shift operation.\n "}, {"sha": "fcefc7903b88de7bd4daf576a43167c412133779", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -1,3 +1,21 @@\n+2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* lib/target-supports.exp (vect_perm_supported): New proc.\n+\t(check_effective_target_vect_perm3_int): Likewise.\n+\t(check_effective_target_vect_perm3_short): Likewise.\n+\t(check_effective_target_vect_perm3_byte): Likewise.\n+\t* gcc.dg/vect/slp-perm-1.c: Expect SLP load permutation to\n+\tsucceed if vect_perm3_int.\n+\t* gcc.dg/vect/slp-perm-5.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-6.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-7.c: Likewise.\n+\t* gcc.dg/vect/slp-perm-8.c: Likewise vect_perm3_byte.\n+\t* gcc.dg/vect/slp-perm-9.c: Likewise vect_perm3_short.\n+\tUse vect_perm_short instead of vect_perm.  Add a scan-tree-dump-not\n+\ttest for vect_perm3_short targets.\n+\n 2017-11-09  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "6bd16ef43b0a96ab2e5cc1d21e8209569cc6fc56", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-1.c?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -80,9 +80,9 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm && {! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm && vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */\n "}, {"sha": "7e132e1262ea3497c9c5f915bc3d9fcf04efdd48", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-5.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-5.c?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -104,9 +104,9 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm && {! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm && vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */\n "}, {"sha": "f97887fa8ba3c37d95796054cb5307ddf1ab5415", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-6.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-6.c?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -103,8 +103,8 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm && {! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" { target { vect_perm3_int && {! vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm && vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "baf7f7888a31772c69537eb09ae9864dee599c62", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-7.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-7.c?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -96,8 +96,8 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target vect_perm } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm && {! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm3_int && { ! vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm && vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_int && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "94d4455dfd9897f6fecf4a3a7eb7ac6a32b0523a", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-8.c?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -60,8 +60,8 @@ int main (int argc, const char* argv[])\n }\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_perm_byte } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm_byte && {! vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm3_byte && { ! vect_load_lanes } } } } } */\n /* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target vect_load_lanes } } } */\n-/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm_byte && vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump \"note: Built SLP cancelled: can use load/store-lanes\" \"vect\" { target { vect_perm3_byte && vect_load_lanes } } } } */\n /* { dg-final { scan-tree-dump \"LOAD_LANES\" \"vect\" { target vect_load_lanes } } } */\n /* { dg-final { scan-tree-dump \"STORE_LANES\" \"vect\" { target vect_load_lanes } } } */"}, {"sha": "0b54b3b303bf81f782df68f0afa8ea404c54c39c", "filename": "gcc/testsuite/gcc.dg/vect/slp-perm-9.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-perm-9.c?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -57,9 +57,10 @@ int main (int argc, const char* argv[])\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\"  { target { {! vect_perm } || {! vect_sizes_16B_8B } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { { vect_perm } && { vect_sizes_16B_8B } } } } } */\n-/* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target vect_perm_short } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target { {! vect_perm } || {! vect_sizes_32B_16B } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { { vect_perm } && { vect_sizes_32B_16B } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 2 \"vect\" { target { ! { vect_perm_short || vect_load_lanes } } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_perm_short || vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump-times \"permutation requires at least three vectors\" 1 \"vect\" { target { vect_perm_short && { ! vect_perm3_short } } } } } */\n+/* { dg-final { scan-tree-dump-not \"permutation requires at least three vectors\" \"vect\" { target vect_perm3_short } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 0 \"vect\" { target { { ! vect_perm3_short } || vect_load_lanes } } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { vect_perm3_short && { ! vect_load_lanes } } } } } */\n "}, {"sha": "8043d24976493fa1f481c9a8d6ddb9a85c2828a5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b26c5492bf1d4c7acab18eff1e78a239af779a1/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=8b26c5492bf1d4c7acab18eff1e78a239af779a1", "patch": "@@ -5547,6 +5547,78 @@ proc check_effective_target_vect_perm { } {\n     return $et_vect_perm_saved($et_index)\n }\n \n+# Return 1 if, for some VF:\n+#\n+# - the target's default vector size is VF * ELEMENT_BITS bits\n+#\n+# - it is possible to implement the equivalent of:\n+#\n+#      int<ELEMENT_BITS>_t s1[COUNT][COUNT * VF], s2[COUNT * VF];\n+#      for (int i = 0; i < COUNT; ++i)\n+#        for (int j = 0; j < COUNT * VF; ++j)\n+#          s1[i][j] = s2[j - j % COUNT + i]\n+#\n+#   using only a single 2-vector permute for each vector in s1.\n+#\n+# E.g. for COUNT == 3 and vector length 4, the two arrays would be:\n+#\n+#    s2    | a0 a1 a2 a3 | b0 b1 b2 b3 | c0 c1 c2 c3\n+#    ------+-------------+-------------+------------\n+#    s1[0] | a0 a0 a0 a3 | a3 a3 b2 b2 | b2 c1 c1 c1\n+#    s1[1] | a1 a1 a1 b0 | b0 b0 b3 b3 | b3 c2 c2 c2\n+#    s1[2] | a2 a2 a2 b1 | b1 b1 c0 c0 | c0 c3 c3 c3\n+#\n+# Each s1 permute requires only two of a, b and c.\n+#\n+# The distance between the start of vector n in s1[0] and the start\n+# of vector n in s2 is:\n+#\n+#    A = (n * VF) % COUNT\n+#\n+# The corresponding value for the end of vector n is:\n+#\n+#    B = (n * VF + VF - 1) % COUNT\n+#\n+# Subtracting i from each value gives the corresponding difference\n+# for s1[i].  The condition being tested by this function is false\n+# iff A - i > 0 and B - i < 0 for some i and n, such that the first\n+# element for s1[i] comes from vector n - 1 of s2 and the last element\n+# comes from vector n + 1 of s2.  The condition is therefore true iff\n+# A <= B for all n.  This is turn means the condition is true iff:\n+#\n+#    (n * VF) % COUNT + (VF - 1) % COUNT < COUNT\n+#\n+# for all n.  COUNT - (n * VF) % COUNT is bounded by gcd (VF, COUNT),\n+# and will be that value for at least one n in [0, COUNT), so we want:\n+#\n+#    (VF - 1) % COUNT < gcd (VF, COUNT)\n+\n+proc vect_perm_supported { count element_bits } {\n+    set vector_bits [lindex [available_vector_sizes] 0]\n+    if { $vector_bits <= 0 } {\n+\treturn 0\n+    }\n+    set vf [expr { $vector_bits / $element_bits }]\n+\n+    # Compute gcd (VF, COUNT).\n+    set gcd $vf\n+    set temp1 $count\n+    while { $temp1 > 0 } {\n+\tset temp2 [expr { $gcd % $temp1 }]\n+\tset gcd $temp1\n+\tset temp1 $temp2\n+    }\n+    return [expr { ($vf - 1) % $count < $gcd }]\n+}\n+\n+# Return 1 if the target supports SLP permutation of 3 vectors when each\n+# element has 32 bits.\n+\n+proc check_effective_target_vect_perm3_int { } {\n+    return [expr { [check_effective_target_vect_perm]\n+\t\t   && [vect_perm_supported 3 32] }]\n+}\n+\n # Return 1 if the target plus current options supports vector permutation\n # on byte-sized elements, 0 otherwise.\n #\n@@ -5578,6 +5650,14 @@ proc check_effective_target_vect_perm_byte { } {\n     return $et_vect_perm_byte_saved($et_index)\n }\n \n+# Return 1 if the target supports SLP permutation of 3 vectors when each\n+# element has 8 bits.\n+\n+proc check_effective_target_vect_perm3_byte { } {\n+    return [expr { [check_effective_target_vect_perm_byte]\n+\t\t   && [vect_perm_supported 3 8] }]\n+}\n+\n # Return 1 if the target plus current options supports vector permutation\n # on short-sized elements, 0 otherwise.\n #\n@@ -5609,6 +5689,14 @@ proc check_effective_target_vect_perm_short { } {\n     return $et_vect_perm_short_saved($et_index)\n }\n \n+# Return 1 if the target supports SLP permutation of 3 vectors when each\n+# element has 16 bits.\n+\n+proc check_effective_target_vect_perm3_short { } {\n+    return [expr { [check_effective_target_vect_perm_short]\n+\t\t   && [vect_perm_supported 3 16] }]\n+}\n+\n # Return 1 if the target plus current options supports folding of\n # copysign into XORSIGN.\n #"}]}