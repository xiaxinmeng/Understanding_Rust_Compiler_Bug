{"sha": "599f37b6d3945ce70d5c75ca42ab156b3f3c5e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk5ZjM3YjZkMzk0NWNlNzBkNWM3NWNhNDJhYjE1NmIzZjNjNWU2NQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-02-24T17:42:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-02-24T17:42:40Z"}, "message": "calls.c (compute_argument_block_size): New function, extracted from expand_calls.\n\n        * calls.c (compute_argument_block_size): New function, extracted from\n        expand_calls.\n        (expand_calls): Use compute_argument_block_size.  Delete\n        original_args_size, use unadjusted_args_size instead.\n\nFrom-SVN: r25411", "tree": {"sha": "594e0811d904721b6390185d9d9d31a0b683753a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/594e0811d904721b6390185d9d9d31a0b683753a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65/comments", "author": null, "committer": null, "parents": [{"sha": "db35306d6fce3e40bc27fa81e223aa875c97db40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db35306d6fce3e40bc27fa81e223aa875c97db40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db35306d6fce3e40bc27fa81e223aa875c97db40"}], "stats": {"total": 132, "additions": 80, "deletions": 52}, "files": [{"sha": "4677929f9a333530f689458e4feb8307d49fce8e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=599f37b6d3945ce70d5c75ca42ab156b3f3c5e65", "patch": "@@ -1,5 +1,10 @@\n Wed Feb 24 14:03:54 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (compute_argument_block_size): New function, extracted from\n+\texpand_calls.\n+\t(expand_calls): Use compute_argument_block_size.  Delete\n+\toriginal_args_size, use unadjusted_args_size instead.\n+\n \t* calls.c (precompute_arguments): New function, extracted from\n \texpand_call.\n \t(expand_call): Use precompute_arguments."}, {"sha": "d0ca24ad81f8688320f419b23b99cc71fec85367", "filename": "gcc/calls.c", "status": "modified", "additions": 75, "deletions": 52, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/599f37b6d3945ce70d5c75ca42ab156b3f3c5e65/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=599f37b6d3945ce70d5c75ca42ab156b3f3c5e65", "patch": "@@ -143,7 +143,8 @@ static int finalize_must_preallocate\t\tPROTO ((int, int,\n static void precompute_arguments \t\tPROTO ((int, int, int,\n \t\t\t\t\t\t\tstruct arg_data *,\n \t\t\t\t\t\t\tstruct args_size *));\n-\n+static int compute_argument_block_size\t\tPROTO ((int, \n+\t\t\t\t\t\t\tstruct args_size *));\n \n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n static rtx save_fixed_argument_area\tPROTO ((int, rtx, int *, int *));\n@@ -829,6 +830,70 @@ store_unaligned_arguments_into_pseudos (args, num_actuals)\n       }\n }\n \n+/* Update ARGS_SIZE to contain the total size for the argument block.\n+   Return the original constant component of the argument block's size.\n+\n+   REG_PARM_STACK_SPACE holds the number of bytes of stack space reserved\n+   for arguments passed in registers.  */\n+\n+static int\n+compute_argument_block_size (reg_parm_stack_space, args_size)\n+     int reg_parm_stack_space;\n+     struct args_size *args_size;\n+{\n+  int unadjusted_args_size = args_size->constant;\n+\n+  /* Compute the actual size of the argument block required.  The variable\n+     and constant sizes must be combined, the size may have to be rounded,\n+     and there may be a minimum required size.  */\n+\n+  if (args_size->var)\n+    {\n+      args_size->var = ARGS_SIZE_TREE (*args_size);\n+      args_size->constant = 0;\n+\n+#ifdef PREFERRED_STACK_BOUNDARY\n+      if (PREFERRED_STACK_BOUNDARY != BITS_PER_UNIT)\n+\targs_size->var = round_up (args_size->var, STACK_BYTES);\n+#endif\n+\n+      if (reg_parm_stack_space > 0)\n+\t{\n+\t  args_size->var\n+\t    = size_binop (MAX_EXPR, args_size->var,\n+\t\t\t  size_int (reg_parm_stack_space));\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+\t  /* The area corresponding to register parameters is not to count in\n+\t     the size of the block we need.  So make the adjustment.  */\n+\t  args_size->var\n+\t    = size_binop (MINUS_EXPR, args_size->var,\n+\t\t\t  size_int (reg_parm_stack_space));\n+#endif\n+\t}\n+    }\n+  else\n+    {\n+#ifdef PREFERRED_STACK_BOUNDARY\n+      args_size->constant = (((args_size->constant + (STACK_BYTES - 1))\n+\t\t\t      / STACK_BYTES) * STACK_BYTES);\n+#endif\n+\n+      args_size->constant = MAX (args_size->constant,\n+\t\t\t\t reg_parm_stack_space);\n+\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+      if (reg_parm_stack_space == 0)\n+\targs_size->constant = 0;\n+#endif\n+\n+#ifndef OUTGOING_REG_PARM_STACK_SPACE\n+      args_size->constant -= reg_parm_stack_space;\n+#endif\n+    }\n+  return unadjusted_args_size;\n+}\n+\n /* Precompute parameters has needed for a function call.\n \n    IS_CONST indicates the target function is a pure function.\n@@ -959,6 +1024,7 @@ finalize_must_preallocate (must_preallocate, num_actuals, args, args_size)\n     }\n   return must_preallocate;\n }\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -1016,7 +1082,7 @@ expand_call (exp, target, ignore)\n   /* Total size in bytes of all the stack-parms scanned so far.  */\n   struct args_size args_size;\n   /* Size of arguments before any adjustments (such as rounding).  */\n-  struct args_size original_args_size;\n+  int unadjusted_args_size;\n   /* Data on reg parms scanned so far.  */\n   CUMULATIVE_ARGS args_so_far;\n   /* Nonzero if a reg parm has been scanned.  */\n@@ -1648,11 +1714,6 @@ expand_call (exp, target, ignore)\n \t\t\t\t\t\t     args_size.var);\n #endif\n       \n-  /* Compute the actual size of the argument block required.  The variable\n-     and constant sizes must be combined, the size may have to be rounded,\n-     and there may be a minimum required size.  */\n-\n-  original_args_size = args_size;\n   if (args_size.var)\n     {\n       /* If this function requires a variable-sized argument list, don't try to\n@@ -1662,49 +1723,13 @@ expand_call (exp, target, ignore)\n \n       is_const = 0;\n       must_preallocate = 1;\n-\n-      args_size.var = ARGS_SIZE_TREE (args_size);\n-      args_size.constant = 0;\n-\n-#ifdef PREFERRED_STACK_BOUNDARY\n-      if (PREFERRED_STACK_BOUNDARY != BITS_PER_UNIT)\n-\targs_size.var = round_up (args_size.var, STACK_BYTES);\n-#endif\n-\n-      if (reg_parm_stack_space > 0)\n-\t{\n-\t  args_size.var\n-\t    = size_binop (MAX_EXPR, args_size.var,\n-\t\t\t  size_int (reg_parm_stack_space));\n-\n-#ifndef OUTGOING_REG_PARM_STACK_SPACE\n-\t  /* The area corresponding to register parameters is not to count in\n-\t     the size of the block we need.  So make the adjustment.  */\n-\t  args_size.var\n-\t    = size_binop (MINUS_EXPR, args_size.var,\n-\t\t\t  size_int (reg_parm_stack_space));\n-#endif\n-\t}\n     }\n-  else\n-    {\n-#ifdef PREFERRED_STACK_BOUNDARY\n-      args_size.constant = (((args_size.constant + (STACK_BYTES - 1))\n-\t\t\t     / STACK_BYTES) * STACK_BYTES);\n-#endif\n-\n-      args_size.constant = MAX (args_size.constant,\n-\t\t\t\treg_parm_stack_space);\n-\n-#ifdef MAYBE_REG_PARM_STACK_SPACE\n-      if (reg_parm_stack_space == 0)\n-\targs_size.constant = 0;\n-#endif\n \n-#ifndef OUTGOING_REG_PARM_STACK_SPACE\n-      args_size.constant -= reg_parm_stack_space;\n-#endif\n-    }\n+  /* Compute the actual size of the argument block required.  The variable\n+     and constant sizes must be combined, the size may have to be rounded,\n+     and there may be a minimum required size.  */\n+  unadjusted_args_size\n+    = compute_argument_block_size (reg_parm_stack_space, &args_size);\n \n   /* Now make final decision about preallocating stack space.  */\n   must_preallocate = finalize_must_preallocate (must_preallocate,\n@@ -1937,8 +1962,7 @@ expand_call (exp, target, ignore)\n   /* If we push args individually in reverse order, perform stack alignment\n      before the first push (the last arg).  */\n   if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n+    anti_adjust_stack (GEN_INT (args_size.constant - unadjusted_args_size));\n #endif\n #endif\n \n@@ -2032,8 +2056,7 @@ expand_call (exp, target, ignore)\n   /* If we pushed args in forward order, perform stack alignment\n      after pushing the last arg.  */\n   if (argblock == 0)\n-    anti_adjust_stack (GEN_INT (args_size.constant\n-\t\t\t\t- original_args_size.constant));\n+    anti_adjust_stack (GEN_INT (args_size.constant - unadjusted_args_size));\n #endif\n #endif\n "}]}