{"sha": "db7ffcabaf01826192370231d15b64cc15958aeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI3ZmZjYWJhZjAxODI2MTkyMzcwMjMxZDE1YjY0Y2MxNTk1OGFlYg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-05-20T14:56:47Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-05-20T14:56:47Z"}, "message": "re PR fortran/65548 (gfc_conv_procedure_call)\n\ngcc/fortran/ChangeLog:\n\n2015-05-19  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/65548\n\t* trans-stmt.c (gfc_trans_allocate): Always retrieve the\n\tdescriptor or a reference to a source= expression for\n\tarrays and non-arrays, respectively.  Use a temporary\n\tsymbol and gfc_trans_assignment for all source=\n\tassignments to allocated objects besides for class and\n\tderived types.\n\ngcc/testsuite/ChangeLog:\n\n2015-05-19  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/65548\n\t* gfortran.dg/allocate_with_source_5.f90: Extend test.\n\nFrom-SVN: r223445", "tree": {"sha": "dee189729a7ec482addf91fb61f0c9f279d87c7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dee189729a7ec482addf91fb61f0c9f279d87c7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db7ffcabaf01826192370231d15b64cc15958aeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7ffcabaf01826192370231d15b64cc15958aeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db7ffcabaf01826192370231d15b64cc15958aeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db7ffcabaf01826192370231d15b64cc15958aeb/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf4ef6f7d4342aff9c7cefeb4bdcffc714806de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf4ef6f7d4342aff9c7cefeb4bdcffc714806de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf4ef6f7d4342aff9c7cefeb4bdcffc714806de9"}], "stats": {"total": 405, "additions": 293, "deletions": 112}, "files": [{"sha": "fa9edb5cf8ab522c57b2d12f026cd43cc3963139", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=db7ffcabaf01826192370231d15b64cc15958aeb", "patch": "@@ -1,3 +1,13 @@\n+2015-05-20  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/65548\n+\t* trans-stmt.c (gfc_trans_allocate): Always retrieve the\n+\tdescriptor or a reference to a source= expression for\n+\tarrays and non-arrays, respectively.  Use a temporary\n+\tsymbol and gfc_trans_assignment for all source=\n+\tassignments to allocated objects besides for class and\n+\tderived types.\n+\n 2015-05-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/66199"}, {"sha": "2c0304b7329d3b894dfdaac33d399ba8b5f91810", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 152, "deletions": 93, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=db7ffcabaf01826192370231d15b64cc15958aeb", "patch": "@@ -5088,7 +5088,7 @@ tree\n gfc_trans_allocate (gfc_code * code)\n {\n   gfc_alloc *al;\n-  gfc_expr *expr;\n+  gfc_expr *expr, *e3rhs = NULL;\n   gfc_se se, se_sz;\n   tree tmp;\n   tree parm;\n@@ -5109,6 +5109,7 @@ gfc_trans_allocate (gfc_code * code)\n   stmtblock_t post;\n   tree nelems;\n   bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set;\n+  gfc_symtree *newsym = NULL;\n \n   if (!code->ext.alloc.list)\n     return NULL_TREE;\n@@ -5148,14 +5149,11 @@ gfc_trans_allocate (gfc_code * code)\n       TREE_USED (label_finish) = 0;\n     }\n \n-  /* When an expr3 is present, try to evaluate it only once.  In most\n-     cases expr3 is invariant for all elements of the allocation list.\n-     Only exceptions are arrays.  Furthermore the standards prevent a\n-     dependency of expr3 on the objects in the allocate list.  Therefore\n-     it is safe to pre-evaluate expr3 for complicated expressions, i.e.\n-     everything not a variable or constant.  When an array allocation\n-     is wanted, then the following block nevertheless evaluates the\n-     _vptr, _len and element_size for expr3.  */\n+  /* When an expr3 is present evaluate it only once.  The standards prevent a\n+     dependency of expr3 on the objects in the allocate list.  An expr3 can\n+     be pre-evaluated in all cases.  One just has to make sure, to use the\n+     correct way, i.e., to get the descriptor or to get a reference\n+     expression.  */\n   if (code->expr3)\n     {\n       bool vtab_needed = false;\n@@ -5168,75 +5166,77 @@ gfc_trans_allocate (gfc_code * code)\n \t   al = al->next)\n \tvtab_needed = (al->expr->ts.type == BT_CLASS);\n \n-      /* A array expr3 needs the scalarizer, therefore do not process it\n-\t here.  */\n-      if (code->expr3->expr_type != EXPR_ARRAY\n-\t  && (code->expr3->rank == 0\n-\t      || code->expr3->expr_type == EXPR_FUNCTION)\n-\t  && (!code->expr3->symtree\n-\t      || !code->expr3->symtree->n.sym->as)\n-\t  && !gfc_is_class_array_ref (code->expr3, NULL))\n-\t{\n-\t  /* When expr3 is a variable, i.e., a very simple expression,\n+      /* When expr3 is a variable, i.e., a very simple expression,\n \t     then convert it once here.  */\n-\t  if ((code->expr3->expr_type == EXPR_VARIABLE)\n-\t      || code->expr3->expr_type == EXPR_CONSTANT)\n-\t    {\n-\t      if (!code->expr3->mold\n-\t\t  || code->expr3->ts.type == BT_CHARACTER\n-\t\t  || vtab_needed)\n-\t\t{\n-\t\t  /* Convert expr3 to a tree.  */\n-\t\t  gfc_init_se (&se, NULL);\n-\t\t  se.want_pointer = 1;\n-\t\t  gfc_conv_expr (&se, code->expr3);\n-\t\t  if (!code->expr3->mold)\n-\t\t    expr3 = se.expr;\n-\t\t  else\n-\t\t    expr3_tmp = se.expr;\n-\t\t  expr3_len = se.string_length;\n-\t\t  gfc_add_block_to_block (&block, &se.pre);\n-\t\t  gfc_add_block_to_block (&post, &se.post);\n-\t\t}\n-\t      /* else expr3 = NULL_TREE set above.  */\n-\t    }\n-\t  else\n+      if (code->expr3->expr_type == EXPR_VARIABLE\n+\t  || code->expr3->expr_type == EXPR_ARRAY\n+\t  || code->expr3->expr_type == EXPR_CONSTANT)\n+\t{\n+\t  if (!code->expr3->mold\n+\t      || code->expr3->ts.type == BT_CHARACTER\n+\t      || vtab_needed)\n \t    {\n-\t      /* In all other cases evaluate the expr3 and create a\n-\t\t temporary.  */\n+\t      /* Convert expr3 to a tree.  */\n \t      gfc_init_se (&se, NULL);\n-\t      if (code->expr3->rank != 0\n-\t\t  && code->expr3->expr_type == EXPR_FUNCTION\n-\t\t  && code->expr3->value.function.isym)\n+\t      /* For all \"simple\" expression just get the descriptor or the\n+\t\t reference, respectively, depending on the rank of the expr.  */\n+\t      if (code->expr3->rank != 0)\n \t\tgfc_conv_expr_descriptor (&se, code->expr3);\n \t      else\n \t\tgfc_conv_expr_reference (&se, code->expr3);\n-\t      if (code->expr3->ts.type == BT_CLASS)\n-\t\tgfc_conv_class_to_class (&se, code->expr3,\n-\t\t\t\t\t code->expr3->ts,\n-\t\t\t\t\t false, true,\n-\t\t\t\t\t false, false);\n+\t      if (!code->expr3->mold)\n+\t\texpr3 = se.expr;\n+\t      else\n+\t\texpr3_tmp = se.expr;\n+\t      expr3_len = se.string_length;\n \t      gfc_add_block_to_block (&block, &se.pre);\n \t      gfc_add_block_to_block (&post, &se.post);\n-\t      /* Prevent aliasing, i.e., se.expr may be already a\n+\t    }\n+\t  /* else expr3 = NULL_TREE set above.  */\n+\t}\n+      else\n+\t{\n+\t  /* In all other cases evaluate the expr3 and create a\n+\t\t temporary.  */\n+\t  gfc_init_se (&se, NULL);\n+\t  symbol_attribute attr;\n+\t  /* Get the descriptor for all arrays, that are not allocatable or\n+\t     pointer, because the latter are descriptors already.  */\n+\t  attr = gfc_expr_attr (code->expr3);\n+\t  if (code->expr3->rank != 0 && !attr.allocatable && !attr.pointer)\n+\t    gfc_conv_expr_descriptor (&se, code->expr3);\n+\t  else\n+\t    gfc_conv_expr_reference (&se, code->expr3);\n+\t  if (code->expr3->ts.type == BT_CLASS)\n+\t    gfc_conv_class_to_class (&se, code->expr3,\n+\t\t\t\t     code->expr3->ts,\n+\t\t\t\t     false, true,\n+\t\t\t\t     false, false);\n+\t  gfc_add_block_to_block (&block, &se.pre);\n+\t  gfc_add_block_to_block (&post, &se.post);\n+\t  /* Prevent aliasing, i.e., se.expr may be already a\n \t\t variable declaration.  */\n-\t      if (!VAR_P (se.expr))\n-\t\t{\n-\t\t  tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t     se.expr);\n-\t\t  tmp = gfc_evaluate_now (tmp, &block);\n-\t\t}\n-\t      else\n-\t\ttmp = se.expr;\n-\t      if (!code->expr3->mold)\n-\t\texpr3 = tmp;\n-\t      else\n-\t\texpr3_tmp = tmp;\n-\t      /* When he length of a char array is easily available\n-\t\t here, fix it for future use.  */\n-\t      if (se.string_length)\n-\t\texpr3_len = gfc_evaluate_now (se.string_length, &block);\n+\t  if (!VAR_P (se.expr))\n+\t    {\n+\t      tree var;\n+\t      tmp = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t se.expr);\n+\t      /* We need a regular (non-UID) symbol here, therefore give a\n+\t\t prefix.  */\n+\t      var = gfc_create_var (TREE_TYPE (tmp), \"atmp\");\n+\t      gfc_add_modify_loc (input_location, &block, var, tmp);\n+\t      tmp = var;\n \t    }\n+\t  else\n+\t    tmp = se.expr;\n+\t  if (!code->expr3->mold)\n+\t    expr3 = tmp;\n+\t  else\n+\t    expr3_tmp = tmp;\n+\t  /* When he length of a char array is easily available\n+\t\t here, fix it for future use.  */\n+\t  if (se.string_length)\n+\t    expr3_len = gfc_evaluate_now (se.string_length, &block);\n \t}\n \n       /* Figure how to get the _vtab entry.  This also obtains the tree\n@@ -5246,11 +5246,15 @@ gfc_trans_allocate (gfc_code * code)\n       if (code->expr3->ts.type == BT_CLASS)\n \t{\n \t  gfc_expr *rhs;\n-\t  /* Polymorphic SOURCE: VPTR must be determined at run time.  */\n-\t  if (expr3 != NULL_TREE && (VAR_P (expr3) || !code->expr3->ref))\n+\t  /* Polymorphic SOURCE: VPTR must be determined at run time.\n+\t     expr3 may be a temporary array declaration, therefore check for\n+\t     GFC_CLASS_TYPE_P before trying to get the _vptr component.  */\n+\t  if (expr3 != NULL_TREE && GFC_CLASS_TYPE_P (TREE_TYPE (expr3))\n+\t      && (VAR_P (expr3) || !code->expr3->ref))\n \t    tmp = gfc_class_vptr_get (expr3);\n \t  else if (expr3_tmp != NULL_TREE\n-\t\t   && (VAR_P (expr3_tmp) ||!code->expr3->ref))\n+\t\t   && GFC_CLASS_TYPE_P (TREE_TYPE (expr3_tmp))\n+\t\t   && (VAR_P (expr3_tmp) || !code->expr3->ref))\n \t    tmp = gfc_class_vptr_get (expr3_tmp);\n \t  else\n \t    {\n@@ -5325,6 +5329,64 @@ gfc_trans_allocate (gfc_code * code)\n \t  else\n \t    expr3_esize = TYPE_SIZE_UNIT (\n \t\t  gfc_typenode_for_spec (&code->expr3->ts));\n+\n+\t  /* The routine gfc_trans_assignment () already implements all\n+\t     techniques needed.  Unfortunately we may have a temporary\n+\t     variable for the source= expression here.  When that is the\n+\t     case convert this variable into a temporary gfc_expr of type\n+\t     EXPR_VARIABLE and used it as rhs for the assignment.  The\n+\t     advantage is, that we get scalarizer support for free,\n+\t     don't have to take care about scalar to array treatment and\n+\t     will benefit of every enhancements gfc_trans_assignment ()\n+\t     gets.  */\n+\t  if (expr3 != NULL_TREE && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))\n+\t    {\n+\t      /* Build a temporary symtree and symbol.  Do not add it to\n+\t\t the current namespace to prevent accidently modifying\n+\t\t a colliding symbol's as.  */\n+\t      newsym = XCNEW (gfc_symtree);\n+\t      /* The name of the symtree should be unique, because\n+\t\t gfc_create_var () took care about generating the\n+\t\t identifier.  */\n+\t      newsym->name = gfc_get_string (IDENTIFIER_POINTER (\n+\t\t\t\t\t       DECL_NAME (expr3)));\n+\t      newsym->n.sym = gfc_new_symbol (newsym->name, NULL);\n+\t      /* The backend_decl is known.  It is expr3, which is inserted\n+\t\t here.  */\n+\t      newsym->n.sym->backend_decl = expr3;\n+\t      e3rhs = gfc_get_expr ();\n+\t      e3rhs->ts = code->expr3->ts;\n+\t      e3rhs->rank = code->expr3->rank;\n+\t      e3rhs->symtree = newsym;\n+\t      /* Mark the symbol referenced or gfc_trans_assignment will\n+\t\t bug.  */\n+\t      newsym->n.sym->attr.referenced = 1;\n+\t      e3rhs->expr_type = EXPR_VARIABLE;\n+\t      /* Set the symbols type, upto it was BT_UNKNOWN.  */\n+\t      newsym->n.sym->ts = e3rhs->ts;\n+\t      /* Check whether the expr3 is array valued.  */\n+\t      if (e3rhs->rank)\n+\t\t{\n+\t\t  gfc_array_spec *arr;\n+\t\t  arr = gfc_get_array_spec ();\n+\t\t  arr->rank = e3rhs->rank;\n+\t\t  arr->type = AS_DEFERRED;\n+\t\t  /* Set the dimension and pointer attribute for arrays\n+\t\t     to be on the safe side.  */\n+\t\t  newsym->n.sym->attr.dimension = 1;\n+\t\t  newsym->n.sym->attr.pointer = 1;\n+\t\t  newsym->n.sym->as = arr;\n+\t\t  gfc_add_full_array_ref (e3rhs, arr);\n+\t\t}\n+\t      else if (POINTER_TYPE_P (TREE_TYPE (expr3)))\n+\t\tnewsym->n.sym->attr.pointer = 1;\n+\t      /* The string length is known to.  Set it for char arrays.  */\n+\t      if (e3rhs->ts.type == BT_CHARACTER)\n+\t\tnewsym->n.sym->ts.u.cl->backend_decl = expr3_len;\n+\t      gfc_commit_symbol (newsym->n.sym);\n+\t    }\n+\t  else\n+\t    e3rhs = gfc_copy_expr (code->expr3);\n \t}\n       gcc_assert (expr3_esize);\n       expr3_esize = fold_convert (sizetype, expr3_esize);\n@@ -5628,13 +5690,12 @@ gfc_trans_allocate (gfc_code * code)\n \t}\n       if (code->expr3 && !code->expr3->mold)\n \t{\n-\t  /* Initialization via SOURCE block\n-\t     (or static default initializer).  */\n-\t  gfc_expr *rhs = gfc_copy_expr (code->expr3);\n+\t  /* Initialization via SOURCE block (or static default initializer).\n+\t     Classes need some special handling, so catch them first.  */\n \t  if (expr3 != NULL_TREE\n \t      && ((POINTER_TYPE_P (TREE_TYPE (expr3))\n \t\t   && TREE_CODE (expr3) != POINTER_PLUS_EXPR)\n-\t\t  || VAR_P (expr3))\n+\t\t  || (VAR_P (expr3) && GFC_CLASS_TYPE_P (TREE_TYPE (expr3))))\n \t      && code->expr3->ts.type == BT_CLASS\n \t      && (expr->ts.type == BT_CLASS\n \t\t  || expr->ts.type == BT_DERIVED))\n@@ -5644,24 +5705,13 @@ gfc_trans_allocate (gfc_code * code)\n \t      tmp = gfc_copy_class_to_class (expr3, to,\n \t\t\t\t\t     nelems, upoly_expr);\n \t    }\n-\t  else if (code->expr3->ts.type == BT_CHARACTER)\n-\t    {\n-\t      tmp = INDIRECT_REF_P (se.expr) ?\n-\t\t\tse.expr :\n-\t\t\tbuild_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t     se.expr);\n-\t      gfc_trans_string_copy (&block, al_len, tmp,\n-\t\t\t\t     code->expr3->ts.kind,\n-\t\t\t\t     expr3_len, expr3,\n-\t\t\t\t     code->expr3->ts.kind);\n-\t      tmp = NULL_TREE;\n-\t    }\n \t  else if (al->expr->ts.type == BT_CLASS)\n \t    {\n \t      gfc_actual_arglist *actual, *last_arg;\n \t      gfc_expr *ppc;\n \t      gfc_code *ppc_code;\n \t      gfc_ref *ref, *dataref;\n+\t      gfc_expr *rhs = gfc_copy_expr (code->expr3);\n \n \t      /* Do a polymorphic deep copy.  */\n \t      actual = gfc_get_actual_arglist ();\n@@ -5688,8 +5738,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t  gfc_ref *ref = dataref->next;\n \t\t  ref->u.ar.type = AR_SECTION;\n \t\t  /* We have to set up the array reference to give ranges\n-\t\t    in all dimensions and ensure that the end and stride\n-\t\t    are set so that the copy can be scalarized.  */\n+\t\t     in all dimensions and ensure that the end and stride\n+\t\t     are set so that the copy can be scalarized.  */\n \t\t  dim = 0;\n \t\t  for (; dim < dataref->u.c.component->as->rank; dim++)\n \t\t    {\n@@ -5758,8 +5808,8 @@ gfc_trans_allocate (gfc_code * code)\n \t\t      gfc_add_len_component (last_arg->expr);\n \t\t    }\n \t\t  else if (code->expr3->ts.type == BT_CHARACTER)\n-\t\t      last_arg->expr =\n-\t\t\t  gfc_copy_expr (code->expr3->ts.u.cl->length);\n+\t\t    last_arg->expr =\n+\t\t\tgfc_copy_expr (code->expr3->ts.u.cl->length);\n \t\t  else\n \t\t    gcc_unreachable ();\n \n@@ -5773,6 +5823,7 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t\t void_type_node, tmp, extcopy, stdcopy);\n \t\t}\n \t      gfc_free_statements (ppc_code);\n+\t      gfc_free_expr (rhs);\n \t    }\n \t  else\n \t    {\n@@ -5781,10 +5832,9 @@ gfc_trans_allocate (gfc_code * code)\n \t      int realloc_lhs = flag_realloc_lhs;\n \t      flag_realloc_lhs = 0;\n \t      tmp = gfc_trans_assignment (gfc_expr_to_initialize (expr),\n-\t\t\t\t\t  rhs, false, false);\n+\t\t\t\t\t  e3rhs, false, false);\n \t      flag_realloc_lhs = realloc_lhs;\n \t    }\n-\t  gfc_free_expr (rhs);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n      else if (code->expr3 && code->expr3->mold\n@@ -5802,6 +5852,15 @@ gfc_trans_allocate (gfc_code * code)\n        gfc_free_expr (expr);\n     } // for-loop\n \n+  if (e3rhs)\n+    {\n+      if (newsym)\n+\t{\n+\t  gfc_free_symbol (newsym->n.sym);\n+\t  XDELETE (newsym);\n+\t}\n+      gfc_free_expr (e3rhs);\n+    }\n   /* STAT.  */\n   if (code->expr1)\n     {"}, {"sha": "1a7a87cae95197d084511d3221c07bb802aae3a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db7ffcabaf01826192370231d15b64cc15958aeb", "patch": "@@ -1,3 +1,8 @@\n+2015-05-20  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/65548\n+\t* gfortran.dg/allocate_with_source_5.f90: Extend test.\n+\n 2015-05-20  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/65447"}, {"sha": "500f0f0817a825fac56ac4dfbc49bc10c1204c99", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_5.f90", "status": "modified", "additions": 126, "deletions": 19, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db7ffcabaf01826192370231d15b64cc15958aeb/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_5.f90?ref=db7ffcabaf01826192370231d15b64cc15958aeb", "patch": "@@ -1,16 +1,16 @@\n ! { dg-do run }\n !\n+! Contributed by Juergen Reuter\n ! Check that pr65548 is fixed.\n-! Contributed by Juergen Reuter  <juergen.reuter@desy.de>\n-\n-module allocate_with_source_5_module\n+!\n \n+module selectors\n   type :: selector_t\n-    integer, dimension(:), allocatable :: map\n-    real, dimension(:), allocatable :: weight\n-  contains\n-    procedure :: init => selector_init\n-  end type selector_t\n+     integer, dimension(:), allocatable :: map\n+     real, dimension(:), allocatable :: weight\n+   contains\n+     procedure :: init => selector_init\n+   end type selector_t\n \n contains\n \n@@ -34,19 +34,126 @@ subroutine selector_init (selector, weight)\n     end if\n   end subroutine selector_init\n \n-end module allocate_with_source_5_module\n+end module selectors\n+\n+module phs_base\n+  type :: flavor_t\n+  contains\n+     procedure :: get_mass => flavor_get_mass\n+  end type flavor_t\n+\n+  type :: phs_config_t\n+     integer :: n_in = 0\n+     type(flavor_t), dimension(:,:), allocatable :: flv\n+  end type phs_config_t\n+\n+  type :: phs_t\n+     class(phs_config_t), pointer :: config => null ()\n+     real, dimension(:), allocatable :: m_in\n+  end type phs_t\n+\n+contains\n+\n+  elemental function flavor_get_mass (flv) result (mass)\n+    real :: mass\n+    class(flavor_t), intent(in) :: flv\n+    mass = 42.0\n+  end function flavor_get_mass\n+\n+  subroutine phs_base_init (phs, phs_config)\n+    class(phs_t), intent(out) :: phs\n+    class(phs_config_t), intent(in), target :: phs_config\n+    phs%config => phs_config\n+    allocate (phs%m_in  (phs%config%n_in), &\n+         source = phs_config%flv(:phs_config%n_in, 1)%get_mass ())\n+  end subroutine phs_base_init\n+\n+end module phs_base\n+\n+module foo\n+  type :: t\n+     integer :: n\n+     real, dimension(:,:), allocatable :: val\n+   contains\n+     procedure :: make => t_make\n+     generic :: get_int => get_int_array, get_int_element\n+     procedure :: get_int_array => t_get_int_array\n+     procedure :: get_int_element => t_get_int_element\n+  end type t\n+\n+contains\n+\n+  subroutine t_make (this)\n+    class(t), intent(inout) :: this\n+    real, dimension(:), allocatable :: int\n+    allocate (int (0:this%n-1), source=this%get_int())\n+  end subroutine t_make\n+\n+  pure function t_get_int_array (this) result (array)\n+    class(t), intent(in) :: this\n+    real, dimension(this%n) :: array\n+    array = this%val (0:this%n-1, 4)\n+  end function t_get_int_array\n+\n+  pure function t_get_int_element (this, set) result (element)\n+    class(t), intent(in) :: this\n+    integer, intent(in) :: set\n+    real :: element\n+    element = this%val (set, 4)\n+  end function t_get_int_element\n+end module foo\n+module foo2\n+  type :: t2\n+     integer :: n\n+     character(32), dimension(:), allocatable :: md5\n+   contains\n+     procedure :: init => t2_init\n+  end type t2\n+\n+contains\n+\n+  subroutine t2_init (this)\n+    class(t2), intent(inout) :: this\n+    character(32), dimension(:), allocatable :: md5\n+    allocate (md5 (this%n), source=this%md5)\n+    if (md5(1) /= \"tst                             \") call abort()\n+    if (md5(2) /= \"                                \") call abort()\n+    if (md5(3) /= \"fooblabar                       \") call abort()\n+  end subroutine t2_init\n+end module foo2\n+\n+program test\n+  use selectors\n+  use phs_base\n+  use foo\n+  use foo2\n+\n+  type(selector_t) :: sel\n+  type(phs_t) :: phs\n+  type(phs_config_t) :: phs_config\n+  type(t) :: o\n+  type(t2) :: o2\n+\n+  call sel%init([2., 0., 3., 0., 4.])\n+\n+  if (any(sel%map /= [1, 3, 5])) call abort()\n+  if (any(abs(sel%weight - [2., 3., 4.] / 9.) > 1E-6)) call abort()\n \n-program allocate_with_source_5\n-  use allocate_with_source_5_module\n+  phs_config%n_in = 2\n+  allocate (phs_config%flv (phs_config%n_in, 1))\n+  call phs_base_init (phs, phs_config)\n \n-  class(selector_t), allocatable :: sel;\n-  real, dimension(5) :: w = [ 1, 0, 2, 0, 3];\n+  if (any(abs(phs%m_in - [42.0, 42.0]) > 1E-6)) call abort()\n \n-  allocate (sel)\n-  call sel%init(w)\n+  o%n = 2\n+  allocate (o%val(2,4))\n+  call o%make()\n \n-  if (any(sel%map /= [ 1, 3, 5])) call abort()\n-  if (any(abs(sel%weight - [1, 2, 3] / 6) < 1E-6)) call abort()\n-end program allocate_with_source_5\n-! { dg-final { cleanup-modules \"allocate_with_source_5_module\" } }\n+  o2%n = 3\n+  allocate(o2%md5(o2%n))\n+  o2%md5(1) = \"tst\"\n+  o2%md5(2) = \"\"\n+  o2%md5(3) = \"fooblabar\"\n+  call o2%init()\n+end program test\n "}]}