{"sha": "3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2VjZjlkMTNhMTRlMWVjNmEzODNjNjY4Y2UwZjFjMzZlNjNiZjU4Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-21T15:51:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-21T15:51:59Z"}, "message": "alias.c (alias_stats): New static var.\n\n\t* alias.c (alias_stats): New static var.\t\n\t(alias_sets_conflict_p, alias_sets_must_conflict_p): Update stats.\n\t(dump_alias_stats_in_alias_c): New function.\n\t* alias.h (dump_alias_stats_in_alias_c): Declare.\n\t* tree-ssa-alias.c (dump_alias_stats): Call it.\n\nFrom-SVN: r223491", "tree": {"sha": "c621772114f4a1e02dcd18ded6f7627816ae66e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c621772114f4a1e02dcd18ded6f7627816ae66e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/comments", "author": null, "committer": null, "parents": [{"sha": "c7b70a3cba495e95f0d4457e6f003ca3d451d971", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7b70a3cba495e95f0d4457e6f003ca3d451d971", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7b70a3cba495e95f0d4457e6f003ca3d451d971"}], "stats": {"total": 78, "additions": 70, "deletions": 8}, "files": [{"sha": "3ec725535a36baa6a11596230c31d63c09bf86a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "patch": "@@ -1,3 +1,11 @@\n+2015-05-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* alias.c (alias_stats): New static var.\t\n+\t(alias_sets_conflict_p, alias_sets_must_conflict_p): Update stats.\n+\t(dump_alias_stats_in_alias_c): New function.\n+\t* alias.h (dump_alias_stats_in_alias_c): Declare.\n+\t* tree-ssa-alias.c (dump_alias_stats): Call it.\n+\n 2015-05-08  Michael Matz  <matz@suse.de>\n \n \t* tree-vectorizer.h (struct _stmt_vec_info): Rename stride_load_p"}, {"sha": "aa7dc21db8377be6e4f811e4098889ba73201b37", "filename": "gcc/alias.c", "status": "modified", "additions": 60, "deletions": 8, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "patch": "@@ -213,6 +213,19 @@ static int write_dependence_p (const_rtx,\n \n static void memory_modified_1 (rtx, const_rtx, void *);\n \n+/* Query statistics for the different low-level disambiguators.\n+   A high-level query may trigger multiple of them.  */\n+\n+static struct {\n+  unsigned long long num_alias_zero;\n+  unsigned long long num_same_alias_set;\n+  unsigned long long num_same_objects;\n+  unsigned long long num_volatile;\n+  unsigned long long num_dag;\n+  unsigned long long num_disambiguated;\n+} alias_stats;\n+\n+\n /* Set up all info needed to perform alias analysis on memory references.  */\n \n /* Returns the size in bytes of the mode of X.  */\n@@ -471,13 +484,20 @@ alias_sets_conflict_p (alias_set_type set1, alias_set_type set2)\n   ase = get_alias_set_entry (set1);\n   if (ase != 0\n       && ase->children->get (set2))\n-    return 1;\n+    {\n+      ++alias_stats.num_dag;\n+      return 1;\n+    }\n \n   /* Now do the same, but with the alias sets reversed.  */\n   ase = get_alias_set_entry (set2);\n   if (ase != 0\n       && ase->children->get (set1))\n-    return 1;\n+    {\n+      ++alias_stats.num_dag;\n+      return 1;\n+    }\n+  ++alias_stats.num_disambiguated;\n \n   /* The two alias sets are distinct and neither one is the\n      child of the other.  Therefore, they cannot conflict.  */\n@@ -489,8 +509,16 @@ alias_sets_conflict_p (alias_set_type set1, alias_set_type set2)\n int\n alias_sets_must_conflict_p (alias_set_type set1, alias_set_type set2)\n {\n-  if (set1 == 0 || set2 == 0 || set1 == set2)\n-    return 1;\n+  if (set1 == 0 || set2 == 0)\n+    {\n+      ++alias_stats.num_alias_zero;\n+      return 1;\n+    }\n+  if (set1 == set2)\n+    {\n+      ++alias_stats.num_same_alias_set;\n+      return 1;\n+    }\n \n   return 0;\n }\n@@ -512,10 +540,17 @@ objects_must_conflict_p (tree t1, tree t2)\n     return 0;\n \n   /* If they are the same type, they must conflict.  */\n-  if (t1 == t2\n-      /* Likewise if both are volatile.  */\n-      || (t1 != 0 && TYPE_VOLATILE (t1) && t2 != 0 && TYPE_VOLATILE (t2)))\n-    return 1;\n+  if (t1 == t2)\n+    {\n+      ++alias_stats.num_same_objects;\n+      return 1;\n+    }\n+  /* Likewise if both are volatile.  */\n+  if (t1 != 0 && TYPE_VOLATILE (t1) && t2 != 0 && TYPE_VOLATILE (t2))\n+    {\n+      ++alias_stats.num_volatile;\n+      return 1;\n+    }\n \n   set1 = t1 ? get_alias_set (t1) : 0;\n   set2 = t2 ? get_alias_set (t2) : 0;\n@@ -3043,4 +3078,21 @@ end_alias_analysis (void)\n   sbitmap_free (reg_known_equiv_p);\n }\n \n+void\n+dump_alias_stats_in_alias_c (FILE *s)\n+{\n+  fprintf (s, \"  TBAA oracle: %llu disambiguations %llu queries\\n\"\n+\t      \"               %llu are in alias set 0\\n\"\n+\t      \"               %llu queries asked about the same object\\n\"\n+\t      \"               %llu queries asked about the same alias set\\n\"\n+\t      \"               %llu access volatile\\n\"\n+\t      \"               %llu are dependent in the DAG\\n\",\n+\t   alias_stats.num_disambiguated,\n+\t   alias_stats.num_alias_zero + alias_stats.num_same_alias_set\n+\t   + alias_stats.num_same_objects + alias_stats.num_volatile\n+\t   + alias_stats.num_dag,\n+\t   alias_stats.num_alias_zero, alias_stats.num_same_alias_set,\n+\t   + alias_stats.num_same_objects, alias_stats.num_volatile,\n+\t   + alias_stats.num_dag);\n+}\n #include \"gt-alias.h\""}, {"sha": "04427b073f246d79d89634c76482bb4efc8651d5", "filename": "gcc/alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2Falias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2Falias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.h?ref=3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "patch": "@@ -41,6 +41,7 @@ extern int alias_sets_conflict_p (alias_set_type, alias_set_type);\n extern int alias_sets_must_conflict_p (alias_set_type, alias_set_type);\n extern int objects_must_conflict_p (tree, tree);\n extern int nonoverlapping_memrefs_p (const_rtx, const_rtx, bool);\n+extern void dump_alias_stats_in_alias_c (FILE *s);\n tree reference_alias_ptr_type (tree);\n bool alias_ptr_types_compatible_p (tree, tree);\n "}, {"sha": "9184242a7ee6e6e157ce561252cd20c98d0c2eff", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=3ecf9d13a14e1ec6a383c668ce0f1c36e63bf587", "patch": "@@ -163,6 +163,7 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.call_may_clobber_ref_p_no_alias,\n \t   alias_stats.call_may_clobber_ref_p_no_alias\n \t   + alias_stats.call_may_clobber_ref_p_may_alias);\n+  dump_alias_stats_in_alias_c (s);\n }\n \n "}]}