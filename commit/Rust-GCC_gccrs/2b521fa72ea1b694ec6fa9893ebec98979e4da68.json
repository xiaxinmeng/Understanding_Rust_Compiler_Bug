{"sha": "2b521fa72ea1b694ec6fa9893ebec98979e4da68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1MjFmYTcyZWExYjY5NGVjNmZhOTg5M2ViZWM5ODk3OWU0ZGE2OA==", "commit": {"author": {"name": "Nic Ferrier", "email": "nferrier@tf1.tapsellferrier.co.uk", "date": "2002-01-08T21:14:58Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-01-08T21:14:58Z"}, "message": "natPlainSocketImpl.cc: Added timeout handling for sockets.\n\n2002-01-08  Nic Ferrier  <nferrier@tf1.tapsellferrier.co.uk>\n\n\t* java/net/natPlainSocketImpl.cc: Added timeout handling for\n\tsockets.\n\t(close): New function closes the socket.\n\t(write): New functions for output to socket.\n\t(read): New functions for reading from socket.\n\t* java/net/PlainSocketImpl.java: Glue for new timeout\n\timplementation.\n\t(write): Call the native impl.\n\t(read): Likewise.\n\t(getInputStream): Get a stream to read from the socket.\n\t(getOutputStream): Get a stream to write to the socket.\n\nFrom-SVN: r48662", "tree": {"sha": "0c7277eb0833a5bcd5d85d2ce5f6352dc8c4ed5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c7277eb0833a5bcd5d85d2ce5f6352dc8c4ed5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b521fa72ea1b694ec6fa9893ebec98979e4da68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b521fa72ea1b694ec6fa9893ebec98979e4da68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b521fa72ea1b694ec6fa9893ebec98979e4da68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b521fa72ea1b694ec6fa9893ebec98979e4da68/comments", "author": null, "committer": null, "parents": [{"sha": "14b3e8ef09b6b6f04a5e5f76d8d4276d0cf53380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14b3e8ef09b6b6f04a5e5f76d8d4276d0cf53380", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14b3e8ef09b6b6f04a5e5f76d8d4276d0cf53380"}], "stats": {"total": 396, "additions": 381, "deletions": 15}, "files": [{"sha": "a5e7fa75f6255bb13c80438a0098b1a88accd707", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b521fa72ea1b694ec6fa9893ebec98979e4da68/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b521fa72ea1b694ec6fa9893ebec98979e4da68/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2b521fa72ea1b694ec6fa9893ebec98979e4da68", "patch": "@@ -1,3 +1,17 @@\n+2002-01-08  Nic Ferrier  <nferrier@tf1.tapsellferrier.co.uk> \n+\n+\t* java/net/natPlainSocketImpl.cc: Added timeout handling for\n+\tsockets.\n+\t(close): New function closes the socket.\n+\t(write): New functions for output to socket.\n+\t(read): New functions for reading from socket.\n+\t* java/net/PlainSocketImpl.java: Glue for new timeout\n+\timplementation.\n+\t(write): Call the native impl.\n+\t(read): Likewise.\n+\t(getInputStream): Get a stream to read from the socket.\n+\t(getOutputStream): Get a stream to write to the socket.\n+\n 2002-01-08  Tom Tromey  <tromey@redhat.com>\n \n \t* resolve.cc (_Jv_PrepareClass): Enable verifier."}, {"sha": "81df4873850a44decf6eea1c774cc0741316826a", "filename": "libjava/java/net/PlainSocketImpl.java", "status": "modified", "additions": 115, "deletions": 14, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b521fa72ea1b694ec6fa9893ebec98979e4da68/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b521fa72ea1b694ec6fa9893ebec98979e4da68/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPlainSocketImpl.java?ref=2b521fa72ea1b694ec6fa9893ebec98979e4da68", "patch": "@@ -1,6 +1,6 @@\n // PlainSocketImpl.java - Implementation of SocketImpl.\n \n-/* Copyright (C) 1999  Free Software Foundation\n+/* Copyright (C) 1999 , 2002 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,17 +11,16 @@\n package java.net;\n import java.io.*;\n \n-/**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date February 22, 1999.\n- */\n \n /**\n+ * The standard GCJ socket implementation.\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n+ *\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>\n  */\n-\n class PlainSocketImpl extends SocketImpl\n {\n   // These fields are mirrored for use in native code to avoid cpp conflicts\n@@ -35,6 +34,18 @@ class PlainSocketImpl extends SocketImpl\n                    _Jv_SO_SNDBUF_ = SocketOptions.SO_SNDBUF,\n                    _Jv_SO_RCVBUF_ = SocketOptions.SO_RCVBUF;\n \n+  /**\n+   * The OS file handle representing the socket.\n+   * This is used for reads and writes to/from the socket and\n+   * to close it.\n+   *\n+   * {@link SocketImpl#fd} is created from this like so:\n+   * <pre>\n+   *   fd = new FileDescriptor (fnum);\n+   * </pre>\n+   *\n+   * When the socket is closed this is reset to -1.\n+   */\n   int fnum = -1;\n \n   // This value is set/read by setOption/getOption.\n@@ -62,37 +73,127 @@ protected native void connect (InetAddress host, int port)\n   protected native void listen (int backlog) throws IOException;\n \n   private native void accept (PlainSocketImpl s) throws IOException;\n+\n   protected void accept (SocketImpl s) throws IOException\n   {\n     accept((PlainSocketImpl) s);\n   }\n \n+  protected native int available() throws IOException;\n+\n+  protected native void close () throws IOException;\n+\n+\n+  // Stream handling.\n+\n+  /** A cached copy of the in stream for reading from the socket.  */\n   private InputStream in;\n+\n+  /** A cached copy of the out stream for writing to the socket.  */\n   private OutputStream out;\n \n+\n+  // The native read methods.\n+\n+  private native int read() throws IOException;\n+\n+  private native int read(byte[] buffer, int offset, int count)\n+    throws IOException;\n+\n+\n+  // The native write methods.\n+\n+  private native void write(int c) throws IOException;\n+\n+  private native void write(byte[] buffer, int offset, int count)\n+    throws IOException;\n+\n+\n+  /** @return the input stream attached to the socket.\n+   */\n   protected InputStream getInputStream() throws IOException\n   {\n-    // FIXME: TODO - Implement class SocketInputStream timeouts in read();\n     if (in == null)\n-      in = new FileInputStream (fd);\n+      in = new SocketInputStream();\n     return in;\n   }\n \n+  /** @return the output stream attached to the socket.\n+   */\n   protected OutputStream getOutputStream() throws IOException\n   {\n     if (out == null)\n-      out = new FileOutputStream (fd);\n+      out = new SocketOutputStream();\n     return out;\n   }\n \n-  protected int available () throws IOException\n+  /**\n+   * A stream which reads from the socket implementation.\n+   *\n+   * @author Nic Ferrier <nferrier@tapsellferrier.co.uk>\n+   */\n+  class SocketInputStream\n+    extends InputStream\n   {\n-    return in.available();\n+    SocketInputStream()\n+    {\n+    }\n+    \n+    public final void close() throws IOException\n+    {\n+      PlainSocketImpl.this.close();\n+    }\n+\n+    public final int available() throws IOException\n+    {\n+      return PlainSocketImpl.this.available();\n+    }\n+\n+    public final int read() throws IOException\n+    {\n+      return PlainSocketImpl.this.read();\n+    }\n+\n+    public final int read(byte[] buffer, int offset, int length)\n+      throws IOException\n+    {\n+      return PlainSocketImpl.this.read(buffer, offset, length);\n+    }\n+\n+    public final int read(byte[] buffer)\n+      throws IOException\n+    {\n+      return PlainSocketImpl.this.read(buffer, 0, buffer.length);\n+    }\n   }\n \n-  protected void close () throws IOException\n+  /** A stream which writes to the socket implementation.\n+   *\n+   * @author Nic Ferrier  <nferrier@tapsellferrier.co.uk>\n+   */\n+  class SocketOutputStream\n+    extends OutputStream\n   {\n-    if (fd.valid())\n-      fd.close();\n+    public final void close() throws IOException\n+    {\n+      PlainSocketImpl.this.close();\n+    }\n+\n+    public final void write(int c) throws IOException\n+    {\n+      PlainSocketImpl.this.write(c);\n+    }\n+\n+    public final void write(byte[] buffer, int offset, int length)\n+      throws IOException\n+    {\n+      PlainSocketImpl.this.write(buffer, offset, length);\n+    }\n+\n+    public final void write(byte[] buffer)\n+      throws IOException\n+    {\n+      PlainSocketImpl.this.write(buffer, 0, buffer.length);\n+    }\n   }\n }"}, {"sha": "cc8dca1183052bcd70f951cedda6531ef037a318", "filename": "libjava/java/net/natPlainSocketImpl.cc", "status": "modified", "additions": 252, "deletions": 1, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b521fa72ea1b694ec6fa9893ebec98979e4da68/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b521fa72ea1b694ec6fa9893ebec98979e4da68/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImpl.cc?ref=2b521fa72ea1b694ec6fa9893ebec98979e4da68", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000 , 2002 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -85,6 +85,9 @@ _Jv_accept (int fd, struct sockaddr *addr, socklen_t *addrlen)\n #include <java/lang/Boolean.h>\n #include <java/lang/Class.h>\n #include <java/lang/Integer.h>\n+#include <java/lang/Thread.h>\n+#include <java/lang/NullPointerException.h>\n+#include <java/lang/ArrayIndexOutOfBoundsException.h>\n \n #define BooleanClass java::lang::Boolean::class$\n \n@@ -327,6 +330,254 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n   throw new java::io::IOException (JvNewStringUTF (strerr));\n }\n \n+// Close(shutdown) the socket.\n+void\n+java::net::PlainSocketImpl::close()\n+{\n+  // should we use shutdown here? how would that effect so_linger?\n+  int res = ::close (fnum);\n+\n+  if (res == -1)\n+    {\n+      // These three errors are not errors according to tests performed\n+      // on the reference implementation.\n+      if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n+\tthrow new java::io::IOException  (JvNewStringUTF (strerror (errno)));\n+    }\n+  // Safe place to reset the file pointer.\n+  fnum = -1;\n+}\n+\n+// Write a byte to the socket.\n+void\n+java::net::PlainSocketImpl::write(jint b)\n+{\n+  jbyte d =(jbyte) b;\n+  int r = 0;\n+\n+  while (r != 1)\n+    {\n+      r = ::write (fnum, &d, 1);\n+      if (r == -1)\n+\t{\n+\t  if (java::lang::Thread::interrupted())\n+\t    {\n+\t      java::io::InterruptedIOException *iioe\n+\t\t= new java::io::InterruptedIOException \n+\t\t(JvNewStringLatin1 (strerror (errno)));\n+\t      iioe->bytesTransferred = 0;\n+\t      throw iioe;\n+\t    }\n+\t  // Some errors should not cause exceptions.\n+\t  if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n+\t    throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+\t}\n+    }\n+}\n+\n+// Write some bytes to the socket.\n+void\n+java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n+{\n+  if (! b)\n+    throw new java::lang::NullPointerException;\n+  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n+    throw new java::lang::ArrayIndexOutOfBoundsException;\n+\n+  jbyte *bytes = elements (b) + offset;\n+  int written = 0;\n+  while (len > 0)\n+    {\n+      int r = ::write (fnum, bytes, len);\n+      if (r == -1)\n+        {\n+\t  if (java::lang::Thread::interrupted())\n+\t    {\n+\t      java::io::InterruptedIOException *iioe\n+\t\t= new java::io::InterruptedIOException\n+\t\t(JvNewStringLatin1 (strerror (errno)));\n+\t      iioe->bytesTransferred = written;\n+\t      throw iioe;\n+\t    }\n+\t  // Some errors should not cause exceptions.\n+\t  if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n+\t    throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+\t}\n+      written += r;\n+      len -= r;\n+      bytes += r;\n+    }\n+}\n+\n+\n+// Read a single byte from the socket.\n+jint\n+java::net::PlainSocketImpl::read(void)\n+{\n+  jbyte b;\n+\n+  // Do timeouts via select.\n+  if (timeout > 0)\n+  {\n+    // Create the file descriptor set.\n+    fd_set read_fds;\n+    FD_ZERO (&read_fds);\n+    FD_SET (fnum,&read_fds);\n+    // Create the timeout struct based on our internal timeout value.\n+    struct timeval timeout_value;\n+    timeout_value.tv_sec = timeout / 1000;\n+    timeout_value.tv_usec = (timeout % 1000) * 1000;\n+    // Select on the fds.\n+    int sel_retval = _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+    // If select returns 0 we've waited without getting data...\n+    // that means we've timed out.\n+    if (sel_retval == 0)\n+      throw new java::io::InterruptedIOException\n+\t(JvNewStringUTF (\"read timed out\") );\n+    // If select returns ok we know we either got signalled or read some data...\n+    // either way we need to try to read.\n+  }\n+  int r = ::read (fnum, &b, 1);\n+\n+  if (r == 0)\n+    return -1;\n+  if (java::lang::Thread::interrupted())\n+    {\n+      java::io::InterruptedIOException *iioe =\n+\tnew java::io::InterruptedIOException\n+\t(JvNewStringUTF(\"read interrupted\"));\n+      iioe->bytesTransferred = r == -1 ? 0 : r;\n+      throw iioe;\n+    }\n+  else if (r == -1)\n+    {\n+      // Some errors cause us to return end of stream...\n+      if (errno == ENOTCONN)\n+\treturn -1;\n+      // Other errors need to be signalled.\n+      throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+    }\n+  return b & 0xFF;\n+}\n+\n+// Read count bytes into the buffer, starting at offset.\n+jint\n+java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n+{\n+  if (! buffer)\n+    throw new java::lang::NullPointerException;\n+  jsize bsize = JvGetArrayLength (buffer);\n+  if (offset < 0 || count < 0 || offset + count > bsize)\n+    throw new java::lang::ArrayIndexOutOfBoundsException;\n+  jbyte *bytes = elements (buffer) + offset;\n+\n+  // Do timeouts via select.\n+  if (timeout > 0)\n+  {\n+    // Create the file descriptor set.\n+    fd_set read_fds;\n+    FD_ZERO (&read_fds);\n+    FD_SET (fnum, &read_fds);\n+    // Create the timeout struct based on our internal timeout value.\n+    struct timeval timeout_value;\n+    timeout_value.tv_sec = timeout / 1000;\n+    timeout_value.tv_usec =(timeout % 1000) * 1000;\n+    // Select on the fds.\n+    int sel_retval = _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n+    // We're only interested in the 0 return.\n+    // error returns still require us to try to read \n+    // the socket to see what happened.\n+    if (sel_retval == 0)\n+      {\n+\tjava::io::InterruptedIOException *iioe =\n+\t  new java::io::InterruptedIOException\n+\t  (JvNewStringUTF (\"read interrupted\"));\n+\tiioe->bytesTransferred = 0;\n+\tthrow iioe;\n+      }\n+  }\n+  // Read the socket.\n+  int r = ::recv (fnum, bytes, count, 0);\n+  if (r == 0)\n+    return -1;\n+  if (java::lang::Thread::interrupted())\n+    {\n+      java::io::InterruptedIOException *iioe =\n+\tnew java::io::InterruptedIOException\n+\t(JvNewStringUTF (\"read interrupted\"));\n+      iioe->bytesTransferred = r == -1 ? 0 : r;\n+      throw iioe;\n+    }\n+  else if (r == -1)\n+    {\n+      // Some errors cause us to return end of stream...\n+      if (errno == ENOTCONN)\n+\treturn -1;\n+      // Other errors need to be signalled.\n+      throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+    }\n+  return r;\n+}\n+\n+// How many bytes are available?\n+jint\n+java::net::PlainSocketImpl::available(void)\n+{\n+#if defined(FIONREAD) || defined(HAVE_SELECT)\n+  long num = 0;\n+  int r = 0;\n+  bool num_set = false;\n+\n+#if defined(FIONREAD)\n+  r = ::ioctl (fnum, FIONREAD, &num);\n+  if (r == -1 && errno == ENOTTY)\n+    {\n+      // If the ioctl doesn't work, we don't care.\n+      r = 0;\n+      num = 0;\n+    }\n+  else\n+    num_set = true;\n+#elif defined(HAVE_SELECT)\n+  if (fnum < 0)\n+    {\n+      errno = EBADF;\n+      r = -1;\n+    }\n+#endif\n+\n+  if (r == -1)\n+    {\n+    posix_error:\n+      throw new java::io::IOException(JvNewStringUTF(strerror(errno)));\n+\n+    }\n+\n+  // If we didn't get anything we can use select.\n+\n+#if defined(HAVE_SELECT)\n+  if (! num_set)\n+    {\n+      fd_set rd;\n+      FD_ZERO (&rd);\n+      FD_SET (fnum, &rd);\n+      struct timeval tv;\n+      tv.tv_sec = 0;\n+      tv.tv_usec = 0;\n+      r = _Jv_select (fnum + 1, &rd, NULL, NULL, &tv);\n+      if(r == -1)\n+\tgoto posix_error;\n+      num = r == 0 ? 0 : 1;\n+    }\n+#endif /* HAVE_SELECT */\n+\n+  return (jint) num;\n+#else\n+  throw new java::io::IOException (JvNewStringUTF (\"unimplemented\"));\n+#endif\n+ }\n+\n+\n void\n java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n {"}]}