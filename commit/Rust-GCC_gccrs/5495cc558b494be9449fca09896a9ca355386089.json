{"sha": "5495cc558b494be9449fca09896a9ca355386089", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQ5NWNjNTU4YjQ5NGJlOTQ0OWZjYTA5ODk2YTljYTM1NTM4NjA4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-01-24T04:02:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-01-24T04:02:40Z"}, "message": "osf.h (TARGET_HAS_XFLOATING_LIBS): Define.\n\n        * alpha/osf.h (TARGET_HAS_XFLOATING_LIBS): Define.\n        * alpha/osf5.h: New file.\n        * configure.in (alpha-*-osf5): Add it to tm_file.\n\n        * emit-rtl.c (operand_subword): Support TFmode on a 64-bit target.\n\n        * alpha-protos.h (alpha_emit_xfloating_arith): Declare.\n        (alpha_emit_xfloating_cvt, function_arg): Declare.\n        * alpha.c (alpha_emit_conditional_branch): Call\n        alpha_emit_xfloating_compare for TFmode compares.\n        (alpha_lookup_xfloating_lib_func): New.\n        (alpha_compute_xfloating_mode_arg): New.\n        (alpha_emit_xfloating_libcall): New.\n        (alpha_emit_xfloating_arith): New.\n        (alpha_emit_xfloating_compare): New.\n        (alpha_emit_xfloating_cvt): New.\n        (print_operand): Add default abort case.\n        (function_arg): Mind FUNCTION_ARG_PASS_BY_REFERENCE.\n        * alpha.h (TARGET_HAS_XFLOATING_LIBS): New.\n        (BIGGEST_ALIGNMENT): Increase to 128 bits.\n        (RETURN_IN_MEMORY): True for TF/TCmode.\n        (ALPHA_ARG_SIZE): TF/TCmode is passed indirect.\n        (FUNCTION_ARG): Move to function_arg.\n        (FUNCTION_ARG_PASS_BY_REFERENCE): New.\n        (ASM_OUTPUT_LONG_DOUBLE): New.\n        (ASM_OUTPUT_DOUBLE): Always output bits.\n        * alpha.md (addtf3, divtf3, multf3, subtf3, cmptf): New.\n        (fix_trunctfdi2, floatditf2, floatunsditf2): New.\n        (extenddftf2, trunctfdf2): New.\n\nFrom-SVN: r31579", "tree": {"sha": "01f52c80cc2f9fdea21bd2466e865f0bfdaa9c01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01f52c80cc2f9fdea21bd2466e865f0bfdaa9c01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5495cc558b494be9449fca09896a9ca355386089", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5495cc558b494be9449fca09896a9ca355386089", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5495cc558b494be9449fca09896a9ca355386089", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5495cc558b494be9449fca09896a9ca355386089/comments", "author": null, "committer": null, "parents": [{"sha": "ac4904440b4733f461bcd2c45915f502b0345f80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac4904440b4733f461bcd2c45915f502b0345f80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac4904440b4733f461bcd2c45915f502b0345f80"}], "stats": {"total": 604, "additions": 551, "deletions": 53}, "files": [{"sha": "1d5a61fdb919ec16cea892e7a1a4b548fa09ffcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -1,3 +1,35 @@\n+2000-01-23  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha/osf.h (TARGET_HAS_XFLOATING_LIBS): Define.\n+\t* alpha/osf5.h: New file.\n+\t* configure.in (alpha-*-osf5): Add it to tm_file.\n+\n+\t* emit-rtl.c (operand_subword): Support TFmode on a 64-bit target.\n+\n+\t* alpha-protos.h (alpha_emit_xfloating_arith): Declare.\n+\t(alpha_emit_xfloating_cvt, function_arg): Declare.\n+\t* alpha.c (alpha_emit_conditional_branch): Call\n+\talpha_emit_xfloating_compare for TFmode compares.\n+\t(alpha_lookup_xfloating_lib_func): New.\n+\t(alpha_compute_xfloating_mode_arg): New.\n+\t(alpha_emit_xfloating_libcall): New.\n+\t(alpha_emit_xfloating_arith): New.\n+\t(alpha_emit_xfloating_compare): New.\n+\t(alpha_emit_xfloating_cvt): New.\n+\t(print_operand): Add default abort case.\n+\t(function_arg): Mind FUNCTION_ARG_PASS_BY_REFERENCE.\n+\t* alpha.h (TARGET_HAS_XFLOATING_LIBS): New.\n+\t(BIGGEST_ALIGNMENT): Increase to 128 bits.\n+\t(RETURN_IN_MEMORY): True for TF/TCmode.\n+\t(ALPHA_ARG_SIZE): TF/TCmode is passed indirect.\n+\t(FUNCTION_ARG): Move to function_arg.\n+\t(FUNCTION_ARG_PASS_BY_REFERENCE): New.\n+\t(ASM_OUTPUT_LONG_DOUBLE): New.\n+\t(ASM_OUTPUT_DOUBLE): Always output bits.\n+\t* alpha.md (addtf3, divtf3, multf3, subtf3, cmptf): New.\n+\t(fix_trunctfdi2, floatditf2, floatunsditf2): New.\n+\t(extenddftf2, trunctfdf2): New.\n+\n 2000-01-23  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>\n \n \t* config/sparc/sol2-sld-64.h (TRANSFER_FROM_TRAMPOLINE): Moved..."}, {"sha": "c29063e9fd221766bb45ca91ff3bd4c2f0b5c057", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -80,6 +80,8 @@ extern rtx alpha_emit_set_long_const PARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t     HOST_WIDE_INT));\n extern rtx alpha_emit_conditional_branch PARAMS ((enum rtx_code));\n extern rtx alpha_emit_conditional_move PARAMS ((rtx, enum machine_mode));\n+extern void alpha_emit_xfloating_arith PARAMS ((enum rtx_code, rtx[]));\n+extern void alpha_emit_xfloating_cvt PARAMS ((enum rtx_code, rtx[]));\n extern void alpha_expand_unaligned_load PARAMS ((rtx, rtx, HOST_WIDE_INT,\n \t\t\t\t\t\tHOST_WIDE_INT, int));\n extern void alpha_expand_unaligned_store PARAMS ((rtx, rtx, HOST_WIDE_INT,\n@@ -114,6 +116,8 @@ extern tree alpha_build_va_list PARAMS ((void));\n #ifdef RTX_CODE\n extern void alpha_va_start PARAMS ((int, tree, rtx));\n extern rtx alpha_va_arg PARAMS ((tree, tree));\n+extern rtx function_arg PARAMS ((CUMULATIVE_ARGS, enum machine_mode,\n+\t\t\t\t tree, int));\n #endif\n extern int vms_valid_decl_attribute_p PARAMS ((tree, tree, tree, tree));\n extern void alpha_start_function PARAMS ((FILE *, const char *, tree));"}, {"sha": "94927747e6d3383e15af36da3279b4da3d0b9228", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 352, "deletions": 3, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -114,9 +114,18 @@ static void alpha_init_machine_status\n   PARAMS ((struct function *p));\n static void alpha_mark_machine_status\n   PARAMS ((struct function *p));\n-static int alpha_ra_ever_killed PARAMS ((void));\n-static rtx set_frame_related_p PARAMS ((void));\n-\n+static int alpha_ra_ever_killed\n+  PARAMS ((void));\n+static rtx set_frame_related_p\n+  PARAMS ((void));\n+static const char *alpha_lookup_xfloating_lib_func\n+  PARAMS ((enum rtx_code));\n+static int alpha_compute_xfloating_mode_arg\n+  PARAMS ((enum rtx_code, enum alpha_fp_rounding_mode));\n+static void alpha_emit_xfloating_libcall\n+  PARAMS ((const char *, rtx, rtx[], int, rtx));\n+static rtx alpha_emit_xfloating_compare\n+  PARAMS ((enum rtx_code, rtx, rtx));\n \n /* Get the number of args of a function in one of two ways.  */\n #ifdef OPEN_VMS\n@@ -1453,6 +1462,23 @@ alpha_emit_conditional_branch (code)\n   rtx op0 = alpha_compare.op0, op1 = alpha_compare.op1;\n   rtx tem;\n \n+  if (alpha_compare.fp_p && GET_MODE (op0) == TFmode)\n+    {\n+      if (! TARGET_HAS_XFLOATING_LIBS)\n+\tabort ();\n+\n+      /* X_floating library comparison functions return\n+\t   -1  unordered\n+\t    0  false\n+\t    1  true\n+\t Convert the compare against the raw return value.  */\n+\n+      op0 = alpha_emit_xfloating_compare (code, op0, op1);\n+      op1 = const0_rtx;\n+      alpha_compare.fp_p = 0;\n+      code = GT;\n+    }\n+\n   /* The general case: fold the comparison code to the types of compares\n      that we have, choosing the branch as necessary.  */\n   switch (code)\n@@ -1680,6 +1706,286 @@ alpha_emit_conditional_move (cmp, mode)\n   return gen_rtx_fmt_ee (cmov_code, cmov_mode, tem, CONST0_RTX (cmp_op_mode));\n }\n \f\n+/* Look up the function X_floating library function name for the\n+   given operation.  */\n+\n+static const char *\n+alpha_lookup_xfloating_lib_func (code)\n+     enum rtx_code code;\n+{\n+  struct xfloating_op\n+    {\n+      enum rtx_code code;\n+      const char *func;\n+    };\n+\n+  static const struct xfloating_op vms_xfloating_ops[] = \n+    {\n+      { PLUS,\t\t\"OTS$ADD_X\" },\n+      { MINUS,\t\t\"OTS$SUB_X\" },\n+      { MULT,\t\t\"OTS$MUL_X\" },\n+      { DIV,\t\t\"OTS$DIV_X\" },\n+      { EQ,\t\t\"OTS$EQL_X\" },\n+      { NE,\t\t\"OTS$NEQ_X\" },\n+      { LT,\t\t\"OTS$LSS_X\" },\n+      { LE,\t\t\"OTS$LEQ_X\" },\n+      { GT,\t\t\"OTS$GTR_X\" },\n+      { GE,\t\t\"OTS$GEQ_X\" },\n+      { FIX,\t\t\"OTS$CVTXQ\" },\n+      { FLOAT,\t\t\"OTS$CVTQX\" },\n+      { UNSIGNED_FLOAT,\t\"OTS$CVTQUX\" },\n+      { FLOAT_EXTEND,\t\"OTS$CVT_FLOAT_T_X\" },\n+      { FLOAT_TRUNCATE,\t\"OTS$CVT_FLOAT_X_T\" },\n+    };\n+\n+  static const struct xfloating_op osf_xfloating_ops[] = \n+    {\n+      { PLUS,\t\t\"_OtsAddX\" },\n+      { MINUS,\t\t\"_OtsSubX\" },\n+      { MULT,\t\t\"_OtsMulX\" },\n+      { DIV,\t\t\"_OtsDivX\" },\n+      { EQ,\t\t\"_OtsEqlX\" },\n+      { NE,\t\t\"_OtsNeqX\" },\n+      { LT,\t\t\"_OtsLssX\" },\n+      { LE,\t\t\"_OtsLeqX\" },\n+      { GT,\t\t\"_OtsGtrX\" },\n+      { GE,\t\t\"_OtsGeqX\" },\n+      { FIX,\t\t\"_OtsCvtXQ\" },\n+      { FLOAT,\t\t\"_OtsCvtQX\" },\n+      { UNSIGNED_FLOAT,\t\"_OtsCvtQUX\" },\n+      { FLOAT_EXTEND,\t\"_OtsConvertFloatTX\" },\n+      { FLOAT_TRUNCATE,\t\"_OtsConvertFloatXT\" },\n+    };\n+\n+  const struct xfloating_op *ops;\n+  const long n = sizeof(osf_xfloating_ops) / sizeof(osf_xfloating_ops[0]);\n+  long i;\n+\n+  /* How irritating.  Nothing to key off for the table.  Hardcode\n+     knowledge of the G_floating routines.  */\n+  if (TARGET_FLOAT_VAX)\n+    {\n+      if (TARGET_OPEN_VMS)\n+\t{\n+\t  if (code == FLOAT_EXTEND)\n+\t    return \"OTS$CVT_FLOAT_G_X\";\n+\t  if (code == FLOAT_TRUNCATE)\n+\t    return \"OTS$CVT_FLOAT_X_G\";\n+\t}\n+      else\n+\t{\n+\t  if (code == FLOAT_EXTEND)\n+\t    return \"_OtsConvertFloatGX\";\n+\t  if (code == FLOAT_TRUNCATE)\n+\t    return \"_OtsConvertFloatXG\";\n+\t}\n+    }\n+\n+  if (TARGET_OPEN_VMS)\n+    ops = vms_xfloating_ops;\n+  else\n+    ops = osf_xfloating_ops;\n+\n+  for (i = 0; i < n; ++i)\n+    if (ops[i].code == code)\n+      return ops[i].func;\n+\n+  abort();\n+}\n+\n+/* Most X_floating operations take the rounding mode as an argument.\n+   Compute that here.  */\n+\n+static int\n+alpha_compute_xfloating_mode_arg (code, round)\n+     enum rtx_code code;\n+     enum alpha_fp_rounding_mode round;\n+{\n+  int mode;\n+\n+  switch (round)\n+    {\n+    case ALPHA_FPRM_NORM:\n+      mode = 2;\n+      break;\n+    case ALPHA_FPRM_MINF:\n+      mode = 1;\n+      break;\n+    case ALPHA_FPRM_CHOP:\n+      mode = 0;\n+      break;\n+    case ALPHA_FPRM_DYN:\n+      mode = 4;\n+      break;\n+    default:\n+      abort ();\n+\n+    /* XXX For reference, round to +inf is mode = 3.  */\n+    }\n+\n+  if (code == FLOAT_TRUNCATE && alpha_fptm == ALPHA_FPTM_N)\n+    mode |= 0x10000;\n+\n+  return mode;\n+}\n+\n+/* Emit an X_floating library function call.\n+\n+   Note that these functions do not follow normal calling conventions:\n+   TFmode arguments are passed in two integer registers (as opposed to\n+   indirect); TFmode return values appear in R16+R17. \n+\n+   FUNC is the function name to call.\n+   TARGET is where the output belongs.\n+   OPERANDS are the inputs.\n+   NOPERANDS is the count of inputs.\n+   EQUIV is the expression equivalent for the function.\n+*/\n+\n+static void\n+alpha_emit_xfloating_libcall (func, target, operands, noperands, equiv)\n+     const char *func;\n+     rtx target;\n+     rtx operands[];\n+     int noperands;\n+     rtx equiv;\n+{\n+  rtx usage = NULL_RTX, tmp, reg;\n+  int regno = 16, i;\n+\n+  start_sequence ();\n+\n+  for (i = 0; i < noperands; ++i)\n+    {\n+      switch (GET_MODE (operands[i]))\n+\t{\n+\tcase TFmode:\n+\t  reg = gen_rtx_REG (TFmode, regno);\n+\t  regno += 2;\n+\t  break;\n+\n+\tcase DFmode:\n+\t  reg = gen_rtx_REG (DFmode, regno + 32);\n+\t  regno += 1;\n+\t  break;\n+\n+\tcase VOIDmode:\n+\t  if (GET_CODE (operands[i]) != CONST_INT)\n+\t    abort ();\n+\t  /* FALLTHRU */\n+\tcase DImode:\n+\t  reg = gen_rtx_REG (DImode, regno);\n+\t  regno += 1;\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      emit_move_insn (reg, operands[i]);\n+      usage = alloc_EXPR_LIST (0, gen_rtx_USE (VOIDmode, reg), usage);\n+    }\n+\n+  switch (GET_MODE (target))\n+    {\n+    case TFmode:\n+      reg = gen_rtx_REG (TFmode, 16);\n+      break;\n+    case DFmode:\n+      reg = gen_rtx_REG (DFmode, 32);\n+      break;\n+    case DImode:\n+      reg = gen_rtx_REG (DImode, 0);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  tmp = gen_rtx_MEM (QImode, gen_rtx_SYMBOL_REF (Pmode, func));\n+  tmp = emit_call_insn (gen_call_value (reg, tmp, const0_rtx,\n+\t\t\t\t\tconst0_rtx, const0_rtx));\n+  CALL_INSN_FUNCTION_USAGE (tmp) = usage;\n+\n+  tmp = get_insns ();\n+  end_sequence ();\n+\n+  emit_libcall_block (tmp, target, reg, equiv);\n+}\n+\n+/* Emit an X_floating library function call for arithmetic (+,-,*,/).  */\n+\n+void\n+alpha_emit_xfloating_arith (code, operands)\n+     enum rtx_code code;\n+     rtx operands[];\n+{\n+  const char *func;\n+  int mode;\n+\n+  func = alpha_lookup_xfloating_lib_func (code);\n+  mode = alpha_compute_xfloating_mode_arg (code, alpha_fprm);\n+\n+  operands[3] = GEN_INT (mode);\n+  alpha_emit_xfloating_libcall (func, operands[0], operands+1, 3,  \n+\t\t\t\tgen_rtx_fmt_ee (code, TFmode, operands[1],\n+\t\t\t\t\t\toperands[2]));\n+}\n+\n+/* Emit an X_floating library function call for a comparison.  */\n+\n+static rtx\n+alpha_emit_xfloating_compare (code, op0, op1)\n+     enum rtx_code code;\n+     rtx op0, op1;\n+{\n+  const char *func;\n+  rtx out, operands[2];\n+\n+  func = alpha_lookup_xfloating_lib_func (code);\n+\n+  operands[0] = op0;\n+  operands[1] = op1;\n+  out = gen_reg_rtx (DImode);\n+\n+  /* ??? Strange equiv cause what's actually returned is -1,0,1, not a\n+     proper boolean value.  */\n+  alpha_emit_xfloating_libcall (func, out, operands, 2, \n+\t\t\t\tgen_rtx_COMPARE (TFmode, op0, op1));\n+\n+  return out;\n+}\n+\n+/* Emit an X_floating library function call for a conversion.  */\n+\n+void\n+alpha_emit_xfloating_cvt (code, operands)\n+     enum rtx_code code;\n+     rtx operands[];\n+{\n+  int noperands = 1, mode;\n+  const char *func;\n+\n+  func = alpha_lookup_xfloating_lib_func (code);\n+\n+  switch (code)\n+    {\n+    case FIX:\n+      mode = alpha_compute_xfloating_mode_arg (code, ALPHA_FPRM_CHOP);\n+      operands[noperands++] = GEN_INT (mode);\n+      break;\n+    case FLOAT_TRUNCATE:\n+      mode = alpha_compute_xfloating_mode_arg (code, alpha_fprm);\n+      operands[noperands++] = GEN_INT (mode);\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  alpha_emit_xfloating_libcall (func, operands[0], operands+1, noperands,\n+\t\t\t\tgen_rtx_fmt_e (code, GET_MODE (operands[0]),\n+\t\t\t\t\t       operands[1]));\n+}\n+\f\n /* Use ext[wlq][lh] as the Architecture Handbook describes for extracting\n    unaligned data:\n \n@@ -1770,6 +2076,7 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n \t  emit_insn (gen_extqh (exth, memh, addr));\n \t  mode = DImode;\n \t  break;\n+\n \tdefault:\n \t  abort();\n \t}\n@@ -2806,6 +3113,8 @@ print_operand (file, x, code)\n \tcase ALPHA_FPRM_DYN:\n \t  fputc ('d', file);\n \t  break;\n+\tdefault:\n+\t  abort ();\n \t}\n       break;\n \n@@ -3213,6 +3522,46 @@ alpha_initialize_trampoline (tramp, fnaddr, cxt, fnofs, cxtofs, jmpofs)\n     emit_insn (gen_imb ());\n }\n \f\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).\n+\n+   On Alpha the first 6 words of args are normally in registers\n+   and the rest are pushed.  */\n+\n+rtx\n+function_arg(cum, mode, type, named)\n+     CUMULATIVE_ARGS cum;\n+     enum machine_mode mode;\n+     tree type;\n+     int named ATTRIBUTE_UNUSED;\n+{\n+  int basereg;\n+\n+  if (cum >= 6 || MUST_PASS_IN_STACK (mode, type))\n+    return NULL_RTX;\n+\n+  if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n+    basereg = 16;\n+  else if (TARGET_FPREGS\n+\t   && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t       || GET_MODE_CLASS (mode) == MODE_FLOAT))\n+    basereg = 32 + 16;\n+  else\n+    basereg = 16;\n+\n+  return gen_rtx_REG (mode, cum + basereg);\n+}\n+\n tree\n alpha_build_va_list ()\n {"}, {"sha": "b146a5a4c24a5dc253761e5c9997a9c296cd52ea", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 38, "deletions": 31, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -181,6 +181,9 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n #ifndef TARGET_CAN_FAULT_IN_PROLOGUE\n #define TARGET_CAN_FAULT_IN_PROLOGUE 0\n #endif\n+#ifndef TARGET_HAS_XFLOATING_LIBS\n+#define TARGET_HAS_XFLOATING_LIBS 0\n+#endif\n \n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n@@ -511,7 +514,7 @@ extern const char *alpha_mlat_string;\t/* For -mmemory-latency= */\n   (optimize > 0 && write_symbols != SDB_DEBUG ? 4 : 0)\n \n /* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 64\n+#define BIGGEST_ALIGNMENT 128\n \n /* For atomic access to objects, must have at least 32-bit alignment\n    unless the machine has byte operations.  */\n@@ -1013,6 +1016,8 @@ extern int alpha_memory_latency;\n \n #define RETURN_IN_MEMORY(TYPE) \\\n   (TYPE_MODE (TYPE) == BLKmode \\\n+   || TYPE_MODE (TYPE) == TFmode \\\n+   || TYPE_MODE (TYPE) == TCmode \\\n    || (TREE_CODE (TYPE) == INTEGER_TYPE && TYPE_PRECISION (TYPE) > 64))\n \n /* 1 if N is a possible register number for a function value\n@@ -1049,9 +1054,9 @@ extern int alpha_memory_latency;\n    for the Alpha.  */\n \n #define ALPHA_ARG_SIZE(MODE, TYPE, NAMED)\t\t\t\t\\\n-((MODE) != BLKmode\t\t\t\t\t\t\t\\\n- ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n- : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+  ((MODE) == TFmode || (MODE) == TCmode ? 1\t\t\t\t\\\n+   : (((MODE) == BLKmode ? int_size_in_bytes (TYPE) : GET_MODE_SIZE (MODE)) \\\n+      + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n \n /* Update the data in CUM to advance over an argument\n    of mode MODE and data type TYPE.\n@@ -1080,14 +1085,16 @@ extern int alpha_memory_latency;\n    and the rest are pushed.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-((CUM) < 6 && ! MUST_PASS_IN_STACK (MODE, TYPE)\t\\\n- ? gen_rtx_REG ((MODE),\t\t\t\t\\\n-\t\t(CUM) + 16\t\t\t\\\n-\t\t+ ((TARGET_FPREGS\t\t\\\n-\t\t    && (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT  \\\n-\t\t\t|| GET_MODE_CLASS (MODE) == MODE_FLOAT)) \\\n-\t\t   * 32))\t\t\t\\\n- : 0)\n+  function_arg((CUM), (MODE), (TYPE), (NAMED))\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type. */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+  ((MODE) == TFmode || (MODE) == TCmode)\n \n /* Specify the padding direction of arguments.\n \n@@ -1132,7 +1139,6 @@ extern int alpha_memory_latency;\n    class, but it isn't worth doing anything more efficient in this rare\n    case.  */\n    \n-\n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n { if ((CUM) < 6)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n@@ -2015,26 +2021,27 @@ literal_section ()\t\t\t\t\t\t\\\n #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\\n   ((OVERFLOW) = check_float_value (MODE, &D, OVERFLOW))\n \n+/* This is how to output an assembler line defining a `long double'\n+   constant.  */\n+\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    long t[4];\t\t\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_LONG_DOUBLE ((VALUE), t);\t\t\t\\\n+    fprintf (FILE, \"\\t.quad 0x%lx%08lx,0x%lx%08lx\\n\",\t\t\t\\\n+\t     t[1] & 0xffffffff, t[0] & 0xffffffff,\t\t\t\\\n+\t     t[3] & 0xffffffff, t[2] & 0xffffffff);\t\t\t\\\n+  } while (0)\n+\n /* This is how to output an assembler line defining a `double' constant.  */\n \n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n-        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n-\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tlong t[2];\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\\\n-\tfprintf (FILE, \"\\t.quad 0x%lx%08lx\\n\",\t\t\t\t\\\n-\t\tt[1] & 0xffffffff, t[0] & 0xffffffff);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tchar str[30];\t\t\t\t\t\t\t\\\n-\tREAL_VALUE_TO_DECIMAL (VALUE, \"%.20e\", str);\t\t\t\\\n-\tfprintf (FILE, \"\\t.%c_floating %s\\n\", (TARGET_FLOAT_VAX)?'g':'t', str);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-  }\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    long t[2];\t\t\t\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\t\t\\\n+    fprintf (FILE, \"\\t.quad 0x%lx%08lx\\n\",\t\t\t\t\\\n+\t     t[1] & 0xffffffff, t[0] & 0xffffffff);\t\t\t\\\n+  } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n@@ -2043,7 +2050,7 @@ literal_section ()\t\t\t\t\t\t\\\n     long t;\t\t\t\t\t\t\t\\\n     REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n     fprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\t\\\n-} while (0)\n+  } while (0)\n   \n /* This is how to output an assembler line defining an `int' constant.  */\n "}, {"sha": "b1d79042baa6c403c13f78198f9dcf81f15051d8", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -1842,6 +1842,13 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"addtf3\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))\n+   (use (match_operand 2 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_arith (PLUS, operands); DONE;\")\n+\n ;; Define conversion operators between DFmode and SImode, using the cvtql\n ;; instruction.  To allow combine et al to do useful things, we keep the\n ;; operation as a unit until after reload, at which point we split the\n@@ -1981,6 +1988,12 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"fix_trunctfdi2\"\n+  [(use (match_operand:DI 0 \"register_operand\" \"\"))\n+   (use (match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_cvt (FIX, operands); DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(float:SF (match_operand:DI 1 \"reg_no_subreg_operand\" \"f\")))]\n@@ -2013,6 +2026,18 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"floatditf2\"\n+  [(use (match_operand:TF 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_cvt (FLOAT, operands); DONE;\")\n+\n+(define_expand \"floatunsditf2\"\n+  [(use (match_operand:TF 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_cvt (UNSIGNED_FLOAT, operands); DONE;\")\n+\n (define_expand \"extendsfdf2\"\n   [(use (match_operand:DF 0 \"register_operand\" \"\"))\n    (use (match_operand:SF 1 \"nonimmediate_operand\" \"\"))]\n@@ -2047,6 +2072,12 @@\n   [(set_attr \"type\" \"fcpys,fld,fst\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"extenddftf2\"\n+  [(use (match_operand:TF 0 \"register_operand\" \"\"))\n+   (use (match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_cvt (FLOAT_EXTEND, operands); DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(float_truncate:SF (match_operand:DF 1 \"reg_or_fp0_operand\" \"fG\")))]\n@@ -2063,6 +2094,12 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"trunctfdf2\"\n+  [(use (match_operand:DF 0 \"register_operand\" \"\"))\n+   (use (match_operand:TF 1 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_cvt (FLOAT_TRUNCATE, operands); DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(div:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\")\n@@ -2129,6 +2166,13 @@\n   [(set_attr \"type\" \"fdiv\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"divtf3\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))\n+   (use (match_operand 2 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_arith (DIV, operands); DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(mult:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"%fG\")\n@@ -2186,6 +2230,13 @@\n   [(set_attr \"type\" \"fmul\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"multf3\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))\n+   (use (match_operand 2 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_arith (MULT, operands); DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(minus:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\")\n@@ -2253,6 +2304,13 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"trap\" \"yes\")])\n \n+(define_expand \"subtf3\"\n+  [(use (match_operand 0 \"register_operand\" \"\"))\n+   (use (match_operand 1 \"general_operand\" \"\"))\n+   (use (match_operand 2 \"general_operand\" \"\"))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"alpha_emit_xfloating_arith (MINUS, operands); DONE;\")\n+\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=&f\")\n \t(sqrt:SF (match_operand:SF 1 \"reg_or_fp0_operand\" \"fG\")))]\n@@ -2964,6 +3022,18 @@\n   DONE;\n }\")\n \n+(define_expand \"cmptf\"\n+  [(set (cc0) (compare (match_operand:TF 0 \"general_operand\" \"\")\n+\t\t       (match_operand:TF 1 \"general_operand\" \"\")))]\n+  \"TARGET_HAS_XFLOATING_LIBS\"\n+  \"\n+{\n+  alpha_compare.op0 = operands[0];\n+  alpha_compare.op1 = operands[1];\n+  alpha_compare.fp_p = 1;\n+  DONE;\n+}\")\n+\n (define_expand \"cmpdi\"\n   [(set (cc0) (compare (match_operand:DI 0 \"reg_or_0_operand\" \"\")\n \t\t       (match_operand:DI 1 \"reg_or_8bit_operand\" \"\")))]"}, {"sha": "50d4d5c040eeac43144e19af0dbeac4077014cce", "filename": "gcc/config/alpha/osf.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Fosf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Fosf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf.h?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -24,6 +24,11 @@ Boston, MA 02111-1307, USA.  */\n #undef TARGET_AS_CAN_SUBTRACT_LABELS\n #define TARGET_AS_CAN_SUBTRACT_LABELS 1\n \n+/* The GEM libraries for X_float are present, though not used by C.  */\n+\n+#undef TARGET_HAS_XFLOATING_LIBS\n+#define TARGET_HAS_XFLOATING_LIBS 1\n+\n /* Names to predefine in the preprocessor for this target machine.  */\n \n #define CPP_PREDEFINES \"\\"}, {"sha": "1c336bd0670f1a2b42f61ae5a5ea7bb0b633c4fa", "filename": "gcc/config/alpha/osf5.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Fosf5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfig%2Falpha%2Fosf5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fosf5.h?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -0,0 +1,22 @@\n+/* Definitions of target machine for GNU compiler, for DEC Alpha on Tru64 5.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+#undef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE  128"}, {"sha": "378be6d9c38d9ff168b31db2253971530891a688", "filename": "gcc/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -3434,7 +3434,7 @@ for machine in $build $host $target; do\n \t\t    install_headers_dir=install-headers-cpio\n \t\t    ;;\n \t\t  *-*-osf5*)\n-\t\t    tm_file=\"${tm_file} alpha/osf.h\"\n+\t\t    tm_file=\"${tm_file} alpha/osf.h alpha/osf5.h\"\n \t\t    ;;\n \t\tesac\n \t\tcase $machine in"}, {"sha": "098e00058279267f4186745f0cc1fd8d17d0ea9c", "filename": "gcc/configure.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -689,7 +689,7 @@ changequote([,])dnl\n \t\t    install_headers_dir=install-headers-cpio\n \t\t    ;;\n \t\t  *-*-osf5*)\n-\t\t    tm_file=\"${tm_file} alpha/osf.h\"\n+\t\t    tm_file=\"${tm_file} alpha/osf.h alpha/osf5.h\"\n \t\t    ;;\n \t\tesac\n \t\tcase $machine in"}, {"sha": "d1e04730764c6c189227192747da09d8c48c7cf3", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5495cc558b494be9449fca09896a9ca355386089/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5495cc558b494be9449fca09896a9ca355386089/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=5495cc558b494be9449fca09896a9ca355386089", "patch": "@@ -1218,9 +1218,9 @@ operand_subword (op, i, validate_address, mode)\n      are defined as returning one or two 32 bit values, respectively,\n      and not values of BITS_PER_WORD bits.  */\n #ifdef REAL_ARITHMETIC\n-/*  The output is some bits, the width of the target machine's word.\n-    A wider-word host can surely hold them in a CONST_INT. A narrower-word\n-    host can't.  */\n+  /* The output is some bits, the width of the target machine's word.\n+     A wider-word host can surely hold them in a CONST_INT. A narrower-word\n+     host can't.  */\n   if (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD\n       && GET_MODE_CLASS (mode) == MODE_FLOAT\n       && GET_MODE_BITSIZE (mode) == 64\n@@ -1271,22 +1271,31 @@ operand_subword (op, i, validate_address, mode)\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT\n \t   && GET_MODE_BITSIZE (mode) > 64\n \t   && GET_CODE (op) == CONST_DOUBLE)\n-  {\n-    long k[4];\n-    REAL_VALUE_TYPE rv;\n+    {\n+      long k[4];\n+      REAL_VALUE_TYPE rv;\n \n-    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n-    REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n+      REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (rv, k);\n \n-    if (BITS_PER_WORD == 32)\n-      {\n-\tval = k[i];\n-\tval = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-\treturn GEN_INT (val);\n-      }\n-    else\n-      abort ();\n-  }\n+      if (BITS_PER_WORD == 32)\n+\t{\n+\t  val = k[i];\n+\t  val = ((val & 0xffffffff) ^ 0x80000000) - 0x80000000;\n+\t  return GEN_INT (val);\n+\t}\n+#if HOST_BITS_PER_WIDE_INT >= 64\n+      else if (BITS_PER_WORD >= 64 && i <= 1)\n+\t{\n+\t  val = k[i*2 + ! WORDS_BIG_ENDIAN];\n+\t  val = (((val & 0xffffffff) ^ 0x80000000) - 0x80000000) << 32;\n+\t  val |= (HOST_WIDE_INT) k[i*2 + WORDS_BIG_ENDIAN] & 0xffffffff;\n+\t  return GEN_INT (val);\n+\t}\n+#endif\n+      else\n+\tabort ();\n+    }\n #else /* no REAL_ARITHMETIC */\n   if (((HOST_FLOAT_FORMAT == TARGET_FLOAT_FORMAT\n \t&& HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)"}]}