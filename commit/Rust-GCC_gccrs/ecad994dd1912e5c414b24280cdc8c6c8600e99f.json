{"sha": "ecad994dd1912e5c414b24280cdc8c6c8600e99f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNhZDk5NGRkMTkxMmU1YzQxNGIyNDI4MGNkYzhjNmM4NjAwZTk5Zg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-27T14:27:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2003-10-27T14:27:17Z"}, "message": "re PR ada/5909 (Ada has no test suite.)\n\n\t* Makefile.generic: Add missing substitution on object_deps handling.\n\n\tPR ada/5909:\n\t* Make-lang.in (check-ada): Enable ACATS test suite.\n\n\t* exp_ch3.adb:\n\t(Freeze_Array_Type): We do not need an initialization routine for types\n\tderived from String or Wide_String. They should be treated the same\n\tas String and Wide_String themselves. This caused problems with the\n\tuse of Initialize_Scalars.\n\n\t* exp_ch5.adb:\n\t(Expand_Assign_Record): Do component-wise assignment of non-byte aligned\n\tcomposites. This allows use of component clauses that are not byte\n\taligned.\n\n\t* sem_prag.adb:\n\t(Analyze_Pragma, case Pack): Generate warning and ignore pack if there\n\tis an attempt to pack an array of atomic objects.\n\n\t* make.adb, prj-env.adb, prj-env.ads: Minor reformatting\n\n\t* g-dirope.adb:\n\t(Basename): Check for drive letters in a pathname only on DOS based OS.\n\n\t* make.adb:\n\t(Gnatmake): When unable to change dir to the object dir, display the\n\tcontent of the parent dir of the obj dir, to try to understand why this\n\thappens.\n\n\t* Make-lang.in: Makefile automatically updated\n\n\t* sem_ch12.adb:\n\t(Inline_Instance_Body): Indicate that the save/restore of use_clauses\n\tshould not be done in Save/Restore_Scope_Stack, because it is performed\n\tlocally.\n\n\t* sem_ch8.adb:\n\t(Save_Scope_Stack, Restore_Scope_Stack): Add parameter to indicate\n\twhether use clauses should be removed/restored.\n\n\t* sem_ch8.ads:\n\t(Save_Scope_Stack, Restore_Scope_Stack): Add parameter to indicate\n\twhether use clauses should be removed/restored.\n\nFrom-SVN: r72983", "tree": {"sha": "5db4ec8273f035a29e6c9504108dd9262b217b21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5db4ec8273f035a29e6c9504108dd9262b217b21"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ecad994dd1912e5c414b24280cdc8c6c8600e99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecad994dd1912e5c414b24280cdc8c6c8600e99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecad994dd1912e5c414b24280cdc8c6c8600e99f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecad994dd1912e5c414b24280cdc8c6c8600e99f/comments", "author": null, "committer": null, "parents": [{"sha": "e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ffc70a2d470cdeb423a572621cbe1d0e2bf64c"}], "stats": {"total": 4003, "additions": 2558, "deletions": 1445}, "files": [{"sha": "adb14dffeda0e1ce4568c3bb214b38b104f5f261", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -1,3 +1,60 @@\n+2003-10-27  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* Makefile.generic: Add missing substitution on object_deps handling.\n+\n+\tPR ada/5909:\n+\t* Make-lang.in (check-ada): Enable ACATS test suite.\n+\n+2003-10-27  Robert Dewar  <dewar@gnat.com>\n+\n+\t* exp_ch3.adb: \n+\t(Freeze_Array_Type): We do not need an initialization routine for types\n+\tderived from String or Wide_String. They should be treated the same\n+\tas String and Wide_String themselves. This caused problems with the\n+\tuse of Initialize_Scalars.\n+\n+\t* exp_ch5.adb: \n+\t(Expand_Assign_Record): Do component-wise assignment of non-byte aligned\n+\tcomposites. This allows use of component clauses that are not byte\n+\taligned.\n+\n+\t* sem_prag.adb: \n+\t(Analyze_Pragma, case Pack): Generate warning and ignore pack if there\n+\tis an attempt to pack an array of atomic objects.\n+\n+\t* make.adb, prj-env.adb, prj-env.ads: Minor reformatting\n+\n+2003-10-27  Pascal Obry  <obry@gnat.com>\n+\n+\t* g-dirope.adb: \n+\t(Basename): Check for drive letters in a pathname only on DOS based OS.\n+\n+2003-10-27  Vincent Celier  <celier@gnat.com>\n+\n+\t* make.adb: \n+\t(Gnatmake): When unable to change dir to the object dir, display the\n+\tcontent of the parent dir of the obj dir, to try to understand why this\n+\thappens.\n+\n+2003-10-27  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n+2003-10-27  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch12.adb: \n+\t(Inline_Instance_Body): Indicate that the save/restore of use_clauses\n+\tshould not be done in Save/Restore_Scope_Stack, because it is performed\n+\tlocally.\n+\n+\t* sem_ch8.adb: \n+\t(Save_Scope_Stack, Restore_Scope_Stack): Add parameter to indicate\n+\twhether use clauses should be removed/restored.\n+\n+\t* sem_ch8.ads: \n+\t(Save_Scope_Stack, Restore_Scope_Stack): Add parameter to indicate\n+\twhether use clauses should be removed/restored.\n+\n 2003-10-26  Andreas Jaeger  <aj@suse.de>\n \n \t* Makefile.in: Remove duplicated lines."}, {"sha": "bbc769a9a84b4a82f6352f2c6d6c8c9ea6eaddd5", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 2267, "deletions": 1391, "changes": 3658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f"}, {"sha": "630f6c5a740f400e2f6cdee46e29a09f56dc3c65", "filename": "gcc/ada/Makefile.generic", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2FMakefile.generic", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2FMakefile.generic", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.generic?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -157,7 +157,7 @@ $(compile_deps): force\n \t@$(MAKE) -C $(dir $(subst |,:,$(@:compile_%=%))) -f Makefile.$(notdir $@) internal-compile\n \n $(object_deps): force\n-\t@$(MAKE) -C $(dir $(@:object_%=%)) -f Makefile.$(notdir $@) internal-archive-objects ARCHIVE=$(ARCHIVE)\n+\t@$(MAKE) -C $(dir $(subst |,:,$(@:object_%=%))) -f Makefile.$(notdir $@) internal-archive-objects ARCHIVE=$(ARCHIVE)\n \n $(ada_deps): force\n \t@$(MAKE) -C $(dir $(subst |,:,$(@:ada_%=%))) -f Makefile.$(notdir $@) internal-ada"}, {"sha": "3fd7225fb0a7696fd4a0819a09742738f0830f93", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -3428,8 +3428,8 @@ package body Exp_Ch3 is\n             --  initialize scalars mode, and these types are treated specially\n             --  and do not need initialization procedures.\n \n-            elsif Base = Standard_String\n-              or else Base = Standard_Wide_String\n+            elsif Root_Type (Base) = Standard_String\n+              or else Root_Type (Base) = Standard_Wide_String\n             then\n                null;\n "}, {"sha": "4287b752ce16f6ba6465e9c20ac135dd96913fc5", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 133, "deletions": 13, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -91,8 +91,25 @@ package body Exp_Ch5 is\n \n    procedure Expand_Assign_Record (N : Node_Id);\n    --  N is an assignment of a non-tagged record value. This routine handles\n-   --  the special cases and checks required for such assignments, including\n-   --  change of representation.\n+   --  the case where the assignment must be made component by component,\n+   --  either because the target is not byte aligned, or there is a change\n+   --  of representation.\n+\n+   function Maybe_Bit_Aligned_Large_Component (N : Node_Id) return Boolean;\n+   --  This function is used in processing the assignment of a record or\n+   --  indexed component. The back end can handle such assignments fine\n+   --  if the object involved is small (64-bits) or if it is aligned on\n+   --  a byte boundary (starts on a byte, and ends on a byte). However,\n+   --  problems arise for large components that are not byte aligned,\n+   --  since the assignment may clobber other components that share\n+   --  bit positions in the starting or ending bytes. This function is\n+   --  used to detect such situations, so that the assignment can be\n+   --  handled component-wise. A value of False means that either the\n+   --  object is known to be greater than 64 bits, or that it is known\n+   --  to be byte aligned. True is returned if the object is known to\n+   --  be greater than 64 bits, and is known to be unaligned. As implied\n+   --  by the name, the result is conservative, in that if the compiler\n+   --  cannot determine these conditions at compile time, True is returned.\n \n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and Tagged assignment,\n@@ -982,28 +999,46 @@ package body Exp_Ch5 is\n    --  by field assignments.\n \n    procedure Expand_Assign_Record (N : Node_Id) is\n+      Lhs : constant Node_Id := Name (N);\n+      Rhs : Node_Id          := Expression (N);\n+\n    begin\n-      if not Change_Of_Representation (N) then\n+      --  If change of representation, then extract the real right hand\n+      --  side from the type conversion, and proceed with component-wise\n+      --  assignment, since the two types are not the same as far as the\n+      --  back end is concerned.\n+\n+      if Change_Of_Representation (N) then\n+         Rhs := Expression (Rhs);\n+\n+      --  If this may be a case of a large bit aligned component, then\n+      --  proceed with component-wise assignment, to avoid possible\n+      --  clobbering of other components sharing bits in the first or\n+      --  last byte of the component to be assigned.\n+\n+      elsif Maybe_Bit_Aligned_Large_Component (Lhs) then\n+         null;\n+\n+      --  If neither condition met, then nothing special to do, the back end\n+      --  can handle assignment of the entire component as a single entity.\n+\n+      else\n          return;\n       end if;\n \n-      --  At this stage we know that the right hand side is a conversion\n+      --  At this stage we know that we must do a component wise assignment\n \n       declare\n          Loc   : constant Source_Ptr := Sloc (N);\n-         Lhs   : constant Node_Id    := Name (N);\n-         Rhs   : constant Node_Id    := Expression (Expression (N));\n-         R_Rec : constant Node_Id    := Expression (Expression (N));\n-         R_Typ : constant Entity_Id  := Base_Type (Etype (R_Rec));\n+         R_Typ : constant Entity_Id  := Base_Type (Etype (Rhs));\n          L_Typ : constant Entity_Id  := Base_Type (Etype (Lhs));\n          Decl  : constant Node_Id    := Declaration_Node (R_Typ);\n          RDef  : Node_Id;\n          F     : Entity_Id;\n \n          function Find_Component\n            (Typ  : Entity_Id;\n-            Comp : Entity_Id)\n-            return Entity_Id;\n+            Comp : Entity_Id) return Entity_Id;\n          --  Find the component with the given name in the underlying record\n          --  declaration for Typ. We need to use the actual entity because\n          --  the type may be private and resolution by identifier alone would\n@@ -1027,9 +1062,7 @@ package body Exp_Ch5 is\n \n          function Find_Component\n            (Typ  : Entity_Id;\n-            Comp : Entity_Id)\n-            return Entity_Id\n-\n+            Comp : Entity_Id) return Entity_Id\n          is\n             Utyp : constant Entity_Id := Underlying_Type (Typ);\n             C    : Entity_Id;\n@@ -3175,4 +3208,91 @@ package body Exp_Ch5 is\n          return Empty_List;\n    end Make_Tag_Ctrl_Assignment;\n \n+   ---------------------------------------\n+   -- Maybe_Bit_Aligned_Large_Component --\n+   ---------------------------------------\n+\n+   function Maybe_Bit_Aligned_Large_Component (N : Node_Id) return Boolean is\n+   begin\n+      case Nkind (N) is\n+\n+         --  Case of indexed component\n+\n+         when N_Indexed_Component =>\n+            declare\n+               P    : constant Node_Id   := Prefix (N);\n+               Ptyp : constant Entity_Id := Etype (P);\n+\n+            begin\n+               --  If we know the component size and it is less than 64, then\n+               --  we are definitely OK. The back end always does assignment\n+               --  of misaligned small objects correctly.\n+\n+               if Known_Static_Component_Size (Ptyp)\n+                 and then Component_Size (Ptyp) <= 64\n+               then\n+                  return False;\n+\n+               --  Otherwise, we need to test the prefix, to see if we are\n+               --  indexing from a possibly unaligned component.\n+\n+               else\n+                  return Maybe_Bit_Aligned_Large_Component (P);\n+               end if;\n+            end;\n+\n+         --  Case of selected component\n+\n+         when N_Selected_Component =>\n+            declare\n+               P    : constant Node_Id   := Prefix (N);\n+               Comp : constant Entity_Id := Entity (Selector_Name (N));\n+\n+            begin\n+               --  If there is no component clause, then we are in the clear\n+               --  since the back end will never misalign a large component\n+               --  unless it is forced to do so. In the clear means we need\n+               --  only the recursive test on the prefix.\n+\n+               if No (Component_Clause (Comp)) then\n+                  return Maybe_Bit_Aligned_Large_Component (P);\n+\n+               --  Otherwise we have a component clause, which means that\n+               --  the Esize and Normalized_First_Bit fields are set and\n+               --  contain static values known at compile time.\n+\n+               else\n+                  --  If we know the size is 64 bits or less we are fine\n+                  --  since the back end always handles small fields right.\n+\n+                  if Esize (Comp) <= 64 then\n+                     return False;\n+\n+                  --  Otherwise if the component is not byte aligned, we\n+                  --  know we have the nasty unaligned case.\n+\n+                  elsif Normalized_First_Bit (Comp) /= Uint_0\n+                    or else Esize (Comp) mod System_Storage_Unit /= Uint_0\n+                  then\n+                     return True;\n+\n+                  --  If we are large and byte aligned, then OK at this level\n+                  --  but we still need to test our prefix recursively.\n+\n+                  else\n+                     return Maybe_Bit_Aligned_Large_Component (P);\n+                  end if;\n+               end if;\n+            end;\n+\n+         --  If we have neither a record nor array component, it means that\n+         --  we have fallen off the top testing prefixes recursively, and\n+         --  we now have a stand alone object, where we don't have a problem\n+\n+         when others =>\n+            return False;\n+\n+      end case;\n+   end Maybe_Bit_Aligned_Large_Component;\n+\n end Exp_Ch5;"}, {"sha": "321b81244c4ee5fd5dd7e27794f2a732e890ae18", "filename": "gcc/ada/g-dirope.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -123,11 +123,17 @@ package body GNAT.Directory_Operations is\n                        Base_Name.Path (Cut_Start - Offset .. Cut_End - Offset);\n             --  Here we use Base_Name.Path to keep the original casing\n \n+            Has_Drive_Letter : constant Boolean :=\n+                                 OS_Lib.Path_Separator /= ':';\n+            --  If Path separator is not ':' then we are on a DOS based OS\n+            --  where this character is used as a drive letter separator.\n+\n          begin\n             if BN = \".\" or else BN = \"..\" then\n                return \"\";\n \n-            elsif BN'Length > 2\n+            elsif Has_Drive_Letter\n+              and then BN'Length > 2\n               and then Characters.Handling.Is_Letter (BN (BN'First))\n               and then BN (BN'First + 1) = ':'\n             then"}, {"sha": "a82c99aff7fc4a6bcd432877fdef6cd41f1cd015", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -3386,7 +3386,7 @@ package body Make is\n \n                   loop\n                      declare\n-                        Main      : constant String := Mains.Next_Main;\n+                        Main : constant String := Mains.Next_Main;\n                         --  The name specified on the command line may include\n                         --  directory information.\n \n@@ -3416,7 +3416,7 @@ package body Make is\n                            if Main /= File_Name then\n                               declare\n                                  Data : constant Project_Data :=\n-                                   Projects.Table (Main_Project);\n+                                          Projects.Table (Main_Project);\n \n                                  Project_Path : constant String :=\n                                    Prj.Env.File_Name_Of_Library_Unit_Body\n@@ -3478,12 +3478,14 @@ package body Make is\n                            end if;\n \n                            if not Unique_Compile then\n+\n                               --  Record the project, if it is the first main\n \n                               if Real_Main_Project = No_Project then\n                                  Real_Main_Project := Proj;\n \n                               elsif Proj /= Real_Main_Project then\n+\n                                  --  Fail, as the current main is not a source\n                                  --  of the same project as the first main.\n \n@@ -3557,11 +3559,14 @@ package body Make is\n \n                   declare\n                      Data : Project_Data := Projects.Table (Main_Project);\n+\n                      Languages : Variable_Value :=\n-                       Prj.Util.Value_Of\n-                         (Name_Languages, Data.Decl.Attributes);\n+                                   Prj.Util.Value_Of\n+                                     (Name_Languages, Data.Decl.Attributes);\n+\n                      Current : String_List_Id;\n                      Element : String_Element;\n+\n                      Foreign_Language  : Boolean := False;\n                      At_Least_One_Main : Boolean := False;\n \n@@ -3593,8 +3598,8 @@ package body Make is\n                      while Value /= Prj.Nil_String loop\n                         Get_Name_String (String_Elements.Table (Value).Value);\n \n-                        --  To know if a main is an Ada main, get its project;\n-                        --  it should be the project specified on the command\n+                        --  To know if a main is an Ada main, get its project.\n+                        --  It should be the project specified on the command\n                         --  line.\n \n                         if (not Foreign_Language) or else\n@@ -3616,6 +3621,7 @@ package body Make is\n                      --  we put all sources of the main project in the Q.\n \n                      if not At_Least_One_Main then\n+\n                         --  First make sure that the binder and the linker\n                         --  will not be invoked.\n \n@@ -3739,6 +3745,45 @@ package body Make is\n \n          exception\n             when Directory_Error =>\n+\n+               --  This should never happen. But, if it does, display the\n+               --  content of the parent directory of the obj dir.\n+\n+               declare\n+                  Parent : constant Dir_Name_Str :=\n+                    Dir_Name\n+                      (Get_Name_String\n+                           (Projects.Table (Main_Project).Object_Directory));\n+                  Dir : Dir_Type;\n+                  Str : String (1 .. 200);\n+                  Last : Natural;\n+\n+               begin\n+                  Write_Str (\"Contents of directory \"\"\");\n+                  Write_Str (Parent);\n+                  Write_Line (\"\"\":\");\n+\n+                  Open (Dir, Parent);\n+\n+                  loop\n+                     Read (Dir, Str, Last);\n+                     exit when Last = 0;\n+                     Write_Str (\"   \");\n+                     Write_Line (Str (1 .. Last));\n+                  end loop;\n+\n+                  Close (Dir);\n+\n+               exception\n+                  when X : others =>\n+                     Write_Line (\"(unexpected exception)\");\n+                     Write_Line (Exception_Information (X));\n+\n+                     if Is_Open (Dir) then\n+                        Close (Dir);\n+                     end if;\n+               end;\n+\n                Make_Failed (\"unable to change working directory to \"\"\",\n                             Get_Name_String\n                              (Projects.Table (Main_Project).Object_Directory),"}, {"sha": "5c3a07be0d942bff2cd71f067f35f10c82ca3eb1", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -203,10 +203,13 @@ package body Prj.Env is\n       return Projects.Table (Project).Ada_Include_Path;\n    end Ada_Include_Path;\n \n+   ----------------------\n+   -- Ada_Include_Path --\n+   ----------------------\n+\n    function Ada_Include_Path\n      (Project   : Project_Id;\n-      Recursive : Boolean)\n-      return      String\n+      Recursive : Boolean) return String\n    is\n    begin\n       if Recursive then\n@@ -224,8 +227,7 @@ package body Prj.Env is\n \n    function Ada_Objects_Path\n      (Project             : Project_Id;\n-      Including_Libraries : Boolean := True)\n-      return                String_Access\n+      Including_Libraries : Boolean := True) return String_Access\n    is\n       procedure Add (Project : Project_Id);\n       --  Add all the object directories of a project to the path only if\n@@ -1061,8 +1063,7 @@ package body Prj.Env is\n      (Name              : String;\n       Project           : Project_Id;\n       Main_Project_Only : Boolean := True;\n-      Full_Path         : Boolean := False)\n-      return              String\n+      Full_Path         : Boolean := False) return String\n    is\n       The_Project   : Project_Id := Project;\n       Data          : Project_Data := Projects.Table (Project);\n@@ -1547,8 +1548,7 @@ package body Prj.Env is\n \n    function Path_Name_Of_Library_Unit_Body\n      (Name    : String;\n-      Project : Project_Id)\n-      return String\n+      Project : Project_Id) return String\n    is\n       Data : constant Project_Data := Projects.Table (Project);\n       Original_Name : String := Name;\n@@ -1733,8 +1733,7 @@ package body Prj.Env is\n \n    function Project_Of\n      (Name         : String;\n-      Main_Project : Project_Id)\n-      return         Project_Id\n+      Main_Project : Project_Id) return Project_Id\n    is\n       Result : Project_Id := No_Project;\n \n@@ -1777,10 +1776,13 @@ package body Prj.Env is\n          Unit := Units.Table (Current);\n \n          --  Check for body\n+\n          Current_Name := Unit.File_Names (Body_Part).Name;\n+\n          --  Case of a body present\n \n          if Current_Name /= No_Name then\n+\n             --  If it has the name of the original name or the body name,\n             --  we have found the project.\n \n@@ -1798,6 +1800,7 @@ package body Prj.Env is\n          Current_Name := Unit.File_Names (Specification).Name;\n \n          if Current_Name /= No_Name then\n+\n             --  If name same as the original name, or the spec name, we have\n             --  found the project.\n "}, {"sha": "8730ccb52d2cef8b34deb2df7460e7089886cd61", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -66,8 +66,7 @@ package Prj.Env is\n \n    function Ada_Include_Path\n      (Project   : Project_Id;\n-      Recursive : Boolean)\n-      return      String;\n+      Recursive : Boolean) return String;\n    --  Get the ADA_INCLUDE_PATH of a Project file. If Recursive it True,\n    --  get all the source directories of the imported and modified project\n    --  files (recursively). If Recursive is False, just get the path for the\n@@ -76,8 +75,7 @@ package Prj.Env is\n \n    function Ada_Objects_Path\n      (Project             : Project_Id;\n-      Including_Libraries : Boolean := True)\n-      return                String_Access;\n+      Including_Libraries : Boolean := True) return String_Access;\n    --  Get the ADA_OBJECTS_PATH of a Project file. For the first call, compute\n    --  it and cache it. When Including_Libraries is False, do not include the\n    --  object directories of the library projects, and do not cache the result.\n@@ -86,39 +84,39 @@ package Prj.Env is\n      (Project             : Project_Id;\n       Including_Libraries : Boolean);\n    --  Set the env vars for additional project path files, after\n-   --  creating if necessary the path files.\n+   --  creating the path files if necessary.\n \n    procedure Delete_All_Path_Files;\n    --  Delete all temporary path files that have been created by\n    --  calls to Set_Ada_Paths.\n \n    function Path_Name_Of_Library_Unit_Body\n      (Name    : String;\n-      Project : Project_Id)\n-      return    String;\n-   --  Returns the Path of a library unit.\n+      Project : Project_Id) return String;\n+   --  Returns the Path of a library unit\n \n    function File_Name_Of_Library_Unit_Body\n      (Name              : String;\n       Project           : Project_Id;\n       Main_Project_Only : Boolean := True;\n-      Full_Path         : Boolean := False)\n-      return              String;\n+      Full_Path         : Boolean := False) return String;\n    --  Returns the file name of a library unit, in canonical case. Name may or\n    --  may not have an extension (corresponding to the naming scheme of the\n    --  project). If there is no body with this name, but there is a spec, the\n    --  name of the spec is returned.\n+   --\n    --  If Full_Path is False (the default), the simple file name is returned.\n+   --\n    --  If Full_Path is True, the absolute path name is returned.\n+   --\n    --  If neither a body nor a spec can be found, an empty string is returned.\n    --  If Main_Project_Only is True, the unit must be an immediate source of\n    --  Project. If it is False, it may be a source of one of its imported\n    --  projects.\n \n    function Project_Of\n      (Name         : String;\n-      Main_Project : Project_Id)\n-      return         Project_Id;\n+      Main_Project : Project_Id) return Project_Id;\n    --  Get the project of a source. The source file name may be truncated\n    --  (\".adb\" or \".ads\" may be missing). If the source is in a project being\n    --  extended, return the ultimate extending project. If it is not a source"}, {"sha": "f8ca61ea52ea370201006bdaad015a6870881898", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -2887,7 +2887,7 @@ package body Sem_Ch12 is\n                --  Remove entities in current scopes from visibility, so\n                --  than instance body is compiled in a clean environment.\n \n-               Save_Scope_Stack;\n+               Save_Scope_Stack (Handle_Use => False);\n \n                if Is_Child_Unit (S) then\n \n@@ -2951,7 +2951,7 @@ package body Sem_Ch12 is\n                end loop;\n             end if;\n \n-            Restore_Scope_Stack;\n+            Restore_Scope_Stack (Handle_Use => False);\n          end if;\n \n          --  Restore use clauses. For a child unit, use clauses in the"}, {"sha": "c4ad473fe84c5594949fecdbd5842ae0e4ada7c0", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -5072,7 +5072,7 @@ package body Sem_Ch8 is\n    -- Restore_Scope_Stack --\n    -------------------------\n \n-   procedure Restore_Scope_Stack is\n+   procedure Restore_Scope_Stack (Handle_Use : Boolean := True) is\n       E         : Entity_Id;\n       S         : Entity_Id;\n       Comp_Unit : Node_Id;\n@@ -5174,6 +5174,7 @@ package body Sem_Ch8 is\n \n       if SS_Last >= Scope_Stack.First\n         and then Scope_Stack.Table (SS_Last).Entity /= Standard_Standard\n+        and then Handle_Use\n       then\n          Install_Use_Clauses (Scope_Stack.Table (SS_Last).First_Use_Clause);\n       end if;\n@@ -5183,7 +5184,7 @@ package body Sem_Ch8 is\n    -- Save_Scope_Stack --\n    ----------------------\n \n-   procedure Save_Scope_Stack is\n+   procedure Save_Scope_Stack (Handle_Use : Boolean := True) is\n       E       : Entity_Id;\n       S       : Entity_Id;\n       SS_Last : constant Int := Scope_Stack.Last;\n@@ -5192,8 +5193,9 @@ package body Sem_Ch8 is\n       if SS_Last >= Scope_Stack.First\n         and then Scope_Stack.Table (SS_Last).Entity /= Standard_Standard\n       then\n-\n-         End_Use_Clauses (Scope_Stack.Table (SS_Last).First_Use_Clause);\n+         if Handle_Use then\n+            End_Use_Clauses (Scope_Stack.Table (SS_Last).First_Use_Clause);\n+         end if;\n \n          --  If the call is from within a compilation unit, as when\n          --  called from Rtsfind, make current entries in scope stack"}, {"sha": "bdd3d53d646c9fffcf0d765aeaf0bf1f97dcefb4", "filename": "gcc/ada/sem_ch8.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -135,14 +135,18 @@ package Sem_Ch8 is\n    --  or else a with-clause on system. N is absent when the function is\n    --  called to find the visibility of implicit operators.\n \n-   procedure Restore_Scope_Stack;\n-   procedure Save_Scope_Stack;\n+   procedure Restore_Scope_Stack (Handle_Use : Boolean := True);\n+   procedure Save_Scope_Stack (Handle_Use : Boolean := True);\n    --  These two procedures are called from Semantics, when a unit U1 is\n    --  to be compiled in the course of the compilation of another unit U2.\n    --  This happens whenever Rtsfind is called. U1, the unit retrieved by\n    --  Rtsfind, must be compiled in its own context, and the current scope\n    --  stack containing U2 and local scopes must be made unreachable. On\n    --  return, the contents of the scope stack must be made accessible again.\n+   --  The flag Handle_Use indicates whether local use clauses must be\n+   --  removed/installed. In the case of inlining of instance bodies, the\n+   --  visiblity handling is done fully in Inline_Instance_Body, and use\n+   --  clauses are handled there.\n \n    procedure Set_Use (L : List_Id);\n    --  Find use clauses that are declarative items in a package declaration"}, {"sha": "d5d82b2e33d36679df70b3fbcc2da50c7e3ec7b2", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ecad994dd1912e5c414b24280cdc8c6c8600e99f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=ecad994dd1912e5c414b24280cdc8c6c8600e99f", "patch": "@@ -7477,7 +7477,9 @@ package body Sem_Prag is\n                   Error_Pragma\n                     (\"pragma% ignored, cannot pack aliased components?\");\n \n-               elsif Has_Atomic_Components (Typ) then\n+               elsif Has_Atomic_Components (Typ)\n+                 or else Is_Atomic (Component_Type (Typ))\n+               then\n                   Error_Pragma\n                     (\"?pragma% ignored, cannot pack atomic components\");\n "}]}