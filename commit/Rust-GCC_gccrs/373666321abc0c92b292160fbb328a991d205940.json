{"sha": "373666321abc0c92b292160fbb328a991d205940", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzczNjY2MzIxYWJjMGM5MmIyOTIxNjBmYmIzMjhhOTkxZDIwNTk0MA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T20:14:57Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-07-06T20:14:57Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1475", "tree": {"sha": "8979093ab82c6099e027310ce4a8ecddb266b9cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8979093ab82c6099e027310ce4a8ecddb266b9cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/373666321abc0c92b292160fbb328a991d205940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/373666321abc0c92b292160fbb328a991d205940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/373666321abc0c92b292160fbb328a991d205940", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/373666321abc0c92b292160fbb328a991d205940/comments", "author": null, "committer": null, "parents": [{"sha": "fb3821f7b217dc72d9792d4c4f62095273a5fac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb3821f7b217dc72d9792d4c4f62095273a5fac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb3821f7b217dc72d9792d4c4f62095273a5fac7"}], "stats": {"total": 392, "additions": 213, "deletions": 179}, "files": [{"sha": "58399dd4041753f851bcc74ce74661ac6e30bedc", "filename": "gcc/regclass.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/373666321abc0c92b292160fbb328a991d205940/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/373666321abc0c92b292160fbb328a991d205940/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=373666321abc0c92b292160fbb328a991d205940", "patch": "@@ -536,7 +536,7 @@ regclass (f, nregs)\n \t      if (GET_CODE (insn) == INSN\n \t\t  && (noperands = asm_noperands (PATTERN (insn))) >= 0)\n \t\t{\n-\t\t  decode_asm_operands (PATTERN (insn), recog_operand, 0,\n+\t\t  decode_asm_operands (PATTERN (insn), recog_operand, NULL_PTR,\n \t\t\t\t       constraints, modes);\n \t\t  nalternatives = n_occurrences (',', constraints[0]) + 1;\n \t\t}\n@@ -557,7 +557,8 @@ regclass (f, nregs)\n \n \t\t  if (set != 0 && GET_CODE (SET_DEST (set)) == REG\n \t\t      && GET_CODE (SET_SRC (set)) == MEM\n-\t\t      && (note = find_reg_note (insn, REG_EQUIV, 0)) != 0\n+\t\t      && (note = find_reg_note (insn, REG_EQUIV,\n+\t\t\t\t\t\tNULL_RTX)) != 0\n \t\t      && GET_CODE (XEXP (note, 0)) == MEM)\n \t\t    {\n \t\t      costs[REGNO (SET_DEST (set))].mem_cost\n@@ -984,7 +985,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, constraints, insn)\n \t\t/* Match any floating double constant, but only if\n \t\t   we can examine the bits of it reliably.  */\n \t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n-\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t     || HOST_BITS_PER_WIDE_INT != BITS_PER_WORD)\n \t\t    && GET_MODE (op) != VOIDmode && ! flag_pretend_float)\n \t\t  break;\n \t\tif (GET_CODE (op) == CONST_DOUBLE)"}, {"sha": "8ebb5a8130ce175bfbce27d6f62a9345661cd423", "filename": "gcc/sdbout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/373666321abc0c92b292160fbb328a991d205940/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/373666321abc0c92b292160fbb328a991d205940/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=373666321abc0c92b292160fbb328a991d205940", "patch": "@@ -1129,8 +1129,8 @@ sdbout_parms (parms)\n \t/* Perform any necessary register eliminations on the parameter's rtl,\n \t   so that the debugging output will be accurate.  */\n \tDECL_INCOMING_RTL (parms) =\n-\t  eliminate_regs (DECL_INCOMING_RTL (parms), 0, 0);\n-\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, 0);\n+\t  eliminate_regs (DECL_INCOMING_RTL (parms), 0, NULL_RTX);\n+\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, NULL_RTX);\n \n \tif (PARM_PASSED_IN_MEMORY (parms))\n \t  {"}, {"sha": "837726534a5455d3ac9a95692816b4677f0e1586", "filename": "gcc/stmt.c", "status": "modified", "additions": 106, "deletions": 83, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/373666321abc0c92b292160fbb328a991d205940/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/373666321abc0c92b292160fbb328a991d205940/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=373666321abc0c92b292160fbb328a991d205940", "patch": "@@ -531,7 +531,7 @@ void\n expand_computed_goto (exp)\n      tree exp;\n {\n-  rtx x = expand_expr (exp, 0, VOIDmode, 0);\n+  rtx x = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n   emit_queue ();\n   emit_indirect_jump (x);\n }\n@@ -644,7 +644,7 @@ expand_goto (label)\n \t    addr = replace_rtx (copy_rtx (addr),\n \t\t\t\tvirtual_stack_vars_rtx, frame_pointer_rtx);\n \n-\t  emit_stack_restore (SAVE_NONLOCAL, addr, 0);\n+\t  emit_stack_restore (SAVE_NONLOCAL, addr, NULL_RTX);\n \n \t  /* Put in the static chain register the nonlocal label address.  */\n \t  emit_move_insn (static_chain_rtx,\n@@ -658,7 +658,7 @@ expand_goto (label)\n \t}\n      }\n   else\n-    expand_goto_internal (label, label_rtx (label), 0);\n+    expand_goto_internal (label, label_rtx (label), NULL_RTX);\n }\n \n /* Generate RTL code for a `goto' statement with target label BODY.\n@@ -696,7 +696,7 @@ expand_goto_internal (body, label, last_insn)\n \t  /* Execute the cleanups for blocks we are exiting.  */\n \t  if (block->data.block.cleanups != 0)\n \t    {\n-\t      expand_cleanups (block->data.block.cleanups, 0);\n+\t      expand_cleanups (block->data.block.cleanups, NULL_TREE);\n \t      do_pending_stack_adjust ();\n \t    }\n \t}\n@@ -707,7 +707,7 @@ expand_goto_internal (body, label, last_insn)\n \t     the stack pointer.  This one should be deleted as dead by flow. */\n \t  clear_pending_stack_adjust ();\n \t  do_pending_stack_adjust ();\n-\t  emit_stack_restore (SAVE_BLOCK, stack_level, 0);\n+\t  emit_stack_restore (SAVE_BLOCK, stack_level, NULL_RTX);\n \t}\n \n       if (body != 0 && DECL_TOO_LATE (body))\n@@ -824,7 +824,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n #endif\n \t     )\n \t    || block->data.block.cleanups)\n-\t   ? tree_cons (0, block->data.block.cleanups,\n+\t   ? tree_cons (NULL_TREE, block->data.block.cleanups,\n \t\t\tblock->data.block.outer_cleanups)\n \t   : 0);\n       fixup->next = goto_fixup_chain;\n@@ -1062,7 +1062,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  && TREE_CODE (val) != INDIRECT_REF)\n \tTREE_VALUE (tail) = save_expr (TREE_VALUE (tail));\n \n-      output_rtx[i] = expand_expr (TREE_VALUE (tail), 0, VOIDmode, 0);\n+      output_rtx[i] = expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n     }\n \n   if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n@@ -1113,7 +1113,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  }\n \n       XVECEXP (body, 3, i)      /* argvec */\n-\t= expand_expr (TREE_VALUE (tail), 0, VOIDmode, 0);\n+\t= expand_expr (TREE_VALUE (tail), NULL_RTX, VOIDmode, 0);\n       XVECEXP (body, 4, i)      /* constraints */\n \t= gen_rtx (ASM_INPUT, TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n \t\t   TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n@@ -1227,7 +1227,9 @@ expand_expr_stmt (exp)\n     }\n   last_expr_type = TREE_TYPE (exp);\n   if (! flag_syntax_only)\n-    last_expr_value = expand_expr (exp, expr_stmts_for_value ? 0 : const0_rtx,\n+    last_expr_value = expand_expr (exp,\n+\t\t\t\t   (expr_stmts_for_value\n+\t\t\t\t    ? NULL_RTX : const0_rtx),\n \t\t\t\t   VOIDmode, 0);\n \n   /* If all we do is reference a volatile value in memory,\n@@ -1244,7 +1246,7 @@ expand_expr_stmt (exp)\n \t  /* Compare the value with itself to reference it.  */\n \t  emit_cmp_insn (last_expr_value, last_expr_value, EQ,\n \t\t\t expand_expr (TYPE_SIZE (last_expr_type),\n-\t\t\t\t      0, VOIDmode, 0),\n+\t\t\t\t      NULL_RTX, VOIDmode, 0),\n \t\t\t BLKmode, 0,\n \t\t\t TYPE_ALIGN (last_expr_type) / BITS_PER_UNIT);\n \t  emit_jump_insn ((*bcc_gen_fctn[(int) EQ]) (lab));\n@@ -1539,7 +1541,7 @@ expand_start_try (try_clause, exitflag, escapeflag)\n   except_stack = thishandler;\n   nesting_stack = thishandler;\n \n-  do_jump (try_clause, thishandler->data.except_stmt.except_label, NULL);\n+  do_jump (try_clause, thishandler->data.except_stmt.except_label, NULL_RTX);\n }\n \n /* End of a TRY block.  Nothing to do for now.  */\n@@ -1548,7 +1550,8 @@ void\n expand_end_try ()\n {\n   except_stack->data.except_stmt.after_label = gen_label_rtx ();\n-  expand_goto_internal (NULL, except_stack->data.except_stmt.after_label, 0);\n+  expand_goto_internal (NULL_TREE, except_stack->data.except_stmt.after_label,\n+\t\t\tNULL_RTX);\n }\n \n /* Start an `except' nesting contour.\n@@ -1611,7 +1614,8 @@ expand_escape_except ()\n   for (n = except_stack; n; n = n->next)\n     if (n->data.except_stmt.escape_label != 0)\n       {\n-\texpand_goto_internal (0, n->data.except_stmt.escape_label, 0);\n+\texpand_goto_internal (NULL_TREE,\n+\t\t\t      n->data.except_stmt.escape_label, NULL_RTX);\n \treturn 1;\n       }\n \n@@ -1714,7 +1718,8 @@ expand_end_catch ()\n {\n   if (except_stack == 0 || except_stack->data.except_stmt.after_label == 0)\n     return 0;\n-  expand_goto_internal (0, except_stack->data.except_stmt.after_label, 0);\n+  expand_goto_internal (NULL_TREE, except_stack->data.except_stmt.after_label,\n+\t\t\tNULL_RTX);\n   return 1;\n }\n \f\n@@ -1745,7 +1750,7 @@ expand_start_cond (cond, exitflag)\n   cond_stack = thiscond;\n   nesting_stack = thiscond;\n \n-  do_jump (cond, thiscond->data.cond.next_label, NULL);\n+  do_jump (cond, thiscond->data.cond.next_label, NULL_RTX);\n }\n \n /* Generate RTL between then-clause and the elseif-clause\n@@ -1760,7 +1765,7 @@ expand_start_elseif (cond)\n   emit_jump (cond_stack->data.cond.endif_label);\n   emit_label (cond_stack->data.cond.next_label);\n   cond_stack->data.cond.next_label = gen_label_rtx ();\n-  do_jump (cond, cond_stack->data.cond.next_label, NULL);\n+  do_jump (cond, cond_stack->data.cond.next_label, NULL_RTX);\n }\n \n /* Generate RTL between the then-clause and the else-clause\n@@ -1821,7 +1826,7 @@ expand_start_loop (exit_flag)\n \n   do_pending_stack_adjust ();\n   emit_queue ();\n-  emit_note (0, NOTE_INSN_LOOP_BEG);\n+  emit_note (NULL_PTR, NOTE_INSN_LOOP_BEG);\n   emit_label (thisloop->data.loop.start_label);\n \n   return thisloop;\n@@ -1848,7 +1853,7 @@ void\n expand_loop_continue_here ()\n {\n   do_pending_stack_adjust ();\n-  emit_note (0, NOTE_INSN_LOOP_CONT);\n+  emit_note (NULL_PTR, NOTE_INSN_LOOP_CONT);\n   emit_label (loop_stack->data.loop.continue_label);\n }\n \n@@ -1952,7 +1957,7 @@ expand_end_loop ()\n     }\n \n   emit_jump (start_label);\n-  emit_note (0, NOTE_INSN_LOOP_END);\n+  emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n   emit_label (loop_stack->data.loop.end_label);\n \n   POPSTACK (loop_stack);\n@@ -1974,7 +1979,8 @@ expand_continue_loop (whichloop)\n     whichloop = loop_stack;\n   if (whichloop == 0)\n     return 0;\n-  expand_goto_internal (0, whichloop->data.loop.continue_label, 0);\n+  expand_goto_internal (NULL_TREE, whichloop->data.loop.continue_label,\n+\t\t\tNULL_RTX);\n   return 1;\n }\n \n@@ -1990,7 +1996,7 @@ expand_exit_loop (whichloop)\n     whichloop = loop_stack;\n   if (whichloop == 0)\n     return 0;\n-  expand_goto_internal (0, whichloop->data.loop.end_label, 0);\n+  expand_goto_internal (NULL_TREE, whichloop->data.loop.end_label, NULL_RTX);\n   return 1;\n }\n \n@@ -2008,7 +2014,7 @@ expand_exit_loop_if_false (whichloop, cond)\n     whichloop = loop_stack;\n   if (whichloop == 0)\n     return 0;\n-  do_jump (cond, whichloop->data.loop.end_label, NULL);\n+  do_jump (cond, whichloop->data.loop.end_label, NULL_RTX);\n   return 1;\n }\n \n@@ -2055,7 +2061,7 @@ expand_exit_something ()\n   for (n = nesting_stack; n; n = n->all)\n     if (n->exit_label != 0)\n       {\n-\texpand_goto_internal (0, n->exit_label, 0);\n+\texpand_goto_internal (NULL_TREE, n->exit_label, NULL_RTX);\n \treturn 1;\n       }\n \n@@ -2133,7 +2139,7 @@ expand_null_return_1 (last_insn, use_goto)\n     {\n       if (end_label == 0)\n \tend_label = return_label = gen_label_rtx ();\n-      expand_goto_internal (0, end_label, last_insn);\n+      expand_goto_internal (NULL_TREE, end_label, last_insn);\n       return;\n     }\n \n@@ -2149,7 +2155,7 @@ expand_null_return_1 (last_insn, use_goto)\n #endif\n \n   /* Otherwise jump to the epilogue.  */\n-  expand_goto_internal (0, end_label, last_insn);\n+  expand_goto_internal (NULL_TREE, end_label, last_insn);\n }\n \f\n /* Generate RTL to evaluate the expression RETVAL and return it\n@@ -2177,7 +2183,7 @@ expand_return (retval)\n   /* If function wants no value, give it none.  */\n   if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n     {\n-      expand_expr (retval, 0, VOIDmode, 0);\n+      expand_expr (retval, NULL_RTX, VOIDmode, 0);\n       expand_null_return ();\n       return;\n     }\n@@ -2213,7 +2219,7 @@ expand_return (retval)\n \t  || TREE_CODE (TREE_OPERAND (retval_rhs, 2)) == CALL_EXPR))\n     {\n       rtx label = gen_label_rtx ();\n-      do_jump (TREE_OPERAND (retval_rhs, 0), label, 0);\n+      do_jump (TREE_OPERAND (retval_rhs, 0), label, NULL_RTX);\n       expand_return (build (MODIFY_EXPR, TREE_TYPE (current_function_decl),\n \t\t\t    DECL_RESULT (current_function_decl),\n \t\t\t    TREE_OPERAND (retval_rhs, 1)));\n@@ -2246,7 +2252,7 @@ expand_return (retval)\n \t\t\t    tail_recursion_reentry);\n \t}\n       emit_queue ();\n-      expand_goto_internal (0, tail_recursion_label, last_insn);\n+      expand_goto_internal (NULL_TREE, tail_recursion_label, last_insn);\n       emit_barrier ();\n       return;\n     }\n@@ -2292,7 +2298,7 @@ expand_return (retval)\n       && GET_CODE (DECL_RTL (DECL_RESULT (current_function_decl))) == REG)\n     {\n       /* Calculate the return value into a pseudo reg.  */\n-      val = expand_expr (retval_rhs, 0, VOIDmode, 0);\n+      val = expand_expr (retval_rhs, NULL_RTX, VOIDmode, 0);\n       emit_queue ();\n       /* All temporaries have now been used.  */\n       free_temp_slots ();\n@@ -2303,7 +2309,7 @@ expand_return (retval)\n     {\n       /* No cleanups or no hard reg used;\n \t calculate value into hard return reg.  */\n-      expand_expr (retval, 0, VOIDmode, 0);\n+      expand_expr (retval, NULL_RTX, VOIDmode, 0);\n       emit_queue ();\n       free_temp_slots ();\n       expand_value_return (DECL_RTL (DECL_RESULT (current_function_decl)));\n@@ -2358,7 +2364,7 @@ tail_recursion_args (actuals, formals)\n   argvec = (rtx *) alloca (i * sizeof (rtx));\n \n   for (a = actuals, i = 0; a; a = TREE_CHAIN (a), i++)\n-    argvec[i] = expand_expr (TREE_VALUE (a), 0, VOIDmode, 0);\n+    argvec[i] = expand_expr (TREE_VALUE (a), NULL_RTX, VOIDmode, 0);\n \n   /* Find which actual values refer to current values of previous formals.\n      Copy each of them now, before any formal is changed.  */\n@@ -2402,7 +2408,7 @@ expand_start_bindings (exit_flag)\n {\n   struct nesting *thisblock = ALLOC_NESTING ();\n \n-  rtx note = emit_note (0, NOTE_INSN_BLOCK_BEG);\n+  rtx note = emit_note (NULL_PTR, NOTE_INSN_BLOCK_BEG);\n \n   /* Make an entry on block_stack for the block we are entering.  */\n \n@@ -2475,7 +2481,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n   /* Mark the beginning and end of the scope if requested.  */\n \n   if (mark_ends)\n-    emit_note (0, NOTE_INSN_BLOCK_END);\n+    emit_note (NULL_PTR, NOTE_INSN_BLOCK_END);\n   else\n     /* Get rid of the beginning-mark if we don't make an end-mark.  */\n     NOTE_LINE_NUMBER (thisblock->data.block.first_insn) = NOTE_INSN_DELETED;\n@@ -2633,7 +2639,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       expr_stmts_for_value = 0;\n \n       /* Do the cleanups.  */\n-      expand_cleanups (thisblock->data.block.cleanups, 0);\n+      expand_cleanups (thisblock->data.block.cleanups, NULL_TREE);\n       do_pending_stack_adjust ();\n \n       expr_stmts_for_value = old_expr_stmts_for_value;\n@@ -2645,9 +2651,10 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       if (thisblock->data.block.stack_level != 0)\n \t{\n \t  emit_stack_restore (thisblock->next ? SAVE_BLOCK : SAVE_FUNCTION,\n-\t\t\t      thisblock->data.block.stack_level, 0);\n+\t\t\t      thisblock->data.block.stack_level, NULL_RTX);\n \t  if (nonlocal_goto_handler_slot != 0)\n-\t    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n+\t    emit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level,\n+\t\t\t     NULL_RTX);\n \t}\n \n       /* Any gotos out of this block must also do these things.\n@@ -2816,17 +2823,18 @@ expand_decl (decl)\n       size = expand_expr (size_binop (CEIL_DIV_EXPR,\n \t\t\t\t      DECL_SIZE (decl),\n \t\t\t\t      size_int (BITS_PER_UNIT)),\n-\t\t\t  0, VOIDmode, 0);\n+\t\t\t  NULL_RTX, VOIDmode, 0);\n       free_temp_slots ();\n \n       /* This is equivalent to calling alloca.  */\n       current_function_calls_alloca = 1;\n \n       /* Allocate space on the stack for the variable.  */\n-      address = allocate_dynamic_stack_space (size, 0, DECL_ALIGN (decl));\n+      address = allocate_dynamic_stack_space (size, NULL_RTX,\n+\t\t\t\t\t      DECL_ALIGN (decl));\n \n       if (nonlocal_goto_handler_slot != 0)\n-\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, 0);\n+\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n \n       /* Reference the variable indirect through that rtx.  */\n       DECL_RTL (decl) = gen_rtx (MEM, DECL_MODE (decl), address);\n@@ -3030,7 +3038,7 @@ fixup_cleanups (list, before_jump)\n   rtx beyond_jump = get_last_insn ();\n   rtx new_before_jump;\n \n-  expand_cleanups (list, 0);\n+  expand_cleanups (list, NULL_TREE);\n   /* Pop any pushes done in the cleanups,\n      in case function is about to return.  */\n   do_pending_stack_adjust ();\n@@ -3144,7 +3152,7 @@ expand_start_case (exit_flag, expr, type, printname)\n   /* Make sure case_stmt.start points to something that won't\n      need any transformation before expand_end_case.  */\n   if (GET_CODE (get_last_insn ()) != NOTE)\n-    emit_note (0, NOTE_INSN_DELETED);\n+    emit_note (NULL_PTR, NOTE_INSN_DELETED);\n \n   thiscase->data.case_stmt.start = get_last_insn ();\n }\n@@ -3661,7 +3669,8 @@ expand_end_case (orig_index)\n \n       else if (TREE_INT_CST_HIGH (range) != 0\n \t       || count < CASE_VALUES_THRESHOLD\n-\t       || (unsigned) (TREE_INT_CST_LOW (range)) > 10 * count\n+\t       || ((unsigned HOST_WIDE_INT) (TREE_INT_CST_LOW (range))\n+\t\t   > 10 * count)\n \t       || TREE_CODE (index_expr) == INTEGER_CST\n \t       /* These will reduce to a constant.  */\n \t       || (TREE_CODE (index_expr) == CALL_EXPR\n@@ -3671,7 +3680,7 @@ expand_end_case (orig_index)\n \t       || (TREE_CODE (index_expr) == COMPOUND_EXPR\n \t\t   && TREE_CODE (TREE_OPERAND (index_expr, 1)) == INTEGER_CST))\n \t{\n-\t  index = expand_expr (index_expr, 0, VOIDmode, 0);\n+\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n \n \t  /* If the index is a short or char that we do not have\n \t     an insn to handle comparisons directly, convert it to\n@@ -3749,7 +3758,8 @@ expand_end_case (orig_index)\n \t      use_cost_table\n \t\t= (TREE_CODE (TREE_TYPE (orig_index)) != ENUMERAL_TYPE\n \t\t   && estimate_case_costs (thiscase->data.case_stmt.case_list));\n-\t      balance_case_nodes (&thiscase->data.case_stmt.case_list, 0);\n+\t      balance_case_nodes (&thiscase->data.case_stmt.case_list, \n+\t\t\t\t  NULL_PTR);\n \t      emit_case_nodes (index, thiscase->data.case_stmt.case_list,\n \t\t\t       default_label, TREE_TYPE (index_expr));\n \t      emit_jump_if_reachable (default_label);\n@@ -3769,14 +3779,14 @@ expand_end_case (orig_index)\n \t\t  > GET_MODE_BITSIZE (index_mode))\n \t\t{\n \t\t  enum machine_mode omode = TYPE_MODE (TREE_TYPE (index_expr));\n-\t\t  rtx rangertx = expand_expr (range, 0, VOIDmode, 0);\n+\t\t  rtx rangertx = expand_expr (range, NULL_RTX, VOIDmode, 0);\n \n \t\t  /* We must handle the endpoints in the original mode.  */\n \t\t  index_expr = build (MINUS_EXPR, TREE_TYPE (index_expr),\n \t\t\t\t      index_expr, minval);\n \t\t  minval = integer_zero_node;\n-\t\t  index = expand_expr (index_expr, 0, VOIDmode, 0);\n-\t\t  emit_cmp_insn (rangertx, index, LTU, 0, omode, 0, 0);\n+\t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n+\t\t  emit_cmp_insn (rangertx, index, LTU, NULL_RTX, omode, 0, 0);\n \t\t  emit_jump_insn (gen_bltu (default_label));\n \t\t  /* Now we can safely truncate.  */\n \t\t  index = convert_to_mode (index_mode, index, 0);\n@@ -3786,14 +3796,16 @@ expand_end_case (orig_index)\n \t\t  if (TYPE_MODE (TREE_TYPE (index_expr)) != index_mode)\n \t\t    index_expr = convert (type_for_size (index_bits, 0),\n \t\t\t\t\t  index_expr);\n-\t\t  index = expand_expr (index_expr, 0, VOIDmode, 0);\n+\t\t  index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n \t\t}\n \t      emit_queue ();\n \t      index = protect_from_queue (index, 0);\n \t      do_pending_stack_adjust ();\n \n-\t      emit_jump_insn (gen_casesi (index, expand_expr (minval, 0, VOIDmode, 0),\n-\t\t\t\t\t  expand_expr (range, 0, VOIDmode, 0),\n+\t      emit_jump_insn (gen_casesi (index, expand_expr (minval, NULL_RTX,\n+\t\t\t\t\t\t\t      VOIDmode, 0),\n+\t\t\t\t\t  expand_expr (range, NULL_RTX,\n+\t\t\t\t\t\t       VOIDmode, 0),\n \t\t\t\t\t  table_label, default_label));\n \t      win = 1;\n \t    }\n@@ -3805,13 +3817,13 @@ expand_end_case (orig_index)\n \t\t\t\t    fold (build (MINUS_EXPR,\n \t\t\t\t\t\t TREE_TYPE (index_expr),\n \t\t\t\t\t\t index_expr, minval)));\n-\t      index = expand_expr (index_expr, 0, VOIDmode, 0);\n+\t      index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n \t      emit_queue ();\n \t      index = protect_from_queue (index, 0);\n \t      do_pending_stack_adjust ();\n \n \t      do_tablejump (index, TYPE_MODE (TREE_TYPE (index_expr)),\n-\t\t\t    expand_expr (range, 0, VOIDmode, 0),\n+\t\t\t    expand_expr (range, NULL_RTX, VOIDmode, 0),\n \t\t\t    table_label, default_label);\n \t      win = 1;\n \t    }\n@@ -3827,7 +3839,7 @@ expand_end_case (orig_index)\n \n \t  for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n \t    {\n-\t      register int i\n+\t      register HOST_WIDE_INT i\n \t\t= TREE_INT_CST_LOW (n->low) - TREE_INT_CST_LOW (minval);\n \n \t      while (1)\n@@ -3903,7 +3915,7 @@ do_jump_if_equal (op1, op2, label, unsignedp)\n       enum machine_mode mode = GET_MODE (op1);\n       if (mode == VOIDmode)\n \tmode = GET_MODE (op2);\n-      emit_cmp_insn (op1, op2, EQ, 0, mode, unsignedp, 0);\n+      emit_cmp_insn (op1, op2, EQ, NULL_RTX, mode, unsignedp, 0);\n       emit_jump_insn (gen_beq (label));\n     }\n }\n@@ -4318,7 +4330,7 @@ emit_case_nodes (index, node, default_label, index_type)\n       /* Node is single valued.  First see if the index expression matches\n \t this node and then check our children, if any. */\n \n-      do_jump_if_equal (index, expand_expr (node->low, 0, VOIDmode, 0),\n+      do_jump_if_equal (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n \t\t\tlabel_rtx (node->code_label), unsignedp);\n \n       if (node->right != 0 && node->left != 0)\n@@ -4331,18 +4343,19 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  if (node_is_bounded (node->right, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t     GT, 0, mode, unsignedp, 0);\n+\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n \n \t      emit_jump_insn ((*gen_bgt_pat) (label_rtx (node->right->code_label)));\n \t      emit_case_nodes (index, node->left, default_label, index_type);\n \t    }\n \n \t  else if (node_is_bounded (node->left, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, 0,\n+\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n \t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     LT, 0, mode, unsignedp, 0);\n+\t\t\t     LT, NULL_RTX, mode, unsignedp, 0);\n \t      emit_jump_insn ((*gen_blt_pat) (label_rtx (node->left->code_label)));\n \t      emit_case_nodes (index, node->right, default_label, index_type);\n \t    }\n@@ -4356,9 +4369,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t\t= build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n \t      /* See if the value is on the right.  */\n-\t      emit_cmp_insn (index, expand_expr (node->high, 0,\n+\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n \t\t\t\t\t\t VOIDmode, 0),\n-\t\t\t     GT, 0, mode, unsignedp, 0);\n+\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n \t      emit_jump_insn ((*gen_bgt_pat) (label_rtx (test_label)));\n \n \t      /* Value must be on the left.\n@@ -4387,8 +4400,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t    {\n \t      if (!node_has_low_bound (node, index_type))\n \t\t{\n-\t\t  emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t\t LT, 0, mode, unsignedp, 0);\n+\t\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t LT, NULL_RTX, mode, unsignedp, 0);\n \t\t  emit_jump_insn ((*gen_blt_pat) (default_label));\n \t\t}\n \n@@ -4399,7 +4413,8 @@ emit_case_nodes (index, node, default_label, index_type)\n \t       since we haven't ruled out the numbers less than\n \t       this node's value.  So handle node->right explicitly.  */\n \t    do_jump_if_equal (index,\n-\t\t\t      expand_expr (node->right->low, 0, VOIDmode, 0),\n+\t\t\t      expand_expr (node->right->low, NULL_RTX,\n+\t\t\t\t\t   VOIDmode, 0),\n \t\t\t      label_rtx (node->right->code_label), unsignedp);\n \t}\n \n@@ -4425,8 +4440,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t    {\n \t      if (!node_has_high_bound (node, index_type))\n \t\t{\n-\t\t  emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t\t GT, 0, mode, unsignedp, 0);\n+\t\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t\t GT, NULL_RTX, mode, unsignedp, 0);\n \t\t  emit_jump_insn ((*gen_bgt_pat) (default_label));\n \t\t}\n \n@@ -4437,7 +4453,8 @@ emit_case_nodes (index, node, default_label, index_type)\n \t       since we haven't ruled out the numbers less than\n \t       this node's value.  So handle node->left explicitly.  */\n \t    do_jump_if_equal (index,\n-\t\t\t      expand_expr (node->left->low, 0, VOIDmode, 0),\n+\t\t\t      expand_expr (node->left->low, NULL_RTX,\n+\t\t\t\t\t   VOIDmode, 0),\n \t\t\t      label_rtx (node->left->code_label), unsignedp);\n \t}\n     }\n@@ -4456,8 +4473,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     then handle the two subtrees.  */\n \t  tree test_label = 0;\n \n-\t  emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t GT, 0, mode, unsignedp, 0);\n+\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t GT, NULL_RTX, mode, unsignedp, 0);\n \n \t  if (node_is_bounded (node->right, index_type))\n \t    /* Right hand node is fully bounded so we can eliminate any\n@@ -4474,8 +4492,8 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n-\t  emit_cmp_insn (index, expand_expr (node->low, 0, VOIDmode, 0),\n-\t\t\t GE, 0, mode, unsignedp, 0);\n+\t  emit_cmp_insn (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n+\t\t\t GE, NULL_RTX, mode, unsignedp, 0);\n \t  emit_jump_insn ((*gen_bge_pat) (label_rtx (node->code_label)));\n \n \t  /* Handle the left-hand subtree.  */\n@@ -4500,15 +4518,17 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     if they are possible.  */\n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->low, 0, VOIDmode, 0),\n-\t\t\t     LT, 0, mode, unsignedp, 0);\n+\t      emit_cmp_insn (index, expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t     LT, NULL_RTX, mode, unsignedp, 0);\n \t      emit_jump_insn ((*gen_blt_pat) (default_label));\n \t    }\n \n \t  /* Value belongs to this node or to the right-hand subtree.  */\n \n-\t  emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t LE, 0, mode, unsignedp, 0);\n+\t  emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t     VOIDmode, 0),\n+\t\t\t LE, NULL_RTX, mode, unsignedp, 0);\n \t  emit_jump_insn ((*gen_ble_pat) (label_rtx (node->code_label)));\n \n \t  emit_case_nodes (index, node->right, default_label, index_type);\n@@ -4520,15 +4540,16 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     if they are possible.  */\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t     GT, 0, mode, unsignedp, 0);\n+\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n \t      emit_jump_insn ((*gen_bgt_pat) (default_label));\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n-\t  emit_cmp_insn (index, expand_expr (node->low, 0, VOIDmode, 0),\n-\t\t\t GE, 0, mode, unsignedp, 0);\n+\t  emit_cmp_insn (index, expand_expr (node->low, NULL_RTX, VOIDmode, 0),\n+\t\t\t GE, NULL_RTX, mode, unsignedp, 0);\n \t  emit_jump_insn ((*gen_bge_pat) (label_rtx (node->code_label)));\n \n \t  emit_case_nodes (index, node->left, default_label, index_type);\n@@ -4542,15 +4563,17 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->high, 0, VOIDmode, 0),\n-\t\t\t     GT, 0, mode, unsignedp, 0);\n+\t      emit_cmp_insn (index, expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t     GT, NULL_RTX, mode, unsignedp, 0);\n \t      emit_jump_insn ((*gen_bgt_pat) (default_label));\n \t    }\n \n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n-\t      emit_cmp_insn (index, expand_expr (node->low, 0, VOIDmode, 0),\n-\t\t\t     LT, 0, mode, unsignedp, 0);\n+\t      emit_cmp_insn (index, expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t VOIDmode, 0),\n+\t\t\t     LT, NULL_RTX, mode, unsignedp, 0);\n \t      emit_jump_insn ((*gen_blt_pat) (default_label));\n \t    }\n "}, {"sha": "1e831935b72317c4675dfc846d30dbdd15da9a48", "filename": "gcc/toplev.c", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/373666321abc0c92b292160fbb328a991d205940/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/373666321abc0c92b292160fbb328a991d205940/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=373666321abc0c92b292160fbb328a991d205940", "patch": "@@ -853,13 +853,16 @@ report_error_function (file)\n }\n \n /* Report an error at the current line number.\n-   S and V are a string and an arg for `printf'.  */\n+   S is a string and V and V2 are args for `printf'.  We use HOST_WIDE_INT\n+   as the type for these args assuming it is wide enough to hold a\n+   pointer.  This isn't terribly portable, but is the best we can do\n+   without vprintf universally available.  */\n \n void\n error (s, v, v2)\n      char *s;\n-     int v;\t\t\t/* @@also used as pointer */\n-     int v2;\t\t\t/* @@also used as pointer */\n+     HOST_WIDE_INT v;\t\t/* Also used as pointer */\n+     HOST_WIDE_INT v2;\t\t/* Also used as pointer */\n {\n   error_with_file_and_line (input_filename, lineno, s, v, v2);\n }\n@@ -872,8 +875,8 @@ error_with_file_and_line (file, line, s, v, v2)\n      char *file;\n      int line;\n      char *s;\n-     int v;\n-     int v2;\n+     HOST_WIDE_INT v;\n+     HOST_WIDE_INT v2;\n {\n   count_error (0);\n \n@@ -888,13 +891,14 @@ error_with_file_and_line (file, line, s, v, v2)\n }\n \n /* Report an error at the declaration DECL.\n-   S and V are a string and an arg which uses %s to substitute the declaration name.  */\n+   S and V are a string and an arg which uses %s to substitute\n+   the declaration name.  */\n \n void\n error_with_decl (decl, s, v)\n      tree decl;\n      char *s;\n-     int v;\n+     HOST_WIDE_INT v;\n {\n   char *junk;\n   count_error (0);\n@@ -920,8 +924,8 @@ void\n error_for_asm (insn, s, v, v2)\n      rtx insn;\n      char *s;\n-     int v;\t\t\t/* @@also used as pointer */\n-     int v2;\t\t\t/* @@also used as pointer */\n+     HOST_WIDE_INT v;\t\t/* Also used as pointer */\n+     HOST_WIDE_INT v2;\t\t/* Also used as pointer */\n {\n   char *filename;\n   int line;\n@@ -954,9 +958,7 @@ warning_with_file_and_line (file, line, s, v, v2, v3)\n      char *file;\n      int line;\n      char *s;\n-     int v;\n-     int v2;\n-     int v3;\n+     HOST_WIDE_INT v, v2, v3;\n {\n   if (count_error (1) == 0)\n     return;\n@@ -979,9 +981,7 @@ warning_with_file_and_line (file, line, s, v, v2, v3)\n void\n warning (s, v, v2, v3)\n      char *s;\n-     int v;\t\t\t/* @@also used as pointer */\n-     int v2;\n-     int v3;\n+     HOST_WIDE_INT v, v2, v3;\t/* Also used as pointer */\n {\n   warning_with_file_and_line (input_filename, lineno, s, v, v2, v3);\n }\n@@ -994,7 +994,7 @@ void\n warning_with_decl (decl, s, v)\n      tree decl;\n      char *s;\n-     int v;\n+     HOST_WIDE_INT v;\n {\n   char *junk;\n \n@@ -1023,8 +1023,8 @@ void\n warning_for_asm (insn, s, v, v2)\n      rtx insn;\n      char *s;\n-     int v;\t\t\t/* @@also used as pointer */\n-     int v2;\t\t\t/* @@also used as pointer */\n+     HOST_WIDE_INT v;\t\t/* Also used as pointer */\n+     HOST_WIDE_INT v2;\t\t/* Also used as pointer */\n {\n   char *filename;\n   int line;\n@@ -1055,8 +1055,8 @@ warning_for_asm (insn, s, v, v2)\n void\n pedwarn (s, v, v2)\n      char *s;\n-     int v;\t\t\t/* @@also used as pointer */\n-     int v2;\n+     HOST_WIDE_INT v;\t\t/* Also used as pointer */\n+     HOST_WIDE_INT v2;\n {\n   if (flag_pedantic_errors)\n     error (s, v, v2);\n@@ -1068,7 +1068,7 @@ void\n pedwarn_with_decl (decl, s, v)\n      tree decl;\n      char *s;\n-     int v;\n+     HOST_WIDE_INT v;\n {\n   if (flag_pedantic_errors)\n     error_with_decl (decl, s, v);\n@@ -1081,8 +1081,8 @@ pedwarn_with_file_and_line (file, line, s, v, v2)\n      char *file;\n      int line;\n      char *s;\n-     int v;\n-     int v2;\n+     HOST_WIDE_INT v;\n+     HOST_WIDE_INT v2;\n {\n   if (flag_pedantic_errors)\n     error_with_file_and_line (file, line, s, v, v2);\n@@ -1096,7 +1096,7 @@ pedwarn_with_file_and_line (file, line, s, v, v2)\n void\n sorry (s, v, v2)\n      char *s;\n-     int v, v2;\n+     HOST_WIDE_INT v, v2;\n {\n   sorrycount++;\n   if (input_filename)\n@@ -1115,7 +1115,7 @@ sorry (s, v, v2)\n void\n really_sorry (s, v, v2)\n      char *s;\n-     int v, v2;\n+     HOST_WIDE_INT v, v2;\n {\n   if (input_filename)\n     fprintf (stderr, \"%s:%d: \", input_filename, lineno);\n@@ -1185,11 +1185,13 @@ xrealloc (ptr, size)\n }\n \f\n /* Return the logarithm of X, base 2, considering X unsigned,\n-   if X is a power of 2.  Otherwise, returns -1.  */\n+   if X is a power of 2.  Otherwise, returns -1.\n+\n+   This should be used via the `exact_log2' macro.  */\n \n int\n-exact_log2 (x)\n-     register unsigned int x;\n+exact_log2_wide (x)\n+     register unsigned HOST_WIDE_INT x;\n {\n   register int log = 0;\n   /* Test for 0 or a power of 2.  */\n@@ -1201,11 +1203,13 @@ exact_log2 (x)\n }\n \n /* Given X, an unsigned number, return the largest int Y such that 2**Y <= X.\n-   If X is 0, return -1.  */\n+   If X is 0, return -1.\n+\n+   This should be used via the floor_log2 macro.  */\n \n int\n-floor_log2 (x)\n-     register unsigned int x;\n+floor_log2_wide (x)\n+     register unsigned HOST_WIDE_INT x;\n {\n   register int log = -1;\n   while (x != 0)\n@@ -1686,7 +1690,7 @@ compile_file (name)\n \t\t|| TREE_USED (decl)\n \t\t|| TREE_ADDRESSABLE (decl)\n \t\t|| TREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (decl)))\n-\t      rest_of_decl_compilation (decl, 0, 1, 1);\n+\t      rest_of_decl_compilation (decl, NULL_PTR, 1, 1);\n \t    else\n \t      /* Cancel the RTL for this decl so that, if debugging info\n \t\t output for global variables is still to come,\n@@ -2171,7 +2175,7 @@ rest_of_compilation (decl)\n     {\n       TIMEVAR (loop_time,\n \t       {\n-\t\t loop_optimize (insns, loop_dump ? loop_dump_file : 0);\n+\t\t loop_optimize (insns, loop_dump_file);\n \t       });\n     }\n \n@@ -2349,10 +2353,9 @@ rest_of_compilation (decl)\n   TIMEVAR (global_alloc_time,\n \t   {\n \t     if (!obey_regdecls)\n-\t       failure = global_alloc (global_reg_dump ? global_reg_dump_file : 0);\n+\t       failure = global_alloc (global_reg_dump_file);\n \t     else\n-\t       failure = reload (insns, 0,\n-\t\t\t\t global_reg_dump ? global_reg_dump_file : 0);\n+\t       failure = reload (insns, 0, global_reg_dump_file);\n \t   });\n \n   if (global_reg_dump)\n@@ -2521,7 +2524,7 @@ rest_of_compilation (decl)\n      queued up for sdb output.  */\n #ifdef SDB_DEBUGGING_INFO\n   if (write_symbols == SDB_DEBUG)\n-    sdbout_types (0);\n+    sdbout_types (NULL_TREE);\n #endif\n \n   /* Put back the tree of subblocks from before we copied it."}, {"sha": "b5c50717fb8dd1848993481163b429c090c752ed", "filename": "gcc/tree.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/373666321abc0c92b292160fbb328a991d205940/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/373666321abc0c92b292160fbb328a991d205940/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=373666321abc0c92b292160fbb328a991d205940", "patch": "@@ -537,7 +537,7 @@ obfree (ptr)\n \n char *\n permalloc (size)\n-     long size;\n+     int size;\n {\n   return (char *) obstack_alloc (&permanent_obstack, size);\n }\n@@ -1055,11 +1055,13 @@ set_identifier_size (size)\n \f\n /* Return a newly constructed INTEGER_CST node whose constant value\n    is specified by the two ints LOW and HI.\n-   The TREE_TYPE is set to `int'.  */\n+   The TREE_TYPE is set to `int'. \n+\n+   This function should be used via the `build_int_2' macro.  */\n \n tree\n-build_int_2 (low, hi)\n-     int low, hi;\n+build_int_2_wide (low, hi)\n+     HOST_WIDE_INT low, hi;\n {\n   register tree t = make_node (INTEGER_CST);\n   TREE_INT_CST_LOW (t) = low;\n@@ -1105,17 +1107,17 @@ real_value_from_int_cst (i)\n   if (TREE_INT_CST_HIGH (i) < 0)\n     {\n       d = (double) (~ TREE_INT_CST_HIGH (i));\n-      d *= ((double) (1 << (HOST_BITS_PER_INT / 2))\n-\t    * (double) (1 << (HOST_BITS_PER_INT / 2)));\n-      d += (double) (unsigned) (~ TREE_INT_CST_LOW (i));\n+      d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n+\t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n+      d += (double) (unsigned HOST_WIDE_INT) (~ TREE_INT_CST_LOW (i));\n       d = (- d - 1.0);\n     }\n   else\n     {\n       d = (double) TREE_INT_CST_HIGH (i);\n-      d *= ((double) (1 << (HOST_BITS_PER_INT / 2))\n-\t    * (double) (1 << (HOST_BITS_PER_INT / 2)));\n-      d += (double) (unsigned) TREE_INT_CST_LOW (i);\n+      d *= ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n+\t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n+      d += (double) (unsigned HOST_WIDE_INT) TREE_INT_CST_LOW (i);\n     }\n #endif /* not REAL_ARITHMETIC */\n   return d;\n@@ -1258,27 +1260,27 @@ integer_all_onesp (expr)\n     return TREE_INT_CST_LOW (expr) == -1 && TREE_INT_CST_HIGH (expr) == -1;\n \n   prec = TYPE_PRECISION (TREE_TYPE (expr));\n-  if (prec >= HOST_BITS_PER_INT)\n+  if (prec >= HOST_BITS_PER_WIDE_INT)\n     {\n       int high_value, shift_amount;\n \n-      shift_amount = prec - HOST_BITS_PER_INT;\n+      shift_amount = prec - HOST_BITS_PER_WIDE_INT;\n \n-      if (shift_amount > HOST_BITS_PER_INT)\n+      if (shift_amount > HOST_BITS_PER_WIDE_INT)\n \t/* Can not handle precisions greater than twice the host int size.  */\n \tabort ();\n-      else if (shift_amount == HOST_BITS_PER_INT)\n+      else if (shift_amount == HOST_BITS_PER_WIDE_INT)\n \t/* Shifting by the host word size is undefined according to the ANSI\n \t   standard, so we must handle this as a special case.  */\n \thigh_value = -1;\n       else\n-\thigh_value = (1 << shift_amount) - 1;\n+\thigh_value = ((HOST_WIDE_INT) 1 << shift_amount) - 1;\n \n       return TREE_INT_CST_LOW (expr) == -1\n \t&& TREE_INT_CST_HIGH (expr) == high_value;\n     }\n   else\n-    return TREE_INT_CST_LOW (expr) == (1 << prec) - 1;\n+    return TREE_INT_CST_LOW (expr) == ((HOST_WIDE_INT) 1 << prec) - 1;\n }\n \n /* Return 1 if EXPR is an integer constant that is a power of 2 (i.e., has only\n@@ -1288,7 +1290,7 @@ int\n integer_pow2p (expr)\n      tree expr;\n {\n-  int high, low;\n+  HOST_WIDE_INT high, low;\n \n   while (TREE_CODE (expr) == NON_LVALUE_EXPR)\n     expr = TREE_OPERAND (expr, 0);\n@@ -1646,7 +1648,7 @@ size_in_bytes (type)\n   type = TYPE_MAIN_VARIANT (type);\n   if (TYPE_SIZE (type) == 0)\n     {\n-      incomplete_type_error (0, type);\n+      incomplete_type_error (NULL_TREE, type);\n       return integer_zero_node;\n     }\n   return size_binop (CEIL_DIV_EXPR, TYPE_SIZE (type),\n@@ -1747,7 +1749,7 @@ save_expr (expr)\n       || TREE_CODE (t) == SAVE_EXPR)\n     return t;\n \n-  t = build (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl, NULL);\n+  t = build (SAVE_EXPR, TREE_TYPE (expr), t, current_function_decl, NULL_TREE);\n \n   /* This expression might be placed ahead of a jump to ensure that the\n      value was computed on both sides of the jump.  So make sure it isn't\n@@ -2628,7 +2630,7 @@ build_index_type (maxval)\n   TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n   if (TREE_CODE (maxval) == INTEGER_CST)\n     {\n-      int maxint = TREE_INT_CST_LOW (maxval);\n+      HOST_WIDE_INT maxint = TREE_INT_CST_LOW (maxval);\n       return type_hash_canon (maxint > 0 ? maxint : - maxint, itype);\n     }\n   else\n@@ -2652,9 +2654,9 @@ build_index_2_type (lowval,highval)\n   if ((TREE_CODE (lowval) == INTEGER_CST)\n       && (TREE_CODE (highval) == INTEGER_CST))\n     {\n-      int highint = TREE_INT_CST_LOW (highval);\n-      int lowint = TREE_INT_CST_LOW (lowval);\n-      int maxint = highint - lowint;\n+      HOST_WIDE_INT highint = TREE_INT_CST_LOW (highval);\n+      HOST_WIDE_INT lowint = TREE_INT_CST_LOW (lowval);\n+      HOST_WIDE_INT maxint = highint - lowint;\n       return type_hash_canon (maxint > 0 ? maxint : - maxint, itype);\n     }\n   else\n@@ -2818,7 +2820,8 @@ build_method_type (basetype, type)\n      which is \"this\".  Put it into the list of argument types.  */\n \n   TYPE_ARG_TYPES (t)\n-    = tree_cons (NULL, build_pointer_type (basetype), TYPE_ARG_TYPES (type));\n+    = tree_cons (NULL_TREE,\n+\t\t build_pointer_type (basetype), TYPE_ARG_TYPES (type));\n \n   /* If we already have such a type, use the old one and free this one.  */\n   hashcode = TYPE_HASH (basetype) + TYPE_HASH (type);"}, {"sha": "38ce48fa28a1c8e4a01f094d70a3d5803464bc0b", "filename": "gcc/varasm.c", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/373666321abc0c92b292160fbb328a991d205940/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/373666321abc0c92b292160fbb328a991d205940/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=373666321abc0c92b292160fbb328a991d205940", "patch": "@@ -1217,7 +1217,7 @@ assemble_real (d, mode)\n       abort ();\n     }\n \n-  set_float_handler (0);\n+  set_float_handler (NULL_PTR);\n }\n \f\n /* Here we combine duplicate floating constants to make\n@@ -1238,7 +1238,7 @@ static rtx const_double_chain;\n \n rtx\n immed_double_const (i0, i1, mode)\n-     int i0, i1;\n+     HOST_WIDE_INT i0, i1;\n      enum machine_mode mode;\n {\n   register rtx r;\n@@ -1250,22 +1250,24 @@ immed_double_const (i0, i1, mode)\n \t sign bit are all one.  So we get either a reasonable negative value\n \t or a reasonable unsigned value for this mode.  */\n       int width = GET_MODE_BITSIZE (mode);\n-      if (width < HOST_BITS_PER_INT\n-\t  && ((i0 & ((-1) << (width - 1))) != ((-1) << (width - 1))))\n-\ti0 &= (1 << width) - 1, i1 = 0;\n-      else if (width == HOST_BITS_PER_INT\n+      if (width < HOST_BITS_PER_WIDE_INT\n+\t  && ((i0 & ((HOST_WIDE_INT) (-1) << (width - 1)))\n+\t      != ((HOST_WIDE_INT) (-1) << (width - 1))))\n+\ti0 &= ((HOST_WIDE_INT) 1 << width) - 1, i1 = 0;\n+      else if (width == HOST_BITS_PER_WIDE_INT\n \t       && ! (i1 == ~0 && i0 < 0))\n \ti1 = 0;\n-      else if (width > 2 * HOST_BITS_PER_INT)\n+      else if (width > 2 * HOST_BITS_PER_WIDE_INT)\n \t/* We cannot represent this value as a constant.  */\n \tabort ();\n \n-      /* If MODE fits within HOST_BITS_PER_INT, always use a CONST_INT.\n+      /* If MODE fits within HOST_BITS_PER_WIDE_INT, always use a CONST_INT.\n \n \t ??? Strictly speaking, this is wrong if we create a CONST_INT\n \t for a large unsigned constant with the size of MODE being\n-\t HOST_BITS_PER_INT and later try to interpret that constant in a wider\n-\t mode.  In that case we will mis-interpret it as a negative number.\n+\t HOST_BITS_PER_WIDE_INT and later try to interpret that constant in a\n+\t wider mode.  In that case we will mis-interpret it as a negative\n+\t number.\n \n \t Unfortunately, the only alternative is to make a CONST_DOUBLE\n \t for any constant in any mode if it is an unsigned constant larger\n@@ -1276,13 +1278,13 @@ immed_double_const (i0, i1, mode)\n \t We have always been making CONST_INTs in this case, so nothing new\n \t is being broken.  */\n \n-      if (width <= HOST_BITS_PER_INT)\n+      if (width <= HOST_BITS_PER_WIDE_INT)\n \ti1 = (i0 < 0) ? ~0 : 0;\n \n       /* If this integer fits in one word, return a CONST_INT.  */\n       if ((i1 == 0 && i0 >= 0)\n \t  || (i1 == ~0 && i0 < 0))\n-\treturn gen_rtx (CONST_INT, VOIDmode, i0);\n+\treturn GEN_INT (i0);\n \n       /* We use VOIDmode for integers.  */\n       mode = VOIDmode;\n@@ -1345,7 +1347,7 @@ immed_real_const_1 (d, mode)\n   else if (REAL_VALUES_EQUAL (dconst1, d))\n     return CONST1_RTX (mode);\n \n-  if (sizeof u == 2 * sizeof (int))\n+  if (sizeof u == 2 * sizeof (HOST_WIDE_INT))\n     return immed_double_const (u.i[0], u.i[1], mode);\n \n   /* The rest of this function handles the case where\n@@ -2579,7 +2581,7 @@ output_constant (exp, size)\n \t     || TREE_CODE (exp) == NON_LVALUE_EXPR)\n \texp = TREE_OPERAND (exp, 0);\n \n-      if (! assemble_integer (expand_expr (exp, 0, VOIDmode,\n+      if (! assemble_integer (expand_expr (exp, NULL_RTX, VOIDmode,\n \t\t\t\t\t   EXPAND_INITIALIZER),\n \t\t\t      size, 0))\n \terror (\"initializer for integer value is too complicated\");\n@@ -2654,7 +2656,7 @@ output_constructor (exp, size)\n   int byte_buffer_in_use = 0;\n   register int byte;\n \n-  if (HOST_BITS_PER_INT < BITS_PER_UNIT)\n+  if (HOST_BITS_PER_WIDE_INT < BITS_PER_UNIT)\n     abort ();\n \n   if (TREE_CODE (TREE_TYPE (exp)) == RECORD_TYPE)\n@@ -2809,26 +2811,27 @@ output_constructor (exp, size)\n \t      shift = end_offset - next_offset - this_time;\n \t      /* Don't try to take a bunch of bits that cross\n \t\t the word boundary in the INTEGER_CST.  */\n-\t      if (shift < HOST_BITS_PER_INT\n-\t\t  && shift + this_time > HOST_BITS_PER_INT)\n+\t      if (shift < HOST_BITS_PER_WIDE_INT\n+\t\t  && shift + this_time > HOST_BITS_PER_WIDE_INT)\n \t\t{\n-\t\t  this_time -= (HOST_BITS_PER_INT - shift);\n-\t\t  shift = HOST_BITS_PER_INT;\n+\t\t  this_time -= (HOST_BITS_PER_WIDE_INT - shift);\n+\t\t  shift = HOST_BITS_PER_WIDE_INT;\n \t\t}\n \n \t      /* Now get the bits from the appropriate constant word.  */\n-\t      if (shift < HOST_BITS_PER_INT)\n+\t      if (shift < HOST_BITS_PER_WIDE_INT)\n \t\t{\n \t\t  value = TREE_INT_CST_LOW (val);\n \t\t}\n-\t      else if (shift < 2 * HOST_BITS_PER_INT)\n+\t      else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n \t\t{\n \t\t  value = TREE_INT_CST_HIGH (val);\n-\t\t  shift -= HOST_BITS_PER_INT;\n+\t\t  shift -= HOST_BITS_PER_WIDE_INT;\n \t\t}\n \t      else\n \t\tabort ();\n-\t      byte |= (((value >> shift) & ((1 << this_time) - 1))\n+\t      byte |= (((value >> shift)\n+\t\t\t& (((HOST_WIDE_INT) 1 << this_time) - 1))\n \t\t       << (BITS_PER_UNIT - this_time - next_bit));\n #else\n \t      /* On little-endian machines,\n@@ -2839,24 +2842,25 @@ output_constructor (exp, size)\n \t\t       - TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field)));\n \t      /* Don't try to take a bunch of bits that cross\n \t\t the word boundary in the INTEGER_CST.  */\n-\t      if (shift < HOST_BITS_PER_INT\n-\t\t  && shift + this_time > HOST_BITS_PER_INT)\n+\t      if (shift < HOST_BITS_PER_WIDE_INT\n+\t\t  && shift + this_time > HOST_BITS_PER_WIDE_INT)\n \t\t{\n-\t\t  this_time -= (HOST_BITS_PER_INT - shift);\n-\t\t  shift = HOST_BITS_PER_INT;\n+\t\t  this_time -= (HOST_BITS_PER_WIDE_INT - shift);\n+\t\t  shift = HOST_BITS_PER_WIDE_INT;\n \t\t}\n \n \t      /* Now get the bits from the appropriate constant word.  */\n \t      if (shift < HOST_BITS_PER_INT)\n \t\tvalue = TREE_INT_CST_LOW (val);\n-\t      else if (shift < 2 * HOST_BITS_PER_INT)\n+\t      else if (shift < 2 * HOST_BITS_PER_WIDE_INT)\n \t\t{\n \t\t  value = TREE_INT_CST_HIGH (val);\n-\t\t  shift -= HOST_BITS_PER_INT;\n+\t\t  shift -= HOST_BITS_PER_WIDE_INT;\n \t\t}\n \t      else\n \t\tabort ();\n-\t      byte |= ((value >> shift) & ((1 << this_time) - 1)) << next_bit;\n+\t      byte |= ((value >> shift)\n+\t\t       & (((HOST_WIDE_INT) 1 << this_time) - 1)) << next_bit;\n #endif\n \t      next_offset += this_time;\n \t      byte_buffer_in_use = 1;"}]}