{"sha": "14707c896a207606f13886d3b3251e8db1f3c9c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ3MDdjODk2YTIwNzYwNmYxMzg4NmQzYjMyNTFlOGRiMWYzYzljMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-13T07:30:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-13T07:30:47Z"}, "message": "openmp: Improve composite triangular loop lowering and expansion\n\nThis propagates needed values from the point where number of iterations\nis calculated on composite loops to the places where that information\nis needed to use the more efficient square root discovery to compute\nthe starting iterator values from the logical iteration number.\n\n2020-10-13  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-low.c (add_taskreg_looptemp_clauses): For triangular loops\n\twith non-constant number of iterations add another 4 _looptemp_\n\tclauses before the (optional) one for lastprivate.\n\t(lower_omp_for_lastprivate): Skip those clauses when looking for\n\tthe lastprivate clause.\n\t(lower_omp_for): For triangular loops with non-constant number of\n\titerations add another 4 _looptemp_ clauses.\n\t* omp-expand.c (expand_omp_for_init_counts): For triangular loops\n\twith non-constant number of iterations set counts[0],\n\tfd->first_inner_iterations, fd->factor and fd->adjn1 from the newly\n\tadded _looptemp_ clauses.\n\t(expand_omp_for_init_vars): Initialize the newly added _looptemp_\n\tclauses.\n\t(find_lastprivate_looptemp): New function.\n\t(expand_omp_for_static_nochunk, expand_omp_for_static_chunk,\n\texpand_omp_taskloop_for_outer): Use it instead of manually skipping\n\t_looptemp_ clauses.", "tree": {"sha": "ae58e04fa9797de1ec9a35349d0df94a776554d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae58e04fa9797de1ec9a35349d0df94a776554d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14707c896a207606f13886d3b3251e8db1f3c9c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14707c896a207606f13886d3b3251e8db1f3c9c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14707c896a207606f13886d3b3251e8db1f3c9c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14707c896a207606f13886d3b3251e8db1f3c9c0/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56cb815ba22dd2ec00fee7a38f0862bc21d1c2a9"}], "stats": {"total": 166, "additions": 124, "deletions": 42}, "files": [{"sha": "6583c88e2765b533aa4c26f42894a1ec6f86b313", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 69, "deletions": 33, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14707c896a207606f13886d3b3251e8db1f3c9c0/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14707c896a207606f13886d3b3251e8db1f3c9c0/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=14707c896a207606f13886d3b3251e8db1f3c9c0", "patch": "@@ -1790,6 +1790,23 @@ expand_omp_for_init_counts (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t  else\n \t    counts[0] = NULL_TREE;\n \t}\n+      if (fd->non_rect\n+\t  && fd->last_nonrect == fd->first_nonrect + 1\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (fd->loops[fd->last_nonrect].v)))\n+\t{\n+\t  tree c[4];\n+\t  for (i = 0; i < 4; i++)\n+\t    {\n+\t      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n+\t      gcc_assert (innerc);\n+\t      c[i] = OMP_CLAUSE_DECL (innerc);\n+\t    }\n+\t  counts[0] = c[0];\n+\t  fd->first_inner_iterations = c[1];\n+\t  fd->factor = c[2];\n+\t  fd->adjn1 = c[3];\n+\t}\n       return;\n     }\n \n@@ -2434,15 +2451,32 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t use it.  */\n       tree innerc = omp_find_clause (clauses, OMP_CLAUSE__LOOPTEMP_);\n       gcc_assert (innerc);\n-      for (i = 0; i < fd->collapse; i++)\n+      int count = 0;\n+      if (fd->non_rect\n+\t  && fd->last_nonrect == fd->first_nonrect + 1\n+\t  && !TYPE_UNSIGNED (TREE_TYPE (fd->loops[fd->last_nonrect].v)))\n+\tcount = 4;\n+      for (i = 0; i < fd->collapse + count; i++)\n \t{\n \t  innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n \t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n \t  gcc_assert (innerc);\n \t  if (i)\n \t    {\n \t      tree tem = OMP_CLAUSE_DECL (innerc);\n-\t      tree t = fold_convert (TREE_TYPE (tem), counts[i]);\n+\t      tree t;\n+\t      if (i < fd->collapse)\n+\t\tt = counts[i];\n+\t      else\n+\t\tswitch (i - fd->collapse)\n+\t\t  {\n+\t\t  case 0: t = counts[0]; break;\n+\t\t  case 1: t = fd->first_inner_iterations; break;\n+\t\t  case 2: t = fd->factor; break;\n+\t\t  case 3: t = fd->adjn1; break;\n+\t\t  default: gcc_unreachable ();\n+\t\t  }\n+\t      t = fold_convert (TREE_TYPE (tem), t);\n \t      t = force_gimple_operand_gsi (gsi, t, false, NULL_TREE,\n \t\t\t\t\t    false, GSI_CONTINUE_LINKING);\n \t      gassign *stmt = gimple_build_assign (tem, t);\n@@ -2478,10 +2512,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t  basic_block bb_triang = NULL, bb_triang_dom = NULL;\n \t  if (fd->first_nonrect + 1 == fd->last_nonrect\n \t      && (TREE_CODE (fd->loop.n2) == INTEGER_CST\n-\t\t  || (fd->first_inner_iterations\n-\t\t      /* For now.  Later add clauses to propagate the\n-\t\t\t values.  */\n-\t\t      && !gimple_omp_for_combined_into_p (fd->for_stmt)))\n+\t\t  || fd->first_inner_iterations)\n \t      && (optab_handler (sqrt_optab, TYPE_MODE (double_type_node))\n \t\t  != CODE_FOR_nothing))\n \t    {\n@@ -4641,6 +4672,35 @@ expand_omp_scantemp_alloc (tree clauses, tree ptr, unsigned HOST_WIDE_INT sz,\n     return ptr;\n }\n \n+/* Return the last _looptemp_ clause if one has been created for\n+   lastprivate on distribute parallel for{, simd} or taskloop.\n+   FD is the loop data and INNERC should be the second _looptemp_\n+   clause (the one holding the end of the range).\n+   This is followed by collapse - 1 _looptemp_ clauses for the\n+   counts[1] and up, and for triangular loops followed by 4\n+   further _looptemp_ clauses (one for counts[0], one first_inner_iterations,\n+   one factor and one adjn1).  After this there is optionally one\n+   _looptemp_ clause that this function returns.  */\n+\n+static tree\n+find_lastprivate_looptemp (struct omp_for_data *fd, tree innerc)\n+{\n+  gcc_assert (innerc);\n+  int count = fd->collapse - 1;\n+  if (fd->non_rect\n+      && fd->last_nonrect == fd->first_nonrect + 1\n+      && !TYPE_UNSIGNED (TREE_TYPE (fd->loops[fd->last_nonrect].v)))\n+    count += 4;\n+  for (int i = 0; i < count; i++)\n+    {\n+      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n+      gcc_assert (innerc);\n+    }\n+  return omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t  OMP_CLAUSE__LOOPTEMP_);\n+}\n+\n /* A subroutine of expand_omp_for.  Generate code for a parallel\n    loop with static schedule and no specified chunk size.  Given\n    parameters:\n@@ -5065,15 +5125,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n       if (fd->collapse > 1 && TREE_CODE (fd->loop.n2) != INTEGER_CST\n \t  && gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n \t{\n-\t  int i;\n-\t  for (i = 1; i < fd->collapse; i++)\n-\t    {\n-\t      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n-\t      gcc_assert (innerc);\n-\t    }\n-\t  innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n+\t  innerc = find_lastprivate_looptemp (fd, innerc);\n \t  if (innerc)\n \t    {\n \t      /* If needed (distribute parallel for with lastprivate),\n@@ -5790,15 +5842,7 @@ expand_omp_for_static_chunk (struct omp_region *region,\n       if (fd->collapse > 1 && TREE_CODE (fd->loop.n2) != INTEGER_CST\n \t  && gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_DISTRIBUTE)\n \t{\n-\t  int i;\n-\t  for (i = 1; i < fd->collapse; i++)\n-\t    {\n-\t      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n-\t      gcc_assert (innerc);\n-\t    }\n-\t  innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n+\t  innerc = find_lastprivate_looptemp (fd, innerc);\n \t  if (innerc)\n \t    {\n \t      /* If needed (distribute parallel for with lastprivate),\n@@ -7041,15 +7085,7 @@ expand_omp_taskloop_for_outer (struct omp_region *region,\n   tree endvar = OMP_CLAUSE_DECL (innerc);\n   if (fd->collapse > 1 && TREE_CODE (fd->loop.n2) != INTEGER_CST)\n     {\n-      gcc_assert (innerc);\n-      for (i = 1; i < fd->collapse; i++)\n-\t{\n-\t  innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n-\t  gcc_assert (innerc);\n-\t}\n-      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n+      innerc = find_lastprivate_looptemp (fd, innerc);\n       if (innerc)\n \t{\n \t  /* If needed (inner taskloop has lastprivate clause), propagate"}, {"sha": "6d0aa8daeb3f16567700bdae2bc1227350d3dce4", "filename": "gcc/omp-low.c", "status": "modified", "additions": 55, "deletions": 9, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14707c896a207606f13886d3b3251e8db1f3c9c0/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14707c896a207606f13886d3b3251e8db1f3c9c0/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=14707c896a207606f13886d3b3251e8db1f3c9c0", "patch": "@@ -1919,12 +1919,38 @@ add_taskreg_looptemp_clauses (enum gf_mask msk, gimple *stmt,\n \t     GIMPLE_OMP_FOR, add one more temporaries for the total number\n \t     of iterations (product of count1 ... countN-1).  */\n \t  if (omp_find_clause (gimple_omp_for_clauses (for_stmt),\n-\t\t\t       OMP_CLAUSE_LASTPRIVATE))\n-\t    count++;\n-\t  else if (msk == GF_OMP_FOR_KIND_FOR\n-\t\t   && omp_find_clause (gimple_omp_parallel_clauses (stmt),\n-\t\t\t\t       OMP_CLAUSE_LASTPRIVATE))\n-\t    count++;\n+\t\t\t       OMP_CLAUSE_LASTPRIVATE)\n+\t      || (msk == GF_OMP_FOR_KIND_FOR\n+\t\t  && omp_find_clause (gimple_omp_parallel_clauses (stmt),\n+\t\t\t\t      OMP_CLAUSE_LASTPRIVATE)))\n+\t    {\n+\t      tree temp = create_tmp_var (type);\n+\t      tree c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n+\t      insert_decl_map (&outer_ctx->cb, temp, temp);\n+\t      OMP_CLAUSE_DECL (c) = temp;\n+\t      OMP_CLAUSE_CHAIN (c) = gimple_omp_taskreg_clauses (stmt);\n+\t      gimple_omp_taskreg_set_clauses (stmt, c);\n+\t    }\n+\t  if (fd.non_rect\n+\t      && fd.last_nonrect == fd.first_nonrect + 1)\n+\t    if (tree v = gimple_omp_for_index (for_stmt, fd.last_nonrect))\n+\t      if (!TYPE_UNSIGNED (TREE_TYPE (v)))\n+\t\t{\n+\t\t  v = gimple_omp_for_index (for_stmt, fd.first_nonrect);\n+\t\t  tree type2 = TREE_TYPE (v);\n+\t\t  count++;\n+\t\t  for (i = 0; i < 3; i++)\n+\t\t    {\n+\t\t      tree temp = create_tmp_var (type2);\n+\t\t      tree c = build_omp_clause (UNKNOWN_LOCATION,\n+\t\t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n+\t\t      insert_decl_map (&outer_ctx->cb, temp, temp);\n+\t\t      OMP_CLAUSE_DECL (c) = temp;\n+\t\t      OMP_CLAUSE_CHAIN (c) = gimple_omp_taskreg_clauses (stmt);\n+\t\t      gimple_omp_taskreg_set_clauses (stmt, c);\n+\t\t    }\n+\t\t}\n \t}\n       for (i = 0; i < count; i++)\n \t{\n@@ -9530,7 +9556,13 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n \t  tree innerc = omp_find_clause (taskreg_clauses,\n \t\t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n \t  gcc_assert (innerc);\n-\t  for (i = 0; i < fd->collapse; i++)\n+\t  int count = fd->collapse;\n+\t  if (fd->non_rect\n+\t      && fd->last_nonrect == fd->first_nonrect + 1)\n+\t    if (tree v = gimple_omp_for_index (fd->for_stmt, fd->last_nonrect))\n+\t      if (!TYPE_UNSIGNED (TREE_TYPE (v)))\n+\t\tcount += 4;\n+\t  for (i = 0; i < count; i++)\n \t    {\n \t      innerc = omp_find_clause (OMP_CLAUSE_CHAIN (innerc),\n \t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n@@ -10453,20 +10485,34 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       if (fd.collapse > 1\n \t  && TREE_CODE (fd.loop.n2) != INTEGER_CST)\n \tcount += fd.collapse - 1;\n+      size_t count2 = 0;\n+      tree type2 = NULL_TREE;\n       bool taskreg_for\n \t= (gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_FOR\n \t   || gimple_omp_for_kind (stmt) == GF_OMP_FOR_KIND_TASKLOOP);\n       tree outerc = NULL, *pc = gimple_omp_for_clauses_ptr (stmt);\n       tree simtc = NULL;\n       tree clauses = *pc;\n+      if (fd.collapse > 1\n+\t  && fd.non_rect\n+\t  && fd.last_nonrect == fd.first_nonrect + 1\n+\t  && TREE_CODE (fd.loop.n2) != INTEGER_CST)\n+\tif (tree v = gimple_omp_for_index (stmt, fd.last_nonrect))\n+\t  if (!TYPE_UNSIGNED (TREE_TYPE (v)))\n+\t    {\n+\t      v = gimple_omp_for_index (stmt, fd.first_nonrect);\n+\t      type2 = TREE_TYPE (v);\n+\t      count++;\n+\t      count2 = 3;\n+\t    }\n       if (taskreg_for)\n \touterc\n \t  = omp_find_clause (gimple_omp_taskreg_clauses (ctx->outer->stmt),\n \t\t\t     OMP_CLAUSE__LOOPTEMP_);\n       if (ctx->simt_stmt)\n \tsimtc = omp_find_clause (gimple_omp_for_clauses (ctx->simt_stmt),\n \t\t\t\t OMP_CLAUSE__LOOPTEMP_);\n-      for (i = 0; i < count; i++)\n+      for (i = 0; i < count + count2; i++)\n \t{\n \t  tree temp;\n \t  if (taskreg_for)\n@@ -10485,7 +10531,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t      if (ctx->simt_stmt)\n \t\ttemp = OMP_CLAUSE_DECL (simtc);\n \t      else\n-\t\ttemp = create_tmp_var (type);\n+\t\ttemp = create_tmp_var (i >= count ? type2 : type);\n \t      insert_decl_map (&ctx->outer->cb, temp, temp);\n \t    }\n \t  *pc = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE__LOOPTEMP_);"}]}