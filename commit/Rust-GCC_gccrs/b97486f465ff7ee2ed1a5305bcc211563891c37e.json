{"sha": "b97486f465ff7ee2ed1a5305bcc211563891c37e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3NDg2ZjQ2NWZmN2VlMmVkMWE1MzA1YmNjMjExNTYzODkxYzM3ZQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-07-01T18:50:34Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2021-07-01T18:55:32Z"}, "message": "Add IEEE 128-bit fp conditional move on PowerPC.\n\nThis patch adds the support for power10 IEEE 128-bit floating point conditional\nmove and for automatically generating min/max.\n\nIn this patch, I simplified things compared to previous patches.  Instead of\nallowing any four of the modes to be used for the conditional move comparison\nand the move itself could use different modes, I restricted the conditional\nmove to just the same mode.  I.e. you can do:\n\n    _Float128 a, b, c, d, e, r;\n\n    r = (a == b) ? c : d;\n\nBut you can't do:\n\n    _Float128 c, d, r;\n    double a, b;\n\n    r = (a == b) ? c : d;\n\nor:\n\n    _Float128 a, b;\n    double c, d, r;\n\n    r = (a == b) ? c : d;\n\nThis eliminates a lot of the complexity of the code, because you don't have to\nworry about the sizes being different, and the IEEE 128-bit types being\nrestricted to Altivec registers, while the SF/DF modes can use any VSX\nregister.\n\nI did not modify the existing support that allowed conditional moves where\nSFmode operands are compared and DFmode operands are moved (and vice versa).\n\nI modified the test cases that I added to reflect this change.  I have also\nfixed the test for not equal to use '!=' instead of '=='.\n\n2021-07-01 Michael Meissner  <meissner@linux.ibm.com>\n\ngcc/\n\n\t* config/rs6000/rs6000.c (rs6000_maybe_emit_fp_cmove): Add IEEE\n\t128-bit floating point conditional move support.\n\t(have_compare_and_set_mask): Add IEEE 128-bit floating point\n\ttypes.\n\t* config/rs6000/rs6000.md (mov<mode>cc, IEEE128 iterator): New insn.\n\t(mov<mode>cc_p10, IEEE128 iterator): New insn.\n\t(mov<mode>cc_invert_p10, IEEE128 iterator): New insn.\n\t(fpmask<mode>, IEEE128 iterator): New insn.\n\t(xxsel<mode>, IEEE128 iterator): New insn.\n\ngcc/testsuite/\n\n\t* gcc.target/powerpc/float128-cmove.c: New test.\n\t* gcc.target/powerpc/float128-minmax-3.c: New test.", "tree": {"sha": "c79e89f59a5407cfad6854c8dbcd25665126106d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c79e89f59a5407cfad6854c8dbcd25665126106d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b97486f465ff7ee2ed1a5305bcc211563891c37e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b97486f465ff7ee2ed1a5305bcc211563891c37e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b97486f465ff7ee2ed1a5305bcc211563891c37e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b97486f465ff7ee2ed1a5305bcc211563891c37e/comments", "author": null, "committer": null, "parents": [{"sha": "f2ce64b53fa76a4c192fe51b2f6c5a863a3b1241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2ce64b53fa76a4c192fe51b2f6c5a863a3b1241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2ce64b53fa76a4c192fe51b2f6c5a863a3b1241"}], "stats": {"total": 211, "additions": 209, "deletions": 2}, "files": [{"sha": "9a5db63d0ef4e097f6316283f371bdf52ddf008f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b97486f465ff7ee2ed1a5305bcc211563891c37e", "patch": "@@ -15699,8 +15699,8 @@ rs6000_emit_vector_cond_expr (rtx dest, rtx op_true, rtx op_false,\n   return 1;\n }\n \n-/* Possibly emit the xsmaxcdp and xsmincdp instructions to emit a maximum or\n-   minimum with \"C\" semantics.\n+/* Possibly emit the xsmaxc{dp,qp} and xsminc{dp,qp} instructions to emit a\n+   maximum or minimum with \"C\" semantics.\n \n    Unless you use -ffast-math, you can't use these instructions to replace\n    conditions that implicitly reverse the condition because the comparison\n@@ -15776,6 +15776,7 @@ rs6000_maybe_emit_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   enum rtx_code code = GET_CODE (op);\n   rtx op0 = XEXP (op, 0);\n   rtx op1 = XEXP (op, 1);\n+  machine_mode compare_mode = GET_MODE (op0);\n   machine_mode result_mode = GET_MODE (dest);\n   rtx compare_rtx;\n   rtx cmove_rtx;\n@@ -15784,6 +15785,29 @@ rs6000_maybe_emit_fp_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   if (!can_create_pseudo_p ())\n     return 0;\n \n+  /* We allow the comparison to be either SFmode/DFmode and the true/false\n+     condition to be either SFmode/DFmode.  I.e. we allow:\n+\n+\tfloat a, b;\n+\tdouble c, d, r;\n+\n+\tr = (a == b) ? c : d;\n+\n+    and:\n+\n+\tdouble a, b;\n+\tfloat c, d, r;\n+\n+\tr = (a == b) ? c : d;\n+\n+    but we don't allow intermixing the IEEE 128-bit floating point types with\n+    the 32/64-bit scalar types.  */\n+\n+  if (!(compare_mode == result_mode\n+\t|| (compare_mode == SFmode && result_mode == DFmode)\n+\t|| (compare_mode == DFmode && result_mode == SFmode)))\n+    return false;\n+\n   switch (code)\n     {\n     case EQ:\n@@ -15836,6 +15860,10 @@ have_compare_and_set_mask (machine_mode mode)\n     case E_DFmode:\n       return TARGET_P9_MINMAX;\n \n+    case E_KFmode:\n+    case E_TFmode:\n+      return TARGET_POWER10 && TARGET_FLOAT128_HW && FLOAT128_IEEE_P (mode);\n+\n     default:\n       break;\n     }"}, {"sha": "e84d0311cc21b52aa8b0e61f232b5980aadadba5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b97486f465ff7ee2ed1a5305bcc211563891c37e", "patch": "@@ -5449,6 +5449,112 @@\n   \"xxsel %x0,%x4,%x3,%x1\"\n   [(set_attr \"type\" \"vecmove\")])\n \n+;; Support for ISA 3.1 IEEE 128-bit conditional move.  The mode used in the\n+;; comparison must be the same as used in the move.\n+(define_expand \"mov<mode>cc\"\n+   [(set (match_operand:IEEE128 0 \"gpc_reg_operand\")\n+\t (if_then_else:IEEE128 (match_operand 1 \"comparison_operator\")\n+\t\t\t       (match_operand:IEEE128 2 \"gpc_reg_operand\")\n+\t\t\t       (match_operand:IEEE128 3 \"gpc_reg_operand\")))]\n+  \"TARGET_POWER10 && TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+{\n+  if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_insn_and_split \"*mov<mode>cc_p10\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=&v,v\")\n+\t(if_then_else:IEEE128\n+\t (match_operator:CCFP 1 \"fpmask_comparison_operator\"\n+\t\t[(match_operand:IEEE128 2 \"altivec_register_operand\" \"v,v\")\n+\t\t (match_operand:IEEE128 3 \"altivec_register_operand\" \"v,v\")])\n+\t (match_operand:IEEE128 4 \"altivec_register_operand\" \"v,v\")\n+\t (match_operand:IEEE128 5 \"altivec_register_operand\" \"v,v\")))\n+   (clobber (match_scratch:V2DI 6 \"=0,&v\"))]\n+  \"TARGET_POWER10 && TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 6)\n+\t(if_then_else:V2DI (match_dup 1)\n+\t\t\t   (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+   (set (match_dup 0)\n+\t(if_then_else:IEEE128 (ne (match_dup 6)\n+\t\t\t\t  (match_dup 8))\n+\t\t\t      (match_dup 4)\n+\t\t\t      (match_dup 5)))]\n+{\n+  if (GET_CODE (operands[6]) == SCRATCH)\n+    operands[6] = gen_reg_rtx (V2DImode);\n+\n+  operands[7] = CONSTM1_RTX (V2DImode);\n+  operands[8] = CONST0_RTX (V2DImode);\n+}\n+ [(set_attr \"length\" \"8\")\n+  (set_attr \"type\" \"vecperm\")])\n+\n+;; Handle inverting the fpmask comparisons.\n+(define_insn_and_split \"*mov<mode>cc_invert_p10\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=&v,v\")\n+\t(if_then_else:IEEE128\n+\t (match_operator:CCFP 1 \"invert_fpmask_comparison_operator\"\n+\t\t[(match_operand:IEEE128 2 \"altivec_register_operand\" \"v,v\")\n+\t\t (match_operand:IEEE128 3 \"altivec_register_operand\" \"v,v\")])\n+\t (match_operand:IEEE128 4 \"altivec_register_operand\" \"v,v\")\n+\t (match_operand:IEEE128 5 \"altivec_register_operand\" \"v,v\")))\n+   (clobber (match_scratch:V2DI 6 \"=0,&v\"))]\n+  \"TARGET_POWER10 && TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 6)\n+\t(if_then_else:V2DI (match_dup 9)\n+\t\t\t   (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+   (set (match_dup 0)\n+\t(if_then_else:IEEE128 (ne (match_dup 6)\n+\t\t\t\t  (match_dup 8))\n+\t\t\t      (match_dup 5)\n+\t\t\t      (match_dup 4)))]\n+{\n+  rtx op1 = operands[1];\n+  enum rtx_code cond = reverse_condition_maybe_unordered (GET_CODE (op1));\n+\n+  if (GET_CODE (operands[6]) == SCRATCH)\n+    operands[6] = gen_reg_rtx (V2DImode);\n+\n+  operands[7] = CONSTM1_RTX (V2DImode);\n+  operands[8] = CONST0_RTX (V2DImode);\n+\n+  operands[9] = gen_rtx_fmt_ee (cond, CCFPmode, operands[2], operands[3]);\n+}\n+ [(set_attr \"length\" \"8\")\n+  (set_attr \"type\" \"vecperm\")])\n+\n+(define_insn \"*fpmask<mode>\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n+\t(if_then_else:V2DI\n+\t (match_operator:CCFP 1 \"fpmask_comparison_operator\"\n+\t\t[(match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")\n+\t\t (match_operand:IEEE128 3 \"altivec_register_operand\" \"v\")])\n+\t (match_operand:V2DI 4 \"all_ones_constant\" \"\")\n+\t (match_operand:V2DI 5 \"zero_constant\" \"\")))]\n+  \"TARGET_POWER10 && TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscmp%V1qp %0,%2,%3\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+(define_insn \"*xxsel<mode>\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(if_then_else:IEEE128\n+\t (ne (match_operand:V2DI 1 \"altivec_register_operand\" \"v\")\n+\t     (match_operand:V2DI 2 \"zero_constant\" \"\"))\n+\t (match_operand:IEEE128 3 \"altivec_register_operand\" \"v\")\n+\t (match_operand:IEEE128 4 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_POWER10 && TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xxsel %x0,%x4,%x3,%x1\"\n+  [(set_attr \"type\" \"vecmove\")])\n+\n \f\n ;; Conversions to and from floating-point.\n "}, {"sha": "2fae8dc23bcff401190da5e6f69066c0874834de", "filename": "gcc/testsuite/gcc.target/powerpc/float128-cmove.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-cmove.c?ref=b97486f465ff7ee2ed1a5305bcc211563891c37e", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target ppc_float128_hw } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#ifndef TYPE\n+#ifdef __LONG_DOUBLE_IEEE128__\n+#define TYPE long double\n+\n+#else\n+#define TYPE _Float128\n+#endif\n+#endif\n+\n+/* Verify that the ISA 3.1 (power10) IEEE 128-bit conditional move instructions\n+   are generated.  */\n+\n+TYPE\n+eq (TYPE a, TYPE b, TYPE c, TYPE d)\n+{\n+  return (a == b) ? c : d;\n+}\n+\n+TYPE\n+ne (TYPE a, TYPE b, TYPE c, TYPE d)\n+{\n+  return (a != b) ? c : d;\n+}\n+\n+TYPE\n+lt (TYPE a, TYPE b, TYPE c, TYPE d)\n+{\n+  return (a < b) ? c : d;\n+}\n+\n+TYPE\n+le (TYPE a, TYPE b, TYPE c, TYPE d)\n+{\n+  return (a <= b) ? c : d;\n+}\n+\n+TYPE\n+gt (TYPE a, TYPE b, TYPE c, TYPE d)\n+{\n+  return (a > b) ? c : d;\n+}\n+\n+TYPE\n+ge (TYPE a, TYPE b, TYPE c, TYPE d)\n+{\n+  return (a >= b) ? c : d;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mxscmpeqqp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mxscmpgeqp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mxscmpgtqp\\M} 2 } } */\n+/* { dg-final { scan-assembler-times {\\mxxsel\\M}     6 } } */\n+/* { dg-final { scan-assembler-not   {\\mxscmpuqp\\M}    } } */"}, {"sha": "6f7627c0f2a1b50fde1d51ea8c020bff633f629a", "filename": "gcc/testsuite/gcc.target/powerpc/float128-minmax-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-minmax-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b97486f465ff7ee2ed1a5305bcc211563891c37e/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-minmax-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-minmax-3.c?ref=b97486f465ff7ee2ed1a5305bcc211563891c37e", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-require-effective-target ppc_float128_hw } */\n+/* { dg-require-effective-target power10_ok } */\n+/* { dg-options \"-mdejagnu-cpu=power10 -O2\" } */\n+\n+#ifndef TYPE\n+#define TYPE _Float128\n+#endif\n+\n+/* Test that the fminf128/fmaxf128 functions generate if/then/else and not a\n+   call.  */\n+TYPE f128_min (TYPE a, TYPE b) { return (a < b) ? a : b; }\n+TYPE f128_max (TYPE a, TYPE b) { return (b > a) ? b : a; }\n+\n+/* { dg-final { scan-assembler {\\mxsmaxcqp\\M} } } */\n+/* { dg-final { scan-assembler {\\mxsmincqp\\M} } } */"}]}