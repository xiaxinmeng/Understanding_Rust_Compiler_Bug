{"sha": "674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc0OTMxZDJiN2JkODg4NmQxNDJmMzFlYTNkMDdhMmFiMmViNjA4YQ==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2019-01-17T12:37:57Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-01-17T12:37:57Z"}, "message": "Port testsuite to GCN\n\nThis collection of miscellaneous patches configures the testsuite to run on AMD\nGCN in a standalone (i.e. not offloading) configuration.  It assumes you have\nyour Dejagnu set up to run binaries via the gcn-run tool.\n\n2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n\t    Julian Brown  <julian@codesourcery.com>\n\t    Tom de Vries  <tom@codesourcery.com>\n\n\tgcc/\n\t* doc/sourcebuild.texi: Document dg-add-options sqrt_insn.\n\n\tgcc/testsuite/\n\t* gcc.dg/20020312-2.c: Add amdgcn support.\n\t* gcc.dg/Wno-frame-address.c: Disable on amdgcn.\n\t* gcc.dg/builtin-apply2.c: Likewise.\n\t* gcc.dg/torture/stackalign/builtin-apply-2.c: Likewise.\n\t* gcc.dg/gimplefe-28.c: Add dg-add-options for sqrt_insn.\n\t* gcc.dg/intermod-1.c: Add -mlocal-symbol-id on amdgcn.\n\t* gcc.dg/memcmp-1.c: Increase timeout factor.\n\t* gcc.dg/pr59605-2.c: Addd -DMAX_COPY=1025 on amdgcn.\n\t* gcc.dg/sibcall-10.c: xfail on amdgcn.\n\t* gcc.dg/sibcall-9.c: Likewise.\n\t* gcc.dg/tree-ssa/gen-vect-11c.c: Likewise.\n\t* gcc.dg/tree-ssa/pr84512.c: Likewise.\n\t* gcc.dg/tree-ssa/loop-1.c: Adjust expectations for amdgcn.\n\t* gfortran.dg/bind_c_array_params_2.f90: Likewise.\n\t* lib/target-supports.exp (check_effective_target_trampolines):\n\tConfigure amdgcn.\n\t(check_profiling_available): Likewise.\n\t(check_effective_target_global_constructor): Likewise.\n\t(check_effective_target_return_address): Likewise.\n\t(check_effective_target_fopenacc): Likewise.\n\t(check_effective_target_fopenmp): Likewise.\n\t(check_effective_target_vect_int): Likewise.\n\t(check_effective_target_vect_intfloat_cvt): Likewise.\n\t(check_effective_target_vect_uintfloat_cvt): Likewise.\n\t(check_effective_target_vect_floatint_cvt): Likewise.\n\t(check_effective_target_vect_floatuint_cvt): Likewise.\n\t(check_effective_target_vect_simd_clones): Likewise.\n\t(check_effective_target_vect_shift): Likewise.\n\t(check_effective_target_whole_vector_shift): Likewise.\n\t(check_effective_target_vect_bswap): Likewise.\n\t(check_effective_target_vect_shift_char): Likewise.\n\t(check_effective_target_vect_long): Likewise.\n\t(check_effective_target_vect_float): Likewise.\n\t(check_effective_target_vect_double): Likewise.\n\t(check_effective_target_vect_perm): Likewise.\n\t(check_effective_target_vect_perm_byte): Likewise.\n\t(check_effective_target_vect_perm_short): Likewise.\n\t(check_effective_target_vect_widen_mult_qi_to_hi): Likewise.\n\t(check_effective_target_vect_widen_mult_hi_to_si): Likewise.\n\t(check_effective_target_vect_widen_mult_qi_to_hi_pattern): Likewise.\n\t(check_effective_target_vect_widen_mult_hi_to_si_pattern): Likewise.\n\t(check_effective_target_vect_natural_alignment): Likewise.\n\t(check_effective_target_vect_fully_masked): Likewise.\n\t(check_effective_target_vect_element_align): Likewise.\n\t(check_effective_target_vect_masked_store): Likewise.\n\t(check_effective_target_vect_scatter_store): Likewise.\n\t(check_effective_target_vect_condition): Likewise.\n\t(check_effective_target_vect_cond_mixed): Likewise.\n\t(check_effective_target_vect_char_mult): Likewise.\n\t(check_effective_target_vect_short_mult): Likewise.\n\t(check_effective_target_vect_int_mult): Likewise.\n\t(check_effective_target_sqrt_insn): Likewise.\n\t(check_effective_target_vect_call_sqrtf): Likewise.\n\t(check_effective_target_vect_call_btrunc): Likewise.\n\t(check_effective_target_vect_call_btruncf): Likewise.\n\t(check_effective_target_vect_call_ceil): Likewise.\n\t(check_effective_target_vect_call_floorf): Likewise.\n\t(check_effective_target_lto): Likewise.\n\t(check_vect_support_and_set_flags): Likewise.\n\t(check_effective_target_vect_stridedN): Enable when fully masked is\n\tavailable.\n\t(add_options_for_sqrt_insn): New procedure.\n\n\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\nCo-Authored-By: Kwok Cheung Yeung <kcy@codesourcery.com>\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r268028", "tree": {"sha": "537ff82be09295f497cba2f514af26f98d8cf9f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/537ff82be09295f497cba2f514af26f98d8cf9f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b50002c4ef663659fcdf8c7b7bad2f3aaa710fea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b50002c4ef663659fcdf8c7b7bad2f3aaa710fea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b50002c4ef663659fcdf8c7b7bad2f3aaa710fea"}], "stats": {"total": 247, "additions": 199, "deletions": 48}, "files": [{"sha": "1ca3a271a9a0cae0d4b0e67238daec530af38dd5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,3 +1,10 @@\n+2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\t* doc/sourcebuild.texi: Document dg-add-options sqrt_insn.\n+\n 2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* doc/sourcebuild.texi: Document dg-require-effective-target"}, {"sha": "32a8f6aa12a71bc280cce0e5e22225dad6b11683", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -2522,6 +2522,10 @@ Add the flags needed to define macro STACK_SIZE and set it to the stack size\n limit associated with the @ref{stack_size_et,,@code{stack_size} effective\n target}.\n \n+@item sqrt_insn\n+Add the target-specific flags needed to enable hardware square root\n+instructions, if any.\n+\n @item tls\n Add the target-specific flags needed to use thread-local storage.\n @end table"}, {"sha": "12b1cbea6846d1916338c79e8e16c2837bc3fb48", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,3 +1,71 @@\n+2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\n+\t* gcc.dg/20020312-2.c: Add amdgcn support.\n+\t* gcc.dg/Wno-frame-address.c: Disable on amdgcn.\n+\t* gcc.dg/builtin-apply2.c: Likewise.\n+\t* gcc.dg/torture/stackalign/builtin-apply-2.c: Likewise.\n+\t* gcc.dg/gimplefe-28.c: Add dg-add-options for sqrt_insn.\n+\t* gcc.dg/intermod-1.c: Add -mlocal-symbol-id on amdgcn.\n+\t* gcc.dg/memcmp-1.c: Increase timeout factor.\n+\t* gcc.dg/pr59605-2.c: Addd -DMAX_COPY=1025 on amdgcn.\n+\t* gcc.dg/sibcall-10.c: xfail on amdgcn.\n+\t* gcc.dg/sibcall-9.c: Likewise.\n+\t* gcc.dg/tree-ssa/gen-vect-11c.c: Likewise.\n+\t* gcc.dg/tree-ssa/pr84512.c: Likewise.\n+\t* gcc.dg/tree-ssa/loop-1.c: Adjust expectations for amdgcn.\n+\t* gfortran.dg/bind_c_array_params_2.f90: Likewise.\n+\t* lib/target-supports.exp (check_effective_target_trampolines):\n+\tConfigure amdgcn.\n+\t(check_profiling_available): Likewise.\n+\t(check_effective_target_global_constructor): Likewise.\n+\t(check_effective_target_return_address): Likewise.\n+\t(check_effective_target_fopenacc): Likewise.\n+\t(check_effective_target_fopenmp): Likewise.\n+\t(check_effective_target_vect_int): Likewise.\n+\t(check_effective_target_vect_intfloat_cvt): Likewise.\n+\t(check_effective_target_vect_uintfloat_cvt): Likewise.\n+\t(check_effective_target_vect_floatint_cvt): Likewise.\n+\t(check_effective_target_vect_floatuint_cvt): Likewise.\n+\t(check_effective_target_vect_simd_clones): Likewise.\n+\t(check_effective_target_vect_shift): Likewise.\n+\t(check_effective_target_whole_vector_shift): Likewise.\n+\t(check_effective_target_vect_bswap): Likewise.\n+\t(check_effective_target_vect_shift_char): Likewise.\n+\t(check_effective_target_vect_long): Likewise.\n+\t(check_effective_target_vect_float): Likewise.\n+\t(check_effective_target_vect_double): Likewise.\n+\t(check_effective_target_vect_perm): Likewise.\n+\t(check_effective_target_vect_perm_byte): Likewise.\n+\t(check_effective_target_vect_perm_short): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi): Likewise.\n+\t(check_effective_target_vect_widen_mult_hi_to_si): Likewise.\n+\t(check_effective_target_vect_widen_mult_qi_to_hi_pattern): Likewise.\n+\t(check_effective_target_vect_widen_mult_hi_to_si_pattern): Likewise.\n+\t(check_effective_target_vect_natural_alignment): Likewise.\n+\t(check_effective_target_vect_fully_masked): Likewise.\n+\t(check_effective_target_vect_element_align): Likewise.\n+\t(check_effective_target_vect_masked_store): Likewise.\n+\t(check_effective_target_vect_scatter_store): Likewise.\n+\t(check_effective_target_vect_condition): Likewise.\n+\t(check_effective_target_vect_cond_mixed): Likewise.\n+\t(check_effective_target_vect_char_mult): Likewise.\n+\t(check_effective_target_vect_short_mult): Likewise.\n+\t(check_effective_target_vect_int_mult): Likewise.\n+\t(check_effective_target_sqrt_insn): Likewise.\n+\t(check_effective_target_vect_call_sqrtf): Likewise.\n+\t(check_effective_target_vect_call_btrunc): Likewise.\n+\t(check_effective_target_vect_call_btruncf): Likewise.\n+\t(check_effective_target_vect_call_ceil): Likewise.\n+\t(check_effective_target_vect_call_floorf): Likewise.\n+\t(check_effective_target_lto): Likewise.\n+\t(check_vect_support_and_set_flags): Likewise.\n+\t(check_effective_target_vect_stridedN): Enable when fully masked is\n+\tavailable.\n+\t(add_options_for_sqrt_insn): New procedure.\n+\n 2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* lib/file-format.exp (gcc_target_object_format): Handle AMD GCN."}, {"sha": "c584d35908ee30e01b80410c2b63387151fccf26", "filename": "gcc/testsuite/gcc.dg/20020312-2.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020312-2.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -119,6 +119,8 @@ extern void abort (void);\n # endif\n #elif defined (__or1k__)\n /* No pic register.  */\n+#elif defined (__AMDGCN__)\n+/* No pic register.  */\n #else\n # error \"Modify the test for your target.\"\n #endif"}, {"sha": "51f20b41742fc4ff185ab036062ad0af830d7348", "filename": "gcc/testsuite/gcc.dg/Wno-frame-address.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2FWno-frame-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2FWno-frame-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWno-frame-address.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-skip-if \"Cannot access arbitrary stack frames\" { arm*-*-* avr-*-* hppa*-*-* ia64-*-* visium-*-* csky-*-* msp430-*-* } } */\n+/* { dg-skip-if \"Cannot access arbitrary stack frames\" { arm*-*-* amdgpu-*-* avr-*-* hppa*-*-* ia64-*-* visium-*-* csky-*-* msp430-*-* } } */\n /* { dg-options \"-Werror\" } */\n /* { dg-additional-options \"-mbackchain\" { target { s390*-*-* } } } */\n "}, {"sha": "3eadc773a519601424afc6988a409e8e02d351dd", "filename": "gcc/testsuite/gcc.dg/builtin-apply2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-apply2.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-require-effective-target untyped_assembly } */\n-/* { dg-skip-if \"Variadic funcs have all args on stack. Normal funcs have args in registers.\" { \"avr-*-* nds32*-*-*\" } } */\n+/* { dg-skip-if \"Variadic funcs have all args on stack. Normal funcs have args in registers.\" { \"avr-*-* nds32*-*-* amdgcn-*-*\" } } */\n /* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs.\" { \"riscv*-*-* or1k*-*-* msp430-*-*\" } } */\n /* { dg-skip-if \"Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.\" { arm*-*-* && arm_hf_eabi } } */\n "}, {"sha": "d2f6b4c5c3ddbfba97d787d67c887eff8a30c1bb", "filename": "gcc/testsuite/gcc.dg/gimplefe-28.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-28.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,5 +1,6 @@\n /* { dg-do compile { target sqrt_insn } } */\n /* { dg-options \"-fgimple -O2\" } */\n+/* { dg-add-options sqrt_insn } */\n \n double __GIMPLE\n f1 (double x)"}, {"sha": "44a8ce071b5a38dd5c399b5347df7f813ad87357", "filename": "gcc/testsuite/gcc.dg/intermod-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fintermod-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fintermod-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fintermod-1.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,4 +1,5 @@\n /* { dg-do compile } */\n+/* { dg-additional-options \"-mlocal-symbol-id=\" { target amdgcn-*-* } } */\n /* { dg-final { scan-assembler-not {foo[1-9]\\.[0-9]} } } */\n \n /* Check that we don't get .0 suffixes on static variables when not using"}, {"sha": "ea837ca0f577db116413d95548c02e957c922e79", "filename": "gcc/testsuite/gcc.dg/memcmp-1.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fmemcmp-1.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -2,6 +2,7 @@\n /* { dg-do run } */\n /* { dg-options \"-O2\" } */\n /* { dg-require-effective-target ptr32plus } */\n+/* { dg-timeout-factor 2 } */\n \n #include <stdio.h>\n #include <stdlib.h>"}, {"sha": "95754815d7d76f7e866666b1ea73723ceb3ff7aa", "filename": "gcc/testsuite/gcc.dg/pr59605-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59605-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59605-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59605-2.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do run } */\n /* { dg-options \"-O2\" } */\n-/* { dg-additional-options \"-DMAX_COPY=1025\" { target { { simulator } || { nvptx-*-* } } } } */\n+/* { dg-additional-options \"-DMAX_COPY=1025\" { target { { simulator } || { nvptx-*-* amdgcn*-*-* } } } } */\n /* { dg-additional-options \"-minline-stringops-dynamically\" { target { i?86-*-* x86_64-*-* } } } */\n \n #include \"pr59605.c\""}, {"sha": "3d58036b468157305c90fa57ec71651b74e12d45", "filename": "gcc/testsuite/gcc.dg/sibcall-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-10.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail { { cris-*-* crisv32-*-* csky-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* msp430*-*-* nds32*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n+/* { dg-do run { xfail { { amdgcn*-*-* cris-*-* crisv32-*-* csky-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* msp430*-*-* nds32*-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n /* -mlongcall disables sibcall patterns.  */\n /* { dg-skip-if \"\" { powerpc*-*-* } { \"-mlongcall\" } { \"\" } } */\n /* -msave-restore disables sibcall patterns.  */"}, {"sha": "6df671da39dfbb3d08c63d0f00d371407b24b3b6", "filename": "gcc/testsuite/gcc.dg/sibcall-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-9.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail { { cris-*-* crisv32-*-* csky-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* msp430*-*-* nds32*-*-* nvptx-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n+/* { dg-do run { xfail { { amdgcn*-*-* cris-*-* crisv32-*-* csky-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* msp430*-*-* nds32*-*-* nvptx-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n /* -mlongcall disables sibcall patterns.  */\n /* { dg-skip-if \"\" { powerpc*-*-* } { \"-mlongcall\" } { \"\" } } */\n /* -msave-restore disables sibcall patterns.  */"}, {"sha": "1c6fe4fc5ff32a0054dbd83a95b1250927225d6b", "filename": "gcc/testsuite/gcc.dg/torture/stackalign/builtin-apply-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fstackalign%2Fbuiltin-apply-2.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -9,7 +9,7 @@\n /* arm_hf_eabi: Variadic funcs use Base AAPCS.  Normal funcs use VFP variant.\n    avr: Variadic funcs don't pass arguments in registers, while normal funcs\n         do.  */\n-/* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs\" { arm_hf_eabi || { avr-*-* riscv*-*-* or1k*-*-* msp430-*-* } } } */\n+/* { dg-skip-if \"Variadic funcs use different argument passing from normal funcs\" { arm_hf_eabi || { avr-*-* riscv*-*-* or1k*-*-* msp430-*-* amdgcn-*-* } } } */\n /* { dg-skip-if \"Variadic funcs have all args on stack. Normal funcs have args in registers.\" { nds32*-*-* } { v850*-*-* } } */\n /* { dg-require-effective-target untyped_assembly } */\n    "}, {"sha": "22ff44cf66da94ce97b993c6ef130f461b6eefc5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/gen-vect-11c.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fgen-vect-11c.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -39,4 +39,4 @@ int main ()\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { xfail amdgcn*-*-* } } } */"}, {"sha": "4b5a43457b0e84ffbf2cac6104da4db4bd454546", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-1.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-1.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -45,8 +45,10 @@ int xxx(void)\n    relaxation.  */\n /* CRIS and MSP430 keep the address in a register.  */\n /* m68k sometimes puts the address in a register, depending on CPU and PIC.  */\n+/* AMD GCN loads symbol addresses as hi/lo pairs, and then reuses that for\n+   each jump.  */\n \n-/* { dg-final { scan-assembler-times \"foo\" 5 { xfail hppa*-*-* ia64*-*-* sh*-*-* cris-*-* crisv32-*-* fido-*-* m68k-*-* i?86-*-mingw* i?86-*-cygwin* x86_64-*-mingw* visium-*-* nvptx*-*-* pdp11*-*-* msp430-*-* } } } */\n+/* { dg-final { scan-assembler-times \"foo\" 5 { xfail hppa*-*-* ia64*-*-* sh*-*-* cris-*-* crisv32-*-* fido-*-* m68k-*-* i?86-*-mingw* i?86-*-cygwin* x86_64-*-mingw* visium-*-* nvptx*-*-* pdp11*-*-* msp430-*-* amdgcn*-*-* } } } */\n /* { dg-final { scan-assembler-times \"foo,%r\" 5 { target hppa*-*-* } } } */\n /* { dg-final { scan-assembler-times \"= foo\"  5 { target ia64*-*-* } } } */\n /* { dg-final { scan-assembler-times \"call\\[ \\t\\]*_foo\" 5 { target i?86-*-mingw* i?86-*-cygwin* } } } */\n@@ -56,3 +58,5 @@ int xxx(void)\n /* { dg-final { scan-assembler-times \"\\[jb\\]sr\" 5 { target fido-*-* m68k-*-* pdp11-*-* } } } */\n /* { dg-final { scan-assembler-times \"bra *tr,r\\[1-9\\]*,r21\" 5 { target visium-*-* } } } */\n /* { dg-final { scan-assembler-times \"(?n)\\[ \\t\\]call\\[ \\t\\].*\\[ \\t\\]foo,\" 5 { target nvptx*-*-* } } } */\n+/* { dg-final { scan-assembler-times \"add_u32\\t\\[sv\\]\\[0-9\\]*, \\[sv\\]\\[0-9\\]*, foo@rel32@lo\" 1 { target { amdgcn*-*-* } } } } */\n+/* { dg-final { scan-assembler-times \"s_swappc_b64\" 5 { target { amdgcn*-*-* } } } } */"}, {"sha": "3975757d8447b84b1d7f2bf59770030100477a2d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr84512.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr84512.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr84512.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr84512.c?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -13,4 +13,4 @@ int foo()\n }\n \n /* Listed targets xfailed due to PR84958.  */\n-/* { dg-final { scan-tree-dump \"return 285;\" \"optimized\" { xfail { { alpha*-*-* nvptx*-*-* } || { sparc*-*-* && lp64 } } } } } */\n+/* { dg-final { scan-tree-dump \"return 285;\" \"optimized\" { xfail { { alpha*-*-* amdgcn*-*-* nvptx*-*-* } || { sparc*-*-* && lp64 } } } } } */"}, {"sha": "4528d13abd8982c2eea25923cb13a41cbdd116a3", "filename": "gcc/testsuite/gfortran.dg/bind_c_array_params_2.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbind_c_array_params_2.f90?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -16,8 +16,9 @@ end subroutine test\n call test(aa)\n end\n \n-! { dg-final { scan-assembler-times \"\\[ \\t\\]\\[$,_0-9\\]*myBindC\" 1 { target { ! { hppa*-*-* s390*-*-* *-*-cygwin* } } } } }\n+! { dg-final { scan-assembler-times \"\\[ \\t\\]\\[$,_0-9\\]*myBindC\" 1 { target { ! { hppa*-*-* s390*-*-* *-*-cygwin* amdgcn*-*-* } } } } }\n ! { dg-final { scan-assembler-times \"myBindC,%r2\" 1 { target { hppa*-*-* } } } }\n ! { dg-final { scan-assembler-times \"call\\tmyBindC\" 1 { target { *-*-cygwin* } } } }\n ! { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,myBindC\" 1 { target { s390*-*-* } } } }\n+! { dg-final { scan-assembler-times \"add_u32\\t\\[sv\\]\\[0-9\\]*, \\[sv\\]\\[0-9\\]*, myBindC@rel32@lo\" 1 { target { amdgcn*-*-* } } } }\n ! { dg-final { scan-tree-dump-times \"cfi_desc_to_gfc_desc \\\\\\(&parm\\\\.\" 1 \"original\" } }"}, {"sha": "c0df467e0175cd92c688cedebb97fd4ae87e985e", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 100, "deletions": 38, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/674931d2b7bd8886d142f31ea3d07a2ab2eb608a/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=674931d2b7bd8886d142f31ea3d07a2ab2eb608a", "patch": "@@ -659,6 +659,7 @@ proc check_profiling_available { test_what } {\n \t# missing other needed machinery.\n \tif {[istarget aarch64*-*-elf]\n \t     || [istarget am3*-*-linux*]\n+\t     || [istarget amdgcn-*-*]\n \t     || [istarget arm*-*-eabi*]\n \t     || [istarget arm*-*-elf]\n \t     || [istarget arm*-*-symbianelf*]\n@@ -784,6 +785,9 @@ proc check_effective_target_global_constructor {} {\n     if { [istarget nvptx-*-*] } {\n \treturn 0\n     }\n+    if { [istarget amdgcn-*-*] } {\n+\treturn 0\n+    }\n     return 1\n }\n \n@@ -804,6 +808,10 @@ proc check_effective_target_return_address {} {\n     if { [istarget nvptx-*-*] } {\n \treturn 0\n     }\n+    # It could be supported on amdgcn, but isn't yet.\n+    if { [istarget amdgcn*-*-*] } {\n+\treturn 0\n+    }\n     return 1\n }\n \n@@ -945,9 +953,10 @@ proc check_effective_target_fgraphite {} {\n # code, 0 otherwise.\n \n proc check_effective_target_fopenacc {} {\n-    # nvptx can be built with the device-side bits of openacc, but it\n+    # nvptx/amdgcn can be built with the device-side bits of openacc, but it\n     # does not make sense to test it as an openacc host.\n     if [istarget nvptx-*-*] { return 0 }\n+    if [istarget amdgcn-*-*] { return 0 }\n \n     return [check_no_compiler_messages fopenacc object {\n \tvoid foo (void) { }\n@@ -958,9 +967,10 @@ proc check_effective_target_fopenacc {} {\n # code, 0 otherwise.\n \n proc check_effective_target_fopenmp {} {\n-    # nvptx can be built with the device-side bits of libgomp, but it\n+    # nvptx/amdgcn can be built with the device-side bits of libgomp, but it\n     # does not make sense to test it as an openmp host.\n     if [istarget nvptx-*-*] { return 0 }\n+    if [istarget amdgcn-*-*] { return 0 }\n \n     return [check_no_compiler_messages fopenmp object {\n \tvoid foo (void) { }\n@@ -3122,6 +3132,7 @@ proc check_effective_target_vect_int { } {\n          [istarget i?86-*-*] || [istarget x86_64-*-*]\n          || ([istarget powerpc*-*-*]\n \t     && ![istarget powerpc-*-linux*paired*])\n+\t || [istarget amdgcn-*-*]\n \t || [istarget spu-*-*]\n \t || [istarget sparc*-*-*]\n \t || [istarget alpha*-*-*]\n@@ -3146,7 +3157,8 @@ proc check_effective_target_vect_intfloat_cvt { } {\n \t\t && ![istarget powerpc-*-linux*paired*])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) }}]\n+\t\t && [et-is-effective-target mips_msa])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports signed double->int conversion\n@@ -3210,7 +3222,8 @@ proc check_effective_target_vect_uintfloat_cvt { } {\n \t     || [istarget aarch64*-*-*]\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) }}]\n+\t\t && [et-is-effective-target mips_msa])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n \n@@ -3224,7 +3237,8 @@ proc check_effective_target_vect_floatint_cvt { } {\n \t\t && ![istarget powerpc-*-linux*paired*])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget mips*-*-*]\n-\t\t && [et-is-effective-target mips_msa]) }}]\n+\t\t && [et-is-effective-target mips_msa])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports unsigned float->int conversion\n@@ -3236,7 +3250,8 @@ proc check_effective_target_vect_floatuint_cvt { } {\n \t      && ![istarget powerpc-*-linux*paired*])\n \t    || [is-effective-target arm_neon]\n \t    || ([istarget mips*-*-*]\n-\t\t&& [et-is-effective-target mips_msa]) }}]\n+\t\t&& [et-is-effective-target mips_msa])\n+\t    || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if peeling for alignment might be profitable on the target\n@@ -3260,7 +3275,8 @@ proc check_effective_target_vect_simd_clones { } {\n     # be able to assemble avx512f.\n     return [check_cached_effective_target_indexed vect_simd_clones {\n       expr { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t      && [check_effective_target_avx512f]) }}]\n+\t      && [check_effective_target_avx512f])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if this is a AArch64 target supporting big endian\n@@ -5392,7 +5408,8 @@ proc check_effective_target_vect_shift { } {\n \t\t && ([et-is-effective-target mips_msa]\n \t\t     || [et-is-effective-target mips_loongson_mmi]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports hardware vector shift by register operation.\n@@ -5414,7 +5431,8 @@ proc check_effective_target_whole_vector_shift { } {\n \t || ([istarget mips*-*-*]\n \t     && [et-is-effective-target mips_loongson_mmi])\n \t || ([istarget s390*-*-*]\n-\t     && [check_effective_target_s390_vx]) } {\n+\t     && [check_effective_target_s390_vx])\n+\t || [istarget amdgcn-*-*] } {\n \tset answer 1\n     } else {\n \tset answer 0\n@@ -5428,7 +5446,9 @@ proc check_effective_target_whole_vector_shift { } {\n \n proc check_effective_target_vect_bswap { } {\n     return [check_cached_effective_target_indexed vect_bswap {\n-      expr { [istarget aarch64*-*-*] || [is-effective-target arm_neon] }}]\n+      expr { [istarget aarch64*-*-*]\n+\t     || [is-effective-target arm_neon]\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports hardware vector shift operation for char.\n@@ -5441,7 +5461,8 @@ proc check_effective_target_vect_shift_char { } {\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports hardware vectors of long, 0 otherwise.\n@@ -5459,7 +5480,8 @@ proc check_effective_target_vect_long { } {\n \t || ([istarget mips*-*-*]\n \t      && [et-is-effective-target mips_msa])\n \t || ([istarget s390*-*-*]\n-\t     && [check_effective_target_s390_vx]) } {\n+\t     && [check_effective_target_s390_vx])\n+\t || [istarget amdgcn-*-*] } {\n \tset answer 1\n     } else {\n \tset answer 0\n@@ -5487,7 +5509,8 @@ proc check_effective_target_vect_float { } {\n \t\t && [et-is-effective-target mips_msa])\n \t     || [is-effective-target arm_neon]\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vxe]) }}]\n+\t\t && [check_effective_target_s390_vxe])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports hardware vectors of float without\n@@ -5516,7 +5539,8 @@ proc check_effective_target_vect_double { } {\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx])} }]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*]} }]\n }\n \n # Return 1 if the target supports conditional addition, subtraction,\n@@ -5591,7 +5615,8 @@ proc check_effective_target_vect_perm { } {\n \t\t && ([et-is-effective-target mpaired_single]\n \t\t     || [et-is-effective-target mips_msa]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if, for some VF:\n@@ -5684,7 +5709,8 @@ proc check_effective_target_vect_perm_byte { } {\n \t     || ([istarget mips-*.*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports SLP permutation of 3 vectors when each\n@@ -5713,7 +5739,8 @@ proc check_effective_target_vect_perm_short { } {\n \t     || ([istarget mips*-*-*]\n \t\t  && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports SLP permutation of 3 vectors when each\n@@ -5805,7 +5832,8 @@ proc check_effective_target_vect_widen_mult_qi_to_hi { } {\n \t\t      && ![check_effective_target_aarch64_sve])\n \t\t  || [is-effective-target arm_neon]\n \t\t  || ([istarget s390*-*-*]\n-\t\t      && [check_effective_target_s390_vx])) }}]\n+\t\t      && [check_effective_target_s390_vx])) \n+\t      || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -5829,7 +5857,8 @@ proc check_effective_target_vect_widen_mult_hi_to_si { } {\n \t\t || [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t\t || [is-effective-target arm_neon]\n \t\t || ([istarget s390*-*-*]\n-\t\t     && [check_effective_target_s390_vx])) }}]\n+\t\t     && [check_effective_target_s390_vx]))\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -5843,7 +5872,8 @@ proc check_effective_target_vect_widen_mult_qi_to_hi_pattern { } {\n              || ([is-effective-target arm_neon]\n \t\t && [check_effective_target_arm_little_endian])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -5860,7 +5890,8 @@ proc check_effective_target_vect_widen_mult_hi_to_si_pattern { } {\n \t     || ([is-effective-target arm_neon]\n \t\t && [check_effective_target_arm_little_endian])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target plus current options supports a vector\n@@ -6104,7 +6135,8 @@ proc check_effective_target_vect_natural_alignment { } {\n     set et_vect_natural_alignment 1\n     if { [check_effective_target_arm_eabi]\n \t || [istarget nvptx-*-*]\n-\t || [istarget s390*-*-*] } {\n+\t || [istarget s390*-*-*]\n+\t || [istarget amdgcn-*-*] } {\n \tset et_vect_natural_alignment 0\n     }\n     verbose \"check_effective_target_vect_natural_alignment:\\\n@@ -6115,7 +6147,8 @@ proc check_effective_target_vect_natural_alignment { } {\n # Return true if fully-masked loops are supported.\n \n proc check_effective_target_vect_fully_masked { } {\n-    return [check_effective_target_aarch64_sve]\n+    return [expr { [check_effective_target_aarch64_sve]\n+\t           || [istarget amdgcn*-*-*] }]\n }\n \n # Return 1 if the target doesn't prefer any alignment beyond element\n@@ -6167,7 +6200,8 @@ proc check_effective_target_vect_element_align { } {\n     return [check_cached_effective_target_indexed vect_element_align {\n       expr { ([istarget arm*-*-*]\n \t      && ![check_effective_target_arm_vect_no_misalign])\n-\t     || [check_effective_target_vect_hw_misalign] }}]\n+\t     || [check_effective_target_vect_hw_misalign]\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if we expect to see unaligned accesses in at least some\n@@ -6192,13 +6226,15 @@ proc check_effective_target_vect_load_lanes { } {\n # Return 1 if the target supports vector masked stores.\n \n proc check_effective_target_vect_masked_store { } {\n-    return [check_effective_target_aarch64_sve]\n+    return [expr { [check_effective_target_aarch64_sve]\n+\t\t   || [istarget amdgcn*-*-*] }]\n }\n \n # Return 1 if the target supports vector scatter stores.\n \n proc check_effective_target_vect_scatter_store { } {\n-    return [check_effective_target_aarch64_sve]\n+    return [expr { [check_effective_target_aarch64_sve]\n+\t\t   || [istarget amdgcn*-*-*] }]\n }\n \n # Return 1 if the target supports vector conditional operations, 0 otherwise.\n@@ -6215,7 +6251,8 @@ proc check_effective_target_vect_condition { } {\n \t     || ([istarget arm*-*-*]\n \t\t && [check_effective_target_arm_neon_ok])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector conditional operations where\n@@ -6229,7 +6266,8 @@ proc check_effective_target_vect_cond_mixed { } {\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector char multiplication, 0 otherwise.\n@@ -6244,7 +6282,8 @@ proc check_effective_target_vect_char_mult { } {\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector short multiplication, 0 otherwise.\n@@ -6261,7 +6300,8 @@ proc check_effective_target_vect_short_mult { } {\n \t\t && ([et-is-effective-target mips_msa]\n \t\t     || [et-is-effective-target mips_loongson_mmi]))\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector int multiplication, 0 otherwise.\n@@ -6277,7 +6317,8 @@ proc check_effective_target_vect_int_mult { } {\n \t\t && [et-is-effective-target mips_msa])\n \t     || [check_effective_target_arm32]\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports 64 bit hardware vector\n@@ -6352,6 +6393,9 @@ foreach N {2 3 4 8} {\n \t\t      || [istarget aarch64*-*-*]) && N >= 2 && N <= 4 } {\n \t\t    return 1\n \t\t}\n+\t\tif [check_effective_target_vect_fully_masked] {\n+\t\t    return 1\n+\t\t}\n \t\treturn 0\n \t    }]\n \t}\n@@ -6419,7 +6463,17 @@ proc check_effective_target_sqrt_insn { } {\n \t     || [istarget aarch64*-*-*]\n \t     || ([istarget arm*-*-*] && [check_effective_target_arm_vfp_ok])\n \t     || ([istarget s390*-*-*]\n-\t\t && [check_effective_target_s390_vx]) }}]\n+\t\t && [check_effective_target_s390_vx])\n+\t     || [istarget amdgcn-*-*] }}]\n+}\n+\n+# Return any additional options to enable square root intructions.\n+\n+proc add_options_for_sqrt_insn { flags } {\n+    if { [istarget amdgcn*-*-*] } {\n+\treturn \"$flags -ffast-math\"\n+    }\n+    return $flags\n }\n \n # Return 1 if the target supports vector sqrtf calls.\n@@ -6438,7 +6492,8 @@ proc check_effective_target_vect_call_sqrtf { } {\n proc check_effective_target_vect_call_lrint { } {\n     set et_vect_call_lrint 0\n     if { (([istarget i?86-*-*] || [istarget x86_64-*-*])\n-\t  && [check_effective_target_ilp32]) } {\n+\t  && [check_effective_target_ilp32])\n+\t || [istarget amdgcn-*-*] } {\n \tset et_vect_call_lrint 1\n     }\n \n@@ -6450,21 +6505,24 @@ proc check_effective_target_vect_call_lrint { } {\n \n proc check_effective_target_vect_call_btrunc { } {\n     return [check_cached_effective_target_indexed vect_call_btrunc {\n-      expr { [istarget aarch64*-*-*] }}]\n+      expr { [istarget aarch64*-*-*]\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector btruncf calls.\n \n proc check_effective_target_vect_call_btruncf { } {\n     return [check_cached_effective_target_indexed vect_call_btruncf {\n-      expr { [istarget aarch64*-*-*] }}]\n+      expr { [istarget aarch64*-*-*]\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector ceil calls.\n \n proc check_effective_target_vect_call_ceil { } {\n     return [check_cached_effective_target_indexed vect_call_ceil {\n-      expr { [istarget aarch64*-*-*] }}]\n+      expr { [istarget aarch64*-*-*]\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector ceilf calls.\n@@ -6485,7 +6543,8 @@ proc check_effective_target_vect_call_floor { } {\n \n proc check_effective_target_vect_call_floorf { } {\n     return [check_cached_effective_target_indexed vect_call_floorf {\n-      expr { [istarget aarch64*-*-*] }}]\n+      expr { [istarget aarch64*-*-*]\n+\t     || [istarget amdgcn-*-*] }}]\n }\n \n # Return 1 if the target supports vector lceil calls.\n@@ -8032,7 +8091,8 @@ proc check_effective_target_gld { } {\n # (LTO) support.\n \n proc check_effective_target_lto { } {\n-    if { [istarget nvptx-*-*] } {\n+    if { [istarget nvptx-*-*]\n+\t || [istarget amdgcn-*-*] } {\n \treturn 0;\n     }\n     return [check_no_compiler_messages lto object {\n@@ -8362,6 +8422,8 @@ proc check_vect_support_and_set_flags { } {\n \t    lappend DEFAULT_VECTCFLAGS \"-march=z14\" \"-mzarch\"\n             set dg-do-what-default compile\n         }\n+    } elseif [istarget amdgcn-*-*] {\n+        set dg-do-what-default run\n     } else {\n         return 0\n     }"}]}