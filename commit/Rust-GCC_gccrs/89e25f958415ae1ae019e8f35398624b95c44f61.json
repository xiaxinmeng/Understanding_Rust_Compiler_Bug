{"sha": "89e25f958415ae1ae019e8f35398624b95c44f61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllMjVmOTU4NDE1YWUxYWUwMTllOGYzNTM5ODYyNGI5NWM0NGY2MQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-07T23:51:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-07T23:51:16Z"}, "message": "dwarf2out: Emit NOTE_INSN_CFI_* both with and without cfi-asm.\n\nThis patch is essentially Bernd's 006-cfilabel patch, updated\nfor all the other changes to dwarf2out.\n\nThe patch reduces the difference between the cfi-asm and non-cfi-asm\ncode paths.  We now emit the CFI notes in all cases.  Later, after we're\ndone producing the CFI insns we need, another pass over the rtl adds\nthe necessary labels and set_loc/advance_loc CFIs.  One consequence of\nthis is that def_cfa_1 can no longer use lookup_cfa, so it just compares\nto an old_cfa variable instead.\n\nThe major change since Bernd's patch is that all the target-specific\nchanges are no longer necessary.\n\n        * dwarf2cfi.c (add_cfi): Remove.\n        (dwarf2out_cfi_label): Remove force argument.  Only generate the\n        label name.\n        (add_fde_cfi): Simplify the different code paths.\n        (add_cie_cfi): New.\n        (old_cfa, old_cfa_remember): New.\n        (def_cfa_1, reg_save): Remove label, add for_cie parameter.\n        (last_reg_save_label): Remove.\n        (dwarf2out_args_size, dwarf2out_stack_adjust, queue_reg_save,\n        dwarf2out_frame_debug_def_cfa, dwarf2out_frame_debug_adjust_cfa,\n        dwarf2out_frame_debug_cfa_offset, dwarf2out_frame_debug_cfa_register,\n        dwarf2out_frame_debug_cfa_expression,\n        dwarf2out_frame_debug_cfa_restore,\n        dwarf2out_frame_debug_cfa_window_save,\n        dwarf2out_frame_debug_expr): Remove label parameter.\n        (cfi_label_required_p, add_cfis_to_fde): New.\n        (dwarf2out_frame_debug_after_prologue): New.\n        (dwarf2cfi_frame_init): Initialize old_cfa.\n        (dwarf2out_frame_debug_restore_state): Likewise.\n        * dwarf2out.c (dwarf2out_emit_cfi): Only do output for cfi_asm.\n        (dwarf2out_switch_text_section): Don't clear dw_fde_current_label here.\n        * final.c (final_start_function): Call\n        dwarf2out_frame_debug_after_prologue.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r176017", "tree": {"sha": "073e65e29ad5e49a203ca0e4f8c6150941d02102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/073e65e29ad5e49a203ca0e4f8c6150941d02102"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e25f958415ae1ae019e8f35398624b95c44f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e25f958415ae1ae019e8f35398624b95c44f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e25f958415ae1ae019e8f35398624b95c44f61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e25f958415ae1ae019e8f35398624b95c44f61/comments", "author": null, "committer": null, "parents": [{"sha": "bc5612ed5640eb8e98e9f50061db7d2325113eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5612ed5640eb8e98e9f50061db7d2325113eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5612ed5640eb8e98e9f50061db7d2325113eef"}], "stats": {"total": 470, "additions": 241, "deletions": 229}, "files": [{"sha": "4a3c7e19b12cb55967188e34a684914684c6a881", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89e25f958415ae1ae019e8f35398624b95c44f61", "patch": "@@ -1,3 +1,30 @@\n+2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (add_cfi): Remove.\n+\t(dwarf2out_cfi_label): Remove force argument.  Only generate the\n+\tlabel name.\n+\t(add_fde_cfi): Simplify the different code paths.\n+\t(add_cie_cfi): New.\n+\t(old_cfa, old_cfa_remember): New.\n+\t(def_cfa_1, reg_save): Remove label, add for_cie parameter.\n+\t(last_reg_save_label): Remove.\n+\t(dwarf2out_args_size, dwarf2out_stack_adjust, queue_reg_save,\n+\tdwarf2out_frame_debug_def_cfa, dwarf2out_frame_debug_adjust_cfa,\n+\tdwarf2out_frame_debug_cfa_offset, dwarf2out_frame_debug_cfa_register,\n+\tdwarf2out_frame_debug_cfa_expression,\n+\tdwarf2out_frame_debug_cfa_restore,\n+\tdwarf2out_frame_debug_cfa_window_save,\n+\tdwarf2out_frame_debug_expr): Remove label parameter.\n+\t(cfi_label_required_p, add_cfis_to_fde): New.\n+\t(dwarf2out_frame_debug_after_prologue): New.\n+\t(dwarf2cfi_frame_init): Initialize old_cfa.\n+\t(dwarf2out_frame_debug_restore_state): Likewise.\n+\t* dwarf2out.c (dwarf2out_emit_cfi): Only do output for cfi_asm.\n+\t(dwarf2out_switch_text_section): Don't clear dw_fde_current_label here.\n+\t* final.c (final_start_function): Call\n+\tdwarf2out_frame_debug_after_prologue.\n+\n 2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n \t    Richard Henderson  <rth@redhat.com>\n "}, {"sha": "cd22e53fe3f1743696f118834627cf0a71253056", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 206, "deletions": 224, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=89e25f958415ae1ae019e8f35398624b95c44f61", "patch": "@@ -257,74 +257,24 @@ new_cfi (void)\n   return cfi;\n }\n \n-/* Add a Call Frame Instruction to list of instructions.  */\n-\n-static inline void\n-add_cfi (cfi_vec *vec, dw_cfi_ref cfi)\n-{\n-  dw_fde_ref fde = current_fde ();\n-\n-  /* When DRAP is used, CFA is defined with an expression.  Redefine\n-     CFA may lead to a different CFA value.   */\n-  /* ??? Of course, this heuristic fails when we're annotating epilogues,\n-     because of course we'll always want to redefine the CFA back to the\n-     stack pointer on the way out.  Where should we move this check?  */\n-  if (0 && fde && fde->drap_reg != INVALID_REGNUM)\n-    switch (cfi->dw_cfi_opc)\n-      {\n-      case DW_CFA_def_cfa_register:\n-      case DW_CFA_def_cfa_offset:\n-      case DW_CFA_def_cfa_offset_sf:\n-      case DW_CFA_def_cfa:\n-      case DW_CFA_def_cfa_sf:\n-\tgcc_unreachable ();\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  VEC_safe_push (dw_cfi_ref, gc, *vec, cfi);\n-}\n-\n-/* Generate a new label for the CFI info to refer to.  FORCE is true\n-   if a label needs to be output even when using .cfi_* directives.  */\n+/* Generate a new label for the CFI info to refer to.  */\n \n static char *\n-dwarf2out_cfi_label (bool force)\n+dwarf2out_cfi_label (void)\n {\n-  static char label[20];\n+  int num = dwarf2out_cfi_label_num++;\n+  char label[20];\n \n-  if (!force && dwarf2out_do_cfi_asm ())\n-    {\n-      /* In this case, we will be emitting the asm directive instead of\n-\t the label, so just return a placeholder to keep the rest of the\n-\t interfaces happy.  */\n-      strcpy (label, \"<do not output>\");\n-    }\n-  else\n-    {\n-      int num = dwarf2out_cfi_label_num++;\n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", num);\n-      cfi_insn = emit_note_after (NOTE_INSN_CFI_LABEL, cfi_insn);\n-      NOTE_LABEL_NUMBER (cfi_insn) = num;\n-    }\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"LCFI\", num);\n \n-  return label;\n+  return xstrdup (label);\n }\n \n-/* Add CFI to the current fde at the PC value indicated by LABEL if specified,\n-   or to the CIE if LABEL is NULL.  */\n+/* Add CFI to the current fde.  */\n \n static void\n-add_fde_cfi (const char *label, dw_cfi_ref cfi)\n+add_fde_cfi (dw_cfi_ref cfi)\n {\n-  cfi_vec *vec;\n-\n-  if (cie_cfi_vec == NULL)\n-    cie_cfi_vec = VEC_alloc (dw_cfi_ref, gc, 20);\n-\n-  vec = &cie_cfi_vec;\n-\n   if (emit_cfa_remember)\n     {\n       dw_cfi_ref cfi_remember;\n@@ -333,110 +283,27 @@ add_fde_cfi (const char *label, dw_cfi_ref cfi)\n       emit_cfa_remember = false;\n       cfi_remember = new_cfi ();\n       cfi_remember->dw_cfi_opc = DW_CFA_remember_state;\n-      add_fde_cfi (label, cfi_remember);\n+      add_fde_cfi (cfi_remember);\n     }\n \n-  if (dwarf2out_do_cfi_asm ())\n+  any_cfis_emitted = true;\n+  if (cfi_insn != NULL)\n     {\n-      if (label)\n-\t{\n-\t  dw_fde_ref fde = current_fde ();\n-\n-\t  gcc_assert (fde != NULL);\n-\n-\t  /* We still have to add the cfi to the list so that lookup_cfa\n-\t     works later on.  When -g2 and above we even need to force\n-\t     emitting of CFI labels and add to list a DW_CFA_set_loc for\n-\t     convert_cfa_to_fb_loc_list purposes.  If we're generating\n-\t     DWARF3 output we use DW_OP_call_frame_cfa and so don't use\n-\t     convert_cfa_to_fb_loc_list.  */\n-\t  if (dwarf_version == 2\n-\t      && debug_info_level > DINFO_LEVEL_TERSE\n-\t      && (write_symbols == DWARF2_DEBUG\n-\t\t  || write_symbols == VMS_AND_DWARF2_DEBUG))\n-\t    {\n-\t      switch (cfi->dw_cfi_opc)\n-\t\t{\n-\t\tcase DW_CFA_def_cfa_offset:\n-\t\tcase DW_CFA_def_cfa_offset_sf:\n-\t\tcase DW_CFA_def_cfa_register:\n-\t\tcase DW_CFA_def_cfa:\n-\t\tcase DW_CFA_def_cfa_sf:\n-\t\tcase DW_CFA_def_cfa_expression:\n-\t\tcase DW_CFA_restore_state:\n-\t\t  if (*label == 0 || strcmp (label, \"<do not output>\") == 0)\n-\t\t    label = dwarf2out_cfi_label (true);\n-\n-\t\t  if (fde->dw_fde_current_label == NULL\n-\t\t      || strcmp (label, fde->dw_fde_current_label) != 0)\n-\t\t    {\n-\t\t      dw_cfi_ref xcfi;\n-\n-\t\t      label = xstrdup (label);\n-\n-\t\t      /* Set the location counter to the new label.  */\n-\t\t      xcfi = new_cfi ();\n-\t\t      /* It doesn't metter whether DW_CFA_set_loc\n-\t\t         or DW_CFA_advance_loc4 is added here, those aren't\n-\t\t         emitted into assembly, only looked up by\n-\t\t         convert_cfa_to_fb_loc_list.  */\n-\t\t      xcfi->dw_cfi_opc = DW_CFA_set_loc;\n-\t\t      xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n-\t\t      add_cfi (&fde->dw_fde_cfi, xcfi);\n-\t\t      fde->dw_fde_current_label = label;\n-\t\t    }\n-\t\t  break;\n-\t\tdefault:\n-\t\t  break;\n-\t        }\n-\t    }\n-\n-\t  cfi_insn = emit_note_after (NOTE_INSN_CFI, cfi_insn);\n-\t  NOTE_CFI (cfi_insn) = cfi;\n-\n-\t  vec = &fde->dw_fde_cfi;\n-\t  any_cfis_emitted = true;\n-\t}\n-      /* ??? If this is a CFI for the CIE, we don't emit.  This\n-\t assumes that the standard CIE contents that the assembler\n-\t uses matches the standard CIE contents that the compiler\n-\t uses.  This is probably a bad assumption.  I'm not quite\n-\t sure how to address this for now.  */\n+      cfi_insn = emit_note_after (NOTE_INSN_CFI, cfi_insn);\n+      NOTE_CFI (cfi_insn) = cfi;\n     }\n-  else if (label)\n+  else\n     {\n       dw_fde_ref fde = current_fde ();\n-\n-      gcc_assert (fde != NULL);\n-\n-      if (*label == 0)\n-\tlabel = dwarf2out_cfi_label (false);\n-\n-      if (fde->dw_fde_current_label == NULL\n-\t  || strcmp (label, fde->dw_fde_current_label) != 0)\n-\t{\n-\t  dw_cfi_ref xcfi;\n-\n-\t  label = xstrdup (label);\n-\n-\t  /* Set the location counter to the new label.  */\n-\t  xcfi = new_cfi ();\n-\t  /* If we have a current label, advance from there, otherwise\n-\t     set the location directly using set_loc.  */\n-\t  xcfi->dw_cfi_opc = fde->dw_fde_current_label\n-\t\t\t     ? DW_CFA_advance_loc4\n-\t\t\t     : DW_CFA_set_loc;\n-\t  xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n-\t  add_cfi (&fde->dw_fde_cfi, xcfi);\n-\n-\t  fde->dw_fde_current_label = label;\n-\t}\n-\n-      vec = &fde->dw_fde_cfi;\n-      any_cfis_emitted = true;\n+      VEC_safe_push (dw_cfi_ref, gc, fde->dw_fde_cfi, cfi);\n+      dwarf2out_emit_cfi (cfi);\n     }\n+}\n \n-  add_cfi (vec, cfi);\n+static void\n+add_cie_cfi (dw_cfi_ref cfi)\n+{\n+  VEC_safe_push (dw_cfi_ref, gc, cie_cfi_vec, cfi);\n }\n \n /* This function fills in aa dw_cfa_location structure from a dwarf location\n@@ -610,13 +477,19 @@ lookup_cfa (dw_cfa_location *loc)\n /* The current rule for calculating the DWARF2 canonical frame address.  */\n static dw_cfa_location cfa;\n \n+/* A copy of the CFA, for comparison purposes.  */\n+static dw_cfa_location old_cfa;\n+\n /* The register used for saving registers to the stack, and its offset\n    from the CFA.  */\n static dw_cfa_location cfa_store;\n \n /* The current save location around an epilogue.  */\n static dw_cfa_location cfa_remember;\n \n+/* Like cfa_remember, but a copy of old_cfa.  */\n+static dw_cfa_location old_cfa_remember;\n+\n /* The running total of the size of arguments pushed onto the stack.  */\n static HOST_WIDE_INT args_size;\n \n@@ -639,10 +512,10 @@ cfa_equal_p (const dw_cfa_location *loc1, const dw_cfa_location *loc2)\n    the dw_cfa_location structure.  */\n \n static void\n-def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n+def_cfa_1 (bool for_cie, dw_cfa_location *loc_p)\n {\n   dw_cfi_ref cfi;\n-  dw_cfa_location old_cfa, loc;\n+  dw_cfa_location loc;\n \n   cfa = *loc_p;\n   loc = *loc_p;\n@@ -651,7 +524,6 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n     cfa_store.offset = loc.offset;\n \n   loc.reg = DWARF_FRAME_REGNUM (loc.reg);\n-  lookup_cfa (&old_cfa);\n \n   /* If nothing changed, no need to issue any call frame instructions.  */\n   if (cfa_equal_p (&loc, &old_cfa))\n@@ -712,16 +584,19 @@ def_cfa_1 (const char *label, dw_cfa_location *loc_p)\n       cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n     }\n \n-  add_fde_cfi (label, cfi);\n+  if (for_cie)\n+    add_cie_cfi (cfi);\n+  else\n+    add_fde_cfi (cfi);\n+  old_cfa = loc;\n }\n \n /* Add the CFI for saving a register.  REG is the CFA column number.\n-   LABEL is passed to add_fde_cfi.\n    If SREG is -1, the register is saved at OFFSET from the CFA;\n    otherwise it is saved in SREG.  */\n \n static void\n-reg_save (const char *label, unsigned int reg, unsigned int sreg,\n+reg_save (bool for_cie, unsigned int reg, unsigned int sreg,\n           HOST_WIDE_INT offset)\n {\n   dw_cfi_ref cfi = new_cfi ();\n@@ -757,7 +632,10 @@ reg_save (const char *label, unsigned int reg, unsigned int sreg,\n       cfi->dw_cfi_oprnd2.dw_cfi_reg_num = sreg;\n     }\n \n-  add_fde_cfi (label, cfi);\n+  if (for_cie)\n+    add_cie_cfi (cfi);\n+  else\n+    add_fde_cfi (cfi);\n }\n \n /* Record the initial position of the return address.  RTL is\n@@ -815,7 +693,7 @@ initial_return_save (rtx rtl)\n     }\n \n   if (reg != DWARF_FRAME_RETURN_COLUMN)\n-    reg_save (NULL, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n+    reg_save (true, DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n }\n \n /* Given a SET, calculate the amount of stack adjustment it\n@@ -1085,7 +963,7 @@ compute_barrier_args_size (void)\n    pushed onto the stack.  */\n \n static void\n-dwarf2out_args_size (const char *label, HOST_WIDE_INT size)\n+dwarf2out_args_size (HOST_WIDE_INT size)\n {\n   dw_cfi_ref cfi;\n \n@@ -1097,13 +975,13 @@ dwarf2out_args_size (const char *label, HOST_WIDE_INT size)\n   cfi = new_cfi ();\n   cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n   cfi->dw_cfi_oprnd1.dw_cfi_offset = size;\n-  add_fde_cfi (label, cfi);\n+  add_fde_cfi (cfi);\n }\n \n /* Record a stack adjustment of OFFSET bytes.  */\n \n static void\n-dwarf2out_stack_adjust (HOST_WIDE_INT offset, const char *label)\n+dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n {\n   if (cfa.reg == STACK_POINTER_REGNUM)\n     cfa.offset += offset;\n@@ -1122,9 +1000,9 @@ dwarf2out_stack_adjust (HOST_WIDE_INT offset, const char *label)\n   if (args_size < 0)\n     args_size = 0;\n \n-  def_cfa_1 (label, &cfa);\n+  def_cfa_1 (false, &cfa);\n   if (flag_asynchronous_unwind_tables)\n-    dwarf2out_args_size (label, args_size);\n+    dwarf2out_args_size (args_size);\n }\n \n /* Check INSN to see if it looks like a push or a stack adjustment, and\n@@ -1135,7 +1013,6 @@ static void\n dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n {\n   HOST_WIDE_INT offset;\n-  const char *label;\n   int i;\n \n   /* Don't handle epilogues at all.  Certainly it would be wrong to do so\n@@ -1166,15 +1043,15 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n \t  if (GET_CODE (insn) == SET)\n \t    insn = SET_SRC (insn);\n \t  gcc_assert (GET_CODE (insn) == CALL);\n-\t  dwarf2out_args_size (\"\", INTVAL (XEXP (insn, 1)));\n+\t  dwarf2out_args_size (INTVAL (XEXP (insn, 1)));\n \t}\n       return;\n     }\n \n   if (CALL_P (insn) && !after_p)\n     {\n       if (!flag_asynchronous_unwind_tables)\n-\tdwarf2out_args_size (\"\", args_size);\n+\tdwarf2out_args_size (args_size);\n       return;\n     }\n   else if (BARRIER_P (insn))\n@@ -1215,8 +1092,7 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n   if (offset == 0)\n     return;\n \n-  label = dwarf2out_cfi_label (false);\n-  dwarf2out_stack_adjust (offset, label);\n+  dwarf2out_stack_adjust (offset);\n }\n \n /* We delay emitting a register save until either (a) we reach the end\n@@ -1284,13 +1160,11 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n   elt->saved_in_reg = dest;\n }\n \n-static const char *last_reg_save_label;\n-\n /* Add an entry to QUEUED_REG_SAVES saying that REG is now saved at\n    SREG, or if SREG is NULL then it is saved at OFFSET to the CFA.  */\n \n static void\n-queue_reg_save (const char *label, rtx reg, rtx sreg, HOST_WIDE_INT offset)\n+queue_reg_save (rtx reg, rtx sreg, HOST_WIDE_INT offset)\n {\n   struct queued_reg_save *q;\n \n@@ -1311,8 +1185,6 @@ queue_reg_save (const char *label, rtx reg, rtx sreg, HOST_WIDE_INT offset)\n   q->reg = reg;\n   q->cfa_offset = offset;\n   q->saved_reg = sreg;\n-\n-  last_reg_save_label = label;\n }\n \n /* Output all the entries in QUEUED_REG_SAVES.  */\n@@ -1333,11 +1205,10 @@ dwarf2out_flush_queued_reg_saves (void)\n \tsreg = DWARF_FRAME_REGNUM (REGNO (q->saved_reg));\n       else\n \tsreg = INVALID_REGNUM;\n-      reg_save (last_reg_save_label, reg, sreg, q->cfa_offset);\n+      reg_save (false, reg, sreg, q->cfa_offset);\n     }\n \n   queued_reg_saves = NULL;\n-  last_reg_save_label = NULL;\n }\n \n /* Does INSN clobber any register which QUEUED_REG_SAVES lists a saved\n@@ -1397,7 +1268,7 @@ static dw_cfa_location cfa_temp;\n /* A subroutine of dwarf2out_frame_debug, process a REG_DEF_CFA note.  */\n \n static void\n-dwarf2out_frame_debug_def_cfa (rtx pat, const char *label)\n+dwarf2out_frame_debug_def_cfa (rtx pat)\n {\n   memset (&cfa, 0, sizeof (cfa));\n \n@@ -1428,13 +1299,13 @@ dwarf2out_frame_debug_def_cfa (rtx pat, const char *label)\n       gcc_unreachable ();\n     }\n \n-  def_cfa_1 (label, &cfa);\n+  def_cfa_1 (false, &cfa);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n \n static void\n-dwarf2out_frame_debug_adjust_cfa (rtx pat, const char *label)\n+dwarf2out_frame_debug_adjust_cfa (rtx pat)\n {\n   rtx src, dest;\n \n@@ -1459,13 +1330,13 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat, const char *label)\n   cfa.reg = REGNO (dest);\n   gcc_assert (cfa.indirect == 0);\n \n-  def_cfa_1 (label, &cfa);\n+  def_cfa_1 (false, &cfa);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_OFFSET note.  */\n \n static void\n-dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n+dwarf2out_frame_debug_cfa_offset (rtx set)\n {\n   HOST_WIDE_INT offset;\n   rtx src, addr, span;\n@@ -1505,7 +1376,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n   if (!span)\n-    reg_save (label, sregno, INVALID_REGNUM, offset);\n+    reg_save (false, sregno, INVALID_REGNUM, offset);\n   else\n     {\n       /* We have a PARALLEL describing where the contents of SRC live.\n@@ -1522,7 +1393,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n \t  rtx elem = XVECEXP (span, 0, par_index);\n \n \t  sregno = DWARF_FRAME_REGNUM (REGNO (src));\n-\t  reg_save (label, sregno, INVALID_REGNUM, span_offset);\n+\t  reg_save (false, sregno, INVALID_REGNUM, span_offset);\n \t  span_offset += GET_MODE_SIZE (GET_MODE (elem));\n \t}\n     }\n@@ -1531,7 +1402,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set, const char *label)\n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_REGISTER note.  */\n \n static void\n-dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n+dwarf2out_frame_debug_cfa_register (rtx set)\n {\n   rtx src, dest;\n   unsigned sregno, dregno;\n@@ -1551,13 +1422,13 @@ dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n \n   /* ??? We'd like to use queue_reg_save, but we need to come up with\n      a different flushing heuristic for epilogues.  */\n-  reg_save (label, sregno, dregno, 0);\n+  reg_save (false, sregno, dregno, 0);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_EXPRESSION note. */\n \n static void\n-dwarf2out_frame_debug_cfa_expression (rtx set, const char *label)\n+dwarf2out_frame_debug_cfa_expression (rtx set)\n {\n   rtx src, dest, span;\n   dw_cfi_ref cfi = new_cfi ();\n@@ -1579,34 +1450,34 @@ dwarf2out_frame_debug_cfa_expression (rtx set, const char *label)\n \n   /* ??? We'd like to use queue_reg_save, were the interface different,\n      and, as above, we could manage flushing for epilogues.  */\n-  add_fde_cfi (label, cfi);\n+  add_fde_cfi (cfi);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_RESTORE note.  */\n \n static void\n-dwarf2out_frame_debug_cfa_restore (rtx reg, const char *label)\n+dwarf2out_frame_debug_cfa_restore (rtx reg)\n {\n   dw_cfi_ref cfi = new_cfi ();\n   unsigned int regno = DWARF_FRAME_REGNUM (REGNO (reg));\n \n   cfi->dw_cfi_opc = (regno & ~0x3f ? DW_CFA_restore_extended : DW_CFA_restore);\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = regno;\n \n-  add_fde_cfi (label, cfi);\n+  add_fde_cfi (cfi);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_WINDOW_SAVE.\n    ??? Perhaps we should note in the CIE where windows are saved (instead of\n    assuming 0(cfa)) and what registers are in the window.  */\n \n static void\n-dwarf2out_frame_debug_cfa_window_save (const char *label)\n+dwarf2out_frame_debug_cfa_window_save (void)\n {\n   dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_opc = DW_CFA_GNU_window_save;\n-  add_fde_cfi (label, cfi);\n+  add_fde_cfi (cfi);\n }\n \n /* Record call frame debugging information for an expression EXPR,\n@@ -1805,7 +1676,7 @@ dwarf2out_frame_debug_cfa_window_save (const char *label)\n   \t   cfa.reg == fde->drap_reg  */\n \n static void\n-dwarf2out_frame_debug_expr (rtx expr, const char *label)\n+dwarf2out_frame_debug_expr (rtx expr)\n {\n   rtx src, dest, span;\n   HOST_WIDE_INT offset;\n@@ -1834,7 +1705,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t    if (GET_CODE (elem) == SET\n \t\t&& MEM_P (SET_DEST (elem))\n \t\t&& (RTX_FRAME_RELATED_P (elem) || par_index == 0))\n-\t      dwarf2out_frame_debug_expr (elem, label);\n+\t      dwarf2out_frame_debug_expr (elem);\n \t  }\n \n       for (par_index = 0; par_index < limit; par_index++)\n@@ -1843,7 +1714,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  if (GET_CODE (elem) == SET\n \t      && (!MEM_P (SET_DEST (elem)) || GET_CODE (expr) == SEQUENCE)\n \t      && (RTX_FRAME_RELATED_P (elem) || par_index == 0))\n-\t    dwarf2out_frame_debug_expr (elem, label);\n+\t    dwarf2out_frame_debug_expr (elem);\n \t  else if (GET_CODE (elem) == SET\n \t\t   && par_index != 0\n \t\t   && !RTX_FRAME_RELATED_P (elem))\n@@ -1853,7 +1724,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      HOST_WIDE_INT offset = stack_adjust_offset (elem, args_size, 0);\n \n \t      if (offset != 0)\n-\t\tdwarf2out_stack_adjust (offset, label);\n+\t\tdwarf2out_stack_adjust (offset);\n \t    }\n \t}\n       return;\n@@ -1913,7 +1784,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t\t\t    && fde->drap_reg != INVALID_REGNUM\n \t\t\t    && cfa.reg != REGNO (src));\n \t      else\n-\t\tqueue_reg_save (label, src, dest, 0);\n+\t\tqueue_reg_save (src, dest, 0);\n \t    }\n \t  break;\n \n@@ -2042,8 +1913,8 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  /* Rule 15 */\n \tcase UNSPEC:\n \tcase UNSPEC_VOLATILE:\n-\t  gcc_assert (targetm.dwarf_handle_frame_unspec);\n-\t  targetm.dwarf_handle_frame_unspec (label, expr, XINT (src, 1));\n+\t  /* All unspecs should be represented by REG_CFA_* notes.  */\n+\t  gcc_unreachable ();\n \t  return;\n \n \t  /* Rule 16 */\n@@ -2072,7 +1943,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t  gcc_unreachable ();\n \t}\n \n-      def_cfa_1 (label, &cfa);\n+      def_cfa_1 (false, &cfa);\n       break;\n \n     case MEM:\n@@ -2232,15 +2103,15 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \n \t\t  fde->drap_reg_saved = 1;\n \n-\t\t  def_cfa_1 (label, &cfa_exp);\n+\t\t  def_cfa_1 (false, &cfa_exp);\n \t\t  break;\n                 }\n \n \t      /* If the source register is exactly the CFA, assume\n \t\t we're saving SP like any other register; this happens\n \t\t on the ARM.  */\n-\t      def_cfa_1 (label, &cfa);\n-\t      queue_reg_save (label, stack_pointer_rtx, NULL_RTX, offset);\n+\t      def_cfa_1 (false, &cfa);\n+\t      queue_reg_save (stack_pointer_rtx, NULL_RTX, offset);\n \t      break;\n \t    }\n \t  else\n@@ -2256,17 +2127,17 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      cfa.reg = REGNO (x);\n \t      cfa.base_offset = offset;\n \t      cfa.indirect = 1;\n-\t      def_cfa_1 (label, &cfa);\n+\t      def_cfa_1 (false, &cfa);\n \t      break;\n \t    }\n \t}\n \n-      def_cfa_1 (label, &cfa);\n+      def_cfa_1 (false, &cfa);\n       {\n \tspan = targetm.dwarf_register_span (src);\n \n \tif (!span)\n-\t  queue_reg_save (label, src, NULL_RTX, offset);\n+\t  queue_reg_save (src, NULL_RTX, offset);\n \telse\n \t  {\n \t    /* We have a PARALLEL describing where the contents of SRC\n@@ -2283,7 +2154,7 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n \t      {\n \t\trtx elem = XVECEXP (span, 0, par_index);\n \n-\t\tqueue_reg_save (label, elem, NULL_RTX, span_offset);\n+\t\tqueue_reg_save (elem, NULL_RTX, span_offset);\n \t\tspan_offset += GET_MODE_SIZE (GET_MODE (elem));\n \t      }\n \t  }\n@@ -2305,7 +2176,6 @@ dwarf2out_frame_debug_expr (rtx expr, const char *label)\n void\n dwarf2out_frame_debug (rtx insn, bool after_p)\n {\n-  const char *label;\n   rtx note, n;\n   bool handled_one = false;\n   bool need_flush = false;\n@@ -2323,10 +2193,10 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \t is still used to save registers.  */\n       if (!ACCUMULATE_OUTGOING_ARGS)\n \tdwarf2out_notice_stack_adjust (insn, after_p);\n+      cfi_insn = NULL;\n       return;\n     }\n \n-  label = dwarf2out_cfi_label (false);\n   any_cfis_emitted = false;\n \n   for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n@@ -2337,7 +2207,7 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \tgoto do_frame_expr;\n \n       case REG_CFA_DEF_CFA:\n-\tdwarf2out_frame_debug_def_cfa (XEXP (note, 0), label);\n+\tdwarf2out_frame_debug_def_cfa (XEXP (note, 0));\n \thandled_one = true;\n \tbreak;\n \n@@ -2349,15 +2219,15 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \t    if (GET_CODE (n) == PARALLEL)\n \t      n = XVECEXP (n, 0, 0);\n \t  }\n-\tdwarf2out_frame_debug_adjust_cfa (n, label);\n+\tdwarf2out_frame_debug_adjust_cfa (n);\n \thandled_one = true;\n \tbreak;\n \n       case REG_CFA_OFFSET:\n \tn = XEXP (note, 0);\n \tif (n == NULL)\n \t  n = single_set (insn);\n-\tdwarf2out_frame_debug_cfa_offset (n, label);\n+\tdwarf2out_frame_debug_cfa_offset (n);\n \thandled_one = true;\n \tbreak;\n \n@@ -2369,15 +2239,15 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \t    if (GET_CODE (n) == PARALLEL)\n \t      n = XVECEXP (n, 0, 0);\n \t  }\n-\tdwarf2out_frame_debug_cfa_register (n, label);\n+\tdwarf2out_frame_debug_cfa_register (n);\n \thandled_one = true;\n \tbreak;\n \n       case REG_CFA_EXPRESSION:\n \tn = XEXP (note, 0);\n \tif (n == NULL)\n \t  n = single_set (insn);\n-\tdwarf2out_frame_debug_cfa_expression (n, label);\n+\tdwarf2out_frame_debug_cfa_expression (n);\n \thandled_one = true;\n \tbreak;\n \n@@ -2390,7 +2260,7 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \t      n = XVECEXP (n, 0, 0);\n \t    n = XEXP (n, 0);\n \t  }\n-\tdwarf2out_frame_debug_cfa_restore (n, label);\n+\tdwarf2out_frame_debug_cfa_restore (n);\n \thandled_one = true;\n \tbreak;\n \n@@ -2410,7 +2280,7 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \tbreak;\n \n       case REG_CFA_WINDOW_SAVE:\n-\tdwarf2out_frame_debug_cfa_window_save (label);\n+\tdwarf2out_frame_debug_cfa_window_save ();\n \thandled_one = true;\n \tbreak;\n \n@@ -2434,7 +2304,7 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n     {\n       insn = PATTERN (insn);\n     do_frame_expr:\n-      dwarf2out_frame_debug_expr (insn, label);\n+      dwarf2out_frame_debug_expr (insn);\n \n       /* Check again.  A parallel can save and update the same register.\n          We could probably check just once, here, but this is safer than\n@@ -2445,15 +2315,15 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n \n   if (need_flush)\n     dwarf2out_flush_queued_reg_saves ();\n+  cfi_insn = NULL;\n }\n \n /* Called once at the start of final to initialize some data for the\n    current function.  */\n+\n void\n dwarf2out_frame_debug_init (void)\n {\n-  rtx insn;\n-\n   regs_saved_in_regs = NULL;\n   queued_reg_saves = NULL;\n \n@@ -2468,10 +2338,115 @@ dwarf2out_frame_debug_init (void)\n   gcc_assert (cfa.reg\n \t      == (unsigned long)DWARF_FRAME_REGNUM (STACK_POINTER_REGNUM));\n \n+  old_cfa = cfa;\n   cfa.reg = STACK_POINTER_REGNUM;\n   cfa_store = cfa;\n   cfa_temp.reg = -1;\n   cfa_temp.offset = 0;\n+}\n+\n+/* Examine CFI and return true if a cfi label and set_loc is needed\n+   beforehand.  Even when generating CFI assembler instructions, we\n+   still have to add the cfi to the list so that lookup_cfa works\n+   later on.  When -g2 and above we even need to force emitting of\n+   CFI labels and add to list a DW_CFA_set_loc for convert_cfa_to_fb_loc_list\n+   purposes.  If we're generating DWARF3 output we use DW_OP_call_frame_cfa\n+   and so don't use convert_cfa_to_fb_loc_list.  */\n+\n+static bool\n+cfi_label_required_p (dw_cfi_ref cfi)\n+{\n+  if (!dwarf2out_do_cfi_asm ())\n+    return true;\n+\n+  if (dwarf_version == 2\n+      && debug_info_level > DINFO_LEVEL_TERSE\n+      && (write_symbols == DWARF2_DEBUG\n+\t  || write_symbols == VMS_AND_DWARF2_DEBUG))\n+    {\n+      switch (cfi->dw_cfi_opc)\n+\t{\n+\tcase DW_CFA_def_cfa_offset:\n+\tcase DW_CFA_def_cfa_offset_sf:\n+\tcase DW_CFA_def_cfa_register:\n+\tcase DW_CFA_def_cfa:\n+\tcase DW_CFA_def_cfa_sf:\n+\tcase DW_CFA_def_cfa_expression:\n+\tcase DW_CFA_restore_state:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Walk the function, looking for NOTE_INSN_CFI notes.  Add the CFIs to the\n+   function's FDE, adding CFI labels and set_loc/advance_loc opcodes as\n+   necessary.  */\n+static void\n+add_cfis_to_fde (void)\n+{\n+  dw_fde_ref fde = current_fde ();\n+  rtx insn, next;\n+  /* We always start with a function_begin label.  */\n+  bool first = false;\n+\n+  for (insn = get_insns (); insn; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+\n+      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_SWITCH_TEXT_SECTIONS)\n+\t{\n+\t  /* Don't attempt to advance_loc4 between labels\n+\t     in different sections.  */\n+\t  first = true;\n+\t}\n+\n+      if (NOTE_P (insn) && NOTE_KIND (insn) == NOTE_INSN_CFI)\n+\t{\n+\t  bool required = cfi_label_required_p (NOTE_CFI (insn));\n+\t  while (next && NOTE_P (next) && NOTE_KIND (next) == NOTE_INSN_CFI)\n+\t    {\n+\t      required |= cfi_label_required_p (NOTE_CFI (next));\n+\t      next = NEXT_INSN (next);\n+\t    }\n+\t  if (required)\n+\t    {\n+\t      int num = dwarf2out_cfi_label_num;\n+\t      const char *label = dwarf2out_cfi_label ();\n+\t      dw_cfi_ref xcfi;\n+\t      rtx tmp;\n+\n+\t      /* Set the location counter to the new label.  */\n+\t      xcfi = new_cfi ();\n+\t      xcfi->dw_cfi_opc = (first ? DW_CFA_set_loc\n+\t\t\t\t  : DW_CFA_advance_loc4);\n+\t      xcfi->dw_cfi_oprnd1.dw_cfi_addr = label;\n+\t      VEC_safe_push (dw_cfi_ref, gc, fde->dw_fde_cfi, xcfi);\n+\n+\t      tmp = emit_note_before (NOTE_INSN_CFI_LABEL, insn);\n+\t      NOTE_LABEL_NUMBER (tmp) = num;\n+\t    }\n+\n+\t  do\n+\t    {\n+\t      VEC_safe_push (dw_cfi_ref, gc, fde->dw_fde_cfi, NOTE_CFI (insn));\n+\t      insn = NEXT_INSN (insn);\n+\t    }\n+\t  while (insn != next);\n+\t  first = false;\n+\t}\n+    }\n+}\n+\n+/* After the (optional) text prologue has been written, emit CFI insns\n+   and update the FDE for frame-related instructions.  */\n+ \n+void\n+dwarf2out_frame_debug_after_prologue (void)\n+{\n+  rtx insn;\n \n   for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n     {\n@@ -2495,6 +2470,7 @@ dwarf2out_frame_debug_init (void)\n \t    case NOTE_INSN_CFA_RESTORE_STATE:\n \t      cfi_insn = insn;\n \t      dwarf2out_frame_debug_restore_state ();\n+\t      cfi_insn = NULL;\n \t      break;\n \t    }\n \t  continue;\n@@ -2523,6 +2499,8 @@ dwarf2out_frame_debug_init (void)\n \n       dwarf2out_frame_debug (insn, true);\n     }\n+\n+  add_cfis_to_fde ();\n }\n \n /* Determine if we need to save and restore CFI information around this\n@@ -2601,6 +2579,7 @@ dwarf2out_cfi_begin_epilogue (rtx insn)\n   /* And emulate the state save.  */\n   gcc_assert (!cfa_remember.in_use);\n   cfa_remember = cfa;\n+  old_cfa_remember = old_cfa;\n   cfa_remember.in_use = 1;\n }\n \n@@ -2611,13 +2590,13 @@ static void\n dwarf2out_frame_debug_restore_state (void)\n {\n   dw_cfi_ref cfi = new_cfi ();\n-  const char *label = dwarf2out_cfi_label (false);\n \n   cfi->dw_cfi_opc = DW_CFA_restore_state;\n-  add_fde_cfi (label, cfi);\n+  add_fde_cfi (cfi);\n \n   gcc_assert (cfa_remember.in_use);\n   cfa = cfa_remember;\n+  old_cfa = old_cfa_remember;\n   cfa_remember.in_use = 0;\n }\n \n@@ -2639,11 +2618,14 @@ dwarf2cfi_frame_init (void)\n   /* Generate the CFA instructions common to all FDE's.  Do it now for the\n      sake of lookup_cfa.  */\n \n+  memset(&old_cfa, 0, sizeof (old_cfa));\n+  old_cfa.reg = INVALID_REGNUM;\n+\n   /* On entry, the Canonical Frame Address is at SP.  */\n   memset(&loc, 0, sizeof (loc));\n   loc.reg = STACK_POINTER_REGNUM;\n   loc.offset = INCOMING_FRAME_SP_OFFSET;\n-  def_cfa_1 (NULL, &loc);\n+  def_cfa_1 (true, &loc);\n \n   if (targetm.debug_unwind_info () == UI_DWARF2\n       || targetm_common.except_unwind_info (&global_options) == UI_DWARF2)"}, {"sha": "a95ed7af96a6d9f9b351d98133a62df815fdccc1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=89e25f958415ae1ae019e8f35398624b95c44f61", "patch": "@@ -945,7 +945,8 @@ output_cfi_directive (dw_cfi_ref cfi)\n void\n dwarf2out_emit_cfi (dw_cfi_ref cfi)\n {\n-  output_cfi_directive (cfi);\n+  if (dwarf2out_do_cfi_asm ())\n+    output_cfi_directive (cfi);\n }\n \n /* Output CFIs from VEC, up to index UPTO, to bring current FDE to the\n@@ -1793,10 +1794,6 @@ dwarf2out_switch_text_section (void)\n     }\n   have_multiple_function_sections = true;\n \n-  /* Reset the current label on switching text sections, so that we\n-     don't attempt to advance_loc4 between labels in different sections.  */\n-  fde->dw_fde_current_label = NULL;\n-\n   /* There is no need to mark used sections when not debugging.  */\n   if (cold_text_section != NULL)\n     dwarf2out_note_section_used ();"}, {"sha": "2c02b948d261959cf2d6f87b0952ed019f0b0d0d", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=89e25f958415ae1ae019e8f35398624b95c44f61", "patch": "@@ -243,6 +243,7 @@ extern enum dw_cfi_oprnd_type dw_cfi_oprnd2_desc\n extern void dwarf2out_decl (tree);\n extern void dwarf2out_frame_debug (rtx, bool);\n extern void dwarf2out_frame_debug_init (void);\n+extern void dwarf2out_frame_debug_after_prologue (void);\n extern void dwarf2out_emit_cfi (dw_cfi_ref cfi);\n \n extern void debug_dwarf (void);"}, {"sha": "319d2389272d662fe6e0ec415984238995d1fb9d", "filename": "gcc/final.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e25f958415ae1ae019e8f35398624b95c44f61/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=89e25f958415ae1ae019e8f35398624b95c44f61", "patch": "@@ -1589,6 +1589,11 @@ final_start_function (rtx first ATTRIBUTE_UNUSED, FILE *file,\n   /* First output the function prologue: code to set up the stack frame.  */\n   targetm.asm_out.function_prologue (file, get_frame_size ());\n \n+#if defined (HAVE_prologue)\n+  if (dwarf2out_do_frame ())\n+    dwarf2out_frame_debug_after_prologue ();\n+#endif\n+\n   /* If the machine represents the prologue as RTL, the profiling code must\n      be emitted when NOTE_INSN_PROLOGUE_END is scanned.  */\n #ifdef HAVE_prologue"}]}