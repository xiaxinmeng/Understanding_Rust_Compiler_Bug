{"sha": "d940c627e077379a534d69025f6a962f8caf4b39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk0MGM2MjdlMDc3Mzc5YTUzNGQ2OTAyNWY2YTk2MmY4Y2FmNGIzOQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-01-11T08:50:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-01-11T08:50:29Z"}, "message": "[Ada] Crash on iterated_component_association in expression function\n\nThis patch improves on the handling of the Ada2020 construct Iterated_\nComponent_Association in various contexts, when the expression involved\nis a record or array aggregate.\n\nExecuting:\n   gnatmake -gnatX -q main\n   ./main\n\nmust yield:\n\n   123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n----\nwith Text_IO; use Text_IO;\nwith Exfor; use Exfor;\nprocedure Main is\n   Map : String := Table_ASCII;\nbegin\n   Put_Line (Map (50..91));\nend;\n----\npackage Exfor is\n   function Table_ASCII return String is\n      (for I in 1 .. Character'Pos (Character'Last) + 1 => Character'Val(I-1));\nend Exfor;\n\n2018-01-11  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_aggr.adb (Resolve_Iterated_Component_Association): Perform\n\tanalysis on a copy of the expression with a copy of the index variable,\n\tbecause full expansion will rewrite construct into a loop with the\n\toriginal loop variable.\n\t* exp_aggr.adb (Gen_Assign): Defer analysis and resolution if the\n\texpression is an iterated component association. Full analysis takes\n\tplace when construct is rewritten as a loop.\n\t(In_Place_Assign_OK, Safe_Component): An iterated_component_association\n\tis not safe for in-place assignment.\n\t* sem_util.adb (Remove_Entity): Handle properly the case of an isolated\n\tentity with no homonym and no other entity in the scope.\n\nFrom-SVN: r256485", "tree": {"sha": "918addcf9e103d9da9f9437a5827c6ceeb124292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/918addcf9e103d9da9f9437a5827c6ceeb124292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d940c627e077379a534d69025f6a962f8caf4b39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d940c627e077379a534d69025f6a962f8caf4b39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d940c627e077379a534d69025f6a962f8caf4b39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d940c627e077379a534d69025f6a962f8caf4b39/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8f258171c90b52a45c6884138df740b2ef88c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8f258171c90b52a45c6884138df740b2ef88c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8f258171c90b52a45c6884138df740b2ef88c27"}], "stats": {"total": 109, "additions": 80, "deletions": 29}, "files": [{"sha": "105bb2f03fe3d7089fe38f013110d747afe3ae8f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d940c627e077379a534d69025f6a962f8caf4b39", "patch": "@@ -1,3 +1,17 @@\n+2018-01-11  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Iterated_Component_Association): Perform\n+\tanalysis on a copy of the expression with a copy of the index variable,\n+\tbecause full expansion will rewrite construct into a loop with the\n+\toriginal loop variable.\n+\t* exp_aggr.adb (Gen_Assign): Defer analysis and resolution if the\n+\texpression is an iterated component association. Full analysis takes\n+\tplace when construct is rewritten as a loop.\n+\t(In_Place_Assign_OK, Safe_Component): An iterated_component_association\n+\tis not safe for in-place assignment.\n+\t* sem_util.adb (Remove_Entity): Handle properly the case of an isolated\n+\tentity with no homonym and no other entity in the scope.\n+\n 2018-01-11  Justin Squirek  <squirek@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma:Pragma_Loop_Variant): Modify error"}, {"sha": "6aff4dd98c77a80d389b8111a035093ec99f5471", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=d940c627e077379a534d69025f6a962f8caf4b39", "patch": "@@ -240,7 +240,7 @@ package body Exp_Aggr is\n    --  calling Flatten.\n    --\n    --  This function also detects and warns about one-component aggregates that\n-   --  appear in a non-static context. Even if the component value is static,\n+   --  appear in a nonstatic context. Even if the component value is static,\n    --  such an aggregate must be expanded into an assignment.\n \n    function Backend_Processing_Possible (N : Node_Id) return Boolean;\n@@ -492,7 +492,7 @@ package body Exp_Aggr is\n          end if;\n \n          --  One-component aggregates are suspicious, and if the context type\n-         --  is an object declaration with non-static bounds it will trip gcc;\n+         --  is an object declaration with nonstatic bounds it will trip gcc;\n          --  such an aggregate must be expanded into a single assignment.\n \n          if Hiv = Lov and then Nkind (Parent (N)) = N_Object_Declaration then\n@@ -674,7 +674,7 @@ package body Exp_Aggr is\n \n          --  Recurse to check subaggregates, which may appear in qualified\n          --  expressions. If delayed, the front-end will have to expand.\n-         --  If the component is a discriminated record, treat as non-static,\n+         --  If the component is a discriminated record, treat as nonstatic,\n          --  as the back-end cannot handle this properly.\n \n          Expr := First (Expressions (N));\n@@ -1537,11 +1537,17 @@ package body Exp_Aggr is\n             --  of the generated loop will analyze the expression in the\n             --  proper context, in which the loop parameter is visible.\n \n-            if Present (Comp_Typ) and then not Is_Array_Type (Comp_Typ)\n-              and then\n-                Nkind (Parent (Expr_Q)) /= N_Iterated_Component_Association\n-            then\n-               Analyze_And_Resolve (Expr_Q, Comp_Typ);\n+            if Present (Comp_Typ) and then not Is_Array_Type (Comp_Typ) then\n+               if\n+                 Nkind (Parent (Expr_Q)) = N_Iterated_Component_Association\n+                or else\n+                  Nkind (Parent (Parent ((Expr_Q))))\n+                     = N_Iterated_Component_Association\n+               then\n+                  null;\n+               else\n+                  Analyze_And_Resolve (Expr_Q, Comp_Typ);\n+               end if;\n             end if;\n \n             if Is_Delayed_Aggregate (Expr_Q) then\n@@ -4045,7 +4051,7 @@ package body Exp_Aggr is\n             Next_Elmt (Disc2);\n          end loop;\n \n-         --  If any discriminant constraint is non-static, emit a check\n+         --  If any discriminant constraint is nonstatic, emit a check\n \n          if Present (Cond) then\n             Insert_Action (N,\n@@ -4298,7 +4304,7 @@ package body Exp_Aggr is\n       --  Check whether all components of the aggregate are compile-time known\n       --  values, and can be passed as is to the back-end without further\n       --  expansion.\n-      --  An Iterated_Component_Association is treated as non-static, but there\n+      --  An Iterated_Component_Association is treated as nonstatic, but there\n       --  are possibilities for optimization here.\n \n       function Flatten\n@@ -5492,6 +5498,16 @@ package body Exp_Aggr is\n \n                   --  For now, too complex to analyze\n \n+                  return False;\n+\n+               elsif\n+                  Nkind (Parent (Expr)) = N_Iterated_Component_Association\n+               then\n+\n+                  --  Ditto for iterated component associations, which in\n+                  --  general require an enclosing loop and involve nonstatic\n+                  --  expressions.\n+\n                   return False;\n                end if;\n \n@@ -5555,7 +5571,7 @@ package body Exp_Aggr is\n                --  bounds. Ditto for an allocator whose qualified expression\n                --  is a constrained type. If the expression in the allocator\n                --  is an unconstrained array, we accept an upper bound that\n-               --  is not static, to allow for non-static expressions of the\n+               --  is not static, to allow for nonstatic expressions of the\n                --  base type. Clearly there are further possibilities (with\n                --  diminishing returns) for safely building arrays in place\n                --  here.\n@@ -7759,7 +7775,7 @@ package body Exp_Aggr is\n          function Get_Component_Val (N : Node_Id) return Uint;\n          --  Given a expression value N of the component type Ctyp, returns a\n          --  value of Csiz (component size) bits representing this value. If\n-         --  the value is non-static or any other reason exists why the value\n+         --  the value is nonstatic or any other reason exists why the value\n          --  cannot be returned, then Not_Handled is raised.\n \n          -----------------------"}, {"sha": "2a4ab3605d9bccfa7167aada2421f538f79e3e96", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=d940c627e077379a534d69025f6a962f8caf4b39", "patch": "@@ -1657,12 +1657,13 @@ package body Sem_Aggr is\n         (N         : Node_Id;\n          Index_Typ : Entity_Id)\n       is\n-         Id  : constant Entity_Id  := Defining_Identifier (N);\n          Loc : constant Source_Ptr := Sloc (N);\n \n          Choice : Node_Id;\n          Dummy  : Boolean;\n          Ent    : Entity_Id;\n+         Expr   : Node_Id;\n+         Id     : Entity_Id;\n \n       begin\n          Choice := First (Discrete_Choices (N));\n@@ -1697,25 +1698,41 @@ package body Sem_Aggr is\n          Ent := New_Internal_Entity (E_Loop, Current_Scope, Loc, 'L');\n          Set_Etype  (Ent, Standard_Void_Type);\n          Set_Parent (Ent, Parent (N));\n+         Push_Scope (Ent);\n+         Id := Make_Defining_Identifier (Loc,\n+           Chars => Chars (Defining_Identifier (N)));\n \n-         --  Decorate the index variable in the current scope. The association\n-         --  may have several choices, each one leading to a loop, so we create\n-         --  this variable only once to prevent homonyms in this scope.\n+         --  Insert and decorate the index variable in the current scope.\n          --  The expression has to be analyzed once the index variable is\n          --  directly visible. Mark the variable as referenced to prevent\n          --  spurious warnings, given that subsequent uses of its name in the\n          --  expression will reference the internal (synonym) loop variable.\n \n-         if No (Scope (Id)) then\n-            Enter_Name (Id);\n-            Set_Etype (Id, Index_Typ);\n-            Set_Ekind (Id, E_Variable);\n-            Set_Scope (Id, Ent);\n-            Set_Referenced (Id);\n+         Enter_Name (Id);\n+         Set_Etype (Id, Index_Typ);\n+         Set_Ekind (Id, E_Variable);\n+         Set_Scope (Id, Ent);\n+         Set_Referenced (Id);\n+\n+         --  Analyze a copy of the expression, to verify legality. We use\n+         --  a copy because the expression will be analyzed anew when the\n+         --  enclosing aggregate is expanded, and the construct is rewritten\n+         --  as a loop with a new index variable.\n+\n+         Expr := New_Copy_Tree (Expression (N));\n+         Dummy := Resolve_Aggr_Expr (Expr, False);\n+\n+         --  An iterated_component_association may appear in a nested\n+         --  aggregate for a multidimensional structure: preserve the bounds\n+         --  computed for the expression, as well as the anonymous array\n+         --  type generated for it; both are needed during array expansion.\n+         --  This does not work for more than two levels of nesting. ???\n+\n+         if Nkind (Expr) = N_Aggregate then\n+            Set_Aggregate_Bounds (Expression (N), Aggregate_Bounds (Expr));\n+            Set_Etype (Expression (N), Etype (Expr));\n          end if;\n \n-         Push_Scope (Ent);\n-         Dummy := Resolve_Aggr_Expr (Expression (N), False);\n          End_Scope;\n       end Resolve_Iterated_Component_Association;\n "}, {"sha": "932454c51a60e58930c2074e8ec7fc7d5753b2e6", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d940c627e077379a534d69025f6a962f8caf4b39/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d940c627e077379a534d69025f6a962f8caf4b39", "patch": "@@ -22373,11 +22373,13 @@ package body Sem_Util is\n \n       else\n          Prev_Id := Current_Entity (Id);\n-         while Present (Prev_Id) and then Homonym (Prev_Id) /= Id loop\n-            Prev_Id := Homonym (Prev_Id);\n-         end loop;\n+         if Present (Prev_Id) then\n+            while Present (Prev_Id) and then Homonym (Prev_Id) /= Id loop\n+               Prev_Id := Homonym (Prev_Id);\n+            end loop;\n \n-         Set_Homonym (Prev_Id, Homonym (Id));\n+            Set_Homonym (Prev_Id, Homonym (Id));\n+         end if;\n       end if;\n \n       --  Remove the entity from the scope entity chain. When the entity is\n@@ -22397,7 +22399,9 @@ package body Sem_Util is\n             Next_Entity (Prev_Id);\n          end loop;\n \n-         Set_Next_Entity (Prev_Id, Next_Entity (Id));\n+         if Present (Prev_Id) then\n+            Set_Next_Entity (Prev_Id, Next_Entity (Id));\n+         end if;\n       end if;\n \n       --  Handle the case where the entity acts as the tail of the scope entity"}]}