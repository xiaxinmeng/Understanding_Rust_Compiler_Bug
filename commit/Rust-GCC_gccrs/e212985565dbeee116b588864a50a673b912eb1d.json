{"sha": "e212985565dbeee116b588864a50a673b912eb1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIxMjk4NTU2NWRiZWVlMTE2YjU4ODg2NGE1MGE2NzNiOTEyZWIxZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-08T20:45:05Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-08T20:45:05Z"}, "message": "Delete bogus file from gcc-2.8 tarball.\n\nFrom-SVN: r17011", "tree": {"sha": "c4e7d719b2313aedb6399829718d749220e6727f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4e7d719b2313aedb6399829718d749220e6727f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e212985565dbeee116b588864a50a673b912eb1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e212985565dbeee116b588864a50a673b912eb1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e212985565dbeee116b588864a50a673b912eb1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e212985565dbeee116b588864a50a673b912eb1d/comments", "author": null, "committer": null, "parents": [{"sha": "d38fbd282d3d7ed5f8d2c2ff67ee0503001bfc95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38fbd282d3d7ed5f8d2c2ff67ee0503001bfc95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38fbd282d3d7ed5f8d2c2ff67ee0503001bfc95"}], "stats": {"total": 211, "additions": 0, "deletions": 211}, "files": [{"sha": "c8c84ee9b9147a93621ea1ab2d7b5b8dc60cf099", "filename": "gcc/ginclude/va-mips.h.hold", "status": "removed", "additions": 0, "deletions": 211, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38fbd282d3d7ed5f8d2c2ff67ee0503001bfc95/gcc%2Fginclude%2Fva-mips.h.hold", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38fbd282d3d7ed5f8d2c2ff67ee0503001bfc95/gcc%2Fginclude%2Fva-mips.h.hold", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-mips.h.hold?ref=d38fbd282d3d7ed5f8d2c2ff67ee0503001bfc95", "patch": "@@ -1,211 +0,0 @@\n-/* ---------------------------------------- */\n-/*           VARARGS  for MIPS/GNU CC       */\n-/*                                          */\n-/*                                          */\n-/*                                          */\n-/*                                          */\n-/* ---------------------------------------- */\n-\n-\n-/* These macros implement varargs for GNU C--either traditional or ANSI.  */\n-\n-/* Define __gnuc_va_list.  */\n-\n-#ifndef __GNUC_VA_LIST\n-#define __GNUC_VA_LIST\n-#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n-\n-typedef struct {\n-  /* Pointer to FP regs.  */\n-  char *__fp_regs;\n-  /* Number of FP regs remaining.  */\n-  int __fp_left;\n-  /* Pointer to GP regs followed by stack parameters.  */\n-  char *__gp_regs;\n-} __gnuc_va_list;\n-\n-#ifdef __mips64\n-#define __va_reg_size 8\n-#else\n-#define __va_reg_size 4\n-#endif\n-\n-enum {\n-  __no_type_class = -1,\n-  __void_type_class,\n-  __integer_type_class,\n-  __char_type_class,\n-  __enumeral_type_class,\n-  __boolean_type_class,\n-  __pointer_type_class,\n-  __reference_type_class,\n-  __offset_type_class,\n-  __real_type_class,\n-  __complex_type_class,\n-  __function_type_class,\n-  __method_type_class,\n-  __record_type_class,\n-  __union_type_class,\n-  __array_type_class,\n-  __string_type_class,\n-  __set_type_class,\n-  __file_type_class,\n-  __lang_type_class\n-};\n-\n-#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n-\n-typedef char * __gnuc_va_list;\n-\n-#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n-#endif /* not __GNUC_VA_LIST */\n-\n-/* If this is for internal libc use, don't define anything but\n-   __gnuc_va_list.  */\n-#if defined (_STDARG_H) || defined (_VARARGS_H)\n-\n-/* In GCC version 2, we want an ellipsis at the end of the declaration\n-   of the argument list.  GCC version 1 can't parse it.  */\n-\n-#if __GNUC__ > 1\n-#define __va_ellipsis ...\n-#else\n-#define __va_ellipsis\n-#endif\n-\n-#ifdef __mips64\n-#define __va_rounded_size(__TYPE)  \\\n-  (((sizeof (__TYPE) + 8 - 1) / 8) * 8)\n-#else\n-#define __va_rounded_size(__TYPE)  \\\n-  (((sizeof (__TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))\n-#endif\n-\n-/* Get definitions for _MIPS_SIM_ABI64 etc.  */\n-#ifdef _MIPS_SIM\n-#include <sgidefs.h>\n-#endif\n-\n-#ifdef _STDARG_H\n-#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n-#define va_start(__AP, __LASTARG)\t\t\t\t\t\\\n-  (__AP.__gp_regs = ((char *) __builtin_next_arg (__LASTARG)\t\t\\\n-\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n-\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n-\t\t\t: 0)),\t\t\t\t\t\t\\\n-   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n-   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n-#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n-#define va_start(__AP, __LASTARG) \\\n-  (__AP = (__gnuc_va_list) __builtin_next_arg (__LASTARG))\n-#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n-#else /* ! _STDARG_H */\n-#define va_alist  __builtin_va_alist\n-#ifdef __mips64\n-/* This assumes that `long long int' is always a 64 bit type.  */\n-#define va_dcl    long long int __builtin_va_alist; __va_ellipsis\n-#else\n-#define va_dcl    int __builtin_va_alist; __va_ellipsis\n-#endif\n-#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n-#define va_start(__AP)\t\t\t\t\t\t\t\\\n-  (__AP.__gp_regs = ((char *) __builtin_next_arg ()\t\t\t\\\n-\t\t     - (__builtin_args_info (2) < 8\t\t\t\\\n-\t\t\t? (8 - __builtin_args_info (2)) * __va_reg_size\t\\\n-\t\t\t: 8)),\t\t\t\t\t\t\\\n-   __AP.__fp_left = 8 - __builtin_args_info (3),\t\t\t\\\n-   __AP.__fp_regs = __AP.__gp_regs - __AP.__fp_left * __va_reg_size)\n-/* Need alternate code for _MIPS_SIM_ABI64.  */\n-#elif defined(_MIPS_SIM) && (_MIPS_SIM == _MIPS_SIM_ABI64 || _MIPS_SIM == _MIPS_SIM_NABI32)\n-#define va_start(__AP)\t\t\t\t\t\t\t\\\n-  (__AP = (__gnuc_va_list) __builtin_next_arg ()\t\t\t\\\n-   + (__builtin_args_info (2) >= 8 ? -8 : 0))\n-#else\n-#define va_start(__AP)  __AP = (char *) &__builtin_va_alist\n-#endif\n-#endif /* ! _STDARG_H */\n-\n-#ifndef va_end\n-void va_end (__gnuc_va_list);\t\t/* Defined in libgcc.a */\n-#endif\n-#define va_end(__AP)\t((void)0)\n-\n-#if defined (__mips_eabi) && ! defined (__mips_soft_float)\n-\n-#ifdef __mips64\n-#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n-  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n-    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n-   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n-   : (__AP.__gp_regs += __va_reg_size) - __va_reg_size)\n-#else\n-#define __va_next_addr(__AP, __type)\t\t\t\t\t\\\n-  ((__builtin_classify_type (*(__type *) 0) == __real_type_class\t\\\n-    && __AP.__fp_left > 0)\t\t\t\t\t\t\\\n-   ? (--__AP.__fp_left, (__AP.__fp_regs += 8) - 8)\t\t\t\\\n-   : (((__builtin_classify_type (* (__type *) 0) < record_type_class\t\\\n-\t&& __alignof__ (__type) > 4)\t\t\t\t\t\\\n-       ? __AP.__gp_regs = (__AP.__gp_regs + 8 - 1) & -8),\t\t\\\n-      (__AP.__gp_regs += __va_reg_size) - __va_reg_size))\n-#endif\n-\n-#ifdef __MIPSEB__\n-#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n-  ((__va_rounded_size (__type) <= __va_reg_size)\t\t\t\\\n-   ? *(__type *) (void *) (__va_next_addr (__AP, __type)\t\t\\\n-\t\t\t   + __va_reg_size\t\t\t\t\\\n-\t\t\t   - sizeof (__type))\t\t\t\t\\\n-   : (__builtin_classify_type (*(__type *) 0) >= __record_type_class\t\\\n-      ? **(__type **) (void *) (__va_next_addr (__AP, __type)\t\t\\\n-\t\t\t\t+ __va_reg_size\t\t\t\t\\\n-\t\t\t\t- sizeof (char *))\t\t\t\\\n-      : *(__type *) (void *) __va_next_addr (__AP, __type)))\n-#else\n-#define va_arg(__AP, __type)\t\t\t\t\t\t\\\n-  (__builtin_classify_type (* (__type *) 0) >= __record_type_class\t\\\n-   ? **(__type **) (void *) __va_next_addr (__AP, __type)\t\t\\\n-   : *(__type *) (void *) __va_next_addr (__AP, __type))\n-#endif\n-\n-#else /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n-\n-/* We cast to void * and then to TYPE * because this avoids\n-   a warning about increasing the alignment requirement.  */\n-/* The __mips64 cases are reversed from the 32 bit cases, because the standard\n-   32 bit calling convention left-aligns all parameters smaller than a word,\n-   whereas the __mips64 calling convention does not (and hence they are\n-   right aligned).  */\n-#ifdef __mips64\n-#ifdef __MIPSEB__\n-#define va_arg(__AP, __type)                                    \\\n-  ((__type *) (void *) (__AP = (char *) ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8) \\\n-\t\t\t\t\t + __va_rounded_size (__type))))[-1]\n-#else\n-#define va_arg(__AP, __type)                                    \\\n-  ((__AP = (char *) ((((__PTRDIFF_TYPE__)__AP + 8 - 1) & -8)\t\\\n-\t\t     + __va_rounded_size (__type))),\t\t\\\n-   *(__type *) (void *) (__AP - __va_rounded_size (__type)))\n-#endif\n-\n-#else /* not __mips64 */\n-\n-#ifdef __MIPSEB__\n-/* For big-endian machines.  */\n-#define va_arg(__AP, __type)\t\t\t\t\t\\\n-  ((__AP = (char *) ((__alignof__ (__type) > 4\t\t\t\\\n-\t\t      ? ((int)__AP + 8 - 1) & -8\t\t\\\n-\t\t      : ((int)__AP + 4 - 1) & -4)\t\t\\\n-\t\t     + __va_rounded_size (__type))),\t\t\\\n-   *(__type *) (void *) (__AP - __va_rounded_size (__type)))\n-#else\n-/* For little-endian machines.  */\n-#define va_arg(__AP, __type)\t\t\t\t\t\t    \\\n-  ((__type *) (void *) (__AP = (char *) ((__alignof__(__type) > 4\t    \\\n-\t\t\t\t\t  ? ((int)__AP + 8 - 1) & -8\t    \\\n-\t\t\t\t\t  : ((int)__AP + 4 - 1) & -4)\t    \\\n-\t\t\t\t\t + __va_rounded_size(__type))))[-1]\n-#endif\n-#endif\n-#endif /* ! (defined (__mips_eabi) && ! defined (__mips_soft_float)) */\n-\n-#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}