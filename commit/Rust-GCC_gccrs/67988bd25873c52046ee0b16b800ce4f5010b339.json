{"sha": "67988bd25873c52046ee0b16b800ce4f5010b339", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5ODhiZDI1ODczYzUyMDQ2ZWUwYjE2YjgwMGNlNGY1MDEwYjMzOQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-09-02T10:13:23Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-09-02T10:13:23Z"}, "message": "Update definitions of HANDLE_PRAGMA macro in order to conform to new spec.\n\nFrom-SVN: r22168", "tree": {"sha": "692081b8edfba5523894819ef77113711a8aa1d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/692081b8edfba5523894819ef77113711a8aa1d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67988bd25873c52046ee0b16b800ce4f5010b339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67988bd25873c52046ee0b16b800ce4f5010b339", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67988bd25873c52046ee0b16b800ce4f5010b339", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67988bd25873c52046ee0b16b800ce4f5010b339/comments", "author": null, "committer": null, "parents": [{"sha": "c5168e64d4f7441a39bc2c173d74cc5e536e2dec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5168e64d4f7441a39bc2c173d74cc5e536e2dec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5168e64d4f7441a39bc2c173d74cc5e536e2dec"}], "stats": {"total": 258, "additions": 137, "deletions": 121}, "files": [{"sha": "28e514ffc676aa0d61434feb5837dc6f8dbb6f1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -1,4 +1,17 @@\n-Wed Sep 2 09:25:29 1998  Nick Clifton  <nickc@cygnus.com>\n+Wed Sep  2 10:06:07 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/nextstep.h:    Update HANDLE_PRAGMA macro.\n+\t* config/h8300/h8300.h: Update HANDLE_PRAGMA macro.\n+\t* config/i960/i960.h:   Update HANDLE_PRAGMA macro.\n+\t\n+\t* config/nextstep.c (handle_pragma): Take three arguments, as per\n+\tthe new HANDLE_PRAGMA macro specification.\n+\t* config/h8300/h8300.c (handle_pragma): Take three arguments, as\n+\tper the new HANDLE_PRAGMA macro specification.\n+\t* config/i960/i960.c (process_pragma): Take three arguments, as\n+\tper the new HANDLE_PRAGMA macro specification.\n+\n+Wed Sep  2 09:25:29 1998  Nick Clifton  <nickc@cygnus.com>\n \n \t* c-lex.c (check_newline):  Call HANDLE_PRAGMA before\n \tHANDLE_SYSV_PRAGMA if both are defined.  Generate warning messages"}, {"sha": "92af43165b12001abb6745b52948ef542c6c7a58", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -856,17 +856,13 @@ eq_operator (x, mode)\n    with this attribute may be safely used in an interrupt vector.  */\n \n int\n-handle_pragma (file, t)\n-     FILE *file;\n-     tree t;\n+handle_pragma (p_getc, p_ungetc, name)\n+     int (*  p_getc) PROTO ((void));\n+     void (* p_ungetc) PROTO ((int));\n+     char * pname;\n {\n   int retval = 0;\n-  register char *pname;\n-\n-  if (TREE_CODE (t) != IDENTIFIER_NODE)\n-    return 0;\n \n-  pname = IDENTIFIER_POINTER (t);\n   if (strcmp (pname, \"interrupt\") == 0)\n     interrupt_handler = retval = 1;\n   else if (strcmp (pname, \"saveall\") == 0)"}, {"sha": "f159174980d42fadc6ac504d7afef78935632c99", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -1358,11 +1358,17 @@ do { char dstr[30];\t\t\t\t\t\\\n \n /* Define this macro if you want to implement any pragmas.  If defined, it\n    should be a C expression to be executed when #pragma is seen.  The\n-   argument STREAM is the stdio input stream from which the source\n-   text can be read.  CH is the first character after the #pragma.  The\n-   result of the expression is the terminating character found\n-   (newline or EOF).  */\n-#define HANDLE_PRAGMA(FILE, NODE) handle_pragma (FILE, NODE)\n+   argument GETC is a function which will return the next character in the\n+   input stream, or EOF if no characters are left.  The argument UNGETC is\n+   a function which will push a character back into the input stream.  The\n+   argument NAME is the word following #pragma in the input stream.  The input\n+   stream pointer will be pointing just beyond the end of this word.  The\n+   expression should return true if it handled the pragma, false otherwise.\n+   The input stream should be left undistrubed if false is returned, otherwise\n+   it should be pointing at the last character after the end of the pragma\n+   (newline or end-of-file).  */\n+#define HANDLE_PRAGMA(GETC, UNGETC, NAME) handle_pragma (GETC, UNGETC, NAME)\n+extern int handle_pragma ();\n \n #define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand,nop)\n "}, {"sha": "9fa8889c3011585f37f9cff5e384ef7576ca7993", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -89,86 +89,83 @@ static int ret_label = 0;\n    intel compilers understand.  */\n \n int\n-process_pragma (finput, t)\n-     FILE *finput;\n-     tree t;\n+process_pragma (p_getc, p_ungetc, pname)\n+     int (*  p_getc) PROTO ((void));\n+     void (* p_ungetc) PROTO ((int));\n+     char * pname;\n {\n   int i;\n   register int c;\n-  register char *pname;\n+  char buf[20];\n+  char *s = buf;\n+  int align;\n \n-  if (TREE_CODE (t) != IDENTIFIER_NODE)\n+  /* Should be pragma 'far' or equivalent for callx/balx here.  */\n+  if (strcmp (pname, \"align\") != 0)\n     return 0;\n-\n-  pname = IDENTIFIER_POINTER (t);\n-\n-  if (strcmp (pname, \"align\") == 0)\n+  \n+  do\n     {\n-      char buf[20];\n-      char *s = buf;\n-      int align;\n-\n-      do {\n-\tc = getc (finput);\n-      } while (c == ' ' || c == '\\t');\n-\n-      if (c == '(')\n-\tc = getc (finput);\n-      while (c >= '0' && c <= '9')\n-\t{\n-\t  if (s < buf + sizeof buf - 1)\n-\t    *s++ = c;\n-\t  c = getc (finput);\n-\t}\n-      *s = '\\0';\n-\n-      /* We had to read a non-numerical character to get out of the\n-\t while loop---often a newline.  So, we have to put it back to\n-\t make sure we continue to parse everything properly.  */\n-      ungetc (c, finput);\n-\n-      align = atoi (buf);\n-      switch (align)\n-\t{\n-\tcase 0:\n-\t  /* Return to last alignment.  */\n-\t  align = i960_last_maxbitalignment / 8;\n-\t  /* Fall through.  */\n-\tcase 16:\n-\tcase 8:\n-\tcase 4:\n-\tcase 2:\n-\tcase 1:\n-\t  i960_last_maxbitalignment = i960_maxbitalignment;\n-\t  i960_maxbitalignment = align * 8;\n-\t  break;\n-\n-\tdefault:\n-\t  /* Silently ignore bad values.  */\n-\t  break;\n-\t}\n-\n-      /* NOTE: ic960 R3.0 pragma align definition:\n-\n-\t #pragma align [(size)] | (identifier=size[,...])\n-\t #pragma noalign [(identifier)[,...]]\n+      c = p_getc ();\n+    }\n+  while (c == ' ' || c == '\\t');\n \n-\t (all parens are optional)\n+  if (c == '(')\n+    c = p_getc ();\n+  \n+  while (c >= '0' && c <= '9')\n+    {\n+      if (s < buf + sizeof buf - 1)\n+\t*s++ = c;\n+      c = p_getc ();\n+    }\n+  \n+  *s = '\\0';\n \n-\t - size is [1,2,4,8,16]\n-\t - noalign means size==1\n-\t - applies only to component elements of a struct (and union?)\n-\t - identifier applies to structure tag (only)\n-\t - missing identifier means next struct\n+  /* We had to read a non-numerical character to get out of the\n+     while loop---often a newline.  So, we have to put it back to\n+     make sure we continue to parse everything properly.  */\n+  \n+  p_ungetc (c);\n \n-\t - alignment rules for bitfields need more investigation  */\n+  align = atoi (buf);\n \n-      return 1;\n+  switch (align)\n+    {\n+    case 0:\n+      /* Return to last alignment.  */\n+      align = i960_last_maxbitalignment / 8;\n+      /* Fall through.  */\n+    case 16:\n+    case 8:\n+    case 4:\n+    case 2:\n+    case 1:\n+      i960_last_maxbitalignment = i960_maxbitalignment;\n+      i960_maxbitalignment = align * 8;\n+      break;\n+      \n+    default:\n+      /* Silently ignore bad values.  */\n+      break;\n     }\n-\n-  /* Should be pragma 'far' or equivalent for callx/balx here.  */\n-\n-  return 0;\n+  \n+  /* NOTE: ic960 R3.0 pragma align definition:\n+     \n+     #pragma align [(size)] | (identifier=size[,...])\n+     #pragma noalign [(identifier)[,...]]\n+     \n+     (all parens are optional)\n+     \n+     - size is [1,2,4,8,16]\n+     - noalign means size==1\n+     - applies only to component elements of a struct (and union?)\n+     - identifier applies to structure tag (only)\n+     - missing identifier means next struct\n+     \n+     - alignment rules for bitfields need more investigation  */\n+  \n+  return 1;\n }\n \n /* Initialize variables before compiling any files.  */"}, {"sha": "b786d386e90872784092ca46871ffa66e4b0d1c9", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -122,7 +122,8 @@ Boston, MA 02111-1307, USA.  */\n   fprintf (asm_out_file, \"\\t.type\\t0x%x;\", A)\n \n /* Handle pragmas for compatibility with Intel's compilers.  */\n-#define HANDLE_PRAGMA(FILE, NODE) process_pragma (FILE, NODE)\n+#define HANDLE_PRAGMA(GET, UNGET, NAME) process_pragma (GET, UNGET, NAME)\n+extern int process_pragma ();\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n "}, {"sha": "bdf13355392bdcc49e6d6bcc63841f4b4732a27f", "filename": "gcc/config/nextstep.c", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fnextstep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fnextstep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.c?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -45,12 +45,12 @@ extern char *get_directive_line ();\n    The result is 1 if the pragma was handled.  */\n \n int\n-handle_pragma (finput, node)\n-     FILE *finput;\n-     tree node;\n+handle_pragma (p_getc, p_ungetc, name)\n+     int (*  p_getc) PROTO ((void));\n+     void (* p_ungetc) PROTO ((int));\n+     char * pname;\n {\n   int retval = 0;\n-  register char *pname;\n \n   /* Record initial setting of optimize flag, so we can restore it.  */\n   if (!pragma_initialized)\n@@ -59,11 +59,6 @@ handle_pragma (finput, node)\n       initial_optimize_flag = optimize;\n     }\n \n-  if (TREE_CODE (node) != IDENTIFIER_NODE)\n-    return 0;\n-\n-  pname = IDENTIFIER_POINTER (node);\n-\n   if (strcmp (pname, \"CC_OPT_ON\") == 0)\n     {\n       optimize = 1, obey_regdecls = 0;"}, {"sha": "854832d75ed0c51cfc5a191e4b749b650534942a", "filename": "gcc/config/nextstep.h", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fnextstep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67988bd25873c52046ee0b16b800ce4f5010b339/gcc%2Fconfig%2Fnextstep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep.h?ref=67988bd25873c52046ee0b16b800ce4f5010b339", "patch": "@@ -27,42 +27,43 @@ Boston, MA 02111-1307, USA.  */\n #undef\tINCLUDE_DEFAULTS\n #define INCLUDE_DEFAULTS\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n-    { GPLUSPLUS_INCLUDE_DIR, 1, 1 },\t\t\t\\\n-    { LOCAL_INCLUDE_DIR, 0, 1 },\t\t\t\\\n-    { TOOL_INCLUDE_DIR, 0, 1 },\t\t\t\t\\\n-    { GCC_INCLUDE_DIR, 0, 0 },\t\t\t\t\\\n+    { GPLUSPLUS_INCLUDE_DIR, \"G++\", 1, 1 },\t\t\\\n+    { LOCAL_INCLUDE_DIR, 0, 0, 1 },\t\t\t\\\n+    { TOOL_INCLUDE_DIR, \"BINUTILS\", 0, 1 },\t\t\\\n+    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\t\t\t\\\n     /* These are for fixincludes-fixed ansi/bsd headers\t\\\n        which wouldn't be found otherwise.\t\t\\\n        (The use of string catenation here is OK since\t\\\n \tNeXT's native compiler is derived from GCC.) */\t\\\n-    { GCC_INCLUDE_DIR \"/ansi\", 0, 0 },\t\t\t\\\n-    { GCC_INCLUDE_DIR \"/bsd\", 0, 0 },\t\t\t\\\n-    { \"/NextDeveloper/Headers\", 0, 0 },\t\t\t\\\n-    { \"/NextDeveloper/Headers/ansi\", 0, 0 },\t\t\\\n-    { \"/NextDeveloper/Headers/bsd\", 0, 0 },\t\t\\\n-    { \"/LocalDeveloper/Headers\", 0, 0 },\t\t\\\n-    { \"/LocalDeveloper/Headers/ansi\", 0, 0 },\t\t\\\n-    { \"/LocalDeveloper/Headers/bsd\", 0, 0 },\t\t\\\n-    { \"/NextDeveloper/2.0CompatibleHeaders\", 0, 0 },\t\\\n-    { STANDARD_INCLUDE_DIR, 0, 0 },\t\t\t\\\n-    { \"/usr/include/bsd\", 0, 0 },\t\t\t\\\n-    { 0, 0, 0 }\t\t\t\t\t\t\\\n+    { GCC_INCLUDE_DIR \"/ansi\", 0, 0, 0 },\t\t\\\n+    { GCC_INCLUDE_DIR \"/bsd\", 0, 0, 0 },\t\t\\\n+    { \"/NextDeveloper/Headers\", 0, 0, 0 },\t\t\\\n+    { \"/NextDeveloper/Headers/ansi\", 0, 0, 0 },\t\t\\\n+    { \"/NextDeveloper/Headers/bsd\", 0, 0, 0 },\t\t\\\n+    { \"/LocalDeveloper/Headers\", 0, 0, 0 },\t\t\\\n+    { \"/LocalDeveloper/Headers/ansi\", 0, 0, 0 },\t\\\n+    { \"/LocalDeveloper/Headers/bsd\", 0, 0, 0 },\t\t\\\n+    { \"/NextDeveloper/2.0CompatibleHeaders\", 0, 0, 0 },\t\\\n+    { STANDARD_INCLUDE_DIR, 0, 0, 0 },                  \\\n+    { \"/usr/include/bsd\", 0, 0, 0 },\t\t\t\\\n+    { 0, 0, 0, 0 }\t\t\t\t       \t\\\n   }\n #else /* CROSS_COMPILE */\n #undef\tINCLUDE_DEFAULTS\n #define INCLUDE_DEFAULTS\t\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n-    { GPLUSPLUS_INCLUDE_DIR, 1, 1 },\t\t\t\\\n-    { LOCAL_INCLUDE_DIR, 0, 1 },\t\t\t\\\n-    { GCC_INCLUDE_DIR, 0, 0 },\t\t\t\t\\\n-    { GCC_INCLUDE_DIR \"/ansi\", 0, 0 },\t\t\t\\\n-    { GCC_INCLUDE_DIR \"/bsd\", 0, 0 },\t\t\t\\\n-    { TOOL_INCLUDE_DIR, 0, 1 },\t\t\t\t\\\n-    { TOOL_INCLUDE_DIR \"/ansi\", 0, 0 },\t\t\t\\\n-    { TOOL_INCLUDE_DIR \"/bsd\", 0, 0 },\t\t\t\\\n-    { STANDARD_INCLUDE_DIR, 0, 0 },\t\t\t\\\n-    { \"/usr/include/bsd\", 0, 0 },\t\t\t\\\n-    { 0, 0, 0 }\t\t\t\t\t\t\\\n+    { GPLUSPLUS_INCLUDE_DIR, \"G++\", 1, 1 },\t\t\\\n+    { GPLUSPLUS_INCLUDE_DIR, 0, 1, 1 },\t\t\t\\\n+    { LOCAL_INCLUDE_DIR, 0, 0, 1 },\t\t\t\\\n+    { GCC_INCLUDE_DIR, \"GCC\", 0, 0 },\t\t\t\\\n+    { GCC_INCLUDE_DIR \"/ansi\", 0, 0, 0 },\t\t\\\n+    { GCC_INCLUDE_DIR \"/bsd\", 0, 0, 0 },\t\t\\\n+    { TOOL_INCLUDE_DIR, \"BINUTILS\", 0, 1 },\t\t\\\n+    { TOOL_INCLUDE_DIR \"/ansi\", 0, 0, 0 },\t\t\\\n+    { TOOL_INCLUDE_DIR \"/bsd\", 0, 0, 0 },\t\t\\\n+    { STANDARD_INCLUDE_DIR, 0, 0, 0 },\t\t\t\\\n+    { \"/usr/include/bsd\", 0, 0, 0 },\t\t\t\\\n+    { 0, 0, 0, 0 }\t\t\t\t\t\\\n   }\n #endif /* CROSS_COMPILE */\n \n@@ -251,7 +252,8 @@ Boston, MA 02111-1307, USA.  */\n /* How to parse #pragma's */\n \n #undef\tHANDLE_PRAGMA\n-#define HANDLE_PRAGMA(FINPUT, NODE) handle_pragma (FINPUT, NODE)\n+#define HANDLE_PRAGMA(GETC, UNGETC, NAME) handle_pragma (GETC, UNGETC, NAME)\n+extern int handle_pragma ();\n \n /* Give methods pretty symbol names on NeXT. */\n \n@@ -581,3 +583,9 @@ objc_section_init ()\t\t\t\t\\\n \tconst_section ();\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n+\n+#ifdef ASM_COMMENT_START\n+# undef ASM_COMMENT_START\n+#endif\n+\n+#define ASM_COMMENT_START \";#\""}]}