{"sha": "af66094d037793773eb8a49597866457f2f6a104", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2NjA5NGQwMzc3OTM3NzNlYjhhNDk1OTc4NjY0NTdmMmY2YTEwNA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-30T22:51:26Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-10-12T22:38:43Z"}, "message": "analyzer: handle static callbacks [PR97258]\n\nThe analyzer's initial worklist was only populated with non-static\nfunctions in the TU (along with those that look promising for call\nsummaries).  Hence some static functions that were never explicitly\ncalled but could be called via function pointers were not being\nanalyzed.\n\nThis patch remedies this by ensuring that functions that escape as\nfunction pointers get added to the worklist, if they haven't been\nalready.  Another fix would be to simply analyze all functions that\nwe have a body for, but too much of the testsuite relies on static\ntest functions not being directly analyzed.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/97258\n\t* engine.cc (impl_region_model_context::on_escaped_function): New\n\tvfunc.\n\t(exploded_graph::add_function_entry): Use m_functions_with_enodes\n\tto implement idempotency.\n\t(add_any_callbacks): New.\n\t(exploded_graph::build_initial_worklist): Use the above to find\n\tcallbacks that are reachable from global initializers.\n\t(exploded_graph::on_escaped_function): New.\n\t* exploded-graph.h\n\t(impl_region_model_context::on_escaped_function): New decl.\n\t(exploded_graph::on_escaped_function): New decl.\n\t(exploded_graph::m_functions_with_enodes): New field.\n\t* region-model-reachability.cc\n\t(reachable_regions::reachable_regions): Replace \"store\" param with\n\t\"model\" param; use it to initialize m_model.\n\t(reachable_regions::add): When getting the svalue for the region,\n\tcall get_store_value on the model rather than using an initial\n\tvalue.\n\t(reachable_regions::mark_escaped_clusters): Add ctxt param and\n\tuse it to call on_escaped_function when a function_region escapes.\n\t* region-model-reachability.h\n\t(reachable_regions::reachable_regions): Replace \"store\" param with\n\t\"model\" param.\n\t(reachable_regions::mark_escaped_clusters): Add ctxt param.\n\t(reachable_regions::m_model): New field.\n\t* region-model.cc (region_model::handle_unrecognized_call): Update\n\tfor change in reachable_regions ctor.\n\t(region_model::handle_unrecognized_call): Pass ctxt to\n\tmark_escaped_clusters.\n\t(region_model::get_reachable_svalues): Update for change in\n\treachable_regions ctor.\n\t(region_model::get_initial_value_for_global): Read-only variables\n\tkeep their initial values.\n\t* region-model.h (region_model_context::on_escaped_function): New\n\tvfunc.\n\t(noop_region_model_context::on_escaped_function): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/97258\n\t* gcc.dg/analyzer/callbacks-1.c: New test.\n\t* gcc.dg/analyzer/callbacks-2.c: New test.\n\t* gcc.dg/analyzer/callbacks-3.c: New test.", "tree": {"sha": "2b7be32bf82b87b904d1a78050d14535217045f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b7be32bf82b87b904d1a78050d14535217045f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af66094d037793773eb8a49597866457f2f6a104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af66094d037793773eb8a49597866457f2f6a104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af66094d037793773eb8a49597866457f2f6a104", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af66094d037793773eb8a49597866457f2f6a104/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "455c3d2efc053a95adc2a7e594aa7e1180887d3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455c3d2efc053a95adc2a7e594aa7e1180887d3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455c3d2efc053a95adc2a7e594aa7e1180887d3b"}], "stats": {"total": 189, "additions": 175, "deletions": 14}, "files": [{"sha": "65d7495f26f546ba577d98f8210f9640298310f8", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -143,6 +143,12 @@ impl_region_model_context::on_unknown_change (const svalue *sval,\n     smap->on_unknown_change (sval, is_mutable, m_ext_state);\n }\n \n+void\n+impl_region_model_context::on_escaped_function (tree fndecl)\n+{\n+  m_eg->on_escaped_function (fndecl);\n+}\n+\n /* class setjmp_svalue : public svalue.  */\n \n /* Implementation of svalue::accept vfunc for setjmp_svalue.  */\n@@ -1931,6 +1937,15 @@ exploded_graph::~exploded_graph ()\n exploded_node *\n exploded_graph::add_function_entry (function *fun)\n {\n+  /* Be idempotent.  */\n+  if (m_functions_with_enodes.contains (fun))\n+    {\n+      logger * const logger = get_logger ();\n+       if (logger)\n+\tlogger->log (\"entrypoint for %qE already exists\", fun->decl);\n+      return NULL;\n+    }\n+\n   program_point point = program_point::from_function_entry (m_sg, fun);\n   program_state state (m_ext_state);\n   state.push_frame (m_ext_state, fun);\n@@ -1942,6 +1957,9 @@ exploded_graph::add_function_entry (function *fun)\n   /* We should never fail to add such a node.  */\n   gcc_assert (enode);\n   add_edge (m_origin, enode, NULL);\n+\n+  m_functions_with_enodes.add (fun);\n+\n   return enode;\n }\n \n@@ -2261,6 +2279,18 @@ toplevel_function_p (cgraph_node *node, function *fun, logger *logger)\n   return true;\n }\n \n+/* Callback for walk_tree for finding callbacks within initializers;\n+   ensure they are treated as possible entrypoints to the analysis.  */\n+\n+static tree\n+add_any_callbacks (tree *tp, int *, void *data)\n+{\n+  exploded_graph *eg = (exploded_graph *)data;\n+  if (TREE_CODE (*tp) == FUNCTION_DECL)\n+    eg->on_escaped_function (*tp);\n+  return NULL_TREE;\n+}\n+\n /* Add initial nodes to EG, with entrypoints for externally-callable\n    functions.  */\n \n@@ -2286,6 +2316,19 @@ exploded_graph::build_initial_worklist ()\n \t  logger->log (\"did not create enode for %qE entrypoint\", fun->decl);\n       }\n   }\n+\n+  /* Find callbacks that are reachable from global initializers.  */\n+  varpool_node *vpnode;\n+  FOR_EACH_VARIABLE (vpnode)\n+    {\n+      tree decl = vpnode->decl;\n+      if (!TREE_PUBLIC (decl))\n+\tcontinue;\n+      tree init = DECL_INITIAL (decl);\n+      if (!init)\n+\tcontinue;\n+      walk_tree (&init, add_any_callbacks, this, NULL);\n+    }\n }\n \n /* The main loop of the analysis.\n@@ -3923,6 +3966,33 @@ exploded_graph::get_node_by_index (int idx) const\n   return enode;\n }\n \n+/* Ensure that there is an exploded_node for a top-level call to FNDECL.  */\n+\n+void\n+exploded_graph::on_escaped_function (tree fndecl)\n+{\n+  logger * const logger = get_logger ();\n+  LOG_FUNC_1 (logger, \"%qE\", fndecl);\n+\n+  cgraph_node *cgnode = cgraph_node::get (fndecl);\n+  if (!cgnode)\n+    return;\n+\n+  function *fun = cgnode->get_fun ();\n+  if (!fun)\n+    return;\n+\n+  exploded_node *enode = add_function_entry (fun);\n+  if (logger)\n+    {\n+      if (enode)\n+\tlogger->log (\"created EN %i for %qE entrypoint\",\n+\t\t     enode->m_index, fun->decl);\n+      else\n+\tlogger->log (\"did not create enode for %qE entrypoint\", fun->decl);\n+    }\n+}\n+\n /* A collection of classes for visualizing the callgraph in .dot form\n    (as represented in the supergraph).  */\n "}, {"sha": "b207b1d0762a5870b7c15c9264a209b53aae8fea", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -66,6 +66,8 @@ class impl_region_model_context : public region_model_context\n   void on_unexpected_tree_code (tree t,\n \t\t\t\tconst dump_location_t &loc) FINAL OVERRIDE;\n \n+  void on_escaped_function (tree fndecl) FINAL OVERRIDE;\n+\n   exploded_graph *m_eg;\n   log_user m_logger;\n   const exploded_node *m_enode_for_diag;\n@@ -799,6 +801,8 @@ class exploded_graph : public digraph<eg_traits>\n     return m_worklist.get_scc_id (node);\n   }\n \n+  void on_escaped_function (tree fndecl);\n+\n private:\n   void print_bar_charts (pretty_printer *pp) const;\n \n@@ -845,6 +849,10 @@ class exploded_graph : public digraph<eg_traits>\n   call_string_data_map_t m_per_call_string_data;\n \n   auto_vec<int> m_PK_AFTER_SUPERNODE_per_snode;\n+\n+  /* Functions with a top-level enode, to make add_function_entry\n+     be idempotent, for use in handling callbacks.  */\n+  hash_set<function *> m_functions_with_enodes;\n };\n \n /* A path within an exploded_graph: a sequence of edges.  */"}, {"sha": "3a6b312a8dfca88dbbdd8b915af805c54ea56fb6", "filename": "gcc/analyzer/region-model-reachability.cc", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model-reachability.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.cc?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -58,9 +58,9 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n-reachable_regions::reachable_regions (store *store,\n+reachable_regions::reachable_regions (region_model *model,\n \t\t\t\t      region_model_manager *mgr)\n-: m_store (store), m_mgr (mgr),\n+: m_model (model), m_store (model->get_store ()), m_mgr (mgr),\n   m_reachable_base_regs (), m_mutable_base_regs ()\n {\n }\n@@ -135,7 +135,7 @@ reachable_regions::add (const region *reg, bool is_mutable)\n   if (binding_cluster *bind_cluster = m_store->get_cluster (base_reg))\n     bind_cluster->for_each_value (handle_sval_cb, this);\n   else\n-    handle_sval (m_mgr->get_or_create_initial_value (base_reg));\n+    handle_sval (m_model->get_store_value (reg));\n }\n \n void\n@@ -206,17 +206,24 @@ reachable_regions::handle_parm (const svalue *sval, tree param_type)\n     }\n }\n \n-/* Update m_store to mark the clusters that were found to be mutable\n-   as having escaped.  */\n+/* Update the store to mark the clusters that were found to be mutable\n+   as having escaped.\n+   Notify CTXT about escaping function_decls.  */\n \n void\n-reachable_regions::mark_escaped_clusters ()\n+reachable_regions::mark_escaped_clusters (region_model_context *ctxt)\n {\n+  gcc_assert (ctxt);\n   for (hash_set<const region *>::iterator iter = m_mutable_base_regs.begin ();\n        iter != m_mutable_base_regs.end (); ++iter)\n     {\n       const region *base_reg = *iter;\n       m_store->mark_as_escaped (base_reg);\n+\n+      /* If we have a function that's escaped, potentially add\n+\t it to the worklist.  */\n+      if (const function_region *fn_reg = base_reg->dyn_cast_function_region ())\n+\tctxt->on_escaped_function (fn_reg->get_fndecl ());\n     }\n }\n "}, {"sha": "fe305b0ce782970618115e83c71fb4cd0ca27e32", "filename": "gcc/analyzer/region-model-reachability.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model-reachability.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model-reachability.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-reachability.h?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -35,7 +35,7 @@ namespace ana {\n class reachable_regions\n {\n public:\n-  reachable_regions (store *store, region_model_manager *mgr);\n+  reachable_regions (region_model *model, region_model_manager *mgr);\n \n   /* Callback called for each cluster when initializing this object.  */\n   static void init_cluster_cb (const region *base_reg,\n@@ -59,8 +59,9 @@ class reachable_regions\n   void handle_parm (const svalue *sval, tree param_type);\n \n   /* Update the store to mark the clusters that were found to be mutable\n-     as having escaped.  */\n-  void mark_escaped_clusters ();\n+     as having escaped.\n+     Notify CTXT about escaping function_decls.  */\n+  void mark_escaped_clusters (region_model_context *ctxt);\n \n   /* Iteration over reachable base regions.  */\n   hash_set<const region *>::iterator begin ()\n@@ -94,6 +95,7 @@ class reachable_regions\n   DEBUG_FUNCTION void dump () const;\n \n private:\n+  region_model *m_model;\n   store *m_store;\n   region_model_manager *m_mgr;\n "}, {"sha": "922e0361e5958e3f024f674f610aed8c2fad3e31", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -836,7 +836,7 @@ region_model::handle_unrecognized_call (const gcall *call,\n {\n   tree fndecl = get_fndecl_for_call (call, ctxt);\n \n-  reachable_regions reachable_regs (&m_store, m_mgr);\n+  reachable_regions reachable_regs (this, m_mgr);\n \n   /* Determine the reachable regions and their mutability.  */\n   {\n@@ -884,7 +884,7 @@ region_model::handle_unrecognized_call (const gcall *call,\n     }\n \n   /* Mark any clusters that have escaped.  */\n-  reachable_regs.mark_escaped_clusters ();\n+  reachable_regs.mark_escaped_clusters (ctxt);\n \n   /* Update bindings for all clusters that have escaped, whether above,\n      or previously.  */\n@@ -904,7 +904,7 @@ void\n region_model::get_reachable_svalues (svalue_set *out,\n \t\t\t\t     const svalue *extra_sval)\n {\n-  reachable_regions reachable_regs (&m_store, m_mgr);\n+  reachable_regions reachable_regs (this, m_mgr);\n \n   /* Add globals and regions that already escaped in previous\n      unknown calls.  */\n@@ -1333,14 +1333,17 @@ region_model::get_initial_value_for_global (const region *reg) const\n      an unknown value if an unknown call has occurred, unless this is\n      static to-this-TU and hasn't escaped.  Globals that have escaped\n      are explicitly tracked, so we shouldn't hit this case for them.  */\n-  if (m_store.called_unknown_fn_p () && TREE_PUBLIC (decl))\n+  if (m_store.called_unknown_fn_p ()\n+      && TREE_PUBLIC (decl)\n+      && !TREE_READONLY (decl))\n     return m_mgr->get_or_create_unknown_svalue (reg->get_type ());\n \n   /* If we are on a path from the entrypoint from \"main\" and we have a\n      global decl defined in this TU that hasn't been touched yet, then\n      the initial value of REG can be taken from the initialization value\n      of the decl.  */\n-  if (called_from_main_p () && !DECL_EXTERNAL (decl))\n+  if ((called_from_main_p () && !DECL_EXTERNAL (decl))\n+      || TREE_READONLY (decl))\n     {\n       /* Get the initializer value for base_reg.  */\n       const svalue *base_reg_init"}, {"sha": "5ad4a492f4f7a97a4da86c1d90c694277e6360d5", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -2795,6 +2795,9 @@ class region_model_context\n      know how to handle the tree code of T at LOC.  */\n   virtual void on_unexpected_tree_code (tree t,\n \t\t\t\t\tconst dump_location_t &loc) = 0;\n+\n+  /* Hook for clients to be notified when a function_decl escapes.  */\n+  virtual void on_escaped_function (tree fndecl) = 0;\n };\n \n /* A \"do nothing\" subclass of region_model_context.  */\n@@ -2821,6 +2824,8 @@ class noop_region_model_context : public region_model_context\n   {\n   }\n   void on_unexpected_tree_code (tree, const dump_location_t &) OVERRIDE {}\n+\n+  void on_escaped_function (tree) OVERRIDE {}\n };\n \n /* A subclass of region_model_context for determining if operations fail"}, {"sha": "52c8fde540a7d36a660087e4f99f694ca83e06d1", "filename": "gcc/testsuite/gcc.dg/analyzer/callbacks-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-1.c?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -0,0 +1,25 @@\n+/* Reproducer for PR analyzer/97258: we should report the double-free\n+   inside a static callback if the callback escapes.  */\n+\n+#include <stdlib.h>\n+\n+static void callback_1 (void *p)\n+{\n+  free (p);\n+  free (p); /* { dg-warning \"double-'free' of 'p'\" } */\n+}\n+\n+struct ops {\n+  void (*cb) (void *);\n+};\n+\n+static const struct ops ops_1 = {\n+  .cb = callback_1\n+};\n+\n+extern void registration (const void *);\n+\n+void register_1 (void)\n+{\n+  registration (&ops_1);\n+}"}, {"sha": "98915ee617bd23b24e8a7a370f0271f273c2206f", "filename": "gcc/testsuite/gcc.dg/analyzer/callbacks-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-2.c?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -0,0 +1,22 @@\n+/* Reproducer for PR analyzer/97258: we should report the double-free\n+   inside a static callback if the callback is accessible via a global\n+   initializer.  */\n+\n+#include <stdlib.h>\n+\n+static void callback_1 (void *p)\n+{\n+  free (p);\n+  free (p); /* { dg-warning \"double-'free' of 'p'\" } */\n+}\n+\n+struct ops {\n+  void (*cb) (void *);\n+};\n+\n+/* Callback struct is not static, and so could be accessed via\n+   another TU.  */\n+\n+const struct ops ops_1 = {\n+  .cb = callback_1\n+};"}, {"sha": "5f12c2a28d37e083fdc3a2b3083dcf1dd3c5faf7", "filename": "gcc/testsuite/gcc.dg/analyzer/callbacks-3.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af66094d037793773eb8a49597866457f2f6a104/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af66094d037793773eb8a49597866457f2f6a104/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcallbacks-3.c?ref=af66094d037793773eb8a49597866457f2f6a104", "patch": "@@ -0,0 +1,19 @@\n+#include \"analyzer-decls.h\"\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef int (*__compar_fn_t)(const void *, const void *);\n+extern void qsort(void *__base, size_t __nmemb, size_t __size,\n+\t\t  __compar_fn_t __compar)\n+  __attribute__((__nonnull__(1, 4)));\n+\n+static int\n+test_1_callback (const void *p1, const void *p2)\n+{\n+  __analyzer_dump_path (); /* { dg-message \"here\" } */\n+  return 0;\n+}\n+\n+void test_1_caller (int *arr, size_t n)\n+{\n+  qsort (arr, n, sizeof (int), test_1_callback);\n+}"}]}