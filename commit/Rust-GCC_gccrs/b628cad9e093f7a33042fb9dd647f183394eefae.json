{"sha": "b628cad9e093f7a33042fb9dd647f183394eefae", "node_id": "C_kwDOANBUbNoAKGI2MjhjYWQ5ZTA5M2Y3YTMzMDQyZmI5ZGQ2NDdmMTgzMzk0ZWVmYWU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-11-30T11:05:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-11-30T11:53:10Z"}, "message": "tree-optimization/107919 - predicate simplification in uninit\n\nThe testcase from the PR at -O2 shows\n\n    ((_277 == 2) AND (_79 == 0))\n    OR ((NOT (_277 == 0)) AND (NOT (_277 > 2)) AND (NOT (_277 == 2)) AND (_79 == 0))\n    OR ((NOT (pretmp_300 == 255)) AND (_277 == 0) AND (NOT (_277 > 2)) AND (NOT (_277 == 2)) AND (_79 == 0))\n\nwhich we fail to simplify.  The following patch makes us simplify\nthe relations on _277, producing\n\n    ((_79 == 0) AND (_277 == 2))\n    OR ((_79 == 0) AND (_277 <= 1) AND (NOT (_277 == 0)))\n    OR ((_79 == 0) AND (_277 == 0) AND (NOT (pretmp_300 == 255)))\n\nwhich might be an incremental step to resolve a bogus uninit\ndiagnostic at -O2.  The patch uses maybe_fold_and_comparison for this.\n\n\tPR tree-optimization/107919\n\t* gimple-predicate-analysis.cc (simplify_1): Rename to ...\n\t(simplify_1a): .. this.\n\t(simplify_1b): New.\n\t(predicate::simplify): Call both simplify_1a and simplify_1b.", "tree": {"sha": "aab9053ecb81a4c6fdc09abca18d26d55690a922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aab9053ecb81a4c6fdc09abca18d26d55690a922"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b628cad9e093f7a33042fb9dd647f183394eefae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b628cad9e093f7a33042fb9dd647f183394eefae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b628cad9e093f7a33042fb9dd647f183394eefae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b628cad9e093f7a33042fb9dd647f183394eefae/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2792cb50f55529e1737461e032ed13e7f04f73d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2792cb50f55529e1737461e032ed13e7f04f73d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2792cb50f55529e1737461e032ed13e7f04f73d2"}], "stats": {"total": 83, "additions": 76, "deletions": 7}, "files": [{"sha": "ce2e1d10e431bacbd9e6f601fd257c18529edcb9", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b628cad9e093f7a33042fb9dd647f183394eefae/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b628cad9e093f7a33042fb9dd647f183394eefae/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=b628cad9e093f7a33042fb9dd647f183394eefae", "patch": "@@ -42,6 +42,7 @@\n #include \"value-query.h\"\n #include \"cfganal.h\"\n #include \"tree-eh.h\"\n+#include \"gimple-fold.h\"\n \n #include \"gimple-predicate-analysis.h\"\n \n@@ -1174,7 +1175,9 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \n /* Implemented simplifications:\n \n-   1) ((x IOR y) != 0) AND (x != 0) is equivalent to (x != 0);\n+   1a) ((x IOR y) != 0) AND (x != 0) is equivalent to (x != 0);\n+   1b) [!](X rel y) AND [!](X rel y') where y == y' or both constant\n+       can possibly be simplified\n    2) (X AND Y) OR (!X AND Y) is equivalent to Y;\n    3) X OR (!X AND Y) is equivalent to (X OR Y);\n    4) ((x IAND y) != 0) || (x != 0 AND y != 0)) is equivalent to\n@@ -1184,11 +1187,11 @@ compute_control_dep_chain (basic_block dom_bb, const_basic_block dep_bb,\n \n    PREDS is the predicate chains, and N is the number of chains.  */\n \n-/* Implement rule 1 above.  PREDS is the AND predicate to simplify\n+/* Implement rule 1a above.  PREDS is the AND predicate to simplify\n    in place.  */\n \n static void\n-simplify_1 (pred_chain &chain)\n+simplify_1a (pred_chain &chain)\n {\n   bool simplified = false;\n   pred_chain s_chain = vNULL;\n@@ -1245,6 +1248,66 @@ simplify_1 (pred_chain &chain)\n   chain = s_chain;\n }\n \n+/* Implement rule 1b above.  PREDS is the AND predicate to simplify\n+   in place.  Returns true if CHAIN simplifies to true.  */\n+\n+static bool\n+simplify_1b (pred_chain &chain)\n+{\n+  for (unsigned i = 0; i < chain.length (); i++)\n+    {\n+      pred_info &a_pred = chain[i];\n+\n+      for (unsigned j = i + 1; j < chain.length (); ++j)\n+\t{\n+\t  pred_info &b_pred = chain[j];\n+\n+\t  if (!operand_equal_p (a_pred.pred_lhs, b_pred.pred_lhs)\n+\t      || (!operand_equal_p (a_pred.pred_rhs, b_pred.pred_rhs)\n+\t\t  && !(CONSTANT_CLASS_P (a_pred.pred_rhs)\n+\t\t       && CONSTANT_CLASS_P (b_pred.pred_rhs))))\n+\t    continue;\n+\n+\t  tree_code a_code = a_pred.cond_code;\n+\t  if (a_pred.invert)\n+\t    a_code = invert_tree_comparison (a_code, false);\n+\t  tree_code b_code = b_pred.cond_code;\n+\t  if (b_pred.invert)\n+\t    b_code = invert_tree_comparison (b_code, false);\n+\t  /* Try to combine X a_code Y && X b_code Y'.  */\n+\t  tree comb = maybe_fold_and_comparisons (boolean_type_node,\n+\t\t\t\t\t\t  a_code,\n+\t\t\t\t\t\t  a_pred.pred_lhs,\n+\t\t\t\t\t\t  a_pred.pred_rhs,\n+\t\t\t\t\t\t  b_code,\n+\t\t\t\t\t\t  b_pred.pred_lhs,\n+\t\t\t\t\t\t  b_pred.pred_rhs, NULL);\n+\t  if (!comb)\n+\t    ;\n+\t  else if (integer_zerop (comb))\n+\t    return true;\n+\t  else if (integer_truep (comb))\n+\t    {\n+\t      chain.ordered_remove (j);\n+\t      chain.ordered_remove (i);\n+\t      i--;\n+\t      break;\n+\t    }\n+\t  else if (COMPARISON_CLASS_P (comb)\n+\t\t   && operand_equal_p (a_pred.pred_lhs, TREE_OPERAND (comb, 0)))\n+\t    {\n+\t      chain.ordered_remove (j);\n+\t      a_pred.cond_code = TREE_CODE (comb);\n+\t      a_pred.pred_rhs = TREE_OPERAND (comb, 1);\n+\t      a_pred.invert = false;\n+\t      j--;\n+\t    }\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n /* Implements rule 2 for the OR predicate PREDS:\n \n    2) (X AND Y) OR (!X AND Y) is equivalent to Y.  */\n@@ -1435,11 +1498,17 @@ predicate::simplify (gimple *use_or_def, bool is_use)\n       dump (dump_file, use_or_def, is_use ? \"[USE]:\\n\" : \"[DEF]:\\n\");\n     }\n \n-  unsigned n = m_preds.length ();\n-  for (unsigned i = 0; i < n; i++)\n-    ::simplify_1 (m_preds[i]);\n+  for (unsigned i = 0; i < m_preds.length (); i++)\n+    {\n+      ::simplify_1a (m_preds[i]);\n+      if (::simplify_1b (m_preds[i]))\n+\t{\n+\t  m_preds.ordered_remove (i);\n+\t  i--;\n+\t}\n+    }\n \n-  if (n < 2)\n+  if (m_preds.length () < 2)\n     return;\n \n   bool changed;"}]}