{"sha": "3db45ab5922caf3331b231c9305ce7c0aa85862c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiNDVhYjU5MjJjYWYzMzMxYjIzMWM5MzA1Y2U3YzBhYTg1ODYyYw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-06-06T11:44:09Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-06-06T11:44:09Z"}, "message": "Fix up whitespacing\n\nFrom-SVN: r114428", "tree": {"sha": "f6bc5402cc736afb252a23b78b57e4d60b438ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6bc5402cc736afb252a23b78b57e4d60b438ef9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3db45ab5922caf3331b231c9305ce7c0aa85862c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db45ab5922caf3331b231c9305ce7c0aa85862c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db45ab5922caf3331b231c9305ce7c0aa85862c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db45ab5922caf3331b231c9305ce7c0aa85862c/comments", "author": null, "committer": null, "parents": [{"sha": "c713f9e49863d9d0f6d8744bd76a5e18eff1b6dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c713f9e49863d9d0f6d8744bd76a5e18eff1b6dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c713f9e49863d9d0f6d8744bd76a5e18eff1b6dc"}], "stats": {"total": 854, "additions": 418, "deletions": 436}, "files": [{"sha": "f0a85039a357452c8f796fccf685df45752771e0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -177,7 +177,7 @@\n \t(cp_parser_pure_specifier): Likewise.\n \n \tPR c++/26068\n-\t* parser.c (cp_parser_set_storage_class): Check for \n+\t* parser.c (cp_parser_set_storage_class): Check for\n \tinvalid uses of storage classes on unbraced linkage\n \tspecifications.\n \t(cp_parser_decl_specifier_seq): Pass keywords, not storage classes,\n@@ -212,7 +212,7 @@\n \t(cp_parser_explicit_specialization): Adjust call to\n \tcp_parser_single_declaration.\n \t(cp_parser_init_declarator): Perform template-parameter access\n-\tchecks. \n+\tchecks.\n \t(cp_parser_parameter_declaration): Do not defer checks for\n \ttemplate parameter default arguments.\n \t(cp_parser_template_declaration_after_export): Gather access\n@@ -398,11 +398,11 @@\n \ttype.\n \t(build_modify_expr): Remove spurious conversions.\n \t* class.c (layout_class_type): Modify the type of bitfields to\n-\tindicate a limited range. \n+\tindicate a limited range.\n \t* call.c (standard_conversion): Adjust the type of bitfield\n \texpressions used in an rvalue context.\n \t(build_conditional_expr): Likewise.\n-\t\n+\n 2006-04-22  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* decl.c: Fix comment typos."}, {"sha": "f852c973204ec5fd176b92859eec54f3f98b203b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -2835,7 +2835,7 @@ build_new_function_call (tree fn, tree args, bool koenig_p)\n    set, upon return, to the allocation function called.  */\n \n tree\n-build_operator_new_call (tree fnname, tree args, \n+build_operator_new_call (tree fnname, tree args,\n \t\t\t tree *size, tree *cookie_size,\n \t\t\t tree *fn)\n {\n@@ -3302,7 +3302,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t  || (conv3 && conv3->kind == ck_ambig))\n \t{\n \t  error (\"operands to ?: have different types %qT and %qT\",\n-             arg2_type, arg3_type);\n+\t\t arg2_type, arg3_type);\n \t  result = error_mark_node;\n \t}\n       else if (conv2 && (!conv2->bad_p || !conv3))\n@@ -3512,8 +3512,8 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n   if (!result_type)\n     {\n-\t  error (\"operands to ?: have different types %qT and %qT\",\n-             arg2_type, arg3_type);\n+      error (\"operands to ?: have different types %qT and %qT\",\n+\t     arg2_type, arg3_type);\n       return error_mark_node;\n     }\n \n@@ -6068,7 +6068,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n \t      if (warn)\n \t\t{\n \t\t  warning (OPT_Wsign_promo, \"passing %qT chooses %qT over %qT\",\n-                           type, type1, type2);\n+\t\t\t   type, type1, type2);\n \t\t  warning (OPT_Wsign_promo, \"  in call to %qD\", w->fn);\n \t\t}\n \t      else"}, {"sha": "82cdef76466fa5189d913bed1b10f424fe49eb74", "filename": "gcc/cp/cfns.h", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcfns.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcfns.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcfns.h?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -57,13 +57,13 @@ hash (register const char *str, register unsigned int len)\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400,   0,   0,\n-        1, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n+\t1, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400,  28,  90,   0,\n        95,   0,  51,  93, 114,  26, 109, 124,   5,   1,\n-        6,  13,  37, 128,   3,   0,   0,  49,  38,   0,\n+\t6,  13,  37, 128,   3,   0,   0,  49,  38,   0,\n       104,  45,   0, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n       400, 400, 400, 400, 400, 400, 400, 400, 400, 400,\n@@ -84,23 +84,23 @@ hash (register const char *str, register unsigned int len)\n   switch (hval)\n     {\n       default:\n-        hval += asso_values[(unsigned char)str[5]+1];\n+\thval += asso_values[(unsigned char)str[5]+1];\n       /*FALLTHROUGH*/\n       case 5:\n-        hval += asso_values[(unsigned char)str[4]];\n+\thval += asso_values[(unsigned char)str[4]];\n       /*FALLTHROUGH*/\n       case 4:\n-        hval += asso_values[(unsigned char)str[3]];\n+\thval += asso_values[(unsigned char)str[3]];\n       /*FALLTHROUGH*/\n       case 3:\n-        hval += asso_values[(unsigned char)str[2]];\n+\thval += asso_values[(unsigned char)str[2]];\n       /*FALLTHROUGH*/\n       case 2:\n-        hval += asso_values[(unsigned char)str[1]];\n+\thval += asso_values[(unsigned char)str[1]];\n       /*FALLTHROUGH*/\n       case 1:\n-        hval += asso_values[(unsigned char)str[0]];\n-        break;\n+\thval += asso_values[(unsigned char)str[0]];\n+\tbreak;\n     }\n   return hval + asso_values[(unsigned char)str[len - 1]];\n }\n@@ -329,17 +329,17 @@ libc_name_p (register const char *str, register unsigned int len)\n       register int key = hash (str, len);\n \n       if (key <= MAX_HASH_VALUE && key >= 0)\n-        {\n-          register int index = lookup[key];\n+\t{\n+\t  register int index = lookup[key];\n \n-          if (index >= 0)\n-            {\n-              register const char *s = wordlist[index];\n+\t  if (index >= 0)\n+\t    {\n+\t      register const char *s = wordlist[index];\n \n-              if (*str == *s && !strcmp (str + 1, s + 1))\n-                return s;\n-            }\n-        }\n+\t      if (*str == *s && !strcmp (str + 1, s + 1))\n+\t\treturn s;\n+\t    }\n+\t}\n     }\n   return 0;\n }"}, {"sha": "84ecf77f958d06c3081ba7d7ebfc20c21bc94371", "filename": "gcc/cp/class.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1066,7 +1066,7 @@ add_method (tree type, tree method, tree using_decl)\n \t}\n     }\n \n-  /* A class should never have more than one destructor.  */ \n+  /* A class should never have more than one destructor.  */\n   if (current_fns && DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n     return false;\n \n@@ -1232,7 +1232,7 @@ check_bases (tree t,\n \t dtor is handled in finish_struct_1.  */\n       if (!TYPE_POLYMORPHIC_P (basetype))\n \twarning (OPT_Weffc__,\n-                 \"base class %q#T has a non-virtual destructor\", basetype);\n+\t\t \"base class %q#T has a non-virtual destructor\", basetype);\n \n       /* If the base class doesn't have copy constructors or\n \t assignment operators that take const references, then the\n@@ -1547,7 +1547,7 @@ maybe_warn_about_overly_private_class (tree t)\n       if (!has_nonprivate_method)\n \t{\n \t  warning (OPT_Wctor_dtor_privacy,\n-                   \"all member functions in class %qT are private\", t);\n+\t\t   \"all member functions in class %qT are private\", t);\n \t  return;\n \t}\n     }\n@@ -1559,7 +1559,7 @@ maybe_warn_about_overly_private_class (tree t)\n   if (fn && TREE_PRIVATE (fn))\n     {\n       warning (OPT_Wctor_dtor_privacy,\n-               \"%q#T only defines a private destructor and has no friends\",\n+\t       \"%q#T only defines a private destructor and has no friends\",\n \t       t);\n       return;\n     }\n@@ -1603,7 +1603,7 @@ maybe_warn_about_overly_private_class (tree t)\n       if (nonprivate_ctor == 0)\n \t{\n \t  warning (OPT_Wctor_dtor_privacy,\n-                   \"%q#T only defines private constructors and has no friends\",\n+\t\t   \"%q#T only defines private constructors and has no friends\",\n \t\t   t);\n \t  return;\n \t}\n@@ -2630,7 +2630,7 @@ check_bitfield_decl (tree field)\n   /* Extract the declared width of the bitfield, which has been\n      temporarily stashed in DECL_INITIAL.  */\n   w = DECL_INITIAL (field);\n-  gcc_assert (w != NULL_TREE); \n+  gcc_assert (w != NULL_TREE);\n   /* Remove the bit-field width indicator so that the rest of the\n      compiler does not treat that value as an initializer.  */\n   DECL_INITIAL (field) = NULL_TREE;\n@@ -3040,13 +3040,13 @@ check_field_decls (tree t, tree *access_decls,\n       if (! TYPE_HAS_INIT_REF (t))\n \t{\n \t  warning (OPT_Weffc__,\n-                   \"  but does not override %<%T(const %T&)%>\", t, t);\n+\t\t   \"  but does not override %<%T(const %T&)%>\", t, t);\n \t  if (!TYPE_HAS_ASSIGN_REF (t))\n \t    warning (OPT_Weffc__, \"  or %<operator=(const %T&)%>\", t);\n \t}\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n \twarning (OPT_Weffc__,\n-                 \"  but does not override %<operator=(const %T&)%>\", t);\n+\t\t \"  but does not override %<operator=(const %T&)%>\", t);\n     }\n \n \n@@ -3136,7 +3136,7 @@ walk_subobject_offsets (tree type,\n \n   if (type == error_mark_node)\n     return 0;\n-  \n+\n   if (!TYPE_P (type))\n     {\n       if (abi_version_at_least (2))\n@@ -3336,7 +3336,7 @@ record_subobject_offsets (tree type,\n      other empty classes might later be placed) or at the end of the\n      class (where other objects might then be placed, so other empty\n      subobjects might later overlap).  */\n-  if (is_data_member \n+  if (is_data_member\n       || !is_empty_class (BINFO_TYPE (type)))\n     max_offset = sizeof_biggest_empty_class;\n   else\n@@ -3503,7 +3503,7 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n \t  (binfo, size_diffop (size_zero_node, BINFO_OFFSET (binfo)));\n       else\n \twarning (OPT_Wabi,\n-                 \"offset of empty base %qT may not be ABI-compliant and may\"\n+\t\t \"offset of empty base %qT may not be ABI-compliant and may\"\n \t\t \"change in a future version of GCC\",\n \t\t BINFO_TYPE (binfo));\n     }\n@@ -3616,7 +3616,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n \t      else\n \t\twarning (OPT_Wabi,\n-                         \"class %qT will be considered nearly empty in a \"\n+\t\t\t \"class %qT will be considered nearly empty in a \"\n \t\t\t \"future version of GCC\", t);\n \t    }\n \t}\n@@ -4361,7 +4361,7 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t\t\t       bitsize_unit_node),\n \t\t   BINFO_OFFSET (vbase))))\n \t    warning (OPT_Wabi,\n-                     \"offset of virtual base %qT is not ABI-compliant and \"\n+\t\t     \"offset of virtual base %qT is not ABI-compliant and \"\n \t\t     \"may change in a future version of GCC\",\n \t\t     basetype);\n \n@@ -4691,7 +4691,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t    /* Versions of G++ before G++ 3.4 did not reset the\n \t       DECL_MODE.  */\n \t    warning (OPT_Wabi,\n-                     \"the offset of %qD may not be ABI-compliant and may \"\n+\t\t     \"the offset of %qD may not be ABI-compliant and may \"\n \t\t     \"change in a future version of GCC\", field);\n \t}\n       else\n@@ -4735,9 +4735,9 @@ layout_class_type (tree t, tree *virtuals_p)\n       /* The middle end uses the type of expressions to determine the\n \t possible range of expression values.  In order to optimize\n \t \"x.i > 7\" to \"false\" for a 2-bit bitfield \"i\", the middle end\n-\t must be made aware of the width of \"i\", via its type.  \n+\t must be made aware of the width of \"i\", via its type.\n \n-         Because C++ does not have integer types of arbitrary width,\n+\t Because C++ does not have integer types of arbitrary width,\n \t we must (for the purposes of the front end) convert from the\n \t type assigned here to the declared type of the bitfield\n \t whenever a bitfield expression is used as an rvalue.\n@@ -4750,8 +4750,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  ftype = TREE_TYPE (field);\n \t  width = tree_low_cst (DECL_SIZE (field), /*unsignedp=*/1);\n \t  if (width != TYPE_PRECISION (ftype))\n-\t    TREE_TYPE (field) \n-\t      = c_build_bitfield_integer_type (width, \n+\t    TREE_TYPE (field)\n+\t      = c_build_bitfield_integer_type (width,\n \t\t\t\t\t       TYPE_UNSIGNED (ftype));\n \t}\n \n@@ -4811,7 +4811,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  TYPE_SIZE_UNIT (base_t) = size_zero_node;\n \t  if (warn_abi && !integer_zerop (rli_size_unit_so_far (rli)))\n \t    warning (OPT_Wabi,\n-                     \"layout of classes derived from empty class %qT \"\n+\t\t     \"layout of classes derived from empty class %qT \"\n \t\t     \"may change in a future version of GCC\",\n \t\t     t);\n \t}\n@@ -4907,7 +4907,7 @@ layout_class_type (tree t, tree *virtuals_p)\n   splay_tree_delete (empty_base_offsets);\n \n   if (CLASSTYPE_EMPTY_P (t)\n-      && tree_int_cst_lt (sizeof_biggest_empty_class, \n+      && tree_int_cst_lt (sizeof_biggest_empty_class,\n \t\t\t  TYPE_SIZE_UNIT (t)))\n     sizeof_biggest_empty_class = TYPE_SIZE_UNIT (t);\n }\n@@ -5440,7 +5440,7 @@ pushclass (tree type)\n       current_class_stack_size *= 2;\n       current_class_stack\n \t= XRESIZEVEC (struct class_stack_node, current_class_stack,\n-                      current_class_stack_size);\n+\t\t      current_class_stack_size);\n     }\n \n   /* Insert a new entry on the class stack.  */\n@@ -5855,7 +5855,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t      build_ptrmemfunc_type (build_pointer_type (instantiation_type));\n \t  else if (!is_reference)\n \t    instantiation_type = build_pointer_type (instantiation_type);\n-\t  if (can_convert_arg (target_type, instantiation_type, instantiation, \n+\t  if (can_convert_arg (target_type, instantiation_type, instantiation,\n \t\t\t       LOOKUP_NORMAL))\n \t    matches = tree_cons (instantiation, fn, matches);\n \t}\n@@ -5866,8 +5866,8 @@ resolve_address_of_overloaded_function (tree target_type,\n \t  tree match = most_specialized_instantiation (matches);\n \n \t  if (match != error_mark_node)\n-\t    matches = tree_cons (TREE_PURPOSE (match), \n-\t\t\t\t NULL_TREE, \n+\t    matches = tree_cons (TREE_PURPOSE (match),\n+\t\t\t\t NULL_TREE,\n \t\t\t\t NULL_TREE);\n \t}\n     }\n@@ -6231,7 +6231,7 @@ get_vfield_name (tree type)\n \n   type = BINFO_TYPE (binfo);\n   buf = (char *) alloca (sizeof (VFIELD_NAME_FORMAT)\n-                         + TYPE_NAME_LENGTH (type) + 2);\n+\t\t\t + TYPE_NAME_LENGTH (type) + 2);\n   sprintf (buf, VFIELD_NAME_FORMAT,\n \t   IDENTIFIER_POINTER (constructor_name (type)));\n   return get_identifier (buf);"}, {"sha": "7ded34fb696283859a5c77074bb6aeb97d0c96e2", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -320,7 +320,7 @@ gimplify_switch_stmt (tree *stmt_p)\n /* Hook into the middle of gimplifying an OMP_FOR node.  This is required\n    in order to properly gimplify CONTINUE statements.  Here we merely\n    manage the continue stack; the rest of the job is performed by the\n-   regular gimplifier.  */ \n+   regular gimplifier.  */\n \n static enum gimplify_status\n cp_gimplify_omp_for (tree *expr_p)\n@@ -613,7 +613,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n   if (is_invisiref_parm (stmt)\n       /* Don't dereference parms in a thunk, pass the references through. */\n       && !(DECL_THUNK_P (current_function_decl)\n-           && TREE_CODE (stmt) == PARM_DECL))\n+\t   && TREE_CODE (stmt) == PARM_DECL))\n     {\n       *stmt_p = convert_from_reference (stmt);\n       *walk_subtrees = 0;"}, {"sha": "60503278930952b5ddbd22b4c40da00c3f1c8d40", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -125,11 +125,11 @@ cp_init_ts (void)\n   tree_contains_struct[NAMESPACE_DECL][TS_DECL_WRTL] = 1;\n   tree_contains_struct[USING_DECL][TS_DECL_WRTL] = 1;\n   tree_contains_struct[TEMPLATE_DECL][TS_DECL_WRTL] = 1;\n-  \n+\n   tree_contains_struct[NAMESPACE_DECL][TS_DECL_COMMON] = 1;\n   tree_contains_struct[USING_DECL][TS_DECL_COMMON] = 1;\n   tree_contains_struct[TEMPLATE_DECL][TS_DECL_COMMON] = 1;\n- \n+\n   tree_contains_struct[NAMESPACE_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[USING_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[TEMPLATE_DECL][TS_DECL_MINIMAL] = 1;"}, {"sha": "cb8369cb53b22fefecf4358a19e08a320b3cfd8d", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -203,19 +203,19 @@ has_c_linkage (tree decl)\n   return DECL_EXTERN_C_P (decl);\n }\n \n-static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map))) \n+static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n      htab_t shadowed_var_for_decl;\n \n /* Lookup a shadowed var for FROM, and return it if we find one.  */\n \n-tree \n+tree\n decl_shadowed_for_var_lookup (tree from)\n {\n   struct tree_map *h, in;\n   in.from = from;\n \n-  h = (struct tree_map *) htab_find_with_hash (shadowed_var_for_decl, &in, \n-                                               htab_hash_pointer (from));\n+  h = (struct tree_map *) htab_find_with_hash (shadowed_var_for_decl, &in,\n+\t\t\t\t\t       htab_hash_pointer (from));\n   if (h)\n     return h->to;\n   return NULL_TREE;"}, {"sha": "4e83852a304e2790f05a93e20cfdbd668714d603", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -179,15 +179,15 @@ struct diagnostic_context;\n #define NON_THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != FUNCTION_DECL &&\t\t\t\t\\\n- \tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl_common.lang_specific\t\\\n+\tTREE_CODE (__t) != TEMPLATE_DECL && __t->decl_common.lang_specific\t\\\n \t&& __t->decl_common.lang_specific->decl_flags.thunk_p)\t\t\t\\\n       tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n     __t; })\n #define THUNK_FUNCTION_CHECK(NODE) __extension__\t\t\t\\\n ({  const tree __t = (NODE);\t\t\t\t\t\t\\\n     if (TREE_CODE (__t) != FUNCTION_DECL || !__t->decl_common.lang_specific\t\\\n \t|| !__t->decl_common.lang_specific->decl_flags.thunk_p)\t\t\\\n-      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0); \t\\\n+      tree_check_failed (__t, __FILE__, __LINE__, __FUNCTION__, 0);\t\\\n      __t; })\n #else\n #define NON_THUNK_FUNCTION_CHECK(NODE) (NODE)\n@@ -2090,7 +2090,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    case, DECL_TEMPLATE_INFO is a TREE_LIST, whose TREE_PURPOSE is the\n    TEMPLATE_DECL of which this entity is a specialization.  The TREE_\n    TREE_VALUE is the template arguments used to specialize the\n-   template.  \n+   template.\n \n    In general, DECL_TEMPLATE_INFO is non-NULL only if\n    DECL_USE_TEMPLATE is nonzero.  However, for friends, we sometimes\n@@ -2102,7 +2102,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n    In this case, S<int>::f is, from the point of view of the compiler,\n    an instantiation of a template -- but, from the point of view of\n    the language, each instantiation of S results in a wholly unrelated\n-   global function f.  */ \n+   global function f.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n   (DECL_LANG_SPECIFIC (VAR_TEMPL_TYPE_OR_FUNCTION_DECL_CHECK (NODE)) \\\n    ->decl_flags.u.template_info)\n@@ -2521,7 +2521,7 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n      [basic.types]\n \n      An object type is a (possibly cv-qualified) type that is not a\n-     function type, not a reference type, and not a void type.  \n+     function type, not a reference type, and not a void type.\n \n    Keep these checks in ascending order, for speed.  */\n #define TYPE_OBJ_P(NODE)\t\t\t\\\n@@ -2992,12 +2992,12 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define OMP_FOR_GIMPLIFYING_P(NODE) \\\n   (TREE_LANG_FLAG_0 (OMP_FOR_CHECK (NODE)))\n \n-/* A language-specific token attached to the OpenMP data clauses to \n+/* A language-specific token attached to the OpenMP data clauses to\n    hold code (or code fragments) related to ctors, dtors, and op=.\n    See semantics.c for details.  */\n #define CP_OMP_CLAUSE_INFO(NODE) \\\n   TREE_TYPE (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, \\\n-\t\t\t             OMP_CLAUSE_COPYPRIVATE))\n+\t\t\t\t     OMP_CLAUSE_COPYPRIVATE))\n \n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n@@ -3793,8 +3793,8 @@ extern tree cp_fold_obj_type_ref\t\t(tree, tree);\n extern void set_linkage_according_to_type\t(tree, tree);\n extern void determine_key_method\t\t(tree);\n extern void check_for_override\t\t\t(tree, tree);\n-extern void push_class_stack                    (void);\n-extern void pop_class_stack                     (void);\n+extern void push_class_stack\t\t\t(void);\n+extern void pop_class_stack\t\t\t(void);\n \n /* in cvt.c */\n extern tree convert_to_reference\t\t(tree, tree, int, int, tree);\n@@ -3855,7 +3855,7 @@ extern int cp_complete_array_type\t\t(tree *, tree, bool);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type\t\t\t(tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n-extern tree build_this_parm                     (tree, cp_cv_quals);\n+extern tree build_this_parm\t\t\t(tree, cp_cv_quals);\n extern int copy_fn_p\t\t\t\t(tree);\n extern tree get_scope_of_declarator\t\t(const cp_declarator *);\n extern void grok_special_member_properties\t(tree);\n@@ -3913,7 +3913,7 @@ extern bool have_extern_spec;\n \n /* in decl2.c */\n extern bool check_java_method\t\t\t(tree);\n-extern tree build_memfn_type                    (tree, tree, cp_cv_quals);\n+extern tree build_memfn_type\t\t\t(tree, tree, cp_cv_quals);\n extern void maybe_retrofit_in_chrg\t\t(tree);\n extern void maybe_make_one_only\t\t\t(tree);\n extern void grokclassfn\t\t\t\t(tree, tree,\n@@ -3947,7 +3947,7 @@ extern tree cxx_callgraph_analyze_expr\t\t(tree *, int *, tree);\n extern void mark_needed\t\t\t\t(tree);\n extern bool decl_needed_p\t\t\t(tree);\n extern void note_vague_linkage_fn\t\t(tree);\n-extern tree build_artificial_parm               (tree, tree);\n+extern tree build_artificial_parm\t\t(tree, tree);\n \n /* in error.c */\n extern void init_error\t\t\t\t(void);\n@@ -4165,7 +4165,7 @@ extern void stop_deferring_access_checks\t(void);\n extern void pop_deferring_access_checks\t\t(void);\n extern tree get_deferred_access_checks\t\t(void);\n extern void pop_to_parent_deferring_access_checks (void);\n-extern void perform_access_checks               (tree);\n+extern void perform_access_checks\t\t(tree);\n extern void perform_deferred_access_checks\t(void);\n extern void perform_or_defer_access_check\t(tree, tree);\n extern int stmts_are_full_exprs_p\t\t(void);\n@@ -4245,7 +4245,7 @@ extern tree finish_template_type\t\t(tree, tree, int);\n extern tree finish_base_specifier\t\t(tree, tree, bool);\n extern void finish_member_declaration\t\t(tree);\n extern void qualified_name_lookup_error\t\t(tree, tree, tree);\n-extern void check_template_keyword              (tree);\n+extern void check_template_keyword\t\t(tree);\n extern tree finish_id_expression\t\t(tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *,\n \t\t\t\t\t\t bool, bool, bool *,\n@@ -4307,7 +4307,7 @@ extern tree get_target_expr\t\t\t(tree);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree hash_tree_cons\t\t\t(tree, tree, tree);\n extern tree hash_tree_chain\t\t\t(tree, tree);\n-extern tree build_qualified_name                (tree, tree, tree, bool);\n+extern tree build_qualified_name\t\t(tree, tree, tree, bool);\n extern int is_overloaded_fn\t\t\t(tree);\n extern tree get_first_fn\t\t\t(tree);\n extern tree ovl_cons\t\t\t\t(tree, tree);\n@@ -4347,10 +4347,10 @@ extern int cp_cannot_inline_tree_fn\t\t(tree*);\n extern tree cp_add_pending_fn_decls\t\t(void*,tree);\n extern int cp_auto_var_in_fn_p\t\t\t(tree,tree);\n extern tree fold_if_not_in_template\t\t(tree);\n-extern tree rvalue                              (tree);\n+extern tree rvalue\t\t\t\t(tree);\n extern tree convert_bitfield_to_declared_type   (tree);\n-extern tree cp_save_expr                        (tree);\n-   \n+extern tree cp_save_expr\t\t\t(tree);\n+\n /* in typeck.c */\n extern int string_conv_p\t\t\t(tree, tree, int);\n extern tree cp_truthvalue_conversion\t\t(tree);\n@@ -4368,7 +4368,7 @@ extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code);\n extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n #define cxx_sizeof_nowarn(T) cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, false)\n extern tree inline_conversion\t\t\t(tree);\n-extern tree is_bitfield_expr_with_lowered_type  (tree); \n+extern tree is_bitfield_expr_with_lowered_type  (tree);\n extern tree decay_conversion\t\t\t(tree);\n extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n extern tree finish_class_member_access_expr     (tree, tree, bool);\n@@ -4393,7 +4393,7 @@ extern tree build_modify_expr\t\t\t(tree, enum tree_code, tree);\n extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n \t\t\t\t\t\t const char *, tree, int);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n-extern bool comp_ptr_ttypes_const               (tree, tree);\n+extern bool comp_ptr_ttypes_const\t\t(tree, tree);\n extern int ptr_reasonably_similar\t\t(tree, tree);\n extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n extern int cp_type_quals\t\t\t(tree);"}, {"sha": "5ceca61a4cb30711b87ac2207586bc59e8cf3c94", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -300,12 +300,12 @@ pp_cxx_constant (cxx_pretty_printer *pp, tree t)\n     {\n     case STRING_CST:\n       {\n-        const bool in_parens = PAREN_STRING_LITERAL_P (t);\n-        if (in_parens)\n-          pp_cxx_left_paren (pp);\n-        pp_c_constant (pp_c_base (pp), t);\n-        if (in_parens)\n-          pp_cxx_right_paren (pp);\n+\tconst bool in_parens = PAREN_STRING_LITERAL_P (t);\n+\tif (in_parens)\n+\t  pp_cxx_left_paren (pp);\n+\tpp_c_constant (pp_c_base (pp), t);\n+\tif (in_parens)\n+\t  pp_cxx_right_paren (pp);\n       }\n       break;\n \n@@ -1757,7 +1757,7 @@ pp_cxx_namespace_alias_definition (cxx_pretty_printer *pp, tree t)\n   pp_equal (pp);\n   pp_cxx_whitespace (pp);\n   if (DECL_CONTEXT (DECL_NAMESPACE_ALIAS (t)))\n-    pp_cxx_nested_name_specifier (pp, \n+    pp_cxx_nested_name_specifier (pp,\n \t\t\t\t  DECL_CONTEXT (DECL_NAMESPACE_ALIAS (t)));\n   pp_cxx_qualified_id (pp, DECL_NAMESPACE_ALIAS (t));\n   pp_cxx_semicolon (pp);\n@@ -1803,8 +1803,7 @@ pp_cxx_template_parameter_list (cxx_pretty_printer *pp, tree t)\n      typename identifier(opt)\n      typename identifier(opt) = type-id\n      template < template-parameter-list > class identifier(opt)\n-     template < template-parameter-list > class identifier(opt) = template-name\n-*/\n+     template < template-parameter-list > class identifier(opt) = template-name  */\n \n static void\n pp_cxx_template_parameter (cxx_pretty_printer *pp, tree t)"}, {"sha": "eb289d6ab323d8bd6bcc9d44596c394d57a43277", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -141,9 +141,7 @@ static tree next_initializable_field (tree);\n \n    Used by RTTI\n \ttree type_info_type_node, tinfo_decl_id, tinfo_decl_type;\n-\ttree tinfo_var_id;\n-\n-*/\n+\ttree tinfo_var_id;  */\n \n tree cp_global_trees[CPTI_MAX];\n \n@@ -204,7 +202,7 @@ struct named_label_entry GTY(())\n      This is initially set to the binding level in which the label\n      is defined, but is modified as scopes are closed.  */\n   struct cp_binding_level *binding_level;\n-  /* The head of the names list that was current when the label was \n+  /* The head of the names list that was current when the label was\n      defined, or the inner scope popped.  These are the decls that will\n      be skipped when jumping to the label.  */\n   tree names_in_scope;\n@@ -1087,7 +1085,7 @@ check_redeclaration_exception_specification (tree new_decl,\n   if ((pedantic || ! DECL_IN_SYSTEM_HEADER (old_decl))\n       && ! DECL_IS_BUILTIN (old_decl)\n       && flag_exceptions\n-      && !comp_except_specs (new_exceptions, old_exceptions, \n+      && !comp_except_specs (new_exceptions, old_exceptions,\n \t\t\t     /*exact=*/true))\n     {\n       error (\"declaration of %qF throws different exceptions\", new_decl);\n@@ -1638,7 +1636,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t{\n \t  DECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n \t  DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);\n-\t  DECL_NONTRIVIALLY_INITIALIZED_P (newdecl) \n+\t  DECL_NONTRIVIALLY_INITIALIZED_P (newdecl)\n \t    |= DECL_NONTRIVIALLY_INITIALIZED_P (olddecl);\n \t  DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (newdecl)\n \t    |= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (olddecl);\n@@ -1914,7 +1912,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n       DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n     }\n-  /* Init priority used to be merged from newdecl to olddecl by the memcpy, \n+  /* Init priority used to be merged from newdecl to olddecl by the memcpy,\n      so keep this behavior.  */\n   if (TREE_CODE (newdecl) == VAR_DECL && DECL_HAS_INIT_PRIORITY_P (newdecl))\n     {\n@@ -1976,7 +1974,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n       memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t      (char *) newdecl + sizeof (struct tree_common),\n \t      sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n-      switch (TREE_CODE (olddecl))       \n+      switch (TREE_CODE (olddecl))\n \t{\n \tcase LABEL_DECL:\n \tcase VAR_DECL:\n@@ -2282,7 +2280,7 @@ identify_goto (tree decl, const location_t *locus)\n /* Check that a single previously seen jump to a newly defined label\n    is OK.  DECL is the LABEL_DECL or 0; LEVEL is the binding_level for\n    the jump context; NAMES are the names in scope in LEVEL at the jump\n-   context; LOCUS is the source position of the jump or 0.  Returns \n+   context; LOCUS is the source position of the jump or 0.  Returns\n    true if all is well.  */\n \n static bool\n@@ -3320,7 +3318,7 @@ cp_make_fname_decl (tree id, int type_dep)\n       while (b->level_chain->kind != sk_function_parms)\n \tb = b->level_chain;\n       pushdecl_with_scope (decl, b, /*is_friend=*/false);\n-      cp_finish_decl (decl, init, /*init_const_expr_p=*/false, NULL_TREE, \n+      cp_finish_decl (decl, init, /*init_const_expr_p=*/false, NULL_TREE,\n \t\t      LOOKUP_ONLYCONVERTING);\n     }\n   else\n@@ -4405,7 +4403,7 @@ reshape_init_vector (tree type, reshape_iter *d)\n \t{\n \t  error (\"invalid type %qT as initializer for a vector of type %qT\",\n \t\tTREE_TYPE (d->cur->value), type);\n-  \t  value = error_mark_node;\n+\t  value = error_mark_node;\n \t}\n       ++d->cur;\n       return value;\n@@ -4461,7 +4459,7 @@ reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p)\n \t{\n \t  if (pedantic)\n \t    pedwarn (\"ISO C++ does not allow designated initializers\");\n-  \t\n+\n \t  field = lookup_field_1 (type, d->cur->index, /*want_type=*/false);\n \n \t  if (!field || TREE_CODE (field) != FIELD_DECL)\n@@ -4517,7 +4515,7 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n \t  error (\"braces around scalar initializer for type %qT\", type);\n \t  init = error_mark_node;\n \t}\n-\t\n+\n       d->cur++;\n       return init;\n     }\n@@ -4550,17 +4548,17 @@ reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p)\n       tree str_init = init;\n \n       /* Strip one level of braces if and only if they enclose a single\n-         element (as allowed by [dcl.init.string]).  */\n+\t element (as allowed by [dcl.init.string]).  */\n       if (!first_initializer_p\n \t  && TREE_CODE (str_init) == CONSTRUCTOR\n \t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (str_init)) == 1)\n \t{\n \t  str_init = VEC_index (constructor_elt,\n \t\t\t\tCONSTRUCTOR_ELTS (str_init), 0)->value;\n \t}\n-  \n+\n       /* If it's a string literal, then it's the initializer for the array\n-         as a whole. Otherwise, continue with normal initialization for\n+\t as a whole. Otherwise, continue with normal initialization for\n \t array types (one value per array element).  */\n       if (TREE_CODE (str_init) == STRING_CST)\n \t{\n@@ -4707,7 +4705,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n   else if (init)\n     {\n       /* Do not reshape constructors of vectors (they don't need to be\n-         reshaped.  */\n+\t reshaped.  */\n       if (TREE_CODE (init) == CONSTRUCTOR\n \t  && !COMPOUND_LITERAL_P (init)\n \t  && !TREE_TYPE (init))  /* ptrmemfunc */\n@@ -4982,7 +4980,7 @@ initialize_artificial_var (tree decl, tree init)\n    if the (init) syntax was used.  */\n \n void\n-cp_finish_decl (tree decl, tree init, bool init_const_expr_p, \n+cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\ttree asmspec_tree, int flags)\n {\n   tree type;\n@@ -5135,7 +5133,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t     occurs.  Therefore, in:\n \n \t       struct S { static const int i = 7 / 0; };\n-\t       \n+\n \t     we issue an error at this point.  It would\n \t     probably be better to forbid division by zero in\n \t     integral constant expressions.  */\n@@ -5808,7 +5806,7 @@ check_class_member_definition_namespace (tree decl)\n /* Build a PARM_DECL for the \"this\" parameter.  TYPE is the\n    METHOD_TYPE for a non-static member function; QUALS are the\n    cv-qualifiers that apply to the function.  */\n- \n+\n tree\n build_this_parm (tree type, cp_cv_quals quals)\n {\n@@ -5825,7 +5823,7 @@ build_this_parm (tree type, cp_cv_quals quals)\n   parm = build_artificial_parm (this_identifier, qual_type);\n   cp_apply_type_quals_to_decl (this_quals, parm);\n   return parm;\n-} \n+}\n \n /* CTYPE is class type, or null if non-class.\n    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE\n@@ -5993,7 +5991,7 @@ grokfndecl (tree ctype,\n \t  tree newtype;\n \t  error (\"%<::main%> must return %<int%>\");\n \t  newtype =  build_function_type (integer_type_node,\n-\t\t\t  \t\t  oldtypeargs);\n+\t\t\t\t\t  oldtypeargs);\n \t  TREE_TYPE (decl) = newtype;\n \t}\n       inlinep = 0;\n@@ -6990,7 +6988,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   /* [dcl.fct.edf]\n-     \n+\n      The declarator in a function-definition shall have the form\n      D1 ( parameter-declaration-clause) ...  */\n   if (funcdef_flag && innermost_code != cdk_function)\n@@ -7502,15 +7500,15 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t   is the same as the class name, and we are defining\n \t\t   a function, then it is a constructor/destructor, and\n \t\t   therefore returns a void type.  */\n-\t\t\n+\n \t\t/* ISO C++ 12.4/2.  A destructor may not be declared\n \t\t   const or volatile.  A destructor may not be\n \t\t   static.\n-\t\t   \n+\n \t\t   ISO C++ 12.1.  A constructor may not be declared\n \t\t   const or volatile.  A constructor may not be\n \t\t   virtual.  A constructor may not be static.  */\n-\t\tif (staticp == 2) \n+\t\tif (staticp == 2)\n \t\t  error ((flags == DTOR_FLAG)\n \t\t\t ? \"destructor cannot be static member function\"\n \t\t\t : \"constructor cannot be static member function\");\n@@ -7609,7 +7607,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t      && (TREE_CODE (type) == FUNCTION_TYPE || memfn_quals))\n \t    {\n \t      memfn_quals |= cp_type_quals (type);\n-\t      type = build_memfn_type (type, \n+\t      type = build_memfn_type (type,\n \t\t\t\t       declarator->u.pointer.class_type,\n \t\t\t\t       memfn_quals);\n \t      memfn_quals = TYPE_UNQUALIFIED;\n@@ -7721,7 +7719,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t       !COMPLETE_TYPE_P (ctype)\n \t       && (/* If the function is being defined, then\n \t\t      qualifying type must certainly be complete.  */\n-\t\t   funcdef_flag \n+\t\t   funcdef_flag\n \t\t   /* A friend declaration of \"T::f\" is OK, even if\n \t\t      \"T\" is a template parameter.  But, if this\n \t\t      function is not a friend, the qualifying type\n@@ -7849,14 +7847,14 @@ grokdeclarator (const cp_declarator *declarator,\n \t in typenames, fields or parameters.  */\n       if (current_lang_name == lang_name_java)\n \tTYPE_FOR_JAVA (type) = 1;\n-      \n+\n       /* This declaration:\n \n-           typedef void f(int) const;\n+\t   typedef void f(int) const;\n \n-         declares a function type which is not a member of any\n+\t declares a function type which is not a member of any\n \t particular class, but which is cv-qualified; for\n-\t example \"f S::*\" declares a pointer to a const-qualified \n+\t example \"f S::*\" declares a pointer to a const-qualified\n \t member function of S.  We record the cv-qualification in the\n \t function type.  */\n       if (memfn_quals && TREE_CODE (type) == FUNCTION_TYPE)\n@@ -7931,7 +7929,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n-      bad_specifiers (decl, \"type\", virtualp, \n+      bad_specifiers (decl, \"type\", virtualp,\n \t\t      memfn_quals != TYPE_UNQUALIFIED,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n \n@@ -8105,7 +8103,7 @@ grokdeclarator (const cp_declarator *declarator,\n       {\n \tdecl = cp_build_parm_decl (unqualified_id, type);\n \n-\tbad_specifiers (decl, \"parameter\", virtualp, \n+\tbad_specifiers (decl, \"parameter\", virtualp,\n \t\t\tmemfn_quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n       }\n@@ -8308,7 +8306,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \n \t\tdecl = do_friend (ctype, unqualified_id, decl,\n-\t\t\t\t  *attrlist, flags, \n+\t\t\t\t  *attrlist, flags,\n \t\t\t\t  funcdef_flag);\n \t\treturn decl;\n \t      }\n@@ -8388,7 +8386,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t      }\n \n-\t    bad_specifiers (decl, \"field\", virtualp, \n+\t    bad_specifiers (decl, \"field\", virtualp,\n \t\t\t    memfn_quals != TYPE_UNQUALIFIED,\n \t\t\t    inlinep, friendp, raises != NULL_TREE);\n \t  }\n@@ -8493,7 +8491,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    ctype ? ctype : in_namespace);\n-\tbad_specifiers (decl, \"variable\", virtualp, \n+\tbad_specifiers (decl, \"variable\", virtualp,\n \t\t\tmemfn_quals != TYPE_UNQUALIFIED,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n \n@@ -10215,7 +10213,7 @@ check_function_type (tree decl, tree current_function_parms)\n   if (!COMPLETE_OR_VOID_TYPE_P (return_type))\n     {\n       tree args = TYPE_ARG_TYPES (fntype);\n-\t  \n+\n       error (\"return type %q#T is incomplete\", return_type);\n \n       /* Make it return void instead.  */\n@@ -10490,7 +10488,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \t\t\tignore interface specifications for\n \t\t\tcompiler-generated functions.  */\n \t\t     && !DECL_ARTIFICIAL (decl1));\n-\t\t     \n+\n   if (DECL_INTERFACE_KNOWN (decl1))\n     {\n       tree ctx = decl_function_context (decl1);\n@@ -10790,7 +10788,7 @@ begin_destructor_body (void)\n \t tables.  */\n       initialize_vtbl_ptrs (current_class_ptr);\n       finish_compound_stmt (compound_stmt);\n-      \n+\n       /* And insert cleanups for our bases and members so that they\n \t will be properly destroyed if we throw.  */\n       push_base_cleanups ();\n@@ -10821,10 +10819,10 @@ finish_destructor_body (void)\n       an implicit definition), non-placement operator delete shall\n       be looked up in the scope of the destructor's class and if\n       found shall be accessible and unambiguous.  */\n-      exprstmt = build_op_delete_call(DELETE_EXPR, current_class_ptr, \n+      exprstmt = build_op_delete_call(DELETE_EXPR, current_class_ptr,\n \t\t\t\t      virtual_size,\n-\t\t\t\t      /*global_p=*/false, \n-\t\t\t\t      /*placement=*/NULL_TREE, \n+\t\t\t\t      /*global_p=*/false,\n+\t\t\t\t      /*placement=*/NULL_TREE,\n \t\t\t\t      /*alloc_fn=*/NULL_TREE);\n \n       if_stmt = begin_if_stmt ();\n@@ -10895,7 +10893,7 @@ finish_function_body (tree compstmt)\n {\n   if (compstmt == NULL_TREE)\n     return;\n-  \n+\n   /* Close the block.  */\n   finish_compound_stmt (compstmt);\n "}, {"sha": "a30fed3064fa9ab48994fd5fcdbd4953b10d2235", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -708,7 +708,7 @@ note_vague_linkage_var (tree var)\n    The other parameters are as for cp_finish_decl.  */\n \n void\n-finish_static_data_member_decl (tree decl, \n+finish_static_data_member_decl (tree decl,\n \t\t\t\ttree init, bool init_const_expr_p,\n \t\t\t\ttree asmspec_tree,\n \t\t\t\tint flags)\n@@ -753,7 +753,7 @@ finish_static_data_member_decl (tree decl,\n \n /* DECLARATOR and DECLSPECS correspond to a class member.  The other\n    parameters are as for cp_finish_decl.  Return the DECL for the\n-   class member declared.  */ \n+   class member declared.  */\n \n tree\n grokfield (const cp_declarator *declarator,\n@@ -907,7 +907,7 @@ grokfield (const cp_declarator *declarator,\n \terror (\"%<asm%> specifiers are not permitted on non-static data members\");\n       if (DECL_INITIAL (value) == error_mark_node)\n \tinit = error_mark_node;\n-      cp_finish_decl (value, init, /*init_const_expr_p=*/false, \n+      cp_finish_decl (value, init, /*init_const_expr_p=*/false,\n \t\t      NULL_TREE, flags);\n       DECL_INITIAL (value) = init;\n       DECL_IN_AGGR_P (value) = 1;\n@@ -917,9 +917,9 @@ grokfield (const cp_declarator *declarator,\n       if (asmspec)\n \tset_user_assembler_name (value, asmspec);\n \n-      cp_finish_decl (value, \n-\t\t      /*init=*/NULL_TREE, \n-\t\t      /*init_const_expr_p=*/false, \n+      cp_finish_decl (value,\n+\t\t      /*init=*/NULL_TREE,\n+\t\t      /*init_const_expr_p=*/false,\n \t\t      asmspec_tree, flags);\n \n       /* Pass friends back this way.  */\n@@ -1608,7 +1608,7 @@ determine_visibility (tree decl)\n \t  && DECL_VISIBILITY_SPECIFIED (decl)\n \t  && (!class_type || !CLASSTYPE_VISIBILITY_SPECIFIED (class_type)))\n \ttargetm.cxx.determine_class_data_visibility (decl);\n-    }      \n+    }\n }\n \n static void\n@@ -2420,12 +2420,12 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n   if (initp)\n     {\n       if (init)\n-        finish_expr_stmt (init);\n+\tfinish_expr_stmt (init);\n \n       /* If we're using __cxa_atexit, register a function that calls the\n-         destructor for the object.  */\n+\t destructor for the object.  */\n       if (flag_use_cxa_atexit)\n-        finish_expr_stmt (register_dtor_fn (decl));\n+\tfinish_expr_stmt (register_dtor_fn (decl));\n     }\n   else\n     finish_expr_stmt (build_cleanup (decl));\n@@ -2498,7 +2498,7 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n \t node = TREE_CHAIN (node))\n       /* Do one initialization or destruction.  */\n       one_static_initialization_or_destruction (TREE_VALUE (node),\n-\t\t\t\t \t\tTREE_PURPOSE (node), initp);\n+\t\t\t\t\t\tTREE_PURPOSE (node), initp);\n \n     /* Finish up the priority if-stmt body.  */\n     finish_then_clause (priority_if_stmt);\n@@ -2994,7 +2994,7 @@ cp_finish_file (void)\n \t     DECL_EXTERNAL appropriately, so there's no need to check\n \t     again, and we do not want to clear DECL_EXTERNAL if a\n \t     previous call to import_export_decl set it.\n-\t     \n+\n \t     This is done in a separate for cycle, because if some\n \t     deferred function is contained in another deferred\n \t     function later in deferred_fns varray,\n@@ -3087,7 +3087,7 @@ cp_finish_file (void)\n   else\n     {\n       /* If we have a ctor or this is obj-c++ and we need a static init,\n-         call generate_ctor_or_dtor_function.  */\n+\t call generate_ctor_or_dtor_function.  */\n       if (static_ctors || (c_dialect_objc () && objc_static_init_needed_p ()))\n \tgenerate_ctor_or_dtor_function (/*constructor_p=*/true,\n \t\t\t\t\tDEFAULT_INIT_PRIORITY, &locus);\n@@ -3116,7 +3116,7 @@ cp_finish_file (void)\n   if (VEC_length (tree, pending_statics) != 0)\n     {\n       check_global_declarations (VEC_address (tree, pending_statics),\n-\t\t\t         VEC_length (tree, pending_statics));\n+\t\t\t\t VEC_length (tree, pending_statics));\n       emit_debug_global_declarations (VEC_address (tree, pending_statics),\n \t\t\t\t      VEC_length (tree, pending_statics));\n     }\n@@ -3251,7 +3251,7 @@ mark_used (tree decl)\n     }\n \n   TREE_USED (decl) = 1;\n-  /* If we don't need a value, then we don't need to synthesize DECL.  */ \n+  /* If we don't need a value, then we don't need to synthesize DECL.  */\n   if (skip_evaluation)\n     return;\n   /* Normally, we can wait until instantiation-time to synthesize\n@@ -3275,9 +3275,9 @@ mark_used (tree decl)\n       saved_processing_template_decl = processing_template_decl;\n       processing_template_decl = 0;\n     }\n-  \n+\n   if (processing_template_decl)\n-    return;  \n+    return;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl)\n       && !TREE_ASM_WRITTEN (decl))\n@@ -3329,12 +3329,12 @@ mark_used (tree decl)\n        template, we now know that we will need to actually do the\n        instantiation. We check that DECL is not an explicit\n        instantiation because that is not checked in instantiate_decl.\n-       \n+\n        We put off instantiating functions in order to improve compile\n        times.  Maintaining a stack of active functions is expensive,\n        and the inliner knows to instantiate any functions it might\n        need.  Therefore, we always try to defer instantiation.  */\n-    instantiate_decl (decl, /*defer_ok=*/true, \n+    instantiate_decl (decl, /*defer_ok=*/true,\n \t\t      /*expl_inst_class_mem_p=*/false);\n \n   processing_template_decl = saved_processing_template_decl;"}, {"sha": "91a73cca4fcee6c8eed32478c2acb6fff437b59c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1396,9 +1396,9 @@ dump_expr (tree t, int flags)\n \tif (TREE_CODE (fn) == ADDR_EXPR)\n \t  fn = TREE_OPERAND (fn, 0);\n \n-        /* Nobody is interested in seeing the guts of vcalls.  */\n-        if (TREE_CODE (fn) == OBJ_TYPE_REF)\n-          fn = resolve_virtual_fun_from_obj_type_ref (fn);\n+\t/* Nobody is interested in seeing the guts of vcalls.  */\n+\tif (TREE_CODE (fn) == OBJ_TYPE_REF)\n+\t  fn = resolve_virtual_fun_from_obj_type_ref (fn);\n \n \tif (TREE_TYPE (fn) != NULL_TREE && NEXT_CODE (fn) == METHOD_TYPE)\n \t  {"}, {"sha": "a02fc2f5533cfdd31ee93cb1723cd7ed88e8cb3d", "filename": "gcc/cp/except.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -444,7 +444,7 @@ expand_start_catch_block (tree decl)\n   /* If the C++ object needs constructing, we need to do that before\n      calling __cxa_begin_catch, so that std::uncaught_exception gets\n      the right value during the copy constructor.  */\n-  else if (flag_use_cxa_get_exception_ptr \n+  else if (flag_use_cxa_get_exception_ptr\n \t   && TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n     {\n       exp = do_get_exception_ptr ();\n@@ -460,7 +460,7 @@ expand_start_catch_block (tree decl)\n       tree init = do_begin_catch ();\n       exp = create_temporary_var (ptr_type_node);\n       DECL_REGISTER (exp) = 1;\n-      cp_finish_decl (exp, init, /*init_const_expr=*/false, \n+      cp_finish_decl (exp, init, /*init_const_expr=*/false,\n \t\t      NULL_TREE, LOOKUP_ONLYCONVERTING);\n       initialize_handler_parm (decl, exp);\n     }\n@@ -664,9 +664,9 @@ build_throw (tree exp)\n \t  fn = push_throw_library_fn (fn, tmp);\n \t}\n \n-      /* [except.throw] \n-\t \n-         A throw-expression initializes a temporary object, the type\n+      /* [except.throw]\n+\n+\t A throw-expression initializes a temporary object, the type\n \t of which is determined by removing any top-level\n \t cv-qualifiers from the static type of the operand of throw\n \t and adjusting the type from \"array of T\" or \"function return\n@@ -702,7 +702,7 @@ build_throw (tree exp)\n       if (CLASS_TYPE_P (temp_type))\n \t{\n \t  /* Call the copy constructor.  */\n-\t  exp = (build_special_member_call \n+\t  exp = (build_special_member_call\n \t\t (object, complete_ctor_identifier,\n \t\t  build_tree_list (NULL_TREE, exp),\n \t\t  TREE_TYPE (object),\n@@ -714,7 +714,7 @@ build_throw (tree exp)\n \t    }\n \t}\n       else\n-\texp = build2 (INIT_EXPR, temp_type, object, \n+\texp = build2 (INIT_EXPR, temp_type, object,\n \t\t      decay_conversion (exp));\n \n       /* Pre-evaluate the thrown expression first, since if we allocated"}, {"sha": "590036b882c78868802c63ce4a50cf0ffe80e41e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1320,7 +1320,7 @@ build_offset_ref (tree type, tree member, bool address_p)\n     return member;\n \n   if (dependent_type_p (type) || type_dependent_expression_p (member))\n-    return build_qualified_name (NULL_TREE, type, member, \n+    return build_qualified_name (NULL_TREE, type, member,\n \t\t\t\t /*template_p=*/false);\n \n   gcc_assert (TYPE_P (type));\n@@ -1339,7 +1339,7 @@ build_offset_ref (tree type, tree member, bool address_p)\n     }\n \n   /* Entities other than non-static members need no further\n-     processing.  */ \n+     processing.  */\n   if (TREE_CODE (member) == TYPE_DECL)\n     return member;\n   if (TREE_CODE (member) == VAR_DECL || TREE_CODE (member) == CONST_DECL)\n@@ -1451,7 +1451,7 @@ static tree\n constant_value_1 (tree decl, bool integral_p)\n {\n   while (TREE_CODE (decl) == CONST_DECL\n-\t || (integral_p \n+\t || (integral_p\n \t     ? DECL_INTEGRAL_CONSTANT_VAR_P (decl)\n \t     : (TREE_CODE (decl) == VAR_DECL\n \t\t&& CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (decl)))))\n@@ -1466,7 +1466,7 @@ constant_value_1 (tree decl, bool integral_p)\n \t instantiation time.  */\n       if (DECL_CLASS_SCOPE_P (decl)\n \t  && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (decl))\n-\t  && uses_template_parms (CLASSTYPE_TI_ARGS \n+\t  && uses_template_parms (CLASSTYPE_TI_ARGS\n \t\t\t\t  (DECL_CONTEXT (decl))))\n \t{\n \t  ++processing_template_decl;\n@@ -1520,7 +1520,7 @@ integral_constant_value (tree decl)\n tree\n decl_constant_value (tree decl)\n {\n-  return constant_value_1 (decl, \n+  return constant_value_1 (decl,\n \t\t\t   /*integral_p=*/processing_template_decl);\n }\n \f\n@@ -1548,9 +1548,9 @@ build_raw_new_expr (tree placement, tree type, tree nelts, tree init,\n \t\t    int use_global_new)\n {\n   tree new_expr;\n-  \n-  new_expr = build4 (NEW_EXPR, build_pointer_type (type), placement, type, \n-\t\t     nelts, init); \n+\n+  new_expr = build4 (NEW_EXPR, build_pointer_type (type), placement, type,\n+\t\t     nelts, init);\n   NEW_EXPR_USE_GLOBAL (new_expr) = use_global_new;\n   TREE_SIDE_EFFECTS (new_expr) = 1;\n \n@@ -1565,7 +1565,6 @@ build_raw_new_expr (tree placement, tree type, tree nelts, tree init,\n static tree\n build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t     bool globally_qualified_p)\n-\t     \n {\n   tree size, rval;\n   /* True iff this is a call to \"operator new[]\" instead of just\n@@ -1894,8 +1893,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t    = build_vec_init (init_expr,\n \t\t\t      cp_build_binary_op (MINUS_EXPR, outer_nelts,\n \t\t\t\t\t\t  integer_one_node),\n-\t\t\t      init, \n-      \t\t\t      explicit_default_init_p,\n+\t\t\t      init,\n+\t\t\t      explicit_default_init_p,\n \t\t\t      /*from_array=*/0);\n \n \t  /* An array initialization is stable because the initialization\n@@ -1920,14 +1919,14 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t    {\n \t      /* We are processing something like `new int (10)', which\n \t\t means allocate an int, and initialize it with 10.  */\n-\t      \n+\n \t      if (TREE_CODE (init) == TREE_LIST)\n-\t\tinit = build_x_compound_expr_from_list (init, \n+\t\tinit = build_x_compound_expr_from_list (init,\n \t\t\t\t\t\t\t\"new initializer\");\n \t      else\n \t\tgcc_assert (TREE_CODE (init) != CONSTRUCTOR\n \t\t\t    || TREE_TYPE (init) != NULL_TREE);\n-\t      \n+\n \t      init_expr = build_modify_expr (init_expr, INIT_EXPR, init);\n \t      stable = stabilize_init (init_expr, &init_preeval_expr);\n \t    }\n@@ -2098,7 +2097,7 @@ build_new (tree placement, tree type, tree nelts, tree init,\n \t   array with no elements.  The pointer returned by the\n \t   new-expression is non-null.  [Note: If the library allocation\n \t   function is called, the pointer returned is distinct from the\n-\t   pointer to any other object.]  \n+\t   pointer to any other object.]\n \n \t However, that is not generally useful, so we issue a\n \t warning.  */\n@@ -2276,7 +2275,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \tdeallocate_expr = build_op_delete_call (VEC_DELETE_EXPR,\n \t\t\t\t\t\tbase_tbd, virtual_size,\n \t\t\t\t\t\tuse_global_delete & 1,\n-\t\t\t\t\t\t/*placement=*/NULL_TREE, \n+\t\t\t\t\t\t/*placement=*/NULL_TREE,\n \t\t\t\t\t\t/*alloc_fn=*/NULL_TREE);\n     }\n \n@@ -2370,7 +2369,7 @@ get_temp_regvar (tree type, tree init)\n    but use assignment instead of initialization.  */\n \n tree\n-build_vec_init (tree base, tree maxindex, tree init, \n+build_vec_init (tree base, tree maxindex, tree init,\n \t\tbool explicit_default_init_p,\n \t\tint from_array)\n {\n@@ -2579,12 +2578,12 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    sorry\n \t      (\"cannot initialize multi-dimensional array with initializer\");\n \t  elt_init = build_vec_init (build1 (INDIRECT_REF, type, base),\n-\t\t\t\t     0, 0, \n+\t\t\t\t     0, 0,\n \t\t\t\t     /*explicit_default_init_p=*/false,\n \t\t\t\t     0);\n \t}\n       else if (!TYPE_NEEDS_CONSTRUCTING (type))\n-\telt_init = (build_modify_expr \n+\telt_init = (build_modify_expr\n \t\t    (to, INIT_EXPR,\n \t\t     build_zero_init (type, size_one_node,\n \t\t\t\t      /*static_storage_p=*/false)));\n@@ -2763,8 +2762,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       if (auto_delete != sfk_deleting_destructor)\n \treturn void_zero_node;\n \n-      return build_op_delete_call (DELETE_EXPR, addr, \n-\t\t\t\t   cxx_sizeof_nowarn (type), \n+      return build_op_delete_call (DELETE_EXPR, addr,\n+\t\t\t\t   cxx_sizeof_nowarn (type),\n \t\t\t\t   use_global_delete,\n \t\t\t\t   /*placement=*/NULL_TREE,\n \t\t\t\t   /*alloc_fn=*/NULL_TREE);\n@@ -2814,7 +2813,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t  /* Make sure we have access to the member op delete, even though\n \t     we'll actually be calling it from the destructor.  */\n \t  build_op_delete_call (DELETE_EXPR, addr, cxx_sizeof_nowarn (type),\n-\t\t\t\t/*global_p=*/false, \n+\t\t\t\t/*global_p=*/false,\n \t\t\t\t/*placement=*/NULL_TREE,\n \t\t\t\t/*alloc_fn=*/NULL_TREE);\n \t}"}, {"sha": "b8702924d7de3ed238b90ee2033cf83bc7bd0870", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -44,9 +44,7 @@\n      mangle_vtbl_for_type:\t\tvirtual table data\n      mangle_vtt_for_type:\t\tVTT data\n      mangle_ctor_vtbl_for_type:\t\t`C-in-B' constructor virtual table data\n-     mangle_thunk:\t\t\tthunk function or entry\n-\n-*/\n+     mangle_thunk:\t\t\tthunk function or entry  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -2741,8 +2739,7 @@ mangle_call_offset (const tree fixed_offset, const tree virtual_offset)\n \n    <special-name> ::= T <call-offset> <base encoding>\n \t\t  ::= Tc <this_adjust call-offset> <result_adjust call-offset>\n-\t\t\t\t\t<base encoding>\n-*/\n+\t\t\t\t\t<base encoding>  */\n \n tree\n mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,"}, {"sha": "1f06229eb1ce23a079791aeadb4d3e11ea781108", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1077,7 +1077,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n       DECL_ARGUMENTS (fn) = cp_build_parm_decl (NULL_TREE, rhs_parm_type);\n       TREE_READONLY (DECL_ARGUMENTS (fn)) = 1;\n     }\n-  /* Add the \"this\" parameter.  */ \n+  /* Add the \"this\" parameter.  */\n   this_parm = build_this_parm (fn_type, TYPE_UNQUALIFIED);\n   TREE_CHAIN (this_parm) = DECL_ARGUMENTS (fn);\n   DECL_ARGUMENTS (fn) = this_parm;"}, {"sha": "bf835d7df776e372c468601f94c6f123edbde4c0", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1100,11 +1100,11 @@ check_for_out_of_scope_variable (tree decl)\n   if (!(TREE_CODE (decl) == VAR_DECL && DECL_DEAD_FOR_LOCAL (decl)))\n     return decl;\n \n-  shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (decl) \n+  shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (decl)\n     ? DECL_SHADOWED_FOR_VAR (decl) : NULL_TREE ;\n   while (shadowed != NULL_TREE && TREE_CODE (shadowed) == VAR_DECL\n \t && DECL_DEAD_FOR_LOCAL (shadowed))\n-    shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (shadowed) \n+    shadowed = DECL_HAS_SHADOWED_FOR_VAR_P (shadowed)\n       ? DECL_SHADOWED_FOR_VAR (shadowed) : NULL_TREE;\n   if (!shadowed)\n     shadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (decl));\n@@ -2774,14 +2774,14 @@ do_class_using_decl (tree scope, tree name)\n     }\n \n   scope_dependent_p = dependent_type_p (scope);\n-  name_dependent_p = (scope_dependent_p \n+  name_dependent_p = (scope_dependent_p\n \t\t      || (IDENTIFIER_TYPENAME_P (name)\n \t\t\t  && dependent_type_p (TREE_TYPE (name))));\n \n   bases_dependent_p = false;\n   if (processing_template_decl)\n     for (binfo = TYPE_BINFO (current_class_type), i = 0;\n-\t BINFO_BASE_ITERATE (binfo, i, base_binfo); \n+\t BINFO_BASE_ITERATE (binfo, i, base_binfo);\n \t i++)\n       if (dependent_type_p (TREE_TYPE (base_binfo)))\n \t{\n@@ -2794,8 +2794,8 @@ do_class_using_decl (tree scope, tree name)\n   /* From [namespace.udecl]:\n \n        A using-declaration used as a member-declaration shall refer to a\n-       member of a base class of the class being defined.  \n-     \n+       member of a base class of the class being defined.\n+\n      In general, we cannot check this constraint in a template because\n      we do not know the entire set of base classes of the current\n      class type.  However, if all of the base classes are\n@@ -2817,7 +2817,7 @@ do_class_using_decl (tree scope, tree name)\n \t  decl = lookup_member (binfo, name, 0, false);\n \t  if (!decl)\n \t    {\n-\t      error (\"no members matching %<%T::%D%> in %q#T\", scope, name, \n+\t      error (\"no members matching %<%T::%D%> in %q#T\", scope, name,\n \t\t     scope);\n \t      return NULL_TREE;\n \t    }\n@@ -4796,7 +4796,7 @@ pushtag (tree name, tree type, tag_scope scope)\n     b = b->level_chain;\n \n   gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n-  \n+\n   /* Do C++ gratuitous typedefing.  */\n   if (IDENTIFIER_TYPE_VALUE (name) != type)\n     {\n@@ -4807,7 +4807,7 @@ pushtag (tree name, tree type, tag_scope scope)\n       if (! context)\n \t{\n \t  tree cs = current_scope ();\n-\t  \n+\n \t  if (scope == ts_current)\n \t    context = cs;\n \t  else if (cs != NULL_TREE && TYPE_P (cs))\n@@ -4844,7 +4844,7 @@ pushtag (tree name, tree type, tag_scope scope)\n \t(type, scope == ts_within_enclosing_non_class, b);\n       if (decl == error_mark_node)\n \tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-\t  \n+\n       if (! in_class)\n \tset_identifier_type_value_with_scope (name, tdef, b);\n \n@@ -4879,11 +4879,11 @@ pushtag (tree name, tree type, tag_scope scope)\n     {\n       maybe_add_class_template_decl_list (current_class_type,\n \t\t\t\t\t  type, /*friend_p=*/0);\n-      \n+\n       if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n \tCLASSTYPE_NESTED_UTDS (current_class_type)\n \t  = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-      \n+\n       binding_table_insert\n \t(CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n     }"}, {"sha": "0d99f9beafa864bd1dc40203b0081adc820dc9a9", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -121,7 +121,7 @@ typedef enum scope_kind {\n \t\t\tspecialization.  Since, by definition, an\n \t\t\texplicit specialization is introduced by\n \t\t\t\"template <>\", this scope is always empty.  */\n-  sk_omp             /* An OpenMP structured block.  */\n+  sk_omp\t     /* An OpenMP structured block.  */\n } scope_kind;\n \n /* The scope where the class/struct/union/enum tag applies.  */"}, {"sha": "ee807295e6b620d1a10d6271e3bb31c5eb754daa", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 66, "deletions": 77, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -513,7 +513,7 @@ cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n \n   /* N is 1-based, not zero-based.  */\n   gcc_assert (n > 0);\n-  \n+\n   if (cp_lexer_debugging_p (lexer))\n     fprintf (cp_lexer_debug_stream,\n \t     \"cp_lexer: peeking ahead %ld at token: \", (long)n);\n@@ -2132,8 +2132,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser, tree scope, tree id)\n    form `ID a', where `ID' is an id-expression and `a' is a plain identifier.\n    Usually, `ID' should name a type, but if we got here it means that it\n    does not. We try to emit the best possible error message depending on\n-   how exactly the id-expression looks like.\n-*/\n+   how exactly the id-expression looks like.  */\n \n static bool\n cp_parser_parse_and_diagnose_invalid_type_name (cp_parser *parser)\n@@ -2455,7 +2454,7 @@ cp_parser_make_typename_type (cp_parser *parser, tree scope, tree id)\n   if (TREE_CODE (id) == IDENTIFIER_NODE)\n     {\n       result = make_typename_type (scope, id, typename_type,\n-                                   /*complain=*/tf_none);\n+\t\t\t\t   /*complain=*/tf_none);\n       if (result == error_mark_node)\n \tcp_parser_diagnose_invalid_type_name (parser, scope, id);\n       return result;\n@@ -2711,33 +2710,33 @@ cp_parser_translation_unit (cp_parser* parser)\n     }\n \n   cp_parser_declaration_seq_opt (parser);\n-  \n+\n   /* If there are no tokens left then all went well.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n     {\n       /* Get rid of the token array; we don't need it any more.  */\n       cp_lexer_destroy (parser->lexer);\n       parser->lexer = NULL;\n-      \n+\n       /* This file might have been a context that's implicitly extern\n-         \"C\".  If so, pop the lang context.  (Only relevant for PCH.) */\n+\t \"C\".  If so, pop the lang context.  (Only relevant for PCH.) */\n       if (parser->implicit_extern_c)\n-        {\n-          pop_lang_context ();\n-          parser->implicit_extern_c = false;\n-        }\n-      \n+\t{\n+\t  pop_lang_context ();\n+\t  parser->implicit_extern_c = false;\n+\t}\n+\n       /* Finish up.  */\n       finish_translation_unit ();\n-      \n+\n       success = true;\n     }\n   else\n     {\n       cp_parser_error (parser, \"expected declaration\");\n       success = false;\n     }\n-  \n+\n   /* Make sure the declarator obstack was fully cleaned up.  */\n   gcc_assert (obstack_next_free (&declarator_obstack)\n \t      == declarator_obstack_base);\n@@ -3094,7 +3093,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      }\n \t  }\n \n-\tdecl = (finish_id_expression \n+\tdecl = (finish_id_expression\n \t\t(id_expression, decl, parser->scope,\n \t\t idk,\n \t\t parser->integral_constant_expression_p,\n@@ -3292,7 +3291,7 @@ static tree\n cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t  bool template_keyword_p,\n \t\t\t  bool check_dependency_p,\n-\t\t\t  bool declarator_p, \n+\t\t\t  bool declarator_p,\n \t\t\t  bool optional_p)\n {\n   cp_token *token;\n@@ -3691,7 +3690,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t\terror (\"%qD used without template parameters\", decl);\n \t\t      else if (ambiguous_decls)\n \t\t\t{\n-\t\t\t  error (\"reference to %qD is ambiguous\", \n+\t\t\t  error (\"reference to %qD is ambiguous\",\n \t\t\t\t token->value);\n \t\t\t  print_candidates (ambiguous_decls);\n \t\t\t  decl = error_mark_node;\n@@ -3773,7 +3772,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n       /* Purge all subsequent tokens.  */\n       cp_lexer_purge_tokens_after (parser->lexer, start);\n     }\n-  \n+\n   if (start)\n     pop_to_parent_deferring_access_checks ();\n \n@@ -4133,8 +4132,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t  }\n \n \t/* It must be a primary-expression.  */\n-\tpostfix_expression \n-\t  = cp_parser_primary_expression (parser, address_p, cast_p, \n+\tpostfix_expression\n+\t  = cp_parser_primary_expression (parser, address_p, cast_p,\n \t\t\t\t\t  /*template_arg_p=*/false,\n \t\t\t\t\t  &idk);\n       }\n@@ -4507,8 +4506,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t pseudo-destructor-name.  */\n       bool template_p;\n       /* Parse the id-expression.  */\n-      name = (cp_parser_id_expression \n-\t      (parser, \n+      name = (cp_parser_id_expression\n+\t      (parser,\n \t       cp_parser_optional_template_keyword (parser),\n \t       /*check_dependency_p=*/true,\n \t       &template_p,\n@@ -5969,8 +5968,7 @@ cp_parser_constant_expression (cp_parser* parser,\n    offsetof-member-designator:\n      id-expression\n      | offsetof-member-designator \".\" id-expression\n-     | offsetof-member-designator \"[\" expression \"]\"\n-*/\n+     | offsetof-member-designator \"[\" expression \"]\"  */\n \n static tree\n cp_parser_builtin_offsetof (cp_parser *parser)\n@@ -6061,7 +6059,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n      declaration-statement\n      try-block\n \n-  IN_COMPOUND is true when the statement is nested inside a \n+  IN_COMPOUND is true when the statement is nested inside a\n   cp_parser_compound_statement; this matters for certain pragmas.  */\n \n static void\n@@ -6149,7 +6147,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n       /* Only certain OpenMP pragmas are attached to statements, and thus\n \t are considered statements themselves.  All others are not.  In\n \t the context of a compound, accept the pragma as a \"statement\" and\n-\t return so that we can check for a close brace.  Otherwise we \n+\t return so that we can check for a close brace.  Otherwise we\n \t require a real statement and must go back and read one.  */\n       if (in_compound)\n \tcp_parser_pragma (parser, pragma_compound);\n@@ -6545,7 +6543,7 @@ cp_parser_condition (cp_parser* parser)\n \t\t\t     attributes, /*prefix_attributes=*/NULL_TREE,\n \t\t\t     &pushed_scope);\n \t  /* Parse the assignment-expression.  */\n-\t  initializer \n+\t  initializer\n \t    = cp_parser_constant_expression (parser,\n \t\t\t\t\t     /*allow_non_constant_p=*/true,\n \t\t\t\t\t     &non_constant_p);\n@@ -6554,7 +6552,7 @@ cp_parser_condition (cp_parser* parser)\n \n \t  /* Process the initializer.  */\n \t  cp_finish_decl (decl,\n-\t\t\t  initializer, !non_constant_p, \n+\t\t\t  initializer, !non_constant_p,\n \t\t\t  asm_specification,\n \t\t\t  LOOKUP_ONLYCONVERTING);\n \n@@ -7673,8 +7671,8 @@ cp_parser_function_specifier_opt (cp_parser* parser,\n \n     case RID_VIRTUAL:\n       /* 14.5.2.3 [temp.mem]\n-\t \n-         A member function template shall not be virtual.  */\n+\n+\t A member function template shall not be virtual.  */\n       if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \terror (\"templates may not be %<virtual%>\");\n       else if (decl_specs)\n@@ -9062,8 +9060,8 @@ cp_parser_template_argument_list (cp_parser* parser)\n   saved_in_template_argument_list_p = parser->in_template_argument_list_p;\n   parser->in_template_argument_list_p = true;\n   /* Even if the template-id appears in an integral\n-     constant-expression, the contents of the argument list do \n-     not.  */ \n+     constant-expression, the contents of the argument list do\n+     not.  */\n   saved_ice_p = parser->integral_constant_expression_p;\n   parser->integral_constant_expression_p = false;\n   saved_non_ice_p = parser->non_integral_constant_expression_p;\n@@ -9268,7 +9266,7 @@ cp_parser_template_argument (cp_parser* parser)\n \n \t  if (TREE_CODE (argument) == BASELINK)\n \t    /* We don't need the information about what class was used\n-\t       to name the overloaded functions.  */  \n+\t       to name the overloaded functions.  */\n \t    argument = BASELINK_FUNCTIONS (argument);\n \n \t  if (TREE_CODE (argument) == VAR_DECL)\n@@ -9400,7 +9398,7 @@ cp_parser_explicit_instantiation (cp_parser* parser)\n       pop_deferring_access_checks ();\n       if (type)\n \tdo_type_instantiation (type, extension_specifier,\n-                               /*complain=*/tf_error);\n+\t\t\t       /*complain=*/tf_error);\n     }\n   else\n     {\n@@ -9465,9 +9463,9 @@ cp_parser_explicit_specialization (cp_parser* parser)\n   /* We have processed another parameter list.  */\n   ++parser->num_template_parameter_lists;\n   /* [temp]\n-   \n+\n      A template ... explicit specialization ... shall not have C\n-     linkage.  */ \n+     linkage.  */\n   if (current_lang_name == lang_name_c)\n     {\n       error (\"template specialization with C linkage\");\n@@ -10249,13 +10247,13 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t    warning (OPT_Wattributes,\n \t\t     \"type attributes are honored only at type definition\");\n \n-\t  template_p = \n+\t  template_p =\n \t    (parser->num_template_parameter_lists\n \t     && (cp_parser_next_token_starts_class_definition_p (parser)\n \t\t || cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)));\n \t  /* An unqualified name was used to reference this type, so\n \t     there were no qualifying templates.  */\n-\t  if (!cp_parser_check_template_parameters (parser, \n+\t  if (!cp_parser_check_template_parameters (parser,\n \t\t\t\t\t\t    /*num_templates=*/0))\n \t    return error_mark_node;\n \t  type = xref_tag (tag_type, identifier, ts, template_p);\n@@ -11537,7 +11535,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t  abstract_ok = (dcl_kind == CP_PARSER_DECLARATOR_EITHER);\n \t  if (abstract_ok)\n \t    cp_parser_parse_tentatively (parser);\n-\t  unqualified_name \n+\t  unqualified_name\n \t    = cp_parser_declarator_id (parser, /*optional_p=*/abstract_ok);\n \t  qualifying_scope = parser->scope;\n \t  if (abstract_ok)\n@@ -11658,7 +11656,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t    *ctor_dtor_or_conv_p = -1;\n \t\t}\n \t    }\n-\t  declarator = make_id_declarator (qualifying_scope, \n+\t  declarator = make_id_declarator (qualifying_scope,\n \t\t\t\t\t   unqualified_name,\n \t\t\t\t\t   sfk);\n \t  declarator->id_loc = token->location;\n@@ -12825,7 +12823,7 @@ cp_parser_class_name (cp_parser *parser,\n   if (typename_p && decl != error_mark_node)\n     {\n       decl = make_typename_type (scope, decl, typename_type,\n-                                 /*complain=*/tf_error);\n+\t\t\t\t /*complain=*/tf_error);\n       if (decl != error_mark_node)\n \tdecl = TYPE_NAME (decl);\n     }\n@@ -12968,7 +12966,7 @@ cp_parser_class_specifier (cp_parser* parser)\n       tree fn;\n       tree class_type = NULL_TREE;\n       tree pushed_scope = NULL_TREE;\n- \n+\n       /* In a first pass, parse default arguments to the functions.\n \t Then, in a second pass, parse the bodies of the functions.\n \t This two-phased approach handles cases like:\n@@ -13879,7 +13877,7 @@ cp_parser_pure_specifier (cp_parser* parser)\n   /* c_lex_with_flags marks a single digit '0' with PURE_ZERO.  */\n   if (token->type != CPP_NUMBER || !(token->flags & PURE_ZERO))\n     {\n-      cp_parser_error (parser, \n+      cp_parser_error (parser,\n \t\t       \"invalid pure specifier (only `= 0' is allowed)\");\n       cp_parser_skip_to_end_of_statement (parser);\n       return error_mark_node;\n@@ -14754,12 +14752,12 @@ cp_parser_label_declaration (cp_parser* parser)\n \n    If AMBIGUOUS_DECLS is non-NULL, *AMBIGUOUS_DECLS is set to a\n    TREE_LIST of candidates if name-lookup results in an ambiguity, and\n-   NULL_TREE otherwise.  */ \n+   NULL_TREE otherwise.  */\n \n static tree\n cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       enum tag_types tag_type,\n-\t\t       bool is_template, \n+\t\t       bool is_template,\n \t\t       bool is_namespace,\n \t\t       bool check_dependency,\n \t\t       tree *ambiguous_decls)\n@@ -15447,7 +15445,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   if (!cp_parser_require (parser, CPP_LESS, \"`<'\"))\n     return;\n   /* [temp]\n-   \n+\n      A template ... shall not have C linkage.  */\n   if (current_lang_name == lang_name_c)\n     {\n@@ -15993,7 +15991,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n \n       if (!processing_template_decl)\n \tparsed_arg = check_default_argument (TREE_VALUE (parm), parsed_arg);\n-      \n+\n       TREE_PURPOSE (parm) = parsed_arg;\n \n       /* Update any instantiations we've already created.  */\n@@ -16158,7 +16156,7 @@ cp_parser_set_storage_class (cp_parser *parser,\n       decl_specs->specs[(int) ds_thread] = 0;\n     }\n \n-  switch (keyword) \n+  switch (keyword)\n     {\n     case RID_AUTO:\n       storage_class = sc_auto;\n@@ -16924,7 +16922,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n   token = cp_lexer_peek_token (parser->lexer);\n \n   while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n-         || token->type == CPP_SCOPE)\n+\t || token->type == CPP_SCOPE)\n     {\n       tree selector = NULL_TREE;\n \n@@ -16933,7 +16931,7 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n \tselector = cp_parser_objc_selector (parser);\n \n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON)\n-          && cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n \t{\n \t  /* Detect if we have a unary selector.  */\n \t  if (maybe_unary_selector_p)\n@@ -16948,9 +16946,9 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n \t}\n       maybe_unary_selector_p = false;\n       token = cp_lexer_consume_token (parser->lexer);\n-      \n+\n       if (token->type == CPP_SCOPE)\n-        {\n+\t{\n \t  sel_seq\n \t    = chainon (sel_seq,\n \t\t       build_tree_list (selector, NULL_TREE));\n@@ -17457,7 +17455,7 @@ cp_parser_objc_class_ivars (cp_parser* parser)\n \t      cplus_decl_attributes (&decl, attributes, /*flags=*/0);\n \t    }\n \t  else\n-\t    decl = grokfield (declarator, &declspecs, \n+\t    decl = grokfield (declarator, &declspecs,\n \t\t\t      NULL_TREE, /*init_const_expr_p=*/false,\n \t\t\t      NULL_TREE, attributes);\n \n@@ -17822,7 +17820,7 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \tcase 'c':\n \t  if (!strcmp (\"copyin\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYIN;\n-          else if (!strcmp (\"copyprivate\", p))\n+\t  else if (!strcmp (\"copyprivate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_COPYPRIVATE;\n \t  break;\n \tcase 'f':\n@@ -18001,7 +17999,7 @@ cp_parser_omp_clause_default (cp_parser *parser, tree list)\n     cp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t   /*or_comma=*/false,\n \t\t\t\t\t   /*consume_paren=*/true);\n-  \n+\n   if (kind == OMP_CLAUSE_DEFAULT_UNSPECIFIED)\n     return list;\n \n@@ -18165,8 +18163,7 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n    schedule ( schedule-kind , expression )\n \n    schedule-kind:\n-     static | dynamic | guided | runtime\n-*/\n+     static | dynamic | guided | runtime  */\n \n static tree\n cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n@@ -18191,7 +18188,7 @@ cp_parser_omp_clause_schedule (cp_parser *parser, tree list)\n \t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n \t  break;\n \n-        case 'g':\n+\tcase 'g':\n \t  if (strcmp (\"guided\", p) != 0)\n \t    goto invalid_kind;\n \t  OMP_CLAUSE_SCHEDULE_KIND (c) = OMP_CLAUSE_SCHEDULE_GUIDED;\n@@ -18476,8 +18473,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n \n \n /* OpenMP 2.5:\n-   # pragma omp barrier new-line\n-*/\n+   # pragma omp barrier new-line  */\n \n static void\n cp_parser_omp_barrier (cp_parser *parser, cp_token *pragma_tok)\n@@ -18488,8 +18484,7 @@ cp_parser_omp_barrier (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 2.5:\n    # pragma omp critical [(name)] new-line\n-     structured-block\n-*/\n+     structured-block  */\n \n static tree\n cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n@@ -18501,7 +18496,7 @@ cp_parser_omp_critical (cp_parser *parser, cp_token *pragma_tok)\n       cp_lexer_consume_token (parser->lexer);\n \n       name = cp_parser_identifier (parser);\n-      \n+\n       if (name == error_mark_node\n \t  || !cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\"))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n@@ -18633,8 +18628,7 @@ cp_parser_omp_for_loop (cp_parser *parser)\n \n /* OpenMP 2.5:\n    #pragma omp for for-clause[optseq] new-line\n-     for-loop\n-*/\n+     for-loop  */\n \n #define OMP_FOR_CLAUSE_MASK\t\t\t\t\\\n \t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n@@ -18669,8 +18663,7 @@ cp_parser_omp_for (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 2.5:\n    # pragma omp master new-line\n-     structured-block\n-*/\n+     structured-block  */\n \n static tree\n cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n@@ -18681,8 +18674,7 @@ cp_parser_omp_master (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 2.5:\n    # pragma omp ordered new-line\n-     structured-block\n-*/\n+     structured-block  */\n \n static tree\n cp_parser_omp_ordered (cp_parser *parser, cp_token *pragma_tok)\n@@ -18721,7 +18713,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n \n       while (1)\n \t{\n-          cp_parser_statement (parser, NULL_TREE, false);\n+\t  cp_parser_statement (parser, NULL_TREE, false);\n \n \t  tok = cp_lexer_peek_token (parser->lexer);\n \t  if (tok->pragma_kind == PRAGMA_OMP_SECTION)\n@@ -18776,8 +18768,7 @@ cp_parser_omp_sections_scope (cp_parser *parser)\n \n /* OpenMP 2.5:\n    # pragma omp sections sections-clause[optseq] newline\n-     sections-scope\n-*/\n+     sections-scope  */\n \n #define OMP_SECTIONS_CLAUSE_MASK\t\t\t\\\n \t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n@@ -18804,8 +18795,7 @@ cp_parser_omp_sections (cp_parser *parser, cp_token *pragma_tok)\n /* OpenMP 2.5:\n    # pragma parallel parallel-clause new-line\n    # pragma parallel for parallel-for-clause new-line\n-   # pragma parallel sections parallel-sections-clause new-line\n-*/\n+   # pragma parallel sections parallel-sections-clause new-line  */\n \n #define OMP_PARALLEL_CLAUSE_MASK\t\t\t\\\n \t( (1u << PRAGMA_OMP_CLAUSE_IF)\t\t\t\\\n@@ -18886,8 +18876,7 @@ cp_parser_omp_parallel (cp_parser *parser, cp_token *pragma_tok)\n \n /* OpenMP 2.5:\n    # pragma omp single single-clause[optseq] new-line\n-     structured-block\n-*/\n+     structured-block  */\n \n #define OMP_SINGLE_CLAUSE_MASK\t\t\t\t\\\n \t( (1u << PRAGMA_OMP_CLAUSE_PRIVATE)\t\t\\\n@@ -18977,7 +18966,7 @@ static GTY (()) cp_parser *the_parser;\n    PCH file, which is a GC collection point.  So we need to handle this\n    first pragma without benefit of an existing lexer structure.\n \n-   Always returns one token to the caller in *FIRST_TOKEN.  This is \n+   Always returns one token to the caller in *FIRST_TOKEN.  This is\n    either the true first token of the file, or the first token after\n    the initial pragma.  */\n "}, {"sha": "8b2f0d3054e45270973e7c99cff96935694175d0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -104,7 +104,7 @@ static tree classtype_mangled_name (tree);\n static char* mangle_class_name_for_template (const char *, tree, tree);\n static tree tsubst_initializer_list (tree, tree);\n static tree get_class_bindings (tree, tree, tree);\n-static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t, \n+static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t,\n \t\t\t\t   bool, bool);\n static void tsubst_enum\t(tree, tree, tree);\n static tree add_to_template_args (tree, tree);\n@@ -658,7 +658,7 @@ check_explicit_instantiation_namespace (tree spec)\n   tree ns;\n \n   /* DR 275: An explicit instantiation shall appear in an enclosing\n-     namespace of its template.  */ \n+     namespace of its template.  */\n   ns = decl_namespace_context (spec);\n   if (!is_ancestor (current_namespace, ns))\n     pedwarn (\"explicit instantiation of %qD in namespace %qD \"\n@@ -895,7 +895,7 @@ static tree\n retrieve_local_specialization (tree tmpl)\n {\n   tree spec = (tree) htab_find_with_hash (local_specializations, tmpl,\n-                                          htab_hash_pointer (tmpl));\n+\t\t\t\t\t  htab_hash_pointer (tmpl));\n   return spec ? TREE_PURPOSE (spec) : NULL_TREE;\n }\n \n@@ -1187,15 +1187,15 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend)\n \t      DECL_INITIAL (fn) = NULL_TREE;\n \t      duplicate_decls (spec, fn, is_friend);\n \t      /* The call to duplicate_decls will have applied\n-\t\t [temp.expl.spec]: \n+\t\t [temp.expl.spec]:\n \n-  \t           An explicit specialization of a function template\n+\t\t   An explicit specialization of a function template\n \t\t   is inline only if it is explicitly declared to be,\n \t\t   and independently of whether its function template\n \t\t   is.\n \n \t\tto the primary function; now copy the inline bits to\n-\t\tthe various clones.  */   \n+\t\tthe various clones.  */\n \t      FOR_EACH_CLONE (clone, fn)\n \t\t{\n \t\t  DECL_DECLARED_INLINE_P (clone)\n@@ -1451,7 +1451,7 @@ determine_specialization (tree template_id,\n \t  if (current_binding_level->kind == sk_template_parms\n \t      && !current_binding_level->explicit_spec_p\n \t      && (TREE_VEC_LENGTH (DECL_INNERMOST_TEMPLATE_PARMS (fn))\n-\t\t  != TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS \n+\t\t  != TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS\n \t\t\t\t      (current_template_parms))))\n \t    continue;\n \n@@ -2150,14 +2150,14 @@ check_explicit_specialization (tree declarator,\n \t  /* If DECL is a friend declaration, declared using an\n \t     unqualified name, the namespace associated with DECL may\n \t     have been set incorrectly.  For example, in:\n-\t     \n-\t       template <typename T> void f(T); \n-               namespace N {\n-  \t         struct S { friend void f<int>(int); }\n-               }\n-\n-             we will have set the DECL_CONTEXT for the friend\n-             declaration to N, rather than to the global namespace.  */\n+\n+\t       template <typename T> void f(T);\n+\t       namespace N {\n+\t\t struct S { friend void f<int>(int); }\n+\t       }\n+\n+\t     we will have set the DECL_CONTEXT for the friend\n+\t     declaration to N, rather than to the global namespace.  */\n \t  if (DECL_NAMESPACE_SCOPE_P (decl))\n \t    DECL_CONTEXT (decl) = DECL_CONTEXT (tmpl);\n \n@@ -3962,7 +3962,7 @@ convert_template_argument (tree parm,\n \tval = arg;\n       /* We only form one instance of each template specialization.\n \t Therefore, if we use a non-canonical variant (i.e., a\n-\t typedef), any future messages referring to the type will use \n+\t typedef), any future messages referring to the type will use\n \t the typedef, which is confusing if those future uses do not\n \t themselves also use the typedef.  */\n       if (TYPE_P (val))\n@@ -4464,7 +4464,7 @@ lookup_template_class (tree d1,\n \targlist = add_to_template_args (current_template_args (), arglist);\n \n       arglist2 = coerce_template_parms (parmlist, arglist, template,\n-\t\t\t\t\tcomplain, \n+\t\t\t\t\tcomplain,\n \t\t\t\t\t/*require_all_args=*/true,\n \t\t\t\t\t/*use_default_args=*/true);\n       if (arglist2 == error_mark_node\n@@ -4535,7 +4535,7 @@ lookup_template_class (tree d1,\n \t    {\n \t      tree a = coerce_template_parms (TREE_VALUE (t),\n \t\t\t\t\t      arglist, template,\n-\t\t\t\t\t      complain, \n+\t\t\t\t\t      complain,\n \t\t\t\t\t      /*require_all_args=*/true,\n \t\t\t\t\t      /*use_default_args=*/true);\n \n@@ -4566,7 +4566,7 @@ lookup_template_class (tree d1,\n \t  = coerce_template_parms (INNERMOST_TEMPLATE_PARMS (parmlist),\n \t\t\t\t   INNERMOST_TEMPLATE_ARGS (arglist),\n \t\t\t\t   template,\n-\t\t\t\t   complain, \n+\t\t\t\t   complain,\n \t\t\t\t   /*require_all_args=*/true,\n \t\t\t\t   /*use_default_args=*/true);\n \n@@ -5539,12 +5539,12 @@ instantiate_class_template (tree type)\n \t specialization.  We replace the innermost set of ARGS with\n \t the arguments appropriate for substitution.  For example,\n \t given:\n-       \n-           template <class T> struct S {};\n+\n+\t   template <class T> struct S {};\n \t   template <class T> struct S<T*> {};\n \n \t and supposing that we are instantiating S<int*>, ARGS will\n-         presently be {int*} -- but we need {int}.  */\n+\t presently be {int*} -- but we need {int}.  */\n       pattern = TREE_TYPE (t);\n       args = TREE_PURPOSE (t);\n     }\n@@ -5762,15 +5762,15 @@ instantiate_class_template (tree type)\n \t\t\t   not occur unless the static data member is\n \t\t\t   itself used in a way that requires the\n \t\t\t   definition of the static data member to\n-\t\t\t   exist.  \n+\t\t\t   exist.\n \n \t\t\t Therefore, we do not substitute into the\n-\t\t         initialized for the static data member here.  */\n-\t\t      finish_static_data_member_decl \n-\t\t\t(r, \n-\t\t\t /*init=*/NULL_TREE, \n+\t\t\t initialized for the static data member here.  */\n+\t\t      finish_static_data_member_decl\n+\t\t\t(r,\n+\t\t\t /*init=*/NULL_TREE,\n \t\t\t /*init_const_expr_p=*/false,\n-\t\t\t /*asmspec_tree=*/NULL_TREE, \n+\t\t\t /*asmspec_tree=*/NULL_TREE,\n \t\t\t /*flags=*/0);\n \t\t      if (DECL_INITIALIZED_IN_CLASS_P (r))\n \t\t\tcheck_static_variable_definition (r, TREE_TYPE (r));\n@@ -6133,7 +6133,7 @@ tsubst_aggr_type (tree t,\n \t\t\t\t\t entering_scope, complain);\n \t      r = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n \t    }\n-\t  \n+\n \t  skip_evaluation = saved_skip_evaluation;\n \n \t  return r;\n@@ -6322,7 +6322,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    tree new_type;\n \t    ++processing_template_decl;\n \t    new_type = tsubst (TREE_TYPE (t), args, complain, in_decl);\n-\t    --processing_template_decl; \n+\t    --processing_template_decl;\n \t    if (new_type == error_mark_node)\n \t      return error_mark_node;\n \n@@ -6345,7 +6345,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    DECL_TI_TEMPLATE (new_decl) = r;\n \t    TREE_TYPE (r) = TREE_TYPE (new_decl);\n \t    DECL_TI_ARGS (r) = DECL_TI_ARGS (new_decl);\n-\t    DECL_CONTEXT (r) = DECL_CONTEXT (new_decl); \n+\t    DECL_CONTEXT (r) = DECL_CONTEXT (new_decl);\n \t  }\n \n \tSET_DECL_IMPLICIT_INSTANTIATION (r);\n@@ -6745,7 +6745,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t      {\n \t\ttree ve = DECL_VALUE_EXPR (t);\n \t\tve = tsubst_expr (ve, args, complain, in_decl);\n-\t        SET_DECL_VALUE_EXPR (r, ve);\n+\t\tSET_DECL_VALUE_EXPR (r, ve);\n \t      }\n \t  }\n \telse if (DECL_SELF_REFERENCE_P (t))\n@@ -7674,8 +7674,8 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     expr = name;\n \n   if (dependent_type_p (scope))\n-    return build_qualified_name (/*type=*/NULL_TREE, \n-\t\t\t\t scope, expr, \n+    return build_qualified_name (/*type=*/NULL_TREE,\n+\t\t\t\t scope, expr,\n \t\t\t\t QUALIFIED_NAME_IS_TEMPLATE (qualified_id));\n \n   if (!BASELINK_P (name) && !DECL_P (expr))\n@@ -7726,7 +7726,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     {\n       expr = (adjust_result_of_qualified_name_lookup\n \t      (expr, scope, current_class_type));\n-      expr = (finish_qualified_id_expr \n+      expr = (finish_qualified_id_expr\n \t      (scope, expr, done, address_p,\n \t       QUALIFIED_NAME_IS_TEMPLATE (qualified_id),\n \t       /*template_arg_p=*/false));\n@@ -7917,7 +7917,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t\t\t\tcomplain, in_decl);\n \t    name = build1 (BIT_NOT_EXPR, NULL_TREE, name);\n \t    name = build_qualified_name (/*type=*/NULL_TREE,\n-\t\t\t\t\t base, name, \n+\t\t\t\t\t base, name,\n \t\t\t\t\t /*template_p=*/false);\n \t  }\n \telse if (TREE_CODE (name) == BASELINK)\n@@ -8885,7 +8885,7 @@ tsubst_copy_and_build (tree t,\n \t      }\n \t    else\n \t      qualified_p = false;\n-\t    \n+\n \t    function = tsubst_copy_and_build (function, args, complain,\n \t\t\t\t\t      in_decl,\n \t\t\t\t\t      !qualified_p);\n@@ -9191,14 +9191,14 @@ check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n \t  if (nt)\n \t    {\n \t      /* DR 488 makes use of a type with no linkage cause\n-\t\t type deduction to fail.  */ \n+\t\t type deduction to fail.  */\n \t      if (complain & tf_error)\n \t\t{\n \t\t  if (TYPE_ANONYMOUS_P (nt))\n \t\t    error (\"%qT is/uses anonymous type\", t);\n \t\t  else\n \t\t    error (\"template argument for %qD uses local type %qT\",\n-                           tmpl, t);\n+\t\t\t   tmpl, t);\n \t\t}\n \t      result = true;\n \t    }\n@@ -9623,10 +9623,10 @@ type_unification_real (tree tparms,\n \t  if (same_type_p (parm, type))\n \t    continue;\n \t  if (strict != DEDUCE_EXACT\n-\t      && can_convert_arg (parm, type, TYPE_P (arg) ? NULL_TREE : arg, \n+\t      && can_convert_arg (parm, type, TYPE_P (arg) ? NULL_TREE : arg,\n \t\t\t\t  flags))\n \t    continue;\n-\t  \n+\n \t  return 1;\n \t}\n \n@@ -10183,8 +10183,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t\t\t    typename Block>\n \t\t  void operator+(float, View<Block> const&);\n \n-\t\t  template <typename Block, \n-\t\t            unsigned int Dim = Block::dim>\n+\t\t  template <typename Block,\n+\t\t\t    unsigned int Dim = Block::dim>\n \t\t  struct Lvalue_proxy { operator float() const; };\n \n \t\t  void\n@@ -10196,8 +10196,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \n \t      Here, if Lvalue_proxy is permitted to bind to View, then\n \t      the global operator+ will be used; if they are not, the\n-\t      Lvalue_proxy will be converted to float.  */\t  \n-\t    if (coerce_template_parms (argtmplvec, parmvec, \n+\t      Lvalue_proxy will be converted to float.  */\n+\t    if (coerce_template_parms (argtmplvec, parmvec,\n \t\t\t\t       TYPE_TI_TEMPLATE (parm),\n \t\t\t\t       tf_none,\n \t\t\t\t       /*require_all_args=*/true,\n@@ -10513,9 +10513,9 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \treturn 1;\n \n       /* CV qualifications for methods can never be deduced, they must\n-  \t match exactly.  We need to check them explicitly here,\n-  \t because type_unification_real treats them as any other\n-  \t cvqualified parameter.  */\n+\t match exactly.  We need to check them explicitly here,\n+\t because type_unification_real treats them as any other\n+\t cvqualified parameter.  */\n       if (TREE_CODE (parm) == METHOD_TYPE\n \t  && (!check_cv_quals_for_unify\n \t      (UNIFY_ALLOW_NONE,\n@@ -10706,7 +10706,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n   tree args2 = TYPE_ARG_TYPES (TREE_TYPE (decl2));\n   int better1 = 0;\n   int better2 = 0;\n-  \n+\n   /* Remove the this parameter from non-static member functions.  If\n      one is a non-static member function and the other is not a static\n      member function, remove the first parameter from that function\n@@ -10729,7 +10729,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n \t  args1 = TREE_CHAIN (args1);\n \t}\n     }\n-    \n+\n   /* If only one is a conversion operator, they are unordered.  */\n   if (DECL_CONV_FN_P (decl1) != DECL_CONV_FN_P (decl2))\n     return 0;\n@@ -10854,7 +10854,7 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n    specialized.\n \n    See [temp.class.order] for information about determining which of\n-   two templates is more specialized.  */ \n+   two templates is more specialized.  */\n \n static int\n more_specialized_class (tree pat1, tree pat2)\n@@ -10871,13 +10871,13 @@ more_specialized_class (tree pat1, tree pat2)\n      types in the arguments, and we need our dependency check functions\n      to behave correctly.  */\n   ++processing_template_decl;\n-  targs = get_class_bindings (TREE_VALUE (pat1), \n+  targs = get_class_bindings (TREE_VALUE (pat1),\n \t\t\t      CLASSTYPE_TI_ARGS (tmpl1),\n \t\t\t      CLASSTYPE_TI_ARGS (tmpl2));\n   if (targs)\n     --winner;\n \n-  targs = get_class_bindings (TREE_VALUE (pat2), \n+  targs = get_class_bindings (TREE_VALUE (pat2),\n \t\t\t      CLASSTYPE_TI_ARGS (tmpl2),\n \t\t\t      CLASSTYPE_TI_ARGS (tmpl1));\n   if (targs)\n@@ -10919,7 +10919,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n       converted_args\n \t= coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n \t\t\t\t explicit_args, NULL_TREE,\n-\t\t\t\t tf_none, \n+\t\t\t\t tf_none,\n \t\t\t\t /*require_all_args=*/false,\n \t\t\t\t /*use_default_args=*/false);\n       if (converted_args == error_mark_node)\n@@ -10976,11 +10976,11 @@ get_class_bindings (tree tparms, tree spec_args, tree args)\n \t\t\t   innermost_deduced_args);\n     }\n   else\n-    deduced_args = innermost_deduced_args; \n+    deduced_args = innermost_deduced_args;\n \n-  if (unify (tparms, deduced_args, \n-\t     INNERMOST_TEMPLATE_ARGS (spec_args), \n-\t     INNERMOST_TEMPLATE_ARGS (args), \n+  if (unify (tparms, deduced_args,\n+\t     INNERMOST_TEMPLATE_ARGS (spec_args),\n+\t     INNERMOST_TEMPLATE_ARGS (args),\n \t     UNIFY_ALLOW_NONE))\n     return NULL_TREE;\n \n@@ -10990,7 +10990,7 @@ get_class_bindings (tree tparms, tree spec_args, tree args)\n \n   /* Verify that nondeduced template arguments agree with the type\n      obtained from argument deduction.\n-     \n+\n      For example:\n \n        struct A { typedef int X; };\n@@ -11168,8 +11168,8 @@ most_specialized_class (tree type, tree tmpl)\n       tree spec_args;\n \n       partial_spec_args = CLASSTYPE_TI_ARGS (TREE_TYPE (t));\n-      spec_args = get_class_bindings (TREE_VALUE (t), \n-\t\t\t\t      partial_spec_args, \n+      spec_args = get_class_bindings (TREE_VALUE (t),\n+\t\t\t\t      partial_spec_args,\n \t\t\t\t      args);\n       if (spec_args)\n \t{\n@@ -11331,11 +11331,11 @@ do_decl_instantiation (tree decl, tree storage)\n     }\n   else\n     error (\"storage class %qD applied to template instantiation\", storage);\n-  \n+\n   check_explicit_instantiation_namespace (result);\n   mark_decl_instantiated (result, extern_p);\n   if (! extern_p)\n-    instantiate_decl (result, /*defer_ok=*/1, \n+    instantiate_decl (result, /*defer_ok=*/1,\n \t\t      /*expl_inst_class_mem_p=*/false);\n }\n \n@@ -11373,7 +11373,7 @@ instantiate_class_member (tree decl, int extern_p)\n {\n   mark_decl_instantiated (decl, extern_p);\n   if (! extern_p)\n-    instantiate_decl (decl, /*defer_ok=*/1, \n+    instantiate_decl (decl, /*defer_ok=*/1,\n \t\t      /*expl_inst_class_mem_p=*/true);\n }\n \n@@ -11671,7 +11671,7 @@ template_for_substitution (tree decl)\n    explicitly instantiated class template.  */\n \n tree\n-instantiate_decl (tree d, int defer_ok, \n+instantiate_decl (tree d, int defer_ok,\n \t\t  bool expl_inst_class_mem_p)\n {\n   tree tmpl = DECL_TI_TEMPLATE (d);\n@@ -11736,9 +11736,9 @@ instantiate_decl (tree d, int defer_ok,\n   code_pattern = DECL_TEMPLATE_RESULT (td);\n \n   /* We should never be trying to instantiate a member of a class\n-     template or partial specialization.  */ \n+     template or partial specialization.  */\n   gcc_assert (d != code_pattern);\n- \n+\n   if ((DECL_NAMESPACE_SCOPE_P (d) && !DECL_INITIALIZED_IN_CLASS_P (d))\n       || DECL_TEMPLATE_SPECIALIZATION (td))\n     /* In the case of a friend template whose definition is provided\n@@ -11769,9 +11769,9 @@ instantiate_decl (tree d, int defer_ok,\n \n   /* If D is a member of an explicitly instantiated class template,\n      and no definition is available, treat it like an implicit\n-     instantiation.  */ \n-  if (!pattern_defined && expl_inst_class_mem_p \n-      && DECL_EXPLICIT_INSTANTIATION (d)) \n+     instantiation.  */\n+  if (!pattern_defined && expl_inst_class_mem_p\n+      && DECL_EXPLICIT_INSTANTIATION (d))\n     {\n       DECL_NOT_REALLY_EXTERN (d) = 0;\n       DECL_INTERFACE_KNOWN (d) = 0;\n@@ -11817,14 +11817,14 @@ instantiate_decl (tree d, int defer_ok,\n       && ! (TREE_CODE (d) == FUNCTION_DECL && DECL_INLINE (d))\n       /* ... we instantiate static data members whose values are\n \t needed in integral constant expressions.  */\n-      && ! (TREE_CODE (d) == VAR_DECL \n+      && ! (TREE_CODE (d) == VAR_DECL\n \t    && DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (d)))\n     goto out;\n   /* Defer all other templates, unless we have been explicitly\n      forbidden from doing so.  */\n   if (/* If there is no definition, we cannot instantiate the\n \t template.  */\n-      ! pattern_defined \n+      ! pattern_defined\n       /* If it's OK to postpone instantiation, do so.  */\n       || defer_ok\n       /* If this is a static data member that will be defined\n@@ -11836,7 +11836,7 @@ instantiate_decl (tree d, int defer_ok,\n       /* The definition of the static data member is now required so\n \t we must substitute the initializer.  */\n       if (TREE_CODE (d) == VAR_DECL\n-\t  && !DECL_INITIAL (d) \n+\t  && !DECL_INITIAL (d)\n \t  && DECL_INITIAL (code_pattern))\n \t{\n \t  tree ns;\n@@ -11845,7 +11845,7 @@ instantiate_decl (tree d, int defer_ok,\n \t  ns = decl_namespace_context (d);\n \t  push_nested_namespace (ns);\n \t  push_nested_class (DECL_CONTEXT (d));\n-\t  init = tsubst_expr (DECL_INITIAL (code_pattern), \n+\t  init = tsubst_expr (DECL_INITIAL (code_pattern),\n \t\t\t      args,\n \t\t\t      tf_warning_or_error, NULL_TREE);\n \t  cp_finish_decl (d, init, /*init_const_expr_p=*/false,\n@@ -12058,7 +12058,7 @@ instantiate_pending_templates (int retries)\n \t\t\t fn;\n \t\t\t fn = TREE_CHAIN (fn))\n \t\t      if (! DECL_ARTIFICIAL (fn))\n-\t\t\tinstantiate_decl (fn, \n+\t\t\tinstantiate_decl (fn,\n \t\t\t\t\t  /*defer_ok=*/0,\n \t\t\t\t\t  /*expl_inst_class_mem_p=*/false);\n \t\t  if (COMPLETE_TYPE_P (instantiation))\n@@ -12080,7 +12080,7 @@ instantiate_pending_templates (int retries)\n \t      if (!DECL_TEMPLATE_SPECIALIZATION (instantiation)\n \t\t  && !DECL_TEMPLATE_INSTANTIATED (instantiation))\n \t\t{\n-\t\t  instantiation \n+\t\t  instantiation\n \t\t    = instantiate_decl (instantiation,\n \t\t\t\t\t/*defer_ok=*/0,\n \t\t\t\t\t/*expl_inst_class_mem_p=*/false);\n@@ -12742,7 +12742,7 @@ type_dependent_expression_p (tree expression)\n     }\n \n   gcc_assert (TREE_CODE (expression) != TYPE_DECL);\n-  \n+\n   return (dependent_type_p (TREE_TYPE (expression)));\n }\n \n@@ -12984,7 +12984,7 @@ build_non_dependent_expr (tree expr)\n \n   /* If the type is unknown, it can't really be non-dependent */\n   gcc_assert (TREE_TYPE (expr) != unknown_type_node);\n-  \n+\n   /* Otherwise, build a NON_DEPENDENT_EXPR.\n \n      REFERENCE_TYPEs are not stripped for expressions in templates"}, {"sha": "246e88b9875acc3441b466f305ec6a5557c84979", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -172,7 +172,7 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n     case BASELINK:\n       print_node (file, \"functions\", BASELINK_FUNCTIONS (node), indent + 4);\n       print_node (file, \"binfo\", BASELINK_BINFO (node), indent + 4);\n-      print_node (file, \"access_binfo\", BASELINK_ACCESS_BINFO (node), \n+      print_node (file, \"access_binfo\", BASELINK_ACCESS_BINFO (node),\n \t\t  indent + 4);\n       break;\n     case OVERLOAD:"}, {"sha": "898db00f3110554460e43afd99ebd7dcd8e46b7b", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -89,8 +89,8 @@ typedef enum tinfo_kind\n   TK_POINTER_MEMBER_TYPE, /* abi::__pointer_to_member_type_info */\n   TK_CLASS_TYPE,\t/* abi::__class_type_info */\n   TK_SI_CLASS_TYPE,\t/* abi::__si_class_type_info */\n-  TK_FIXED   \t\t/* end of fixed descriptors. */\n-  /* ... \t\t   abi::__vmi_type_info<I> */\n+  TK_FIXED\t\t/* end of fixed descriptors. */\n+  /* ...\t\t   abi::__vmi_type_info<I> */\n } tinfo_kind;\n \n /* A vector of all tinfo decls that haven't yet been emitted.  */\n@@ -865,7 +865,7 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \t size_binop (MULT_EXPR,\n \t\t     size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),\n \t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n-      \n+\n       ti->vtable = vtable_ptr;\n     }\n \n@@ -890,7 +890,7 @@ static tree\n generic_initializer (tinfo_s *ti, tree target)\n {\n   tree init = tinfo_base_init (ti, target);\n-  \n+\n   init = build_constructor_from_list (NULL_TREE, init);\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n@@ -949,7 +949,7 @@ ptm_initializer (tinfo_s *ti, tree target)\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (klass),\n \t\t    init);\n-  \n+\n   init = build_constructor_from_list (NULL_TREE, nreverse (init));\n   TREE_CONSTANT (init) = 1;\n   TREE_INVARIANT (init) = 1;\n@@ -1007,16 +1007,16 @@ static tree\n get_pseudo_ti_init (tree type, unsigned tk_index)\n {\n   tinfo_s *ti = VEC_index (tinfo_s, tinfo_descs, tk_index);\n-  \n+\n   gcc_assert (at_eof);\n   switch (tk_index)\n     {\n     case TK_POINTER_MEMBER_TYPE:\n       return ptm_initializer (ti, type);\n-      \n+\n     case TK_POINTER_TYPE:\n       return ptr_initializer (ti, type);\n-      \n+\n     case TK_BUILTIN_TYPE:\n     case TK_ENUMERAL_TYPE:\n     case TK_FUNCTION_TYPE:\n@@ -1046,9 +1046,9 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \tVEC(tree,gc) *base_accesses = BINFO_BASE_ACCESSES (binfo);\n \ttree base_inits = NULL_TREE;\n \tint ix;\n-          \n+\n \tgcc_assert (tk_index >= TK_FIXED);\n-      \n+\n \t/* Generate the base information initializer.  */\n \tfor (ix = nbases; ix--;)\n \t  {\n@@ -1057,21 +1057,21 @@ get_pseudo_ti_init (tree type, unsigned tk_index)\n \t    int flags = 0;\n \t    tree tinfo;\n \t    tree offset;\n-\t    \n+\n \t    if (VEC_index (tree, base_accesses, ix) == access_public_node)\n \t      flags |= 2;\n \t    tinfo = get_tinfo_ptr (BINFO_TYPE (base_binfo));\n \t    if (BINFO_VIRTUAL_P (base_binfo))\n \t      {\n \t\t/* We store the vtable offset at which the virtual\n-       \t\t   base offset can be found.  */\n+\t\t   base offset can be found.  */\n \t\toffset = BINFO_VPTR_FIELD (base_binfo);\n \t\toffset = convert (sizetype, offset);\n \t\tflags |= 1;\n \t      }\n \t    else\n \t      offset = BINFO_OFFSET (base_binfo);\n-\t    \n+\n \t    /* Combine offset and flags into one field.  */\n \t    offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n \t\t\t\t\t build_int_cst (NULL_TREE, 8));\n@@ -1167,29 +1167,29 @@ static unsigned\n get_pseudo_ti_index (tree type)\n {\n   unsigned ix;\n-  \n+\n   switch (TREE_CODE (type))\n     {\n     case OFFSET_TYPE:\n       ix = TK_POINTER_MEMBER_TYPE;\n       break;\n-      \n+\n     case POINTER_TYPE:\n       ix = TK_POINTER_TYPE;\n       break;\n-      \n+\n     case ENUMERAL_TYPE:\n       ix = TK_ENUMERAL_TYPE;\n       break;\n-      \n+\n     case FUNCTION_TYPE:\n       ix = TK_FUNCTION_TYPE;\n       break;\n-      \n+\n     case ARRAY_TYPE:\n       ix = TK_ARRAY_TYPE;\n       break;\n-      \n+\n     case UNION_TYPE:\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n@@ -1235,7 +1235,7 @@ get_pseudo_ti_index (tree type)\n \t\t{\n \t\t  /* too short, extend.  */\n \t\t  unsigned len = VEC_length (tinfo_s, tinfo_descs);\n-\t\t  \n+\n \t\t  VEC_safe_grow (tinfo_s, gc, tinfo_descs, ix + 1);\n \t\t  while (VEC_iterate (tinfo_s, tinfo_descs, len++, ti))\n \t\t    ti->type = ti->vtable = ti->name = NULL_TREE;\n@@ -1282,11 +1282,11 @@ static void\n create_tinfo_types (void)\n {\n   tinfo_s *ti;\n-  \n+\n   gcc_assert (!tinfo_descs);\n \n   VEC_safe_grow (tinfo_s, gc, tinfo_descs, TK_FIXED);\n-  \n+\n   push_nested_namespace (abi_node);\n \n   /* Create the internal type_info structure. This is used as a base for\n@@ -1317,15 +1317,15 @@ create_tinfo_types (void)\n   create_pseudo_type_info (TK_ARRAY_TYPE, \"__array_type_info\", NULL);\n   create_pseudo_type_info (TK_FUNCTION_TYPE, \"__function_type_info\", NULL);\n   create_pseudo_type_info (TK_ENUMERAL_TYPE, \"__enum_type_info\", NULL);\n-  \n+\n   /* Class type_info.  No additional fields.  */\n   create_pseudo_type_info (TK_CLASS_TYPE, \"__class_type_info\", NULL);\n-  \n-  /* Single public non-virtual base class. Add pointer to base class. \n+\n+  /* Single public non-virtual base class. Add pointer to base class.\n      This is really a descendant of __class_type_info.  */\n   create_pseudo_type_info (TK_SI_CLASS_TYPE, \"__si_class_type_info\",\n-            build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-            NULL);\n+\t    build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\t    NULL);\n \n   /* Base class internal helper. Pointer to base type, offset to base,\n      flags.  */\n@@ -1338,9 +1338,9 @@ create_tinfo_types (void)\n     field = build_decl (FIELD_DECL, NULL_TREE, integer_types[itk_long]);\n     TREE_CHAIN (field) = fields;\n     fields = field;\n-  \n+\n     ti = VEC_index (tinfo_s, tinfo_descs, TK_BASE_TYPE);\n-    \n+\n     ti->type = make_aggr_type (RECORD_TYPE);\n     ti->vtable = NULL_TREE;\n     ti->name = NULL_TREE;\n@@ -1362,10 +1362,10 @@ create_tinfo_types (void)\n      This is really a descendant of __pbase_type_info.  */\n   create_pseudo_type_info (TK_POINTER_MEMBER_TYPE,\n        \"__pointer_to_member_type_info\",\n-        build_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n-        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-        build_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n-        NULL);\n+\tbuild_decl (FIELD_DECL, NULL_TREE, integer_type_node),\n+\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\tbuild_decl (FIELD_DECL, NULL_TREE, type_info_ptr_type),\n+\tNULL);\n \n   pop_nested_namespace (abi_node);\n }\n@@ -1482,7 +1482,7 @@ emit_tinfo_decl (tree decl)\n   if (DECL_NOT_REALLY_EXTERN (decl) && decl_needed_p (decl))\n     {\n       tree init;\n-      \n+\n       DECL_EXTERNAL (decl) = 0;\n       init = get_pseudo_ti_init (type, get_pseudo_ti_index (type));\n       DECL_INITIAL (decl) = init;"}, {"sha": "21d1b7762465cc44b0ffa4b9bbe38599abb67506", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -875,8 +875,8 @@ accessible_p (tree type, tree decl, bool consider_local_p)\n      instantiation.  However, PROCESSING_TEMPLATE_DECL is set in the\n      parameter list for a template (because we may see dependent types\n      in default arguments for template parameters), and access\n-     checking should be performed in the outermost parameter list.  */ \n-  if (processing_template_decl \n+     checking should be performed in the outermost parameter list.  */\n+  if (processing_template_decl\n       && (!processing_template_parmlist || processing_template_decl > 1))\n     return 1;\n "}, {"sha": "b4e9505b75bead02d820be2976b64aca59d1f98f", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1212,17 +1212,17 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t  if (!lvalue_or_else (operand, lv_asm))\n \t    operand = error_mark_node;\n \n-          if (operand != error_mark_node\n+\t  if (operand != error_mark_node\n \t      && (TREE_READONLY (operand)\n \t\t  || CP_TYPE_CONST_P (TREE_TYPE (operand))\n-\t          /* Functions are not modifiable, even though they are\n-\t             lvalues.  */\n-\t          || TREE_CODE (TREE_TYPE (operand)) == FUNCTION_TYPE\n-\t          || TREE_CODE (TREE_TYPE (operand)) == METHOD_TYPE\n-\t          /* If it's an aggregate and any field is const, then it is\n-\t             effectively const.  */\n-\t          || (CLASS_TYPE_P (TREE_TYPE (operand))\n-\t              && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))\n+\t\t  /* Functions are not modifiable, even though they are\n+\t\t     lvalues.  */\n+\t\t  || TREE_CODE (TREE_TYPE (operand)) == FUNCTION_TYPE\n+\t\t  || TREE_CODE (TREE_TYPE (operand)) == METHOD_TYPE\n+\t\t  /* If it's an aggregate and any field is const, then it is\n+\t\t     effectively const.  */\n+\t\t  || (CLASS_TYPE_P (TREE_TYPE (operand))\n+\t\t      && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))\n \t    readonly_error (operand, \"assignment (via 'asm' output)\", 0);\n \n \t  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n@@ -1517,10 +1517,10 @@ check_accessibility_of_qualified_id (tree decl,\n    is true iff this qualified name appears as a template argument.  */\n \n tree\n-finish_qualified_id_expr (tree qualifying_class, \n-\t\t\t  tree expr, \n+finish_qualified_id_expr (tree qualifying_class,\n+\t\t\t  tree expr,\n \t\t\t  bool done,\n-\t\t\t  bool address_p, \n+\t\t\t  bool address_p,\n \t\t\t  bool template_p,\n \t\t\t  bool template_arg_p)\n {\n@@ -1603,7 +1603,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n     return error_mark_node;\n \n   /* If the last statement does not have \"void\" type, then the value\n-     of the last statement is the value of the entire expression.  */ \n+     of the last statement is the value of the entire expression.  */\n   if (expr)\n     {\n       tree type;\n@@ -1633,9 +1633,9 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t statement-expression.  */\n       if (!processing_template_decl && !VOID_TYPE_P (type))\n \t{\n-\t  tree target_expr; \n-\t  if (CLASS_TYPE_P (type) \n-\t      && !TYPE_HAS_TRIVIAL_INIT_REF (type)) \n+\t  tree target_expr;\n+\t  if (CLASS_TYPE_P (type)\n+\t      && !TYPE_HAS_TRIVIAL_INIT_REF (type))\n \t    {\n \t      target_expr = build_target_expr_with_type (expr, type);\n \t      expr = TARGET_EXPR_INITIAL (target_expr);\n@@ -1648,7 +1648,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t\t problem described above.  */\n \t      target_expr = force_target_expr (type, expr);\n \t      expr = TARGET_EXPR_INITIAL (target_expr);\n-\t      expr = build2 (INIT_EXPR, \n+\t      expr = build2 (INIT_EXPR,\n \t\t\t     type,\n \t\t\t     TARGET_EXPR_SLOT (target_expr),\n \t\t\t     expr);\n@@ -2043,7 +2043,7 @@ finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n     {\n       /* If this compound-literal appears outside of a function, then\n \t the corresponding variable has static storage duration, just\n-\t like the variable in whose initializer it appears.  */  \n+\t like the variable in whose initializer it appears.  */\n       TREE_STATIC (var) = 1;\n       /* The variable has internal linkage, since there is no need to\n \t reference it from another translation unit.  */\n@@ -2056,7 +2056,7 @@ finish_compound_literal (tree type, VEC(constructor_elt,gc) *initializer_list)\n   pushdecl (var);\n   /* Initialize the variable as we would any other variable with a\n      brace-enclosed initializer.  */\n-  cp_finish_decl (var, compound_literal, \n+  cp_finish_decl (var, compound_literal,\n \t\t  /*init_const_expr_p=*/false,\n \t\t  /*asmspec_tree=*/NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n@@ -3603,7 +3603,7 @@ finish_omp_clauses (tree clauses)\n \t\t\t\t\t     inner_type, LOOKUP_NORMAL);\n \n \t      /* We'll have called convert_from_reference on the call, which\n-\t\t may well have added an indirect_ref.  It's unneeded here, \n+\t\t may well have added an indirect_ref.  It's unneeded here,\n \t\t and in the way, so kill it.  */\n \t      if (TREE_CODE (t) == INDIRECT_REF)\n \t\tt = TREE_OPERAND (t, 0);\n@@ -3811,9 +3811,9 @@ finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n void\n finish_omp_atomic (enum tree_code code, tree lhs, tree rhs)\n {\n-  /* If either of the operands are dependent, we can't do semantic \n+  /* If either of the operands are dependent, we can't do semantic\n      processing yet.  Stuff the values away for now.  We cheat a bit\n-     and use the same tree code for this, even though the operands \n+     and use the same tree code for this, even though the operands\n      are of totally different form, thus we need to remember which\n      statements are which, thus the lang_flag bit.  */\n   /* ??? We ought to be using type_dependent_expression_p, but the"}, {"sha": "7b44ad6df19995f8994ef13711f440823faa1d42", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -825,7 +825,7 @@ debug_binfo (tree elem)\n    the type of the result expression, if known, or NULL_TREE if the\n    resulting expression is type-dependent.  If TEMPLATE_P is true,\n    NAME is known to be a template because the user explicitly used the\n-   \"template\" keyword after the \"::\".   \n+   \"template\" keyword after the \"::\".\n \n    All SCOPE_REFs should be built by use of this function.  */\n \n@@ -2170,8 +2170,8 @@ decl_linkage (tree decl)\n   /* Things that are TREE_PUBLIC have external linkage.  */\n   if (TREE_PUBLIC (decl))\n     return lk_external;\n-  \n-  /* Linkage of a CONST_DECL depends on the linkage of the enumeration \n+\n+  /* Linkage of a CONST_DECL depends on the linkage of the enumeration\n      type.  */\n   if (TREE_CODE (decl) == CONST_DECL)\n     return decl_linkage (TYPE_NAME (TREE_TYPE (decl)));"}, {"sha": "a47c35e64fbdc01c1fd4d03fb1078b6a72893d3f", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -1318,7 +1318,7 @@ static tree\n cxx_alignof_expr (tree e)\n {\n   tree t;\n-  \n+\n   if (e == error_mark_node)\n     return error_mark_node;\n \n@@ -1505,7 +1505,7 @@ decay_conversion (tree exp)\n       adr = build_unary_op (ADDR_EXPR, exp, 1);\n       return cp_convert (ptrtype, adr);\n     }\n-  \n+\n   /* If a bitfield is used in a context where integral promotion\n      applies, then the caller is expected to have used\n      default_conversion.  That function promotes bitfields correctly\n@@ -1546,7 +1546,7 @@ default_conversion (tree exp)\n {\n   /* Perform the integral promotions first so that bitfield\n      expressions (which may promote to \"int\", even if the bitfield is\n-     declared \"unsigned\") are promoted correctly.  */  \n+     declared \"unsigned\") are promoted correctly.  */\n   if (INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (exp)))\n     exp = perform_integral_promotions (exp);\n   /* Perform the other conversions.  */\n@@ -1990,8 +1990,8 @@ check_template_keyword (tree decl)\n       template, the program is ill-formed.\n \n      DR 228 removed the restriction that the template be a member\n-     template.  \n-     \n+     template.\n+\n      DR 96, if accepted would add the further restriction that explicit\n      template arguments must be provided if the template keyword is\n      used, but, as of 2005-10-16, that DR is still in \"drafting\".  If\n@@ -2199,7 +2199,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n \t\t\t\torig_object, orig_name,\n \t\t\t\tNULL_TREE);\n     }\n-  \n+\n   return expr;\n }\n \n@@ -3215,8 +3215,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case EQ_EXPR:\n     case NE_EXPR:\n       if (code0 == REAL_TYPE || code1 == REAL_TYPE)\n-\twarning (OPT_Wfloat_equal, \n-                 \"comparing floating point with == or != is unsafe\");\n+\twarning (OPT_Wfloat_equal,\n+\t\t \"comparing floating point with == or != is unsafe\");\n       if ((TREE_CODE (orig_op0) == STRING_CST && !integer_zerop (op1))\n \t  || (TREE_CODE (orig_op1) == STRING_CST && !integer_zerop (op0)))\n \twarning (OPT_Wstring_literal_comparison,\n@@ -5711,7 +5711,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n \t\t   ? 1 + (modifycode != INIT_EXPR): 0;\n-      return build_vec_init (lhs, NULL_TREE, newrhs, \n+      return build_vec_init (lhs, NULL_TREE, newrhs,\n \t\t\t     /*explicit_default_init_p=*/false,\n \t\t\t     from_array);\n     }\n@@ -6201,7 +6201,7 @@ convert_for_assignment (tree type, tree rhs,\n \t\t \"%s might be a candidate for a format attribute\",\n \t\t errtype);\n     }\n-  \n+\n   return perform_implicit_conversion (strip_top_quals (type), rhs);\n }\n \n@@ -6421,8 +6421,8 @@ check_return_expr (tree retval, bool *no_warning)\n \t return!).  */\n       current_function_returns_null = 0;\n       /* And signal caller that TREE_NO_WARNING should be set on the\n-         RETURN_EXPR to avoid control reaches end of non-void function\n-         warnings in tree-cfg.c.  */\n+\t RETURN_EXPR to avoid control reaches end of non-void function\n+\t warnings in tree-cfg.c.  */\n       *no_warning = true;\n     }\n   /* Check for a return statement with a value in a function that\n@@ -6551,7 +6551,7 @@ check_return_expr (tree retval, bool *no_warning)\n \t was an incomplete type.  Just treat this as 'return;' */\n       if (VOID_TYPE_P (functype))\n \treturn error_mark_node;\n-      \n+\n       /* First convert the value to the function's return type, then\n \t to the type of return value's location to handle the\n \t case that functype is smaller than the valtype.  */"}, {"sha": "97d5eaa37be9f754e9cd132921404167781183d7", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db45ab5922caf3331b231c9305ce7c0aa85862c/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3db45ab5922caf3331b231c9305ce7c0aa85862c", "patch": "@@ -839,7 +839,7 @@ process_init_constructor_array (tree type, tree init)\n \t     add anything to the CONSTRUCTOR.  */\n \t  break;\n \n-\tflags |= picflag_from_initializer (next);    \n+\tflags |= picflag_from_initializer (next);\n \tCONSTRUCTOR_APPEND_ELT (v, size_int (i), next);\n       }\n \n@@ -894,7 +894,7 @@ process_init_constructor_record (tree type, tree init)\n \t      gcc_assert (TREE_CODE (ce->index) == FIELD_DECL\n \t\t\t  || TREE_CODE (ce->index) == IDENTIFIER_NODE);\n \t      if (ce->index != field\n-\t          && ce->index != DECL_NAME (field))\n+\t\t  && ce->index != DECL_NAME (field))\n \t\tsorry (\"non-trivial designated initializers not supported\");\n \t    }\n \n@@ -1021,7 +1021,7 @@ process_init_constructor_union (tree type, tree init)\n    After the execution, the initializer will have TREE_CONSTANT if all elts are\n    constant, and TREE_STATIC set if, in addition, all elts are simple enough\n    constants that the assembler and linker can compute them.\n-   \n+\n    The function returns the initializer itself, or error_mark_node in case\n    of error.  */\n "}]}