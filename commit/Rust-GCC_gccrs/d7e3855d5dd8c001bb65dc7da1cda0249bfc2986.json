{"sha": "d7e3855d5dd8c001bb65dc7da1cda0249bfc2986", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlMzg1NWQ1ZGQ4YzAwMWJiNjVkYzdkYTFjZGEwMjQ5YmZjMjk4Ng==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2021-07-06T05:04:09Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2021-07-06T05:04:09Z"}, "message": "Do not replace variable op variable in I/O implied DO loop replacement.\n\nThis PR came about because index expressions of the form k+k in\nimplied DO loops in I/O statements were considered for replacement\nby array slices.\n\nFixed by only doing the transformation if the expression is of the\ntype expr OP contastant.\n\ngcc/fortran/ChangeLog:\n\n\tPR fortran/100227\n\t* frontend-passes.c (traverse_io_block): Adjust test for\n\twhen a variable is eligible for the transformation to\n\tarray slice.\n\ngcc/testsuite/ChangeLog:\n\n\tPR fortran/100227\n\t* gfortran.dg/implied_do_io_7.f90: New test.", "tree": {"sha": "bcc5ce81885138f5d5c6f024ea217edb60cbf100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc5ce81885138f5d5c6f024ea217edb60cbf100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986/comments", "author": null, "committer": null, "parents": [{"sha": "c64d15224c6dc4dc3b6b3c2c6b6fd5c7e0e9c072", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c64d15224c6dc4dc3b6b3c2c6b6fd5c7e0e9c072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c64d15224c6dc4dc3b6b3c2c6b6fd5c7e0e9c072"}], "stats": {"total": 20, "additions": 18, "deletions": 2}, "files": [{"sha": "996dcc2e5474b69b4e37102dfa46005121410fc2", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=d7e3855d5dd8c001bb65dc7da1cda0249bfc2986", "patch": "@@ -1299,8 +1299,8 @@ traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)\n \t\tstd::swap (start->value.op.op1, start->value.op.op2);\n \t      gcc_fallthrough ();\n \t    case INTRINSIC_MINUS:\n-\t      if ((start->value.op.op1->expr_type!= EXPR_VARIABLE\n-\t\t   && start->value.op.op2->expr_type != EXPR_CONSTANT)\n+\t      if (start->value.op.op1->expr_type!= EXPR_VARIABLE\n+\t\t  || start->value.op.op2->expr_type != EXPR_CONSTANT\n \t\t  || start->value.op.op1->ref)\n \t\treturn false;\n \t      if (!stack_top || !stack_top->iter"}, {"sha": "63927aafea9360389c4b56dc3a171ccb3899ff4c", "filename": "gcc/testsuite/gfortran.dg/implied_do_io_7.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e3855d5dd8c001bb65dc7da1cda0249bfc2986/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_7.f90?ref=d7e3855d5dd8c001bb65dc7da1cda0249bfc2986", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! PR 100227 - this was falsely optimized, leading to nonsense  results.\n+! Original test case by \"Mathieu\".\n+\n+program p\n+  implicit none\n+  integer, parameter :: nbmode = 3\n+  integer :: k\n+  real    :: mass(nbmode*2)\n+  character (len=80) :: line\n+  do k = 1, nbmode*2\n+     mass(k) = k\n+  end do\n+  write (unit=line,fmt='(*(F6.2))') (mass(k+k), k=1,nbmode)\n+  if (line /= '  2.00  4.00  6.00') stop 1\n+end program"}]}