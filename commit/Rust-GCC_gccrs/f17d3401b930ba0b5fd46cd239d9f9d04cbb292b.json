{"sha": "f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE3ZDM0MDFiOTMwYmEwYjVmZDQ2Y2QyMzlkOWY5ZDA0Y2JiMjkyYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-07-23T19:58:46Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-07-23T19:58:46Z"}, "message": "dwarf2cfi: Introduce a dw_cfi_row state.\n\nUse it instead of old_cfa, old_args_size, and cfa_remember variables.\n\nRemove the global cfa variable, as it was usually a duplicate of\nold_cfa and otherwise confusing.  Always make a local copy of the\ncur_row->cfa variable before modification instead.\n\n        * dwarf2cfi.c (dw_cfi_row, dw_cfi_row_ref): New.\n        (cie_cfi_row): New.\n        (new_cfi_row, copy_cfi_row, free_cfi_row): New.\n        (cfa, old_cfa, cfa_remember, old_cfa_remember, old_args_size): Remove.\n        (cur_row, remember_row): New.\n        (def_cfa_1): Use cur_row instead of the old_* variables.\n        (dwarf2out_frame_debug_restore_state): Similarly.\n        (dwarf2out_args_size, dwarf2out_notice_stack_adjust): Likewise.\n        (dwarf2out_frame_debug_def_cfa): Use a local variable instead of cfa.\n        (dwarf2out_frame_debug_adjust_cfa): Likewise.\n        (dwarf2out_frame_debug_cfa_offset): Likewise.\n        (dwarf2out_frame_debug_expr): Likewise.\n        (execute_dwarf2_frame): Set up cur_row.\n        * dwarf2out.h (struct cfa_loc): Mark for GTY.\n\nFrom-SVN: r176697", "tree": {"sha": "601188a008c6702ea15051b1759dbd0ed9a67feb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/601188a008c6702ea15051b1759dbd0ed9a67feb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/comments", "author": null, "committer": null, "parents": [{"sha": "0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0be7e7a6dbb4cdf48e76bf9b38f42b95ebf4d752"}], "stats": {"total": 227, "additions": 152, "deletions": 75}, "files": [{"sha": "87d7368d23c65d33b194461b235aeaf1aabccf28", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "patch": "@@ -1,3 +1,20 @@\n+2011-07-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2cfi.c (dw_cfi_row, dw_cfi_row_ref): New.\n+\t(cie_cfi_row): New.\n+\t(new_cfi_row, copy_cfi_row, free_cfi_row): New.\n+\t(cfa, old_cfa, cfa_remember, old_cfa_remember, old_args_size): Remove.\n+\t(cur_row, remember_row): New.\n+\t(def_cfa_1): Use cur_row instead of the old_* variables.\n+\t(dwarf2out_frame_debug_restore_state): Similarly.\n+\t(dwarf2out_args_size, dwarf2out_notice_stack_adjust): Likewise.\n+\t(dwarf2out_frame_debug_def_cfa): Use a local variable instead of cfa.\n+\t(dwarf2out_frame_debug_adjust_cfa): Likewise.\n+\t(dwarf2out_frame_debug_cfa_offset): Likewise.\n+\t(dwarf2out_frame_debug_expr): Likewise.\n+\t(execute_dwarf2_frame): Set up cur_row.\n+\t* dwarf2out.h (struct cfa_loc): Mark for GTY.\n+\n 2011-07-23  Richard Henderson  <rth@redhat.com>\n \n \t* basic-block.h (EDGE_PRESERVE): New."}, {"sha": "1c1b74f959df5a7ffa81263a5ebcc14a171c8902", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 134, "deletions": 74, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "patch": "@@ -58,9 +58,31 @@ along with GCC; see the file COPYING3.  If not see\n /* Maximum size (in bytes) of an artificially generated label.  */\n #define MAX_ARTIFICIAL_LABEL_BYTES\t30\n \f\n+/* A collected description of an entire row of the abstract CFI table.  */\n+typedef struct GTY(()) dw_cfi_row_struct\n+{\n+  /* The expression that computes the CFA, expressed in two different ways.\n+     The CFA member for the simple cases, and the full CFI expression for\n+     the complex cases.  The later will be a DW_CFA_cfa_expression.  */\n+  dw_cfa_location cfa;\n+  dw_cfi_ref cfa_cfi;\n+\n+  /* The expressions for any register column that is saved.  */\n+  cfi_vec reg_save;\n+\n+  /* The value of any DW_CFA_GNU_args_size.  */\n+  HOST_WIDE_INT args_size;\n+} dw_cfi_row;\n+\n+typedef dw_cfi_row *dw_cfi_row_ref;\n+\f\n /* A vector of call frame insns for the CIE.  */\n cfi_vec cie_cfi_vec;\n \n+/* The state of the first row of the FDE table, which includes the\n+   state provided by the CIE.  */\n+static GTY(()) dw_cfi_row_ref cie_cfi_row;\n+\n static GTY(()) unsigned long dwarf2out_cfi_label_num;\n \n /* The insn after which a new CFI note should be emitted.  */\n@@ -185,6 +207,43 @@ new_cfi (void)\n   return cfi;\n }\n \n+/* Return a newly allocated CFI row, with no defined data.  */\n+\n+static dw_cfi_row_ref\n+new_cfi_row (void)\n+{\n+  dw_cfi_row_ref row = ggc_alloc_cleared_dw_cfi_row ();\n+\n+  row->cfa.reg = INVALID_REGNUM;\n+\n+  return row;\n+}\n+\n+/* Return a copy of an existing CFI row.  */\n+\n+static dw_cfi_row_ref\n+copy_cfi_row (dw_cfi_row_ref src)\n+{\n+  dw_cfi_row_ref dst = ggc_alloc_dw_cfi_row ();\n+\n+  *dst = *src;\n+  dst->reg_save = VEC_copy (dw_cfi_ref, gc, src->reg_save);\n+\n+  return dst;\n+}\n+\n+/* Free an allocated CFI row.  */\n+\n+static void\n+free_cfi_row (dw_cfi_row_ref row)\n+{\n+  if (row != NULL)\n+    {\n+      VEC_free (dw_cfi_ref, gc, row->reg_save);\n+      ggc_free (row);\n+    }\n+}\n+\n /* Generate a new label for the CFI info to refer to.  */\n \n static char *\n@@ -371,28 +430,25 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n     }\n }\n \n-/* The current rule for calculating the DWARF2 canonical frame address.  */\n-static dw_cfa_location cfa;\n+/* The current, i.e. most recently generated, row of the CFI table.  */\n+static dw_cfi_row_ref cur_row;\n \n-/* A copy of the CFA, for comparison purposes.  */\n-static dw_cfa_location old_cfa;\n+/* The row state from a preceeding DW_CFA_remember_state.  */\n+static dw_cfi_row_ref remember_row;\n \n /* The register used for saving registers to the stack, and its offset\n    from the CFA.  */\n static dw_cfa_location cfa_store;\n \n-/* The current save location around an epilogue.  */\n-static dw_cfa_location cfa_remember;\n-\n-/* Like cfa_remember, but a copy of old_cfa.  */\n-static dw_cfa_location old_cfa_remember;\n+/* A temporary register holding an integral value used in adjusting SP\n+   or setting up the store_reg.  The \"offset\" field holds the integer\n+   value, not an offset.  */\n+static dw_cfa_location cfa_temp;\n \n-/* The running total of the size of arguments pushed onto the stack.  */\n+/* The (really) current value for DW_CFA_GNU_args_size.  We delay actually\n+   emitting this data, i.e. updating CUR_ROW, without async unwind.  */\n static HOST_WIDE_INT args_size;\n \n-/* The last args_size we actually output.  */\n-static HOST_WIDE_INT old_args_size;\n-\n /* Determine if two dw_cfa_location structures define the same data.  */\n \n bool\n@@ -412,21 +468,18 @@ static void\n def_cfa_1 (dw_cfa_location *loc_p)\n {\n   dw_cfi_ref cfi;\n-  dw_cfa_location loc;\n-\n-  cfa = *loc_p;\n-  loc = *loc_p;\n+  dw_cfa_location loc = *loc_p;\n \n   if (cfa_store.reg == loc.reg && loc.indirect == 0)\n     cfa_store.offset = loc.offset;\n \n   /* If nothing changed, no need to issue any call frame instructions.  */\n-  if (cfa_equal_p (&loc, &old_cfa))\n+  if (cfa_equal_p (&loc, &cur_row->cfa))\n     return;\n \n   cfi = new_cfi ();\n \n-  if (loc.reg == old_cfa.reg && !loc.indirect && !old_cfa.indirect)\n+  if (loc.reg == cur_row->cfa.reg && !loc.indirect && !cur_row->cfa.indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction, indicating\n \t the CFA register did not change but the offset did.  The data\n@@ -440,10 +493,10 @@ def_cfa_1 (dw_cfa_location *loc_p)\n     }\n \n #ifndef MIPS_DEBUGGING_INFO  /* SGI dbx thinks this means no offset.  */\n-  else if (loc.offset == old_cfa.offset\n-\t   && old_cfa.reg != INVALID_REGNUM\n+  else if (loc.offset == cur_row->cfa.offset\n+\t   && cur_row->cfa.reg != INVALID_REGNUM\n \t   && !loc.indirect\n-\t   && !old_cfa.indirect)\n+\t   && !cur_row->cfa.indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_register <register>\" instruction,\n \t indicating the CFA register has changed to <register> but the\n@@ -477,10 +530,12 @@ def_cfa_1 (dw_cfa_location *loc_p)\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n       loc_list = build_cfa_loc (&loc, 0);\n       cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n+\n+      cur_row->cfa_cfi = cfi;\n     }\n \n   add_cfi (cfi);\n-  old_cfa = loc;\n+  cur_row->cfa = loc;\n }\n \n /* Add the CFI for saving a register.  REG is the CFA column number.\n@@ -503,7 +558,8 @@ reg_save (unsigned int reg, unsigned int sreg, HOST_WIDE_INT offset)\n       cfi->dw_cfi_opc = DW_CFA_expression;\n       cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n       cfi->dw_cfi_oprnd2.dw_cfi_loc\n-\t= build_cfa_aligned_loc (&cfa, offset, fde->stack_realignment);\n+\t= build_cfa_aligned_loc (&cur_row->cfa, offset,\n+\t\t\t\t fde->stack_realignment);\n     }\n   else if (sreg == INVALID_REGNUM)\n     {\n@@ -797,10 +853,10 @@ dwarf2out_args_size (HOST_WIDE_INT size)\n {\n   dw_cfi_ref cfi;\n \n-  if (size == old_args_size)\n+  if (size == cur_row->args_size)\n     return;\n \n-  old_args_size = size;\n+  cur_row->args_size = size;\n \n   cfi = new_cfi ();\n   cfi->dw_cfi_opc = DW_CFA_GNU_args_size;\n@@ -813,12 +869,19 @@ dwarf2out_args_size (HOST_WIDE_INT size)\n static void\n dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n {\n-  if (cfa.reg == dw_stack_pointer_regnum)\n-    cfa.offset += offset;\n+  dw_cfa_location loc = cur_row->cfa;\n+\n+  if (loc.reg == dw_stack_pointer_regnum)\n+    loc.offset += offset;\n \n   if (cfa_store.reg == dw_stack_pointer_regnum)\n     cfa_store.offset += offset;\n \n+  /* ??? The assumption seems to be that if A_O_A, the only CFA adjustments\n+     involving the stack pointer are inside the prologue and marked as\n+     RTX_FRAME_RELATED_P.  That said, should we not verify this assumption\n+     by *asserting* A_O_A at this point?  Why else would we have a change\n+     to the stack pointer?  */\n   if (ACCUMULATE_OUTGOING_ARGS)\n     return;\n \n@@ -830,7 +893,7 @@ dwarf2out_stack_adjust (HOST_WIDE_INT offset)\n   if (args_size < 0)\n     args_size = 0;\n \n-  def_cfa_1 (&cfa);\n+  def_cfa_1 (&loc);\n   if (flag_asynchronous_unwind_tables)\n     dwarf2out_args_size (args_size);\n }\n@@ -862,7 +925,8 @@ dwarf2out_notice_stack_adjust (rtx insn, bool after_p)\n \n   /* If only calls can throw, and we have a frame pointer,\n      save up adjustments until we see the CALL_INSN.  */\n-  if (!flag_asynchronous_unwind_tables && cfa.reg != dw_stack_pointer_regnum)\n+  if (!flag_asynchronous_unwind_tables\n+      && cur_row->cfa.reg != dw_stack_pointer_regnum)\n     {\n       if (CALL_P (insn) && !after_p)\n \t{\n@@ -1103,54 +1167,51 @@ reg_saved_in (rtx reg)\n   return NULL_RTX;\n }\n \n-\n-/* A temporary register holding an integral value used in adjusting SP\n-   or setting up the store_reg.  The \"offset\" field holds the integer\n-   value, not an offset.  */\n-static dw_cfa_location cfa_temp;\n-\n /* A subroutine of dwarf2out_frame_debug, process a REG_DEF_CFA note.  */\n \n static void\n dwarf2out_frame_debug_def_cfa (rtx pat)\n {\n-  memset (&cfa, 0, sizeof (cfa));\n+  dw_cfa_location loc;\n+\n+  memset (&loc, 0, sizeof (loc));\n \n   switch (GET_CODE (pat))\n     {\n     case PLUS:\n-      cfa.reg = dwf_regno (XEXP (pat, 0));\n-      cfa.offset = INTVAL (XEXP (pat, 1));\n+      loc.reg = dwf_regno (XEXP (pat, 0));\n+      loc.offset = INTVAL (XEXP (pat, 1));\n       break;\n \n     case REG:\n-      cfa.reg = dwf_regno (pat);\n+      loc.reg = dwf_regno (pat);\n       break;\n \n     case MEM:\n-      cfa.indirect = 1;\n+      loc.indirect = 1;\n       pat = XEXP (pat, 0);\n       if (GET_CODE (pat) == PLUS)\n \t{\n-\t  cfa.base_offset = INTVAL (XEXP (pat, 1));\n+\t  loc.base_offset = INTVAL (XEXP (pat, 1));\n \t  pat = XEXP (pat, 0);\n \t}\n-      cfa.reg = dwf_regno (pat);\n+      loc.reg = dwf_regno (pat);\n       break;\n \n     default:\n       /* Recurse and define an expression.  */\n       gcc_unreachable ();\n     }\n \n-  def_cfa_1 (&cfa);\n+  def_cfa_1 (&loc);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_ADJUST_CFA note.  */\n \n static void\n dwarf2out_frame_debug_adjust_cfa (rtx pat)\n {\n+  dw_cfa_location loc = cur_row->cfa;\n   rtx src, dest;\n \n   gcc_assert (GET_CODE (pat) == SET);\n@@ -1160,8 +1221,8 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n   switch (GET_CODE (src))\n     {\n     case PLUS:\n-      gcc_assert (dwf_regno (XEXP (src, 0)) == cfa.reg);\n-      cfa.offset -= INTVAL (XEXP (src, 1));\n+      gcc_assert (dwf_regno (XEXP (src, 0)) == loc.reg);\n+      loc.offset -= INTVAL (XEXP (src, 1));\n       break;\n \n     case REG:\n@@ -1171,10 +1232,10 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n \tgcc_unreachable ();\n     }\n \n-  cfa.reg = dwf_regno (dest);\n-  gcc_assert (cfa.indirect == 0);\n+  loc.reg = dwf_regno (dest);\n+  gcc_assert (loc.indirect == 0);\n \n-  def_cfa_1 (&cfa);\n+  def_cfa_1 (&loc);\n }\n \n /* A subroutine of dwarf2out_frame_debug, process a REG_CFA_OFFSET note.  */\n@@ -1195,12 +1256,12 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      gcc_assert (dwf_regno (addr) == cfa.reg);\n-      offset = -cfa.offset;\n+      gcc_assert (dwf_regno (addr) == cur_row->cfa.reg);\n+      offset = -cur_row->cfa.offset;\n       break;\n     case PLUS:\n-      gcc_assert (dwf_regno (XEXP (addr, 0)) == cfa.reg);\n-      offset = INTVAL (XEXP (addr, 1)) - cfa.offset;\n+      gcc_assert (dwf_regno (XEXP (addr, 0)) == cur_row->cfa.reg);\n+      offset = INTVAL (XEXP (addr, 1)) - cur_row->cfa.offset;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -1366,7 +1427,9 @@ dwarf2out_frame_debug_cfa_window_save (void)\n   Invariants / Summaries of Rules\n \n   cfa\t       current rule for calculating the CFA.  It usually\n-\t       consists of a register and an offset.\n+\t       consists of a register and an offset.  This is\n+\t       actually stored in cur_row->cfa, but abbreviated\n+\t       for the purposes of this documentation.\n   cfa_store    register used by prologue code to save things to the stack\n \t       cfa_store.offset is the offset from the value of\n \t       cfa_store.reg to the actual CFA\n@@ -1520,6 +1583,7 @@ dwarf2out_frame_debug_cfa_window_save (void)\n static void\n dwarf2out_frame_debug_expr (rtx expr)\n {\n+  dw_cfa_location cfa = cur_row->cfa;\n   rtx src, dest, span;\n   HOST_WIDE_INT offset;\n   dw_fde_ref fde;\n@@ -2391,10 +2455,8 @@ dwarf2out_cfi_begin_epilogue (rtx insn)\n   emit_cfa_remember = true;\n \n   /* And emulate the state save.  */\n-  gcc_assert (!cfa_remember.in_use);\n-  cfa_remember = cfa;\n-  old_cfa_remember = old_cfa;\n-  cfa_remember.in_use = 1;\n+  gcc_assert (remember_row == NULL);\n+  remember_row = copy_cfi_row (cur_row);\n }\n \n /* A \"subroutine\" of dwarf2out_cfi_begin_epilogue.  Emit the restore\n@@ -2408,10 +2470,10 @@ dwarf2out_frame_debug_restore_state (void)\n   cfi->dw_cfi_opc = DW_CFA_restore_state;\n   add_cfi (cfi);\n \n-  gcc_assert (cfa_remember.in_use);\n-  cfa = cfa_remember;\n-  old_cfa = old_cfa_remember;\n-  cfa_remember.in_use = 0;\n+  gcc_assert (remember_row != NULL);\n+  free_cfi_row (cur_row);\n+  cur_row = remember_row;\n+  remember_row = NULL;\n }\n \f\n /* Record the initial position of the return address.  RTL is\n@@ -2472,7 +2534,7 @@ initial_return_save (rtx rtl)\n     {\n       if (reg != INVALID_REGNUM)\n         record_reg_saved_in_reg (rtl, pc_rtx);\n-      reg_save (DWARF_FRAME_RETURN_COLUMN, reg, offset - cfa.offset);\n+      reg_save (DWARF_FRAME_RETURN_COLUMN, reg, offset - cur_row->cfa.offset);\n     }\n }\n \n@@ -2492,9 +2554,7 @@ execute_dwarf2_frame (void)\n       dw_frame_pointer_regnum = DWARF_FRAME_REGNUM (HARD_FRAME_POINTER_REGNUM);\n \n       add_cfi_vec = &cie_cfi_vec;\n-\n-      memset (&old_cfa, 0, sizeof (old_cfa));\n-      old_cfa.reg = INVALID_REGNUM;\n+      cie_cfi_row = cur_row = new_cfi_row ();\n \n       /* On entry, the Canonical Frame Address is at SP.  */\n       memset(&loc, 0, sizeof (loc));\n@@ -2537,19 +2597,16 @@ execute_dwarf2_frame (void)\n   gcc_checking_assert (queued_reg_saves == NULL);\n   gcc_checking_assert (regs_saved_in_regs == NULL);\n \n-  memset (&cfa, 0, sizeof(cfa));\n-  cfa.reg = dw_stack_pointer_regnum;\n-  cfa.offset = INCOMING_FRAME_SP_OFFSET;\n+  cur_row = copy_cfi_row (cie_cfi_row);\n+  if (cie_return_save)\n+    VEC_safe_push (reg_saved_in_data, gc, regs_saved_in_regs, cie_return_save);\n \n-  old_cfa = cfa;\n-  cfa_store = cfa;\n+  cfa_store = cur_row->cfa;\n+  args_size = 0;\n \n   memset (&cfa_temp, 0, sizeof(cfa_temp));\n   cfa_temp.reg = INVALID_REGNUM;\n \n-  if (cie_return_save)\n-    VEC_safe_push (reg_saved_in_data, gc, regs_saved_in_regs, cie_return_save);\n-\n   dwarf2out_alloc_current_fde ();\n \n   /* Do the work.  */\n@@ -2562,6 +2619,9 @@ execute_dwarf2_frame (void)\n   regs_saved_in_regs = NULL;\n   queued_reg_saves = NULL;\n \n+  free_cfi_row (cur_row);\n+  cur_row = NULL;\n+\n   return 0;\n }\n \f"}, {"sha": "d0e76a786f8a1c6ef2a97ba34e99a1d3c0b4bbcb", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f17d3401b930ba0b5fd46cd239d9f9d04cbb292b/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=f17d3401b930ba0b5fd46cd239d9f9d04cbb292b", "patch": "@@ -118,7 +118,7 @@ dw_fde_node;\n    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.\n    Instead of passing around REG and OFFSET, we pass a copy\n    of this structure.  */\n-typedef struct cfa_loc {\n+typedef struct GTY(()) cfa_loc {\n   HOST_WIDE_INT offset;\n   HOST_WIDE_INT base_offset;\n   /* REG is in DWARF_FRAME_REGNUM space, *not* normal REGNO space.  */"}]}