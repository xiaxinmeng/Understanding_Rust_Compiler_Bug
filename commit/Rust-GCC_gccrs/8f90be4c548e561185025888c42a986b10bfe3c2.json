{"sha": "8f90be4c548e561185025888c42a986b10bfe3c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5MGJlNGM1NDhlNTYxMTg1MDI1ODg4YzQyYTk4NmIxMGJmZTNjMg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-14T22:51:36Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-02-14T22:51:36Z"}, "message": "Backend for Motorola's MCore processors.\n\nFrom-SVN: r31972", "tree": {"sha": "46e2297952ebf8e12e5a9bdc2b6a9087d7412780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46e2297952ebf8e12e5a9bdc2b6a9087d7412780"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f90be4c548e561185025888c42a986b10bfe3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f90be4c548e561185025888c42a986b10bfe3c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f90be4c548e561185025888c42a986b10bfe3c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f90be4c548e561185025888c42a986b10bfe3c2/comments", "author": null, "committer": null, "parents": [{"sha": "77de5d85d0492c686d37f00851c2189ee71e6348", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77de5d85d0492c686d37f00851c2189ee71e6348", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77de5d85d0492c686d37f00851c2189ee71e6348"}], "stats": {"total": 9785, "additions": 9785, "deletions": 0}, "files": [{"sha": "50a78146decfd0ab9f3c13051f31c5b010271f41", "filename": "gcc/config/mcore/crti.asm", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fcrti.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fcrti.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fcrti.asm?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,74 @@\n+# crti.asm for ELF based systems\n+\n+#   Copyright (C) 1992, 1998, 1999 Free Software Foundation, Inc.\n+#   Written By David Vinayak Henkel-Wallace, June 1992\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+# \n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+# \n+\n+# This file just makes a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+\t.file\t\t\"crti.asm\"\n+\n+\t.section\t\".init\"\n+\t.global\t_init\n+\t.type\t_init,@function\n+\t.align\t4\n+_init:\n+\tsubi\tr0, 16\n+\tst.w\tr15, (r0, 12)\n+\n+\t# These nops are here to align the end of this code with a 16 byte\n+\t# boundary.  The linker will start inserting code into the .init\n+\t# section at such a boundary.\n+\t\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\n+\t\n+\t.section\t\".fini\"\n+\t.global\t_fini\n+\t.type\t_fini,@function\n+\t.align\t4\n+_fini:\n+\tsubi\tr0, 16\n+\tst.w\tr15, (r0, 12)\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop\n+\tnop"}, {"sha": "253d425d73cdc071d8308eb6767a2ee1f3a98a53", "filename": "gcc/config/mcore/crtn.asm", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fcrtn.asm?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,57 @@\n+# crtn.asm for ELF based systems\n+\n+#   Copyright (C) 1992, 1999, 2000 Free Software Foundation, Inc.\n+#   Written By David Vinayak Henkel-Wallace, June 1992\n+# \n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 2, or (at your option) any\n+# later version.\n+# \n+# In addition to the permissions in the GNU General Public License, the\n+# Free Software Foundation gives you unlimited permission to link the\n+# compiled version of this file with other programs, and to distribute\n+# those programs without any restriction coming from the use of this\n+# file.  (The General Public License restrictions do apply in other\n+# respects; for example, they cover modification of the file, and\n+# distribution when not linked into another program.)\n+# \n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 59 Temple Place - Suite 330,\n+# Boston, MA 02111-1307, USA.\n+# \n+#    As a special exception, if you link this library with files\n+#    compiled with GCC to produce an executable, this does not cause\n+#    the resulting executable to be covered by the GNU General Public License.\n+#    This exception does not however invalidate any other reasons why\n+#    the executable file might be covered by the GNU General Public License.\n+# \n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t.file\t\t\"crtn.asm\"\n+\n+\t.section\t\".init\"\n+\t.align\t\t4\n+\n+        ldw     r15,(r0, 12)\n+        addi    r0,16\n+        jmp     r15\n+\t\n+\t.section\t\".fini\"\n+\t.align\t\t4\n+\n+        ldw     r15, (r0, 12)\n+        addi    r0,16\n+        jmp     r15\n+\n+# Th-th-th-that is all folks!\n+"}, {"sha": "4469ff4445608864660fc8e146dbd7347fdec398", "filename": "gcc/config/mcore/gfloat.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fgfloat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fgfloat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fgfloat.h?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,64 @@\n+/* Output routines for Motorola MCore processor\n+   Copyright (C) 1993, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* float.h for the M*Core microprocessor. It uses IEEE floating point.\n+ *\tfloat is 32 bit IEEE-754 format\n+ *\tdouble is 64 bit IEEE-754 format\n+ *\tlong double is not defined right now...\n+ */\n+#ifndef\t__FLOAT_H___\n+#define\t__FLOAT_H___\n+\n+#define FLT_RADIX 2\n+#define FLT_ROUNDS 1\n+\n+#define FLT_MANT_DIG\t24\n+#define FLT_DIG       \t6\n+#define FLT_EPSILON \t((float)1.19209290e-07)\n+#define FLT_MIN_EXP \t(-125)\n+#define FLT_MIN \t((float)1.17549435e-38)\n+#define FLT_MIN_10_EXP \t(-37)\n+#define FLT_MAX_EXP \t128\n+#define FLT_MAX \t((float)3.40282347e+38)\n+#define FLT_MAX_10_EXP \t38\n+\n+#define DBL_MANT_DIG \t53\n+#define DBL_DIG \t15\n+#define DBL_EPSILON \t2.2204460492503131e-16\n+#define DBL_MIN_EXP \t(-1021)\n+#define DBL_MIN \t2.2250738585072014e-308\n+#define DBL_MIN_10_EXP \t(-307)\n+#define DBL_MAX_EXP \t1024\n+#define DBL_MAX \t1.7976931348623157e+308\n+#define DBL_MAX_10_EXP \t308\n+\n+\n+/* No definitions for LDBL at this time.  */\n+\n+#undef\tLDBL_MANT_DIG\n+#undef\tLDBL_DIG\n+#undef\tLDBL_EPSILON\n+#undef\tLDBL_MIN_EXP\n+#undef\tLDBL_MIN\n+#undef\tLDBL_MIN_10_EXP\n+#undef\tLDBL_MAX_EXP\n+#undef\tLDBL_MAX\n+#undef\tLDBL_MAX_10_EXP\n+\n+#endif /* __FLOAT_H__ */"}, {"sha": "f8a4a8fcff7e1152a763d3c608bb5832659ba762", "filename": "gcc/config/mcore/lib1.asm", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Flib1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Flib1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Flib1.asm?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,313 @@\n+/* libgcc1 routines for the MCore.\n+   Copyright (C) 1993, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\t\n+#define CONCAT1(a, b) CONCAT2(a, b)\n+#define CONCAT2(a, b) a ## b\n+\n+/* Use the right prefix for global labels.  */\n+\n+#define SYM(x) CONCAT1 (__, x)\n+\n+#ifdef __ELF__\n+#define TYPE(x) .type SYM (x),@function\n+#define SIZE(x) .size SYM (x), . - SYM (x)\n+#else\n+#define TYPE(x)\n+#define SIZE(x)\n+#endif\n+\n+.macro FUNC_START name\n+\t.text\n+\t.globl SYM (\\name)\n+\tTYPE (\\name)\n+SYM (\\name):\n+.endm\n+\n+.macro FUNC_END name\n+\tSIZE (\\name)\n+.endm\n+\n+#ifdef\tL_udivsi3\n+FUNC_START udiv32\n+FUNC_START udivsi32\n+\n+\tmovi\tr1,0\t\t// r1-r2 form 64 bit dividend\n+\tmovi\tr4,1\t\t// r4 is quotient (1 for a sentinel)\n+\n+\tcmpnei\tr3,0\t\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t\t// divide by 0\n+9:\n+\t// control iterations; skip across high order 0 bits in dividend\n+\tmov\tr7,r2\n+\tcmpnei\tr7,0\n+\tbt\t8f\n+\tmovi\tr2,0\t\t// 0 dividend\n+\tjmp\tr15\t\t// quick return\n+8:\n+\tff1\tr7\t\t// figure distance to skip\n+\tlsl\tr4,r7\t\t// move the sentinel along (with 0's behind)\n+\tlsl\tr2,r7\t\t// and the low 32 bits of numerator\n+\n+// appears to be wrong...\n+// tested out incorrectly in our OS work...\n+//\tmov\tr7,r3\t\t// looking at divisor\n+//\tff1\tr7\t\t// I can move 32-r7 more bits to left.\n+//\taddi\tr7,1\t\t// ok, one short of that...\n+//\tmov\tr1,r2\n+//\tlsr\tr1,r7\t\t// bits that came from low order...\n+//\trsubi\tr7,31\t\t// r7 == \"32-n\" == LEFT distance\n+//\taddi\tr7,1\t\t// this is (32-n)\n+//\tlsl\tr4,r7\t\t// fixes the high 32 (quotient)\n+//\tlsl\tr2,r7\n+//\tcmpnei\tr4,0\n+//\tbf\t4f\t\t// the sentinel went away...\n+\n+\t// run the remaining bits\n+\n+1:\tlslc\tr2,1\t\t// 1 bit left shift of r1-r2\n+\taddc\tr1,r1\n+\tcmphs\tr1,r3\t\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsub\tr1,r3\t\t// if yes, subtract divisor\n+2:\taddc\tr4,r4\t\t// shift by 1 and count subtracts\n+\tbf\t1b\t\t// if sentinel falls out of quotient, stop\n+\n+4:\tmov\tr2,r4\t\t// return quotient\n+\tmov\tr3,r1\t\t// and piggyback the remainder\n+\tjmp\tr15\n+FUNC_END udiv32\n+FUNC_END udivsi32\n+#endif\n+\n+#ifdef\tL_umodsi3\n+FUNC_START urem32\n+FUNC_START umodsi3\n+\tmovi\tr1,0\t\t// r1-r2 form 64 bit dividend\n+\tmovi\tr4,1\t\t// r4 is quotient (1 for a sentinel)\n+\tcmpnei\tr3,0\t\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t\t// divide by 0\n+9:\n+\t// control iterations; skip across high order 0 bits in dividend\n+\tmov\tr7,r2\n+\tcmpnei\tr7,0\n+\tbt\t8f\n+\tmovi\tr2,0\t\t// 0 dividend\n+\tjmp\tr15\t\t// quick return\n+8:\n+\tff1\tr7\t\t// figure distance to skip\n+\tlsl\tr4,r7\t\t// move the sentinel along (with 0's behind)\n+\tlsl\tr2,r7\t\t// and the low 32 bits of numerator\n+\n+1:\tlslc\tr2,1\t\t// 1 bit left shift of r1-r2\n+\taddc\tr1,r1\n+\tcmphs\tr1,r3\t\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsub\tr1,r3\t\t// if yes, subtract divisor\n+2:\taddc\tr4,r4\t\t// shift by 1 and count subtracts\n+\tbf\t1b\t\t// if sentinel falls out of quotient, stop\n+\tmov\tr2,r1\t\t// return remainder\n+\tjmp\tr15\n+FUNC_END urem32\n+FUNC_END umodsi3\n+#endif\n+\n+#ifdef\tL_divsi3\n+FUNC_START div32\n+FUNC_START divsi3\n+\tmov\tr5,r2\t\t// calc sign of quotient\n+\txor\tr5,r3\n+\tabs\tr2\t\t// do unsigned divide\n+\tabs\tr3\n+\tmovi\tr1,0\t\t// r1-r2 form 64 bit dividend\n+\tmovi\tr4,1\t\t// r4 is quotient (1 for a sentinel)\n+\tcmpnei\tr3,0\t\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t\t// divide by 0\n+9:\n+\t// control iterations; skip across high order 0 bits in dividend\n+\tmov\tr7,r2\n+\tcmpnei\tr7,0\n+\tbt\t8f\n+\tmovi\tr2,0\t\t// 0 dividend\n+\tjmp\tr15\t\t// quick return\n+8:\n+\tff1\tr7\t\t// figure distance to skip\n+\tlsl\tr4,r7\t\t// move the sentinel along (with 0's behind)\n+\tlsl\tr2,r7\t\t// and the low 32 bits of numerator\n+\n+// tested out incorrectly in our OS work...\n+//\tmov\tr7,r3\t\t// looking at divisor\n+//\tff1\tr7\t\t// I can move 32-r7 more bits to left.\n+//\taddi\tr7,1\t\t// ok, one short of that...\n+//\tmov\tr1,r2\n+//\tlsr\tr1,r7\t\t// bits that came from low order...\n+//\trsubi\tr7,31\t\t// r7 == \"32-n\" == LEFT distance\n+//\taddi\tr7,1\t\t// this is (32-n)\n+//\tlsl\tr4,r7\t\t// fixes the high 32 (quotient)\n+//\tlsl\tr2,r7\n+//\tcmpnei\tr4,0\n+//\tbf\t4f\t\t// the sentinel went away...\n+\n+\t// run the remaining bits\n+1:\tlslc\tr2,1\t\t// 1 bit left shift of r1-r2\n+\taddc\tr1,r1\n+\tcmphs\tr1,r3\t\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsub\tr1,r3\t\t// if yes, subtract divisor\n+2:\taddc\tr4,r4\t\t// shift by 1 and count subtracts\n+\tbf\t1b\t\t// if sentinel falls out of quotient, stop\n+\n+4:\tmov\tr2,r4\t\t// return quotient\n+\tmov\tr3,r1\t\t// piggyback the remainder\n+\tbtsti\tr5,31\t\t// after adjusting for sign\n+\tbf\t3f\n+\trsubi\tr2,0\n+\trsubi\tr3,0\n+3:\tjmp\tr15\n+FUNC_END div32\n+FUNC_END divsi3\n+#endif\n+\n+#ifdef\tL_modsi3\n+FUNC_START rem32\n+FUNC_START modsi3\n+\tmov\tr5,r2\t\t// calc sign of remainder\n+\tabs\tr2\t\t// do unsigned divide\n+\tabs\tr3\n+\tmovi\tr1,0\t\t// r1-r2 form 64 bit dividend\n+\tmovi\tr4,1\t\t// r4 is quotient (1 for a sentinel)\n+\tcmpnei\tr3,0\t\t// look for 0 divisor\n+\tbt\t9f\n+\ttrap\t3\t\t// divide by 0\n+9: \n+\t// control iterations; skip across high order 0 bits in dividend\n+\tmov\tr7,r2\n+\tcmpnei\tr7,0\n+\tbt\t8f\n+\tmovi\tr2,0\t\t// 0 dividend\n+\tjmp\tr15\t\t// quick return\n+8:\n+\tff1\tr7\t\t// figure distance to skip\n+\tlsl\tr4,r7\t\t// move the sentinel along (with 0's behind)\n+\tlsl\tr2,r7\t\t// and the low 32 bits of numerator\n+\n+1:\tlslc\tr2,1\t\t// 1 bit left shift of r1-r2\n+\taddc\tr1,r1\n+\tcmphs\tr1,r3\t\t// upper 32 of dividend >= divisor?\n+\tbf\t2f\n+\tsub\tr1,r3\t\t// if yes, subtract divisor\n+2:\taddc\tr4,r4\t\t// shift by 1 and count subtracts\n+\tbf\t1b\t\t// if sentinel falls out of quotient, stop\n+\tmov\tr2,r1\t\t// return remainder\n+\tbtsti\tr5,31\t\t// after adjusting for sign\n+\tbf\t3f\n+\trsubi\tr2,0\n+3:\tjmp\tr15\n+FUNC_END rem32\n+FUNC_END modsi3\n+#endif\n+\n+\n+/* GCC expects that {__eq,__ne,__gt,__ge,__le,__lt}{df2,sf2}\n+   will behave as __cmpdf2. So, we stub the implementations to\n+   jump on to __cmpdf2 and __cmpsf2.\n+ \n+   All of these shortcircuit the return path so that __cmp{sd}f2\n+   will go directly back to the caller. */\n+\n+.macro  COMPARE_DF_JUMP name\n+\t.import SYM (cmpdf2)\n+FUNC_START \\name\n+\tjmpi SYM (cmpdf2)\n+FUNC_END \\name\n+.endm\n+\t\t\n+#ifdef  L_eqdf2\n+COMPARE_DF_JUMP eqdf2\n+#endif /* L_eqdf2 */\n+\n+#ifdef  L_nedf2\n+COMPARE_DF_JUMP nedf2\n+#endif /* L_nedf2 */\n+\n+#ifdef  L_gtdf2\n+COMPARE_DF_JUMP gtdf2\n+#endif /* L_gtdf2 */\n+\n+#ifdef  L_gedf2\n+COMPARE_DF_JUMP gedf2\n+#endif /* L_gedf2 */\n+\n+#ifdef  L_ltdf2\n+COMPARE_DF_JUMP ltdf2\n+#endif /* L_ltdf2 */\n+\t\n+#ifdef  L_ledf2\n+COMPARE_DF_JUMP ledf2\n+#endif /* L_ledf2 */\n+\n+/* SINGLE PRECISION FLOATING POINT STUBS */\n+\n+.macro  COMPARE_SF_JUMP name\n+\t.import SYM (cmpsf2)\n+FUNC_START \\name\n+\tjmpi SYM (cmpsf2)\n+FUNC_END \\name\n+.endm\n+\t\t\n+#ifdef  L_eqsf2\n+COMPARE_SF_JUMP eqsf2\n+#endif /* L_eqsf2 */\n+\t\n+#ifdef  L_nesf2\n+COMPARE_SF_JUMP nesf2\n+#endif /* L_nesf2 */\n+\t\n+#ifdef  L_gtsf2\n+COMPARE_SF_JUMP gtsf2\n+#endif /* L_gtsf2 */\n+\t\n+#ifdef  L_gesf2\n+COMPARE_SF_JUMP __gesf2\n+#endif /* L_gesf2 */\n+\t\n+#ifdef  L_ltsf2\n+COMPARE_SF_JUMP __ltsf2\n+#endif /* L_ltsf2 */\n+\t\n+#ifdef  L_lesf2\n+COMPARE_SF_JUMP lesf2\n+#endif /* L_lesf2 */"}, {"sha": "f8623904e14d2070d7c9aac7ec1a9961617dc633", "filename": "gcc/config/mcore/mcore-elf.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-elf.h?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,206 @@\n+/* Definitions of MCore target. \n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Cygnus Solutions.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifndef __MCORE_ELF_H__\n+#define __MCORE_ELF_H__\n+\n+/* Run-time Target Specification.  */\n+#define TARGET_VERSION fputs (\" (Motorola MCORE/elf)\", stderr)\n+\n+#define SUBTARGET_CPP_PREDEFINES \" -D__ELF__\"\n+\n+#include \"svr4.h\"\n+#include \"mcore/mcore.h\"\n+\n+/* Use DWARF2 debugging info.  */\n+#ifndef DWARF2_DEBUGGING_INFO\n+#define DWARF2_DEBUGGING_INFO 1\n+#endif\n+\n+#undef  PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+\n+/* But allow DWARF 1 if the user wants it.  */\n+#ifndef DWARF_DEBUGGING_INFO\n+#define DWARF_DEBUGGING_INFO 1\n+#endif\n+\n+/* The numbers used to denote specific machine registers in the System V\n+   Release 4 DWARF debugging information are quite likely to be totally\n+   different from the numbers used in BSD stabs debugging information\n+   for the same kind of target machine.  Thus, we undefine the macro\n+   DBX_REGISTER_NUMBER here as an extra inducement to get people to\n+   provide proper machine-specific definitions of DBX_REGISTER_NUMBER\n+   (which is also used to provide DWARF registers numbers in dwarfout.c)\n+   in their tm.h files which include this file.  */\n+\n+#undef  DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* When using stabs, gcc2_compiled must be a stabs entry, not an\n+   ordinary symbol, or gdb won't see it.  The stabs entry must be\n+   before the N_SO in order for gdb to find it.  */\n+#undef  ASM_IDENTIFY_GCC\n+#define ASM_IDENTIFY_GCC(FILE)\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (write_symbols != DBX_DEBUG)\t\t\t\t\t\\\n+      fputs (\"gcc2_compiled.:\\n\", FILE);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.stabs\\t\\\"gcc2_compiled.\\\", 0x3c, 0, 0, 0\\n\", FILE);\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* MCore defines .long and .short to NOT force any alignment.\n+   This lets you misalign as much as you wish.  */\n+#define\tUNALIGNED_INT_ASM_OP\t\".long\"\n+#define\tUNALIGNED_SHORT_ASM_OP\t\".short\"\n+\n+#define EXPORTS_SECTION_ASM_OP\t\"\\t.section .exports\"\n+\n+#define SUBTARGET_EXTRA_SECTIONS in_const, in_exports\n+\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\\\n+  EXPORT_SECTION_FUNCTION\t\t\t\\\n+\n+/* CONST_SECTION_FUNCTION is defined svr4.h.  */\n+\n+#define EXPORT_SECTION_FUNCTION \t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+exports_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_exports)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", EXPORTS_SECTION_ASM_OP);\t\\\n+      in_section = in_exports;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define SUBTARGET_SWITCH_SECTIONS\t\t\\\n+  case in_exports: exports_section (); break;\t\\\n+  case in_const: const_section (); break;\n+\n+\n+#define MCORE_EXPORT_NAME(STREAM, NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      exports_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       MCORE_STRIP_NAME_ENCODING (NAME));\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0);\n+\n+/* Write the extra assembler code needed to declare a function properly.\n+   Some svr4 assemblers need to also have something extra said about the\n+   function's return value.  We allow for that here.  */\n+#undef  ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (mcore_dllexport_name_p (NAME))\t\t\\\n+\t{\t\t\t\t\t\t\\\n+          MCORE_EXPORT_NAME (FILE, NAME);\t\t\\\n+\t  function_section (DECL);\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\\\n+      putc ('\\n', FILE);\t\t\t\t\\\n+      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\\\n+      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Write the extra assembler code needed to declare an object properly.  */\n+#undef  ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\t\\\n+      if (mcore_dllexport_name_p (NAME))\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\t\\\n+          enum in_section save_section = in_section;\t\t\t\t\\\n+\t  MCORE_EXPORT_NAME (FILE, NAME);\t\t\t\t\t\\\n+          switch_to_section (save_section, (DECL));\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t%s\\t \", TYPE_ASM_OP);\t\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n+      size_directive_output = 0;\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL))\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\t\\\n+          size_directive_output = 1;\t\t\t\t\t\t\\\n+          fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);\t\t\t\t\\\n+          assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+          fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+        }\t\t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+ \n+/* Output the size directive for a decl in rest_of_decl_compilation\n+   in the case where we did not do so before the initializer.\n+   Once we find the error_mark_node, we know that the value of\n+   size_directive_output was set\n+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n+#undef  ASM_FINISH_DECLARE_OBJECT\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)         \\\n+  do                                                                     \\\n+    {                                                                    \\\n+      char * name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);                 \\\n+      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)               \\\n+          && ! AT_END && TOP_LEVEL                                       \\\n+          && DECL_INITIAL (DECL) == error_mark_node                      \\\n+          && !size_directive_output)                                     \\\n+        {                                                                \\\n+          fprintf (FILE, \"\\t%s\\t \", SIZE_ASM_OP);                        \\\n+          assemble_name (FILE, name);                                    \\\n+          fprintf (FILE, \",%d\\n\",  int_size_in_bytes (TREE_TYPE (DECL)));\\\n+        }                                                                \\\n+    }                                                                    \\\n+  while (0)\n+\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt0.o%s crti.o%s crtbegin.o%s\"\n+\n+/* Include the OS stub library, so that the code can be simulated.\n+   This is not the right way to do this.  Ideally this kind of thing\n+   should be done in the linker script - but I have not worked out how\n+   to specify the location of a linker script in a gcc command line yet.  */\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC  \"%{!mno-lsim:-lsim} crtend.o%s crtn.o%s\"\n+\n+\n+/* The subroutine calls in the .init and .fini sections create literal\n+   pools which must be jumped around...  */\n+#define FORCE_INIT_SECTION_ALIGN\tasm (\"br 1f ; .literals ; 1:\")\n+#define FORCE_FINI_SECTION_ALIGN\tasm (\"br 1f ; .literals ; 1:\")\n+\n+#undef  CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"aw\\\"\"\n+#undef  DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"aw\\\"\"\n+     \n+#endif /* __MCORE_ELF_H__ */"}, {"sha": "89d4e6128b5ff04bed69d5db73d05e3286fe799e", "filename": "gcc/config/mcore/mcore-pe.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,251 @@\n+/* Definitions of target machine for GNU compiler, for MCore using COFF/PE.\n+   Copyright (C) 1994, 1999, 2000 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Run-time Target Specification.  */\n+#define TARGET_VERSION fputs (\" (MCORE/pe)\", stderr)\n+\n+#define SUBTARGET_CPP_PREDEFINES \" -D__pe__\"\n+\n+#include \"svr3.h\"\n+#include \"mcore/mcore.h\"\n+#include \"dbxcoff.h\"\n+\n+#undef  SDB_DEBUGGING_INFO\n+#undef  DBX_DEBUGGING_INFO\n+#define DBX_DEBUGGING_INFO 1\n+\n+/* Computed in toplev.c.  */\n+#undef  PREFERRED_DEBUGGING_TYPE\n+\n+/* Lay out additional 'sections' where we place things like code\n+   and readonly data. This gets them out of default places.  */\n+\n+#define SUBTARGET_SWITCH_SECTIONS \t\t\\\n+  case in_drectve: drectve_section (); break;\t\\\n+  case in_rdata:   rdata_section (); break;\n+\n+#define DRECTVE_SECTION_ASM_OP\t\"\\t.section .drectve\"\n+#define RDATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n+\n+#define SUBTARGET_EXTRA_SECTIONS in_drectve, in_rdata\n+\n+#define SUBTARGET_EXTRA_SECTION_FUNCTIONS \\\n+  DRECTVE_SECTION_FUNCTION\t\t  \\\n+  RDATA_SECTION_FUNCTION\n+\n+#define DRECTVE_SECTION_FUNCTION \t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+drectve_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_drectve)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DRECTVE_SECTION_ASM_OP);\t\\\n+      in_section = in_drectve;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define RDATA_SECTION_FUNCTION \t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+rdata_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", RDATA_SECTION_ASM_OP);\t\\\n+      in_section = in_rdata;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef  READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION() rdata_section ()\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+#undef  SELECT_SECTION\n+#define SELECT_SECTION(DECL, RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\trdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((0 && RELOC)\t/* should be (flag_pic && RELOC) */\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\trdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    rdata_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+#undef  SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE, RTX) rdata_section ()\n+\n+#define MCORE_EXPORT_NAME(STREAM, NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      drectve_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n+\t       MCORE_STRIP_NAME_ENCODING (NAME));\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0);\n+\n+/* Output the label for an initialized variable.  */\n+#undef  ASM_DECLARE_OBJECT_NAME\n+#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (mcore_dllexport_name_p (NAME))\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          enum in_section save_section = in_section;\t\t\\\n+\t  MCORE_EXPORT_NAME (STREAM, NAME);\t\t\t\\\n+          switch_to_section (save_section, (DECL));\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Output a function label definition.  */\n+#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (mcore_dllexport_name_p (NAME))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+          MCORE_EXPORT_NAME (STREAM, NAME);\t\t\t\\\n+\t  function_section (DECL);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0);\n+\n+#undef  ASM_FILE_START\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      extern char * version_string;\t\t\t\t\\\n+      fprintf (STREAM, \"%s Generated by gcc %s for MCore/pe\\n\",\t\\\n+\t   ASM_COMMENT_START, version_string);\t\t\t\\\n+      output_file_directive ((STREAM), main_input_filename);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_OUTPUT_SOURCE_LINE\n+#define ASM_OUTPUT_SOURCE_LINE(FILE, LINE)\t\t\t\t  \\\n+  {\t\t\t\t\t\t\t\t\t  \\\n+    if (write_symbols == DBX_DEBUG)\t\t\t\t\t  \\\n+      {\t\t\t\t\t\t\t\t\t  \\\n+        static int sym_lineno = 1;\t\t\t\t\t  \\\n+        char buffer[256];\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+        ASM_GENERATE_INTERNAL_LABEL (buffer, \"LM\", sym_lineno);\t\t  \\\n+        fprintf (FILE, \".stabn 68,0,%d,\", LINE);\t\t\t  \\\n+        assemble_name (FILE, buffer);\t\t\t\t\t  \\\n+        putc ('-', FILE);\t\t\t\t\t\t  \\\n+        assemble_name (FILE,\t\t\t\t\t\t  \\\n+\t\t   XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0)); \\\n+        putc ('\\n', FILE);\t\t\t\t\t\t  \\\n+        ASM_OUTPUT_INTERNAL_LABEL (FILE, \"LM\", sym_lineno);\t\t  \\\n+        sym_lineno ++;\t\t\t\t\t\t\t  \\\n+      }\t\t\t\t\t\t\t\t\t  \\\n+  }\n+\n+#define STARTFILE_SPEC \"crt0.o%s\"\n+#define ENDFILE_SPEC  \"%{!mno-lsim:-lsim}\"\n+\n+#undef  CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP\t\".section\\t.ctors,\\\"x\\\"\"\n+#undef  DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP\t\".section\\t.dtors,\\\"x\\\"\"\n+\n+#define INT_ASM_OP \".long\"\n+\n+#undef  ASM_OUTPUT_CONSTRUCTOR\n+#define ASM_OUTPUT_CONSTRUCTOR(STREAM, NAME) \t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      ctors_section ();\t\t\t\t\\\n+      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+      assemble_name (STREAM, NAME);\t\t\\\n+      fprintf (STREAM, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#undef  ASM_OUTPUT_DESTRUCTOR\n+#define ASM_OUTPUT_DESTRUCTOR(STREAM, NAME) \t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      dtors_section ();                   \t\\\n+      fprintf (STREAM, \"\\t%s\\t \", INT_ASM_OP);\t\\\n+      assemble_name (STREAM, NAME);             \\\n+      fprintf (STREAM, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n+#define CTOR_LISTS_DEFINED_EXTERNALLY\n+\n+#undef DO_GLOBAL_CTORS_BODY\n+#undef DO_GLOBAL_DTORS_BODY\n+#undef INIT_SECTION_ASM_OP\n+\n+#define UNIQUE_SECTION_P(DECL) DECL_ONE_ONLY (DECL)\n+\n+#define SUPPORTS_ONE_ONLY 1\n+\n+/* A C statement to output something to the assembler file to switch to section\n+   NAME for object DECL which is either a FUNCTION_DECL, a VAR_DECL or\n+   NULL_TREE.  Some target formats do not support arbitrary sections.  Do not\n+   define this macro in such cases.  */\n+#undef  ASM_OUTPUT_SECTION_NAME\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC) \t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((DECL) && TREE_CODE (DECL) == FUNCTION_DECL)\t\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"x\\\"\\n\", NAME);\t\\\n+      else if ((DECL) && DECL_READONLY_SECTION (DECL, RELOC))\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"\\\"\\n\", NAME);\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.section %s,\\\"w\\\"\\n\", NAME);\t\\\n+      /* Functions may have been compiled at various levels of\t\\\n+\t optimization so we can't use `same_size' here.  \t\\\n+\t Instead, have the linker pick one.  */\t\t\t\\\n+      if ((DECL) && DECL_ONE_ONLY (DECL))\t\t\t\\\n+\tfprintf (STREAM, \"\\t.linkonce %s\\n\",\t\t\t\\\n+\t\t TREE_CODE (DECL) == FUNCTION_DECL\t\t\\\n+\t\t ? \"discard\" : \"same_size\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "5069a62dbc1100cfa78a7707a4b034313ea017d6", "filename": "gcc/config/mcore/mcore-protos.h", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-protos.h?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,109 @@\n+/* Prototypes for exported functions defined in mcore.c\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Nick Clifton (nickc@cygnus.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+extern char * mcore_output_jump_label_table\tPARAMS ((void));\n+extern void   mcore_expand_prolog          \tPARAMS ((void));\n+extern void   mcore_expand_epilog          \tPARAMS ((void));\n+extern int    mcore_const_ok_for_inline    \tPARAMS ((long));\n+extern int    mcore_num_ones               \tPARAMS ((int));\n+extern int    mcore_num_zeros              \tPARAMS ((int));\n+extern int    mcore_initial_elimination_offset\tPARAMS ((int, int));\n+extern int    mcore_byte_offset            \tPARAMS ((unsigned int));\n+extern int    mcore_halfword_offset        \tPARAMS ((unsigned int));\n+extern int    mcore_const_trick_uses_not   \tPARAMS ((long));\n+extern void   mcore_override_options       \tPARAMS ((void));\n+extern int    mcore_dllexport_name_p       \tPARAMS ((char *));\n+extern int    mcore_dllimport_name_p       \tPARAMS ((char *));\n+extern int    mcore_naked_function_p       \tPARAMS ((void));\n+\n+#ifdef TREE_CODE\n+extern void   mcore_unique_section         \tPARAMS ((tree, int));\n+extern void   mcore_encode_section_info    \tPARAMS ((tree));\n+extern int    mcore_valid_machine_decl_attribute PARAMS ((tree, tree, tree, tree));\n+extern tree   mcore_merge_machine_decl_attributes PARAMS ((tree, tree));\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern int    mcore_function_arg_partial_nregs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n+extern void   mcore_setup_incoming_varargs\tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int *));\n+extern int    mcore_num_arg_regs           \tPARAMS ((enum machine_mode, tree));\n+extern int    mcore_must_pass_on_stack     \tPARAMS ((enum machine_mode, tree));\n+#endif /* HAVE_MACHINE_MODES */\n+\n+#ifdef RTX_CODE\n+extern rtx  mcore_function_value         PARAMS ((tree, tree));\n+#endif /* RTX_CODE */\n+#endif /* TREE_CODE */\n+\n+#ifdef RTX_CODE\n+\n+extern rtx arch_compare_op0;\n+extern rtx arch_compare_op1;\n+\n+extern char * mcore_output_bclri         \tPARAMS ((rtx, int));\n+extern char * mcore_output_bseti         \tPARAMS ((rtx, int));\n+extern char * mcore_output_cmov          \tPARAMS ((rtx *, int, char *));\n+extern char * mcore_output_call          \tPARAMS ((rtx *, int));\n+extern int    mcore_is_dead                \tPARAMS ((rtx, rtx));\n+extern int    mcore_expand_insv            \tPARAMS ((rtx *));\n+extern int    mcore_modify_comparison      \tPARAMS ((RTX_CODE));\n+extern void   mcore_expand_block_move      \tPARAMS ((rtx, rtx, rtx *));\n+extern rtx    mcore_dependent_simplify_rtx \tPARAMS ((rtx, int, int, int, int *));\n+extern void   mcore_dependent_reorg        \tPARAMS ((rtx));\n+extern int    mcore_const_costs            \tPARAMS ((rtx, RTX_CODE));\n+extern int    mcore_and_cost               \tPARAMS ((rtx));\n+extern int    mcore_ior_cost               \tPARAMS ((rtx));\n+extern char * mcore_output_andn          \tPARAMS ((rtx, rtx *));\n+extern void   mcore_print_operand_address  \tPARAMS ((FILE *, rtx));\n+extern void   mcore_print_operand          \tPARAMS ((FILE *, rtx, int));\n+extern rtx    mcore_gen_compare_reg        \tPARAMS ((RTX_CODE));\n+extern int    mcore_symbolic_address_p     \tPARAMS ((rtx));\n+extern enum reg_class mcore_reload_class \tPARAMS ((rtx, enum reg_class));\n+extern int    mcore_is_same_reg            \tPARAMS ((rtx, rtx));\n+extern int    mcore_arith_S_operand         \tPARAMS ((rtx));\n+\n+#ifdef HAVE_MACHINE_MODES\n+extern char * mcore_output_move          \tPARAMS ((rtx, rtx *, enum machine_mode));\n+extern char * mcore_output_movedouble    \tPARAMS ((rtx *, enum machine_mode));\n+extern char * mcore_output_inline_const_forced\tPARAMS ((rtx, rtx *, enum machine_mode));\n+extern int    mcore_arith_reg_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_general_movsrc_operand  \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_general_movdst_operand  \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_reload_operand          \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_J_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_K_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_K_operand_not_0   \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_M_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_K_S_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_imm_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_any_imm_operand   \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_arith_O_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_literal_K_operand       \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_addsub_operand          \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_compare_operand         \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_load_multiple_operation \tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_store_multiple_operation\tPARAMS ((rtx, enum machine_mode));\n+extern int    mcore_call_address_operand    \tPARAMS ((rtx, enum machine_mode));\n+\n+#ifdef TREE_CODE\n+extern rtx    mcore_function_arg           \tPARAMS ((CUMULATIVE_ARGS, enum machine_mode, tree, int));\n+#endif /* TREE_CODE */\n+#endif /* HAVE_MACHINE_MODES */\n+#endif /* RTX_CODE */"}, {"sha": "2fa8c8183111359ca9439dd3fe11d904bdf4639d", "filename": "gcc/config/mcore/mcore.c", "status": "added", "additions": 3574, "deletions": 0, "changes": 3574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=8f90be4c548e561185025888c42a986b10bfe3c2"}, {"sha": "a165004e01455be928a922be387becbd9784a9ef", "filename": "gcc/config/mcore/mcore.h", "status": "added", "additions": 1458, "deletions": 0, "changes": 1458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,1458 @@\n+/* Definitions of target machine for GNU compiler,\n+   for Motorola M*CORE Processor.\n+   Copyright (C) 1993, 1999, 2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#ifndef __MCORE__H\n+#define __MCORE__H\n+\n+/* RBE: need to move these elsewhere.  */\n+#undef\tLIKE_PPC_ABI \n+#define\tMCORE_STRUCT_ARGS\n+/* RBE: end of \"move elsewhere\".  */\n+\n+#include \"hwint.h\"\n+\n+#ifndef HAVE_MACHINE_MODES\n+#include \"machmode.h\"\n+#endif\n+\n+/* Run-time Target Specification.  */\n+#define TARGET_MCORE\n+\n+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS\n+   is a valid machine specific attribute for DECL.\n+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */\n+#undef  VALID_MACHINE_DECL_ATTRIBUTE\n+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n+  mcore_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n+\n+#define MERGE_MACHINE_DECL_ATTRIBUTES(OLD, NEW) \\\n+  mcore_merge_machine_decl_attributes (OLD, NEW)\n+\n+/* Support the __declspec keyword by turning them into attributes.\n+   We currently only support: dllexport and dllimport.\n+   Note that the current way we do this may result in a collision with\n+   predefined attributes later on.  This can be solved by using one attribute,\n+   say __declspec__, and passing args to it.  The problem with that approach\n+   is that args are not accumulated: each new appearance would clobber any\n+   existing args.  XXX- FIXME the definition below relies upon string\n+   concatenation, which is non-portable.  */\n+#define CPP_PREDEFINES \\\n+  \"-D__mcore__ -D__MCORE__=1 -D__declspec(x)=__attribute__((x))\" SUBTARGET_CPP_PREDEFINES\n+\n+/* If -m4align is ever re-enabled then uncomment this line as well:\n+   #define CPP_SPEC \"%{!m4align:-D__MCORE_ALIGN_8__} %{m4align:-D__MCORE__ALIGN_4__}\" */\n+\n+#undef  CPP_SPEC\n+#define CPP_SPEC \"\t\t\t\t\t\t\t\\\n+%{mbig-endian:\t\t\t\t\t\t\t\t\\\n+  %{mlittle-endian:%echoose either big or little endian, not both}\t\\\n+  -D__MCOREBE__}\t\t\t\t\t\t\t\\\n+%{m210:\t\t\t\t\t\t\t\t\t\\\n+  %{m340:%echoose either m340 or m210 not both}\t\t\t\t\\\n+  %{mlittle-endian:%ethe m210 does not have little endian support}\t\\\n+  -D__M210__}\t\t\t\t\t\t\t\t\\\n+%{!mbig-endian: -D__MCORELE__}\t\t\t\t\t\t\\\n+%{!m210: -D__M340__}\t\t\t\t\t\t\t\\\n+\"\n+/* If -m4align is ever re-enabled then add this line to the defintion of CPP_SPEC\n+   %{!m4align:-D__MCORE_ALIGN_8__} %{m4align:-D__MCORE__ALIGN_4__} */\n+\n+/* We don't have a -lg library, so don't put it in the list.  */\n+#undef\tLIB_SPEC\n+#define LIB_SPEC \"%{!shared: %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}\"\n+\n+#undef\tASM_SPEC\n+#define\tASM_SPEC \"%{mbig-endian:-EB} %{m210:-cpu=210 -EB}\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC \"%{mbig-endian:-EB} %{m210:-EB} -X\"\n+\n+/* Can only count on 16 bits of availability; change to long would affect\n+   many architecture specific files (other architectures...).  */\n+extern int target_flags;\n+\n+#define HARDLIT_BIT\t   (1 << 0) /* Build in-line literals using 2 insns */\n+#define ALIGN8_BIT\t   (1 << 1) /* Max alignment goes to 8 instead of 4 */\n+#define DIV_BIT\t\t   (1 << 2) /* Generate divide instructions */\n+#define RELAX_IMM_BIT\t   (1 << 3) /* Arbitrary immediates in and, or, tst */\n+#define W_FIELD_BIT\t   (1 << 4) /* Generate bit insv/extv using SImode */\n+#define\tOVERALIGN_FUNC_BIT (1 << 5) /* Align functions to 4 byte boundary */\n+#define CGDATA_BIT\t   (1 << 6) /* Generate callgraph data */\n+#define SLOW_BYTES_BIT     (1 << 7) /* Slow byte access */\n+#define LITTLE_END_BIT     (1 << 8) /* Generate little endian code */\n+#define M340_BIT           (1 << 9) /* Generate code for the m340 */\n+\n+#define TARGET_DEFAULT     \\\n+ (HARDLIT_BIT | ALIGN8_BIT | DIV_BIT | RELAX_IMM_BIT | M340_BIT | LITTLE_END_BIT)\n+\n+#ifndef MULTILIB_DEFAULTS\n+#define MULTILIB_DEFAULTS { \"mlittle-endian\", \"m340\" }\n+#endif\n+\n+#define TARGET_HARDLIT\t\t(target_flags & HARDLIT_BIT)\n+/* The ability to have 4 byte alignment is being suppressed for now.\n+   If this ability is reenabled, you must enable the definition below\n+   *and* edit t-mcore to enable multilibs for 4 byte alignment code.  */\n+#if 0 \n+#define TARGET_8ALIGN\t\t(target_flags & ALIGN8_BIT)\n+#else\n+#define TARGET_8ALIGN\t\t1\n+#endif\n+#define TARGET_DIV\t\t(target_flags & DIV_BIT)\n+#define TARGET_RELAX_IMM        (target_flags & RELAX_IMM_BIT)\n+#define TARGET_W_FIELD          (target_flags & W_FIELD_BIT)\n+#define TARGET_OVERALIGN_FUNC   (target_flags & OVERALIGN_FUNC_BIT)\n+#define TARGET_CG_DATA \t\t(target_flags & CGDATA_BIT)\n+#define TARGET_CG_DATA \t\t(target_flags & CGDATA_BIT)\n+#define TARGET_SLOW_BYTES \t(target_flags & SLOW_BYTES_BIT)\n+#define TARGET_LITTLE_END\t(target_flags & LITTLE_END_BIT)\n+#define TARGET_M340 \t\t(target_flags & M340_BIT)\n+\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\\\n+{ {\"hardlit\", \t            HARDLIT_BIT,\t\t\t\\\n+     \"Inline constants if it can be done in 2 insns or less\" },\t\\\n+  {\"no-hardlit\",          - HARDLIT_BIT,\t\t\t\\\n+     \"inline constants if it only takes 1 instruction\" },\t\\\n+  {\"4align\",              - ALIGN8_BIT,\t\t\t\t\\\n+     \"Set maximum alignment to 4\" },\t\t\t\t\\\n+  {\"8align\",\t            ALIGN8_BIT,\t\t\t\t\\\n+     \"Set maximum alignment to 8\" },\t\t\t\t\\\n+  {\"div\",                   DIV_BIT,\t\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  {\"no-div\",\t          - DIV_BIT,\t\t\t\t\\\n+     \"Do not use the divide instruction\" },\t\t\t\\\n+  {\"relax-immediates\",      RELAX_IMM_BIT,\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  {\"no-relax-immediates\", - RELAX_IMM_BIT,\t\t\t\\\n+     \"Do not arbitary sized immediates in bit operations\" },\t\\\n+  {\"wide-bitfields\",        W_FIELD_BIT,\t\t\t\\\n+     \"Always treat bitfield as int-sized\" },\t\t\t\\\n+  {\"no-wide-bitfields\",   - W_FIELD_BIT,\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  {\"4byte-functions\",       OVERALIGN_FUNC_BIT,\t\t\t\\\n+     \"Force functions to be aligned to a 4 byte boundary\" },\t\\\n+  {\"no-4byte-functions\",  - OVERALIGN_FUNC_BIT,\t\t\t\\\n+     \"Force functions to be aligned to a 2 byte boundary\" },\t\\\n+  {\"callgraph-data\",        CGDATA_BIT,\t\t\t\t\\\n+     \"Emit call graph information\" },\t\t\t\t\\\n+  {\"no-callgraph-data\",   - CGDATA_BIT,\t\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  {\"slow-bytes\",            SLOW_BYTES_BIT,\t\t\t\\\n+     \"Prefer word accesses over byte accesses\" },\t\t\\\n+  {\"no-slow-bytes\",       - SLOW_BYTES_BIT,\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  { \"no-lsim\",              0, \"\" },\t\t\t \t\\\n+  {\"little-endian\",         LITTLE_END_BIT,\t\t\t\\\n+     \"Generate little endian code\" },\t\t\t\t\\\n+  {\"big-endian\",          - LITTLE_END_BIT,\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  {\"210\",                 - M340_BIT,\t\t\t\t\\\n+     \"\" },\t\t\t\t\t\t\t\\\n+  {\"340\",                   M340_BIT,\t\t\t\t\\\n+     \"Generate code for the M*Core M340\" },\t\t\t\\\n+  {\"\",   \t            TARGET_DEFAULT,\t\t\t\\\n+     \"\" }\t\t\t\t\t\t\t\\\n+}\n+\n+extern char * mcore_current_function_name;\n+ \n+/* Target specific options (as opposed to the switches above).  */\n+extern const char * mcore_stack_increment_string;\n+\n+#define\tTARGET_OPTIONS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  {\"stack-increment=\", & mcore_stack_increment_string,\t\t\\\n+     \"Maximum amount for a single stack increment operation\"}\t\\\n+}\n+\n+/* The MCore ABI says that bitfields are unsigned by default. */\n+/* The EPOC C++ environment does not support exceptions.  */\n+#define CC1_SPEC \"-funsigned-bitfields %{!DIN_GCC:-fno-rtti} %{!DIN_GCC:-fno-exceptions}\"\n+\n+/* What options are we going to default to specific settings when\n+   -O* happens; the user can subsequently override these settings.\n+  \n+   Omitting the frame pointer is a very good idea on the MCore.\n+   Scheduling isn't worth anything on the current MCore implementation.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\\\n+{\t\t\t\t\t\t\\\n+  if (LEVEL)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      flag_no_function_cse = 1;\t\t\t\\\n+      flag_omit_frame_pointer = 1;\t\t\\\n+\t\t\t\t\t\t\\\n+      if (LEVEL >= 2)\t\t\t\t\\\n+        {\t\t\t\t\t\\\n+          flag_caller_saves = 0;\t\t\\\n+          flag_schedule_insns = 0;\t\t\\\n+          flag_schedule_insns_after_reload = 0;\t\\\n+        }\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  if (SIZE)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      target_flags &= ~ HARDLIT_BIT;\t\t\\\n+    }\t\t\t\t\t\t\\\n+}\n+\n+/* What options are we going to force to specific settings,\n+   regardless of what the user thought he wanted.\n+   We also use this for some post-processing of options. */\n+#define OVERRIDE_OPTIONS  mcore_override_options ()\n+\n+/* Target machine storage Layout.  */\n+\n+/* Define to use software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion.  */\n+#define REAL_ARITHMETIC\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT         \\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD) \\\n+    {\t\t\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\\\n+      (UNSIGNEDP) = 1;\t\t\t\t\\\n+    }\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+#define PROMOTE_FUNCTION_RETURN\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN  0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN (! TARGET_LITTLE_END)\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN (! TARGET_LITTLE_END)\n+\n+#define LIBGCC2_WORDS_BIG_ENDIAN 1\n+#ifdef __MCORELE__\n+#undef  LIBGCC2_WORDS_BIG_ENDIAN\n+#define LIBGCC2_WORDS_BIG_ENDIAN 0\n+#endif\n+\n+/* Number of bits in an addressable storage unit.  */\n+#define BITS_PER_UNIT  8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD  32\n+#define MAX_BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD\t4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE  32\n+\n+/* A C expression for the size in bits of the type `long long' on the\n+   target machine.  If you don't define this, the default is two\n+   words.  */\n+#define LONG_LONG_TYPE_SIZE 64\n+\n+/* the size of the boolean type -- in C++; */\n+#define\tBOOL_TYPE_SIZE\t8\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY  \t32\n+\n+/* Doubles must be alogned to an 8 byte boundary.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+  ((MODE != BLKmode && (GET_MODE_SIZE (MODE) == 8)) \\\n+   ? BIGGEST_ALIGNMENT : PARM_BOUNDARY)\n+     \n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY  (TARGET_8ALIGN ? 64 : 32)\n+\n+/* Largest increment in UNITS we allow the stack to grow in a single operation.  */\n+extern int mcore_stack_increment;\n+#define STACK_UNITS_MAXSTEP  4096\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY  ((TARGET_OVERALIGN_FUNC) ? 32 : 16)\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY  32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT  (TARGET_8ALIGN ? 64 : 32)\n+\n+/* The best alignment to use in cases where we have a choice.  */\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Every structures size must be a multiple of 8 bits.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* Look at the fundamental type that is used for a bitfield and use \n+   that to impose alignment on the enclosing structure.\n+   struct s {int a:8}; should have same alignment as \"int\", not \"char\".  */\n+#define\tPCC_BITFIELD_TYPE_MATTERS\t1\n+\n+/* Largest integer machine mode for structures.  If undefined, the default\n+   is GET_MODE_SIZE(DImode).  */\n+#define MAX_FIXED_MODE_SIZE 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  ((TREE_CODE (EXP) == STRING_CST\t\\\n+    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n+   ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+     \n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Standard register usage.  */\n+\n+/* Register allocation for our first guess \n+\n+\tr0\t\tstack pointer\n+\tr1\t\tscratch, target reg for xtrb?\n+\tr2-r7\t\targuments.\n+\tr8-r14\t\tcall saved\n+\tr15\t\tlink register\n+\tap\t\targ pointer (doesn't really exist, always eliminated)\n+\tc               c bit\n+\tfp\t\tframe pointer (doesn't really exist, always eliminated)\n+\tx19\t\ttwo control registers  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   MCore has 16 integer registers and 2 control registers + the arg\n+   pointer.  */\n+\n+#define FIRST_PSEUDO_REGISTER 20\n+\n+#define R1_REG  1\t/* where literals are forced */\n+#define LK_REG\t15\t/* overloaded on general register */\n+#define AP_REG  16\t/* fake arg pointer register */\n+/* RBE: mcore.md depends on CC_REG being set to 17 */\n+#define CC_REG\t17\t/* cant name it C_REG */\n+#define FP_REG  18\t/* fake frame pointer register */\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+\n+#undef PC_REGNUM /* Define this if the program counter is overloaded on a register.  */\n+#define STACK_POINTER_REGNUM 0 /* Register to use for pushing function arguments.  */\n+#define FRAME_POINTER_REGNUM 8 /* When we need FP, use r8.  */\n+\n+/* The assembler's names for the registers.  RFP need not always be used as\n+   the Real framepointer; it can also be used as a normal general register.\n+   Note that the name `fp' is horribly misleading since `fp' is in fact only\n+   the argument-and-return-context pointer.  */\n+#define REGISTER_NAMES  \t\t\t\t\\\n+{\t\t\t\t                   \t\\\n+  \"sp\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n+  \"apvirtual\",  \"c\", \"fpvirtual\", \"x19\" \\\n+}\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.  */\n+#define FIXED_REGISTERS  \\\n+ /*  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15 ap  c  fp x19 */ \\\n+   { 1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1, 1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+/* RBE: r15 {link register} not available across calls,\n+ *  But we don't mark it that way here... */\n+#define CALL_USED_REGISTERS \\\n+ /*  r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 r11 r12 r13 r14 r15 ap  c   fp x19 */ \\\n+   { 1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1, 1}\n+\n+/* The order in which register should be allocated.  */\n+#define REG_ALLOC_ORDER  \\\n+ /* r7  r6  r5  r4  r3  r2  r15 r14 r13 r12 r11 r10  r9  r8  r1  r0  ap  c   fp x19*/ \\\n+  {  7,  6,  5,  4,  3,  2,  15, 14, 13, 12, 11, 10,  9,  8,  1,  0, 16, 17, 18, 19}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   On the MCore regs are UNITS_PER_WORD bits wide; */\n+#define HARD_REGNO_NREGS(REGNO, MODE)  \\\n+   (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   We may keep double values in even registers.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)  \\\n+  ((TARGET_8ALIGN && GET_MODE_SIZE (MODE) > UNITS_PER_WORD) ? (((REGNO) & 1) == 0) : (REGNO < 18))\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  ((MODE1) == (MODE2) || GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms may be accessed\n+   via the stack pointer) in functions that seem suitable.  */\n+#define FRAME_POINTER_REQUIRED\t0\n+\n+/* Definitions for register eliminations.\n+\n+   We have two registers that can be eliminated on the MCore.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer.  */\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM\t16\n+\n+/* Register in which the static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM\t1\n+\n+/* This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM},}\n+\n+/* Given FROM and TO register numbers, say whether this elimination\n+   is allowed.  */\n+#define CAN_ELIMINATE(FROM, TO) \\\n+  (!((FROM) == FRAME_POINTER_REGNUM && FRAME_POINTER_REQUIRED))\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  OFFSET = mcore_initial_elimination_offset (FROM, TO)\n+\n+/* Place that structure value return address is placed.  */\n+#define STRUCT_VALUE 0\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The MCore has only general registers. There are\n+   also some special purpose registers: the T bit register, the\n+   procedure Link and the Count Registers */\n+enum reg_class\n+{\n+  NO_REGS,\n+  ONLYR1_REGS,\n+  LRW_REGS,\n+  GENERAL_REGS,\n+  C_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES  (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+#define REG_CLASS_NAMES  \\\n+{\t\t\t\\\n+  \"NO_REGS\",\t\t\\\n+  \"ONLYR1_REGS\",\t\\\n+  \"LRW_REGS\",\t\t\\\n+  \"GENERAL_REGS\",\t\\\n+  \"C_REGS\",\t\t\\\n+  \"ALL_REGS\",\t\t\\\n+}\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+/* ??? STACK_POINTER_REGNUM should be excluded from LRW_REGS.  */\n+#define REG_CLASS_CONTENTS      \t\\\n+{\t\t\t\t\t\\\n+  {0x000000},  /* NO_REGS       */\t\\\n+  {0x000002},  /* ONLYR1_REGS   */\t\\\n+  {0x007FFE},  /* LRW_REGS      */\t\\\n+  {0x01FFFF},  /* GENERAL_REGS  */\t\\\n+  {0x020000},  /* C_REGS        */\t\\\n+  {0x0FFFFF}   /* ALL_REGS      */\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+extern int regno_reg_class[];\n+#define REGNO_REG_CLASS(REGNO) regno_reg_class[REGNO]\n+\n+/* When defined, the compiler allows registers explicitly used in the\n+   rtl to be used as spill registers but prevents the compiler from\n+   extending the lifetime of these registers.  */\n+#define SMALL_REGISTER_CLASSES 1\n+ \n+/* The class value for index registers, and the one for base regs.  */\n+#define INDEX_REG_CLASS  NO_REGS\n+#define BASE_REG_CLASS\t GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine \n+   description.  */\n+extern enum reg_class reg_class_from_letter[];\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+   ( (C) >= 'a' && (C) <= 'z' ? reg_class_from_letter[(C) - 'a'] : NO_REGS )\n+\n+/* The letters I, J, K, L, M, N, O, and P in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\tI: loadable by movi (0..127)\n+\tJ: arithmetic operand 1..32\n+\tK: shift operand 0..31\n+\tL: negative arithmetic operand -1..-32\n+\tM: powers of two, constants loadable by bgeni\n+\tN: powers of two minus 1, constants loadable by bmaski, including -1\n+        O: allowed by cmov with two constants +/- 1 of each other\n+        P: values we will generate 'inline' -- without an 'lrw'\n+\n+   Others defined for use after reload\n+        Q: constant 1\n+\tR: a label\n+        S: 0/1/2 cleared bits out of 32\t[for bclri's]\n+        T: 2 set bits out of 32\t[for bseti's]\n+        U: constant 0\n+        xxxS: 1 cleared bit out of 32 (complement of power of 2). for bclri\n+        xxxT: 2 cleared bits out of 32. for pairs of bclris.  */\n+#define CONST_OK_FOR_I(VALUE) (((int)(VALUE)) >= 0 && ((int)(VALUE)) <= 0x7f)\n+#define CONST_OK_FOR_J(VALUE) (((int)(VALUE)) >  0 && ((int)(VALUE)) <= 32)\n+#define CONST_OK_FOR_L(VALUE) (((int)(VALUE)) <  0 && ((int)(VALUE)) >= -32)\n+#define CONST_OK_FOR_K(VALUE) (((int)(VALUE)) >= 0 && ((int)(VALUE)) <= 31)\n+#define CONST_OK_FOR_M(VALUE) (exact_log2 (VALUE) >= 0)\n+#define CONST_OK_FOR_N(VALUE) (((int)(VALUE)) == -1 || exact_log2 ((VALUE) + 1) >= 0)\n+#define CONST_OK_FOR_O(VALUE) (CONST_OK_FOR_I(VALUE) || \\\n+                               CONST_OK_FOR_M(VALUE) || \\\n+                               CONST_OK_FOR_N(VALUE) || \\\n+                               CONST_OK_FOR_M((int)(VALUE) - 1) || \\\n+                               CONST_OK_FOR_N((int)(VALUE) + 1))\n+\n+#define CONST_OK_FOR_P(VALUE) (mcore_const_ok_for_inline (VALUE)) \n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)     \\\n+     ((C) == 'I' ? CONST_OK_FOR_I (VALUE)   \\\n+    : (C) == 'J' ? CONST_OK_FOR_J (VALUE)   \\\n+    : (C) == 'L' ? CONST_OK_FOR_L (VALUE)   \\\n+    : (C) == 'K' ? CONST_OK_FOR_K (VALUE)   \\\n+    : (C) == 'M' ? CONST_OK_FOR_M (VALUE)   \\\n+    : (C) == 'N' ? CONST_OK_FOR_N (VALUE)   \\\n+    : (C) == 'P' ? CONST_OK_FOR_P (VALUE)   \\\n+    : (C) == 'O' ? CONST_OK_FOR_O (VALUE)   \\\n+    : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n+   ((C) == 'G' ? CONST_OK_FOR_I (CONST_DOUBLE_HIGH (VALUE)) \\\n+\t      && CONST_OK_FOR_I (CONST_DOUBLE_LOW (VALUE))  \\\n+    : 0)\n+\n+/* Letters in the range `Q' through `U' in a register constraint string\n+   may be defined in a machine-dependent fashion to stand for arbitrary\n+   operand types.  */\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'R' ? (GET_CODE (OP) == MEM\t\t\t\\\n+\t\t && GET_CODE (XEXP (OP, 0)) == LABEL_REF) \\\n+   : (C) == 'S' ? (GET_CODE (OP) == CONST_INT \\\n+                   && mcore_num_zeros (INTVAL (OP)) <= 2) \\\n+   : (C) == 'T' ? (GET_CODE (OP) == CONST_INT \\\n+                   && mcore_num_ones (INTVAL (OP)) == 2) \\\n+   : (C) == 'Q' ? (GET_CODE (OP) == CONST_INT \\\n+                   && INTVAL(OP) == 1) \\\n+   : (C) == 'U' ? (GET_CODE (OP) == CONST_INT \\\n+                   && INTVAL(OP) == 0) \\\n+   : 0)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) mcore_reload_class (X, CLASS)\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) NO_REGS\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS. \n+\n+   On MCore this is the size of MODE in words.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)  \\\n+     (ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define the number of register that can hold parameters.\n+   These two macros are used only in other macro definitions below.  */\n+#define NPARM_REGS 6\n+#define FIRST_PARM_REG 2\n+#define FIRST_RET_REG 2\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD  \n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+/* We don't define this, because the MCore does not support\n+   addresses with negative offsets.  */\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET  0\n+\n+/* If defined, the maximum amount of space required for outgoing arguments\n+   will be computed and placed into the variable\n+   `current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue should\n+   increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL)  0\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the MCore, the callee does not pop any of its arguments that were passed\n+   on the stack.  */\n+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  mcore_function_value (VALTYPE, FUNC)\n+\n+/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n+   we want to retain compatibility with older gcc versions.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* how we are going to return big values */\n+/*\n+ * #define RETURN_IN_MEMORY(TYPE) \\\n+ *   (TYPE_MODE (TYPE) == BLKmode \\\n+ *    || ((TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE(TYPE) == UNION_TYPE) \\\n+ *        && !(TYPE_MODE (TYPE) == SImode \\\n+ * \t    || (TYPE_MODE (TYPE) == BLKmode \\\n+ * \t\t&& TYPE_ALIGN (TYPE) == BITS_PER_WORD \\\n+ * \t\t&& int_size_in_bytes (TYPE) == UNITS_PER_WORD))))\n+ */ \n+\n+\n+/* How many registers to use for struct return.  */\n+#define\tRETURN_IN_MEMORY(TYPE) (int_size_in_bytes (TYPE) > 2 * UNITS_PER_WORD)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, FIRST_RET_REG)\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the MCore, only r4 can return results.  */\n+#define FUNCTION_VALUE_REGNO_P(REGNO)  ((REGNO) == FIRST_RET_REG)\n+\n+#define\tMUST_PASS_IN_STACK(MODE,TYPE)  \\\n+  mcore_must_pass_on_stack (MODE, TYPE)\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+#define FUNCTION_ARG_REGNO_P(REGNO)  \\\n+  ((REGNO) >= FIRST_PARM_REG && (REGNO) < (NPARM_REGS + FIRST_PARM_REG))\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On MCore, this is a single integer, which is a number of words\n+   of arguments scanned so far (including the invisible argument,\n+   if any, which holds the structure-value-address).\n+   Thus NARGREGS or more means all following args should go on the stack.  */\n+#define CUMULATIVE_ARGS  int\n+\n+#define ROUND_ADVANCE(SIZE)\t\\\n+  ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Round a register number up to a proper boundary for an arg of mode \n+   MODE. \n+   \n+   We round to an even reg for things larger than a word.  */\n+#define ROUND_REG(X, MODE) \t\t\t\t\\\n+  ((TARGET_8ALIGN \t\t\t\t\t\\\n+   && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD) \t\\\n+   ? ((X) + ((X) & 1)) : (X))\n+\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On MCore, the offset always starts at 0: the first parm reg is always\n+   the same reg.  */\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)  \\\n+  ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be\n+   available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t   \\\n+ ((CUM) = (ROUND_REG ((CUM), (MODE))\t\t\t   \\\n+\t   + ((NAMED) * mcore_num_arg_regs (MODE, TYPE)))) \\\n+\n+/* Define where to put the arguments to a function.  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  mcore_function_arg (CUM, MODE, TYPE, NAMED)\n+\n+/* A C expression that indicates when an argument must be passed by\n+   reference.  If nonzero for an argument, a copy of that argument is\n+   made in memory and a pointer to the argument is passed instead of\n+   the argument itself.  The pointer is passed in whatever way is\n+   appropriate for passing a pointer to that type.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n+  MUST_PASS_IN_STACK (MODE, TYPE)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.\n+   Any arg that starts in the first NPARM_REGS regs but won't entirely\n+   fit in them needs partial registers on the MCore.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+  mcore_function_arg_partial_nregs (CUM, MODE, TYPE, NAMED)\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments.  */\n+#define SETUP_INCOMING_VARARGS(ASF, MODE, TYPE, PAS, ST) \\\n+  mcore_setup_incoming_varargs (ASF, MODE, TYPE, & PAS)\n+\n+/* Call the function profiler with a given profile label.  */\n+#define FUNCTION_PROFILER(STREAM,LABELNO)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\ttrap\t1\\n\");\t\t\t\\\n+  fprintf (STREAM, \"\t.align\t2\\n\");\t\t\t\\\n+  fprintf (STREAM, \"\t.long\tLP%d\\n\", (LABELNO));\t\\\n+}\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+#define EXIT_IGNORE_STACK 0\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   On the MCore, the trapoline looks like:\n+   \tlrw\tr1,  function\n+     \tlrw\tr13, area\n+   \tjmp\tr13\n+   \tor\tr0, r0\n+    .literals                                                */\n+#define TRAMPOLINE_TEMPLATE(FILE)  \t\t\\\n+{\t\t\t\t\t\t\\\n+  fprintf ((FILE), \"\t.short\t0x7102\\n\");\t\\\n+  fprintf ((FILE), \"\t.short\t0x7d02\\n\");\t\\\n+  fprintf ((FILE), \"\t.short\t0x00cd\\n\");     \\\n+  fprintf ((FILE), \"\t.short\t0x1e00\\n\");\t\\\n+  fprintf ((FILE), \"\t.long\t0\\n\");\t\t\\\n+  fprintf ((FILE), \"\t.long\t0\\n\");\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+#define TRAMPOLINE_SIZE  12\n+\n+/* Alignment required for a trampoline in units.  */\n+#define TRAMPOLINE_ALIGN  4\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 8)),\t\\\n+\t\t  (CXT));\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n+\t\t  (FNADDR));\t\t\t\t\t\t\\\n+}\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+  ((REGNO) < AP_REG || (unsigned) reg_renumber[(REGNO)] < AP_REG)\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO)   0\n+\n+/* Maximum number of registers that can appear in a valid memory \n+   address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Recognize any constant value that is a valid address.  */\n+#define CONSTANT_ADDRESS_P(X) \t (GET_CODE (X) == LABEL_REF)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n+\n+   On the MCore, allow anything but a double.  */\n+#define LEGITIMATE_CONSTANT_P(X) (GET_CODE(X) != CONST_DOUBLE)\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.  */\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) \\\n+    \t(REGNO (X) <= 16 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X)\t0\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X)\t\\\n+\tREGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X)\t0\n+\n+#endif\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+#define BASE_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+\n+#define INDEX_REGISTER_RTX_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+\n+\n+/* Jump to LABEL if X is a valid address RTX.  This must also take\n+   REG_OK_STRICT into account when deciding about valid registers, but it uses\n+   the above macros so we are in luck.  \n+ \n+   Allow  REG\n+\t  REG+disp \n+\n+   A legitimate index for a QI is 0..15, for HI is 0..30, for SI is 0..60,\n+   and for DI is 0..56 because we use two SI loads, etc.  */\n+#define GO_IF_LEGITIMATE_INDEX(MODE, REGNO, OP, LABEL)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (OP) == CONST_INT) \t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) >= 4\t\t\t\t\t\\\n+\t      && (((unsigned)INTVAL (OP)) % 4) == 0\t\t\t\\\n+\t      &&  ((unsigned)INTVAL (OP)) <= 64 - GET_MODE_SIZE (MODE))\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) == 2 \t\t\t\t\\\n+\t      && (((unsigned)INTVAL (OP)) % 2) == 0\t\t\t\\\n+\t      &&  ((unsigned)INTVAL (OP)) <= 30)\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t  if (GET_MODE_SIZE (MODE) == 1 \t\t\t\t\\\n+\t      && ((unsigned)INTVAL (OP)) <= 15)\t\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)                  \\\n+{ \t\t\t\t\t\t\t\t  \\\n+  if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t  \\\n+    goto LABEL;\t\t\t\t\t\t\t  \\\n+  else if (GET_CODE (X) == PLUS || GET_CODE (X) == LO_SUM) \t  \\\n+    {\t\t\t\t\t\t\t\t  \\\n+      rtx xop0 = XEXP (X,0);\t\t\t\t\t  \\\n+      rtx xop1 = XEXP (X,1);\t\t\t\t\t  \\\n+      if (BASE_REGISTER_RTX_P (xop0))\t\t\t\t  \\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop0), xop1, LABEL); \\\n+      if (BASE_REGISTER_RTX_P (xop1))\t\t\t\t  \\\n+\tGO_IF_LEGITIMATE_INDEX (MODE, REGNO (xop1), xop0, LABEL); \\\n+    }\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t   \n+\t\t\t\t\t\t\t\t   \n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (   GET_CODE (ADDR) == PRE_DEC || GET_CODE (ADDR) == POST_DEC\t\\\n+      || GET_CODE (ADDR) == PRE_INC || GET_CODE (ADDR) == POST_INC)\t\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR  FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR  TRUNC_DIV_EXPR\n+\n+/* 'char' is signed by default.  */\n+#define DEFAULT_SIGNED_CHAR  0\n+\n+/* The type of size_t unsigned int.  */\n+#define SIZE_TYPE \"unsigned int\"\n+\n+/* Don't cse the address of the function being compiled.  */\n+#define NO_RECURSIVE_FUNCTION_CSE 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define if operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n+   will either zero-extend or sign-extend.  The value of this macro should\n+   be the code that says which one of the two operations is implicitly\n+   done, NIL if none.  */\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS TARGET_SLOW_BYTES\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+#define STORE_FLAG_VALUE 1\n+\n+/* Immediate shift counts are truncated by the output routines (or was it\n+   the assembler?).  Shift counts in a register are truncated by ARM.  Note\n+   that the native compiler puts too large (> 32) immediate shift counts\n+   into a register and shifts by the register, letting the ARM decide what\n+   to do instead of doing that itself.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* All integers have the same format so truncation is easy.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC)  1\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on machines where ordinary constants are expensive\n+   but a CALL with constant address is cheap.  */\n+/* why is this defined??? -- dac */\n+#define NO_FUNCTION_CSE 1\n+\n+/* Chars and shorts should be passed as ints.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* The machine modes of pointers and functions.  */\n+#define Pmode          SImode\n+#define FUNCTION_MODE  Pmode\n+\n+/* The relative costs of various types of constants.  Note that cse.c defines\n+   REG = 1, SUBREG = 2, any node = (2 + sum of subnodes).  */\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)      \\\n+  case CONST_INT:\t\t\t\t\\\n+    return mcore_const_costs (RTX, OUTER_CODE); \\\n+  case CONST: \t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\\\n+    return 5;\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\\\n+      return 10;\n+\n+/* provide the cost for an address calculation.\n+   All addressing modes cost the same on the MCore.  */\n+#define\tADDRESS_COST(RTX)\t1\n+\n+/* Provide the cost of an rtl expression. */\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n+  case AND:                                             \\\n+    return COSTS_N_INSNS (mcore_and_cost (X));          \\\n+  case IOR:                                             \\\n+    return COSTS_N_INSNS (mcore_ior_cost (X));          \\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (100);\t\t\t\t\\\n+  case FLOAT:\t\t\t\t\t\t\\\n+  case FIX:\t\t\t\t\t\t\\\n+    return 100;\n+\n+/* Compute extra cost of moving data between one register class\n+   and another.  All register moves are cheap.  */\n+#define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS) 2\n+\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Provided in ANSI C MCore libraries.  */\n+#undef  HAVE_ATEXIT\n+#define HAVE_ATEXIT 1\n+\n+/* Implicit library calls should use memcpy, not bcopy, etc.  */\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Assembler output control.  */\n+#define ASM_COMMENT_START \"\\t//\"\n+\n+#define ASM_APP_ON\t\"// inline asm begin\\n\"\n+#define ASM_APP_OFF\t\"// inline asm end\\n\"\n+\n+#define FILE_ASM_OP     \"\\t.file\\n\"\n+\n+/* Switch to the text or data segment.  */\n+#define TEXT_SECTION_ASM_OP  \"\\t.text\"\n+#define DATA_SECTION_ASM_OP  \"\\t.data\"\n+\n+#undef  EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_ctors, in_dtors, SUBTARGET_EXTRA_SECTIONS\n+\n+#undef  EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\\\n+  DTORS_SECTION_FUNCTION\t\t\t\\\n+  SUBTARGET_EXTRA_SECTION_FUNCTIONS\t\t\\\n+  SWITCH_SECTION_FUNCTION\n+\n+#ifndef CTORS_SECTION_FUNCTION\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+#endif\n+\n+/* Switch to SECTION (an `enum in_section').\n+\n+   ??? This facility should be provided by GCC proper.\n+   The problem is that we want to temporarily switch sections in\n+   ASM_DECLARE_OBJECT_NAME and then switch back to the original section\n+   afterwards.  */\n+#define SWITCH_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+switch_to_section (section, decl)\t\t\t\t\\\n+     enum in_section section;\t\t\t\t\t\\\n+     tree decl;\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  switch (section)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      case in_text: text_section (); break;\t\t\t\\\n+      case in_data: data_section (); break;\t\t\t\\\n+      case in_named: named_section (decl, NULL, 0); break;\t\\\n+      case in_ctors: ctors_section (); break;\t\t\t\\\n+      case in_dtors: dtors_section (); break;\t\t\t\\\n+      SUBTARGET_SWITCH_SECTIONS      \t\t\t\t\\\n+      default: abort (); break;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+\n+#define ASM_OUTPUT_SECTION(file, nam) \\\n+   do { fprintf (file, \"\\t.section\\t%s\\n\", nam); } while (0) \n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsubi\\t %s,%d\\n\\tstw\\t %s,(%s)\\n\",\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   (STACK_BOUNDARY / BITS_PER_UNIT),\t\t\\\n+\t   reg_names[REGNO],\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM])\n+\n+/* Length in instructions of the code output by ASM_OUTPUT_REG_PUSH.  */\n+#define REG_PUSH_LENGTH 2\n+\n+/* This is how to output an insn to pop a register from the stack.  */\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tldw\\t %s,(%s)\\n\\taddi\\t %s,%d\\n\",\t\\\n+\t   reg_names[REGNO],\t\t\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   reg_names[STACK_POINTER_REGNUM],\t\t\\\n+\t   (STACK_BOUNDARY / BITS_PER_UNIT))\n+\n+  \n+/* DBX register number for a given compiler register number.  */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n+\n+/* Output a label definition.  */\n+#define ASM_OUTPUT_LABEL(FILE,NAME)  \\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* Output a reference to a label.  */\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(STREAM, NAME)  \\\n+  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, MCORE_STRIP_NAME_ENCODING (NAME))\n+\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align\\t%d\\n\", LOG)\n+\n+#ifndef ASM_DECLARE_RESULT\n+#define ASM_DECLARE_RESULT(FILE, RESULT)\n+#endif\n+\n+/* Strip export encoding from a function name.  */\n+#define MCORE_STRIP_NAME_ENCODING(SYM_NAME) \\\n+  ((SYM_NAME) + ((SYM_NAME)[0] == '@' ? 3 : 0))\n+\n+/* Strip any text from SYM_NAME added by ENCODE_SECTION_INFO and store\n+   the result in VAR.  */\n+#undef  STRIP_NAME_ENCODING\n+#define STRIP_NAME_ENCODING(VAR, SYM_NAME) \\\n+  (VAR) = MCORE_STRIP_NAME_ENCODING (SYM_NAME)\n+\n+#undef  UNIQUE_SECTION\n+#define UNIQUE_SECTION(DECL, RELOC) mcore_unique_section (DECL, RELOC)\n+\n+#define REDO_SECTION_INFO_P(DECL) 1\n+\n+#define MULTIPLE_SYMBOL_SPACES 1\n+\n+#define SUPPORTS_ONE_ONLY 1\n+\n+/* A pair of macros to output things for the callgraph data.\n+   VALUE means (to the tools that reads this info later):\n+  \t0 a call from src to dst\n+  \t1 the call is special (e.g. dst is \"unknown\" or \"alloca\")\n+  \t2 the call is special (e.g., the src is a table instead of routine)\n+  \n+   Frame sizes are augmented with timestamps to help later tools \n+   differentiate between static entities with same names in different\n+   files.  */\n+extern long mcore_current_compilation_timestamp;\n+#define\tASM_OUTPUT_CG_NODE(FILE,SRCNAME,VALUE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (mcore_current_compilation_timestamp == 0)\t\t\t\\\n+        mcore_current_compilation_timestamp = time (0);\t\t\t\\\n+      fprintf ((FILE),\"\\t.equ\\t__$frame$size$_%s_$_%08lx,%d\\n\",\t\t\\\n+             (SRCNAME), mcore_current_compilation_timestamp, (VALUE));\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define\tASM_OUTPUT_CG_EDGE(FILE,SRCNAME,DSTNAME,VALUE)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf ((FILE),\"\\t.equ\\t__$function$call$_%s_$_%s,%d\\n\",\t\\\n+             (SRCNAME), (DSTNAME), (VALUE));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Output a globalising directive for a label.  */\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n+  (fprintf (STREAM, \"\\t.export\\t\"),\t  \\\n+   assemble_name (STREAM, NAME),\t  \\\n+   fputc ('\\n',STREAM))                   \\\n+\n+/* The prefix to add to user-visible assembler symbols. */\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+/* Make an internal label into a string.  */\n+#undef  ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n+  sprintf (STRING, \"*.%s%ld\", PREFIX, (long) NUM)\n+\n+/* Output an internal label definition.  */\n+#undef  ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* Construct a private name.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n+  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n+   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+\n+/* Jump tables must be 32 bit aligned. */\n+#undef  ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE) \\\n+  fprintf (STREAM, \"\\t.align 2\\n.%s%d:\\n\", PREFIX, NUM);\n+\n+/* Output a relative address. Not needed since jump tables are absolute\n+   but we must define it anyway.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,BODY,VALUE,REL)  \\\n+  fputs (\"- - - ASM_OUTPUT_ADDR_DIFF_ELT called!\\n\", STREAM)\n+\n+/* Output an element of a dispatch table.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n+    fprintf (STREAM, \"\\t.long\\t.L%d\\n\", VALUE)\n+\n+/* Output various types of constants.  */\n+\n+/* This is how to output an assembler line defining a `double'.  */\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+      fprintf (FILE, \"\\t.double %s\\n\", dstr);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      char dstr[30];\t\t\t\t\t\\\n+      REAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", dstr);\t\\\n+      fprintf (FILE, \"\\t.float %s\\n\", dstr);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_INT(STREAM, EXP)  \t\\\n+  (fprintf (STREAM, \"\\t.long\\t\"),      \t\\\n+   output_addr_const (STREAM, (EXP)),  \t\\\n+   fputc ('\\n', STREAM))\t\t\n+\n+#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n+  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n+   output_addr_const (STREAM, (EXP)),  \\\n+   fputc ('\\n', STREAM))\t\t\n+\n+#define ASM_OUTPUT_CHAR(STREAM, EXP)  \t\\\n+  (fprintf (STREAM, \"\\t.byte\\t\"),      \t\\\n+   output_addr_const (STREAM, (EXP)),  \t\\\n+   fputc ('\\n', STREAM))\n+\n+#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \t\\\n+  fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE)  \t\\\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+#undef  ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.fill %d, 1\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol, with alignment information.  */\n+/* XXX - for now we ignore the alignment.  */     \n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (mcore_dllexport_name_p (NAME))\t\t\t\\\n+\tMCORE_EXPORT_NAME (FILE, NAME)\t\t\t\t\\\n+      if (! mcore_dllimport_name_p (NAME))\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          fputs (\"\\t.comm\\t\", FILE);\t\t\t\t\\\n+          assemble_name (FILE, NAME);\t\t\t\t\\\n+          fprintf (FILE, \",%d\\n\", SIZE);\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This says how to output an assembler line\n+   to define an external symbol.  */\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)   \\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fputs (\"\\t.import\\t\", (FILE));\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\\\n+      fputs (\"\\n\", (FILE));\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+     \n+#undef\tASM_OUTPUT_EXTERNAL\n+/* RBE: we undefined this and let gas do it's \"undefined is imported\"\n+   games. This is because when we use this, we get a marked \n+   reference through the call to assemble_name and this forces C++\n+   inlined member functions (or any inlined function) to be instantiated\n+   regardless of whether any callsites remain.\n+   This makes this aspect of the compiler non-ABI compliant.  */\n+\n+/* Similar, but for libcall. FUN is an rtx.  */\n+#undef  ASM_OUTPUT_EXTERNAL_LIBCALL\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.import\\t\");\t\t\\\n+      assemble_name (FILE, XSTR (FUN, 0));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol...  */\n+#undef  ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n+  (fputs (\"\\t.lcomm\\t\", FILE),\t\t\t\t\\\n+  assemble_name (FILE, NAME),\t\t\t\t\\\n+  fprintf (FILE, \",%d\\n\", SIZE))\n+\n+/* ... and how to define a local common symbol whose alignment\n+   we wish to specify.  ALIGN comes in as bits, we have to turn\n+   it into bytes.  */\n+#undef  ASM_OUTPUT_ALIGNED_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fputs (\"\\t.bss\\t\", (FILE));\t\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      fprintf ((FILE), \",%d,%d\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* We must mark dll symbols specially.  Definitions of dllexport'd objects\n+   install some info in the .drective (PE) or .exports (ELF) sections.   */\n+#undef  ENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL) mcore_encode_section_info (DECL)\n+\n+/* The assembler's parentheses characters.  */\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Target characters.  */\n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+#define PRINT_OPERAND(STREAM, X, CODE)  mcore_print_operand (STREAM, X, CODE)\n+\n+/* Print a memory address as an operand to reference that memory location.  */\n+#define PRINT_OPERAND_ADDRESS(STREAM,X)  mcore_print_operand_address (STREAM, X)\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n+  ((CHAR)=='.' || (CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '!')\n+\n+/* This is to handle loads from the constant pool.  */\n+#define MACHINE_DEPENDENT_REORG(X) mcore_dependent_reorg (X)\n+\n+/* This handles MCore dependent rtl simplifications.  */\n+#define MACHINE_DEPENDENT_SIMPLIFY(X,M,L,I,S) \\\n+  mcore_dependent_simplify_rtx (X, M, L, I, S)\n+     \n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  { \"mcore_arith_reg_operand\",\t\t{ REG, SUBREG }},\t\t\\\n+  { \"mcore_general_movsrc_operand\",\t{ MEM, CONST_INT, REG, SUBREG }},\\\n+  { \"mcore_general_movdst_operand\",\t{ MEM, CONST_INT, REG, SUBREG }},\\\n+  { \"mcore_reload_operand\",\t        { MEM, REG, SUBREG }},\t\t\\\n+  { \"mcore_arith_J_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_K_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_K_operand_not_0\",\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_M_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_K_S_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_O_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_imm_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_arith_any_imm_operand\",\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_literal_K_operand\",\t\t{ CONST_INT }},\t\t\t\\\n+  { \"mcore_addsub_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_compare_operand\",\t\t{ CONST_INT, REG, SUBREG }},\t\\\n+  { \"mcore_load_multiple_operation\",\t{ PARALLEL }},\t\t\t\\\n+  { \"mcore_store_multiple_operation\",\t{ PARALLEL }},\t\t\t\\\n+  { \"mcore_call_address_operand\",\t{ REG, SUBREG, CONST_INT }},\t\\\n+\n+#endif /* __MCORE__H */"}, {"sha": "6c64561cfe4a06ead12dc62cdd854c89e21ab2f4", "filename": "gcc/config/mcore/mcore.md", "status": "added", "additions": 3526, "deletions": 0, "changes": 3526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fmcore.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.md?ref=8f90be4c548e561185025888c42a986b10bfe3c2"}, {"sha": "baeb9d2780a1218bbeb6cf30422af730f7dfc608", "filename": "gcc/config/mcore/t-mcore", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Ft-mcore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Ft-mcore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Ft-mcore?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,64 @@\n+# Name of assembly file containing libgcc1 functions.\n+# This entry must be present, but it can be empty if the target does\n+# not need any assembler functions to support its code generation.\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC    = mcore/lib1.asm\n+LIB1ASMFUNCS  = _divsi3 _udivsi3 _modsi3 _umodsi3\n+\n+# Assemble startup files.\n+$(T)crti.o: $(srcdir)/config/mcore/crti.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/mcore/crti.asm\n+\n+$(T)crtn.o: $(srcdir)/config/mcore/crtn.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(MULTILIB_CFLAGS) $(INCLUDES) \\\n+\t-c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/mcore/crtn.asm\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/mcore/t-mcore\n+\trm -f dp-bit.c\n+\techo '' > dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/mcore/t-mcore\n+\trm -f fp-bit.c\n+\techo '' > fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+T_CFLAGS = -DDONT_HAVE_STDIO -DDONT_HAVE_SETJMP  -Dinhibit_libc \n+# could use -msifilter to be safe from interrupt/jmp interactions and others.\n+TARGET_LIBGCC2_CFLAGS=-O3 -DNO_FLOATLIB_FIXUNSDFSI #-msifilter\n+\n+# We have values for float.h.\n+CROSS_FLOAT_H = $(srcdir)/config/mcore/gfloat.h\n+\n+# let the library provider supply an <assert.h>\n+INSTALL_ASSERT_H=\n+\n+# If support for -m4align is ever re-enabled then comment out the\n+# following line and uncomment the mutlilib lines below.\n+\n+EXTRA_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+\n+# MULTILIB_OPTIONS     = m8align/m4align\n+# MULTILIB_DIRNAMES    = align8 align4\n+# MULTILIB_MATCHES     = \n+# MULTILIB_EXTRA_OPTS  = \n+# MULTILIB_EXCEPTIONS  =\n+# EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+# LIBGCC               = stmp-multilib\n+# INSTALL_LIBGCC       = install-multilib\n+\n+MULTILIB_OPTIONS     = mbig-endian/mlittle-endian m210/m340\n+MULTILIB_DIRNAMES    = big little m210 m340\n+\n+EXTRA_PARTS          =\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o crti.o crtn.o\n+LIBGCC               = stmp-multilib\n+INSTALL_LIBGCC       = install-multilib"}, {"sha": "6955c9905fa41120a6c0100499965de089f3642e", "filename": "gcc/config/mcore/t-mcore-pe", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Ft-mcore-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Ft-mcore-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Ft-mcore-pe?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,47 @@\n+# Name of assembly file containing libgcc1 functions.\n+# This entry must be present, but it can be empty if the target does\n+# not need any assembler functions to support its code generation.\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC    = mcore/lib1.asm\n+LIB1ASMFUNCS  = _divsi3 _udivsi3 _modsi3 _umodsi3\n+\n+# We want fine grained libraries, so use the new code to build the\n+# floating point emulation libraries.\n+FPBIT = fp-bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/mcore/t-mcore\n+\trm -f dp-bit.c\n+\techo '' > dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/mcore/t-mcore\n+\trm -f fp-bit.c\n+\techo '' > fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+T_CFLAGS = -DDONT_HAVE_STDIO -DDONT_HAVE_SETJMP  -Dinhibit_libc \n+# could use -msifilter to be safe from interrupt/jmp interactions and others.\n+TARGET_LIBGCC2_CFLAGS=-O3 -DNO_FLOATLIB_FIXUNSDFSI #-msifilter\n+\n+# We have values for float.h.\n+CROSS_FLOAT_H = $(srcdir)/config/mcore/gfloat.h\n+\n+# let the library provider supply an <assert.h>\n+INSTALL_ASSERT_H=\n+\n+MULTILIB_OPTIONS     = mbig-endian/mlittle-endian m210/m340\n+MULTILIB_DIRNAMES    = big little m210 m340\n+MULTILIB_MATCHES     = \n+MULTILIB_EXTRA_OPTS  = \n+MULTILIB_EXCEPTIONS  =\n+\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+LIBGCC               = stmp-multilib\n+INSTALL_LIBGCC       = install-multilib\n+\n+# If EXTRA_MULTILIB_PARTS is not defined above then define EXTRA_PARTS here\n+# EXTRA_PARTS = crtbegin.o crtend.o \n+"}, {"sha": "46b4eff5fd0f307d6dc44e9dc23d5e9880ab61a5", "filename": "gcc/config/mcore/xm-mcore.h", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fxm-mcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f90be4c548e561185025888c42a986b10bfe3c2/gcc%2Fconfig%2Fmcore%2Fxm-mcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fxm-mcore.h?ref=8f90be4c548e561185025888c42a986b10bfe3c2", "patch": "@@ -0,0 +1,42 @@\n+/* Configuration for GNU C-compiler for the Motorola M*Core.\n+   Copyright (C) 1993, 1999, 2000 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR   8\n+#define HOST_BITS_PER_SHORT 16\n+#define HOST_BITS_PER_INT   32\n+#define HOST_BITS_PER_LONG  32\n+\n+/* If compiled with GNU C, use the built-in alloca.  */\n+#ifdef __GNUC__\n+#define alloca __builtin_alloca\n+#endif\n+\n+/* Target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.  */\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+"}]}