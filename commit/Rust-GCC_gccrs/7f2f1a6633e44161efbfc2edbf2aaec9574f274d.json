{"sha": "7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YyZjFhNjYzM2U0NDE2MWVmYmZjMmVkYmYyYWFlYzk1NzRmMjc0ZA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-11-14T18:32:06Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-14T18:32:06Z"}, "message": "cppexp.c (parse_defined): Call cpp_get_token not _cpp_get_token.\n\n\t* cppexp.c (parse_defined): Call cpp_get_token not\n\t_cpp_get_token.\n\t(lex): Similarly.\n\t* cpplex.c (cpp_output_line): Similarly.\n\t* cpplib.c (glue_header_name, do_line, do_ident,\n\tparse_answer, parse_assertion): Similarly.\n\t(_cpp_handle_diretive): Don't save to lookaheads\n\twhen processing directives.\n\t* cppmacro.c (parse_arg, expand_arg): Call cpp_get_token not\n\t_cpp_get_token.\n\t(funlike_invocation_p): Don't save to lookaheads\n\twhen pre-expanding arguments.\n\t(_cpp_get_token): Delete.\n\t(cpp_get_token): Merge contents of _cpp_get_token.\n\nFrom-SVN: r37462", "tree": {"sha": "5e118199d108d9149834d978b08d106ac77d7ea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e118199d108d9149834d978b08d106ac77d7ea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/comments", "author": null, "committer": null, "parents": [{"sha": "f36d6244de2d705437102b9e3ebf34589c92edea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f36d6244de2d705437102b9e3ebf34589c92edea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f36d6244de2d705437102b9e3ebf34589c92edea"}], "stats": {"total": 120, "additions": 69, "deletions": 51}, "files": [{"sha": "57c300f5b7dad41323752cb8899c2f9db3b0a509", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "patch": "@@ -1,3 +1,20 @@\n+2000-11-14  Neil Booth  <neilb@earthling.net>\n+\n+\t* cppexp.c (parse_defined): Call cpp_get_token not\n+\t_cpp_get_token.\n+\t(lex): Similarly.\n+\t* cpplex.c (cpp_output_line): Similarly.\n+\t* cpplib.c (glue_header_name, do_line, do_ident,\n+\tparse_answer, parse_assertion): Similarly.\n+\t(_cpp_handle_diretive): Don't save to lookaheads\n+\twhen processing directives.\n+\t* cppmacro.c (parse_arg, expand_arg): Call cpp_get_token not\n+\t_cpp_get_token.\n+\t(funlike_invocation_p): Don't save to lookaheads\n+\twhen pre-expanding arguments.\n+\t(_cpp_get_token): Delete.\n+\t(cpp_get_token): Merge contents of _cpp_get_token.\n+\n 2000-11-14  Jakub Jelinek  <jakub@redhat.com>\n \n \t* builtins.c (expand_builtin_setjmp): Set"}, {"sha": "98bd94e202929a3c26e0e2d512eafae93c43cbec", "filename": "gcc/cppexp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "patch": "@@ -321,19 +321,19 @@ parse_defined (pfile)\n   /* Don't expand macros.  */\n   pfile->state.prevent_expansion++;\n \n-  _cpp_get_token (pfile, &token);\n+  cpp_get_token (pfile, &token);\n   if (token.type == CPP_OPEN_PAREN)\n     {\n       paren = 1;\n-      _cpp_get_token (pfile, &token);\n+      cpp_get_token (pfile, &token);\n     }\n \n   if (token.type == CPP_NAME)\n     {\n       node = token.val.node;\n       if (paren)\n \t{\n-\t  _cpp_get_token (pfile, &token);\n+\t  cpp_get_token (pfile, &token);\n \t  if (token.type != CPP_CLOSE_PAREN)\n \t    {\n \t      cpp_error (pfile, \"missing ')' after \\\"defined\\\"\");\n@@ -378,13 +378,14 @@ lex (pfile, skip_evaluation, token)\n {\n   struct op op;\n \n-  _cpp_get_token (pfile, token);\n+  cpp_get_token (pfile, token);\n \n   switch (token->type)\n     {\n     case CPP_INT:\n     case CPP_NUMBER:\n       return parse_number (pfile, token);\n+\n     case CPP_CHAR:\n     case CPP_WCHAR:\n       return parse_charconst (pfile, token);"}, {"sha": "ccbe1c7d58ca1e22df7201af7a1bbdb6c4ec1f8d", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "patch": "@@ -158,7 +158,6 @@ extern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_pop_context\t\tPARAMS ((cpp_reader *));\n-extern void _cpp_get_token \t\tPARAMS ((cpp_reader *, cpp_token *));\n extern void _cpp_free_lookaheads\tPARAMS ((cpp_reader *));\n extern void _cpp_release_lookahead\tPARAMS ((cpp_reader *));\n extern void _cpp_push_token\t\tPARAMS ((cpp_reader *, const cpp_token *,"}, {"sha": "96e2454316ab8d15ba1811de4c89b7339268c285", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "patch": "@@ -1677,12 +1677,12 @@ cpp_output_line (pfile, fp)\n {\n   cpp_token token;\n \n-  _cpp_get_token (pfile, &token);\n+  cpp_get_token (pfile, &token);\n   token.flags &= ~PREV_WHITE;\n   while (token.type != CPP_EOF)\n     {\n       cpp_output_token (&token, fp);\n-      _cpp_get_token (pfile, &token);\n+      cpp_get_token (pfile, &token);\n     }\n \n   putc ('\\n', fp);"}, {"sha": "caa319af89e955f257d8c4a2a42a381ee4cb76e2", "filename": "gcc/cpplib.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "patch": "@@ -183,7 +183,7 @@ skip_rest_of_line (pfile)\n {\n   cpp_token token;\n \n-  /* Discard all lookaheads.  */\n+  /* Discard all input lookaheads.  */\n   while (pfile->la_read)\n     _cpp_release_lookahead (pfile);\n \n@@ -221,18 +221,22 @@ _cpp_handle_directive (pfile, indented)\n      cpp_reader *pfile;\n      int indented;\n {\n+  struct cpp_lookahead *la_saved;\n   cpp_buffer *buffer = pfile->buffer;\n   const directive *dir = 0;\n   cpp_token dname;\n   int not_asm = 1;\n \n+  /* Setup in-directive state.  */\n+  pfile->state.in_directive = 1;\n+  pfile->state.save_comments = 0;\n+\n   /* Some handlers need the position of the # for diagnostics.  */\n   pfile->directive_pos = pfile->lexer_pos;\n \n-  /* We're now in a directive.  This ensures we get pedantic warnings\n-     about /v and /f in whitespace.  */\n-  pfile->state.in_directive = 1;\n-  pfile->state.save_comments = 0;\n+  /* Don't save directive tokens for external clients.  */\n+  la_saved = pfile->la_write;\n+  pfile->la_write = 0;\n \n   /* Lex the directive name directly.  */\n   _cpp_lex_token (pfile, &dname);\n@@ -334,6 +338,9 @@ _cpp_handle_directive (pfile, indented)\n   /* Save the lookahead token for assembler.  */\n   if (not_asm)\n     skip_rest_of_line (pfile);\n+\n+  /* Restore state.  */\n+  pfile->la_write = la_saved;\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n   pfile->state.in_directive = 0;\n   pfile->state.angled_headers = 0;\n@@ -496,7 +503,7 @@ glue_header_name (pfile, header)\n   buffer = (unsigned char *) xmalloc (capacity);\n   for (;;)\n     {\n-      _cpp_get_token (pfile, &token);\n+      cpp_get_token (pfile, &token);\n \n       if (token.type == CPP_GREATER || token.type == CPP_EOF)\n \tbreak;\n@@ -703,7 +710,7 @@ do_line (pfile)\n   cpp_token token;\n \n   /* #line commands expand macros.  */\n-  _cpp_get_token (pfile, &token);\n+  cpp_get_token (pfile, &token);\n   if (token.type != CPP_NUMBER\n       || strtoul_for_line (token.val.str.text, token.val.str.len, &new_lineno))\n     {\n@@ -715,7 +722,7 @@ do_line (pfile)\n   if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n     cpp_pedwarn (pfile, \"line number out of range\");\n \n-  _cpp_get_token (pfile, &token);\n+  cpp_get_token (pfile, &token);\n \n   if (token.type != CPP_EOF)\n     {\n@@ -829,7 +836,7 @@ do_ident (pfile)\n {\n   cpp_token str;\n \n-  _cpp_get_token (pfile, &str);\n+  cpp_get_token (pfile, &str);\n   if (str.type != CPP_STRING)\n     cpp_error (pfile, \"invalid #ident\");\n   else if (pfile->cb.ident)\n@@ -1403,7 +1410,7 @@ parse_answer (pfile, answerp, type)\n \t  token = &answer->first[answer->count];\n \t}\n \n-      _cpp_get_token (pfile, token);\n+      cpp_get_token (pfile, token);\n       if (token->type == CPP_CLOSE_PAREN)\n \tbreak;\n \n@@ -1432,9 +1439,7 @@ parse_answer (pfile, answerp, type)\n \n /* Parses an assertion, returning a pointer to the hash node of the\n    predicate, or 0 on error.  If an answer was supplied, it is placed\n-   in ANSWERP, otherwise it is set to 0.  We use _cpp_get_raw_token,\n-   since we cannot assume tokens are consecutive in a #if statement\n-   (we may be in a macro), and we don't want to macro expand.  */\n+   in ANSWERP, otherwise it is set to 0.  */\n static cpp_hashnode *\n parse_assertion (pfile, answerp, type)\n      cpp_reader *pfile;\n@@ -1451,7 +1456,7 @@ parse_assertion (pfile, answerp, type)\n   pfile->string_pool = &pfile->ident_pool;\n \n   *answerp = 0;\n-  _cpp_get_token (pfile, &predicate);\n+  cpp_get_token (pfile, &predicate);\n   if (predicate.type == CPP_EOF)\n     cpp_error (pfile, \"assertion without predicate\");\n   else if (predicate.type != CPP_NAME)"}, {"sha": "35ecc4d4bf10031e3cc22f1afc87e7c13f806d03", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f2f1a6633e44161efbfc2edbf2aaec9574f274d/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=7f2f1a6633e44161efbfc2edbf2aaec9574f274d", "patch": "@@ -488,7 +488,7 @@ parse_arg (pfile, arg, var_args)\n \t  token = &arg->first[arg->count];\n \t}\n \n-      _cpp_get_token (pfile, token);\n+      cpp_get_token (pfile, token);\n       result = token->type;\n \n       if (result == CPP_OPEN_PAREN)\n@@ -619,7 +619,13 @@ funlike_invocation_p (pfile, node, list)\n   if (args)\n     {\n       if (node->value.macro->paramc > 0)\n-\treplace_args (pfile, node->value.macro, args, list);\n+\t{\n+\t  /* Don't save tokens during pre-expansion.  */\n+\t  struct cpp_lookahead *la_saved = pfile->la_write;\n+\t  pfile->la_write = 0;\n+\t  replace_args (pfile, node->value.macro, args, list);\n+\t  pfile->la_write = la_saved;\n+\t}\n       free (args);\n     }\n \n@@ -846,7 +852,7 @@ expand_arg (pfile, arg)\n \t    xrealloc (arg->expanded, capacity * sizeof (cpp_token));\n \t}\n       token = &arg->expanded[arg->expanded_count++];\n-      _cpp_get_token (pfile, token);\n+      cpp_get_token (pfile, token);\n     }\n   while (token->type != CPP_EOF);\n \n@@ -872,12 +878,19 @@ _cpp_pop_context (pfile)\n     }\n }\n \n-/* Internal routine to return a token, either from an in-progress\n-   macro expansion, or from the source file as appropriate.\n-   Transparently enters included files.  Handles macros, so tokens\n-   returned are post-expansion.  Returns CPP_EOF at EOL and EOF.  */\n+/* Eternal routine to get a token.  Also used nearly everywhere\n+   internally, except for places where we know we can safely call\n+   the lexer directly, such as lexing a directive name.\n+\n+   Macro expansions and directives are transparently handled,\n+   including entering included files.  Thus tokens are post-macro\n+   expansion, and after any intervening directives.  External callers\n+   see CPP_EOF only at EOF.  Internal callers also see it when meeting\n+   a directive inside a macro call, when at the end of a directive and\n+   state.in_directive is still 1, and at the end of argument\n+   pre-expansion.  */\n void\n-_cpp_get_token (pfile, token)\n+cpp_get_token (pfile, token)\n      cpp_reader *pfile;\n      cpp_token *token;\n {\n@@ -897,6 +910,9 @@ _cpp_get_token (pfile, token)\n \t  *token = *context->list.first++;\n \t  token->flags |= flags;\n \t  flags = 0;\n+\t  /* PASTE_LEFT tokens can only appear in macro expansions.  */\n+\t  if (token->flags & PASTE_LEFT && !pfile->skipping)\n+\t    paste_all_tokens (pfile, token);\n \t}\n       else\n \t{\n@@ -915,9 +931,6 @@ _cpp_get_token (pfile, token)\n       if (pfile->skipping)\n \tcontinue;\n \n-      if (token->flags & PASTE_LEFT)\n-\tpaste_all_tokens (pfile, token);\n-\n       if (token->type != CPP_NAME)\n \tbreak;\n \n@@ -949,27 +962,10 @@ _cpp_get_token (pfile, token)\n       if (token->val.node != pfile->spec_nodes.n__Pragma)\n \tbreak;\n \n-      /* Handle it, and get another token.  */\n-      pfile->mi_state = MI_FAILED;\n+      /* Handle it, and loop back for another token.  MI is cleared\n+         since this token came from either the lexer or a macro.  */\n       _cpp_do__Pragma (pfile);\n     }\n-}\n-\n-/* External interface to get a token.  Tokens are returned after macro\n-   expansion and directives have been handled, as a continuous stream.\n-   Compared to the function above, CPP_EOF means EOF, and placemarker\n-   tokens are filtered out.  Also, it skips tokens if we're skipping,\n-   and saves tokens to lookahead.\n-\n-   CPP_EOF indicates end of original source file.  For the benefit of\n-   #pragma callbacks which may want to get the pragma's tokens,\n-   returns CPP_EOF to indicate end-of-directive in this case.  */\n-void\n-cpp_get_token (pfile, token)\n-     cpp_reader *pfile;\n-     cpp_token *token;\n-{\n-  _cpp_get_token (pfile, token);\n \n   if (pfile->la_write)\n     save_lookahead_token (pfile, token);"}]}