{"sha": "d4ba09c0b92b7d07318e93d7b97588d46560981b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRiYTA5YzBiOTJiN2QwNzMxOGU5M2Q3Yjk3NTg4ZDQ2NTYwOTgxYg==", "commit": {"author": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-02-09T22:45:50Z"}, "committer": {"name": "Stan Cox", "email": "coxs@gnu.org", "date": "1996-02-09T22:45:50Z"}, "message": "(OPTIMIZATION_OPTIONS, ALIGN_DFmode, IS_STACK_MODE,\n\nFrom-SVN: r11189", "tree": {"sha": "9f0f3ccfeb7cab101acda4b3b410f830111b4c86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f0f3ccfeb7cab101acda4b3b410f830111b4c86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4ba09c0b92b7d07318e93d7b97588d46560981b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ba09c0b92b7d07318e93d7b97588d46560981b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4ba09c0b92b7d07318e93d7b97588d46560981b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4ba09c0b92b7d07318e93d7b97588d46560981b/comments", "author": null, "committer": null, "parents": [{"sha": "32b5b1aa6a63943056693f4c0b2e7868d6c58ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b5b1aa6a63943056693f4c0b2e7868d6c58ab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b5b1aa6a63943056693f4c0b2e7868d6c58ab5"}], "stats": {"total": 485, "additions": 412, "deletions": 73}, "files": [{"sha": "e05882ffcc726b521d868c46ce6249b6df994266", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 412, "deletions": 73, "changes": 485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4ba09c0b92b7d07318e93d7b97588d46560981b/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4ba09c0b92b7d07318e93d7b97588d46560981b/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d4ba09c0b92b7d07318e93d7b97588d46560981b", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Intel X86\n    (386, 486, Pentium).\n-   Copyright (C) 1988, 1992, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992, 1994, 1995, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -17,8 +17,7 @@ GNU General Public License for more details.\n You should have received a copy of the GNU General Public License\n along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n+Boston, MA 02111-1307, USA. */\n \n /* The purpose of this file is to define the characteristics of the i386,\n    independent of assembler syntax or operating system.\n@@ -53,6 +52,20 @@ Boston, MA 02111-1307, USA.  */\n #define HALF_PIC_FINISH(STREAM)\n #endif\n \n+/* Define the specific costs for a given cpu */\n+\n+struct processor_costs {\n+  int add;\t\t\t/* cost of an add instruction */\n+  int lea;\t\t\t/* cost of a lea instruction */\n+  int shift_var;\t\t/* variable shift costs */\n+  int shift_const;\t\t/* constant shift costs */\n+  int mult_init;\t\t/* cost of starting a multiply */\n+  int mult_bit;\t\t\t/* cost of multiply per each bit set */\n+  int divide;\t\t\t/* cost of a divide/mod */\n+};\n+\n+extern struct processor_costs *ix86_cost;\n+\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n@@ -74,12 +87,12 @@ extern int target_flags;\n #define MASK_IEEE_FP\t\t000000000100\t/* IEEE fp comparisons */\n #define MASK_FLOAT_RETURNS\t000000000200\t/* Return float in st(0) */\n #define MASK_NO_FANCY_MATH_387\t000000000400\t/* Disable sin, cos, sqrt */\n-\n \t\t\t\t\t\t/* Temporary codegen switches */\n #define MASK_DEBUG_ADDR\t\t000001000000\t/* Debug GO_IF_LEGITIMATE_ADDRESS */\n #define MASK_NO_WIDE_MULTIPLY\t000002000000\t/* Disable 32x32->64 multiplies */\n #define MASK_NO_MOVE\t\t000004000000\t/* Don't generate mem->mem */\n-#define MASK_DEBUG_ARG\t\t000010000000\t/* Debug function_arg */   \n+#define MASK_NO_PSEUDO\t\t000010000000\t/* Move op's args -> pseudos */\n+#define MASK_DEBUG_ARG\t\t000020000000\t/* Debug function_arg */   \n \n /* Use the floating point instructions */\n #define TARGET_80387 (target_flags & MASK_80387)\n@@ -127,6 +140,8 @@ extern int target_flags;\n \n /* Hack macros for tuning code generation */\n #define TARGET_MOVE\t((target_flags & MASK_NO_MOVE) == 0)\t/* Don't generate memory->memory */\n+#define TARGET_PSEUDO\t((target_flags & MASK_NO_PSEUDO) == 0)\t/* Move op's args into pseudos */\n+\n #define TARGET_386 (ix86_cpu == PROCESSOR_I386)\n #define TARGET_486 (ix86_cpu == PROCESSOR_I486)\n #define TARGET_PENTIUM (ix86_cpu == PROCESSOR_PENTIUM)\n@@ -174,7 +189,9 @@ extern int target_flags;\n   SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   { \"\", TARGET_DEFAULT}}\n \n-/* Processor type.  */\n+/* Which processor to schedule for. The cpu attribute defines a list that\n+   mirrors this list, so changes to i386.md must be made at the same time.  */\n+\n enum processor_type\n  {PROCESSOR_I386,\t\t\t/* 80386 */\n   PROCESSOR_I486,\t\t\t/* 80486DX, 80486SX, 80486DX[24] */\n@@ -247,6 +264,9 @@ extern enum processor_type ix86_cpu;\n #define SUBTARGET_SWITCHES\n #define SUBTARGET_OPTIONS\n \n+/* Define this to change the optimizations performed by default.  */\n+#define OPTIMIZATION_OPTIONS(LEVEL) optimization_options(LEVEL)\n+\n /* Specs for the compiler proper */\n \n #ifndef CC1_SPEC\n@@ -328,6 +348,9 @@ extern enum processor_type ix86_cpu;\n    aligned on 64 bit boundaries. */\n #define BIGGEST_ALIGNMENT (TARGET_ALIGN_DOUBLE ? 64 : 32)\n \n+/* align DFmode constants and nonaggregates */\n+#define ALIGN_DFmode (!TARGET_386)\n+\n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 0\n@@ -355,6 +378,7 @@ extern enum processor_type ix86_cpu;\n    for details. */\n \n #define STACK_REGS\n+#define IS_STACK_MODE(mode) (mode==DFmode || mode==SFmode || mode==XFmode)\n \n /* Number of actual hardware registers.\n    The hardware registers are assigned numbers for the compiler\n@@ -487,15 +511,6 @@ extern enum processor_type ix86_cpu;\n \n #define MODES_TIEABLE_P(MODE1, MODE2) ((MODE1) == (MODE2))\n \n-/* A C expression returning the cost of moving data from a register of class\n-   CLASS1 to one of CLASS2.\n-\n-   On the i386, copying between floating-point and fixed-point\n-   registers is expensive.  */\n-\n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\\\n-  ((FLOAT_CLASS_P (CLASS1) == FLOAT_CLASS_P (CLASS2)) ? 2 : 10)\n-\n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n@@ -628,7 +643,7 @@ enum reg_class\n      0x3,\t\t\t/* AD_REGS */\t\t\t\\\n      0xf,\t\t\t/* Q_REGS */\t\t\t\\\n     0x10,   0x20,\t\t/* SIREG, DIREG */\t\t\\\n- 0x07f,\t\t\t\t/* INDEX_REGS */\t\t\\\n+ 0x7f,\t\t\t\t/* INDEX_REGS */\t\t\\\n  0x100ff,\t\t\t/* GENERAL_REGS */\t\t\\\n   0x0100, 0x0200,\t\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n   0xff00,\t\t\t/* FLOAT_REGS */\t\t\\\n@@ -719,6 +734,7 @@ enum reg_class\n    (C) == 'L' ? (VALUE) == 0xffff :\t\t\\\n    (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3 :\t\\\n    (C) == 'N' ? (VALUE) >= 0 && (VALUE) <= 255 :\\\n+   (C) == 'O' ? (VALUE) >= 0 && (VALUE) <= 32 :\t\\\n    0)\n \n /* Similar, but for floating constants, and defining letters G and H.\n@@ -1563,6 +1579,8 @@ do {\t\t\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t\\\n }\n \n+#define REWRITE_ADDRESS(x) rewrite_address(x)\n+\n /* Nonzero if the constant value X is a legitimate general operand\n    when generating PIC code.  It is given that flag_pic is on and \n    that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n@@ -1597,6 +1615,15 @@ do\t\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \trtx rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\\\n \t\t   ? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (TARGET_DEBUG_ADDR\t\t\t\t\t\t\\\n+\t    && TREE_CODE_CLASS (TREE_CODE (DECL)) == 'd')\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (stderr, \"Encode %s, public = %s\\n\",\t\t\\\n+\t\t     IDENTIFIER_POINTER (DECL_NAME (DECL)),\t\t\\\n+\t\t     TREE_PUBLIC (DECL));\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n \tSYMBOL_REF_FLAG (XEXP (rtl, 0))\t\t\t\t\t\\\n \t  = (TREE_CODE_CLASS (TREE_CODE (DECL)) != 'd'\t\t\t\\\n \t     || ! TREE_PUBLIC (DECL));\t\t\t\t\t\\\n@@ -1687,17 +1714,18 @@ while (0)\n    in one reasonably fast instruction.  */\n #define MOVE_MAX 4\n \n-/* MOVE_RATIO is the number of move instructions that is better than a\n-   block move.  Make this large on i386, since the block move is very\n-   inefficient with small blocks, and the hard register needs of the\n-   block move require much reload work. */\n-#define MOVE_RATIO 5\n+/* The number of scalar move insns which should be generated instead\n+   of a string move insn or a library call.  Increasing the value\n+   will always make code faster, but eventually incurs high cost in\n+   increased code size.\n \n-/* Define this if zero-extension is slow (more than one real instruction).  */\n-/* #define SLOW_ZERO_EXTEND */\n+   If you don't define this, a reasonable default is used.\n \n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n+   Make this large on i386, since the block move is very inefficient with small\n+   blocks, and the hard register needs of the block move require much reload\n+   work. */\n+\n+#define MOVE_RATIO 5\n \n /* Define if shifts truncate the shift count\n    which implies one can omit a sign-extension or zero-extension\n@@ -1729,70 +1757,154 @@ while (0)\n    is a byte address (for indexing purposes)\n    so give the MEM rtx a byte's mode.  */\n #define FUNCTION_MODE QImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on the 386 because a CALL with a constant address is\n-   not much slower than one with a register address.  On a 486,\n-   it is faster to call with a constant address than indirect.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Provide the costs of a rtl expression.  This is in the body of a\n-   switch on CODE. */\n-\n-#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (20);\t\t\t\t\t\\\n-  case DIV:\t\t\t\t\t\t\t\\\n-  case UDIV:\t\t\t\t\t\t\t\\\n-  case MOD:\t\t\t\t\t\t\t\\\n-  case UMOD:\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (20);\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\\\n-  case ASHIFT:\t\t\t\t\t\t\t\\\n-    return (4 + rtx_cost (XEXP (X, 0), OUTER_CODE)\t\t\\\n-\t    + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 0)) == MULT\t\t\t\t\\\n-\t&& GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\\\n-\t&& (INTVAL (XEXP (XEXP (X, 0), 1)) == 2\t\t\t\\\n-\t    || INTVAL (XEXP (XEXP (X, 0), 1)) == 4\t\t\\\n-\t    || INTVAL (XEXP (XEXP (X, 0), 1)) == 8))\t\t\\\n-      return (2 + rtx_cost (XEXP (XEXP (X, 0), 0), OUTER_CODE)\t\\\n-\t      + rtx_cost (XEXP (X, 1), OUTER_CODE));\t\t\\\n-    break;\n-\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n+\f\n+/* A part of a C `switch' statement that describes the relative costs\n+   of constant RTL expressions.  It must contain `case' labels for\n+   expression codes `const_int', `const', `symbol_ref', `label_ref'\n+   and `const_double'.  Each case must ultimately reach a `return'\n+   statement to return the relative cost of the use of that kind of\n+   constant value in an expression.  The cost may depend on the\n+   precise value of the constant, which is available for examination\n+   in X, and the rtx code of the expression in which it is contained,\n+   found in OUTER_CODE.\n+  \n+   CODE is the expression code--redundant, since it can be obtained\n+   with `GET_CODE (X)'.  */\n \n #define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n   case CONST_INT:\t\t\t\t\t\t\\\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n     return flag_pic && SYMBOLIC_CONST (RTX) ? 2 : 0;\t\t\\\n+\t\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       int code;\t\t\t\t\t\t\t\\\n       if (GET_MODE (RTX) == VOIDmode)\t\t\t\t\\\n \treturn 2;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n       code = standard_80387_constant_p (RTX);\t\t\t\\\n       return code == 1 ? 0 :\t\t\t\t\t\\\n \t     code == 2 ? 1 :\t\t\t\t\t\\\n \t\t\t 2;\t\t\t\t\t\\\n     }\n \n-/* Compute the cost of an address.  This is meant to approximate the size\n-   and/or execution delay of an insn using that address.  If the cost is\n-   approximated by the RTL complexity, including CONST_COSTS above, as\n-   is usually the case for CISC machines, this macro should not be defined.\n-   For aggressively RISCy machines, only one insn format is allowed, so\n-   this macro should be a constant.  The value of this macro only matters\n-   for valid addresses.\n+/* Like `CONST_COSTS' but applies to nonconstant RTL expressions.\n+   This can be used, for example, to indicate how costly a multiply\n+   instruction is.  In writing this macro, you can use the construct\n+   `COSTS_N_INSNS (N)' to specify a cost equal to N fast\n+   instructions.  OUTER_CODE is the code of the expression in which X\n+   is contained.\n+\n+   This macro is optional; do not define it if the default cost\n+   assumptions are adequate for the target machine.  */\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+\t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tHOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (value == 1)\t\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->add);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (value == 2 || value == 3)\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (ix86_cost->lea);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n+\t\t  \t\t\t\t\t\t\t\\\n+  case ROTATE:\t\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\t\\\n+  case ROTATERT:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS ((GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\\\n+\t\t\t\t? ix86_cost->shift_const\t\t\t\\\n+\t\t\t\t: ix86_cost->shift_var);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunsigned HOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\\\n+\tint nbits = 0;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\twhile (value != 0)\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    nbits++;\t\t\t\t\t\t\t\\\n+\t    value >>= 1;\t\t\t\t\t\t\\\n+\t  } \t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\\\n+\t\t\t      + nbits * ix86_cost->mult_bit);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t/* This is arbitrary */\t\t\t\\\n+      return COSTS_N_INSNS (ix86_cost->mult_init\t\t\t\t\\\n+\t\t\t    + 7 * ix86_cost->mult_bit);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (ix86_cost->divide);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+\t&& GET_MODE (XEXP (X, 0)) == SImode\t\t\t\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == PLUS)\t\t\t\t\\\n+      return COSTS_N_INSNS (ix86_cost->lea);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n+  case AND:\t\t\t\t\t\t\t\t\\\n+  case IOR:\t\t\t\t\t\t\t\t\\\n+  case XOR:\t\t\t\t\t\t\t\t\\\n+  case MINUS:\t\t\t\t\t\t\t\t\\\n+  case NEG:\t\t\t\t\t\t\t\t\\\n+  case NOT:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (ix86_cost->add);\n+\n+\n+/* An expression giving the cost of an addressing mode that contains\n+   ADDRESS.  If not defined, the cost is computed from the ADDRESS\n+   expression and the `CONST_COSTS' values.\n+\n+   For most CISC machines, the default cost is a good approximation\n+   of the true cost of the addressing mode.  However, on RISC\n+   machines, all instructions normally have the same length and\n+   execution time.  Hence all addresses will have equal costs.\n+\n+   In cases where more than one form of an address is known, the form\n+   with the lowest cost will be used.  If multiple forms have the\n+   same, lowest, cost, the one that is the most complex will be used.\n+\n+   For example, suppose an address that is equal to the sum of a\n+   register and a constant is used twice in the same basic block.\n+   When this macro is not defined, the address will be computed in a\n+   register and memory references will be indirect through that\n+   register.  On machines where the cost of the addressing mode\n+   containing the sum is no higher than that of a simple indirect\n+   reference, this will produce an additional instruction and\n+   possibly require an additional register.  Proper specification of\n+   this macro eliminates this overhead for such machines.\n+\n+   Similar use of this macro is made in strength reduction of loops.\n+\n+   ADDRESS need not be valid as an address.  In such a case, the cost\n+   is not relevant and can be any value; invalid addresses need not be\n+   assigned a different cost.\n+\n+   On machines where an address involving more than one register is as\n+   cheap as an address computation involving only one register,\n+   defining `ADDRESS_COST' to reflect this can cause two registers to\n+   be live over a region of code where only one would have been if\n+   `ADDRESS_COST' were not defined in that manner.  This effect should\n+   be considered in the definition of this macro.  Equivalent costs\n+   should probably only be given to addresses with different numbers\n+   of registers on machines with lots of registers.\n+\n+   This macro will normally either not be defined or be defined as a\n+   constant.\n \n    For i386, it is better to use a complex address than let gcc copy\n    the address into a reg and make a new pseudo.  But not if the address\n@@ -1805,6 +1917,193 @@ while (0)\n \t&& REG_P (XEXP (RTX, 0)))) ? 0\t\t\t\t\\\n    : REG_P (RTX) ? 1\t\t\t\t\t\t\\\n    : 2)\n+\n+/* A C expression for the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   If moving between registers and memory is more expensive than\n+   between two registers, you should define this macro to express the\n+   relative cost.\n+\n+   On the i386, copying between floating-point and fixed-point\n+   registers is expensive.  */\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\t\t\\\n+  (((FLOAT_CLASS_P (CLASS1) && ! FLOAT_CLASS_P (CLASS2))\t\t\\\n+    || (! FLOAT_CLASS_P (CLASS1) && FLOAT_CLASS_P (CLASS2))) ? 10\t\\\n+   : 2)\n+\n+\n+/* A C expression for the cost of moving data of mode M between a\n+   register and memory.  A value of 2 is the default; this cost is\n+   relative to those in `REGISTER_MOVE_COST'.\n+\n+   If moving between registers and memory is more expensive than\n+   between two registers, you should define this macro to express the\n+   relative cost.  */\n+\n+/* #define MEMORY_MOVE_COST(M) 2  */\n+\n+/* A C expression for the cost of a branch instruction.  A value of 1\n+   is the default; other values are interpreted relative to that.  */\n+\n+/* #define BRANCH_COST 1 */\n+\n+/* Define this macro as a C expression which is nonzero if accessing\n+   less than a word of memory (i.e. a `char' or a `short') is no\n+   faster than accessing a word of memory, i.e., if such access\n+   require more than one instruction or if there is no difference in\n+   cost between byte and (aligned) word loads.\n+\n+   When this macro is not defined, the compiler will access a field by\n+   finding the smallest containing object; when it is defined, a\n+   fullword load will be used if alignment permits.  Unless bytes\n+   accesses are faster than word accesses, using word accesses is\n+   preferable since it may eliminate subsequent memory access if\n+   subsequent accesses occur to other fields in the same word of the\n+   structure, but to different bytes.  */\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Nonzero if access to memory by shorts is slow and undesirable.  */\n+#define SLOW_SHORT_ACCESS 0\n+\n+/* Define this macro if zero-extension (of a `char' or `short' to an\n+   `int') can be done faster if the destination is a register that is\n+   known to be zero.\n+\n+   If you define this macro, you must have instruction patterns that\n+   recognize RTL structures like this:\n+\n+          (set (strict_low_part (subreg:QI (reg:SI ...) 0)) ...)\n+\n+   and likewise for `HImode'.  */\n+\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Define this macro to be the value 1 if unaligned accesses have a\n+   cost many times greater than aligned accesses, for example if they\n+   are emulated in a trap handler.\n+\n+   When this macro is non-zero, the compiler will act as if\n+   `STRICT_ALIGNMENT' were non-zero when generating code for block\n+   moves.  This can cause significantly more instructions to be\n+   produced.  Therefore, do not set this macro non-zero if unaligned\n+   accesses only add a cycle or two to the time for a memory access.\n+\n+   If the value of this macro is always zero, it need not be defined.  */\n+\n+/* #define SLOW_UNALIGNED_ACCESS 0 */\n+\n+/* Define this macro to inhibit strength reduction of memory\n+   addresses.  (On some machines, such strength reduction seems to do\n+   harm rather than good.)  */\n+\n+/* #define DONT_REDUCE_ADDR */\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.\n+\n+   Desirable on the 386 because a CALL with a constant address is\n+   faster than one with a register address.  */\n+\n+#define NO_FUNCTION_CSE\n+\n+/* Define this macro if it is as good or better for a function to call\n+   itself with an explicit address than to call an address kept in a\n+   register.  */\n+\n+#define NO_RECURSIVE_FUNCTION_CSE\n+\n+/* A C statement (sans semicolon) to update the integer variable COST\n+   based on the relationship between INSN that is dependent on\n+   DEP_INSN through the dependence LINK.  The default is to make no\n+   adjustment to COST.  This can be used for example to specify to\n+   the scheduler that an output- or anti-dependence does not incur\n+   the same cost as a data-dependence.  */\n+\n+#define ADJUST_COST(insn,link,dep_insn,cost)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    rtx next_inst;\t\t\t\t\t\t\t\\\n+    if (GET_CODE (dep_insn) == CALL_INSN)\t\t\t\t\\\n+      (cost) = 0;\t\t\t\t\t\t\t\\\n+   \t\t\t\t\t\t\t\t\t\\\n+    else if (GET_CODE (dep_insn) == INSN\t\t\t\t\\\n+\t&& GET_CODE (PATTERN (dep_insn)) == SET\t\t\t\t\\\n+\t&& GET_CODE (SET_DEST (PATTERN (dep_insn))) == REG\t\t\\\n+\t&& GET_CODE (insn) == INSN\t\t\t\t\t\\\n+\t&& GET_CODE (PATTERN (insn)) == SET\t\t\t\t\\\n+\t&& !reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\t\\\n+\t\t\t\t     SET_SRC (PATTERN (insn))))\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(cost) = 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    else if (GET_CODE (insn) == JUMP_INSN)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        (cost) = 0;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_PENTIUM)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        if (cost !=0 && is_fp_insn (insn) && is_fp_insn (dep_insn)\t\\\n+            && !is_fp_dest (dep_insn))\t\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+            (cost) = 0;\t\t\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+        if (agi_dependent (insn, dep_insn))\t\t\t\t\\\n+          {\t\t\t\t\t\t\t\t\\\n+            (cost) = 3;\t\t\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+        else if (GET_CODE (insn) == INSN\t\t\t\t\\\n+                 && GET_CODE (PATTERN (insn)) == SET\t\t\t\\\n+                 && SET_DEST (PATTERN (insn)) == cc0_rtx\t\t\\\n+                 && (next_inst = next_nonnote_insn (insn))\t\t\\\n+                 && GET_CODE (next_inst) == JUMP_INSN)\t\t\t\\\n+          { /* compare probably paired with jump */\t\t\t\\\n+            (cost) = 0;\t\t\t\t\t\t\t\\\n+          }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      if (!is_fp_dest (dep_insn))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if(!agi_dependent (insn, dep_insn))\t\t\t\t\\\n+\t    (cost) = 0;\t\t\t\t\t\t\t\\\n+\t  else if (TARGET_486)\t\t\t\t\t\t\\\n+\t    (cost) = 2;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tif (is_fp_store (insn) && is_fp_insn (dep_insn)\t\t\t\\\n+\t    && NEXT_INSN (insn) && NEXT_INSN (NEXT_INSN (insn))\t\t\\\n+\t    && NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))\t\t\t\\\n+\t    && (GET_CODE (NEXT_INSN (insn)) == INSN)\t\t\t\\\n+\t    && (GET_CODE (NEXT_INSN (NEXT_INSN (insn))) == JUMP_INSN)\t\\\n+\t    && (GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))) == NOTE) \\\n+\t    && (NOTE_LINE_NUMBER (NEXT_INSN (NEXT_INSN (NEXT_INSN (insn)))) \\\n+\t\t== NOTE_INSN_LOOP_END))\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    (cost) = 3;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+\n+#define ADJUST_BLOCKAGE(last_insn,insn,blockage)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (is_fp_store (last_insn) && is_fp_insn (insn)\t\t\t\\\n+      && NEXT_INSN (last_insn) && NEXT_INSN (NEXT_INSN (last_insn))\t\\\n+      && NEXT_INSN (NEXT_INSN (NEXT_INSN (last_insn)))\t\t\t\\\n+      && (GET_CODE (NEXT_INSN (last_insn)) == INSN)\t\t\t\\\n+      && (GET_CODE (NEXT_INSN (NEXT_INSN (last_insn))) == JUMP_INSN)\t\\\n+      && (GET_CODE (NEXT_INSN (NEXT_INSN (NEXT_INSN (last_insn)))) == NOTE) \\\n+      && (NOTE_LINE_NUMBER (NEXT_INSN (NEXT_INSN (NEXT_INSN (last_insn)))) \\\n+\t  == NOTE_INSN_LOOP_END))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      (blockage) = 3;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n \f\n /* Add any extra modes needed to represent the condition code.\n \n@@ -1837,6 +2136,10 @@ extern struct rtx_def *(*i386_compare_gen)(), *(*i386_compare_gen_eq)();\n /* Here we define machine-dependent flags and fields in cc_status\n    (see `conditions.h').  */\n \n+/* Set if the cc value is was actually from the 80387 and\n+   we are testing eax directly (i.e. no sahf) */\n+#define CC_TEST_AX 020000\n+\n /* Set if the cc value is actually in the 80387, so a floating point\n    conditional branch must be output.  */\n #define CC_IN_80387 04000\n@@ -2174,10 +2477,25 @@ extern char *qi_high_reg_name[];\n \f\n #define RET return \"\"\n #define AT_SP(mode) (gen_rtx (MEM, (mode), stack_pointer_rtx))\n+\f\n+/* Helper macros to expand a binary/unary operator if needed */\n+#define IX86_EXPAND_BINARY_OPERATOR(OP, MODE, OPERANDS)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (!ix86_expand_binary_operator (OP, MODE, OPERANDS))\t\t\\\n+    FAIL;\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#define IX86_EXPAND_UNARY_OPERATOR(OP, MODE, OPERANDS)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (!ix86_expand_unary_operator (OP, MODE, OPERANDS,))\t\t\\\n+    FAIL;\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n \f\n /* Functions in i386.c */\n extern void override_options ();\n extern void order_regs_for_local_alloc ();\n+extern char *output_strlen_unroll ();\n extern int i386_valid_decl_attribute_p ();\n extern int i386_valid_type_attribute_p ();\n extern int i386_return_pops_args ();\n@@ -2199,6 +2517,10 @@ extern int symbolic_operand ();\n extern int call_insn_operand ();\n extern int expander_call_insn_operand ();\n extern int symbolic_reference_mentioned_p ();\n+extern int ix86_expand_binary_operator ();\n+extern int ix86_binary_operator_ok ();\n+extern int ix86_expand_unary_operator ();\n+extern int ix86_unary_operator_ok ();\n extern void emit_pic_move ();\n extern void function_prologue ();\n extern int simple_386_epilogue ();\n@@ -2221,6 +2543,22 @@ extern void save_386_machine_status ();\n extern void restore_386_machine_status ();\n extern void clear_386_stack_locals ();\n extern struct rtx_def *assign_386_stack_local ();\n+extern int is_mul ();\n+extern int is_div ();\n+extern int last_to_set_cc ();\n+extern int doesnt_set_condition_code ();\n+extern int sets_condition_code ();\n+extern int str_immediate_operand ();\n+extern int is_fp_insn ();\n+extern int is_fp_dest ();\n+extern int is_fp_store ();\n+extern int agi_dependent ();\n+extern int reg_mentioned_in_mem ();\n+\n+#ifdef NOTYET\n+extern struct rtx_def *copy_all_rtx ();\n+extern void rewrite_address ();\n+#endif\n \n /* Variables in i386.c */\n extern char *ix86_cpu_string;\t\t\t/* for -mcpu=<xxx> */\n@@ -2242,11 +2580,12 @@ extern struct rtx_def *i386_compare_op0;\t/* operand 0 for comparisons */\n extern struct rtx_def *i386_compare_op1;\t/* operand 1 for comparisons */\n \n /* External variables used */\n-extern int optimize;\t\t\t/* optimization level */\n-extern int obey_regdecls;\t\t/* TRUE if stupid register allocation */\n+extern int optimize;\t\t\t\t/* optimization level */\n+extern int obey_regdecls;\t\t\t/* TRUE if stupid register allocation */\n \n /* External functions used */\n extern struct rtx_def *force_operand ();\n+\n \f\n /*\n Local variables:"}]}