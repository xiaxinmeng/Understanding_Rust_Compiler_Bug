{"sha": "b4e82619bca237b96d0a85da90d4f67c71428f99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRlODI2MTliY2EyMzdiOTZkMGE4NWRhOTBkNGY2N2M3MTQyOGY5OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-05T22:53:08Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-05T22:53:08Z"}, "message": "re PR target/20342 (ICE in spill_failure, at reload1.c:1872)\n\n        PR target/20342\n        PR target/20447\n        * config/i386/i386.c (print_operand): Handle vector zeros.\n        (ix86_split_to_parts): Handle CONST_VECTOR.\n        (ix86_hard_regno_mode_ok): Allow MMX modes in general regs.\n        (ix86_modes_tieable_p): Use ix86_hard_regno_mode_ok to decide\n        what modes to tie for MMX and SSE registers.\n        * config/i386/i386.h (MMX_REG_MODE_P): Remove.\n        * config/i386/i386.md: Extend move 0 -> xor peephole to apply\n        to vector modes as well.\n        * config/i386/predicates.md (const0_operand): Handle VOIDmode\n        properly as an input mode.\n\nFrom-SVN: r97663", "tree": {"sha": "98aa6b43aa9c1823b585cac4ca25a427d8f49bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98aa6b43aa9c1823b585cac4ca25a427d8f49bd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4e82619bca237b96d0a85da90d4f67c71428f99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e82619bca237b96d0a85da90d4f67c71428f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e82619bca237b96d0a85da90d4f67c71428f99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e82619bca237b96d0a85da90d4f67c71428f99/comments", "author": null, "committer": null, "parents": [{"sha": "aca32e16b027b8b454e1c0ae3ee2e9825fb17bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aca32e16b027b8b454e1c0ae3ee2e9825fb17bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aca32e16b027b8b454e1c0ae3ee2e9825fb17bb4"}], "stats": {"total": 100, "additions": 75, "deletions": 25}, "files": [{"sha": "846d4367a004d9939dd5c0e2f96c2c29e7be2980", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4e82619bca237b96d0a85da90d4f67c71428f99", "patch": "@@ -1,3 +1,18 @@\n+2005-04-05  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/20342\n+\tPR target/20447\n+\t* config/i386/i386.c (print_operand): Handle vector zeros.\n+\t(ix86_split_to_parts): Handle CONST_VECTOR.\n+\t(ix86_hard_regno_mode_ok): Allow MMX modes in general regs.\n+\t(ix86_modes_tieable_p): Use ix86_hard_regno_mode_ok to decide\n+\twhat modes to tie for MMX and SSE registers.\n+\t* config/i386/i386.h (MMX_REG_MODE_P): Remove.\n+\t* config/i386/i386.md: Extend move 0 -> xor peephole to apply\n+\tto vector modes as well.\n+\t* config/i386/predicates.md (const0_operand): Handle VOIDmode\n+\tproperly as an input mode.\n+\n 2005-04-05  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-ssa-operands.c (verify_abort): Use %p for pointers."}, {"sha": "e762fa751870ab57d7e8a129cdb78a56685549b6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b4e82619bca237b96d0a85da90d4f67c71428f99", "patch": "@@ -6773,6 +6773,17 @@ print_operand (FILE *file, rtx x, int code)\n \n   else\n     {\n+      /* We have patterns that allow zero sets of memory, for instance.\n+\t In 64-bit mode, we should probably support all 8-byte vectors,\n+\t since we can in fact encode that into an immediate.  */\n+      if (GET_CODE (x) == CONST_VECTOR)\n+\t{\n+\t  if (x == CONST0_RTX (GET_MODE (x)))\n+\t    x = const0_rtx;\n+\t  else\n+\t    abort ();\n+\t}\n+\n       if (code != 'P')\n \t{\n \t  if (GET_CODE (x) == CONST_INT || GET_CODE (x) == CONST_DOUBLE)\n@@ -10350,8 +10361,18 @@ ix86_split_to_parts (rtx operand, rtx *parts, enum machine_mode mode)\n       operand = copy_rtx (operand);\n       PUT_MODE (operand, Pmode);\n       parts[0] = parts[1] = parts[2] = operand;\n+      return size;\n     }\n-  else if (!TARGET_64BIT)\n+\n+  if (GET_CODE (operand) == CONST_VECTOR)\n+    {\n+      enum machine_mode imode = int_mode_for_mode (mode);\n+      operand = simplify_subreg (imode, operand, mode, 0);\n+      gcc_assert (operand != NULL);\n+      mode = imode;\n+    }\n+\n+  if (!TARGET_64BIT)\n     {\n       if (mode == DImode)\n \tsplit_di (&operand, 1, &parts[0], &parts[1]);\n@@ -15111,15 +15132,30 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n       return (VALID_MMX_REG_MODE (mode)\n \t      || VALID_MMX_REG_MODE_3DNOW (mode));\n     }\n-  /* We handle both integer and floats in the general purpose registers.\n-     In future we should be able to handle vector modes as well.  */\n-  if (!VALID_INT_MODE_P (mode) && !VALID_FP_MODE_P (mode))\n-    return 0;\n-  /* Take care for QImode values - they can be in non-QI regs, but then\n-     they do cause partial register stalls.  */\n-  if (regno < 4 || mode != QImode || TARGET_64BIT)\n+\n+  if (mode == QImode)\n+    {\n+      /* Take care for QImode values - they can be in non-QI regs,\n+\t but then they do cause partial register stalls.  */\n+      if (regno < 4 || TARGET_64BIT)\n+\treturn 1;\n+      if (!TARGET_PARTIAL_REG_STALL)\n+\treturn 1;\n+      return reload_in_progress || reload_completed;\n+    }\n+  /* We handle both integer and floats in the general purpose registers.  */\n+  else if (VALID_INT_MODE_P (mode))\n+    return 1;\n+  else if (VALID_FP_MODE_P (mode))\n+    return 1;\n+  /* Lots of MMX code casts 8 byte vector modes to DImode.  If we then go\n+     on to use that value in smaller contexts, this can easily force a \n+     pseudo to be allocated to GENERAL_REGS.  Since this is no worse than\n+     supporting DImode, allow it.  */\n+  else if (VALID_MMX_REG_MODE_3DNOW (mode) || VALID_MMX_REG_MODE (mode))\n     return 1;\n-  return reload_in_progress || reload_completed || !TARGET_PARTIAL_REG_STALL;\n+\n+  return 0;\n }\n \n /* A subroutine of ix86_modes_tieable_p.  Return true if MODE is a \n@@ -15172,12 +15208,14 @@ ix86_modes_tieable_p (enum machine_mode mode1, enum machine_mode mode2)\n \n   /* If MODE2 is only appropriate for an SSE register, then tie with \n      any other mode acceptable to SSE registers.  */\n-  if (SSE_REG_MODE_P (mode2))\n+  if (GET_MODE_SIZE (mode2) >= 8\n+      && ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode2))\n     return ix86_hard_regno_mode_ok (FIRST_SSE_REG, mode1);\n \n   /* If MODE2 is appropriate for an MMX (or SSE) register, then tie\n      with any other mode acceptable to MMX registers.  */\n-  if (MMX_REG_MODE_P (mode2))\n+  if (GET_MODE_SIZE (mode2) == 8\n+      && ix86_hard_regno_mode_ok (FIRST_MMX_REG, mode2))\n     return ix86_hard_regno_mode_ok (FIRST_MMX_REG, mode1);\n \n   return false;"}, {"sha": "ffba1d791457490fcde34ab32b2be39f98cdf3b3", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b4e82619bca237b96d0a85da90d4f67c71428f99", "patch": "@@ -1109,11 +1109,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    || (MODE) == V8HImode || (MODE) == V2DFmode || (MODE) == V2DImode\t\\\n    || (MODE) == V4SFmode || (MODE) == V4SImode)\n \n-/* Return true for modes passed in MMX registers.  */\n-#define MMX_REG_MODE_P(MODE) \\\n- ((MODE) == V8QImode || (MODE) == V4HImode || (MODE) == V2SImode\t\\\n-   || (MODE) == V2SFmode)\n-\n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\"}, {"sha": "179546924d6a0af7a5c7c105b67aef66c8361330", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b4e82619bca237b96d0a85da90d4f67c71428f99", "patch": "@@ -18659,18 +18659,16 @@\n ;; Attempt to always use XOR for zeroing registers.\n (define_peephole2\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(const_int 0))]\n-  \"(GET_MODE (operands[0]) == QImode\n-    || GET_MODE (operands[0]) == HImode\n-    || GET_MODE (operands[0]) == SImode\n-    || (GET_MODE (operands[0]) == DImode && TARGET_64BIT))\n+\t(match_operand 1 \"const0_operand\" \"\"))]\n+  \"GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && (! TARGET_USE_MOV0 || optimize_size)\n    && GENERAL_REG_P (operands[0])\n    && peep2_regno_dead_p (0, FLAGS_REG)\"\n   [(parallel [(set (match_dup 0) (const_int 0))\n \t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[0] = gen_lowpart (GET_MODE (operands[0]) == DImode ? DImode : SImode,\n-\t\t\t      operands[0]);\")\n+{\n+  operands[0] = gen_lowpart (word_mode, operands[0]);\n+})\n \n (define_peephole2\n   [(set (strict_low_part (match_operand 0 \"register_operand\" \"\"))"}, {"sha": "668c7c061e5f9d0d5e5fbd6117ab1700b503f029", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4e82619bca237b96d0a85da90d4f67c71428f99/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=b4e82619bca237b96d0a85da90d4f67c71428f99", "patch": "@@ -499,8 +499,12 @@\n \n ;; Match exactly zero.\n (define_predicate \"const0_operand\"\n-  (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"op == CONST0_RTX (mode)\")))\n+  (match_code \"const_int,const_double,const_vector\")\n+{\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op);\n+  return op == CONST0_RTX (mode);\n+})\n \n ;; Match exactly one.\n (define_predicate \"const1_operand\""}]}