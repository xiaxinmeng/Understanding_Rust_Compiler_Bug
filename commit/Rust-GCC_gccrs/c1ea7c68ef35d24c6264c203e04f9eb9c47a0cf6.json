{"sha": "c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFlYTdjNjhlZjM1ZDI0YzYyNjRjMjAzZTA0ZjllYjljNDdhMGNmNg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-16T13:51:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-16T13:55:38Z"}, "message": "c++: Fix detailed-mem-stat breakage\n\nmodule.cc has a static initializer that ends up in a circular\ndependency when detailed mem stats are enabled.  This removes the need\nfor that initializer to be dynamic, and we punt to the lazy\ninitializing we already had inside the object in question anyway.  At\nthe cost of an additional indirection.\n\n\tgcc/cp/\n\t* module.cc (loc_spans): Make spans a pointer, not inline.\n\tAdjust all accesses.", "tree": {"sha": "e2c1b0fb8a1cdcb141cbefbfcacde142a30dd19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2c1b0fb8a1cdcb141cbefbfcacde142a30dd19d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "151d1347c99acfcf0f5bcd8caac36dcc7353816d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151d1347c99acfcf0f5bcd8caac36dcc7353816d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151d1347c99acfcf0f5bcd8caac36dcc7353816d"}], "stats": {"total": 47, "additions": 25, "deletions": 22}, "files": [{"sha": "d2806966e436e84f8caaf89a3c8b4c324b8572c3", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=c1ea7c68ef35d24c6264c203e04f9eb9c47a0cf6", "patch": "@@ -3273,32 +3273,34 @@ class loc_spans {\n   };\n \n private:\n-  vec<span> spans;\n+  vec<span> *spans;\n \n public:\n   loc_spans ()\n+    /* Do not preallocate spans, as that causes\n+       --enable-detailed-mem-stats problems.  */\n+    : spans (nullptr)\n   {\n-    spans.create (20);\n   }\n   ~loc_spans ()\n   {\n-    spans.release ();\n+    delete spans;\n   }\n \n public:\n   span &operator[] (unsigned ix)\n   {\n-    return spans[ix];\n+    return (*spans)[ix];\n   }\n   unsigned length () const\n   {\n-    return spans.length ();\n+    return spans->length ();\n   }\n \n public:\n   bool init_p () const\n   {\n-    return spans.length () != 0;\n+    return spans != nullptr;\n   }\n   /* Initializer.  */\n   void init (const line_maps *lmaps, const line_map_ordinary *map);\n@@ -3321,7 +3323,7 @@ class loc_spans {\n public:\n   location_t main_start () const\n   {\n-    return spans[SPAN_MAIN].ordinary.first;\n+    return (*spans)[SPAN_MAIN].ordinary.first;\n   }\n \n public:\n@@ -13656,7 +13658,8 @@ void\n loc_spans::init (const line_maps *lmaps, const line_map_ordinary *map)\n {\n   gcc_checking_assert (!init_p ());\n-  spans.reserve (20);\n+  spans = new vec<span> ();\n+  spans->reserve (20);\n \n   span interval;\n   interval.ordinary.first = 0;\n@@ -13668,10 +13671,10 @@ loc_spans::init (const line_maps *lmaps, const line_map_ordinary *map)\n     = MAP_START_LOCATION (LINEMAPS_ORDINARY_MAP_AT (line_table, 0));\n   interval.macro.first = interval.macro.second;\n   dump (dumper::LOCATION)\n-    && dump (\"Fixed span %u ordinary:[%u,%u) macro:[%u,%u)\", spans.length (),\n+    && dump (\"Fixed span %u ordinary:[%u,%u) macro:[%u,%u)\", spans->length (),\n \t     interval.ordinary.first, interval.ordinary.second,\n \t     interval.macro.first, interval.macro.second);\n-  spans.quick_push (interval);\n+  spans->quick_push (interval);\n \n   /* A span for command line & forced headers.  */\n   interval.ordinary.first = interval.ordinary.second;\n@@ -13682,18 +13685,18 @@ loc_spans::init (const line_maps *lmaps, const line_map_ordinary *map)\n       interval.macro.first = LINEMAPS_MACRO_LOWEST_LOCATION (lmaps);\n     }\n   dump (dumper::LOCATION)\n-    && dump (\"Pre span %u ordinary:[%u,%u) macro:[%u,%u)\", spans.length (),\n+    && dump (\"Pre span %u ordinary:[%u,%u) macro:[%u,%u)\", spans->length (),\n \t     interval.ordinary.first, interval.ordinary.second,\n \t     interval.macro.first, interval.macro.second);\n-  spans.quick_push (interval);\n+  spans->quick_push (interval);\n   \n   /* Start an interval for the main file.  */\n   interval.ordinary.first = interval.ordinary.second;\n   interval.macro.second = interval.macro.first;\n   dump (dumper::LOCATION)\n-    && dump (\"Main span %u ordinary:[%u,*) macro:[*,%u)\", spans.length (),\n+    && dump (\"Main span %u ordinary:[%u,*) macro:[*,%u)\", spans->length (),\n \t     interval.ordinary.first, interval.macro.second);\n-  spans.quick_push (interval);\n+  spans->quick_push (interval);\n }\n \n /* Reopen the span, if we want the about-to-be-inserted set of maps to\n@@ -13727,9 +13730,9 @@ loc_spans::open (location_t hwm = UNKNOWN_LOCATION)\n   interval.ordinary_delta = interval.macro_delta = 0;\n   dump (dumper::LOCATION)\n     && dump (\"Opening span %u ordinary:[%u,... macro:...,%u)\",\n-\t     spans.length (), interval.ordinary.first,\n+\t     spans->length (), interval.ordinary.first,\n \t     interval.macro.second);\n-  spans.safe_push (interval);\n+  spans->safe_push (interval);\n }\n \n /* Close out the current linemap interval.  The last maps are within\n@@ -13738,15 +13741,15 @@ loc_spans::open (location_t hwm = UNKNOWN_LOCATION)\n void\n loc_spans::close ()\n {\n-  span &interval = spans.last ();\n+  span &interval = spans->last ();\n \n   interval.ordinary.second\n     = ((line_table->highest_location + (1 << line_table->default_range_bits))\n        & ~((1u << line_table->default_range_bits) - 1));\n   interval.macro.first = LINEMAPS_MACRO_LOWEST_LOCATION (line_table);\n   dump (dumper::LOCATION)\n     && dump (\"Closing span %u ordinary:[%u,%u) macro:[%u,%u)\",\n-\t     spans.length () - 1,\n+\t     spans->length () - 1,\n \t     interval.ordinary.first,interval.ordinary.second,\n \t     interval.macro.first, interval.macro.second);\n }\n@@ -13757,12 +13760,12 @@ loc_spans::close ()\n const loc_spans::span *\n loc_spans::ordinary (location_t loc)\n {\n-  unsigned len = spans.length ();\n+  unsigned len = spans->length ();\n   unsigned pos = 0;\n   while (len)\n     {\n       unsigned half = len / 2;\n-      const span &probe = spans[pos + half];\n+      const span &probe = (*spans)[pos + half];\n       if (loc < probe.ordinary.first)\n \tlen = half;\n       else if (loc < probe.ordinary.second)\n@@ -13782,12 +13785,12 @@ loc_spans::ordinary (location_t loc)\n const loc_spans::span *\n loc_spans::macro (location_t loc)\n {\n-  unsigned len = spans.length ();\n+  unsigned len = spans->length ();\n   unsigned pos = 0;\n   while (len)\n     {\n       unsigned half = len / 2;\n-      const span &probe = spans[pos + half];\n+      const span &probe = (*spans)[pos + half];\n       if (loc >= probe.macro.second)\n \tlen = half;\n       else if (loc >= probe.macro.first)"}]}