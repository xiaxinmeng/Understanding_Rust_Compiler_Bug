{"sha": "174425adcde4e0f7205e9ac6832f4e7a451b123e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0NDI1YWRjZGU0ZTBmNzIwNWU5YWM2ODMyZjRlN2E0NTFiMTIzZQ==", "commit": {"author": {"name": "Kai Tietz", "email": "kai.tietz@onevision.com", "date": "2010-09-26T04:02:24Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-09-26T04:02:24Z"}, "message": "cygwin.asm: Include auto-host.h.\n\n\t* config/i386/cygwin.asm: Include auto-host.h.\n\t(cfi_startproc, cfi_endproc, cfi_adjust_cfa_offset,\n\tcfi_def_cfa_register, cfi_register, cfi_push, cfi_pop): New macros.\n\t(__chkstk, __alloca): Annotate for dwarf2 unwind info.  Drop\n\talignment code from the 64-bit path.  Use gas local labels.\n\t* config/i386/i386.md (pro_epilogue_adjust_stack_<mode>_2): Macroize\n\tfrom _di_2.  Remove the useless constant integer argument.\n\t(pro_epilogue_adjust_stack_<mode>_3): New.\n\t(allocate_stack_worker_probe_<mode>): Macroize from\n\tallocate_stack_worker_{32,64}.  Use __chkstk_ms.  Update all users.\n\t* config/i386/i386.c (ix86_expand_prologue): Use __chkstk_ms;\n\tuse gen_pro_epilogue_adjust_stack_*_3 and annotate it.\n\t(__chkstk_ms): New function.\n\t* config/i386/t-cygming (LIB1ASMFUNCS): Add _chkstk_ms.\n\t* gcc/config/i386/t-interix: Likewise.\n\t* configure.ac (HAVE_GAS_CFI_DIRECTIVE): Export for target.\n\t(HAVE_GAS_CFI_PERSONALITY_DIRECTIVE): Likewise.\n\t(HAVE_GAS_CFI_SECTIONS_DIRECTIVE): Likewise.\n\t* configure, config.in: Rebuild.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r164628", "tree": {"sha": "94844f8fe08bec0ae9421339a340782e1641513e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94844f8fe08bec0ae9421339a340782e1641513e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174425adcde4e0f7205e9ac6832f4e7a451b123e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174425adcde4e0f7205e9ac6832f4e7a451b123e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174425adcde4e0f7205e9ac6832f4e7a451b123e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174425adcde4e0f7205e9ac6832f4e7a451b123e/comments", "author": null, "committer": null, "parents": [{"sha": "a0549e082c417e9ef40e47f2288fb7b8b0c648e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0549e082c417e9ef40e47f2288fb7b8b0c648e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0549e082c417e9ef40e47f2288fb7b8b0c648e5"}], "stats": {"total": 358, "additions": 216, "deletions": 142}, "files": [{"sha": "138fc99398981326785c231e11ace798edb86f45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -1,3 +1,26 @@\n+2010-09-25  Kai Tietz  <kai.tietz@onevision.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/cygwin.asm: Include auto-host.h.\n+\t(cfi_startproc, cfi_endproc, cfi_adjust_cfa_offset,\n+\tcfi_def_cfa_register, cfi_register, cfi_push, cfi_pop): New macros.\n+\t(__chkstk, __alloca): Annotate for dwarf2 unwind info.  Drop\n+\talignment code from the 64-bit path.  Use gas local labels.\n+\t* config/i386/i386.md (pro_epilogue_adjust_stack_<mode>_2): Macroize\n+\tfrom _di_2.  Remove the useless constant integer argument.\n+\t(pro_epilogue_adjust_stack_<mode>_3): New.\n+\t(allocate_stack_worker_probe_<mode>): Macroize from\n+\tallocate_stack_worker_{32,64}.  Use __chkstk_ms.  Update all users.\n+\t* config/i386/i386.c (ix86_expand_prologue): Use __chkstk_ms;\n+\tuse gen_pro_epilogue_adjust_stack_*_3 and annotate it.\n+\t(__chkstk_ms): New function.\n+\t* config/i386/t-cygming (LIB1ASMFUNCS): Add _chkstk_ms.\n+\t* gcc/config/i386/t-interix: Likewise.\n+\t* configure.ac (HAVE_GAS_CFI_DIRECTIVE): Export for target.\n+\t(HAVE_GAS_CFI_PERSONALITY_DIRECTIVE): Likewise.\n+\t(HAVE_GAS_CFI_SECTIONS_DIRECTIVE): Likewise.\n+\t* configure, config.in: Rebuild.\n+\n 2010-09-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-inline.c (copy_bb): Use GSI_CONTINUE_LINKING when inserting new"}, {"sha": "574c033e894c567c03cd42e84e7ed3ff2aeae433", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -936,22 +936,13 @@\n \n \n /* Define 0/1 if your assembler supports CFI directives. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_GAS_CFI_DIRECTIVE\n-#endif\n-\n \n /* Define 0/1 if your assembler supports .cfi_personality. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_GAS_CFI_PERSONALITY_DIRECTIVE\n-#endif\n-\n \n /* Define 0/1 if your assembler supports .cfi_sections. */\n-#ifndef USED_FOR_TARGET\n #undef HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n-#endif\n-\n \n /* Define if your assembler supports the .loc discriminator sub-directive. */\n #ifndef USED_FOR_TARGET"}, {"sha": "a6cc94d160a8bf5604d3e98417cb10481ddffbda", "filename": "gcc/config/i386/cygwin.asm", "status": "modified", "additions": 138, "deletions": 76, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Fcygwin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Fcygwin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.asm?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -1,6 +1,7 @@\n /* stuff needed for libgcc on win32.\n  *\n- *   Copyright (C) 1996, 1998, 2001, 2003, 2008, 2009 Free Software Foundation, Inc.\n+ *   Copyright (C) 1996, 1998, 2001, 2003, 2008, 2009\n+ *   Free Software Foundation, Inc.\n  *   Written By Steve Chamberlain\n  * \n  * This file is free software; you can redistribute it and/or modify it\n@@ -23,104 +24,165 @@\n  * <http://www.gnu.org/licenses/>.\n  */\n \n-#ifdef L_chkstk\n+#include \"auto-host.h\"\n+\n+#ifdef HAVE_GAS_CFI_SECTIONS_DIRECTIVE\n+\t.cfi_sections\t.debug_frame\n+# define cfi_startproc()\t\t.cfi_startproc\n+# define cfi_endproc()\t\t\t.cfi_endproc\n+# define cfi_adjust_cfa_offset(X) \t.cfi_adjust_cfa_offset X\n+# define cfi_def_cfa_register(X)\t.cfi_def_cfa_register X\n+# define cfi_register(D,S)\t\t.cfi_register D, S\n+# ifdef _WIN64\n+#  define cfi_push(X)\t\t.cfi_adjust_cfa_offset 8; .cfi_rel_offset X, 0\n+#  define cfi_pop(X)\t\t.cfi_adjust_cfa_offset -8; .cfi_restore X\n+# else\n+#  define cfi_push(X)\t\t.cfi_adjust_cfa_offset 4; .cfi_rel_offset X, 0\n+#  define cfi_pop(X)\t\t.cfi_adjust_cfa_offset -4; .cfi_restore X\n+# endif\n+#else\n+# define cfi_startproc()\n+# define cfi_endproc()\n+# define cfi_adjust_cfa_offset(X)\n+# define cfi_def_cfa_register(X)\n+# define cfi_register(D,S)\n+# define cfi_push(X)\n+# define cfi_pop(X)\n+#endif /* HAVE_GAS_CFI_SECTIONS_DIRECTIVE */\n \n-/* Function prologue calls _alloca to probe the stack when allocating more\n+#ifdef L_chkstk\n+/* Function prologue calls __chkstk to probe the stack when allocating more\n    than CHECK_STACK_LIMIT bytes in one go.  Touching the stack at 4K\n    increments is necessary to ensure that the guard pages used\n    by the OS virtual memory manger are allocated in correct sequence.  */\n \n \t.global ___chkstk\n \t.global\t__alloca\n-#ifndef _WIN64\n-___chkstk:\n+#ifdef _WIN64\n+/* __alloca is a normal function call, which uses %rcx as the argument.  */\n+\tcfi_startproc()\n __alloca:\n-\tpushl\t%ecx\t\t/* save temp */\n-\tleal\t8(%esp), %ecx\t/* point past return addr */\n-\tcmpl\t$0x1000, %eax\t/* > 4k ?*/\n-\tjb\tLdone\n+\tmovq\t%rcx, %rax\n+\t/* FALLTHRU */\n \n-Lprobe:\n-\tsubl\t$0x1000, %ecx  \t\t/* yes, move pointer down 4k*/\n-\torl\t$0x0, (%ecx)   \t\t/* probe there */\n-\tsubl\t$0x1000, %eax  \t \t/* decrement count */\n-\tcmpl\t$0x1000, %eax\n-\tja\tLprobe         \t \t/* and do it again */\n+/* ___chkstk is a *special* function call, which uses %rax as the argument.\n+   We avoid clobbering the 4 integer argument registers, %rcx, %rdx, \n+   %r8 and %r9, which leaves us with %rax, %r10, and %r11 to use.  */\n+\t.align\t4\n+___chkstk:\n+\tpopq\t%r11\t\t\t/* pop return address */\n+\tcfi_adjust_cfa_offset(-8)\t/* indicate return address in r11 */\n+\tcfi_register(%rip, %r11)\n+\tmovq\t%rsp, %r10\n+\tcmpq\t$0x1000, %rax\t\t/* > 4k ?*/\n+\tjb\t2f\n \n-Ldone:\n-\tsubl\t%eax, %ecx\t   \n-\torl\t$0x0, (%ecx)\t/* less than 4k, just peek here */\n+1:\tsubq\t$0x1000, %r10  \t\t/* yes, move pointer down 4k*/\n+\torl\t$0x0, (%r10)   \t\t/* probe there */\n+\tsubq\t$0x1000, %rax  \t \t/* decrement count */\n+\tcmpq\t$0x1000, %rax\n+\tja\t1b\t\t\t/* and do it again */\n \n-\tmovl\t%esp, %eax\t/* save old stack pointer */\n-\tmovl\t%ecx, %esp\t/* decrement stack */\n-\tmovl\t(%eax), %ecx\t/* recover saved temp */\n-\tmovl\t4(%eax), %eax\t/* recover return address */\n+2:\tsubq\t%rax, %r10\n+\tmovq\t%rsp, %rax\t\t/* hold CFA until return */\n+\tcfi_def_cfa_register(%rax)\n+\torl\t$0x0, (%r10)\t\t/* less than 4k, just peek here */\n+\tmovq\t%r10, %rsp\t\t/* decrement stack */\n \n \t/* Push the return value back.  Doing this instead of just\n-\t   jumping to %eax preserves the cached call-return stack\n+\t   jumping to %r11 preserves the cached call-return stack\n \t   used by most modern processors.  */\n-\tpushl\t%eax\n+\tpushq\t%r11\n \tret\n+\tcfi_endproc()\n #else\n-/* __alloca is a normal function call, which uses %rcx as the argument.  And stack space\n-   for the argument is saved.  */\n+\tcfi_startproc()\n+___chkstk:\n __alloca:\n- \tmovq\t%rcx, %rax\n-\taddq\t$0x7, %rax\n-\tandq\t$0xfffffffffffffff8, %rax\n-\tpopq\t%rcx\t\t/* pop return address */\n-\tpopq\t%r10\t\t/* Pop the reserved stack space.  */\n-\tmovq\t%rsp, %r10\t/* get sp */\n-\tcmpq\t$0x1000, %rax\t/* > 4k ?*/\n-\tjb\tLdone_alloca\n-\n-Lprobe_alloca:\n-\tsubq\t$0x1000, %r10  \t\t/* yes, move pointer down 4k*/\n-\torq\t$0x0, (%r10)   \t\t/* probe there */\n-\tsubq\t$0x1000, %rax  \t \t/* decrement count */\n-\tcmpq\t$0x1000, %rax\n-\tja\tLprobe_alloca         \t \t/* and do it again */\n+\tpushl\t%ecx\t\t\t/* save temp */\n+\tcfi_push(%eax)\n+\tleal\t8(%esp), %ecx\t\t/* point past return addr */\n+\tcmpl\t$0x1000, %eax\t\t/* > 4k ?*/\n+\tjb\t2f\n+\n+1:\tsubl\t$0x1000, %ecx  \t\t/* yes, move pointer down 4k*/\n+\torl\t$0x0, (%ecx)   \t\t/* probe there */\n+\tsubl\t$0x1000, %eax  \t \t/* decrement count */\n+\tcmpl\t$0x1000, %eax\n+\tja\t1b\t\t\t/* and do it again */\n \n-Ldone_alloca:\n-\tsubq\t%rax, %r10\n-\torq\t$0x0, (%r10)\t/* less than 4k, just peek here */\n-\tmovq\t%r10, %rax\n-\tsubq\t$0x8, %r10\t/* Reserve argument stack space.  */\n-\tmovq\t%r10, %rsp\t/* decrement stack */\n+2:\tsubl\t%eax, %ecx\t   \n+\torl\t$0x0, (%ecx)\t\t/* less than 4k, just peek here */\n+\tmovl\t%esp, %eax\t\t/* save current stack pointer */\n+\tcfi_def_cfa_register(%eax)\n+\tmovl\t%ecx, %esp\t\t/* decrement stack */\n+\tmovl\t(%eax), %ecx\t\t/* recover saved temp */\n \n-\t/* Push the return value back.  Doing this instead of just\n-\t   jumping to %rcx preserves the cached call-return stack\n-\t   used by most modern processors.  */\n-\tpushq\t%rcx\n+\t/* Copy the return register.  Doing this instead of just jumping to\n+\t   the address preserves the cached call-return stack used by most\n+\t   modern processors.  */\n+\tpushl\t4(%eax)\n \tret\n+\tcfi_endproc()\n+#endif /* _WIN64 */\n+#endif /* L_chkstk */\n \n-/* ___chkstk is a *special* function call, which uses %rax as the argument.\n-   We avoid clobbering the 4 integer argument registers, %rcx, %rdx, \n-   %r8 and %r9, which leaves us with %rax, %r10, and %r11 to use.  */\n-___chkstk:\n-\taddq\t$0x7, %rax\t/* Make sure stack is on alignment of 8.  */\n-\tandq\t$0xfffffffffffffff8, %rax\n-\tpopq\t%r11\t\t/* pop return address */\n-\tmovq\t%rsp, %r10\t/* get sp */\n-\tcmpq\t$0x1000, %rax\t/* > 4k ?*/\n-\tjb\tLdone\n-\n-Lprobe:\n-\tsubq\t$0x1000, %r10  \t\t/* yes, move pointer down 4k*/\n-\torl\t$0x0, (%r10)   \t\t/* probe there */\n+#ifdef L_chkstk_ms\n+/* ___chkstk_ms is a *special* function call, which uses %rax as the argument.\n+   We avoid clobbering any registers.  Unlike ___chkstk, it just probes the\n+   stack and does no stack allocation.  */\n+\t.global ___chkstk_ms\n+#ifdef _WIN64\n+\tcfi_startproc()\n+___chkstk_ms:\n+\tpushq\t%rcx\t\t\t/* save temps */\n+\tcfi_push(%rcx)\n+\tpushq\t%rax\n+\tcfi_push(%rax)\n+\tcmpq\t$0x1000, %rax\t\t/* > 4k ?*/\n+\tleaq\t24(%rsp), %rcx\t\t/* point past return addr */\n+\tjb\t2f\n+\n+1:\tsubq\t$0x1000, %rcx  \t\t/* yes, move pointer down 4k */\n+\torq\t$0x0, (%rcx)   \t\t/* probe there */\n \tsubq\t$0x1000, %rax  \t \t/* decrement count */\n \tcmpq\t$0x1000, %rax\n-\tja\tLprobe         \t \t/* and do it again */\n+\tja\t1b\t\t\t/* and do it again */\n \n-Ldone:\n-\tsubq\t%rax, %r10\n-\torl\t$0x0, (%r10)\t/* less than 4k, just peek here */\n-\tmovq\t%r10, %rsp\t/* decrement stack */\n+2:\tsubq\t%rax, %rcx\n+\torq\t$0x0, (%rcx)\t\t/* less than 4k, just peek here */\n \n-\t/* Push the return value back.  Doing this instead of just\n-\t   jumping to %r11 preserves the cached call-return stack\n-\t   used by most modern processors.  */\n-\tpushq\t%r11\n+\tpopq\t%rax\n+\tcfi_pop(%rax)\n+\tpopq\t%rcx\n+\tcfi_pop(%rcx)\n+\tret\n+\tcfi_endproc()\n+#else\n+\tcfi_startproc()\n+___chkstk_ms:\n+\tpushl\t%ecx\t\t\t/* save temp */\n+\tcfi_push(%ecx)\n+\tpushl\t%eax\n+\tcfi_push(%eax)\n+\tcmpl\t$0x1000, %eax\t\t/* > 4k ?*/\n+\tleal\t12(%esp), %ecx\t\t/* point past return addr */\n+\tjb\t2f\n+\n+1:\tsubl\t$0x1000, %ecx  \t\t/* yes, move pointer down 4k*/\n+\torl\t$0x0, (%ecx)   \t\t/* probe there */\n+\tsubl\t$0x1000, %eax  \t \t/* decrement count */\n+\tcmpl\t$0x1000, %eax\n+\tja\t1b\t\t\t/* and do it again */\n+\n+2:\tsubl\t%eax, %ecx\n+\torl\t$0x0, (%ecx)\t\t/* less than 4k, just peek here */\n+\n+\tpopl\t%eax\n+\tcfi_pop(%eax)\n+\tpopl\t%ecx\n+\tcfi_pop(%ecx)\n \tret\n-#endif\n-#endif\n+\tcfi_endproc()\n+#endif /* _WIN64 */\n+#endif /* L_chkstk_ms */"}, {"sha": "788ea4e1ef1afbcd02c31a9cb6feef876b6e4d6b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -3661,7 +3661,7 @@ ix86_option_override_internal (bool main_args_p)\n       ix86_gen_one_cmpl2 = gen_one_cmpldi2;\n       ix86_gen_monitor = gen_sse3_monitor64;\n       ix86_gen_andsp = gen_anddi3;\n-      ix86_gen_allocate_stack_worker = gen_allocate_stack_worker_64;\n+      ix86_gen_allocate_stack_worker = gen_allocate_stack_worker_probe_di;\n       ix86_gen_adjust_stack_and_probe = gen_adjust_stack_and_probedi;\n       ix86_gen_probe_stack_range = gen_probe_stack_rangedi;\n     }\n@@ -3674,7 +3674,7 @@ ix86_option_override_internal (bool main_args_p)\n       ix86_gen_one_cmpl2 = gen_one_cmplsi2;\n       ix86_gen_monitor = gen_sse3_monitor;\n       ix86_gen_andsp = gen_andsi3;\n-      ix86_gen_allocate_stack_worker = gen_allocate_stack_worker_32;\n+      ix86_gen_allocate_stack_worker = gen_allocate_stack_worker_probe_si;\n       ix86_gen_adjust_stack_and_probe = gen_adjust_stack_and_probesi;\n       ix86_gen_probe_stack_range = gen_probe_stack_rangesi;\n     }\n@@ -8796,8 +8796,7 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n       insn = emit_insn (gen_rtx_SET (DImode, tmp, offset));\n       if (style < 0)\n \tRTX_FRAME_RELATED_P (insn) = 1;\n-      insn = emit_insn (gen_pro_epilogue_adjust_stack_di_2 (dest, src, tmp,\n-\t\t\t\t\t\t\t    offset));\n+      insn = emit_insn (gen_pro_epilogue_adjust_stack_di_2 (dest, src, tmp));\n     }\n \n   if (style >= 0)\n@@ -9720,16 +9719,26 @@ ix86_expand_prologue (void)\n \t}\n \n       emit_move_insn (eax, GEN_INT (allocate));\n+      emit_insn (ix86_gen_allocate_stack_worker (eax, eax));\n \n-      insn = emit_insn (ix86_gen_allocate_stack_worker (eax, eax));\n+      /* Use the fact that AX still contains ALLOCATE.  */\n+      if (TARGET_64BIT)\n+\tinsn = gen_pro_epilogue_adjust_stack_di_3 (stack_pointer_rtx,\n+\t\t\t\t\t           stack_pointer_rtx, eax);\n+      else\n+\tinsn = gen_pro_epilogue_adjust_stack_si_3 (stack_pointer_rtx,\n+\t\t\t\t\t           stack_pointer_rtx, eax);\n+      insn = emit_insn (insn);\n \n       if (m->fs.cfa_reg == stack_pointer_rtx)\n \t{\n \t  m->fs.cfa_offset += allocate;\n-\t  t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));\n-\t  t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n-\t  add_reg_note (insn, REG_CFA_ADJUST_CFA, t);\n+\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+\t\t\tgen_rtx_SET (VOIDmode, stack_pointer_rtx,\n+\t\t\t\t     plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t    -allocate)));\n \t}\n       m->fs.sp_offset += allocate;\n "}, {"sha": "fddacd53791189b2f3bd06c641278d6b8a9f29e9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 30, "deletions": 47, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -16242,52 +16242,35 @@\n \t      (const_string \"*\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"pro_epilogue_adjust_stack_di_2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"0,r\")\n-\t\t (match_operand:DI 3 \"immediate_operand\" \"i,i\")))\n-   (use (match_operand:DI 2 \"register_operand\" \"r,l\"))\n+(define_insn \"pro_epilogue_adjust_stack_<mode>_2\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(plus:P (match_operand:DI 1 \"register_operand\" \"0\")\n+\t\t (match_operand:DI 2 \"register_operand\" \"r\")))\n    (clobber (reg:CC FLAGS_REG))\n    (clobber (mem:BLK (scratch)))]\n-  \"TARGET_64BIT\"\n-{\n-  switch (get_attr_type (insn))\n-    {\n-    case TYPE_ALU:\n-      return \"add{q}\\t{%2, %0|%0, %2}\";\n-\n-    case TYPE_LEA:\n-      operands[2] = gen_rtx_PLUS (DImode, operands[1], operands[2]);\n-      return \"lea{q}\\t{%a2, %0|%0, %a2}\";\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-  [(set_attr \"type\" \"alu,lea\")\n-   (set_attr \"mode\" \"DI\")])\n+  \"\"\n+  \"add{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"allocate_stack_worker_32\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-\t(unspec_volatile:SI [(match_operand:SI 1 \"register_operand\" \"0\")]\n-\t\t\t    UNSPECV_STACK_PROBE))\n-   (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 1)))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT && ix86_target_stack_probe ()\"\n-  \"call\\t___chkstk\"\n-  [(set_attr \"type\" \"multi\")\n-   (set_attr \"length\" \"5\")])\n+(define_insn \"pro_epilogue_adjust_stack_<mode>_3\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(minus:P (match_operand:P 1 \"register_operand\" \"0\")\n+\t\t (match_operand:P 2 \"register_operand\" \"r\")))\n+   (clobber (reg:CC FLAGS_REG))\n+   (clobber (mem:BLK (scratch)))]\n+  \"\"\n+  \"sub{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"alu\")\n+   (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"allocate_stack_worker_64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-\t(unspec_volatile:DI [(match_operand:DI 1 \"register_operand\" \"0\")]\n+(define_insn \"allocate_stack_worker_probe_<mode>\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=a\")\n+\t(unspec_volatile:P [(match_operand:P 1 \"register_operand\" \"0\")]\n \t\t\t    UNSPECV_STACK_PROBE))\n-   (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 1)))\n-   (clobber (reg:DI R10_REG))\n-   (clobber (reg:DI R11_REG))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_target_stack_probe ()\"\n-  \"call\\t___chkstk\"\n+  \"ix86_target_stack_probe ()\"\n+  \"call\\t___chkstk_ms\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n \n@@ -16312,15 +16295,15 @@\n     }\n   else\n     {\n-      rtx (*gen_allocate_stack_worker) (rtx, rtx);\n-\n+      x = copy_to_mode_reg (Pmode, operands[1]);\n       if (TARGET_64BIT)\n-\tgen_allocate_stack_worker = gen_allocate_stack_worker_64;\n+        emit_insn (gen_allocate_stack_worker_probe_di (x, x));\n       else\n-\tgen_allocate_stack_worker = gen_allocate_stack_worker_32;\n-\n-      x = copy_to_mode_reg (Pmode, operands[1]);\n-      emit_insn (gen_allocate_stack_worker (x, x));\n+        emit_insn (gen_allocate_stack_worker_probe_si (x, x));\n+      x = expand_simple_binop (Pmode, MINUS, stack_pointer_rtx, x,\n+\t\t\t       stack_pointer_rtx, 0, OPTAB_DIRECT);\n+      if (x != stack_pointer_rtx)\n+\temit_move_insn (stack_pointer_rtx, x);\n     }\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);"}, {"sha": "183e545d8eb7f0af553d8fc5cedf6377b848857d", "filename": "gcc/config/i386/t-cygming", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Ft-cygming", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Ft-cygming", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-cygming?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -17,7 +17,7 @@\n # <http://www.gnu.org/licenses/>.\n \n LIB1ASMSRC = i386/cygwin.asm\n-LIB1ASMFUNCS = _chkstk\n+LIB1ASMFUNCS = _chkstk _chkstk_ms\n \n # cygwin and mingw always have a limits.h, but, depending upon how we are\n # doing the build, it may not be installed yet."}, {"sha": "30539e2e13fc30e7907f3e11b83f6be43c7191cd", "filename": "gcc/config/i386/t-interix", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Ft-interix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfig%2Fi386%2Ft-interix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-interix?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -1,5 +1,5 @@\n LIB1ASMSRC = i386/cygwin.asm\n-LIB1ASMFUNCS = _chkstk\n+LIB1ASMFUNCS = _chkstk _chkstk_ms\n \n winnt.o: $(srcdir)/config/i386/winnt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   $(TM_H) $(RTL_H) $(REGS_H) hard-reg-set.h output.h $(TREE_H) flags.h \\"}, {"sha": "b7a1c111e744f3a3e971664223b79e0376f6bc70", "filename": "gcc/configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -21662,12 +21662,14 @@ else\n   gcc_cv_as_cfi_advance_working=no\n fi\n \n+\n cat >>confdefs.h <<_ACEOF\n #define HAVE_GAS_CFI_DIRECTIVE `if test $gcc_cv_as_cfi_directive = yes \\\n        && test $gcc_cv_as_cfi_advance_working = yes; then echo 1; else echo 0; fi`\n _ACEOF\n \n \n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for cfi personality directive\" >&5\n $as_echo_n \"checking assembler for cfi personality directive... \" >&6; }\n if test \"${gcc_cv_as_cfi_personality_directive+set}\" = set; then :\n@@ -21749,6 +21751,7 @@ fi\n $as_echo \"$gcc_cv_as_cfi_sections_directive\" >&6; }\n \n \n+\n cat >>confdefs.h <<_ACEOF\n #define HAVE_GAS_CFI_SECTIONS_DIRECTIVE `if test $gcc_cv_as_cfi_sections_directive = yes;\n     then echo 1; else echo 0; fi`"}, {"sha": "e9a86149d8ee2ce53fe97ef58524f3afc7e262cd", "filename": "gcc/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174425adcde4e0f7205e9ac6832f4e7a451b123e/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=174425adcde4e0f7205e9ac6832f4e7a451b123e", "patch": "@@ -2388,11 +2388,13 @@ else\n   # no objdump, err on the side of caution\n   gcc_cv_as_cfi_advance_working=no\n fi\n+GCC_TARGET_TEMPLATE(HAVE_GAS_CFI_DIRECTIVE)\n AC_DEFINE_UNQUOTED(HAVE_GAS_CFI_DIRECTIVE,\n   [`if test $gcc_cv_as_cfi_directive = yes \\\n        && test $gcc_cv_as_cfi_advance_working = yes; then echo 1; else echo 0; fi`],\n   [Define 0/1 if your assembler supports CFI directives.])\n \n+GCC_TARGET_TEMPLATE(HAVE_GAS_CFI_PERSONALITY_DIRECTIVE)\n gcc_GAS_CHECK_FEATURE([cfi personality directive],\n   gcc_cv_as_cfi_personality_directive, ,,\n [\t.text\n@@ -2426,6 +2428,7 @@ gcc_GAS_CHECK_FEATURE([cfi sections directive],\n     gcc_cv_as_cfi_sections_directive=yes\n     ;;\n esac])\n+GCC_TARGET_TEMPLATE(HAVE_GAS_CFI_SECTIONS_DIRECTIVE)\n AC_DEFINE_UNQUOTED(HAVE_GAS_CFI_SECTIONS_DIRECTIVE,\n   [`if test $gcc_cv_as_cfi_sections_directive = yes;\n     then echo 1; else echo 0; fi`],"}]}