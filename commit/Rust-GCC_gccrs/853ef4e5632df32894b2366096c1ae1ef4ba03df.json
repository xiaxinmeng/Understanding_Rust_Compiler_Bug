{"sha": "853ef4e5632df32894b2366096c1ae1ef4ba03df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUzZWY0ZTU2MzJkZjMyODk0YjIzNjYwOTZjMWFlMWVmNGJhMDNkZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-02-28T23:57:09Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-02-28T23:57:09Z"}, "message": "Class template argument deduction refinements\n\n\t* call.c (joust): Move deduction guide tiebreaker down.\n\t* decl.c (start_decl_1, cp_finish_decl, grokdeclarator): Allow class\n\tdeduction with no initializer.\n\t* pt.c (build_deduction_guide): Handle implicit default/copy ctor.\n\t(do_class_deduction): Use that rather than special case.\n\t(do_auto_deduction): Handle null initializer.\n\nFrom-SVN: r245796", "tree": {"sha": "9c3a71f0fc9f1269321ec72fd50dd34bf67987ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c3a71f0fc9f1269321ec72fd50dd34bf67987ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/853ef4e5632df32894b2366096c1ae1ef4ba03df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/853ef4e5632df32894b2366096c1ae1ef4ba03df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/853ef4e5632df32894b2366096c1ae1ef4ba03df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/853ef4e5632df32894b2366096c1ae1ef4ba03df/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad1de65225fc1ac05fe6b05b6198dc50a51e4935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad1de65225fc1ac05fe6b05b6198dc50a51e4935", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad1de65225fc1ac05fe6b05b6198dc50a51e4935"}], "stats": {"total": 407, "additions": 243, "deletions": 164}, "files": [{"sha": "b0e589c812db5f76305862cbe2264e4dbcdd07a2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -1,3 +1,13 @@\n+2017-02-28  Jason Merrill  <jason@redhat.com>\n+\n+\tClass template argument deduction refinements\n+\t* call.c (joust): Move deduction guide tiebreaker down.\n+\t* decl.c (start_decl_1, cp_finish_decl, grokdeclarator): Allow class\n+\tdeduction with no initializer.\n+\t* pt.c (build_deduction_guide): Handle implicit default/copy ctor.\n+\t(do_class_deduction): Use that rather than special case.\n+\t(do_auto_deduction): Handle null initializer.\n+\n 2017-02-28  Jakub Jelinek  <jakub@redhat.com>\n \n \t* decl.c (find_decomp_class_base): Use cond ? G_(\"...\") : G_(\"...\")"}, {"sha": "babab00158db18fa43e9fa7c02afcd1b3f8a75e4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -9670,18 +9670,6 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \treturn winner;\n     }\n \n-  /* F1 is generated from a deduction-guide (13.3.1.8) and F2 is not */\n-  if (deduction_guide_p (cand1->fn))\n-    {\n-      gcc_assert (deduction_guide_p (cand2->fn));\n-      /* We distinguish between candidates from an explicit deduction guide and\n-\t candidates built from a constructor based on DECL_ARTIFICIAL.  */\n-      int art1 = DECL_ARTIFICIAL (cand1->fn);\n-      int art2 = DECL_ARTIFICIAL (cand2->fn);\n-      if (art1 != art2)\n-\treturn art2 - art1;\n-    }\n-\n   /* or, if not that,\n      F1 is a non-template function and F2 is a template function\n      specialization.  */\n@@ -9719,6 +9707,18 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \treturn winner;\n     }\n \n+  /* F1 is generated from a deduction-guide (13.3.1.8) and F2 is not */\n+  if (deduction_guide_p (cand1->fn))\n+    {\n+      gcc_assert (deduction_guide_p (cand2->fn));\n+      /* We distinguish between candidates from an explicit deduction guide and\n+\t candidates built from a constructor based on DECL_ARTIFICIAL.  */\n+      int art1 = DECL_ARTIFICIAL (cand1->fn);\n+      int art2 = DECL_ARTIFICIAL (cand2->fn);\n+      if (art1 != art2)\n+\treturn art2 - art1;\n+    }\n+\n   /* or, if not that, F2 is from a using-declaration, F1 is not, and the\n      conversion sequences are equivalent.\n      (proposed in http://lists.isocpp.org/core/2016/10/1142.php) */"}, {"sha": "3e7316f3e0b739df02354e025769ad68eb1da8f6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -5238,13 +5238,15 @@ start_decl_1 (tree decl, bool initialized)\n   else if (aggregate_definition_p && !complete_p)\n     {\n       if (type_uses_auto (type))\n-\tgcc_unreachable ();\n+\tgcc_assert (CLASS_PLACEHOLDER_TEMPLATE (type));\n       else\n-\terror (\"aggregate %q#D has incomplete type and cannot be defined\",\n-\t       decl);\n-      /* Change the type so that assemble_variable will give\n-\t DECL an rtl we can live with: (mem (const_int 0)).  */\n-      type = TREE_TYPE (decl) = error_mark_node;\n+\t{\n+\t  error (\"aggregate %q#D has incomplete type and cannot be defined\",\n+\t\t decl);\n+\t  /* Change the type so that assemble_variable will give\n+\t     DECL an rtl we can live with: (mem (const_int 0)).  */\n+\t  type = TREE_TYPE (decl) = error_mark_node;\n+\t}\n     }\n \n   /* Create a new scope to hold this declaration if necessary.\n@@ -6816,14 +6818,17 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t      return;\n \t    }\n \n-\t  gcc_unreachable ();\n+\t  gcc_assert (CLASS_PLACEHOLDER_TEMPLATE (auto_node));\n \t}\n       d_init = init;\n-      if (TREE_CODE (d_init) == TREE_LIST\n-\t  && !CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n-\td_init = build_x_compound_expr_from_list (d_init, ELK_INIT,\n-\t\t\t\t\t\t  tf_warning_or_error);\n-      d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);\n+      if (d_init)\n+\t{\n+\t  if (TREE_CODE (d_init) == TREE_LIST\n+\t      && !CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n+\t    d_init = build_x_compound_expr_from_list (d_init, ELK_INIT,\n+\t\t\t\t\t\t      tf_warning_or_error);\n+\t  d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);\n+\t}\n       enum auto_deduction_context adc = adc_variable_type;\n       if (VAR_P (decl) && DECL_DECOMPOSITION_P (decl))\n \tadc = adc_decomp_type;\n@@ -12323,19 +12328,12 @@ grokdeclarator (const cp_declarator *declarator,\n \n     if (VAR_P (decl) && !initialized)\n       if (tree auto_node = type_uses_auto (type))\n-\t{\n-\t  location_t loc = declspecs->locations[ds_type_spec];\n-\t  if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n-\t    {\n-\t      error_at (loc, \"invalid use of template-name %qE without an \"\n-\t\t\t\"argument list\", tmpl);\n-\t      inform (loc, \"class template argument deduction \"\n-\t\t      \"requires an initializer\");\n-\t    }\n-\t  else\n+\tif (!CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n+\t  {\n+\t    location_t loc = declspecs->locations[ds_type_spec];\n \t    error_at (loc, \"declaration of %q#D has no initializer\", decl);\n-\t  TREE_TYPE (decl) = error_mark_node;\n-\t}\n+\t    TREE_TYPE (decl) = error_mark_node;\n+\t  }\n \n     if (storage_class == sc_extern && initialized && !funcdef_flag)\n       {"}, {"sha": "ec9d53a83ee2fadba023a01dac3e82f79a18a60b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 150, "deletions": 116, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -24941,103 +24941,137 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n }\n \n /* Returns a C++17 class deduction guide template based on the constructor\n-   CTOR.  */\n+   CTOR.  As a special case, CTOR can be a RECORD_TYPE for an implicit default\n+   guide, or REFERENCE_TYPE for an implicit copy/move guide.  */\n \n static tree\n build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n {\n-  if (outer_args)\n-    ctor = tsubst (ctor, outer_args, complain, ctor);\n-  tree type = DECL_CONTEXT (ctor);\n-  tree fn_tmpl;\n-  if (TREE_CODE (ctor) == TEMPLATE_DECL)\n+  tree type, tparms, targs, fparms, fargs, ci;\n+  bool memtmpl = false;\n+  bool explicit_p;\n+  location_t loc;\n+\n+  if (TYPE_P (ctor))\n     {\n-      fn_tmpl = ctor;\n-      ctor = DECL_TEMPLATE_RESULT (fn_tmpl);\n+      type = ctor;\n+      bool copy_p = TREE_CODE (type) == REFERENCE_TYPE;\n+      if (copy_p)\n+\t{\n+\t  type = TREE_TYPE (type);\n+\t  fparms = tree_cons (NULL_TREE, type, void_list_node);\n+\t}\n+      else\n+\tfparms = void_list_node;\n+\n+      tree ctmpl = CLASSTYPE_TI_TEMPLATE (type);\n+      tparms = DECL_TEMPLATE_PARMS (ctmpl);\n+      targs = CLASSTYPE_TI_ARGS (type);\n+      ci = NULL_TREE;\n+      fargs = NULL_TREE;\n+      loc = DECL_SOURCE_LOCATION (ctmpl);\n+      explicit_p = false;\n     }\n   else\n-    fn_tmpl = DECL_TI_TEMPLATE (ctor);\n-\n-  tree tparms = DECL_TEMPLATE_PARMS (fn_tmpl);\n-  /* If type is a member class template, DECL_TI_ARGS (ctor) will have fully\n-     specialized args for the enclosing class.  Strip those off, as the\n-     deduction guide won't have those template parameters.  */\n-  tree targs = get_innermost_template_args (DECL_TI_ARGS (ctor),\n-\t\t\t\t\t    TMPL_PARMS_DEPTH (tparms));\n-  /* Discard the 'this' parameter.  */\n-  tree fparms = FUNCTION_ARG_CHAIN (ctor);\n-  tree fargs = TREE_CHAIN (DECL_ARGUMENTS (ctor));\n-  tree ci = get_constraints (ctor);\n-\n-  if (PRIMARY_TEMPLATE_P (fn_tmpl))\n-    {\n-      /* For a member template constructor, we need to flatten the two template\n-\t parameter lists into one, and then adjust the function signature\n-\t accordingly.  This gets...complicated.  */\n-      ++processing_template_decl;\n-      tree save_parms = current_template_parms;\n-\n-      /* For a member template we should have two levels of parms/args, one for\n-\t the class and one for the constructor.  We stripped specialized args\n-\t for further enclosing classes above.  */\n-      const int depth = 2;\n-      gcc_assert (TMPL_ARGS_DEPTH (targs) == depth);\n-\n-      /* Template args for translating references to the two-level template\n-\t parameters into references to the one-level template parameters we are\n-\t creating.  */\n-      tree tsubst_args = copy_node (targs);\n-      TMPL_ARGS_LEVEL (tsubst_args, depth)\n-\t= copy_node (TMPL_ARGS_LEVEL (tsubst_args, depth));\n-\n-      /* Template parms for the constructor template.  */\n-      tree ftparms = TREE_VALUE (tparms);\n-      unsigned flen = TREE_VEC_LENGTH (ftparms);\n-      /* Template parms for the class template.  */\n-      tparms = TREE_CHAIN (tparms);\n-      tree ctparms = TREE_VALUE (tparms);\n-      unsigned clen = TREE_VEC_LENGTH (ctparms);\n-      /* Template parms for the deduction guide start as a copy of the template\n-\t parms for the class.  We set current_template_parms for\n-\t lookup_template_class_1.  */\n-      current_template_parms = tparms = copy_node (tparms);\n-      tree new_vec = TREE_VALUE (tparms) = make_tree_vec (flen + clen);\n-      for (unsigned i = 0; i < clen; ++i)\n-\tTREE_VEC_ELT (new_vec, i) = TREE_VEC_ELT (ctparms, i);\n-\n-      /* Now we need to rewrite the constructor parms to append them to the\n-\t class parms.  */\n-      for (unsigned i = 0; i < flen; ++i)\n+    {\n+      if (outer_args)\n+\tctor = tsubst (ctor, outer_args, complain, ctor);\n+      type = DECL_CONTEXT (ctor);\n+      tree fn_tmpl;\n+      if (TREE_CODE (ctor) == TEMPLATE_DECL)\n \t{\n-\t  unsigned index = i + clen;\n-\t  unsigned level = 1;\n-\t  tree oldelt = TREE_VEC_ELT (ftparms, i);\n-\t  tree olddecl = TREE_VALUE (oldelt);\n-\t  tree newdecl = rewrite_template_parm (olddecl, index, level,\n-\t\t\t\t\t\ttsubst_args, complain);\n-\t  tree newdef = tsubst_template_arg (TREE_PURPOSE (oldelt),\n-\t\t\t\t\t     tsubst_args, complain, ctor);\n-\t  tree list = build_tree_list (newdef, newdecl);\n-\t  TEMPLATE_PARM_CONSTRAINTS (list)\n-\t    = tsubst_constraint_info (TEMPLATE_PARM_CONSTRAINTS (oldelt),\n-\t\t\t\t      tsubst_args, complain, ctor);\n-\t  TREE_VEC_ELT (new_vec, index) = list;\n-\t  TMPL_ARG (tsubst_args, depth, i) = template_parm_to_arg (list);\n+\t  fn_tmpl = ctor;\n+\t  ctor = DECL_TEMPLATE_RESULT (fn_tmpl);\n \t}\n+      else\n+\tfn_tmpl = DECL_TI_TEMPLATE (ctor);\n+\n+      tparms = DECL_TEMPLATE_PARMS (fn_tmpl);\n+      /* If type is a member class template, DECL_TI_ARGS (ctor) will have\n+\t fully specialized args for the enclosing class.  Strip those off, as\n+\t the deduction guide won't have those template parameters.  */\n+      targs = get_innermost_template_args (DECL_TI_ARGS (ctor),\n+\t\t\t\t\t\tTMPL_PARMS_DEPTH (tparms));\n+      /* Discard the 'this' parameter.  */\n+      fparms = FUNCTION_ARG_CHAIN (ctor);\n+      fargs = TREE_CHAIN (DECL_ARGUMENTS (ctor));\n+      ci = get_constraints (ctor);\n+      loc = DECL_SOURCE_LOCATION (ctor);\n+      explicit_p = DECL_NONCONVERTING_P (ctor);\n+\n+      if (PRIMARY_TEMPLATE_P (fn_tmpl))\n+\t{\n+\t  memtmpl = true;\n+\n+\t  /* For a member template constructor, we need to flatten the two\n+\t     template parameter lists into one, and then adjust the function\n+\t     signature accordingly.  This gets...complicated.  */\n+\t  ++processing_template_decl;\n+\t  tree save_parms = current_template_parms;\n+\n+\t  /* For a member template we should have two levels of parms/args, one\n+\t     for the class and one for the constructor.  We stripped\n+\t     specialized args for further enclosing classes above.  */\n+\t  const int depth = 2;\n+\t  gcc_assert (TMPL_ARGS_DEPTH (targs) == depth);\n+\n+\t  /* Template args for translating references to the two-level template\n+\t     parameters into references to the one-level template parameters we\n+\t     are creating.  */\n+\t  tree tsubst_args = copy_node (targs);\n+\t  TMPL_ARGS_LEVEL (tsubst_args, depth)\n+\t    = copy_node (TMPL_ARGS_LEVEL (tsubst_args, depth));\n+\n+\t  /* Template parms for the constructor template.  */\n+\t  tree ftparms = TREE_VALUE (tparms);\n+\t  unsigned flen = TREE_VEC_LENGTH (ftparms);\n+\t  /* Template parms for the class template.  */\n+\t  tparms = TREE_CHAIN (tparms);\n+\t  tree ctparms = TREE_VALUE (tparms);\n+\t  unsigned clen = TREE_VEC_LENGTH (ctparms);\n+\t  /* Template parms for the deduction guide start as a copy of the\n+\t     template parms for the class.  We set current_template_parms for\n+\t     lookup_template_class_1.  */\n+\t  current_template_parms = tparms = copy_node (tparms);\n+\t  tree new_vec = TREE_VALUE (tparms) = make_tree_vec (flen + clen);\n+\t  for (unsigned i = 0; i < clen; ++i)\n+\t    TREE_VEC_ELT (new_vec, i) = TREE_VEC_ELT (ctparms, i);\n+\n+\t  /* Now we need to rewrite the constructor parms to append them to the\n+\t     class parms.  */\n+\t  for (unsigned i = 0; i < flen; ++i)\n+\t    {\n+\t      unsigned index = i + clen;\n+\t      unsigned level = 1;\n+\t      tree oldelt = TREE_VEC_ELT (ftparms, i);\n+\t      tree olddecl = TREE_VALUE (oldelt);\n+\t      tree newdecl = rewrite_template_parm (olddecl, index, level,\n+\t\t\t\t\t\t    tsubst_args, complain);\n+\t      tree newdef = tsubst_template_arg (TREE_PURPOSE (oldelt),\n+\t\t\t\t\t\t tsubst_args, complain, ctor);\n+\t      tree list = build_tree_list (newdef, newdecl);\n+\t      TEMPLATE_PARM_CONSTRAINTS (list)\n+\t\t= tsubst_constraint_info (TEMPLATE_PARM_CONSTRAINTS (oldelt),\n+\t\t\t\t\t  tsubst_args, complain, ctor);\n+\t      TREE_VEC_ELT (new_vec, index) = list;\n+\t      TMPL_ARG (tsubst_args, depth, i) = template_parm_to_arg (list);\n+\t    }\n \n-      /* Now we have a final set of template parms to substitute into the\n-\t function signature.  */\n-      targs = template_parms_to_args (tparms);\n-      fparms = tsubst_arg_types (fparms, tsubst_args, NULL_TREE,\n-\t\t\t\t complain, ctor);\n-      fargs = tsubst (fargs, tsubst_args, complain, ctor);\n-      if (ci)\n-\tci = tsubst_constraint_info (ci, tsubst_args, complain, ctor);\n+\t  /* Now we have a final set of template parms to substitute into the\n+\t     function signature.  */\n+\t  targs = template_parms_to_args (tparms);\n+\t  fparms = tsubst_arg_types (fparms, tsubst_args, NULL_TREE,\n+\t\t\t\t     complain, ctor);\n+\t  fargs = tsubst (fargs, tsubst_args, complain, ctor);\n+\t  if (ci)\n+\t    ci = tsubst_constraint_info (ci, tsubst_args, complain, ctor);\n \n-      current_template_parms = save_parms;\n-      --processing_template_decl;\n+\t  current_template_parms = save_parms;\n+\t  --processing_template_decl;\n+\t}\n     }\n-  else\n+\n+  if (!memtmpl)\n     {\n       /* Copy the parms so we can set DECL_PRIMARY_TEMPLATE.  */\n       tparms = copy_node (tparms);\n@@ -25046,12 +25080,12 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n     }\n \n   tree fntype = build_function_type (type, fparms);\n-  tree ded_fn = build_lang_decl_loc (DECL_SOURCE_LOCATION (ctor),\n+  tree ded_fn = build_lang_decl_loc (loc,\n \t\t\t\t     FUNCTION_DECL,\n \t\t\t\t     dguide_name (type), fntype);\n   DECL_ARGUMENTS (ded_fn) = fargs;\n   DECL_ARTIFICIAL (ded_fn) = true;\n-  DECL_NONCONVERTING_P (ded_fn) = DECL_NONCONVERTING_P (ctor);\n+  DECL_NONCONVERTING_P (ded_fn) = explicit_p;\n   tree ded_tmpl = build_template_decl (ded_fn, tparms, /*member*/false);\n   DECL_ARTIFICIAL (ded_tmpl) = true;\n   DECL_TEMPLATE_RESULT (ded_tmpl) = ded_fn;\n@@ -25085,27 +25119,16 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n   tree type = TREE_TYPE (tmpl);\n \n   vec<tree,va_gc> *args;\n-  if (TREE_CODE (init) == TREE_LIST)\n+  if (init == NULL_TREE\n+      || TREE_CODE (init) == TREE_LIST)\n     args = make_tree_vector_from_list (init);\n-  else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n+  else if (BRACE_ENCLOSED_INITIALIZER_P (init)\n+\t   && !TYPE_HAS_LIST_CTOR (type)\n+\t   && !is_std_init_list (type))\n     args = make_tree_vector_from_ctor (init);\n   else\n     args = make_tree_vector_single (init);\n \n-  if (args->length() == 1)\n-    {\n-      /* First try to deduce directly, since we don't have implicitly-declared\n-\t constructors yet.  */\n-      tree parms = build_tree_list (NULL_TREE, type);\n-      tree tparms = INNERMOST_TEMPLATE_PARMS (DECL_TEMPLATE_PARMS (tmpl));\n-      tree targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n-      int err = type_unification_real (tparms, targs, parms, &(*args)[0],\n-\t\t\t\t       1, /*subr*/false, DEDUCE_CALL,\n-\t\t\t\t       LOOKUP_NORMAL, NULL, /*explain*/false);\n-      if (err == 0)\n-\treturn tsubst (type, targs, complain, tmpl);\n-    }\n-\n   tree dname = dguide_name (tmpl);\n   tree cands = lookup_qualified_name (CP_DECL_CONTEXT (tmpl), dname,\n \t\t\t\t      /*type*/false, /*complain*/false,\n@@ -25121,28 +25144,39 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n       type = TREE_TYPE (most_general_template (tmpl));\n     }\n \n+  bool saw_default = false;\n+  bool saw_copy = false;\n   if (CLASSTYPE_METHOD_VEC (type))\n     // FIXME cache artificial deduction guides\n     for (tree fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))\n       {\n \ttree fn = OVL_CURRENT (fns);\n \ttree guide = build_deduction_guide (fn, outer_args, complain);\n \tcands = ovl_cons (guide, cands);\n+\n+\ttree parms = FUNCTION_FIRST_USER_PARMTYPE (fn);\n+\tif (sufficient_parms_p (parms))\n+\t  saw_default = true;\n+\tif (parms && sufficient_parms_p (TREE_CHAIN (parms)))\n+\t  {\n+\t    tree pt = TREE_VALUE (parms);\n+\t    if (TREE_CODE (pt) == REFERENCE_TYPE\n+\t\t&& (same_type_ignoring_top_level_qualifiers_p\n+\t\t    (TREE_TYPE (pt), type)))\n+\t      saw_copy = true;\n+\t  }\n       }\n \n-  if (cands == NULL_TREE)\n+  if (!saw_default && args->length() == 0)\n     {\n-      if (args->length() == 0)\n-\t{\n-\t  /* Try tmpl<>.  */\n-\t  tree t = lookup_template_class (tmpl, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t  NULL_TREE, false, tf_none);\n-\t  if (t != error_mark_node)\n-\t    return t;\n-\t}\n-      error (\"cannot deduce template arguments for %qT, as it has \"\n-\t     \"no deduction guides or user-declared constructors\", type);\n-      return error_mark_node;\n+      tree guide = build_deduction_guide (type, outer_args, complain);\n+      cands = ovl_cons (guide, cands);\n+    }\n+  if (!saw_copy && args->length() == 1)\n+    {\n+      tree guide = build_deduction_guide (build_reference_type (type),\n+\t\t\t\t\t  outer_args, complain);\n+      cands = ovl_cons (guide, cands);\n     }\n \n   /* Prune explicit deduction guides in copy-initialization context.  */\n@@ -25225,7 +25259,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n   if (init == error_mark_node)\n     return error_mark_node;\n \n-  if (type_dependent_expression_p (init)\n+  if (init && type_dependent_expression_p (init)\n       && context != adc_unify)\n     /* Defining a subset of type-dependent expressions that we can deduce\n        from ahead of time isn't worth the trouble.  */"}, {"sha": "7f2be00af233efab6bf59e729e49e76f428244a7", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction17.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction17.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -0,0 +1,11 @@\n+// { dg-options -std=c++1z }\n+\n+#include <initializer_list>\n+template <class T>\n+struct A\n+{\n+  A (std::initializer_list<T>);\n+};\n+\n+A a{1,2};\n+"}, {"sha": "0e496e62d85a5e10f5febd481f32604b1be479c4", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction25.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction25.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction25.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction25.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -15,10 +15,10 @@ template<class T> struct A {\n template<class T, int N = remove_ref_t<T>::value> A(T&&, int*) -> A<T>; //#3\n \n A a{1,0}; // uses #1 to deduce A<int> and initializes with #1\n-A b{a,0}; // uses #3 (not #2) to deduce A<A<int>&> and initializes with #1\n+A b{a,0}; // uses #2 to deduce A<int> and initializes with #2\n \n template <class,class> struct same;\n template <class T> struct same<T,T> {};\n \n same<decltype(a),A<int>> s1;\n-same<decltype(b),A<A<int>&>> s2;\n+same<decltype(b),A<int>> s2;"}, {"sha": "f50e87819ea8ef85f33dae1e91ef09ce48fb7e46", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction30.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction30.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction30.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction30.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -3,4 +3,4 @@\n template <class T = void> struct A { };\n \n A a{};\n-\n+A a2;"}, {"sha": "4423157490a1e23bf4b03cec9838fcead06001a4", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction31.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction31.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction31.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction31.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options -std=c++1z }\n+\n+template <class T> struct A {\n+  A(T); // #1\n+  A(const A&); // #2\n+};\n+\n+template <class T> A(T) -> A<T>;  // #3\n+\n+A a (42); // uses #3 to deduce A<int> and initializes with #1\n+A b = a;  // uses #2 (not #3) to deduce A<int> and initializes with #2; #2 is more specialized\n+\n+template <class T> A(A<T>) -> A<A<T>>;  // #4\n+\n+A b2 = a;  // uses #4 to deduce A<A<int>> and initializes with #1; #4 is as specialized as #2\n+\n+template <class,class> struct same;\n+template <class T> struct same<T,T> {};\n+\n+same<decltype(a),A<int>> s1;\n+same<decltype(b),A<int>> s2;\n+same<decltype(b2),A<A<int>>> s3;"}, {"sha": "4c3824fdee8f23b5cf618f6300285627b4057f32", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction32.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction32.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -0,0 +1,5 @@\n+// { dg-options -std=c++1z }\n+\n+#include <initializer_list>\n+\n+std::initializer_list l { 1, 2, 3 };"}, {"sha": "c32b5d421ffa004394b709c3446277038f158b41", "filename": "gcc/testsuite/g++.dg/parse/error15.C", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror15.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -10,12 +10,13 @@ namespace N\n   int K;\n }\n \n-N::A f2;              // { dg-error \"1:invalid use of template-name 'N::A' without an argument list\" }\n+N::A f2;              // { dg-error \"1:invalid use of template-name 'N::A' without an argument list\" \"\" { target c++14_down } }\n+\t\t\t\t// { dg-error \"deduction|no match\" \"\" { target c++1z } .-1 }\n N::INVALID f3;        // { dg-error \"4:'INVALID' in namespace 'N' does not name a type\" }\n N::C::INVALID f4;     // { dg-error \"7:'INVALID' in 'struct N::C' does not name a type\" }\n N::K f6;              // { dg-error \"4:'K' in namespace 'N' does not name a type\" }\n typename N::A f7;\n-// { dg-error \"13:invalid use of template-name 'N::A' without an argument list\" \"13\" { target *-*-* } 17 }\n+// { dg-error \"13:invalid use of template-name 'N::A' without an argument list\" \"13\" { target *-*-* } .-1 }\n \n struct B\n {\n@@ -24,7 +25,7 @@ struct B\n   N::C::INVALID f4;   // { dg-error \"9:'INVALID' in 'struct N::C' does not name a type\" }\n   N::K f6;            // { dg-error \"6:'K' in namespace 'N' does not name a type\" }\n   typename N::A f7;\n-// { dg-error \"15:invalid use of template-name 'N::A' without an argument list\" \"15\" { target *-*-* } 26 }\n+// { dg-error \"15:invalid use of template-name 'N::A' without an argument list\" \"15\" { target *-*-* } .-1 }\n };\n \n template <int>\n@@ -36,5 +37,3 @@ struct C\n   N::K f6;            // { dg-error \"6:'K' in namespace 'N' does not name a type\" }\n   typename N::A f7;   // { dg-error \"15:invalid use of template-name 'N::A' without an argument list\" }\n };\n-\n-// { dg-bogus \"bogus excess errors in declaration\" \"bogus excess errors in declaration\" { target *-*-* } 17 }"}, {"sha": "03068bbf440ce4806cec86b21b3775d0178a42c5", "filename": "gcc/testsuite/g++.dg/template/error52.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror52.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853ef4e5632df32894b2366096c1ae1ef4ba03df/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror52.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ferror52.C?ref=853ef4e5632df32894b2366096c1ae1ef4ba03df", "patch": "@@ -9,11 +9,11 @@ namespace H {\n     struct B {};\n     }\n \n-A a;             // { dg-error \"template\" }\n-H::B b;          // { dg-error \"template\" }\n+A a;             // { dg-error \"template|no match\" }\n+H::B b;          // { dg-error \"template|no match\" }\n \n int main() {\n-    A a;         // { dg-error \"template\" }\n-    H::B b;      // { dg-error \"template\" }\n+    A a;         // { dg-error \"template|no match\" }\n+    H::B b;      // { dg-error \"template|no match\" }\n     return 0;\n     }"}]}