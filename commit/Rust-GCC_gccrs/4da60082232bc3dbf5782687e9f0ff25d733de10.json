{"sha": "4da60082232bc3dbf5782687e9f0ff25d733de10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRhNjAwODIyMzJiYzNkYmY1NzgyNjg3ZTlmMGZmMjVkNzMzZGUxMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-06-03T08:02:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-06-03T08:02:10Z"}, "message": "re PR tree-optimization/63916 (value-numbering fails to forward variable addresses)\n\n2015-06-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/63916\n\t* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address):\n\tForward-propagate non-invariant addresses by splicing their\n\treference ops if the result isn't going to be used by PRE.\n\t(vn_reference_lookup_3): Remove pointless assert.\n\n\t* gcc.dg/tree-ssa/ssa-fre-45.c: New testcase.\n\nFrom-SVN: r224061", "tree": {"sha": "4a730c210522915db4aab6f110f5afa8c3aa58b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a730c210522915db4aab6f110f5afa8c3aa58b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4da60082232bc3dbf5782687e9f0ff25d733de10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da60082232bc3dbf5782687e9f0ff25d733de10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4da60082232bc3dbf5782687e9f0ff25d733de10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4da60082232bc3dbf5782687e9f0ff25d733de10/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9b79ba4264cf635fbd3cc66530c5eb83d3ce568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b79ba4264cf635fbd3cc66530c5eb83d3ce568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b79ba4264cf635fbd3cc66530c5eb83d3ce568"}], "stats": {"total": 59, "additions": 52, "deletions": 7}, "files": [{"sha": "8813ade38d50570eec5ee4d1a5359655ecd5d046", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4da60082232bc3dbf5782687e9f0ff25d733de10", "patch": "@@ -1,3 +1,11 @@\n+2015-06-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63916\n+\t* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address):\n+\tForward-propagate non-invariant addresses by splicing their\n+\treference ops if the result isn't going to be used by PRE.\n+\t(vn_reference_lookup_3): Remove pointless assert.\n+\n 2015-06-03  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66375"}, {"sha": "026dd538696ce3c846673fca43a2260d53bc34ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4da60082232bc3dbf5782687e9f0ff25d733de10", "patch": "@@ -1,3 +1,8 @@\n+2015-06-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/63916\n+\t* gcc.dg/tree-ssa/ssa-fre-45.c: New testcase.\n+\n 2015-06-03  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66375"}, {"sha": "ea8957fccc5b54173733fe85184318896b3c854e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-45.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-45.c?ref=4da60082232bc3dbf5782687e9f0ff25d733de10", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1\" } */\n+\n+struct S { float a, b; };\n+\n+float\n+foo (int x, float y)\n+{\n+  struct S z[1024];\n+  z[x].a = y;\n+  struct S *p = &z[x];\n+  float *q = (float *) p;\n+  return *q;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return y_\\\\d\\+\\\\(D\\\\);\" \"fre1\" } } */"}, {"sha": "e7838ed4132a9eeb58ce0411cbb2501b877c4160", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4da60082232bc3dbf5782687e9f0ff25d733de10/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=4da60082232bc3dbf5782687e9f0ff25d733de10", "patch": "@@ -144,6 +144,10 @@ along with GCC; see the file COPYING3.  If not see\n */\n \n \n+static tree *last_vuse_ptr;\n+static vn_lookup_kind vn_walk_kind;\n+static vn_lookup_kind default_vn_walk_kind;\n+\n /* vn_nary_op hashtable helpers.  */\n \n struct vn_nary_op_hasher : typed_noop_remove <vn_nary_op_s>\n@@ -1259,6 +1263,25 @@ vn_reference_maybe_forwprop_address (vec<vn_reference_op_s> *ops,\n       addr = gimple_assign_rhs1 (def_stmt);\n       addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),\n \t\t\t\t\t\t &addr_offset);\n+      /* If that didn't work because the address isn't invariant propagate\n+         the reference tree from the address operation in case the current\n+\t dereference isn't offsetted.  */\n+      if (!addr_base\n+\t  && *i_p == ops->length () - 1\n+\t  && off == 0\n+\t  /* This makes us disable this transform for PRE where the\n+\t     reference ops might be also used for code insertion which\n+\t     is invalid.  */\n+\t  && default_vn_walk_kind == VN_WALKREWRITE)\n+\t{\n+\t  auto_vec<vn_reference_op_s, 32> tem;\n+\t  copy_reference_ops_from_ref (TREE_OPERAND (addr, 0), &tem);\n+\t  ops->pop ();\n+\t  ops->pop ();\n+\t  ops->safe_splice (tem);\n+\t  --*i_p;\n+\t  return;\n+\t}\n       if (!addr_base\n \t  || TREE_CODE (addr_base) != MEM_REF)\n \treturn;\n@@ -1557,10 +1580,6 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n   return NULL_TREE;\n }\n \n-static tree *last_vuse_ptr;\n-static vn_lookup_kind vn_walk_kind;\n-static vn_lookup_kind default_vn_walk_kind;\n-\n /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_\n    with the current VUSE and performs the expression lookup.  */\n \n@@ -1649,15 +1668,12 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n   /* First try to disambiguate after value-replacing in the definitions LHS.  */\n   if (is_gimple_assign (def_stmt))\n     {\n-      vec<vn_reference_op_s> tem;\n       tree lhs = gimple_assign_lhs (def_stmt);\n       bool valueized_anything = false;\n       /* Avoid re-allocation overhead.  */\n       lhs_ops.truncate (0);\n       copy_reference_ops_from_ref (lhs, &lhs_ops);\n-      tem = lhs_ops;\n       lhs_ops = valueize_refs_1 (lhs_ops, &valueized_anything);\n-      gcc_assert (lhs_ops == tem);\n       if (valueized_anything)\n \t{\n \t  lhs_ref_ok = ao_ref_init_from_vn_reference (&lhs_ref,"}]}