{"sha": "72f76540ad0e7185d4f516e781e8bead13ebc170", "node_id": "C_kwDOANBUbNoAKDcyZjc2NTQwYWQwZTcxODVkNGY1MTZlNzgxZThiZWFkMTNlYmMxNzA", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-05-19T16:24:33Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-05-24T19:50:26Z"}, "message": "c++: discarded-value and constexpr\n\nI've been thinking for a while that the 'lval' parameter needed a third\nvalue for discarded-value expressions; most importantly,\ncxx_eval_store_expression does extra work for an lvalue result, and we also\ndon't want to do the l->r conversion.\n\nMostly this is pretty mechanical.  Apart from the _store_ fix, I also use\nvc_discard for substatements of a STATEMENT_LIST other than a stmt-expr\nresult, and avoid building _REFs to be ignored in a few other places.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (enum value_cat): New. Change all 'lval' parameters\n\tfrom int to value_cat.  Change most false to vc_prvalue, most true\n\tto vc_glvalue, cases where the return value is ignored to\n\tvc_discard.\n\t(cxx_eval_statement_list): Only vc_prvalue for stmt-expr result.\n\t(cxx_eval_store_expression): Only build _REF for vc_glvalue.\n\t(cxx_eval_array_reference, cxx_eval_component_reference)\n\t(cxx_eval_indirect_ref, cxx_eval_constant_expression): Likewise.", "tree": {"sha": "843cb42d0a7025cb8cadc4432c64ba871a0e9587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/843cb42d0a7025cb8cadc4432c64ba871a0e9587"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72f76540ad0e7185d4f516e781e8bead13ebc170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f76540ad0e7185d4f516e781e8bead13ebc170", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72f76540ad0e7185d4f516e781e8bead13ebc170", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f76540ad0e7185d4f516e781e8bead13ebc170/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2540e2c604142889308857657d3510874955336a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2540e2c604142889308857657d3510874955336a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2540e2c604142889308857657d3510874955336a"}], "stats": {"total": 198, "additions": 108, "deletions": 90}, "files": [{"sha": "a015bc7c8185d3cc6dcf8ef418fe5137e0e4838e", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 108, "deletions": 90, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72f76540ad0e7185d4f516e781e8bead13ebc170/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72f76540ad0e7185d4f516e781e8bead13ebc170/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=72f76540ad0e7185d4f516e781e8bead13ebc170", "patch": "@@ -1210,9 +1210,6 @@ uid_sensitive_constexpr_evaluation_checker::evaluation_restricted_p () const\n \n static GTY (()) hash_table<constexpr_call_hasher> *constexpr_call_table;\n \n-static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n-\t\t\t\t\t  bool, bool *, bool *, tree * = NULL);\n-\n /* Compute a hash value for a constexpr call representation.  */\n \n inline hashval_t\n@@ -1346,13 +1343,25 @@ get_nth_callarg (tree t, int n)\n     }\n }\n \n+/* Whether our evaluation wants a prvalue (e.g. CONSTRUCTOR or _CST),\n+   a glvalue (e.g. VAR_DECL or _REF), or nothing.  */\n+\n+enum value_cat {\n+   vc_prvalue = 0,\n+   vc_glvalue = 1,\n+   vc_discard = 2\n+};\n+\n+static tree cxx_eval_constant_expression (const constexpr_ctx *, tree,\n+\t\t\t\t\t  value_cat, bool *, bool *, tree * = NULL);\n+\n /* Attempt to evaluate T which represents a call to a builtin function.\n    We assume here that all builtin functions evaluate to scalar types\n    represented by _CST nodes.  */\n \n static tree\n cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n-\t\t\t\tbool lval,\n+\t\t\t\tvalue_cat lval,\n \t\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   const int nargs = call_expr_nargs (t);\n@@ -1458,7 +1467,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t, tree fun,\n \t  || potential_constant_expression (arg))\n \t{\n \t  bool dummy1 = false, dummy2 = false;\n-\t  arg = cxx_eval_constant_expression (&new_ctx, arg, false,\n+\t  arg = cxx_eval_constant_expression (&new_ctx, arg, vc_prvalue,\n \t\t\t\t\t      &dummy1, &dummy2);\n \t}\n \n@@ -1703,7 +1712,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t, tree fun,\n       /* Normally we would strip a TARGET_EXPR in an initialization context\n \t such as this, but here we do the elision differently: we keep the\n \t TARGET_EXPR, and use its CONSTRUCTOR as the value of the parm.  */\n-      arg = cxx_eval_constant_expression (ctx, x, /*lval=*/false,\n+      arg = cxx_eval_constant_expression (ctx, x, vc_prvalue,\n \t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && ctx->quiet)\n@@ -1807,7 +1816,7 @@ cx_error_context (void)\n \n static tree\n cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n-\t\t\t    bool lval,\n+\t\t\t    value_cat lval,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   enum tree_code opcode = ERROR_MARK;\n@@ -1832,12 +1841,13 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n \n     case IFN_LAUNDER:\n       return cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t   false, non_constant_p, overflow_p);\n+\t\t\t\t\t   vc_prvalue, non_constant_p,\n+\t\t\t\t\t   overflow_p);\n \n     case IFN_VEC_CONVERT:\n       {\n \ttree arg = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, 0),\n-\t\t\t\t\t\t false, non_constant_p,\n+\t\t\t\t\t\t vc_prvalue, non_constant_p,\n \t\t\t\t\t\t overflow_p);\n \tif (TREE_CODE (arg) == VECTOR_CST)\n \t  if (tree r = fold_const_call (CFN_VEC_CONVERT, TREE_TYPE (t), arg))\n@@ -2103,7 +2113,7 @@ cxx_eval_dynamic_cast_fn (const constexpr_ctx *ctx, tree call,\n     }\n \n   /* Evaluate the object so that we know its dynamic type.  */\n-  obj = cxx_eval_constant_expression (ctx, obj, /*lval*/false, non_constant_p,\n+  obj = cxx_eval_constant_expression (ctx, obj, vc_prvalue, non_constant_p,\n \t\t\t\t      overflow_p);\n   if (*non_constant_p)\n     return call;\n@@ -2138,7 +2148,7 @@ cxx_eval_dynamic_cast_fn (const constexpr_ctx *ctx, tree call,\n      considered to be a most derived object that has the type of the\n      constructor or destructor's class.  */\n   tree vtable = build_vfield_ref (obj, objtype);\n-  vtable = cxx_eval_constant_expression (ctx, vtable, /*lval*/false,\n+  vtable = cxx_eval_constant_expression (ctx, vtable, vc_prvalue,\n \t\t\t\t\t non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return call;\n@@ -2301,7 +2311,7 @@ replace_decl (tree *tp, tree decl, tree replacement)\n \n static tree\n cxx_eval_thunk_call (const constexpr_ctx *ctx, tree t, tree thunk_fndecl,\n-\t\t     bool lval,\n+\t\t     value_cat lval,\n \t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree function = THUNK_TARGET (thunk_fndecl);\n@@ -2362,7 +2372,7 @@ cxx_set_object_constness (const constexpr_ctx *ctx, tree object,\n     {\n       /* Subobjects might not be stored in ctx->global->values but we\n \t can get its CONSTRUCTOR by evaluating *this.  */\n-      tree e = cxx_eval_constant_expression (ctx, object, /*lval*/false,\n+      tree e = cxx_eval_constant_expression (ctx, object, vc_prvalue,\n \t\t\t\t\t     non_constant_p, overflow_p);\n       if (TREE_CODE (e) == CONSTRUCTOR && !*non_constant_p)\n \tTREE_READONLY (e) = readonly_p;\n@@ -2375,7 +2385,7 @@ cxx_set_object_constness (const constexpr_ctx *ctx, tree object,\n \n static tree\n cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t  bool lval,\n+\t\t\t  value_cat lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   /* Handle concept checks separately.  */\n@@ -2395,9 +2405,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n   if (TREE_CODE (fun) != FUNCTION_DECL)\n     {\n       /* Might be a constexpr function pointer.  */\n-      fun = cxx_eval_constant_expression (ctx, fun,\n-\t\t\t\t\t  /*lval*/false, non_constant_p,\n-\t\t\t\t\t  overflow_p);\n+      fun = cxx_eval_constant_expression (ctx, fun, vc_prvalue,\n+\t\t\t\t\t  non_constant_p, overflow_p);\n       STRIP_NOPS (fun);\n       if (TREE_CODE (fun) == ADDR_EXPR)\n \tfun = TREE_OPERAND (fun, 0);\n@@ -2463,7 +2472,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  for (int i = 0; i < nargs; ++i)\n \t    {\n \t      tree arg = CALL_EXPR_ARG (t, i);\n-\t      arg = cxx_eval_constant_expression (ctx, arg, false,\n+\t      arg = cxx_eval_constant_expression (ctx, arg, vc_prvalue,\n \t\t\t\t\t\t  non_constant_p, overflow_p);\n \t      VERIFY_CONSTANT (arg);\n \t      if (i == 0)\n@@ -2571,7 +2580,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t  for (int i = 0; i < nargs; ++i)\n \t    {\n \t      tree arg = CALL_EXPR_ARG (t, i);\n-\t      arg = cxx_eval_constant_expression (ctx, arg, false,\n+\t      arg = cxx_eval_constant_expression (ctx, arg, vc_prvalue,\n \t\t\t\t\t\t  non_constant_p, overflow_p);\n \t      if (i == 1)\n \t\targ1 = arg;\n@@ -2852,7 +2861,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \n \t  tree jump_target = NULL_TREE;\n \t  cxx_eval_constant_expression (&ctx_with_save_exprs, body,\n-\t\t\t\t\tlval, non_constant_p, overflow_p,\n+\t\t\t\t\tvc_discard, non_constant_p, overflow_p,\n \t\t\t\t\t&jump_target);\n \n \t  if (DECL_CONSTRUCTOR_P (fun))\n@@ -3213,7 +3222,7 @@ cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n {\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n-  tree arg = cxx_eval_constant_expression (ctx, orig_arg, /*lval*/false,\n+  tree arg = cxx_eval_constant_expression (ctx, orig_arg, vc_prvalue,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg);\n   location_t loc = EXPR_LOCATION (t);\n@@ -3259,8 +3268,8 @@ cxx_fold_pointer_plus_expression (const constexpr_ctx *ctx, tree t,\n \n       t = fold_convert_loc (loc, ssizetype, TREE_OPERAND (lhs, 1));\n       tree nelts = array_type_nelts_top (TREE_TYPE (TREE_OPERAND (lhs, 0)));\n-      nelts = cxx_eval_constant_expression (ctx, nelts, false, non_constant_p,\n-\t\t\t\t\t    overflow_p);\n+      nelts = cxx_eval_constant_expression (ctx, nelts, vc_prvalue,\n+\t\t\t\t\t    non_constant_p, overflow_p);\n       if (*non_constant_p)\n \treturn NULL_TREE;\n       /* Don't fold an out-of-bound access.  */\n@@ -3281,7 +3290,7 @@ cxx_fold_pointer_plus_expression (const constexpr_ctx *ctx, tree t,\n \t\t      t, NULL_TREE, NULL_TREE);\n       t = cp_build_addr_expr (t, tf_warning_or_error);\n       t = cp_fold_convert (orig_type, t);\n-      return cxx_eval_constant_expression (ctx, t, /*lval*/false,\n+      return cxx_eval_constant_expression (ctx, t, vc_prvalue,\n \t\t\t\t\t   non_constant_p, overflow_p);\n     }\n \n@@ -3325,20 +3334,20 @@ cxx_maybe_fold_addr_pointer_plus (tree t)\n \n static tree\n cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t    bool lval,\n+\t\t\t    value_cat lval,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   tree r = NULL_TREE;\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n-  lhs = cxx_eval_constant_expression (ctx, orig_lhs, /*lval*/false,\n+  lhs = cxx_eval_constant_expression (ctx, orig_lhs, vc_prvalue,\n \t\t\t\t      non_constant_p, overflow_p);\n   /* Don't VERIFY_CONSTANT here, it's unnecessary and will break pointer\n      subtraction.  */\n   if (*non_constant_p)\n     return t;\n-  rhs = cxx_eval_constant_expression (ctx, orig_rhs, /*lval*/false,\n+  rhs = cxx_eval_constant_expression (ctx, orig_rhs, vc_prvalue,\n \t\t\t\t      non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n@@ -3457,12 +3466,12 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t\t bool lval,\n+\t\t\t\t value_cat lval,\n \t\t\t\t bool *non_constant_p, bool *overflow_p,\n \t\t\t\t tree *jump_target)\n {\n   tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   /*lval*/false,\n+\t\t\t\t\t   vc_prvalue,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n   if (TREE_CODE (t) == IF_STMT && IF_STMT_CONSTEVAL_P (t))\n@@ -3504,15 +3513,15 @@ cxx_eval_vector_conditional_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree arg1 = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t    /*lval*/false,\n+\t\t\t\t\t    vc_prvalue,\n \t\t\t\t\t    non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg1);\n   tree arg2 = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\t    /*lval*/false,\n+\t\t\t\t\t    vc_prvalue,\n \t\t\t\t\t    non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg2);\n   tree arg3 = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n-\t\t\t\t\t    /*lval*/false,\n+\t\t\t\t\t    vc_prvalue,\n \t\t\t\t\t    non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg3);\n   location_t loc = EXPR_LOCATION (t);\n@@ -3844,7 +3853,7 @@ get_array_or_vector_nelts (const constexpr_ctx *ctx, tree type,\n     gcc_unreachable ();\n \n   /* For VLAs, the number of elements won't be an integer constant.  */\n-  nelts = cxx_eval_constant_expression (ctx, nelts, false,\n+  nelts = cxx_eval_constant_expression (ctx, nelts, vc_prvalue,\n \t\t\t\t\tnon_constant_p, overflow_p);\n   return nelts;\n }\n@@ -3881,7 +3890,7 @@ eval_and_check_array_index (const constexpr_ctx *ctx,\n   location_t loc = cp_expr_loc_or_input_loc (t);\n   tree ary = TREE_OPERAND (t, 0);\n   t = TREE_OPERAND (t, 1);\n-  tree index = cxx_eval_constant_expression (ctx, t, false,\n+  tree index = cxx_eval_constant_expression (ctx, t, vc_prvalue,\n \t\t\t\t\t     non_constant_p, overflow_p);\n   VERIFY_CONSTANT (index);\n \n@@ -3913,7 +3922,7 @@ eval_and_check_array_index (const constexpr_ctx *ctx,\n \n static tree\n cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n-\t\t\t  bool lval,\n+\t\t\t  value_cat lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   tree oldary = TREE_OPERAND (t, 0);\n@@ -3936,6 +3945,8 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \n   if (lval && ary == oldary && index == oldidx)\n     return t;\n+  else if (lval == vc_discard)\n+    return t;\n   else if (lval)\n     return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n \n@@ -4043,7 +4054,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool lval,\n+\t\t\t      value_cat lval,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   unsigned HOST_WIDE_INT i;\n@@ -4067,6 +4078,8 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n     whole = cplus_expand_constant (whole);\n   if (whole == orig_whole)\n     return t;\n+  if (lval == vc_discard)\n+    return t;\n   if (lval)\n     return fold_build3 (COMPONENT_REF, TREE_TYPE (t),\n \t\t\twhole, part, NULL_TREE);\n@@ -4152,7 +4165,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n-\t\t\tbool lval,\n+\t\t\tvalue_cat lval,\n \t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree orig_whole = TREE_OPERAND (t, 0);\n@@ -4449,7 +4462,7 @@ cxx_eval_bit_cast (const constexpr_ctx *ctx, tree t, bool *non_constant_p,\n       return t;\n     }\n \n-  tree op = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n+  tree op = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), vc_prvalue,\n \t\t\t\t\t  non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n@@ -4569,14 +4582,14 @@ cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,\n {\n   tree r;\n   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   /*lval*/false, non_constant_p,\n+\t\t\t\t\t   vc_prvalue, non_constant_p,\n \t\t\t\t\t   overflow_p);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t    /*lval*/false, non_constant_p,\n+\t\t\t\t    vc_prvalue, non_constant_p,\n \t\t\t\t    overflow_p);\n   VERIFY_CONSTANT (r);\n   return r;\n@@ -4725,7 +4738,7 @@ verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n \n static tree\n cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n-\t\t\t bool lval,\n+\t\t\t value_cat lval,\n \t\t\t bool *non_constant_p, bool *overflow_p)\n {\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n@@ -4858,7 +4871,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n-\t\t     bool value_init, bool lval,\n+\t\t     bool value_init, value_cat lval,\n \t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree elttype = TREE_TYPE (atype);\n@@ -5000,7 +5013,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \n static tree\n cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n-\t\t   bool lval,\n+\t\t   value_cat lval,\n \t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree atype = TREE_TYPE (t);\n@@ -5070,7 +5083,7 @@ cxx_union_active_member (const constexpr_ctx *ctx, tree t)\n   constexpr_ctx new_ctx = *ctx;\n   new_ctx.quiet = true;\n   bool non_constant_p = false, overflow_p = false;\n-  tree ctor = cxx_eval_constant_expression (&new_ctx, t, false,\n+  tree ctor = cxx_eval_constant_expression (&new_ctx, t, vc_prvalue,\n \t\t\t\t\t    &non_constant_p,\n \t\t\t\t\t    &overflow_p);\n   if (TREE_CODE (ctor) == CONSTRUCTOR\n@@ -5306,7 +5319,7 @@ cxx_fold_indirect_ref (const constexpr_ctx *ctx, location_t loc, tree type,\n \n static tree\n cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n-\t\t       bool lval,\n+\t\t       value_cat lval,\n \t\t       bool *non_constant_p, bool *overflow_p)\n {\n   tree orig_op0 = TREE_OPERAND (t, 0);\n@@ -5330,7 +5343,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n     {\n       /* If that didn't work, evaluate the operand first.  */\n       tree op0 = cxx_eval_constant_expression (ctx, orig_op0,\n-\t\t\t\t\t       /*lval*/false, non_constant_p,\n+\t\t\t\t\t       vc_prvalue, non_constant_p,\n \t\t\t\t\t       overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p)\n@@ -5366,7 +5379,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \t      return t;\n \t    }\n \n-\t  if (lval && op0 != orig_op0)\n+\t  if (lval == vc_glvalue && op0 != orig_op0)\n \t    return build1 (INDIRECT_REF, TREE_TYPE (t), op0);\n \t  if (!lval)\n \t    VERIFY_CONSTANT (t);\n@@ -5462,7 +5475,7 @@ non_const_var_error (location_t loc, tree r)\n \n static tree\n cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t     bool lval,\n+\t\t\t     value_cat lval,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   int i;\n@@ -5594,7 +5607,7 @@ modifying_const_object_p (tree_code code, tree obj, bool mutable_p)\n \n static tree\n cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t   bool lval,\n+\t\t\t   value_cat lval,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   constexpr_ctx new_ctx = *ctx;\n@@ -5617,19 +5630,19 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t stored in, so that any side-effects happen first.  */\n       if (!SCALAR_TYPE_P (type))\n \tnew_ctx.ctor = new_ctx.object = NULL_TREE;\n-      init = cxx_eval_constant_expression (&new_ctx, init, false,\n+      init = cxx_eval_constant_expression (&new_ctx, init, vc_prvalue,\n \t\t\t\t\t   non_constant_p, overflow_p);\n       if (*non_constant_p)\n \treturn t;\n     }\n \n   bool evaluated = false;\n-  if (lval)\n+  if (lval == vc_glvalue)\n     {\n       /* If we want to return a reference to the target, we need to evaluate it\n \t as a whole; otherwise, only evaluate the innermost piece to avoid\n \t building up unnecessary *_REFs.  */\n-      target = cxx_eval_constant_expression (ctx, target, true,\n+      target = cxx_eval_constant_expression (ctx, target, lval,\n \t\t\t\t\t     non_constant_p, overflow_p);\n       evaluated = true;\n       if (*non_constant_p)\n@@ -5681,7 +5694,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t    object = probe;\n \t  else\n \t    {\n-\t      probe = cxx_eval_constant_expression (ctx, probe, true,\n+\t      probe = cxx_eval_constant_expression (ctx, probe, vc_glvalue,\n \t\t\t\t\t\t    non_constant_p, overflow_p);\n \t      evaluated = true;\n \t      if (*non_constant_p)\n@@ -5893,7 +5906,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n       if (TREE_CODE (init) == TARGET_EXPR)\n \tif (tree tinit = TARGET_EXPR_INITIAL (init))\n \t  init = tinit;\n-      init = cxx_eval_constant_expression (&new_ctx, init, false,\n+      init = cxx_eval_constant_expression (&new_ctx, init, vc_prvalue,\n \t\t\t\t\t   non_constant_p, overflow_p);\n       /* The hash table might have moved since the get earlier, and the\n \t initializer might have mutated the underlying CONSTRUCTORs, so we must\n@@ -5992,7 +6005,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool lval,\n+\t\t\t      value_cat lval,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   enum tree_code code = TREE_CODE (t);\n@@ -6006,12 +6019,12 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n   offset = fold_simple (offset);\n \n   /* The operand as an lvalue.  */\n-  op = cxx_eval_constant_expression (ctx, op, true,\n+  op = cxx_eval_constant_expression (ctx, op, vc_glvalue,\n \t\t\t\t     non_constant_p, overflow_p);\n \n   /* The operand as an rvalue.  */\n   tree val\n-    = cxx_eval_constant_expression (ctx, op, false,\n+    = cxx_eval_constant_expression (ctx, op, vc_prvalue,\n \t\t\t\t    non_constant_p, overflow_p);\n   /* Don't VERIFY_CONSTANT if this might be dealing with a pointer to\n      a local array in a constexpr function.  */\n@@ -6160,8 +6173,10 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n       local_target = NULL_TREE;\n       jump_target = &local_target;\n     }\n-  for (tree stmt : tsi_range (t))\n+  for (tree_stmt_iterator i = tsi_start (t); !tsi_end_p (i); ++i)\n     {\n+      tree stmt = *i;\n+\n       /* We've found a continue, so skip everything until we reach\n \t the label its jumping to.  */\n       if (continues (jump_target))\n@@ -6174,7 +6189,13 @@ cxx_eval_statement_list (const constexpr_ctx *ctx, tree t,\n \t}\n       if (TREE_CODE (stmt) == DEBUG_BEGIN_STMT)\n \tcontinue;\n-      r = cxx_eval_constant_expression (ctx, stmt, false,\n+\n+      value_cat lval = vc_discard;\n+      /* The result of a statement-expression is not wrapped in EXPR_STMT.  */\n+      if (tsi_one_before_end_p (i) && TREE_CODE (stmt) != EXPR_STMT)\n+\tlval = vc_prvalue;\n+\n+      r = cxx_eval_constant_expression (ctx, stmt, lval,\n \t\t\t\t\tnon_constant_p, overflow_p,\n \t\t\t\t\tjump_target);\n       if (*non_constant_p)\n@@ -6228,7 +6249,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n       break;\n     case FOR_STMT:\n       if (FOR_INIT_STMT (t))\n-\tcxx_eval_constant_expression (ctx, FOR_INIT_STMT (t), /*lval*/false,\n+\tcxx_eval_constant_expression (ctx, FOR_INIT_STMT (t), vc_discard,\n \t\t\t\t      non_constant_p, overflow_p, jump_target);\n       if (*non_constant_p)\n \treturn NULL_TREE;\n@@ -6247,7 +6268,7 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n       if (count != -1)\n \t{\n \t  if (body)\n-\t    cxx_eval_constant_expression (&new_ctx, body, /*lval*/false,\n+\t    cxx_eval_constant_expression (&new_ctx, body, vc_discard,\n \t\t\t\t\t  non_constant_p, overflow_p,\n \t\t\t\t\t  jump_target);\n \t  if (breaks (jump_target))\n@@ -6260,15 +6281,15 @@ cxx_eval_loop_expr (const constexpr_ctx *ctx, tree t,\n \t    *jump_target = NULL_TREE;\n \n \t  if (expr)\n-\t    cxx_eval_constant_expression (&new_ctx, expr, /*lval*/false,\n+\t    cxx_eval_constant_expression (&new_ctx, expr, vc_prvalue,\n \t\t\t\t\t  non_constant_p, overflow_p,\n \t\t\t\t\t  jump_target);\n \t}\n \n       if (cond)\n \t{\n \t  tree res\n-\t    = cxx_eval_constant_expression (&new_ctx, cond, /*lval*/false,\n+\t    = cxx_eval_constant_expression (&new_ctx, cond, vc_prvalue,\n \t\t\t\t\t    non_constant_p, overflow_p,\n \t\t\t\t\t    jump_target);\n \t  if (res)\n@@ -6322,7 +6343,7 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n {\n   tree cond\n     = TREE_CODE (t) == SWITCH_STMT ? SWITCH_STMT_COND (t) : SWITCH_COND (t);\n-  cond = cxx_eval_constant_expression (ctx, cond, false,\n+  cond = cxx_eval_constant_expression (ctx, cond, vc_prvalue,\n \t\t\t\t       non_constant_p, overflow_p);\n   VERIFY_CONSTANT (cond);\n   *jump_target = cond;\n@@ -6332,15 +6353,15 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n   constexpr_ctx new_ctx = *ctx;\n   constexpr_switch_state css = css_default_not_seen;\n   new_ctx.css_state = &css;\n-  cxx_eval_constant_expression (&new_ctx, body, false,\n+  cxx_eval_constant_expression (&new_ctx, body, vc_discard,\n \t\t\t\tnon_constant_p, overflow_p, jump_target);\n   if (switches (jump_target) && css == css_default_seen)\n     {\n       /* If the SWITCH_EXPR body has default: label, process it once again,\n \t this time instructing label_matches to return true for default:\n \t label on switches (jump_target).  */\n       css = css_default_processing;\n-      cxx_eval_constant_expression (&new_ctx, body, false,\n+      cxx_eval_constant_expression (&new_ctx, body, vc_discard,\n \t\t\t\t    non_constant_p, overflow_p, jump_target);\n     }\n   if (breaks (jump_target) || switches (jump_target))\n@@ -6351,7 +6372,7 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n /* Find the object of TYPE under initialization in CTX.  */\n \n static tree\n-lookup_placeholder (const constexpr_ctx *ctx, bool lval, tree type)\n+lookup_placeholder (const constexpr_ctx *ctx, value_cat lval, tree type)\n {\n   if (!ctx)\n     return NULL_TREE;\n@@ -6478,12 +6499,12 @@ build_new_constexpr_heap_type (const constexpr_ctx *ctx, tree elt_type,\n \t  tree op1 = TREE_OPERAND (arg_size, 1);\n \t  if (integer_zerop (op0))\n \t    arg_size\n-\t      = cxx_eval_constant_expression (ctx, op1, false, non_constant_p,\n-\t\t\t\t\t      overflow_p);\n+\t      = cxx_eval_constant_expression (ctx, op1, vc_prvalue,\n+\t\t\t\t\t      non_constant_p, overflow_p);\n \t  else if (integer_zerop (op1))\n \t    arg_size\n-\t      = cxx_eval_constant_expression (ctx, op0, false, non_constant_p,\n-\t\t\t\t\t      overflow_p);\n+\t      = cxx_eval_constant_expression (ctx, op0, vc_prvalue,\n+\t\t\t\t\t      non_constant_p, overflow_p);\n \t  else\n \t    arg_size = NULL_TREE;\n \t}\n@@ -6513,7 +6534,7 @@ build_new_constexpr_heap_type (const constexpr_ctx *ctx, tree elt_type,\n \n static tree\n cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool lval,\n+\t\t\t      value_cat lval,\n \t\t\t      bool *non_constant_p, bool *overflow_p,\n \t\t\t      tree *jump_target /* = NULL */)\n {\n@@ -6760,8 +6781,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n \tif (tree init = DECL_INITIAL (r))\n \t  {\n-\t    init = cxx_eval_constant_expression (ctx, init,\n-\t\t\t\t\t\t false,\n+\t    init = cxx_eval_constant_expression (ctx, init, vc_prvalue,\n \t\t\t\t\t\t non_constant_p, overflow_p);\n \t    /* Don't share a CONSTRUCTOR that might be changed.  */\n \t    init = unshare_constructor (init);\n@@ -6821,10 +6841,9 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t    ctx->global->values.put (new_ctx.object, new_ctx.ctor);\n \t    ctx = &new_ctx;\n \t  }\n-\t/* Pass false for 'lval' because this indicates\n+\t/* Pass vc_prvalue because this indicates\n \t   initialization of a temporary.  */\n-\tr = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\t  false,\n+\tr = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1), vc_prvalue,\n \t\t\t\t\t  non_constant_p, overflow_p);\n \tif (*non_constant_p)\n \t  break;\n@@ -6880,7 +6899,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tr = *p;\n       else\n \t{\n-\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), false,\n+\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0), vc_prvalue,\n \t\t\t\t\t    non_constant_p, overflow_p);\n \t  if (*non_constant_p)\n \t    break;\n@@ -6922,7 +6941,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \ttree cleanup;\n \t/* Evaluate the cleanups.  */\n \tFOR_EACH_VEC_ELT_REVERSE (cleanups, i, cleanup)\n-\t  cxx_eval_constant_expression (ctx, cleanup, false,\n+\t  cxx_eval_constant_expression (ctx, cleanup, vc_discard,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       }\n       break;\n@@ -6933,7 +6952,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\tjump_target);\n       if (!*non_constant_p)\n \t/* Also evaluate the cleanup.  */\n-\tcxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1), true,\n+\tcxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1), vc_discard,\n \t\t\t\t      non_constant_p, overflow_p);\n       break;\n \n@@ -6945,7 +6964,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t{\n \t  iloc_sentinel ils (loc);\n \t  /* Also evaluate the cleanup.  */\n-\t  cxx_eval_constant_expression (ctx, CLEANUP_EXPR (t), true,\n+\t  cxx_eval_constant_expression (ctx, CLEANUP_EXPR (t), vc_discard,\n \t\t\t\t\tnon_constant_p, overflow_p);\n \t}\n       break;\n@@ -6962,8 +6981,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case ADDR_EXPR:\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n-\ttree op = cxx_eval_constant_expression (ctx, oldop,\n-\t\t\t\t\t\t/*lval*/true,\n+\ttree op = cxx_eval_constant_expression (ctx, oldop, vc_glvalue,\n \t\t\t\t\t\tnon_constant_p, overflow_p);\n \t/* Don't VERIFY_CONSTANT here.  */\n \tif (*non_constant_p)\n@@ -6987,7 +7005,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t    non_constant_p, overflow_p);\n \t  if (r == error_mark_node)\n \t    ;\n-\t  else if (r == TREE_OPERAND (t, 0))\n+\t  else if (r == TREE_OPERAND (t, 0) || lval == vc_discard)\n \t    r = t;\n \t  else\n \t    r = fold_build1 (TREE_CODE (t), TREE_TYPE (t), r);\n@@ -7039,8 +7057,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \telse\n \t  {\n \t    /* Check that the LHS is constant and then discard it.  */\n-\t    cxx_eval_constant_expression (ctx, op0,\n-\t\t\t\t\t  true, non_constant_p, overflow_p,\n+\t    cxx_eval_constant_expression (ctx, op0, vc_discard,\n+\t\t\t\t\t  non_constant_p, overflow_p,\n \t\t\t\t\t  jump_target);\n \t    if (*non_constant_p)\n \t      return t;\n@@ -7461,7 +7479,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case EXIT_EXPR:\n       {\n \ttree cond = TREE_OPERAND (t, 0);\n-\tcond = cxx_eval_constant_expression (ctx, cond, /*lval*/false,\n+\tcond = cxx_eval_constant_expression (ctx, cond, vc_prvalue,\n \t\t\t\t\t     non_constant_p, overflow_p);\n \tVERIFY_CONSTANT (cond);\n \tif (integer_nonzerop (cond))\n@@ -7820,8 +7838,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \n   if (manifestly_const_eval)\n     instantiate_constexpr_fns (r);\n-  r = cxx_eval_constant_expression (&ctx, r,\n-\t\t\t\t    false, &non_constant_p, &overflow_p);\n+  r = cxx_eval_constant_expression (&ctx, r, vc_prvalue,\n+\t\t\t\t    &non_constant_p, &overflow_p);\n \n   if (!constexpr_dtor)\n     verify_constant (r, allow_non_constant, &non_constant_p, &overflow_p);\n@@ -7832,7 +7850,7 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   tree cleanup;\n   /* Evaluate the cleanups.  */\n   FOR_EACH_VEC_ELT_REVERSE (cleanups, i, cleanup)\n-    cxx_eval_constant_expression (&ctx, cleanup, false,\n+    cxx_eval_constant_expression (&ctx, cleanup, vc_discard,\n \t\t\t\t  &non_constant_p, &overflow_p);\n \n   /* Mutable logic is a bit tricky: we want to allow initialization of"}]}