{"sha": "0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFhYWZhNWU5NWRmNDRlZWQzYWQ2N2VhNjVjOWFmZGEyZGJkZDQ5Mw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-08-28T19:09:38Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-08-28T19:09:38Z"}, "message": "PR middle-end/86631 - missing -Walloc-size-larger-than on ILP32 hosts\n\ngcc/ChangeLog:\n\n\tPR middle-end/86631\n\t* calls.c (alloc_max_size): Treat HOST_WIDE_INT special.\n\t* gimple-ssa-warn-alloca.c (adjusted_warn_limit): New function.\n\t(pass_walloca::gate): Use it.\n\t(alloca_call_type): Same.\n\t(pass_walloca::execute): Same.\n\t* stor-layout.c (layout_decl): Treat HOST_WIDE_INT special.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/86631\n\t* g++.dg/Walloca1.C: Adjust.\n\nFrom-SVN: r263928", "tree": {"sha": "dbf4c33008642719c398d068222b45cd34a970c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dbf4c33008642719c398d068222b45cd34a970c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dd35da2cbef6d8bf9db86d7e66faeebb5022c881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd35da2cbef6d8bf9db86d7e66faeebb5022c881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd35da2cbef6d8bf9db86d7e66faeebb5022c881"}], "stats": {"total": 88, "additions": 67, "deletions": 21}, "files": [{"sha": "b4b56da6c0d8cd868d9ddab05d27b9db8d077f36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "patch": "@@ -1,3 +1,13 @@\n+2018-08-28  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/86631\n+\t* calls.c (alloc_max_size): Treat HOST_WIDE_INT special.\n+\t* gimple-ssa-warn-alloca.c (adjusted_warn_limit): New function.\n+\t(pass_walloca::gate): Use it.\n+\t(alloca_call_type): Same.\n+\t(pass_walloca::execute): Same.\n+\t* stor-layout.c (layout_decl): Treat HOST_WIDE_INT special.\n+\n 2018-08-28  David Malcolm  <dmalcolm@redhat.com>\n \n \t* dumpfile.h (ATTRIBUTE_GCC_DUMP_PRINTF): Change version check on"}, {"sha": "e9660b6242463c5d90772e1a321d09becfefc87c", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "patch": "@@ -1222,8 +1222,11 @@ alloc_max_size (void)\n   if (alloc_object_size_limit)\n     return alloc_object_size_limit;\n \n-  alloc_object_size_limit\n-    = build_int_cst (size_type_node, warn_alloc_size_limit);\n+  HOST_WIDE_INT limit = warn_alloc_size_limit;\n+  if (limit == HOST_WIDE_INT_MAX)\n+    limit = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\n+  alloc_object_size_limit = build_int_cst (size_type_node, limit);\n \n   return alloc_object_size_limit;\n }"}, {"sha": "4d5aed866e1b696e7e28b37313126b7feaca321d", "filename": "gcc/gimple-ssa-warn-alloca.c", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Fgimple-ssa-warn-alloca.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Fgimple-ssa-warn-alloca.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-alloca.c?ref=0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "patch": "@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"intl.h\"\n \n+static unsigned HOST_WIDE_INT adjusted_warn_limit (bool);\n+\n const pass_data pass_data_walloca = {\n   GIMPLE_PASS,\n   \"walloca\",\n@@ -82,7 +84,9 @@ pass_walloca::gate (function *fun ATTRIBUTE_UNUSED)\n   // Warning is disabled when its size limit is greater than PTRDIFF_MAX\n   // for the target maximum, which makes the limit negative since when\n   // represented in signed HOST_WIDE_INT.\n-  return warn_alloca_limit >= 0 || warn_vla_limit >= 0;\n+  unsigned HOST_WIDE_INT max = tree_to_uhwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n+  return (adjusted_warn_limit (false) <= max\n+\t  || adjusted_warn_limit (true) <= max);\n }\n \n // Possible problematic uses of alloca.\n@@ -127,6 +131,30 @@ struct alloca_type_and_limit {\n   alloca_type_and_limit (enum alloca_type type) : type(type) { }\n };\n \n+/* Return the value of the argument N to -Walloca-larger-than= or\n+   -Wvla-larger-than= adjusted for the target data model so that\n+   when N == HOST_WIDE_INT_MAX, the adjusted value is set to\n+   PTRDIFF_MAX on the target.  This is done to prevent warnings\n+   for unknown/unbounded allocations in the \"permissive mode\"\n+   while still diagnosing excessive and necessarily invalid\n+   allocations.  */\n+\n+static unsigned HOST_WIDE_INT\n+adjusted_warn_limit (bool idx)\n+{\n+  static HOST_WIDE_INT limits[2];\n+  if (limits[idx])\n+    return limits[idx];\n+\n+  limits[idx] = idx ? warn_vla_limit : warn_alloca_limit;\n+  if (limits[idx] != HOST_WIDE_INT_MAX)\n+    return limits[idx];\n+\n+  limits[idx] = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n+  return limits[idx];\n+}\n+\n+\n // NOTE: When we get better range info, this entire function becomes\n // irrelevant, as it should be possible to get range info for an SSA\n // name at any point in the program.\n@@ -309,11 +337,7 @@ alloca_call_type (gimple *stmt, bool is_vla, tree *invalid_casted_type)\n \n   // Adjust warn_alloca_max_size for VLAs, by taking the underlying\n   // type into account.\n-  unsigned HOST_WIDE_INT max_size;\n-  if (is_vla)\n-    max_size = warn_vla_limit;\n-  else\n-    max_size = warn_alloca_limit;\n+  unsigned HOST_WIDE_INT max_size = adjusted_warn_limit (is_vla);\n \n   // Check for the obviously bounded case.\n   if (TREE_CODE (len) == INTEGER_CST)\n@@ -510,6 +534,8 @@ pass_walloca::execute (function *fun)\n \t  struct alloca_type_and_limit t\n \t    = alloca_call_type (stmt, is_vla, &invalid_casted_type);\n \n+\t  unsigned HOST_WIDE_INT adjusted_alloca_limit\n+\t    = adjusted_warn_limit (false);\n \t  // Even if we think the alloca call is OK, make sure it's not in a\n \t  // loop, except for a VLA, since VLAs are guaranteed to be cleaned\n \t  // up when they go out of scope, including in a loop.\n@@ -519,8 +545,7 @@ pass_walloca::execute (function *fun)\n \t\t is less than the maximum valid object size.  */\n \t      const offset_int maxobjsize\n \t\t= wi::to_offset (max_object_size ());\n-\t      if ((unsigned HOST_WIDE_INT) warn_alloca_limit\n-\t\t  < maxobjsize.to_uhwi ())\n+\t      if (adjusted_alloca_limit < maxobjsize.to_uhwi ())\n \t\tt = alloca_type_and_limit (ALLOCA_IN_LOOP);\n \t    }\n \n@@ -544,7 +569,8 @@ pass_walloca::execute (function *fun)\n \t\t    print_decu (t.limit, buff);\n \t\t    inform (loc, G_(\"limit is %wu bytes, but argument \"\n \t\t\t\t    \"may be as large as %s\"),\n-\t\t\t    is_vla ? warn_vla_limit : warn_alloca_limit, buff);\n+\t\t\t    is_vla ? warn_vla_limit : adjusted_alloca_limit,\n+\t\t\t    buff);\n \t\t  }\n \t      }\n \t      break;\n@@ -559,7 +585,7 @@ pass_walloca::execute (function *fun)\n \t\t  {\n \t\t    print_decu (t.limit, buff);\n \t\t    inform (loc, G_(\"limit is %wu bytes, but argument is %s\"),\n-\t\t\t      is_vla ? warn_vla_limit : warn_alloca_limit,\n+\t\t\t      is_vla ? warn_vla_limit : adjusted_alloca_limit,\n \t\t\t      buff);\n \t\t  }\n \t      }"}, {"sha": "088f3606a0d038232054dc0f7b1baeca2d791cbc", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "patch": "@@ -760,14 +760,19 @@ layout_decl (tree decl, unsigned int known_align)\n     {\n       tree size = DECL_SIZE_UNIT (decl);\n \n-      if (size != 0 && TREE_CODE (size) == INTEGER_CST\n-\t  && compare_tree_int (size, warn_larger_than_size) > 0)\n+      if (size != 0 && TREE_CODE (size) == INTEGER_CST)\n \t{\n-\t  unsigned HOST_WIDE_INT uhwisize = tree_to_uhwi (size);\n-\n-\t  warning (OPT_Wlarger_than_, \"size of %q+D %wu bytes exceeds \"\n-\t\t   \"maximum object size %wu\",\n-\t\t   decl, uhwisize, warn_larger_than_size);\n+\t  /* -Wlarger-than= argument of HOST_WIDE_INT_MAX is treated\n+\t     as if PTRDIFF_MAX had been specified, with the value\n+\t     being that on the target rather than the host.  */\n+\t  unsigned HOST_WIDE_INT max_size = warn_larger_than_size;\n+\t  if (max_size == HOST_WIDE_INT_MAX)\n+\t    max_size = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\n+\t  if (compare_tree_int (size, max_size) > 0)\n+\t    warning (OPT_Wlarger_than_, \"size of %q+D %E bytes exceeds \"\n+\t\t     \"maximum object size %wu\",\n+\t\t     decl, size, max_size);\n \t}\n     }\n "}, {"sha": "2985ac91c62397b0bcdad9186efe4389257db4f7", "filename": "gcc/testsuite/g++.dg/Walloca1.C", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWalloca1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aaafa5e95df44eed3ad67ea65c9afda2dbdd493/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWalloca1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FWalloca1.C?ref=0aaafa5e95df44eed3ad67ea65c9afda2dbdd493", "patch": "@@ -1,7 +1,9 @@\n-/* PR middle-end/79809 */\n+/* PR middle-end/79809 - ICE in alloca_call_type, at gimple-ssa-warn-alloca.c */\n /* { dg-do compile } */\n /* { dg-options \"-Walloca-larger-than=4207115063 -Wvla-larger-than=1233877270 -O2\" } */\n /* { dg-require-effective-target alloca } */\n \n int a;\n-char *b = static_cast<char *>(__builtin_alloca (a)); // { dg-warning \"argument to .alloca. may be too large|unbounded use of\" }\n+char *b = static_cast<char *>(__builtin_alloca (a));\n+\n+// { dg-prune-output \"argument to .alloca.\" }"}]}