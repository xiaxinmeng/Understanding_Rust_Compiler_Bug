{"sha": "dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM0NzhhNWRkNDVmMTBhMWM5ZDQyMjMwYTNlYjZjNmFhMWU1MGExZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-29T16:08:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-29T16:08:59Z"}, "message": "* tree.c: Fix formatting.\n\nFrom-SVN: r36036", "tree": {"sha": "ccc3ddf2d935a42470ae715351f0f0accbb251a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccc3ddf2d935a42470ae715351f0f0accbb251a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d/comments", "author": null, "committer": null, "parents": [{"sha": "abf9af023a5199e8a2b0c0eb610ffb91fda2617f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf9af023a5199e8a2b0c0eb610ffb91fda2617f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abf9af023a5199e8a2b0c0eb610ffb91fda2617f"}], "stats": {"total": 205, "additions": 105, "deletions": 100}, "files": [{"sha": "a12a9432405ef32160c978a1664b1bb6018d947b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d", "patch": "@@ -1,5 +1,7 @@\n 2000-08-28  Kazu Hirata  <kazu@hxi.com>\n \n+\t* tree.c: Fix formatting.\n+\n \t* xcoffout.c: Fix formatting.\n \n 2000-08-28  Jason Merrill  <jason@redhat.com>"}, {"sha": "6e9648770aee9f25af6b3f3a257dddd1e9fed290", "filename": "gcc/tree.c", "status": "modified", "additions": 103, "deletions": 100, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=dc478a5dd45f10a1c9d42230a3eb6c6aa1e50a1d", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This file contains the low level primitives for operating on tree nodes,\n    including allocation, list operations, interning of identifiers,\n    construction of data type nodes and statement nodes,\n@@ -48,7 +47,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n-/* obstack.[ch] explicitly declined to prototype this. */\n+/* obstack.[ch] explicitly declined to prototype this.  */\n extern int _obstack_allocated_p PARAMS ((struct obstack *h, PTR obj));\n \n static void unsave_expr_now_r PARAMS ((tree));\n@@ -146,7 +145,7 @@ char *momentary_function_firstobj;\n int all_types_permanent;\n \n /* Stack of places to restore the momentary obstack back to.  */\n-   \n+\n struct momentary_level\n {\n   /* Pointer back to previous such level.  */\n@@ -211,8 +210,8 @@ typedef enum\n   all_kinds\n } tree_node_kind;\n \n-int tree_node_counts[(int)all_kinds];\n-int tree_node_sizes[(int)all_kinds];\n+int tree_node_counts[(int) all_kinds];\n+int tree_node_sizes[(int) all_kinds];\n int id_string_size = 0;\n \n static const char * const tree_node_kind_names[] = {\n@@ -259,7 +258,7 @@ struct type_hash\n   tree type;\n };\n \n-/* Initial size of the hash table (rounded to next prime). */\n+/* Initial size of the hash table (rounded to next prime).  */\n #define TYPE_HASH_INITIAL_SIZE 1000\n \n /* Now here is the hash table.  When recording a type, it is added to\n@@ -329,7 +328,7 @@ init_obstacks ()\n   ggc_add_tree_root (hash_table, sizeof hash_table / sizeof (tree));\n \n   /* Initialize the hash table of types.  */\n-  type_hash_table = htab_create (TYPE_HASH_INITIAL_SIZE, type_hash_hash, \n+  type_hash_table = htab_create (TYPE_HASH_INITIAL_SIZE, type_hash_hash,\n \t\t\t\t type_hash_eq, 0);\n   ggc_add_root (&type_hash_table, 1, sizeof type_hash_table, mark_type_hash);\n   ggc_add_tree_root (global_trees, TI_MAX);\n@@ -522,7 +521,7 @@ void\n push_obstacks_nochange ()\n {\n   struct obstack_stack *p;\n-  \n+\n   p = (struct obstack_stack *) obstack_alloc (&obstack_stack_obstack,\n \t\t\t\t\t      (sizeof (struct obstack_stack)));\n \n@@ -934,7 +933,7 @@ make_node (code)\n \t PARM_DECLs of top-level functions do not have this problem.  However,\n \t we allocate them where we put the FUNCTION_DECL for languages such as\n \t Ada that need to consult some flags in the PARM_DECLs of the function\n-\t when calling it. \n+\t when calling it.\n \n \t See comment in restore_tree_status for why we can't put this\n \t in function_obstack.  */\n@@ -1047,8 +1046,8 @@ make_node (code)\n   memset ((PTR) t, 0, length);\n \n #ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)kind]++;\n-  tree_node_sizes[(int)kind] += length;\n+  tree_node_counts[(int) kind]++;\n+  tree_node_sizes[(int) kind] += length;\n #endif\n \n   TREE_SET_CODE (t, code);\n@@ -1067,7 +1066,7 @@ make_node (code)\n       DECL_USER_ALIGN (t) = 0;\n       DECL_IN_SYSTEM_HEADER (t) = in_system_header;\n       DECL_SOURCE_LINE (t) = lineno;\n-      DECL_SOURCE_FILE (t) = \n+      DECL_SOURCE_FILE (t) =\n \t(input_filename) ? input_filename : built_in_filename;\n       DECL_UID (t) = next_decl_uid++;\n       /* Note that we have not yet computed the alias set for this\n@@ -1109,7 +1108,7 @@ make_node (code)\n \t     operands are.  */\n \t  TREE_SIDE_EFFECTS (t) = 1;\n \t  break;\n-\t  \n+\n \tdefault:\n \t  break;\n \t}\n@@ -1127,7 +1126,7 @@ tree (*make_lang_type_fn) PARAMS ((enum tree_code)) = make_node;\n /* Return a new type (with the indicated CODE), doing whatever\n    language-specific processing is required.  */\n \n-tree \n+tree\n make_lang_type (code)\n      enum tree_code code;\n {\n@@ -1278,15 +1277,16 @@ get_identifier (text)\n \n   hi &= (1 << HASHBITS) - 1;\n   hi %= MAX_HASH_TABLE;\n-  \n-  /* Search table for identifier */\n+\n+  /* Search table for identifier.  */\n   for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n     if (IDENTIFIER_LENGTH (idp) == len\n \t&& IDENTIFIER_POINTER (idp)[0] == text[0]\n \t&& !bcmp (IDENTIFIER_POINTER (idp), text, len))\n-      return idp;\t\t/* <-- return if found */\n+      /* Return if found.  */\n+      return idp;\n \n-  /* Not found; optionally warn about a similar identifier */\n+  /* Not found; optionally warn about a similar identifier.  */\n   if (warn_id_clash && do_identifier_warnings && len >= id_clash_len)\n     for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n       if (!strncmp (IDENTIFIER_POINTER (idp), text, id_clash_len))\n@@ -1344,8 +1344,8 @@ maybe_get_identifier (text)\n \n   hi &= (1 << HASHBITS) - 1;\n   hi %= MAX_HASH_TABLE;\n-  \n-  /* Search table for identifier */\n+\n+  /* Search table for identifier.  */\n   for (idp = hash_table[hi]; idp; idp = TREE_CHAIN (idp))\n     if (IDENTIFIER_LENGTH (idp) == len\n \t&& IDENTIFIER_POINTER (idp)[0] == text[0]\n@@ -1379,7 +1379,7 @@ set_identifier_size (size)\n \f\n /* Return a newly constructed INTEGER_CST node whose constant value\n    is specified by the two ints LOW and HI.\n-   The TREE_TYPE is set to `int'. \n+   The TREE_TYPE is set to `int'.\n \n    This function should be used via the `build_int_2' macro.  */\n \n@@ -1448,11 +1448,11 @@ real_value_from_int_cst (type, i)\n     {\n       REAL_VALUE_TYPE e;\n \n-      d = (double) (~ TREE_INT_CST_HIGH (i));\n+      d = (double) (~TREE_INT_CST_HIGH (i));\n       e = ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n \t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n       d *= e;\n-      e = (double) (~ TREE_INT_CST_LOW (i));\n+      e = (double) (~TREE_INT_CST_LOW (i));\n       d += e;\n       d = (- d - 1.0);\n     }\n@@ -1462,7 +1462,7 @@ real_value_from_int_cst (type, i)\n \n       d = (double) (unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (i);\n       e = ((double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2))\n-\t    * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n+\t   * (double) ((HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)));\n       d *= e;\n       e = (double) TREE_INT_CST_LOW (i);\n       d += e;\n@@ -1475,20 +1475,20 @@ real_value_from_int_cst (type, i)\n \n struct brfic_args\n {\n-  tree type;\t\t\t/* Input: type to conver to. */\n-  tree i;\t\t\t/* Input: operand to convert */\n-  REAL_VALUE_TYPE d;\t\t/* Output: floating point value. */\n+  tree type;\t\t\t/* Input: type to conver to.  */\n+  tree i;\t\t\t/* Input: operand to convert.  */\n+  REAL_VALUE_TYPE d;\t\t/* Output: floating point value.  */\n };\n \n /* Convert an integer to a floating point value while protected by a floating\n    point exception handler.  */\n \n static void\n build_real_from_int_cst_1 (data)\n-  PTR data;\n+     PTR data;\n {\n   struct brfic_args *args = (struct brfic_args *) data;\n-  \n+\n #ifdef REAL_ARITHMETIC\n   args->d = real_value_from_int_cst (args->type, args->i);\n #else\n@@ -1529,7 +1529,7 @@ build_real_from_int_cst (type, i)\n       d = dconst0;\n       overflow = 1;\n     }\n-  \n+\n   /* Check for valid float value for this type on this target machine.  */\n \n #ifdef CHECK_FLOAT_VALUE\n@@ -1675,7 +1675,7 @@ integer_all_onesp (expr)\n \n   uns = TREE_UNSIGNED (TREE_TYPE (expr));\n   if (!uns)\n-    return (TREE_INT_CST_LOW (expr) == ~ (unsigned HOST_WIDE_INT) 0\n+    return (TREE_INT_CST_LOW (expr) == ~(unsigned HOST_WIDE_INT) 0\n \t    && TREE_INT_CST_HIGH (expr) == -1);\n \n   /* Note that using TYPE_PRECISION here is wrong.  We care about the\n@@ -1698,7 +1698,7 @@ integer_all_onesp (expr)\n       else\n \thigh_value = ((HOST_WIDE_INT) 1 << shift_amount) - 1;\n \n-      return (TREE_INT_CST_LOW (expr) == ~ (unsigned HOST_WIDE_INT) 0\n+      return (TREE_INT_CST_LOW (expr) == ~(unsigned HOST_WIDE_INT) 0\n \t      && TREE_INT_CST_HIGH (expr) == high_value);\n     }\n   else\n@@ -1787,7 +1787,7 @@ tree_log2 (expr)\n     }\n \n   return (high != 0 ? HOST_BITS_PER_WIDE_INT + exact_log2 (high)\n-\t  :  exact_log2 (low));\n+\t  : exact_log2 (low));\n }\n \n /* Similar, but return the largest integer Y such that 2 ** Y is less\n@@ -1879,7 +1879,7 @@ real_twop (expr)\n }\n \n /* Nonzero if EXP is a constant or a cast of a constant.  */\n- \n+\n int\n really_constant_p (exp)\n      tree exp;\n@@ -2050,7 +2050,8 @@ chainon (op1, op2)\n #endif\n       return op1;\n     }\n-  else return op2;\n+  else\n+    return op2;\n }\n \n /* Return the last node in a chain of nodes (chained through TREE_CHAIN).  */\n@@ -2516,7 +2517,7 @@ save_expr (expr)\n   /* If the tree evaluates to a constant, then we don't want to hide that\n      fact (i.e. this allows further folding, and direct checks for constants).\n      However, a read-only object that has side effects cannot be bypassed.\n-     Since it is no problem to reevaluate literals, we just return the \n+     Since it is no problem to reevaluate literals, we just return the\n      literal node.  */\n \n   if (TREE_CONSTANT (t) || (TREE_READONLY (t) && ! TREE_SIDE_EFFECTS (t))\n@@ -2614,7 +2615,7 @@ unsave_expr_1 (expr)\n       TREE_OPERAND (expr, 1) = TREE_OPERAND (expr, 3);\n       TREE_OPERAND (expr, 3) = NULL_TREE;\n       break;\n-      \n+\n     case RTL_EXPR:\n       /* I don't yet know how to emit a sequence multiple times.  */\n       if (RTL_EXPR_SEQUENCE (expr) != 0)\n@@ -2671,7 +2672,7 @@ unsave_expr_now_r (expr)\n     case '1':  /* a unary arithmetic expression */\n       {\n \tint i;\n-\t\n+\n \tfor (i = first_rtl_op (code) - 1; i >= 0; i--)\n \t  unsave_expr_now_r (TREE_OPERAND (expr, i));\n       }\n@@ -2699,7 +2700,7 @@ unsave_expr_now (expr)\n \n /* Return 0 if it is safe to evaluate EXPR multiple times,\n    return 1 if it is safe if EXPR is unsaved afterward, or\n-   return 2 if it is completely unsafe. \n+   return 2 if it is completely unsafe.\n \n    This assumes that CALL_EXPRs and TARGET_EXPRs are never replicated in\n    an expression tree, so that it safe to unsave them and the surrounding\n@@ -2710,7 +2711,7 @@ unsave_expr_now (expr)\n    safe to unsave a SAVE_EXPR if you know that all occurrences appear\n    below the UNSAVE_EXPR.\n \n-   RTL_EXPRs consume their rtl during evaluation.  It is therefore \n+   RTL_EXPRs consume their rtl during evaluation.  It is therefore\n    never possible to unsave them.  */\n \n int\n@@ -2817,14 +2818,14 @@ contains_placeholder_p (exp)\n \t\t|| (TREE_CHAIN (exp) != 0\n \t\t    && contains_placeholder_p (TREE_CHAIN (exp))));\n       break;\n-\t\t\t\t\t\n+\n     case '1':\n     case '2':  case '<':\n     case 'e':\n       switch (code)\n \t{\n \tcase COMPOUND_EXPR:\n-\t  /* Ignoring the first operand isn't quite right, but works best. */\n+\t  /* Ignoring the first operand isn't quite right, but works best.  */\n \t  return contains_placeholder_p (TREE_OPERAND (exp, 1));\n \n \tcase RTL_EXPR:\n@@ -2982,7 +2983,7 @@ substitute_in_expr (exp, f, r)\n \t  op0 = substitute_in_expr (TREE_OPERAND (exp, 0), f, r);\n \t  if (op0 == TREE_OPERAND (exp, 0))\n \t    return exp;\n-\t  \n+\n \t  new = fold (build1 (code, TREE_TYPE (exp), op0));\n \t  break;\n \n@@ -3051,7 +3052,7 @@ substitute_in_expr (exp, f, r)\n \t      && TREE_OPERAND (exp, 1) == f)\n \t    return r;\n \n-\t  /* If this expression hasn't been completed let, leave it \n+\t  /* If this expression hasn't been completed let, leave it\n \t     alone.  */\n \t  if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n \t      && TREE_TYPE (inner) == 0)\n@@ -3089,7 +3090,7 @@ substitute_in_expr (exp, f, r)\n \t  abort ();\n \t}\n       break;\n-      \n+\n     default:\n       abort ();\n     }\n@@ -3168,7 +3169,6 @@ stabilize_reference (ref)\n \t\t\t\t\t  ref)));\n       break;\n \n-\n       /* If arg isn't a kind of lvalue we recognize, make no change.\n \t Caller should recognize the error for an invalid lvalue.  */\n     default:\n@@ -3236,7 +3236,7 @@ stabilize_reference_1 (e)\n       /* Constants need no processing.  In fact, we should never reach\n \t here.  */\n       return e;\n-      \n+\n     case '2':\n       /* Division is slow and tends to be compiled with jumps,\n \t especially the division by powers of 2 that is often\n@@ -3259,7 +3259,7 @@ stabilize_reference_1 (e)\n     default:\n       abort ();\n     }\n-  \n+\n   TREE_TYPE (result) = TREE_TYPE (e);\n   TREE_READONLY (result) = TREE_READONLY (e);\n   TREE_SIDE_EFFECTS (result) = TREE_SIDE_EFFECTS (e);\n@@ -3388,8 +3388,8 @@ build1 (code, type, node)\n   memset ((PTR) t, 0, sizeof (struct tree_common));\n \n #ifdef GATHER_STATISTICS\n-  tree_node_counts[(int)kind]++;\n-  tree_node_sizes[(int)kind] += length;\n+  tree_node_counts[(int) kind]++;\n+  tree_node_sizes[(int) kind] += length;\n #endif\n \n   TREE_SET_CODE (t, code);\n@@ -3415,7 +3415,7 @@ build1 (code, type, node)\n \t operands are.  */\n       TREE_SIDE_EFFECTS (t) = 1;\n       break;\n-\t  \n+\n     default:\n       break;\n     }\n@@ -3627,7 +3627,7 @@ build_type_attribute_variant (ttype, attribute)\n \t\t  + attribute_hash_list (attribute));\n \n       switch (TREE_CODE (ntype))\n-        {\n+\t{\n \tcase FUNCTION_TYPE:\n \t  hashcode += TYPE_HASH (TYPE_ARG_TYPES (ntype));\n \t  break;\n@@ -3642,7 +3642,7 @@ build_type_attribute_variant (ttype, attribute)\n \t  break;\n \tdefault:\n \t  break;\n-        }\n+\t}\n \n       ntype = type_hash_canon (hashcode, ntype);\n       ttype = build_qualified_type (ntype, TYPE_QUALS (ttype));\n@@ -3700,7 +3700,8 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \n #ifdef VALID_MACHINE_TYPE_ATTRIBUTE\n   if (validated)\n-    /* Don't apply the attribute to both the decl and the type.  */;\n+    /* Don't apply the attribute to both the decl and the type.  */\n+    ;\n   else if (VALID_MACHINE_TYPE_ATTRIBUTE (type, type_attr_list, attr_name,\n \t\t\t\t\t attr_args))\n     {\n@@ -3718,7 +3719,7 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n       else\n \t{\n \t  /* If this is part of a declaration, create a type variant,\n-\t     otherwise, this is part of a type definition, so add it \n+\t     otherwise, this is part of a type definition, so add it\n \t     to the base type.  */\n \t  type_attr_list = tree_cons (attr_name, attr_args, type_attr_list);\n \t  if (decl != 0)\n@@ -3858,27 +3859,27 @@ merge_attributes (a1, a2)\n   /* One that completely contains the other?  Take it.  */\n \n   else if (a2 != 0 && ! attribute_list_contained (a1, a2))\n-  {\n-    if (attribute_list_contained (a2, a1))\n-      attributes = a2;\n-    else\n-      {\n-\t/* Pick the longest list, and hang on the other list.  */\n-\t/* ??? For the moment we punt on the issue of attrs with args.  */\n-\n-\tif (list_length (a1) < list_length (a2))\n-\t  attributes = a2, a2 = a1;\n-\n-\tfor (; a2 != 0; a2 = TREE_CHAIN (a2))\n-\t  if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\tattributes) == NULL_TREE)\n-\t    {\n-\t      a1 = copy_node (a2);\n-\t      TREE_CHAIN (a1) = attributes;\n-\t      attributes = a1;\n-\t    }\n-      }\n-  }\n+    {\n+      if (attribute_list_contained (a2, a1))\n+\tattributes = a2;\n+      else\n+\t{\n+\t  /* Pick the longest list, and hang on the other list.  */\n+\t  /* ??? For the moment we punt on the issue of attrs with args.  */\n+\n+\t  if (list_length (a1) < list_length (a2))\n+\t    attributes = a2, a2 = a1;\n+\n+\t  for (; a2 != 0; a2 = TREE_CHAIN (a2))\n+\t    if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n+\t\t\t\t  attributes) == NULL_TREE)\n+\t      {\n+\t\ta1 = copy_node (a2);\n+\t\tTREE_CHAIN (a1) = attributes;\n+\t\tattributes = a1;\n+\t      }\n+\t}\n+    }\n   return attributes;\n }\n \n@@ -3918,7 +3919,7 @@ merge_machine_decl_attributes (olddecl, newdecl)\n static void\n set_type_quals (type, type_quals)\n      tree type;\n-     int  type_quals;\n+     int type_quals;\n {\n   TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;\n   TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;\n@@ -3938,7 +3939,7 @@ build_qualified_type (type, type_quals)\n      int type_quals;\n {\n   register tree t;\n-  \n+\n   /* Search the chain of variants to see if there is already one there just\n      like the one we need to have.  If so, use that existing one.  We must\n      preserve the TYPE_NAME, since there is code that depends on this.  */\n@@ -4037,7 +4038,7 @@ static unsigned int\n type_hash_hash (item)\n      const void *item;\n {\n-  return ((const struct type_hash*)item)->hash;\n+  return ((const struct type_hash *) item)->hash;\n }\n \n /* Look in the type hash table for a type isomorphic to TYPE.\n@@ -4051,7 +4052,7 @@ type_hash_lookup (hashcode, type)\n   struct type_hash *h, in;\n \n   /* The TYPE_ALIGN field of a type is set by layout_type(), so we\n-     must call that routine before comparing TYPE_ALIGNs. */\n+     must call that routine before comparing TYPE_ALIGNs.  */\n   layout_type (type);\n \n   in.hash = hashcode;\n@@ -4078,7 +4079,7 @@ type_hash_add (hashcode, type)\n   h->hash = hashcode;\n   h->type = type;\n   loc = htab_find_slot_with_hash (type_hash_table, h, hashcode, INSERT);\n-  *(struct type_hash**) loc = h;\n+  *(struct type_hash **) loc = h;\n }\n \n /* Given TYPE, and HASHCODE its hash code, return the canonical\n@@ -4132,7 +4133,7 @@ mark_hash_entry (entry, param)\n      void **entry;\n      void *param ATTRIBUTE_UNUSED;\n {\n-  struct type_hash *p = *(struct type_hash **)entry;\n+  struct type_hash *p = *(struct type_hash **) entry;\n \n   ggc_mark_tree (p->type);\n \n@@ -4204,7 +4205,7 @@ attribute_list_contained (l1, l2)\n \n   /* First check the obvious, maybe the lists are identical.  */\n   if (l1 == l2)\n-     return 1;\n+    return 1;\n \n   /* Maybe the lists are similar.  */\n   for (t1 = l1, t2 = l2;\n@@ -4323,7 +4324,7 @@ tree_low_cst (t, pos)\n     return TREE_INT_CST_LOW (t);\n   else\n     abort ();\n-}  \n+}\n \n /* Return the most significant bit of the integer constant T.  */\n \n@@ -4341,7 +4342,7 @@ tree_int_cst_msb (t)\n   rshift_double (TREE_INT_CST_LOW (t), TREE_INT_CST_HIGH (t), prec,\n \t\t 2 * HOST_BITS_PER_WIDE_INT, &l, &h, 0);\n   return (l & 1) == 1;\n-  }\n+}\n \n /* Return an indication of the sign of the integer constant T.\n    The return value is -1 if T < 0, 0 if T == 0, and 1 if T > 0.\n@@ -4486,7 +4487,7 @@ simple_cst_equal (t1, t2)\n     case CONST_DECL:\n     case FUNCTION_DECL:\n       return 0;\n-      \n+\n     default:\n       break;\n     }\n@@ -4942,7 +4943,7 @@ build_complex_type (component_type)\n    OP must have integer, real or enumeral type.  Pointers are not allowed!\n \n    There are some cases where the obvious value we could return\n-   would regenerate to OP if converted to OP's type, \n+   would regenerate to OP if converted to OP's type,\n    but would not extend like OP to wider types.\n    If FOR_TYPE indicates such extension is contemplated, we eschew such values.\n    For example, if OP is (unsigned short)(signed char)-1,\n@@ -5191,7 +5192,7 @@ decl_function_context (decl)\n     {\n       if (TREE_CODE (context) == BLOCK)\n \tcontext = BLOCK_SUPERCONTEXT (context);\n-      else \n+      else\n \tcontext = get_containing_scope (context);\n     }\n \n@@ -5230,7 +5231,7 @@ decl_type_context (decl)\n }\n \n /* CALL is a CALL_EXPR.  Return the declaration for the function\n-   called, or NULL_TREE if the called function cannot be \n+   called, or NULL_TREE if the called function cannot be\n    determined.  */\n \n tree\n@@ -5394,15 +5395,15 @@ clean_symbol_name (p)\n      char *p;\n {\n   for (; *p; p++)\n-    if (! ( ISDIGIT(*p)\n+    if (! (ISDIGIT(*p)\n #ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n \t    || *p == '$'\n #endif\n #ifndef NO_DOT_IN_LABEL\t\t/* this for `.'; unlikely, but...  */\n \t    || *p == '.'\n #endif\n-\t    || ISUPPER(*p)\n-\t    || ISLOWER(*p)))\n+\t    || ISUPPER (*p)\n+\t    || ISLOWER (*p)))\n       *p = '_';\n }\n   \n@@ -5443,7 +5444,7 @@ get_file_function_name_long (type)\n   buf = (char *) alloca (sizeof (FILE_FUNCTION_FORMAT) + strlen (p)\n \t\t\t + strlen (type));\n \n-  /* Set up the name of the file-level functions we may need. \n+  /* Set up the name of the file-level functions we may need.\n      Use a global object (which is already required to be unique over\n      the program) rather than the file name (which imposes extra\n      constraints).  */\n@@ -5492,7 +5493,7 @@ get_set_constructor_bits (init, buffer, bit_size)\n   for (i = 0; i < bit_size; i++)\n     buffer[i] = 0;\n \n-  for (vals = TREE_OPERAND (init, 1); \n+  for (vals = TREE_OPERAND (init, 1);\n        vals != NULL_TREE; vals = TREE_CHAIN (vals))\n     {\n       if (TREE_CODE (TREE_VALUE (vals)) != INTEGER_CST\n@@ -5509,9 +5510,9 @@ get_set_constructor_bits (init, buffer, bit_size)\n \t    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;\n \n \t  if (lo_index < 0 || lo_index >= bit_size\n-\t    || hi_index < 0 || hi_index >= bit_size)\n+\t      || hi_index < 0 || hi_index >= bit_size)\n \t    abort ();\n-\t  for ( ; lo_index <= hi_index; lo_index++)\n+\t  for (; lo_index <= hi_index; lo_index++)\n \t    buffer[lo_index] = 1;\n \t}\n       else\n@@ -5546,7 +5547,7 @@ get_set_constructor_bytes (init, buffer, wd_size)\n   int bit_size = wd_size * set_word_size;\n   int bit_pos = 0;\n   unsigned char *bytep = buffer;\n-  char *bit_buffer = (char *) alloca(bit_size);\n+  char *bit_buffer = (char *) alloca (bit_size);\n   tree non_const_bits = get_set_constructor_bits (init, bit_buffer, bit_size);\n \n   for (i = 0; i < wd_size; i++)\n@@ -5571,6 +5572,7 @@ get_set_constructor_bytes (init, buffer, wd_size)\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n /* Complain that the tree code of NODE does not match the expected CODE.\n    FILE, LINE, and FUNCTION are of the caller.  */\n+\n void\n tree_check_failed (node, code, file, line, function)\n      const tree node;\n@@ -5586,6 +5588,7 @@ tree_check_failed (node, code, file, line, function)\n \n /* Similar to above, except that we check for a class of tree\n    code, given in CL.  */\n+\n void\n tree_class_check_failed (node, cl, file, line, function)\n      const tree node;\n@@ -5601,10 +5604,10 @@ tree_class_check_failed (node, cl, file, line, function)\n }\n \n #endif /* ENABLE_TREE_CHECKING */\n-\n \f\n /* For a new vector type node T, build the information necessary for\n    debuggint output.  */\n+\n static void\n finish_vector_type (t)\n      tree t;\n@@ -5664,7 +5667,7 @@ finish_vector_type (t)\n /* Create nodes for all integer types (and error_mark_node) using the sizes\n    of C datatypes.  The caller should call set_sizetype soon after calling\n    this function to select one of the types as sizetype.  */\n-   \n+\n void\n build_common_tree_nodes (signed_char)\n      int signed_char;\n@@ -5776,7 +5779,7 @@ build_common_tree_nodes_2 (short_double)\n   layout_type (complex_long_double_type_node);\n \n #ifdef BUILD_VA_LIST_TYPE\n-  BUILD_VA_LIST_TYPE(va_list_type_node);\n+  BUILD_VA_LIST_TYPE (va_list_type_node);\n #else\n   va_list_type_node = ptr_type_node;\n #endif"}]}