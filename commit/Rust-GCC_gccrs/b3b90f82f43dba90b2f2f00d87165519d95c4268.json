{"sha": "b3b90f82f43dba90b2f2f00d87165519d95c4268", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiOTBmODJmNDNkYmE5MGIyZjJmMDBkODcxNjU1MTlkOTVjNDI2OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2000-12-26T07:18:16Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-12-26T07:18:16Z"}, "message": "MenuItem.java (paramString): Now protected.\n\n\t* java/awt/MenuItem.java (paramString): Now protected.\n\n\t* java/awt/MenuShortcut.java: Implements Serializable.\n\n\t* java/awt/MenuBar.java: Rewrote from scratch.\n\n\t* java/awt/MenuComponent.java (removeNotify): Wrote.\n\tImplements Serializable.\n\n\t* java/awt/GridBagConstraints.java (GridBagConstraints): New\n\tconstructor.\n\n\t* java/awt/CheckboxMenuItem.java: Wrote.\n\nFrom-SVN: r38488", "tree": {"sha": "c25b24dcc12943d0d0c10a6650871a857a409bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c25b24dcc12943d0d0c10a6650871a857a409bd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3b90f82f43dba90b2f2f00d87165519d95c4268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b90f82f43dba90b2f2f00d87165519d95c4268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b90f82f43dba90b2f2f00d87165519d95c4268", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b90f82f43dba90b2f2f00d87165519d95c4268/comments", "author": null, "committer": null, "parents": [{"sha": "5472d1951a2f96bf92d004dec143cd21a4da3965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5472d1951a2f96bf92d004dec143cd21a4da3965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5472d1951a2f96bf92d004dec143cd21a4da3965"}], "stats": {"total": 452, "additions": 425, "deletions": 27}, "files": [{"sha": "ac7344f051d68fb9fd1222726e277a0f77395e76", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b3b90f82f43dba90b2f2f00d87165519d95c4268", "patch": "@@ -1,3 +1,19 @@\n+2000-12-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/awt/MenuItem.java (paramString): Now protected.\n+\n+\t* java/awt/MenuShortcut.java: Implements Serializable.\n+\n+\t* java/awt/MenuBar.java: Rewrote from scratch.\n+\n+\t* java/awt/MenuComponent.java (removeNotify): Wrote.\n+\tImplements Serializable.\n+\n+\t* java/awt/GridBagConstraints.java (GridBagConstraints): New\n+\tconstructor.\n+\n+\t* java/awt/CheckboxMenuItem.java: Wrote.\n+\n 2000-12-25  Tom Tromey  <tromey@redhat.com>\n \n \t* java/awt/MenuContainer.java: Fixed typo."}, {"sha": "83941a782643c4ec7990fd96c40e5f746fb78420", "filename": "libjava/java/awt/CheckboxMenuItem.java", "status": "modified", "additions": 121, "deletions": 3, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FCheckboxMenuItem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FCheckboxMenuItem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FCheckboxMenuItem.java?ref=b3b90f82f43dba90b2f2f00d87165519d95c4268", "patch": "@@ -7,9 +7,127 @@\n details.  */\n \n package java.awt;\n+import java.awt.peer.CheckboxMenuItemPeer;\n+import java.awt.event.ItemListener;\n+import java.awt.event.ItemEvent;\n \n-/* A very incomplete placeholder. */\n-\n-public class CheckboxMenuItem extends MenuItem\n+/** This implements a menu item which keeps track of a boolean state.\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @date December 25, 2000\n+ */\n+public class CheckboxMenuItem extends MenuItem implements ItemSelectable\n {\n+  /** Create a new CheckboxMenuItem.\n+   * @param label The checkbox label.  A null value is the same as \"\";\n+   *              null is the default.\n+   * @param state The initial check state; defaults to false.\n+   */\n+  public CheckboxMenuItem ()\n+  {\n+    this (null, false);\n+  }\n+\n+  public CheckboxMenuItem (String label)\n+  {\n+    this (label, false);\n+  }\n+\n+  public CheckboxMenuItem (String label, boolean state)\n+  {\n+    this.label = label;\n+    this.state = state;\n+  }\n+\n+  /** Add a listener for item events.\n+   * @param listener The listener to add.\n+   */\n+  public synchronized void addItemListener (ItemListener listener)\n+  {\n+    listeners = AWTEventMulticaster.add (listeners, listener);\n+  }\n+\n+  /** This creates the component's peer.  */\n+  public void addNotify ()\n+  {\n+    if (peer != null)\n+      {\n+\t// This choice of toolkit seems unsatisfying, but I'm not sure\n+\t// what else to do.\n+\tpeer = Toolkit.getDefaultToolkit ().createCheckboxMenuItem (this);\n+      }\n+  }\n+\n+  /** Returns this checkbox's label if this checkbox is selected.  */\n+  public Object[] getSelectedObjects ()\n+  {\n+    Object[] r;\n+    if (state)\n+      {\n+\tr = new Object[1];\n+\tr[0] = label;\n+      }\n+    else\n+      r = new Object[0];\n+    return r;\n+  }\n+\n+  /** Returns the current state of this checkbox.  */\n+  public boolean getState ()\n+  {\n+    return state;\n+  }\n+\n+  /** Generates a String representation of this Checkbox's state.  */\n+  public String paramString ()\n+  {\n+    return (\"[\" + getClass ().getName ()\n+\t    + \"state=\" + state + \",\"\n+\t    + \"label=\" + label + \"]\");\n+  }\n+\n+  /** Process an event for this Checkbox.\n+   * @param event The event the process.\n+   */\n+  protected void processEvent (AWTEvent event) \n+  {\n+    if (event instanceof ItemEvent)\n+      processItemEvent ((ItemEvent) event);\n+    else\n+      super.processEvent (event);\n+  }\n+\n+  /** Process an item event for this Checkbox.\n+   * @param event The ItemEvent to process\n+   */\n+  protected void processItemEvent (ItemEvent event)\n+  {\n+    if (listeners != null)\n+      listeners.itemStateChanged (event);\n+  }\n+\n+  /** Remove an item listener.\n+   * @param listener Item listener to remove.\n+   */\n+  public synchronized void removeItemListener (ItemListener listener)\n+  {\n+    listeners = AWTEventMulticaster.remove (listeners, listener);\n+  }\n+\n+  /** Set the checkbox's state.\n+   * @param state The new state.\n+   */\n+  public void setState (boolean state)\n+  {\n+    this.state = state;\n+    if (peer != null)\n+      {\n+\tCheckboxMenuItemPeer cp = (CheckboxMenuItemPeer) peer;\n+\tcp.setState (state);\n+      }\n+  }\n+\n+  // Private state.\n+  String label;\n+  boolean state;\n+  ItemListener listeners;\n }"}, {"sha": "2c34cc9b42f7fa44a85b8653915eec76d44f153a", "filename": "libjava/java/awt/GridBagConstraints.java", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FGridBagConstraints.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FGridBagConstraints.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FGridBagConstraints.java?ref=b3b90f82f43dba90b2f2f00d87165519d95c4268", "patch": "@@ -86,4 +86,25 @@ public GridBagConstraints ()\n     this.weightx = 0;\n     this.weighty = 0;\n   }\n+\n+  /** Create a new GridBagConstraints object with the indicated\n+   * parameters.  */\n+  public GridBagConstraints (int gridx, int gridy,\n+\t\t\t     int gridwidth, int gridheight,\n+\t\t\t     double weightx, double weighty,\n+\t\t\t     int anchor, int fill,\n+\t\t\t     Insets insets, int ipadx, int ipady)\n+  {\n+    this.anchor = anchor;\n+    this.fill = fill;\n+    this.gridx = gridx;\n+    this.gridy = gridy;\n+    this.gridwidth = gridwidth;\n+    this.gridheight = gridheight;\n+    this.ipadx = ipadx;\n+    this.ipady = ipady;\n+    this.insets = insets;\n+    this.weightx = weightx;\n+    this.weighty = weighty;\n+  }\n }"}, {"sha": "6e25bc9ca4675ced1872c0d52e33cf2358ddd9ad", "filename": "libjava/java/awt/MenuBar.java", "status": "modified", "additions": 262, "deletions": 21, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FMenuBar.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FMenuBar.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMenuBar.java?ref=b3b90f82f43dba90b2f2f00d87165519d95c4268", "patch": "@@ -8,40 +8,281 @@\n \n package java.awt;\n \n-/* A very incomplete placeholder. */\n+import java.awt.peer.MenuBarPeer;\n+import java.util.Vector;\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n \n-public class MenuBar extends MenuComponent  implements MenuContainer\n+/** This class implements a MenuBar, such as might appear across the\n+ * top of a window.\n+ * @author Tom Tromey <tromey@redhat.com>\n+ * @date December 25, 2000\n+ */\n+public class MenuBar extends MenuComponent implements MenuContainer\n {\n-  Menu[] menus;\n-  int count;\n+  /** Create a new MenuBar.  */\n+  public MenuBar ()\n+  {\n+    menus = new Vector ();\n+  }\n+\n+  /** Add a menu to this MenuBar.  If the menu has already has a\n+   * parent, it is first removed from its old parent before being\n+   * added.\n+   * @param menu The menu to add.\n+   * @returns menu\n+   */\n+  public synchronized Menu add (Menu menu)\n+  {\n+    if (menu.parent != null)\n+      menu.parent.remove (menu);\n+\n+    menu.parent = this;\n+    menus.add (menu);\n+\n+    if (peer != null)\n+      {\n+\tMenuBarPeer mp = (MenuBarPeer) peer;\n+\tmp.add (menu);\n+      }\n+\n+    return menu;\n+  }\n+\n+  /** This creates the component's peer.  */\n+  public void addNotify ()\n+  {\n+    if (peer != null)\n+      {\n+\t// This choice of toolkit seems unsatisfying, but I'm not sure\n+\t// what else to do.\n+\tpeer = Toolkit.getDefaultToolkit ().createMenuBar (this);\n+      }\n+  }\n+\n+  /** @deprecated  Use getMenuCount() instead.  */\n+  public int countMenus ()\n+  {\n+    return getMenuCount ();\n+  }\n+\n+  /** Delete a keyboard shortcut.\n+   * @param shortcut The short cut which should be deleted from all\n+   *                 menus on this MenuBar.\n+   */\n+  public void deleteShortcut (MenuShortcut shortcut)\n+  {\n+    MenuItem it;\n+    // This is a slow implementation, but it probably doesn't matter.\n+    while ((it = getShortcutMenuItem (shortcut)) != null)\n+      it.deleteShortcut ();\n+  }\n+\n+  /** Returns the current Help menu.  */\n+  public Menu getHelpMenu ()\n+  {\n+    return help_menu;\n+  }\n \n-  public synchronized Menu add (Menu m)\n+  /** Returns a menu from this object.\n+   * @param index Index of menu to return.\n+   */\n+  public Menu getMenu (int index)\n   {\n-    if (menus == null)\n-      menus = new Menu[1];\n-    else if (count == menus.length)\n+    return (Menu) menus.get (index);\n+  }\n+\n+  /** Returns the number of menus on this MenuBar.  */\n+  public int getMenuCount ()\n+  {\n+    return menus.size ();\n+  }\n+\n+  /** Returns the menu item on this MenuBar with the specified\n+   * shortcut.\n+   * @param shortcut Shortcut to look for\n+   */\n+  public MenuItem getShortcutMenuItem (MenuShortcut shortcut)\n+  {\n+    Enumeration m = new MenuEnumeration (this);\n+    while (m.hasMoreElements ())\n       {\n-\tMenu[] newMenus = new Menu[2 * count];\n-\tSystem.arraycopy(menus, 0, newMenus, 0, count);\n+\tMenuItem item = (MenuItem) m.nextElement ();\n+\tif (item.getShortcut () == shortcut)\n+\t  return item;\n       }\n-    menus[count++] = m;\n-    return m;\n+    return null;\n   }\n \n-  public void remove (MenuComponent comp)\n+  /** Remove a menu from the menu bar.  If the menu is specified by\n+   * component (and not index), and does not exist on the menu, then\n+   * the method does nothing.  If the removed menu has a peer, it is\n+   * destroyed.\n+   * @param menu The menu to remove\n+   * @param index The index of the menu to remove\n+   */\n+  public synchronized void remove (MenuComponent menu)\n   {\n-    for (int i = count; --i >= 0; )\n+    int s = menus.size ();\n+    for (int i = 0; i < s; ++i)\n       {\n-\tif (menus[i] == comp)\n+\tif (menus.get (i) == menu)\n \t  {\n-\t    System.arraycopy(menus, i, menus, i+1, count-i-1);\n-\t    count--;\n-\t    // FIXME:  destroy peer\n-\t    return;\n+\t    remove (i);\n+\t    break;\n \t  }\n       }\n   }\n \n-  public Font getFont() { return null; } // FIXME\n-  public boolean postEvent(Event evt) { return false; } // FIXME\n+  public synchronized void remove (int index)\n+  {\n+    Menu m = (Menu) menus.get (index);\n+    menus.remove (index);\n+    m.removeNotify ();\n+    m.parent = null;\n+\n+    if (peer != null)\n+      {\n+\tMenuBarPeer mp = (MenuBarPeer) peer;\n+\tmp.remove (index);\n+      }\n+  }\n+\n+  /** Set the Help menu for this MenuBar.  If a Help menu already\n+   * exists, it is first removed.\n+   * @param menu The new Help menu.\n+   */\n+  public synchronized void setHelpMenu (Menu menu)\n+  {\n+    if (help_menu != null)\n+      {\n+\thelp_menu.removeNotify ();\n+\thelp_menu.parent = null;\n+      }\n+\n+    if (menu.parent != null)\n+      menu.parent.remove (menu);\n+    if (menu.parent != null)\n+      menu.parent.remove (menu);\n+    menu.parent = this;\n+\n+    if (peer != null)\n+      {\n+\tMenuBarPeer mp = (MenuBarPeer) peer;\n+\tmp.addHelpMenu (menu);\n+      }\n+  }\n+\n+  /** Returns an Enumeration which lists the keyboard shortcuts\n+   * associated with menu items on this MenuBar.\n+   */\n+  public synchronized Enumeration shortcuts ()\n+  {\n+    return new ShortcutEnumeration (new MenuEnumeration (this));\n+  }\n+\n+  // Iterate over the items of a menu.\n+  private static class MenuEnumeration implements Enumeration\n+  {\n+    // Enumerate over the menu's items.\n+    Enumeration main;\n+    // Enumerate over a submenu.\n+    Enumeration sub;\n+    // Menubar so we can keep track of help menu too.\n+    MenuBar menubar;\n+\n+    MenuEnumeration (Menu m)\n+    {\n+      sub = null;\n+      menubar = null;\n+      main = m.items.elements ();\n+    }\n+\n+    MenuEnumeration (MenuBar mb)\n+    {\n+      sub = null;\n+      menubar = mb;\n+      main = mb.menus.elements ();\n+    }\n+\n+    public boolean hasMoreElements ()\n+    {\n+      boolean r = false;\n+      if (sub != null)\n+\tr = sub.hasMoreElements ();\n+      if (! r)\n+\tr = main.hasMoreElements ();\n+      if (! r && menubar != null)\n+\t{\n+\t  if (menubar.help_menu != null)\n+\t    {\n+\t      main = new MenuEnumeration (menubar.help_menu);\n+\t      r = main.hasMoreElements ();\n+\t    }\n+\t  menubar = null;\n+\t}\n+      return r;\n+    }\n+\n+    public Object nextElement () throws NoSuchElementException\n+    {\n+      while (true)\n+\t{\n+\t  if (! sub.hasMoreElements ())\n+\t    sub = null;\n+\t  else\n+\t    return sub.nextElement ();\n+\n+\t  if (! main.hasMoreElements () && menubar != null\n+\t      && menubar.help_menu != null)\n+\t    {\n+\t      main = new MenuEnumeration (menubar.help_menu);\n+\t      menubar = null;\n+\t    }\n+\n+\t  Object r = main.nextElement ();\n+\t  if (r instanceof Menu)\n+\t    {\n+\t      sub = new MenuEnumeration ((Menu) r);\n+\t      continue;\n+\t    }\n+\n+\t  return r;\n+\t}\n+    }\n+  }\n+\n+  // This is an enumeration that shadows another enumeration and\n+  // returns the shortcut for each item returned.  I wonder if we're\n+  // only supposed to return unique shortcuts?  If so then we could\n+  // keep a hash table here and remove duplicates.\n+  private static class ShortcutEnumeration implements Enumeration\n+  {\n+    Enumeration back;\n+\n+    ShortcutEnumeration (Enumeration back)\n+    {\n+      this.back = back;\n+    }\n+\n+    public boolean hasMoreElements ()\n+    {\n+      return back.hasMoreElements ();\n+    }\n+\n+    public Object nextElement () throws NoSuchElementException\n+    {\n+      while (true)\n+\t{\n+\t  MenuItem item = (MenuItem) back.nextElement ();\n+\t  if (item.getShortcut () != null)\n+\t    return item.getShortcut ();\n+\t}\n+    }\n+  }\n+\n+  // We use Vector because it makes enumerating easier than ArrayList\n+  // in this case.\n+  Vector menus;\n+  Menu help_menu;\n }"}, {"sha": "a6905ede547d654d955170b8666f7794c13672a5", "filename": "libjava/java/awt/MenuComponent.java", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FMenuComponent.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FMenuComponent.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMenuComponent.java?ref=b3b90f82f43dba90b2f2f00d87165519d95c4268", "patch": "@@ -10,7 +10,7 @@\n \n /* Status: partially complete, untested. */\n \n-public abstract class MenuComponent\n+public abstract class MenuComponent implements java.io.Serializable\n {\n   // Fields from the serialization spec. Decalare others \"transient\".\n   Font font;\n@@ -71,7 +71,9 @@ public void setFont(Font f)\n \n   public void removeNotify()\n   {\n-    // FIXME\n+    if (peer != null)\n+      peer.dispose ();\n+    peer = null;\n   }\n \n   /** @deprecated Replaced by dispatchEvent(AWTEvent) */"}, {"sha": "289e10c00b75aa2950627c860eadb3fcedb9afde", "filename": "libjava/java/awt/MenuShortcut.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FMenuShortcut.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3b90f82f43dba90b2f2f00d87165519d95c4268/libjava%2Fjava%2Fawt%2FMenuShortcut.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2FMenuShortcut.java?ref=b3b90f82f43dba90b2f2f00d87165519d95c4268", "patch": "@@ -12,7 +12,7 @@\n \n /* Status: Complete, except for hashCode(). Untested. */\n \n-public class MenuShortcut\n+public class MenuShortcut implements java.io.Serializable\n {\n   // Fields from the serialization spec. Decalare others \"transient\".\n   int key;"}]}