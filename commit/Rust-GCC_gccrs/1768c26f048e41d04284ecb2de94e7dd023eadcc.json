{"sha": "1768c26f048e41d04284ecb2de94e7dd023eadcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2OGMyNmYwNDhlNDFkMDQyODRlY2IyZGU5NGU3ZGQwMjNlYWRjYw==", "commit": {"author": {"name": "Philip Blundell", "email": "pb@nexus.co.uk", "date": "2002-02-18T19:37:33Z"}, "committer": {"name": "Phil Blundell", "email": "pb@gcc.gnu.org", "date": "2002-02-18T19:37:33Z"}, "message": "arm.c (arm_compute_save_reg_mask): Fix typo in comment.\n\n2002-02-18 Philip Blundell <pb@nexus.co.uk>\n\n\t* config/arm/arm.c (arm_compute_save_reg_mask): Fix typo in\n\tcomment.\n\t(output_return_instruction): Allow use of LDR to unstack\n\treturn addresss even for interrupt handlers or when\n\tinterworking.  If compiling for ARMv5, use interworking-safe\n\treturn instructions by default.  Remove duplicated code and\n\tlengthy \"strcat\" sequences.\n\nFrom-SVN: r49845", "tree": {"sha": "de6c3c5d890d83925eb3229c22c398c5a5b686d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de6c3c5d890d83925eb3229c22c398c5a5b686d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1768c26f048e41d04284ecb2de94e7dd023eadcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1768c26f048e41d04284ecb2de94e7dd023eadcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1768c26f048e41d04284ecb2de94e7dd023eadcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1768c26f048e41d04284ecb2de94e7dd023eadcc/comments", "author": null, "committer": null, "parents": [{"sha": "ccd84f51ad2f49e4db0752350427ce83e6deff2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccd84f51ad2f49e4db0752350427ce83e6deff2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccd84f51ad2f49e4db0752350427ce83e6deff2a"}], "stats": {"total": 174, "additions": 89, "deletions": 85}, "files": [{"sha": "fe35ed4e23e445e9c6bb894f1436bc71e3eab1f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768c26f048e41d04284ecb2de94e7dd023eadcc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768c26f048e41d04284ecb2de94e7dd023eadcc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1768c26f048e41d04284ecb2de94e7dd023eadcc", "patch": "@@ -1,3 +1,13 @@\n+2002-02-18 Philip Blundell <pb@nexus.co.uk>\n+\n+\t* config/arm/arm.c (arm_compute_save_reg_mask): Fix typo in\n+\tcomment.\n+\t(output_return_instruction): Allow use of LDR to unstack\n+\treturn addresss even for interrupt handlers or when\n+\tinterworking.  If compiling for ARMv5, use interworking-safe\n+\treturn instructions by default.  Remove duplicated code and\n+\tlengthy \"strcat\" sequences.\n+\n 2002-02-18  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* config/rs6000/sysv4.h (STARTFILE_SPEC): Use crtbeginT.o for -static."}, {"sha": "9ef81bf0478b5a75ebf573999e0e945e248d14f7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 79, "deletions": 85, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1768c26f048e41d04284ecb2de94e7dd023eadcc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1768c26f048e41d04284ecb2de94e7dd023eadcc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1768c26f048e41d04284ecb2de94e7dd023eadcc", "patch": "@@ -7136,7 +7136,7 @@ arm_compute_save_reg_mask ()\n   /* Decide if we need to save the link register.\n      Interrupt routines have their own banked link register,\n      so they never need to save it.\n-     Otheriwse if we do not use the link register we do not need to save\n+     Otherwise if we do not use the link register we do not need to save\n      it.  If we are pushing other registers onto the stack however, we\n      can save an instruction in the epilogue by pushing the link register\n      now and then popping it back into the PC.  This incurs extra memory\n@@ -7204,21 +7204,20 @@ output_return_instruction (operand, really_return, reverse)\n \n   live_regs_mask = arm_compute_save_reg_mask ();\n \n-  /* On some ARM architectures it is faster to use LDR rather than LDM to\n-     load a single register.  On other architectures, the cost is the same.\n-     In 26 bit mode we have to use LDM in order to be able to restore the CPSR.  */\n-  if ((live_regs_mask  == (1 << LR_REGNUM))\n-      && ! TARGET_INTERWORK\n-      && ! IS_INTERRUPT (func_type)\n-      && (! really_return || TARGET_APCS_32))\n+  if (live_regs_mask)\n     {\n-      if (! really_return)\n-\tsprintf (instr, \"ldr%s\\t%%|lr, [%%|sp], #4\", conditional);\n+      const char * return_reg;\n+\n+      /* If we do not have any special requirements for function exit \n+\t (eg interworking, or ISR) then we can load the return address \n+\t directly into the PC.  Otherwise we must load it into LR.  */\n+      if (really_return\n+\t  && ! IS_INTERRUPT (func_type)\n+\t  && ! TARGET_INTERWORK)\n+\treturn_reg = reg_names[PC_REGNUM];\n       else\n-\tsprintf (instr, \"ldr%s\\t%%|pc, [%%|sp], #4\", conditional);\n-    }\n-  else if (live_regs_mask)\n-    {\n+\treturn_reg = reg_names[LR_REGNUM];\n+\n       if ((live_regs_mask & (1 << IP_REGNUM)) == (1 << IP_REGNUM))\n \t/* There are two possible reasons for the IP register being saved.\n \t   Either a stack frame was created, in which case IP contains the\n@@ -7230,47 +7229,66 @@ output_return_instruction (operand, really_return, reverse)\n \t    live_regs_mask |=   (1 << SP_REGNUM);\n \t  }\n \n-      /* Generate the load multiple instruction to restore the registers.  */\n-      if (frame_pointer_needed)\n-\tsprintf (instr, \"ldm%sea\\t%%|fp, {\", conditional);\n-      else\n-\tsprintf (instr, \"ldm%sfd\\t%%|sp!, {\", conditional);\n-\n-      for (reg = 0; reg <= SP_REGNUM; reg++)\n-\tif (live_regs_mask & (1 << reg))\n-\t  {\n-\t    strcat (instr, \"%|\");\n-\t    strcat (instr, reg_names[reg]);\n-\t    strcat (instr, \", \");\n-\t  }\n-\n-      if ((live_regs_mask & (1 << LR_REGNUM)) == 0)\n+      /* On some ARM architectures it is faster to use LDR rather than LDM to\n+\t load a single register.  On other architectures, the cost is the same.\n+\t In 26 bit mode we have to use LDM in order to be able to restore the \n+\t CPSR.  */\n+      if ((live_regs_mask  == (1 << LR_REGNUM))\n+\t  && (! really_return || TARGET_APCS_32))\n \t{\n-\t  /* If we are not restoring the LR register then we will\n-\t     have added one too many commas to the list above.\n-\t     Replace it with a closing brace.  */\n-\t  instr [strlen (instr) - 2] =  '}';\n+\t  sprintf (instr, \"ldr%s\\t%%|%s, [%%|sp], #4\", conditional, return_reg);\n \t}\n       else\n \t{\n-\t  strcat (instr, \"%|\");\n+\t  char *p;\n+\t  int first = 1;\n \n-\t  /* At this point there should only be one or two registers left in\n-\t     live_regs_mask: always LR, and possibly PC if we created a stack\n-\t     frame.  LR contains the return address.  If we do not have any\n-\t     special requirements for function exit (eg interworking, or ISR)\n-\t     then we can load this value directly into the PC and save an\n-\t     instruction.  */\n-\t  if (! TARGET_INTERWORK\n-\t      && ! IS_INTERRUPT (func_type)\n-\t      && really_return)\n-\t    strcat (instr, reg_names [PC_REGNUM]);\n+\t  /* Generate the load multiple instruction to restore the registers.  */\n+\t  if (frame_pointer_needed)\n+\t    sprintf (instr, \"ldm%sea\\t%%|fp, {\", conditional);\n \t  else\n-\t    strcat (instr, reg_names [LR_REGNUM]);\n+\t    sprintf (instr, \"ldm%sfd\\t%%|sp!, {\", conditional);\n+\n+\t  p = instr + strlen (instr);\n+\n+\t  for (reg = 0; reg <= SP_REGNUM; reg++)\n+\t    if (live_regs_mask & (1 << reg))\n+\t      {\n+\t\tint l = strlen (reg_names[reg]);\n+\n+\t\tif (first)\n+\t\t  first = 0;\n+\t\telse\n+\t\t  {\n+\t\t    memcpy (p, \", \", 2);\n+\t\t    p += 2;\n+\t\t  }\n+\n+\t\tmemcpy (p, \"%|\", 2);\n+\t\tmemcpy (p + 2, reg_names[reg], l);\n+\t\tp += l + 2;\n+\t      }\n+\t  \n+\t  if (live_regs_mask & (1 << LR_REGNUM))\n+\t    {\n+\t      int l = strlen (return_reg);\n+\n+\t      if (! first)\n+\t\t{\n+\t\t  memcpy (p, \", \", 2);\n+\t\t  p += 2;\n+\t\t}\n \n-\t  strcat (instr, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n+\t      memcpy (p, \"%|\", 2);\n+\t      memcpy (p + 2, return_reg, l);\n+\t      strcpy (p + 2 + l, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n+\t    }\n+\t  else\n+\t    strcpy (p, \"}\");\n \t}\n \n+      output_asm_insn (instr, & operand);\n+\n       if (really_return)\n \t{\n \t  /* See if we need to generate an extra instruction to\n@@ -7279,47 +7297,22 @@ output_return_instruction (operand, really_return, reverse)\n \t    {\n \t    case ARM_FT_ISR:\n \t    case ARM_FT_FIQ:\n-\t      output_asm_insn (instr, & operand);\n-\n-\t      strcpy (instr, \"sub\");\n-\t      strcat (instr, conditional);\n-\t      strcat (instr, \"s\\t%|pc, %|lr, #4\");\n-\t      break;\n-\n \t    case ARM_FT_EXCEPTION:\n-\t      output_asm_insn (instr, & operand);\n-\n-\t      strcpy (instr, \"mov\");\n-\t      strcat (instr, conditional);\n-\t      strcat (instr, \"s\\t%|pc, %|lr\");\n-\t      break;\n-\n \t    case ARM_FT_INTERWORKED:\n-\t      output_asm_insn (instr, & operand);\n-\n-\t      strcpy (instr, \"bx\");\n-\t      strcat (instr, conditional);\n-\t      strcat (instr, \"\\t%|lr\");\n+\t      /* A separate return instruction is always needed.  */\n \t      break;\n \n \t    default:\n-\t      /* The return has already been handled\n+\t      /* The return may have already been handled\n \t\t by loading the LR into the PC.  */\n-\t      if ((live_regs_mask & (1 << LR_REGNUM)) == 0)\n-\t\t{\n-\t\t  output_asm_insn (instr, & operand);\n-\n-\t\t  strcpy (instr, \"mov\");\n-\t\t  strcat (instr, conditional);\n-\t\t  if (! TARGET_APCS_32)\n-\t\t    strcat (instr, \"s\");\n-\t\t  strcat (instr, \"\\t%|pc, %|lr\");\n-\t\t}\n+\t      if ((live_regs_mask & (1 << LR_REGNUM)) != 0)\n+\t\treally_return = 0;\n \t      break;\n \t    }\n \t}\n     }\n-  else if (really_return)\n+  \n+  if (really_return)\n     {\n       switch ((int) ARM_FUNC_TYPE (func_type))\n \t{\n@@ -7337,18 +7330,19 @@ output_return_instruction (operand, really_return, reverse)\n \t  break;\n \n \tdefault:\n-\t  sprintf (instr, \"mov%s%s\\t%%|pc, %%|lr\",\n-\t\t   conditional, TARGET_APCS_32 ? \"\" : \"s\");\n+\t  /* ARMv5 implementations always provide BX, so interworking\n+\t     is the default unless APCS-26 is in use.  */\n+\t  if ((insn_flags & FL_ARCH5) != 0 && TARGET_APCS_32)\n+\t    sprintf (instr, \"bx%s\\t%%|lr\", conditional);\t    \n+\t  else\n+\t    sprintf (instr, \"mov%s%s\\t%%|pc, %%|lr\",\n+\t\t     conditional, TARGET_APCS_32 ? \"\" : \"s\");\n \t  break;\n \t}\n+\n+      output_asm_insn (instr, & operand);\n     }\n-  else\n-    /* Nothing to load off the stack, and\n-       no return instruction to generate.  */\n-    return \"\";\n \n-  output_asm_insn (instr, & operand);\n-      \n   return \"\";\n }\n "}]}