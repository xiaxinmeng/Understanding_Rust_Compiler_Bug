{"sha": "2da14663d0dee41a3f90f40704f9063e53a8b247", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRhMTQ2NjNkMGRlZTQxYTNmOTBmNDA3MDRmOTA2M2U1M2E4YjI0Nw==", "commit": {"author": {"name": "Carl Love", "email": "cel@us.ibm.com", "date": "2018-10-01T15:41:24Z"}, "committer": {"name": "Carl Love", "email": "carll@gcc.gnu.org", "date": "2018-10-01T15:41:24Z"}, "message": "rs6000-builtin.def (__builtin_mffsl): New.\n\ngcc/ChangeLog:\n\n2018-10-01  Carl Love  <cel@us.ibm.com>\n\n\t* config/rs6000/rs6000-builtin.def (__builtin_mffsl): New.\n\t(__builtin_mtfsb0): New.\n\t(__builtin_mtfsb1): New.\n\t( __builtin_set_fpscr_rn): New.\n\t(__builtin_set_fpscr_drn): New.\n\t* config/rs6000/rs6000.c (rs6000_expand_mtfsb_builtin): Add.\n\t(rs6000_expand_set_fpscr_rn_builtin): Add.\n\t(rs6000_expand_set_fpscr_drn_builtin): Add.\n\t(rs6000_expand_builtin): Add case statement entries for\n\tRS6000_BUILTIN_MTFSB0, RS6000_BUILTIN_MTFSB1,\n\tRS6000_BUILTIN_SET_FPSCR_RN, RS6000_BUILTIN_SET_FPSCR_DRN,\n\tRS6000_BUILTIN_MFFSL.\n\t(rs6000_init_builtins): Add ftype initialization and def_builtin\n\tcalls for __builtin_mffsl, __builtin_mtfsb0, __builtin_mtfsb1,\n\t__builtin_set_fpscr_rn, __builtin_set_fpscr_drn.\n\t* config/rs6000.md (rs6000_mtfsb0, rs6000_mtfsb1, rs6000_mffscrn,\n\trs6000_mffscdrn): Add define_insn.\n\t(rs6000_set_fpscr_rn, rs6000_set_fpscr_drn): Add define_expand.\n\t* doc/extend.texi: Add documentation for the builtins.\n\ngcc/testsuite/ChangeLog:\n\n2018-10-01  Carl Love  <cel@us.ibm.com>\n\n\t* gcc.target/powerpc/test_mffsl-p9.c: New file.\n\t* gcc.target/powerpc/test_fpscr_rn_builtin.c: New file.\n\t* gcc.target/powerpc/test_fpscr_drn_builtin.c: New file.\n\t* gcc.target/powerpc/test_fpscr_rn_builtin_error.c: New file.\n\t* gcc.target/powerpc/test_fpscr_drn_builtin_error.c: New file.\n\nFrom-SVN: r264762", "tree": {"sha": "38d1a67389a2d342746039e5898ed0659f245b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38d1a67389a2d342746039e5898ed0659f245b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2da14663d0dee41a3f90f40704f9063e53a8b247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da14663d0dee41a3f90f40704f9063e53a8b247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2da14663d0dee41a3f90f40704f9063e53a8b247", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2da14663d0dee41a3f90f40704f9063e53a8b247/comments", "author": {"login": "carlelove", "id": 86435705, "node_id": "MDQ6VXNlcjg2NDM1NzA1", "avatar_url": "https://avatars.githubusercontent.com/u/86435705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/carlelove", "html_url": "https://github.com/carlelove", "followers_url": "https://api.github.com/users/carlelove/followers", "following_url": "https://api.github.com/users/carlelove/following{/other_user}", "gists_url": "https://api.github.com/users/carlelove/gists{/gist_id}", "starred_url": "https://api.github.com/users/carlelove/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/carlelove/subscriptions", "organizations_url": "https://api.github.com/users/carlelove/orgs", "repos_url": "https://api.github.com/users/carlelove/repos", "events_url": "https://api.github.com/users/carlelove/events{/privacy}", "received_events_url": "https://api.github.com/users/carlelove/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3553df866af08c5b9e5873ca536058eace183f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553df866af08c5b9e5873ca536058eace183f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3553df866af08c5b9e5873ca536058eace183f12"}], "stats": {"total": 824, "additions": 822, "deletions": 2}, "files": [{"sha": "49f99edf132d01cffce05c4e07b8e63977c5d5b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -1,3 +1,25 @@\n+2018-10-01  Carl Love  <cel@us.ibm.com>\n+\n+\t* config/rs6000/rs6000-builtin.def (__builtin_mffsl): New.\n+\t(__builtin_mtfsb0): New.\n+\t(__builtin_mtfsb1): New.\n+\t( __builtin_set_fpscr_rn): New.\n+\t(__builtin_set_fpscr_drn): New.\n+\t* config/rs6000/rs6000.c (rs6000_expand_mtfsb_builtin): Add.\n+\t(rs6000_expand_set_fpscr_rn_builtin): Add.\n+\t(rs6000_expand_set_fpscr_drn_builtin): Add.\n+\t(rs6000_expand_builtin): Add case statement entries for\n+\tRS6000_BUILTIN_MTFSB0, RS6000_BUILTIN_MTFSB1,\n+\tRS6000_BUILTIN_SET_FPSCR_RN, RS6000_BUILTIN_SET_FPSCR_DRN,\n+\tRS6000_BUILTIN_MFFSL.\n+\t(rs6000_init_builtins): Add ftype initialization and def_builtin\n+\tcalls for __builtin_mffsl, __builtin_mtfsb0, __builtin_mtfsb1,\n+\t__builtin_set_fpscr_rn, __builtin_set_fpscr_drn.\n+\t* config/rs6000.md (rs6000_mtfsb0, rs6000_mtfsb1, rs6000_mffscrn,\n+\trs6000_mffscdrn): Add define_insn.\n+\t(rs6000_set_fpscr_rn, rs6000_set_fpscr_drn): Add define_expand.\n+\t* doc/extend.texi: Add documentation for the builtins.\n+\n 2018-10-01  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87465"}, {"sha": "976c36b252ef1552df70f35b01d0fd2d62fc59dd", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -2486,11 +2486,35 @@ BU_SPECIAL_X (RS6000_BUILTIN_MFTB, \"__builtin_ppc_mftb\",\n BU_SPECIAL_X (RS6000_BUILTIN_MFFS, \"__builtin_mffs\",\n \t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n \n+BU_SPECIAL_X (RS6000_BUILTIN_MFFSL, \"__builtin_mffsl\",\n+\t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n+\n RS6000_BUILTIN_X (RS6000_BUILTIN_MTFSF, \"__builtin_mtfsf\",\n \t          RS6000_BTM_ALWAYS,\n \t          RS6000_BTC_MISC | RS6000_BTC_UNARY | RS6000_BTC_VOID,\n \t\t  CODE_FOR_rs6000_mtfsf)\n \n+RS6000_BUILTIN_X (RS6000_BUILTIN_MTFSB0, \"__builtin_mtfsb0\",\n+\t\t  RS6000_BTM_ALWAYS,\n+\t\t  RS6000_BTC_MISC | RS6000_BTC_UNARY | RS6000_BTC_VOID,\n+\t\t  CODE_FOR_rs6000_mtfsb0)\n+\n+RS6000_BUILTIN_X (RS6000_BUILTIN_MTFSB1, \"__builtin_mtfsb1\",\n+\t\t  RS6000_BTM_ALWAYS,\n+\t\t  RS6000_BTC_MISC | RS6000_BTC_UNARY | RS6000_BTC_VOID,\n+\t\t  CODE_FOR_rs6000_mtfsb1)\n+\n+RS6000_BUILTIN_X (RS6000_BUILTIN_SET_FPSCR_RN, \"__builtin_set_fpscr_rn\",\n+\t\t  RS6000_BTM_ALWAYS,\n+\t\t  RS6000_BTC_MISC | RS6000_BTC_UNARY| RS6000_BTC_VOID,\n+\t\t  CODE_FOR_rs6000_set_fpscr_rn)\n+\n+RS6000_BUILTIN_X (RS6000_BUILTIN_SET_FPSCR_DRN, \"__builtin_set_fpscr_drn\",\n+\t\t  RS6000_BTM_ALWAYS,\n+\t\t  RS6000_BTC_MISC | RS6000_BTM_64BIT | RS6000_BTC_UNARY\n+\t\t  | RS6000_BTC_VOID,\n+\t\t  CODE_FOR_rs6000_set_fpscr_drn)\n+\n BU_SPECIAL_X (RS6000_BUILTIN_CPU_INIT, \"__builtin_cpu_init\",\n \t      RS6000_BTM_ALWAYS, RS6000_BTC_MISC)\n "}, {"sha": "a2813c8fd99e31bf2fb11e9581e016d923ca1168", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -13260,6 +13260,13 @@ rs6000_expand_zeroop_builtin (enum insn_code icode, rtx target)\n     /* Builtin not supported on this processor.  */\n     return 0;\n \n+  if (icode == CODE_FOR_rs6000_mffsl\n+      && rs6000_isa_flags_explicit & OPTION_MASK_SOFT_FLOAT)\n+    {\n+      error (\"__builtin_mffsl() not supported with -msoft-float\");\n+      return const0_rtx;\n+    }\n+\n   if (target == 0\n       || GET_MODE (target) != tmode\n       || ! (*insn_data[icode].operand[0].predicate) (target, tmode))\n@@ -13308,6 +13315,134 @@ rs6000_expand_mtfsf_builtin (enum insn_code icode, tree exp)\n     op1 = copy_to_mode_reg (mode1, op1);\n \n   pat = GEN_FCN (icode) (op0, op1);\n+  if (!pat)\n+    return const0_rtx;\n+  emit_insn (pat);\n+\n+  return NULL_RTX;\n+}\n+\n+static rtx\n+rs6000_expand_mtfsb_builtin (enum insn_code icode, tree exp)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  rtx op0 = expand_normal (arg0);\n+\n+  if (icode == CODE_FOR_nothing)\n+    /* Builtin not supported on this processor.  */\n+    return 0;\n+\n+  if (rs6000_isa_flags_explicit & OPTION_MASK_SOFT_FLOAT)\n+    {\n+      error (\"__builtin_mtfsb0 and __builtin_mtfsb1 not supported with -msoft-float\");\n+      return const0_rtx;\n+    }\n+\n+  /* If we got invalid arguments bail out before generating bad rtl.  */\n+  if (arg0 == error_mark_node)\n+    return const0_rtx;\n+\n+  /* Only allow bit numbers 0 to 31.  */\n+  if (!u5bit_cint_operand (op0, VOIDmode))\n+    {\n+       error (\"Argument must be a constant between 0 and 31.\");\n+       return const0_rtx;\n+     }\n+\n+  pat = GEN_FCN (icode) (op0);\n+  if (!pat)\n+    return const0_rtx;\n+  emit_insn (pat);\n+\n+  return NULL_RTX;\n+}\n+\n+static rtx\n+rs6000_expand_set_fpscr_rn_builtin (enum insn_code icode, tree exp)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  rtx op0 = expand_normal (arg0);\n+  machine_mode mode0 = insn_data[icode].operand[0].mode;\n+\n+  if (icode == CODE_FOR_nothing)\n+    /* Builtin not supported on this processor.  */\n+    return 0;\n+\n+  if (rs6000_isa_flags_explicit & OPTION_MASK_SOFT_FLOAT)\n+    {\n+      error (\"__builtin_set_fpscr_rn not supported with -msoft-float\");\n+      return const0_rtx;\n+    }\n+\n+  /* If we got invalid arguments bail out before generating bad rtl.  */\n+  if (arg0 == error_mark_node)\n+    return const0_rtx;\n+\n+  /* If the argument is a constant, check the range. Argument can only be a\n+     2-bit value.  Unfortunately, can't check the range of the value at\n+     compile time if the argument is a variable.  The least significant two\n+     bits of the argument, regardless of type, are used to set the rounding\n+     mode.  All other bits are ignored.  */\n+  if (GET_CODE (op0) == CONST_INT && !const_0_to_3_operand(op0, VOIDmode))\n+    {\n+      error (\"Argument must be a value between 0 and 3.\");\n+      return const0_rtx;\n+    }\n+\n+  if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+\n+  pat = GEN_FCN (icode) (op0);\n+  if (!pat)\n+    return const0_rtx;\n+  emit_insn (pat);\n+\n+  return NULL_RTX;\n+}\n+static rtx\n+rs6000_expand_set_fpscr_drn_builtin (enum insn_code icode, tree exp)\n+{\n+  rtx pat;\n+  tree arg0 = CALL_EXPR_ARG (exp, 0);\n+  rtx op0 = expand_normal (arg0);\n+  machine_mode mode0 = insn_data[icode].operand[0].mode;\n+\n+  if (TARGET_32BIT)\n+    /* Builtin not supported in 32-bit mode.  */\n+    fatal_error (input_location,\n+\t\t \"__builtin_set_fpscr_drn is not supported in 32-bit mode.\");\n+\n+  if (rs6000_isa_flags_explicit & OPTION_MASK_SOFT_FLOAT)\n+    {\n+      error (\"__builtin_set_fpscr_drn not supported with -msoft-float\");\n+      return const0_rtx;\n+    }\n+\n+  if (icode == CODE_FOR_nothing)\n+    /* Builtin not supported on this processor.  */\n+    return 0;\n+\n+  /* If we got invalid arguments bail out before generating bad rtl.  */\n+  if (arg0 == error_mark_node)\n+    return const0_rtx;\n+\n+  /* If the argument is a constant, check the range. Agrument can only be a\n+     3-bit value.  Unfortunately, can't check the range of the value at\n+     compile time if the argument is a variable. The least significant two\n+     bits of the argument, regardless of type, are used to set the rounding\n+     mode.  All other bits are ignored.  */\n+  if (GET_CODE (op0) == CONST_INT && !const_0_to_7_operand(op0, VOIDmode))\n+   {\n+      error (\"Argument must be a value between 0 and 7.\");\n+      return const0_rtx;\n+    }\n+\n+  if (! (*insn_data[icode].operand[0].predicate) (op0, mode0))\n+    op0 = copy_to_mode_reg (mode0, op0);\n+\n+  pat = GEN_FCN (icode) (op0);\n   if (! pat)\n     return const0_rtx;\n   emit_insn (pat);\n@@ -16066,6 +16201,24 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     case RS6000_BUILTIN_MFFS:\n       return rs6000_expand_zeroop_builtin (CODE_FOR_rs6000_mffs, target);\n \n+    case RS6000_BUILTIN_MTFSB0:\n+      return rs6000_expand_mtfsb_builtin (CODE_FOR_rs6000_mtfsb0, exp);\n+\n+    case RS6000_BUILTIN_MTFSB1:\n+      return rs6000_expand_mtfsb_builtin (CODE_FOR_rs6000_mtfsb1, exp);\n+\n+    case RS6000_BUILTIN_SET_FPSCR_RN:\n+      return rs6000_expand_set_fpscr_rn_builtin (CODE_FOR_rs6000_set_fpscr_rn,\n+\t\t\t\t\t\t exp);\n+\n+    case RS6000_BUILTIN_SET_FPSCR_DRN:\n+      return\n+        rs6000_expand_set_fpscr_drn_builtin (CODE_FOR_rs6000_set_fpscr_drn,\n+\t\t\t\t\t     exp);\n+\n+    case RS6000_BUILTIN_MFFSL:\n+      return rs6000_expand_zeroop_builtin (CODE_FOR_rs6000_mffsl, target);\n+\n     case RS6000_BUILTIN_MTFSF:\n       return rs6000_expand_mtfsf_builtin (CODE_FOR_rs6000_mtfsf, exp);\n \n@@ -16449,6 +16602,29 @@ rs6000_init_builtins (void)\n   ftype = build_function_type_list (double_type_node, NULL_TREE);\n   def_builtin (\"__builtin_mffs\", ftype, RS6000_BUILTIN_MFFS);\n \n+  ftype = build_function_type_list (double_type_node, NULL_TREE);\n+  def_builtin (\"__builtin_mffsl\", ftype, RS6000_BUILTIN_MFFSL);\n+\n+  ftype = build_function_type_list (void_type_node,\n+\t\t\t\t    intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (\"__builtin_mtfsb0\", ftype, RS6000_BUILTIN_MTFSB0);\n+\n+  ftype = build_function_type_list (void_type_node,\n+\t\t\t\t    intSI_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (\"__builtin_mtfsb1\", ftype, RS6000_BUILTIN_MTFSB1);\n+\n+  ftype = build_function_type_list (void_type_node,\n+\t\t\t\t    intDI_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (\"__builtin_set_fpscr_rn\", ftype, RS6000_BUILTIN_SET_FPSCR_RN);\n+\n+  ftype = build_function_type_list (void_type_node,\n+\t\t\t\t    intDI_type_node,\n+\t\t\t\t    NULL_TREE);\n+  def_builtin (\"__builtin_set_fpscr_drn\", ftype, RS6000_BUILTIN_SET_FPSCR_DRN);\n+\n   ftype = build_function_type_list (void_type_node,\n \t\t\t\t    intSI_type_node, double_type_node,\n \t\t\t\t    NULL_TREE);"}, {"sha": "31a74ca735a19770ac33fef96bdfe580b1953ec1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 174, "deletions": 1, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -163,7 +163,13 @@\n    UNSPECV_MFTB\t\t\t; move from time base\n    UNSPECV_NLGR\t\t\t; non-local goto receiver\n    UNSPECV_MFFS\t\t\t; Move from FPSCR\n-   UNSPECV_MTFSF\t\t; Move to FPSCR Fields\n+   UNSPECV_MFFSL\t\t; Move from FPSCR light instruction version\n+   UNSPECV_MFFSCRN\t\t; Move from FPSCR float rounding mode\n+   UNSPECV_MFFSCDRN\t\t; Move from FPSCR decimal float rounding mode\n+   UNSPECV_MTFSF\t\t; Move to FPSCR Fields 8 to 15\n+   UNSPECV_MTFSF_HI\t\t; Move to FPSCR Fields 0 to 7\n+   UNSPECV_MTFSB0\t\t; Set FPSCR Field bit to 0\n+   UNSPECV_MTFSB1\t\t; Set FPSCR Field bit to 1\n    UNSPECV_SPLIT_STACK_RETURN   ; A camouflaged return\n    UNSPECV_SPEC_BARRIER         ; Speculation barrier\n   ])\n@@ -5811,6 +5817,129 @@\n    xscvdpuxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"rs6000_mtfsb0\"\n+  [(unspec_volatile [(match_operand:SI 0 \"u5bit_cint_operand\" \"n\")]\n+\t\t    UNSPECV_MTFSB0)]\n+  \"TARGET_HARD_FLOAT\"\n+  \"mtfsb0 %0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"rs6000_mtfsb1\"\n+  [(unspec_volatile [(match_operand:SI 0 \"u5bit_cint_operand\" \"n\")]\n+\t\t    UNSPECV_MTFSB1)]\n+  \"TARGET_HARD_FLOAT\"\n+  \"mtfsb1 %0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"rs6000_mffscrn\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+\t(unspec_volatile:DF [(match_operand:DF 1 \"gpc_reg_operand\" \"d\")]\n+\t\t\t    UNSPECV_MFFSCRN))]\n+   \"TARGET_P9_MISC\"\n+   \"mffscrn %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"rs6000_mffscdrn\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+   (unspec_volatile:DF [(const_int 0)] UNSPECV_MFFSCDRN))\n+   (use (match_operand:DF 1 \"gpc_reg_operand\" \"d\"))]\n+  \"TARGET_P9_MISC\"\n+  \"mffscdrn %0,%1\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"rs6000_set_fpscr_rn\"\n+ [(match_operand 0 \"reg_or_cint_operand\")]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  rtx tmp_df = gen_reg_rtx (DFmode);\n+\n+  /* The floating point rounding control bits are FPSCR[62:63]. Put the\n+     new rounding mode bits from operands[0][62:63] into FPSCR[62:63].  */\n+  if (TARGET_P9_MISC)\n+    {\n+      rtx src_df = gen_reg_rtx (DImode);\n+\n+      src_df = simplify_gen_subreg (DFmode, operands[0], DImode, 0);\n+      emit_insn (gen_rs6000_mffscrn (tmp_df, src_df));\n+      DONE;\n+    }\n+\n+  if (CONST_INT_P (operands[0]))\n+    {\n+      if ((INTVAL (operands[0]) & 0x1) == 0x1)\n+\temit_insn (gen_rs6000_mtfsb1 (GEN_INT (31)));\n+      else\n+\temit_insn (gen_rs6000_mtfsb0 (GEN_INT (31)));\n+\n+      if ((INTVAL (operands[0]) & 0x2) == 0x2)\n+\temit_insn (gen_rs6000_mtfsb1 (GEN_INT (30)));\n+      else\n+\temit_insn (gen_rs6000_mtfsb0 (GEN_INT (30)));\n+    }\n+  else\n+    {\n+      rtx tmp_rn = gen_reg_rtx (DImode);\n+      rtx tmp_di = gen_reg_rtx (DImode);\n+\n+      /* Extract new RN mode from operand.  */\n+      emit_insn (gen_anddi3 (tmp_rn, operands[0], GEN_INT (0x3)));\n+\n+      /* Insert new RN mode into FSCPR.  */\n+      emit_insn (gen_rs6000_mffs (tmp_df));\n+      tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);\n+      emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (-4)));\n+      emit_insn (gen_iordi3 (tmp_di, tmp_di, tmp_rn));\n+\n+      /* Need to write to field k=15.  The fields are [0:15].  Hence with\n+\t L=0, W=0, FLM_i must be equal to 8, 16 = i + 8*(1-W).  FLM is an\n+\t 8-bit field[0:7]. Need to set the bit that corresponds to the\n+\t value of i that you want [0:7].  */\n+      tmp_df = simplify_gen_subreg (DFmode, tmp_di, DImode, 0);\n+      emit_insn (gen_rs6000_mtfsf (GEN_INT (0x01), tmp_df));\n+    }\n+  DONE;\n+})\n+\n+(define_expand \"rs6000_set_fpscr_drn\"\n+  [(match_operand:DI 0  \"gpc_reg_operand\")]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  rtx tmp_df = gen_reg_rtx (DFmode);\n+\n+  /* The decimal floating point rounding control bits are FPSCR[29:31]. Put the\n+     new rounding mode bits from operands[0][61:63] into FPSCR[29:31].  */\n+  if (TARGET_P9_MISC)\n+    {\n+      rtx src_df = gen_reg_rtx (DFmode);\n+\n+      emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n+      src_df = simplify_gen_subreg (DFmode, operands[0], DImode, 0);\n+      emit_insn (gen_rs6000_mffscdrn (tmp_df, src_df));\n+    }\n+  else\n+    {\n+      rtx tmp_rn = gen_reg_rtx (DImode);\n+      rtx tmp_di = gen_reg_rtx (DImode);\n+\n+      /* Extract new DRN mode from operand.  */\n+      emit_insn (gen_anddi3 (tmp_rn, operands[0], GEN_INT (0x7)));\n+      emit_insn (gen_ashldi3 (tmp_rn, tmp_rn, GEN_INT (32)));\n+\n+      /* Insert new RN mode into FSCPR.  */\n+      emit_insn (gen_rs6000_mffs (tmp_df));\n+      tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);\n+      emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (0xFFFFFFF8FFFFFFFF)));\n+      emit_insn (gen_iordi3 (tmp_di, tmp_di, tmp_rn));\n+\n+      /* Need to write to field 7.  The fields are [0:15].  The equation to\n+\t select the field is i + 8*(1-W). Hence with L=0 and W=1, need to set\n+\t i to 0x1 to get field 7 where i selects the field.  */\n+      tmp_df = simplify_gen_subreg (DFmode, tmp_di, DImode, 0);\n+      emit_insn (gen_rs6000_mtfsf_hi (GEN_INT (0x01), tmp_df));\n+    }\n+  DONE;\n+})\n+\n ;; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n ;; rather than (set (subreg:SI (reg)) (fix:SI ...))\n ;; because the first makes it clear that operand 0 is not live\n@@ -13507,6 +13636,43 @@\n })\n \n \f\n+;; The ISA 3.0 mffsl instruction is a lower latency instruction\n+;; for reading bits [29:31], [45:51] and [56:63] of the FPSCR.\n+(define_insn \"rs6000_mffsl_hw\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n+        (unspec_volatile:DF [(const_int 0)] UNSPECV_MFFSL))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"mffsl %0\")\n+\n+(define_expand \"rs6000_mffsl\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\")\n+\t(unspec_volatile:DF [(const_int 0)] UNSPECV_MFFSL))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  /* If the low latency mffsl instruction (ISA 3.0) is available use it,\n+     otherwise fall back to the older mffs instruction to emulate the mffsl\n+     instruction.  */\n+\n+  if (!TARGET_P9_MISC)\n+    {\n+       rtx tmp_di = gen_reg_rtx (DImode);\n+       rtx tmp_df = gen_reg_rtx (DFmode);\n+\n+       /* The mffs instruction reads the entire FPSCR.  Emulate the mffsl\n+          instruction using the mffs instruction and masking off the bits\n+          the mmsl instruciton actually reads.  */\n+       emit_insn (gen_rs6000_mffs (tmp_df));\n+       tmp_di = simplify_gen_subreg (DImode, tmp_df, DFmode, 0);\n+       emit_insn (gen_anddi3 (tmp_di, tmp_di, GEN_INT (0x70007f0ffLL)));\n+\n+       operands[0] = simplify_gen_subreg (DFmode, tmp_di, DImode, 0);\n+       DONE;\n+    }\n+\n+    emit_insn (gen_rs6000_mffsl_hw (operands[0]));\n+    DONE;\n+})\n+\n (define_insn \"rs6000_mffs\"\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=d\")\n \t(unspec_volatile:DF [(const_int 0)] UNSPECV_MFFS))]\n@@ -13520,6 +13686,13 @@\n   \"TARGET_HARD_FLOAT\"\n   \"mtfsf %0,%1\")\n \n+(define_insn \"rs6000_mtfsf_hi\"\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"n\")\n+\t\t     (match_operand:DF 1 \"gpc_reg_operand\" \"d\")]\n+\t\t    UNSPECV_MTFSF_HI)]\n+  \"TARGET_HARD_FLOAT\"\n+  \"mtfsf %0,%1,0,1\")\n+\n \f\n ;; Power8 fusion support for fusing an addis instruction with a D-form load of\n ;; a GPR.  The addis instruction must be adjacent to the load, and use the same"}, {"sha": "0d9b99f14d30f8284413bd394ae11dd26d8d61a7", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -15781,6 +15781,10 @@ uint64_t __builtin_ppc_get_timebase ();\n unsigned long __builtin_ppc_mftb ();\n __ibm128 __builtin_unpack_ibm128 (__ibm128, int);\n __ibm128 __builtin_pack_ibm128 (double, double);\n+double __builtin_mffs (void);\n+void __builtin_mtfsb0 (const int);\n+void __builtin_mtfsb1 (const int);\n+void __builtin_set_fpscr_rn (int);\n @end smallexample\n \n The @code{__builtin_ppc_get_timebase} and @code{__builtin_ppc_mftb}\n@@ -15789,7 +15793,21 @@ functions generate instructions to read the Time Base Register.  The\n instructions and always returns the 64 bits of the Time Base Register.\n The @code{__builtin_ppc_mftb} function always generates one instruction and\n returns the Time Base Register value as an unsigned long, throwing away\n-the most significant word on 32-bit environments.\n+the most significant word on 32-bit environments.  The @code{__builtin_mffs}\n+return the value of the FPSCR register.  Note, ISA 3.0 supports the\n+@code{__builtin_mffsl()} which permits software to read the control and\n+non-sticky status bits in the FSPCR without the higher latency associated with\n+accessing the sticky status bits.  The\n+@code{__builtin_mtfsb0} and @code{__builtin_mtfsb1} take the bit to change\n+as an argument.  The valid bit range is between 0 and 31.  The builtins map to\n+the @code{mtfsb0} and @code{mtfsb1} instructions which take the argument and\n+add 32.  Hence these instructions only modify the FPSCR[32:63] bits by\n+changing the specified bit to a zero or one respectively.  The\n+@code{__builtin_set_fpscr_rn} builtin allows changing both of the floating\n+point rounding mode bits.  The argument is a 2-bit value.  The argument can\n+either be a const int or stored in a variable. The builtin uses the ISA 3.0\n+instruction @code{mffscrn} if available, otherwise it reads the FPSCR, masks\n+the current rounding mode bits out and OR's in the new value.\n \n @node Basic PowerPC Built-in Functions Available on ISA 2.05\n @subsubsection Basic PowerPC Built-in Functions Available on ISA 2.05\n@@ -15825,6 +15843,7 @@ The following built-in functions are available\n when hardware decimal floating point\n (@option{-mhard-dfp}) is available:\n @smallexample\n+void __builtin_set_fpscr_drn(int);\n _Decimal64 __builtin_ddedpd (int, _Decimal64);\n _Decimal128 __builtin_ddedpdq (int, _Decimal128);\n _Decimal64 __builtin_denbcd (int, _Decimal64);\n@@ -15839,6 +15858,14 @@ long long __builtin_dxex (_Decimal64);\n long long __builtin_dxexq (_Decimal128);\n _Decimal128 __builtin_pack_dec128 (unsigned long long, unsigned long long);\n unsigned long long __builtin_unpack_dec128 (_Decimal128, int);\n+\n+The @code{__builtin_set_fpscr_drn} builtin allows changing the three decimal\n+floating point rounding mode bits.  The argument is a 3-bit value.  The\n+argument can either be a const int or the value can be stored in a variable.\n+The builtin uses the ISA 3.0 instruction @code{mffscdrn} if available.\n+Otherwise the builtin reads the FPSCR, masks the current decimal rounding\n+mode bits out and OR's in the new value.\n+\n @end smallexample\n \n The following functions require @option{-mhard-float},\n@@ -16040,6 +16067,9 @@ int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);\n int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);\n+\n+double __builtin_mffsl(void);\n+\n @end smallexample\n The @code{__builtin_byte_in_set} function requires a\n 64-bit environment supporting ISA 3.0 or later.  This function returns\n@@ -16091,6 +16121,12 @@ The @code{__builtin_dfp_dtstsfi_ov_dd} and\n require that the type of the @code{value} argument be\n @code{__Decimal64} and @code{__Decimal128} respectively.\n \n+The @code{__builtin_mffsl} uses the ISA 3.0 @code{mffsl} instruction to read\n+the FPSCR.  The instruction is a lower latency version of the @code{mffs}\n+instruction.  If the @code{mffsl} instruction is not available, then the\n+builtin uses the older @code{mffs} instruction to read the FPSCR.\n+\n+\n @node PowerPC AltiVec/VSX Built-in Functions\n @subsection PowerPC AltiVec/VSX Built-in Functions\n "}, {"sha": "22713d9c4ab83f23d03d2cd502c1fe9c59539fca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -1,3 +1,11 @@\n+2018-10-01  Carl Love  <cel@us.ibm.com>\n+\n+\t* gcc.target/powerpc/test_mffsl-p9.c: New file.\n+\t* gcc.target/powerpc/test_fpscr_rn_builtin.c: New file.\n+\t* gcc.target/powerpc/test_fpscr_drn_builtin.c: New file.\n+\t* gcc.target/powerpc/test_fpscr_rn_builtin_error.c: New file.\n+\t* gcc.target/powerpc/test_fpscr_drn_builtin_error.c: New file.\n+\n 2018-10-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/65677"}, {"sha": "685bf97d70561b09e9882e956cf2c1dc89afb4cb", "filename": "gcc/testsuite/gcc.target/powerpc/test_fpscr_drn_builtin.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_drn_builtin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_drn_builtin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_drn_builtin.c?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -0,0 +1,117 @@\n+/* { dg-do run { target { powerpc*-*-* &&  lp64 } } } */\n+/* { dg-require-effective-target dfp_hw } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+#include <altivec.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#define DRN_MASK 0x700000000LL     /* DRN field mask */\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i;\n+  int val, bit;\n+  double fpscr_val;\n+  union blah {\n+    double d;\n+    unsigned long long ll;\n+  } conv_val;\n+  \n+  unsigned long long ll_value;\n+  register double  f14;\n+\n+  /* __builtin_set_fpscr_drn() builtin can take a const or a variable\n+     value between 0 and 7 as the argument.\n+  */\n+\n+  /* Test builtin decimal float rounding mode with const argument.  */\n+  __builtin_set_fpscr_drn(7);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & DRN_MASK;\n+\n+  if (ll_value != 0x700000000)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_drn(7) did not set rounding mode to 7.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  __builtin_set_fpscr_drn(2);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & DRN_MASK;\n+\n+  if (ll_value != 0x200000000)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_drn(2) did not set rounding mode to 2.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  __builtin_set_fpscr_drn(5);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & DRN_MASK;\n+\n+  if (ll_value != 0x500000000)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_drn(5) did not set rounding mode to 5.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  /* Test builtin decimal float rounding mode with variable as argument.  */\n+  val = 7;\n+  __builtin_set_fpscr_drn(val);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & DRN_MASK;\n+\n+  if (ll_value != ((unsigned long long)val << 32))\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_drn(val=%d) did not set rounding mode to %d.\\n\",\n+\t      val, val);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  val = 0;\n+  __builtin_set_fpscr_drn(val);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & DRN_MASK;\n+\n+  if (ll_value != ((unsigned long long)val << 32))\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_drn(val=%d) did not set rounding mode to %d.\\n\",\n+\t      val, val);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  val = 2;\n+  __builtin_set_fpscr_drn(val);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & DRN_MASK;\n+\n+  if (ll_value != ((unsigned long long)val << 32))\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_drn(val=%d) did not set rounding mode to %d.\\n\",\n+\t      val, val);\n+#else\n+       abort();\n+#endif\n+    }\t  \n+}"}, {"sha": "58453f0534d59aa6b18b1a816f438d168730971f", "filename": "gcc/testsuite/gcc.target/powerpc/test_fpscr_drn_builtin_error.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_drn_builtin_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_drn_builtin_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_drn_builtin_error.c?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target dfp_hw } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+#include <altivec.h>\n+\n+int main ()\n+{\n+\n+  /* Test builin with out of range arguments. The builtin\n+     __builtin_set_fpscr_drn() also support a variable as an argument but\n+     can't test variable value at compile time.  */\n+\n+  __builtin_set_fpscr_drn(-1);  /* { dg-error \"Argument must be a value between 0 and 7\" } */ \n+  __builtin_set_fpscr_drn(8);   /* { dg-error \"Argument must be a value between 0 and 7\" } */ \n+\n+}\n+"}, {"sha": "be05dcf39f4e28585b86685cec725e5658681ebb", "filename": "gcc/testsuite/gcc.target/powerpc/test_fpscr_rn_builtin.c", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_rn_builtin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_rn_builtin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_rn_builtin.c?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -0,0 +1,190 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+#include <altivec.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+#define RN_MASK  0x3LL             /* RN field mask */\n+\n+void abort (void);\n+\n+int main ()\n+{\n+  int i;\n+  int val, bit;\n+  double fpscr_val;\n+  union blah {\n+    double d;\n+    unsigned long long ll;\n+  } conv_val;\n+  \n+  unsigned long long ll_value;\n+  register double  f14;\n+\n+  /* __builtin_set_fpscr_rn() builtin can take a const or a variable\n+     value between 0 and 3 as the argument.\n+     __builtin_mtfsb0 and __builtin_mtfsb1 argument must be a constant \n+     30 or 31.\n+  */\n+\n+  /* Test reading the FPSCR register */\n+  __asm __volatile (\"mffs %0\" : \"=f\"(f14));\n+  conv_val.d = f14;\n+\n+  if (conv_val.d != __builtin_mffs())\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mffs() returned 0x%llx, not the expecected value 0x%llx\\n\",\n+\t      __builtin_mffs(), conv_val.d);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  /* Test float rounding mode builtin with const value argument.  */\n+  __builtin_set_fpscr_rn(3);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & RN_MASK;\n+\n+  if (ll_value != 3)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_rn(3) returned 0x%llx, not the expecected value 0x%x\\n\",\n+\t      ll_value, 3);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  val = 2;\n+  __builtin_set_fpscr_rn(val);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & RN_MASK;\n+\n+  if (ll_value != val)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_rn(val=%d) returned 0x%llx, not the expecected value 0x%x\\n\",\n+\t      val, ll_value, val);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  /* Reset to 0 for testing */\n+  val = 0;\n+  __builtin_set_fpscr_rn(val);\n+\n+  __builtin_mtfsb1(31);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & 0x1LL;\n+\n+  if (ll_value != 1)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mtfsb1(31) did not set the bit to a 1.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  __builtin_mtfsb0(31);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & 0x1LL;\n+\n+  if (ll_value != 0)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mtfsb0(31) did not set the bit to a 0.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+ __builtin_mtfsb1(30);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & 0x2LL;\n+\n+  if (ll_value != 2)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mtfsb1(31) did not set the bit to a 1.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  __builtin_mtfsb0(30);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & 0x2LL;\n+\n+  if (ll_value != 0)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mtfsb1(31) did not set the bit to a 0.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  __builtin_mtfsb1(0);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & (0x1LL << (31-0));\n+\n+  if (ll_value != (0x1LL << (31-0)))\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mtfsb1(0) did not set the bit to a 1.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  __builtin_mtfsb0(0);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & (0x1LL << (31-0));\n+\n+  if (ll_value != 0)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_mtfsb0(0) did not set the bit to a 0.\\n\");\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+\n+  /* Test builtin float rounding mode with variable as argument.  */\n+  val = 0;\n+  __builtin_set_fpscr_rn(val);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & RN_MASK;\n+\n+  if (ll_value != val)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_rn(val=%d) did not set rounding mode to %x.\\n\",\n+\t      val, val);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+\n+  val = 3;\n+  __builtin_set_fpscr_rn(val);\n+  conv_val.d = __builtin_mffs();\n+  ll_value = conv_val.ll & RN_MASK;\n+\n+  if (ll_value != val)\n+    {\n+#ifdef DEBUG\n+       printf(\"ERROR, __builtin_set_fpscr_rn(val=%d) did not set rounding mode to %x.\\n\",\n+\t      val, val);\n+#else\n+       abort();\n+#endif\n+    }\t\t  \n+}"}, {"sha": "a529ce6158de941317f0f2bdaf5cf1829c0d8588", "filename": "gcc/testsuite/gcc.target/powerpc/test_fpscr_rn_builtin_error.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_rn_builtin_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_rn_builtin_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_fpscr_rn_builtin_error.c?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+#include <altivec.h>\n+\n+int main ()\n+{\n+\n+  /* Test builin with out of range arguments. Can only test for constant\n+     int arguments.  The builtins __builtin_set_fpscr_rn() also supports a\n+     variable as an argument but can't test variable value at compile time.  */\n+\n+  __builtin_mtfsb0(-1);  /* { dg-error \"Argument must be a constant between 0 and 31\" } */\n+  __builtin_mtfsb0(32);  /* { dg-error \"Argument must be a constant between 0 and 31\" } */\n+\n+  __builtin_mtfsb1(-1);  /* { dg-error \"Argument must be a constant between 0 and 31\" } */\n+  __builtin_mtfsb1(32);  /* { dg-error \"Argument must be a constant between 0 and 31\" } */ \n+\n+  __builtin_set_fpscr_rn(-1);  /* { dg-error \"Argument must be a value between 0 and 3\" } */ \n+  __builtin_set_fpscr_rn(4);   /* { dg-error \"Argument must be a value between 0 and 3\" } */ \n+}\n+"}, {"sha": "278dfbfcefe9ff451c1feb127aa17a15cadbb7b5", "filename": "gcc/testsuite/gcc.target/powerpc/test_mffsl.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_mffsl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2da14663d0dee41a3f90f40704f9063e53a8b247/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_mffsl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ftest_mffsl.c?ref=2da14663d0dee41a3f90f40704f9063e53a8b247", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2 -std=c99\" } */\n+\n+#include <altivec.h>\n+\n+#ifdef DEBUG\n+#include <stdio.h>\n+#endif\n+\n+void abort (void);\n+\n+int main ()\n+{\n+\n+  register double  f14;\n+  union blah {\n+    double d;\n+    unsigned long long ll;\n+  } conv_val;\n+\n+  /* Test reading the FPSCR register.  */\n+  __asm __volatile (\"mffs %0\" : \"=f\"(f14));\n+  conv_val.d = f14;\n+\n+  if (conv_val.d != __builtin_mffsl())\n+    {\n+#ifdef DEBUG\n+      printf(\"ERROR, __builtin_mffsl() returned 0x%llx, not the expecected value 0x%llx\\n\",\n+\t     __builtin_mffsl(), conv_val.d);\n+#else\n+      abort();\n+#endif\n+    }\t\t  \n+}"}]}