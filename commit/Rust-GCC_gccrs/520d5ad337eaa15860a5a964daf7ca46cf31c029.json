{"sha": "520d5ad337eaa15860a5a964daf7ca46cf31c029", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwZDVhZDMzN2VhYTE1ODYwYTVhOTY0ZGFmN2NhNDZjZjMxYzAyOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-14T12:52:36Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-11-14T12:52:36Z"}, "message": "Detect EAF flags in ipa-modref\n\nA minimal patch for the EAF flags discovery.  It works only in local ipa-modref\nand gives up on cyclic SSA graphs.  It improves pt_solution_includes\ndisambiguations twice.\n\ngcc/Changelog:\n\n\t* gimple.c: Include ipa-modref-tree.h and ipa-modref.h.\n\t(gimple_call_arg_flags): Use modref to determine flags.\n\t* ipa-modref.c: Include gimple-ssa.h, tree-phinodes.h,\n\ttree-ssa-operands.h, stringpool.h and tree-ssanames.h.\n\t(analyze_ssa_name_flags): Declare.\n\t(modref_summary::useful_p): Summary is also useful if arg flags are\n\tknown.\n\t(dump_eaf_flags): New function.\n\t(modref_summary::dump): Use it.\n\t(get_modref_function_summary): Be read for current_function_decl\n\tbeing NULL.\n\t(memory_access_to): New function.\n\t(deref_flags): New function.\n\t(call_lhs_flags): New function.\n\t(analyze_parms): New function.\n\t(analyze_function): Use it.\n\t* ipa-modref.h (struct modref_summary): Add arg_flags.\n\t* doc/invoke.texi (ipa-modref-max-depth): Document.\n\t* params.opt (ipa-modref-max-depth): New param.", "tree": {"sha": "9d875db97de3265cd0cffe2a2c000dc3eb7ffa53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d875db97de3265cd0cffe2a2c000dc3eb7ffa53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/520d5ad337eaa15860a5a964daf7ca46cf31c029", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520d5ad337eaa15860a5a964daf7ca46cf31c029", "html_url": "https://github.com/Rust-GCC/gccrs/commit/520d5ad337eaa15860a5a964daf7ca46cf31c029", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/520d5ad337eaa15860a5a964daf7ca46cf31c029/comments", "author": null, "committer": null, "parents": [{"sha": "2873c8af66e1248734bb638a49e6bc53f5e45382", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2873c8af66e1248734bb638a49e6bc53f5e45382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2873c8af66e1248734bb638a49e6bc53f5e45382"}], "stats": {"total": 434, "additions": 414, "deletions": 20}, "files": [{"sha": "b3a2c7ce51d89bbfc3703ed1201ed5255a1fc9d4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=520d5ad337eaa15860a5a964daf7ca46cf31c029", "patch": "@@ -13008,6 +13008,10 @@ memory locations using the mod/ref information.  This parameter ought to be\n bigger than @option{--param ipa-modref-max-bases} and @option{--param\n ipa-modref-max-refs}.\n \n+@item ipa-modref-max-depth\n+Specified the maximum depth of DFS walk used by modref escape analysis.\n+Setting to 0 disables the analysis completely.\n+\n @item profile-func-internal-id\n A parameter to control whether to use function internal id in profile\n database lookup. If the value is 0, the compiler uses an id that"}, {"sha": "e3e508daf2fe9248c7cf17cd6c97b8cfb322d134", "filename": "gcc/gimple.c", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=520d5ad337eaa15860a5a964daf7ca46cf31c029", "patch": "@@ -46,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"asan.h\"\n #include \"langhooks.h\"\n #include \"attr-fnspec.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n \n \n /* All the tuples have their operand vector (if present) at the very bottom\n@@ -1528,24 +1530,45 @@ int\n gimple_call_arg_flags (const gcall *stmt, unsigned arg)\n {\n   attr_fnspec fnspec = gimple_call_fnspec (stmt);\n-\n-  if (!fnspec.known_p ())\n-    return 0;\n-\n   int flags = 0;\n \n-  if (!fnspec.arg_specified_p (arg))\n-    ;\n-  else if (!fnspec.arg_used_p (arg))\n-    flags = EAF_UNUSED;\n-  else\n+  if (fnspec.known_p ())\n     {\n-      if (fnspec.arg_direct_p (arg))\n-\tflags |= EAF_DIRECT;\n-      if (fnspec.arg_noescape_p (arg))\n-\tflags |= EAF_NOESCAPE;\n-      if (fnspec.arg_readonly_p (arg))\n-\tflags |= EAF_NOCLOBBER;\n+      if (!fnspec.arg_specified_p (arg))\n+\t;\n+      else if (!fnspec.arg_used_p (arg))\n+\tflags = EAF_UNUSED;\n+      else\n+\t{\n+\t  if (fnspec.arg_direct_p (arg))\n+\t    flags |= EAF_DIRECT;\n+\t  if (fnspec.arg_noescape_p (arg))\n+\t    flags |= EAF_NOESCAPE;\n+\t  if (fnspec.arg_readonly_p (arg))\n+\t    flags |= EAF_NOCLOBBER;\n+\t}\n+    }\n+  tree callee = gimple_call_fndecl (stmt);\n+  if (callee)\n+    {\n+      cgraph_node *node = cgraph_node::get (callee);\n+      modref_summary *summary = node ? get_modref_function_summary (node)\n+\t\t\t\t: NULL;\n+\n+      if (summary && summary->arg_flags.length () > arg)\n+\t{\n+\t  int modref_flags = summary->arg_flags[arg];\n+\n+\t  /* We have possibly optimized out load.  Be conservative here.  */\n+\t  if (!node->binds_to_current_def_p ())\n+\t    {\n+\t      if ((modref_flags & EAF_UNUSED) && !(flags & EAF_UNUSED))\n+\t\tmodref_flags &= ~EAF_UNUSED;\n+\t      if ((modref_flags & EAF_DIRECT) && !(flags & EAF_DIRECT))\n+\t\tmodref_flags &= ~EAF_DIRECT;\n+\t    }\n+\t  flags |= modref_flags;\n+\t}\n     }\n   return flags;\n }"}, {"sha": "5273c200f00976beeed2f0fea4daa6cd547bcad8", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 367, "deletions": 5, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=520d5ad337eaa15860a5a964daf7ca46cf31c029", "patch": "@@ -61,6 +61,15 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-fnsummary.h\"\n #include \"attr-fnspec.h\"\n #include \"symtab-clones.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-phinodes.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"ssa-iterators.h\"\n+#include \"stringpool.h\"\n+#include \"tree-ssanames.h\"\n+\n+static int analyze_ssa_name_flags (tree name,\n+\t\t\t\t   vec<unsigned char> &known_flags, int depth);\n \n /* We record fnspec specifiers for call edges since they depends on actual\n    gimple statements.  */\n@@ -186,6 +195,8 @@ modref_summary::useful_p (int ecf_flags)\n {\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n     return false;\n+  if (arg_flags.length ())\n+    return true;\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n@@ -355,6 +366,22 @@ dump_lto_records (modref_records_lto *tt, FILE *out)\n     }\n }\n \n+/* Dump EAF flags.  */\n+\n+static void\n+dump_eaf_flags (FILE *out, int flags)\n+{\n+  if (flags & EAF_DIRECT)\n+    fprintf (out, \" direct\");\n+  if (flags & EAF_NOCLOBBER)\n+    fprintf (out, \" noclobber\");\n+  if (flags & EAF_NOESCAPE)\n+    fprintf (out, \" noescape\");\n+  if (flags & EAF_UNUSED)\n+    fprintf (out, \" unused\");\n+  fprintf (out, \"\\n\");\n+}\n+\n /* Dump summary.  */\n \n void\n@@ -372,6 +399,15 @@ modref_summary::dump (FILE *out)\n     }\n   if (writes_errno)\n     fprintf (out, \"  Writes errno\\n\");\n+  if (arg_flags.length ())\n+    {\n+      for (unsigned int i = 0; i < arg_flags.length (); i++)\n+\tif (arg_flags[i])\n+\t  {\n+\t    fprintf (out, \"  parm %i flags:\", i);\n+\t    dump_eaf_flags (out, arg_flags[i]);\n+\t  }\n+    }\n }\n \n /* Dump summary.  */\n@@ -402,7 +438,8 @@ get_modref_function_summary (cgraph_node *func)\n      function.  */\n   enum availability avail;\n   func = func->function_or_virtual_thunk_symbol\n-\t     (&avail, cgraph_node::get (current_function_decl));\n+\t\t (&avail, current_function_decl ?\n+\t\t\t  cgraph_node::get (current_function_decl) : NULL);\n   if (avail <= AVAIL_INTERPOSABLE)\n     return NULL;\n \n@@ -634,7 +671,7 @@ merge_call_side_effects (modref_summary *cur_summary,\n       cur_summary->loads->collapse ();\n     }\n \n-  parm_map.safe_grow_cleared (gimple_call_num_args (stmt));\n+  parm_map.safe_grow_cleared (gimple_call_num_args (stmt), true);\n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n       parm_map[i] = parm_map_for_arg (stmt, i);\n@@ -1067,6 +1104,326 @@ remove_summary (bool lto, bool nolto, bool ipa)\n \t     \" - modref done with result: not tracked.\\n\");\n }\n \n+/* Return true if OP accesses memory pointed to by SSA_NAME.  */\n+\n+bool\n+memory_access_to (tree op, tree ssa_name)\n+{\n+  tree base = get_base_address (op);\n+  if (!base)\n+    return false;\n+  if (TREE_CODE (base) != MEM_REF && TREE_CODE (base) != TARGET_MEM_REF)\n+    return false;\n+  return TREE_OPERAND (base, 0) == ssa_name;\n+}\n+\n+/* Consider statement val = *arg.\n+   return EAF flags of ARG that can be determined from EAF flags of VAL\n+   (which are known to be FLAGS).  If IGNORE_STORES is true we can ignore\n+   all stores to VAL, i.e. when handling noreturn function.  */\n+\n+static int\n+deref_flags (int flags, bool ignore_stores)\n+{\n+  int ret = 0;\n+  if (flags & EAF_UNUSED)\n+    ret |= EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE;\n+  else\n+    {\n+      if ((flags & EAF_NOCLOBBER) || ignore_stores)\n+\tret |= EAF_NOCLOBBER;\n+      if ((flags & EAF_NOESCAPE) || ignore_stores)\n+\tret |= EAF_NOESCAPE;\n+    }\n+  return ret;\n+}\n+\n+/* Call statements may return their parameters.  Consider argument number\n+   ARG of USE_STMT and determine flags that can needs to be cleared\n+   in case pointer possibly indirectly references from ARG I is returned.\n+   KNOWN_FLAGS and DEPTH are same as in analyze_ssa_name_flags.  */\n+\n+static int\n+call_lhs_flags (gcall *call, int arg,\n+\t\tvec<unsigned char> &known_flags, int depth)\n+{\n+  /* If there is no return value, no flags are affected.  */\n+  if (!gimple_call_lhs (call))\n+    return EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+\n+  /* If we know that function returns given argument and it is not ARG\n+     we can still be happy.  */\n+  int flags = gimple_call_return_flags (call);\n+  if ((flags & ERF_RETURNS_ARG)\n+      && (flags & ERF_RETURN_ARG_MASK) != arg)\n+    return EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+\n+  /* If return value is SSA name determine its flags.  */\n+  if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n+    return analyze_ssa_name_flags\n+\t\t       (gimple_call_lhs (call), known_flags,\n+\t\t\tdepth + 1);\n+  /* In the case of memory store we can do nothing.  */\n+  else\n+    return 0;\n+}\n+\n+/* Analyze EAF flags for SSA name NAME.\n+   KNOWN_FLAGS is a cache for flags we already determined.\n+   DEPTH is a recursion depth used to make debug output prettier.  */\n+\n+static int\n+analyze_ssa_name_flags (tree name, vec<unsigned char> &known_flags, int depth)\n+{\n+  imm_use_iterator ui;\n+  gimple *use_stmt;\n+  int flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED;\n+\n+  /* See if value is already computed.  */\n+  if (known_flags[SSA_NAME_VERSION (name)])\n+    {\n+      /* Punt on cycles for now, so we do not need dataflow.  */\n+      if (known_flags[SSA_NAME_VERSION (name)] == 1)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"%*sGiving up on a cycle in SSA graph\\n\", depth * 4, \"\");\n+\t  return 0;\n+\t}\n+      return known_flags[SSA_NAME_VERSION (name)] - 2;\n+    }\n+  if (depth == param_modref_max_depth)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"%*sGiving up on max depth\\n\", depth * 4, \"\");\n+      return 0;\n+    }\n+  /* Recursion guard.  */\n+  known_flags[SSA_NAME_VERSION (name)] = 1;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"%*sAnalyzing flags of ssa name: \", depth * 4, \"\");\n+      print_generic_expr (dump_file, name);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, ui, name)\n+    {\n+      if (flags == 0)\n+\t{\n+\t  BREAK_FROM_IMM_USE_STMT (ui);\n+\t}\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"%*s  Analyzing stmt:\", depth * 4, \"\");\n+\t  print_gimple_stmt (dump_file, use_stmt, 0);\n+\t}\n+\n+      /* Gimple return may load the return value.  */\n+      if (greturn *ret = dyn_cast <greturn *> (use_stmt))\n+\t{\n+\t  if (memory_access_to (gimple_return_retval (ret), name))\n+\t    flags &= ~EAF_UNUSED;\n+\t}\n+      /* Account for LHS store, arg loads and flags from callee function.  */\n+      else if (gcall *call = dyn_cast <gcall *> (use_stmt))\n+\t{\n+\t  tree callee = gimple_call_fndecl (call);\n+\n+\t  /* Recursion would require bit of propagation; give up for now.  */\n+\t  if (callee && recursive_call_p (current_function_decl, callee))\n+\t    flags = 0;\n+\t  else\n+\t    {\n+\t      int ecf_flags = gimple_call_flags (call);\n+\t      bool ignore_stores = ignore_stores_p (current_function_decl,\n+\t\t\t\t\t\t    ecf_flags);\n+\n+\t      /* Handle *name = func (...).  */\n+\t      if (gimple_call_lhs (call)\n+\t\t  && memory_access_to (gimple_call_lhs (call), name))\n+\t\tflags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\n+\t      /* We do not track accesses to the static chain (we could)\n+\t\t so give up.  */\n+\t      if (gimple_call_chain (call)\n+\t\t  && (gimple_call_chain (call) == name))\n+\t\tflags = 0;\n+\n+\t      /* Handle all function parameters.  */\n+\t      for (unsigned i = 0; i < gimple_call_num_args (call); i++)\n+\t\t/* Name is directly passed to the callee.  */\n+\t\tif (gimple_call_arg (call, i) == name)\n+\t\t  {\n+\t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+\t\t      flags &= ignore_stores\n+\t\t\t       ? 0\n+\t\t\t       : call_lhs_flags (call, i, known_flags, depth);\n+\t\t    else\n+\t\t      {\n+\t\t\tint call_flags = gimple_call_arg_flags (call, i);\n+\t\t\tif (ignore_stores)\n+\t\t\t  call_flags |= EAF_NOCLOBBER | EAF_NOESCAPE;\n+\t\t\telse\n+\t\t\t  call_flags &= call_lhs_flags (call, i,\n+\t\t\t\t\t\t\tknown_flags, depth);\n+\n+\t\t\tflags &= call_flags;\n+\t\t      }\n+\t\t  }\n+\t\t/* Name is dereferenced and passed to a callee.  */\n+\t\telse if (memory_access_to (gimple_call_arg (call, i), name))\n+\t\t  {\n+\t\t    if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+\t\t      flags &= ~EAF_UNUSED;\n+\t\t    else\n+\t\t      flags &= deref_flags (gimple_call_arg_flags (call, i),\n+\t\t\t\t\t    ignore_stores);\n+\t\t    if (!ignore_stores)\n+\t\t      flags &= call_lhs_flags (call, i, known_flags, depth);\n+\t\t  }\n+\t    }\n+\t  /* Only NOCLOBBER or DIRECT flags alone are not useful (see comments\n+\t     in tree-ssa-alias.c).  Give up earlier.  */\n+\t  if ((flags & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n+\t    flags = 0;\n+\t}\n+      else if (gimple_assign_load_p (use_stmt))\n+\t{\n+\t  gassign *assign = as_a <gassign *> (use_stmt);\n+\t  /* Memory to memory copy.  */\n+\t  if (gimple_store_p (assign))\n+\t    {\n+\t      /* Handle *name = *exp.  */\n+\t      if (memory_access_to (gimple_assign_lhs (assign), name))\n+\t\tflags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\n+\t      /* Handle *lhs = *name.\n+\n+\t\t We do not track memory locations, so assume that value\n+\t\t is used arbitrarily.  */\n+\t      if (memory_access_to (gimple_assign_rhs1 (assign), name))\n+\t\tflags = 0;\n+\t    }\n+\t  /* Handle lhs = *name.  */\n+\t  else if (memory_access_to (gimple_assign_rhs1 (assign), name))\n+\t    flags &= deref_flags (analyze_ssa_name_flags\n+\t\t\t\t      (gimple_assign_lhs (assign),\n+\t\t\t\t       known_flags, depth + 1), false);\n+\t}\n+      else if (gimple_store_p (use_stmt))\n+\t{\n+\t  gassign *assign = dyn_cast <gassign *> (use_stmt);\n+\n+\t  /* Handle *lhs = name.  */\n+\t  if (assign && gimple_assign_rhs1 (assign) == name)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"%*s  ssa name saved to memory\\n\",\n+\t\t\t depth * 4, \"\");\n+\t      flags = 0;\n+\t    }\n+\t  /* Handle *name = exp.  */\n+\t  else if (assign\n+\t\t   && memory_access_to (gimple_assign_lhs (assign), name))\n+\t    flags &= ~(EAF_UNUSED | EAF_NOCLOBBER);\n+\t  /* ASM statements etc.  */\n+\t  else if (!assign)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"%*s  Unhandled store\\n\",\n+\t\t\t depth * 4, \"\");\n+\t      flags = 0;\n+\t    }\n+\t}\n+      else if (gassign *assign = dyn_cast <gassign *> (use_stmt))\n+\t{\n+\t  enum tree_code code = gimple_assign_rhs_code (assign);\n+\n+\t  /* See if operation is a merge as considered by\n+\t     tree-ssa-structalias.c:find_func_aliases.  */\n+\t  if (!truth_value_p (code)\n+\t      && code != POINTER_DIFF_EXPR\n+\t      && (code != POINTER_PLUS_EXPR\n+\t\t  || gimple_assign_rhs1 (assign) == name))\n+\t    flags &= analyze_ssa_name_flags\n+\t\t\t       (gimple_assign_lhs (assign), known_flags,\n+\t\t\t\tdepth + 1);\n+\t}\n+      else if (gphi *phi = dyn_cast <gphi *> (use_stmt))\n+\t{\n+\t  flags &= analyze_ssa_name_flags\n+\t\t\t     (gimple_phi_result (phi), known_flags,\n+\t\t\t      depth + 1);\n+\t}\n+      /* Conditions are not considered escape points\n+\t by tree-ssa-structalias.  */\n+      else if (gimple_code (use_stmt) == GIMPLE_COND)\n+\t;\n+      else\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"%*s  Unhandled stmt\\n\", depth * 4, \"\");\n+\t  flags = 0;\n+\t}\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"%*s  current flags of \", depth * 4, \"\");\n+\t  print_generic_expr (dump_file, name);\n+\t  dump_eaf_flags (dump_file, flags);\n+\t}\n+    }\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"%*sflags of ssa name \", depth * 4, \"\");\n+      print_generic_expr (dump_file, name);\n+      dump_eaf_flags (dump_file, flags);\n+    }\n+  known_flags[SSA_NAME_VERSION (name)] = flags + 2;\n+  return flags;\n+}\n+\n+/* Determine EAF flags for function parameters.  */\n+\n+static void\n+analyze_parms (modref_summary *summary)\n+{\n+  unsigned int parm_index = 0;\n+  unsigned int count = 0;\n+\n+  for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n+       parm = TREE_CHAIN (parm))\n+    count++;\n+\n+  if (!count)\n+    return;\n+\n+  auto_vec<unsigned char> known_flags;\n+  known_flags.safe_grow_cleared (num_ssa_names, true);\n+\n+  for (tree parm = DECL_ARGUMENTS (current_function_decl); parm; parm_index++,\n+       parm = TREE_CHAIN (parm))\n+    {\n+      tree name = ssa_default_def (cfun, parm);\n+      if (!name)\n+\tcontinue;\n+      int flags = analyze_ssa_name_flags (name, known_flags, 0);\n+\n+      if (flags)\n+\t{\n+\t  if (parm_index >= summary->arg_flags.length ())\n+\t    summary->arg_flags.safe_grow_cleared (count, true);\n+\t  summary->arg_flags[parm_index] = flags;\n+\t}\n+    }\n+}\n+\n /* Analyze function F.  IPA indicates whether we're running in local mode\n    (false) or the IPA mode (true).  */\n \n@@ -1174,6 +1531,10 @@ analyze_function (function *f, bool ipa)\n \t\t\t\t  param_modref_max_accesses);\n       summary_lto->writes_errno = false;\n     }\n+\n+  if (!ipa)\n+    analyze_parms (summary);\n+\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n   auto_vec <gimple *, 32> recursive_calls;\n \n@@ -1191,8 +1552,9 @@ analyze_function (function *f, bool ipa)\n \t      || ((!summary || !summary->useful_p (ecf_flags))\n \t\t  && (!summary_lto || !summary_lto->useful_p (ecf_flags))))\n \t    {\n-\t      remove_summary (lto, nolto, ipa);\n-\t      return;\n+\t      collapse_loads (summary, summary_lto);\n+\t      collapse_stores (summary, summary_lto);\n+\t      break;\n \t    }\n \t}\n     }\n@@ -1959,7 +2321,7 @@ compute_parm_map (cgraph_edge *callee_edge, vec<modref_parm_map> *parm_map)\n \t\t\t\t\t: callee_edge->caller);\n       callee_pi = IPA_NODE_REF (callee);\n \n-      (*parm_map).safe_grow_cleared (count);\n+      (*parm_map).safe_grow_cleared (count, true);\n \n       for (i = 0; i < count; i++)\n \t{"}, {"sha": "59872301cd6642a79ea7f09b572cdc9cd8ec7db5", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=520d5ad337eaa15860a5a964daf7ca46cf31c029", "patch": "@@ -29,6 +29,7 @@ struct GTY(()) modref_summary\n   /* Load and stores in function (transitively closed to all callees)  */\n   modref_records *loads;\n   modref_records *stores;\n+  auto_vec<unsigned char> GTY((skip)) arg_flags;\n \n   modref_summary ();\n   ~modref_summary ();"}, {"sha": "5b00284c1fbb17e63d947dd772daa2f0ac81ae7a", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/520d5ad337eaa15860a5a964daf7ca46cf31c029/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=520d5ad337eaa15860a5a964daf7ca46cf31c029", "patch": "@@ -927,6 +927,10 @@ Maximum number of accesse stored in each modref reference.\n Common Joined UInteger Var(param_modref_max_tests) Init(64)\n Maximum number of tests performed by modref query.\n \n+-param=modref-max-depth=\n+Common Joined UInteger Var(param_modref_max_depth) Init(256)\n+Maximum depth of DFS walk used by modref escape analysis\n+\n -param=tm-max-aggregate-size=\n Common Joined UInteger Var(param_tm_max_aggregate_size) Init(9) Param Optimization\n Size in bytes after which thread-local aggregates should be instrumented with the logging functions instead of save/restore pairs."}]}