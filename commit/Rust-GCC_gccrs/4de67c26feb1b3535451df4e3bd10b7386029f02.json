{"sha": "4de67c26feb1b3535451df4e3bd10b7386029f02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRlNjdjMjZmZWIxYjM1MzU0NTFkZjRlM2JkMTBiNzM4NjAyOWYwMg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2005-06-28T21:55:24Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2005-06-28T21:55:24Z"}, "message": "target.h (invalid_conversion, [...]): New hooks.\n\n\t* target.h (invalid_conversion, invalid_unary_op,\n\tinvalid_binary_op): New hooks.\n\t* target-def.h (TARGET_INVALID_CONVERSION,\n\tTARGET_INVALID_UNARY_OP, TARGET_INVALID_BINARY_OP,\n\tTARGET_INITIALIZER): Likewise.\n\t* hooks.h (hook_constcharptr_tree_tree_null,\n\thook_constcharptr_int_tree_null,\n\thook_constcharptr_int_tree_tree_null): New.\n\t* hooks.c (hook_constcharptr_tree_tree_null,\n\thook_constcharptr_int_tree_null,\n\thook_constcharptr_int_tree_tree_null): Likewise.\n\t* gcc/doc/tm.texi (TARGET_INVALID_CONVERSION,\n\tTARGET_INVALID_UNARY_OP, TARGET_INVALID_BINARY_OP): Document.\n\t* c-convert.c (convert): Use invalid_conversion hook.\n\t* c-typeck.c (build_unary_op): Use invalid_unary_op hook.\n\t(build_binary_op): Use invalid_binary_op hook.\n\t* config/ia64/ia64-modes.def: Define RFmode.\n\t* config/ia64/ia64-protos.h (spill_xfmode_operand): Remove.\n\t(ia64_expand_movxf_movrf): New.\n\t* config/ia64/ia64.md (movxf): Move code to\n\tia64_expand_movxf_movrf.\n\t(movrf, movrf_internal): New.\n\t* ia64.c (ia64_invalid_conversion, ia64_invalid_unary_op,\n\tia64_invalid_binary_op, TARGET_INVALID_CONVERSION,\n\tTARGET_INVALID_UNARY_OP, TARGET_INVALID_BINARY_OP): New.\n\t(spill_xfmode_operand): Rename to spill_xfmode_rfmode_operand.\n\tAdd mode parameter.  Make static.\n\t(ia64_expand_movxf_movrf): New, moved from ia64.md.  Handle RFmode\n\tas well as XFmode.\n\t(ia64_function_arg, ia64_function_value, ia64_register_move_cost,\n\tia64_scalar_mode_supported_p): Handle RFmode as well as XFmode.\n\t(ia64_init_builtins): Set up __fpreg as RFmode.\n\t(ia64_mangle_fundamental_type): Mangle __fpreg as u7__fpreg.\n\ncp:\n\t* cvt.c (ocp_convert): Use invalid_conversion hook.\n\t* typeck.c (build_binary_op): Use invalid_binary_op hook.\n\t(build_unary_op): Use invalid_unary_op hook.\n\ntestsuite:\n\t* g++.dg/ext/fpreg1.C, gcc.target/ia64/fpreg-1.c,\n\tgcc.target/ia64/fpreg-2.c: New tests.\n\nFrom-SVN: r101391", "tree": {"sha": "caf995fd6dda6f4540bef216b200472fdbd03fbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/caf995fd6dda6f4540bef216b200472fdbd03fbc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4de67c26feb1b3535451df4e3bd10b7386029f02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4de67c26feb1b3535451df4e3bd10b7386029f02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4de67c26feb1b3535451df4e3bd10b7386029f02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4de67c26feb1b3535451df4e3bd10b7386029f02/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a75c0b6d2f48f19e5917f7d307a855db58f5b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a75c0b6d2f48f19e5917f7d307a855db58f5b81"}], "stats": {"total": 710, "additions": 578, "deletions": 132}, "files": [{"sha": "cb6775571aef130810b665b08485a0f9db2097e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -1,3 +1,39 @@\n+2005-06-28  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* target.h (invalid_conversion, invalid_unary_op,\n+\tinvalid_binary_op): New hooks.\n+\t* target-def.h (TARGET_INVALID_CONVERSION,\n+\tTARGET_INVALID_UNARY_OP, TARGET_INVALID_BINARY_OP,\n+\tTARGET_INITIALIZER): Likewise.\n+\t* hooks.h (hook_constcharptr_tree_tree_null,\n+\thook_constcharptr_int_tree_null,\n+\thook_constcharptr_int_tree_tree_null): New.\n+\t* hooks.c (hook_constcharptr_tree_tree_null,\n+\thook_constcharptr_int_tree_null,\n+\thook_constcharptr_int_tree_tree_null): Likewise.\n+\t* gcc/doc/tm.texi (TARGET_INVALID_CONVERSION,\n+\tTARGET_INVALID_UNARY_OP, TARGET_INVALID_BINARY_OP): Document.\n+\t* c-convert.c (convert): Use invalid_conversion hook.\n+\t* c-typeck.c (build_unary_op): Use invalid_unary_op hook.\n+\t(build_binary_op): Use invalid_binary_op hook.\n+\t* config/ia64/ia64-modes.def: Define RFmode.\n+\t* config/ia64/ia64-protos.h (spill_xfmode_operand): Remove.\n+\t(ia64_expand_movxf_movrf): New.\n+\t* config/ia64/ia64.md (movxf): Move code to\n+\tia64_expand_movxf_movrf.\n+\t(movrf, movrf_internal): New.\n+\t* ia64.c (ia64_invalid_conversion, ia64_invalid_unary_op,\n+\tia64_invalid_binary_op, TARGET_INVALID_CONVERSION,\n+\tTARGET_INVALID_UNARY_OP, TARGET_INVALID_BINARY_OP): New.\n+\t(spill_xfmode_operand): Rename to spill_xfmode_rfmode_operand.\n+\tAdd mode parameter.  Make static.\n+\t(ia64_expand_movxf_movrf): New, moved from ia64.md.  Handle RFmode\n+\tas well as XFmode.\n+\t(ia64_function_arg, ia64_function_value, ia64_register_move_cost,\n+\tia64_scalar_mode_supported_p): Handle RFmode as well as XFmode.\n+\t(ia64_init_builtins): Set up __fpreg as RFmode.\n+\t(ia64_mangle_fundamental_type): Mangle __fpreg as u7__fpreg.\n+\n 2006-06-28  Adrian Straetling  <straetling@de.ibm.com>\n \n \t* builtins.c: (expand_builtin_memset): Rewrite to support"}, {"sha": "50bb923bae26e1df0fe61a24a1ddce41524db312", "filename": "gcc/c-convert.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"c-tree.h\"\n #include \"langhooks.h\"\n #include \"toplev.h\"\n+#include \"target.h\"\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -69,10 +70,21 @@ convert (tree type, tree expr)\n {\n   tree e = expr;\n   enum tree_code code = TREE_CODE (type);\n+  const char *invalid_conv_diag;\n \n-  if (type == TREE_TYPE (expr)\n-      || TREE_CODE (expr) == ERROR_MARK\n-      || code == ERROR_MARK || TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n+  if (type == error_mark_node\n+      || expr == error_mark_node\n+      || TREE_TYPE (expr) == error_mark_node)\n+    return error_mark_node;\n+\n+  if ((invalid_conv_diag\n+       = targetm.invalid_conversion (TREE_TYPE (expr), type)))\n+    {\n+      error (invalid_conv_diag);\n+      return error_mark_node;\n+    }\n+\n+  if (type == TREE_TYPE (expr))\n     return expr;\n \n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))"}, {"sha": "34f94d14205819b7b159fd7d39da9e5fed0e08ff", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -2501,12 +2501,20 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n   enum tree_code typecode = TREE_CODE (TREE_TYPE (arg));\n   tree val;\n   int noconvert = flag;\n+  const char *invalid_op_diag;\n \n   if (typecode == ERROR_MARK)\n     return error_mark_node;\n   if (typecode == ENUMERAL_TYPE || typecode == BOOLEAN_TYPE)\n     typecode = INTEGER_TYPE;\n \n+  if ((invalid_op_diag\n+       = targetm.invalid_unary_op (code, TREE_TYPE (xarg))))\n+    {\n+      error (invalid_op_diag);\n+      return error_mark_node;\n+    }\n+\n   switch (code)\n     {\n     case CONVERT_EXPR:\n@@ -7397,6 +7405,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   tree type0, type1;\n   enum tree_code code0, code1;\n   tree op0, op1;\n+  const char *invalid_op_diag;\n \n   /* Expression code to give to the expression when it is built.\n      Normally this is CODE, which is what the caller asked for,\n@@ -7472,6 +7481,13 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   if (code0 == ERROR_MARK || code1 == ERROR_MARK)\n     return error_mark_node;\n \n+  if ((invalid_op_diag\n+       = targetm.invalid_binary_op (code, type0, type1)))\n+    {\n+      error (invalid_op_diag);\n+      return error_mark_node;\n+    }\n+\n   objc_ok = objc_compare_types (type0, type1, -3, NULL_TREE);\n \n   switch (code)"}, {"sha": "c7e992777a4512b82df291491249434c46cb46e7", "filename": "gcc/config/ia64/ia64-modes.def", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-modes.def?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -23,9 +23,12 @@ Boston, MA 02110-1301, USA.  */\n /* IA64 requires both XF and TF modes.\n    XFmode is __float80 is IEEE extended; TFmode is __float128\n    is IEEE quad.  Both these modes occupy 16 bytes, but XFmode\n-   only has 80 significant bits.  */\n+   only has 80 significant bits.  RFmode is __fpreg is IA64 internal\n+   register format with 82 significant bits but otherwise handled like\n+   XFmode.  */\n \n FRACTIONAL_FLOAT_MODE (XF, 80, 16, ieee_extended_intel_128_format);\n+FRACTIONAL_FLOAT_MODE (RF, 82, 16, ieee_extended_intel_128_format);\n FLOAT_MODE (TF, 16, ieee_quad_format);\n \n /* The above produces:\n@@ -54,6 +57,12 @@ ADJUST_FLOAT_FORMAT (XF, (TARGET_ILP32 && !TARGET_HPUX)\n ADJUST_BYTESIZE  (XF, (TARGET_ILP32 && !TARGET_HPUX) ? 12 : 16);\n ADJUST_ALIGNMENT (XF, (TARGET_ILP32 && !TARGET_HPUX) ?  4 : 16);\n \n+ADJUST_FLOAT_FORMAT (RF, (TARGET_ILP32 && !TARGET_HPUX)\n+\t\t\t ? &ieee_extended_intel_96_format\n+\t\t\t : &ieee_extended_intel_128_format);\n+ADJUST_BYTESIZE  (RF, (TARGET_ILP32 && !TARGET_HPUX) ? 12 : 16);\n+ADJUST_ALIGNMENT (RF, (TARGET_ILP32 && !TARGET_HPUX) ?  4 : 16);\n+\n ADJUST_ALIGNMENT (TF, (TARGET_ILP32 &&  TARGET_HPUX) ?  8 : 16);\n \n /* 256-bit integer mode is needed for STACK_SAVEAREA_MODE.  */"}, {"sha": "86846495def0a60df8436d3de4677847778869c8", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -45,7 +45,7 @@ extern int addp4_optimize_ok (rtx, rtx);\n extern void ia64_emit_cond_move (rtx, rtx, rtx);\n extern int ia64_depz_field_mask (rtx, rtx);\n extern void ia64_split_tmode_move (rtx[]);\n-extern rtx spill_xfmode_operand (rtx, int);\n+extern bool ia64_expand_movxf_movrf (enum machine_mode, rtx[]);\n extern rtx ia64_expand_compare (enum rtx_code, enum machine_mode);\n extern void ia64_expand_vecint_cmov (rtx[]);\n extern bool ia64_expand_vecint_minmax (enum rtx_code, enum machine_mode, rtx[]);"}, {"sha": "7ebe2938d75ca87052c5bc08f12cc84c9467bca1", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 190, "deletions": 12, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -52,6 +52,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"langhooks.h\"\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n+#include \"intl.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -263,6 +264,9 @@ static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n static bool ia64_cannot_force_const_mem (rtx);\n static const char *ia64_mangle_fundamental_type (tree);\n+static const char *ia64_invalid_conversion (tree, tree);\n+static const char *ia64_invalid_unary_op (int, tree);\n+static const char *ia64_invalid_binary_op (int, tree, tree);\n \f\n /* Table of valid machine attributes.  */\n static const struct attribute_spec ia64_attribute_table[] =\n@@ -433,6 +437,13 @@ static const struct attribute_spec ia64_attribute_table[] =\n #undef TARGET_MANGLE_FUNDAMENTAL_TYPE\n #define TARGET_MANGLE_FUNDAMENTAL_TYPE ia64_mangle_fundamental_type\n \n+#undef TARGET_INVALID_CONVERSION\n+#define TARGET_INVALID_CONVERSION ia64_invalid_conversion\n+#undef TARGET_INVALID_UNARY_OP\n+#define TARGET_INVALID_UNARY_OP ia64_invalid_unary_op\n+#undef TARGET_INVALID_BINARY_OP\n+#define TARGET_INVALID_BINARY_OP ia64_invalid_binary_op\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n typedef enum\n@@ -1285,27 +1296,153 @@ ia64_split_tmode_move (rtx operands[])\n    This solution attempts to prevent this situation from occurring.  When\n    we see something like the above, we spill the inner register to memory.  */\n \n-rtx\n-spill_xfmode_operand (rtx in, int force)\n+static rtx\n+spill_xfmode_rfmode_operand (rtx in, int force, enum machine_mode mode)\n {\n   if (GET_CODE (in) == SUBREG\n       && GET_MODE (SUBREG_REG (in)) == TImode\n       && GET_CODE (SUBREG_REG (in)) == REG)\n     {\n       rtx memt = assign_stack_temp (TImode, 16, 0);\n       emit_move_insn (memt, SUBREG_REG (in));\n-      return adjust_address (memt, XFmode, 0);\n+      return adjust_address (memt, mode, 0);\n     }\n   else if (force && GET_CODE (in) == REG)\n     {\n-      rtx memx = assign_stack_temp (XFmode, 16, 0);\n+      rtx memx = assign_stack_temp (mode, 16, 0);\n       emit_move_insn (memx, in);\n       return memx;\n     }\n   else\n     return in;\n }\n \n+/* Expand the movxf or movrf pattern (MODE says which) with the given\n+   OPERANDS, returning true if the pattern should then invoke\n+   DONE.  */\n+\n+bool\n+ia64_expand_movxf_movrf (enum machine_mode mode, rtx operands[])\n+{\n+  rtx op0 = operands[0];\n+\n+  if (GET_CODE (op0) == SUBREG)\n+    op0 = SUBREG_REG (op0);\n+\n+  /* We must support XFmode loads into general registers for stdarg/vararg,\n+     unprototyped calls, and a rare case where a long double is passed as\n+     an argument after a float HFA fills the FP registers.  We split them into\n+     DImode loads for convenience.  We also need to support XFmode stores\n+     for the last case.  This case does not happen for stdarg/vararg routines,\n+     because we do a block store to memory of unnamed arguments.  */\n+\n+  if (GET_CODE (op0) == REG && GR_REGNO_P (REGNO (op0)))\n+    {\n+      rtx out[2];\n+\n+      /* We're hoping to transform everything that deals with XFmode\n+\t quantities and GR registers early in the compiler.  */\n+      gcc_assert (!no_new_pseudos);\n+\n+      /* Struct to register can just use TImode instead.  */\n+      if ((GET_CODE (operands[1]) == SUBREG\n+\t   && GET_MODE (SUBREG_REG (operands[1])) == TImode)\n+\t  || (GET_CODE (operands[1]) == REG\n+\t      && GR_REGNO_P (REGNO (operands[1]))))\n+\t{\n+\t  rtx op1 = operands[1];\n+\n+\t  if (GET_CODE (op1) == SUBREG)\n+\t    op1 = SUBREG_REG (op1);\n+\t  else\n+\t    op1 = gen_rtx_REG (TImode, REGNO (op1));\n+\n+\t  emit_move_insn (gen_rtx_REG (TImode, REGNO (op0)), op1);\n+\t  return true;\n+\t}\n+\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (op0)),\n+\t\t\t  operand_subword (operands[1], 0, 0, mode));\n+\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (op0) + 1),\n+\t\t\t  operand_subword (operands[1], 1, 0, mode));\n+\t  return true;\n+\t}\n+\n+      /* If the quantity is in a register not known to be GR, spill it.  */\n+      if (register_operand (operands[1], mode))\n+\toperands[1] = spill_xfmode_rfmode_operand (operands[1], 1, mode);\n+\n+      gcc_assert (GET_CODE (operands[1]) == MEM);\n+\n+      out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (op0));\n+      out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (op0) + 1);\n+\n+      emit_move_insn (out[0], adjust_address (operands[1], DImode, 0));\n+      emit_move_insn (out[1], adjust_address (operands[1], DImode, 8));\n+      return true;\n+    }\n+\n+  if (GET_CODE (operands[1]) == REG && GR_REGNO_P (REGNO (operands[1])))\n+    {\n+      /* We're hoping to transform everything that deals with XFmode\n+\t quantities and GR registers early in the compiler.  */\n+      gcc_assert (!no_new_pseudos);\n+\n+      /* Op0 can't be a GR_REG here, as that case is handled above.\n+\t If op0 is a register, then we spill op1, so that we now have a\n+\t MEM operand.  This requires creating an XFmode subreg of a TImode reg\n+\t to force the spill.  */\n+      if (register_operand (operands[0], mode))\n+\t{\n+\t  rtx op1 = gen_rtx_REG (TImode, REGNO (operands[1]));\n+\t  op1 = gen_rtx_SUBREG (mode, op1, 0);\n+\t  operands[1] = spill_xfmode_rfmode_operand (op1, 0, mode);\n+\t}\n+\n+      else\n+\t{\n+\t  rtx in[2];\n+\n+          gcc_assert (GET_CODE (operands[0]) == MEM);\n+\t  in[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[1]));\n+\t  in[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[1]) + 1);\n+\n+\t  emit_move_insn (adjust_address (operands[0], DImode, 0), in[0]);\n+\t  emit_move_insn (adjust_address (operands[0], DImode, 8), in[1]);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (!reload_in_progress && !reload_completed)\n+    {\n+      operands[1] = spill_xfmode_rfmode_operand (operands[1], 0, mode);\n+\n+      if (GET_MODE (op0) == TImode && GET_CODE (op0) == REG)\n+\t{\n+\t  rtx memt, memx, in = operands[1];\n+\t  if (CONSTANT_P (in))\n+\t    in = validize_mem (force_const_mem (mode, in));\n+\t  if (GET_CODE (in) == MEM)\n+\t    memt = adjust_address (in, TImode, 0);\n+\t  else\n+\t    {\n+\t      memt = assign_stack_temp (TImode, 16, 0);\n+\t      memx = adjust_address (memt, mode, 0);\n+\t      emit_move_insn (memx, in);\n+\t    }\n+\t  emit_move_insn (op0, memt);\n+\t  return true;\n+\t}\n+\n+      if (!ia64_move_ok (operands[0], operands[1]))\n+\toperands[1] = force_reg (mode, operands[1]);\n+    }\n+\n+  return false;\n+}\n+\n /* Emit comparison instruction if necessary, returning the expression\n    that holds the compare result in the proper mode.  */\n \n@@ -3839,9 +3976,9 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n                    gen_rtx_EXPR_LIST (VOIDmode,\n \t\t     gen_rtx_REG (DImode, basereg + cum->words + offset),\n \t\t\t\t      const0_rtx)));\n-      /* Similarly, an anonymous XFmode value must be split into two\n-\t registers and padded appropriately.  */\n-      else if (BYTES_BIG_ENDIAN && mode == XFmode)\n+      /* Similarly, an anonymous XFmode or RFmode value must be split\n+\t into two registers and padded appropriately.  */\n+      else if (BYTES_BIG_ENDIAN && (mode == XFmode || mode == RFmode))\n \t{\n \t  rtx loc[2];\n \t  loc[0] = gen_rtx_EXPR_LIST (VOIDmode,\n@@ -4159,7 +4296,7 @@ ia64_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n \t the middle-end will give it XFmode anyway, and XFmode values\n \t don't normally fit in integer registers.  So we need to smuggle\n \t the value inside a parallel.  */\n-      else if (mode == XFmode || mode == XCmode)\n+      else if (mode == XFmode || mode == XCmode || mode == RFmode)\n \tneed_parallel = true;\n \n       if (need_parallel)\n@@ -4574,7 +4711,7 @@ ia64_register_move_cost (enum machine_mode mode, enum reg_class from,\n      so that we get secondary memory reloads.  Between FR_REGS,\n      we have to make this at least as expensive as MEMORY_MOVE_COST\n      to avoid spectacularly poor register class preferencing.  */\n-  if (mode == XFmode)\n+  if (mode == XFmode || mode == RFmode)\n     {\n       if (to != GR_REGS || from != GR_REGS)\n         return MEMORY_MOVE_COST (mode, to, 0);\n@@ -8058,9 +8195,7 @@ ia64_init_builtins (void)\n \n   /* The __fpreg type.  */\n   fpreg_type = make_node (REAL_TYPE);\n-  /* ??? The back end should know to load/save __fpreg variables using\n-     the ldf.fill and stf.spill instructions.  */\n-  TYPE_PRECISION (fpreg_type) = 80;\n+  TYPE_PRECISION (fpreg_type) = 82;\n   layout_type (fpreg_type);\n   (*lang_hooks.types.register_builtin_type) (fpreg_type, \"__fpreg\");\n \n@@ -8549,6 +8684,7 @@ ia64_scalar_mode_supported_p (enum machine_mode mode)\n     case SFmode:\n     case DFmode:\n     case XFmode:\n+    case RFmode:\n       return true;\n \n     case TFmode:\n@@ -8659,6 +8795,48 @@ ia64_mangle_fundamental_type (tree type)\n      double is 80 bits.  */\n   if (TYPE_MODE (type) == XFmode)\n     return TARGET_HPUX ? \"u9__float80\" : \"e\";\n+  if (TYPE_MODE (type) == RFmode)\n+    return \"u7__fpreg\";\n+  return NULL;\n+}\n+\n+/* Return the diagnostic message string if conversion from FROMTYPE to\n+   TOTYPE is not allowed, NULL otherwise.  */\n+static const char *\n+ia64_invalid_conversion (tree fromtype, tree totype)\n+{\n+  /* Reject nontrivial conversion to or from __fpreg.  */\n+  if (TYPE_MODE (fromtype) == RFmode\n+      && TYPE_MODE (totype) != RFmode\n+      && TYPE_MODE (totype) != VOIDmode)\n+    return N_(\"invalid conversion from %<__fpreg%>\");\n+  if (TYPE_MODE (totype) == RFmode\n+      && TYPE_MODE (fromtype) != RFmode)\n+    return N_(\"invalid conversion to %<__fpreg%>\");\n+  return NULL;\n+}\n+\n+/* Return the diagnostic message string if the unary operation OP is\n+   not permitted on TYPE, NULL otherwise.  */\n+static const char *\n+ia64_invalid_unary_op (int op, tree type)\n+{\n+  /* Reject operations on __fpreg other than unary + or &.  */\n+  if (TYPE_MODE (type) == RFmode\n+      && op != CONVERT_EXPR\n+      && op != ADDR_EXPR)\n+    return N_(\"invalid operation on %<__fpreg%>\");\n+  return NULL;\n+}\n+\n+/* Return the diagnostic message string if the binary operation OP is\n+   not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n+static const char *\n+ia64_invalid_binary_op (int op ATTRIBUTE_UNUSED, tree type1, tree type2)\n+{\n+  /* Reject operations on __fpreg.  */\n+  if (TYPE_MODE (type1) == RFmode || TYPE_MODE (type2) == RFmode)\n+    return N_(\"invalid operation on %<__fpreg%>\");\n   return NULL;\n }\n "}, {"sha": "18e6cb3ace6445481f629c67bac81daeadc245b5", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 22, "deletions": 115, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -736,121 +736,8 @@\n \t(match_operand:XF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n-  rtx op0 = operands[0];\n-\n-  if (GET_CODE (op0) == SUBREG)\n-    op0 = SUBREG_REG (op0);\n-\n-  /* We must support XFmode loads into general registers for stdarg/vararg,\n-     unprototyped calls, and a rare case where a long double is passed as\n-     an argument after a float HFA fills the FP registers.  We split them into\n-     DImode loads for convenience.  We also need to support XFmode stores\n-     for the last case.  This case does not happen for stdarg/vararg routines,\n-     because we do a block store to memory of unnamed arguments.  */\n-\n-  if (GET_CODE (op0) == REG && GR_REGNO_P (REGNO (op0)))\n-    {\n-      rtx out[2];\n-\n-      /* We're hoping to transform everything that deals with XFmode\n-\t quantities and GR registers early in the compiler.  */\n-      gcc_assert (!no_new_pseudos);\n-\n-      /* Struct to register can just use TImode instead.  */\n-      if ((GET_CODE (operands[1]) == SUBREG\n-\t   && GET_MODE (SUBREG_REG (operands[1])) == TImode)\n-\t  || (GET_CODE (operands[1]) == REG\n-\t      && GR_REGNO_P (REGNO (operands[1]))))\n-\t{\n-\t  rtx op1 = operands[1];\n-\n-\t  if (GET_CODE (op1) == SUBREG)\n-\t    op1 = SUBREG_REG (op1);\n-\t  else\n-\t    op1 = gen_rtx_REG (TImode, REGNO (op1));\n-\n-\t  emit_move_insn (gen_rtx_REG (TImode, REGNO (op0)), op1);\n-\t  DONE;\n-\t}\n-\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t{\n-\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (op0)),\n-\t\t\t  operand_subword (operands[1], 0, 0, XFmode));\n-\t  emit_move_insn (gen_rtx_REG (DImode, REGNO (op0) + 1),\n-\t\t\t  operand_subword (operands[1], 1, 0, XFmode));\n-\t  DONE;\n-\t}\n-\n-      /* If the quantity is in a register not known to be GR, spill it.  */\n-      if (register_operand (operands[1], XFmode))\n-\toperands[1] = spill_xfmode_operand (operands[1], 1);\n-\n-      gcc_assert (GET_CODE (operands[1]) == MEM);\n-\n-      out[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (op0));\n-      out[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (op0) + 1);\n-\n-      emit_move_insn (out[0], adjust_address (operands[1], DImode, 0));\n-      emit_move_insn (out[1], adjust_address (operands[1], DImode, 8));\n-      DONE;\n-    }\n-\n-  if (GET_CODE (operands[1]) == REG && GR_REGNO_P (REGNO (operands[1])))\n-    {\n-      /* We're hoping to transform everything that deals with XFmode\n-\t quantities and GR registers early in the compiler.  */\n-      gcc_assert (!no_new_pseudos);\n-\n-      /* Op0 can't be a GR_REG here, as that case is handled above.\n-\t If op0 is a register, then we spill op1, so that we now have a\n-\t MEM operand.  This requires creating an XFmode subreg of a TImode reg\n-\t to force the spill.  */\n-      if (register_operand (operands[0], XFmode))\n-\t{\n-\t  rtx op1 = gen_rtx_REG (TImode, REGNO (operands[1]));\n-\t  op1 = gen_rtx_SUBREG (XFmode, op1, 0);\n-\t  operands[1] = spill_xfmode_operand (op1, 0);\n-\t}\n-\n-      else\n-\t{\n-\t  rtx in[2];\n-\n-          gcc_assert (GET_CODE (operands[0]) == MEM);\n-\t  in[WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[1]));\n-\t  in[!WORDS_BIG_ENDIAN] = gen_rtx_REG (DImode, REGNO (operands[1]) + 1);\n-\n-\t  emit_move_insn (adjust_address (operands[0], DImode, 0), in[0]);\n-\t  emit_move_insn (adjust_address (operands[0], DImode, 8), in[1]);\n-\t  DONE;\n-\t}\n-    }\n-\n-  if (! reload_in_progress && ! reload_completed)\n-    {\n-      operands[1] = spill_xfmode_operand (operands[1], 0);\n-\n-      if (GET_MODE (op0) == TImode && GET_CODE (op0) == REG)\n-\t{\n-\t  rtx memt, memx, in = operands[1];\n-\t  if (CONSTANT_P (in))\n-\t    in = validize_mem (force_const_mem (XFmode, in));\n-\t  if (GET_CODE (in) == MEM)\n-\t    memt = adjust_address (in, TImode, 0);\n-\t  else\n-\t    {\n-\t      memt = assign_stack_temp (TImode, 16, 0);\n-\t      memx = adjust_address (memt, XFmode, 0);\n-\t      emit_move_insn (memx, in);\n-\t    }\n-\t  emit_move_insn (op0, memt);\n-\t  DONE;\n-\t}\n-\n-      if (! ia64_move_ok (operands[0], operands[1]))\n-\toperands[1] = force_reg (XFmode, operands[1]);\n-    }\n+  if (ia64_expand_movxf_movrf (XFmode, operands))\n+    DONE;\n })\n \n ;; ??? There's no easy way to mind volatile acquire/release semantics.\n@@ -865,6 +752,26 @@\n    stfe %0 = %F1%P0\"\n   [(set_attr \"itanium_class\" \"fmisc,fld,stf\")])\n \n+;; Same as for movxf, but for RFmode.\n+(define_expand \"movrf\"\n+  [(set (match_operand:RF 0 \"general_operand\" \"\")\n+\t(match_operand:RF 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (ia64_expand_movxf_movrf (RFmode, operands))\n+    DONE;\n+})\n+\n+(define_insn \"*movrf_internal\"\n+  [(set (match_operand:RF 0 \"destination_operand\" \"=f,f, m\")\n+\t(match_operand:RF 1 \"general_operand\"     \"fG,m,fG\"))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"@\n+   mov %0 = %F1\n+   ldf.fill %0 = %1%P1\n+   stf.spill %0 = %F1%P0\"\n+  [(set_attr \"itanium_class\" \"fmisc,fld,stf\")])\n+\n ;; Better code generation via insns that deal with TFmode register pairs\n ;; directly.  Same concerns apply as for TImode.\n (define_expand \"movtf\""}, {"sha": "a9736222b8741b984828be5e200165b85cb40605", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -1,3 +1,9 @@\n+2005-06-28  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* cvt.c (ocp_convert): Use invalid_conversion hook.\n+\t* typeck.c (build_binary_op): Use invalid_binary_op hook.\n+\t(build_unary_op): Use invalid_unary_op hook.\n+\n 2005-06-28  Paul Brook  <paul@codesourcery.com>\n \n \t* Make-lang.in (cp/except.o): Depend on $(TARGET_H)"}, {"sha": "de0792aca47ef470b17076ea5576e1b95e66f5e4", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -36,6 +36,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"convert.h\"\n #include \"toplev.h\"\n #include \"decl.h\"\n+#include \"target.h\"\n \n static tree cp_convert_to_pointer (tree, tree, bool);\n static tree convert_to_pointer_force (tree, tree);\n@@ -601,13 +602,21 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n {\n   tree e = expr;\n   enum tree_code code = TREE_CODE (type);\n+  const char *invalid_conv_diag;\n \n   if (error_operand_p (e) || type == error_mark_node)\n     return error_mark_node;\n \n   complete_type (type);\n   complete_type (TREE_TYPE (expr));\n \n+  if ((invalid_conv_diag\n+       = targetm.invalid_conversion (TREE_TYPE (expr), type)))\n+    {\n+      error (invalid_conv_diag);\n+      return error_mark_node;\n+    }\n+\n   e = integral_constant_value (e);\n \n   if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP)"}, {"sha": "32d3f0439d5dfde55f10bf7c7f66a658d3044d77", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -2736,6 +2736,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   tree op0, op1;\n   enum tree_code code0, code1;\n   tree type0, type1;\n+  const char *invalid_op_diag;\n \n   /* Expression code to give to the expression when it is built.\n      Normally this is CODE, which is what the caller asked for,\n@@ -2845,6 +2846,13 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   if (code0 == ERROR_MARK || code1 == ERROR_MARK)\n     return error_mark_node;\n \n+  if ((invalid_op_diag\n+       = targetm.invalid_binary_op (code, type0, type1)))\n+    {\n+      error (invalid_op_diag);\n+      return error_mark_node;\n+    }\n+\n   switch (code)\n     {\n     case PLUS_EXPR:\n@@ -3725,10 +3733,21 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n   tree argtype = 0;\n   const char *errstring = NULL;\n   tree val;\n+  const char *invalid_op_diag;\n \n   if (arg == error_mark_node)\n     return error_mark_node;\n \n+  if ((invalid_op_diag\n+       = targetm.invalid_unary_op ((code == UNARY_PLUS_EXPR\n+\t\t\t\t    ? CONVERT_EXPR\n+\t\t\t\t    : code),\n+\t\t\t\t   TREE_TYPE (xarg))))\n+    {\n+      error (invalid_op_diag);\n+      return error_mark_node;\n+    }\n+\n   switch (code)\n     {\n     case UNARY_PLUS_EXPR:"}, {"sha": "dca9ad6345928eb0cbe01f63e860767e8f4fdaa6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -9606,6 +9606,26 @@ illegal to pass argument @var{val} to function @var{funcdecl}\n with prototype @var{typelist}.\n @end deftypefn\n \n+@deftypefn {Target Hook} {const char *} TARGET_INVALID_CONVERSION (tree @var{fromtype}, tree @var{totype})\n+If defined, this macro returns the diagnostic message when it is\n+invalid to convert from @var{fromtype} to @var{totype}, or @code{NULL}\n+if validity should be determined by the front end.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {const char *} TARGET_INVALID_UNARY_OP (int @var{op}, tree @var{type})\n+If defined, this macro returns the diagnostic message when it is\n+invalid to apply operation @var{op} (where unary plus is denoted by\n+@code{CONVERT_EXPR}) to an operand of type @var{type}, or @code{NULL}\n+if validity should be determined by the front end.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} {const char *} TARGET_INVALID_BINARY_OP (int @var{op}, tree @var{type1}, tree @var{type2})\n+If defined, this macro returns the diagnostic message when it is\n+invalid to apply operation @var{op} to operands of types @var{type1}\n+and @var{type2}, or @code{NULL} if validity should be determined by\n+the front end.\n+@end deftypefn\n+\n @defmac TARGET_USE_JCR_SECTION\n This macro determines whether to use the JCR section to register Java\n classes. By default, TARGET_USE_JCR_SECTION is defined to 1 if both"}, {"sha": "78871a47858b83c2157b7fb9fa61d8f78056e800", "filename": "gcc/hooks.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -256,3 +256,25 @@ hook_constcharptr_rtx_null (rtx r ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }\n+\n+const char *\n+hook_constcharptr_tree_tree_null (tree t0 ATTRIBUTE_UNUSED,\n+\t\t\t\t  tree t1 ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n+const char *\n+hook_constcharptr_int_tree_null (int i ATTRIBUTE_UNUSED,\n+\t\t\t\t tree t0 ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}\n+\n+const char *\n+hook_constcharptr_int_tree_tree_null (int i ATTRIBUTE_UNUSED,\n+\t\t\t\t      tree t0 ATTRIBUTE_UNUSED,\n+\t\t\t\t      tree t1 ATTRIBUTE_UNUSED)\n+{\n+  return NULL;\n+}"}, {"sha": "eebda9a41fda0897ef46037a803bf14dba86ffe8", "filename": "gcc/hooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -66,4 +66,7 @@ extern tree hook_tree_tree_tree_tree_3rd_identity (tree, tree, tree);\n extern const char *hook_constcharptr_tree_null (tree);\n extern tree hook_tree_tree_tree_bool_null (tree, tree, bool);\n extern const char *hook_constcharptr_rtx_null (rtx);\n+extern const char *hook_constcharptr_tree_tree_null (tree, tree);\n+extern const char *hook_constcharptr_int_tree_null (int, tree);\n+extern const char *hook_constcharptr_int_tree_tree_null (int, tree, tree);\n #endif"}, {"sha": "447b5c3cd92e1455f70d1f44cb1e39ee0c3542e4", "filename": "gcc/target-def.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -379,6 +379,10 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n #define TARGET_INVALID_ARG_FOR_UNPROTOTYPED_FN hook_invalid_arg_for_unprototyped_fn\n #endif\n \n+#define TARGET_INVALID_CONVERSION hook_constcharptr_tree_tree_null\n+#define TARGET_INVALID_UNARY_OP hook_constcharptr_int_tree_null\n+#define TARGET_INVALID_BINARY_OP hook_constcharptr_int_tree_tree_null\n+\n #define TARGET_FIXED_CONDITION_CODE_REGS hook_bool_uintp_uintp_false\n \n #define TARGET_CC_MODES_COMPATIBLE default_cc_modes_compatible\n@@ -581,6 +585,9 @@ Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n   TARGET_STACK_PROTECT_FAIL,\t\t\t\\\n   TARGET_INVALID_WITHIN_DOLOOP,\t\t\t\\\n   TARGET_CALLS,\t\t\t\t\t\\\n+  TARGET_INVALID_CONVERSION,\t\t\t\\\n+  TARGET_INVALID_UNARY_OP,\t\t\t\\\n+  TARGET_INVALID_BINARY_OP,\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n   TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "65e50caef29841ee28001fc5bd4dc1115d0d782b", "filename": "gcc/target.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -598,6 +598,18 @@ struct gcc_target\n \t\t\t\t\t     \t    tree funcdecl, tree val);\n   } calls;\n \n+  /* Return the diagnostic message string if conversion from FROMTYPE\n+     to TOTYPE is not allowed, NULL otherwise.  */\n+  const char *(*invalid_conversion) (tree fromtype, tree totype);\n+\n+  /* Return the diagnostic message string if the unary operation OP is\n+     not permitted on TYPE, NULL otherwise.  */\n+  const char *(*invalid_unary_op) (int op, tree type);\n+\n+  /* Return the diagnostic message string if the binary operation OP\n+     is not permitted on TYPE1 and TYPE2, NULL otherwise.  */\n+  const char *(*invalid_binary_op) (int op, tree type1, tree type2);\n+\n   /* Functions specific to the C++ frontend.  */\n   struct cxx {\n     /* Return the integer type used for guard variables.  */"}, {"sha": "1794a3bd2688af891be9cd52c7467f541d233bb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -1,3 +1,8 @@\n+2005-06-28  Joseph S. Myers  <joseph@codesourcery.com>\n+\n+\t* g++.dg/ext/fpreg1.C, gcc.target/ia64/fpreg-1.c,\n+\tgcc.target/ia64/fpreg-2.c: New tests.\n+\n 2005-06-28  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* gfortran.dg/dev_null.f90: Run test only on linux and solaris."}, {"sha": "72b81134fb8cc1ddcd0f306e279bc630e0dbac4f", "filename": "gcc/testsuite/g++.dg/ext/fpreg1.C", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ffpreg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ffpreg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ffpreg1.C?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -0,0 +1,82 @@\n+// Test permitted and invalid uses of __fpreg, for C++.\n+// Origin: Joseph Myers <joseph@codesourcery.com>\n+// { dg-do compile { target ia64-*-* } }\n+// { dg-options \"\" }\n+\n+__float80 f80;\n+double d;\n+// Default initialized __fpreg is OK.\n+__fpreg fpreg, fpreg2;\n+// But explicitly zero-initialized is an invalid conversion.\n+__fpreg fi = 0; // { dg-error \"error: invalid conversion to '__fpreg'\" }\n+\n+__fpreg f0 (__fpreg);\n+int f1 (__float80);\n+\n+// __fpreg in a structure is OK.\n+struct s {\n+  __float80 b;\n+  __fpreg a;\n+} x;\n+\n+void\n+f (void)\n+{\n+  __fpreg *p;\n+  // Valid operations.\n+  fpreg = fpreg2;\n+  fpreg2 = (__fpreg) fpreg;\n+  fpreg = f0 (fpreg2);\n+  fpreg = +fpreg2;\n+  p = &fpreg;\n+  (void) fpreg;\n+  fpreg = x.a;\n+  fpreg2 = (struct s) { 0 }.a;\n+  fpreg = (d ? fpreg : fpreg2);\n+  d = sizeof (fpreg);\n+  (void)(fpreg, fpreg);\n+  // Invalid operations.\n+  ++fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  --fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg++; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg--; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = -fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = ~fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = !fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = *fpreg; // { dg-error \"error: invalid type argument\" }\n+  if (fpreg) // { dg-error \"error: invalid conversion from '__fpreg'\" }\n+    return;\n+  d = fpreg; // { dg-error \"error: invalid conversion from '__fpreg'\" }\n+  d = (double) fpreg; // { dg-error \"error: invalid conversion from '__fpreg'\" }\n+  fpreg = (__fpreg) d; // { dg-error \"error: invalid conversion to '__fpreg'\" }\n+  fpreg = fpreg * fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = fpreg / fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = fpreg % fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = fpreg + fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = fpreg - fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = fpreg << fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  fpreg = fpreg >> fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg < fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg > fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg <= fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg >= fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg == fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg != fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg & fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg ^ fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg | fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg && fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = fpreg || fpreg; // { dg-error \"error: invalid operation on '__fpreg'\" }\n+  d = (fpreg ? 1 : 2); // { dg-error \"error: invalid conversion from '__fpreg'\" }\n+  fpreg = (d ? fpreg : d); // { dg-error \"error: invalid conversion to '__fpreg'\" }\n+  fpreg *= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg /= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg %= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg += fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg -= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg <<= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg >>= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg &= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg ^= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+  fpreg |= fpreg; // { dg-error \"error: invalid operation on '__fpreg'|in evaluation\" }\n+}"}, {"sha": "022fb94461ec5357b4ce8e6a73f97b1240ca1ac5", "filename": "gcc/testsuite/gcc.target/ia64/fpreg-1.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Ffpreg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Ffpreg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Ffpreg-1.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -0,0 +1,82 @@\n+/* Test permitted and invalid uses of __fpreg.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+__float80 f80;\n+double d;\n+/* Default initialized __fpreg is OK.  */\n+__fpreg fpreg, fpreg2;\n+/* But explicitly zero-initialized is an invalid conversion.  */\n+__fpreg fi = 0; /* { dg-error \"error: invalid conversion to '__fpreg'\" } */\n+\n+__fpreg f0 (__fpreg);\n+int f1 (__float80);\n+\n+/* __fpreg in a structure is OK.  */\n+struct s {\n+  __float80 b;\n+  __fpreg a;\n+} x;\n+\n+void\n+f (void)\n+{\n+  __fpreg *p;\n+  /* Valid operations.  */\n+  fpreg = fpreg2;\n+  fpreg2 = (__fpreg) fpreg;\n+  fpreg = f0 (fpreg2);\n+  fpreg = +fpreg2;\n+  p = &fpreg;\n+  (void) fpreg;\n+  fpreg = x.a;\n+  fpreg2 = (struct s) { 0 }.a;\n+  fpreg = (d ? fpreg : fpreg2);\n+  d = sizeof (fpreg);\n+  (void)(fpreg, fpreg);\n+  /* Invalid operations.  */\n+  ++fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  --fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg++; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg--; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = -fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = ~fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = !fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = *fpreg; /* { dg-error \"error: invalid type argument\" } */\n+  if (fpreg) /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+    return;\n+  d = fpreg; /* { dg-error \"error: invalid conversion from '__fpreg'\" } */\n+  d = (double) fpreg; /* { dg-error \"error: invalid conversion from '__fpreg'\" } */\n+  fpreg = (__fpreg) d; /* { dg-error \"error: invalid conversion to '__fpreg'\" } */\n+  fpreg = fpreg * fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = fpreg / fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = fpreg % fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = fpreg + fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = fpreg - fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = fpreg << fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = fpreg >> fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg < fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg > fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg <= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg >= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg == fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg != fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg & fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg ^ fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg | fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg && fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = fpreg || fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  d = (fpreg ? 1 : 2); /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg = (d ? fpreg : d); /* { dg-error \"error: invalid conversion to '__fpreg'\" } */\n+  fpreg *= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg /= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg %= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg += fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg -= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg <<= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg >>= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg &= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg ^= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+  fpreg |= fpreg; /* { dg-error \"error: invalid operation on '__fpreg'\" } */\n+}"}, {"sha": "a21bd0fb23168efd9993773b6f8fb8a2afd2f3a9", "filename": "gcc/testsuite/gcc.target/ia64/fpreg-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Ffpreg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de67c26feb1b3535451df4e3bd10b7386029f02/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Ffpreg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fia64%2Ffpreg-2.c?ref=4de67c26feb1b3535451df4e3bd10b7386029f02", "patch": "@@ -0,0 +1,21 @@\n+/* Test __fpreg ABI.  */\n+/* Origin: Joseph Myers <joseph@codesourcery.com> */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-final { scan-assembler \"ldf.fill\" } } */\n+/* { dg-final { scan-assembler \"stf.spill\" } } */\n+\n+__fpreg x;\n+\n+void f (void);\n+\n+void\n+g (void)\n+{\n+  __fpreg b = x;\n+  f ();\n+  x = b;\n+}\n+\n+char t1[(sizeof (__fpreg) == sizeof (__float80) ? 1 : -1)];\n+char t2[(__alignof (__fpreg) == __alignof (__float80) ? 1 : -1)];"}]}