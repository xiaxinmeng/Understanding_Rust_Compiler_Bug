{"sha": "6da794e83532c526345040d6251acf12147d4231", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRhNzk0ZTgzNTMyYzUyNjM0NTA0MGQ2MjUxYWNmMTIxNDdkNDIzMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2002-03-15T18:31:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2002-03-15T18:31:55Z"}, "message": "re PR c++/5857 (C++ duplicate_decls shouldn't use common_type)\n\n        PR c++/5857\n        * decl.c (duplicate_decls): Use merge_types instead of common_type.\n        * typeck.c (common_type): Just hand off to\n        type_after_usual_arithmetic_conversions and\n        composite_pointer_type.\n        (merge_types): New fn.\n        (commonparms): Use it instead of common_type.\n        (type_after_usual_arithmetic_conversions): Also handle COMPLEX_TYPE.\n        (composite_pointer_type): Also handle attributes.\n        * cp-tree.h: Declare merge_types.\n\nFrom-SVN: r50820", "tree": {"sha": "5bf7381d37be615ff3e1be31fe56f3a90cad3f02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bf7381d37be615ff3e1be31fe56f3a90cad3f02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6da794e83532c526345040d6251acf12147d4231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da794e83532c526345040d6251acf12147d4231", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6da794e83532c526345040d6251acf12147d4231", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6da794e83532c526345040d6251acf12147d4231/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3b77addd069e3f4010f482942af55b2a8c0e9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b77addd069e3f4010f482942af55b2a8c0e9c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b77addd069e3f4010f482942af55b2a8c0e9c5"}], "stats": {"total": 286, "additions": 129, "deletions": 157}, "files": [{"sha": "111edcc283a2adbfa73626f7709980c08a45bf40", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6da794e83532c526345040d6251acf12147d4231", "patch": "@@ -1,5 +1,16 @@\n 2002-03-15  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/5857\n+\t* decl.c (duplicate_decls): Use merge_types instead of common_type.\n+\t* typeck.c (common_type): Just hand off to\n+\ttype_after_usual_arithmetic_conversions and\n+\tcomposite_pointer_type.\n+\t(merge_types): New fn.\n+\t(commonparms): Use it instead of common_type.\n+\t(type_after_usual_arithmetic_conversions): Also handle COMPLEX_TYPE.\n+\t(composite_pointer_type): Also handle attributes.\n+\t* cp-tree.h: Declare merge_types.\n+\n \t* decl.c (make_rtl_for_nonlocal_decl): Also defer COMDAT\n \tvariables.\n \t* decl2.c (maybe_make_one_only): Also mark the decl as needed."}, {"sha": "5f58ef66ca5f2b6fd05fa1baef874359c323ce50", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6da794e83532c526345040d6251acf12147d4231", "patch": "@@ -4355,6 +4355,7 @@ extern tree pfn_from_ptrmemfunc                 PARAMS ((tree));\n extern tree type_after_usual_arithmetic_conversions PARAMS ((tree, tree));\n extern tree composite_pointer_type              PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t       const char*));\n+extern tree merge_types\t\t\t\tPARAMS ((tree, tree));\n extern tree check_return_expr                   PARAMS ((tree));\n #define cp_build_binary_op(code, arg1, arg2) \\\n   build_binary_op(code, arg1, arg2, 1)"}, {"sha": "d76c6a5c49041bf106cabeaad5d42fdc68b21c51", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6da794e83532c526345040d6251acf12147d4231", "patch": "@@ -3515,16 +3515,16 @@ duplicate_decls (newdecl, olddecl)\n       tree newtype;\n \n       /* Merge the data types specified in the two decls.  */\n-      newtype = common_type (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n+      newtype = merge_types (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n \n-      /* If common_type produces a non-typedef type, just use the old type.  */\n+      /* If merge_types produces a non-typedef type, just use the old type.  */\n       if (TREE_CODE (newdecl) == TYPE_DECL\n \t  && newtype == DECL_ORIGINAL_TYPE (newdecl))\n \tnewtype = oldtype;\n \n       if (TREE_CODE (newdecl) == VAR_DECL)\n \tDECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);\n-      /* Do this after calling `common_type' so that default\n+      /* Do this after calling `merge_types' so that default\n \t parameters don't confuse us.  */\n       else if (TREE_CODE (newdecl) == FUNCTION_DECL\n \t  && (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (newdecl))"}, {"sha": "a8a424a7b59a2a5ff0378b5f2a013da386f8f8b4", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 104, "deletions": 154, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da794e83532c526345040d6251acf12147d4231/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6da794e83532c526345040d6251acf12147d4231", "patch": "@@ -285,7 +285,7 @@ commonparms (p1, p2)\n       if (TREE_VALUE (p1) != TREE_VALUE (p2))\n \t{\n \t  any_change = 1;\n-\t  TREE_VALUE (n) = common_type (TREE_VALUE (p1), TREE_VALUE (p2));\n+\t  TREE_VALUE (n) = merge_types (TREE_VALUE (p1), TREE_VALUE (p2));\n \t}\n       else\n \tTREE_VALUE (n) = TREE_VALUE (p1);\n@@ -330,16 +330,38 @@ type_after_usual_arithmetic_conversions (t1, t2)\n \n   /* FIXME: Attributes.  */\n   my_friendly_assert (ARITHMETIC_TYPE_P (t1) \n+\t\t      || TREE_CODE (t1) == COMPLEX_TYPE\n \t\t      || TREE_CODE (t1) == ENUMERAL_TYPE,\n \t\t      19990725);\n   my_friendly_assert (ARITHMETIC_TYPE_P (t2) \n+\t\t      || TREE_CODE (t2) == COMPLEX_TYPE\n \t\t      || TREE_CODE (t2) == ENUMERAL_TYPE,\n \t\t      19990725);\n \n-  /* In what follows, we slightly generalize the rules given in [expr]\n-     so as to deal with `long long'.  First, merge the attributes.  */\n+  /* In what follows, we slightly generalize the rules given in [expr] so\n+     as to deal with `long long' and `complex'.  First, merge the\n+     attributes.  */\n   attributes = (*targetm.merge_type_attributes) (t1, t2);\n \n+  /* If one type is complex, form the common type of the non-complex\n+     components, then make that complex.  Use T1 or T2 if it is the\n+     required type.  */\n+  if (code1 == COMPLEX_TYPE || code2 == COMPLEX_TYPE)\n+    {\n+      tree subtype1 = code1 == COMPLEX_TYPE ? TREE_TYPE (t1) : t1;\n+      tree subtype2 = code2 == COMPLEX_TYPE ? TREE_TYPE (t2) : t2;\n+      tree subtype\n+\t= type_after_usual_arithmetic_conversions (subtype1, subtype2);\n+\n+      if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n+\treturn build_type_attribute_variant (t1, attributes);\n+      else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n+\treturn build_type_attribute_variant (t2, attributes);\n+      else\n+\treturn build_type_attribute_variant (build_complex_type (subtype),\n+\t\t\t\t\t     attributes);\n+    }\n+\n   /* If only one is real, use it as the result.  */\n   if (code1 == REAL_TYPE && code2 != REAL_TYPE)\n     return build_type_attribute_variant (t1, attributes);\n@@ -439,6 +461,7 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n      const char* location;\n {\n   tree result_type;\n+  tree attributes;\n \n   /* [expr.rel]\n \n@@ -456,6 +479,9 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n   if (TYPE_PTRMEMFUNC_P (t2))\n     t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n   \n+  /* Merge the attributes.  */\n+  attributes = (*targetm.merge_type_attributes) (t1, t2);\n+\n   /* We have:\n \n        [expr.rel]\n@@ -504,21 +530,18 @@ composite_pointer_type (t1, t2, arg1, arg2, location)\n \t}\n     }\n \n-  return result_type;\n+  return build_type_attribute_variant (result_type, attributes);\n }\n \n-/* Return the common type of two types.\n+/* Return the merged type of two types.\n    We assume that comptypes has already been done and returned 1;\n    if that isn't so, this may crash.\n \n-   This is the type for the result of most arithmetic operations\n-   if the operands have the given two types.\n-\n-   We do not deal with enumeral types here because they have already been\n-   converted to integer types.  */\n+   This just combines attributes and default arguments; any other\n+   differences would cause the two types to compare unalike.  */\n \n tree\n-common_type (t1, t2)\n+merge_types (t1, t2)\n      tree t1, t2;\n {\n   register enum tree_code code1;\n@@ -528,9 +551,7 @@ common_type (t1, t2)\n   /* Save time if the two types are the same.  */\n   if (t1 == t2)\n     return t1;\n-  t1 = original_type (t1);\n-  t2 = original_type (t2);\n-  if (t1 == t2)\n+  if (original_type (t1) == original_type (t2))\n     return t1;\n \n   /* If one type is nonsense, use the other.  */\n@@ -539,20 +560,11 @@ common_type (t1, t2)\n   if (t2 == error_mark_node)\n     return t1;\n \n-  if ((ARITHMETIC_TYPE_P (t1) || TREE_CODE (t1) == ENUMERAL_TYPE)\n-      && (ARITHMETIC_TYPE_P (t2) || TREE_CODE (t2) == ENUMERAL_TYPE))\n-    return type_after_usual_arithmetic_conversions (t1, t2);\n-\n   /* Merge the attributes.  */\n   attributes = (*targetm.merge_type_attributes) (t1, t2);\n \n   /* Treat an enum type as the unsigned integer type of the same width.  */\n \n-  if (TREE_CODE (t1) == ENUMERAL_TYPE)\n-    t1 = type_for_size (TYPE_PRECISION (t1), 1);\n-  if (TREE_CODE (t2) == ENUMERAL_TYPE)\n-    t2 = type_for_size (TYPE_PRECISION (t2), 1);\n-\n   if (TYPE_PTRMEMFUNC_P (t1))\n     t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n   if (TYPE_PTRMEMFUNC_P (t2))\n@@ -561,82 +573,13 @@ common_type (t1, t2)\n   code1 = TREE_CODE (t1);\n   code2 = TREE_CODE (t2);\n \n-  /* If one type is complex, form the common type of the non-complex\n-     components, then make that complex.  Use T1 or T2 if it is the\n-     required type.  */\n-  if (code1 == COMPLEX_TYPE || code2 == COMPLEX_TYPE)\n-    {\n-      tree subtype1 = code1 == COMPLEX_TYPE ? TREE_TYPE (t1) : t1;\n-      tree subtype2 = code2 == COMPLEX_TYPE ? TREE_TYPE (t2) : t2;\n-      tree subtype = common_type (subtype1, subtype2);\n-\n-      if (code1 == COMPLEX_TYPE && TREE_TYPE (t1) == subtype)\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else if (code2 == COMPLEX_TYPE && TREE_TYPE (t2) == subtype)\n-\treturn build_type_attribute_variant (t2, attributes);\n-      else\n-\treturn build_type_attribute_variant (build_complex_type (subtype),\n-\t\t\t\t\t     attributes);\n-    }\n-\n   switch (code1)\n     {\n-    case INTEGER_TYPE:\n-    case REAL_TYPE:\n-      /* We should have called type_after_usual_arithmetic_conversions\n-\t above.  */\n-      abort ();\n-      break;\n-\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n-      /* For two pointers, do this recursively on the target type,\n-\t and combine the qualifiers of the two types' targets.  */\n-      /* This code was turned off; I don't know why.\n- \t But ISO C++ specifies doing this with the qualifiers.\n- \t So I turned it on again.  */\n+      /* For two pointers, do this recursively on the target type.  */\n       {\n-\ttree tt1 = TREE_TYPE (t1);\n-\ttree tt2 = TREE_TYPE (t2);\n-\ttree b1, b2;\n-\tint type_quals;\n-\ttree target;\n-\n-\tif (TREE_CODE (tt1) == OFFSET_TYPE)\n-\t  {\n-\t    b1 = TYPE_OFFSET_BASETYPE (tt1);\n-\t    b2 = TYPE_OFFSET_BASETYPE (tt2);\n-\t    tt1 = TREE_TYPE (tt1);\n-\t    tt2 = TREE_TYPE (tt2);\n-\t  }\n-\telse\n-\t  b1 = b2 = NULL_TREE;\n-\n-\ttype_quals = (cp_type_quals (tt1) | cp_type_quals (tt2));\n-\ttt1 = TYPE_MAIN_VARIANT (tt1);\n-\ttt2 = TYPE_MAIN_VARIANT (tt2);\n-\n-\tif (tt1 == tt2)\n-\t  target = tt1;\n-\telse if (VOID_TYPE_P (tt1) || VOID_TYPE_P (tt2))\n-\t  target = void_type_node;\n-\telse if (tt1 == unknown_type_node)\n-\t  target = tt2;\n-\telse if (tt2 == unknown_type_node)\n-\t  target = tt1;\n-\telse\n-\t  target = common_type (tt1, tt2);\n-\n-\ttarget = cp_build_qualified_type (target, type_quals);\n-\n-\tif (b1)\n-\t  {\n-\t    if (same_type_p (b1, b2)\n-\t\t|| (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n-\t      target = build_offset_type (b2, target);\n-\t    else if (binfo_or_else (b2, b1))\n-\t      target = build_offset_type (b1, target);\n-\t  }\n+\ttree target = merge_types (TREE_TYPE (t1), TREE_TYPE (t2));\n \n \tif (code1 == POINTER_TYPE)\n \t  t1 = build_pointer_type (target);\n@@ -650,9 +593,17 @@ common_type (t1, t2)\n \treturn t1;\n       }\n \n+    case OFFSET_TYPE:\n+      {\n+\ttree base = TYPE_OFFSET_BASETYPE (t1);\n+\ttree target = merge_types (TREE_TYPE (t1), TREE_TYPE (t2));\n+\tt1 = build_offset_type (base, target);\n+\tbreak;\n+      }\n+\n     case ARRAY_TYPE:\n       {\n-\ttree elt = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n+\ttree elt = merge_types (TREE_TYPE (t1), TREE_TYPE (t2));\n \t/* Save space: see if the result is identical to one of the args.  */\n \tif (elt == TREE_TYPE (t1) && TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t1, attributes);\n@@ -661,14 +612,14 @@ common_type (t1, t2)\n \t/* Merge the element types, and have a size if either arg has one.  */\n \tt1 = build_cplus_array_type\n \t  (elt, TYPE_DOMAIN (TYPE_DOMAIN (t1) ? t1 : t2));\n-\treturn build_type_attribute_variant (t1, attributes);\n+\tbreak;\n       }\n \n     case FUNCTION_TYPE:\n       /* Function types: prefer the one that specified arg types.\n \t If both do, merge the arg types.  Also merge the return types.  */\n       {\n-\ttree valtype = common_type (TREE_TYPE (t1), TREE_TYPE (t2));\n+\ttree valtype = merge_types (TREE_TYPE (t1), TREE_TYPE (t2));\n \ttree p1 = TYPE_ARG_TYPES (t1);\n \ttree p2 = TYPE_ARG_TYPES (t2);\n \ttree rval, raises;\n@@ -697,73 +648,72 @@ common_type (t1, t2)\n \t  }\n \n \trval = build_function_type (valtype, commonparms (p1, p2));\n-\trval = build_exception_variant (rval, raises);\n-\treturn build_type_attribute_variant (rval, attributes);\n+\tt1 = build_exception_variant (rval, raises);\n+\tbreak;\n       }\n \n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-      t1 = TYPE_MAIN_VARIANT (t1);\n-      t2 = TYPE_MAIN_VARIANT (t2);\n+    case METHOD_TYPE:\n+      {\n+\t/* Get this value the long way, since TYPE_METHOD_BASETYPE\n+\t   is just the main variant of this.  */\n+\ttree basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t2)));\n+\ttree raises = TYPE_RAISES_EXCEPTIONS (t1);\n+\ttree t3;\n+\n+\t/* If this was a member function type, get back to the\n+\t   original type of type member function (i.e., without\n+\t   the class instance variable up front.  */\n+\tt1 = build_function_type (TREE_TYPE (t1),\n+\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (t1)));\n+\tt2 = build_function_type (TREE_TYPE (t2),\n+\t\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (t2)));\n+\tt3 = merge_types (t1, t2);\n+\tt3 = build_cplus_method_type (basetype, TREE_TYPE (t3),\n+\t\t\t\t      TYPE_ARG_TYPES (t3));\n+\tt1 = build_exception_variant (t3, raises);\n+\tbreak;\n+      }\n \n-      if (DERIVED_FROM_P (t1, t2) && binfo_or_else (t1, t2))\n-\treturn build_type_attribute_variant (t1, attributes);\n-      else if (binfo_or_else (t2, t1))\n-\treturn build_type_attribute_variant (t2, attributes);\n-      else\n-\t{\n-\t  compiler_error (\"common_type called with uncommon aggregate types\");\n-\t  return error_mark_node;\n-\t}\n+    default:;\n+    }\n+  return build_type_attribute_variant (t1, attributes);\n+}\n \n-    case METHOD_TYPE:\n-      if (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2)))\n-\t{\n-\t  /* Get this value the long way, since TYPE_METHOD_BASETYPE\n-\t     is just the main variant of this.  */\n-\t  tree basetype;\n-\t  tree raises, t3;\n+/* Return the common type of two types.\n+   We assume that comptypes has already been done and returned 1;\n+   if that isn't so, this may crash.\n \n-\t  tree b1 = TYPE_OFFSET_BASETYPE (t1);\n-\t  tree b2 = TYPE_OFFSET_BASETYPE (t2);\n+   This is the type for the result of most arithmetic operations\n+   if the operands have the given two types.  */\n \n-\t  if (same_type_p (b1, b2)\n-\t      || (DERIVED_FROM_P (b1, b2) && binfo_or_else (b1, b2)))\n-\t    basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t2)));\n-\t  else\n-\t    {\n-\t      if (binfo_or_else (b2, b1) == NULL_TREE)\n-\t\tcompiler_error (\"common_type called with uncommon method types\");\n-\t      basetype = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t1)));\n-\t    }\n+tree\n+common_type (t1, t2)\n+     tree t1, t2;\n+{\n+  enum tree_code code1;\n+  enum tree_code code2;\n \n-\t  raises = TYPE_RAISES_EXCEPTIONS (t1);\n-\n-\t  /* If this was a member function type, get back to the\n-\t     original type of type member function (i.e., without\n-\t     the class instance variable up front.  */\n-\t  t1 = build_function_type (TREE_TYPE (t1),\n-\t\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t1)));\n-\t  t2 = build_function_type (TREE_TYPE (t2),\n-\t\t\t\t    TREE_CHAIN (TYPE_ARG_TYPES (t2)));\n-\t  t3 = common_type (t1, t2);\n-\t  t3 = build_cplus_method_type (basetype, TREE_TYPE (t3),\n-\t\t\t\t\tTYPE_ARG_TYPES (t3));\n-\t  t1 = build_exception_variant (t3, raises);\n-\t}\n-      else\n-        compiler_error (\"common_type called with uncommon method types\");\n+  /* If one type is nonsense, bail.  */\n+  if (t1 == error_mark_node || t2 == error_mark_node)\n+    return error_mark_node;\n \n-      return build_type_attribute_variant (t1, attributes);\n+  code1 = TREE_CODE (t1);\n+  code2 = TREE_CODE (t2);\n \n-    case OFFSET_TYPE:\n-      /* Pointers to members should now be handled by the POINTER_TYPE\n-\t case above.  */\n-      abort ();\n+  if ((ARITHMETIC_TYPE_P (t1) || code1 == ENUMERAL_TYPE\n+       || code1 == COMPLEX_TYPE)\n+      && (ARITHMETIC_TYPE_P (t2) || code2 == ENUMERAL_TYPE\n+\t  || code2 == COMPLEX_TYPE))\n+    return type_after_usual_arithmetic_conversions (t1, t2);\n \n-    default:\n-      return build_type_attribute_variant (t1, attributes);\n-    }\n+  else if ((TYPE_PTR_P (t1) && TYPE_PTR_P (t2))\n+\t   || (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2))\n+\t   || (TYPE_PTRMEMFUNC_P (t1) && TYPE_PTRMEMFUNC_P (t2)))\n+    return composite_pointer_type (t1, t2, error_mark_node, error_mark_node,\n+\t\t\t\t   \"conversion\");\n+\n+  else\n+    abort ();\n }\n \f\n /* Compare two exception specifier types for exactness or subsetness, if"}, {"sha": "cfcf6682691ddf1b494b7ec77166135b087dfb7c", "filename": "gcc/testsuite/g++.dg/other/redecl1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6da794e83532c526345040d6251acf12147d4231/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fredecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6da794e83532c526345040d6251acf12147d4231/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fredecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fredecl1.C?ref=6da794e83532c526345040d6251acf12147d4231", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/5857\n+// This testcase failed because during duplicate_decls the type was promoted\n+// to int.\n+\n+// { dg-do compile }\n+\n+typedef char baz;\n+extern const char foo[];\n+const baz foo[] = \"xyz\";\n+const char bar[] = \"abc\";"}]}