{"sha": "4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNmZjZhYmU0MDVmNGU0ZDY2MGFiNmY2Y2Y4YjI5YmE5ZDQ5ZDRmZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-01-23T10:36:26Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-01-23T10:36:26Z"}, "message": "call.c (build_conv): Typo in comment.\n\ncp:\n\t* call.c (build_conv): Typo in comment.\n\t(add_builtin_candidate): Add more explanation.\n\tRemove extra test for ENUMERAL_TYPE in {PRE,POST}INCREMENT_EXPR.\n\tAllow ENUMERAL_TYPEs for relops and eqops. Add both candidates\n\twhen we have enumeral types.\n\t(add_builtin_candidates): Add more explanation. Add ENUMERAL_TYPE\n\tcandidates for relops and eqops.\n\t(joust): Simplify control flow. Allow a non-template user\n\tfunction to hide a builtin.\ntestsuite:\n\t* g++.old-deja/g++.pt/overload14.C: New test.\n\nFrom-SVN: r39197", "tree": {"sha": "633beaf84c5f866061ba3e83160fdcc3d1166a9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/633beaf84c5f866061ba3e83160fdcc3d1166a9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/comments", "author": null, "committer": null, "parents": [{"sha": "20b11783a374a792e0737b9495bdae63269b5883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b11783a374a792e0737b9495bdae63269b5883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b11783a374a792e0737b9495bdae63269b5883"}], "stats": {"total": 139, "additions": 109, "deletions": 30}, "files": [{"sha": "f5b46ff6400cb6354cfd275f2372b71be0a3a91b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "patch": "@@ -1,3 +1,15 @@\n+2001-01-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (build_conv): Typo in comment.\n+\t(add_builtin_candidate): Add more explanation.\n+\tRemove extra test for ENUMERAL_TYPE in {PRE,POST}INCREMENT_EXPR.\n+\tAllow ENUMERAL_TYPEs for relops and eqops. Add both candidates\n+\twhen we have enumeral types.\n+\t(add_builtin_candidates): Add more explanation. Add ENUMERAL_TYPE\n+\tcandidates for relops and eqops.\n+\t(joust): Simplify control flow. Allow a non-template user\n+\tfunction to hide a builtin.\n+\n 2001-01-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.h (unification_kind_t): Add DEDUCE_ORDER."}, {"sha": "793a778525ac4064f15cf04c0ac76083aa877c99", "filename": "gcc/cp/call.c", "status": "modified", "additions": 73, "deletions": 30, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "patch": "@@ -608,7 +608,7 @@ build_conv (code, type, from)\n   tree t;\n   int rank = ICS_STD_RANK (from);\n \n-  /* We can't use buidl1 here because CODE could be USER_CONV, which\n+  /* We can't use buildl1 here because CODE could be USER_CONV, which\n      takes two arguments.  In that case, the caller is responsible for\n      filling in the second argument.  */\n   t = make_node (code);\n@@ -1563,7 +1563,12 @@ promoted_arithmetic_type_p (type)\n /* Create any builtin operator overload candidates for the operator in\n    question given the converted operand types TYPE1 and TYPE2.  The other\n    args are passed through from add_builtin_candidates to\n-   build_builtin_candidate.  */\n+   build_builtin_candidate.  \n+   \n+   TYPE1 and TYPE2 may not be permissible, and we must filter them. \n+   If CODE is requires candidates operands of the same type of the kind\n+   of which TYPE1 and TYPE2 are, we add both candidates\n+   CODE (TYPE1, TYPE1) and CODE (TYPE2, TYPE2).  */\n \n static struct z_candidate *\n add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n@@ -1611,8 +1616,7 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \treturn candidates;\n     case POSTINCREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-      if ((ARITHMETIC_TYPE_P (type1) && TREE_CODE (type1) != ENUMERAL_TYPE)\n-\t  || TYPE_PTROB_P (type1))\n+      if (ARITHMETIC_TYPE_P (type1) || TYPE_PTROB_P (type1))\n \t{\n \t  type1 = build_reference_type (type1);\n \t  break;\n@@ -1712,8 +1716,8 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n      candidate operator functions of the form112)\n \t     ptrdiff_t operator-(T, T);\n \n-   16For  every pointer type T, there exist candidate operator functions of\n-     the form\n+   16For  every enumeral or pointer type T, there exist candidate operator\n+     functions of the form\n \t     bool    operator<(T, T);\n \t     bool    operator>(T, T);\n \t     bool    operator<=(T, T);\n@@ -1757,15 +1761,19 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n \t  type1 = type2;\n \t  break;\n \t}\n+      /* FALLTHROUGH */\n     case LT_EXPR:\n     case GT_EXPR:\n     case LE_EXPR:\n     case GE_EXPR:\n     case MAX_EXPR:\n     case MIN_EXPR:\n-      if ((ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n-\t  || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2)))\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+        break;\n+      if (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n \tbreak;\n+      if (TREE_CODE (type1) == ENUMERAL_TYPE && TREE_CODE (type2) == ENUMERAL_TYPE)\n+        break;\n       if (TYPE_PTR_P (type1) && null_ptr_cst_p (args[1]))\n \t{\n \t  type2 = type1;\n@@ -1940,15 +1948,16 @@ add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n       my_friendly_abort (367);\n     }\n \n-  /* If we're dealing with two pointer types, we need candidates\n-     for both of them.  */\n+  /* If we're dealing with two pointer types or two enumeral types,\n+     we need candidates for both of them.  */\n   if (type2 && !same_type_p (type1, type2)\n       && TREE_CODE (type1) == TREE_CODE (type2)\n       && (TREE_CODE (type1) == REFERENCE_TYPE\n \t  || (TREE_CODE (type1) == POINTER_TYPE\n \t      && TYPE_PTRMEM_P (type1) == TYPE_PTRMEM_P (type2))\n \t  || TYPE_PTRMEMFUNC_P (type1)\n-\t  || IS_AGGR_TYPE (type1)))\n+\t  || IS_AGGR_TYPE (type1)\n+\t  || TREE_CODE (type1) == ENUMERAL_TYPE))\n     {\n       candidates = build_builtin_candidate\n \t(candidates, fnname, type1, type1, args, argtypes, flags);\n@@ -1977,7 +1986,12 @@ type_decays_to (type)\n    2) pointer-pair taking candidates.  These are generated for each type\n       one of the input types converts to.\n    3) arithmetic candidates.  According to the standard, we should generate\n-      all of these, but I'm trying not to... */\n+      all of these, but I'm trying not to...\n+   \n+   Here we generate a superset of the possible candidates for this particular\n+   case.  That is a subset of the full set the standard defines, plus some\n+   other cases which the standard disallows. add_builtin_candidate will\n+   filter out the illegal set.  */\n \n static struct z_candidate *\n add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n@@ -1987,6 +2001,7 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n      int flags;\n {\n   int ref1, i;\n+  int enum_p = 0;\n   tree type, argtypes[3];\n   /* TYPES[i] is the set of possible builtin-operator parameter types\n      we will consider for the Ith argument.  These are represented as\n@@ -2038,6 +2053,16 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n     case COMPONENT_REF:\n       return candidates;\n \n+    case COND_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case LT_EXPR:\n+    case LE_EXPR:\n+    case GT_EXPR:\n+    case GE_EXPR:\n+      enum_p = 1;\n+      /* FALLTHROUGH */\n+    \n     default:\n       ref1 = 0;\n     }\n@@ -2086,8 +2111,8 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t      if (i != 0 || ! ref1)\n \t\t{\n \t\t  type = TYPE_MAIN_VARIANT (type_decays_to (type));\n-\t\t  if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t          if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t            types[i] = tree_cons (NULL_TREE, type, types[i]);\n \t\t  if (INTEGRAL_TYPE_P (type))\n \t\t    type = type_promotes_to (type);\n \t\t}\n@@ -2105,8 +2130,8 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n \t  if (i != 0 || ! ref1)\n \t    {\n \t      type = TYPE_MAIN_VARIANT (type_decays_to (type));\n-\t      if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n-\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t      if (enum_p && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t        types[i] = tree_cons (NULL_TREE, type, types[i]);\n \t      if (INTEGRAL_TYPE_P (type))\n \t\ttype = type_promotes_to (type);\n \t    }\n@@ -5186,21 +5211,34 @@ joust (cand1, cand2, warn)\n   if (winner)\n     return winner;\n \n-  /* or, if not that,\n-     F1 is a non-template function and F2 is a template function */\n+  /* or, if not that, a non-template function is better than a\n+     template function.  */\n \n   if (! cand1->template && cand2->template)\n     return 1;\n   else if (cand1->template && ! cand2->template)\n     return -1;\n   else if (cand1->template && cand2->template)\n-    winner = more_specialized\n-      (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template),\n-       DEDUCE_ORDER,\n-       /* Never do unification on the 'this' parameter.  */\n-       TREE_VEC_LENGTH (cand1->convs)\n-       - DECL_NONSTATIC_MEMBER_FUNCTION_P (cand1->fn));\n+    {\n+      winner = more_specialized\n+        (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template),\n+         DEDUCE_ORDER,\n+         /* Never do unification on the 'this' parameter.  */\n+         TREE_VEC_LENGTH (cand1->convs)\n+         - DECL_NONSTATIC_MEMBER_FUNCTION_P (cand1->fn));\n+      if (winner)\n+        return winner;\n+    }\n \n+  /* or, if not that, a non-template user function is better than a\n+     builtin.  */\n+  if (TREE_CODE (cand1->fn) != IDENTIFIER_NODE\n+      && TREE_CODE (cand2->fn) == IDENTIFIER_NODE)\n+    return 1;\n+  else if (TREE_CODE (cand1->fn) == IDENTIFIER_NODE\n+           && TREE_CODE (cand2->fn) != IDENTIFIER_NODE)\n+    return -1;\n+  \n   /* or, if not that,\n      the  context  is  an  initialization by user-defined conversion (see\n      _dcl.init_  and  _over.match.user_)  and  the  standard   conversion\n@@ -5209,11 +5247,15 @@ joust (cand1, cand2, warn)\n      sequence  than the standard conversion sequence from the return type\n      of F2 to the destination type.  */\n \n-  if (! winner && cand1->second_conv)\n-    winner = compare_ics (cand1->second_conv, cand2->second_conv);\n-\n+  if (cand1->second_conv)\n+    {\n+      winner = compare_ics (cand1->second_conv, cand2->second_conv);\n+      if (winner)\n+        return winner;\n+    }\n+  \n   /* If the built-in candidates are the same, arbitrarily pick one.  */\n-  if (! winner && cand1->fn == cand2->fn\n+  if (cand1->fn == cand2->fn\n       && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n     {\n       for (i = 0; i < len; ++i)\n@@ -5253,7 +5295,7 @@ joust (cand1, cand2, warn)\n \n   /* Extension: If the worst conversion for one candidate is worse than the\n      worst conversion for the other, take the first.  */\n-  if (! winner && ! pedantic)\n+  if (!pedantic)\n     {\n       int rank1 = IDENTITY_RANK, rank2 = IDENTITY_RANK;\n \n@@ -5271,7 +5313,8 @@ joust (cand1, cand2, warn)\n \treturn -1;\n     }\n \n-  return winner;\n+  my_friendly_assert (!winner, 20010121);\n+  return 0;\n }\n \n /* Given a list of candidates for overloading, find the best one, if any."}, {"sha": "31f25fb58c559e233e4149f920e341fa0b980203", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "patch": "@@ -1,3 +1,7 @@\n+2001-01-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.old-deja/g++.pt/overload14.C: New test.\n+\n 2001-01-22  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n \n \t* gcc.c-torture/execute/20010122-1.c: New test, exercise"}, {"sha": "022326e65d8f1644db8af440476ee8de6a8cc246", "filename": "gcc/testsuite/g++.old-deja/g++.pt/overload14.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Foverload14.C?ref=4cff6abe405f4e4d660ab6f6cf8b29ba9d49d4fd", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+// \n+// Copyright (C) 2000 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 18 Jan 2001 <nathan@codesourcery.com>\n+\n+// Bug 1639. We failed to have builtin relop candidates with enumeral type.\n+\n+template <typename T1, typename T2> void operator == (T1, T2);\n+\n+enum E {e1};\n+void operator != (E, E);\n+\n+bool Foo (E e)\n+{\n+  return e == e1;\n+}\n+bool Baz (E e)\n+{\n+  return e != e1; // ERROR - void not ignored.\n+}"}]}