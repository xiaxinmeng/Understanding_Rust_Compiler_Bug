{"sha": "e28c20522742a9782f6468551f11e3266ea2f823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTI4YzIwNTIyNzQyYTk3ODJmNjQ2ODU1MWYxMWUzMjY2ZWEyZjgyMw==", "commit": {"author": {"name": "Mikhail Maltsev", "email": "maltsevm@gmail.com", "date": "2015-10-30T04:08:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-30T04:08:15Z"}, "message": "[PATCH 8/9] ENABLE_CHECKING refactoring: target-specific parts\n\n\t* config/alpha/alpha.c (alpha_function_arg): Use gcc_checking_assert,\n\tflag_checking and/or CHECKING_P to eliminate conditional compilation\n\ton ENABLE_CHECKING.\n\t* config/arm/arm.c (arm_unwind_emit_sequence): Likewise.\n\t* config/bfin/bfin.c (hwloop_optimize): Likewise.\n\t* config/i386/i386.c (ix86_print_operand_address): Likewise.\n\t(output_387_binary_op): Likewise.\n\t* config/ia64/ia64.c (ia64_sched_init, bundling): Likewise.\n\t* config/m68k/m68k.c (m68k_sched_md_init_global): Likewise.\n\t* config/rs6000/rs6000.c (htm_expand_builtin, rs6000_emit_prologue):\n\tLikewise.\n\t* config/rs6000/rs6000.h: Likewise.\n\t* config/visium/visium.c (visium_setup_incoming_varargs): Likewise.\n\nFrom-SVN: r229567", "tree": {"sha": "7fbdc43691b6544d44daaf19d6ab83d87d89f607", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fbdc43691b6544d44daaf19d6ab83d87d89f607"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28c20522742a9782f6468551f11e3266ea2f823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28c20522742a9782f6468551f11e3266ea2f823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28c20522742a9782f6468551f11e3266ea2f823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28c20522742a9782f6468551f11e3266ea2f823/comments", "author": {"login": "miyuki", "id": 4668268, "node_id": "MDQ6VXNlcjQ2NjgyNjg=", "avatar_url": "https://avatars.githubusercontent.com/u/4668268?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miyuki", "html_url": "https://github.com/miyuki", "followers_url": "https://api.github.com/users/miyuki/followers", "following_url": "https://api.github.com/users/miyuki/following{/other_user}", "gists_url": "https://api.github.com/users/miyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/miyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miyuki/subscriptions", "organizations_url": "https://api.github.com/users/miyuki/orgs", "repos_url": "https://api.github.com/users/miyuki/repos", "events_url": "https://api.github.com/users/miyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/miyuki/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "88833adc282e3090b4833d39567e18e8a3577af9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88833adc282e3090b4833d39567e18e8a3577af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88833adc282e3090b4833d39567e18e8a3577af9"}], "stats": {"total": 281, "additions": 142, "deletions": 139}, "files": [{"sha": "934711b183b10085ef96fac8f5658dc4c9549b7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -1,3 +1,19 @@\n+2015-10-29  Mikhail Maltsev  <maltsevm@gmail.com>\n+\n+\t* config/alpha/alpha.c (alpha_function_arg): Use gcc_checking_assert,\n+\tflag_checking and/or CHECKING_P to eliminate conditional compilation\n+\ton ENABLE_CHECKING.\n+\t* config/arm/arm.c (arm_unwind_emit_sequence): Likewise.\n+\t* config/bfin/bfin.c (hwloop_optimize): Likewise.\n+\t* config/i386/i386.c (ix86_print_operand_address): Likewise.\n+\t(output_387_binary_op): Likewise.\n+\t* config/ia64/ia64.c (ia64_sched_init, bundling): Likewise.\n+\t* config/m68k/m68k.c (m68k_sched_md_init_global): Likewise.\n+\t* config/rs6000/rs6000.c (htm_expand_builtin, rs6000_emit_prologue):\n+\tLikewise.\n+\t* config/rs6000/rs6000.h: Likewise.\n+\t* config/visium/visium.c (visium_setup_incoming_varargs): Likewise.\n+\n 2015-10-29  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.opt (mfdpic): Add missing period."}, {"sha": "11da372fce7509da92c5ccf32b37324094338c45", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -5558,11 +5558,9 @@ alpha_function_arg (cumulative_args_t cum_v, machine_mode mode,\n     basereg = 16;\n   else\n     {\n-#ifdef ENABLE_CHECKING\n       /* With alpha_split_complex_arg, we shouldn't see any raw complex\n \t values here.  */\n-      gcc_assert (!COMPLEX_MODE_P (mode));\n-#endif\n+      gcc_checking_assert (!COMPLEX_MODE_P (mode));\n \n       /* Set up defaults for FP operands passed in FP registers, and\n \t integral operands passed in integer registers.  */"}, {"sha": "7c72a81ece0beaca3e531e24a9697ee7a6216fc3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -26857,20 +26857,21 @@ arm_unwind_emit_sequence (FILE * asm_out_file, rtx p)\n       else\n \tasm_fprintf (asm_out_file, \"%r\", reg);\n \n-#ifdef ENABLE_CHECKING\n-      /* Check that the addresses are consecutive.  */\n-      e = XEXP (SET_DEST (e), 0);\n-      if (GET_CODE (e) == PLUS)\n-\tgcc_assert (REG_P (XEXP (e, 0))\n-\t\t    && REGNO (XEXP (e, 0)) == SP_REGNUM\n-\t\t    && CONST_INT_P (XEXP (e, 1))\n-\t\t    && offset == INTVAL (XEXP (e, 1)));\n-      else\n-\tgcc_assert (i == 1\n-\t\t    && REG_P (e)\n-\t\t    && REGNO (e) == SP_REGNUM);\n-      offset += reg_size;\n-#endif\n+      if (flag_checking)\n+\t{\n+\t  /* Check that the addresses are consecutive.  */\n+\t  e = XEXP (SET_DEST (e), 0);\n+\t  if (GET_CODE (e) == PLUS)\n+\t    gcc_assert (REG_P (XEXP (e, 0))\n+\t\t\t&& REGNO (XEXP (e, 0)) == SP_REGNUM\n+\t\t\t&& CONST_INT_P (XEXP (e, 1))\n+\t\t\t&& offset == INTVAL (XEXP (e, 1)));\n+\t  else\n+\t    gcc_assert (i == 1\n+\t\t\t&& REG_P (e)\n+\t\t\t&& REGNO (e) == SP_REGNUM);\n+\t  offset += reg_size;\n+\t}\n     }\n   fprintf (asm_out_file, \"}\\n\");\n   if (padfirst)"}, {"sha": "6a5f90a7f1e5592ec5fffc88de420b95998bb168", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -3792,8 +3792,7 @@ hwloop_optimize (hwloop_info loop)\n       edge e;\n       edge_iterator ei;\n \n-#ifdef ENABLE_CHECKING\n-      if (loop->head != loop->incoming_dest)\n+      if (flag_checking && loop->head != loop->incoming_dest)\n \t{\n \t  /* We aren't entering the loop at the top.  Since we've established\n \t     that the loop is entered only at one point, this means there\n@@ -3803,7 +3802,6 @@ hwloop_optimize (hwloop_info loop)\n \t  FOR_EACH_EDGE (e, ei, loop->head->preds)\n \t    gcc_assert (!(e->flags & EDGE_FALLTHRU));\n \t}\n-#endif\n \n       emit_insn_before (seq, BB_HEAD (loop->head));\n       seq = emit_label_before (gen_label_rtx (), seq);"}, {"sha": "913dc00e02c65eefead3e7a5efd267083ab927a5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -17348,22 +17348,23 @@ ix86_print_operand_address (FILE *file, rtx addr)\n       /* Print SImode register names to force addr32 prefix.  */\n       if (SImode_address_operand (addr, VOIDmode))\n \t{\n-#ifdef ENABLE_CHECKING\n-\t  gcc_assert (TARGET_64BIT);\n-\t  switch (GET_CODE (addr))\n+\t  if (flag_checking)\n \t    {\n-\t    case SUBREG:\n-\t      gcc_assert (GET_MODE (addr) == SImode);\n-\t      gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n-\t      break;\n-\t    case ZERO_EXTEND:\n-\t    case AND:\n-\t      gcc_assert (GET_MODE (addr) == DImode);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n+\t      gcc_assert (TARGET_64BIT);\n+\t      switch (GET_CODE (addr))\n+\t\t{\n+\t\tcase SUBREG:\n+\t\t  gcc_assert (GET_MODE (addr) == SImode);\n+\t\t  gcc_assert (GET_MODE (SUBREG_REG (addr)) == DImode);\n+\t\t  break;\n+\t\tcase ZERO_EXTEND:\n+\t\tcase AND:\n+\t\t  gcc_assert (GET_MODE (addr) == DImode);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable ();\n+\t\t}\n \t    }\n-#endif\n \t  gcc_assert (!code);\n \t  code = 'k';\n \t}\n@@ -17620,10 +17621,10 @@ output_387_binary_op (rtx insn, rtx *operands)\n   const char *ssep;\n   int is_sse = SSE_REG_P (operands[0]) || SSE_REG_P (operands[1]) || SSE_REG_P (operands[2]);\n \n-#ifdef ENABLE_CHECKING\n   /* Even if we do not want to check the inputs, this documents input\n      constraints.  Which helps in understanding the following code.  */\n-  if (STACK_REG_P (operands[0])\n+  if (flag_checking\n+      && STACK_REG_P (operands[0])\n       && ((REG_P (operands[1])\n \t   && REGNO (operands[0]) == REGNO (operands[1])\n \t   && (STACK_REG_P (operands[2]) || MEM_P (operands[2])))\n@@ -17633,8 +17634,7 @@ output_387_binary_op (rtx insn, rtx *operands)\n       && (STACK_TOP_P (operands[1]) || STACK_TOP_P (operands[2])))\n     ; /* ok */\n   else\n-    gcc_assert (is_sse);\n-#endif\n+    gcc_checking_assert (is_sse);\n \n   switch (GET_CODE (operands[3]))\n     {"}, {"sha": "d92af1770827ecc952e162d0cde5c5cf9020318e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 52, "deletions": 56, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -6125,7 +6125,7 @@ struct reg_write_state\n \n /* Cumulative info for the current instruction group.  */\n struct reg_write_state rws_sum[NUM_REGS];\n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n /* Bitmap whether a register has been written in the current insn.  */\n HARD_REG_ELT_TYPE rws_insn[(NUM_REGS + HOST_BITS_PER_WIDEST_FAST_INT - 1)\n \t\t\t   / HOST_BITS_PER_WIDEST_FAST_INT];\n@@ -7293,15 +7293,13 @@ ia64_sched_init (FILE *dump ATTRIBUTE_UNUSED,\n \t\t int sched_verbose ATTRIBUTE_UNUSED,\n \t\t int max_ready ATTRIBUTE_UNUSED)\n {\n-#ifdef ENABLE_CHECKING\n-  rtx_insn *insn;\n-\n-  if (!sel_sched_p () && reload_completed)\n-    for (insn = NEXT_INSN (current_sched_info->prev_head);\n-\t insn != current_sched_info->next_tail;\n-\t insn = NEXT_INSN (insn))\n-      gcc_assert (!SCHED_GROUP_P (insn));\n-#endif\n+  if (flag_checking && !sel_sched_p () && reload_completed)\n+    {\n+      for (rtx_insn *insn = NEXT_INSN (current_sched_info->prev_head);\n+\t   insn != current_sched_info->next_tail;\n+\t   insn = NEXT_INSN (insn))\n+\tgcc_assert (!SCHED_GROUP_P (insn));\n+    }\n   last_scheduled_insn = NULL;\n   init_insn_group_barriers ();\n \n@@ -9299,54 +9297,52 @@ bundling (FILE *dump, int verbose, rtx_insn *prev_head_insn, rtx_insn *tail)\n \t}\n     }\n \n-#ifdef ENABLE_CHECKING\n-  {\n-    /* Assert right calculation of middle_bundle_stops.  */\n-    int num = best_state->middle_bundle_stops;\n-    bool start_bundle = true, end_bundle = false;\n-\n-    for (insn = NEXT_INSN (prev_head_insn);\n-\t insn && insn != tail;\n-\t insn = NEXT_INSN (insn))\n-      {\n-\tif (!INSN_P (insn))\n-\t  continue;\n-\tif (recog_memoized (insn) == CODE_FOR_bundle_selector)\n-\t  start_bundle = true;\n-\telse\n-\t  {\n-\t    rtx_insn *next_insn;\n-\n-\t    for (next_insn = NEXT_INSN (insn);\n-\t\t next_insn && next_insn != tail;\n-\t\t next_insn = NEXT_INSN (next_insn))\n-\t      if (INSN_P (next_insn)\n-\t\t  && (ia64_safe_itanium_class (next_insn)\n-\t\t      != ITANIUM_CLASS_IGNORE\n-\t\t      || recog_memoized (next_insn)\n-\t\t      == CODE_FOR_bundle_selector)\n-\t\t  && GET_CODE (PATTERN (next_insn)) != USE\n-\t\t  && GET_CODE (PATTERN (next_insn)) != CLOBBER)\n-\t\tbreak;\n+  if (flag_checking)\n+    {\n+      /* Assert right calculation of middle_bundle_stops.  */\n+      int num = best_state->middle_bundle_stops;\n+      bool start_bundle = true, end_bundle = false;\n \n-\t    end_bundle = next_insn == NULL_RTX\n-\t     || next_insn == tail\n-\t     || (INSN_P (next_insn)\n-\t\t && recog_memoized (next_insn)\n-\t\t == CODE_FOR_bundle_selector);\n-\t    if (recog_memoized (insn) == CODE_FOR_insn_group_barrier\n-\t\t&& !start_bundle && !end_bundle\n-\t\t&& next_insn\n-\t\t&& !unknown_for_bundling_p (next_insn))\n-\t      num--;\n-\n-\t    start_bundle = false;\n-\t  }\n-      }\n+      for (insn = NEXT_INSN (prev_head_insn);\n+\t   insn && insn != tail;\n+\t   insn = NEXT_INSN (insn))\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\t  if (recog_memoized (insn) == CODE_FOR_bundle_selector)\n+\t    start_bundle = true;\n+\t  else\n+\t    {\n+\t      rtx_insn *next_insn;\n+\n+\t      for (next_insn = NEXT_INSN (insn);\n+\t\t   next_insn && next_insn != tail;\n+\t\t   next_insn = NEXT_INSN (next_insn))\n+\t\tif (INSN_P (next_insn)\n+\t\t    && (ia64_safe_itanium_class (next_insn)\n+\t\t\t!= ITANIUM_CLASS_IGNORE\n+\t\t\t|| recog_memoized (next_insn)\n+\t\t\t== CODE_FOR_bundle_selector)\n+\t\t    && GET_CODE (PATTERN (next_insn)) != USE\n+\t\t    && GET_CODE (PATTERN (next_insn)) != CLOBBER)\n+\t\t  break;\n+\n+\t      end_bundle = next_insn == NULL_RTX\n+\t\t|| next_insn == tail\n+\t\t|| (INSN_P (next_insn)\n+\t\t    && recog_memoized (next_insn) == CODE_FOR_bundle_selector);\n+\t      if (recog_memoized (insn) == CODE_FOR_insn_group_barrier\n+\t\t  && !start_bundle && !end_bundle\n+\t\t  && next_insn\n+\t\t  && !unknown_for_bundling_p (next_insn))\n+\t\tnum--;\n+\n+\t      start_bundle = false;\n+\t    }\n+\t}\n \n-    gcc_assert (num == 0);\n-  }\n-#endif\n+      gcc_assert (num == 0);\n+    }\n \n   free (index_to_bundle_states);\n   finish_bundle_state_table ();"}, {"sha": "37b1af2db3aef9534c2ee0b93f68f477b178738e", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -6118,28 +6118,27 @@ m68k_sched_md_init_global (FILE *sched_dump ATTRIBUTE_UNUSED,\n \t\t\t   int sched_verbose ATTRIBUTE_UNUSED,\n \t\t\t   int n_insns ATTRIBUTE_UNUSED)\n {\n-#ifdef ENABLE_CHECKING\n   /* Check that all instructions have DFA reservations and\n      that all instructions can be issued from a clean state.  */\n-  {\n-    rtx_insn *insn;\n-    state_t state;\n+  if (flag_checking)\n+    {\n+      rtx_insn *insn;\n+      state_t state;\n \n-    state = alloca (state_size ());\n+      state = alloca (state_size ());\n \n-    for (insn = get_insns (); insn != NULL; insn = NEXT_INSN (insn))\n-      {\n- \tif (INSN_P (insn) && recog_memoized (insn) >= 0)\n-\t  {\n- \t    gcc_assert (insn_has_dfa_reservation_p (insn));\n+      for (insn = get_insns (); insn != NULL; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn) && recog_memoized (insn) >= 0)\n+\t    {\n+\t      gcc_assert (insn_has_dfa_reservation_p (insn));\n \n- \t    state_reset (state);\n- \t    if (state_transition (state, insn) >= 0)\n- \t      gcc_unreachable ();\n- \t  }\n-      }\n-  }\n-#endif\n+\t      state_reset (state);\n+\t      if (state_transition (state, insn) >= 0)\n+\t\tgcc_unreachable ();\n+\t    }\n+\t}\n+    }\n \n   /* Setup target cpu.  */\n "}, {"sha": "53b86afd83f0b8384bd90e04bf4599a36181a8c2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -12906,15 +12906,13 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)\n \t  case HTM_BUILTIN_TENDALL:  /* Alias for: tend. 1  */\n \t  case HTM_BUILTIN_TRESUME:  /* Alias for: tsr. 1  */\n \t    op[nopnds++] = GEN_INT (1);\n-#ifdef ENABLE_CHECKING\n-\t    attr |= RS6000_BTC_UNARY;\n-#endif\n+\t    if (flag_checking)\n+\t      attr |= RS6000_BTC_UNARY;\n \t    break;\n \t  case HTM_BUILTIN_TSUSPEND: /* Alias for: tsr. 0  */\n \t    op[nopnds++] = GEN_INT (0);\n-#ifdef ENABLE_CHECKING\n-\t    attr |= RS6000_BTC_UNARY;\n-#endif\n+\t    if (flag_checking)\n+\t      attr |= RS6000_BTC_UNARY;\n \t    break;\n \t  default:\n \t    break;\n@@ -12935,21 +12933,23 @@ htm_expand_builtin (tree exp, rtx target, bool * expandedp)\n \t    op[nopnds++] = cr;\n \t  }\n \n-#ifdef ENABLE_CHECKING\n-\tint expected_nopnds = 0;\n-\tif ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_UNARY)\n-\t  expected_nopnds = 1;\n-\telse if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_BINARY)\n-\t  expected_nopnds = 2;\n-\telse if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_TERNARY)\n-\t  expected_nopnds = 3;\n-\tif (!(attr & RS6000_BTC_VOID))\n-\t  expected_nopnds += 1;\n-\tif (uses_spr)\n-\t  expected_nopnds += 2;\n+\tif (flag_checking)\n+\t  {\n+\t    int expected_nopnds = 0;\n+\t    if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_UNARY)\n+\t      expected_nopnds = 1;\n+\t    else if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_BINARY)\n+\t      expected_nopnds = 2;\n+\t    else if ((attr & RS6000_BTC_TYPE_MASK) == RS6000_BTC_TERNARY)\n+\t      expected_nopnds = 3;\n+\t    if (!(attr & RS6000_BTC_VOID))\n+\t      expected_nopnds += 1;\n+\t    if (uses_spr)\n+\t      expected_nopnds += 2;\n \n-\tgcc_assert (nopnds == expected_nopnds && nopnds <= MAX_HTM_OPERANDS);\n-#endif\n+\t    gcc_assert (nopnds == expected_nopnds\n+\t\t\t&& nopnds <= MAX_HTM_OPERANDS);\n+\t  }\n \n \tswitch (nopnds)\n \t  {\n@@ -24325,7 +24325,7 @@ rs6000_emit_prologue (void)\n      prior to it, when r12 is not used here for other purposes.  */\n   rtx_insn *sp_adjust = 0;\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n   /* Track and check usage of r0, r11, r12.  */\n   int reg_inuse = using_static_chain_p ? 1 << 11 : 0;\n #define START_USE(R) do \\"}, {"sha": "02da097227bcb4eaeebe4a8f5d890c17a7d690f1", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -1479,15 +1479,10 @@ enum reg_class\n \n extern enum reg_class rs6000_regno_regclass[FIRST_PSEUDO_REGISTER];\n \n-#if ENABLE_CHECKING\n #define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n-  (gcc_assert (IN_RANGE ((REGNO), 0, FIRST_PSEUDO_REGISTER-1)),\t\t\\\n+  (gcc_checking_assert (IN_RANGE ((REGNO), 0, FIRST_PSEUDO_REGISTER-1)),\\\n    rs6000_regno_regclass[(REGNO)])\n \n-#else\n-#define REGNO_REG_CLASS(REGNO) rs6000_regno_regclass[(REGNO)]\n-#endif\n-\n /* Register classes for various constraints that are based on the target\n    switches.  */\n enum r6000_reg_class_enum {"}, {"sha": "d1b580ebc44d5ffb86ce1b7eb480f1aa9199dfa9", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c20522742a9782f6468551f11e3266ea2f823/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=e28c20522742a9782f6468551f11e3266ea2f823", "patch": "@@ -1338,7 +1338,7 @@ visium_setup_incoming_varargs (cumulative_args_t pcum_v,\n   local_args_so_far.p = &local_copy;\n   locargs = get_cumulative_args (pcum_v);\n \n-#ifdef ENABLE_CHECKING\n+#if CHECKING_P\n   local_args_so_far.magic = CUMULATIVE_ARGS_MAGIC;\n #endif\n "}]}