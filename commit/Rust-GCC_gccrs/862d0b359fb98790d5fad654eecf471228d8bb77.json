{"sha": "862d0b359fb98790d5fad654eecf471228d8bb77", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyZDBiMzU5ZmI5ODc5MGQ1ZmFkNjU0ZWVjZjQ3MTIyOGQ4YmI3Nw==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2013-11-08T22:46:16Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2013-11-08T22:46:16Z"}, "message": "Re-factor tree.h - Part 1.\n\nThis is the first patch in a series of patches to cleanup tree.h to\nreduce the exposure it has all over the compiler.\n\nIn this patch, I'm moving functions that are used once into the files\nthat use them, and make them private to that file. These functions\nwere declared extern in tree.h and called from exactly one place.\n\nThe patch does not move EVERY function. This usually happens\nwhen the function uses private state from its original file, and\nmoving that private state would mean moving other functions that made\nno sense to move.\n\nAdditionally, the patch removes functions that were never used.\n\nIn subsequent patches, I will be moving out of tree.h extern definitions\nthat should be grouped in other files (e.g., all functions defined in\nsome FOO.c will be moved to the corresponding FOO.h). This will allow\nme to remove the inclusion of tree.h from some files.\n\n    * attribs.c (lookup_scoped_attribute_spec): Make static.\n    (get_attribute_namespace): Likewise.\n    * builtins.c (more_const_call_expr_args_p): Move from\n    tree.h.\n    (validate_arglist): Move earlier in the file. Make static.\n    (expand_stack_restore): Move from stmt.c\n    (expand_stack_save): Move from stmt.c\n    (rewrite_call_expr_array): Move earlier in the file.\n    (rewrite_call_expr_valist): Likewise.\n    * cfgexpand.c: Include hard-reg-set.h before tree.h\n    Include recog.h.\n    Include output.h.\n    (expand_asm_loc): Move from stmt.c.\n    (n_occurrences): Move from stmt.c.\n    (check_operand_nalternatives): Move from stmt.c.\n    (tree_conflicts_with_clobbers_p): Move from stmt.c.\n    (expand_asm_operands): Move from stmt.c\n    (expand_asm_stmt): Move from stmt.c\n    (expand_computed_goto): Move from stmt.c\n    (expand_goto): Move from stmt.c\n    (expand_null_return_1): Move from stmt.c\n    (expand_null_return): Move from stmt.c\n    (expand_value_return): Move from stmt.c\n    (expand_return): Move from stmt.c\n    (expand_main_function): Move from function.c\n    (stack_protect_prologue): Move from function.c\n    * cgraphclones.c (build_function_type_skip_args): Move from tree.c.\n    (build_function_decl_skip_args): Move from tree.c.\n    * explow.c (tree_expr_size): Move from tree.c.\n    * expr.c (addr_expr_of_non_mem_decl_p): Remove.\n    (fields_length): Move from tree.c.\n    * fold-const.c (size_low_cst): Move from tree.c.\n    (tree_expr_nonzero_warnv_p): Make static. Move earlier in the file.\n    (tree_expr_nonzero_p): Make static. Move earlier in the file.\n    (fold_build3_initializer_loc): Remove.\n    (tree_invalid_nonnegative_warnv_p): Make static.\n    * function.c (expand_main_function): Move to cfgexpand.c.\n    (stack_protect_prologue): Move to cfgexpand.c.\n    (set_insn_locations): Move earlier in the file.\n    * gimple-fold.c: Include langhooks.h.\n    (truth_type_for): Move from tree.c.\n    * print-tree.c (print_vec_tree): Remove.\n    * stmt.c (expand_computed_goto): Move to cfgexpand.c.\n    (expand_goto): Move to cfgexpand.c.\n    (n_occurrences): Move to cfgexpand.c.\n    (expand_asm_loc): Move to cfgexpand.c\n    (tree_conflicts_with_clobbers_p): Move to cfgexpand.c.\n    (expand_asm_operands): Move to cfgexpand.c.\n    (expand_asm_stmt): Move to cfgexpand.c.\n    (check_operand_nalternatives): Move to cfgexpand.c\n    (expand_null_return): Move to cfgexpand.c.\n    (expand_value_return): Move to cfgexpand.c.\n    (expand_null_return_1): Move to cfgexpand.c.\n    (expand_return): Move to cfgexpand.c.\n    (expand_stack_save): Move to builtins.c.\n    (expand_stack_restore): Move to builtins.c\n    * symtab.c: Include output.h.\n    (decl_assembler_name_hash): Move from tree.c.\n    (decl_assembler_name_equal): Move from tree.c.\n    * trans-mem.c (is_tm_safe_or_pure): Move from tree.h.\n    * tree-eh.c (in_array_bounds_p): Move from tree.c.\n    (range_in_array_bounds_p): Move from tree.c.\n    * tree-object-size.c (fini_object_sizes): Make static.\n    * tree-ssa-dom.c (iterative_hash_exprs_commutative): Move from tree.h.\n    * tree-vrp.c (ssa_name_nonnegative_p): Remove.\n    * tree.c (decl_assembler_name_equal): Move to symtab.c.\n    (tree_expr_size): Move to explow.c.\n    (decl_assembler_name_hash): Move to symtab.c.\n    (real_twop): Remove.\n    (tree_expr_size): Move to explow.c.\n    (stabilize_reference_1): Move earlier in the file. Make static.\n    (omp_remove_redundant_declare_simd_attrs): Remove.\n    (simple_cst_list_equal): Move earlier in the file. Make static.\n    (size_low_cst): Move to fold-const.c.\n    (build_type_no_quals): Remove.\n    (build_function_type_skip_args): Move to cgraphclones.c.\n    (build_function_decl_skip_args): Move to cgraphclones.c.\n    (in_array_bounds_p): Move to tree-eh.c.\n    (range_in_array_bounds_p): Move to tree-eh.c.\n    (truth_type_for): Move to gimple-fold.c.\n    (list_equal_p): remove.\n    * tree.h (decl_assembler_name_equal): Remove.\n    (decl_assembler_name_hash): Remove.\n    (truth_type_for): Remove.\n    (build_type_no_quals): Remove.\n    (build_function_decl_skip_args): Remove.\n    (in_array_bounds_p): Remove.\n    (range_in_array_bounds_p): Remove.\n    (size_low_cst): Remove.\n    (omp_remove_redundant_declare_simd_attrs): Remove.\n    (tree_expr_size): Remove.\n    (fields_length): Remove.\n    (stabilize_reference_1): Remove.\n    (expand_goto): Remove.\n    (expand_stack_save): Remove.\n    (expand_stack_restore): Remove.\n    (expand_return): Remove.\n    (fold_build3_initializer_loc): Remove.\n    (tree_expr_nonzero_p): Remove.\n    (tree_invalid_nonnegative_warnv_p): Remove.\n    (tree_expr_nonzero_warnv_p): Remove.\n    (fold_builtin_snprintf_chk): Remove.\n    (validate_arglist): Remove.\n    (iterative_hash_exprs_commutative): Move to tree-ssa-dom.c.\n    (simple_cst_list_equal): Remove.\n    (real_twop): Remove.\n    (expand_main_function): Remove.\n    (stack_protect_prologue): Remove.\n    (print_vec_tree): Remove.\n    (lookup_scoped_attribute_spec): Remove.\n    (get_attribute_namespace): Remove.\n    (expand_computed_goto): Remove.\n    (expand_asm_stmt): Remove.\n    (list_equal_p): Remove.\n    (ssa_name_nonnegative_p): Remove.\n    (fini_object_sizes): Remove.\n    (addr_expr_of_non_mem_decl_p): Remove.\n    (is_tm_safe_or_pure): Move to trans-mem.c.\n    (more_const_call_expr_args_p): Remove.\n    (save_vtable_map_decl): Remove.\n\nFrom-SVN: r204606", "tree": {"sha": "956d82c4131695b3b703c5ba7a83a02ad61d5928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/956d82c4131695b3b703c5ba7a83a02ad61d5928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862d0b359fb98790d5fad654eecf471228d8bb77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862d0b359fb98790d5fad654eecf471228d8bb77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862d0b359fb98790d5fad654eecf471228d8bb77", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862d0b359fb98790d5fad654eecf471228d8bb77/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0e56cd667259c3bc4234cb75c5137136af7b25d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e56cd667259c3bc4234cb75c5137136af7b25d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0e56cd667259c3bc4234cb75c5137136af7b25d"}], "stats": {"total": 3595, "additions": 1752, "deletions": 1843}, "files": [{"sha": "9387646a7a0294bdebafa939b432a0c8837f89d4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -172,6 +172,129 @@\n \tNo longer check if we have __builtin_trap, assume it's\n \tavailable.\n \n+2013-11-07  Diego Novillo  <dnovillo@google.com>\n+\n+\t* attribs.c (lookup_scoped_attribute_spec): Make static.\n+\t(get_attribute_namespace): Likewise.\n+\t* builtins.c (more_const_call_expr_args_p): Move from\n+\ttree.h.\n+\t(validate_arglist): Move earlier in the file. Make static.\n+\t(expand_stack_restore): Move from stmt.c\n+\t(expand_stack_save): Move from stmt.c\n+\t(rewrite_call_expr_array): Move earlier in the file.\n+\t(rewrite_call_expr_valist): Likewise.\n+\t* cfgexpand.c: Include hard-reg-set.h before tree.h\n+\tInclude recog.h.\n+\tInclude output.h.\n+\t(expand_asm_loc): Move from stmt.c.\n+\t(n_occurrences): Move from stmt.c.\n+\t(check_operand_nalternatives): Move from stmt.c.\n+\t(tree_conflicts_with_clobbers_p): Move from stmt.c.\n+\t(expand_asm_operands): Move from stmt.c\n+\t(expand_asm_stmt): Move from stmt.c\n+\t(expand_computed_goto): Move from stmt.c\n+\t(expand_goto): Move from stmt.c\n+\t(expand_null_return_1): Move from stmt.c\n+\t(expand_null_return): Move from stmt.c\n+\t(expand_value_return): Move from stmt.c\n+\t(expand_return): Move from stmt.c\n+\t(expand_main_function): Move from function.c\n+\t(stack_protect_prologue): Move from function.c\n+\t* cgraphclones.c (build_function_type_skip_args): Move from tree.c.\n+\t(build_function_decl_skip_args): Move from tree.c.\n+\t* explow.c (tree_expr_size): Move from tree.c.\n+\t* expr.c (addr_expr_of_non_mem_decl_p): Remove.\n+\t(fields_length): Move from tree.c.\n+\t* fold-const.c (size_low_cst): Move from tree.c.\n+\t(tree_expr_nonzero_warnv_p): Make static. Move earlier in the file.\n+\t(tree_expr_nonzero_p): Make static. Move earlier in the file.\n+\t(fold_build3_initializer_loc): Remove.\n+\t(tree_invalid_nonnegative_warnv_p): Make static.\n+\t* function.c (expand_main_function): Move to cfgexpand.c.\n+\t(stack_protect_prologue): Move to cfgexpand.c.\n+\t(set_insn_locations): Move earlier in the file.\n+\t* gimple-fold.c: Include langhooks.h.\n+\t(truth_type_for): Move from tree.c.\n+\t* print-tree.c (print_vec_tree): Remove.\n+\t* stmt.c (expand_computed_goto): Move to cfgexpand.c.\n+\t(expand_goto): Move to cfgexpand.c.\n+\t(n_occurrences): Move to cfgexpand.c.\n+\t(expand_asm_loc): Move to cfgexpand.c\n+\t(tree_conflicts_with_clobbers_p): Move to cfgexpand.c.\n+\t(expand_asm_operands): Move to cfgexpand.c.\n+\t(expand_asm_stmt): Move to cfgexpand.c.\n+\t(check_operand_nalternatives): Move to cfgexpand.c\n+\t(expand_null_return): Move to cfgexpand.c.\n+\t(expand_value_return): Move to cfgexpand.c.\n+\t(expand_null_return_1): Move to cfgexpand.c.\n+\t(expand_return): Move to cfgexpand.c.\n+\t(expand_stack_save): Move to builtins.c.\n+\t(expand_stack_restore): Move to builtins.c\n+\t* symtab.c: Include output.h.\n+\t(decl_assembler_name_hash): Move from tree.c.\n+\t(decl_assembler_name_equal): Move from tree.c.\n+\t* trans-mem.c (is_tm_safe_or_pure): Move from tree.h.\n+\t* tree-eh.c (in_array_bounds_p): Move from tree.c.\n+\t(range_in_array_bounds_p): Move from tree.c.\n+\t* tree-object-size.c (fini_object_sizes): Make static.\n+\t* tree-ssa-dom.c (iterative_hash_exprs_commutative): Move from tree.h.\n+\t* tree-vrp.c (ssa_name_nonnegative_p): Remove.\n+\t* tree.c (decl_assembler_name_equal): Move to symtab.c.\n+\t(tree_expr_size): Move to explow.c.\n+\t(decl_assembler_name_hash): Move to symtab.c.\n+\t(real_twop): Remove.\n+\t(tree_expr_size): Move to explow.c.\n+\t(stabilize_reference_1): Move earlier in the file. Make static.\n+\t(omp_remove_redundant_declare_simd_attrs): Remove.\n+\t(simple_cst_list_equal): Move earlier in the file. Make static.\n+\t(size_low_cst): Move to fold-const.c.\n+\t(build_type_no_quals): Remove.\n+\t(build_function_type_skip_args): Move to cgraphclones.c.\n+\t(build_function_decl_skip_args): Move to cgraphclones.c.\n+\t(in_array_bounds_p): Move to tree-eh.c.\n+\t(range_in_array_bounds_p): Move to tree-eh.c.\n+\t(truth_type_for): Move to gimple-fold.c.\n+\t(list_equal_p): remove.\n+\t* tree.h (decl_assembler_name_equal): Remove.\n+\t(decl_assembler_name_hash): Remove.\n+\t(truth_type_for): Remove.\n+\t(build_type_no_quals): Remove.\n+\t(build_function_decl_skip_args): Remove.\n+\t(in_array_bounds_p): Remove.\n+\t(range_in_array_bounds_p): Remove.\n+\t(size_low_cst): Remove.\n+\t(omp_remove_redundant_declare_simd_attrs): Remove.\n+\t(tree_expr_size): Remove.\n+\t(fields_length): Remove.\n+\t(stabilize_reference_1): Remove.\n+\t(expand_goto): Remove.\n+\t(expand_stack_save): Remove.\n+\t(expand_stack_restore): Remove.\n+\t(expand_return): Remove.\n+\t(fold_build3_initializer_loc): Remove.\n+\t(tree_expr_nonzero_p): Remove.\n+\t(tree_invalid_nonnegative_warnv_p): Remove.\n+\t(tree_expr_nonzero_warnv_p): Remove.\n+\t(fold_builtin_snprintf_chk): Remove.\n+\t(validate_arglist): Remove.\n+\t(iterative_hash_exprs_commutative): Move to tree-ssa-dom.c.\n+\t(simple_cst_list_equal): Remove.\n+\t(real_twop): Remove.\n+\t(expand_main_function): Remove.\n+\t(stack_protect_prologue): Remove.\n+\t(print_vec_tree): Remove.\n+\t(lookup_scoped_attribute_spec): Remove.\n+\t(get_attribute_namespace): Remove.\n+\t(expand_computed_goto): Remove.\n+\t(expand_asm_stmt): Remove.\n+\t(list_equal_p): Remove.\n+\t(ssa_name_nonnegative_p): Remove.\n+\t(fini_object_sizes): Remove.\n+\t(addr_expr_of_non_mem_decl_p): Remove.\n+\t(is_tm_safe_or_pure): Move to trans-mem.c.\n+\t(more_const_call_expr_args_p): Remove.\n+\t(save_vtable_map_decl): Remove.\n+\n 2013-11-07  Thomas Schwinge  <thomas@codesourcery.com>\n \n \t* doc/sourcebuild.texi (Top Level) <lto-plugin>: GNU ld can use"}, {"sha": "296bcd6eb740bc0a5bb215ab8417b0678a49d74c", "filename": "gcc/attribs.c", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -297,7 +297,7 @@ register_scoped_attribute (const struct attribute_spec *attr,\n /* Return the spec for the scoped attribute with namespace NS and\n    name NAME.   */\n \n-const struct attribute_spec *\n+static const struct attribute_spec *\n lookup_scoped_attribute_spec (const_tree ns, const_tree name)\n {\n   struct substring attr;\n@@ -334,7 +334,23 @@ lookup_attribute_spec (const_tree name)\n   return lookup_scoped_attribute_spec (ns, name);\n }\n \n-\f\n+\n+/* Return the namespace of the attribute ATTR.  This accessor works on\n+   GNU and C++11 (scoped) attributes.  On GNU attributes,\n+   it returns an identifier tree for the string \"gnu\".\n+\n+   Please read the comments of cxx11_attribute_p to understand the\n+   format of attributes.  */\n+\n+static tree\n+get_attribute_namespace (const_tree attr)\n+{\n+  if (cxx11_attribute_p (attr))\n+    return TREE_PURPOSE (TREE_PURPOSE (attr));\n+  return get_identifier (\"gnu\");\n+}\n+\n+\n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n    which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n    it should be modified in place; if a TYPE, a copy should be created\n@@ -659,21 +675,6 @@ get_attribute_name (const_tree attr)\n   return TREE_PURPOSE (attr);\n }\n \n-/* Return the namespace of the attribute ATTR.  This accessor works on\n-   GNU and C++11 (scoped) attributes.  On GNU attributes,\n-   it returns an identifier tree for the string \"gnu\".\n-\n-   Please read the comments of cxx11_attribute_p to understand the\n-   format of attributes.  */\n-\n-tree\n-get_attribute_namespace (const_tree attr)\n-{\n-  if (cxx11_attribute_p (attr))\n-    return TREE_PURPOSE (TREE_PURPOSE (attr));\n-  return get_identifier (\"gnu\");\n-}\n-\n /* Subroutine of set_method_tm_attributes.  Apply TM attribute ATTR\n    to the method FNDECL.  */\n "}, {"sha": "7a04664c9099ced6ed1437af25047a0e05499fdf", "filename": "gcc/builtins.c", "status": "modified", "additions": 165, "deletions": 132, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -1050,6 +1050,63 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n     }\n }\n \n+static inline bool\n+more_const_call_expr_args_p (const const_call_expr_arg_iterator *iter)\n+{\n+  return (iter->i < iter->n);\n+}\n+\n+/* This function validates the types of a function call argument list\n+   against a specified list of tree_codes.  If the last specifier is a 0,\n+   that represents an ellipses, otherwise the last specifier must be a\n+   VOID_TYPE.  */\n+\n+static bool\n+validate_arglist (const_tree callexpr, ...)\n+{\n+  enum tree_code code;\n+  bool res = 0;\n+  va_list ap;\n+  const_call_expr_arg_iterator iter;\n+  const_tree arg;\n+\n+  va_start (ap, callexpr);\n+  init_const_call_expr_arg_iterator (callexpr, &iter);\n+\n+  do\n+    {\n+      code = (enum tree_code) va_arg (ap, int);\n+      switch (code)\n+\t{\n+\tcase 0:\n+\t  /* This signifies an ellipses, any further arguments are all ok.  */\n+\t  res = true;\n+\t  goto end;\n+\tcase VOID_TYPE:\n+\t  /* This signifies an endlink, if no arguments remain, return\n+\t     true, otherwise return false.  */\n+\t  res = !more_const_call_expr_args_p (&iter);\n+\t  goto end;\n+\tdefault:\n+\t  /* If no parameters remain or the parameter's code does not\n+\t     match the specified code, return false.  Otherwise continue\n+\t     checking any remaining arguments.  */\n+\t  arg = next_const_call_expr_arg (&iter);\n+\t  if (!validate_arg (arg, code))\n+\t    goto end;\n+\t  break;\n+\t}\n+    }\n+  while (1);\n+\n+  /* We need gotos here since we can only have one VA_CLOSE in a\n+     function.  */\n+ end: ;\n+  va_end (ap);\n+\n+  return res;\n+}\n+\n /* Expand a call to __builtin_nonlocal_goto.  We're passed the target label\n    and the address of the save area.  */\n \n@@ -5581,6 +5638,33 @@ expand_builtin_set_thread_pointer (tree exp)\n }\n \n \f\n+/* Emit code to restore the current value of stack.  */\n+\n+static void\n+expand_stack_restore (tree var)\n+{\n+  rtx prev, sa = expand_normal (var);\n+\n+  sa = convert_memory_address (Pmode, sa);\n+\n+  prev = get_last_insn ();\n+  emit_stack_restore (SAVE_BLOCK, sa);\n+  fixup_args_size_notes (prev, get_last_insn (), 0);\n+}\n+\n+\n+/* Emit code to save the current value of stack.  */\n+\n+static rtx\n+expand_stack_save (void)\n+{\n+  rtx ret = NULL_RTX;\n+\n+  do_pending_stack_adjust ();\n+  emit_stack_save (SAVE_BLOCK, &ret);\n+  return ret;\n+}\n+\n /* Expand an expression EXP that calls a built-in function,\n    with result going to TARGET if that's convenient\n    (and in mode MODE if that's convenient).\n@@ -10962,47 +11046,51 @@ fold_builtin_n (location_t loc, tree fndecl, tree *args, int nargs, bool ignore)\n   return NULL_TREE;\n }\n \n-/* Builtins with folding operations that operate on \"...\" arguments\n-   need special handling; we need to store the arguments in a convenient\n-   data structure before attempting any folding.  Fortunately there are\n-   only a few builtins that fall into this category.  FNDECL is the\n-   function, EXP is the CALL_EXPR for the call, and IGNORE is true if the\n-   result of the function call is ignored.  */\n+/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n+   list ARGS along with N new arguments in NEWARGS.  SKIP is the number\n+   of arguments in ARGS to be omitted.  OLDNARGS is the number of\n+   elements in ARGS.  */\n \n static tree\n-fold_builtin_varargs (location_t loc, tree fndecl, tree exp,\n-\t\t      bool ignore ATTRIBUTE_UNUSED)\n+rewrite_call_expr_valist (location_t loc, int oldnargs, tree *args,\n+\t\t\t  int skip, tree fndecl, int n, va_list newargs)\n {\n-  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n-  tree ret = NULL_TREE;\n+  int nargs = oldnargs - skip + n;\n+  tree *buffer;\n \n-  switch (fcode)\n+  if (n > 0)\n     {\n-    case BUILT_IN_SPRINTF_CHK:\n-    case BUILT_IN_VSPRINTF_CHK:\n-      ret = fold_builtin_sprintf_chk (loc, exp, fcode);\n-      break;\n+      int i, j;\n \n-    case BUILT_IN_SNPRINTF_CHK:\n-    case BUILT_IN_VSNPRINTF_CHK:\n-      ret = fold_builtin_snprintf_chk (loc, exp, NULL_TREE, fcode);\n-      break;\n+      buffer = XALLOCAVEC (tree, nargs);\n+      for (i = 0; i < n; i++)\n+\tbuffer[i] = va_arg (newargs, tree);\n+      for (j = skip; j < oldnargs; j++, i++)\n+\tbuffer[i] = args[j];\n+    }\n+  else\n+    buffer = args + skip;\n \n-    case BUILT_IN_FPCLASSIFY:\n-      ret = fold_builtin_fpclassify (loc, exp);\n-      break;\n+  return build_call_expr_loc_array (loc, fndecl, nargs, buffer);\n+}\n \n-    default:\n-      break;\n-    }\n-  if (ret)\n-    {\n-      ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n-      SET_EXPR_LOCATION (ret, loc);\n-      TREE_NO_WARNING (ret) = 1;\n-      return ret;\n-    }\n-  return NULL_TREE;\n+/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n+   list ARGS along with N new arguments specified as the \"...\"\n+   parameters.  SKIP is the number of arguments in ARGS to be omitted.\n+   OLDNARGS is the number of elements in ARGS.  */\n+\n+static tree\n+rewrite_call_expr_array (location_t loc, int oldnargs, tree *args,\n+\t\t\t int skip, tree fndecl, int n, ...)\n+{\n+  va_list ap;\n+  tree t;\n+\n+  va_start (ap, n);\n+  t = rewrite_call_expr_valist (loc, oldnargs, args, skip, fndecl, n, ap);\n+  va_end (ap);\n+\n+  return t;\n }\n \n /* Return true if FNDECL shouldn't be folded right now.\n@@ -11193,53 +11281,6 @@ fold_builtin_call_array (location_t loc, tree type,\n   return build_call_array_loc (loc, type, fn, n, argarray);\n }\n \n-/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n-   list ARGS along with N new arguments in NEWARGS.  SKIP is the number\n-   of arguments in ARGS to be omitted.  OLDNARGS is the number of\n-   elements in ARGS.  */\n-\n-static tree\n-rewrite_call_expr_valist (location_t loc, int oldnargs, tree *args,\n-\t\t\t  int skip, tree fndecl, int n, va_list newargs)\n-{\n-  int nargs = oldnargs - skip + n;\n-  tree *buffer;\n-\n-  if (n > 0)\n-    {\n-      int i, j;\n-\n-      buffer = XALLOCAVEC (tree, nargs);\n-      for (i = 0; i < n; i++)\n-\tbuffer[i] = va_arg (newargs, tree);\n-      for (j = skip; j < oldnargs; j++, i++)\n-\tbuffer[i] = args[j];\n-    }\n-  else\n-    buffer = args + skip;\n-\n-  return build_call_expr_loc_array (loc, fndecl, nargs, buffer);\n-}\n-\n-/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n-   list ARGS along with N new arguments specified as the \"...\"\n-   parameters.  SKIP is the number of arguments in ARGS to be omitted.\n-   OLDNARGS is the number of elements in ARGS.  */\n-\n-static tree\n-rewrite_call_expr_array (location_t loc, int oldnargs, tree *args,\n-\t\t\t int skip, tree fndecl, int n, ...)\n-{\n-  va_list ap;\n-  tree t;\n-\n-  va_start (ap, n);\n-  t = rewrite_call_expr_valist (loc, oldnargs, args, skip, fndecl, n, ap);\n-  va_end (ap);\n-\n-  return t;\n-}\n-\n /* Construct a new CALL_EXPR using the tail of the argument list of EXP\n    along with N new arguments specified as the \"...\" parameters.  SKIP\n    is the number of arguments in EXP to be omitted.  This function is used\n@@ -11329,57 +11370,6 @@ validate_gimple_arglist (const_gimple call, ...)\n   return res;\n }\n \n-/* This function validates the types of a function call argument list\n-   against a specified list of tree_codes.  If the last specifier is a 0,\n-   that represents an ellipses, otherwise the last specifier must be a\n-   VOID_TYPE.  */\n-\n-bool\n-validate_arglist (const_tree callexpr, ...)\n-{\n-  enum tree_code code;\n-  bool res = 0;\n-  va_list ap;\n-  const_call_expr_arg_iterator iter;\n-  const_tree arg;\n-\n-  va_start (ap, callexpr);\n-  init_const_call_expr_arg_iterator (callexpr, &iter);\n-\n-  do\n-    {\n-      code = (enum tree_code) va_arg (ap, int);\n-      switch (code)\n-\t{\n-\tcase 0:\n-\t  /* This signifies an ellipses, any further arguments are all ok.  */\n-\t  res = true;\n-\t  goto end;\n-\tcase VOID_TYPE:\n-\t  /* This signifies an endlink, if no arguments remain, return\n-\t     true, otherwise return false.  */\n-\t  res = !more_const_call_expr_args_p (&iter);\n-\t  goto end;\n-\tdefault:\n-\t  /* If no parameters remain or the parameter's code does not\n-\t     match the specified code, return false.  Otherwise continue\n-\t     checking any remaining arguments.  */\n-\t  arg = next_const_call_expr_arg (&iter);\n-\t  if (!validate_arg (arg, code))\n-\t    goto end;\n-\t  break;\n-\t}\n-    }\n-  while (1);\n-\n-  /* We need gotos here since we can only have one VA_CLOSE in a\n-     function.  */\n- end: ;\n-  va_end (ap);\n-\n-  return res;\n-}\n-\n /* Default target-specific builtin expander that does nothing.  */\n \n rtx\n@@ -13151,14 +13141,57 @@ fold_builtin_snprintf_chk_1 (location_t loc, int nargs, tree *args,\n    BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n    passed as second argument.  */\n \n-tree\n+static tree\n fold_builtin_snprintf_chk (location_t loc, tree exp, tree maxlen,\n \t\t\t   enum built_in_function fcode)\n {\n   return fold_builtin_snprintf_chk_1 (loc, call_expr_nargs (exp),\n \t\t\t\t      CALL_EXPR_ARGP (exp), maxlen, fcode);\n }\n \n+/* Builtins with folding operations that operate on \"...\" arguments\n+   need special handling; we need to store the arguments in a convenient\n+   data structure before attempting any folding.  Fortunately there are\n+   only a few builtins that fall into this category.  FNDECL is the\n+   function, EXP is the CALL_EXPR for the call, and IGNORE is true if the\n+   result of the function call is ignored.  */\n+\n+static tree\n+fold_builtin_varargs (location_t loc, tree fndecl, tree exp,\n+\t\t      bool ignore ATTRIBUTE_UNUSED)\n+{\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree ret = NULL_TREE;\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_SPRINTF_CHK:\n+    case BUILT_IN_VSPRINTF_CHK:\n+      ret = fold_builtin_sprintf_chk (loc, exp, fcode);\n+      break;\n+\n+    case BUILT_IN_SNPRINTF_CHK:\n+    case BUILT_IN_VSNPRINTF_CHK:\n+      ret = fold_builtin_snprintf_chk (loc, exp, NULL_TREE, fcode);\n+      break;\n+\n+    case BUILT_IN_FPCLASSIFY:\n+      ret = fold_builtin_fpclassify (loc, exp);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  if (ret)\n+    {\n+      ret = build1 (NOP_EXPR, TREE_TYPE (ret), ret);\n+      SET_EXPR_LOCATION (ret, loc);\n+      TREE_NO_WARNING (ret) = 1;\n+      return ret;\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Fold a call to the {,v}printf{,_unlocked} and __{,v}printf_chk builtins.\n    FMT and ARG are the arguments to the call; we don't fold cases with\n    more than 2 arguments, and ARG may be null if this is a 1-argument case."}, {"sha": "8faf48ad4f8d557165fad7523667e36f92633df8", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 910, "deletions": 1, "changes": 911, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -21,8 +21,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n-#include \"tree.h\"\n #include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"tree.h\"\n #include \"tm_p.h\"\n #include \"basic-block.h\"\n #include \"function.h\"\n@@ -57,6 +58,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"insn-attr.h\" /* For INSN_SCHEDULING.  */\n #include \"asan.h\"\n #include \"tree-ssa-address.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n \n /* This variable holds information helping the rewriting of SSA trees\n    into RTL.  */\n@@ -2194,6 +2197,866 @@ expand_call_stmt (gimple stmt)\n   mark_transaction_restart_calls (stmt);\n }\n \n+\n+/* Generate RTL for an asm statement (explicit assembler code).\n+   STRING is a STRING_CST node containing the assembler code text,\n+   or an ADDR_EXPR containing a STRING_CST.  VOL nonzero means the\n+   insn is volatile; don't optimize it.  */\n+\n+static void\n+expand_asm_loc (tree string, int vol, location_t locus)\n+{\n+  rtx body;\n+\n+  if (TREE_CODE (string) == ADDR_EXPR)\n+    string = TREE_OPERAND (string, 0);\n+\n+  body = gen_rtx_ASM_INPUT_loc (VOIDmode,\n+\t\t\t\tggc_strdup (TREE_STRING_POINTER (string)),\n+\t\t\t\tlocus);\n+\n+  MEM_VOLATILE_P (body) = vol;\n+\n+  emit_insn (body);\n+}\n+\n+/* Return the number of times character C occurs in string S.  */\n+static int\n+n_occurrences (int c, const char *s)\n+{\n+  int n = 0;\n+  while (*s)\n+    n += (*s++ == c);\n+  return n;\n+}\n+\n+/* A subroutine of expand_asm_operands.  Check that all operands have\n+   the same number of alternatives.  Return true if so.  */\n+\n+static bool\n+check_operand_nalternatives (tree outputs, tree inputs)\n+{\n+  if (outputs || inputs)\n+    {\n+      tree tmp = TREE_PURPOSE (outputs ? outputs : inputs);\n+      int nalternatives\n+\t= n_occurrences (',', TREE_STRING_POINTER (TREE_VALUE (tmp)));\n+      tree next = inputs;\n+\n+      if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n+\t{\n+\t  error (\"too many alternatives in %<asm%>\");\n+\t  return false;\n+\t}\n+\n+      tmp = outputs;\n+      while (tmp)\n+\t{\n+\t  const char *constraint\n+\t    = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tmp)));\n+\n+\t  if (n_occurrences (',', constraint) != nalternatives)\n+\t    {\n+\t      error (\"operand constraints for %<asm%> differ \"\n+\t\t     \"in number of alternatives\");\n+\t      return false;\n+\t    }\n+\n+\t  if (TREE_CHAIN (tmp))\n+\t    tmp = TREE_CHAIN (tmp);\n+\t  else\n+\t    tmp = next, next = 0;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+/* Check for overlap between registers marked in CLOBBERED_REGS and\n+   anything inappropriate in T.  Emit error and return the register\n+   variable definition for error, NULL_TREE for ok.  */\n+\n+static bool\n+tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n+{\n+  /* Conflicts between asm-declared register variables and the clobber\n+     list are not allowed.  */\n+  tree overlap = tree_overlaps_hard_reg_set (t, clobbered_regs);\n+\n+  if (overlap)\n+    {\n+      error (\"asm-specifier for variable %qE conflicts with asm clobber list\",\n+\t     DECL_NAME (overlap));\n+\n+      /* Reset registerness to stop multiple errors emitted for a single\n+\t variable.  */\n+      DECL_REGISTER (overlap) = 0;\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Generate RTL for an asm statement with arguments.\n+   STRING is the instruction template.\n+   OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n+   Each output or input has an expression in the TREE_VALUE and\n+   a tree list in TREE_PURPOSE which in turn contains a constraint\n+   name in TREE_VALUE (or NULL_TREE) and a constraint string\n+   in TREE_PURPOSE.\n+   CLOBBERS is a list of STRING_CST nodes each naming a hard register\n+   that is clobbered by this insn.\n+\n+   LABELS is a list of labels, and if LABELS is non-NULL, FALLTHRU_BB\n+   should be the fallthru basic block of the asm goto.\n+\n+   Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.\n+   Some elements of OUTPUTS may be replaced with trees representing temporary\n+   values.  The caller should copy those temporary values to the originally\n+   specified lvalues.\n+\n+   VOL nonzero means the insn is volatile; don't optimize it.  */\n+\n+static void\n+expand_asm_operands (tree string, tree outputs, tree inputs,\n+\t\t     tree clobbers, tree labels, basic_block fallthru_bb,\n+\t\t     int vol, location_t locus)\n+{\n+  rtvec argvec, constraintvec, labelvec;\n+  rtx body;\n+  int ninputs = list_length (inputs);\n+  int noutputs = list_length (outputs);\n+  int nlabels = list_length (labels);\n+  int ninout;\n+  int nclobbers;\n+  HARD_REG_SET clobbered_regs;\n+  int clobber_conflict_found = 0;\n+  tree tail;\n+  tree t;\n+  int i;\n+  /* Vector of RTX's of evaluated output operands.  */\n+  rtx *output_rtx = XALLOCAVEC (rtx, noutputs);\n+  int *inout_opnum = XALLOCAVEC (int, noutputs);\n+  rtx *real_output_rtx = XALLOCAVEC (rtx, noutputs);\n+  enum machine_mode *inout_mode = XALLOCAVEC (enum machine_mode, noutputs);\n+  const char **constraints = XALLOCAVEC (const char *, noutputs + ninputs);\n+  int old_generating_concat_p = generating_concat_p;\n+  rtx fallthru_label = NULL_RTX;\n+\n+  /* An ASM with no outputs needs to be treated as volatile, for now.  */\n+  if (noutputs == 0)\n+    vol = 1;\n+\n+  if (! check_operand_nalternatives (outputs, inputs))\n+    return;\n+\n+  string = resolve_asm_operand_names (string, outputs, inputs, labels);\n+\n+  /* Collect constraints.  */\n+  i = 0;\n+  for (t = outputs; t ; t = TREE_CHAIN (t), i++)\n+    constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+  for (t = inputs; t ; t = TREE_CHAIN (t), i++)\n+    constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+\n+  /* Sometimes we wish to automatically clobber registers across an asm.\n+     Case in point is when the i386 backend moved from cc0 to a hard reg --\n+     maintaining source-level compatibility means automatically clobbering\n+     the flags register.  */\n+  clobbers = targetm.md_asm_clobbers (outputs, inputs, clobbers);\n+\n+  /* Count the number of meaningful clobbered registers, ignoring what\n+     we would ignore later.  */\n+  nclobbers = 0;\n+  CLEAR_HARD_REG_SET (clobbered_regs);\n+  for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n+    {\n+      const char *regname;\n+      int nregs;\n+\n+      if (TREE_VALUE (tail) == error_mark_node)\n+\treturn;\n+      regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n+\n+      i = decode_reg_name_and_count (regname, &nregs);\n+      if (i == -4)\n+\t++nclobbers;\n+      else if (i == -2)\n+\terror (\"unknown register name %qs in %<asm%>\", regname);\n+\n+      /* Mark clobbered registers.  */\n+      if (i >= 0)\n+        {\n+\t  int reg;\n+\n+\t  for (reg = i; reg < i + nregs; reg++)\n+\t    {\n+\t      ++nclobbers;\n+\n+\t      /* Clobbering the PIC register is an error.  */\n+\t      if (reg == (int) PIC_OFFSET_TABLE_REGNUM)\n+\t\t{\n+\t\t  error (\"PIC register clobbered by %qs in %<asm%>\", regname);\n+\t\t  return;\n+\t\t}\n+\n+\t      SET_HARD_REG_BIT (clobbered_regs, reg);\n+\t    }\n+\t}\n+    }\n+\n+  /* First pass over inputs and outputs checks validity and sets\n+     mark_addressable if needed.  */\n+\n+  ninout = 0;\n+  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+    {\n+      tree val = TREE_VALUE (tail);\n+      tree type = TREE_TYPE (val);\n+      const char *constraint;\n+      bool is_inout;\n+      bool allows_reg;\n+      bool allows_mem;\n+\n+      /* If there's an erroneous arg, emit no insn.  */\n+      if (type == error_mark_node)\n+\treturn;\n+\n+      /* Try to parse the output constraint.  If that fails, there's\n+\t no point in going further.  */\n+      constraint = constraints[i];\n+      if (!parse_output_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t    &allows_mem, &allows_reg, &is_inout))\n+\treturn;\n+\n+      if (! allows_reg\n+\t  && (allows_mem\n+\t      || is_inout\n+\t      || (DECL_P (val)\n+\t\t  && REG_P (DECL_RTL (val))\n+\t\t  && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n+\tmark_addressable (val);\n+\n+      if (is_inout)\n+\tninout++;\n+    }\n+\n+  ninputs += ninout;\n+  if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n+    {\n+      error (\"more than %d operands in %<asm%>\", MAX_RECOG_OPERANDS);\n+      return;\n+    }\n+\n+  for (i = 0, tail = inputs; tail; i++, tail = TREE_CHAIN (tail))\n+    {\n+      bool allows_reg, allows_mem;\n+      const char *constraint;\n+\n+      /* If there's an erroneous arg, emit no insn, because the ASM_INPUT\n+\t would get VOIDmode and that could cause a crash in reload.  */\n+      if (TREE_TYPE (TREE_VALUE (tail)) == error_mark_node)\n+\treturn;\n+\n+      constraint = constraints[i + noutputs];\n+      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n+\t\t\t\t    constraints, &allows_mem, &allows_reg))\n+\treturn;\n+\n+      if (! allows_reg && allows_mem)\n+\tmark_addressable (TREE_VALUE (tail));\n+    }\n+\n+  /* Second pass evaluates arguments.  */\n+\n+  /* Make sure stack is consistent for asm goto.  */\n+  if (nlabels > 0)\n+    do_pending_stack_adjust ();\n+\n+  ninout = 0;\n+  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+    {\n+      tree val = TREE_VALUE (tail);\n+      tree type = TREE_TYPE (val);\n+      bool is_inout;\n+      bool allows_reg;\n+      bool allows_mem;\n+      rtx op;\n+      bool ok;\n+\n+      ok = parse_output_constraint (&constraints[i], i, ninputs,\n+\t\t\t\t    noutputs, &allows_mem, &allows_reg,\n+\t\t\t\t    &is_inout);\n+      gcc_assert (ok);\n+\n+      /* If an output operand is not a decl or indirect ref and our constraint\n+\t allows a register, make a temporary to act as an intermediate.\n+\t Make the asm insn write into that, then our caller will copy it to\n+\t the real output operand.  Likewise for promoted variables.  */\n+\n+      generating_concat_p = 0;\n+\n+      real_output_rtx[i] = NULL_RTX;\n+      if ((TREE_CODE (val) == INDIRECT_REF\n+\t   && allows_mem)\n+\t  || (DECL_P (val)\n+\t      && (allows_mem || REG_P (DECL_RTL (val)))\n+\t      && ! (REG_P (DECL_RTL (val))\n+\t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n+\t  || ! allows_reg\n+\t  || is_inout)\n+\t{\n+\t  op = expand_expr (val, NULL_RTX, VOIDmode,\n+\t\t\t    !allows_reg ? EXPAND_MEMORY : EXPAND_WRITE);\n+\t  if (MEM_P (op))\n+\t    op = validize_mem (op);\n+\n+\t  if (! allows_reg && !MEM_P (op))\n+\t    error (\"output number %d not directly addressable\", i);\n+\t  if ((! allows_mem && MEM_P (op))\n+\t      || GET_CODE (op) == CONCAT)\n+\t    {\n+\t      real_output_rtx[i] = op;\n+\t      op = gen_reg_rtx (GET_MODE (op));\n+\t      if (is_inout)\n+\t\temit_move_insn (op, real_output_rtx[i]);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  op = assign_temp (type, 0, 1);\n+\t  op = validize_mem (op);\n+\t  if (!MEM_P (op) && TREE_CODE (TREE_VALUE (tail)) == SSA_NAME)\n+\t    set_reg_attrs_for_decl_rtl (SSA_NAME_VAR (TREE_VALUE (tail)), op);\n+\t  TREE_VALUE (tail) = make_tree (type, op);\n+\t}\n+      output_rtx[i] = op;\n+\n+      generating_concat_p = old_generating_concat_p;\n+\n+      if (is_inout)\n+\t{\n+\t  inout_mode[ninout] = TYPE_MODE (type);\n+\t  inout_opnum[ninout++] = i;\n+\t}\n+\n+      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n+\tclobber_conflict_found = 1;\n+    }\n+\n+  /* Make vectors for the expression-rtx, constraint strings,\n+     and named operands.  */\n+\n+  argvec = rtvec_alloc (ninputs);\n+  constraintvec = rtvec_alloc (ninputs);\n+  labelvec = rtvec_alloc (nlabels);\n+\n+  body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n+\t\t\t\t: GET_MODE (output_rtx[0])),\n+\t\t\t       ggc_strdup (TREE_STRING_POINTER (string)),\n+\t\t\t       empty_string, 0, argvec, constraintvec,\n+\t\t\t       labelvec, locus);\n+\n+  MEM_VOLATILE_P (body) = vol;\n+\n+  /* Eval the inputs and put them into ARGVEC.\n+     Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */\n+\n+  for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), ++i)\n+    {\n+      bool allows_reg, allows_mem;\n+      const char *constraint;\n+      tree val, type;\n+      rtx op;\n+      bool ok;\n+\n+      constraint = constraints[i + noutputs];\n+      ok = parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n+\t\t\t\t   constraints, &allows_mem, &allows_reg);\n+      gcc_assert (ok);\n+\n+      generating_concat_p = 0;\n+\n+      val = TREE_VALUE (tail);\n+      type = TREE_TYPE (val);\n+      /* EXPAND_INITIALIZER will not generate code for valid initializer\n+\t constants, but will still generate code for other types of operand.\n+\t This is the behavior we want for constant constraints.  */\n+      op = expand_expr (val, NULL_RTX, VOIDmode,\n+\t\t\tallows_reg ? EXPAND_NORMAL\n+\t\t\t: allows_mem ? EXPAND_MEMORY\n+\t\t\t: EXPAND_INITIALIZER);\n+\n+      /* Never pass a CONCAT to an ASM.  */\n+      if (GET_CODE (op) == CONCAT)\n+\top = force_reg (GET_MODE (op), op);\n+      else if (MEM_P (op))\n+\top = validize_mem (op);\n+\n+      if (asm_operand_ok (op, constraint, NULL) <= 0)\n+\t{\n+\t  if (allows_reg && TYPE_MODE (type) != BLKmode)\n+\t    op = force_reg (TYPE_MODE (type), op);\n+\t  else if (!allows_mem)\n+\t    warning (0, \"asm operand %d probably doesn%'t match constraints\",\n+\t\t     i + noutputs);\n+\t  else if (MEM_P (op))\n+\t    {\n+\t      /* We won't recognize either volatile memory or memory\n+\t\t with a queued address as available a memory_operand\n+\t\t at this point.  Ignore it: clearly this *is* a memory.  */\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      generating_concat_p = old_generating_concat_p;\n+      ASM_OPERANDS_INPUT (body, i) = op;\n+\n+      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n+\t= gen_rtx_ASM_INPUT (TYPE_MODE (type),\n+\t\t\t     ggc_strdup (constraints[i + noutputs]));\n+\n+      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n+\tclobber_conflict_found = 1;\n+    }\n+\n+  /* Protect all the operands from the queue now that they have all been\n+     evaluated.  */\n+\n+  generating_concat_p = 0;\n+\n+  /* For in-out operands, copy output rtx to input rtx.  */\n+  for (i = 0; i < ninout; i++)\n+    {\n+      int j = inout_opnum[i];\n+      char buffer[16];\n+\n+      ASM_OPERANDS_INPUT (body, ninputs - ninout + i)\n+\t= output_rtx[j];\n+\n+      sprintf (buffer, \"%d\", j);\n+      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, ninputs - ninout + i)\n+\t= gen_rtx_ASM_INPUT (inout_mode[i], ggc_strdup (buffer));\n+    }\n+\n+  /* Copy labels to the vector.  */\n+  for (i = 0, tail = labels; i < nlabels; ++i, tail = TREE_CHAIN (tail))\n+    {\n+      rtx r;\n+      /* If asm goto has any labels in the fallthru basic block, use\n+\t a label that we emit immediately after the asm goto.  Expansion\n+\t may insert further instructions into the same basic block after\n+\t asm goto and if we don't do this, insertion of instructions on\n+\t the fallthru edge might misbehave.  See PR58670.  */\n+      if (fallthru_bb\n+\t  && label_to_block_fn (cfun, TREE_VALUE (tail)) == fallthru_bb)\n+\t{\n+\t  if (fallthru_label == NULL_RTX)\n+\t    fallthru_label = gen_label_rtx ();\n+\t  r = fallthru_label;\n+\t}\n+      else\n+\tr = label_rtx (TREE_VALUE (tail));\n+      ASM_OPERANDS_LABEL (body, i) = gen_rtx_LABEL_REF (Pmode, r);\n+    }\n+\n+  generating_concat_p = old_generating_concat_p;\n+\n+  /* Now, for each output, construct an rtx\n+     (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER\n+\t\t\t       ARGVEC CONSTRAINTS OPNAMES))\n+     If there is more than one, put them inside a PARALLEL.  */\n+\n+  if (nlabels > 0 && nclobbers == 0)\n+    {\n+      gcc_assert (noutputs == 0);\n+      emit_jump_insn (body);\n+    }\n+  else if (noutputs == 0 && nclobbers == 0)\n+    {\n+      /* No output operands: put in a raw ASM_OPERANDS rtx.  */\n+      emit_insn (body);\n+    }\n+  else if (noutputs == 1 && nclobbers == 0)\n+    {\n+      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = ggc_strdup (constraints[0]);\n+      emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n+    }\n+  else\n+    {\n+      rtx obody = body;\n+      int num = noutputs;\n+\n+      if (num == 0)\n+\tnum = 1;\n+\n+      body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num + nclobbers));\n+\n+      /* For each output operand, store a SET.  */\n+      for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+\t{\n+\t  XVECEXP (body, 0, i)\n+\t    = gen_rtx_SET (VOIDmode,\n+\t\t\t   output_rtx[i],\n+\t\t\t   gen_rtx_ASM_OPERANDS\n+\t\t\t   (GET_MODE (output_rtx[i]),\n+\t\t\t    ggc_strdup (TREE_STRING_POINTER (string)),\n+\t\t\t    ggc_strdup (constraints[i]),\n+\t\t\t    i, argvec, constraintvec, labelvec, locus));\n+\n+\t  MEM_VOLATILE_P (SET_SRC (XVECEXP (body, 0, i))) = vol;\n+\t}\n+\n+      /* If there are no outputs (but there are some clobbers)\n+\t store the bare ASM_OPERANDS into the PARALLEL.  */\n+\n+      if (i == 0)\n+\tXVECEXP (body, 0, i++) = obody;\n+\n+      /* Store (clobber REG) for each clobbered register specified.  */\n+\n+      for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n+\t{\n+\t  const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n+\t  int reg, nregs;\n+\t  int j = decode_reg_name_and_count (regname, &nregs);\n+\t  rtx clobbered_reg;\n+\n+\t  if (j < 0)\n+\t    {\n+\t      if (j == -3)\t/* `cc', which is not a register */\n+\t\tcontinue;\n+\n+\t      if (j == -4)\t/* `memory', don't cache memory across asm */\n+\t\t{\n+\t\t  XVECEXP (body, 0, i++)\n+\t\t    = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t       gen_rtx_MEM\n+\t\t\t\t       (BLKmode,\n+\t\t\t\t\tgen_rtx_SCRATCH (VOIDmode)));\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* Ignore unknown register, error already signaled.  */\n+\t      continue;\n+\t    }\n+\n+\t  for (reg = j; reg < j + nregs; reg++)\n+\t    {\n+\t      /* Use QImode since that's guaranteed to clobber just\n+\t       * one reg.  */\n+\t      clobbered_reg = gen_rtx_REG (QImode, reg);\n+\n+\t      /* Do sanity check for overlap between clobbers and\n+\t\t respectively input and outputs that hasn't been\n+\t\t handled.  Such overlap should have been detected and\n+\t\t reported above.  */\n+\t      if (!clobber_conflict_found)\n+\t\t{\n+\t\t  int opno;\n+\n+\t\t  /* We test the old body (obody) contents to avoid\n+\t\t     tripping over the under-construction body.  */\n+\t\t  for (opno = 0; opno < noutputs; opno++)\n+\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n+\t\t\t\t\t\t output_rtx[opno]))\n+\t\t      internal_error\n+\t\t\t(\"asm clobber conflict with output operand\");\n+\n+\t\t  for (opno = 0; opno < ninputs - ninout; opno++)\n+\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n+\t\t\t\t\t\t ASM_OPERANDS_INPUT (obody,\n+\t\t\t\t\t\t\t\t     opno)))\n+\t\t      internal_error\n+\t\t\t(\"asm clobber conflict with input operand\");\n+\t\t}\n+\n+\t      XVECEXP (body, 0, i++)\n+\t\t= gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n+\t    }\n+\t}\n+\n+      if (nlabels > 0)\n+\temit_jump_insn (body);\n+      else\n+\temit_insn (body);\n+    }\n+\n+  if (fallthru_label)\n+    emit_label (fallthru_label);\n+\n+  /* For any outputs that needed reloading into registers, spill them\n+     back to where they belong.  */\n+  for (i = 0; i < noutputs; ++i)\n+    if (real_output_rtx[i])\n+      emit_move_insn (real_output_rtx[i], output_rtx[i]);\n+\n+  crtl->has_asm_statement = 1;\n+  free_temp_slots ();\n+}\n+\n+\n+static void\n+expand_asm_stmt (gimple stmt)\n+{\n+  int noutputs;\n+  tree outputs, tail, t;\n+  tree *o;\n+  size_t i, n;\n+  const char *s;\n+  tree str, out, in, cl, labels;\n+  location_t locus = gimple_location (stmt);\n+  basic_block fallthru_bb = NULL;\n+\n+  /* Meh... convert the gimple asm operands into real tree lists.\n+     Eventually we should make all routines work on the vectors instead\n+     of relying on TREE_CHAIN.  */\n+  out = NULL_TREE;\n+  n = gimple_asm_noutputs (stmt);\n+  if (n > 0)\n+    {\n+      t = out = gimple_asm_output_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n+    }\n+\n+  in = NULL_TREE;\n+  n = gimple_asm_ninputs (stmt);\n+  if (n > 0)\n+    {\n+      t = in = gimple_asm_input_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n+    }\n+\n+  cl = NULL_TREE;\n+  n = gimple_asm_nclobbers (stmt);\n+  if (n > 0)\n+    {\n+      t = cl = gimple_asm_clobber_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n+    }\n+\n+  labels = NULL_TREE;\n+  n = gimple_asm_nlabels (stmt);\n+  if (n > 0)\n+    {\n+      edge fallthru = find_fallthru_edge (gimple_bb (stmt)->succs);\n+      if (fallthru)\n+\tfallthru_bb = fallthru->dest;\n+      t = labels = gimple_asm_label_op (stmt, 0);\n+      for (i = 1; i < n; i++)\n+\tt = TREE_CHAIN (t) = gimple_asm_label_op (stmt, i);\n+    }\n+\n+  s = gimple_asm_string (stmt);\n+  str = build_string (strlen (s), s);\n+\n+  if (gimple_asm_input_p (stmt))\n+    {\n+      expand_asm_loc (str, gimple_asm_volatile_p (stmt), locus);\n+      return;\n+    }\n+\n+  outputs = out;\n+  noutputs = gimple_asm_noutputs (stmt);\n+  /* o[I] is the place that output number I should be written.  */\n+  o = (tree *) alloca (noutputs * sizeof (tree));\n+\n+  /* Record the contents of OUTPUTS before it is modified.  */\n+  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+    o[i] = TREE_VALUE (tail);\n+\n+  /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n+     OUTPUTS some trees for where the values were actually stored.  */\n+  expand_asm_operands (str, outputs, in, cl, labels, fallthru_bb,\n+\t\t       gimple_asm_volatile_p (stmt), locus);\n+\n+  /* Copy all the intermediate outputs into the specified outputs.  */\n+  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n+    {\n+      if (o[i] != TREE_VALUE (tail))\n+\t{\n+\t  expand_assignment (o[i], TREE_VALUE (tail), false);\n+\t  free_temp_slots ();\n+\n+\t  /* Restore the original value so that it's correct the next\n+\t     time we expand this function.  */\n+\t  TREE_VALUE (tail) = o[i];\n+\t}\n+    }\n+}\n+\n+/* Emit code to jump to the address\n+   specified by the pointer expression EXP.  */\n+\n+static void\n+expand_computed_goto (tree exp)\n+{\n+  rtx x = expand_normal (exp);\n+\n+  x = convert_memory_address (Pmode, x);\n+\n+  do_pending_stack_adjust ();\n+  emit_indirect_jump (x);\n+}\n+\n+/* Generate RTL code for a `goto' statement with target label LABEL.\n+   LABEL should be a LABEL_DECL tree node that was or will later be\n+   defined with `expand_label'.  */\n+\n+static void\n+expand_goto (tree label)\n+{\n+#ifdef ENABLE_CHECKING\n+  /* Check for a nonlocal goto to a containing function.  Should have\n+     gotten translated to __builtin_nonlocal_goto.  */\n+  tree context = decl_function_context (label);\n+  gcc_assert (!context || context == current_function_decl);\n+#endif\n+\n+  emit_jump (label_rtx (label));\n+}\n+\n+/* Output a return with no value.  */\n+\n+static void\n+expand_null_return_1 (void)\n+{\n+  clear_pending_stack_adjust ();\n+  do_pending_stack_adjust ();\n+  emit_jump (return_label);\n+}\n+\n+/* Generate RTL to return from the current function, with no value.\n+   (That is, we do not do anything about returning any value.)  */\n+\n+void\n+expand_null_return (void)\n+{\n+  /* If this function was declared to return a value, but we\n+     didn't, clobber the return registers so that they are not\n+     propagated live to the rest of the function.  */\n+  clobber_return_register ();\n+\n+  expand_null_return_1 ();\n+}\n+\n+/* Generate RTL to return from the current function, with value VAL.  */\n+\n+static void\n+expand_value_return (rtx val)\n+{\n+  /* Copy the value to the return location unless it's already there.  */\n+\n+  tree decl = DECL_RESULT (current_function_decl);\n+  rtx return_reg = DECL_RTL (decl);\n+  if (return_reg != val)\n+    {\n+      tree funtype = TREE_TYPE (current_function_decl);\n+      tree type = TREE_TYPE (decl);\n+      int unsignedp = TYPE_UNSIGNED (type);\n+      enum machine_mode old_mode = DECL_MODE (decl);\n+      enum machine_mode mode;\n+      if (DECL_BY_REFERENCE (decl))\n+        mode = promote_function_mode (type, old_mode, &unsignedp, funtype, 2);\n+      else\n+        mode = promote_function_mode (type, old_mode, &unsignedp, funtype, 1);\n+\n+      if (mode != old_mode)\n+\tval = convert_modes (mode, old_mode, val, unsignedp);\n+\n+      if (GET_CODE (return_reg) == PARALLEL)\n+\temit_group_load (return_reg, val, type, int_size_in_bytes (type));\n+      else\n+\temit_move_insn (return_reg, val);\n+    }\n+\n+  expand_null_return_1 ();\n+}\n+\n+/* Generate RTL to evaluate the expression RETVAL and return it\n+   from the current function.  */\n+\n+static void\n+expand_return (tree retval)\n+{\n+  rtx result_rtl;\n+  rtx val = 0;\n+  tree retval_rhs;\n+\n+  /* If function wants no value, give it none.  */\n+  if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n+    {\n+      expand_normal (retval);\n+      expand_null_return ();\n+      return;\n+    }\n+\n+  if (retval == error_mark_node)\n+    {\n+      /* Treat this like a return of no value from a function that\n+\t returns a value.  */\n+      expand_null_return ();\n+      return;\n+    }\n+  else if ((TREE_CODE (retval) == MODIFY_EXPR\n+\t    || TREE_CODE (retval) == INIT_EXPR)\n+\t   && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n+    retval_rhs = TREE_OPERAND (retval, 1);\n+  else\n+    retval_rhs = retval;\n+\n+  result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n+\n+  /* If we are returning the RESULT_DECL, then the value has already\n+     been stored into it, so we don't have to do anything special.  */\n+  if (TREE_CODE (retval_rhs) == RESULT_DECL)\n+    expand_value_return (result_rtl);\n+\n+  /* If the result is an aggregate that is being returned in one (or more)\n+     registers, load the registers here.  */\n+\n+  else if (retval_rhs != 0\n+\t   && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n+\t   && REG_P (result_rtl))\n+    {\n+      val = copy_blkmode_to_reg (GET_MODE (result_rtl), retval_rhs);\n+      if (val)\n+\t{\n+\t  /* Use the mode of the result value on the return register.  */\n+\t  PUT_MODE (result_rtl, GET_MODE (val));\n+\t  expand_value_return (val);\n+\t}\n+      else\n+\texpand_null_return ();\n+    }\n+  else if (retval_rhs != 0\n+\t   && !VOID_TYPE_P (TREE_TYPE (retval_rhs))\n+\t   && (REG_P (result_rtl)\n+\t       || (GET_CODE (result_rtl) == PARALLEL)))\n+    {\n+      /* Calculate the return value into a temporary (usually a pseudo\n+         reg).  */\n+      tree ot = TREE_TYPE (DECL_RESULT (current_function_decl));\n+      tree nt = build_qualified_type (ot, TYPE_QUALS (ot) | TYPE_QUAL_CONST);\n+\n+      val = assign_temp (nt, 0, 1);\n+      val = expand_expr (retval_rhs, val, GET_MODE (val), EXPAND_NORMAL);\n+      val = force_not_mem (val);\n+      /* Return the calculated value.  */\n+      expand_value_return (val);\n+    }\n+  else\n+    {\n+      /* No hard reg used; calculate value into hard return reg.  */\n+      expand_expr (retval, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+      expand_value_return (result_rtl);\n+    }\n+}\n+\n /* A subroutine of expand_gimple_stmt, expanding one gimple statement\n    STMT that doesn't require special handling for outgoing edges.  That\n    is no tailcalls and no GIMPLE_COND.  */\n@@ -4534,6 +5397,52 @@ expand_stack_alignment (void)\n       fixup_tail_calls ();\n     }\n }\n+\f\n+\n+static void\n+expand_main_function (void)\n+{\n+#if (defined(INVOKE__main)\t\t\t\t\\\n+     || (!defined(HAS_INIT_SECTION)\t\t\t\\\n+\t && !defined(INIT_SECTION_ASM_OP)\t\t\\\n+\t && !defined(INIT_ARRAY_SECTION_ASM_OP)))\n+  emit_library_call (init_one_libfunc (NAME__MAIN), LCT_NORMAL, VOIDmode, 0);\n+#endif\n+}\n+\f\n+\n+/* Expand code to initialize the stack_protect_guard.  This is invoked at\n+   the beginning of a function to be protected.  */\n+\n+#ifndef HAVE_stack_protect_set\n+# define HAVE_stack_protect_set\t\t0\n+# define gen_stack_protect_set(x,y)\t(gcc_unreachable (), NULL_RTX)\n+#endif\n+\n+static void\n+stack_protect_prologue (void)\n+{\n+  tree guard_decl = targetm.stack_protect_guard ();\n+  rtx x, y;\n+\n+  x = expand_normal (crtl->stack_protect_guard);\n+  y = expand_normal (guard_decl);\n+\n+  /* Allow the target to copy from Y to X without leaking Y into a\n+     register.  */\n+  if (HAVE_stack_protect_set)\n+    {\n+      rtx insn = gen_stack_protect_set (x, y);\n+      if (insn)\n+\t{\n+\t  emit_insn (insn);\n+\t  return;\n+\t}\n+    }\n+\n+  /* Otherwise do a straight move.  */\n+  emit_move_insn (x, y);\n+}\n \n /* Translate the intermediate representation contained in the CFG\n    from GIMPLE trees to RTL."}, {"sha": "9bb5656fb078e64cf71637e56c969542308f3b8a", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -277,6 +277,111 @@ clone_function_name (tree decl, const char *suffix)\n   return get_identifier (tmp_name);\n }\n \n+/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP and the\n+   return value if SKIP_RETURN is true.  */\n+\n+static tree\n+build_function_type_skip_args (tree orig_type, bitmap args_to_skip,\n+\t\t\t       bool skip_return)\n+{\n+  tree new_type = NULL;\n+  tree args, new_args = NULL, t;\n+  tree new_reversed;\n+  int i = 0;\n+\n+  for (args = TYPE_ARG_TYPES (orig_type); args && args != void_list_node;\n+       args = TREE_CHAIN (args), i++)\n+    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n+      new_args = tree_cons (NULL_TREE, TREE_VALUE (args), new_args);\n+\n+  new_reversed = nreverse (new_args);\n+  if (args)\n+    {\n+      if (new_reversed)\n+        TREE_CHAIN (new_args) = void_list_node;\n+      else\n+\tnew_reversed = void_list_node;\n+    }\n+\n+  /* Use copy_node to preserve as much as possible from original type\n+     (debug info, attribute lists etc.)\n+     Exception is METHOD_TYPEs must have THIS argument.\n+     When we are asked to remove it, we need to build new FUNCTION_TYPE\n+     instead.  */\n+  if (TREE_CODE (orig_type) != METHOD_TYPE\n+      || !args_to_skip\n+      || !bitmap_bit_p (args_to_skip, 0))\n+    {\n+      new_type = build_distinct_type_copy (orig_type);\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+    }\n+  else\n+    {\n+      new_type\n+        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n+\t\t\t\t\t\t\t new_reversed));\n+      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n+    }\n+\n+  if (skip_return)\n+    TREE_TYPE (new_type) = void_type_node;\n+\n+  /* This is a new type, not a copy of an old type.  Need to reassociate\n+     variants.  We can handle everything except the main variant lazily.  */\n+  t = TYPE_MAIN_VARIANT (orig_type);\n+  if (t != orig_type)\n+    {\n+      t = build_function_type_skip_args (t, args_to_skip, skip_return);\n+      TYPE_MAIN_VARIANT (new_type) = t;\n+      TYPE_NEXT_VARIANT (new_type) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = new_type;\n+    }\n+  else\n+    {\n+      TYPE_MAIN_VARIANT (new_type) = new_type;\n+      TYPE_NEXT_VARIANT (new_type) = NULL;\n+    }\n+\n+  return new_type;\n+}\n+\n+/* Build variant of function decl ORIG_DECL skipping ARGS_TO_SKIP and the\n+   return value if SKIP_RETURN is true.\n+\n+   Arguments from DECL_ARGUMENTS list can't be removed now, since they are\n+   linked by TREE_CHAIN directly.  The caller is responsible for eliminating\n+   them when they are being duplicated (i.e. copy_arguments_for_versioning).  */\n+\n+static tree\n+build_function_decl_skip_args (tree orig_decl, bitmap args_to_skip,\n+\t\t\t       bool skip_return)\n+{\n+  tree new_decl = copy_node (orig_decl);\n+  tree new_type;\n+\n+  new_type = TREE_TYPE (orig_decl);\n+  if (prototype_p (new_type)\n+      || (skip_return && !VOID_TYPE_P (TREE_TYPE (new_type))))\n+    new_type\n+      = build_function_type_skip_args (new_type, args_to_skip, skip_return);\n+  TREE_TYPE (new_decl) = new_type;\n+\n+  /* For declarations setting DECL_VINDEX (i.e. methods)\n+     we expect first argument to be THIS pointer.   */\n+  if (args_to_skip && bitmap_bit_p (args_to_skip, 0))\n+    DECL_VINDEX (new_decl) = NULL_TREE;\n+\n+  /* When signature changes, we need to clear builtin info.  */\n+  if (DECL_BUILT_IN (new_decl)\n+      && args_to_skip\n+      && !bitmap_empty_p (args_to_skip))\n+    {\n+      DECL_BUILT_IN_CLASS (new_decl) = NOT_BUILT_IN;\n+      DECL_FUNCTION_CODE (new_decl) = (enum built_in_function) 0;\n+    }\n+  return new_decl;\n+}\n+\n /* Create callgraph node clone with new declaration.  The actual body will\n    be copied later at compilation stage.\n "}, {"sha": "bf5742de89652103bde81e386d62409322f68742", "filename": "gcc/explow.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -235,6 +235,18 @@ eliminate_constant_term (rtx x, rtx *constptr)\n   return x;\n }\n \n+/* Returns a tree for the size of EXP in bytes.  */\n+\n+static tree\n+tree_expr_size (const_tree exp)\n+{\n+  if (DECL_P (exp)\n+      && DECL_SIZE_UNIT (exp) != 0)\n+    return DECL_SIZE_UNIT (exp);\n+  else\n+    return size_in_bytes (TREE_TYPE (exp));\n+}\n+\n /* Return an rtx for the size in bytes of the value of EXP.  */\n \n rtx"}, {"sha": "28b43320798c196f42b1e60f24bdc6575c96d580", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -4630,17 +4630,6 @@ mem_ref_refers_to_non_mem_p (tree ref)\n   return addr_expr_of_non_mem_decl_p_1 (base, false);\n }\n \n-/* Return TRUE iff OP is an ADDR_EXPR of a DECL that's not\n-   addressable.  This is very much like mem_ref_refers_to_non_mem_p,\n-   but instead of the MEM_REF, it takes its base, and it doesn't\n-   assume a DECL is in memory just because its RTL is not set yet.  */\n-\n-bool\n-addr_expr_of_non_mem_decl_p (tree op)\n-{\n-  return addr_expr_of_non_mem_decl_p_1 (op, true);\n-}\n-\n /* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL\n    is true, try generating a nontemporal store.  */\n \n@@ -5753,6 +5742,23 @@ store_constructor_field (rtx target, unsigned HOST_WIDE_INT bitsize,\n     store_field (target, bitsize, bitpos, 0, 0, mode, exp, alias_set, false);\n }\n \n+\n+/* Returns the number of FIELD_DECLs in TYPE.  */\n+\n+static int\n+fields_length (const_tree type)\n+{\n+  tree t = TYPE_FIELDS (type);\n+  int count = 0;\n+\n+  for (; t; t = DECL_CHAIN (t))\n+    if (TREE_CODE (t) == FIELD_DECL)\n+      ++count;\n+\n+  return count;\n+}\n+\n+\n /* Store the value of constructor EXP into the rtx TARGET.\n    TARGET is either a REG or a MEM; we know it cannot conflict, since\n    safe_from_p has been called."}, {"sha": "3e6f15887dbbce00aca9a7dc7776795f68e96110", "filename": "gcc/fold-const.c", "status": "modified", "additions": 123, "deletions": 125, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -8944,6 +8944,17 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n   return total.low > (unsigned HOST_WIDE_INT) size;\n }\n \n+/* Return the HOST_WIDE_INT least significant bits of T, a sizetype\n+   kind INTEGER_CST.  This makes sure to properly sign-extend the\n+   constant.  */\n+\n+static HOST_WIDE_INT\n+size_low_cst (const_tree t)\n+{\n+  double_int d = tree_to_double_int (t);\n+  return d.sext (TYPE_PRECISION (TREE_TYPE (t))).low;\n+}\n+\n /* Subroutine of fold_binary.  This routine performs all of the\n    transformations that are common to the equality/inequality\n    operators (EQ_EXPR and NE_EXPR) and the ordering operators\n@@ -9951,6 +9962,117 @@ mask_with_tz (tree type, double_int x, double_int y)\n   return x;\n }\n \n+/* Return true when T is an address and is known to be nonzero.\n+   For floating point we further ensure that T is not denormal.\n+   Similar logic is present in nonzero_address in rtlanal.h.\n+\n+   If the return value is based on the assumption that signed overflow\n+   is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n+   change *STRICT_OVERFLOW_P.  */\n+\n+static bool\n+tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n+{\n+  tree type = TREE_TYPE (t);\n+  enum tree_code code;\n+\n+  /* Doing something useful for floating point would need more work.  */\n+  if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n+    return false;\n+\n+  code = TREE_CODE (t);\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_unary:\n+      return tree_unary_nonzero_warnv_p (code, type, TREE_OPERAND (t, 0),\n+\t\t\t\t\t      strict_overflow_p);\n+    case tcc_binary:\n+    case tcc_comparison:\n+      return tree_binary_nonzero_warnv_p (code, type,\n+\t\t\t\t\t       TREE_OPERAND (t, 0),\n+\t\t\t\t\t       TREE_OPERAND (t, 1),\n+\t\t\t\t\t       strict_overflow_p);\n+    case tcc_constant:\n+    case tcc_declaration:\n+    case tcc_reference:\n+      return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n+\n+    default:\n+      break;\n+    }\n+\n+  switch (code)\n+    {\n+    case TRUTH_NOT_EXPR:\n+      return tree_unary_nonzero_warnv_p (code, type, TREE_OPERAND (t, 0),\n+\t\t\t\t\t      strict_overflow_p);\n+\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      return tree_binary_nonzero_warnv_p (code, type,\n+\t\t\t\t\t       TREE_OPERAND (t, 0),\n+\t\t\t\t\t       TREE_OPERAND (t, 1),\n+\t\t\t\t\t       strict_overflow_p);\n+\n+    case COND_EXPR:\n+    case CONSTRUCTOR:\n+    case OBJ_TYPE_REF:\n+    case ASSERT_EXPR:\n+    case ADDR_EXPR:\n+    case WITH_SIZE_EXPR:\n+    case SSA_NAME:\n+      return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n+\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case BIND_EXPR:\n+      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\tstrict_overflow_p);\n+\n+    case SAVE_EXPR:\n+      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\tstrict_overflow_p);\n+\n+    case CALL_EXPR:\n+      {\n+\ttree fndecl = get_callee_fndecl (t);\n+\tif (!fndecl) return false;\n+\tif (flag_delete_null_pointer_checks && !flag_check_new\n+\t    && DECL_IS_OPERATOR_NEW (fndecl)\n+\t    && !TREE_NOTHROW (fndecl))\n+\t  return true;\n+\tif (flag_delete_null_pointer_checks\n+\t    && lookup_attribute (\"returns_nonnull\",\n+\t\t TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n+\t  return true;\n+\treturn alloca_call_p (t);\n+      }\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+/* Return true when T is an address and is known to be nonzero.\n+   Handle warnings about undefined signed overflow.  */\n+\n+static bool\n+tree_expr_nonzero_p (tree t)\n+{\n+  bool ret, strict_overflow_p;\n+\n+  strict_overflow_p = false;\n+  ret = tree_expr_nonzero_warnv_p (t, &strict_overflow_p);\n+  if (strict_overflow_p)\n+    fold_overflow_warning ((\"assuming signed overflow does not occur when \"\n+\t\t\t    \"determining that expression is always \"\n+\t\t\t    \"non-zero\"),\n+\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+  return ret;\n+}\n+\n /* Fold a binary expression of code CODE and type TYPE with operands\n    OP0 and OP1.  LOC is the location of the resulting expression.\n    Return the folded expression if folding is successful.  Otherwise,\n@@ -15243,19 +15365,6 @@ fold_build2_initializer_loc (location_t loc, enum tree_code code,\n   return result;\n }\n \n-tree\n-fold_build3_initializer_loc (location_t loc, enum tree_code code,\n-\t\t\t     tree type, tree op0, tree op1, tree op2)\n-{\n-  tree result;\n-  START_FOLD_INIT;\n-\n-  result = fold_build3_loc (loc, code, type, op0, op1, op2);\n-\n-  END_FOLD_INIT;\n-  return result;\n-}\n-\n tree\n fold_build_call_array_initializer_loc (location_t loc, tree type, tree fn,\n \t\t\t\t       int nargs, tree *argarray)\n@@ -15777,7 +15886,7 @@ tree_call_nonnegative_warnv_p (tree type, tree fndecl,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.  */\n \n-bool\n+static bool\n tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n {\n   enum tree_code code = TREE_CODE (t);\n@@ -16146,117 +16255,6 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n   return false;\n }\n \n-/* Return true when T is an address and is known to be nonzero.\n-   For floating point we further ensure that T is not denormal.\n-   Similar logic is present in nonzero_address in rtlanal.h.\n-\n-   If the return value is based on the assumption that signed overflow\n-   is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n-   change *STRICT_OVERFLOW_P.  */\n-\n-bool\n-tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n-{\n-  tree type = TREE_TYPE (t);\n-  enum tree_code code;\n-\n-  /* Doing something useful for floating point would need more work.  */\n-  if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n-    return false;\n-\n-  code = TREE_CODE (t);\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_unary:\n-      return tree_unary_nonzero_warnv_p (code, type, TREE_OPERAND (t, 0),\n-\t\t\t\t\t      strict_overflow_p);\n-    case tcc_binary:\n-    case tcc_comparison:\n-      return tree_binary_nonzero_warnv_p (code, type,\n-\t\t\t\t\t       TREE_OPERAND (t, 0),\n-\t\t\t\t\t       TREE_OPERAND (t, 1),\n-\t\t\t\t\t       strict_overflow_p);\n-    case tcc_constant:\n-    case tcc_declaration:\n-    case tcc_reference:\n-      return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n-\n-    default:\n-      break;\n-    }\n-\n-  switch (code)\n-    {\n-    case TRUTH_NOT_EXPR:\n-      return tree_unary_nonzero_warnv_p (code, type, TREE_OPERAND (t, 0),\n-\t\t\t\t\t      strict_overflow_p);\n-\n-    case TRUTH_AND_EXPR:\n-    case TRUTH_OR_EXPR:\n-    case TRUTH_XOR_EXPR:\n-      return tree_binary_nonzero_warnv_p (code, type,\n-\t\t\t\t\t       TREE_OPERAND (t, 0),\n-\t\t\t\t\t       TREE_OPERAND (t, 1),\n-\t\t\t\t\t       strict_overflow_p);\n-\n-    case COND_EXPR:\n-    case CONSTRUCTOR:\n-    case OBJ_TYPE_REF:\n-    case ASSERT_EXPR:\n-    case ADDR_EXPR:\n-    case WITH_SIZE_EXPR:\n-    case SSA_NAME:\n-      return tree_single_nonzero_warnv_p (t, strict_overflow_p);\n-\n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case BIND_EXPR:\n-      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n-\t\t\t\t\tstrict_overflow_p);\n-\n-    case SAVE_EXPR:\n-      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t\tstrict_overflow_p);\n-\n-    case CALL_EXPR:\n-      {\n-\ttree fndecl = get_callee_fndecl (t);\n-\tif (!fndecl) return false;\n-\tif (flag_delete_null_pointer_checks && !flag_check_new\n-\t    && DECL_IS_OPERATOR_NEW (fndecl)\n-\t    && !TREE_NOTHROW (fndecl))\n-\t  return true;\n-\tif (flag_delete_null_pointer_checks\n-\t    && lookup_attribute (\"returns_nonnull\",\n-\t\t TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n-\t  return true;\n-\treturn alloca_call_p (t);\n-      }\n-\n-    default:\n-      break;\n-    }\n-  return false;\n-}\n-\n-/* Return true when T is an address and is known to be nonzero.\n-   Handle warnings about undefined signed overflow.  */\n-\n-bool\n-tree_expr_nonzero_p (tree t)\n-{\n-  bool ret, strict_overflow_p;\n-\n-  strict_overflow_p = false;\n-  ret = tree_expr_nonzero_warnv_p (t, &strict_overflow_p);\n-  if (strict_overflow_p)\n-    fold_overflow_warning ((\"assuming signed overflow does not occur when \"\n-\t\t\t    \"determining that expression is always \"\n-\t\t\t    \"non-zero\"),\n-\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n-  return ret;\n-}\n-\n /* Given the components of a binary expression CODE, TYPE, OP0 and OP1,\n    attempt to fold the expression to a constant without modifying TYPE,\n    OP0 or OP1."}, {"sha": "ba881c9744ed30511878f402dc6758cbcb513ed0", "filename": "gcc/function.c", "status": "modified", "additions": 13, "deletions": 58, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -130,7 +130,6 @@ static bool contains (const_rtx, htab_t);\n static void prepare_function_start (void);\n static void do_clobber_return_reg (rtx, void *);\n static void do_use_return_reg (rtx, void *);\n-static void set_insn_locations (rtx, int) ATTRIBUTE_UNUSED;\n \f\n /* Stack of nested functions.  */\n /* Keep track of the cfun stack.  */\n@@ -4644,51 +4643,6 @@ init_function_start (tree subr)\n     warning (OPT_Waggregate_return, \"function returns an aggregate\");\n }\n \n-\n-void\n-expand_main_function (void)\n-{\n-#if (defined(INVOKE__main)\t\t\t\t\\\n-     || (!defined(HAS_INIT_SECTION)\t\t\t\\\n-\t && !defined(INIT_SECTION_ASM_OP)\t\t\\\n-\t && !defined(INIT_ARRAY_SECTION_ASM_OP)))\n-  emit_library_call (init_one_libfunc (NAME__MAIN), LCT_NORMAL, VOIDmode, 0);\n-#endif\n-}\n-\f\n-/* Expand code to initialize the stack_protect_guard.  This is invoked at\n-   the beginning of a function to be protected.  */\n-\n-#ifndef HAVE_stack_protect_set\n-# define HAVE_stack_protect_set\t\t0\n-# define gen_stack_protect_set(x,y)\t(gcc_unreachable (), NULL_RTX)\n-#endif\n-\n-void\n-stack_protect_prologue (void)\n-{\n-  tree guard_decl = targetm.stack_protect_guard ();\n-  rtx x, y;\n-\n-  x = expand_normal (crtl->stack_protect_guard);\n-  y = expand_normal (guard_decl);\n-\n-  /* Allow the target to copy from Y to X without leaking Y into a\n-     register.  */\n-  if (HAVE_stack_protect_set)\n-    {\n-      rtx insn = gen_stack_protect_set (x, y);\n-      if (insn)\n-\t{\n-\t  emit_insn (insn);\n-\t  return;\n-\t}\n-    }\n-\n-  /* Otherwise do a straight move.  */\n-  emit_move_insn (x, y);\n-}\n-\n /* Expand code to verify the stack_protect_guard.  This is invoked at\n    the end of a function to be protected.  */\n \n@@ -5006,6 +4960,19 @@ do_warn_unused_parameter (tree fn)\n       warning (OPT_Wunused_parameter, \"unused parameter %q+D\", decl);\n }\n \n+/* Set the location of the insn chain starting at INSN to LOC.  */\n+\n+static void\n+set_insn_locations (rtx insn, int loc)\n+{\n+  while (insn != NULL_RTX)\n+    {\n+      if (INSN_P (insn))\n+\tINSN_LOCATION (insn) = loc;\n+      insn = NEXT_INSN (insn);\n+    }\n+}\n+\n /* Generate RTL for the end of the current function.  */\n \n void\n@@ -5335,18 +5302,6 @@ maybe_copy_prologue_epilogue_insn (rtx insn, rtx copy)\n   *slot = copy;\n }\n \n-/* Set the location of the insn chain starting at INSN to LOC.  */\n-static void\n-set_insn_locations (rtx insn, int loc)\n-{\n-  while (insn != NULL_RTX)\n-    {\n-      if (INSN_P (insn))\n-\tINSN_LOCATION (insn) = loc;\n-      insn = NEXT_INSN (insn);\n-    }\n-}\n-\n /* Determine if any INSNs in HASH are, or are part of, INSN.  Because\n    we can be running after reorg, SEQUENCE rtl is possible.  */\n "}, {"sha": "89d1ac993f6de78e07da3fa3675d0d592f7059cf", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -38,6 +38,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"gimple-pretty-print.h\"\n #include \"tree-ssa-address.h\"\n+#include \"langhooks.h\"\n \n /* Return true when DECL can be referenced from current unit.\n    FROM_DECL (if non-null) specify constructor of variable DECL was taken from."}, {"sha": "5916c523f9d4af0189ce35db351dece919a3ed01", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -962,30 +962,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   fprintf (file, \">\");\n }\n \n-/* Print the tree vector VEC in full on file FILE, preceded by PREFIX,\n-   starting in column INDENT.  */\n-\n-void\n-print_vec_tree (FILE *file, const char *prefix, vec<tree, va_gc> *vec, int indent)\n-{\n-  tree elt;\n-  unsigned ix;\n-\n-  /* Indent to the specified column, since this is the long form.  */\n-  indent_to (file, indent);\n-\n-  /* Print the slot this node is in, and its code, and address.  */\n-  fprintf (file, \"%s <VEC\", prefix);\n-  dump_addr (file, \" \", vec->address ());\n-\n-  FOR_EACH_VEC_ELT (*vec, ix, elt)\n-    {\n-      char temp[10];\n-      sprintf (temp, \"elt %d\", ix);\n-      print_node (file, temp, elt, indent + 4);\n-    }\n-}\n-\n \n /* Print the node NODE on standard error, for debugging.\n    Most nodes referred to by this one are printed recursively"}, {"sha": "947dca9e8b89d42c6e2823aeabaeb288d7d4f3d7", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 886, "changes": 886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -102,13 +102,8 @@ typedef struct case_node *case_node_ptr;\n \n extern basic_block label_to_block_fn (struct function *, tree);\n \f\n-static int n_occurrences (int, const char *);\n-static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n-static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n-static void expand_null_return_1 (void);\n-static void expand_value_return (rtx);\n static void balance_case_nodes (case_node_ptr *, case_node_ptr);\n static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n@@ -157,20 +152,6 @@ emit_jump (rtx label)\n   emit_jump_insn (gen_jump (label));\n   emit_barrier ();\n }\n-\n-/* Emit code to jump to the address\n-   specified by the pointer expression EXP.  */\n-\n-void\n-expand_computed_goto (tree exp)\n-{\n-  rtx x = expand_normal (exp);\n-\n-  x = convert_memory_address (Pmode, x);\n-\n-  do_pending_stack_adjust ();\n-  emit_indirect_jump (x);\n-}\n \f\n /* Handle goto statements and the labels that they can go to.  */\n \n@@ -209,56 +190,7 @@ expand_label (tree label)\n   if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n     maybe_set_first_label_num (label_r);\n }\n-\n-/* Generate RTL code for a `goto' statement with target label LABEL.\n-   LABEL should be a LABEL_DECL tree node that was or will later be\n-   defined with `expand_label'.  */\n-\n-void\n-expand_goto (tree label)\n-{\n-#ifdef ENABLE_CHECKING\n-  /* Check for a nonlocal goto to a containing function.  Should have\n-     gotten translated to __builtin_nonlocal_goto.  */\n-  tree context = decl_function_context (label);\n-  gcc_assert (!context || context == current_function_decl);\n-#endif\n-\n-  emit_jump (label_rtx (label));\n-}\n-\f\n-/* Return the number of times character C occurs in string S.  */\n-static int\n-n_occurrences (int c, const char *s)\n-{\n-  int n = 0;\n-  while (*s)\n-    n += (*s++ == c);\n-  return n;\n-}\n \f\n-/* Generate RTL for an asm statement (explicit assembler code).\n-   STRING is a STRING_CST node containing the assembler code text,\n-   or an ADDR_EXPR containing a STRING_CST.  VOL nonzero means the\n-   insn is volatile; don't optimize it.  */\n-\n-static void\n-expand_asm_loc (tree string, int vol, location_t locus)\n-{\n-  rtx body;\n-\n-  if (TREE_CODE (string) == ADDR_EXPR)\n-    string = TREE_OPERAND (string, 0);\n-\n-  body = gen_rtx_ASM_INPUT_loc (VOIDmode,\n-\t\t\t\tggc_strdup (TREE_STRING_POINTER (string)),\n-\t\t\t\tlocus);\n-\n-  MEM_VOLATILE_P (body) = vol;\n-\n-  emit_insn (body);\n-}\n-\n /* Parse the output constraint pointed to by *CONSTRAINT_P.  It is the\n    OPERAND_NUMth output operand, indexed from zero.  There are NINPUTS\n    inputs and NOUTPUTS outputs to this extended-asm.  Upon return,\n@@ -577,663 +509,6 @@ tree_overlaps_hard_reg_set (tree decl, HARD_REG_SET *regs)\n   return walk_tree (&decl, decl_overlaps_hard_reg_set_p, regs, NULL);\n }\n \n-/* Check for overlap between registers marked in CLOBBERED_REGS and\n-   anything inappropriate in T.  Emit error and return the register\n-   variable definition for error, NULL_TREE for ok.  */\n-\n-static bool\n-tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n-{\n-  /* Conflicts between asm-declared register variables and the clobber\n-     list are not allowed.  */\n-  tree overlap = tree_overlaps_hard_reg_set (t, clobbered_regs);\n-\n-  if (overlap)\n-    {\n-      error (\"asm-specifier for variable %qE conflicts with asm clobber list\",\n-\t     DECL_NAME (overlap));\n-\n-      /* Reset registerness to stop multiple errors emitted for a single\n-\t variable.  */\n-      DECL_REGISTER (overlap) = 0;\n-      return true;\n-    }\n-\n-  return false;\n-}\n-\n-/* Generate RTL for an asm statement with arguments.\n-   STRING is the instruction template.\n-   OUTPUTS is a list of output arguments (lvalues); INPUTS a list of inputs.\n-   Each output or input has an expression in the TREE_VALUE and\n-   a tree list in TREE_PURPOSE which in turn contains a constraint\n-   name in TREE_VALUE (or NULL_TREE) and a constraint string\n-   in TREE_PURPOSE.\n-   CLOBBERS is a list of STRING_CST nodes each naming a hard register\n-   that is clobbered by this insn.\n-\n-   LABELS is a list of labels, and if LABELS is non-NULL, FALLTHRU_BB\n-   should be the fallthru basic block of the asm goto.\n-\n-   Not all kinds of lvalue that may appear in OUTPUTS can be stored directly.\n-   Some elements of OUTPUTS may be replaced with trees representing temporary\n-   values.  The caller should copy those temporary values to the originally\n-   specified lvalues.\n-\n-   VOL nonzero means the insn is volatile; don't optimize it.  */\n-\n-static void\n-expand_asm_operands (tree string, tree outputs, tree inputs,\n-\t\t     tree clobbers, tree labels, basic_block fallthru_bb,\n-\t\t     int vol, location_t locus)\n-{\n-  rtvec argvec, constraintvec, labelvec;\n-  rtx body;\n-  int ninputs = list_length (inputs);\n-  int noutputs = list_length (outputs);\n-  int nlabels = list_length (labels);\n-  int ninout;\n-  int nclobbers;\n-  HARD_REG_SET clobbered_regs;\n-  int clobber_conflict_found = 0;\n-  tree tail;\n-  tree t;\n-  int i;\n-  /* Vector of RTX's of evaluated output operands.  */\n-  rtx *output_rtx = XALLOCAVEC (rtx, noutputs);\n-  int *inout_opnum = XALLOCAVEC (int, noutputs);\n-  rtx *real_output_rtx = XALLOCAVEC (rtx, noutputs);\n-  enum machine_mode *inout_mode = XALLOCAVEC (enum machine_mode, noutputs);\n-  const char **constraints = XALLOCAVEC (const char *, noutputs + ninputs);\n-  int old_generating_concat_p = generating_concat_p;\n-  rtx fallthru_label = NULL_RTX;\n-\n-  /* An ASM with no outputs needs to be treated as volatile, for now.  */\n-  if (noutputs == 0)\n-    vol = 1;\n-\n-  if (! check_operand_nalternatives (outputs, inputs))\n-    return;\n-\n-  string = resolve_asm_operand_names (string, outputs, inputs, labels);\n-\n-  /* Collect constraints.  */\n-  i = 0;\n-  for (t = outputs; t ; t = TREE_CHAIN (t), i++)\n-    constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n-  for (t = inputs; t ; t = TREE_CHAIN (t), i++)\n-    constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n-\n-  /* Sometimes we wish to automatically clobber registers across an asm.\n-     Case in point is when the i386 backend moved from cc0 to a hard reg --\n-     maintaining source-level compatibility means automatically clobbering\n-     the flags register.  */\n-  clobbers = targetm.md_asm_clobbers (outputs, inputs, clobbers);\n-\n-  /* Count the number of meaningful clobbered registers, ignoring what\n-     we would ignore later.  */\n-  nclobbers = 0;\n-  CLEAR_HARD_REG_SET (clobbered_regs);\n-  for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n-    {\n-      const char *regname;\n-      int nregs;\n-\n-      if (TREE_VALUE (tail) == error_mark_node)\n-\treturn;\n-      regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n-\n-      i = decode_reg_name_and_count (regname, &nregs);\n-      if (i == -4)\n-\t++nclobbers;\n-      else if (i == -2)\n-\terror (\"unknown register name %qs in %<asm%>\", regname);\n-\n-      /* Mark clobbered registers.  */\n-      if (i >= 0)\n-        {\n-\t  int reg;\n-\n-\t  for (reg = i; reg < i + nregs; reg++)\n-\t    {\n-\t      ++nclobbers;\n-\n-\t      /* Clobbering the PIC register is an error.  */\n-\t      if (reg == (int) PIC_OFFSET_TABLE_REGNUM)\n-\t\t{\n-\t\t  error (\"PIC register clobbered by %qs in %<asm%>\", regname);\n-\t\t  return;\n-\t\t}\n-\n-\t      SET_HARD_REG_BIT (clobbered_regs, reg);\n-\t    }\n-\t}\n-    }\n-\n-  /* First pass over inputs and outputs checks validity and sets\n-     mark_addressable if needed.  */\n-\n-  ninout = 0;\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      tree val = TREE_VALUE (tail);\n-      tree type = TREE_TYPE (val);\n-      const char *constraint;\n-      bool is_inout;\n-      bool allows_reg;\n-      bool allows_mem;\n-\n-      /* If there's an erroneous arg, emit no insn.  */\n-      if (type == error_mark_node)\n-\treturn;\n-\n-      /* Try to parse the output constraint.  If that fails, there's\n-\t no point in going further.  */\n-      constraint = constraints[i];\n-      if (!parse_output_constraint (&constraint, i, ninputs, noutputs,\n-\t\t\t\t    &allows_mem, &allows_reg, &is_inout))\n-\treturn;\n-\n-      if (! allows_reg\n-\t  && (allows_mem\n-\t      || is_inout\n-\t      || (DECL_P (val)\n-\t\t  && REG_P (DECL_RTL (val))\n-\t\t  && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n-\tmark_addressable (val);\n-\n-      if (is_inout)\n-\tninout++;\n-    }\n-\n-  ninputs += ninout;\n-  if (ninputs + noutputs > MAX_RECOG_OPERANDS)\n-    {\n-      error (\"more than %d operands in %<asm%>\", MAX_RECOG_OPERANDS);\n-      return;\n-    }\n-\n-  for (i = 0, tail = inputs; tail; i++, tail = TREE_CHAIN (tail))\n-    {\n-      bool allows_reg, allows_mem;\n-      const char *constraint;\n-\n-      /* If there's an erroneous arg, emit no insn, because the ASM_INPUT\n-\t would get VOIDmode and that could cause a crash in reload.  */\n-      if (TREE_TYPE (TREE_VALUE (tail)) == error_mark_node)\n-\treturn;\n-\n-      constraint = constraints[i + noutputs];\n-      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n-\t\t\t\t    constraints, &allows_mem, &allows_reg))\n-\treturn;\n-\n-      if (! allows_reg && allows_mem)\n-\tmark_addressable (TREE_VALUE (tail));\n-    }\n-\n-  /* Second pass evaluates arguments.  */\n-\n-  /* Make sure stack is consistent for asm goto.  */\n-  if (nlabels > 0)\n-    do_pending_stack_adjust ();\n-\n-  ninout = 0;\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      tree val = TREE_VALUE (tail);\n-      tree type = TREE_TYPE (val);\n-      bool is_inout;\n-      bool allows_reg;\n-      bool allows_mem;\n-      rtx op;\n-      bool ok;\n-\n-      ok = parse_output_constraint (&constraints[i], i, ninputs,\n-\t\t\t\t    noutputs, &allows_mem, &allows_reg,\n-\t\t\t\t    &is_inout);\n-      gcc_assert (ok);\n-\n-      /* If an output operand is not a decl or indirect ref and our constraint\n-\t allows a register, make a temporary to act as an intermediate.\n-\t Make the asm insn write into that, then our caller will copy it to\n-\t the real output operand.  Likewise for promoted variables.  */\n-\n-      generating_concat_p = 0;\n-\n-      real_output_rtx[i] = NULL_RTX;\n-      if ((TREE_CODE (val) == INDIRECT_REF\n-\t   && allows_mem)\n-\t  || (DECL_P (val)\n-\t      && (allows_mem || REG_P (DECL_RTL (val)))\n-\t      && ! (REG_P (DECL_RTL (val))\n-\t\t    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))\n-\t  || ! allows_reg\n-\t  || is_inout)\n-\t{\n-\t  op = expand_expr (val, NULL_RTX, VOIDmode,\n-\t\t\t    !allows_reg ? EXPAND_MEMORY : EXPAND_WRITE);\n-\t  if (MEM_P (op))\n-\t    op = validize_mem (op);\n-\n-\t  if (! allows_reg && !MEM_P (op))\n-\t    error (\"output number %d not directly addressable\", i);\n-\t  if ((! allows_mem && MEM_P (op))\n-\t      || GET_CODE (op) == CONCAT)\n-\t    {\n-\t      real_output_rtx[i] = op;\n-\t      op = gen_reg_rtx (GET_MODE (op));\n-\t      if (is_inout)\n-\t\temit_move_insn (op, real_output_rtx[i]);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  op = assign_temp (type, 0, 1);\n-\t  op = validize_mem (op);\n-\t  if (!MEM_P (op) && TREE_CODE (TREE_VALUE (tail)) == SSA_NAME)\n-\t    set_reg_attrs_for_decl_rtl (SSA_NAME_VAR (TREE_VALUE (tail)), op);\n-\t  TREE_VALUE (tail) = make_tree (type, op);\n-\t}\n-      output_rtx[i] = op;\n-\n-      generating_concat_p = old_generating_concat_p;\n-\n-      if (is_inout)\n-\t{\n-\t  inout_mode[ninout] = TYPE_MODE (type);\n-\t  inout_opnum[ninout++] = i;\n-\t}\n-\n-      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n-\tclobber_conflict_found = 1;\n-    }\n-\n-  /* Make vectors for the expression-rtx, constraint strings,\n-     and named operands.  */\n-\n-  argvec = rtvec_alloc (ninputs);\n-  constraintvec = rtvec_alloc (ninputs);\n-  labelvec = rtvec_alloc (nlabels);\n-\n-  body = gen_rtx_ASM_OPERANDS ((noutputs == 0 ? VOIDmode\n-\t\t\t\t: GET_MODE (output_rtx[0])),\n-\t\t\t       ggc_strdup (TREE_STRING_POINTER (string)),\n-\t\t\t       empty_string, 0, argvec, constraintvec,\n-\t\t\t       labelvec, locus);\n-\n-  MEM_VOLATILE_P (body) = vol;\n-\n-  /* Eval the inputs and put them into ARGVEC.\n-     Put their constraints into ASM_INPUTs and store in CONSTRAINTS.  */\n-\n-  for (i = 0, tail = inputs; tail; tail = TREE_CHAIN (tail), ++i)\n-    {\n-      bool allows_reg, allows_mem;\n-      const char *constraint;\n-      tree val, type;\n-      rtx op;\n-      bool ok;\n-\n-      constraint = constraints[i + noutputs];\n-      ok = parse_input_constraint (&constraint, i, ninputs, noutputs, ninout,\n-\t\t\t\t   constraints, &allows_mem, &allows_reg);\n-      gcc_assert (ok);\n-\n-      generating_concat_p = 0;\n-\n-      val = TREE_VALUE (tail);\n-      type = TREE_TYPE (val);\n-      /* EXPAND_INITIALIZER will not generate code for valid initializer\n-\t constants, but will still generate code for other types of operand.\n-\t This is the behavior we want for constant constraints.  */\n-      op = expand_expr (val, NULL_RTX, VOIDmode,\n-\t\t\tallows_reg ? EXPAND_NORMAL\n-\t\t\t: allows_mem ? EXPAND_MEMORY\n-\t\t\t: EXPAND_INITIALIZER);\n-\n-      /* Never pass a CONCAT to an ASM.  */\n-      if (GET_CODE (op) == CONCAT)\n-\top = force_reg (GET_MODE (op), op);\n-      else if (MEM_P (op))\n-\top = validize_mem (op);\n-\n-      if (asm_operand_ok (op, constraint, NULL) <= 0)\n-\t{\n-\t  if (allows_reg && TYPE_MODE (type) != BLKmode)\n-\t    op = force_reg (TYPE_MODE (type), op);\n-\t  else if (!allows_mem)\n-\t    warning (0, \"asm operand %d probably doesn%'t match constraints\",\n-\t\t     i + noutputs);\n-\t  else if (MEM_P (op))\n-\t    {\n-\t      /* We won't recognize either volatile memory or memory\n-\t\t with a queued address as available a memory_operand\n-\t\t at this point.  Ignore it: clearly this *is* a memory.  */\n-\t    }\n-\t  else\n-\t    gcc_unreachable ();\n-\t}\n-\n-      generating_concat_p = old_generating_concat_p;\n-      ASM_OPERANDS_INPUT (body, i) = op;\n-\n-      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, i)\n-\t= gen_rtx_ASM_INPUT (TYPE_MODE (type),\n-\t\t\t     ggc_strdup (constraints[i + noutputs]));\n-\n-      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n-\tclobber_conflict_found = 1;\n-    }\n-\n-  /* Protect all the operands from the queue now that they have all been\n-     evaluated.  */\n-\n-  generating_concat_p = 0;\n-\n-  /* For in-out operands, copy output rtx to input rtx.  */\n-  for (i = 0; i < ninout; i++)\n-    {\n-      int j = inout_opnum[i];\n-      char buffer[16];\n-\n-      ASM_OPERANDS_INPUT (body, ninputs - ninout + i)\n-\t= output_rtx[j];\n-\n-      sprintf (buffer, \"%d\", j);\n-      ASM_OPERANDS_INPUT_CONSTRAINT_EXP (body, ninputs - ninout + i)\n-\t= gen_rtx_ASM_INPUT (inout_mode[i], ggc_strdup (buffer));\n-    }\n-\n-  /* Copy labels to the vector.  */\n-  for (i = 0, tail = labels; i < nlabels; ++i, tail = TREE_CHAIN (tail))\n-    {\n-      rtx r;\n-      /* If asm goto has any labels in the fallthru basic block, use\n-\t a label that we emit immediately after the asm goto.  Expansion\n-\t may insert further instructions into the same basic block after\n-\t asm goto and if we don't do this, insertion of instructions on\n-\t the fallthru edge might misbehave.  See PR58670.  */\n-      if (fallthru_bb\n-\t  && label_to_block_fn (cfun, TREE_VALUE (tail)) == fallthru_bb)\n-\t{\n-\t  if (fallthru_label == NULL_RTX)\n-\t    fallthru_label = gen_label_rtx ();\n-\t  r = fallthru_label;\n-\t}\n-      else\n-\tr = label_rtx (TREE_VALUE (tail));\n-      ASM_OPERANDS_LABEL (body, i) = gen_rtx_LABEL_REF (Pmode, r);\n-    }\n-\n-  generating_concat_p = old_generating_concat_p;\n-\n-  /* Now, for each output, construct an rtx\n-     (set OUTPUT (asm_operands INSN OUTPUTCONSTRAINT OUTPUTNUMBER\n-\t\t\t       ARGVEC CONSTRAINTS OPNAMES))\n-     If there is more than one, put them inside a PARALLEL.  */\n-\n-  if (nlabels > 0 && nclobbers == 0)\n-    {\n-      gcc_assert (noutputs == 0);\n-      emit_jump_insn (body);\n-    }\n-  else if (noutputs == 0 && nclobbers == 0)\n-    {\n-      /* No output operands: put in a raw ASM_OPERANDS rtx.  */\n-      emit_insn (body);\n-    }\n-  else if (noutputs == 1 && nclobbers == 0)\n-    {\n-      ASM_OPERANDS_OUTPUT_CONSTRAINT (body) = ggc_strdup (constraints[0]);\n-      emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n-    }\n-  else\n-    {\n-      rtx obody = body;\n-      int num = noutputs;\n-\n-      if (num == 0)\n-\tnum = 1;\n-\n-      body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num + nclobbers));\n-\n-      /* For each output operand, store a SET.  */\n-      for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-\t{\n-\t  XVECEXP (body, 0, i)\n-\t    = gen_rtx_SET (VOIDmode,\n-\t\t\t   output_rtx[i],\n-\t\t\t   gen_rtx_ASM_OPERANDS\n-\t\t\t   (GET_MODE (output_rtx[i]),\n-\t\t\t    ggc_strdup (TREE_STRING_POINTER (string)),\n-\t\t\t    ggc_strdup (constraints[i]),\n-\t\t\t    i, argvec, constraintvec, labelvec, locus));\n-\n-\t  MEM_VOLATILE_P (SET_SRC (XVECEXP (body, 0, i))) = vol;\n-\t}\n-\n-      /* If there are no outputs (but there are some clobbers)\n-\t store the bare ASM_OPERANDS into the PARALLEL.  */\n-\n-      if (i == 0)\n-\tXVECEXP (body, 0, i++) = obody;\n-\n-      /* Store (clobber REG) for each clobbered register specified.  */\n-\n-      for (tail = clobbers; tail; tail = TREE_CHAIN (tail))\n-\t{\n-\t  const char *regname = TREE_STRING_POINTER (TREE_VALUE (tail));\n-\t  int reg, nregs;\n-\t  int j = decode_reg_name_and_count (regname, &nregs);\n-\t  rtx clobbered_reg;\n-\n-\t  if (j < 0)\n-\t    {\n-\t      if (j == -3)\t/* `cc', which is not a register */\n-\t\tcontinue;\n-\n-\t      if (j == -4)\t/* `memory', don't cache memory across asm */\n-\t\t{\n-\t\t  XVECEXP (body, 0, i++)\n-\t\t    = gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t       gen_rtx_MEM\n-\t\t\t\t       (BLKmode,\n-\t\t\t\t\tgen_rtx_SCRATCH (VOIDmode)));\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Ignore unknown register, error already signaled.  */\n-\t      continue;\n-\t    }\n-\n-\t  for (reg = j; reg < j + nregs; reg++)\n-\t    {\n-\t      /* Use QImode since that's guaranteed to clobber just\n-\t       * one reg.  */\n-\t      clobbered_reg = gen_rtx_REG (QImode, reg);\n-\n-\t      /* Do sanity check for overlap between clobbers and\n-\t\t respectively input and outputs that hasn't been\n-\t\t handled.  Such overlap should have been detected and\n-\t\t reported above.  */\n-\t      if (!clobber_conflict_found)\n-\t\t{\n-\t\t  int opno;\n-\n-\t\t  /* We test the old body (obody) contents to avoid\n-\t\t     tripping over the under-construction body.  */\n-\t\t  for (opno = 0; opno < noutputs; opno++)\n-\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n-\t\t\t\t\t\t output_rtx[opno]))\n-\t\t      internal_error\n-\t\t\t(\"asm clobber conflict with output operand\");\n-\n-\t\t  for (opno = 0; opno < ninputs - ninout; opno++)\n-\t\t    if (reg_overlap_mentioned_p (clobbered_reg,\n-\t\t\t\t\t\t ASM_OPERANDS_INPUT (obody,\n-\t\t\t\t\t\t\t\t     opno)))\n-\t\t      internal_error\n-\t\t\t(\"asm clobber conflict with input operand\");\n-\t\t}\n-\n-\t      XVECEXP (body, 0, i++)\n-\t\t= gen_rtx_CLOBBER (VOIDmode, clobbered_reg);\n-\t    }\n-\t}\n-\n-      if (nlabels > 0)\n-\temit_jump_insn (body);\n-      else\n-\temit_insn (body);\n-    }\n-\n-  if (fallthru_label)\n-    emit_label (fallthru_label);\n-\n-  /* For any outputs that needed reloading into registers, spill them\n-     back to where they belong.  */\n-  for (i = 0; i < noutputs; ++i)\n-    if (real_output_rtx[i])\n-      emit_move_insn (real_output_rtx[i], output_rtx[i]);\n-\n-  crtl->has_asm_statement = 1;\n-  free_temp_slots ();\n-}\n-\n-void\n-expand_asm_stmt (gimple stmt)\n-{\n-  int noutputs;\n-  tree outputs, tail, t;\n-  tree *o;\n-  size_t i, n;\n-  const char *s;\n-  tree str, out, in, cl, labels;\n-  location_t locus = gimple_location (stmt);\n-  basic_block fallthru_bb = NULL;\n-\n-  /* Meh... convert the gimple asm operands into real tree lists.\n-     Eventually we should make all routines work on the vectors instead\n-     of relying on TREE_CHAIN.  */\n-  out = NULL_TREE;\n-  n = gimple_asm_noutputs (stmt);\n-  if (n > 0)\n-    {\n-      t = out = gimple_asm_output_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_output_op (stmt, i);\n-    }\n-\n-  in = NULL_TREE;\n-  n = gimple_asm_ninputs (stmt);\n-  if (n > 0)\n-    {\n-      t = in = gimple_asm_input_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_input_op (stmt, i);\n-    }\n-\n-  cl = NULL_TREE;\n-  n = gimple_asm_nclobbers (stmt);\n-  if (n > 0)\n-    {\n-      t = cl = gimple_asm_clobber_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_clobber_op (stmt, i);\n-    }\n-\n-  labels = NULL_TREE;\n-  n = gimple_asm_nlabels (stmt);\n-  if (n > 0)\n-    {\n-      edge fallthru = find_fallthru_edge (gimple_bb (stmt)->succs);\n-      if (fallthru)\n-\tfallthru_bb = fallthru->dest;\n-      t = labels = gimple_asm_label_op (stmt, 0);\n-      for (i = 1; i < n; i++)\n-\tt = TREE_CHAIN (t) = gimple_asm_label_op (stmt, i);\n-    }\n-\n-  s = gimple_asm_string (stmt);\n-  str = build_string (strlen (s), s);\n-\n-  if (gimple_asm_input_p (stmt))\n-    {\n-      expand_asm_loc (str, gimple_asm_volatile_p (stmt), locus);\n-      return;\n-    }\n-\n-  outputs = out;\n-  noutputs = gimple_asm_noutputs (stmt);\n-  /* o[I] is the place that output number I should be written.  */\n-  o = (tree *) alloca (noutputs * sizeof (tree));\n-\n-  /* Record the contents of OUTPUTS before it is modified.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    o[i] = TREE_VALUE (tail);\n-\n-  /* Generate the ASM_OPERANDS insn; store into the TREE_VALUEs of\n-     OUTPUTS some trees for where the values were actually stored.  */\n-  expand_asm_operands (str, outputs, in, cl, labels, fallthru_bb,\n-\t\t       gimple_asm_volatile_p (stmt), locus);\n-\n-  /* Copy all the intermediate outputs into the specified outputs.  */\n-  for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n-    {\n-      if (o[i] != TREE_VALUE (tail))\n-\t{\n-\t  expand_assignment (o[i], TREE_VALUE (tail), false);\n-\t  free_temp_slots ();\n-\n-\t  /* Restore the original value so that it's correct the next\n-\t     time we expand this function.  */\n-\t  TREE_VALUE (tail) = o[i];\n-\t}\n-    }\n-}\n-\n-/* A subroutine of expand_asm_operands.  Check that all operands have\n-   the same number of alternatives.  Return true if so.  */\n-\n-static bool\n-check_operand_nalternatives (tree outputs, tree inputs)\n-{\n-  if (outputs || inputs)\n-    {\n-      tree tmp = TREE_PURPOSE (outputs ? outputs : inputs);\n-      int nalternatives\n-\t= n_occurrences (',', TREE_STRING_POINTER (TREE_VALUE (tmp)));\n-      tree next = inputs;\n-\n-      if (nalternatives + 1 > MAX_RECOG_ALTERNATIVES)\n-\t{\n-\t  error (\"too many alternatives in %<asm%>\");\n-\t  return false;\n-\t}\n-\n-      tmp = outputs;\n-      while (tmp)\n-\t{\n-\t  const char *constraint\n-\t    = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tmp)));\n-\n-\t  if (n_occurrences (',', constraint) != nalternatives)\n-\t    {\n-\t      error (\"operand constraints for %<asm%> differ \"\n-\t\t     \"in number of alternatives\");\n-\t      return false;\n-\t    }\n-\n-\t  if (TREE_CHAIN (tmp))\n-\t    tmp = TREE_CHAIN (tmp);\n-\t  else\n-\t    tmp = next, next = 0;\n-\t}\n-    }\n-\n-  return true;\n-}\n \n /* A subroutine of expand_asm_operands.  Check that all operand names\n    are unique.  Return true if so.  We rely on the fact that these names\n@@ -1427,19 +702,6 @@ resolve_operand_name_1 (char *p, tree outputs, tree inputs, tree labels)\n   return p;\n }\n \f\n-/* Generate RTL to return from the current function, with no value.\n-   (That is, we do not do anything about returning any value.)  */\n-\n-void\n-expand_null_return (void)\n-{\n-  /* If this function was declared to return a value, but we\n-     didn't, clobber the return registers so that they are not\n-     propagated live to the rest of the function.  */\n-  clobber_return_register ();\n-\n-  expand_null_return_1 ();\n-}\n \n /* Generate RTL to return directly from the current function.\n    (That is, we bypass any return value.)  */\n@@ -1459,154 +721,6 @@ expand_naked_return (void)\n   emit_jump (end_label);\n }\n \n-/* Generate RTL to return from the current function, with value VAL.  */\n-\n-static void\n-expand_value_return (rtx val)\n-{\n-  /* Copy the value to the return location unless it's already there.  */\n-\n-  tree decl = DECL_RESULT (current_function_decl);\n-  rtx return_reg = DECL_RTL (decl);\n-  if (return_reg != val)\n-    {\n-      tree funtype = TREE_TYPE (current_function_decl);\n-      tree type = TREE_TYPE (decl);\n-      int unsignedp = TYPE_UNSIGNED (type);\n-      enum machine_mode old_mode = DECL_MODE (decl);\n-      enum machine_mode mode;\n-      if (DECL_BY_REFERENCE (decl))\n-        mode = promote_function_mode (type, old_mode, &unsignedp, funtype, 2);\n-      else\n-        mode = promote_function_mode (type, old_mode, &unsignedp, funtype, 1);\n-\n-      if (mode != old_mode)\n-\tval = convert_modes (mode, old_mode, val, unsignedp);\n-\n-      if (GET_CODE (return_reg) == PARALLEL)\n-\temit_group_load (return_reg, val, type, int_size_in_bytes (type));\n-      else\n-\temit_move_insn (return_reg, val);\n-    }\n-\n-  expand_null_return_1 ();\n-}\n-\n-/* Output a return with no value.  */\n-\n-static void\n-expand_null_return_1 (void)\n-{\n-  clear_pending_stack_adjust ();\n-  do_pending_stack_adjust ();\n-  emit_jump (return_label);\n-}\n-\f\n-/* Generate RTL to evaluate the expression RETVAL and return it\n-   from the current function.  */\n-\n-void\n-expand_return (tree retval)\n-{\n-  rtx result_rtl;\n-  rtx val = 0;\n-  tree retval_rhs;\n-\n-  /* If function wants no value, give it none.  */\n-  if (TREE_CODE (TREE_TYPE (TREE_TYPE (current_function_decl))) == VOID_TYPE)\n-    {\n-      expand_normal (retval);\n-      expand_null_return ();\n-      return;\n-    }\n-\n-  if (retval == error_mark_node)\n-    {\n-      /* Treat this like a return of no value from a function that\n-\t returns a value.  */\n-      expand_null_return ();\n-      return;\n-    }\n-  else if ((TREE_CODE (retval) == MODIFY_EXPR\n-\t    || TREE_CODE (retval) == INIT_EXPR)\n-\t   && TREE_CODE (TREE_OPERAND (retval, 0)) == RESULT_DECL)\n-    retval_rhs = TREE_OPERAND (retval, 1);\n-  else\n-    retval_rhs = retval;\n-\n-  result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n-\n-  /* If we are returning the RESULT_DECL, then the value has already\n-     been stored into it, so we don't have to do anything special.  */\n-  if (TREE_CODE (retval_rhs) == RESULT_DECL)\n-    expand_value_return (result_rtl);\n-\n-  /* If the result is an aggregate that is being returned in one (or more)\n-     registers, load the registers here.  */\n-\n-  else if (retval_rhs != 0\n-\t   && TYPE_MODE (TREE_TYPE (retval_rhs)) == BLKmode\n-\t   && REG_P (result_rtl))\n-    {\n-      val = copy_blkmode_to_reg (GET_MODE (result_rtl), retval_rhs);\n-      if (val)\n-\t{\n-\t  /* Use the mode of the result value on the return register.  */\n-\t  PUT_MODE (result_rtl, GET_MODE (val));\n-\t  expand_value_return (val);\n-\t}\n-      else\n-\texpand_null_return ();\n-    }\n-  else if (retval_rhs != 0\n-\t   && !VOID_TYPE_P (TREE_TYPE (retval_rhs))\n-\t   && (REG_P (result_rtl)\n-\t       || (GET_CODE (result_rtl) == PARALLEL)))\n-    {\n-      /* Calculate the return value into a temporary (usually a pseudo\n-         reg).  */\n-      tree ot = TREE_TYPE (DECL_RESULT (current_function_decl));\n-      tree nt = build_qualified_type (ot, TYPE_QUALS (ot) | TYPE_QUAL_CONST);\n-\n-      val = assign_temp (nt, 0, 1);\n-      val = expand_expr (retval_rhs, val, GET_MODE (val), EXPAND_NORMAL);\n-      val = force_not_mem (val);\n-      /* Return the calculated value.  */\n-      expand_value_return (val);\n-    }\n-  else\n-    {\n-      /* No hard reg used; calculate value into hard return reg.  */\n-      expand_expr (retval, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      expand_value_return (result_rtl);\n-    }\n-}\n-\f\n-\f\n-/* Emit code to save the current value of stack.  */\n-rtx\n-expand_stack_save (void)\n-{\n-  rtx ret = NULL_RTX;\n-\n-  do_pending_stack_adjust ();\n-  emit_stack_save (SAVE_BLOCK, &ret);\n-  return ret;\n-}\n-\n-/* Emit code to restore the current value of stack.  */\n-void\n-expand_stack_restore (tree var)\n-{\n-  rtx prev, sa = expand_normal (var);\n-\n-  sa = convert_memory_address (Pmode, sa);\n-\n-  prev = get_last_insn ();\n-  emit_stack_restore (SAVE_BLOCK, sa);\n-  fixup_args_size_notes (prev, get_last_insn (), 0);\n-}\n-\n /* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE. PROB\n    is the probability of jumping to LABEL.  */\n static void"}, {"sha": "9310dfd21ec9eac517614280667866d34dc21329", "filename": "gcc/symtab.c", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"timevar.h\"\n #include \"lto-streamer.h\"\n #include \"rtl.h\"\n+#include \"output.h\"\n \n const char * const ld_plugin_symbol_resolution_names[]=\n {\n@@ -81,6 +82,28 @@ eq_node (const void *p1, const void *p2)\n   return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n }\n \n+/* Hash asmnames ignoring the user specified marks.  */\n+\n+static hashval_t\n+decl_assembler_name_hash (const_tree asmname)\n+{\n+  if (IDENTIFIER_POINTER (asmname)[0] == '*')\n+    {\n+      const char *decl_str = IDENTIFIER_POINTER (asmname) + 1;\n+      size_t ulp_len = strlen (user_label_prefix);\n+\n+      if (ulp_len == 0)\n+\t;\n+      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n+\tdecl_str += ulp_len;\n+\n+      return htab_hash_string (decl_str);\n+    }\n+\n+  return htab_hash_string (IDENTIFIER_POINTER (asmname));\n+}\n+\n+\n /* Returns a hash code for P.  */\n \n static hashval_t\n@@ -90,6 +113,62 @@ hash_node_by_assembler_name (const void *p)\n   return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n }\n \n+/* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n+\n+static bool\n+decl_assembler_name_equal (tree decl, const_tree asmname)\n+{\n+  tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n+  const char *decl_str;\n+  const char *asmname_str;\n+  bool test = false;\n+\n+  if (decl_asmname == asmname)\n+    return true;\n+\n+  decl_str = IDENTIFIER_POINTER (decl_asmname);\n+  asmname_str = IDENTIFIER_POINTER (asmname);\n+\n+\n+  /* If the target assembler name was set by the user, things are trickier.\n+     We have a leading '*' to begin with.  After that, it's arguable what\n+     is the correct thing to do with -fleading-underscore.  Arguably, we've\n+     historically been doing the wrong thing in assemble_alias by always\n+     printing the leading underscore.  Since we're not changing that, make\n+     sure user_label_prefix follows the '*' before matching.  */\n+  if (decl_str[0] == '*')\n+    {\n+      size_t ulp_len = strlen (user_label_prefix);\n+\n+      decl_str ++;\n+\n+      if (ulp_len == 0)\n+\ttest = true;\n+      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n+\tdecl_str += ulp_len, test=true;\n+      else\n+\tdecl_str --;\n+    }\n+  if (asmname_str[0] == '*')\n+    {\n+      size_t ulp_len = strlen (user_label_prefix);\n+\n+      asmname_str ++;\n+\n+      if (ulp_len == 0)\n+\ttest = true;\n+      else if (strncmp (asmname_str, user_label_prefix, ulp_len) == 0)\n+\tasmname_str += ulp_len, test=true;\n+      else\n+\tasmname_str --;\n+    }\n+\n+  if (!test)\n+    return false;\n+  return strcmp (decl_str, asmname_str) == 0;\n+}\n+\n+\n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int"}, {"sha": "784ff247e9d752d126c39f9a1704c79c6170eb7b", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -592,6 +592,12 @@ diagnose_tm_1_op (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+static inline bool\n+is_tm_safe_or_pure (const_tree x)\n+{\n+  return is_tm_safe (x) || is_tm_pure (x);\n+}\n+\n static tree\n diagnose_tm_1 (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t\t    struct walk_stmt_info *wi)"}, {"sha": "a489b61c3f246f10546c701e64fd5631f88ccd46", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -2506,6 +2506,68 @@ operation_could_trap_p (enum tree_code op, bool fp_operation, bool honor_trapv,\n \t\t\t\t\t&handled);\n }\n \n+\n+/* Returns true if it is possible to prove that the index of\n+   an array access REF (an ARRAY_REF expression) falls into the\n+   array bounds.  */\n+\n+static bool\n+in_array_bounds_p (tree ref)\n+{\n+  tree idx = TREE_OPERAND (ref, 1);\n+  tree min, max;\n+\n+  if (TREE_CODE (idx) != INTEGER_CST)\n+    return false;\n+\n+  min = array_ref_low_bound (ref);\n+  max = array_ref_up_bound (ref);\n+  if (!min\n+      || !max\n+      || TREE_CODE (min) != INTEGER_CST\n+      || TREE_CODE (max) != INTEGER_CST)\n+    return false;\n+\n+  if (tree_int_cst_lt (idx, min)\n+      || tree_int_cst_lt (max, idx))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Returns true if it is possible to prove that the range of\n+   an array access REF (an ARRAY_RANGE_REF expression) falls\n+   into the array bounds.  */\n+\n+static bool\n+range_in_array_bounds_p (tree ref)\n+{\n+  tree domain_type = TYPE_DOMAIN (TREE_TYPE (ref));\n+  tree range_min, range_max, min, max;\n+\n+  range_min = TYPE_MIN_VALUE (domain_type);\n+  range_max = TYPE_MAX_VALUE (domain_type);\n+  if (!range_min\n+      || !range_max\n+      || TREE_CODE (range_min) != INTEGER_CST\n+      || TREE_CODE (range_max) != INTEGER_CST)\n+    return false;\n+\n+  min = array_ref_low_bound (ref);\n+  max = array_ref_up_bound (ref);\n+  if (!min\n+      || !max\n+      || TREE_CODE (min) != INTEGER_CST\n+      || TREE_CODE (max) != INTEGER_CST)\n+    return false;\n+\n+  if (tree_int_cst_lt (range_min, min)\n+      || tree_int_cst_lt (max, range_max))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if EXPR can trap, as in dereferencing an invalid pointer\n    location or floating point arithmetic.  C.f. the rtl version, may_trap_p.\n    This routine expects only GIMPLE lhs or rhs input.  */"}, {"sha": "576dcb786ede05e0ff282ce7d718e827e6873a26", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -1181,7 +1181,7 @@ init_object_sizes (void)\n \n /* Destroy data structures after the object size computation.  */\n \n-void\n+static void\n fini_object_sizes (void)\n {\n   int object_size_type;"}, {"sha": "6a6f027e90cc62ace942ca0ba7104ea95654b95d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -536,6 +536,29 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n     }\n }\n \n+/* Generate a hash value for a pair of expressions.  This can be used\n+   iteratively by passing a previous result as the VAL argument.\n+\n+   The same hash value is always returned for a given pair of expressions,\n+   regardless of the order in which they are presented.  This is useful in\n+   hashing the operands of commutative functions.  */\n+\n+static hashval_t\n+iterative_hash_exprs_commutative (const_tree t1,\n+                                  const_tree t2, hashval_t val)\n+{\n+  hashval_t one = iterative_hash_expr (t1, 0);\n+  hashval_t two = iterative_hash_expr (t2, 0);\n+  hashval_t t;\n+\n+  if (one > two)\n+    t = one, one = two, two = t;\n+  val = iterative_hash_hashval_t (one, val);\n+  val = iterative_hash_hashval_t (two, val);\n+\n+  return val;\n+}\n+\n /* Compute a hash value for a hashable_expr value EXPR and a\n    previously accumulated hash value VAL.  If two hashable_expr\n    values compare equal with hashable_expr_equal_p, they must"}, {"sha": "8f8b5ebada78af27a953e167da9fb7d510b2e748", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -1464,24 +1464,6 @@ value_range_nonnegative_p (value_range_t *vr)\n   return false;\n }\n \n-/* Return true if T, an SSA_NAME, is known to be nonnegative.  Return\n-   false otherwise or if no value range information is available.  */\n-\n-bool\n-ssa_name_nonnegative_p (const_tree t)\n-{\n-  value_range_t *vr = get_value_range (t);\n-\n-  if (INTEGRAL_TYPE_P (t)\n-      && TYPE_UNSIGNED (t))\n-    return true;\n-\n-  if (!vr)\n-    return false;\n-\n-  return value_range_nonnegative_p (vr);\n-}\n-\n /* If *VR has a value rante that is a single constant value return that,\n    otherwise return NULL_TREE.  */\n "}, {"sha": "686a680f94c698ffa63f55390c3ed4088aefe9ec", "filename": "gcc/tree.c", "status": "modified", "additions": 94, "deletions": 500, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -588,82 +588,6 @@ decl_assembler_name (tree decl)\n   return DECL_WITH_VIS_CHECK (decl)->decl_with_vis.assembler_name;\n }\n \n-/* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n-\n-bool\n-decl_assembler_name_equal (tree decl, const_tree asmname)\n-{\n-  tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n-  const char *decl_str;\n-  const char *asmname_str;\n-  bool test = false;\n-\n-  if (decl_asmname == asmname)\n-    return true;\n-\n-  decl_str = IDENTIFIER_POINTER (decl_asmname);\n-  asmname_str = IDENTIFIER_POINTER (asmname);\n-\n-\n-  /* If the target assembler name was set by the user, things are trickier.\n-     We have a leading '*' to begin with.  After that, it's arguable what\n-     is the correct thing to do with -fleading-underscore.  Arguably, we've\n-     historically been doing the wrong thing in assemble_alias by always\n-     printing the leading underscore.  Since we're not changing that, make\n-     sure user_label_prefix follows the '*' before matching.  */\n-  if (decl_str[0] == '*')\n-    {\n-      size_t ulp_len = strlen (user_label_prefix);\n-\n-      decl_str ++;\n-\n-      if (ulp_len == 0)\n-\ttest = true;\n-      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n-\tdecl_str += ulp_len, test=true;\n-      else\n-\tdecl_str --;\n-    }\n-  if (asmname_str[0] == '*')\n-    {\n-      size_t ulp_len = strlen (user_label_prefix);\n-\n-      asmname_str ++;\n-\n-      if (ulp_len == 0)\n-\ttest = true;\n-      else if (strncmp (asmname_str, user_label_prefix, ulp_len) == 0)\n-\tasmname_str += ulp_len, test=true;\n-      else\n-\tasmname_str --;\n-    }\n-\n-  if (!test)\n-    return false;\n-  return strcmp (decl_str, asmname_str) == 0;\n-}\n-\n-/* Hash asmnames ignoring the user specified marks.  */\n-\n-hashval_t\n-decl_assembler_name_hash (const_tree asmname)\n-{\n-  if (IDENTIFIER_POINTER (asmname)[0] == '*')\n-    {\n-      const char *decl_str = IDENTIFIER_POINTER (asmname) + 1;\n-      size_t ulp_len = strlen (user_label_prefix);\n-\n-      if (ulp_len == 0)\n-\t;\n-      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n-\tdecl_str += ulp_len;\n-\n-      return htab_hash_string (decl_str);\n-    }\n-\n-  return htab_hash_string (IDENTIFIER_POINTER (asmname));\n-}\n-\n /* Compute the number of bytes occupied by a tree with code CODE.\n    This function cannot be used for nodes that have variable sizes,\n    including TREE_VEC, STRING_CST, and CALL_EXPR.  */\n@@ -2386,35 +2310,6 @@ real_onep (const_tree expr)\n     }\n }\n \n-/* Return 1 if EXPR is the real constant two.  Trailing zeroes matter\n-   for decimal float constants, so don't return 1 for them.  */\n-\n-int\n-real_twop (const_tree expr)\n-{\n-  STRIP_NOPS (expr);\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case REAL_CST:\n-      return REAL_VALUES_EQUAL (TREE_REAL_CST (expr), dconst2)\n-\t     && !(DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (expr))));\n-    case COMPLEX_CST:\n-      return real_twop (TREE_REALPART (expr))\n-\t     && real_zerop (TREE_IMAGPART (expr));\n-    case VECTOR_CST:\n-      {\n-\tunsigned i;\n-\tfor (i = 0; i < VECTOR_CST_NELTS (expr); ++i)\n-\t  if (!real_twop (VECTOR_CST_ELT (expr, i)))\n-\t    return false;\n-\treturn true;\n-      }\n-    default:\n-      return false;\n-    }\n-}\n-\n /* Return 1 if EXPR is the real constant minus one.  Trailing zeroes\n    matter for decimal float constants, so don't return 1 for them.  */\n \n@@ -2552,21 +2447,6 @@ list_length (const_tree t)\n   return len;\n }\n \n-/* Returns the number of FIELD_DECLs in TYPE.  */\n-\n-int\n-fields_length (const_tree type)\n-{\n-  tree t = TYPE_FIELDS (type);\n-  int count = 0;\n-\n-  for (; t; t = DECL_CHAIN (t))\n-    if (TREE_CODE (t) == FIELD_DECL)\n-      ++count;\n-\n-  return count;\n-}\n-\n /* Returns the first FIELD_DECL in the TYPE_FIELDS of the RECORD_TYPE or\n    UNION_TYPE TYPE, or NULL_TREE if none.  */\n \n@@ -2787,18 +2667,6 @@ max_int_size_in_bytes (const_tree type)\n \n   return size;\n }\n-\n-/* Returns a tree for the size of EXP in bytes.  */\n-\n-tree\n-tree_expr_size (const_tree exp)\n-{\n-  if (DECL_P (exp)\n-      && DECL_SIZE_UNIT (exp) != 0)\n-    return DECL_SIZE_UNIT (exp);\n-  else\n-    return size_in_bytes (TREE_TYPE (exp));\n-}\n \f\n /* Return the bit position of FIELD, in bits from the start of the record.\n    This is a tree of type bitsizetype.  */\n@@ -3902,6 +3770,88 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n   return new_tree;\n }\n \f\n+\n+/* Subroutine of stabilize_reference; this is called for subtrees of\n+   references.  Any expression with side-effects must be put in a SAVE_EXPR\n+   to ensure that it is only evaluated once.\n+\n+   We don't put SAVE_EXPR nodes around everything, because assigning very\n+   simple expressions to temporaries causes us to miss good opportunities\n+   for optimizations.  Among other things, the opportunity to fold in the\n+   addition of a constant into an addressing mode often gets lost, e.g.\n+   \"y[i+1] += x;\".  In general, we take the approach that we should not make\n+   an assignment unless we are forced into it - i.e., that any non-side effect\n+   operator should be allowed, and that cse should take care of coalescing\n+   multiple utterances of the same expression should that prove fruitful.  */\n+\n+static tree\n+stabilize_reference_1 (tree e)\n+{\n+  tree result;\n+  enum tree_code code = TREE_CODE (e);\n+\n+  /* We cannot ignore const expressions because it might be a reference\n+     to a const array but whose index contains side-effects.  But we can\n+     ignore things that are actual constant or that already have been\n+     handled by this function.  */\n+\n+  if (tree_invariant_p (e))\n+    return e;\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_exceptional:\n+    case tcc_type:\n+    case tcc_declaration:\n+    case tcc_comparison:\n+    case tcc_statement:\n+    case tcc_expression:\n+    case tcc_reference:\n+    case tcc_vl_exp:\n+      /* If the expression has side-effects, then encase it in a SAVE_EXPR\n+\t so that it will only be evaluated once.  */\n+      /* The reference (r) and comparison (<) classes could be handled as\n+\t below, but it is generally faster to only evaluate them once.  */\n+      if (TREE_SIDE_EFFECTS (e))\n+\treturn save_expr (e);\n+      return e;\n+\n+    case tcc_constant:\n+      /* Constants need no processing.  In fact, we should never reach\n+\t here.  */\n+      return e;\n+\n+    case tcc_binary:\n+      /* Division is slow and tends to be compiled with jumps,\n+\t especially the division by powers of 2 that is often\n+\t found inside of an array reference.  So do it just once.  */\n+      if (code == TRUNC_DIV_EXPR || code == TRUNC_MOD_EXPR\n+\t  || code == FLOOR_DIV_EXPR || code == FLOOR_MOD_EXPR\n+\t  || code == CEIL_DIV_EXPR || code == CEIL_MOD_EXPR\n+\t  || code == ROUND_DIV_EXPR || code == ROUND_MOD_EXPR)\n+\treturn save_expr (e);\n+      /* Recursively stabilize each operand.  */\n+      result = build_nt (code, stabilize_reference_1 (TREE_OPERAND (e, 0)),\n+\t\t\t stabilize_reference_1 (TREE_OPERAND (e, 1)));\n+      break;\n+\n+    case tcc_unary:\n+      /* Recursively stabilize each operand.  */\n+      result = build_nt (code, stabilize_reference_1 (TREE_OPERAND (e, 0)));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  TREE_TYPE (result) = TREE_TYPE (e);\n+  TREE_READONLY (result) = TREE_READONLY (e);\n+  TREE_SIDE_EFFECTS (result) = TREE_SIDE_EFFECTS (e);\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n+\n+  return result;\n+}\n+\n /* Stabilize a reference so that we can use it any number of times\n    without causing its operands to be evaluated more than once.\n    Returns the stabilized reference.  This works by means of save_expr,\n@@ -3983,87 +3933,6 @@ stabilize_reference (tree ref)\n \n   return result;\n }\n-\n-/* Subroutine of stabilize_reference; this is called for subtrees of\n-   references.  Any expression with side-effects must be put in a SAVE_EXPR\n-   to ensure that it is only evaluated once.\n-\n-   We don't put SAVE_EXPR nodes around everything, because assigning very\n-   simple expressions to temporaries causes us to miss good opportunities\n-   for optimizations.  Among other things, the opportunity to fold in the\n-   addition of a constant into an addressing mode often gets lost, e.g.\n-   \"y[i+1] += x;\".  In general, we take the approach that we should not make\n-   an assignment unless we are forced into it - i.e., that any non-side effect\n-   operator should be allowed, and that cse should take care of coalescing\n-   multiple utterances of the same expression should that prove fruitful.  */\n-\n-tree\n-stabilize_reference_1 (tree e)\n-{\n-  tree result;\n-  enum tree_code code = TREE_CODE (e);\n-\n-  /* We cannot ignore const expressions because it might be a reference\n-     to a const array but whose index contains side-effects.  But we can\n-     ignore things that are actual constant or that already have been\n-     handled by this function.  */\n-\n-  if (tree_invariant_p (e))\n-    return e;\n-\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_exceptional:\n-    case tcc_type:\n-    case tcc_declaration:\n-    case tcc_comparison:\n-    case tcc_statement:\n-    case tcc_expression:\n-    case tcc_reference:\n-    case tcc_vl_exp:\n-      /* If the expression has side-effects, then encase it in a SAVE_EXPR\n-\t so that it will only be evaluated once.  */\n-      /* The reference (r) and comparison (<) classes could be handled as\n-\t below, but it is generally faster to only evaluate them once.  */\n-      if (TREE_SIDE_EFFECTS (e))\n-\treturn save_expr (e);\n-      return e;\n-\n-    case tcc_constant:\n-      /* Constants need no processing.  In fact, we should never reach\n-\t here.  */\n-      return e;\n-\n-    case tcc_binary:\n-      /* Division is slow and tends to be compiled with jumps,\n-\t especially the division by powers of 2 that is often\n-\t found inside of an array reference.  So do it just once.  */\n-      if (code == TRUNC_DIV_EXPR || code == TRUNC_MOD_EXPR\n-\t  || code == FLOOR_DIV_EXPR || code == FLOOR_MOD_EXPR\n-\t  || code == CEIL_DIV_EXPR || code == CEIL_MOD_EXPR\n-\t  || code == ROUND_DIV_EXPR || code == ROUND_MOD_EXPR)\n-\treturn save_expr (e);\n-      /* Recursively stabilize each operand.  */\n-      result = build_nt (code, stabilize_reference_1 (TREE_OPERAND (e, 0)),\n-\t\t\t stabilize_reference_1 (TREE_OPERAND (e, 1)));\n-      break;\n-\n-    case tcc_unary:\n-      /* Recursively stabilize each operand.  */\n-      result = build_nt (code, stabilize_reference_1 (TREE_OPERAND (e, 0)));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  TREE_TYPE (result) = TREE_TYPE (e);\n-  TREE_READONLY (result) = TREE_READONLY (e);\n-  TREE_SIDE_EFFECTS (result) = TREE_SIDE_EFFECTS (e);\n-  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n-\n-  return result;\n-}\n \f\n /* Low-level constructors for expressions.  */\n \n@@ -4758,43 +4627,22 @@ omp_declare_simd_clauses_equal (tree clauses1, tree clauses2)\n   return true;\n }\n \n-/* Remove duplicate \"omp declare simd\" attributes.  */\n+/* Compare two constructor-element-type constants.  Return 1 if the lists\n+   are known to be equal; otherwise return 0.  */\n \n-void\n-omp_remove_redundant_declare_simd_attrs (tree fndecl)\n+static bool\n+simple_cst_list_equal (const_tree l1, const_tree l2)\n {\n-  tree attr, end_attr = NULL_TREE, last_attr = NULL_TREE;\n-  for (attr = lookup_attribute (\"omp declare simd\", DECL_ATTRIBUTES (fndecl));\n-       attr;\n-       attr = lookup_attribute (\"omp declare simd\", TREE_CHAIN (attr)))\n+  while (l1 != NULL_TREE && l2 != NULL_TREE)\n     {\n-      tree *pc;\n-      for (pc = &TREE_CHAIN (attr); *pc && *pc != end_attr; )\n-\t{\n-\t  if (is_attribute_p (\"omp declare simd\", TREE_PURPOSE (*pc)))\n-\t    {\n-\t      last_attr = TREE_CHAIN (*pc);\n-\t      if (TREE_VALUE (attr) == NULL_TREE)\n-\t\t{\n-\t\t  if (TREE_VALUE (*pc) == NULL_TREE)\n-\t\t    {\n-\t\t      *pc = TREE_CHAIN (*pc);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t      else if (TREE_VALUE (*pc) != NULL_TREE\n-\t\t       && omp_declare_simd_clauses_equal\n-\t\t\t\t(TREE_VALUE (TREE_VALUE (*pc)),\n-\t\t\t\t TREE_VALUE (TREE_VALUE (attr))))\n-\t\t{\n-\t\t  *pc = TREE_CHAIN (*pc);\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t  pc = &TREE_CHAIN (*pc);\n-\t}\n-      end_attr = last_attr;\n+      if (simple_cst_equal (TREE_VALUE (l1), TREE_VALUE (l2)) != 1)\n+\treturn false;\n+\n+      l1 = TREE_CHAIN (l1);\n+      l2 = TREE_CHAIN (l2);\n     }\n+\n+  return l1 == l2;\n }\n \n /* Compare two attributes for their value identity.  Return true if the\n@@ -7129,17 +6977,6 @@ tree_low_cst (const_tree t, int pos)\n   return TREE_INT_CST_LOW (t);\n }\n \n-/* Return the HOST_WIDE_INT least significant bits of T, a sizetype\n-   kind INTEGER_CST.  This makes sure to properly sign-extend the\n-   constant.  */\n-\n-HOST_WIDE_INT\n-size_low_cst (const_tree t)\n-{\n-  double_int d = tree_to_double_int (t);\n-  return d.sext (TYPE_PRECISION (TREE_TYPE (t))).low;\n-}\n-\n /* Return the most significant (sign) bit of T.  */\n \n int\n@@ -7201,24 +7038,6 @@ tree_int_cst_min_precision (tree value, bool unsignedp)\n     return tree_floor_log2 (value) + 1 + !unsignedp;\n }\n \n-/* Compare two constructor-element-type constants.  Return 1 if the lists\n-   are known to be equal; otherwise return 0.  */\n-\n-int\n-simple_cst_list_equal (const_tree l1, const_tree l2)\n-{\n-  while (l1 != NULL_TREE && l2 != NULL_TREE)\n-    {\n-      if (simple_cst_equal (TREE_VALUE (l1), TREE_VALUE (l2)) != 1)\n-\treturn 0;\n-\n-      l1 = TREE_CHAIN (l1);\n-      l2 = TREE_CHAIN (l2);\n-    }\n-\n-  return l1 == l2;\n-}\n-\n /* Return truthvalue of whether T1 is the same tree structure as T2.\n    Return 1 if they are the same.\n    Return 0 if they are understandably different.\n@@ -7644,29 +7463,6 @@ iterative_hash_expr (const_tree t, hashval_t val)\n     }\n }\n \n-/* Generate a hash value for a pair of expressions.  This can be used\n-   iteratively by passing a previous result as the VAL argument.\n-\n-   The same hash value is always returned for a given pair of expressions,\n-   regardless of the order in which they are presented.  This is useful in\n-   hashing the operands of commutative functions.  */\n-\n-hashval_t\n-iterative_hash_exprs_commutative (const_tree t1,\n-                                  const_tree t2, hashval_t val)\n-{\n-  hashval_t one = iterative_hash_expr (t1, 0);\n-  hashval_t two = iterative_hash_expr (t2, 0);\n-  hashval_t t;\n-\n-  if (one > two)\n-    t = one, one = two, two = t;\n-  val = iterative_hash_hashval_t (one, val);\n-  val = iterative_hash_hashval_t (two, val);\n-\n-  return val;\n-}\n-\f\n /* Constructors for pointer, array and function types.\n    (RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE nodes are\n    constructed by language-dependent code, not here.)  */\n@@ -7808,30 +7604,6 @@ build_reference_type (tree to_type)\n   return build_reference_type_for_mode (to_type, pointer_mode, false);\n }\n \n-/* Build a type that is compatible with t but has no cv quals anywhere\n-   in its type, thus\n-\n-   const char *const *const *  ->  char ***.  */\n-\n-tree\n-build_type_no_quals (tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case POINTER_TYPE:\n-      return build_pointer_type_for_mode (build_type_no_quals (TREE_TYPE (t)),\n-\t\t\t\t\t  TYPE_MODE (t),\n-\t\t\t\t\t  TYPE_REF_CAN_ALIAS_ALL (t));\n-    case REFERENCE_TYPE:\n-      return\n-\tbuild_reference_type_for_mode (build_type_no_quals (TREE_TYPE (t)),\n-\t\t\t\t       TYPE_MODE (t),\n-\t\t\t\t       TYPE_REF_CAN_ALIAS_ALL (t));\n-    default:\n-      return TYPE_MAIN_VARIANT (t);\n-    }\n-}\n-\n #define MAX_INT_CACHED_PREC \\\n   (HOST_BITS_PER_WIDE_INT > 64 ? HOST_BITS_PER_WIDE_INT : 64)\n static GTY(()) tree nonstandard_integer_type_cache[2 * MAX_INT_CACHED_PREC + 2];\n@@ -8207,111 +7979,6 @@ build_function_type (tree value_type, tree arg_types)\n   return t;\n }\n \n-/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP and the\n-   return value if SKIP_RETURN is true.  */\n-\n-static tree\n-build_function_type_skip_args (tree orig_type, bitmap args_to_skip,\n-\t\t\t       bool skip_return)\n-{\n-  tree new_type = NULL;\n-  tree args, new_args = NULL, t;\n-  tree new_reversed;\n-  int i = 0;\n-\n-  for (args = TYPE_ARG_TYPES (orig_type); args && args != void_list_node;\n-       args = TREE_CHAIN (args), i++)\n-    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n-      new_args = tree_cons (NULL_TREE, TREE_VALUE (args), new_args);\n-\n-  new_reversed = nreverse (new_args);\n-  if (args)\n-    {\n-      if (new_reversed)\n-        TREE_CHAIN (new_args) = void_list_node;\n-      else\n-\tnew_reversed = void_list_node;\n-    }\n-\n-  /* Use copy_node to preserve as much as possible from original type\n-     (debug info, attribute lists etc.)\n-     Exception is METHOD_TYPEs must have THIS argument.\n-     When we are asked to remove it, we need to build new FUNCTION_TYPE\n-     instead.  */\n-  if (TREE_CODE (orig_type) != METHOD_TYPE\n-      || !args_to_skip\n-      || !bitmap_bit_p (args_to_skip, 0))\n-    {\n-      new_type = build_distinct_type_copy (orig_type);\n-      TYPE_ARG_TYPES (new_type) = new_reversed;\n-    }\n-  else\n-    {\n-      new_type\n-        = build_distinct_type_copy (build_function_type (TREE_TYPE (orig_type),\n-\t\t\t\t\t\t\t new_reversed));\n-      TYPE_CONTEXT (new_type) = TYPE_CONTEXT (orig_type);\n-    }\n-\n-  if (skip_return)\n-    TREE_TYPE (new_type) = void_type_node;\n-\n-  /* This is a new type, not a copy of an old type.  Need to reassociate\n-     variants.  We can handle everything except the main variant lazily.  */\n-  t = TYPE_MAIN_VARIANT (orig_type);\n-  if (t != orig_type)\n-    {\n-      t = build_function_type_skip_args (t, args_to_skip, skip_return);\n-      TYPE_MAIN_VARIANT (new_type) = t;\n-      TYPE_NEXT_VARIANT (new_type) = TYPE_NEXT_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = new_type;\n-    }\n-  else\n-    {\n-      TYPE_MAIN_VARIANT (new_type) = new_type;\n-      TYPE_NEXT_VARIANT (new_type) = NULL;\n-    }\n-\n-  return new_type;\n-}\n-\n-/* Build variant of function decl ORIG_DECL skipping ARGS_TO_SKIP and the\n-   return value if SKIP_RETURN is true.\n-\n-   Arguments from DECL_ARGUMENTS list can't be removed now, since they are\n-   linked by TREE_CHAIN directly.  The caller is responsible for eliminating\n-   them when they are being duplicated (i.e. copy_arguments_for_versioning).  */\n-\n-tree\n-build_function_decl_skip_args (tree orig_decl, bitmap args_to_skip,\n-\t\t\t       bool skip_return)\n-{\n-  tree new_decl = copy_node (orig_decl);\n-  tree new_type;\n-\n-  new_type = TREE_TYPE (orig_decl);\n-  if (prototype_p (new_type)\n-      || (skip_return && !VOID_TYPE_P (TREE_TYPE (new_type))))\n-    new_type\n-      = build_function_type_skip_args (new_type, args_to_skip, skip_return);\n-  TREE_TYPE (new_decl) = new_type;\n-\n-  /* For declarations setting DECL_VINDEX (i.e. methods)\n-     we expect first argument to be THIS pointer.   */\n-  if (args_to_skip && bitmap_bit_p (args_to_skip, 0))\n-    DECL_VINDEX (new_decl) = NULL_TREE;\n-\n-  /* When signature changes, we need to clear builtin info.  */\n-  if (DECL_BUILT_IN (new_decl)\n-      && args_to_skip\n-      && !bitmap_empty_p (args_to_skip))\n-    {\n-      DECL_BUILT_IN_CLASS (new_decl) = NOT_BUILT_IN;\n-      DECL_FUNCTION_CODE (new_decl) = (enum built_in_function) 0;\n-    }\n-  return new_decl;\n-}\n-\n /* Build a function type.  The RETURN_TYPE is the type returned by the\n    function.  If VAARGS is set, no void_type_node is appended to the\n    the list.  ARGP must be always be terminated be a NULL_TREE.  */\n@@ -10781,68 +10448,6 @@ build_call_vec (tree return_type, tree fn, vec<tree, va_gc> *args)\n   return ret;\n }\n \n-\n-/* Returns true if it is possible to prove that the index of\n-   an array access REF (an ARRAY_REF expression) falls into the\n-   array bounds.  */\n-\n-bool\n-in_array_bounds_p (tree ref)\n-{\n-  tree idx = TREE_OPERAND (ref, 1);\n-  tree min, max;\n-\n-  if (TREE_CODE (idx) != INTEGER_CST)\n-    return false;\n-\n-  min = array_ref_low_bound (ref);\n-  max = array_ref_up_bound (ref);\n-  if (!min\n-      || !max\n-      || TREE_CODE (min) != INTEGER_CST\n-      || TREE_CODE (max) != INTEGER_CST)\n-    return false;\n-\n-  if (tree_int_cst_lt (idx, min)\n-      || tree_int_cst_lt (max, idx))\n-    return false;\n-\n-  return true;\n-}\n-\n-/* Returns true if it is possible to prove that the range of\n-   an array access REF (an ARRAY_RANGE_REF expression) falls\n-   into the array bounds.  */\n-\n-bool\n-range_in_array_bounds_p (tree ref)\n-{\n-  tree domain_type = TYPE_DOMAIN (TREE_TYPE (ref));\n-  tree range_min, range_max, min, max;\n-\n-  range_min = TYPE_MIN_VALUE (domain_type);\n-  range_max = TYPE_MAX_VALUE (domain_type);\n-  if (!range_min\n-      || !range_max\n-      || TREE_CODE (range_min) != INTEGER_CST\n-      || TREE_CODE (range_max) != INTEGER_CST)\n-    return false;\n-\n-  min = array_ref_low_bound (ref);\n-  max = array_ref_up_bound (ref);\n-  if (!min\n-      || !max\n-      || TREE_CODE (min) != INTEGER_CST\n-      || TREE_CODE (max) != INTEGER_CST)\n-    return false;\n-\n-  if (tree_int_cst_lt (range_min, min)\n-      || tree_int_cst_lt (max, range_max))\n-    return false;\n-\n-  return true;\n-}\n-\n /* Return true if T (assumed to be a DECL) must be assigned a memory\n    location.  */\n \n@@ -11910,17 +11515,6 @@ block_ultimate_origin (const_tree block)\n     }\n }\n \n-/* Return true if T1 and T2 are equivalent lists.  */\n-\n-bool\n-list_equal_p (const_tree t1, const_tree t2)\n-{\n-  for (; t1 && t2; t1 = TREE_CHAIN (t1) , t2 = TREE_CHAIN (t2))\n-    if (TREE_VALUE (t1) != TREE_VALUE (t2))\n-      return false;\n-  return !t1 && !t2;\n-}\n-\n /* Return true iff conversion in EXP generates no instruction.  Mark\n    it inline so that we fully inline into the stripping functions even\n    though we have two uses of this function.  */"}, {"sha": "c4b23d0864ab906355c166d8e56acd5c45935d38", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862d0b359fb98790d5fad654eecf471228d8bb77/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=862d0b359fb98790d5fad654eecf471228d8bb77", "patch": "@@ -3385,8 +3385,6 @@ tree_operand_check_code (const_tree __t, enum tree_code __code, int __i,\n    || ((NODE) && TREE_TYPE ((NODE)) == error_mark_node))\n \n extern tree decl_assembler_name (tree);\n-extern bool decl_assembler_name_equal (tree decl, const_tree asmname);\n-extern hashval_t decl_assembler_name_hash (const_tree asmname);\n \n /* Compute the number of bytes occupied by 'node'.  This routine only\n    looks at TREE_CODE and, if the code is TREE_VEC, TREE_VEC_LENGTH.  */\n@@ -3619,14 +3617,12 @@ extern tree build_reference_type (tree);\n extern tree build_vector_type_for_mode (tree, enum machine_mode);\n extern tree build_vector_type (tree innertype, int nunits);\n extern tree build_opaque_vector_type (tree innertype, int nunits);\n-extern tree build_type_no_quals (tree);\n extern tree build_index_type (tree);\n extern tree build_array_type (tree, tree);\n extern tree build_nonshared_array_type (tree, tree);\n extern tree build_array_type_nelts (tree, unsigned HOST_WIDE_INT);\n extern tree build_function_type (tree, tree);\n extern tree build_function_type_list (tree, ...);\n-extern tree build_function_decl_skip_args (tree, bitmap, bool);\n extern tree build_varargs_function_type_list (tree, ...);\n extern tree build_function_type_array (tree, int, tree *);\n extern tree build_varargs_function_type_array (tree, int, tree *);\n@@ -3640,8 +3636,6 @@ extern tree build_method_type (tree, tree);\n extern tree build_offset_type (tree, tree);\n extern tree build_complex_type (tree);\n extern tree array_type_nelts (const_tree);\n-extern bool in_array_bounds_p (tree);\n-extern bool range_in_array_bounds_p (tree);\n \n extern tree value_member (tree, tree);\n extern tree purpose_member (const_tree, tree);\n@@ -3667,7 +3661,6 @@ tree_low_cst (const_tree t, int pos)\n   return TREE_INT_CST_LOW (t);\n }\n #endif\n-extern HOST_WIDE_INT size_low_cst (const_tree);\n extern int tree_int_cst_sgn (const_tree);\n extern int tree_int_cst_sign_bit (const_tree);\n extern unsigned int tree_int_cst_min_precision (tree, bool);\n@@ -3726,9 +3719,6 @@ extern tree build_type_attribute_variant (tree, tree);\n extern tree build_decl_attribute_variant (tree, tree);\n extern tree build_type_attribute_qual_variant (tree, tree, int);\n \n-/* Remove redundant \"omp declare simd\" attributes from fndecl.  */\n-extern void omp_remove_redundant_declare_simd_attrs (tree);\n-\n /* Return 0 if the attributes for two types are incompatible, 1 if they\n    are compatible, and 2 if they are nearly compatible (which causes a\n    warning to be generated).  */\n@@ -3902,7 +3892,6 @@ extern tree expr_last (tree);\n extern tree size_in_bytes (const_tree);\n extern HOST_WIDE_INT int_size_in_bytes (const_tree);\n extern HOST_WIDE_INT max_int_size_in_bytes (const_tree);\n-extern tree tree_expr_size (const_tree);\n extern tree bit_position (const_tree);\n extern HOST_WIDE_INT int_bit_position (const_tree);\n extern tree byte_position (const_tree);\n@@ -3963,10 +3952,6 @@ extern tree nreverse (tree);\n \n extern int list_length (const_tree);\n \n-/* Returns the number of FIELD_DECLs in a type.  */\n-\n-extern int fields_length (const_tree);\n-\n /* Returns the first FIELD_DECL in a type.  */\n \n extern tree first_field (const_tree);\n@@ -4127,12 +4112,6 @@ extern tree variable_size (tree);\n \n extern tree stabilize_reference (tree);\n \n-/* Subroutine of stabilize_reference; this is called for subtrees of\n-   references.  Any expression with side-effects must be put in a SAVE_EXPR\n-   to ensure that it is only evaluated once.  */\n-\n-extern tree stabilize_reference_1 (tree);\n-\n /* Return EXP, stripped of any conversions to wider types\n    in such a way that the result of converting to type FOR_TYPE\n    is the same as if EXP were converted to FOR_TYPE.\n@@ -4315,11 +4294,6 @@ extern tree unshare_expr_without_location (tree);\n /* In stmt.c */\n \n extern void expand_label (tree);\n-extern void expand_goto (tree);\n-\n-extern rtx expand_stack_save (void);\n-extern void expand_stack_restore (tree);\n-extern void expand_return (tree);\n \n /* Compare and hash for any structure which begins with a canonical\n    pointer.  Assumes all pointers are interchangeable, which is sort\n@@ -4389,7 +4363,6 @@ extern tree fold_build3_stat_loc (location_t, enum tree_code, tree, tree, tree,\n \t\t\t\t  tree MEM_STAT_DECL);\n extern tree fold_build1_initializer_loc (location_t, enum tree_code, tree, tree);\n extern tree fold_build2_initializer_loc (location_t, enum tree_code, tree, tree, tree);\n-extern tree fold_build3_initializer_loc (location_t, enum tree_code, tree, tree, tree, tree);\n #define fold_build_call_array(T1,T2,N,T4)\\\n    fold_build_call_array_loc (UNKNOWN_LOCATION, T1, T2, N, T4)\n extern tree fold_build_call_array_loc (location_t, tree, tree, int, tree *);\n@@ -4452,7 +4425,6 @@ extern enum tree_code swap_tree_comparison (enum tree_code);\n extern bool ptr_difference_const (tree, tree, HOST_WIDE_INT *);\n extern enum tree_code invert_tree_comparison (enum tree_code, bool);\n \n-extern bool tree_expr_nonzero_p (tree);\n extern bool tree_unary_nonzero_warnv_p (enum tree_code, tree, tree, bool *);\n extern bool tree_binary_nonzero_warnv_p (enum tree_code, tree, tree, tree op1,\n                                          bool *);\n@@ -4461,11 +4433,8 @@ extern bool tree_unary_nonnegative_warnv_p (enum tree_code, tree, tree, bool *);\n extern bool tree_binary_nonnegative_warnv_p (enum tree_code, tree, tree, tree,\n                                              bool *);\n extern bool tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n-extern bool tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p);\n extern bool tree_call_nonnegative_warnv_p (tree, tree, tree, tree, bool *);\n \n-extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n-\n extern bool fold_real_zero_addition_p (const_tree, const_tree, int);\n extern tree combine_comparisons (location_t, enum tree_code, enum tree_code,\n \t\t\t\t enum tree_code, tree, tree, tree);\n@@ -4536,7 +4505,6 @@ extern tree fold_builtin_stxcpy_chk (location_t, tree, tree, tree, tree, tree, b\n \t\t\t\t     enum built_in_function);\n extern tree fold_builtin_stxncpy_chk (location_t, tree, tree, tree, tree, tree, bool,\n \t\t\t\t      enum built_in_function);\n-extern tree fold_builtin_snprintf_chk (location_t, tree, tree, enum built_in_function);\n extern bool fold_builtin_next_arg (tree, bool);\n extern enum built_in_function builtin_mathfn_code (const_tree);\n extern tree fold_builtin_call_array (location_t, tree, tree, int, tree *);\n@@ -4547,7 +4515,6 @@ extern tree build_call_expr (tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree c_strlen (tree, int);\n extern tree build_string_literal (int, const char *);\n-extern bool validate_arglist (const_tree, ...);\n extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n extern bool is_builtin_fn (tree);\n extern bool get_object_alignment_1 (tree, unsigned int *,\n@@ -4585,22 +4552,18 @@ extern int tree_floor_log2 (const_tree);\n extern unsigned int tree_ctz (const_tree);\n extern int simple_cst_equal (const_tree, const_tree);\n extern hashval_t iterative_hash_expr (const_tree, hashval_t);\n-extern hashval_t iterative_hash_exprs_commutative (const_tree,\n-                                                   const_tree, hashval_t);\n extern hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n extern hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);\n extern hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n extern int compare_tree_int (const_tree, unsigned HOST_WIDE_INT);\n extern int type_list_equal (const_tree, const_tree);\n extern int chain_member (const_tree, const_tree);\n-extern int simple_cst_list_equal (const_tree, const_tree);\n extern void dump_tree_statistics (void);\n extern void recompute_tree_invariant_for_addr_expr (tree);\n extern bool needs_to_live_in_memory (const_tree);\n extern tree reconstruct_complex_type (tree, tree);\n \n extern int real_onep (const_tree);\n-extern int real_twop (const_tree);\n extern int real_minus_onep (const_tree);\n extern void init_ttree (void);\n extern void build_common_tree_nodes (bool, bool);\n@@ -4635,10 +4598,8 @@ extern const char *get_tree_code_name (enum tree_code);\n extern tree build_addr (tree, tree);\n \n /* In function.c */\n-extern void expand_main_function (void);\n extern void expand_function_end (void);\n extern void expand_function_start (tree);\n-extern void stack_protect_prologue (void);\n extern void stack_protect_epilogue (void);\n extern void init_dummy_function_start (void);\n extern void expand_dummy_function_end (void);\n@@ -4682,7 +4643,6 @@ extern void debug_raw (vec<tree, va_gc> *ptr);\n #ifdef BUFSIZ\n extern void dump_addr (FILE*, const char *, const void *);\n extern void print_node (FILE *, const char *, tree, int);\n-extern void print_vec_tree (FILE *, const char *, vec<tree, va_gc> *, int);\n extern void print_node_brief (FILE *, const char *, const_tree, int);\n extern void indent_to (FILE *, int);\n #endif\n@@ -4707,9 +4667,6 @@ extern bool must_pass_in_stack_var_size_or_pad (enum machine_mode, const_tree);\n /* In attribs.c.  */\n \n extern const struct attribute_spec *lookup_attribute_spec (const_tree);\n-extern const struct attribute_spec *lookup_scoped_attribute_spec (const_tree,\n-\t\t\t\t\t\t\t\t  const_tree);\n-\n extern void init_attributes (void);\n \n /* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n@@ -4726,8 +4683,6 @@ extern bool cxx11_attribute_p (const_tree);\n \n extern tree get_attribute_name (const_tree);\n \n-extern tree get_attribute_namespace (const_tree);\n-\n extern void apply_tm_attr (tree, tree);\n \n /* In stor-layout.c */\n@@ -4783,12 +4738,10 @@ extern bool initializer_constant_valid_for_bitfield_p (tree);\n extern bool constructor_static_from_elts_p (const_tree);\n \n /* In stmt.c */\n-extern void expand_computed_goto (tree);\n extern bool parse_output_constraint (const char **, int, int, int,\n \t\t\t\t     bool *, bool *, bool *);\n extern bool parse_input_constraint (const char **, int, int, int, int,\n \t\t\t\t    const char * const *, bool *, bool *);\n-extern void expand_asm_stmt (gimple);\n extern tree resolve_asm_operand_names (tree, tree, tree, tree);\n #ifdef HARD_CONST\n /* Silly ifdef to avoid having all includers depend on hard-reg-set.h.  */\n@@ -4822,7 +4775,6 @@ extern tree drop_tree_overflow (tree);\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);\n-extern bool list_equal_p (const_tree, const_tree);\n \n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);\n@@ -4844,12 +4796,8 @@ extern unsigned int tree_decl_map_hash (const void *);\n #define tree_vec_map_hash tree_decl_map_hash\n #define tree_vec_map_marked_p tree_map_base_marked_p\n \n-/* In tree-vrp.c */\n-extern bool ssa_name_nonnegative_p (const_tree);\n-\n /* In tree-object-size.c.  */\n extern void init_object_sizes (void);\n-extern void fini_object_sizes (void);\n extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n \n /* In expr.c.  */\n@@ -4859,9 +4807,6 @@ extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n    succeed.  */\n extern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n \n-/* Is it an ADDR_EXPR of a DECL that's not in memory?  */\n-extern bool addr_expr_of_non_mem_decl_p (tree);\n-\n extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);\n extern tree build_personality_function (const char *);\n \n@@ -4874,12 +4819,6 @@ extern bool is_tm_ending_fndecl (tree);\n extern void record_tm_replacement (tree, tree);\n extern void tm_malloc_replacement (tree);\n \n-static inline bool\n-is_tm_safe_or_pure (const_tree x)\n-{\n-  return is_tm_safe (x) || is_tm_pure (x);\n-}\n-\n /* In tree-inline.c.  */\n \n void init_inline_once (void);\n@@ -4952,12 +4891,6 @@ more_call_expr_args_p (const call_expr_arg_iterator *iter)\n   return (iter->i < iter->n);\n }\n \n-static inline bool\n-more_const_call_expr_args_p (const const_call_expr_arg_iterator *iter)\n-{\n-  return (iter->i < iter->n);\n-}\n-\n /* Iterate through each argument ARG of CALL_EXPR CALL, using variable ITER\n    (of type call_expr_arg_iterator) to hold the iteration state.  */\n #define FOR_EACH_CALL_EXPR_ARG(arg, iter, call)\t\t\t\\\n@@ -4975,9 +4908,6 @@ is_lang_specific (tree t)\n   return TREE_CODE (t) == LANG_TYPE || TREE_CODE (t) >= NUM_TREE_CODES;\n }\n \n-/* In vtable-verify.c.  */\n-extern void save_vtable_map_decl (tree);\n-\n /* Valid builtin number.  */\n #define BUILTIN_VALID_P(FNCODE) \\\n   (IN_RANGE ((int)FNCODE, ((int)BUILT_IN_NONE) + 1, ((int) END_BUILTINS) - 1))"}]}