{"sha": "2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkMDYyYTBiZTNlMmM2ZTdiZDUwZDI1ZDllZGUzMzZmYWQ3YmUzOA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-10-01T06:55:15Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T21:13:21Z"}, "message": "Improved parsing of MatchExpr (and AST structure)\n\nFixed compilation errors\n\nFixed accidental break out of loop when expr_with_block when parsing match expr", "tree": {"sha": "3eb122d4ae25035a067ddaf78576541a75fdf9b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3eb122d4ae25035a067ddaf78576541a75fdf9b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cfd93746242dc6e73f4fa71520bb361a2d6de4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cfd93746242dc6e73f4fa71520bb361a2d6de4a"}], "stats": {"total": 344, "additions": 231, "deletions": 113}, "files": [{"sha": "28a4af81bd2f0f826af6b5f7c9b9cdff7abdda3a", "filename": "gcc/rust/analysis/rust-name-resolution.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-name-resolution.cc?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -361,12 +361,12 @@ void\n NameResolution::visit (AST::IfLetExprConseqIfLet &expr)\n {}\n // void NameResolution::visit(MatchCase& match_case) {}\n-void\n+/*void\n NameResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}\n-void\n+{}*/\n+/*void\n NameResolution::visit (AST::MatchCaseExpr &match_case)\n-{}\n+{}*/\n void\n NameResolution::visit (AST::MatchExpr &expr)\n {}"}, {"sha": "b3bc78002c054522474d1ba80f87df3ffd80dc7a", "filename": "gcc/rust/analysis/rust-name-resolution.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-name-resolution.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -112,8 +112,8 @@ class NameResolution : public Resolution\n   void visit (AST::IfLetExprConseqIf &expr) override;\n   void visit (AST::IfLetExprConseqIfLet &expr) override;\n   //  void visit(MatchCase& match_case) override;\n-  void visit (AST::MatchCaseBlockExpr &match_case) override;\n-  void visit (AST::MatchCaseExpr &match_case) override;\n+  // void visit (AST::MatchCaseBlockExpr &match_case) override;\n+  // void visit (AST::MatchCaseExpr &match_case) override;\n   void visit (AST::MatchExpr &expr) override;\n   void visit (AST::AwaitExpr &expr) override;\n   void visit (AST::AsyncBlockExpr &expr) override;"}, {"sha": "402ac3284c1e3e93ff13d9cb87e74fcc4e94cf45", "filename": "gcc/rust/analysis/rust-scan.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.cc?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -297,12 +297,12 @@ void\n TopLevelScan::visit (AST::IfLetExprConseqIfLet &expr)\n {}\n // void TopLevelScan::visit(MatchCase& match_case) {}\n-void\n+/*void\n TopLevelScan::visit (AST::MatchCaseBlockExpr &match_case)\n-{}\n-void\n+{}*/\n+/*void\n TopLevelScan::visit (AST::MatchCaseExpr &match_case)\n-{}\n+{}*/\n void\n TopLevelScan::visit (AST::MatchExpr &expr)\n {}"}, {"sha": "77beeca86a03e838094af284798475834c7254ce", "filename": "gcc/rust/analysis/rust-scan.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-scan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-scan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -117,8 +117,8 @@ class TopLevelScan : public AST::ASTVisitor\n   virtual void visit (AST::IfLetExprConseqIf &expr);\n   virtual void visit (AST::IfLetExprConseqIfLet &expr);\n   // virtual void visit(MatchCase& match_case);\n-  virtual void visit (AST::MatchCaseBlockExpr &match_case);\n-  virtual void visit (AST::MatchCaseExpr &match_case);\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n+  // virtual void visit (AST::MatchCaseExpr &match_case);\n   virtual void visit (AST::MatchExpr &expr);\n   virtual void visit (AST::AwaitExpr &expr);\n   virtual void visit (AST::AsyncBlockExpr &expr);"}, {"sha": "3503a8352e7bc8ac9a31816bcec8bb4bc95ef2b3", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -704,12 +704,12 @@ void\n TypeResolution::visit (AST::IfLetExprConseqIfLet &expr)\n {}\n // void TypeResolution::visit(MatchCase& match_case) {}\n-void\n+/*void\n TypeResolution::visit (AST::MatchCaseBlockExpr &match_case)\n-{}\n-void\n+{}*/\n+/*void\n TypeResolution::visit (AST::MatchCaseExpr &match_case)\n-{}\n+{}*/\n void\n TypeResolution::visit (AST::MatchExpr &expr)\n {}"}, {"sha": "af4594ea09b5a10e97e79c5ea6f7f1b375a7fb46", "filename": "gcc/rust/analysis/rust-type-resolution.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -188,8 +188,8 @@ class TypeResolution : public Resolution\n   void visit (AST::IfLetExprConseqIf &expr) override;\n   void visit (AST::IfLetExprConseqIfLet &expr) override;\n   //  void visit(MatchCase& match_case) override;\n-  void visit (AST::MatchCaseBlockExpr &match_case) override;\n-  void visit (AST::MatchCaseExpr &match_case) override;\n+  // void visit (AST::MatchCaseBlockExpr &match_case) override;\n+  // void visit (AST::MatchCaseExpr &match_case) override;\n   void visit (AST::MatchExpr &expr) override;\n   void visit (AST::AwaitExpr &expr) override;\n   void visit (AST::AsyncBlockExpr &expr) override;"}, {"sha": "9b604a5dde7aff6695ccaa0d5f6ee7455a3cc1af", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -134,9 +134,10 @@ namespace Rust {\n         class IfLetExprConseqIf;\n         class IfLetExprConseqIfLet;\n         struct MatchArm;\n-        class MatchCase;\n-        class MatchCaseBlockExpr;\n-        class MatchCaseExpr;\n+        // class MatchCase;\n+        // class MatchCaseBlockExpr;\n+        // class MatchCaseExpr;\n+        struct MatchCase;\n         class MatchExpr;\n         class AwaitExpr;\n         class AsyncBlockExpr;"}, {"sha": "33d17366dbefd2b070e6b720c20f58df3374c62d", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -2391,11 +2391,12 @@ MatchCase::as_string () const\n   std::string str (\"MatchCase: (match arm) \");\n \n   str += \"\\n Match arm matcher: \\n\" + arm.as_string ();\n+  str += \"\\n Expr: \" + expr->as_string ();\n \n   return str;\n }\n \n-std::string\n+/*std::string\n MatchCaseBlockExpr::as_string () const\n {\n   std::string str = MatchCase::as_string ();\n@@ -2413,7 +2414,7 @@ MatchCaseExpr::as_string () const\n   str += \"\\n Expr: \" + expr->as_string ();\n \n   return str;\n-}\n+}*/\n \n std::string\n MatchExpr::as_string () const\n@@ -2447,9 +2448,7 @@ MatchExpr::as_string () const\n   else\n     {\n       for (const auto &arm : match_arms)\n-\t{\n-\t  str += \"\\n  \" + arm->as_string ();\n-\t}\n+\t  str += \"\\n  \" + arm.as_string ();\n     }\n \n   return str;\n@@ -5759,7 +5758,7 @@ IfLetExprConseqIfLet::accept_vis (ASTVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n+/*void\n MatchCaseBlockExpr::accept_vis (ASTVisitor &vis)\n {\n   vis.visit (*this);\n@@ -5769,7 +5768,7 @@ void\n MatchCaseExpr::accept_vis (ASTVisitor &vis)\n {\n   vis.visit (*this);\n-}\n+}*/\n \n void\n MatchExpr::accept_vis (ASTVisitor &vis)"}, {"sha": "b48e8f31357ec76624ed191c70a86bc1e5061a2a", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -113,8 +113,8 @@ class ASTVisitor\n   virtual void visit (IfLetExprConseqIf &expr) = 0;\n   virtual void visit (IfLetExprConseqIfLet &expr) = 0;\n   // virtual void visit(MatchCase& match_case) = 0;\n-  virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n-  virtual void visit (MatchCaseExpr &match_case) = 0;\n+  // virtual void visit (MatchCaseBlockExpr &match_case) = 0;\n+  // virtual void visit (MatchCaseExpr &match_case) = 0;\n   virtual void visit (MatchExpr &expr) = 0;\n   virtual void visit (AwaitExpr &expr) = 0;\n   virtual void visit (AsyncBlockExpr &expr) = 0;"}, {"sha": "f9fbc36e508c92acf2061f3c746fbb9d23d32894", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -2,11 +2,6 @@\n #define RUST_AST_BASE_H\n // Base for AST used in gccrs, basically required by all specific ast things\n \n-// GCC imports\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\" // order: config, system, coretypes\n-\n #include \"rust-system.h\"\n \n // STL imports\n@@ -847,6 +842,9 @@ class Expr\n    * methods. */\n   virtual Location get_locus_slow () const { return Location (); }\n \n+  // HACK: strictly not needed, but faster than full downcast clone\n+  virtual bool is_expr_without_block () const = 0;\n+\n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n protected:\n@@ -887,6 +885,8 @@ class ExprWithoutBlock : public Expr\n     return clone_expr_without_block_impl ();\n   }\n \n+  bool is_expr_without_block () const final override { return true; };\n+\n public:\n   // Unique pointer custom clone function\n   std::unique_ptr<ExprWithoutBlock> clone_expr_without_block () const"}, {"sha": "b989006f0bd0a0dd173edeb4f31563aeded84485", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 87, "deletions": 44, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -28,6 +28,8 @@ class ExprWithBlock : public Expr\n     return clone_expr_with_block_impl ();\n   }\n \n+  bool is_expr_without_block () const final override { return false; };\n+\n public:\n   // Unique pointer custom clone function\n   std::unique_ptr<ExprWithBlock> clone_expr_with_block () const\n@@ -889,12 +891,12 @@ class ArrayElems\n // Value array elements\n class ArrayElemsValues : public ArrayElems\n {\n-  std::vector<std::unique_ptr<Expr>> values;\n+  std::vector<std::unique_ptr<Expr> > values;\n \n   // TODO: should this store location data?\n \n public:\n-  ArrayElemsValues (std::vector<std::unique_ptr<Expr>> elems)\n+  ArrayElemsValues (std::vector<std::unique_ptr<Expr> > elems)\n     : values (std::move (elems))\n   {}\n \n@@ -1117,7 +1119,7 @@ class TupleExpr : public ExprWithoutBlock\n {\n   std::vector<Attribute> inner_attrs;\n \n-  std::vector<std::unique_ptr<Expr>> tuple_elems;\n+  std::vector<std::unique_ptr<Expr> > tuple_elems;\n   // replaces (inlined version of) TupleElements\n \n   Location locus;\n@@ -1127,7 +1129,7 @@ class TupleExpr : public ExprWithoutBlock\n \n   std::vector<Attribute> get_inner_attrs () const { return inner_attrs; }\n \n-  TupleExpr (std::vector<std::unique_ptr<Expr>> tuple_elements,\n+  TupleExpr (std::vector<std::unique_ptr<Expr> > tuple_elements,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (outer_attribs)),\n@@ -1493,7 +1495,7 @@ class StructExprStructFields : public StructExprStruct\n {\n public:\n   // std::vector<StructExprField> fields;\n-  std::vector<std::unique_ptr<StructExprField>> fields;\n+  std::vector<std::unique_ptr<StructExprField> > fields;\n \n   // bool has_struct_base;\n   StructBase struct_base;\n@@ -1513,7 +1515,7 @@ class StructExprStructFields : public StructExprStruct\n   // Constructor for StructExprStructFields when no struct base is used\n   StructExprStructFields (\n     PathInExpression struct_path,\n-    std::vector<std::unique_ptr<StructExprField>> expr_fields, Location locus,\n+    std::vector<std::unique_ptr<StructExprField> > expr_fields, Location locus,\n     StructBase base_struct = StructBase::error (),\n     std::vector<Attribute> inner_attribs = std::vector<Attribute> (),\n     std::vector<Attribute> outer_attribs = std::vector<Attribute> ())\n@@ -1608,7 +1610,7 @@ class StructExprStructBase : public StructExprStruct\n class StructExprTuple : public StructExpr\n {\n   std::vector<Attribute> inner_attrs;\n-  std::vector<std::unique_ptr<Expr>> exprs;\n+  std::vector<std::unique_ptr<Expr> > exprs;\n \n   Location locus;\n \n@@ -1622,7 +1624,7 @@ class StructExprTuple : public StructExpr\n   }*/\n \n   StructExprTuple (PathInExpression struct_path,\n-\t\t   std::vector<std::unique_ptr<Expr>> tuple_exprs,\n+\t\t   std::vector<std::unique_ptr<Expr> > tuple_exprs,\n \t\t   std::vector<Attribute> inner_attribs,\n \t\t   std::vector<Attribute> outer_attribs, Location locus)\n     : StructExpr (std::move (struct_path), std::move (outer_attribs)),\n@@ -1867,7 +1869,7 @@ class EnumExprFieldIndexValue : public EnumExprFieldWithVal\n class EnumExprStruct : public EnumVariantExpr\n {\n   // std::vector<EnumExprField> fields;\n-  std::vector<std::unique_ptr<EnumExprField>> fields;\n+  std::vector<std::unique_ptr<EnumExprField> > fields;\n \n   Location locus;\n \n@@ -1879,7 +1881,7 @@ class EnumExprStruct : public EnumVariantExpr\n   }*/\n \n   EnumExprStruct (PathInExpression enum_variant_path,\n-\t\t  std::vector<std::unique_ptr<EnumExprField>> variant_fields,\n+\t\t  std::vector<std::unique_ptr<EnumExprField> > variant_fields,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n     : EnumVariantExpr (std::move (enum_variant_path),\n \t\t       std::move (outer_attribs)),\n@@ -1936,7 +1938,7 @@ class EnumExprStruct : public EnumVariantExpr\n // Tuple-like syntax enum variant instance creation AST node\n class EnumExprTuple : public EnumVariantExpr\n {\n-  std::vector<std::unique_ptr<Expr>> values;\n+  std::vector<std::unique_ptr<Expr> > values;\n \n   Location locus;\n \n@@ -1948,7 +1950,7 @@ class EnumExprTuple : public EnumVariantExpr\n   }*/\n \n   EnumExprTuple (PathInExpression enum_variant_path,\n-\t\t std::vector<std::unique_ptr<Expr>> variant_values,\n+\t\t std::vector<std::unique_ptr<Expr> > variant_values,\n \t\t std::vector<Attribute> outer_attribs, Location locus)\n     : EnumVariantExpr (std::move (enum_variant_path),\n \t\t       std::move (outer_attribs)),\n@@ -2051,7 +2053,7 @@ class CallExpr : public ExprWithoutBlock\n public:\n   std::unique_ptr<Expr> function;\n   // inlined form of CallParams\n-  std::vector<std::unique_ptr<Expr>> params;\n+  std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n \n@@ -2064,7 +2066,7 @@ class CallExpr : public ExprWithoutBlock\n   }*/\n \n   CallExpr (std::unique_ptr<Expr> function_expr,\n-\t    std::vector<std::unique_ptr<Expr>> function_params,\n+\t    std::vector<std::unique_ptr<Expr> > function_params,\n \t    std::vector<Attribute> outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (outer_attribs)),\n       function (std::move (function_expr)),\n@@ -2128,7 +2130,7 @@ class MethodCallExpr : public ExprWithoutBlock\n   std::unique_ptr<Expr> receiver;\n   PathExprSegment method_name;\n   // inlined form of CallParams\n-  std::vector<std::unique_ptr<Expr>> params;\n+  std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n \n@@ -2141,7 +2143,7 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   MethodCallExpr (std::unique_ptr<Expr> call_receiver,\n \t\t  PathExprSegment method_path,\n-\t\t  std::vector<std::unique_ptr<Expr>> method_params,\n+\t\t  std::vector<std::unique_ptr<Expr> > method_params,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n     : ExprWithoutBlock (std::move (outer_attribs)),\n       receiver (std::move (call_receiver)),\n@@ -2407,7 +2409,7 @@ class BlockExpr : public ExprWithBlock\n   std::vector<Attribute> inner_attrs;\n \n   // bool has_statements;\n-  std::vector<std::unique_ptr<Stmt>> statements;\n+  std::vector<std::unique_ptr<Stmt> > statements;\n   // bool has_expr;\n   std::unique_ptr<ExprWithoutBlock> expr; // inlined from Statements\n \n@@ -2421,7 +2423,7 @@ class BlockExpr : public ExprWithBlock\n   // Returns whether the block contains an expression\n   bool has_expr () const { return expr != nullptr; }\n \n-  BlockExpr (std::vector<std::unique_ptr<Stmt>> block_statements,\n+  BlockExpr (std::vector<std::unique_ptr<Stmt> > block_statements,\n \t     std::unique_ptr<ExprWithoutBlock> block_expr,\n \t     std::vector<Attribute> inner_attribs,\n \t     std::vector<Attribute> outer_attribs, Location locus)\n@@ -3278,14 +3280,14 @@ class WhileLoopExpr : public BaseLoopExpr\n class WhileLetLoopExpr : public BaseLoopExpr\n {\n   // MatchArmPatterns patterns;\n-  std::vector<std::unique_ptr<Pattern>> match_arm_patterns; // inlined\n+  std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n   std::unique_ptr<Expr> condition;\n \n public:\n   std::string as_string () const override;\n \n   // Constructor with a loop label\n-  WhileLetLoopExpr (std::vector<std::unique_ptr<Pattern>> match_arm_patterns,\n+  WhileLetLoopExpr (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t\t    std::unique_ptr<Expr> condition,\n \t\t    std::unique_ptr<BlockExpr> loop_block, Location locus,\n \t\t    LoopLabel loop_label = LoopLabel::error (),\n@@ -3622,7 +3624,7 @@ class IfExprConseqIf : public IfExpr\n class IfLetExpr : public ExprWithBlock\n {\n   // MatchArmPatterns patterns;\n-  std::vector<std::unique_ptr<Pattern>> match_arm_patterns; // inlined\n+  std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n   std::unique_ptr<Expr> value;\n   std::unique_ptr<BlockExpr> if_block;\n \n@@ -3631,7 +3633,7 @@ class IfLetExpr : public ExprWithBlock\n public:\n   std::string as_string () const override;\n \n-  IfLetExpr (std::vector<std::unique_ptr<Pattern>> match_arm_patterns,\n+  IfLetExpr (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n \t     Location locus)\n     : ExprWithBlock (std::vector<Attribute> ()),\n@@ -3774,7 +3776,7 @@ class IfLetExprConseqElse : public IfLetExpr\n   std::string as_string () const override;\n \n   IfLetExprConseqElse (\n-    std::vector<std::unique_ptr<Pattern>> match_arm_patterns,\n+    std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n     std::unique_ptr<BlockExpr> else_block, Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n@@ -3839,7 +3841,7 @@ class IfLetExprConseqIf : public IfLetExpr\n public:\n   std::string as_string () const override;\n \n-  IfLetExprConseqIf (std::vector<std::unique_ptr<Pattern>> match_arm_patterns,\n+  IfLetExprConseqIf (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t\t     std::unique_ptr<Expr> value,\n \t\t     std::unique_ptr<BlockExpr> if_block,\n \t\t     std::unique_ptr<IfExpr> if_expr, Location locus)\n@@ -3905,7 +3907,7 @@ class IfLetExprConseqIfLet : public IfLetExpr\n   std::string as_string () const override;\n \n   IfLetExprConseqIfLet (\n-    std::vector<std::unique_ptr<Pattern>> match_arm_patterns,\n+    std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n     std::unique_ptr<Expr> value, std::unique_ptr<BlockExpr> if_block,\n     std::unique_ptr<IfLetExpr> if_let_expr, Location locus)\n     : IfLetExpr (std::move (match_arm_patterns), std::move (value),\n@@ -3966,7 +3968,7 @@ struct MatchArm\n private:\n   std::vector<Attribute> outer_attrs;\n   // MatchArmPatterns patterns;\n-  std::vector<std::unique_ptr<Pattern>> match_arm_patterns; // inlined\n+  std::vector<std::unique_ptr<Pattern> > match_arm_patterns; // inlined\n \n   // bool has_match_arm_guard;\n   // inlined from MatchArmGuard\n@@ -3979,7 +3981,7 @@ struct MatchArm\n   bool has_match_arm_guard () const { return guard_expr != nullptr; }\n \n   // Constructor for match arm with a guard expression\n-  MatchArm (std::vector<std::unique_ptr<Pattern>> match_arm_patterns,\n+  MatchArm (std::vector<std::unique_ptr<Pattern> > match_arm_patterns,\n \t    std::unique_ptr<Expr> guard_expr = nullptr,\n \t    std::vector<Attribute> outer_attrs = std::vector<Attribute> ())\n     : outer_attrs (std::move (outer_attrs)),\n@@ -3988,9 +3990,7 @@ struct MatchArm\n   {}\n \n   // Copy constructor with clone\n-  MatchArm (MatchArm const &other)\n-    : /*match_arm_patterns(other.match_arm_patterns),*/ outer_attrs (\n-      other.outer_attrs)\n+  MatchArm (MatchArm const &other) : outer_attrs (other.outer_attrs)\n   {\n     // guard to protect from null pointer dereference\n     if (other.guard_expr != nullptr)\n@@ -4006,9 +4006,10 @@ struct MatchArm\n   // Overload assignment operator to clone\n   MatchArm &operator= (MatchArm const &other)\n   {\n-    // match_arm_patterns = other.match_arm_patterns;\n     outer_attrs = other.outer_attrs;\n-    guard_expr = other.guard_expr->clone_expr ();\n+\n+    if (other.guard_expr != nullptr)\n+      guard_expr = other.guard_expr->clone_expr ();\n \n     match_arm_patterns.reserve (other.match_arm_patterns.size ());\n     for (const auto &e : other.match_arm_patterns)\n@@ -4027,12 +4028,13 @@ struct MatchArm\n   // Creates a match arm in an error state.\n   static MatchArm create_error ()\n   {\n-    return MatchArm (std::vector<std::unique_ptr<Pattern>> ());\n+    return MatchArm (std::vector<std::unique_ptr<Pattern> > ());\n   }\n \n   std::string as_string () const;\n };\n \n+/*\n // Base \"match case\" for a match expression - abstract\n class MatchCase\n {\n@@ -4059,7 +4061,45 @@ class MatchCase\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n };\n+*/\n+\n+/* A \"match case\" - a correlated match arm and resulting expression. Not\n+ * abstract. */\n+struct MatchCase\n+{\n+private:\n+  MatchArm arm;\n+  std::unique_ptr<Expr> expr;\n+\n+  /* TODO: does whether trailing comma exists need to be stored? currently\n+   * assuming it is only syntactical and has no effect on meaning. */\n+\n+public:\n+  MatchCase (MatchArm arm, std::unique_ptr<Expr> expr)\n+    : arm (std::move (arm)), expr (std::move (expr))\n+  {}\n+\n+  MatchCase (const MatchCase &other)\n+    : arm (other.arm), expr (other.expr->clone_expr ())\n+  {}\n \n+  MatchCase &operator= (const MatchCase &other)\n+  {\n+    arm = other.arm;\n+    expr = other.expr->clone_expr ();\n+\n+    return *this;\n+  }\n+\n+  MatchCase (MatchCase &&other) = default;\n+  MatchCase &operator= (MatchCase &&other) = default;\n+\n+  ~MatchCase () = default;\n+\n+  std::string as_string () const;\n+};\n+\n+#if 0\n // Block expression match case\n class MatchCaseBlockExpr : public MatchCase\n {\n@@ -4147,6 +4187,7 @@ class MatchCaseExpr : public MatchCase\n     return new MatchCaseExpr (*this);\n   }\n };\n+#endif\n \n // Match expression AST node\n class MatchExpr : public ExprWithBlock\n@@ -4156,7 +4197,9 @@ class MatchExpr : public ExprWithBlock\n \n   // bool has_match_arms;\n   // MatchArms match_arms;\n-  std::vector<std::unique_ptr<MatchCase>> match_arms; // inlined from MatchArms\n+  // std::vector<std::unique_ptr<MatchCase> > match_arms; // inlined from\n+  // MatchArms\n+  std::vector<MatchCase> match_arms;\n \n   Location locus;\n \n@@ -4167,7 +4210,8 @@ class MatchExpr : public ExprWithBlock\n   bool has_match_arms () const { return !match_arms.empty (); }\n \n   MatchExpr (std::unique_ptr<Expr> branch_value,\n-\t     std::vector<std::unique_ptr<MatchCase>> match_arms,\n+\t     // std::vector<std::unique_ptr<MatchCase> > match_arms,\n+\t     std::vector<MatchCase> match_arms,\n \t     std::vector<Attribute> inner_attrs,\n \t     std::vector<Attribute> outer_attrs, Location locus)\n     : ExprWithBlock (std::move (outer_attrs)),\n@@ -4178,29 +4222,28 @@ class MatchExpr : public ExprWithBlock\n \n   // Copy constructor requires clone due to unique_ptr\n   MatchExpr (MatchExpr const &other)\n-    : ExprWithBlock (other),\n-      branch_value (\n-\tother.branch_value->clone_expr ()), /*match_arms(other.match_arms),*/\n-      inner_attrs (other.inner_attrs), locus (other.locus)\n+    : ExprWithBlock (other), branch_value (other.branch_value->clone_expr ()),\n+      inner_attrs (other.inner_attrs), match_arms (other.match_arms),\n+      locus (other.locus)\n   {\n-    match_arms.reserve (other.match_arms.size ());\n+    /*match_arms.reserve (other.match_arms.size ());\n     for (const auto &e : other.match_arms)\n-      match_arms.push_back (e->clone_match_case ());\n+      match_arms.push_back (e->clone_match_case ());*/\n   }\n \n   // Overloaded assignment operator to clone due to unique_ptr\n   MatchExpr &operator= (MatchExpr const &other)\n   {\n     ExprWithBlock::operator= (other);\n     branch_value = other.branch_value->clone_expr ();\n-    // match_arms = other.match_arms;\n     inner_attrs = other.inner_attrs;\n+    match_arms = other.match_arms;\n     // outer_attrs = other.outer_attrs;\n     locus = other.locus;\n \n-    match_arms.reserve (other.match_arms.size ());\n+    /*match_arms.reserve (other.match_arms.size ());\n     for (const auto &e : other.match_arms)\n-      match_arms.push_back (e->clone_match_case ());\n+      match_arms.push_back (e->clone_match_case ());*/\n \n     return *this;\n   }"}, {"sha": "6374a45337f319d78ed4c6ca33ae0fdac389a24d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -889,12 +889,12 @@ Compilation::visit (AST::IfLetExprConseqIfLet &expr)\n }\n \n // void Compilation::visit(MatchCase& match_case) {}\n-void\n+/*void\n Compilation::visit (AST::MatchCaseBlockExpr &match_case)\n-{}\n-void\n+{}*/\n+/*void\n Compilation::visit (AST::MatchCaseExpr &match_case)\n-{}\n+{}*/\n void\n Compilation::visit (AST::MatchExpr &expr)\n {}"}, {"sha": "ba034839f2797550e7acd6ce38123219952aaeee", "filename": "gcc/rust/backend/rust-compile.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fbackend%2Frust-compile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fbackend%2Frust-compile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -116,8 +116,8 @@ class Compilation : public AST::ASTVisitor\n   virtual void visit (AST::IfLetExprConseqIf &expr);\n   virtual void visit (AST::IfLetExprConseqIfLet &expr);\n   // virtual void visit(MatchCase& match_case);\n-  virtual void visit (AST::MatchCaseBlockExpr &match_case);\n-  virtual void visit (AST::MatchCaseExpr &match_case);\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n+  // virtual void visit (AST::MatchCaseExpr &match_case);\n   virtual void visit (AST::MatchExpr &expr);\n   virtual void visit (AST::AwaitExpr &expr);\n   virtual void visit (AST::AsyncBlockExpr &expr);"}, {"sha": "468312e97fdf1ee8fdf42df6315fe8e512b43389", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 100, "deletions": 28, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -3895,7 +3895,8 @@ Parser<ManagedTokenSource>::parse_struct (\n \tlexer.skip_token ();\n \n \t// parse struct fields, if any\n-\tstd::vector<AST::StructField> struct_fields = parse_struct_fields ();\n+\tstd::vector<AST::StructField> struct_fields\n+\t  = parse_struct_fields ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n \tif (!skip_token (RIGHT_CURLY))\n \t  {\n@@ -3938,42 +3939,69 @@ Parser<ManagedTokenSource>::parse_struct_fields ()\n \n   // Return empty field list if no field there\n   if (initial_field.is_error ())\n-    {\n-      return fields;\n-    }\n+    return fields;\n \n   fields.push_back (std::move (initial_field));\n \n-  // maybe think of a better control structure here - do-while with an initial\n-  // error state? basically, loop through field list until can't find any more\n-  // params\n-  while (true)\n+  while (lexer.peek_token ()->get_id () == COMMA)\n     {\n-      if (lexer.peek_token ()->get_id () != COMMA)\n+      lexer.skip_token ();\n+\n+      AST::StructField field = parse_struct_field ();\n+\n+      if (field.is_error ())\n \t{\n+\t  // would occur with trailing comma, so allowed\n \t  break;\n \t}\n \n-      // skip comma if applies\n+      fields.push_back (std::move (field));\n+    }\n+\n+  fields.shrink_to_fit ();\n+  return fields;\n+  // TODO: template if possible (parse_non_ptr_seq)\n+}\n+\n+// Parses struct fields in struct declarations.\n+template <typename ManagedTokenSource>\n+template <typename EndTokenPred>\n+std::vector<AST::StructField>\n+Parser<ManagedTokenSource>::parse_struct_fields (EndTokenPred is_end_tok)\n+{\n+  std::vector<AST::StructField> fields;\n+\n+  AST::StructField initial_field = parse_struct_field ();\n+\n+  // Return empty field list if no field there\n+  if (initial_field.is_error ())\n+    return fields;\n+\n+  fields.push_back (std::move (initial_field));\n+\n+  while (lexer.peek_token ()->get_id () == COMMA)\n+    {\n       lexer.skip_token ();\n \n-      AST::StructField field = parse_struct_field ();\n+      if (is_end_tok (lexer.peek_token ()->get_id ()))\n+\tbreak;\n \n-      if (!field.is_error ())\n-\t{\n-\t  fields.push_back (std::move (field));\n-\t}\n-      else\n+      AST::StructField field = parse_struct_field ();\n+      if (field.is_error ())\n \t{\n-\t  // this would occur with a trailing comma, which is allowed\n-\t  break;\n+\t  /* TODO: should every field be ditched just because one couldn't be\n+\t   * parsed? */\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse struct field in struct fields\");\n+\t  return {};\n \t}\n+\n+      fields.push_back (std::move (field));\n     }\n \n+  fields.shrink_to_fit ();\n   return fields;\n-\n-  // TODO: this shares basically all code with function params and tuple fields\n-  // - templates?\n+  // TODO: template if possible (parse_non_ptr_seq)\n }\n \n // Parses a single struct field (in a struct definition). Does not parse commas.\n@@ -4257,7 +4285,8 @@ Parser<ManagedTokenSource>::parse_enum_item ()\n \t// struct enum item\n \tlexer.skip_token ();\n \n-\tstd::vector<AST::StructField> struct_fields = parse_struct_fields ();\n+\tstd::vector<AST::StructField> struct_fields\n+\t  = parse_struct_fields ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n \tif (!skip_token (RIGHT_CURLY))\n \t  {\n@@ -4326,7 +4355,8 @@ Parser<ManagedTokenSource>::parse_union (\n \n   /* parse union inner items as \"struct fields\" because hey, syntax reuse. Spec\n    * said so. */\n-  std::vector<AST::StructField> union_fields = parse_struct_fields ();\n+  std::vector<AST::StructField> union_fields\n+    = parse_struct_fields ([] (TokenId id) { return id == RIGHT_CURLY; });\n \n   if (!skip_token (RIGHT_CURLY))\n     {\n@@ -8017,18 +8047,20 @@ Parser<ManagedTokenSource>::parse_match_expr (\n   std::vector<AST::Attribute> inner_attrs = parse_inner_attributes ();\n \n   // parse match arms (if they exist)\n-  std::vector<std::unique_ptr<AST::MatchCase> > match_arms;\n+  // std::vector<std::unique_ptr<AST::MatchCase> > match_arms;\n+  std::vector<AST::MatchCase> match_arms;\n \n-  // FIXME: absolute worst control structure ever\n   // parse match cases\n-  while (true)\n+  while (lexer.peek_token ()->get_id () != RIGHT_CURLY)\n     {\n       // parse match arm itself, which is required\n       AST::MatchArm arm = parse_match_arm ();\n       if (arm.is_error ())\n \t{\n-\t  // not necessarily an error\n-\t  break;\n+\t  // TODO is this worth throwing everything away?\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse match arm in match arms\");\n+\t  return nullptr;\n \t}\n \n       if (!skip_token (MATCH_ARROW))\n@@ -8038,6 +8070,45 @@ Parser<ManagedTokenSource>::parse_match_expr (\n \t  return nullptr;\n \t}\n \n+      std::unique_ptr<AST::Expr> expr = parse_expr ();\n+      if (expr == nullptr)\n+\t{\n+\t  rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t \"failed to parse expr in match arm in match expr\");\n+\t  // skip somewhere?\n+\t  return nullptr;\n+\t}\n+      bool is_expr_without_block = expr->is_expr_without_block ();\n+\n+      // construct match case expr and add to cases\n+      match_arms.push_back (AST::MatchCase (std::move (arm), std::move (expr)));\n+\n+      // handle comma presence\n+      if (lexer.peek_token ()->get_id () != COMMA)\n+\t{\n+\t  if (!is_expr_without_block)\n+\t    {\n+\t      // allowed even if not final case\n+\t      continue;\n+\t    }\n+\t  else if (is_expr_without_block\n+\t\t   && lexer.peek_token ()->get_id () != RIGHT_CURLY)\n+\t    {\n+\t      // not allowed if not final case\n+\t      rust_error_at (lexer.peek_token ()->get_locus (),\n+\t\t\t     \"exprwithoutblock requires comma after match case \"\n+\t\t\t     \"expression in match arm (if not final case)\");\n+\t      return nullptr;\n+\t    }\n+\t  else\n+\t    {\n+\t      // otherwise, must be final case, so fine\n+\t      break;\n+\t    }\n+\t}\n+      lexer.skip_token ();\n+\n+#if 0\n       // branch on next token - if '{', block expr, otherwise just expr\n       if (lexer.peek_token ()->get_id () == LEFT_CURLY)\n \t{\n@@ -8089,6 +8160,7 @@ Parser<ManagedTokenSource>::parse_match_expr (\n \t    }\n \t  lexer.skip_token ();\n \t}\n+#endif\n     }\n \n   if (!skip_token (RIGHT_CURLY))"}, {"sha": "e2f3a78d84cb4e54464b5fc9ac886ccd1d63d20c", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ed062a0be3e2c6e7bd50d25d9ede336fad7be38/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=2ed062a0be3e2c6e7bd50d25d9ede336fad7be38", "patch": "@@ -189,6 +189,8 @@ template <typename ManagedTokenSource> class Parser\n   std::unique_ptr<AST::Struct>\n   parse_struct (AST::Visibility vis, std::vector<AST::Attribute> outer_attrs);\n   std::vector<AST::StructField> parse_struct_fields ();\n+  template <typename EndTokenPred>\n+  std::vector<AST::StructField> parse_struct_fields (EndTokenPred is_end_token);\n   AST::StructField parse_struct_field ();\n   std::vector<AST::TupleField> parse_tuple_fields ();\n   AST::TupleField parse_tuple_field ();\n@@ -528,6 +530,7 @@ template <typename ManagedTokenSource> class Parser\n \t\t\t       = std::vector<AST::Attribute> (),\n \t\t\t       bool pratt_parse = false);\n   std::unique_ptr<AST::StructExprField> parse_struct_expr_field ();\n+  bool will_be_expr_with_block ();\n \n   // Type-related\n   std::unique_ptr<AST::Type> parse_type ();"}]}