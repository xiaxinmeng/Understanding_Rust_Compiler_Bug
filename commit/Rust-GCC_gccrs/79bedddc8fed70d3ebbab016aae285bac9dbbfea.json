{"sha": "79bedddc8fed70d3ebbab016aae285bac9dbbfea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzliZWRkZGM4ZmVkNzBkM2ViYmFiMDE2YWFlMjg1YmFjOWRiYmZlYQ==", "commit": {"author": {"name": "Silvius Rus", "email": "rus@google.com", "date": "2007-05-11T16:20:08Z"}, "committer": {"name": "Silvius Rus", "email": "rus@gcc.gnu.org", "date": "2007-05-11T16:20:08Z"}, "message": "Makefile.in (OBJS-common): Add tree-ssa-alias-warnings.o.\n\ngcc/\n        * Makefile.in (OBJS-common): Add tree-ssa-alias-warnings.o.\n        * c-common.c (strict_aliasing_warning): Modify -Wstrict-aliasing logic.\n        * c-common.h (strict_aliasing_warning): Change return type.\n        * c-opts.c (c_common_handle_option): Add call to set_Wstrict_aliasing.\n        * c-typeck.c (build_indirect_ref): Add call to strict_aliasing_warning.\n        (build_c_cast): Condition call to strict_aliasing_warning.\n        * doc/invoke.texi: Update description of -Wstrict-aliasing[=n].\n        * flags.h (set_Wstrict_aliasing): Declare.\n        * opts.c (set_Wstrict_alising): Define, add call to.\n        * tree-flow.h (strict_aliasing_warning_backend): Declare.\n        * tree-ssa-alias-warnings.c: New file.\n        * tree-ssa-alias.c (compute_may_aliases): Add call to\n        strict_aliasing_warning_backend.\n\ngcc/cp\n        * cp/typeck.c (build_indirect_ref): Add call to\n        strict_aliasing_warning.\n        (build_reinterpret_cast_1): Condition call to\n        strict_aliasing_warning.\n\ngcc/testsuite\n        * gcc.dg/Wstrict-aliasing-bogus-const-ptr-nonconst-ptr.c: New test.\n        * gcc.dg/Wstrict-aliasing-bogus-never-dereferenced.c: New test.\n        * gcc.dg/Wstrict-aliasing-bogus-struct-included.c: New test.\n        * gcc.dg/Wstrict-aliasing-converted-assigned.c: New test.\n        * gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c: New test.\n        * gcc.dg/alias-1.c: Update option: -Wstrict-aliasing=2.\n        * gcc.dg/alias-9.c: Update option: -Wstrict-aliasing=2.\n        * g++.dg/warn/Wstrict-aliasing-7.C: Update option: -Wstrict-aliasing=2.\n        * g++.dg/warn/Wstrict-aliasing-bogus-base-derived.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-bogus-char-1.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-bogus-const.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-bogus-nested-arrays.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-bogus-signed-unsigned.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-bogus-struct-included.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-bogus-union.C: New test.\n        * g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: New test.\n\nFrom-SVN: r124622", "tree": {"sha": "f0873ca8d26c98fe6770ac353fa336c975e5e22a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0873ca8d26c98fe6770ac353fa336c975e5e22a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79bedddc8fed70d3ebbab016aae285bac9dbbfea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79bedddc8fed70d3ebbab016aae285bac9dbbfea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79bedddc8fed70d3ebbab016aae285bac9dbbfea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79bedddc8fed70d3ebbab016aae285bac9dbbfea/comments", "author": null, "committer": null, "parents": [{"sha": "8339896e55eb0538ddf35cb22f7de5b5b126259c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8339896e55eb0538ddf35cb22f7de5b5b126259c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8339896e55eb0538ddf35cb22f7de5b5b126259c"}], "stats": {"total": 1392, "additions": 1362, "deletions": 30}, "files": [{"sha": "3f1318b2b45efc7f88262163e907da9fc518cec8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1,3 +1,19 @@\n+2007-05-11  Silvius Rus  <rus@google.com>\n+\n+\t* Makefile.in (OBJS-common): Add tree-ssa-alias-warnings.o.\n+\t* c-common.c (strict_aliasing_warning): Modify -Wstrict-aliasing logic.\n+\t* c-common.h (strict_aliasing_warning): Change return type.\n+\t* c-opts.c (c_common_handle_option): Add call to set_Wstrict_aliasing.\n+\t* c-typeck.c (build_indirect_ref): Add call to strict_aliasing_warning.\n+\t(build_c_cast): Condition call to strict_aliasing_warning.\n+\t* doc/invoke.texi: Update description of -Wstrict-aliasing[=n].\n+\t* flags.h (set_Wstrict_aliasing): Declare.\n+\t* opts.c (set_Wstrict_alising): Define, add call to.\n+\t* tree-flow.h (strict_aliasing_warning_backend): Declare.\n+\t* tree-ssa-alias-warnings.c: New file.\n+\t* tree-ssa-alias.c (compute_may_aliases): Add call to\n+\tstrict_aliasing_warning_backend. \n+\n 2007-05-11  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-loop-linear.c (gather_interchange_stats, try_interchange_loops):"}, {"sha": "a1952f5496f06a5f95ceacd3ac857173afa9cda8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1106,6 +1106,7 @@ OBJS-common = \\\n \ttree-sra.o \\\n \ttree-ssa-address.o \\\n \ttree-ssa-alias.o \\\n+\ttree-ssa-alias-warnings.o \\\n \ttree-ssa-ccp.o \\\n \ttree-ssa-coalesce.o \\\n \ttree-ssa-copy.o \\\n@@ -2104,6 +2105,11 @@ tree-ssa-loop-im.o : tree-ssa-loop-im.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-math-opts.o : tree-ssa-math-opts.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TIMEVAR_H) tree-pass.h $(TM_H) $(FLAGS_H) \\\n    alloc-pool.h $(BASIC_BLOCK_H) $(TARGET_H)\n+tree-ssa-alias-warnings.o : tree-ssa-alias-warnings.c \\\n+   $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(TREE_DUMP_H) \\\n+   $(TREE_FLOW_H) $(PARAMS_H) $(FUNCTION_H) $(EXPR_H) toplev.h \\\n+   tree-ssa-structalias.h tree-ssa-propagate.h langhooks.h alloc-pool.h \\\n+   $(DIAGNOSTIC_H)\n tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(TREE_INLINE_H) $(FLAGS_H) \\\n    $(FUNCTION_H) $(TIMEVAR_H) convert.h $(TM_H) coretypes.h langhooks.h \\"}, {"sha": "17a0067378e6fb54b100c7ae360916554fac53bd", "filename": "gcc/c-common.c", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1014,35 +1014,67 @@ warn_logical_operator (enum tree_code code, tree arg1, tree\n    strict aliasing mode is in effect. OTYPE is the original\n    TREE_TYPE of EXPR, and TYPE the type we're casting to. */\n \n-void\n+bool\n strict_aliasing_warning (tree otype, tree type, tree expr)\n {\n-  if (flag_strict_aliasing && warn_strict_aliasing\n-      && POINTER_TYPE_P (type) && POINTER_TYPE_P (otype)\n-      && TREE_CODE (expr) == ADDR_EXPR\n+  if (!(flag_strict_aliasing && POINTER_TYPE_P (type) \n+        && POINTER_TYPE_P (otype) && !VOID_TYPE_P (TREE_TYPE (type))))\n+    return false;\n+\n+  if ((warn_strict_aliasing > 1) && TREE_CODE (expr) == ADDR_EXPR\n       && (DECL_P (TREE_OPERAND (expr, 0))\n-          || handled_component_p (TREE_OPERAND (expr, 0)))\n-      && !VOID_TYPE_P (TREE_TYPE (type)))\n+          || handled_component_p (TREE_OPERAND (expr, 0))))\n     {\n       /* Casting the address of an object to non void pointer. Warn\n          if the cast breaks type based aliasing.  */\n-      if (!COMPLETE_TYPE_P (TREE_TYPE (type)))\n-        warning (OPT_Wstrict_aliasing, \"type-punning to incomplete type \"\n-                 \"might break strict-aliasing rules\");\n+      if (!COMPLETE_TYPE_P (TREE_TYPE (type)) && warn_strict_aliasing == 2)\n+\t{\n+\t  warning (OPT_Wstrict_aliasing, \"type-punning to incomplete type \"\n+\t\t   \"might break strict-aliasing rules\");\n+\t  return true;\n+\t}\n       else\n         {\n-          HOST_WIDE_INT set1 = get_alias_set (TREE_TYPE (TREE_OPERAND (expr, 0)));\n+          /* warn_strict_aliasing >= 3.   This includes the default (3).  \n+             Only warn if the cast is dereferenced immediately.  */\n+          HOST_WIDE_INT set1 =\n+\t    get_alias_set (TREE_TYPE (TREE_OPERAND (expr, 0)));\n           HOST_WIDE_INT set2 = get_alias_set (TREE_TYPE (type));\n \n           if (!alias_sets_conflict_p (set1, set2))\n-            warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n-                     \"pointer will break strict-aliasing rules\");\n-          else if (warn_strict_aliasing > 1\n-                  && !alias_sets_might_conflict_p (set1, set2))\n-            warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n-                     \"pointer might break strict-aliasing rules\");\n+\t    {\n+\t      warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t       \"pointer will break strict-aliasing rules\");\n+\t      return true;\n+\t    }\n+          else if (warn_strict_aliasing == 2\n+\t\t   && !alias_sets_might_conflict_p (set1, set2))\n+\t    {\n+\t      warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+\t\t       \"pointer might break strict-aliasing rules\");\n+\t      return true;\n+\t    }\n         }\n     }\n+  else\n+    if ((warn_strict_aliasing == 1) && !VOID_TYPE_P (TREE_TYPE (otype)))\n+      {\n+        /* At this level, warn for any conversions, even if an address is\n+           not taken in the same statement.  This will likely produce many\n+           false positives, but could be useful to pinpoint problems that\n+           are not revealed at higher levels.  */\n+        HOST_WIDE_INT set1 = get_alias_set (TREE_TYPE (otype));\n+        HOST_WIDE_INT set2 = get_alias_set (TREE_TYPE (type));\n+        if (!COMPLETE_TYPE_P(type)\n+            || !alias_sets_might_conflict_p (set1, set2))\n+\t  {\n+            warning (OPT_Wstrict_aliasing, \"dereferencing type-punned \"\n+                     \"pointer might break strict-aliasing rules\");\n+            return true;\n+          }\n+      }\n+\n+  return false;\n }\n \n /* Print a warning about if (); or if () .. else; constructs"}, {"sha": "7e1967a988e9c8b40824c0a02e899dbaf138f2b0", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -682,7 +682,7 @@ extern void binary_op_error (enum tree_code);\n extern tree fix_string_type (tree);\n struct varray_head_tag;\n extern void constant_expression_warning (tree);\n-extern void strict_aliasing_warning (tree, tree, tree);\n+extern bool strict_aliasing_warning (tree, tree, tree);\n extern void empty_if_body_warning (tree, tree);\n extern void warnings_for_convert_and_check (tree, tree, tree);\n extern tree convert_and_check (tree, tree);"}, {"sha": "ed832afa788c8626386d6c36de22e85e405b6b09", "filename": "gcc/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -400,7 +400,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       if (c_dialect_cxx ())\n \twarn_sign_compare = value;\n       warn_switch = value;\n-      warn_strict_aliasing = value;\n+      set_Wstrict_aliasing (value);\n       warn_address = value;\n       warn_strict_overflow = value;\n       warn_array_bounds = value;"}, {"sha": "2b1e965117bd2f4f5ca787c06a244ca037f6d57f", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1876,6 +1876,19 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n+      if (TREE_CODE (pointer) == CONVERT_EXPR\n+          || TREE_CODE (pointer) == NOP_EXPR\n+          || TREE_CODE (pointer) == VIEW_CONVERT_EXPR)\n+\t{\n+\t  /* If a warning is issued, mark it to avoid duplicates from\n+\t     the backend.  This only needs to be done at\n+\t     warn_strict_aliasing > 2.  */\n+\t  if (warn_strict_aliasing > 2)\n+\t    if (strict_aliasing_warning (TREE_TYPE (TREE_OPERAND (pointer, 0)),\n+\t\t\t\t\t type, TREE_OPERAND (pointer, 0)))\n+\t      TREE_NO_WARNING (pointer) = 1;\n+\t}\n+\n       if (TREE_CODE (pointer) == ADDR_EXPR\n \t  && (TREE_TYPE (TREE_OPERAND (pointer, 0))\n \t      == TREE_TYPE (type)))\n@@ -3574,7 +3587,8 @@ build_c_cast (tree type, tree expr)\n \twarning (OPT_Wint_to_pointer_cast, \"cast to pointer from integer \"\n \t\t \"of different size\");\n \n-      strict_aliasing_warning (otype, type, expr);\n+      if (warn_strict_aliasing <= 2)\n+        strict_aliasing_warning (otype, type, expr);\n \n       /* If pedantic, warn for conversions between function and object\n \t pointer types, except for converting a null pointer constant"}, {"sha": "a4c5ceabec01e83ef061a4f9ea27304638924d9b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1,3 +1,10 @@\n+2007-05-11  Silvius Rus  <rus@google.com>\n+\n+\t* cp/typeck.c (build_indirect_ref): Add call to\n+\tstrict_aliasing_warning.\n+\t(build_reinterpret_cast_1): Condition call to\n+\tstrict_aliasing_warning. \n+\n 2007-05-11  Jan Hubicka  <jh@suse.cz>\n \n \t* semantics.c (expand_or_defer_fn): Do not call c_record_cdtor_fn."}, {"sha": "fa0c956dc73674e67cd66baa9e8c6d16f8693260", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -2333,6 +2333,19 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t types.  */\n       tree t = canonical_type_variant (TREE_TYPE (type));\n \n+      if (TREE_CODE (ptr) == CONVERT_EXPR\n+          || TREE_CODE (ptr) == NOP_EXPR\n+          || TREE_CODE (ptr) == VIEW_CONVERT_EXPR)\n+\t{\n+\t  /* If a warning is issued, mark it to avoid duplicates from\n+\t     the backend.  This only needs to be done at\n+\t     warn_strict_aliasing > 2.  */\n+\t  if (warn_strict_aliasing > 2)\n+\t    if (strict_aliasing_warning (TREE_TYPE (TREE_OPERAND (ptr, 0)),\n+\t\t\t\t\t type, TREE_OPERAND (ptr, 0)))\n+\t      TREE_NO_WARNING (ptr) = 1;\n+\t}\n+\n       if (VOID_TYPE_P (t))\n \t{\n \t  /* A pointer to incomplete type (other than cv void) can be\n@@ -5289,7 +5302,8 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       /* We need to strip nops here, because the front end likes to\n \t create (int *)&a for array-to-pointer decay, instead of &a[0].  */\n       STRIP_NOPS (sexpr);\n-      strict_aliasing_warning (intype, type, sexpr);\n+      if (warn_strict_aliasing <= 2)\n+\tstrict_aliasing_warning (intype, type, sexpr);\n \n       return fold_if_not_in_template (build_nop (type, expr));\n     }"}, {"sha": "9b0d65ac7096994c61c2565833edebada565b932", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -248,7 +248,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wredundant-decls @gol\n -Wreturn-type  -Wsequence-point  -Wshadow @gol\n -Wsign-compare  -Wstack-protector @gol\n--Wstrict-aliasing -Wstrict-aliasing=2 @gol\n+-Wstrict-aliasing -Wstrict-aliasing=n @gol\n -Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum @gol\n -Wsystem-headers  -Wtrigraphs  -Wundef  -Wuninitialized @gol\n@@ -3008,14 +3008,40 @@ It warns about code which might break the strict aliasing rules that the\n compiler is using for optimization.  The warning does not catch all\n cases, but does attempt to catch the more common pitfalls.  It is\n included in @option{-Wall}.\n+It is equivalent to -Wstrict-aliasing=3\n \n-@item -Wstrict-aliasing=2\n-@opindex Wstrict-aliasing=2\n+@item -Wstrict-aliasing=n\n+@opindex Wstrict-aliasing=n\n This option is only active when @option{-fstrict-aliasing} is active.\n It warns about code which might break the strict aliasing rules that the\n-compiler is using for optimization.  This warning catches more cases than\n-@option{-Wstrict-aliasing}, but it will also give a warning for some ambiguous\n-cases that are safe.\n+compiler is using for optimization.\n+Higher levels correspond to higher accuracy (fewer false positives).\n+Higher levels also correspond to more effort, similar to the way -O works.\n+@option{-Wstrict-aliasing} is equivalent to @option{-Wstrict-aliasing=n},\n+with n=3.\n+\n+Level 1: Most aggressive, quick, least accurate.\n+Possibly useful when higher levels\n+do not warn but -fstrict-aliasing still breaks the code, as it has very few \n+false negatives.  However, it has many false positives.\n+Warns for all pointer conversions between possibly incompatible types, \n+even if never dereferenced.  Runs in the frontend only.\n+\n+Level 2: Aggressive, quick, not too precise.\n+May still have many false positives (not as many as level 1 though),\n+and few false negatives (but possibly more than level 1).\n+Unlike level 1, it only warns when an address is taken.  Warns about\n+incomplete types.  Runs in the frontend only.\n+\n+Level 3 (default for @option{-Wstrict-aliasing}): \n+Should have very few false positives and few false \n+negatives.  Slightly slower than levels 1 or 2 when optimization is enabled.\n+Takes care of the common punn+dereference pattern in the frontend:\n+@code{*(int*)&some_float}.\n+If optimization is enabled, it also runs in the backend, where it deals \n+with multiple statement cases using flow-sensitive points-to information.\n+Only warns when the converted pointer is dereferenced.\n+Does not warn about incomplete types.\n \n @item -Wstrict-overflow\n @item -Wstrict-overflow=@var{n}"}, {"sha": "07e5ec358b8464e9c9fd8b9c08ca43c6d880614d", "filename": "gcc/flags.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -122,6 +122,15 @@ extern bool extra_warnings;\n \n extern void set_Wunused (int setting);\n \n+/* Used to set the level of -Wstrict-aliasing, when no level is specified.  \n+   The external way to set the default level is to use\n+   -Wstrict-aliasing=level.  \n+   ONOFF is assumed to take value 1 when -Wstrict-aliasing is specified,\n+   and 0 otherwise.  After calling this function, wstrict_aliasing will be\n+   set to the default value of -Wstrict_aliasing=level.  */\n+\n+extern void set_Wstrict_aliasing (int onoff);\n+\n /* Nonzero means warn about any objects definitions whose size is larger\n    than N bytes.  Also want about function definitions whose returned\n    values are larger than N bytes. The value N is in `larger_than_size'.  */"}, {"sha": "a711f198f68fb5291b3953b40d4f3e1cacc4d3a5", "filename": "gcc/opts.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1352,6 +1352,9 @@ common_handle_option (size_t scode, const char *arg, int value,\n       break;\n \n     case OPT_Wstrict_aliasing:\n+      set_Wstrict_aliasing (value);\n+      break;\n+\n     case OPT_Wstrict_aliasing_:\n       warn_strict_aliasing = value;\n       break;\n@@ -1715,6 +1718,20 @@ set_Wunused (int setting)\n   warn_unused_value = setting;\n }\n \n+/* Used to set the level of strict aliasing warnings, \n+   when no level is specified (i.e., when -Wstrict-aliasing, and not\n+   -Wstrict-aliasing=level was given).\n+   ONOFF is assumed to take value 1 when -Wstrict-aliasing is specified,\n+   and 0 otherwise.  After calling this function, wstrict_aliasing will be\n+   set to the default value of -Wstrict_aliasing=level, currently 3.  */\n+void\n+set_Wstrict_aliasing (int onoff)\n+{\n+  gcc_assert (onoff == 0 || onoff == 1);\n+  if (onoff != 0)\n+    warn_strict_aliasing = 3;\n+}\n+\n /* The following routines are useful in setting all the flags that\n    -ffast-math and -fno-fast-math imply.  */\n void"}, {"sha": "6eca7190a3aae3bedb4d4628e85497bd88cb8d90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1,3 +1,22 @@\n+2007-05-11  Silvius Rus  <rus@google.com>\n+\n+\t* gcc.dg/Wstrict-aliasing-bogus-const-ptr-nonconst-ptr.c: New test.\n+\t* gcc.dg/Wstrict-aliasing-bogus-never-dereferenced.c: New test.\n+\t* gcc.dg/Wstrict-aliasing-bogus-struct-included.c: New test.\n+\t* gcc.dg/Wstrict-aliasing-converted-assigned.c: New test.\n+\t* gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c: New test.\n+\t* gcc.dg/alias-1.c: Update option: -Wstrict-aliasing=2.\n+\t* gcc.dg/alias-9.c: Update option: -Wstrict-aliasing=2.\n+\t* g++.dg/warn/Wstrict-aliasing-7.C: Update option: -Wstrict-aliasing=2.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-base-derived.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-char-1.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-const.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-nested-arrays.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-signed-unsigned.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-struct-included.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-bogus-union.C: New test.\n+\t* g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C: New test. \n+\n 2007-05-11  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR other/31852"}, {"sha": "71ed6cae851b7a3a8731f496487e08c40ad86527", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-7.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Wstrict-aliasing -O2\" } */\n+/* { dg-options \"-Wstrict-aliasing=2 -O2\" } */\n \n int a[2];\n "}, {"sha": "18e6caf90f144f1ea7b6f56ba7b30261ffb6844b", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-base-derived.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-base-derived.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-base-derived.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-base-derived.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+class base {\n+ public:\n+  int x;\n+};\n+\n+class derived: public base {\n+ public:\n+  int y;\n+};\n+\n+base foo () {\n+  derived d;\n+  base* pb = &d;  /* { dg-bogus \"base vs. derived\" } */\n+  pb->x = 1;\n+\n+  return d;\n+}"}, {"sha": "bdd24aca64a854c110547861b7f00ccceaabf0c2", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-char-1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-char-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-char-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-char-1.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+int foo () {\n+  int i;\n+  char* c= reinterpret_cast<char*>(&i);  /* { dg-bogus \"char\" } */\n+  c[1] = 1;\n+  return i;\n+}"}, {"sha": "7c079ad5c54834ca967478975656c540c1a88e27", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-const.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-const.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-const.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-const.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+int foo(int* p) {\n+  const int& q = *p;  /* { dg-bogus \"const vs. non-const\" } */\n+  *p = 1;\n+  return q;\n+}\n+"}, {"sha": "5291181024737653b4dea7a910e250d11cbf0d15", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-nested-arrays.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-nested-arrays.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-nested-arrays.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-nested-arrays.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+int foo () {\n+  int buffer[10][10];\n+  int* pi = &buffer[0][0];  /* { dg-bogus \"same element type\" } */\n+  *pi = 10;\n+  return buffer[0][0];\n+}"}, {"sha": "5e71ebff805107fa06178eaa7966d3d077720ed2", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-signed-unsigned.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-signed-unsigned.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-signed-unsigned.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-signed-unsigned.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+int foo () {\n+  int i;\n+  unsigned int* pu = reinterpret_cast<unsigned int*> (&i);  /* { dg-bogus \"signed vs. unsigned\" } */\n+  *pu = 1000000;\n+  return i;\n+}"}, {"sha": "3f55c78c96d6709b7e356332bfb64b7246998d21", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-struct-included.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-struct-included.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-struct-included.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-struct-included.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+struct S {\n+  int i;\n+  float f;\n+};\n+\n+int foo () {\n+  struct S s;\n+  s.i = 7;\n+  float* f = &s.f;  /* { dg-bogus \"float included in struct S\" } */\n+  *f = 2.0;\n+  return s.i + (int)s.f;\n+}"}, {"sha": "dfbb42c6fd5d2db1c9fed0c70da2db4b5c414bfc", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-bogus-union.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-union.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-union.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-bogus-union.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+union U {\n+  int i;\n+  float f;\n+};\n+\n+float foo () {\n+  union U u;\n+  float* f = &u.f;  /* { dg-bogus \"unions are holy in GCC\" } */\n+  u.i = 2;\n+  return *f;\n+}"}, {"sha": "5527808b4a6a542335387d4b53d31d744b3bcc8c", "filename": "gcc/testsuite/g++.dg/warn/Wstrict-aliasing-float-ref-int-obj.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstrict-aliasing-float-ref-int-obj.C?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+int foo() {\n+  int x;\n+  float& q = reinterpret_cast<float&> (x);  /* { dg-warning \"type-punn\" } */\n+  q = 1.0;\n+  return x;\n+}"}, {"sha": "8a5dcd8e2a56d8050213b972a4e91302f5140717", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-const-ptr-nonconst-ptr.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-const-ptr-nonconst-ptr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-const-ptr-nonconst-ptr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-const-ptr-nonconst-ptr.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+const int* foo (void)\n+{\n+  int *i;\n+  const int** cpi = (const int**) &i; /* { dg-bogus \"const vs. non-const\" } */\n+  i = 0;\n+  return *cpi;\n+}"}, {"sha": "fd3f767ac8618e082481cc1e03d970fd2e6f9a5d", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-never-dereferenced.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-never-dereferenced.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-never-dereferenced.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-never-dereferenced.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+int foo ()\n+{\n+  int x = 10;\n+  int *p;\n+  float *q;\n+\n+  q = (float*) &x;  /* { dg-bogus \"not referenced\" } */\n+\n+  return x;\n+}"}, {"sha": "382fecd6f5a9de6507ff5b6bd157e7e2138f69df", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-bogus-struct-included.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-struct-included.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-struct-included.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-bogus-struct-included.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+struct U\n+{\n+  float f;\n+  int i;\n+};\n+\n+\n+int foo ()\n+{\n+  struct U u;\n+  float *pf = (float*)&u;  /* { dg-bogus \"float included in struct U\" } */\n+  *pf = 2.0;\n+  return u.i;\n+}"}, {"sha": "409120f2a40ac7b70f2398af69d7d56ab043573d", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-converted-assigned.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-converted-assigned.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+\n+int foo()\n+{\n+  int i;\n+  *(long*)&i = 0;  /* { dg-warning \"type-punn\" } */\n+  return i;\n+}"}, {"sha": "7780fa6fcd65e146b82b6ff116d2f57624986b33", "filename": "gcc/testsuite/gcc.dg/Wstrict-aliasing-float-ptr-int-obj.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-aliasing-float-ptr-int-obj.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -Wstrict-aliasing -fstrict-aliasing\" } */\n+\n+extern int flag;\n+\n+int foo() {\n+\n+  int x;\n+  int y = 9;\n+  float* q;\n+  float* r;\n+\n+  if (flag) {\n+    q = (float*) &x;  /* { dg-warning \"type-punn\" } */\n+  } else {\n+    q = (float*) &y;  /* { dg-warning \"type-punn\" } */\n+  }\n+\n+  *q = 1.0;\n+\n+  return x;\n+\n+}"}, {"sha": "388cb3bf533d49c938eea3f27f6ae4429c9b7cb7", "filename": "gcc/testsuite/gcc.dg/alias-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2Falias-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2Falias-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-1.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1,5 +1,5 @@\n // { dg-do compile }\n-// { dg-options \"-Wstrict-aliasing -fstrict-aliasing\" }\n+// { dg-options \"-Wstrict-aliasing=2 -fstrict-aliasing\" }\n \n // Copyright (C) 2002 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 29 Sep 2002 <nathan@codesourcery.com>"}, {"sha": "f8c10031622dd12e47fce9a2f48b0dea2192303b", "filename": "gcc/testsuite/gcc.dg/alias-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2Falias-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftestsuite%2Fgcc.dg%2Falias-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-9.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-Wstrict-aliasing -O2\" } */\n+/* { dg-options \"-Wstrict-aliasing=2 -O2\" } */\n \n int a[2];\n "}, {"sha": "1997abd8779ff5a06e07c6646217a10833df79d0", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -860,6 +860,8 @@ extern void debug_all_mem_sym_stats (void);\n    definition, a function with this prototype is called.  */\n typedef bool (*walk_use_def_chains_fn) (tree, tree, void *);\n \n+/* In tree-ssa-alias-warnings.c  */\n+extern void strict_aliasing_warning_backend (void);\n \n /* In tree-ssa.c  */\n extern void init_tree_ssa (void);"}, {"sha": "149731a19c54e8d5cdc7321a76f35dcc7f9b0074", "filename": "gcc/tree-ssa-alias-warnings.c", "status": "added", "additions": 991, "deletions": 0, "changes": 991, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftree-ssa-alias-warnings.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftree-ssa-alias-warnings.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias-warnings.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -0,0 +1,991 @@\n+/* Strict aliasing checks.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+   Contributed by Silvius Rus <rus@google.com>.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+   Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"alloc-pool.h\"\n+#include \"tree.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-flow.h\"\n+#include \"params.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"toplev.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-ssa-structalias.h\"\n+#include \"tree-ssa-propagate.h\"\n+#include \"langhooks.h\"\n+\n+/* Module to issue a warning when a program uses data through a type\n+   different from the type through which the data were defined.\n+   Implements -Wstrict-aliasing and -Wstrict-aliasing=n.\n+   These checks only happen when -fstrict-aliasing is present.\n+\n+   The idea is to use the compiler to identify occurrences of nonstandard\n+   aliasing, and report them to programmers.  Programs free of such aliasing\n+   are more portable, maintainable, and can usually be optimized better.\n+\n+   The current, as of April 2007, C and C++ language standards forbid\n+   accessing data of type A through an lvalue of another type B,\n+   with certain exceptions. See the C Standard ISO/IEC 9899:1999,\n+   section 6.5, paragraph 7, and the C++ Standard ISO/IEC 14882:1998,\n+   section 3.10, paragraph 15.\n+\n+   Example 1:*a is used as int but was defined as a float, *b.\n+        int* a = ...;\n+        float* b = reinterpret_cast<float*> (a);\n+        *b = 2.0;\n+        return *a\n+\n+   Unfortunately, the problem is in general undecidable if we take into\n+   account arithmetic expressions such as array indices or pointer arithmetic.\n+   (It is at least as hard as Peano arithmetic decidability.)\n+   Even ignoring arithmetic, the problem is still NP-hard, because it is\n+   at least as hard as flow-insensitive may-alias analysis, which was proved\n+   NP-hard by Horwitz et al, TOPLAS 1997.\n+\n+   It is clear that we need to choose some heuristics.\n+   Unfortunately, various users have different goals which correspond to\n+   different time budgets so a common approach will not suit all.\n+   We present the user with three effort/accuracy levels.  By accuracy, we mean\n+   a common-sense mix of low count of false positives with a\n+   reasonably low number of false negatives.  We are heavily biased\n+   towards a low count of false positives.\n+   The effort (compilation time) is likely to increase with the level.\n+\n+   -Wstrict-aliasing=1\n+   ===================\n+   Most aggressive, least accurate.  Possibly useful when higher levels\n+   do not warn but -fstrict-aliasing still breaks the code, as\n+   it has very few false negatives.\n+   Warn for all bad pointer conversions, even if never dereferenced.\n+   Implemented in the front end (c-common.c).\n+   Uses alias_sets_might_conflict to compare types.\n+\n+   -Wstrict-aliasing=2\n+   ===================\n+   Aggressive, not too precise.\n+   May still have many false positives (not as many as level 1 though),\n+   and few false negatives (but possibly more than level 1).\n+   Runs only in the front end. Uses alias_sets_might_conflict to\n+   compare types. Does not check for pointer dereferences.\n+   Only warns when an address is taken. Warns about incomplete type punning.\n+\n+   -Wstrict-aliasing=3 (default)\n+   ===================\n+   Should have very few false positives and few false negatives.\n+   Takes care of the common punn+dereference pattern in the front end:\n+   *(int*)&some_float.\n+   Takes care of multiple statement cases in the back end,\n+   using flow-sensitive points-to information (-O required).\n+   Uses alias_sets_conflict_p to compare types and only warns\n+   when the converted pointer is dereferenced.\n+   Does not warn about incomplete type punning.\n+\n+   Future improvements can be included by adding higher levels.\n+\n+   In summary, expression level analysis is performed in the front-end,\n+   and multiple-statement analysis is performed in the backend.\n+   The remainder of this discussion is only about the backend analysis.\n+\n+   This implementation uses flow-sensitive points-to information.\n+   Flow-sensitivity refers to accesses to the pointer, and not the object\n+   pointed.  For instance, we do not warn about the following case.\n+\n+   Example 2.\n+        int* a = (int*)malloc (...);\n+        float* b = reinterpret_cast<float*> (a);\n+        *b = 2.0;\n+        a = (int*)malloc (...);\n+        return *a;\n+\n+   In SSA, it becomes clear that the INT value *A_2 referenced in the\n+   return statement is not aliased to the FLOAT defined through *B_1.\n+        int* a_1 = (int*)malloc (...);\n+        float* b_1 = reinterpret_cast<float*> (a_1);\n+        *b_1 = 2.0;\n+        a_2 = (int*)malloc (...);\n+        return *a_2;\n+\n+\n+   Algorithm Outline\n+   =================\n+\n+   ForEach (ptr, object) in the points-to table\n+     If (incompatible_types (*ptr, object))\n+       If (referenced (ptr, current function)\n+           and referenced (object, current function))\n+         Issue warning (ptr, object, reference locations)\n+\n+   The complexity is:\n+   O (sizeof (points-to table)\n+      + sizeof (function body) * lookup_time (points-to table))\n+\n+   Pointer dereference locations are looked up on demand.  The search is\n+   a single scan of the function body, in which all references to pointers\n+   and objects in the points-to table are recorded.  However, this dominant\n+   time factor occurs rarely, only when cross-type aliasing was detected.\n+\n+\n+   Limitations of the Proposed Implementation\n+   ==========================================\n+\n+   1. We do not catch the following case, because -fstrict-aliasing will\n+      associate different tags with MEM while building points-to information,\n+      thus before we get to analyze it.\n+      XXX: this could be solved by either running with -fno-strict-aliasing\n+      or by recording the points-to information before splitting the orignal\n+      tag based on type.\n+\n+   Example 3.\n+        void* mem = malloc (...);\n+\tint* pi = reinterpret_cast<int*> (mem);\n+\tfloat* b = reinterpret_cast<float*> (mem);\n+\t*b = 2.0;\n+\treturn *pi+1;\n+\n+   2. We do not check whether the two conflicting (de)references can\n+      reach each other in the control flow sense.  If we fixed limitation\n+      1, we would wrongly issue a warning in the following case.\n+\n+   Example 4.\n+        void* raw = malloc (...);\n+        if (...) {\n+         float* b = reinterpret_cast<float*> (raw);\n+         *b = 2.0;\n+         return (int)*b;\n+        } else {\n+         int* a = reinterpret_cast<int*> (raw);\n+         *a = 1;\n+         return *a;\n+\n+   3. Only simple types are compared, thus no structures, unions or classes\n+      are analyzed.  A first attempt to deal with structures introduced much\n+      complication and has not showed much improvement in preliminary tests,\n+      so it was left out.\n+\n+   4. All analysis is intraprocedural.  */\n+\n+\n+/* Local declarations.  */\n+static void find_references_in_function (void);\n+\f\n+\n+\n+/* Get main type of tree TYPE, stripping array dimensions and qualifiers.  */\n+\n+static tree\n+get_main_type (tree type)\n+{\n+  while (TREE_CODE (type) == ARRAY_TYPE)\n+    type = TREE_TYPE (type);\n+  return TYPE_MAIN_VARIANT (type);\n+}\n+\n+\n+/* Get the type of the given object.  If IS_PTR is true, get the type of the\n+   object pointed to or referenced by OBJECT instead.\n+   For arrays, return the element type.  Ignore all qualifiers.  */\n+\n+static tree\n+get_otype (tree object, bool is_ptr)\n+{\n+  tree otype = TREE_TYPE (object);\n+\n+  if (is_ptr)\n+    {\n+      gcc_assert (POINTER_TYPE_P (otype));\n+      otype = TREE_TYPE (otype);\n+    }\n+  return get_main_type (otype);\n+}\n+\n+\n+/* Return true if tree TYPE is struct, class or union.  */\n+\n+static bool\n+struct_class_union_p (tree type)\n+{\n+  return (TREE_CODE (type) == RECORD_TYPE\n+\t  || TREE_CODE (type) == UNION_TYPE\n+\t  || TREE_CODE (type) == QUAL_UNION_TYPE);\n+}\n+\f\n+\n+\n+/* Keep data during a search for an aliasing site.\n+   RHS = object or pointer aliased.  No LHS is specified because we are only\n+   looking in the UseDef paths of a given variable, so LHS will always be\n+   an SSA name of the same variable.\n+   When IS_RHS_POINTER = true, we are looking for ... = RHS.  Otherwise,\n+   we are looking for ... = &RHS.\n+   SITE is the output of a search, non-NULL if the search succeeded.  */\n+\n+struct alias_match\n+{\n+  tree rhs;\n+  bool is_rhs_pointer;\n+  tree site;\n+};\n+\n+\n+/* Callback for find_alias_site.  Return true if the right hand site\n+   of STMT matches DATA.  */\n+\n+static bool\n+find_alias_site_helper (tree var ATTRIBUTE_UNUSED, tree stmt, void *data)\n+{\n+  struct alias_match *match = (struct alias_match *) data;\n+  tree rhs_pointer = get_rhs (stmt);\n+  tree to_match = NULL_TREE;\n+\n+  while (TREE_CODE (rhs_pointer) == NOP_EXPR\n+         || TREE_CODE (rhs_pointer) == CONVERT_EXPR\n+         || TREE_CODE (rhs_pointer) == VIEW_CONVERT_EXPR)\n+    rhs_pointer = TREE_OPERAND (rhs_pointer, 0);\n+\n+  if (!rhs_pointer)\n+    /* Not a type conversion.  */\n+    return false;\n+\n+  if (TREE_CODE (rhs_pointer) == ADDR_EXPR && !match->is_rhs_pointer)\n+    to_match = TREE_OPERAND (rhs_pointer, 0);\n+  else if (POINTER_TYPE_P (rhs_pointer) && match->is_rhs_pointer)\n+    to_match = rhs_pointer;\n+\n+  if (to_match != match->rhs)\n+    /* Type conversion, but not a name match.  */\n+    return false;\n+\n+  /* Found it.  */\n+  match->site = stmt;\n+  return true;\n+}\n+\n+\n+/* Find the statement where OBJECT1 gets aliased to OBJECT2.\n+   If IS_PTR2 is true, consider OBJECT2 to be the name of a pointer or\n+   reference rather than the actual aliased object.\n+   For now, just implement the case where OBJECT1 is an SSA name defined\n+   by a PHI statement.  */\n+\n+static tree\n+find_alias_site (tree object1, bool is_ptr1 ATTRIBUTE_UNUSED,\n+                 tree object2, bool is_ptr2)\n+{\n+  struct alias_match match;\n+\n+  match.rhs = object2;\n+  match.is_rhs_pointer = is_ptr2;\n+  match.site = NULL_TREE;\n+\n+  if (TREE_CODE (object1) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  walk_use_def_chains (object1, find_alias_site_helper, &match, false);\n+  return match.site;\n+}\n+\n+\n+/* Structure to store temporary results when trying to figure out whether\n+   an object is referenced.  Just its presence in the text is not enough,\n+   as we may just be taking its address.  */\n+\n+struct match_info\n+{\n+  tree object;\n+  bool is_ptr;\n+  /* The difference between the number of references to OBJECT\n+     and the number of occurences of &OBJECT.  */\n+  int found;\n+};\n+\n+\n+/* Return the base if EXPR is an SSA name.  Return EXPR otherwise.  */\n+\n+static tree\n+get_ssa_base (tree expr)\n+{\n+  if (TREE_CODE (expr) == SSA_NAME)\n+    return SSA_NAME_VAR (expr);\n+  else\n+    return expr;\n+}\n+\n+\n+/* Record references to objects and pointer dereferences across some piece of\n+   code.  The number of references is recorded for each item.\n+   References to an object just to take its address are not counted.\n+   For instance, if PTR is a pointer and OBJ is an object:\n+   1. Expression &obj + *ptr will have the following reference match structure:\n+   ptrs: <ptr, 1>\n+   objs: <ptr, 1>\n+   OBJ does not appear as referenced because we just take its address.\n+   2. Expression ptr + *ptr will have the following reference match structure:\n+   ptrs: <ptr, 1>\n+   objs: <ptr, 2>\n+   PTR shows up twice as an object, but is dereferenced only once.\n+\n+   The elements of the hash tables are tree_map objects.  */\n+struct reference_matches\n+{\n+  htab_t ptrs;\n+  htab_t objs;\n+};\n+\n+\n+/* Return the match, if any.  Otherwise, return NULL_TREE.  It will\n+   return NULL_TREE even when a match was found, if the value associated\n+   to KEY is NULL_TREE.  */\n+\n+static inline tree\n+match (htab_t ref_map, tree key)\n+{\n+  struct tree_map *found;\n+  void **slot = NULL;\n+  slot = htab_find_slot (ref_map, &key, NO_INSERT);\n+\n+  if (!slot)\n+    return NULL_TREE;\n+\n+  found = (struct tree_map *) *slot;\n+  return found->to;\n+}\n+\n+\n+/* Set the entry corresponding to KEY, but only if the entry\n+   already exists and its value is NULL_TREE.  Otherwise, do nothing.  */\n+\n+static inline void\n+maybe_add_match (htab_t ref_map, struct tree_map *key)\n+{\n+  struct tree_map *found = htab_find (ref_map, key);\n+\n+  if (found && !found->to)\n+    found->to = key->to;\n+}\n+\n+\n+/* Add an entry to HT, with key T and value NULL_TREE.  */\n+\n+static void\n+add_key (htab_t ht, tree t, alloc_pool references_pool)\n+{\n+  void **slot;\n+  struct tree_map *tp = pool_alloc (references_pool);\n+\n+  tp->base.from = t;\n+  tp->to = NULL_TREE;\n+  slot = htab_find_slot (ht, &t, INSERT);\n+  *slot = (void *) tp;\n+}\n+\n+\n+/* Some memory to keep the objects in the reference table.  */\n+\n+static alloc_pool ref_table_alloc_pool = NULL;\n+\n+\n+/* Get some memory to keep the objects in the reference table.  */\n+\n+static inline alloc_pool\n+reference_table_alloc_pool (bool build)\n+{\n+  if (ref_table_alloc_pool || !build)\n+    return ref_table_alloc_pool;\n+\n+  ref_table_alloc_pool =\n+    create_alloc_pool (\"ref_table_alloc_pool\", sizeof (struct tree_map), 20);\n+\n+  return ref_table_alloc_pool;\n+}\n+\n+\n+/* Initialize the reference table by adding all pointers in the points-to\n+   table as keys, and NULL_TREE as associated values.  */\n+\n+static struct reference_matches *\n+build_reference_table (void)\n+{\n+  unsigned int i;\n+  struct reference_matches *ref_table = NULL;\n+  alloc_pool references_pool = reference_table_alloc_pool (true);\n+\n+  ref_table = XNEW (struct reference_matches);\n+  ref_table->objs = htab_create (10, tree_map_base_hash, tree_map_eq, NULL);\n+  ref_table->ptrs = htab_create (10, tree_map_base_hash, tree_map_eq, NULL);\n+\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree ptr = ssa_name (i);\n+      struct ptr_info_def *pi;\n+\n+      if (ptr == NULL_TREE)\n+\tcontinue;\n+\n+      pi = SSA_NAME_PTR_INFO (ptr);\n+\n+      if (!SSA_NAME_IN_FREE_LIST (ptr) && pi && pi->name_mem_tag)\n+\t{\n+\t  /* Add pointer to the interesting dereference list.  */\n+\t  add_key (ref_table->ptrs, ptr, references_pool);\n+\n+\t  /* Add all aliased names to the interesting reference list.  */\n+\t  if (pi->pt_vars)\n+\t    {\n+\t      unsigned ix;\n+\t      bitmap_iterator bi;\n+\n+\t      EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n+\t\t{\n+\t\t  tree alias = referenced_var (ix);\n+\t\t  add_key (ref_table->objs, alias, references_pool);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return ref_table;\n+}\n+\n+\n+/*  Reference table.  */\n+\n+static struct reference_matches *ref_table = NULL;\n+\n+\n+/* Clean up the reference table if allocated.  */\n+\n+static void\n+maybe_free_reference_table (void)\n+{\n+  if (ref_table)\n+    {\n+      htab_delete (ref_table->ptrs);\n+      htab_delete (ref_table->objs);\n+      free (ref_table);\n+      ref_table = NULL;\n+    }\n+\n+  if (ref_table_alloc_pool)\n+    {\n+      free_alloc_pool (ref_table_alloc_pool);\n+      ref_table_alloc_pool = NULL;\n+    }\n+}\n+\n+\n+/* Get the reference table.  Initialize it if needed.  */\n+\n+static inline struct reference_matches *\n+reference_table (bool build)\n+{\n+  if (ref_table || !build)\n+    return ref_table;\n+\n+  ref_table = build_reference_table ();\n+  find_references_in_function ();\n+  return ref_table;\n+}\n+\n+\n+/* Callback for find_references_in_function.\n+   Check whether *TP is an object reference or pointer dereference for the\n+   variables given in ((struct match_info*)DATA)->OBJS or\n+   ((struct match_info*)DATA)->PTRS.  The total number of references\n+   is stored in the same structures.  */\n+\n+static tree\n+find_references_in_tree_helper (tree *tp,\n+\t\t\t\tint *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t\tvoid *data)\n+{\n+  struct tree_map match;\n+  static int parent_tree_code = ERROR_MARK;\n+\n+  /* Do not report references just for the purpose of taking an address.\n+     XXX: we rely on the fact that the tree walk is in preorder\n+     and that ADDR_EXPR is not a leaf, thus cannot be carried over across\n+     walks.  */\n+  if (parent_tree_code == ADDR_EXPR)\n+    goto finish;\n+\n+  match.to = (tree) data;\n+\n+  if (TREE_CODE (*tp) == INDIRECT_REF)\n+    {\n+      match.base.from = TREE_OPERAND (*tp, 0);\n+      maybe_add_match (reference_table (true)->ptrs, &match);\n+    }\n+  else\n+    {\n+      match.base.from = *tp;\n+      maybe_add_match (reference_table (true)->objs, &match);\n+    }\n+\n+finish:\n+  parent_tree_code = TREE_CODE (*tp);\n+  return NULL_TREE;\n+}\n+\n+\n+/* Find all the references to aliased variables in the current function.  */\n+\n+static void\n+find_references_in_function (void)\n+{\n+  basic_block bb;\n+  block_stmt_iterator i;\n+\n+  FOR_EACH_BB (bb)\n+    for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n+      walk_tree (bsi_stmt_ptr (i), find_references_in_tree_helper,\n+\t\t (void *) *bsi_stmt_ptr (i), NULL);\n+}\n+\n+\n+/* Find the reference site for OBJECT.\n+   If IS_PTR is true, look for derferences of OBJECT instead.\n+   XXX: only the first site is returned in the current\n+   implementation.  If there are no matching sites, return NULL_TREE.  */\n+\n+static tree\n+reference_site (tree object, bool is_ptr)\n+{\n+  if (is_ptr)\n+    return match (reference_table (true)->ptrs, object);\n+  else\n+    return match (reference_table (true)->objs, object);\n+}\n+\n+\n+/* Try to get more location info when something is missing.\n+   OBJECT1 and OBJECT2 are aliased names.  If IS_PTR1 or IS_PTR2, the alias\n+   is on the memory referenced or pointed to by OBJECT1 and OBJECT2.\n+   ALIAS_SITE, DEREF_SITE1 and DEREF_SITE2 are the statements where the\n+   alias takes place (some pointer assignment usually) and where the\n+   alias is referenced through OBJECT1 and OBJECT2 respectively.\n+   REF_TYPE1 and REF_TYPE2 will return the type of the reference at the\n+   respective sites.  Only the first matching reference is returned for\n+   each name.  If no statement is found, the function header is returned.  */\n+\n+static void\n+maybe_find_missing_stmts (tree object1, bool is_ptr1,\n+                          tree object2, bool is_ptr2,\n+                          tree *alias_site,\n+                          tree *deref_site1,\n+                          tree *deref_site2)\n+{\n+  if (object1 && object2)\n+    {\n+      if (!*alias_site || !EXPR_HAS_LOCATION (*alias_site))\n+\t*alias_site = find_alias_site (object1, is_ptr1, object2, is_ptr2);\n+\n+      if (!*deref_site1 || !EXPR_HAS_LOCATION (*deref_site1))\n+\t*deref_site1 = reference_site (object1, is_ptr1);\n+\n+      if (!*deref_site2 || !EXPR_HAS_LOCATION (*deref_site2))\n+\t*deref_site2 = reference_site (object2, is_ptr2);\n+    }\n+\n+  /* If we could not find the alias site, set it to one of the dereference\n+     sites, if available.  */\n+  if (!*alias_site)\n+    {\n+      if (*deref_site1)\n+\t*alias_site = *deref_site1;\n+      else if (*deref_site2)\n+\t*alias_site = *deref_site2;\n+    }\n+\n+  /* If we could not find the dereference sites, set them to the alias site,\n+     if known.  */\n+  if (!*deref_site1 && *alias_site)\n+    *deref_site1 = *alias_site;\n+  if (!*deref_site2 && *alias_site)\n+    *deref_site2 = *alias_site;\n+}\n+\n+\n+/* Callback for find_first_artificial_name.\n+   Find out if there are no artificial names at tree node *T.  */\n+\n+static tree\n+ffan_walker (tree *t,\n+             int *go_below ATTRIBUTE_UNUSED,\n+             void *data ATTRIBUTE_UNUSED)\n+{\n+  if (DECL_P (*t) && DECL_ARTIFICIAL (*t))\n+    return *t;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Return the first artificial name within EXPR, or NULL_TREE if\n+   none exists.  */\n+\n+static tree\n+find_first_artificial_name (tree expr)\n+{\n+  return walk_tree_without_duplicates (&expr, ffan_walker, NULL);\n+}\n+\n+\n+/* Get a name from the original program for VAR.  */\n+\n+static const char *\n+get_var_name (tree var)\n+{\n+  if (TREE_CODE (var) == SSA_NAME)\n+    return get_var_name (get_ssa_base (var));\n+\n+  if (find_first_artificial_name (var))\n+    return \"{unknown}\";\n+\n+  if (TREE_CODE (var) == VAR_DECL || TREE_CODE (var) == PARM_DECL)\n+    if (DECL_NAME (var))\n+      return IDENTIFIER_POINTER (DECL_NAME (var));\n+\n+  return \"{unknown}\";\n+}\n+\n+\n+/* Return \"*\" if OBJECT is not the actual alias but a pointer to it, or\n+   \"\" otherwise.\n+   IS_PTR is true when OBJECT is not the actual alias.\n+   In addition to checking IS_PTR, we also make sure that OBJECT is a pointer\n+   since IS_PTR would also be true for C++ references, but we should only\n+   print a * before a pointer and not before a reference.  */\n+\n+static const char *\n+get_maybe_star_prefix (tree object, bool is_ptr)\n+{\n+  gcc_assert (object);\n+  return (is_ptr\n+          && TREE_CODE (TREE_TYPE (object)) == POINTER_TYPE) ? \"*\" : \"\";\n+}\n+\n+\n+/* Callback for contains_node_type_p.\n+   Returns true if *T has tree code *(int*)DATA.  */\n+\n+static tree\n+contains_node_type_p_callback (tree *t,\n+\t\t\t       int *go_below ATTRIBUTE_UNUSED,\n+\t\t\t       void *data)\n+{\n+  return ((int) TREE_CODE (*t) == *((int *) data)) ? *t : NULL_TREE;\n+}\n+\n+\n+/* Return true if T contains a node with tree code TYPE.  */\n+\n+static bool\n+contains_node_type_p (tree t, int type)\n+{\n+  return (walk_tree_without_duplicates (&t, contains_node_type_p_callback,\n+\t\t\t\t\t(void *) &type)\n+\t  != NULL_TREE);\n+}\n+\n+\n+/* Return true if a warning was issued in the front end at STMT.  */\n+\n+static bool\n+already_warned_in_frontend_p (tree stmt)\n+{\n+  tree rhs_pointer;\n+\n+  if (stmt == NULL_TREE)\n+    return false;\n+\n+  rhs_pointer = get_rhs (stmt);\n+\n+  if ((TREE_CODE (rhs_pointer) == NOP_EXPR\n+       || TREE_CODE (rhs_pointer) == CONVERT_EXPR\n+       || TREE_CODE (rhs_pointer) == VIEW_CONVERT_EXPR)\n+      && TREE_NO_WARNING (rhs_pointer))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+\n+/* Return true if and only if TYPE is a function or method pointer type,\n+   or pointer to a pointer to ... to a function or method.  */\n+\n+static bool\n+is_method_pointer (tree type)\n+{\n+  while (TREE_CODE (type) == POINTER_TYPE)\n+    type = TREE_TYPE (type);\n+  return TREE_CODE (type) == METHOD_TYPE || TREE_CODE (type) == FUNCTION_TYPE;\n+}\n+\n+\n+/* Issue a -Wstrict-aliasing warning.\n+   OBJECT1 and OBJECT2 are aliased names.\n+   If IS_PTR1 and/or IS_PTR2 is true, then the corresponding name\n+   OBJECT1/OBJECT2 is a pointer or reference to the aliased memory,\n+   rather than actual storage.\n+   ALIAS_SITE is a statement where the alias took place.  In the most common\n+   case, that is where a pointer was assigned to the address of an object.  */\n+\n+static bool\n+strict_aliasing_warn (tree alias_site,\n+                      tree object1, bool is_ptr1,\n+                      tree object2, bool is_ptr2,\n+\t\t      bool filter_artificials)\n+{\n+  tree ref_site1 = NULL_TREE;\n+  tree ref_site2 = NULL_TREE;\n+  const char *name1;\n+  const char *name2;\n+  location_t alias_loc;\n+  location_t ref1_loc;\n+  location_t ref2_loc;\n+  gcc_assert (object1);\n+  gcc_assert (object2);\n+  name1 = get_var_name (object1);\n+  name2 = get_var_name (object2);\n+\n+\n+  if (is_method_pointer (get_main_type (TREE_TYPE (object2))))\n+    return false;\n+\n+  maybe_find_missing_stmts (object1, is_ptr1, object2, is_ptr2, &alias_site,\n+                            &ref_site1, &ref_site2);\n+\n+  if (EXPR_HAS_LOCATION (alias_site))\n+    alias_loc = EXPR_LOCATION (alias_site);\n+  else\n+    return false;\n+\n+  if (EXPR_HAS_LOCATION (ref_site1))\n+    ref1_loc = EXPR_LOCATION (ref_site1);\n+  else\n+    ref1_loc = alias_loc;\n+\n+  if (EXPR_HAS_LOCATION (ref_site2))\n+    ref2_loc = EXPR_LOCATION (ref_site2);\n+  else\n+    ref2_loc = alias_loc;\n+\n+  if (already_warned_in_frontend_p (alias_site))\n+    return false;\n+\n+  /* If they are not SSA names, but contain SSA names, drop the warning\n+     because it cannot be displayed well.\n+     Also drop it if they both contain artificials.\n+     XXX: this is a hack, must figure out a better way to display them.  */\n+  if (filter_artificials)\n+    if ((find_first_artificial_name (get_ssa_base (object1))\n+\t && find_first_artificial_name (get_ssa_base (object2)))\n+\t|| (TREE_CODE (object1) != SSA_NAME\n+\t    && contains_node_type_p (object1, SSA_NAME))\n+\t|| (TREE_CODE (object2) != SSA_NAME\n+\t    && contains_node_type_p (object2, SSA_NAME)))\n+      return false;\n+\n+\n+  /* XXX: In the following format string, %s:%d should be replaced by %H.\n+     However, in my tests only the first %H printed ok, while the\n+     second and third were printed as blanks.  */\n+  warning (OPT_Wstrict_aliasing,\n+\t   \"%Hlikely type-punning may break strict-aliasing rules: \"\n+\t   \"object %<%s%s%> of main type %qT is referenced at or around \"\n+\t   \"%s:%d and may be \"\n+\t   \"aliased to object %<%s%s%> of main type %qT which is referenced \"\n+\t   \"at or around %s:%d.\",\n+\t   &alias_loc,\n+\t   get_maybe_star_prefix (object1, is_ptr1),\n+\t   name1, get_otype (object1, is_ptr1),\n+\t   LOCATION_FILE (ref1_loc), LOCATION_LINE (ref1_loc),\n+\t   get_maybe_star_prefix (object2, is_ptr2),\n+\t   name2, get_otype (object2, is_ptr2),\n+\t   LOCATION_FILE (ref2_loc), LOCATION_LINE (ref2_loc));\n+\n+  return true;\n+}\n+\f\n+\n+\n+/* Return true when any objects of TYPE1 and TYPE2 respectively\n+   may not be aliased according to the language standard.  */\n+\n+static bool\n+nonstandard_alias_types_p (tree type1, tree type2)\n+{\n+  HOST_WIDE_INT set1;\n+  HOST_WIDE_INT set2;\n+\n+  if (VOID_TYPE_P (type1) || VOID_TYPE_P (type2))\n+    return false;\n+\n+  set1 = get_alias_set (type1);\n+  set2 = get_alias_set (type2);\n+  return !alias_sets_conflict_p (set1, set2);\n+}\n+\f\n+\n+\n+/* Returns true when *PTR may not be aliased to ALIAS.\n+   See C standard 6.5p7 and C++ standard 3.10p15.\n+   If PTR_PTR is true, ALIAS represents a pointer or reference to the\n+   aliased storage rather than its actual name.  */\n+\n+static bool\n+nonstandard_alias_p (tree ptr, tree alias, bool ptr_ptr)\n+{\n+  /* Find the types to compare.  */\n+  tree ptr_type = get_otype (ptr, true);\n+  tree alias_type = get_otype (alias, ptr_ptr);\n+\n+  /* XXX: for now, say it's OK if the alias escapes.\n+     Not sure this is needed in general, but otherwise GCC will not\n+     bootstrap.  */\n+  if (var_ann (get_ssa_base (alias))->escape_mask != NO_ESCAPE)\n+    return false;\n+\n+  /* XXX: don't get into structures for now.  It brings much complication\n+     and little benefit.  */\n+  if (struct_class_union_p (ptr_type) || struct_class_union_p (alias_type))\n+    return false;\n+\n+  /* If they are both SSA names of artificials, let it go, the warning\n+     is too confusing.  */\n+  if (find_first_artificial_name (ptr) && find_first_artificial_name (alias))\n+    return false;\n+\n+  /* Compare the types.  */\n+  return nonstandard_alias_types_p (ptr_type, alias_type);\n+}\n+\n+\n+/* Return true when we should skip analysis for pointer PTR based on the\n+   fact that their alias information *PI is not considered relevant.  */\n+\n+static bool\n+skip_this_pointer (tree ptr ATTRIBUTE_UNUSED, struct ptr_info_def *pi)\n+{\n+  /* If it is not dereferenced, it is not a problem (locally).  */\n+  if (!pi->is_dereferenced)\n+    return true;\n+\n+  /* This would probably cause too many false positives.  */\n+  if (pi->value_escapes_p || pi->pt_anything)\n+    return true;\n+\n+  return false;\n+}\n+\n+\n+/* Find aliasing to named objects for pointer PTR.  */\n+\n+static void\n+dsa_named_for (tree ptr)\n+{\n+  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\n+  if (pi)\n+    {\n+      if (skip_this_pointer (ptr, pi))\n+\treturn;\n+\n+      /* For all the variables it could be aliased to.  */\n+      if (pi->pt_vars)\n+\t{\n+\t  unsigned ix;\n+\t  bitmap_iterator bi;\n+\n+\t  EXECUTE_IF_SET_IN_BITMAP (pi->pt_vars, 0, ix, bi)\n+\t    {\n+\t      tree alias = referenced_var (ix);\n+\n+\t      if (nonstandard_alias_p (ptr, alias, false))\n+\t\tstrict_aliasing_warn (SSA_NAME_DEF_STMT (ptr),\n+\t\t\t\t      ptr, true, alias, false, true);\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n+/* Detect and report strict aliasing violation of named objects.  */\n+\n+static void\n+detect_strict_aliasing_named (void)\n+{\n+  unsigned int i;\n+\n+  for (i = 1; i < num_ssa_names; i++)\n+    {\n+      tree ptr = ssa_name (i);\n+      struct ptr_info_def *pi;\n+\n+      if (ptr == NULL_TREE)\n+\tcontinue;\n+\n+      pi = SSA_NAME_PTR_INFO (ptr);\n+\n+      if (!SSA_NAME_IN_FREE_LIST (ptr) && pi && pi->name_mem_tag)\n+\tdsa_named_for (ptr);\n+    }\n+}\n+\n+\n+/* Return false only the first time I see each instance of FUNC.  */\n+\n+static bool\n+processed_func_p (tree func)\n+{\n+  static htab_t seen = NULL;\n+  void **slot = NULL;\n+\n+  if (!seen)\n+    seen = htab_create (10, tree_map_base_hash, tree_map_eq, NULL);\n+\n+  slot = htab_find_slot (seen, &func, INSERT);\n+  gcc_assert (slot);\n+\n+  if (*slot)\n+    return true;\n+\n+  gcc_assert (slot);\n+  *slot = &func;\n+  return false;\n+}\n+\n+\n+/* Detect and warn about type-punning using points-to information.  */\n+\n+void\n+strict_aliasing_warning_backend (void)\n+{\n+  if (flag_strict_aliasing && warn_strict_aliasing == 3\n+      && !processed_func_p (current_function_decl))\n+    {\n+      detect_strict_aliasing_named ();\n+      maybe_free_reference_table ();\n+    }\n+}"}, {"sha": "2ecad8bafdfcee0de91f75a584b7e79fe4f4a70d", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79bedddc8fed70d3ebbab016aae285bac9dbbfea/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=79bedddc8fed70d3ebbab016aae285bac9dbbfea", "patch": "@@ -97,6 +97,7 @@ static void set_pt_anything (tree);\n void debug_mp_info (VEC(mem_sym_stats_t,heap) *);\n \n \n+\n /* Return memory reference stats for symbol VAR.  Create a new slot in\n    cfun->gimple_df->mem_sym_stats if needed.  */\n \n@@ -1605,6 +1606,9 @@ compute_may_aliases (void)\n \tdump_referenced_vars (dump_file);\n     }\n \n+  /* Report strict aliasing violations.  */\n+  strict_aliasing_warning_backend ();\n+\n   /* Deallocate memory used by aliasing data structures.  */\n   delete_alias_info (ai);\n   \n@@ -3932,7 +3936,7 @@ create_structure_vars (void)\n \t      update_stmt (stmt);\n \t  }\n       }\n-  \n+\n   return 0;\n }\n "}]}