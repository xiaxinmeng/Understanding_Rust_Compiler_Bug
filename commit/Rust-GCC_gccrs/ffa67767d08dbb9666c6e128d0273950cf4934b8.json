{"sha": "ffa67767d08dbb9666c6e128d0273950cf4934b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhNjc3NjdkMDhkYmI5NjY2YzZlMTI4ZDAyNzM5NTBjZjQ5MzRiOA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-01-31T21:37:11Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-01-31T21:37:11Z"}, "message": "stl_algo.h: Wrap overlong lines...\n\n2004-01-31  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_algo.h: Wrap overlong lines, constify\n\ta few variables, reformat according to the coding standards.\n\t* include/bits/stl_algobase.h: Likewise.\n\t* include/bits/stl_heap.h: Likewise.\n\nFrom-SVN: r77050", "tree": {"sha": "e294aab90cd1e09b3b6d953799de7627a0b5cd50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e294aab90cd1e09b3b6d953799de7627a0b5cd50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffa67767d08dbb9666c6e128d0273950cf4934b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa67767d08dbb9666c6e128d0273950cf4934b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa67767d08dbb9666c6e128d0273950cf4934b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa67767d08dbb9666c6e128d0273950cf4934b8/comments", "author": null, "committer": null, "parents": [{"sha": "fdf064f28d11202cc70d8ae65fccf140fef9c46b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdf064f28d11202cc70d8ae65fccf140fef9c46b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdf064f28d11202cc70d8ae65fccf140fef9c46b"}], "stats": {"total": 2902, "additions": 1662, "deletions": 1240}, "files": [{"sha": "ccabde1db6e339b6e3fcaaf1bbd6afb96255c06b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ffa67767d08dbb9666c6e128d0273950cf4934b8", "patch": "@@ -1,3 +1,10 @@\n+2004-01-31  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_algo.h: Wrap overlong lines, constify\n+\ta few variables, reformat according to the coding standards.\n+\t* include/bits/stl_algobase.h: Likewise.\n+\t* include/bits/stl_heap.h: Likewise.\n+\n 2004-01-31  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/basic_string.h (_Rep::operator[]): Remove, unused."}, {"sha": "9f0f376f613662126183176924429ba8f450189f", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 1482, "deletions": 1116, "changes": 2598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=ffa67767d08dbb9666c6e128d0273950cf4934b8"}, {"sha": "3a1441f5801de8d36724bae392c03a45596c7530", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=ffa67767d08dbb9666c6e128d0273950cf4934b8", "patch": "@@ -91,16 +91,22 @@ namespace std\n     inline void\n     iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n     {\n-      typedef typename iterator_traits<_ForwardIterator1>::value_type _ValueType1;\n-      typedef typename iterator_traits<_ForwardIterator2>::value_type _ValueType2;\n+      typedef typename iterator_traits<_ForwardIterator1>::value_type\n+\t_ValueType1;\n+      typedef typename iterator_traits<_ForwardIterator2>::value_type\n+\t_ValueType2;\n \n       // concept requirements\n-      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator1>)\n-      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator2>)\n-      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1, _ValueType2>)\n-      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2, _ValueType1>)\n-\n-      _ValueType1 __tmp = *__a;\n+      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n+\t\t\t\t  _ForwardIterator1>)\n+      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n+\t\t\t\t  _ForwardIterator2>)\n+      __glibcxx_function_requires(_ConvertibleConcept<_ValueType1,\n+\t\t\t\t  _ValueType2>)\n+      __glibcxx_function_requires(_ConvertibleConcept<_ValueType2,\n+\t\t\t\t  _ValueType1>)\n+\n+      const _ValueType1 __tmp = *__a;\n       *__a = *__b;\n       *__b = __tmp;\n     }\n@@ -121,7 +127,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)\n       \n-      _Tp __tmp = __a;\n+      const _Tp __tmp = __a;\n       __a = __b;\n       __b = __tmp;\n     }\n@@ -146,7 +152,9 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n       //return __b < __a ? __b : __a;\n-      if (__b < __a) return __b; return __a;\n+      if (__b < __a)\n+\treturn __b;\n+      return __a;\n     }\n \n   /**\n@@ -166,7 +174,9 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n       //return  __a < __b ? __b : __a;\n-      if (__a < __b) return __b; return __a;\n+      if (__a < __b)\n+\treturn __b;\n+      return __a;\n     }\n \n   /**\n@@ -184,7 +194,9 @@ namespace std\n     min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n     {\n       //return __comp(__b, __a) ? __b : __a;\n-      if (__comp(__b, __a)) return __b; return __a;\n+      if (__comp(__b, __a))\n+\treturn __b;\n+      return __a;\n     }\n \n   /**\n@@ -202,7 +214,9 @@ namespace std\n     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n     {\n       //return __comp(__a, __b) ? __b : __a;\n-      if (__comp(__a, __b)) return __b; return __a;\n+      if (__comp(__a, __b))\n+\treturn __b;\n+      return __a;\n     }\n \n   // All of these auxiliary functions serve two purposes.  (1) Replace\n@@ -249,13 +263,15 @@ namespace std\n     inline _OutputIterator\n     __copy_aux2(_InputIterator __first, _InputIterator __last,\n \t\t_OutputIterator __result, __false_type)\n-    { return std::__copy(__first, __last, __result, std::__iterator_category(__first)); }\n+    { return std::__copy(__first, __last, __result,\n+\t\t\t std::__iterator_category(__first)); }\n \n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n     __copy_aux2(_InputIterator __first, _InputIterator __last,\n \t\t_OutputIterator __result, __true_type)\n-    { return std::__copy(__first, __last, __result, std::__iterator_category(__first)); }\n+    { return std::__copy(__first, __last, __result,\n+\t\t\t std::__iterator_category(__first)); }\n \n   template<typename _Tp>\n     inline _Tp*\n@@ -274,9 +290,9 @@ namespace std\n \t       _OutputIterator __result, __true_type)\n     {\n       typedef typename iterator_traits<_InputIterator>::value_type\n-\t  _ValueType;\n-      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator\n-\t  _Trivial;\n+\t_ValueType;\n+      typedef typename __type_traits<\n+\t_ValueType>::has_trivial_assignment_operator _Trivial;\n       return _OutputIterator(std::__copy_aux2(__first, __last, __result.base(),\n \t\t\t\t\t      _Trivial()));\n     }\n@@ -287,8 +303,8 @@ namespace std\n \t       _OutputIterator __result, __false_type)\n     {\n       typedef typename iterator_traits<_InputIterator>::value_type _ValueType;\n-      typedef typename __type_traits<_ValueType>::has_trivial_assignment_operator\n-          _Trivial;\n+      typedef typename __type_traits<\n+\t_ValueType>::has_trivial_assignment_operator _Trivial;\n       return std::__copy_aux2(__first, __last, __result, _Trivial());\n     }\n \n@@ -298,7 +314,8 @@ namespace std\n \t       _OutputIterator __result, __true_type)\n     {\n       typedef typename _Is_normal_iterator<_OutputIterator>::_Normal __Normal;\n-      return std::__copy_ni2(__first.base(), __last.base(), __result, __Normal());\n+      return std::__copy_ni2(__first.base(), __last.base(),\n+\t\t\t     __result, __Normal());\n     }\n \n   template<typename _InputIterator, typename _OutputIterator>\n@@ -328,7 +345,8 @@ namespace std\n   */\n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n-    copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n+    copy(_InputIterator __first, _InputIterator __last,\n+\t _OutputIterator __result)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n@@ -342,8 +360,10 @@ namespace std\n \n   template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>\n     inline _BidirectionalIterator2\n-    __copy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, \n-\t\t    _BidirectionalIterator2 __result, bidirectional_iterator_tag)\n+    __copy_backward(_BidirectionalIterator1 __first,\n+\t\t    _BidirectionalIterator1 __last, \n+\t\t    _BidirectionalIterator2 __result,\n+\t\t    bidirectional_iterator_tag)\n     {\n       while (__first != __last)\n         *--__result = *--__last;\n@@ -373,10 +393,8 @@ namespace std\n       static _BidirectionalIterator2\n       copy(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last, \n \t   _BidirectionalIterator2 __result)\n-      {\n-        return std::__copy_backward(__first, __last, __result, \n-\t\t\t\t    std::__iterator_category(__first));\n-      }\n+      { return std::__copy_backward(__first, __last, __result, \n+\t\t\t\t    std::__iterator_category(__first)); }\n     };\n \n   template<typename _Tp>\n@@ -408,9 +426,10 @@ namespace std\n     {\n       typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>\n \t\t\t    ::has_trivial_assignment_operator _Trivial;\n-      return std::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first, \n-\t\t\t\t\t\t\t\t       __last, \n-\t\t\t\t\t\t\t\t       __result);\n+      return\n+\tstd::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first, \n+\t\t\t\t\t\t\t\t  __last, \n+\t\t\t\t\t\t\t\t  __result);\n     }\n \n   template <typename _BI1, typename _BI2>\n@@ -432,8 +451,8 @@ namespace std\n     {\n       typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;\n       return std::__copy_backward_output_normal_iterator(__first.base(),\n-\t\t\t\t\t\t\t __last.base(), __result, \n-\t\t\t\t\t\t\t __Normal());\n+\t\t\t\t\t\t\t __last.base(),\n+\t\t\t\t\t\t\t __result, __Normal());\n     }\n \n   template <typename _BI1, typename _BI2>\n@@ -442,8 +461,8 @@ namespace std\n \t\t\t\t\t  _BI2 __result, __false_type)\n     {\n       typedef typename _Is_normal_iterator<_BI2>::_Normal __Normal;\n-      return std::__copy_backward_output_normal_iterator(__first, __last, __result,\n-\t\t\t\t\t\t\t __Normal());\n+      return std::__copy_backward_output_normal_iterator(__first, __last,\n+\t\t\t\t\t\t\t __result, __Normal());\n     }\n \n   /**\n@@ -476,8 +495,8 @@ namespace std\n       __glibcxx_requires_valid_range(__first, __last);\n \n       typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;\n-      return std::__copy_backward_input_normal_iterator(__first, __last, __result,\n-\t\t\t\t\t\t\t__Normal());\n+      return std::__copy_backward_input_normal_iterator(__first, __last,\n+\t\t\t\t\t\t\t__result, __Normal());\n     }\n \n \n@@ -497,7 +516,8 @@ namespace std\n     fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n     {\n       // concept requirements\n-      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n+      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<\n+\t\t\t\t  _ForwardIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n@@ -532,23 +552,23 @@ namespace std\n   fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)\n   {\n     __glibcxx_requires_valid_range(__first, __last);\n-    unsigned char __tmp = __c;\n+    const unsigned char __tmp = __c;\n     std::memset(__first, __tmp, __last - __first);\n   }\n \n   inline void\n   fill(signed char* __first, signed char* __last, const signed char& __c)\n   {\n     __glibcxx_requires_valid_range(__first, __last);\n-    signed char __tmp = __c;\n+    const signed char __tmp = __c;\n     std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n \n   inline void\n   fill(char* __first, char* __last, const char& __c)\n   {\n     __glibcxx_requires_valid_range(__first, __last);\n-    char __tmp = __c;\n+    const char __tmp = __c;\n     std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n \n@@ -625,7 +645,8 @@ namespace std\n    *  second iterator points into the second range, and the elements pointed\n    *  to by the iterators are not equal.\n   */\n-  template<typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate>\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n     pair<_InputIterator1, _InputIterator2>\n     mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n \t     _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n@@ -656,7 +677,8 @@ namespace std\n   */\n   template<typename _InputIterator1, typename _InputIterator2>\n     inline bool\n-    equal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n+    equal(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t  _InputIterator2 __first2)\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n@@ -685,7 +707,8 @@ namespace std\n    *  false depending on whether all of the corresponding elements of the\n    *  ranges are equal.\n   */\n-  template<typename _InputIterator1, typename _InputIterator2, typename _BinaryPredicate>\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n     inline bool\n     equal(_InputIterator1 __first1, _InputIterator1 __last1,\n \t  _InputIterator2 __first2,\n@@ -753,7 +776,8 @@ namespace std\n    *  The same as the four-parameter @c lexigraphical_compare, but uses the\n    *  comp parameter instead of @c <.\n   */\n-  template<typename _InputIterator1, typename _InputIterator2, typename _Compare>\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _Compare>\n     bool\n     lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n \t\t\t    _InputIterator2 __first2, _InputIterator2 __last2,\n@@ -787,7 +811,8 @@ namespace std\n \n     const size_t __len1 = __last1 - __first1;\n     const size_t __len2 = __last2 - __first2;\n-    const int __result = std::memcmp(__first1, __first2, std::min(__len1, __len2));\n+    const int __result = std::memcmp(__first1, __first2,\n+\t\t\t\t     std::min(__len1, __len2));\n     return __result != 0 ? __result < 0 : __len1 < __len2;\n   }\n "}, {"sha": "97311ed71617ce73ed675171030c0c094dd5e7f9", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 102, "deletions": 78, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffa67767d08dbb9666c6e128d0273950cf4934b8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=ffa67767d08dbb9666c6e128d0273950cf4934b8", "patch": "@@ -1,6 +1,6 @@\n // Heap implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -72,12 +72,13 @@ namespace std\n     __is_heap(_RandomAccessIterator __first, _Distance __n)\n     {\n       _Distance __parent = 0;\n-      for (_Distance __child = 1; __child < __n; ++__child) {\n-\tif (__first[__parent] < __first[__child]) \n-\t  return false;\n-\tif ((__child & 1) == 0)\n-\t  ++__parent;\n-      }\n+      for (_Distance __child = 1; __child < __n; ++__child)\n+\t{\n+\t  if (__first[__parent] < __first[__child]) \n+\t    return false;\n+\t  if ((__child & 1) == 0)\n+\t    ++__parent;\n+\t}\n       return true;\n     }\n \n@@ -88,12 +89,13 @@ namespace std\n \t      _Distance __n)\n     {\n       _Distance __parent = 0;\n-      for (_Distance __child = 1; __child < __n; ++__child) {\n-\tif (__comp(__first[__parent], __first[__child]))\n-\t  return false;\n-\tif ((__child & 1) == 0)\n-\t  ++__parent;\n-      }\n+      for (_Distance __child = 1; __child < __n; ++__child)\n+\t{\n+\t  if (__comp(__first[__parent], __first[__child]))\n+\t    return false;\n+\t  if ((__child & 1) == 0)\n+\t    ++__parent;\n+\t}\n       return true;\n     }\n \n@@ -116,11 +118,12 @@ namespace std\n \t\t_Distance __holeIndex, _Distance __topIndex, _Tp __value)\n     {\n       _Distance __parent = (__holeIndex - 1) / 2;\n-      while (__holeIndex > __topIndex && *(__first + __parent) < __value) {\n-\t*(__first + __holeIndex) = *(__first + __parent);\n-\t__holeIndex = __parent;\n-\t__parent = (__holeIndex - 1) / 2;\n-      }    \n+      while (__holeIndex > __topIndex && *(__first + __parent) < __value)\n+\t{\n+\t  *(__first + __holeIndex) = *(__first + __parent);\n+\t  __holeIndex = __parent;\n+\t  __parent = (__holeIndex - 1) / 2;\n+\t}\n       *(__first + __holeIndex) = __value;\n     }\n \n@@ -149,8 +152,8 @@ namespace std\n       __glibcxx_requires_valid_range(__first, __last);\n       //      __glibcxx_requires_heap(__first, __last - 1);\n \n-      std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), \n-\t\t       _ValueType(*(__last - 1)));\n+      std::__push_heap(__first, _DistanceType((__last - __first) - 1),\n+\t\t       _DistanceType(0), _ValueType(*(__last - 1)));\n     }\n \n   template<typename _RandomAccessIterator, typename _Distance, typename _Tp, \n@@ -160,11 +163,13 @@ namespace std\n \t\t_Distance __topIndex, _Tp __value, _Compare __comp)\n     {\n       _Distance __parent = (__holeIndex - 1) / 2;\n-      while (__holeIndex > __topIndex && __comp(*(__first + __parent), __value)) {\n-\t*(__first + __holeIndex) = *(__first + __parent);\n-\t__holeIndex = __parent;\n-\t__parent = (__holeIndex - 1) / 2;\n-      }\n+      while (__holeIndex > __topIndex\n+\t     && __comp(*(__first + __parent), __value))\n+\t{\n+\t  *(__first + __holeIndex) = *(__first + __parent);\n+\t  __holeIndex = __parent;\n+\t  __parent = (__holeIndex - 1) / 2;\n+\t}\n       *(__first + __holeIndex) = __value;\n     }\n \n@@ -195,28 +200,30 @@ namespace std\n       __glibcxx_requires_valid_range(__first, __last);\n       __glibcxx_requires_heap_pred(__first, __last - 1, __comp);\n \n-      std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), \n-\t\t       _ValueType(*(__last - 1)), __comp);\n+      std::__push_heap(__first, _DistanceType((__last - __first) - 1),\n+\t\t       _DistanceType(0), _ValueType(*(__last - 1)), __comp);\n     }\n \n   template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n     void \n     __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n \t\t  _Distance __len, _Tp __value)\n     {\n-      _Distance __topIndex = __holeIndex;\n+      const _Distance __topIndex = __holeIndex;\n       _Distance __secondChild = 2 * __holeIndex + 2;\n-      while (__secondChild < __len) {\n-\tif (*(__first + __secondChild) < *(__first + (__secondChild - 1)))\n-\t  __secondChild--;\n-\t*(__first + __holeIndex) = *(__first + __secondChild);\n-\t__holeIndex = __secondChild;\n-\t__secondChild = 2 * (__secondChild + 1);\n-      }\n-      if (__secondChild == __len) {\n-\t*(__first + __holeIndex) = *(__first + (__secondChild - 1));\n-\t__holeIndex = __secondChild - 1;\n-      }\n+      while (__secondChild < __len)\n+\t{\n+\t  if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))\n+\t    __secondChild--;\n+\t  *(__first + __holeIndex) = *(__first + __secondChild);\n+\t  __holeIndex = __secondChild;\n+\t  __secondChild = 2 * (__secondChild + 1);\n+\t}\n+      if (__secondChild == __len)\n+\t{\n+\t  *(__first + __holeIndex) = *(__first + (__secondChild - 1));\n+\t  __holeIndex = __secondChild - 1;\n+\t}\n       std::__push_heap(__first, __holeIndex, __topIndex, __value);\n     }\n \n@@ -225,9 +232,11 @@ namespace std\n     __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t       _RandomAccessIterator __result, _Tp __value)\n     {\n-      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t_Distance;\n       *__result = *__first;\n-      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value);\n+      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),\n+\t\t\t __value);\n     }\n \n   /**\n@@ -243,7 +252,8 @@ namespace std\n     inline void\n     pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n     {\n-      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n+\t_ValueType;\n \n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n@@ -252,7 +262,8 @@ namespace std\n       __glibcxx_requires_valid_range(__first, __last);\n       __glibcxx_requires_heap(__first, __last);\n \n-      std::__pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)));\n+      std::__pop_heap(__first, __last - 1, __last - 1,\n+\t\t      _ValueType(*(__last - 1)));\n     }\n \n   template<typename _RandomAccessIterator, typename _Distance,\n@@ -261,19 +272,22 @@ namespace std\n     __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n \t\t  _Distance __len, _Tp __value, _Compare __comp)\n     {\n-      _Distance __topIndex = __holeIndex;\n+      const _Distance __topIndex = __holeIndex;\n       _Distance __secondChild = 2 * __holeIndex + 2;\n-      while (__secondChild < __len) {\n-\tif (__comp(*(__first + __secondChild), *(__first + (__secondChild - 1))))\n-\t  __secondChild--;\n-\t*(__first + __holeIndex) = *(__first + __secondChild);\n-\t__holeIndex = __secondChild;\n-\t__secondChild = 2 * (__secondChild + 1);\n-      }\n-      if (__secondChild == __len) {\n-\t*(__first + __holeIndex) = *(__first + (__secondChild - 1));\n-\t__holeIndex = __secondChild - 1;\n-      }\n+      while (__secondChild < __len)\n+\t{\n+\t  if (__comp(*(__first + __secondChild),\n+\t\t     *(__first + (__secondChild - 1))))\n+\t    __secondChild--;\n+\t  *(__first + __holeIndex) = *(__first + __secondChild);\n+\t  __holeIndex = __secondChild;\n+\t  __secondChild = 2 * (__secondChild + 1);\n+\t}\n+      if (__secondChild == __len)\n+\t{\n+\t  *(__first + __holeIndex) = *(__first + (__secondChild - 1));\n+\t  __holeIndex = __secondChild - 1;\n+\t}\n       std::__push_heap(__first, __holeIndex, __topIndex, __value, __comp);\n     }\n \n@@ -282,9 +296,10 @@ namespace std\n     __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t       _RandomAccessIterator __result, _Tp __value, _Compare __comp)\n     {\n-      typedef typename iterator_traits<_RandomAccessIterator>::difference_type _Distance;\n+      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n+\t_Distance;\n       *__result = *__first;\n-      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first), \n+      std::__adjust_heap(__first, _Distance(0), _Distance(__last - __first),\n \t\t\t __value, __comp);\n     }\n \n@@ -310,8 +325,10 @@ namespace std\n       __glibcxx_requires_valid_range(__first, __last);\n       __glibcxx_requires_heap_pred(__first, __last, __comp);\n \n-      typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n-      std::__pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);\n+      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n+\t_ValueType;\n+      std::__pop_heap(__first, __last - 1, __last - 1,\n+\t\t      _ValueType(*(__last - 1)), __comp);\n     }\n \n   /**\n@@ -337,15 +354,19 @@ namespace std\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      if (__last - __first < 2) return;\n-      _DistanceType __len = __last - __first;\n-      _DistanceType __parent = (__len - 2)/2;\n-\t\n-      while (true) {\n-\tstd::__adjust_heap(__first, __parent, __len, _ValueType(*(__first + __parent)));\n-\tif (__parent == 0) return;\n-\t__parent--;\n-      }\n+      if (__last - __first < 2)\n+\treturn;\n+\n+      const _DistanceType __len = __last - __first;    \n+      _DistanceType __parent = (__len - 2) / 2;\n+      while (true)\n+\t{\n+\t  std::__adjust_heap(__first, __parent, __len,\n+\t\t\t     _ValueType(*(__first + __parent)));\n+\t  if (__parent == 0)\n+\t    return;\n+\t  __parent--;\n+\t}\n     }\n \n   /**\n@@ -373,16 +394,19 @@ namespace std\n \t    _RandomAccessIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n       \n-      if (__last - __first < 2) return;\n-      _DistanceType __len = __last - __first;\n-      _DistanceType __parent = (__len - 2)/2;\n-\t\n-      while (true) {\n-\tstd::__adjust_heap(__first, __parent, __len,\n-\t\t\t   _ValueType(*(__first + __parent)), __comp);\n-\tif (__parent == 0) return;\n-\t__parent--;\n-      }\n+      if (__last - __first < 2)\n+\treturn;\n+\n+      const _DistanceType __len = __last - __first;\n+      _DistanceType __parent = (__len - 2) / 2;\n+      while (true)\n+\t{\n+\t  std::__adjust_heap(__first, __parent, __len,\n+\t\t\t     _ValueType(*(__first + __parent)), __comp);\n+\t  if (__parent == 0)\n+\t    return;\n+\t  __parent--;\n+\t}\n     }\n \n   /**"}]}