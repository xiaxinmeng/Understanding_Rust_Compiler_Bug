{"sha": "e8525382d986350f38193ca20504631bfadc43ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg1MjUzODJkOTg2MzUwZjM4MTkzY2EyMDUwNDYzMWJmYWRjNDNiYQ==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2004-08-29T15:58:16Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-08-29T15:58:16Z"}, "message": "check.c (gfc_check_besn, [...]): New functions.\n\n2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n\tPaul Brook  <paul@codesourcery.com>\n\n\t* check.c (gfc_check_besn, gfc_check_g77_math1): New functions.\n\t* f95-lang.c (DO_DEFINE_MATH_BUILTIN): Define.\n\t(DEFINE_MATH_BUILTIN, DEFINE_MATH_BUILTIN_C): Use it.\n\t(build_builtin_fntypes): New function.\n\t(gfc_init_builtin_functions): Use it.\n\t* gfortran.h (enum gfc_generic_isym_id): Add GFC_ISYM_{J,Y}{0,1,N}\n\tand GFC_ISYM_ERF{,C}.\n\t(gfc_c_int_kind): Declare.\n\t* intrinsic.c (add_functions): Add [d]bes* and [d]erf*.\n\t* intrinsic.h (gfc_check_besn, gfc_check_g77_math1, gfc_resolve_besn,\n\tgfc_resolve_g77_math1): Add prototypes.\n\t* resolve.c (gfc_resolve_besn, gfc_resolve_g77_math1): New functions.\n\t* mathbuiltins.def: Add comment.  Change third argument.  Use\n\tDEFINE_MATH_BUILTIN_C.  Add bessel and error functions.\n\t* trans-intrinsic.c (BUILT_IN_FUNCTION): Define.\n\t(DEFINE_MATH_BUILTIN, DEFINE_MATH_BUILTIN_C): Use it.\n\t* trans-types.c (gfc_c_int_kind): Declare.\n\t(gfc_init_kinds): Set it.\ntestsuite/\n\t* gfortran.dg/g77/README: Update.\n\t* gfortran.dg/g77/erfc.f: Copy from g77.f-torture.\n\t* gfortran.dg/g77/intrinsic-unix-bessel.f: Ditto.\n\t* gfortran.dg/g77/intrinsic-unix-erf.f: Ditto.\nlibgfortran/\n\t* intrinsics/bessel.c: New file.\n\t* intrinsics/erf.c: New file.\n\t* Makefie.am: Add intrinsics/bessel.c and intrinsics/erf.c.\n\t* configure.ac: Test for C99 Bessel and Error functions.\n\t* Makefile.in: Regenerate.\n\t* config.h.in: Regenerate.\n\t* configure: Regenerate.\n\nCo-Authored-By: Paul Brook <paul@codesourcery.com>\n\nFrom-SVN: r86727", "tree": {"sha": "764a8802dba0b681b9c0d6f4248a2b2513c2b2fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/764a8802dba0b681b9c0d6f4248a2b2513c2b2fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8525382d986350f38193ca20504631bfadc43ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8525382d986350f38193ca20504631bfadc43ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8525382d986350f38193ca20504631bfadc43ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8525382d986350f38193ca20504631bfadc43ba/comments", "author": null, "committer": null, "parents": [{"sha": "766ff1b11748f66da98c901b9498a90e72698c05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/766ff1b11748f66da98c901b9498a90e72698c05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/766ff1b11748f66da98c901b9498a90e72698c05"}], "stats": {"total": 1778, "additions": 1734, "deletions": 44}, "files": [{"sha": "fd405fef9216d5a8038b39ffebe5120859696f37", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -1,3 +1,25 @@\n+2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\t* check.c (gfc_check_besn, gfc_check_g77_math1): New functions.\n+\t* f95-lang.c (DO_DEFINE_MATH_BUILTIN): Define.\n+\t(DEFINE_MATH_BUILTIN, DEFINE_MATH_BUILTIN_C): Use it.\n+\t(build_builtin_fntypes): New function.\n+\t(gfc_init_builtin_functions): Use it.\n+\t* gfortran.h (enum gfc_generic_isym_id): Add GFC_ISYM_{J,Y}{0,1,N}\n+\tand GFC_ISYM_ERF{,C}.\n+\t(gfc_c_int_kind): Declare.\n+\t* intrinsic.c (add_functions): Add [d]bes* and [d]erf*.\n+\t* intrinsic.h (gfc_check_besn, gfc_check_g77_math1, gfc_resolve_besn,\n+\tgfc_resolve_g77_math1): Add prototypes.\n+\t* resolve.c (gfc_resolve_besn, gfc_resolve_g77_math1): New functions.\n+\t* mathbuiltins.def: Add comment.  Change third argument.  Use\n+\tDEFINE_MATH_BUILTIN_C.  Add bessel and error functions.\n+\t* trans-intrinsic.c (BUILT_IN_FUNCTION): Define.\n+\t(DEFINE_MATH_BUILTIN, DEFINE_MATH_BUILTIN_C): Use it.\n+\t* trans-types.c (gfc_c_int_kind): Declare.\n+\t(gfc_init_kinds): Set it.\n+\n 2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "6bc9e09f2034e2fca92d1cc6e7aed0fa99b2ccda", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -525,6 +525,28 @@ gfc_check_atan2 (gfc_expr * y, gfc_expr * x)\n }\n \n   \n+/* BESJN and BESYN functions.  */\n+\n+try\n+gfc_check_besn (gfc_expr * n, gfc_expr * x)\n+{\n+\n+  if (scalar_check (n, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (n, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (scalar_check (x, 1) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (x, 1, BT_REAL) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n try\n gfc_check_btest (gfc_expr * i, gfc_expr * pos)\n {\n@@ -728,6 +750,22 @@ gfc_check_eoshift (gfc_expr * array, gfc_expr * shift, gfc_expr * boundary,\n }\n \n \n+/* This is used for the g77 one-argument Bessel functions, and the\n+   error function.  */\n+\n+try\n+gfc_check_g77_math1 (gfc_expr * x)\n+{\n+\n+  if (scalar_check (x, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (x, 0, BT_REAL) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n \n try\n gfc_check_huge (gfc_expr * x)"}, {"sha": "b822a89fefeb32c540e6a68259ca1bdf116161b6", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 44, "deletions": 17, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -712,38 +712,64 @@ gfc_define_builtin (const char * name,\n }\n \n \n-#define DEFINE_MATH_BUILTIN(code, name, nargs) \\\n-    gfc_define_builtin (\"__builtin_\" name, mfunc_double[nargs-1], \\\n+#define DO_DEFINE_MATH_BUILTIN(code, name, argtype, tbase) \\\n+    gfc_define_builtin (\"__builtin_\" name, tbase##double[argtype], \\\n \t\t\tBUILT_IN_ ## code, name, true); \\\n-    gfc_define_builtin (\"__builtin_\" name \"f\", mfunc_float[nargs-1], \\\n+    gfc_define_builtin (\"__builtin_\" name \"f\", tbase##float[argtype], \\\n \t\t\tBUILT_IN_ ## code ## F, name \"f\", true);\n \n+#define DEFINE_MATH_BUILTIN(code, name, argtype) \\\n+    DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_)\n+\n+/* The middle-end is missing builtins for some complex math functions, so\n+   we don't use them yet.  */\n+#define DEFINE_MATH_BUILTIN_C(code, name, argtype) \\\n+    DO_DEFINE_MATH_BUILTIN (code, name, argtype, mfunc_)\n+/*    DO_DEFINE_MATH_BUILTIN (C##code, \"c\" name, argtype, mfunc_c)*/\n+\n+\n+/* Create function types for builtin functions.  */\n+\n+static void\n+build_builtin_fntypes (tree * fntype, tree type)\n+{\n+  tree tmp;\n+\n+  /* type (*) (type) */\n+  tmp = tree_cons (NULL_TREE, float_type_node, void_list_node);\n+  fntype[0] = build_function_type (type, tmp);\n+  /* type (*) (type, type) */\n+  tmp = tree_cons (NULL_TREE, float_type_node, tmp);\n+  fntype[1] = build_function_type (type, tmp);\n+  /* type (*) (int, type) */\n+  tmp = tree_cons (NULL_TREE, integer_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, type, tmp);\n+  fntype[2] = build_function_type (type, tmp);\n+}\n+\n+\n /* Initialisation of builtin function nodes.  */\n+\n static void\n gfc_init_builtin_functions (void)\n {\n-  tree mfunc_float[2];\n-  tree mfunc_double[2];\n+  tree mfunc_float[3];\n+  tree mfunc_double[3];\n+  tree mfunc_cfloat[3];\n+  tree mfunc_cdouble[3];\n   tree func_cfloat_float;\n   tree func_cdouble_double;\n   tree ftype;\n   tree tmp;\n \n-  tmp = tree_cons (NULL_TREE, float_type_node, void_list_node);\n-  mfunc_float[0] = build_function_type (float_type_node, tmp);\n-  tmp = tree_cons (NULL_TREE, float_type_node, tmp);\n-  mfunc_float[1] = build_function_type (float_type_node, tmp);\n-  \n+  build_builtin_fntypes (mfunc_float, float_type_node);\n+  build_builtin_fntypes (mfunc_double, double_type_node);\n+  build_builtin_fntypes (mfunc_cfloat, complex_float_type_node);\n+  build_builtin_fntypes (mfunc_cdouble, complex_double_type_node);\n+\n   tmp = tree_cons (NULL_TREE, complex_float_type_node, void_list_node);\n   func_cfloat_float = build_function_type (float_type_node, tmp);\n-  \n \n-  tmp = tree_cons (NULL_TREE, double_type_node, void_list_node);\n-  mfunc_double[0] = build_function_type (double_type_node, tmp);\n-  tmp = tree_cons (NULL_TREE, double_type_node, tmp);\n-  mfunc_double[1] = build_function_type (double_type_node, tmp);\n-  \n-  \n   tmp = tree_cons (NULL_TREE, complex_double_type_node, void_list_node);\n   func_cdouble_double = build_function_type (double_type_node, tmp);\n \n@@ -835,6 +861,7 @@ gfc_init_builtin_functions (void)\n \t\t      \"alloca\", false);\n }\n \n+#undef DEFINE_MATH_BUILTIN_C\n #undef DEFINE_MATH_BUILTIN\n \n #include \"gt-fortran-f95-lang.h\""}, {"sha": "89c182d507c615f715d58bf73c3b48edee3a2851", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -286,6 +286,12 @@ enum gfc_generic_isym_id\n   GFC_ISYM_ASSOCIATED,\n   GFC_ISYM_ATAN,\n   GFC_ISYM_ATAN2,\n+  GFC_ISYM_J0,\n+  GFC_ISYM_J1,\n+  GFC_ISYM_JN,\n+  GFC_ISYM_Y0,\n+  GFC_ISYM_Y1,\n+  GFC_ISYM_YN,\n   GFC_ISYM_BTEST,\n   GFC_ISYM_CEILING,\n   GFC_ISYM_CHAR,\n@@ -301,6 +307,8 @@ enum gfc_generic_isym_id\n   GFC_ISYM_DOT_PRODUCT,\n   GFC_ISYM_DPROD,\n   GFC_ISYM_EOSHIFT,\n+  GFC_ISYM_ERF,\n+  GFC_ISYM_ERFC,\n   GFC_ISYM_ETIME,\n   GFC_ISYM_EXP,\n   GFC_ISYM_EXPONENT,\n@@ -1518,6 +1526,7 @@ extern int gfc_default_double_kind;\n extern int gfc_default_character_kind;\n extern int gfc_default_logical_kind;\n extern int gfc_default_complex_kind;\n+extern int gfc_c_int_kind;\n \n /* symbol.c */\n void gfc_clear_new_implicit (void);"}, {"sha": "414cc1a59137030adab32e0e1eaae0b2a5f18beb", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -969,6 +969,68 @@ add_functions (void)\n \n   make_generic (\"atan2\", GFC_ISYM_ATAN2);\n \n+  /* Bessel and Neumann functions for G77 compatibility.  */\n+\n+  add_sym_1 (\"besj0\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dr, 0);\n+\n+  add_sym_1 (\"dbesj0\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dd, 0);\n+\n+  make_generic (\"besj0\", GFC_ISYM_J0);\n+\n+  add_sym_1 (\"besj1\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dr, 1);\n+\n+  add_sym_1 (\"dbesj1\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dd, 1);\n+\n+  make_generic (\"besj1\", GFC_ISYM_J1);\n+\n+  add_sym_2 (\"besjn\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_besn, NULL, gfc_resolve_besn, n, BT_INTEGER, di, 1,\n+         x, BT_REAL, dr, 1);\n+\n+  add_sym_2 (\"dbesjn\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_besn, NULL, gfc_resolve_besn, n, BT_INTEGER, di, 1,\n+         x, BT_REAL, dd, 1);\n+\n+  make_generic (\"besjn\", GFC_ISYM_JN);\n+\n+  add_sym_1 (\"besy0\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dr, 0);\n+\n+  add_sym_1 (\"dbesy0\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dd, 0);\n+\n+  make_generic (\"besy0\", GFC_ISYM_Y0);\n+\n+  add_sym_1 (\"besy1\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dr, 1);\n+\n+  add_sym_1 (\"dbesy1\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dd, 1);\n+\n+  make_generic (\"besy1\", GFC_ISYM_Y1);\n+\n+  add_sym_2 (\"besyn\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_besn, NULL, gfc_resolve_besn, n, BT_INTEGER, di, 1,\n+         x, BT_REAL, dr, 1);\n+\n+  add_sym_2 (\"dbesyn\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_besn, NULL, gfc_resolve_besn, n, BT_INTEGER, di, 1,\n+         x, BT_REAL, dd, 1);\n+\n+  make_generic (\"besyn\", GFC_ISYM_YN);\n+\n   add_sym_1 (\"bit_size\", 0, 1, BT_INTEGER, di,\n \t     gfc_check_i, gfc_simplify_bit_size, NULL,\n \t     i, BT_INTEGER, di, 0);\n@@ -1113,6 +1175,27 @@ add_functions (void)\n \n   make_generic (\"epsilon\", GFC_ISYM_NONE);\n \n+  /* G77 compatibility for the ERF() and ERFC() functions.  */\n+  add_sym_1 (\"erf\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dr, 0);\n+\n+  add_sym_1 (\"derf\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dd, 0);\n+\n+  make_generic (\"erf\", GFC_ISYM_ERF);\n+\n+  add_sym_1 (\"erfc\", 1, 0, BT_REAL, dr,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dr, 0);\n+\n+  add_sym_1 (\"derfc\", 1, 0, BT_REAL, dd,\n+\t     gfc_check_g77_math1, NULL, gfc_resolve_g77_math1,\n+\t     x, BT_REAL, dd, 0);\n+\n+  make_generic (\"erfc\", GFC_ISYM_ERFC);\n+\n   /* G77 compatibility */\n   add_sym_1 (\"etime\", 0, 1, BT_REAL, 4,\n \t     gfc_check_etime, NULL, NULL,"}, {"sha": "b2ffb155a858c797e864fe133ad3b73f8cc4a9e2", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -35,6 +35,7 @@ try gfc_check_all_any (gfc_expr *, gfc_expr *);\n try gfc_check_allocated (gfc_expr *);\n try gfc_check_associated (gfc_expr *, gfc_expr *);\n try gfc_check_atan2 (gfc_expr *, gfc_expr *);\n+try gfc_check_besn (gfc_expr *, gfc_expr *);\n try gfc_check_btest (gfc_expr *, gfc_expr *);\n try gfc_check_char (gfc_expr *, gfc_expr *);\n try gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -47,6 +48,7 @@ try gfc_check_dot_product (gfc_expr *, gfc_expr *);\n try gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_etime (gfc_expr *);\n try gfc_check_etime_sub (gfc_expr *, gfc_expr *);\n+try gfc_check_g77_math1 (gfc_expr *);\n try gfc_check_huge (gfc_expr *);\n try gfc_check_i (gfc_expr *);\n try gfc_check_iand (gfc_expr *, gfc_expr *);\n@@ -231,6 +233,7 @@ void gfc_resolve_any (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_asin (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan (gfc_expr *, gfc_expr *);\n void gfc_resolve_atan2 (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_besn (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_btest (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ceiling (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_char (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -252,6 +255,7 @@ void gfc_resolve_exp (gfc_expr *, gfc_expr *);\n void gfc_resolve_exponent (gfc_expr *, gfc_expr *);\n void gfc_resolve_floor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fraction (gfc_expr *, gfc_expr *);\n+void gfc_resolve_g77_math1 (gfc_expr *, gfc_expr *);\n void gfc_resolve_getgid (gfc_expr *);\n void gfc_resolve_getpid (gfc_expr *);\n void gfc_resolve_getuid (gfc_expr *);"}, {"sha": "6df95839c12369f9a42aa2044bf270bbb8ca5bcf", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -269,6 +269,24 @@ gfc_resolve_atan2 (gfc_expr * f, gfc_expr * x,\n }\n \n \n+/* Resolve the BESYN and BESJN intrinsics.  */\n+\n+void\n+gfc_resolve_besn (gfc_expr * f, gfc_expr * n, gfc_expr * x)\n+{\n+  gfc_typespec ts;\n+  \n+  f->ts = x->ts;\n+  if (n->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      gfc_convert_type (n, &ts, 2);\n+    }\n+  f->value.function.name = gfc_get_string (\"<intrinsic>\");\n+}\n+\n+\n void\n gfc_resolve_btest (gfc_expr * f, gfc_expr * i, gfc_expr * pos)\n {\n@@ -544,6 +562,16 @@ gfc_resolve_fraction (gfc_expr * f, gfc_expr * x)\n }\n \n \n+/* Resolve single-argument g77 math intrinsics, eg BESY0, ERF.  */\n+\n+void\n+gfc_resolve_g77_math1 (gfc_expr * f, gfc_expr * x)\n+{\n+  f->ts = x->ts;\n+  f->value.function.name = gfc_get_string (\"<intrinsic>\");\n+}\n+\n+\n void\n gfc_resolve_getgid (gfc_expr * f)\n {"}, {"sha": "0bbf8d9c1f7d59fb7a7b98fbc685dd7eaa5585f7", "filename": "gcc/fortran/mathbuiltins.def", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fmathbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Fmathbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmathbuiltins.def?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -1,14 +1,29 @@\n-DEFINE_MATH_BUILTIN (ACOS,  \"acos\", 1)\n-DEFINE_MATH_BUILTIN (ASIN,  \"asin\", 1)\n-DEFINE_MATH_BUILTIN (ATAN, \"atan\", 1)\n-DEFINE_MATH_BUILTIN (ATAN2, \"atan2\", 2)\n-DEFINE_MATH_BUILTIN (COS, \"cos\", 1)\n-DEFINE_MATH_BUILTIN (COSH,  \"cosh\", 1)\n-DEFINE_MATH_BUILTIN (EXP, \"exp\", 1)\n-DEFINE_MATH_BUILTIN (LOG, \"log\", 1)\n-DEFINE_MATH_BUILTIN (LOG10, \"log10\", 1)\n-DEFINE_MATH_BUILTIN (SIN, \"sin\", 1)\n-DEFINE_MATH_BUILTIN (SINH,  \"sinh\", 1)\n-DEFINE_MATH_BUILTIN (SQRT, \"sqrt\", 1)\n-DEFINE_MATH_BUILTIN (TAN, \"tan\", 1)\n-DEFINE_MATH_BUILTIN (TANH,  \"tanh\", 1)\n+/* DEFINE_MATH_BUILTIN (CODE, NAME, ARGTYPE)\n+   NAME\t  The name of the builtin\n+   SNAME  The name of the builtin as a string\n+   ARGTYPE The type of the arguments.  See f95-lang.c\n+\n+   Use DEFINE_MATH_BUILTIN_C if the complex versions of the builtin are\n+   also available.  */\n+DEFINE_MATH_BUILTIN_C (ACOS,  \"acos\",   0)\n+DEFINE_MATH_BUILTIN_C (ASIN,  \"asin\",   0)\n+DEFINE_MATH_BUILTIN_C (ATAN,  \"atan\",   0)\n+DEFINE_MATH_BUILTIN   (ATAN2, \"atan2\",  1)\n+DEFINE_MATH_BUILTIN_C (COS,   \"cos\",    0)\n+DEFINE_MATH_BUILTIN_C (COSH,  \"cosh\",   0)\n+DEFINE_MATH_BUILTIN_C (EXP,   \"exp\",    0)\n+DEFINE_MATH_BUILTIN_C (LOG,   \"log\",    0)\n+DEFINE_MATH_BUILTIN_C (LOG10, \"log10\",  0)\n+DEFINE_MATH_BUILTIN_C (SIN,   \"sin\",    0)\n+DEFINE_MATH_BUILTIN_C (SINH,  \"sinh\",   0)\n+DEFINE_MATH_BUILTIN_C (SQRT,  \"sqrt\",   0)\n+DEFINE_MATH_BUILTIN_C (TAN,   \"tan\",    0)\n+DEFINE_MATH_BUILTIN_C (TANH,  \"tanh\",   0)\n+DEFINE_MATH_BUILTIN   (J0,    \"j0\",     0)\n+DEFINE_MATH_BUILTIN   (J1,    \"j1\",     0)\n+DEFINE_MATH_BUILTIN   (JN,    \"jn\",     2)\n+DEFINE_MATH_BUILTIN   (Y0,    \"y0\",     0)\n+DEFINE_MATH_BUILTIN   (Y1,    \"y1\",     0)\n+DEFINE_MATH_BUILTIN   (YN,    \"yn\",     2)\n+DEFINE_MATH_BUILTIN   (ERF,   \"erf\",    0)\n+DEFINE_MATH_BUILTIN   (ERFC,  \"erfc\",   0)"}, {"sha": "ec5689583a4dc80f50ed1c16950c80c8286e45a9", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -85,9 +85,16 @@ gfc_intrinsic_map_t;\n /* ??? The NARGS==1 hack here is based on the fact that (c99 at least)\n    defines complex variants of all of the entries in mathbuiltins.def\n    except for atan2.  */\n-#define DEFINE_MATH_BUILTIN(ID, NAME, NARGS) \\\n+#define BUILT_IN_FUNCTION(ID, NAME, HAVE_COMPLEX) \\\n   { GFC_ISYM_ ## ID, BUILT_IN_ ## ID ## F, BUILT_IN_ ## ID, true, \\\n-    NARGS == 1, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n+    HAVE_COMPLEX, true, NAME, NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE},\n+\n+#define DEFINE_MATH_BUILTIN(id, name, argtype) \\\n+  BUILT_IN_FUNCTION (id, name, false)\n+\n+/* TODO: Use builtin function for complex intrinsics.  */\n+#define DEFINE_MATH_BUILTIN_C(id, name, argtype) \\\n+  BUILT_IN_FUNCTION (id, name, true)\n \n #define LIBM_FUNCTION(ID, NAME, HAVE_COMPLEX) \\\n   { GFC_ISYM_ ## ID, END_BUILTINS, END_BUILTINS, true, HAVE_COMPLEX, true, \\\n@@ -117,6 +124,8 @@ static GTY(()) gfc_intrinsic_map_t gfc_intrinsic_map[] =\n   LIBF_FUNCTION (NONE, NULL, false)\n };\n #undef DEFINE_MATH_BUILTIN\n+#undef DEFINE_MATH_BUILTIN_C\n+#undef BUILT_IN_FUNCTION\n #undef LIBM_FUNCTION\n #undef LIBF_FUNCTION\n "}, {"sha": "d1ace6dac50e68b449e80bd54be4f1f754ce2db9", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -84,6 +84,7 @@ int gfc_default_double_kind;\n int gfc_default_character_kind;\n int gfc_default_logical_kind;\n int gfc_default_complex_kind;\n+int gfc_c_int_kind;\n \n /* Query the target to determine which machine modes are available for\n    computation.  Choose KIND numbers for them.  */\n@@ -232,6 +233,8 @@ gfc_init_kinds (void)\n \n   /* Choose the integer kind the same size as \"void*\" for our index kind.  */\n   gfc_index_integer_kind = POINTER_SIZE / 8;\n+  /* Pick a kind the same size as the C \"int\" type.  */\n+  gfc_c_int_kind = INT_TYPE_SIZE / 8;\n }\n \n /* Make sure that a valid kind is present.  Returns an index into the"}, {"sha": "84c03ab5f7db44695ba446b76b45d265a4944de4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -1,3 +1,11 @@\n+2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\t* gfortran.dg/g77/README: Update.\n+\t* gfortran.dg/g77/erfc.f: Copy from g77.f-torture.\n+\t* gfortran.dg/g77/intrinsic-unix-bessel.f: Ditto.\n+\t* gfortran.dg/g77/intrinsic-unix-erf.f: Ditto.\n+\n 2004-08-28  Paul Brook  <paul@codesourcery.com>\n \n \tPR libfortran/17195"}, {"sha": "2605369f2c2f3b6c056399f4e2993d5e047514a7", "filename": "gcc/testsuite/gfortran.dg/g77/README", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2FREADME?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -167,15 +167,15 @@ cpp.F\t(Renamed cpp3.F)\tY\n cpp2.F\t\t\t\t- Compiler warnings\n dcomplex.f\t\t\tY\n dnrm2.f\t\t\t\tY Add dg-warning as required\n-erfc.f\t\t\t\t  Link errors\n+erfc.f\t\t\t\tY\n exp.f\t\t\t\t  Compiler warnings and fails\n f90-intrinsic-bit.f             F 16581 Compile errors\n f90-intrinsic-mathematical.f\tY \n f90-intrinsic-numeric.f\t\tY\n int8421.f\t\t\tY\n intrinsic-f2c-z.f\t\tF Execution fail\n-intrinsic-unix-bessel.f\t\t  Link errors\n-intrinsic-unix-erf.f\t\t  Link erros\n+intrinsic-unix-bessel.f\t\tY\n+intrinsic-unix-erf.f\t\tY\n intrinsic-vax-cd.f\t\tF Execution fail\n intrinsic77.f\t \t\tF PR 16580 Compiler ICE\n io0.f & io0.x"}, {"sha": "0ab0aee8c1c803e8e994f04ade26baa225e2835a", "filename": "gcc/testsuite/gfortran.dg/g77/erfc.f", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ferfc.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ferfc.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ferfc.f?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -0,0 +1,39 @@\n+c { dg-do run }\n+c============================================== test.f\n+                real x, y\n+\t\treal*8 x1, y1\n+\t\tx=0.\n+\t\ty = erfc(x)\n+\t\tif (y .ne. 1.) call abort\n+\n+\t\tx=1.1\n+\t\ty = erfc(x)\n+\t\tif (abs(y - .1197949) .ge. 1.e-6) call abort\n+\n+* modified from x=10, y .gt. 1.5e-44 to avoid lack of -mieee on Alphas.\n+\t\tx=8\n+\t\ty = erfc(x)\n+\t\tif (y .gt. 1.2e-28) call abort\n+\n+\t\tx1=0.\n+\t\ty1 = erfc(x1)\n+\t\tif (y1 .ne. 1.) call abort\n+\n+\t\tx1=1.1d0\n+\t\ty1 = erfc(x1)\n+\t\tif (abs(y1 - .1197949d0) .ge. 1.d-6) call abort\n+\n+\t\tx1=10\n+\t\ty1 = erfc(x1)\n+\t\tif (y1 .gt. 1.5d-44) call abort\n+\t\tend\n+c=================================================\n+!output:\n+!  0.  1.875\n+!  1.10000002  1.48958981\n+!  10.  5.00220949E-06\n+!\n+!The values should be:\n+!erfc(0)=1\n+!erfc(1.1)= 0.1197949\n+!erfc(10)<1.543115467311259E-044"}, {"sha": "0b5789da679512be51dbb676cdaad19c9d3a8f7f", "filename": "gcc/testsuite/gfortran.dg/g77/intrinsic-unix-bessel.f", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fintrinsic-unix-bessel.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fintrinsic-unix-bessel.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fintrinsic-unix-bessel.f?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -0,0 +1,109 @@\n+c { dg-do run }\n+c  intrinsic-unix-bessel.f\n+c\n+c Test Bessel function intrinsics.  \n+c These functions are only available if provided by system\n+c\n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+      real x, a\n+      double precision dx, da\n+      integer i\n+      integer*2 j\n+      integer*1 k\n+      integer*8 m\n+      logical fail\n+      common /flags/ fail\n+      fail = .false.\n+\n+      x = 2.0\n+      dx = x \n+      i = 2\n+      j = i\n+      k = i\n+      m = i\n+c     BESJ0  - Bessel function of first kind of order zero\n+      a = 0.22389077\n+      da = a\n+      call c_r(BESJ0(x),a,'BESJ0(real)')\n+      call c_d(BESJ0(dx),da,'BESJ0(double)')\n+      call c_d(DBESJ0(dx),da,'DBESJ0(double)')\n+\n+c     BESJ1  - Bessel function of first kind of order one\n+      a = 0.57672480\n+      da = a\n+      call c_r(BESJ1(x),a,'BESJ1(real)')\n+      call c_d(BESJ1(dx),da,'BESJ1(double)')\n+      call c_d(DBESJ1(dx),da,'DBESJ1(double)')\n+\n+c     BESJN  - Bessel function of first kind of order N\n+      a = 0.3528340\n+      da = a\n+      call c_r(BESJN(i,x),a,'BESJN(integer,real)')\n+      call c_r(BESJN(j,x),a,'BESJN(integer*2,real)')\n+      call c_r(BESJN(k,x),a,'BESJN(integer*1,real)')\n+      call c_d(BESJN(i,dx),da,'BESJN(integer,double)')\n+      call c_d(BESJN(j,dx),da,'BESJN(integer*2,double)')\n+      call c_d(BESJN(k,dx),da,'BESJN(integer*1,double)')\n+      call c_d(DBESJN(i,dx),da,'DBESJN(integer,double)')\n+      call c_d(DBESJN(j,dx),da,'DBESJN(integer*2,double)')\n+      call c_d(DBESJN(k,dx),da,'DBESJN(integer*1,double)')\n+\n+c     BESY0  - Bessel function of second kind of order zero\n+      a = 0.51037567\n+      da = a\n+      call c_r(BESY0(x),a,'BESY0(real)')\n+      call c_d(BESY0(dx),da,'BESY0(double)')\n+      call c_d(DBESY0(dx),da,'DBESY0(double)')\n+\n+c     BESY1  - Bessel function of second kind of order one\n+      a = 0.-0.1070324\n+      da = a\n+      call c_r(BESY1(x),a,'BESY1(real)')\n+      call c_d(BESY1(dx),da,'BESY1(double)')\n+      call c_d(DBESY1(dx),da,'DBESY1(double)')\n+\n+c     BESYN  - Bessel function of second kind of order N\n+      a = -0.6174081\n+      da = a\n+      call c_r(BESYN(i,x),a,'BESYN(integer,real)')\n+      call c_r(BESYN(j,x),a,'BESYN(integer*2,real)')\n+      call c_r(BESYN(k,x),a,'BESYN(integer*1,real)')\n+      call c_d(BESYN(i,dx),da,'BESYN(integer,double)')\n+      call c_d(BESYN(j,dx),da,'BESYN(integer*2,double)')\n+      call c_d(BESYN(k,dx),da,'BESYN(integer*1,double)')\n+      call c_d(DBESYN(i,dx),da,'DBESYN(integer,double)')\n+      call c_d(DBESYN(j,dx),da,'DBESYN(integer*2,double)')\n+      call c_d(DBESYN(k,dx),da,'DBESYN(integer*1,double)')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_r(a,b,label)\n+c     Check if REAL a equals b, and fail otherwise\n+      real a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end"}, {"sha": "460ddeea4171effe521f5df7accba33e55e3efdc", "filename": "gcc/testsuite/gfortran.dg/g77/intrinsic-unix-erf.f", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fintrinsic-unix-erf.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fintrinsic-unix-erf.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Fintrinsic-unix-erf.f?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -0,0 +1,61 @@\n+c { dg-do run }\n+c  intrinsic-unix-erf.f\n+c\n+c Test Bessel function intrinsics.  \n+c These functions are only available if provided by system\n+c\n+c     David Billinghurst <David.Billinghurst@riotinto.com>\n+c\n+      real x, a\n+      double precision dx, da\n+      logical fail\n+      common /flags/ fail\n+      fail = .false.\n+\n+      x = 0.6\n+      dx = x \n+c     ERF  - error function\n+      a = 0.6038561\n+      da = a\n+      call c_r(ERF(x),a,'ERF(real)')\n+      call c_d(ERF(dx),da,'ERF(double)')\n+      call c_d(DERF(dx),da,'DERF(double)')\n+\n+c     ERFC  - complementary error function\n+      a = 1.0 - a\n+      da = a\n+      call c_r(ERFC(x),a,'ERFC(real)')\n+      call c_d(ERFC(dx),da,'ERFC(double)')\n+      call c_d(DERFC(dx),da,'DERFC(double)')\n+\n+      if ( fail ) call abort()\n+      end\n+\n+      subroutine failure(label)\n+c     Report failure and set flag\n+      character*(*) label\n+      logical fail\n+      common /flags/ fail\n+      write(6,'(a,a,a)') 'Test ',label,' FAILED'\n+      fail = .true.\n+      end\n+\n+      subroutine c_r(a,b,label)\n+c     Check if REAL a equals b, and fail otherwise\n+      real a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0e-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end\n+\n+      subroutine c_d(a,b,label)\n+c     Check if DOUBLE PRECISION a equals b, and fail otherwise\n+      double precision a, b\n+      character*(*) label\n+      if ( abs(a-b) .gt. 1.0d-5 ) then\n+         call failure(label)\n+         write(6,*) 'Got ',a,' expected ', b\n+      end if\n+      end"}, {"sha": "097e356f3a563a2d9b148c0ee05bbbed5a9bc358", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -1,3 +1,14 @@\n+2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n+\tPaul Brook  <paul@codesourcery.com>\n+\n+\t* intrinsics/bessel.c: New file.\n+\t* intrinsics/erf.c: New file.\n+\t* Makefie.am: Add intrinsics/bessel.c and intrinsics/erf.c.\n+\t* configure.ac: Test for C99 Bessel and Error functions.\n+\t* Makefile.in: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\n 2004-08-29  Steven G. Kargl  <kargls@comcast.net>\n \tPaul Brook  <paul@codesourcery.com>\n "}, {"sha": "f07f1b554c7b710bda69bff11c5383eba95e1c46", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -39,11 +39,13 @@ gfor_helper_src= \\\n intrinsics/associated.c \\\n intrinsics/abort.c \\\n intrinsics/args.c \\\n+intrinsics/bessel.c \\\n intrinsics/c99_functions.c \\\n intrinsics/cpu_time.c \\\n intrinsics/cshift0.c \\\n intrinsics/date_and_time.c \\\n intrinsics/env.c \\\n+intrinsics/erf.c \\\n intrinsics/eoshift0.c \\\n intrinsics/eoshift2.c \\\n intrinsics/etime.c \\"}, {"sha": "e83388dc3ab61207fec8f15e2929faad44864470", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -118,14 +118,14 @@ am__objects_31 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n am__objects_32 = backspace.lo close.lo endfile.lo format.lo inquire.lo \\\n \tlist_read.lo lock.lo open.lo read.lo rewind.lo transfer.lo \\\n \tunit.lo unix.lo write.lo\n-am__objects_33 = associated.lo abort.lo args.lo c99_functions.lo \\\n-\tcpu_time.lo cshift0.lo date_and_time.lo env.lo eoshift0.lo \\\n-\teoshift2.lo etime.lo getXid.lo ishftc.lo pack_generic.lo \\\n-\tsize.lo spread_generic.lo string_intrinsics.lo rand.lo \\\n-\trandom.lo reshape_generic.lo reshape_packed.lo \\\n-\tselected_kind.lo system_clock.lo transpose_generic.lo \\\n-\tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\tnormalize.lo\n+am__objects_33 = associated.lo abort.lo args.lo bessel.lo \\\n+\tc99_functions.lo cpu_time.lo cshift0.lo date_and_time.lo \\\n+\tenv.lo erf.lo eoshift0.lo eoshift2.lo etime.lo getXid.lo \\\n+\tishftc.lo pack_generic.lo size.lo spread_generic.lo \\\n+\tstring_intrinsics.lo rand.lo random.lo reshape_generic.lo \\\n+\treshape_packed.lo selected_kind.lo system_clock.lo \\\n+\ttranspose_generic.lo unpack_generic.lo in_pack_generic.lo \\\n+\tin_unpack_generic.lo normalize.lo\n am__objects_34 =\n am__objects_35 = _abs_c4.lo _abs_c8.lo _abs_i4.lo _abs_i8.lo \\\n \t_abs_r4.lo _abs_r8.lo _exp_r4.lo _exp_r8.lo _exp_c4.lo \\\n@@ -311,11 +311,13 @@ gfor_helper_src = \\\n intrinsics/associated.c \\\n intrinsics/abort.c \\\n intrinsics/args.c \\\n+intrinsics/bessel.c \\\n intrinsics/c99_functions.c \\\n intrinsics/cpu_time.c \\\n intrinsics/cshift0.c \\\n intrinsics/date_and_time.c \\\n intrinsics/env.c \\\n+intrinsics/erf.c \\\n intrinsics/eoshift0.c \\\n intrinsics/eoshift2.c \\\n intrinsics/etime.c \\\n@@ -1992,6 +1994,15 @@ args.obj: intrinsics/args.c\n args.lo: intrinsics/args.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o args.lo `test -f 'intrinsics/args.c' || echo '$(srcdir)/'`intrinsics/args.c\n \n+bessel.o: intrinsics/bessel.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel.o `test -f 'intrinsics/bessel.c' || echo '$(srcdir)/'`intrinsics/bessel.c\n+\n+bessel.obj: intrinsics/bessel.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel.obj `if test -f 'intrinsics/bessel.c'; then $(CYGPATH_W) 'intrinsics/bessel.c'; else $(CYGPATH_W) '$(srcdir)/intrinsics/bessel.c'; fi`\n+\n+bessel.lo: intrinsics/bessel.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o bessel.lo `test -f 'intrinsics/bessel.c' || echo '$(srcdir)/'`intrinsics/bessel.c\n+\n c99_functions.o: intrinsics/c99_functions.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o c99_functions.o `test -f 'intrinsics/c99_functions.c' || echo '$(srcdir)/'`intrinsics/c99_functions.c\n \n@@ -2037,6 +2048,15 @@ env.obj: intrinsics/env.c\n env.lo: intrinsics/env.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o env.lo `test -f 'intrinsics/env.c' || echo '$(srcdir)/'`intrinsics/env.c\n \n+erf.o: intrinsics/erf.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o erf.o `test -f 'intrinsics/erf.c' || echo '$(srcdir)/'`intrinsics/erf.c\n+\n+erf.obj: intrinsics/erf.c\n+\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o erf.obj `if test -f 'intrinsics/erf.c'; then $(CYGPATH_W) 'intrinsics/erf.c'; else $(CYGPATH_W) '$(srcdir)/intrinsics/erf.c'; fi`\n+\n+erf.lo: intrinsics/erf.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o erf.lo `test -f 'intrinsics/erf.c' || echo '$(srcdir)/'`intrinsics/erf.c\n+\n eoshift0.o: intrinsics/eoshift0.c\n \t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o eoshift0.o `test -f 'intrinsics/eoshift0.c' || echo '$(srcdir)/'`intrinsics/eoshift0.c\n "}, {"sha": "c3d0d0b53fc46d1f7c99c40ec58221a61abd854d", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -30,6 +30,18 @@\n /* libm includes coshf */\n #undef HAVE_COSHF\n \n+/* libm includes erf */\n+#undef HAVE_ERF\n+\n+/* libm includes erfc */\n+#undef HAVE_ERFC\n+\n+/* libm includes erfcf */\n+#undef HAVE_ERFCF\n+\n+/* libm includes erff */\n+#undef HAVE_ERFF\n+\n /* libm includes expf */\n #undef HAVE_EXPF\n \n@@ -63,6 +75,24 @@\n /* Define to 1 if you have the <inttypes.h> header file. */\n #undef HAVE_INTTYPES_H\n \n+/* libm includes j0 */\n+#undef HAVE_J0\n+\n+/* libm includes j0f */\n+#undef HAVE_J0F\n+\n+/* libm includes j1 */\n+#undef HAVE_J1\n+\n+/* libm includes j1f */\n+#undef HAVE_J1F\n+\n+/* libm includes jn */\n+#undef HAVE_JN\n+\n+/* libm includes jnf */\n+#undef HAVE_JNF\n+\n /* libm includes log10f */\n #undef HAVE_LOG10F\n \n@@ -156,6 +186,24 @@\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n \n+/* libm includes y0 */\n+#undef HAVE_Y0\n+\n+/* libm includes y0f */\n+#undef HAVE_Y0F\n+\n+/* libm includes y1 */\n+#undef HAVE_Y1\n+\n+/* libm includes y1f */\n+#undef HAVE_Y1F\n+\n+/* libm includes yn */\n+#undef HAVE_YN\n+\n+/* libm includes ynf */\n+#undef HAVE_YNF\n+\n /* Define to the address where bug reports for this package should be sent. */\n #undef PACKAGE_BUGREPORT\n "}, {"sha": "b1193086185544d38145e41fcc74a40ac74a0b29", "filename": "libgfortran/configure", "status": "modified", "additions": 1137, "deletions": 0, "changes": 1137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -6895,6 +6895,7 @@ fi\n \n \n # Check for C99 (and other IEEE) math functions\n+# ??? This list seems awful long. Is there a better way to test for these?\n echo \"$as_me:$LINENO: checking for acosf in -lm\" >&5\n echo $ECHO_N \"checking for acosf in -lm... $ECHO_C\" >&6\n if test \"${ac_cv_lib_m_acosf+set}\" = set; then\n@@ -8599,6 +8600,1142 @@ _ACEOF\n \n fi\n \n+echo \"$as_me:$LINENO: checking for erf in -lm\" >&5\n+echo $ECHO_N \"checking for erf in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_erf+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char erf ();\n+int\n+main ()\n+{\n+erf ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_erf=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_erf=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_erf\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_erf\" >&6\n+if test $ac_cv_lib_m_erf = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_ERF 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for erfc in -lm\" >&5\n+echo $ECHO_N \"checking for erfc in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_erfc+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char erfc ();\n+int\n+main ()\n+{\n+erfc ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_erfc=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_erfc=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_erfc\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_erfc\" >&6\n+if test $ac_cv_lib_m_erfc = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_ERFC 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for erfcf in -lm\" >&5\n+echo $ECHO_N \"checking for erfcf in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_erfcf+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char erfcf ();\n+int\n+main ()\n+{\n+erfcf ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_erfcf=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_erfcf=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_erfcf\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_erfcf\" >&6\n+if test $ac_cv_lib_m_erfcf = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_ERFCF 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for erff in -lm\" >&5\n+echo $ECHO_N \"checking for erff in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_erff+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char erff ();\n+int\n+main ()\n+{\n+erff ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_erff=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_erff=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_erff\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_erff\" >&6\n+if test $ac_cv_lib_m_erff = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_ERFF 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for j0 in -lm\" >&5\n+echo $ECHO_N \"checking for j0 in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_j0+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char j0 ();\n+int\n+main ()\n+{\n+j0 ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_j0=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_j0=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_j0\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_j0\" >&6\n+if test $ac_cv_lib_m_j0 = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_J0 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for j0f in -lm\" >&5\n+echo $ECHO_N \"checking for j0f in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_j0f+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char j0f ();\n+int\n+main ()\n+{\n+j0f ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_j0f=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_j0f=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_j0f\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_j0f\" >&6\n+if test $ac_cv_lib_m_j0f = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_J0F 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for j1 in -lm\" >&5\n+echo $ECHO_N \"checking for j1 in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_j1+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char j1 ();\n+int\n+main ()\n+{\n+j1 ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_j1=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_j1=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_j1\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_j1\" >&6\n+if test $ac_cv_lib_m_j1 = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_J1 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for j1f in -lm\" >&5\n+echo $ECHO_N \"checking for j1f in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_j1f+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char j1f ();\n+int\n+main ()\n+{\n+j1f ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_j1f=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_j1f=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_j1f\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_j1f\" >&6\n+if test $ac_cv_lib_m_j1f = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_J1F 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for jn in -lm\" >&5\n+echo $ECHO_N \"checking for jn in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_jn+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char jn ();\n+int\n+main ()\n+{\n+jn ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_jn=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_jn=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_jn\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_jn\" >&6\n+if test $ac_cv_lib_m_jn = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_JN 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for jnf in -lm\" >&5\n+echo $ECHO_N \"checking for jnf in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_jnf+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char jnf ();\n+int\n+main ()\n+{\n+jnf ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_jnf=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_jnf=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_jnf\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_jnf\" >&6\n+if test $ac_cv_lib_m_jnf = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_JNF 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for y0 in -lm\" >&5\n+echo $ECHO_N \"checking for y0 in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_y0+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char y0 ();\n+int\n+main ()\n+{\n+y0 ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_y0=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_y0=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_y0\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_y0\" >&6\n+if test $ac_cv_lib_m_y0 = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_Y0 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for y0f in -lm\" >&5\n+echo $ECHO_N \"checking for y0f in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_y0f+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char y0f ();\n+int\n+main ()\n+{\n+y0f ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_y0f=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_y0f=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_y0f\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_y0f\" >&6\n+if test $ac_cv_lib_m_y0f = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_Y0F 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for y1 in -lm\" >&5\n+echo $ECHO_N \"checking for y1 in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_y1+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char y1 ();\n+int\n+main ()\n+{\n+y1 ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_y1=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_y1=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_y1\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_y1\" >&6\n+if test $ac_cv_lib_m_y1 = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_Y1 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for y1f in -lm\" >&5\n+echo $ECHO_N \"checking for y1f in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_y1f+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char y1f ();\n+int\n+main ()\n+{\n+y1f ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_y1f=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_y1f=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_y1f\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_y1f\" >&6\n+if test $ac_cv_lib_m_y1f = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_Y1F 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for yn in -lm\" >&5\n+echo $ECHO_N \"checking for yn in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_yn+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char yn ();\n+int\n+main ()\n+{\n+yn ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_yn=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_yn=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_yn\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_yn\" >&6\n+if test $ac_cv_lib_m_yn = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_YN 1\n+_ACEOF\n+\n+fi\n+\n+echo \"$as_me:$LINENO: checking for ynf in -lm\" >&5\n+echo $ECHO_N \"checking for ynf in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_ynf+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char ynf ();\n+int\n+main ()\n+{\n+ynf ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_ynf=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_ynf=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_ynf\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_ynf\" >&6\n+if test $ac_cv_lib_m_ynf = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_YNF 1\n+_ACEOF\n+\n+fi\n+\n \n # Let the user override this\n # Check whether --enable-cmath or --disable-cmath was given."}, {"sha": "d1cf0276cc0e41099ac018ad1747e682a65ac8ba", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8525382d986350f38193ca20504631bfadc43ba/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=e8525382d986350f38193ca20504631bfadc43ba", "patch": "@@ -166,6 +166,7 @@ AC_CHECK_LIB([c],[getpid],[AC_DEFINE([HAVE_GETPID],[1],[libc includes getpid])])\n AC_CHECK_LIB([c],[getuid],[AC_DEFINE([HAVE_GETUID],[1],[libc includes getuid])])\n \n # Check for C99 (and other IEEE) math functions\n+# ??? This list seems awful long. Is there a better way to test for these?\n AC_CHECK_LIB([m],[acosf],[AC_DEFINE([HAVE_ACOSF],[1],[libm includes acosf])])\n AC_CHECK_LIB([m],[asinf],[AC_DEFINE([HAVE_ASINF],[1],[libm includes asinf])])\n AC_CHECK_LIB([m],[atan2f],[AC_DEFINE([HAVE_ATAN2F],[1],[libm includes atan2f])])\n@@ -190,6 +191,22 @@ AC_CHECK_LIB([m],[sinhf],[AC_DEFINE([HAVE_SINHF],[1],[libm includes sinhf])])\n AC_CHECK_LIB([m],[sqrtf],[AC_DEFINE([HAVE_SQRTF],[1],[libm includes sqrtf])])\n AC_CHECK_LIB([m],[tanf],[AC_DEFINE([HAVE_TANF],[1],[libm includes tanf])])\n AC_CHECK_LIB([m],[tanhf],[AC_DEFINE([HAVE_TANHF],[1],[libm includes tanhf])])\n+AC_CHECK_LIB([m],[erf],[AC_DEFINE([HAVE_ERF],[1],[libm includes erf])])\n+AC_CHECK_LIB([m],[erfc],[AC_DEFINE([HAVE_ERFC],[1],[libm includes erfc])])\n+AC_CHECK_LIB([m],[erfcf],[AC_DEFINE([HAVE_ERFCF],[1],[libm includes erfcf])])\n+AC_CHECK_LIB([m],[erff],[AC_DEFINE([HAVE_ERFF],[1],[libm includes erff])])\n+AC_CHECK_LIB([m],[j0],[AC_DEFINE([HAVE_J0],[1],[libm includes j0])])\n+AC_CHECK_LIB([m],[j0f],[AC_DEFINE([HAVE_J0F],[1],[libm includes j0f])])\n+AC_CHECK_LIB([m],[j1],[AC_DEFINE([HAVE_J1],[1],[libm includes j1])])\n+AC_CHECK_LIB([m],[j1f],[AC_DEFINE([HAVE_J1F],[1],[libm includes j1f])])\n+AC_CHECK_LIB([m],[jn],[AC_DEFINE([HAVE_JN],[1],[libm includes jn])])\n+AC_CHECK_LIB([m],[jnf],[AC_DEFINE([HAVE_JNF],[1],[libm includes jnf])])\n+AC_CHECK_LIB([m],[y0],[AC_DEFINE([HAVE_Y0],[1],[libm includes y0])])\n+AC_CHECK_LIB([m],[y0f],[AC_DEFINE([HAVE_Y0F],[1],[libm includes y0f])])\n+AC_CHECK_LIB([m],[y1],[AC_DEFINE([HAVE_Y1],[1],[libm includes y1])])\n+AC_CHECK_LIB([m],[y1f],[AC_DEFINE([HAVE_Y1F],[1],[libm includes y1f])])\n+AC_CHECK_LIB([m],[yn],[AC_DEFINE([HAVE_YN],[1],[libm includes yn])])\n+AC_CHECK_LIB([m],[ynf],[AC_DEFINE([HAVE_YNF],[1],[libm includes ynf])])\n \n # Let the user override this\n AC_ARG_ENABLE(cmath,"}]}