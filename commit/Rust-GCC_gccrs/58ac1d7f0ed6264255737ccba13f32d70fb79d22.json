{"sha": "58ac1d7f0ed6264255737ccba13f32d70fb79d22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThhYzFkN2YwZWQ2MjY0MjU1NzM3Y2NiYTEzZjMyZDcwZmI3OWQyMg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2003-06-12T03:24:16Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-06-12T03:24:16Z"}, "message": "acinclude.m4 (GLIBCPP_ENABLE_CSTDIO): Simplify.\n\n\n2003-06-11  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* acinclude.m4 (GLIBCPP_ENABLE_CSTDIO): Simplify.\n\t* aclocal.m4: Regenerate.\n\t* Makefile.am (SUBDIRS): Remove libio.\n\t* Makefile.in: Regenerate.\n\t* configure.in: Same.\n\t* configure: Regenerate.\n\t* config/io/basic_file_libio.cc: Remove.\n\t* config/io/basic_file_libio.h: Remove.\n\t* config/io/c_io_libio_codecvt.c: Remove.\n\t* config/io/c_io_libio.h: Remove.\n\t* libio/*: Remove.\n\t* src/Makefile.am: Same.\n\t* src/Makefile.in: Regenerate.\n\t* docs/html/configopts.html: Edits.\n\t* docs/html/explanations.html: Edits.\n\nFrom-SVN: r67813", "tree": {"sha": "ad6068da56e44aec81658b029e5bb40cc4a77c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad6068da56e44aec81658b029e5bb40cc4a77c03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58ac1d7f0ed6264255737ccba13f32d70fb79d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ac1d7f0ed6264255737ccba13f32d70fb79d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58ac1d7f0ed6264255737ccba13f32d70fb79d22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58ac1d7f0ed6264255737ccba13f32d70fb79d22/comments", "author": null, "committer": null, "parents": [{"sha": "3ad93a347592606340d535571e43943199cc3ab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad93a347592606340d535571e43943199cc3ab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad93a347592606340d535571e43943199cc3ab8"}], "stats": {"total": 13609, "additions": 1459, "deletions": 12150}, "files": [{"sha": "49d6adeffacc7d25f7c2a32e5998448bb59dadf9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -1,3 +1,21 @@\n+2003-06-11  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* acinclude.m4 (GLIBCPP_ENABLE_CSTDIO): Simplify.\n+\t* aclocal.m4: Regenerate.\n+\t* Makefile.am (SUBDIRS): Remove libio.\n+\t* Makefile.in: Regenerate.\n+\t* configure.in: Same.\n+\t* configure: Regenerate.\n+\t* config/io/basic_file_libio.cc: Remove.\n+\t* config/io/basic_file_libio.h: Remove.\t\n+\t* config/io/c_io_libio_codecvt.c: Remove.\n+\t* config/io/c_io_libio.h: Remove.\t\n+\t* libio/*: Remove.\n+\t* src/Makefile.am: Same.\n+\t* src/Makefile.in: Regenerate.\n+\t* docs/html/configopts.html: Edits.\t\n+\t* docs/html/explanations.html: Edits.\n+\t\n 2003-06-11  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* include/bits/stl_alloc.h (__debug_alloc): Move out."}, {"sha": "d17784bdea3ca39b63907fcfd5c4a4a126d421be", "filename": "libstdc++-v3/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.am?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -25,7 +25,7 @@\n AUTOMAKE_OPTIONS = 1.3 cygnus\n MAINT_CHARSET = latin1\n \n-SUBDIRS = include libio libmath libsupc++ src po testsuite \n+SUBDIRS = include libmath libsupc++ src po testsuite \n \n mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n "}, {"sha": "37efa7c29fc2eb728544939b2c292b61fb66187c", "filename": "libstdc++-v3/Makefile.in", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -1,6 +1,6 @@\n-# Makefile.in generated automatically by automake 1.4-p4 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n-# Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n+# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -70,7 +70,6 @@ AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -97,7 +96,6 @@ GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n LIBMATHOBJS = @LIBMATHOBJS@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n@@ -128,6 +126,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_builddir = @glibcpp_builddir@\n@@ -139,14 +138,13 @@ glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n gxx_include_dir = @gxx_include_dir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n \n AUTOMAKE_OPTIONS = 1.3 cygnus\n MAINT_CHARSET = latin1\n \n-SUBDIRS = include libio libmath libsupc++ src po testsuite \n+SUBDIRS = include libmath libsupc++ src po testsuite \n \n mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n \n@@ -170,7 +168,45 @@ MULTICLEAN = true\n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS =  \t\"AR_FLAGS=$(AR_FLAGS)\" \t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \t\"CFLAGS=$(CFLAGS)\" \t\"CXXFLAGS=$(CXXFLAGS)\" \t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \t\"INSTALL=$(INSTALL)\" \t\"INSTALL_DATA=$(INSTALL_DATA)\" \t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \t\"LDFLAGS=$(LDFLAGS)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \t\"MAKE=$(MAKE)\" \t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \t\"SHELL=$(SHELL)\" \t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \t\"exec_prefix=$(exec_prefix)\" \t\"infodir=$(infodir)\" \t\"libdir=$(libdir)\" \t\"includedir=$(includedir)\" \t\"prefix=$(prefix)\" \t\"tooldir=$(tooldir)\" \t\"gxx_include_dir=$(gxx_include_dir)\" \t\"AR=$(AR)\" \t\"AS=$(AS)\" \t\"LD=$(LD)\" \t\"LIBCFLAGS=$(LIBCFLAGS)\" \t\"PICFLAG=$(PICFLAG)\" \t\"RANLIB=$(RANLIB)\" \t\"NM=$(NM)\" \t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \t\"DESTDIR=$(DESTDIR)\" \t\"WERROR=$(WERROR)\" \n+AM_MAKEFLAGS = \\\n+\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n+\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n+\t\"CC_FOR_TARGET=$(CC_FOR_TARGET)\" \\\n+\t\"CFLAGS=$(CFLAGS)\" \\\n+\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n+\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n+\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n+\t\"INSTALL=$(INSTALL)\" \\\n+\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n+\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n+\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n+\t\"LDFLAGS=$(LDFLAGS)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n+\t\"MAKE=$(MAKE)\" \\\n+\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n+\t\"SHELL=$(SHELL)\" \\\n+\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n+\t\"exec_prefix=$(exec_prefix)\" \\\n+\t\"infodir=$(infodir)\" \\\n+\t\"libdir=$(libdir)\" \\\n+\t\"includedir=$(includedir)\" \\\n+\t\"prefix=$(prefix)\" \\\n+\t\"tooldir=$(tooldir)\" \\\n+\t\"gxx_include_dir=$(gxx_include_dir)\" \\\n+\t\"AR=$(AR)\" \\\n+\t\"AS=$(AS)\" \\\n+\t\"LD=$(LD)\" \\\n+\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n+\t\"PICFLAG=$(PICFLAG)\" \\\n+\t\"RANLIB=$(RANLIB)\" \\\n+\t\"NM=$(NM)\" \\\n+\t\"NM_FOR_BUILD=$(NM_FOR_BUILD)\" \\\n+\t\"NM_FOR_TARGET=$(NM_FOR_TARGET)\" \\\n+\t\"DESTDIR=$(DESTDIR)\" \\\n+\t\"WERROR=$(WERROR)\" \n \n \n # Subdir rules rely on $(FLAGS_TO_PASS)\n@@ -185,7 +221,7 @@ mkcheck.in testsuite_flags.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n@@ -199,7 +235,7 @@ Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status\n $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ configure.in  acinclude.m4\n \tcd $(srcdir) && $(ACLOCAL)\n \n-config.status: $(srcdir)/configure.in $(CONFIG_STATUS_DEPENDENCIES)\n+config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n \t$(SHELL) ./config.status --recheck\n $(srcdir)/configure: @MAINTAINER_MODE_TRUE@$(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)\n \tcd $(srcdir) && $(AUTOCONF)\n@@ -272,7 +308,7 @@ maintainer-clean-recursive:\n \tdot_seen=no; \\\n \trev=''; list='$(SUBDIRS)'; for subdir in $$list; do \\\n \t  rev=\"$$subdir $$rev\"; \\\n-\t  test \"$$subdir\" = \".\" && dot_seen=yes; \\\n+\t  test \"$$subdir\" != \".\" || dot_seen=yes; \\\n \tdone; \\\n \ttest \"$$dot_seen\" = \"no\" && rev=\". $$rev\"; \\\n \ttarget=`echo $@ | sed s/-recursive//`; \\"}, {"sha": "9981eed63ae84a96a8b9f42df71a7dd863e6db6f", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -206,8 +206,6 @@ AC_DEFUN(GLIBCPP_CONFIGURE, [\n   need_libmath=no\n   enable_wchar_t=no\n   #enable_debug=no\n-  #need_libio=no\n-  #need_wlibio=no\n   #glibcpp_pch_comp=no\n   #enable_cheaders=c\n   #c_compatibility=no\n@@ -1331,10 +1329,9 @@ AC_DEFUN(GLIBCPP_ENABLE_CLOCALE, [\n \n \n dnl\n-dnl Check for which I/O library to use:  libio, or something specific.\n+dnl Check for which I/O library to use:  stdio, or something specific.\n dnl\n dnl GLIBCPP_ENABLE_CSTDIO\n-dnl --enable-cstdio=libio sets config/io/c_io_libio.h and friends\n dnl\n dnl default is stdio\n dnl\n@@ -1353,72 +1350,12 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n \n   dnl Check if a valid I/O package\n   case x${enable_cstdio_flag} in\n-    xlibio)\n-      CSTDIO_H=config/io/c_io_libio.h\n-      BASIC_FILE_H=config/io/basic_file_libio.h\n-      BASIC_FILE_CC=config/io/basic_file_libio.cc\n-      AC_MSG_RESULT(libio)\n-\n-      # see if we are on a system with libio native (ie, linux)\n-      AC_CHECK_HEADER(libio.h,  has_libio=yes, has_libio=no)\n-\n-      # Need to check and see what version of glibc is being used. If\n-      # it's not glibc-2.2 or higher, then we'll need to go ahead and\n-      # compile most of libio for linux systems.\n-      if test x$has_libio = x\"yes\"; then\n-        case \"$target\" in\n-          *-*-linux*)\n-              AC_MSG_CHECKING([for glibc version >= 2.2])\n-              AC_EGREP_CPP([ok], [\n-            #include <features.h>\n-              #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)\n-                    ok\n-              #endif\n-              ], glibc_satisfactory=yes, glibc_satisfactory=no)\n-              AC_MSG_RESULT($glibc_satisfactory)\n-            ;;\n-        esac\n-\n-        # XXX at the moment, admit defeat and force the recompilation\n-        # XXX of glibc even on glibc-2.2 systems, because libio is not synched.\n-        glibc_satisfactory=no\n-\n-        if test x$glibc_satisfactory = x\"yes\"; then\n-           need_libio=no\n-           need_wlibio=no\n-        else\n-           need_libio=yes\n-           # bkoz XXX need to add checks to enable this\n-           # pme XXX here's a first pass at such a check\n-           if test x$enable_c_mbchar != xno; then\n-              need_wlibio=yes\n-           else\n-              need_wlibio=no\n-           fi\n-        fi\n-\n-      else\n-         # Using libio, but <libio.h> doesn't exist on the target system. . .\n-         need_libio=yes\n-         # bkoz XXX need to add checks to enable this\n-         # pme XXX here's a first pass at such a check\n-         if test x$enable_c_mbchar != xno; then\n-             need_wlibio=yes\n-         else\n-             need_wlibio=no\n-         fi\n-      fi\n-      ;;\n     xstdio | x | xno | xnone | xyes)\n       # default\n       CSTDIO_H=config/io/c_io_stdio.h\n       BASIC_FILE_H=config/io/basic_file_stdio.h\n       BASIC_FILE_CC=config/io/basic_file_stdio.cc\n       AC_MSG_RESULT(stdio)\n-\n-      # We're not using stdio.\n-      need_libio=no\n-      need_wlibio=no\n       ;;\n     *)\n       echo \"$enable_cstdio is an unknown io package\" 1>&2\n@@ -1428,22 +1365,6 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n   AC_SUBST(CSTDIO_H)\n   AC_SUBST(BASIC_FILE_H)\n   AC_SUBST(BASIC_FILE_CC)\n-\n-  # 2000-08-04 bkoz hack\n-  CCODECVT_C=config/io/c_io_libio_codecvt.c\n-  AC_SUBST(CCODECVT_C)\n-  # 2000-08-04 bkoz hack\n-\n-  AM_CONDITIONAL(GLIBCPP_BUILD_LIBIO,\n-                 test \"$need_libio\" = yes || test \"$need_wlibio\" = yes)\n-  AM_CONDITIONAL(GLIBCPP_NEED_LIBIO, test \"$need_libio\" = yes)\n-  AM_CONDITIONAL(GLIBCPP_NEED_WLIBIO, test \"$need_wlibio\" = yes)\n-  if test \"$need_libio\" = yes || test \"$need_wlibio\" = yes; then\n-    libio_la=../libio/libio.la\n-  else\n-    libio_la=\n-  fi\n-  AC_SUBST(libio_la)\n ])\n \n \n@@ -1859,7 +1780,6 @@ dnl\n dnl TOPLEVEL_INCLUDES\n dnl LIBMATH_INCLUDES\n dnl LIBSUPCXX_INCLUDES\n-dnl LIBIO_INCLUDES\n dnl\n dnl GLIBCPP_EXPORT_INCLUDES\n AC_DEFUN(GLIBCPP_EXPORT_INCLUDES, [\n@@ -1875,11 +1795,6 @@ AC_DEFUN(GLIBCPP_EXPORT_INCLUDES, [\n \n   LIBSUPCXX_INCLUDES='-I$(top_srcdir)/libsupc++'\n \n-  if test x\"$need_libio\" = xyes; then\n-    LIBIO_INCLUDES='-I$(top_builddir)/libio -I$(top_srcdir)/libio'\n-    AC_SUBST(LIBIO_INCLUDES)\n-  fi\n-\n   # Now, export this to all the little Makefiles....\n   AC_SUBST(GLIBCPP_INCLUDES)\n   AC_SUBST(TOPLEVEL_INCLUDES)"}, {"sha": "c56ac1ac99f10a8a54e21f281e0e110c93720db2", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -218,8 +218,6 @@ AC_DEFUN(GLIBCPP_CONFIGURE, [\n   need_libmath=no\n   enable_wchar_t=no\n   #enable_debug=no\n-  #need_libio=no\n-  #need_wlibio=no\n   #glibcpp_pch_comp=no\n   #enable_cheaders=c\n   #c_compatibility=no\n@@ -1343,10 +1341,9 @@ AC_DEFUN(GLIBCPP_ENABLE_CLOCALE, [\n \n \n dnl\n-dnl Check for which I/O library to use:  libio, or something specific.\n+dnl Check for which I/O library to use:  stdio, or something specific.\n dnl\n dnl GLIBCPP_ENABLE_CSTDIO\n-dnl --enable-cstdio=libio sets config/io/c_io_libio.h and friends\n dnl\n dnl default is stdio\n dnl\n@@ -1365,72 +1362,12 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n \n   dnl Check if a valid I/O package\n   case x${enable_cstdio_flag} in\n-    xlibio)\n-      CSTDIO_H=config/io/c_io_libio.h\n-      BASIC_FILE_H=config/io/basic_file_libio.h\n-      BASIC_FILE_CC=config/io/basic_file_libio.cc\n-      AC_MSG_RESULT(libio)\n-\n-      # see if we are on a system with libio native (ie, linux)\n-      AC_CHECK_HEADER(libio.h,  has_libio=yes, has_libio=no)\n-\n-      # Need to check and see what version of glibc is being used. If\n-      # it's not glibc-2.2 or higher, then we'll need to go ahead and\n-      # compile most of libio for linux systems.\n-      if test x$has_libio = x\"yes\"; then\n-        case \"$target\" in\n-          *-*-linux*)\n-              AC_MSG_CHECKING([for glibc version >= 2.2])\n-              AC_EGREP_CPP([ok], [\n-            #include <features.h>\n-              #if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)\n-                    ok\n-              #endif\n-              ], glibc_satisfactory=yes, glibc_satisfactory=no)\n-              AC_MSG_RESULT($glibc_satisfactory)\n-            ;;\n-        esac\n-\n-        # XXX at the moment, admit defeat and force the recompilation\n-        # XXX of glibc even on glibc-2.2 systems, because libio is not synched.\n-        glibc_satisfactory=no\n-\n-        if test x$glibc_satisfactory = x\"yes\"; then\n-           need_libio=no\n-           need_wlibio=no\n-        else\n-           need_libio=yes\n-           # bkoz XXX need to add checks to enable this\n-           # pme XXX here's a first pass at such a check\n-           if test x$enable_c_mbchar != xno; then\n-              need_wlibio=yes\n-           else\n-              need_wlibio=no\n-           fi\n-        fi\n-\n-      else\n-         # Using libio, but <libio.h> doesn't exist on the target system. . .\n-         need_libio=yes\n-         # bkoz XXX need to add checks to enable this\n-         # pme XXX here's a first pass at such a check\n-         if test x$enable_c_mbchar != xno; then\n-             need_wlibio=yes\n-         else\n-             need_wlibio=no\n-         fi\n-      fi\n-      ;;\n     xstdio | x | xno | xnone | xyes)\n       # default\n       CSTDIO_H=config/io/c_io_stdio.h\n       BASIC_FILE_H=config/io/basic_file_stdio.h\n       BASIC_FILE_CC=config/io/basic_file_stdio.cc\n       AC_MSG_RESULT(stdio)\n-\n-      # We're not using stdio.\n-      need_libio=no\n-      need_wlibio=no\n       ;;\n     *)\n       echo \"$enable_cstdio is an unknown io package\" 1>&2\n@@ -1440,22 +1377,6 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n   AC_SUBST(CSTDIO_H)\n   AC_SUBST(BASIC_FILE_H)\n   AC_SUBST(BASIC_FILE_CC)\n-\n-  # 2000-08-04 bkoz hack\n-  CCODECVT_C=config/io/c_io_libio_codecvt.c\n-  AC_SUBST(CCODECVT_C)\n-  # 2000-08-04 bkoz hack\n-\n-  AM_CONDITIONAL(GLIBCPP_BUILD_LIBIO,\n-                 test \"$need_libio\" = yes || test \"$need_wlibio\" = yes)\n-  AM_CONDITIONAL(GLIBCPP_NEED_LIBIO, test \"$need_libio\" = yes)\n-  AM_CONDITIONAL(GLIBCPP_NEED_WLIBIO, test \"$need_wlibio\" = yes)\n-  if test \"$need_libio\" = yes || test \"$need_wlibio\" = yes; then\n-    libio_la=../libio/libio.la\n-  else\n-    libio_la=\n-  fi\n-  AC_SUBST(libio_la)\n ])\n \n \n@@ -1871,7 +1792,6 @@ dnl\n dnl TOPLEVEL_INCLUDES\n dnl LIBMATH_INCLUDES\n dnl LIBSUPCXX_INCLUDES\n-dnl LIBIO_INCLUDES\n dnl\n dnl GLIBCPP_EXPORT_INCLUDES\n AC_DEFUN(GLIBCPP_EXPORT_INCLUDES, [\n@@ -1887,11 +1807,6 @@ AC_DEFUN(GLIBCPP_EXPORT_INCLUDES, [\n \n   LIBSUPCXX_INCLUDES='-I$(top_srcdir)/libsupc++'\n \n-  if test x\"$need_libio\" = xyes; then\n-    LIBIO_INCLUDES='-I$(top_builddir)/libio -I$(top_srcdir)/libio'\n-    AC_SUBST(LIBIO_INCLUDES)\n-  fi\n-\n   # Now, export this to all the little Makefiles....\n   AC_SUBST(GLIBCPP_INCLUDES)\n   AC_SUBST(TOPLEVEL_INCLUDES)"}, {"sha": "3ec05679ab1380122b8fdbf63d095bfc48b5995f", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -1,4 +1,4 @@\n-/* config.h.in.  Generated automatically from configure.in by autoheader 2.13.  */\n+/* config.h.in.  Generated automatically from configure.in by autoheader.  */\n \n /* Define if you have a working `mmap' system call.  */\n #undef HAVE_MMAP\n@@ -749,6 +749,9 @@\n /* Define if you have the <nan.h> header file.  */\n #undef HAVE_NAN_H\n \n+/* Define if you have the <stdlib.h> header file.  */\n+#undef HAVE_STDLIB_H\n+\n /* Define if you have the <sys/filio.h> header file.  */\n #undef HAVE_SYS_FILIO_H\n "}, {"sha": "60eb006a8474a6421b165f56450e6fe1bf461c23", "filename": "libstdc++-v3/config/io/basic_file_libio.cc", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.cc?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,194 +0,0 @@\n-// Wrapper of C-language FILE struct -*- C++ -*-\n-\n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//\n-// ISO C++ 14882: 27.8  File-based streams\n-//\n-\n-#include <bits/basic_file.h>\n-\n-namespace std \n-{\n-  // __basic_file<char> definitions\n-  __basic_file<char>::__basic_file(__c_lock* __lock)\n-  {\n-#ifdef _IO_MTSAFE_IO\n-    _lock = __lock;\n-#endif\n-    // Don't set the orientation of the stream when initializing.\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-    _IO_no_init(this, 0, 0, &_M_wfile, 0);\n-#else /* !defined(_GLIBCPP_USE_WCHAR_T) */\n-    _IO_no_init(this, 0, 0, NULL, 0);\n-#endif /* !defined(_GLIBCPP_USE_WCHAR_T) */\n-    _IO_JUMPS((_IO_FILE_plus *) this) = &_IO_file_jumps;\n-    _IO_file_init((_IO_FILE_plus*)this);\n-  }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::overflow(int __c) \n-  { return _IO_file_overflow(this, __c); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::underflow()  \n-  { return _IO_file_underflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::uflow()  \n-  { return _IO_default_uflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::pbackfail(int __c) \n-  { return _IO_default_pbackfail(this, __c); }\n- \n-  streamsize \n-  __basic_file<char>::xsputn(const char* __s, streamsize __n)\n-  { return _IO_file_xsputn(this, __s, __n); }\n-\n-  streamoff\n-  __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t      ios_base::openmode __mode)\n-  { return _IO_file_seekoff(this, __off, __way, __mode); }\n-\n-  streamoff\n-  __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode)\n-  { return _IO_file_seekoff(this, __pos, ios_base::beg, __mode); }\n-\n- // NB: Unused.\n-  streambuf* \n-  __basic_file<char>::setbuf(char* __b, int __len)\n-  { return (streambuf*) _IO_file_setbuf(this,__b, __len); }\n-\n- int \n-  __basic_file<char>::sync()\n-  { return _IO_file_sync(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<char>::doallocate() \n-  { return _IO_file_doallocate(this); }\n-\n-  // __basic_file<wchar_t> definitions\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  __basic_file<wchar_t>::__basic_file(__c_lock* __lock)\n-  {\n-#ifdef _IO_MTSAFE_IO\n-    _lock = __lock;\n-#endif\n-    // Don't set the orientation of the stream when initializing.\n-    _IO_no_init(this, 0, 0, &_M_wfile, &_IO_wfile_jumps);\n-    _IO_JUMPS((_IO_FILE_plus *) this) = &_IO_wfile_jumps;\n-    _IO_file_init((_IO_FILE_plus*)this);\n-\n-    // In addition, need to allocate the buffer...\n-    _IO_wdoallocbuf(this);\n-    // Setup initial positions for this buffer...\n-    //    if (!(_flags & _IO_NO_READS))\n-    _IO_wsetg(this, _wide_data->_IO_buf_base, _wide_data->_IO_buf_base,\n-\t      _wide_data->_IO_buf_base);\n-    //    if (!(_flags & _IO_NO_WRITES))\n-    _IO_wsetp(this, _wide_data->_IO_buf_base, _wide_data->_IO_buf_base);\n-    \n-    // Setup codecvt bits...\n-    _codecvt = &__c_libio_codecvt;\n-    \n-    // Do the same for narrow bits...\n-    if (_IO_write_base == NULL)\n-      {\n-\t_IO_doallocbuf(this);\n-\t//      if (!(_flags & _IO_NO_READS))\n-\t_IO_setg(this, _IO_buf_base, _IO_buf_base, _IO_buf_base);\n-\t//    if (!(_flags & _IO_NO_WRITES))\n-\t_IO_setp(this, _IO_buf_base, _IO_buf_base);\n-      }\n-  }\n-\n- int \n-  __basic_file<wchar_t>::overflow(int __c) \n-  { return _IO_wfile_overflow(this, __c); }\n-\n-  int \n-  __basic_file<wchar_t>::underflow()  \n-  { return _IO_wfile_underflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<wchar_t>::uflow()  \n-  { return _IO_wdefault_uflow(this); }\n-\n-  // NB: Unused.\n-  int \n-  __basic_file<wchar_t>::pbackfail(int __c) \n-  { return _IO_wdefault_pbackfail(this, __c); }\n-\n-  streamsize \n-  __basic_file<wchar_t>::xsputn(const wchar_t* __s, streamsize __n)\n-  { return _IO_wfile_xsputn(this, __s, __n); }\n-  \n-  streamoff\n-  __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\t ios_base::openmode __mode)\n-  { return _IO_wfile_seekoff(this, __off, __way, __mode); }\n-\n-  streamoff\n-  __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode)\n-  { return _IO_wfile_seekoff(this, __pos, ios_base::beg, __mode); }\n-\n-   streambuf* \n-  __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len)\n-  { return (streambuf*) _IO_wfile_setbuf(this,__b, __len); }\n-\n-   int \n-  __basic_file<wchar_t>::sync()\n-  { return _IO_wfile_sync(this); }\n-\n-  int \n-  __basic_file<wchar_t>::doallocate() \n-  { return _IO_wfile_doallocate(this); }\n-#endif\n-\n-  // Need to instantiate base class here for type-info bits, etc\n-  template struct __basic_file_base<char>;\n-  template class __basic_file<char>;\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template struct __basic_file_base<wchar_t>;\n-  template class __basic_file<wchar_t>;\n-#endif\n-}  // namespace std\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "959ecf948d0c97784ea6c09caefbd5d9a690b76a", "filename": "libstdc++-v3/config/io/basic_file_libio.h", "status": "removed", "additions": 0, "deletions": 528, "changes": 528, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fbasic_file_libio.h?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,528 +0,0 @@\n-// Wrapper of C-language FILE struct -*- C++ -*-\n-\n-// Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-//\n-// ISO C++ 14882: 27.8  File-based streams\n-//\n-\n-/** @file basic_file.h\n- *  This is an internal header file, included by other library headers.\n- *  You should not attempt to use it directly.\n- */\n-\n-#ifndef _CPP_BASIC_FILE\n-#define _CPP_BASIC_FILE 1\n-\n-#pragma GCC system_header\n-\n-#include <bits/c++config.h>\n-#include <ios>\n-#include <libioP.h>\n-\n-namespace std \n-{\n-  // Ulrich is going to make some detailed comment here, explaining\n-  // all this unpleasantness, providing detailed performance analysis\n-  // as to why we have to do all this lame vtable hacking instead of a\n-  // sane, function-based approach. This verbiage will provide a clear\n-  // and detailed description of the whole object-layout,\n-  // vtable-swapping, sordid history of this hack.\n-  template<typename _CharT>\n-    struct __basic_file_base: public __c_file\n-    {\n-      virtual \n-      ~__basic_file_base() { };\n-\n-      virtual int \n-      overflow(int __c = EOF) = 0;\n-\n-      virtual int \n-      underflow() = 0;\n-\n-      virtual int \n-      uflow() = 0;\n-\n-      virtual int \n-      pbackfail(int __c) = 0;\n-\n-      virtual streamsize \n-      xsputn(const _CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamsize \n-      xsgetn(_CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamoff\n-      seekoff(streamoff __off, ios_base::seekdir __way,\n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n-\n-      virtual streamoff\n-      seekpos(streamoff __pos, \n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out) = 0;\n-\n-      virtual streambuf* \n-      setbuf(_CharT* __b, int __len) = 0;\n-\n-      virtual int \n-      sync() = 0;\n-\n-      virtual int \n-      doallocate() = 0;\n-\n-      virtual streamsize \n-      sys_read(_CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamsize \n-      sys_write(const _CharT* __s, streamsize __n) = 0;\n-\n-      virtual streamoff\n-      sys_seek(streamoff __off, ios_base::seekdir __way) = 0;\n-\n-      virtual int \n-      sys_close() = 0;\n-\n-      virtual int \n-      sys_stat(void* __v) = 0;\n-\n-      virtual int \n-      showmanyc() = 0;\n-\n-      virtual void \n-      imbue(void* __v) = 0;\n-    };\n-\n-  // Some of these member functions are based on libio/filebuf.cc.\n-  // Also note that the order and number of virtual functions has to precisely\n-  // match the order and number in the _IO_jump_t struct defined in libioP.h.\n-  template<typename _CharT>\n-    class __basic_file: public __basic_file_base<_CharT>\n-    {\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-      __c_wfile\t_M_wfile;\n-# endif\n-\n-    public:\n-      __basic_file(__c_lock* __lock = 0);\n-      \n-      void \n-      _M_open_mode(ios_base::openmode __mode, int& __p_mode, int& __rw_mode, \n-\t\t   char* __c_mode);\n-      \n-      // Equivalent to the normal fopen function.\n-      __basic_file* \n-      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);\n-\n-      // Used for opening the standard streams, cin, cout, cerr, clog,\n-      // and their wide-stream equivalents. Instead of calling open, it\n-      // just sets\n-      //  - for libio:  __c_file->_fileno and the respective _flags bits\n-      //  - for stdio:  _M_cfile = __file and some internal flags\n-      // and returns.\n-      __basic_file*\n-      sys_open(__c_file* __file, ios_base::openmode __mode);\n-\n-      __basic_file*\n-      sys_open(int __fd, ios_base::openmode __mode, bool __del);\n-\n-      _CharT\n-      sys_getc();\n-\n-      _CharT\n-      sys_ungetc(_CharT);\n-\n-      __basic_file* \n-      close(); \n-\n-      bool \n-      is_open() const;\n-\n-      int \n-      fd();\n-\n-      // NB: Must match FILE specific jump table starting here--this\n-      // means all virtual functions starting with the dtor must match,\n-      // slot by slot. For glibc-based dystems, this means the _IO_FILE\n-      // as the FILE struct and _IO_jump_t as the jump table.\n-      virtual \n-      ~__basic_file(); // Takes the place of __finish.\n-\n-      virtual int \n-      overflow(int __c = EOF);\n-\n-      virtual int \n-      underflow();\n-\n-      virtual int \n-      uflow();\n-\n-      virtual int \n-      pbackfail(int __c);\n-\n-      // A complex \"write\" function that sets all of __c_file's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamsize \n-      xsputn(const _CharT* __s, streamsize __n);\n-\n-      // A complex \"read\" function that sets all of __c_file's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamsize \n-      xsgetn(_CharT* __s, streamsize __n);\n-\n-      // A complex \"seekoff\" function that sets all of __c_file's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamoff\n-      seekoff(streamoff __off, ios_base::seekdir __way,\n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n-\n-      // A complex \"seekpos\" function that sets all of __c_file's\n-      // pointers and associated data members correctly and manages its\n-      // relation to the external byte sequence.\n-      virtual streamoff\n-      seekpos(streamoff __pos, \n-\t      ios_base::openmode __mode = ios_base::in | ios_base::out);\n-\n-      virtual streambuf* \n-      setbuf(_CharT* __b, int __len);\n-\n-      virtual int \n-      sync();\n-\n-      virtual int \n-      doallocate();\n-\n-      // A simple read function for the external byte sequence, that\n-      // does no mucking around with or setting of the pointers or flags\n-      // in __c_file.\n-      virtual streamsize \n-      sys_read(_CharT* __s, streamsize __n);\n-\n-      // A simple write function for the external byte sequence, that\n-      // does no mucking around with or setting of the pointers or flags\n-      // in __c_file.\n-      virtual streamsize \n-      sys_write(const _CharT* __s, streamsize __n);\n-\n-      // A simple seek function for the external byte sequence, that\n-      // does no mucking around with or setting of the pointers or flags\n-      // in __c_file.\n-      virtual streamoff\n-      sys_seek(streamoff __off, ios_base::seekdir __way);\n-\n-      virtual int \n-      sys_close();\n-\n-      virtual int \n-      sys_stat(void* __v);\n-\n-      virtual int \n-      showmanyc();\n-\n-      virtual void \n-      imbue(void* __v);\n-    };\n-\n-  // __basic_file<char> specializations\n-  template<>\n-    __basic_file<char>::__basic_file(__c_lock* __lock);\n-\n-  template<>\n-    int \n-    __basic_file<char>::overflow(int __c);\n-\n-  template<>\n-    int \n-    __basic_file<char>::underflow();\n-\n-  template<>\n-    int \n-    __basic_file<char>::uflow();\n-\n-  template<>\n-    int \n-    __basic_file<char>::pbackfail(int __c);\n-\n-  template<>\n-    streamsize \n-    __basic_file<char>::xsputn(const char* __s, streamsize __n);\n-\n-  template<>\n-    streamoff\n-    __basic_file<char>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\tios_base::openmode __mode);\n-\n-  template<>\n-    streamoff\n-    __basic_file<char>::seekpos(streamoff __pos, ios_base::openmode __mode);\n-\n-  template<>\n-    streambuf* \n-    __basic_file<char>::setbuf(char* __b, int __len);\n-\n-  template<>\n-    int \n-    __basic_file<char>::sync();\n-\n-  template<>\n-    int \n-    __basic_file<char>::doallocate();\n-\n-  // __basic_file<wchar_t> specializations\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  template<>\n-    __basic_file<wchar_t>::__basic_file(__c_lock* __lock);\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::overflow(int __c);\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::underflow();\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::uflow();\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::pbackfail(int __c);\n-\n-  template<>\n-    streamsize \n-    __basic_file<wchar_t>::xsputn(const wchar_t* __s, streamsize __n);\n-\n-  template<>\n-    streamoff\n-    __basic_file<wchar_t>::seekoff(streamoff __off, ios_base::seekdir __way, \n-\t\t\t\tios_base::openmode __mode);\n-\n-  template<>\n-    streamoff\n-    __basic_file<wchar_t>::seekpos(streamoff __pos, ios_base::openmode __mode);\n-\n-  template<>\n-    streambuf* \n-    __basic_file<wchar_t>::setbuf(wchar_t* __b, int __len);\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::sync();\n-\n-  template<>\n-    int \n-    __basic_file<wchar_t>::doallocate();\n-#endif\n-\n-  template<typename _CharT>\n-    __basic_file<_CharT>::~__basic_file()\n-    { _IO_file_finish(this, 0); }\n-      \n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::_M_open_mode(ios_base::openmode __mode, \n-\t\t\t\t       int& __p_mode, int& __rw_mode, \n-\t\t\t\t       char* /*__c_mode*/)\n-    {  \n-#ifdef O_BINARY\n-      bool __testb = __mode & ios_base::binary;\n-#endif\n-      bool __testi = __mode & ios_base::in;\n-      bool __testo = __mode & ios_base::out;\n-      bool __testt = __mode & ios_base::trunc;\n-      bool __testa = __mode & ios_base::app;\n-      \n-      if (!__testi && __testo && !__testt && !__testa)\n-\t{\n-\t  __p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n-\t  __rw_mode = _IO_NO_READS;\n-\t}\n-      if (!__testi && __testo && !__testt && __testa)\n-\t{\n-\t  __p_mode = O_WRONLY | O_APPEND | O_CREAT;\n-\t  __rw_mode = _IO_NO_READS | _IO_IS_APPENDING;\n-\t}\n-      if (!__testi && __testo && __testt && !__testa)\n-\t{\n-\t  __p_mode = O_WRONLY | O_TRUNC | O_CREAT;\n-\t  __rw_mode = _IO_NO_READS;\n-\t}\n-      if (__testi && !__testo && !__testt && !__testa)\n-\t{\n-\t  __p_mode = O_RDONLY;\n-\t  __rw_mode = _IO_NO_WRITES;\n-\t}\n-      if (__testi && __testo && !__testt && !__testa)\n-\t{\n-\t  __p_mode = O_RDWR;\n-\t  __rw_mode = 0;\n-\t}\n-      if (__testi && __testo && __testt && !__testa)\n-\t{\n-\t  __p_mode = O_RDWR | O_TRUNC | O_CREAT;\n-\t  __rw_mode = 0;\n-\t}\n-#ifdef O_BINARY\n-      if (__testb)\n-\t__p_mode |= O_BINARY;\n-#endif\t   \n-    }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>*\n-    __basic_file<_CharT>::sys_open(__c_file* __f, \n-\t\t\t\t   ios_base::openmode __mode) \n-    {\n-      __basic_file* __ret = NULL;\n-      int __fd = fileno(__f);\n-      int __p_mode = 0;\n-      int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n-      char __c_mode[4];\n-      \n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-\n-      if (!_IO_file_is_open(this))\n-\t{\n-\t  _fileno = __fd;\n-\t  _flags &= ~(_IO_NO_READS + _IO_NO_WRITES);\n-\t  _flags |= _IO_DELETE_DONT_CLOSE;\n-\t  _offset = _IO_pos_BAD;\n-\t  int __mask = _IO_NO_READS + _IO_NO_WRITES + _IO_IS_APPENDING;\n-\t  _IO_mask_flags(this, __rw_mode, __mask);\n-\t}\n-\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-  __basic_file<_CharT>*\n-  __basic_file<_CharT>::sys_open(int __fd, ios_base::openmode __mode, \n-\t\t\t       bool __del) \n-  {\n-    __basic_file* __ret = NULL;\n-    int __p_mode = 0;\n-    int __rw_mode = 0;\n-    char __c_mode[4];\n-\n-#if 0    \n-#error copy from basic_file_stdio.h will make no sense\n-    _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-    if (!this->is_open() && (_M_cfile = fdopen(__fd, __c_mode)))\n-      {\n-\t// Iff __del is true, then close will fclose the fd.\n-\t_M_cfile_created = __del;\n-\n-\tif (__fd == 0)\n-\t  setvbuf(_M_cfile, reinterpret_cast<char*>(NULL), _IONBF, 0);\n-\n-\t__ret = this;\n-      }\n-#endif\n-    return __ret;\n-  }\n-\n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::open(const char* __name, ios_base::openmode __mode, \n-\t\t\t       int __prot)\n-    {\n-      __basic_file* __ret = NULL;\n-      int __p_mode = 0;\n-      int __rw_mode = _IO_NO_READS + _IO_NO_WRITES; \n-      char __c_mode[4];\n-\n-      _M_open_mode(__mode, __p_mode, __rw_mode, __c_mode);\n-      if (!_IO_file_is_open(this))\n-\t{\n-\t  __c_file* __f;\n-\t  __f = _IO_file_open(this, __name, __p_mode, __prot, __rw_mode, 0);\n-\t  __ret = __f ? this: NULL;\n-\t}\n-      return __ret;\n-    }\n-  \n-  template<typename _CharT>\n-    bool \n-    __basic_file<_CharT>::is_open() const { return _fileno >= 0; }\n-  \n-  template<typename _CharT>\n-    __basic_file<_CharT>* \n-    __basic_file<_CharT>::close()\n-    { \n-      return _IO_file_close_it(this) ? static_cast<__basic_file*>(NULL) : this;\n-    }\n- \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::xsgetn(_CharT* __s, streamsize __n)\n-    { return _IO_file_xsgetn(this, __s, __n); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_read(_CharT* __s, streamsize __n) \n-    { return _IO_file_read(this, __s, __n); }\n-\n-  // NB: Unused.    \n-  template<typename _CharT>\n-    streamsize \n-    __basic_file<_CharT>::sys_write(const _CharT* __s, streamsize __n) \n-    { return _IO_file_write(this, __s, __n); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    streamoff\n-    __basic_file<_CharT>::sys_seek(streamoff __pos, ios_base::seekdir __way)\n-    { return _IO_file_seek(this, __pos, __way); }\n-  \n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_close() \n-    { return _IO_file_close(this); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::sys_stat(void* __v) \n-    { return _IO_file_stat(this, __v); }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    int \n-    __basic_file<_CharT>::showmanyc() { return EOF; }\n-\n-  // NB: Unused.\n-  template<typename _CharT>\n-    void \n-    __basic_file<_CharT>::imbue(void* /*__v*/) { }\n-}  // namespace std\n-\n-#endif\t// _CPP_BASIC_FILE"}, {"sha": "81c87315c2da49bf30181bef4bbd44f02b37a4e1", "filename": "libstdc++-v3/config/io/c_io_libio.h", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio.h?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,113 +0,0 @@\n-// underlying io library  -*- C++ -*-\n-\n-// Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n-//\n-// This file is part of the GNU ISO C++ Library.  This library is free\n-// software; you can redistribute it and/or modify it under the\n-// terms of the GNU General Public License as published by the\n-// Free Software Foundation; either version 2, or (at your option)\n-// any later version.\n-\n-// This library is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-// GNU General Public License for more details.\n-\n-// You should have received a copy of the GNU General Public License along\n-// with this library; see the file COPYING.  If not, write to the Free\n-// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-// USA.\n-\n-// As a special exception, you may use this file as part of a free software\n-// library without restriction.  Specifically, if other files instantiate\n-// templates or use macros or inline functions from this file, or you compile\n-// this file and link it with other files to produce an executable, this\n-// file does not by itself cause the resulting executable to be covered by\n-// the GNU General Public License.  This exception does not however\n-// invalidate any other reasons why the executable file might be covered by\n-// the GNU General Public License.\n-\n-// c_io_libio.h - Defines for using the GNU libio\n-\n-#ifndef _CPP_IO_LIBIO_H\n-#define _CPP_IO_LIBIO_H 1\n-\n-#include <libio.h>\n-\n-namespace std \n-{\n-// from fpos.h\n-  typedef _IO_ssize_t \tstreamsize; // Signed integral type\n-  typedef _IO_ssize_t \twstreamsize;\n-\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-  typedef _IO_off64_t \tstreamoff;\n-  typedef _IO_fpos64_t \t__c_streampos;\n-#else\n-  typedef _IO_off_t \tstreamoff;\n-  typedef _IO_fpos_t \t__c_streampos;\n-#endif\n-\n-#ifdef _GLIBCPP_USE_THREADS\n-  typedef _IO_lock_t   __c_lock;\n-#else\n-  typedef int          __c_lock;\n-#endif\n-\n-// from basic_file.h\n-  typedef _IO_FILE \t__c_file;\n-  typedef _IO_wide_data __c_wfile;\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-  extern \"C\" _IO_codecvt __c_libio_codecvt;\n-#endif \n-\n-// from ios_base.h\n-  struct __ios_flags\n-  {\n-    typedef short __int_type;\n-\n-    static const __int_type _S_boolalpha =\t_IO_BAD_SEEN;\n-    static const __int_type _S_dec =\t\t_IO_DEC;\n-    static const __int_type _S_fixed = \t\t_IO_FIXED;\n-    static const __int_type _S_hex =\t\t_IO_HEX;\n-    static const __int_type _S_internal = \t_IO_INTERNAL;\n-    static const __int_type _S_left =          \t_IO_LEFT;\n-    static const __int_type _S_oct =\t\t_IO_OCT;\n-    static const __int_type _S_right =\t\t_IO_RIGHT;\n-    static const __int_type _S_scientific =\t_IO_SCIENTIFIC;\n-    static const __int_type _S_showbase =      \t_IO_SHOWBASE;\n-    static const __int_type _S_showpoint =\t_IO_SHOWPOINT;\n-    static const __int_type _S_showpos =       \t_IO_SHOWPOS;\n-    static const __int_type _S_skipws =\t\t_IO_SKIPWS;\n-    static const __int_type _S_unitbuf =       \t_IO_UNITBUF;\n-    static const __int_type _S_uppercase =\t_IO_UPPERCASE;\n-    static const __int_type _S_adjustfield =\t_IO_LEFT | _IO_RIGHT\n-    \t\t\t\t\t\t| _IO_INTERNAL;\n-    static const __int_type _S_basefield =\t_IO_DEC | _IO_OCT | _IO_HEX;\n-    static const __int_type _S_floatfield =\t_IO_SCIENTIFIC | _IO_FIXED;\n-\n-    // 27.4.2.1.3  Type ios_base::iostate\n-    static const __int_type _S_badbit =\t\t_IO_BAD_SEEN;\n-    static const __int_type _S_eofbit =\t\t_IO_EOF_SEEN;\n-    static const __int_type _S_failbit =       \t_IO_ERR_SEEN;\n-\n-    // 27.4.2.1.4  Type openmode\n-    static const __int_type _S_app =\t\t_IOS_APPEND;\n-    static const __int_type _S_ate =\t\t_IOS_ATEND;\n-    static const __int_type _S_bin =\t\t_IOS_BIN;\n-    static const __int_type _S_in =\t\t_IOS_INPUT;\n-    static const __int_type _S_out =\t\t_IOS_OUTPUT;\n-    static const __int_type _S_trunc =\t\t_IOS_TRUNC;\n-  };\n-}\n-\n-#endif // _CPP_IO_LIBIO_H\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "38d8b55e0c2aed0fc534f1f6bd4a8528f554a1fa", "filename": "libstdc++-v3/config/io/c_io_libio_codecvt.c", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio_codecvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio_codecvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fio%2Fc_io_libio_codecvt.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,153 +0,0 @@\n-/* Copyright (C) 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/* Slightly modified from glibc/libio/iofwide.c */\n-\n-#include <libio.h>\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-\n-/* Prototypes of libio's codecvt functions.  */\n-static enum __codecvt_result \n-do_out(struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-       const wchar_t *from_start, const wchar_t *from_end,\n-       const wchar_t **from_stop, char *to_start, char *to_end, \n-       char **to_stop);\n-\n-static enum __codecvt_result \n-do_unshift(struct _IO_codecvt *codecvt, __c_mbstate_t *statep, char *to_start, \n-\t   char *to_end, char **to_stop);\n-\n-static enum __codecvt_result \n-do_in(struct _IO_codecvt *codecvt, __c_mbstate_t *statep, \n-      const char *from_start, const char *from_end, const char **from_stop, \n-      wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop);\n-\n-static int \n-do_encoding(struct _IO_codecvt *codecvt);\n-\n-static int \n-do_length(struct _IO_codecvt *codecvt, __c_mbstate_t *statep, \n-\t  const char *from_start, const char *from_end, _IO_size_t max);\n-\n-static int \n-do_max_length(struct _IO_codecvt *codecvt);\n-\n-static int \n-do_always_noconv(struct _IO_codecvt *codecvt);\n-\n-\n-/* The functions used in `codecvt' for libio are always the same.  */\n-struct _IO_codecvt __c_libio_codecvt =\n-{\n-  .__codecvt_destr = NULL,\t\t/* Destructor, never used.  */\n-  .__codecvt_do_out = do_out,\n-  .__codecvt_do_unshift = do_unshift,\n-  .__codecvt_do_in = do_in,\n-  .__codecvt_do_encoding = do_encoding,\n-  .__codecvt_do_always_noconv = do_always_noconv,\n-  .__codecvt_do_length = do_length,\n-  .__codecvt_do_max_length = do_max_length\n-};\n-\n-static enum __codecvt_result\n-do_out(struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-       const wchar_t *from_start, const wchar_t *from_end,\n-       const wchar_t **from_stop, char *to_start, char *to_end,\n-       char **to_stop)\n-{\n-  enum __codecvt_result res = __codecvt_ok;\n-\n-  while (from_start < from_end)\n-    {\n-      if (to_start >= to_end)\n-\t{\n-\t  res = __codecvt_partial;\n-\t  break;\n-\t}\n-      *to_start++ = (char) *from_start++;\n-    }\n-\n-  *from_stop = from_start;\n-  *to_stop = to_start;\n-\n-  return res;\n-}\n-\n-\n-static enum __codecvt_result\n-do_unshift(struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-\t   char *to_start, char *to_end, char **to_stop)\n-{\n-  *to_stop = to_start;\n-  return __codecvt_ok;\n-}\n-\n-\n-static enum __codecvt_result\n-do_in(struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-      const char *from_start, const char *from_end, const char **from_stop,\n-      wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)\n-{\n-  enum __codecvt_result res = __codecvt_ok;\n-\n-  while (from_start < from_end)\n-    {\n-      if (to_start >= to_end)\n-\t{\n-\t  res = __codecvt_partial;\n-\t  break;\n-\t}\n-      *to_start++ = (wchar_t) *from_start++;\n-    }\n-\n-  *from_stop = from_start;\n-  *to_stop = to_start;\n-\n-  return res;\n-}\n-\n-\n-static int\n-do_encoding(struct _IO_codecvt *codecvt)\n-{ return 1; }\n-\n-\n-static int\n-do_always_noconv(struct _IO_codecvt *codecvt)\n-{ return 0; }\n-\n-\n-static int\n-do_length(struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-\t  const char *from_start, const char *from_end, _IO_size_t max)\n-{ return from_end - from_start; }\n-\n-\n-static int\n-do_max_length(struct _IO_codecvt *codecvt)\n-{ return 1; }\n-\n-#endif /* _GLIBCPP_USE_WCHAR_T */"}, {"sha": "ce5d0db91dde21a89347cb1e9a9a55e78689aa9a", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 1281, "deletions": 1431, "changes": 2712, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22"}, {"sha": "8e20600527c931e5779e57a3b18c48bc778cb342", "filename": "libstdc++-v3/configure.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -490,7 +490,7 @@ AC_SUBST(LIBSUPCXX_PICFLAGS)\n # top_srcdir/{src,libsupc++}/Makefile.am, manually append it here.\n AC_OUTPUT(Makefile \\\n include/Makefile src/Makefile \\\n-libmath/Makefile libio/Makefile libsupc++/Makefile \\\n+libmath/Makefile libsupc++/Makefile \\\n po/Makefile testsuite/Makefile mkcheck testsuite_flags,\n [test -z \"$CONFIG_HEADERS\" || echo timestamp > stamp-h\n  if test -n \"$CONFIG_FILES\"; then\n@@ -532,7 +532,7 @@ ORIGINAL_LD_FOR_MULTILIBS=\"${ORIGINAL_LD_FOR_MULTILIBS}\"\n dnl  In autoconf 2.5x, AC_OUTPUT is replaced by three AC_ macros:\n dnl  AC_CONFIG_FILES(Makefile \\\n dnl      include/Makefile src/Makefile \\\n-dnl      libmath/Makefile libio/Makefile libsupc++/Makefile \\\n+dnl      libmath/Makefile libsupc++/Makefile \\\n dnl      po/Makefile testsuite/Makefile mkcheck testsuite_flags)\n dnl  AC_CONFIG_COMMANDS([default],\n dnl  [if test -n \"$CONFIG_FILES\"; then"}, {"sha": "4ba060363ca06844ab342cd4971c3004088c867c", "filename": "libstdc++-v3/docs/html/configopts.html", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fconfigopts.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fconfigopts.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fconfigopts.html?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -90,13 +90,10 @@ <h1 class=\"centered\"><a name=\"top\">Interesting <code>configure</code>\n  </dd>\n \n  <dt><code>--enable-cstdio=OPTION  </code></dt>\n- <dd><p>Select a target-specific I/O package.  As of libstdc++-v3\n-        snapshot 3.0.96, the choices are 'libio' to specify the GNU\n-        I/O package (from\n-        <a href=\"http://sources.redhat.com/glibc/\">glibc</a>, the\n-        GNU C library), or 'stdio' to use a generic &quot;C&quot;\n-        abstraction.  The default is 'stdio'.  A longer explanation\n-        is <a href=\"explanations.html#cstdio\">here</a>.\n+ <dd><p>Select a target-specific I/O package. At the moment, the only\n+        choice is to use 'stdio', a generic &quot;C&quot; abstraction.\n+        The default is 'stdio'.  A longer explanation is <a\n+        href=\"explanations.html#cstdio\">here</a>.\n      </p>\n  </dd>\n "}, {"sha": "86aa403698422c1ac291e0fc32c6707ec507a8f7", "filename": "libstdc++-v3/docs/html/explanations.html", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fexplanations.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fexplanations.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fexplanations.html?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -48,12 +48,6 @@ <h3><a name=\"cstdio\">&quot;I/O packages&quot;, <code>--enable-cstdio</code></a><\n    disadvantage is that the C++ code will run slower (fortunately, the layer\n    is thin).\n </p>\n-<p>Choosing 'libio' is the cool way; it allows C++ and C to share some\n-   buffers.  It's disabled because of tricky synchronization issues.  Other\n-   cool ways (various methods of sharing resources between C and C++\n-   facilities, instead of layering) are possible.  This approach can speed\n-   up I/O significantly.\n-</p>\n <p>Other packages are possible.  For a new package, a header must be\n    written to provide types like streamsize (usually just a typedef), as\n    well as some internal types like<code> __c_file_type </code> and"}, {"sha": "3e5a376e766c347a689c31972deb1938c000bf89", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -70,7 +70,6 @@ AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -95,7 +94,6 @@ EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@\n GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n LIBMATHOBJS = @LIBMATHOBJS@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@\n@@ -134,7 +132,6 @@ glibcpp_prefixdir = @glibcpp_prefixdir@\n glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n "}, {"sha": "1ae75373a861cd44288a229192a3e5d8bdb0776e", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -1,6 +1,6 @@\n // Threading support -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the"}, {"sha": "1d18309f7c28ad1a9b34e5d55a5ea907047126f4", "filename": "libstdc++-v3/libio/ChangeLog", "status": "removed", "additions": 0, "deletions": 2778, "changes": 2778, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FChangeLog?ref=3ad93a347592606340d535571e43943199cc3ab8"}, {"sha": "903ca8d8ae60e180dd0d36214cd1fd9a30010fcc", "filename": "libstdc++-v3/libio/Makefile.am", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.am?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,67 +0,0 @@\n-## Makefile for the libio subdirectory of the GNU C++ Standard library.\n-##\n-## Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n-##\n-## This file is part of the libstdc++ version 3 distribution.\n-## Process this file with automake to produce Makefile.in.\n-\n-## This file is part of the GNU ISO C++ Library.  This library is free\n-## software; you can redistribute it and/or modify it under the\n-## terms of the GNU General Public License as published by the\n-## Free Software Foundation; either version 2, or (at your option)\n-## any later version.\n-\n-## This library is distributed in the hope that it will be useful,\n-## but WITHOUT ANY WARRANTY; without even the implied warranty of\n-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-## GNU General Public License for more details.\n-\n-## You should have received a copy of the GNU General Public License along\n-## with this library; see the file COPYING.  If not, write to the Free\n-## Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n-## USA.\n-\n-AUTOMAKE_OPTIONS = 1.3 cygnus\n-\n-mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n-\n-if GLIBCPP_BUILD_LIBIO\n-noinst_LTLIBRARIES = libio.la\n-else\n-noinst_LTLIBRARIES =\n-endif\n-\n-# Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n-GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n-TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n-\n-INCLUDES = \\\n-\t-nostdinc++ \\\n-\t$(GLIBCPP_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n-\n-libio_headers = \\\n-        libio.h libioP.h iolibio.h\n-\n-if GLIBCPP_NEED_LIBIO\n-LIBIO_SRCS = \\\n-\tfiledoalloc.c genops.c fileops.c stdfiles.c \\\n-\tiofclose.c iofopen.c \n-else\n-LIBIO_SRCS =\n-endif\n-\n-if GLIBCPP_NEED_WLIBIO\n-LIBIO_WSRCS = \\\n-\twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n-else\n-LIBIO_WSRCS =\n-endif\n-\n-\n-EXTRA_DIST = iostreamP.h\n-\n-libio_la_SOURCES = $(LIBIO_SRCS) $(LIBIO_WSRCS)\n-\n-\n-AM_CFLAGS = -D_GNU_SOURCE "}, {"sha": "dc342eb9960f6a7b120cd9c2142afc624971ca0d", "filename": "libstdc++-v3/libio/Makefile.in", "status": "removed", "additions": 0, "deletions": 415, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,415 +0,0 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n-\n-# Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-\n-SHELL = @SHELL@\n-\n-srcdir = @srcdir@\n-top_srcdir = @top_srcdir@\n-VPATH = @srcdir@\n-prefix = @prefix@\n-exec_prefix = @exec_prefix@\n-\n-bindir = @bindir@\n-sbindir = @sbindir@\n-libexecdir = @libexecdir@\n-datadir = @datadir@\n-sysconfdir = @sysconfdir@\n-sharedstatedir = @sharedstatedir@\n-localstatedir = @localstatedir@\n-libdir = @libdir@\n-infodir = @infodir@\n-mandir = @mandir@\n-includedir = @includedir@\n-oldincludedir = /usr/include\n-\n-DESTDIR =\n-\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-\n-top_builddir = ..\n-\n-ACLOCAL = @ACLOCAL@\n-AUTOCONF = @AUTOCONF@\n-AUTOMAKE = @AUTOMAKE@\n-AUTOHEADER = @AUTOHEADER@\n-\n-INSTALL = @INSTALL@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@ $(AM_INSTALL_PROGRAM_FLAGS)\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-transform = @program_transform_name@\n-\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_alias = @build_alias@\n-build_triplet = @build@\n-host_alias = @host_alias@\n-host_triplet = @host@\n-target_alias = @target_alias@\n-target_triplet = @target@\n-AR = @AR@\n-AS = @AS@\n-ATOMICITY_INC_SRCDIR = @ATOMICITY_INC_SRCDIR@\n-AWK = @AWK@\n-BASIC_FILE_CC = @BASIC_FILE_CC@\n-BASIC_FILE_H = @BASIC_FILE_H@\n-CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n-CCODECVT_CC = @CCODECVT_CC@\n-CCODECVT_H = @CCODECVT_H@\n-CCOLLATE_CC = @CCOLLATE_CC@\n-CCTYPE_CC = @CCTYPE_CC@\n-CLOCALE_CC = @CLOCALE_CC@\n-CLOCALE_H = @CLOCALE_H@\n-CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@\n-CMESSAGES_CC = @CMESSAGES_CC@\n-CMESSAGES_H = @CMESSAGES_H@\n-CMONEY_CC = @CMONEY_CC@\n-CNUMERIC_CC = @CNUMERIC_CC@\n-CPP = @CPP@\n-CSTDIO_H = @CSTDIO_H@\n-CTIME_CC = @CTIME_CC@\n-CTIME_H = @CTIME_H@\n-CXX = @CXX@\n-CXXCPP = @CXXCPP@\n-C_INCLUDE_DIR = @C_INCLUDE_DIR@\n-DEBUG_FLAGS = @DEBUG_FLAGS@\n-DLLTOOL = @DLLTOOL@\n-EXEEXT = @EXEEXT@\n-EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@\n-GCJ = @GCJ@\n-GCJFLAGS = @GCJFLAGS@\n-GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBMATHOBJS = @LIBMATHOBJS@\n-LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n-LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n-LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@\n-LIBTOOL = @LIBTOOL@\n-LIBUNWIND_FLAG = @LIBUNWIND_FLAG@\n-LN_S = @LN_S@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n-OPT_LDFLAGS = @OPT_LDFLAGS@\n-OS_INC_SRCDIR = @OS_INC_SRCDIR@\n-PACKAGE = @PACKAGE@\n-RANLIB = @RANLIB@\n-SECTION_FLAGS = @SECTION_FLAGS@\n-SECTION_LDFLAGS = @SECTION_LDFLAGS@\n-STRIP = @STRIP@\n-SYMVER_MAP = @SYMVER_MAP@\n-USE_NLS = @USE_NLS@\n-VERSION = @VERSION@\n-WARN_FLAGS = @WARN_FLAGS@\n-WERROR = @WERROR@\n-baseline_file = @baseline_file@\n-check_msgfmt = @check_msgfmt@\n-enable_shared = @enable_shared@\n-enable_static = @enable_static@\n-glibcpp_CXX = @glibcpp_CXX@\n-glibcpp_MOFILES = @glibcpp_MOFILES@\n-glibcpp_POFILES = @glibcpp_POFILES@\n-glibcpp_basedir = @glibcpp_basedir@\n-glibcpp_builddir = @glibcpp_builddir@\n-glibcpp_localedir = @glibcpp_localedir@\n-glibcpp_prefixdir = @glibcpp_prefixdir@\n-glibcpp_srcdir = @glibcpp_srcdir@\n-glibcpp_thread_h = @glibcpp_thread_h@\n-glibcpp_toolexecdir = @glibcpp_toolexecdir@\n-glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n-gxx_include_dir = @gxx_include_dir@\n-ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n-libtool_VERSION = @libtool_VERSION@\n-toplevel_srcdir = @toplevel_srcdir@\n-\n-AUTOMAKE_OPTIONS = 1.3 cygnus\n-\n-mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs\n-@GLIBCPP_BUILD_LIBIO_TRUE@noinst_LTLIBRARIES = @GLIBCPP_BUILD_LIBIO_TRUE@libio.la\n-@GLIBCPP_BUILD_LIBIO_FALSE@noinst_LTLIBRARIES = \n-\n-# Use common includes from acinclude.m4/GLIBCPP_EXPORT_INCLUDES\n-GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n-TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n-\n-INCLUDES = \\\n-\t-nostdinc++ \\\n-\t$(GLIBCPP_INCLUDES) $(LIBIO_INCLUDES) $(TOPLEVEL_INCLUDES)\t\n-\n-\n-libio_headers = \\\n-        libio.h libioP.h iolibio.h\n-\n-@GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = @GLIBCPP_NEED_LIBIO_TRUE@\\\n-@GLIBCPP_NEED_LIBIO_TRUE@\tfiledoalloc.c genops.c fileops.c stdfiles.c \\\n-@GLIBCPP_NEED_LIBIO_TRUE@\tiofclose.c iofopen.c \n-@GLIBCPP_NEED_LIBIO_FALSE@LIBIO_SRCS = \n-@GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = @GLIBCPP_NEED_WLIBIO_TRUE@\\\n-@GLIBCPP_NEED_WLIBIO_TRUE@\twfiledoalloc.c wfileops.c wgenops.c iofwide.c\n-@GLIBCPP_NEED_WLIBIO_FALSE@LIBIO_WSRCS = \n-\n-EXTRA_DIST = iostreamP.h\n-\n-libio_la_SOURCES = $(LIBIO_SRCS) $(LIBIO_WSRCS)\n-\n-AM_CFLAGS = -D_GNU_SOURCE \n-CONFIG_HEADER = ../config.h\n-CONFIG_CLEAN_FILES = \n-LTLIBRARIES =  $(noinst_LTLIBRARIES)\n-\n-\n-DEFS = @DEFS@ -I. -I$(srcdir) -I..\n-CPPFLAGS = @CPPFLAGS@\n-LDFLAGS = @LDFLAGS@\n-LIBS = @LIBS@\n-libio_la_LDFLAGS = \n-libio_la_LIBADD = \n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo fileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfiledoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wgenops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofwide.lo\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wfiledoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wfileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wgenops.lo \\\n-@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofwide.lo\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@iofclose.lo \\\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@iofopen.lo\n-@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS = \n-CFLAGS = @CFLAGS@\n-COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n-DIST_COMMON =  ChangeLog Makefile.am Makefile.in\n-\n-\n-DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n-\n-TAR = gtar\n-GZIP_ENV = --best\n-SOURCES = $(libio_la_SOURCES)\n-OBJECTS = $(libio_la_OBJECTS)\n-\n-all: all-redirect\n-.SUFFIXES:\n-.SUFFIXES: .S .c .lo .o .obj .s\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n-\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus libio/Makefile\n-\n-Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status\n-\tcd $(top_builddir) \\\n-\t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n-\n-\n-mostlyclean-noinstLTLIBRARIES:\n-\n-clean-noinstLTLIBRARIES:\n-\t-test -z \"$(noinst_LTLIBRARIES)\" || rm -f $(noinst_LTLIBRARIES)\n-\n-distclean-noinstLTLIBRARIES:\n-\n-maintainer-clean-noinstLTLIBRARIES:\n-\n-.c.o:\n-\t$(COMPILE) -c $<\n-\n-# FIXME: We should only use cygpath when building on Windows,\n-# and only if it is available.\n-.c.obj:\n-\t$(COMPILE) -c `cygpath -w $<`\n-\n-.s.o:\n-\t$(COMPILE) -c $<\n-\n-.S.o:\n-\t$(COMPILE) -c $<\n-\n-mostlyclean-compile:\n-\t-rm -f *.o core *.core\n-\t-rm -f *.$(OBJEXT)\n-\n-clean-compile:\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-maintainer-clean-compile:\n-\n-.c.lo:\n-\t$(LIBTOOL) --mode=compile $(COMPILE) -c $<\n-\n-.s.lo:\n-\t$(LIBTOOL) --mode=compile $(COMPILE) -c $<\n-\n-.S.lo:\n-\t$(LIBTOOL) --mode=compile $(COMPILE) -c $<\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\n-maintainer-clean-libtool:\n-\n-libio.la: $(libio_la_OBJECTS) $(libio_la_DEPENDENCIES)\n-\t$(LINK)  $(libio_la_LDFLAGS) $(libio_la_OBJECTS) $(libio_la_LIBADD) $(LIBS)\n-\n-tags: TAGS\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP)\n-\tlist='$(SOURCES) $(HEADERS)'; \\\n-\tunique=`for i in $$list; do echo $$i; done | \\\n-\t  awk '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\there=`pwd` && cd $(srcdir) \\\n-\t  && mkid -f$$here/ID $$unique $(LISP)\n-\n-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n-\ttags=; \\\n-\there=`pwd`; \\\n-\tlist='$(SOURCES) $(HEADERS)'; \\\n-\tunique=`for i in $$list; do echo $$i; done | \\\n-\t  awk '    { files[$$0] = 1; } \\\n-\t       END { for (i in files) print i; }'`; \\\n-\ttest -z \"$(ETAGS_ARGS)$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)\n-\n-mostlyclean-tags:\n-\n-clean-tags:\n-\n-distclean-tags:\n-\t-rm -f TAGS ID\n-\n-maintainer-clean-tags:\n-\n-distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n-\n-subdir = libio\n-\n-distdir: $(DISTFILES)\n-\t@for file in $(DISTFILES); do \\\n-\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n-\t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n-\t  else \\\n-\t    test -f $(distdir)/$$file \\\n-\t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n-\t    || cp -p $$d/$$file $(distdir)/$$file || :; \\\n-\t  fi; \\\n-\tdone\n-info-am:\n-info: info-am\n-dvi-am:\n-dvi: dvi-am\n-check-am:\n-check: check-am\n-installcheck-am:\n-installcheck: installcheck-am\n-install-info-am: \n-install-info: install-info-am\n-install-exec-am:\n-install-exec: install-exec-am\n-\n-install-data-am:\n-install-data: install-data-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-install: install-am\n-uninstall-am:\n-uninstall: uninstall-am\n-all-am: Makefile $(LTLIBRARIES)\n-all-redirect: all-am\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install\n-installdirs:\n-\n-\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-rm -f Makefile $(CONFIG_CLEAN_FILES)\n-\t-rm -f config.cache config.log stamp-h stamp-h[0-9]*\n-\n-maintainer-clean-generic:\n-mostlyclean-am:  mostlyclean-noinstLTLIBRARIES mostlyclean-compile \\\n-\t\tmostlyclean-libtool mostlyclean-tags \\\n-\t\tmostlyclean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-clean-am:  clean-noinstLTLIBRARIES clean-compile clean-libtool \\\n-\t\tclean-tags clean-generic mostlyclean-am\n-\n-clean: clean-am\n-\n-distclean-am:  distclean-noinstLTLIBRARIES distclean-compile \\\n-\t\tdistclean-libtool distclean-tags distclean-generic \\\n-\t\tclean-am\n-\t-rm -f libtool\n-\n-distclean: distclean-am\n-\n-maintainer-clean-am:  maintainer-clean-noinstLTLIBRARIES \\\n-\t\tmaintainer-clean-compile maintainer-clean-libtool \\\n-\t\tmaintainer-clean-tags maintainer-clean-generic \\\n-\t\tdistclean-am\n-\t@echo \"This command is intended for maintainers to use;\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-\n-maintainer-clean: maintainer-clean-am\n-\n-.PHONY: mostlyclean-noinstLTLIBRARIES distclean-noinstLTLIBRARIES \\\n-clean-noinstLTLIBRARIES maintainer-clean-noinstLTLIBRARIES \\\n-mostlyclean-compile distclean-compile clean-compile \\\n-maintainer-clean-compile mostlyclean-libtool distclean-libtool \\\n-clean-libtool maintainer-clean-libtool tags mostlyclean-tags \\\n-distclean-tags clean-tags maintainer-clean-tags distdir info-am info \\\n-dvi-am dvi check check-am installcheck-am installcheck install-info-am \\\n-install-info install-exec-am install-exec install-data-am install-data \\\n-install-am install uninstall-am uninstall all-redirect all-am all \\\n-installdirs mostlyclean-generic distclean-generic clean-generic \\\n-maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n-\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "d6738c2bf7be669de752ee548266639ca2b46ce6", "filename": "libstdc++-v3/libio/_G_config.h", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2F_G_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2F_G_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2F_G_config.h?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,136 +0,0 @@\n-/* This file is needed by libio to define various configuration parameters.\n-   These are always the same in the GNU C library.  */\n-\n-#ifndef _G_config_h\n-#define _G_config_h 1\n-\n-#ifndef _LIBC\n-# include <bits/c++config.h>\n-# ifdef _GLIBCPP_USE_THREADS\n-#   define _IO_MTSAFE_IO\n-# endif\n-#endif\n-\n-/* Define types for libio in terms of the standard internal type names.  */\n-\n-#include <sys/types.h>\n-#define __need_size_t\n-#define __need_wchar_t\n-#define __need_wint_t\n-#define __need_NULL\n-#define __need_ptrdiff_t\n-#ifdef __cplusplus\n-# include <cstddef>\n-#else\n-# include <stddef.h>\n-#endif\n-\n-\n-#ifndef _WINT_T\n-/* Integral type unchanged by default argument promotions that can\n-   hold any value corresponding to members of the extended character\n-   set, as well as at least one value that does not correspond to any\n-   member of the extended character set.  */\n-# define _WINT_T\n-typedef unsigned int wint_t;\n-#endif\n-\n-/* For use as part of glibc (native) or as part of libstdc++ (maybe\n-   not glibc) */\n-#ifndef __c_mbstate_t_defined\n-# define __c_mbstate_t_defined\t1\n-/*# ifdef _GLIBCPP_USE_WCHAR_T*/\n-typedef struct\n-{\n-  int count;\n-  wint_t value;\n-}__c_mbstate_t;\n-/*# endif*/\n-#endif\n-#undef __need_mbstate_t\n-\n-typedef size_t _G_size_t;\n-\n-\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-typedef struct\n-{\n-  __off_t __pos;\n-  __c_mbstate_t __state;\n-} _G_fpos_t;\n-\n-typedef struct\n-{\n-  __off64_t __pos;\n-  __c_mbstate_t __state;\n-} _G_fpos64_t;\n-#else\n-typedef __off_t _G_fpos_t;\n-typedef __off64_t _G_fpos64_t;\n-#endif\n-#define _G_ssize_t\t__ssize_t\n-#define _G_off_t\t__off_t\n-#define _G_off64_t\t__off64_t\n-#define\t_G_pid_t\t__pid_t\n-#define\t_G_uid_t\t__uid_t\n-#define _G_wchar_t\twchar_t\n-#define _G_wint_t\twint_t\n-#define _G_stat64\tstat64\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-# include <iconv.h>\n-typedef iconv_t _G_iconv_t;\n-#endif\n-\n-typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));\n-typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));\n-typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));\n-typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));\n-\n-#define _G_HAVE_BOOL 1\n-\n-\n-/* These library features are always available in the GNU C library.  */\n-#define _G_HAVE_ATEXIT 1\n-#define _G_HAVE_SYS_CDEFS 1\n-#define _G_HAVE_SYS_WAIT 1\n-#define _G_NEED_STDARG_H 1\n-#define _G_va_list __gnuc_va_list\n-\n-#define _G_HAVE_PRINTF_FP 1\n-#define _G_HAVE_MMAP 1\n-#define _G_HAVE_LONG_DOUBLE_IO 1\n-#define _G_HAVE_IO_FILE_OPEN 1\n-#define _G_HAVE_IO_GETLINE_INFO 1\n-\n-#define _G_IO_IO_FILE_VERSION 0x20001\n-\n-//#define _G_OPEN64\t__open64\n-//#define _G_LSEEK64\t__lseek64\n-//#define _G_FSTAT64(fd,buf) __fxstat64 (_STAT_VER, fd, buf)\n-\n-/* This is defined by <bits/stat.h> if `st_blksize' exists.  */\n-/*#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)*/\n-\n-#define _G_BUFSIZ 8192\n-\n-/* These are the vtbl details for ELF.  */\n-#define _G_NAMES_HAVE_UNDERSCORE 0\n-#define _G_VTABLE_LABEL_HAS_LENGTH 1\n-#ifndef _G_USING_THUNKS\n-# define _G_USING_THUNKS\t1\n-#endif /* _G_USING_THUNKS */\n-#define _G_VTABLE_LABEL_PREFIX \"__vt_\"\n-#define _G_VTABLE_LABEL_PREFIX_ID __vt_\n-\n-#define _G_INTERNAL_CCS\t\"UCS4\"\n-#define _G_HAVE_WEAK_SYMBOL 1\n-#define _G_STDIO_USES_LIBIO 1\n-\n-#if defined __cplusplus || defined __STDC__\n-# define _G_ARGS(ARGLIST) ARGLIST\n-#else\n-# define _G_ARGS(ARGLIST) ()\n-#endif\n-\n-#endif\t/* _G_config.h */\n-"}, {"sha": "12c1135bcbe075f79455642f38ccbc41f8d1c03c", "filename": "libstdc++-v3/libio/filedoalloc.c", "status": "removed", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,101 +0,0 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/*\n- * Copyright (c) 1990 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms are permitted\n- * provided that the above copyright notice and this paragraph are\n- * duplicated in all such forms and that any documentation,\n- * advertising materials, and other materials related to such\n- * distribution and use acknowledge that the software was developed\n- * by the University of California, Berkeley.  The name of the\n- * University may not be used to endorse or promote products derived\n- * from this software without specific prior written permission.\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n- */\n-\n-/* Modified for GNU iostream by Per Bothner 1991, 1992. */\n-\n-#ifndef _POSIX_SOURCE\n-# define _POSIX_SOURCE\n-#endif\n-#include \"libioP.h\"\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#include <unistd.h>\n-#endif\n-\n-#ifdef _LIBC\n-# undef isatty\n-# define isatty(Fd) __isatty (Fd)\n-#endif\n-\n-/*\n- * Allocate a file buffer, or switch to unbuffered I/O.\n- * Per the ANSI C standard, ALL tty devices default to line buffered.\n- *\n- * As a side effect, we set __SOPT or __SNPT (en/dis-able fseek\n- * optimisation) right after the _fstat() that finds the buffer size.\n- */\n-\n-int\n-_IO_file_doallocate (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t size;\n-  int couldbetty;\n-  char *p;\n-  struct _G_stat64 st;\n-\n-  if (fp->_fileno < 0 || _IO_SYSSTAT (fp, &st) < 0)\n-    {\n-      couldbetty = 0;\n-      size = _IO_BUFSIZ;\n-#if 0\n-      /* do not try to optimise fseek() */\n-      fp->_flags |= __SNPT;\n-#endif\n-    }\n-  else\n-    {\n-      couldbetty = S_ISCHR (st.st_mode);\n-#if _IO_HAVE_ST_BLKSIZE\n-      size = st.st_blksize <= 0 ? _IO_BUFSIZ : st.st_blksize;\n-#else\n-      size = _IO_BUFSIZ;\n-#endif\n-    }\n-  ALLOC_BUF (p, size, EOF);\n-  _IO_setb (fp, p, p + size, 1);\n-  if (couldbetty && isatty (fp->_fileno))\n-    fp->_flags |= _IO_LINE_BUF;\n-  return 1;\n-}"}, {"sha": "a830b5cd4395a02470067011cf079e10dcdbae98", "filename": "libstdc++-v3/libio/fileops.c", "status": "removed", "additions": 0, "deletions": 1049, "changes": 1049, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Ffileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Ffileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Ffileops.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,1049 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997-1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-   Written by Per Bothner <bothner@cygnus.com>.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-\n-#ifndef _POSIX_SOURCE\n-# define _POSIX_SOURCE\n-#endif\n-#include \"libioP.h\"\n-#include <fcntl.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <string.h>\n-#include <errno.h>\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#if _LIBC\n-# include \"../wcsmbs/wcsmbsload.h\"\n-# include <shlib-compat.h>\n-#endif\n-#ifndef errno\n-extern int errno;\n-#endif\n-#ifndef __set_errno\n-# define __set_errno(Val) errno = (Val)\n-#endif\n-\n-\n-#ifdef _LIBC\n-# define open(Name, Flags, Prot) __open (Name, Flags, Prot)\n-# define close(FD) __close (FD)\n-# define lseek(FD, Offset, Whence) __lseek (FD, Offset, Whence)\n-# define read(FD, Buf, NBytes) __read (FD, Buf, NBytes)\n-# define write(FD, Buf, NBytes) __write (FD, Buf, NBytes)\n-#else\n-# define _IO_new_do_write _IO_do_write\n-# define _IO_new_file_attach _IO_file_attach\n-# define _IO_new_file_close_it _IO_file_close_it\n-# define _IO_new_file_finish _IO_file_finish\n-# define _IO_new_file_fopen _IO_file_fopen\n-# define _IO_new_file_init _IO_file_init\n-# define _IO_new_file_setbuf _IO_file_setbuf\n-# define _IO_new_file_sync _IO_file_sync\n-# define _IO_new_file_overflow _IO_file_overflow\n-# define _IO_new_file_seekoff _IO_file_seekoff\n-# define _IO_new_file_underflow _IO_file_underflow\n-# define _IO_new_file_write _IO_file_write\n-# define _IO_new_file_xsputn _IO_file_xsputn\n-#endif\n-\n-/* An fstream can be in at most one of put mode, get mode, or putback mode.\n-   Putback mode is a variant of get mode.\n-\n-   In a filebuf, there is only one current position, instead of two\n-   separate get and put pointers.  In get mode, the current position\n-   is that of gptr(); in put mode that of pptr().\n-\n-   The position in the buffer that corresponds to the position\n-   in external file system is normally _IO_read_end, except in putback\n-   mode, when it is _IO_save_end.\n-   If the field _fb._offset is >= 0, it gives the offset in\n-   the file as a whole corresponding to eGptr(). (?)\n-\n-   PUT MODE:\n-   If a filebuf is in put mode, then all of _IO_read_ptr, _IO_read_end,\n-   and _IO_read_base are equal to each other.  These are usually equal\n-   to _IO_buf_base, though not necessarily if we have switched from\n-   get mode to put mode.  (The reason is to maintain the invariant\n-   that _IO_read_end corresponds to the external file position.)\n-   _IO_write_base is non-NULL and usually equal to _IO_base_base.\n-   We also have _IO_write_end == _IO_buf_end, but only in fully buffered mode.\n-   The un-flushed character are those between _IO_write_base and _IO_write_ptr.\n-\n-   GET MODE:\n-   If a filebuf is in get or putback mode, eback() != egptr().\n-   In get mode, the unread characters are between gptr() and egptr().\n-   The OS file position corresponds to that of egptr().\n-\n-   PUTBACK MODE:\n-   Putback mode is used to remember \"excess\" characters that have\n-   been sputbackc'd in a separate putback buffer.\n-   In putback mode, the get buffer points to the special putback buffer.\n-   The unread characters are the characters between gptr() and egptr()\n-   in the putback buffer, as well as the area between save_gptr()\n-   and save_egptr(), which point into the original reserve buffer.\n-   (The pointers save_gptr() and save_egptr() are the values\n-   of gptr() and egptr() at the time putback mode was entered.)\n-   The OS position corresponds to that of save_egptr().\n-\n-   LINE BUFFERED OUTPUT:\n-   During line buffered output, _IO_write_base==base() && epptr()==base().\n-   However, ptr() may be anywhere between base() and ebuf().\n-   This forces a call to filebuf::overflow(int C) on every put.\n-   If there is more space in the buffer, and C is not a '\\n',\n-   then C is inserted, and pptr() incremented.\n-\n-   UNBUFFERED STREAMS:\n-   If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer.\n-*/\n-\n-#define CLOSED_FILEBUF_FLAGS \\\n-  (_IO_IS_FILEBUF+_IO_NO_READS+_IO_NO_WRITES+_IO_TIED_PUT_GET)\n-\n-\n-void\n-_IO_new_file_init (fp)\n-     struct _IO_FILE_plus *fp;\n-{\n-  /* POSIX.1 allows another file handle to be used to change the position\n-     of our file descriptor.  Hence we actually don't know the actual\n-     position before we do the first fseek (and until a following fflush). */\n-  fp->file._offset = _IO_pos_BAD;\n-  fp->file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;\n-\n-  _IO_link_in (fp);\n-  fp->file._fileno = -1;\n-}\n-\n-int\n-_IO_new_file_close_it (fp)\n-     _IO_FILE *fp;\n-{\n-  int write_status, close_status;\n-  if (!_IO_file_is_open (fp))\n-    return EOF;\n-\n-  write_status = _IO_do_flush (fp);\n-\n-  _IO_unsave_markers(fp);\n-\n-  close_status = _IO_SYSCLOSE (fp);\n-\n-  /* Free buffer. */\n-  if (fp->_mode <= 0)\n-    {\n-      _IO_setb (fp, NULL, NULL, 0);\n-      _IO_setg (fp, NULL, NULL, NULL);\n-      _IO_setp (fp, NULL, NULL);\n-    }\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  else\n-    {\n-      _IO_wsetb (fp, NULL, NULL, 0);\n-      _IO_wsetg (fp, NULL, NULL, NULL);\n-      _IO_wsetp (fp, NULL, NULL);\n-    }\n-#endif\n-\n-  _IO_un_link ((struct _IO_FILE_plus *) fp);\n-  fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;\n-  fp->_fileno = -1;\n-  fp->_offset = _IO_pos_BAD;\n-\n-  return close_status ? close_status : write_status;\n-}\n-\n-void\n-_IO_new_file_finish (fp, dummy)\n-     _IO_FILE *fp;\n-     int dummy;\n-{\n-  if (_IO_file_is_open (fp))\n-    {\n-      _IO_do_flush (fp);\n-      if (!(fp->_flags & _IO_DELETE_DONT_CLOSE))\n-\t_IO_SYSCLOSE (fp);\n-    }\n-  _IO_default_finish (fp, 0);\n-}\n-\n-#if defined __GNUC__ && __GNUC__ >= 2\n-__inline__\n-#endif\n-_IO_FILE *\n-_IO_file_open (fp, filename, posix_mode, prot, read_write, is32not64)\n-     _IO_FILE *fp;\n-     const char *filename;\n-     int posix_mode;\n-     int prot;\n-     int read_write;\n-     int is32not64;\n-{\n-  int fdesc;\n-#ifdef _G_OPEN64\n-  fdesc = (is32not64\n-\t   ? open (filename, posix_mode, prot)\n-\t   : _G_OPEN64 (filename, posix_mode, prot));\n-#else\n-  fdesc = open (filename, posix_mode, prot);\n-#endif\n-  if (fdesc < 0)\n-    return NULL;\n-  fp->_fileno = fdesc;\n-  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n-  if (read_write & _IO_IS_APPENDING)\n-    if (_IO_SEEKOFF (fp, (_IO_off64_t)0, _IO_seek_end, _IOS_INPUT|_IOS_OUTPUT)\n-\t== _IO_pos_BAD && errno != ESPIPE)\n-      return NULL;\n-  _IO_link_in ((struct _IO_FILE_plus *) fp);\n-  return fp;\n-}\n-\n-_IO_FILE *\n-_IO_new_file_fopen (fp, filename, mode, is32not64)\n-     _IO_FILE *fp;\n-     const char *filename;\n-     const char *mode;\n-     int is32not64;\n-{\n-  int oflags = 0, omode;\n-  int read_write;\n-  int oprot = 0666;\n-  int i;\n-  _IO_FILE *result;\n-#if _LIBC\n-  const char *cs;\n-#endif\n-\n-  if (_IO_file_is_open (fp))\n-    return 0;\n-  switch (*mode)\n-    {\n-    case 'r':\n-      omode = O_RDONLY;\n-      read_write = _IO_NO_WRITES;\n-      break;\n-    case 'w':\n-      omode = O_WRONLY;\n-      oflags = O_CREAT|O_TRUNC;\n-      read_write = _IO_NO_READS;\n-      break;\n-    case 'a':\n-      omode = O_WRONLY;\n-      oflags = O_CREAT|O_APPEND;\n-      read_write = _IO_NO_READS|_IO_IS_APPENDING;\n-      break;\n-    default:\n-      __set_errno (EINVAL);\n-      return NULL;\n-    }\n-  for (i = 1; i < 4; ++i)\n-    {\n-      switch (*++mode)\n-\t{\n-\tcase '\\0':\n-\t  break;\n-\tcase '+':\n-\t  omode = O_RDWR;\n-\t  read_write &= _IO_IS_APPENDING;\n-\t  continue;\n-\tcase 'x':\n-\t  oflags |= O_EXCL;\n-\t  continue;\n-\tcase 'b':\n-\tdefault:\n-\t  /* Ignore.  */\n-\t  continue;\n-\t}\n-      break;\n-    }\n-\n-  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,\n-\t\t\t  is32not64);\n-\n-\n-#if _LIBC\n-  /* Test whether the mode string specifies the conversion.  */\n-  cs = strstr (mode, \",ccs=\");\n-  if (cs != NULL)\n-    {\n-      /* Yep.  Load the appropriate conversions and set the orientation\n-\t to wide.  */\n-\tstruct gconv_fcts fcts;\n-\tstruct _IO_codecvt *cc;\n-\n-\tif (! _IO_CHECK_WIDE (fp) || __wcsmbs_named_conv (&fcts, cs + 5) != 0)\n-\t  {\n-\t    /* Something went wrong, we cannot load the conversion modules.\n-\t       This means we cannot proceed since the user explicitly asked\n-\t       for these.  */\n-\t    _IO_new_fclose (result);\n-\t    return NULL;\n-\t  }\n-\n-\tcc = fp->_codecvt = &fp->_wide_data->_codecvt;\n-\n-\t/* The functions are always the same.  */\n-\t*cc = __libio_codecvt;\n-\n-\tcc->__cd_in.__cd.__nsteps = 1; /* Only one step allowed.  */\n-\tcc->__cd_in.__cd.__steps = fcts.towc;\n-\n-\tcc->__cd_in.__cd.__data[0].__invocation_counter = 0;\n-\tcc->__cd_in.__cd.__data[0].__internal_use = 1;\n-\tcc->__cd_in.__cd.__data[0].__flags = __GCONV_IS_LAST;\n-\tcc->__cd_in.__cd.__data[0].__statep = &result->_wide_data->_IO_state;\n-\n-\tcc->__cd_out.__cd.__nsteps = 1; /* Only one step allowed.  */\n-\tcc->__cd_out.__cd.__steps = fcts.tomb;\n-\n-\tcc->__cd_out.__cd.__data[0].__invocation_counter = 0;\n-\tcc->__cd_out.__cd.__data[0].__internal_use = 1;\n-\tcc->__cd_out.__cd.__data[0].__flags = __GCONV_IS_LAST;\n-\tcc->__cd_out.__cd.__data[0].__statep = &result->_wide_data->_IO_state;\n-\n-\t/* Set the mode now.  */\n-\tresult->_mode = 1;\n-    }\n-#endif\t/* GNU libc */\n-\n-  return result;\n-}\n-\n-_IO_FILE *\n-_IO_new_file_attach (fp, fd)\n-     _IO_FILE *fp;\n-     int fd;\n-{\n-  if (_IO_file_is_open (fp))\n-    return NULL;\n-  fp->_fileno = fd;\n-  fp->_flags &= ~(_IO_NO_READS+_IO_NO_WRITES);\n-  fp->_flags |= _IO_DELETE_DONT_CLOSE;\n-  /* Get the current position of the file. */\n-  /* We have to do that since that may be junk. */\n-  fp->_offset = _IO_pos_BAD;\n-  if (_IO_SEEKOFF (fp, (_IO_off64_t)0, _IO_seek_cur, _IOS_INPUT|_IOS_OUTPUT)\n-      == _IO_pos_BAD && errno != ESPIPE)\n-    return NULL;\n-  return fp;\n-}\n-\n-_IO_FILE *\n-_IO_new_file_setbuf (fp, p, len)\n-     _IO_FILE *fp;\n-     char *p;\n-     _IO_ssize_t len;\n-{\n-  if (_IO_default_setbuf (fp, p, len) == NULL)\n-    return NULL;\n-\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n-    = fp->_IO_buf_base;\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-\n-  return fp;\n-}\n-\n-static int new_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n-\n-/* Write TO_DO bytes from DATA to FP.\n-   Then mark FP as having empty buffers. */\n-\n-int\n-_IO_new_do_write (fp, data, to_do)\n-     _IO_FILE *fp;\n-     const char *data;\n-     _IO_size_t to_do;\n-{\n-  return (to_do == 0 || new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;\n-}\n-\n-static\n-int\n-new_do_write (fp, data, to_do)\n-     _IO_FILE *fp;\n-     const char *data;\n-     _IO_size_t to_do;\n-{\n-  _IO_size_t count;\n-  if (fp->_flags & _IO_IS_APPENDING)\n-    /* On a system without a proper O_APPEND implementation,\n-       you would need to sys_seek(0, SEEK_END) here, but is\n-       is not needed nor desirable for Unix- or Posix-like systems.\n-       Instead, just indicate that offset (before and after) is\n-       unpredictable. */\n-    fp->_offset = _IO_pos_BAD;\n-  else if (fp->_IO_read_end != fp->_IO_write_base)\n-    {\n-      _IO_off64_t new_pos\n-\t= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n-      if (new_pos == _IO_pos_BAD)\n-\treturn 0;\n-      fp->_offset = new_pos;\n-    }\n-  count = _IO_SYSWRITE (fp, data, to_do);\n-  if (fp->_cur_column && count)\n-    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;\n-  fp->_IO_write_end = (fp->_mode < 0\n-\t\t       && (fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\t\t       ? fp->_IO_buf_base : fp->_IO_buf_end);\n-  return count;\n-}\n-\n-int\n-_IO_new_file_underflow (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_ssize_t count;\n-#if 0\n-  /* SysV does not make this test; take it out for compatibility */\n-  if (fp->_flags & _IO_EOF_SEEN)\n-    return (EOF);\n-#endif\n-\n-  if (fp->_flags & _IO_NO_READS)\n-    {\n-      fp->_flags |= _IO_ERR_SEEN;\n-      __set_errno (EBADF);\n-      return EOF;\n-    }\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char *) fp->_IO_read_ptr;\n-\n-  if (fp->_IO_buf_base == NULL)\n-    {\n-      /* Maybe we already have a push back pointer.  */\n-      if (fp->_IO_save_base != NULL)\n-\t{\n-\t  free (fp->_IO_save_base);\n-\t  fp->_flags &= ~_IO_IN_BACKUP;\n-\t}\n-      _IO_doallocbuf (fp);\n-    }\n-\n-  /* Flush all line buffered files before reading. */\n-  /* FIXME This can/should be moved to genops ?? */\n-  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-    _IO_flush_all_linebuffered ();\n-\n-  _IO_switch_to_get_mode (fp);\n-\n-  /* This is very tricky. We have to adjust those\n-     pointers before we call _IO_SYSREAD () since\n-     we may longjump () out while waiting for\n-     input. Those pointers may be screwed up. H.J. */\n-  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n-  fp->_IO_read_end = fp->_IO_buf_base;\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n-    = fp->_IO_buf_base;\n-\n-  count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n-\t\t       fp->_IO_buf_end - fp->_IO_buf_base);\n-  if (count <= 0)\n-    {\n-      if (count == 0)\n-\tfp->_flags |= _IO_EOF_SEEN;\n-      else\n-\tfp->_flags |= _IO_ERR_SEEN, count = 0;\n-  }\n-  fp->_IO_read_end += count;\n-  if (count == 0)\n-    return EOF;\n-  if (fp->_offset != _IO_pos_BAD)\n-    _IO_pos_adjust (fp->_offset, count);\n-  return *(unsigned char *) fp->_IO_read_ptr;\n-}\n-\n-int\n-_IO_new_file_overflow (f, ch)\n-      _IO_FILE *f;\n-      int ch;\n-{\n-  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n-    {\n-      f->_flags |= _IO_ERR_SEEN;\n-      __set_errno (EBADF);\n-      return EOF;\n-    }\n-  /* If currently reading or no buffer allocated. */\n-  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == 0)\n-    {\n-      /* Allocate a buffer if needed. */\n-      if (f->_IO_write_base == 0)\n-\t{\n-\t  _IO_doallocbuf (f);\n-\t  _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n-\t}\n-      /* Otherwise must be currently reading.\n-\t If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,\n-\t logically slide the buffer forwards one block (by setting the\n-\t read pointers to all point at the beginning of the block).  This\n-\t makes room for subsequent output.\n-\t Otherwise, set the read pointers to _IO_read_end (leaving that\n-\t alone, so it can continue to correspond to the external position). */\n-      if (f->_IO_read_ptr == f->_IO_buf_end)\n-\tf->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n-      f->_IO_write_ptr = f->_IO_read_ptr;\n-      f->_IO_write_base = f->_IO_write_ptr;\n-      f->_IO_write_end = f->_IO_buf_end;\n-      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n-\n-      f->_flags |= _IO_CURRENTLY_PUTTING;\n-      if (f->_mode < 0 && f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\tf->_IO_write_end = f->_IO_write_ptr;\n-    }\n-  if (ch == EOF)\n-    return _IO_new_do_write(f, f->_IO_write_base,\n-\t\t\t    f->_IO_write_ptr - f->_IO_write_base);\n-  if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */\n-    if (_IO_do_flush (f) == EOF)\n-      return EOF;\n-  *f->_IO_write_ptr++ = ch;\n-  if ((f->_flags & _IO_UNBUFFERED)\n-      || ((f->_flags & _IO_LINE_BUF) && ch == '\\n'))\n-    if (_IO_new_do_write(f, f->_IO_write_base,\n-\t\t\t f->_IO_write_ptr - f->_IO_write_base) == EOF)\n-      return EOF;\n-  return (unsigned char) ch;\n-}\n-\n-int\n-_IO_new_file_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_ssize_t delta;\n-  int retval = 0;\n-\n-  /*    char* ptr = cur_ptr(); */\n-  if (fp->_IO_write_ptr > fp->_IO_write_base)\n-    if (_IO_do_flush(fp)) return EOF;\n-  delta = fp->_IO_read_ptr - fp->_IO_read_end;\n-  if (delta != 0)\n-    {\n-#ifdef TODO\n-      if (_IO_in_backup (fp))\n-\tdelta -= eGptr () - Gbase ();\n-#endif\n-      _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1);\n-      if (new_pos != (_IO_off64_t) EOF)\n-\tfp->_IO_read_end = fp->_IO_read_ptr;\n-#ifdef ESPIPE\n-      else if (errno == ESPIPE)\n-\t; /* Ignore error from unseekable devices. */\n-#endif\n-      else\n-\tretval = EOF;\n-    }\n-  if (retval != EOF)\n-    fp->_offset = _IO_pos_BAD;\n-  /* FIXME: Cleanup - can this be shared? */\n-  /*    setg(base(), ptr, ptr); */\n-  return retval;\n-}\n-\n-_IO_off64_t\n-_IO_new_file_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off64_t offset;\n-     int dir;\n-     int mode;\n-{\n-  _IO_off64_t result;\n-  _IO_off64_t delta, new_offset;\n-  long count;\n-  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n-     offset of the underlying file must be exact.  */\n-  int must_be_exact = (fp->_IO_read_base == fp->_IO_read_end\n-\t\t       && fp->_IO_write_base == fp->_IO_write_ptr);\n-\n-  if (mode == 0)\n-    dir = _IO_seek_cur, offset = 0; /* Don't move any pointers. */\n-\n-  /* Flush unwritten characters.\n-     (This may do an unneeded write if we seek within the buffer.\n-     But to be able to switch to reading, we would need to set\n-     egptr to ptr.  That can't be done in the current design,\n-     which assumes file_ptr() is eGptr.  Anyway, since we probably\n-     end up flushing when we close(), it doesn't make much difference.)\n-     FIXME: simulate mem-papped files. */\n-\n-  if (fp->_IO_write_ptr > fp->_IO_write_base || _IO_in_put_mode (fp))\n-    if (_IO_switch_to_get_mode (fp))\n-      return EOF;\n-\n-  if (fp->_IO_buf_base == NULL)\n-    {\n-      /* It could be that we already have a pushback buffer.  */\n-      if (fp->_IO_read_base != NULL)\n-\t{\n-\t  free (fp->_IO_read_base);\n-\t  fp->_flags &= ~_IO_IN_BACKUP;\n-\t}\n-      _IO_doallocbuf (fp);\n-      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-    }\n-\n-  switch (dir)\n-    {\n-    case _IO_seek_cur:\n-      /* Adjust for read-ahead (bytes is buffer). */\n-      offset -= fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (fp->_offset == _IO_pos_BAD)\n-\tgoto dumb;\n-      /* Make offset absolute, assuming current pointer is file_ptr(). */\n-      offset += fp->_offset;\n-\n-      dir = _IO_seek_set;\n-      break;\n-    case _IO_seek_set:\n-      break;\n-    case _IO_seek_end:\n-      {\n-\tstruct _G_stat64 st;\n-\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n-\t  {\n-\t    offset += st.st_size;\n-\t    dir = _IO_seek_set;\n-\t  }\n-\telse\n-\t  goto dumb;\n-      }\n-    }\n-  /* At this point, dir==_IO_seek_set. */\n-\n-  /* If we are only interested in the current position we've found it now.  */\n-  if (mode == 0)\n-    return offset;\n-\n-  /* If destination is within current buffer, optimize: */\n-  if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n-      && !_IO_in_backup (fp))\n-    {\n-      /* Offset relative to start of main get area. */\n-      _IO_off64_t rel_offset = (offset - fp->_offset\n-\t\t\t\t+ (fp->_IO_read_end - fp->_IO_read_base));\n-      if (rel_offset >= 0)\n-\t{\n-#if 0\n-\t  if (_IO_in_backup (fp))\n-\t    _IO_switch_to_main_get_area (fp);\n-#endif\n-\t  if (rel_offset <= fp->_IO_read_end - fp->_IO_read_base)\n-\t    {\n-\t      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + rel_offset,\n-\t\t\tfp->_IO_read_end);\n-\t      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-\t      {\n-\t\t_IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-\t\tgoto resync;\n-\t      }\n-\t    }\n-#ifdef TODO\n-\t    /* If we have streammarkers, seek forward by reading ahead. */\n-\t    if (_IO_have_markers (fp))\n-\t      {\n-\t\tint to_skip = rel_offset\n-\t\t  - (fp->_IO_read_ptr - fp->_IO_read_base);\n-\t\tif (ignore (to_skip) != to_skip)\n-\t\t  goto dumb;\n-\t\t_IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-\t\tgoto resync;\n-\t      }\n-#endif\n-\t}\n-#ifdef TODO\n-      if (rel_offset < 0 && rel_offset >= Bbase () - Bptr ())\n-\t{\n-\t  if (!_IO_in_backup (fp))\n-\t    _IO_switch_to_backup_area (fp);\n-\t  gbump (fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n-\t  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-\t  goto resync;\n-\t}\n-#endif\n-    }\n-\n-#ifdef TODO\n-  _IO_unsave_markers (fp);\n-#endif\n-\n-  if (fp->_flags & _IO_NO_READS)\n-    goto dumb;\n-\n-  /* Try to seek to a block boundary, to improve kernel page management. */\n-  new_offset = offset & ~(fp->_IO_buf_end - fp->_IO_buf_base - 1);\n-  delta = offset - new_offset;\n-  if (delta > fp->_IO_buf_end - fp->_IO_buf_base)\n-    {\n-      new_offset = offset;\n-      delta = 0;\n-    }\n-  result = _IO_SYSSEEK (fp, new_offset, 0);\n-  if (result < 0)\n-    return EOF;\n-  if (delta == 0)\n-    count = 0;\n-  else\n-    {\n-      count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n-\t\t\t   (must_be_exact\n-\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n-      if (count < delta)\n-\t{\n-\t  /* We weren't allowed to read, but try to seek the remainder. */\n-\t  offset = count == EOF ? delta : delta-count;\n-\t  dir = _IO_seek_cur;\n-\t  goto dumb;\n-\t}\n-    }\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n-\t    fp->_IO_buf_base + count);\n-  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-  fp->_offset = result + count;\n-  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-  return offset;\n- dumb:\n-\n-  _IO_unsave_markers (fp);\n-  result = _IO_SYSSEEK (fp, offset, dir);\n-  if (result != EOF)\n-    {\n-      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-      fp->_offset = result;\n-      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-    }\n-  return result;\n-\n-resync:\n-  /* We need to do it since it is possible that the file offset in\n-     the kernel may be changed behind our back. It may happen when\n-     we fopen a file and then do a fork. One process may access the\n-     the file and the kernel file offset will be changed. */\n-  if (fp->_offset >= 0)\n-    _IO_SYSSEEK (fp, fp->_offset, 0);\n-\n-  return offset;\n-}\n-\n-_IO_ssize_t\n-_IO_file_read (fp, buf, size)\n-     _IO_FILE *fp;\n-     void *buf;\n-     _IO_ssize_t size;\n-{\n-  return read (fp->_fileno, buf, size);\n-}\n-\n-_IO_off64_t\n-_IO_file_seek (fp, offset, dir)\n-     _IO_FILE *fp;\n-     _IO_off64_t offset;\n-     int dir;\n-{\n-#ifdef _G_LSEEK64\n-  return _G_LSEEK64 (fp->_fileno, offset, dir);\n-#else\n-  return lseek (fp->_fileno, offset, dir);\n-#endif\n-}\n-\n-int\n-_IO_file_stat (fp, st)\n-     _IO_FILE *fp;\n-     void *st;\n-{\n-#ifdef _G_FSTAT64\n-  return _G_FSTAT64 (fp->_fileno, (struct _G_stat64 *) st);\n-#else\n-  return fstat (fp->_fileno, (struct stat *) st);\n-#endif\n-}\n-\n-int\n-_IO_file_close (fp)\n-     _IO_FILE *fp;\n-{\n-  return close (fp->_fileno);\n-}\n-\n-_IO_ssize_t\n-_IO_new_file_write (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_ssize_t n;\n-{\n-  _IO_ssize_t to_do = n;\n-  while (to_do > 0)\n-    {\n-      _IO_ssize_t count = write (f->_fileno, data, to_do);\n-      if (count < 0)\n-\t{\n-\t  f->_flags |= _IO_ERR_SEEN;\n-\t  break;\n-        }\n-      to_do -= count;\n-      data = (void *) ((char *) data + count);\n-    }\n-  n -= to_do;\n-  if (f->_offset >= 0)\n-    f->_offset += n;\n-  return n;\n-}\n-\n-_IO_size_t\n-_IO_new_file_xsputn (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_size_t n;\n-{\n-  register const char *s = (const char *) data;\n-  _IO_size_t to_do = n;\n-  int must_flush = 0;\n-  _IO_size_t count;\n-\n-  if (n <= 0)\n-    return 0;\n-  /* This is an optimized implementation.\n-     If the amount to be written straddles a block boundary\n-     (or the filebuf is unbuffered), use sys_write directly. */\n-\n-  /* First figure out how much space is available in the buffer. */\n-  count = f->_IO_write_end - f->_IO_write_ptr; /* Space available. */\n-  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n-    {\n-      count = f->_IO_buf_end - f->_IO_write_ptr;\n-      if (count >= n)\n-\t{\n-\t  register const char *p;\n-\t  for (p = s + n; p > s; )\n-\t    {\n-\t      if (*--p == '\\n')\n-\t\t{\n-\t\t  count = p - s + 1;\n-\t\t  must_flush = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  /* Then fill the buffer. */\n-  if (count > 0)\n-    {\n-      if (count > to_do)\n-\tcount = to_do;\n-      if (count > 20)\n-\t{\n-#ifdef _LIBC\n-\t  f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n-#else\n-\t  memcpy (f->_IO_write_ptr, s, count);\n-\t  f->_IO_write_ptr += count;\n-#endif\n-\t  s += count;\n-\t}\n-      else\n-\t{\n-\t  register char *p = f->_IO_write_ptr;\n-\t  register int i = (int) count;\n-\t  while (--i >= 0)\n-\t    *p++ = *s++;\n-\t  f->_IO_write_ptr = p;\n-\t}\n-      to_do -= count;\n-    }\n-  if (to_do + must_flush > 0)\n-    {\n-      _IO_size_t block_size, do_write;\n-      /* Next flush the (full) buffer. */\n-      if (_IO_OVERFLOW (f, EOF) == EOF)\n-\treturn n - to_do;\n-\n-      /* Try to maintain alignment: write a whole number of blocks.\n-\t dont_write is what gets left over. */\n-      block_size = f->_IO_buf_end - f->_IO_buf_base;\n-      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);\n-\n-      if (do_write)\n-        {\n-\t  count = new_do_write (f, s, do_write);\n-\t  to_do -= count;\n-\t  if (count < do_write)\n-\t    return n - to_do;\n-        }\n-\n-      /* Now write out the remainder.  Normally, this will fit in the\n-\t buffer, but it's somewhat messier for line-buffered files,\n-\t so we let _IO_default_xsputn handle the general case. */\n-      if (to_do)\n-\tto_do -= _IO_default_xsputn (f, s+do_write, to_do);\n-    }\n-  return n - to_do;\n-}\n-\n-_IO_size_t\n-_IO_file_xsgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  register _IO_size_t want, have;\n-  register _IO_ssize_t count;\n-  register char *s = data;\n-\n-  want = n;\n-\n-  if (fp->_IO_buf_base == NULL)\n-    {\n-      /* Maybe we already have a push back pointer.  */\n-      if (fp->_IO_save_base != NULL)\n-\t{\n-\t  free (fp->_IO_save_base);\n-\t  fp->_flags &= ~_IO_IN_BACKUP;\n-\t}\n-      _IO_doallocbuf (fp);\n-    }\n-\n-  while (want > 0)\n-    {\n-      have = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (want <= have)\n-\t{\n-\t  memcpy (s, fp->_IO_read_ptr, want);\n-\t  fp->_IO_read_ptr += want;\n-\t  want = 0;\n-\t}\n-      else\n-\t{\n-\t  if (have > 0)\n-\t    {\n-#ifdef _LIBC\n-\t      s = __mempcpy (s, fp->_IO_read_ptr, have);\n-#else\n-\t      memcpy (s, fp->_IO_read_ptr, have);\n-\t      s += have;\n-#endif\n-\t      want -= have;\n-\t      fp->_IO_read_ptr += have;\n-\t    }\n-\n-\t  /* Check for backup and repeat */\n-\t  if (_IO_in_backup (fp))\n-\t    {\n-\t      _IO_switch_to_main_get_area (fp);\n-\t      continue;\n-\t    }\n-\n-\t  /* If we now want less than a buffer, underflow and repeat\n-\t     the copy.  Otherwise, _IO_SYSREAD directly to\n-\t     the user buffer. */\n-\t  if (fp->_IO_buf_base && want < fp->_IO_buf_end - fp->_IO_buf_base)\n-\t    {\n-\t      if (__underflow (fp) == EOF)\n-\t\tbreak;\n-\n-\t      continue;\n-\t    }\n-\n-\t  /* These must be set before the sysread as we might longjmp out\n-\t     waiting for input. */\n-\t  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-\t  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-\n-\t  /* Try to maintain alignment: read a whole number of blocks.  */\n-\t  count = want;\n-\t  if (fp->_IO_buf_base)\n-\t    {\n-\t      _IO_size_t block_size = fp->_IO_buf_end - fp->_IO_buf_base;\n-\t      if (block_size >= 128)\n-\t\tcount -= want % block_size;\n-\t    }\n-\n-\t  count = _IO_SYSREAD (fp, s, count);\n-\t  if (count <= 0)\n-\t    {\n-\t      if (count == 0)\n-\t\tfp->_flags |= _IO_EOF_SEEN;\n-\t      else\n-\t\tfp->_flags |= _IO_ERR_SEEN;\n-\n-\t      break;\n-\t    }\n-\n-\t  s += count;\n-\t  want -= count;\n-\t  if (fp->_offset != _IO_pos_BAD)\n-\t    _IO_pos_adjust (fp->_offset, count);\n-\t}\n-    }\n-\n-  return n - want;\n-}\n-\n-struct _IO_jump_t _IO_file_jumps =\n-{\n-  JUMP_INIT_DUMMY,\n-  JUMP_INIT(finish, _IO_new_file_finish),\n-  JUMP_INIT(overflow, _IO_new_file_overflow),\n-  JUMP_INIT(underflow, _IO_new_file_underflow),\n-  JUMP_INIT(uflow, _IO_default_uflow),\n-  JUMP_INIT(pbackfail, _IO_default_pbackfail),\n-  JUMP_INIT(xsputn, _IO_new_file_xsputn),\n-  JUMP_INIT(xsgetn, _IO_file_xsgetn),\n-  JUMP_INIT(seekoff, _IO_new_file_seekoff),\n-  JUMP_INIT(seekpos, _IO_default_seekpos),\n-  JUMP_INIT(setbuf, _IO_new_file_setbuf),\n-  JUMP_INIT(sync, _IO_new_file_sync),\n-  JUMP_INIT(doallocate, _IO_file_doallocate),\n-  JUMP_INIT(read, _IO_file_read),\n-  JUMP_INIT(write, _IO_new_file_write),\n-  JUMP_INIT(seek, _IO_file_seek),\n-  JUMP_INIT(close, _IO_file_close),\n-  JUMP_INIT(stat, _IO_file_stat),\n-  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n-  JUMP_INIT(imbue, _IO_default_imbue)\n-};\n-\n-#ifdef _LIBC\n-versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);\n-versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);\n-#endif"}, {"sha": "b1ae5afc506fd350fc344b64ccbca13d8f2bb139", "filename": "libstdc++-v3/libio/genops.c", "status": "removed", "additions": 0, "deletions": 1123, "changes": 1123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fgenops.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,1123 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997-1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/* Generic or default I/O operations. */\n-\n-#include \"libioP.h\"\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#include <string.h>\n-\n-#ifdef _IO_MTSAFE_IO\n-static _IO_lock_t list_all_lock = _IO_lock_initializer;\n-#endif\n-\n-void\n-_IO_un_link (fp)\n-     struct _IO_FILE_plus *fp;\n-{\n-  if (fp->file._flags & _IO_LINKED)\n-    {\n-      struct _IO_FILE_plus **f;\n-#ifdef _IO_MTSAFE_IO\n-      _IO_lock_lock (list_all_lock);\n-#endif\n-      for (f = &_IO_list_all; *f; f = (struct _IO_FILE_plus **) &(*f)->file._chain)\n-\t{\n-\t  if (*f == fp)\n-\t    {\n-\t      *f = (struct _IO_FILE_plus *) fp->file._chain;\n-\t      break;\n-\t    }\n-\t}\n-#ifdef _IO_MTSAFE_IO\n-      _IO_lock_unlock (list_all_lock);\n-#endif\n-      fp->file._flags &= ~_IO_LINKED;\n-    }\n-}\n-\n-void\n-_IO_link_in (fp)\n-     struct _IO_FILE_plus *fp;\n-{\n-    if ((fp->file._flags & _IO_LINKED) == 0)\n-      {\n-\tfp->file._flags |= _IO_LINKED;\n-#ifdef _IO_MTSAFE_IO\n-\t_IO_lock_lock (list_all_lock);\n-#endif\n-\tfp->file._chain = (_IO_FILE *) _IO_list_all;\n-\t_IO_list_all = fp;\n-#ifdef _IO_MTSAFE_IO\n-\t_IO_lock_unlock (list_all_lock);\n-#endif\n-      }\n-}\n-\n-/* Return minimum _pos markers\n-   Assumes the current get area is the main get area. */\n-_IO_ssize_t _IO_least_marker __P ((_IO_FILE *fp, char *end_p));\n-\n-_IO_ssize_t\n-_IO_least_marker (fp, end_p)\n-     _IO_FILE *fp;\n-     char *end_p;\n-{\n-  _IO_ssize_t least_so_far = end_p - fp->_IO_read_base;\n-  struct _IO_marker *mark;\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    if (mark->_pos < least_so_far)\n-      least_so_far = mark->_pos;\n-  return least_so_far;\n-}\n-\n-/* Switch current get area from backup buffer to (start of) main get area. */\n-\n-void\n-_IO_switch_to_main_get_area (fp)\n-     _IO_FILE *fp;\n-{\n-  char *tmp;\n-  fp->_flags &= ~_IO_IN_BACKUP;\n-  /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_IO_read_end;\n-  fp->_IO_read_end = fp->_IO_save_end;\n-  fp->_IO_save_end= tmp;\n-  /* Swap _IO_read_base and _IO_save_base. */\n-  tmp = fp->_IO_read_base;\n-  fp->_IO_read_base = fp->_IO_save_base;\n-  fp->_IO_save_base = tmp;\n-  /* Set _IO_read_ptr. */\n-  fp->_IO_read_ptr = fp->_IO_read_base;\n-}\n-\n-/* Switch current get area from main get area to (end of) backup area. */\n-\n-void\n-_IO_switch_to_backup_area (fp)\n-     _IO_FILE *fp;\n-{\n-  char *tmp;\n-  fp->_flags |= _IO_IN_BACKUP;\n-  /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_IO_read_end;\n-  fp->_IO_read_end = fp->_IO_save_end;\n-  fp->_IO_save_end = tmp;\n-  /* Swap _IO_read_base and _IO_save_base. */\n-  tmp = fp->_IO_read_base;\n-  fp->_IO_read_base = fp->_IO_save_base;\n-  fp->_IO_save_base = tmp;\n-  /* Set _IO_read_ptr.  */\n-  fp->_IO_read_ptr = fp->_IO_read_end;\n-}\n-\n-int\n-_IO_switch_to_get_mode (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_IO_write_ptr > fp->_IO_write_base)\n-    if (_IO_OVERFLOW (fp, EOF) == EOF)\n-      return EOF;\n-  if (_IO_in_backup (fp))\n-    fp->_IO_read_base = fp->_IO_backup_base;\n-  else\n-    {\n-      fp->_IO_read_base = fp->_IO_buf_base;\n-      if (fp->_IO_write_ptr > fp->_IO_read_end)\n-\tfp->_IO_read_end = fp->_IO_write_ptr;\n-    }\n-  fp->_IO_read_ptr = fp->_IO_write_ptr;\n-\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = fp->_IO_read_ptr;\n-\n-  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n-  return 0;\n-}\n-\n-void\n-_IO_free_backup_area (fp)\n-     _IO_FILE *fp;\n-{\n-  if (_IO_in_backup (fp))\n-    _IO_switch_to_main_get_area (fp);  /* Just in case. */\n-  free (fp->_IO_save_base);\n-  fp->_IO_save_base = NULL;\n-  fp->_IO_save_end = NULL;\n-  fp->_IO_backup_base = NULL;\n-}\n-\n-#if 0\n-int\n-_IO_switch_to_put_mode (fp)\n-     _IO_FILE *fp;\n-{\n-  fp->_IO_write_base = fp->_IO_read_ptr;\n-  fp->_IO_write_ptr = fp->_IO_read_ptr;\n-  /* Following is wrong if line- or un-buffered? */\n-  fp->_IO_write_end = (fp->_flags & _IO_IN_BACKUP\n-\t\t       ? fp->_IO_read_end : fp->_IO_buf_end);\n-\n-  fp->_IO_read_ptr = fp->_IO_read_end;\n-  fp->_IO_read_base = fp->_IO_read_end;\n-\n-  fp->_flags |= _IO_CURRENTLY_PUTTING;\n-  return 0;\n-}\n-#endif\n-\n-int\n-__overflow (f, ch)\n-     _IO_FILE *f;\n-     int ch;\n-{\n-  /* This is a single-byte stream.  */\n-  if (f->_mode == 0)\n-    _IO_fwide (f, -1);\n-  return _IO_OVERFLOW (f, ch);\n-}\n-\n-static int save_for_backup __P ((_IO_FILE *fp, char *end_p))\n-#ifdef _LIBC\n-     internal_function\n-#endif\n-     ;\n-\n-static int\n-#ifdef _LIBC\n-internal_function\n-#endif\n-save_for_backup (fp, end_p)\n-     _IO_FILE *fp;\n-     char *end_p;\n-{\n-  /* Append [_IO_read_base..end_p] to backup area. */\n-  _IO_ssize_t least_mark = _IO_least_marker (fp, end_p);\n-  /* needed_size is how much space we need in the backup area. */\n-  _IO_size_t needed_size = (end_p - fp->_IO_read_base) - least_mark;\n-  /* FIXME: Dubious arithmetic if pointers are NULL */\n-  _IO_size_t current_Bsize = fp->_IO_save_end - fp->_IO_save_base;\n-  _IO_size_t avail; /* Extra space available for future expansion. */\n-  _IO_ssize_t delta;\n-  struct _IO_marker *mark;\n-  if (needed_size > current_Bsize)\n-    {\n-      char *new_buffer;\n-      avail = 100;\n-      new_buffer = (char *) malloc (avail + needed_size);\n-      if (new_buffer == NULL)\n-\treturn EOF;\t\t/* FIXME */\n-      if (least_mark < 0)\n-\t{\n-#ifdef _LIBC\n-\t  __mempcpy (__mempcpy (new_buffer + avail,\n-\t\t\t\tfp->_IO_save_end + least_mark,\n-\t\t\t\t-least_mark),\n-\t\t     fp->_IO_read_base,\n-\t\t     end_p - fp->_IO_read_base);\n-#else\n-\t  memcpy (new_buffer + avail,\n-\t\t  fp->_IO_save_end + least_mark,\n-\t\t  -least_mark);\n-\t  memcpy (new_buffer + avail - least_mark,\n-\t\t  fp->_IO_read_base,\n-\t\t  end_p - fp->_IO_read_base);\n-#endif\n-\t}\n-      else\n-\tmemcpy (new_buffer + avail,\n-\t\tfp->_IO_read_base + least_mark,\n-\t\tneeded_size);\n-      if (fp->_IO_save_base)\n-\tfree (fp->_IO_save_base);\n-      fp->_IO_save_base = new_buffer;\n-      fp->_IO_save_end = new_buffer + avail + needed_size;\n-    }\n-  else\n-    {\n-      avail = current_Bsize - needed_size;\n-      if (least_mark < 0)\n-\t{\n-\t  memmove (fp->_IO_save_base + avail,\n-\t\t   fp->_IO_save_end + least_mark,\n-\t\t   -least_mark);\n-\t  memcpy (fp->_IO_save_base + avail - least_mark,\n-\t\t  fp->_IO_read_base,\n-\t\t  end_p - fp->_IO_read_base);\n-\t}\n-      else if (needed_size > 0)\n-\tmemcpy (fp->_IO_save_base + avail,\n-\t\tfp->_IO_read_base + least_mark,\n-\t\tneeded_size);\n-    }\n-  fp->_IO_backup_base = fp->_IO_save_base + avail;\n-  /* Adjust all the streammarkers. */\n-  delta = end_p - fp->_IO_read_base;\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    mark->_pos -= delta;\n-  return 0;\n-}\n-\n-int\n-__underflow (fp)\n-     _IO_FILE *fp;\n-{\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  if (fp->_vtable_offset == 0 && _IO_fwide (fp, -1) != -1)\n-    return EOF;\n-#endif\n-\n-  if (fp->_mode == 0)\n-    _IO_fwide (fp, -1);\n-  if (_IO_in_put_mode (fp))\n-    if (_IO_switch_to_get_mode (fp) == EOF)\n-      return EOF;\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char *) fp->_IO_read_ptr;\n-  if (_IO_in_backup (fp))\n-    {\n-      _IO_switch_to_main_get_area (fp);\n-      if (fp->_IO_read_ptr < fp->_IO_read_end)\n-\treturn *(unsigned char *) fp->_IO_read_ptr;\n-    }\n-  if (_IO_have_markers (fp))\n-    {\n-      if (save_for_backup (fp, fp->_IO_read_end))\n-\treturn EOF;\n-    }\n-  else if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-  return _IO_UNDERFLOW (fp);\n-}\n-\n-int\n-__uflow (fp)\n-     _IO_FILE *fp;\n-{\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  if (fp->_vtable_offset == 0 && _IO_fwide (fp, -1) != -1)\n-    return EOF;\n-#endif\n-\n-  if (fp->_mode == 0)\n-    _IO_fwide (fp, -11);\n-  if (_IO_in_put_mode (fp))\n-    if (_IO_switch_to_get_mode (fp) == EOF)\n-      return EOF;\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    return *(unsigned char *) fp->_IO_read_ptr++;\n-  if (_IO_in_backup (fp))\n-    {\n-      _IO_switch_to_main_get_area (fp);\n-      if (fp->_IO_read_ptr < fp->_IO_read_end)\n-\treturn *(unsigned char *) fp->_IO_read_ptr++;\n-    }\n-  if (_IO_have_markers (fp))\n-    {\n-      if (save_for_backup (fp, fp->_IO_read_end))\n-\treturn EOF;\n-    }\n-  else if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-  return _IO_UFLOW (fp);\n-}\n-\n-void\n-_IO_setb (f, b, eb, a)\n-     _IO_FILE *f;\n-      char *b;\n-     char *eb;\n-     int a;\n-{\n-  if (f->_IO_buf_base && !(f->_flags & _IO_USER_BUF))\n-    FREE_BUF (f->_IO_buf_base, _IO_blen (f));\n-  f->_IO_buf_base = b;\n-  f->_IO_buf_end = eb;\n-  if (a)\n-    f->_flags &= ~_IO_USER_BUF;\n-  else\n-    f->_flags |= _IO_USER_BUF;\n-}\n-\n-void\n-_IO_doallocbuf (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_IO_buf_base)\n-    return;\n-  if (!(fp->_flags & _IO_UNBUFFERED))\n-    if (_IO_DOALLOCATE (fp) != EOF)\n-      return;\n-  _IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n-}\n-\n-int\n-_IO_default_underflow (fp)\n-     _IO_FILE *fp;\n-{\n-  return EOF;\n-}\n-\n-int\n-_IO_default_uflow (fp)\n-     _IO_FILE *fp;\n-{\n-  int ch = _IO_UNDERFLOW (fp);\n-  if (ch == EOF)\n-    return EOF;\n-  return *(unsigned char *) fp->_IO_read_ptr++;\n-}\n-\n-_IO_size_t\n-_IO_default_xsputn (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_size_t n;\n-{\n-  const char *s = (char *) data;\n-  _IO_size_t more = n;\n-  if (more <= 0)\n-    return 0;\n-  for (;;)\n-    {\n-      /* Space available. */\n-      _IO_ssize_t count = f->_IO_write_end - f->_IO_write_ptr;\n-      if (count > 0)\n-\t{\n-\t  if ((_IO_size_t) count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-#ifdef _LIBC\n-\t      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n-#else\n-\t      memcpy (f->_IO_write_ptr, s, count);\n-\t      f->_IO_write_ptr += count;\n-#endif\n-\t      s += count;\n-            }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      char *p = f->_IO_write_ptr;\n-\t      _IO_ssize_t i;\n-\t      for (i = count; --i >= 0; )\n-\t\t*p++ = *s++;\n-\t      f->_IO_write_ptr = p;\n-            }\n-\t  more -= count;\n-        }\n-      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)\n-\tbreak;\n-      more--;\n-    }\n-  return n - more;\n-}\n-\n-_IO_size_t\n-_IO_sgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  /* FIXME handle putback buffer here! */\n-  return _IO_XSGETN (fp, data, n);\n-}\n-\n-_IO_size_t\n-_IO_default_xsgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  _IO_size_t more = n;\n-  char *s = (char*) data;\n-  for (;;)\n-    {\n-      /* Data available. */\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (count > 0)\n-\t{\n-\t  if ((_IO_size_t) count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-#ifdef _LIBC\n-\t      s = __mempcpy (s, fp->_IO_read_ptr, count);\n-#else\n-\t      memcpy (s, fp->_IO_read_ptr, count);\n-\t      s += count;\n-#endif\n-\t      fp->_IO_read_ptr += count;\n-\t    }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      char *p = fp->_IO_read_ptr;\n-\t      int i = (int) count;\n-\t      while (--i >= 0)\n-\t\t*s++ = *p++;\n-\t      fp->_IO_read_ptr = p;\n-            }\n-            more -= count;\n-        }\n-      if (more == 0 || __underflow (fp) == EOF)\n-\tbreak;\n-    }\n-  return n - more;\n-}\n-\n-#if 0\n-/* Seems not to be needed. --drepper */\n-int\n-_IO_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  return 0;\n-}\n-#endif\n-\n-_IO_FILE *\n-_IO_default_setbuf (fp, p, len)\n-     _IO_FILE *fp;\n-     char *p;\n-     _IO_ssize_t len;\n-{\n-    if (_IO_SYNC (fp) == EOF)\n-\treturn NULL;\n-    if (p == NULL || len == 0)\n-      {\n-\tfp->_flags |= _IO_UNBUFFERED;\n-\t_IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n-      }\n-    else\n-      {\n-\tfp->_flags &= ~_IO_UNBUFFERED;\n-\t_IO_setb (fp, p, p+len, 0);\n-      }\n-    fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = 0;\n-    fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end = 0;\n-    return fp;\n-}\n-\n-_IO_off64_t\n-_IO_default_seekpos (fp, pos, mode)\n-     _IO_FILE *fp;\n-     _IO_off64_t pos;\n-     int mode;\n-{\n-  return _IO_SEEKOFF (fp, pos, 0, mode);\n-}\n-\n-int\n-_IO_default_doallocate (fp)\n-     _IO_FILE *fp;\n-{\n-  char *buf;\n-\n-  ALLOC_BUF (buf, _IO_BUFSIZ, EOF);\n-  _IO_setb (fp, buf, buf+_IO_BUFSIZ, 1);\n-  return 1;\n-}\n-\n-void\n-_IO_init (fp, flags)\n-     _IO_FILE *fp;\n-     int flags;\n-{\n-  _IO_no_init (fp, flags, -1, NULL, NULL);\n-}\n-\n-void\n-_IO_no_init (fp, flags, orientation, wd, jmp)\n-     _IO_FILE *fp;\n-     int flags;\n-     int orientation;\n-     struct _IO_wide_data *wd;\n-     struct _IO_jump_t *jmp;\n-{\n-  fp->_flags = _IO_MAGIC|flags;\n-  fp->_IO_buf_base = NULL;\n-  fp->_IO_buf_end = NULL;\n-  fp->_IO_read_base = NULL;\n-  fp->_IO_read_ptr = NULL;\n-  fp->_IO_read_end = NULL;\n-  fp->_IO_write_base = NULL;\n-  fp->_IO_write_ptr = NULL;\n-  fp->_IO_write_end = NULL;\n-  fp->_chain = NULL; /* Not necessary. */\n-\n-  fp->_IO_save_base = NULL;\n-  fp->_IO_backup_base = NULL;\n-  fp->_IO_save_end = NULL;\n-  fp->_markers = NULL;\n-  fp->_cur_column = 0;\n-#if _IO_JUMPS_OFFSET\n-  fp->_vtable_offset = 0;\n-#endif\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_init (*fp->_lock);\n-#endif\n-  fp->_mode = orientation;\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  if (orientation >= 0)\n-    {\n-      fp->_wide_data = wd;\n-      fp->_wide_data->_IO_buf_base = NULL;\n-      fp->_wide_data->_IO_buf_end = NULL;\n-      fp->_wide_data->_IO_read_base = NULL;\n-      fp->_wide_data->_IO_read_ptr = NULL;\n-      fp->_wide_data->_IO_read_end = NULL;\n-      fp->_wide_data->_IO_write_base = NULL;\n-      fp->_wide_data->_IO_write_ptr = NULL;\n-      fp->_wide_data->_IO_write_end = NULL;\n-      fp->_wide_data->_IO_save_base = NULL;\n-      fp->_wide_data->_IO_backup_base = NULL;\n-      fp->_wide_data->_IO_save_end = NULL;\n-\n-      fp->_wide_data->_wide_vtable = jmp;\n-    }\n-#endif\n-}\n-\n-int\n-_IO_default_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  return 0;\n-}\n-\n-/* The way the C++ classes are mapped into the C functions in the\n-   current implementation, this function can get called twice! */\n-\n-void\n-_IO_default_finish (fp, dummy)\n-     _IO_FILE *fp;\n-     int dummy;\n-{\n-  struct _IO_marker *mark;\n-  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n-    {\n-      FREE_BUF (fp->_IO_buf_base, _IO_blen (fp));\n-      fp->_IO_buf_base = fp->_IO_buf_end = NULL;\n-    }\n-\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    mark->_sbuf = NULL;\n-\n-  if (fp->_IO_save_base)\n-    {\n-      free (fp->_IO_save_base);\n-      fp->_IO_save_base = NULL;\n-    }\n-\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_fini (*fp->_lock);\n-#endif\n-\n-  _IO_un_link ((struct _IO_FILE_plus *) fp);\n-}\n-\n-_IO_off64_t\n-_IO_default_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off64_t offset;\n-     int dir;\n-     int mode;\n-{\n-    return _IO_pos_BAD;\n-}\n-\n-int\n-_IO_sputbackc (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  int result;\n-\n-  if (fp->_IO_read_ptr > fp->_IO_read_base\n-      && (unsigned char)fp->_IO_read_ptr[-1] == (unsigned char)c)\n-    {\n-      fp->_IO_read_ptr--;\n-      result = (unsigned char) c;\n-    }\n-  else\n-    result = _IO_PBACKFAIL (fp, c);\n-\n-  if (result != EOF)\n-    fp->_flags &= ~_IO_EOF_SEEN;\n-\n-  return result;\n-}\n-\n-int\n-_IO_sungetc (fp)\n-     _IO_FILE *fp;\n-{\n-  int result;\n-\n-  if (fp->_IO_read_ptr > fp->_IO_read_base)\n-    {\n-      fp->_IO_read_ptr--;\n-      result = (unsigned char) *fp->_IO_read_ptr;\n-    }\n-  else\n-    result = _IO_PBACKFAIL (fp, EOF);\n-\n-  if (result != EOF)\n-    fp->_flags &= ~_IO_EOF_SEEN;\n-\n-  return result;\n-}\n-\n-#if 0 /* Work in progress */\n-/* Seems not to be needed.  */\n-#if 0\n-void\n-_IO_set_column (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  if (c == -1)\n-    fp->_column = -1;\n-  else\n-    fp->_column = c - (fp->_IO_write_ptr - fp->_IO_write_base);\n-}\n-#else\n-int\n-_IO_set_column (fp, i)\n-     _IO_FILE *fp;\n-     int i;\n-{\n-  fp->_cur_column = i + 1;\n-  return 0;\n-}\n-#endif\n-#endif\n-\n-\n-unsigned\n-_IO_adjust_column (start, line, count)\n-     unsigned start;\n-     const char *line;\n-     int count;\n-{\n-  const char *ptr = line + count;\n-  while (ptr > line)\n-    if (*--ptr == '\\n')\n-      return line + count - ptr - 1;\n-  return start + count;\n-}\n-\n-#if 0\n-/* Seems not to be needed. --drepper */\n-int\n-_IO_get_column (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_cur_column)\n-    return _IO_adjust_column (fp->_cur_column - 1,\n-\t\t\t      fp->_IO_write_base,\n-\t\t\t      fp->_IO_write_ptr - fp->_IO_write_base);\n-  return -1;\n-}\n-#endif\n-\n-int\n-_IO_flush_all ()\n-{\n-  int result = 0;\n-  struct _IO_FILE *fp;\n-  for (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp->_chain)\n-    if (((fp->_mode < 0 && fp->_IO_write_ptr > fp->_IO_write_base)\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-\t || (fp->_vtable_offset == 0\n-\t     && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr\n-\t\t\t\t  > fp->_wide_data->_IO_write_base))\n-#endif\n-\t )\n-\t&& _IO_OVERFLOW (fp, EOF) == EOF)\n-      result = EOF;\n-  return result;\n-}\n-\n-void\n-_IO_flush_all_linebuffered ()\n-{\n-  struct _IO_FILE *fp;\n-  for (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp->_chain)\n-    if ((fp->_flags & _IO_NO_WRITES) == 0 && fp->_flags & _IO_LINE_BUF)\n-      _IO_OVERFLOW (fp, EOF);\n-}\n-\n-static void _IO_unbuffer_write __P ((void));\n-\n-static void\n-_IO_unbuffer_write ()\n-{\n-  struct _IO_FILE *fp;\n-  for (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp->_chain)\n-    if (! (fp->_flags & _IO_UNBUFFERED)\n-\t&& (! (fp->_flags & _IO_NO_WRITES)\n-\t    || (fp->_flags & _IO_IS_APPENDING))\n-\t/* Iff stream is un-orientated, it wasn't used. */\n-\t&& fp->_mode != 0)\n-      _IO_SETBUF (fp, NULL, 0);\n-}\n-\n-int\n-_IO_cleanup ()\n-{\n-  int result = _IO_flush_all ();\n-\n-  /* We currently don't have a reliable mechanism for making sure that\n-     C++ static destructors are executed in the correct order.\n-     So it is possible that other static destructors might want to\n-     write to cout - and they're supposed to be able to do so.\n-\n-     The following will make the standard streambufs be unbuffered,\n-     which forces any output from late destructors to be written out. */\n-  _IO_unbuffer_write ();\n-\n-  return result;\n-}\n-\n-\n-void\n-_IO_init_marker (marker, fp)\n-     struct _IO_marker *marker;\n-     _IO_FILE *fp;\n-{\n-  marker->_sbuf = fp;\n-  if (_IO_in_put_mode (fp))\n-    _IO_switch_to_get_mode (fp);\n-  if (_IO_in_backup (fp))\n-    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_end;\n-  else\n-    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n-\n-  /* Should perhaps sort the chain? */\n-  marker->_next = fp->_markers;\n-  fp->_markers = marker;\n-}\n-\n-void\n-_IO_remove_marker (marker)\n-     struct _IO_marker *marker;\n-{\n-  /* Unlink from sb's chain. */\n-  struct _IO_marker **ptr = &marker->_sbuf->_markers;\n-  for (; ; ptr = &(*ptr)->_next)\n-    {\n-      if (*ptr == NULL)\n-\tbreak;\n-      else if (*ptr == marker)\n-\t{\n-\t  *ptr = marker->_next;\n-\t  return;\n-\t}\n-    }\n-#if 0\n-    if _sbuf has a backup area that is no longer needed, should we delete\n-    it now, or wait until the next underflow?\n-#endif\n-}\n-\n-#define BAD_DELTA EOF\n-\n-int\n-_IO_marker_difference (mark1, mark2)\n-     struct _IO_marker *mark1;\n-     struct _IO_marker *mark2;\n-{\n-  return mark1->_pos - mark2->_pos;\n-}\n-\n-/* Return difference between MARK and current position of MARK's stream. */\n-int\n-_IO_marker_delta (mark)\n-     struct _IO_marker *mark;\n-{\n-  int cur_pos;\n-  if (mark->_sbuf == NULL)\n-    return BAD_DELTA;\n-  if (_IO_in_backup (mark->_sbuf))\n-    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_end;\n-  else\n-    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_base;\n-  return mark->_pos - cur_pos;\n-}\n-\n-int\n-_IO_seekmark (fp, mark, delta)\n-     _IO_FILE *fp;\n-     struct _IO_marker *mark;\n-     int delta;\n-{\n-  if (mark->_sbuf != fp)\n-    return EOF;\n- if (mark->_pos >= 0)\n-    {\n-      if (_IO_in_backup (fp))\n-\t_IO_switch_to_main_get_area (fp);\n-      fp->_IO_read_ptr = fp->_IO_read_base + mark->_pos;\n-    }\n-  else\n-    {\n-      if (!_IO_in_backup (fp))\n-\t_IO_switch_to_backup_area (fp);\n-      fp->_IO_read_ptr = fp->_IO_read_end + mark->_pos;\n-    }\n-  return 0;\n-}\n-\n-void\n-_IO_unsave_markers (fp)\n-     _IO_FILE *fp;\n-{\n-  struct _IO_marker *mark = fp->_markers;\n-  if (mark)\n-    {\n-#ifdef TODO\n-      streampos offset = seekoff (0, ios::cur, ios::in);\n-      if (offset != EOF)\n-\t{\n-\t  offset += eGptr () - Gbase ();\n-\t  for ( ; mark != NULL; mark = mark->_next)\n-\t    mark->set_streampos (mark->_pos + offset);\n-\t}\n-    else\n-      {\n-\tfor ( ; mark != NULL; mark = mark->_next)\n-\t  mark->set_streampos (EOF);\n-      }\n-#endif\n-      fp->_markers = 0;\n-    }\n-\n-  if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-}\n-\n-#if 0\n-/* Seems not to be needed. --drepper */\n-int\n-_IO_nobackup_pbackfail (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  if (fp->_IO_read_ptr > fp->_IO_read_base)\n-\tfp->_IO_read_ptr--;\n-  if (c != EOF && *fp->_IO_read_ptr != c)\n-      *fp->_IO_read_ptr = c;\n-  return (unsigned char) c;\n-}\n-#endif\n-\n-int\n-_IO_default_pbackfail (fp, c)\n-     _IO_FILE *fp;\n-     int c;\n-{\n-  if (fp->_IO_read_ptr > fp->_IO_read_base && !_IO_in_backup (fp)\n-      && (unsigned char) fp->_IO_read_ptr[-1] == c)\n-    --fp->_IO_read_ptr;\n-  else\n-    {\n-      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n-      if (!_IO_in_backup (fp))\n-\t{\n-\t  /* We need to keep the invariant that the main get area\n-\t     logically follows the backup area.  */\n-\t  if (fp->_IO_read_ptr > fp->_IO_read_base && _IO_have_backup (fp))\n-\t    {\n-\t      if (save_for_backup (fp, fp->_IO_read_ptr))\n-\t\treturn EOF;\n-\t    }\n-\t  else if (!_IO_have_backup (fp))\n-\t    {\n-\t      /* No backup buffer: allocate one. */\n-\t      /* Use nshort buffer, if unused? (probably not)  FIXME */\n-\t      int backup_size = 128;\n-\t      char *bbuf = (char *) malloc (backup_size);\n-\t      if (bbuf == NULL)\n-\t\treturn EOF;\n-\t      fp->_IO_save_base = bbuf;\n-\t      fp->_IO_save_end = fp->_IO_save_base + backup_size;\n-\t      fp->_IO_backup_base = fp->_IO_save_end;\n-\t    }\n-\t  fp->_IO_read_base = fp->_IO_read_ptr;\n-\t  _IO_switch_to_backup_area (fp);\n-\t}\n-      else if (fp->_IO_read_ptr <= fp->_IO_read_base)\n-\t{\n-\t  /* Increase size of existing backup buffer. */\n-\t  _IO_size_t new_size;\n-\t  _IO_size_t old_size = fp->_IO_read_end - fp->_IO_read_base;\n-\t  char *new_buf;\n-\t  new_size = 2 * old_size;\n-\t  new_buf = (char *) malloc (new_size);\n-\t  if (new_buf == NULL)\n-\t    return EOF;\n-\t  memcpy (new_buf + (new_size - old_size), fp->_IO_read_base,\n-\t\t  old_size);\n-\t  free (fp->_IO_read_base);\n-\t  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),\n-\t\t    new_buf + new_size);\n-\t  fp->_IO_backup_base = fp->_IO_read_ptr;\n-\t}\n-\n-      *--fp->_IO_read_ptr = c;\n-    }\n-  return (unsigned char) c;\n-}\n-\n-_IO_off64_t\n-_IO_default_seek (fp, offset, dir)\n-     _IO_FILE *fp;\n-     _IO_off64_t offset;\n-     int dir;\n-{\n-  return _IO_pos_BAD;\n-}\n-\n-int\n-_IO_default_stat (fp, st)\n-     _IO_FILE *fp;\n-     void* st;\n-{\n-  return EOF;\n-}\n-\n-_IO_ssize_t\n-_IO_default_read (fp, data, n)\n-     _IO_FILE* fp;\n-     void *data;\n-     _IO_ssize_t n;\n-{\n-  return -1;\n-}\n-\n-_IO_ssize_t\n-_IO_default_write (fp, data, n)\n-     _IO_FILE *fp;\n-     const void *data;\n-     _IO_ssize_t n;\n-{\n-  return 0;\n-}\n-\n-int\n-_IO_default_showmanyc (fp)\n-     _IO_FILE *fp;\n-{\n-  return -1;\n-}\n-\n-void\n-_IO_default_imbue (fp, locale)\n-     _IO_FILE *fp;\n-     void *locale;\n-{\n-}\n-\n-_IO_ITER\n-_IO_iter_begin()\n-{\n-  return (_IO_ITER) _IO_list_all;\n-}\n-\n-_IO_ITER\n-_IO_iter_end()\n-{\n-  return NULL;\n-}\n-\n-_IO_ITER\n-_IO_iter_next(iter)\n-    _IO_ITER iter;\n-{\n-  return iter->_chain;\n-}\n-\n-_IO_FILE *\n-_IO_iter_file(iter)\n-    _IO_ITER iter;\n-{\n-  return iter;\n-}\n-\n-void\n-_IO_list_lock()\n-{\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_lock (list_all_lock);\n-#endif\n-}\n-\n-void\n-_IO_list_unlock()\n-{\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_unlock (list_all_lock);\n-#endif\n-}\n-\n-void\n-_IO_list_resetlock()\n-{\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_init (list_all_lock);\n-#endif\n-}\n-\n-\n-#ifdef TODO\n-#if defined(linux)\n-#define IO_CLEANUP ;\n-#endif\n-\n-#ifdef IO_CLEANUP\n-  IO_CLEANUP\n-#else\n-struct __io_defs {\n-    __io_defs() { }\n-    ~__io_defs() { _IO_cleanup (); }\n-};\n-__io_defs io_defs__;\n-#endif\n-\n-#endif /* TODO */\n-\n-#ifdef weak_alias\n-weak_alias (_IO_cleanup, _cleanup)\n-#endif\n-\n-#ifdef text_set_element\n-text_set_element(__libc_atexit, _cleanup);\n-#endif"}, {"sha": "43a3f5833fc5a916d6d7205840ca9fb29fc6f538", "filename": "libstdc++-v3/libio/iofclose.c", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiofclose.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiofclose.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiofclose.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,97 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997-1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#if _LIBC\n-# include \"../iconv/gconv_int.h\"\n-# include <shlib-compat.h>\n-#else\n-# define SHLIB_COMPAT(a, b, c) 0\n-# define _IO_new_fclose fclose\n-#endif\n-\n-int\n-_IO_new_fclose (fp)\n-     _IO_FILE *fp;\n-{\n-  int status;\n-\n-  CHECK_FILE(fp, EOF);\n-\n-#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)\n-  /* We desperately try to help programs which are using streams in a\n-     strange way and mix old and new functions.  Detect old streams\n-     here.  */\n-  if (fp->_vtable_offset != 0)\n-    return _IO_old_fclose (fp);\n-#endif\n-\n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n-  if (fp->_IO_file_flags & _IO_IS_FILEBUF)\n-    status = _IO_file_close_it (fp);\n-  else\n-    status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;\n-  _IO_FINISH (fp);\n-  _IO_funlockfile (fp);\n-  if (fp->_mode > 0)\n-    {\n-#if _LIBC\n-      /* This stream has a wide orientation.  This means we have to free\n-\t the conversion functions.  */\n-      struct _IO_codecvt *cc = fp->_codecvt;\n-\n-      if (cc->__cd_in.__cd.__steps->__shlib_handle != NULL)\n-\t{\n-\t  --cc->__cd_in.__cd.__steps->__counter;\n-\t  __gconv_close_transform (cc->__cd_in.__cd.__steps, 1);\n-\t}\n-      if (cc->__cd_out.__cd.__steps->__shlib_handle != NULL)\n-\t{\n-\t  --cc->__cd_out.__cd.__steps->__counter;\n-\t  __gconv_close_transform (cc->__cd_out.__cd.__steps, 1);\n-\t}\n-#endif\n-    }\n-  _IO_cleanup_region_end (0);\n-  if (_IO_have_backup (fp))\n-    _IO_free_backup_area (fp);\n-  if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)\n-    {\n-      fp->_IO_file_flags = 0;\n-      free(fp);\n-    }\n-\n-  return status;\n-}\n-\n-#ifdef _LIBC\n-versioned_symbol (libc, _IO_new_fclose, _IO_fclose, GLIBC_2_1);\n-strong_alias (_IO_new_fclose, __new_fclose)\n-versioned_symbol (libc, __new_fclose, fclose, GLIBC_2_1);\n-#endif"}, {"sha": "2dcdee0235cbf51fcb1b237eea4288e5482dc748", "filename": "libstdc++-v3/libio/iofopen.c", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiofopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiofopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiofopen.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,78 +0,0 @@\n-/* Copyright (C) 1993, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#ifdef _LIBC\n-# include <shlib-compat.h>\n-#else\n-# define _IO_new_fopen fopen\n-#endif\n-\n-_IO_FILE *\n-_IO_new_fopen (filename, mode)\n-     const char *filename;\n-     const char *mode;\n-{\n-  struct locked_FILE\n-  {\n-    struct _IO_FILE_plus fp;\n-#ifdef _IO_MTSAFE_IO\n-    _IO_lock_t lock;\n-#endif\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-    struct _IO_wide_data wd;\n-#endif /* !(defined _LIBC || defined _GLIBCPP_USE_WCHAR_T) */\n-  } *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n-\n-  if (new_f == NULL)\n-    return NULL;\n-#ifdef _IO_MTSAFE_IO\n-  new_f->fp.file._lock = &new_f->lock;\n-#endif\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  _IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd, &_IO_wfile_jumps);\n-#else\n-  _IO_no_init (&new_f->fp.file, 1, 0, NULL, NULL);\n-#endif\n-  _IO_JUMPS (&new_f->fp) = &_IO_file_jumps;\n-  _IO_file_init (&new_f->fp);\n-#if  !_IO_UNIFIED_JUMPTABLES\n-  new_f->fp.vtable = NULL;\n-#endif\n-  if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, 1) != NULL)\n-    return (_IO_FILE *) &new_f->fp;\n-  _IO_un_link (&new_f->fp);\n-  free (new_f);\n-  return NULL;\n-}\n-\n-#ifdef _LIBC\n-strong_alias (_IO_new_fopen, __new_fopen)\n-versioned_symbol (libc, _IO_new_fopen, _IO_fopen, GLIBC_2_1);\n-versioned_symbol (libc, __new_fopen, fopen, GLIBC_2_1);\n-#endif"}, {"sha": "76a20ce3fb43eecf4f5516129c77c1a62142756c", "filename": "libstdc++-v3/libio/iofwide.c", "status": "removed", "additions": 0, "deletions": 476, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiofwide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiofwide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiofwide.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,476 +0,0 @@\n-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include <libioP.h>\n-#ifdef _LIBC\n-# include <dlfcn.h>\n-# include <wchar.h>\n-# include <locale/localeinfo.h>\n-# include <wcsmbs/wcsmbsload.h>\n-# include <iconv/gconv_int.h>\n-#endif\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#if defined(_LIBC) || defined(_GLIBCPP_USE_WCHAR_T)\n-# include <langinfo.h>\n-#endif\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-/* Prototypes of libio's codecvt functions.  */\n-static enum __codecvt_result do_out (struct _IO_codecvt *codecvt,\n-\t\t\t\t     __c_mbstate_t *statep,\n-\t\t\t\t     const wchar_t *from_start,\n-\t\t\t\t     const wchar_t *from_end,\n-\t\t\t\t     const wchar_t **from_stop, char *to_start,\n-\t\t\t\t     char *to_end, char **to_stop);\n-static enum __codecvt_result do_unshift (struct _IO_codecvt *codecvt,\n-\t\t\t\t\t __c_mbstate_t *statep, char *to_start,\n-\t\t\t\t\t char *to_end, char **to_stop);\n-static enum __codecvt_result do_in (struct _IO_codecvt *codecvt,\n-\t\t\t\t    __c_mbstate_t *statep,\n-\t\t\t\t    const char *from_start,\n-\t\t\t\t    const char *from_end,\n-\t\t\t\t    const char **from_stop, wchar_t *to_start,\n-\t\t\t\t    wchar_t *to_end, wchar_t **to_stop);\n-static int do_encoding (struct _IO_codecvt *codecvt);\n-static int do_length (struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-\t\t      const char *from_start,\n-\t\t      const char *from_end, _IO_size_t max);\n-static int do_max_length (struct _IO_codecvt *codecvt);\n-static int do_always_noconv (struct _IO_codecvt *codecvt);\n-\n-\n-/* The functions used in `codecvt' for libio are always the same.  */\n-struct _IO_codecvt __libio_codecvt =\n-{\n-  .__codecvt_destr = NULL,\t\t/* Destructor, never used.  */\n-  .__codecvt_do_out = do_out,\n-  .__codecvt_do_unshift = do_unshift,\n-  .__codecvt_do_in = do_in,\n-  .__codecvt_do_encoding = do_encoding,\n-  .__codecvt_do_always_noconv = do_always_noconv,\n-  .__codecvt_do_length = do_length,\n-  .__codecvt_do_max_length = do_max_length\n-};\n-\n-\n-#ifdef _LIBC\n-static struct __gconv_trans_data libio_translit =\n-{\n-  .__trans_fct = __gconv_transliterate\n-};\n-#endif\n-#endif /* defined(GLIBCPP_USE_WCHAR_T) */\n-\n-/* Return orientation of stream.  If mode is nonzero try to change\n-   the orientation first.  */\n-#undef _IO_fwide\n-int\n-_IO_fwide (fp, mode)\n-     _IO_FILE *fp;\n-     int mode;\n-{\n-  /* Normalize the value.  */\n-  mode = mode < 0 ? -1 : (mode == 0 ? 0 : 1);\n-\n-  if (mode == 0 || fp->_mode != 0)\n-    /* The caller simply wants to know about the current orientation\n-       or the orientation already has been determined.  */\n-    return fp->_mode;\n-\n-  /* Set the orientation appropriately.  */\n-  if (mode > 0)\n-    {\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-      struct _IO_codecvt *cc = fp->_codecvt;\n-\n-      fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n-      fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_write_base;\n-\n-#ifdef _LIBC\n-      /* Get the character conversion functions based on the currently\n-\t selected locale for LC_CTYPE.  */\n-      {\n-\tstruct gconv_fcts fcts;\n-\n-\t/* Clear the state.  We start all over again.  */\n-\tmemset (&fp->_wide_data->_IO_state, '\\0', sizeof (__c_mbstate_t));\n-\tmemset (&fp->_wide_data->_IO_last_state, '\\0', sizeof (__c_mbstate_t));\n-\n-\t__wcsmbs_clone_conv (&fcts);\n-\n-\t/* The functions are always the same.  */\n-\t*cc = __libio_codecvt;\n-\n-\tcc->__cd_in.__cd.__nsteps = 1; /* Only one step allowed.  */\n-\tcc->__cd_in.__cd.__steps = fcts.towc;\n-\n-\tcc->__cd_in.__cd.__data[0].__invocation_counter = 0;\n-\tcc->__cd_in.__cd.__data[0].__internal_use = 1;\n-\tcc->__cd_in.__cd.__data[0].__flags = __GCONV_IS_LAST;\n-\tcc->__cd_in.__cd.__data[0].__statep = &fp->_wide_data->_IO_state;\n-\n-\t/* XXX For now no transliteration.  */\n-\tcc->__cd_in.__cd.__data[0].__trans = NULL;\n-\n-\tcc->__cd_out.__cd.__nsteps = 1; /* Only one step allowed.  */\n-\tcc->__cd_out.__cd.__steps = fcts.tomb;\n-\n-\tcc->__cd_out.__cd.__data[0].__invocation_counter = 0;\n-\tcc->__cd_out.__cd.__data[0].__internal_use = 1;\n-\tcc->__cd_out.__cd.__data[0].__flags = __GCONV_IS_LAST;\n-\tcc->__cd_out.__cd.__data[0].__statep = &fp->_wide_data->_IO_state;\n-\n-\t/* And now the transliteration.  */\n-\tcc->__cd_out.__cd.__data[0].__trans = &libio_translit;\n-      }\n-#else\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-      {\n-\t/* Determine internal and external character sets.\n-\t   XXX For now we make our life easy: we assume a fixed internal\n-\t   encoding (as most sane systems have; hi HP/UX!).  If somebody\n-\t   cares about systems which changing internal charsets they\n-\t   should come up with a solution for the determination of the\n-\t   currently used internal character set.  */\n-#if 0\n-\tconst char *internal_ccs = _G_INTERNAL_CCS;\n-\tconst char *external_ccs = nl_langinfo(CODESET);\n-\n-\tif (external_ccs == NULL)\n-\t  external_ccs = \"ISO-8859-1\";\n-\n-\tcc->__cd_in = iconv_open (internal_ccs, external_ccs);\n-\tif (cc->__cd_in != (iconv_t) -1)\n-\t  cc->__cd_out = iconv_open (external_ccs, internal_ccs);\n-#endif\n-      }\n-# else\n-#  error \"somehow determine this from LC_CTYPE\"\n-# endif\n-#endif\n-\n-      /* From now on use the wide character callback functions.  */\n-      ((struct _IO_FILE_plus *) fp)->vtable = fp->_wide_data->_wide_vtable;\n-#else /* !defined(_GLIBCPP_USE_WCHAR_T) */\n-      mode = fp->_mode;\n-#endif /* !defined(_GLIBCPP_USE_WCHAR_T) */\n-    }\n-\n-  /* Set the mode now.  */\n-  fp->_mode = mode;\n-\n-  return mode;\n-}\n-\n-#ifdef weak_alias\n-weak_alias (_IO_fwide, fwide)\n-#endif\n-\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-\n-static enum __codecvt_result\n-do_out (struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-\tconst wchar_t *from_start, const wchar_t *from_end,\n-\tconst wchar_t **from_stop, char *to_start, char *to_end,\n-\tchar **to_stop)\n-{\n-  enum __codecvt_result result;\n-\n-#ifdef _LIBC\n-  struct __gconv_step *gs = codecvt->__cd_out.__cd.__steps;\n-  int status;\n-  size_t dummy;\n-  const unsigned char *from_start_copy = (unsigned char *) from_start;\n-\n-  codecvt->__cd_out.__cd.__data[0].__outbuf = to_start;\n-  codecvt->__cd_out.__cd.__data[0].__outbufend = to_end;\n-  codecvt->__cd_out.__cd.__data[0].__statep = statep;\n-\n-  status = DL_CALL_FCT (gs->__fct,\n-\t\t\t(gs, codecvt->__cd_out.__cd.__data, &from_start_copy,\n-\t\t\t (const unsigned char *) from_end, NULL,\n-\t\t\t &dummy, 0, 0));\n-\n-  *from_stop = (wchar_t *) from_start_copy;\n-  *to_stop = codecvt->__cd_out.__cd.__data[0].__outbuf;\n-\n-  switch (status)\n-    {\n-    case __GCONV_OK:\n-    case __GCONV_EMPTY_INPUT:\n-      result = __codecvt_ok;\n-      break;\n-\n-    case __GCONV_FULL_OUTPUT:\n-    case __GCONV_INCOMPLETE_INPUT:\n-      result = __codecvt_partial;\n-      break;\n-\n-    default:\n-      result = __codecvt_error;\n-      break;\n-    }\n-#else\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-  size_t res;\n-  const char *from_start_copy = (const char *) from_start;\n-  size_t from_len = from_end - from_start;\n-  char *to_start_copy = to_start;\n-  size_t to_len = to_end - to_start;\n-  res = iconv (codecvt->__cd_out, &from_start_copy, &from_len,\n-\t       &to_start_copy, &to_len);\n-\n-  if (res == 0 || from_len == 0)\n-    result = __codecvt_ok;\n-  else if (to_len < codecvt->__codecvt_do_max_length (codecvt))\n-    result = __codecvt_partial;\n-  else\n-    result = __codecvt_error;\n-\n-# else\n-  /* Decide what to do.  */\n-  result = __codecvt_error;\n-# endif\n-#endif\n-\n-  return result;\n-}\n-\n-\n-static enum __codecvt_result\n-do_unshift (struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-\t    char *to_start, char *to_end, char **to_stop)\n-{\n-  enum __codecvt_result result;\n-\n-#ifdef _LIBC\n-  struct __gconv_step *gs = codecvt->__cd_out.__cd.__steps;\n-  int status;\n-  size_t dummy;\n-\n-  codecvt->__cd_out.__cd.__data[0].__outbuf = to_start;\n-  codecvt->__cd_out.__cd.__data[0].__outbufend = to_end;\n-  codecvt->__cd_out.__cd.__data[0].__statep = statep;\n-\n-  status = DL_CALL_FCT (gs->__fct,\n-\t\t\t(gs, codecvt->__cd_out.__cd.__data, NULL, NULL,\n-\t\t\t NULL, &dummy, 1, 0));\n-\n-  *to_stop = codecvt->__cd_out.__cd.__data[0].__outbuf;\n-\n-  switch (status)\n-    {\n-    case __GCONV_OK:\n-    case __GCONV_EMPTY_INPUT:\n-      result = __codecvt_ok;\n-      break;\n-\n-    case __GCONV_FULL_OUTPUT:\n-    case __GCONV_INCOMPLETE_INPUT:\n-      result = __codecvt_partial;\n-      break;\n-\n-    default:\n-      result = __codecvt_error;\n-      break;\n-    }\n-#else\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-  size_t res;\n-  char *to_start_copy = (char *) to_start;\n-  size_t to_len = to_end - to_start;\n-\n-  res = iconv (codecvt->__cd_out, NULL, NULL, &to_start_copy, &to_len);\n-\n-  if (res == 0)\n-    result = __codecvt_ok;\n-  else if (to_len < codecvt->__codecvt_do_max_length (codecvt))\n-    result = __codecvt_partial;\n-  else\n-    result = __codecvt_error;\n-# else\n-  /* Decide what to do.  */\n-  result = __codecvt_error;\n-# endif\n-#endif\n-\n-  return result;\n-}\n-\n-\n-static enum __codecvt_result\n-do_in (struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-       const char *from_start, const char *from_end, const char **from_stop,\n-       wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)\n-{\n-  enum __codecvt_result result;\n-\n-#ifdef _LIBC\n-  struct __gconv_step *gs = codecvt->__cd_in.__cd.__steps;\n-  int status;\n-  size_t dummy;\n-  const unsigned char *from_start_copy = (unsigned char *) from_start;\n-\n-  codecvt->__cd_in.__cd.__data[0].__outbuf = (char *) to_start;\n-  codecvt->__cd_in.__cd.__data[0].__outbufend = (char *) to_end;\n-  codecvt->__cd_in.__cd.__data[0].__statep = statep;\n-\n-  status = DL_CALL_FCT (gs->__fct,\n-\t\t\t(gs, codecvt->__cd_in.__cd.__data, &from_start_copy,\n-\t\t\t from_end, NULL, &dummy, 0, 0));\n-\n-  *from_stop = from_start_copy;\n-  *to_stop = (wchar_t *) codecvt->__cd_in.__cd.__data[0].__outbuf;\n-\n-  switch (status)\n-    {\n-    case __GCONV_OK:\n-    case __GCONV_EMPTY_INPUT:\n-      result = __codecvt_ok;\n-      break;\n-\n-    case __GCONV_FULL_OUTPUT:\n-    case __GCONV_INCOMPLETE_INPUT:\n-      result = __codecvt_partial;\n-      break;\n-\n-    default:\n-      result = __codecvt_error;\n-      break;\n-    }\n-#else\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-  size_t res;\n-  const char *from_start_copy = (const char *) from_start;\n-  size_t from_len = from_end - from_start;\n-  char *to_start_copy = (char *) from_start;\n-  size_t to_len = to_end - to_start;\n-\n-  res = iconv (codecvt->__cd_in, &from_start_copy, &from_len,\n-\t       &to_start_copy, &to_len);\n-\n-  if (res == 0)\n-    result = __codecvt_ok;\n-  else if (to_len == 0)\n-    result = __codecvt_partial;\n-  else if (from_len < codecvt->__codecvt_do_max_length (codecvt))\n-    result = __codecvt_partial;\n-  else\n-    result = __codecvt_error;\n-# else\n-  /* Decide what to do.  */\n-  result = __codecvt_error;\n-# endif\n-#endif\n-\n-  return result;\n-}\n-\n-\n-static int\n-do_encoding (struct _IO_codecvt *codecvt)\n-{\n-#ifdef _LIBC\n-  /* See whether the encoding is stateful.  */\n-  if (codecvt->__cd_in.__cd.__steps[0].__stateful)\n-    return -1;\n-  /* Fortunately not.  Now determine the input bytes for the conversion\n-     necessary for each wide character.  */\n-  if (codecvt->__cd_in.__cd.__steps[0].__min_needed_from\n-      != codecvt->__cd_in.__cd.__steps[0].__max_needed_from)\n-    /* Not a constant value.  */\n-    return 0;\n-\n-  return codecvt->__cd_in.__cd.__steps[0].__min_needed_from;\n-#else\n-  /* Worst case scenario.  */\n-  return -1;\n-#endif\n-}\n-\n-\n-static int\n-do_always_noconv (struct _IO_codecvt *codecvt)\n-{\n-  return 0;\n-}\n-\n-\n-static int\n-do_length (struct _IO_codecvt *codecvt, __c_mbstate_t *statep,\n-\t   const char *from_start, const char *from_end, _IO_size_t max)\n-{\n-  int result;\n-#ifdef _LIBC\n-  const unsigned char *cp = (const unsigned char *) from_start;\n-  wchar_t to_buf[max];\n-  struct __gconv_step *gs = codecvt->__cd_in.__cd.__steps;\n-  int status;\n-  size_t dummy;\n-\n-  codecvt->__cd_in.__cd.__data[0].__outbuf = (char *) to_buf;\n-  codecvt->__cd_in.__cd.__data[0].__outbufend = (char *) &to_buf[max];\n-  codecvt->__cd_in.__cd.__data[0].__statep = statep;\n-\n-  status = DL_CALL_FCT (gs->__fct,\n-\t\t\t(gs, codecvt->__cd_in.__cd.__data, &cp, from_end,\n-\t\t\t NULL, &dummy, 0, 0));\n-\n-  result = cp - (const unsigned char *) from_start;\n-#else\n-# ifdef _GLIBCPP_USE_WCHAR_T\n-  const char *from_start_copy = (const char *) from_start;\n-  size_t from_len = from_end - from_start;\n-  wchar_t to_buf[max];\n-  size_t res;\n-  char *to_start = (char *) to_buf;\n-\n-  res = iconv (codecvt->__cd_in, &from_start_copy, &from_len,\n-\t       &to_start, &max);\n-\n-  result = from_start_copy - (char *) from_start;\n-# else\n-  /* Decide what to do.  */\n-  result = 0;\n-# endif\n-#endif\n-\n-  return result;\n-}\n-\n-\n-static int\n-do_max_length (struct _IO_codecvt *codecvt)\n-{\n-#ifdef _LIBC\n-  return codecvt->__cd_in.__cd.__steps[0].__max_needed_from;\n-#else\n-  return MB_CUR_MAX;\n-#endif\n-}\n-\n-#endif /* defined(_GLIBCPP_USE_WCHAR_T) */"}, {"sha": "61be4b73b94d9e2c7c19e671ca6f446f2c563464", "filename": "libstdc++-v3/libio/iolibio.h", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,82 +0,0 @@\n-#include \"libio.h\"\n-\n-/* These emulate stdio functionality, but with a different name\n-   (_IO_ungetc instead of ungetc), and using _IO_FILE instead of FILE. */\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern int _IO_fclose __P((_IO_FILE*));\n-extern int _IO_new_fclose __P((_IO_FILE*));\n-extern int _IO_old_fclose __P((_IO_FILE*));\n-extern _IO_FILE *_IO_fdopen __P((int, const char*));\n-extern _IO_FILE *_IO_old_fdopen __P((int, const char*));\n-extern _IO_FILE *_IO_new_fdopen __P((int, const char*));\n-extern int _IO_fflush __P((_IO_FILE*));\n-extern int _IO_fgetpos __P((_IO_FILE*, _IO_fpos_t*));\n-extern int _IO_fgetpos64 __P((_IO_FILE*, _IO_fpos64_t*));\n-extern char* _IO_fgets __P((char*, int, _IO_FILE*));\n-extern _IO_FILE *_IO_fopen __P((const char*, const char*));\n-extern _IO_FILE *_IO_old_fopen __P((const char*, const char*));\n-extern _IO_FILE *_IO_new_fopen __P((const char*, const char*));\n-extern _IO_FILE *_IO_fopen64 __P((const char*, const char*));\n-extern int _IO_fprintf __P((_IO_FILE*, const char*, ...));\n-extern int _IO_fputs __P((const char*, _IO_FILE*));\n-extern int _IO_fsetpos __P((_IO_FILE*, const _IO_fpos_t *));\n-extern int _IO_fsetpos64 __P((_IO_FILE*, const _IO_fpos64_t *));\n-extern long int _IO_ftell __P((_IO_FILE*));\n-extern _IO_size_t _IO_fread __P((void*, _IO_size_t, _IO_size_t, _IO_FILE*));\n-extern _IO_size_t _IO_fwrite __P((const void*,\n-\t\t\t\t      _IO_size_t, _IO_size_t, _IO_FILE*));\n-extern char* _IO_gets __P((char*));\n-extern void _IO_perror __P((const char*));\n-extern int _IO_printf __P((const char*, ...));\n-extern int _IO_puts __P((const char*));\n-extern int _IO_scanf __P((const char*, ...));\n-extern void _IO_setbuffer __P((_IO_FILE *, char*, _IO_size_t));\n-extern int _IO_setvbuf __P((_IO_FILE*, char*, int, _IO_size_t));\n-extern int _IO_sscanf __P((const char*, const char*, ...));\n-extern int _IO_sprintf __P((char *, const char*, ...));\n-extern int _IO_ungetc __P((int, _IO_FILE*));\n-extern int _IO_vsscanf __P((const char *, const char *, _IO_va_list));\n-extern int _IO_vsprintf __P((char*, const char*, _IO_va_list));\n-extern int _IO_vswprintf __P((wchar_t*, _IO_size_t, const wchar_t*,\n-\t\t\t      _IO_va_list));\n-\n-struct obstack;\n-extern int _IO_obstack_vprintf __P ((struct obstack *, const char *,\n-\t\t\t\t     _IO_va_list));\n-extern int _IO_obstack_printf __P ((struct obstack *, const char *, ...));\n-#ifndef _IO_pos_BAD\n-#define _IO_pos_BAD ((_IO_off64_t)(-1))\n-#endif\n-#define _IO_clearerr(FP) ((FP)->_flags &= ~(_IO_ERR_SEEN|_IO_EOF_SEEN))\n-#define _IO_fseek(__fp, __offset, __whence) \\\n-  (_IO_seekoff(__fp, __offset, __whence, _IOS_INPUT|_IOS_OUTPUT) == _IO_pos_BAD ? EOF : 0)\n-#define _IO_rewind(FILE) (void)_IO_seekoff(FILE, 0, 0, _IOS_INPUT|_IOS_OUTPUT)\n-#define _IO_vprintf(FORMAT, ARGS) _IO_vfprintf(_IO_stdout, FORMAT, ARGS)\n-#define _IO_freopen(FILENAME, MODE, FP) \\\n-  (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE, 0))\n-#define _IO_old_freopen(FILENAME, MODE, FP) \\\n-  (_IO_old_file_close_it (FP), _IO_old_file_fopen(FP, FILENAME, MODE))\n-#define _IO_freopen64(FILENAME, MODE, FP) \\\n-  (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE, 1))\n-#define _IO_fileno(FP) ((FP)->_fileno)\n-extern _IO_FILE* _IO_popen __P((const char*, const char*));\n-extern _IO_FILE* _IO_new_popen __P((const char*, const char*));\n-extern _IO_FILE* _IO_old_popen __P((const char*, const char*));\n-extern int __new_pclose __P((_IO_FILE *));\n-extern int __old_pclose __P((_IO_FILE *));\n-#define _IO_pclose _IO_fclose\n-#define _IO_setbuf(_FP, _BUF) _IO_setbuffer(_FP, _BUF, _IO_BUFSIZ)\n-#define _IO_setlinebuf(_FP) _IO_setvbuf(_FP, NULL, 1, 0)\n-\n-_IO_FILE *__new_freopen __P ((const char *, const char *, _IO_FILE *));\n-_IO_FILE *__old_freopen __P ((const char *, const char *, _IO_FILE *));\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-"}, {"sha": "e2a2a15bcb0d9d541d6324707950c91355ce1349", "filename": "libstdc++-v3/libio/libio.h", "status": "removed", "additions": 0, "deletions": 511, "changes": 511, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Flibio.h?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,511 +0,0 @@\n-/* Copyright (C) 1991,92,93,94,95,97,98,99,2000,2001 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-   Written by Per Bothner <bothner@cygnus.com>.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#ifndef _IO_STDIO_H\n-#define _IO_STDIO_H\n-\n-#include <_G_config.h>\n-/* ALL of these should be defined in _G_config.h */\n-#define _IO_pos_t _G_fpos_t /* obsolete */\n-#define _IO_fpos_t _G_fpos_t\n-#define _IO_fpos64_t _G_fpos64_t\n-#define _IO_size_t _G_size_t\n-#define _IO_ssize_t _G_ssize_t\n-#define _IO_off_t _G_off_t\n-#define _IO_off64_t _G_off64_t\n-#define _IO_pid_t _G_pid_t\n-#define _IO_uid_t _G_uid_t\n-#define _IO_iconv_t _G_iconv_t\n-#define _IO_HAVE_SYS_WAIT _G_HAVE_SYS_WAIT\n-#define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE\n-#define _IO_BUFSIZ _G_BUFSIZ\n-#define _IO_va_list _G_va_list\n-#define _IO_wint_t _G_wint_t\n-\n-#ifdef _G_NEED_STDARG_H\n-/* This define avoids name pollution if we're using GNU stdarg.h */\n-# define __need___va_list\n-# include <stdarg.h>\n-# ifdef __GNUC_VA_LIST\n-#  undef _IO_va_list\n-#  define _IO_va_list __gnuc_va_list\n-# endif /* __GNUC_VA_LIST */\n-#endif\n-\n-#ifndef __THROW\n-# ifdef __cplusplus\n-#  define __THROW throw ()\n-# else\n-#  define __THROW\n-# endif\n-#endif /* not __THROW */\n-\n-#ifndef __P\n-# define __P(p) p __THROW\n-#endif /* not __P */\n-\n-#ifndef __PMT\n-# define __PMT(p) p\n-#endif /* not __PMT */\n-\n-/* For backward compatibility */\n-#ifndef _PARAMS\n-# define _PARAMS(protos) __P(protos)\n-#endif /*!_PARAMS*/\n-\n-#ifndef __STDC__\n-# ifndef const\n-#  define const\n-# endif\n-#endif\n-#define _IO_UNIFIED_JUMPTABLES 1\n-#ifndef _G_HAVE_PRINTF_FP\n-# define _IO_USE_DTOA 1\n-#endif\n-\n-#ifndef EOF\n-# define EOF (-1)\n-#endif\n-#ifndef NULL\n-# if defined __GNUG__ && \\\n-    (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))\n-#  define NULL (__null)\n-# else\n-#  if !defined(__cplusplus)\n-#   define NULL ((void*)0)\n-#  else\n-#   define NULL (0)\n-#  endif\n-# endif\n-#endif\n-\n-#define _IOS_INPUT\t1\n-#define _IOS_OUTPUT\t2\n-#define _IOS_ATEND\t4\n-#define _IOS_APPEND\t8\n-#define _IOS_TRUNC\t16\n-#define _IOS_NOCREATE\t32\n-#define _IOS_NOREPLACE\t64\n-#define _IOS_BIN\t128\n-\n-/* Magic numbers and bits for the _flags field.\n-   The magic numbers use the high-order bits of _flags;\n-   the remaining bits are available for variable flags.\n-   Note: The magic numbers must all be negative if stdio\n-   emulation is desired. */\n-\n-#define _IO_MAGIC 0xFBAD0000 /* Magic number */\n-#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */\n-#define _IO_MAGIC_MASK 0xFFFF0000\n-#define _IO_USER_BUF 1 /* User owns buffer; don't delete it on close. */\n-#define _IO_UNBUFFERED 2\n-#define _IO_NO_READS 4 /* Reading not allowed */\n-#define _IO_NO_WRITES 8 /* Writing not allowd */\n-#define _IO_EOF_SEEN 0x10\n-#define _IO_ERR_SEEN 0x20\n-#define _IO_DELETE_DONT_CLOSE 0x40 /* Don't call close(_fileno) on cleanup. */\n-#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/\n-#define _IO_IN_BACKUP 0x100\n-#define _IO_LINE_BUF 0x200\n-#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */\n-#define _IO_CURRENTLY_PUTTING 0x800\n-#define _IO_IS_APPENDING 0x1000\n-#define _IO_IS_FILEBUF 0x2000\n-#define _IO_BAD_SEEN 0x4000\n-#define _IO_USER_LOCK 0x8000\n-\n-/* These are \"formatting flags\" matching the iostream fmtflags enum values. */\n-#define _IO_SKIPWS 01\n-#define _IO_LEFT 02\n-#define _IO_RIGHT 04\n-#define _IO_INTERNAL 010\n-#define _IO_DEC 020\n-#define _IO_OCT 040\n-#define _IO_HEX 0100\n-#define _IO_SHOWBASE 0200\n-#define _IO_SHOWPOINT 0400\n-#define _IO_UPPERCASE 01000\n-#define _IO_SHOWPOS 02000\n-#define _IO_SCIENTIFIC 04000\n-#define _IO_FIXED 010000\n-#define _IO_UNITBUF 020000\n-#define _IO_STDIO 040000\n-#define _IO_DONT_CLOSE 0100000\n-#define _IO_BOOLALPHA 0200000\n-\n-\n-struct _IO_jump_t;  struct _IO_FILE;\n-\n-/* Handle lock.  */\n-#ifdef _IO_MTSAFE_IO\n-# if defined __GLIBC__ && __GLIBC__ >= 2\n-#  if __GLIBC_MINOR__ == 0\n-#   include <stdio-lock.h>\n-#  else\n-#   include <bits/stdio-lock.h>\n-#  endif\n-# else\n-/*# include <comthread.h>*/\n-# endif\n-#else\n-typedef void _IO_lock_t;\n-#endif\n-\n-\n-/* A streammarker remembers a position in a buffer. */\n-\n-struct _IO_marker {\n-  struct _IO_marker *_next;\n-  struct _IO_FILE *_sbuf;\n-  /* If _pos >= 0\n- it points to _buf->Gbase()+_pos. FIXME comment */\n-  /* if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment */\n-  int _pos;\n-#if 0\n-    void set_streampos(streampos sp) { _spos = sp; }\n-    void set_offset(int offset) { _pos = offset; _spos = (streampos)(-2); }\n-  public:\n-    streammarker(streambuf *sb);\n-    ~streammarker();\n-    int saving() { return  _spos == -2; }\n-    int delta(streammarker&);\n-    int delta();\n-#endif\n-};\n-\n-/* This is the structure from the libstdc++ codecvt class.  */\n-enum __codecvt_result\n-{\n-  __codecvt_ok,\n-  __codecvt_partial,\n-  __codecvt_error,\n-  __codecvt_noconv\n-};\n-\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-/* The order of the elements in the following struct must match the order\n-   of the virtual functions in the libstdc++ codecvt class.  */\n-struct _IO_codecvt\n-{\n-  void (*__codecvt_destr) (struct _IO_codecvt *);\n-  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,\n-\t\t\t\t\t     __c_mbstate_t *,\n-\t\t\t\t\t     const wchar_t *,\n-\t\t\t\t\t     const wchar_t *,\n-\t\t\t\t\t     const wchar_t **, char *,\n-\t\t\t\t\t     char *, char **);\n-  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,\n-\t\t\t\t\t\t __c_mbstate_t *, char *,\n-\t\t\t\t\t\t char *, char **);\n-  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,\n-\t\t\t\t\t    __c_mbstate_t *,\n-\t\t\t\t\t    const char *, const char *,\n-\t\t\t\t\t    const char **, wchar_t *,\n-\t\t\t\t\t    wchar_t *, wchar_t **);\n-  int (*__codecvt_do_encoding) (struct _IO_codecvt *);\n-  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);\n-  int (*__codecvt_do_length) (struct _IO_codecvt *, __c_mbstate_t *,\n-\t\t\t      const char *, const char *, _IO_size_t);\n-  int (*__codecvt_do_max_length) (struct _IO_codecvt *);\n-\n-  _IO_iconv_t __cd_in;\n-  _IO_iconv_t __cd_out;\n-};\n-\n-/* Extra data for wide character streams.  */\n-struct _IO_wide_data\n-{\n-  wchar_t *_IO_read_ptr;\t/* Current read pointer */\n-  wchar_t *_IO_read_end;\t/* End of get area. */\n-  wchar_t *_IO_read_base;\t/* Start of putback+get area. */\n-  wchar_t *_IO_write_base;\t/* Start of put area. */\n-  wchar_t *_IO_write_ptr;\t/* Current put pointer. */\n-  wchar_t *_IO_write_end;\t/* End of put area. */\n-  wchar_t *_IO_buf_base;\t/* Start of reserve area. */\n-  wchar_t *_IO_buf_end;\t\t/* End of reserve area. */\n-  /* The following fields are used to support backing up and undo. */\n-  wchar_t *_IO_save_base;\t/* Pointer to start of non-current get area. */\n-  wchar_t *_IO_backup_base;\t/* Pointer to first valid character of\n-\t\t\t\t   backup area */\n-  wchar_t *_IO_save_end;\t/* Pointer to end of non-current get area. */\n-\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  __c_mbstate_t _IO_state;\n-  __c_mbstate_t _IO_last_state;\n-#endif\n-  struct _IO_codecvt _codecvt;\n-\n-  wchar_t _shortbuf[1];\n-\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  struct _IO_jump_t *_wide_vtable;\n-#endif\n-};\n-#else /* !(defined _LIBC || defined _GLIBCPP_USE_WCHAR_T) */\n-/* Because _IO_no_init unconditionally takes a `_IO_wide_data*' as its\n-   last parameter we must still define this type.  We intentionally\n-   leave it incomplete to prevent any use of this type when we are not\n-   supporting wide characters.  */\n-struct _IO_wide_data;\n-#endif /* !(defined _LIBC || defined _GLIBCPP_USE_WCHAR_T) */\n-\n-struct _IO_FILE {\n-  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */\n-#define _IO_file_flags _flags\n-\n-  /* The following pointers correspond to the C++ streambuf protocol. */\n-  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n-  char* _IO_read_ptr;\t/* Current read pointer */\n-  char* _IO_read_end;\t/* End of get area. */\n-  char* _IO_read_base;\t/* Start of putback+get area. */\n-  char* _IO_write_base;\t/* Start of put area. */\n-  char* _IO_write_ptr;\t/* Current put pointer. */\n-  char* _IO_write_end;\t/* End of put area. */\n-  char* _IO_buf_base;\t/* Start of reserve area. */\n-  char* _IO_buf_end;\t/* End of reserve area. */\n-  /* The following fields are used to support backing up and undo. */\n-  char *_IO_save_base; /* Pointer to start of non-current get area. */\n-  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n-  char *_IO_save_end; /* Pointer to end of non-current get area. */\n-\n-  struct _IO_marker *_markers;\n-\n-  struct _IO_FILE *_chain;\n-\n-  int _fileno;\n-  int _blksize;\n-  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n-\n-#define __HAVE_COLUMN /* temporary */\n-  /* 1+column number of pbase(); 0 is unknown. */\n-  unsigned short _cur_column;\n-  signed char _vtable_offset;\n-  char _shortbuf[1];\n-\n-  /*  char* _save_gptr;  char* _save_egptr; */\n-\n-  _IO_lock_t *_lock;\n-#ifdef _IO_USE_OLD_IO_FILE\n-};\n-\n-struct _IO_FILE_complete\n-{\n-  struct _IO_FILE _file;\n-#endif\n-#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001\n-  _IO_off64_t _offset;\n-# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-  /* Wide character stream stuff.  */\n-  struct _IO_codecvt *_codecvt;\n-  struct _IO_wide_data *_wide_data;\n-# else\n-  void *__pad1;\n-  void *__pad2;\n-# endif\n-  int _mode;\n-  /* Make sure we don't get into trouble again.  */\n-  char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];\n-#endif\n-};\n-\n-#ifndef __cplusplus\n-typedef struct _IO_FILE _IO_FILE;\n-#endif\n-\n-struct _IO_FILE_plus;\n-\n-extern struct _IO_FILE_plus _IO_2_1_stdin_;\n-extern struct _IO_FILE_plus _IO_2_1_stdout_;\n-extern struct _IO_FILE_plus _IO_2_1_stderr_;\n-#ifndef _LIBC\n-#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))\n-#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))\n-#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))\n-#else\n-extern _IO_FILE *_IO_stdin;\n-extern _IO_FILE *_IO_stdout;\n-extern _IO_FILE *_IO_stderr;\n-#endif\n-\n-\n-/* Functions to do I/O and file management for a stream.  */\n-\n-/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.\n-   Return number of bytes read.  */\n-typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);\n-\n-/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes\n-   unless there is an error.  Return number of bytes written, or -1 if\n-   there is an error without writing anything.  If the file has been\n-   opened for append (__mode.__append set), then set the file pointer\n-   to the end of the file and then do the write; if not, just write at\n-   the current file pointer.  */\n-typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,\n-\t\t\t\t size_t __n);\n-\n-/* Move COOKIE's file position to *POS bytes from the\n-   beginning of the file (if W is SEEK_SET),\n-   the current position (if W is SEEK_CUR),\n-   or the end of the file (if W is SEEK_END).\n-   Set *POS to the new file position.\n-   Returns zero if successful, nonzero if not.  */\n-typedef int __io_seek_fn (void *__cookie, _IO_off64_t *__pos, int __w);\n-\n-/* Close COOKIE.  */\n-typedef int __io_close_fn (void *__cookie);\n-\n-\n-#ifdef _GNU_SOURCE\n-/* User-visible names for the above.  */\n-typedef __io_read_fn cookie_read_function_t;\n-typedef __io_write_fn cookie_write_function_t;\n-typedef __io_seek_fn cookie_seek_function_t;\n-typedef __io_close_fn cookie_close_function_t;\n-\n-/* The structure with the cookie function pointers.  */\n-typedef struct\n-{\n-  __io_read_fn *read;\t\t/* Read bytes.  */\n-  __io_write_fn *write;\t\t/* Write bytes.  */\n-  __io_seek_fn *seek;\t\t/* Seek/tell file position.  */\n-  __io_close_fn *close;\t\t/* Close file.  */\n-} _IO_cookie_io_functions_t;\n-typedef _IO_cookie_io_functions_t cookie_io_functions_t;\n-\n-struct _IO_cookie_file;\n-\n-/* Initialize one of those.  */\n-extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,\n-\t\t\t     void *__cookie, _IO_cookie_io_functions_t __fns);\n-#endif\n-\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern int __underflow (_IO_FILE *) __THROW;\n-extern int __uflow (_IO_FILE *) __THROW;\n-extern int __overflow (_IO_FILE *, int) __THROW;\n-extern _IO_wint_t __wunderflow (_IO_FILE *) __THROW;\n-extern _IO_wint_t __wuflow (_IO_FILE *) __THROW;\n-extern _IO_wint_t __woverflow (_IO_FILE *, _IO_wint_t) __THROW;\n-\n-#define _IO_getc_unlocked(_fp) \\\n-       ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end ? __uflow (_fp) \\\n-\t: *(unsigned char *) (_fp)->_IO_read_ptr++)\n-#define _IO_peekc_unlocked(_fp) \\\n-       ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end \\\n-\t  && __underflow (_fp) == EOF ? EOF \\\n-\t: *(unsigned char *) (_fp)->_IO_read_ptr)\n-#define _IO_putc_unlocked(_ch, _fp) \\\n-   (((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) \\\n-    ? __overflow (_fp, (unsigned char) (_ch)) \\\n-    : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))\n-\n-#define _IO_getwc_unlocked(_fp) \\\n-  ((_fp)->_wide_data->_IO_read_ptr >= (_fp)->_wide_data->_IO_read_end \\\n-   ? __wuflow (_fp) : (_IO_wint_t) *(_fp)->_wide_data->_IO_read_ptr++)\n-#define _IO_putwc_unlocked(_wch, _fp) \\\n-  ((_fp)->_wide_data->_IO_write_ptr >= (_fp)->_wide_data->_IO_write_end \\\n-   ? __woverflow (_fp, _wch) \\\n-   : (_IO_wint_t) (*(_fp)->_wide_data->_IO_write_ptr++ = (_wch)))\n-\n-#define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)\n-#define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)\n-\n-extern int _IO_getc (_IO_FILE *__fp) __THROW;\n-extern int _IO_putc (int __c, _IO_FILE *__fp) __THROW;\n-extern int _IO_feof (_IO_FILE *__fp) __THROW;\n-extern int _IO_ferror (_IO_FILE *__fp) __THROW;\n-\n-extern int _IO_peekc_locked (_IO_FILE *__fp) __THROW;\n-\n-/* This one is for Emacs. */\n-#define _IO_PENDING_OUTPUT_COUNT(_fp)\t\\\n-\t((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)\n-\n-extern void _IO_flockfile (_IO_FILE *) __THROW;\n-extern void _IO_funlockfile (_IO_FILE *) __THROW;\n-extern int _IO_ftrylockfile (_IO_FILE *) __THROW;\n-\n-#ifdef _IO_MTSAFE_IO\n-# define _IO_peekc(_fp) _IO_peekc_locked (_fp)\n-#else\n-# define _IO_peekc(_fp) _IO_peekc_unlocked (_fp)\n-# define _IO_flockfile(_fp) /**/\n-# define _IO_funlockfile(_fp) /**/\n-# define _IO_ftrylockfile(_fp) /**/\n-# define _IO_cleanup_region_start(_fct, _fp) /**/\n-# define _IO_cleanup_region_end(_Doit) /**/\n-#endif /* !_IO_MTSAFE_IO */\n-\n-extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,\n-\t\t\t_IO_va_list, int *__restrict) __THROW;\n-extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,\n-\t\t\t _IO_va_list) __THROW;\n-extern _IO_ssize_t _IO_padn (_IO_FILE *, int, _IO_ssize_t) __THROW;\n-extern _IO_size_t _IO_sgetn (_IO_FILE *, void *, _IO_size_t) __THROW;\n-\n-extern _IO_off64_t _IO_seekoff (_IO_FILE *, _IO_off64_t, int, int) __THROW;\n-extern _IO_off64_t _IO_seekpos (_IO_FILE *, _IO_off64_t, int) __THROW;\n-\n-extern void _IO_free_backup_area (_IO_FILE *) __THROW;\n-\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-extern _IO_wint_t _IO_getwc (_IO_FILE *__fp) __THROW;\n-extern _IO_wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp) __THROW;\n-extern int _IO_fwide (_IO_FILE *__fp, int __mode) __THROW;\n-# if __GNUC__ >= 2\n-/* A special optimized version of the function above.  It optimizes the\n-   case of initializing an unoriented byte stream.  */\n-#  define _IO_fwide(__fp, __mode) \\\n-  ({ int __result = (__mode);\t\t\t\t\t\t      \\\n-     if (__result < 0)\t\t\t\t\t\t\t      \\\n-       {\t\t\t\t\t\t\t\t      \\\n-\t if ((__fp)->_mode == 0)\t\t\t\t\t      \\\n-\t   /* We know that all we have to do is to set the flag.  */\t      \\\n-\t   (__fp)->_mode = -1;\t\t\t\t\t\t      \\\n-\t __result = (__fp)->_mode;\t\t\t\t\t      \\\n-       }\t\t\t\t\t\t\t\t      \\\n-     else\t\t\t\t\t\t\t\t      \\\n-       __result = _IO_fwide (__fp, __result);\t\t\t\t      \\\n-     __result; })\n-# endif\n-\n-extern int _IO_vfwscanf (_IO_FILE * __restrict, const wchar_t * __restrict,\n-\t\t\t _IO_va_list, int *__restrict) __THROW;\n-extern int _IO_vfwprintf (_IO_FILE *__restrict, const wchar_t *__restrict,\n-\t\t\t  _IO_va_list) __THROW;\n-extern _IO_ssize_t _IO_wpadn (_IO_FILE *, wint_t, _IO_ssize_t) __THROW;\n-extern void _IO_free_wbackup_area (_IO_FILE *) __THROW;\n-#endif\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif /* _IO_STDIO_H */"}, {"sha": "4aecf4eaa1b2038a5b978307038ba567ca8552a4", "filename": "libstdc++-v3/libio/libioP.h", "status": "removed", "additions": 0, "deletions": 821, "changes": 821, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FlibioP.h?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,821 +0,0 @@\n-/* Copyright (C) 1993, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-# include <errno.h>\n-\n-#ifndef __set_errno\n-# define __set_errno(Val) errno = (Val)\n-#endif\n-#if defined __GLIBC__ && __GLIBC__ >= 2\n-# include <bits/libc-lock.h>\n-#else\n-/*# include <comthread.h>*/\n-#endif\n-\n-#include \"iolibio.h\"\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#define _IO_seek_set 0\n-#define _IO_seek_cur 1\n-#define _IO_seek_end 2\n-\n-/* THE JUMPTABLE FUNCTIONS.\n-\n- * The _IO_FILE type is used to implement the FILE type in GNU libc,\n- * as well as the streambuf class in GNU iostreams for C++.\n- * These are all the same, just used differently.\n- * An _IO_FILE (or FILE) object is allows followed by a pointer to\n- * a jump table (of pointers to functions).  The pointer is accessed\n- * with the _IO_JUMPS macro.  The jump table has a eccentric format,\n- * so as to be compatible with the layout of a C++ virtual function table.\n- * (as implemented by g++).  When a pointer to a streambuf object is\n- * coerced to an (_IO_FILE*), then _IO_JUMPS on the result just\n- * happens to point to the virtual function table of the streambuf.\n- * Thus the _IO_JUMPS function table used for C stdio/libio does\n- * double duty as the virtual function table for C++ streambuf.\n- *\n- * The entries in the _IO_JUMPS function table (and hence also the\n- * virtual functions of a streambuf) are described below.\n- * The first parameter of each function entry is the _IO_FILE/streambuf\n- * object being acted on (i.e. the 'this' parameter).\n- */\n-\n-#if (!defined _IO_USE_OLD_IO_FILE \\\n-     && (!defined _G_IO_NO_BACKWARD_COMPAT || _G_IO_NO_BACKWARD_COMPAT == 0))\n-# define _IO_JUMPS_OFFSET 1\n-#endif\n-\n-#define _IO_JUMPS(THIS) (THIS)->vtable\n-#define _IO_WIDE_JUMPS(THIS) ((struct _IO_FILE *) (THIS))->_wide_data->_wide_vtable\n-#define _IO_CHECK_WIDE(THIS) (((struct _IO_FILE *) (THIS))->_wide_data != NULL)\n-\n-#if _IO_JUMPS_OFFSET\n-# define _IO_JUMPS_FUNC(THIS) \\\n- (*(struct _IO_jump_t **) ((void *) &_IO_JUMPS ((struct _IO_FILE_plus *) (THIS)) \\\n-\t\t\t   + (THIS)->_vtable_offset))\n-#else\n-# define _IO_JUMPS_FUNC(THIS) _IO_JUMPS ((struct _IO_FILE_plus *) (THIS))\n-#endif\n-#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n-#if _G_USING_THUNKS\n-# define JUMP_FIELD(TYPE, NAME) TYPE NAME\n-# define JUMP0(FUNC, THIS) _IO_JUMPS_FUNC(THIS)->FUNC (THIS)\n-# define JUMP1(FUNC, THIS, X1) _IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1)\n-# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1, X2)\n-# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1,X2, X3)\n-# define JUMP_INIT(NAME, VALUE) VALUE\n-# define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)\n-\n-# define WJUMP0(FUNC, THIS) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS)\n-# define WJUMP1(FUNC, THIS, X1) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1)\n-# define WJUMP2(FUNC, THIS, X1, X2) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1, X2)\n-# define WJUMP3(FUNC, THIS, X1,X2,X3) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1,X2, X3)\n-#else\n-/* These macros will change when we re-implement vtables to use \"thunks\"! */\n-# define JUMP_FIELD(TYPE, NAME) struct { short delta1, delta2; TYPE pfn; } NAME\n-# define JUMP0(FUNC, THIS) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS)\n-# define JUMP1(FUNC, THIS, X1) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1)\n-# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1, X2)\n-# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1,X2,X3)\n-# define JUMP_INIT(NAME, VALUE) {0, 0, VALUE}\n-# define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0)\n-\n-# define WJUMP0(FUNC, THIS) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS)\n-# define WJUMP1(FUNC, THIS, X1) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1)\n-# define WJUMP2(FUNC, THIS, X1, X2) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1, X2)\n-# define WJUMP3(FUNC, THIS, X1,X2,X3) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1,X2,X3)\n-#endif\n-\n-/* The 'finish' function does any final cleaning up of an _IO_FILE object.\n-   It does not delete (free) it, but does everything else to finalize it.\n-   It matches the streambuf::~streambuf virtual destructor.  */\n-typedef void (*_IO_finish_t) __PMT ((_IO_FILE *, int)); /* finalize */\n-#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)\n-#define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)\n-\n-/* The 'overflow' hook flushes the buffer.\n-   The second argument is a character, or EOF.\n-   It matches the streambuf::overflow virtual function. */\n-typedef int (*_IO_overflow_t) __PMT ((_IO_FILE *, int));\n-#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n-#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)\n-\n-/* The 'underflow' hook tries to fills the get buffer.\n-   It returns the next character (as an unsigned char) or EOF.  The next\n-   character remains in the get buffer, and the get position is not changed.\n-   It matches the streambuf::underflow virtual function. */\n-typedef int (*_IO_underflow_t) __PMT ((_IO_FILE *));\n-#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)\n-#define _IO_WUNDERFLOW(FP) WJUMP0 (__underflow, FP)\n-\n-/* The 'uflow' hook returns the next character in the input stream\n-   (cast to unsigned char), and increments the read position;\n-   EOF is returned on failure.\n-   It matches the streambuf::uflow virtual function, which is not in the\n-   cfront implementation, but was added to C++ by the ANSI/ISO committee. */\n-#define _IO_UFLOW(FP) JUMP0 (__uflow, FP)\n-#define _IO_WUFLOW(FP) WJUMP0 (__uflow, FP)\n-\n-/* The 'pbackfail' hook handles backing up.\n-   It matches the streambuf::pbackfail virtual function. */\n-typedef int (*_IO_pbackfail_t) __PMT ((_IO_FILE *, int));\n-#define _IO_PBACKFAIL(FP, CH) JUMP1 (__pbackfail, FP, CH)\n-#define _IO_WPBACKFAIL(FP, CH) WJUMP1 (__pbackfail, FP, CH)\n-\n-/* The 'xsputn' hook writes upto N characters from buffer DATA.\n-   Returns the number of character actually written.\n-   It matches the streambuf::xsputn virtual function. */\n-typedef _IO_size_t (*_IO_xsputn_t) __PMT ((_IO_FILE *FP, const void *DATA,\n-\t\t\t\t\t   _IO_size_t N));\n-#define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)\n-#define _IO_WXSPUTN(FP, DATA, N) WJUMP2 (__xsputn, FP, DATA, N)\n-\n-/* The 'xsgetn' hook reads upto N characters into buffer DATA.\n-   Returns the number of character actually read.\n-   It matches the streambuf::xsgetn virtual function. */\n-typedef _IO_size_t (*_IO_xsgetn_t) __PMT ((_IO_FILE *FP, void *DATA,\n-\t\t\t\t\t   _IO_size_t N));\n-#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)\n-#define _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)\n-\n-/* The 'seekoff' hook moves the stream position to a new position\n-   relative to the start of the file (if DIR==0), the current position\n-   (MODE==1), or the end of the file (MODE==2).\n-   It matches the streambuf::seekoff virtual function.\n-   It is also used for the ANSI fseek function. */\n-typedef _IO_off64_t (*_IO_seekoff_t) __PMT ((_IO_FILE *FP, _IO_off64_t OFF,\n-\t\t\t\t\t     int DIR, int MODE));\n-#define _IO_SEEKOFF(FP, OFF, DIR, MODE) JUMP3 (__seekoff, FP, OFF, DIR, MODE)\n-#define _IO_WSEEKOFF(FP, OFF, DIR, MODE) WJUMP3 (__seekoff, FP, OFF, DIR, MODE)\n-\n-/* The 'seekpos' hook also moves the stream position,\n-   but to an absolute position given by a fpos64_t (seekpos).\n-   It matches the streambuf::seekpos virtual function.\n-   It is also used for the ANSI fgetpos and fsetpos functions.  */\n-/* The _IO_seek_cur and _IO_seek_end options are not allowed. */\n-typedef _IO_off64_t (*_IO_seekpos_t) __PMT ((_IO_FILE *, _IO_off64_t, int));\n-#define _IO_SEEKPOS(FP, POS, FLAGS) JUMP2 (__seekpos, FP, POS, FLAGS)\n-#define _IO_WSEEKPOS(FP, POS, FLAGS) WJUMP2 (__seekpos, FP, POS, FLAGS)\n-\n-/* The 'setbuf' hook gives a buffer to the file.\n-   It matches the streambuf::setbuf virtual function. */\n-typedef _IO_FILE* (*_IO_setbuf_t) __PMT ((_IO_FILE *, char *, _IO_ssize_t));\n-#define _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2 (__setbuf, FP, BUFFER, LENGTH)\n-#define _IO_WSETBUF(FP, BUFFER, LENGTH) WJUMP2 (__setbuf, FP, BUFFER, LENGTH)\n-\n-/* The 'sync' hook attempts to synchronize the internal data structures\n-   of the file with the external state.\n-   It matches the streambuf::sync virtual function. */\n-typedef int (*_IO_sync_t) __PMT ((_IO_FILE *));\n-#define _IO_SYNC(FP) JUMP0 (__sync, FP)\n-#define _IO_WSYNC(FP) WJUMP0 (__sync, FP)\n-\n-/* The 'doallocate' hook is used to tell the file to allocate a buffer.\n-   It matches the streambuf::doallocate virtual function, which is not\n-   in the ANSI/ISO C++ standard, but is part traditional implementations. */\n-typedef int (*_IO_doallocate_t) __PMT ((_IO_FILE *));\n-#define _IO_DOALLOCATE(FP) JUMP0 (__doallocate, FP)\n-#define _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)\n-\n-/* The following four hooks (sysread, syswrite, sysclose, sysseek, and\n-   sysstat) are low-level hooks specific to this implementation.\n-   There is no correspondence in the ANSI/ISO C++ standard library.\n-   The hooks basically correspond to the Unix system functions\n-   (read, write, close, lseek, and stat) except that a _IO_FILE*\n-   parameter is used instead of a integer file descriptor;  the default\n-   implementation used for normal files just calls those functions.\n-   The advantage of overriding these functions instead of the higher-level\n-   ones (underflow, overflow etc) is that you can leave all the buffering\n-   higher-level functions.  */\n-\n-/* The 'sysread' hook is used to read data from the external file into\n-   an existing buffer.  It generalizes the Unix read(2) function.\n-   It matches the streambuf::sys_read virtual function, which is\n-   specific to this implementation. */\n-typedef _IO_ssize_t (*_IO_read_t) __PMT ((_IO_FILE *, void *, _IO_ssize_t));\n-#define _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)\n-#define _IO_WSYSREAD(FP, DATA, LEN) WJUMP2 (__read, FP, DATA, LEN)\n-\n-/* The 'syswrite' hook is used to write data from an existing buffer\n-   to an external file.  It generalizes the Unix write(2) function.\n-   It matches the streambuf::sys_write virtual function, which is\n-   specific to this implementation. */\n-typedef _IO_ssize_t (*_IO_write_t) __PMT ((_IO_FILE *, const void *,\n-\t\t\t\t\t   _IO_ssize_t));\n-#define _IO_SYSWRITE(FP, DATA, LEN) JUMP2 (__write, FP, DATA, LEN)\n-#define _IO_WSYSWRITE(FP, DATA, LEN) WJUMP2 (__write, FP, DATA, LEN)\n-\n-/* The 'sysseek' hook is used to re-position an external file.\n-   It generalizes the Unix lseek(2) function.\n-   It matches the streambuf::sys_seek virtual function, which is\n-   specific to this implementation. */\n-typedef _IO_off64_t (*_IO_seek_t) __PMT ((_IO_FILE *, _IO_off64_t, int));\n-#define _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2 (__seek, FP, OFFSET, MODE)\n-#define _IO_WSYSSEEK(FP, OFFSET, MODE) WJUMP2 (__seek, FP, OFFSET, MODE)\n-\n-/* The 'sysclose' hook is used to finalize (close, finish up) an\n-   external file.  It generalizes the Unix close(2) function.\n-   It matches the streambuf::sys_close virtual function, which is\n-   specific to this implementation. */\n-typedef int (*_IO_close_t) __PMT ((_IO_FILE *)); /* finalize */\n-#define _IO_SYSCLOSE(FP) JUMP0 (__close, FP)\n-#define _IO_WSYSCLOSE(FP) WJUMP0 (__close, FP)\n-\n-/* The 'sysstat' hook is used to get information about an external file\n-   into a struct stat buffer.  It generalizes the Unix fstat(2) call.\n-   It matches the streambuf::sys_stat virtual function, which is\n-   specific to this implementation. */\n-typedef int (*_IO_stat_t) __PMT ((_IO_FILE *, void *));\n-#define _IO_SYSSTAT(FP, BUF) JUMP1 (__stat, FP, BUF)\n-#define _IO_WSYSSTAT(FP, BUF) WJUMP1 (__stat, FP, BUF)\n-\n-/* The 'showmany' hook can be used to get an image how much input is\n-   available.  In many cases the answer will be 0 which means unknown\n-   but some cases one can provide real information.  */\n-typedef int (*_IO_showmanyc_t) __PMT ((_IO_FILE *));\n-#define _IO_SHOWMANYC(FP) JUMP0 (__showmanyc, FP)\n-#define _IO_WSHOWMANYC(FP) WJUMP0 (__showmanyc, FP)\n-\n-/* The 'imbue' hook is used to get information about the currently\n-   installed locales.  */\n-typedef void (*_IO_imbue_t) __PMT ((_IO_FILE *, void *));\n-#define _IO_IMBUE(FP, LOCALE) JUMP1 (__imbue, FP, LOCALE)\n-#define _IO_WIMBUE(FP, LOCALE) WJUMP1 (__imbue, FP, LOCALE)\n-\n-\n-#define _IO_CHAR_TYPE char /* unsigned char ? */\n-#define _IO_INT_TYPE int\n-\n-struct _IO_jump_t\n-{\n-    JUMP_FIELD(_G_size_t, __dummy);\n-#if _G_USING_THUNKS\n-    JUMP_FIELD(_G_size_t, __dummy2);\n-#endif\n-    JUMP_FIELD(_IO_finish_t, __finish);\n-    JUMP_FIELD(_IO_overflow_t, __overflow);\n-    JUMP_FIELD(_IO_underflow_t, __underflow);\n-    JUMP_FIELD(_IO_underflow_t, __uflow);\n-    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);\n-    /* showmany */\n-    JUMP_FIELD(_IO_xsputn_t, __xsputn);\n-    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);\n-    JUMP_FIELD(_IO_seekoff_t, __seekoff);\n-    JUMP_FIELD(_IO_seekpos_t, __seekpos);\n-    JUMP_FIELD(_IO_setbuf_t, __setbuf);\n-    JUMP_FIELD(_IO_sync_t, __sync);\n-    JUMP_FIELD(_IO_doallocate_t, __doallocate);\n-    JUMP_FIELD(_IO_read_t, __read);\n-    JUMP_FIELD(_IO_write_t, __write);\n-    JUMP_FIELD(_IO_seek_t, __seek);\n-    JUMP_FIELD(_IO_close_t, __close);\n-    JUMP_FIELD(_IO_stat_t, __stat);\n-    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);\n-    JUMP_FIELD(_IO_imbue_t, __imbue);\n-#if 0\n-    get_column;\n-    set_column;\n-#endif\n-};\n-\n-/* We always allocate an extra word following an _IO_FILE.\n-   This contains a pointer to the function jump table used.\n-   This is for compatibility with C++ streambuf; the word can\n-   be used to smash to a pointer to a virtual function table. */\n-\n-struct _IO_FILE_plus\n-{\n-  _IO_FILE file;\n-  const struct _IO_jump_t *vtable;\n-};\n-\n-/* Special file type for fopencookie function.  */\n-struct _IO_cookie_file\n-{\n-  struct _IO_FILE_plus __fp;\n-  void *__cookie;\n-  _IO_cookie_io_functions_t __io_functions;\n-};\n-\n-/* Iterator type for walking global linked list of _IO_FILE objects. */\n-\n-typedef struct _IO_FILE *_IO_ITER;\n-\n-/* Generic functions */\n-\n-extern void _IO_switch_to_main_get_area __P ((_IO_FILE *));\n-extern void _IO_switch_to_backup_area __P ((_IO_FILE *));\n-extern int _IO_switch_to_get_mode __P ((_IO_FILE *));\n-extern void _IO_init __P ((_IO_FILE *, int));\n-extern int _IO_sputbackc __P ((_IO_FILE *, int));\n-extern int _IO_sungetc __P ((_IO_FILE *));\n-extern void _IO_un_link __P ((struct _IO_FILE_plus *));\n-extern void _IO_link_in __P ((struct _IO_FILE_plus *));\n-extern void _IO_doallocbuf __P ((_IO_FILE *));\n-extern void _IO_unsave_markers __P ((_IO_FILE *));\n-extern void _IO_setb __P ((_IO_FILE *, char *, char *, int));\n-extern unsigned _IO_adjust_column __P ((unsigned, const char *, int));\n-#define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)\n-\n-extern void _IO_switch_to_main_wget_area __P ((_IO_FILE *));\n-extern void _IO_switch_to_wbackup_area __P ((_IO_FILE *));\n-extern int _IO_switch_to_wget_mode __P ((_IO_FILE *));\n-extern void _IO_wsetb __P ((_IO_FILE *, wchar_t *, wchar_t *, int));\n-extern wint_t _IO_sputbackwc __P ((_IO_FILE *, wint_t));\n-extern wint_t _IO_sungetwc __P ((_IO_FILE *));\n-extern void _IO_wdoallocbuf __P ((_IO_FILE *));\n-extern void _IO_unsave_wmarkers __P ((_IO_FILE *));\n-extern unsigned _IO_adjust_wcolumn __P ((unsigned, const wchar_t *, int));\n-\n-/* Marker-related function. */\n-\n-extern void _IO_init_marker __P ((struct _IO_marker *, _IO_FILE *));\n-extern void _IO_init_wmarker __P ((struct _IO_marker *, _IO_FILE *));\n-extern void _IO_remove_marker __P ((struct _IO_marker *));\n-extern int _IO_marker_difference __P ((struct _IO_marker *,\n-\t\t\t\t       struct _IO_marker *));\n-extern int _IO_marker_delta __P ((struct _IO_marker *));\n-extern int _IO_wmarker_delta __P ((struct _IO_marker *));\n-extern int _IO_seekmark __P ((_IO_FILE *, struct _IO_marker *, int));\n-extern int _IO_seekwmark __P ((_IO_FILE *, struct _IO_marker *, int));\n-\n-/* Functions for iterating global list and dealing with\n-   its lock */\n-\n-extern _IO_ITER _IO_iter_begin __P ((void));\n-extern _IO_ITER _IO_iter_end __P ((void));\n-extern _IO_ITER _IO_iter_next __P ((_IO_ITER));\n-extern _IO_FILE *_IO_iter_file __P ((_IO_ITER));\n-extern void _IO_list_lock __P ((void));\n-extern void _IO_list_unlock __P ((void));\n-extern void _IO_list_resetlock __P ((void));\n-\n-/* Default jumptable functions. */\n-\n-extern int _IO_default_underflow __P ((_IO_FILE *));\n-extern int _IO_default_uflow __P ((_IO_FILE *));\n-extern wint_t _IO_wdefault_uflow __P ((_IO_FILE *));\n-extern int _IO_default_doallocate __P ((_IO_FILE *));\n-extern int _IO_wdefault_doallocate __P ((_IO_FILE *));\n-extern void _IO_default_finish __P ((_IO_FILE *, int));\n-extern void _IO_wdefault_finish __P ((_IO_FILE *, int));\n-extern int _IO_default_pbackfail __P ((_IO_FILE *, int));\n-extern wint_t _IO_wdefault_pbackfail __P ((_IO_FILE *, wint_t));\n-extern _IO_FILE* _IO_default_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n-extern _IO_FILE* _IO_wdefault_setbuf __P ((_IO_FILE *, wchar_t *,\n-\t\t\t\t\t   _IO_ssize_t));\n-extern _IO_size_t _IO_default_xsputn __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t   _IO_size_t));\n-extern _IO_size_t _IO_wdefault_xsputn __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t    _IO_size_t));\n-extern _IO_size_t _IO_default_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n-extern _IO_size_t _IO_wdefault_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n-extern _IO_off64_t _IO_default_seekoff __P ((_IO_FILE *,\n-\t\t\t\t\t     _IO_off64_t, int, int));\n-extern _IO_off64_t _IO_default_seekpos __P ((_IO_FILE *, _IO_off64_t, int));\n-extern _IO_ssize_t _IO_default_write __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t   _IO_ssize_t));\n-extern _IO_ssize_t _IO_default_read __P ((_IO_FILE *, void *, _IO_ssize_t));\n-extern int _IO_default_stat __P ((_IO_FILE *, void *));\n-extern _IO_off64_t _IO_default_seek __P ((_IO_FILE *, _IO_off64_t, int));\n-extern int _IO_default_sync __P ((_IO_FILE *));\n-#define _IO_default_close ((_IO_close_t) _IO_default_sync)\n-extern int _IO_default_showmanyc __P ((_IO_FILE *));\n-extern void _IO_default_imbue __P ((_IO_FILE *, void *));\n-\n-extern struct _IO_jump_t _IO_file_jumps;\n-extern struct _IO_jump_t _IO_wfile_jumps;\n-extern struct _IO_jump_t _IO_old_file_jumps;\n-extern struct _IO_jump_t _IO_streambuf_jumps;\n-extern struct _IO_jump_t _IO_proc_jumps;\n-extern struct _IO_jump_t _IO_old_proc_jumps;\n-extern struct _IO_jump_t _IO_str_jumps;\n-extern struct _IO_jump_t _IO_wstr_jumps;\n-extern struct _IO_codecvt __libio_codecvt;\n-extern int _IO_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n-extern int _IO_new_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n-extern int _IO_old_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n-extern int _IO_wdo_write __P ((_IO_FILE *, const wchar_t *, _IO_size_t));\n-extern int _IO_flush_all __P ((void));\n-extern int _IO_cleanup __P ((void));\n-extern void _IO_flush_all_linebuffered __P ((void));\n-extern int _IO_new_fgetpos __P ((_IO_FILE *, _IO_fpos_t *));\n-extern int _IO_old_fgetpos __P ((_IO_FILE *, _IO_fpos_t *));\n-extern int _IO_new_fsetpos __P ((_IO_FILE *, const _IO_fpos_t *));\n-extern int _IO_old_fsetpos __P ((_IO_FILE *, const _IO_fpos_t *));\n-extern int _IO_new_fgetpos64 __P ((_IO_FILE *, _IO_fpos64_t *));\n-extern int _IO_old_fgetpos64 __P ((_IO_FILE *, _IO_fpos64_t *));\n-extern int _IO_new_fsetpos64 __P ((_IO_FILE *, const _IO_fpos64_t *));\n-extern int _IO_old_fsetpos64 __P ((_IO_FILE *, const _IO_fpos64_t *));\n-\n-\n-#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-# define _IO_do_flush(_f) \\\n-  ((_f)->_mode <= 0\t\t\t\t\t\t\t      \\\n-   ? _IO_do_write(_f, (_f)->_IO_write_base,\t\t\t\t      \\\n-\t\t  (_f)->_IO_write_ptr-(_f)->_IO_write_base)\t\t      \\\n-   : _IO_wdo_write(_f, (_f)->_wide_data->_IO_write_base,\t\t      \\\n-\t\t   ((_f)->_wide_data->_IO_write_ptr\t\t\t      \\\n-\t\t    - (_f)->_wide_data->_IO_write_base)))\n-#else\n-# define _IO_do_flush(_f) \\\n-   _IO_do_write(_f, (_f)->_IO_write_base,\t\t\t\t      \\\n-\t\t(_f)->_IO_write_ptr-(_f)->_IO_write_base)\n-#endif\n-#define _IO_old_do_flush(_f) \\\n-  _IO_old_do_write(_f, (_f)->_IO_write_base, \\\n-\t\t   (_f)->_IO_write_ptr-(_f)->_IO_write_base)\n-#define _IO_in_put_mode(_fp) ((_fp)->_flags & _IO_CURRENTLY_PUTTING)\n-#define _IO_mask_flags(fp, f, mask) \\\n-       ((fp)->_flags = ((fp)->_flags & ~(mask)) | ((f) & (mask)))\n-#define _IO_setg(fp, eb, g, eg)  ((fp)->_IO_read_base = (eb),\\\n-\t(fp)->_IO_read_ptr = (g), (fp)->_IO_read_end = (eg))\n-#define _IO_wsetg(fp, eb, g, eg)  ((fp)->_wide_data->_IO_read_base = (eb),\\\n-\t(fp)->_wide_data->_IO_read_ptr = (g), \\\n-\t(fp)->_wide_data->_IO_read_end = (eg))\n-#define _IO_setp(__fp, __p, __ep) \\\n-       ((__fp)->_IO_write_base = (__fp)->_IO_write_ptr \\\n-\t= __p, (__fp)->_IO_write_end = (__ep))\n-#define _IO_wsetp(__fp, __p, __ep) \\\n-       ((__fp)->_wide_data->_IO_write_base \\\n-\t= (__fp)->_wide_data->_IO_write_ptr = __p, \\\n-\t(__fp)->_wide_data->_IO_write_end = (__ep))\n-#define _IO_have_backup(fp) ((fp)->_IO_save_base != NULL)\n-#define _IO_have_wbackup(fp) ((fp)->_wide_data->_IO_save_base != NULL)\n-#define _IO_in_backup(fp) ((fp)->_flags & _IO_IN_BACKUP)\n-#define _IO_have_markers(fp) ((fp)->_markers != NULL)\n-#define _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)\n-#define _IO_wblen(fp) ((fp)->_wide_data->_IO_buf_end \\\n-\t\t       - (fp)->_wide_data->_IO_buf_base)\n-\n-/* Jumptable functions for files. */\n-\n-extern int _IO_file_doallocate __P ((_IO_FILE *));\n-extern _IO_FILE* _IO_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n-extern _IO_off64_t _IO_file_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern _IO_size_t _IO_file_xsputn __P ((_IO_FILE *, const void *, _IO_size_t));\n-extern _IO_size_t _IO_file_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n-extern int _IO_file_stat __P ((_IO_FILE *, void *));\n-extern int _IO_file_close __P ((_IO_FILE *));\n-extern int _IO_file_underflow __P ((_IO_FILE *));\n-extern int _IO_file_overflow __P ((_IO_FILE *, int));\n-#define _IO_file_is_open(__fp) ((__fp)->_fileno != -1)\n-extern void _IO_file_init __P ((struct _IO_FILE_plus *));\n-extern _IO_FILE* _IO_file_attach __P ((_IO_FILE *, int));\n-extern _IO_FILE* _IO_file_open __P ((_IO_FILE *, const char *, int, int,\n-\t\t\t\t     int, int));\n-extern _IO_FILE* _IO_file_fopen __P ((_IO_FILE *, const char *, const char *,\n-\t\t\t\t      int));\n-extern _IO_ssize_t _IO_file_write __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t_IO_ssize_t));\n-extern _IO_ssize_t _IO_file_read __P ((_IO_FILE *, void *, _IO_ssize_t));\n-extern int _IO_file_sync __P ((_IO_FILE *));\n-extern int _IO_file_close_it __P ((_IO_FILE *));\n-extern _IO_off64_t _IO_file_seek __P ((_IO_FILE *, _IO_off64_t, int));\n-extern void _IO_file_finish __P ((_IO_FILE *, int));\n-\n-extern _IO_FILE* _IO_new_file_attach __P ((_IO_FILE *, int));\n-extern int _IO_new_file_close_it __P ((_IO_FILE *));\n-extern void _IO_new_file_finish __P ((_IO_FILE *, int));\n-extern _IO_FILE* _IO_new_file_fopen __P ((_IO_FILE *, const char *, const char *,\n-\t\t\t\t\t  int));\n-extern void _IO_no_init __P ((_IO_FILE *, int, int, struct _IO_wide_data *,\n-\t\t\t      struct _IO_jump_t *));\n-extern void _IO_new_file_init __P ((struct _IO_FILE_plus *));\n-extern _IO_FILE* _IO_new_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n-extern int _IO_new_file_sync __P ((_IO_FILE *));\n-extern int _IO_new_file_underflow __P ((_IO_FILE *));\n-extern int _IO_new_file_overflow __P ((_IO_FILE *, int));\n-extern _IO_off64_t _IO_new_file_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern _IO_ssize_t _IO_new_file_write __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t    _IO_ssize_t));\n-extern _IO_size_t _IO_new_file_xsputn __P ((_IO_FILE *, const void *, _IO_size_t));\n-\n-extern _IO_FILE* _IO_old_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n-extern _IO_off64_t _IO_old_file_seekoff __P ((_IO_FILE *, _IO_off64_t, int,\n-\t\t\t\t\t      int));\n-extern _IO_size_t _IO_old_file_xsputn __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t    _IO_size_t));\n-extern int _IO_old_file_underflow __P ((_IO_FILE *));\n-extern int _IO_old_file_overflow __P ((_IO_FILE *, int));\n-extern void _IO_old_file_init __P ((struct _IO_FILE_plus *));\n-extern _IO_FILE* _IO_old_file_attach __P ((_IO_FILE *, int));\n-extern _IO_FILE* _IO_old_file_fopen __P ((_IO_FILE *, const char *,\n-\t\t\t\t\t  const char *));\n-extern _IO_ssize_t _IO_old_file_write __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t    _IO_ssize_t));\n-extern int _IO_old_file_sync __P ((_IO_FILE *));\n-extern int _IO_old_file_close_it __P ((_IO_FILE *));\n-extern void _IO_old_file_finish __P ((_IO_FILE *, int));\n-\n-extern int _IO_wfile_doallocate __P ((_IO_FILE *));\n-extern _IO_size_t _IO_wfile_xsputn __P ((_IO_FILE *, const void *,\n-\t\t\t\t\t _IO_size_t));\n-extern _IO_FILE* _IO_wfile_setbuf __P ((_IO_FILE *, wchar_t *, _IO_ssize_t));\n-extern wint_t _IO_wfile_sync __P ((_IO_FILE *));\n-extern wint_t _IO_wfile_underflow __P ((_IO_FILE *));\n-extern wint_t _IO_wfile_overflow __P ((_IO_FILE *, wint_t));\n-extern _IO_off64_t _IO_wfile_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-\n-/* Jumptable functions for proc_files. */\n-extern _IO_FILE* _IO_proc_open __P ((_IO_FILE *, const char *, const char *));\n-extern _IO_FILE* _IO_new_proc_open __P ((_IO_FILE *, const char *, const char *));\n-extern _IO_FILE* _IO_old_proc_open __P ((_IO_FILE *, const char *, const char *));\n-extern int _IO_proc_close __P ((_IO_FILE *));\n-extern int _IO_new_proc_close __P ((_IO_FILE *));\n-extern int _IO_old_proc_close __P ((_IO_FILE *));\n-\n-/* Jumptable functions for strfiles. */\n-extern int _IO_str_underflow __P ((_IO_FILE *));\n-extern int _IO_str_overflow __P ((_IO_FILE *, int));\n-extern int _IO_str_pbackfail __P ((_IO_FILE *, int));\n-extern _IO_off64_t _IO_str_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern void _IO_str_finish __P ((_IO_FILE *, int));\n-\n-/* Other strfile functions */\n-struct _IO_strfile_;\n-extern void _IO_str_init_static __P ((struct _IO_strfile_ *, char *, int, char *));\n-extern void _IO_str_init_readonly __P ((struct _IO_strfile_ *, const char *, int));\n-extern _IO_ssize_t _IO_str_count __P ((_IO_FILE *));\n-\n-/* And the wide character versions.  */\n-extern void _IO_wstr_init_static __P ((_IO_FILE *, wchar_t *, int, wchar_t *));\n-extern void _IO_wstr_init_readonly __P ((_IO_FILE *, const char *, int));\n-extern _IO_ssize_t _IO_wstr_count __P ((_IO_FILE *));\n-extern _IO_wint_t _IO_wstr_overflow __P ((_IO_FILE *, _IO_wint_t));\n-extern _IO_wint_t _IO_wstr_underflow __P ((_IO_FILE *));\n-extern _IO_off64_t _IO_wstr_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern _IO_wint_t _IO_wstr_pbackfail __P ((_IO_FILE *, _IO_wint_t));\n-extern void _IO_wstr_finish __P ((_IO_FILE *, int));\n-\n-extern int _IO_vasprintf __P ((char **result_ptr, __const char *format,\n-\t\t\t       _IO_va_list args));\n-extern int _IO_vdprintf __P ((int d, __const char *format, _IO_va_list arg));\n-extern int _IO_vsnprintf __P ((char *string, _IO_size_t maxlen,\n-\t\t\t       __const char *format, _IO_va_list args));\n-\n-\n-extern _IO_size_t _IO_getline __P ((_IO_FILE *,char *, _IO_size_t, int, int));\n-extern _IO_size_t _IO_getline_info __P ((_IO_FILE *,char *, _IO_size_t,\n-\t\t\t\t\t int, int, int *));\n-extern _IO_ssize_t _IO_getdelim __P ((char **, _IO_size_t *, int, _IO_FILE *));\n-extern _IO_size_t _IO_getwline __P ((_IO_FILE *,wchar_t *, _IO_size_t, wint_t,\n-\t\t\t\t     int));\n-extern _IO_size_t _IO_getwline_info __P ((_IO_FILE *,wchar_t *, _IO_size_t,\n-\t\t\t\t\t  wint_t, int, wint_t *));\n-extern double _IO_strtod __P ((const char *, char **));\n-extern char *_IO_dtoa __P ((double __d, int __mode, int __ndigits,\n-\t\t\t    int *__decpt, int *__sign, char **__rve));\n-extern int _IO_outfloat __P ((double __value, _IO_FILE *__sb, int __type,\n-\t\t\t      int __width, int __precision, int __flags,\n-\t\t\t      int __sign_mode, int __fill));\n-\n-extern struct _IO_FILE_plus *_IO_list_all;\n-extern void (*_IO_cleanup_registration_needed) __PMT ((void));\n-\n-#ifndef EOF\n-# define EOF (-1)\n-#endif\n-#ifndef NULL\n-# if defined __GNUG__ && \\\n-    (__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 8))\n-#  define NULL (__null)\n-# else\n-#  if !defined(__cplusplus)\n-#   define NULL ((void*)0)\n-#  else\n-#   define NULL (0)\n-#  endif\n-# endif\n-#endif\n-\n-#if _G_HAVE_MMAP\n-\n-#ifdef __cplusplus\n-} \n-#endif\n-\n-# include <unistd.h>\n-# include <fcntl.h>\n-# include <sys/mman.h>\n-# include <sys/param.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-# if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)\n-#  define MAP_ANONYMOUS MAP_ANON\n-# endif\n-\n-# if !defined(MAP_ANONYMOUS) || !defined(EXEC_PAGESIZE)\n-#  undef _G_HAVE_MMAP\n-#  define _G_HAVE_MMAP 0\n-# endif\n-\n-#endif /* _G_HAVE_MMAP */\n-\n-#if _G_HAVE_MMAP\n-\n-# ifdef _LIBC\n-/* When using this code in the GNU libc we must not pollute the name space.  */\n-#  define mmap __mmap\n-#  define munmap __munmap\n-#  define ftruncate __ftruncate\n-# endif\n-\n-# define ROUND_TO_PAGE(_S) \\\n-       (((_S) + EXEC_PAGESIZE - 1) & ~(EXEC_PAGESIZE - 1))\n-\n-# define FREE_BUF(_B, _S) \\\n-       munmap ((_B), ROUND_TO_PAGE (_S))\n-# define ALLOC_BUF(_B, _S, _R) \\\n-       do {\t\t\t\t\t\t\t\t      \\\n-\t  (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),\t\t\t      \\\n-\t\t\t\tPROT_READ | PROT_WRITE,\t\t\t      \\\n-\t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n-\t  if ((_B) == (char *) MAP_FAILED)\t\t\t\t      \\\n-\t    return (_R);\t\t\t\t\t\t      \\\n-       } while (0)\n-# define ALLOC_WBUF(_B, _S, _R) \\\n-       do {\t\t\t\t\t\t\t\t      \\\n-\t  (_B) = (wchar_t *) mmap (0, ROUND_TO_PAGE (_S),\t\t      \\\n-\t\t\t\t   PROT_READ | PROT_WRITE,\t\t      \\\n-\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n-\t  if ((_B) == (wchar_t *) MAP_FAILED)\t\t\t\t      \\\n-\t    return (_R);\t\t\t\t\t\t      \\\n-       } while (0)\n-\n-#else /* _G_HAVE_MMAP */\n-\n-# define FREE_BUF(_B, _S) \\\n-       free(_B)\n-# define ALLOC_BUF(_B, _S, _R) \\\n-       do {\t\t\t\t\t\t\t\t      \\\n-\t  (_B) = (char*)malloc(_S);\t\t\t\t\t      \\\n-\t  if ((_B) == NULL)\t\t\t\t\t\t      \\\n-\t    return (_R);\t\t\t\t\t\t      \\\n-       } while (0)\n-# define ALLOC_WBUF(_B, _S, _R) \\\n-       do {\t\t\t\t\t\t\t\t      \\\n-\t  (_B) = (wchar_t *)malloc(_S);\t\t\t\t\t      \\\n-\t  if ((_B) == NULL)\t\t\t\t\t\t      \\\n-\t    return (_R);\t\t\t\t\t\t      \\\n-       } while (0)\n-\n-#endif /* _G_HAVE_MMAP */\n-\n-#ifndef OS_FSTAT\n-# define OS_FSTAT fstat\n-#endif\n-struct stat;\n-extern _IO_ssize_t _IO_read __P ((int, void *, _IO_size_t));\n-extern _IO_ssize_t _IO_write __P ((int, const void *, _IO_size_t));\n-extern _IO_off64_t _IO_lseek __P ((int, _IO_off64_t, int));\n-extern int _IO_close __P ((int));\n-extern int _IO_fstat __P ((int, struct stat *));\n-extern int _IO_vscanf __P ((const char *, _IO_va_list));\n-\n-/* _IO_pos_BAD is an _IO_off64_t value indicating error, unknown, or EOF. */\n-#ifndef _IO_pos_BAD\n-# define _IO_pos_BAD ((_IO_off64_t) -1)\n-#endif\n-/* _IO_pos_adjust adjust an _IO_off64_t by some number of bytes. */\n-#ifndef _IO_pos_adjust\n-# define _IO_pos_adjust(pos, delta) ((pos) += (delta))\n-#endif\n-/* _IO_pos_0 is an _IO_off64_t value indicating beginning of file. */\n-#ifndef _IO_pos_0\n-# define _IO_pos_0 ((_IO_off64_t) 0)\n-#endif\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#ifdef _IO_MTSAFE_IO\n-/* check following! */\n-# ifdef _IO_USE_OLD_IO_FILE\n-#  define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n-       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \\\n-\t 0, _IO_pos_BAD, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock }\n-# else\n-#  if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n-       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \\\n-\t 0, _IO_pos_BAD, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock, _IO_pos_BAD,\\\n-\t NULL, WDP, 0 }\n-#  else\n-#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n-       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \\\n-\t 0, _IO_pos_BAD, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock, _IO_pos_BAD,\\\n-\t 0 }\n-#  endif\n-# endif\n-#else\n-# ifdef _IO_USE_OLD_IO_FILE\n-#  define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n-       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \\\n-\t 0, _IO_pos_BAD }\n-# else\n-#  if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n-       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \\\n-\t 0, _IO_pos_BAD, 0, 0, { 0 }, 0, _IO_pos_BAD, \\\n-\t NULL, WDP, 0 }\n-#  else\n-#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n-       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (_IO_FILE *) CHAIN, FD, \\\n-\t 0, _IO_pos_BAD, 0, 0, { 0 }, 0, _IO_pos_BAD, \\\n-\t 0 }\n-#  endif\n-# endif\n-#endif\n-\n-/* VTABLE_LABEL defines NAME as of the CLASS class.\n-   CNLENGTH is strlen(#CLASS).  */\n-#ifdef __GNUC__\n-# if _G_VTABLE_LABEL_HAS_LENGTH\n-#  define VTABLE_LABEL(NAME, CLASS, CNLENGTH) \\\n-  extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CNLENGTH #CLASS);\n-# else\n-#  define VTABLE_LABEL(NAME, CLASS, CNLENGTH) \\\n-  extern char NAME[] asm (_G_VTABLE_LABEL_PREFIX #CLASS);\n-# endif\n-#endif /* __GNUC__ */\n-\n-#if !defined(builtinbuf_vtable) && defined(__cplusplus)\n-# ifdef __GNUC__\n-VTABLE_LABEL(builtinbuf_vtable, builtinbuf, 10)\n-# else\n-#  if _G_VTABLE_LABEL_HAS_LENGTH\n-#   define builtinbuf_vtable _G_VTABLE_LABEL_PREFIX_ID##10builtinbuf\n-#  else\n-#   define builtinbuf_vtable _G_VTABLE_LABEL_PREFIX_ID##builtinbuf\n-#  endif\n-# endif\n-#endif /* !defined(builtinbuf_vtable) && defined(__cplusplus) */\n-\n-#if defined(__STDC__) || defined(__cplusplus)\n-# define _IO_va_start(args, last) va_start(args, last)\n-#else\n-# define _IO_va_start(args, last) va_start(args)\n-#endif\n-\n-extern struct _IO_fake_stdiobuf _IO_stdin_buf, _IO_stdout_buf, _IO_stderr_buf;\n-\n-#if 1\n-# define COERCE_FILE(FILE) /* Nothing */\n-#else\n-/* This is part of the kludge for binary compatibility with old stdio. */\n-# define COERCE_FILE(FILE) \\\n-  (((FILE)->_IO_file_flags & _IO_MAGIC_MASK) == _OLD_MAGIC_MASK \\\n-    && (FILE) = *(FILE**)&((int*)fp)[1])\n-#endif\n-\n-#ifdef EINVAL\n-# define MAYBE_SET_EINVAL __set_errno (EINVAL)\n-#else\n-# define MAYBE_SET_EINVAL /* nothing */\n-#endif\n-\n-#ifdef IO_DEBUG\n-# define CHECK_FILE(FILE, RET) \\\n-\tif ((FILE) == NULL) { MAYBE_SET_EINVAL; return RET; } \\\n-\telse { COERCE_FILE(FILE); \\\n-\t       if (((FILE)->_IO_file_flags & _IO_MAGIC_MASK) != _IO_MAGIC) \\\n-\t  { MAYBE_SET_EINVAL; return RET; }}\n-#else\n-# define CHECK_FILE(FILE, RET) COERCE_FILE (FILE)\n-#endif"}, {"sha": "b81fef8b883009e7f9187a59dd19c1d0fc268ad6", "filename": "libstdc++-v3/libio/stdfiles.c", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,71 +0,0 @@\n-/* Copyright (C) 1993, 1994, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-\n-/* This file provides definitions of _IO_stdin, _IO_stdout, and _IO_stderr\n-   for C code.  Compare stdstreams.cc.\n-   (The difference is that here the vtable field is set to 0,\n-   so the objects defined are not valid C++ objects.  On the other\n-   hand, we don't need a C++ compiler to build this file.) */\n-\n-#include \"libioP.h\"\n-\n-#ifdef _IO_MTSAFE_IO\n-# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n-  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n-  static struct _IO_wide_data _IO_wide_data_##FD \\\n-    = { ._wide_vtable = &_IO_wfile_jumps }; \\\n-  struct _IO_FILE_plus NAME \\\n-    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, &_IO_wide_data_##FD), \\\n-       &_IO_file_jumps};\n-# else\n-#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n-  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n-  struct _IO_FILE_plus NAME \\\n-    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, NULL), \\\n-       &_IO_file_jumps};\n-# endif\n-#else\n-# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n-#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n-  static struct _IO_wide_data _IO_wide_data_##FD \\\n-    = { ._wide_vtable = &_IO_wfile_jumps }; \\\n-  struct _IO_FILE_plus NAME \\\n-    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, &_IO_wide_data_##FD), \\\n-       &_IO_file_jumps};\n-# else\n-#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n-  struct _IO_FILE_plus NAME \\\n-    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, NULL), \\\n-       &_IO_file_jumps};\n-# endif\n-#endif\n-\n-DEF_STDFILE(_IO_2_1_stdin_, 0, 0, _IO_NO_WRITES);\n-DEF_STDFILE(_IO_2_1_stdout_, 1, &_IO_2_1_stdin_, _IO_NO_READS);\n-DEF_STDFILE(_IO_2_1_stderr_, 2, &_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);\n-\n-struct _IO_FILE_plus *_IO_list_all = &_IO_2_1_stderr_;"}, {"sha": "3b897ced1767d5f41b7da16530f6926fa0c29de7", "filename": "libstdc++-v3/libio/stdio.c", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fstdio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fstdio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fstdio.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,43 +0,0 @@\n-/* Copyright (C) 1993, 1994, 1996, 1997, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include \"libioP.h\"\n-#include \"stdio.h\"\n-\n-#undef stdin\n-#undef stdout\n-#undef stderr\n-_IO_FILE *stdin = (FILE *) &_IO_2_1_stdin_;\n-_IO_FILE *stdout = (FILE *) &_IO_2_1_stdout_;\n-_IO_FILE *stderr = (FILE *) &_IO_2_1_stderr_;\n-\n-#undef _IO_stdin\n-#undef _IO_stdout\n-#undef _IO_stderr\n-#ifdef _LIBC\n-strong_alias (stdin, _IO_stdin);\n-strong_alias (stdout, _IO_stdout);\n-strong_alias (stderr, _IO_stderr);\n-#endif"}, {"sha": "9c05162041485f93c3cfc6083adaf998f8c9d10a", "filename": "libstdc++-v3/libio/wfiledoalloc.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fwfiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fwfiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fwfiledoalloc.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,108 +0,0 @@\n-/* Copyright (C) 1993, 1997, 1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/*\n- * Copyright (c) 1990 The Regents of the University of California.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms are permitted\n- * provided that the above copyright notice and this paragraph are\n- * duplicated in all such forms and that any documentation,\n- * advertising materials, and other materials related to such\n- * distribution and use acknowledge that the software was developed\n- * by the University of California, Berkeley.  The name of the\n- * University may not be used to endorse or promote products derived\n- * from this software without specific prior written permission.\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n- */\n-\n-/* Modified for GNU iostream by Per Bothner 1991, 1992. */\n-\n-#ifndef _POSIX_SOURCE\n-# define _POSIX_SOURCE\n-#endif\n-#include \"libioP.h\"\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#include <unistd.h>\n-#endif\n-\n-#ifdef _LIBC\n-# undef isatty\n-# define isatty(Fd) __isatty (Fd)\n-#endif\n-\n-/*\n- * Allocate a file buffer, or switch to unbuffered I/O.\n- * Per the ANSI C standard, ALL tty devices default to line buffered.\n- *\n- * As a side effect, we set __SOPT or __SNPT (en/dis-able fseek\n- * optimisation) right after the _fstat() that finds the buffer size.\n- */\n-\n-int\n-_IO_wfile_doallocate (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_size_t size;\n-  int couldbetty;\n-  wchar_t *p;\n-  struct _G_stat64 st;\n-\n-  /* Allocate room for the external buffer.  */\n-  if (fp->_IO_buf_base == NULL)\n-    _IO_file_doallocate (fp);\n-\n-  if (fp->_fileno < 0 || _IO_SYSSTAT (fp, &st) < 0)\n-    {\n-      couldbetty = 0;\n-      size = _IO_BUFSIZ;\n-#if 0\n-      /* do not try to optimise fseek() */\n-      fp->_flags |= __SNPT;\n-#endif\n-    }\n-  else\n-    {\n-      couldbetty = S_ISCHR (st.st_mode);\n-#if _IO_HAVE_ST_BLKSIZE\n-      size = st.st_blksize <= 0 ? _IO_BUFSIZ : st.st_blksize;\n-#else\n-      size = _IO_BUFSIZ;\n-#endif\n-    }\n-  ALLOC_WBUF (p, size * sizeof (wchar_t), EOF);\n-  _IO_wsetb (fp, p, p + size, 1);\n-  if (couldbetty && isatty (fp->_fileno))\n-    fp->_flags |= _IO_LINE_BUF;\n-  return 1;\n-}\n-\n-#endif /* _GLIBCPP_USE_WCHAR_T */"}, {"sha": "1dd524a3ffb25d3c0aa438ed6b779743cbb17f2b", "filename": "libstdc++-v3/libio/wfileops.c", "status": "removed", "additions": 0, "deletions": 754, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fwfileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fwfileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fwfileops.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,754 +0,0 @@\n-/* Copyright (C) 1993, 95, 97, 98, 99, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-   Written by Ulrich Drepper <drepper@cygnus.com>.\n-   Based on the single byte version by Per Bothner <bothner@cygnus.com>.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-#include <assert.h>\n-#include <libioP.h>\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-#include <wchar.h>\n-#ifdef HAVE_GCONV_H\n-#  include <gconv.h>\n-#endif\n-#include <stdlib.h>\n-#include <string.h>\n-\n-\n-#ifndef _LIBC\n-# define _IO_new_do_write _IO_do_write\n-# define _IO_new_file_attach _IO_file_attach\n-# define _IO_new_file_close_it _IO_file_close_it\n-# define _IO_new_file_finish _IO_file_finish\n-# define _IO_new_file_fopen _IO_file_fopen\n-# define _IO_new_file_init _IO_file_init\n-# define _IO_new_file_setbuf _IO_file_setbuf\n-# define _IO_new_file_sync _IO_file_sync\n-# define _IO_new_file_overflow _IO_file_overflow\n-# define _IO_new_file_seekoff _IO_file_seekoff\n-# define _IO_new_file_underflow _IO_file_underflow\n-# define _IO_new_file_write _IO_file_write\n-# define _IO_new_file_xsputn _IO_file_xsputn\n-#endif\n-\n-\n-_IO_FILE *\n-_IO_wfile_setbuf (fp, p, len)\n-     _IO_FILE *fp;\n-     wchar_t *p;\n-     _IO_ssize_t len;\n-{\n-  if (_IO_wdefault_setbuf (fp, p, len) == NULL)\n-    return NULL;\n-\n-  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr =\n-    fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_buf_base;\n-  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base,\n-\t     fp->_wide_data->_IO_buf_base);\n-\n-  return fp;\n-}\n-\n-\n-/* Convert TO_DO wide character from DATA to FP.\n-   Then mark FP as having empty buffers. */\n-int\n-_IO_wdo_write (fp, data, to_do)\n-     _IO_FILE *fp;\n-     const wchar_t *data;\n-     _IO_size_t to_do;\n-{\n-  struct _IO_codecvt *cc = fp->_codecvt;\n-\n-  if (to_do > 0)\n-    {\n-      if (fp->_IO_write_end == fp->_IO_write_ptr\n-\t  && fp->_IO_write_end != fp->_IO_write_base)\n-\t{\n-\t  if (_IO_new_do_write (fp, fp->_IO_write_base,\n-\t\t\t\tfp->_IO_write_ptr - fp->_IO_write_base) == EOF)\n-\t    return EOF;\n-\t}\n-\n-      do\n-\t{\n-\t  enum __codecvt_result result;\n-\t  const wchar_t *new_data;\n-\n-\t  /* Now convert from the internal format into the external buffer.  */\n-\t  result = (*cc->__codecvt_do_out) (cc, &fp->_wide_data->_IO_state,\n-\t\t\t\t\t    data, data + to_do, &new_data,\n-\t\t\t\t\t    fp->_IO_write_ptr,\n-\t\t\t\t\t    fp->_IO_buf_end,\n-\t\t\t\t\t    &fp->_IO_write_ptr);\n-\n-\t  /* Write out what we produced so far.  */\n-\t  if (_IO_new_do_write (fp, fp->_IO_write_base,\n-\t\t\t\tfp->_IO_write_ptr - fp->_IO_write_base) == EOF)\n-\t    /* Something went wrong.  */\n-\t    return EOF;\n-\n-\t  to_do -= new_data - data;\n-\n-\t  /* Next see whether we had problems during the conversion.  If yes,\n-\t     we cannot go on.  */\n-\t  if (result != __codecvt_ok\n-\t      && (result != __codecvt_partial || new_data - data == 0))\n-\t    break;\n-\n-\t  data = new_data;\n-\t}\n-      while (to_do > 0);\n-    }\n-\n-  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base,\n-\t     fp->_wide_data->_IO_buf_base);\n-  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n-    = fp->_wide_data->_IO_buf_base;\n-  fp->_wide_data->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\t\t\t\t   ? fp->_wide_data->_IO_buf_base\n-\t\t\t\t   : fp->_wide_data->_IO_buf_end);\n-\n-  return to_do == 0 ? 0 : WEOF;\n-}\n-\n-\n-wint_t\n-_IO_wfile_underflow (fp)\n-     _IO_FILE *fp;\n-{\n-  struct _IO_codecvt *cd;\n-  enum __codecvt_result status;\n-  _IO_ssize_t count;\n-  int tries;\n-  const char *read_ptr_copy;\n-\n-  if (fp->_flags & _IO_NO_READS)\n-    {\n-      fp->_flags |= _IO_ERR_SEEN;\n-      __set_errno (EBADF);\n-      return WEOF;\n-    }\n-  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n-    return *fp->_wide_data->_IO_read_ptr;\n-\n-  cd = fp->_codecvt;\n-\n-  /* Maybe there is something left in the external buffer.  */\n-  if (fp->_IO_read_ptr < fp->_IO_read_end)\n-    {\n-      /* Convert it.  */\n-      size_t avail_bytes = fp->_IO_read_end - fp->_IO_read_ptr;\n-\n-      if (avail_bytes >= (*cd->__codecvt_do_max_length) (cd))\n-\t{\n-\t  /* There is more in the external.  */\n-\t  const char *read_stop = (const char *) fp->_IO_read_ptr;\n-\n-\t  fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;\n-\t  status = (*cd->__codecvt_do_in) (cd, &fp->_wide_data->_IO_state,\n-\t\t\t\t\t   fp->_IO_read_ptr, fp->_IO_read_end,\n-\t\t\t\t\t   &read_stop,\n-\t\t\t\t\t   fp->_wide_data->_IO_read_end,\n-\t\t\t\t\t   fp->_wide_data->_IO_buf_end,\n-\t\t\t\t\t   &fp->_wide_data->_IO_read_end);\n-\n-\t  fp->_IO_read_ptr = (char *) read_stop;\n-\n-\t  /* If we managed to generate some text return the next character.  */\n-\t  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n-\t    return *fp->_wide_data->_IO_read_ptr;\n-\n-\t  if (status == __codecvt_error)\n-\t    {\n-\t      __set_errno (EILSEQ);\n-\t      fp->_flags |= _IO_ERR_SEEN;\n-\t      return WEOF;\n-\t    }\n-\t}\n-\n-      /* Move the remaining content of the read buffer to the beginning.  */\n-      memmove (fp->_IO_buf_base, fp->_IO_read_ptr,\n-\t       fp->_IO_read_end - fp->_IO_read_ptr);\n-      fp->_IO_read_end = (fp->_IO_buf_base\n-\t\t\t  + (fp->_IO_read_end - fp->_IO_read_ptr));\n-      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n-    }\n-  else\n-    fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =\n-      fp->_IO_buf_base;\n-\n-  if (fp->_IO_buf_base == NULL)\n-    {\n-      /* Maybe we already have a push back pointer.  */\n-      if (fp->_IO_save_base != NULL)\n-\t{\n-\t  free (fp->_IO_save_base);\n-\t  fp->_flags &= ~_IO_IN_BACKUP;\n-\t}\n-      _IO_doallocbuf (fp);\n-\n-      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =\n-\tfp->_IO_buf_base;\n-    }\n-\n-  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end =\n-    fp->_IO_buf_base;\n-\n-  if (fp->_wide_data->_IO_buf_base == NULL)\n-    {\n-      /* Maybe we already have a push back pointer.  */\n-      if (fp->_wide_data->_IO_save_base != NULL)\n-\t{\n-\t  free (fp->_wide_data->_IO_save_base);\n-\t  fp->_flags &= ~_IO_IN_BACKUP;\n-\t}\n-      _IO_wdoallocbuf (fp);\n-    }\n-\n-  /* Flush all line buffered files before reading. */\n-  /* FIXME This can/should be moved to genops ?? */\n-  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-    _IO_flush_all_linebuffered ();\n-\n-  _IO_switch_to_get_mode (fp);\n-\n-  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr =\n-    fp->_wide_data->_IO_buf_base;\n-  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_buf_base;\n-  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr =\n-    fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_buf_base;\n-\n-  tries = 0;\n- again:\n-  count = _IO_SYSREAD (fp, fp->_IO_read_end,\n-\t\t       fp->_IO_buf_end - fp->_IO_read_end);\n-  if (count <= 0)\n-    {\n-      if (count == 0 && tries == 0)\n-\tfp->_flags |= _IO_EOF_SEEN;\n-      else\n-\tfp->_flags |= _IO_ERR_SEEN, count = 0;\n-    }\n-  fp->_IO_read_end += count;\n-  if (count == 0)\n-    {\n-      if (tries != 0)\n-\t/* There are some bytes in the external buffer but they don't\n-           convert to anything.  */\n-\t__set_errno (EILSEQ);\n-      return WEOF;\n-    }\n-  if (fp->_offset != _IO_pos_BAD)\n-    _IO_pos_adjust (fp->_offset, count);\n-\n-  /* Now convert the read input.  */\n-  fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;\n-  fp->_IO_read_base = fp->_IO_read_ptr;\n-  status = (*cd->__codecvt_do_in) (cd, &fp->_wide_data->_IO_state,\n-\t\t\t\t   fp->_IO_read_ptr, fp->_IO_read_end,\n-\t\t\t\t   &read_ptr_copy,\n-\t\t\t\t   fp->_wide_data->_IO_read_end,\n-\t\t\t\t   fp->_wide_data->_IO_buf_end,\n-\t\t\t\t   &fp->_wide_data->_IO_read_end);\n-\n-  fp->_IO_read_ptr = (char *) read_ptr_copy;\n-  if (fp->_wide_data->_IO_read_end == fp->_wide_data->_IO_buf_base)\n-    {\n-      if (status == __codecvt_error || fp->_IO_read_end == fp->_IO_buf_end)\n-\t{\n-\t  __set_errno (EILSEQ);\n-\t  fp->_flags |= _IO_ERR_SEEN;\n-\t  return WEOF;\n-\t}\n-\n-      /* The read bytes make no complete character.  Try reading again.  */\n-      assert (status == __codecvt_partial);\n-      ++tries;\n-      goto again;\n-    }\n-\n-  return *fp->_wide_data->_IO_read_ptr;\n-}\n-\n-\n-wint_t\n-_IO_wfile_overflow (f, wch)\n-     _IO_FILE *f;\n-     wint_t wch;\n-{\n-  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n-    {\n-      f->_flags |= _IO_ERR_SEEN;\n-      __set_errno (EBADF);\n-      return WEOF;\n-    }\n-  /* If currently reading or no buffer allocated. */\n-  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n-    {\n-      /* Allocate a buffer if needed. */\n-      if (f->_wide_data->_IO_write_base == 0)\n-\t{\n-\t  _IO_wdoallocbuf (f);\n-\t  _IO_wsetg (f, f->_wide_data->_IO_buf_base,\n-\t\t     f->_wide_data->_IO_buf_base, f->_wide_data->_IO_buf_base);\n-\n-\t  if (f->_IO_write_base == NULL)\n-\t    {\n-\t      _IO_doallocbuf (f);\n-\t      _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise must be currently reading.  If _IO_read_ptr\n-\t     (and hence also _IO_read_end) is at the buffer end,\n-\t     logically slide the buffer forwards one block (by setting\n-\t     the read pointers to all point at the beginning of the\n-\t     block).  This makes room for subsequent output.\n-\t     Otherwise, set the read pointers to _IO_read_end (leaving\n-\t     that alone, so it can continue to correspond to the\n-\t     external position). */\n-\t  if (f->_wide_data->_IO_read_ptr == f->_wide_data->_IO_buf_end)\n-\t    {\n-\t      f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n-\t      f->_wide_data->_IO_read_end = f->_wide_data->_IO_read_ptr =\n-\t\tf->_wide_data->_IO_buf_base;\n-\t    }\n-\t}\n-      f->_wide_data->_IO_write_ptr = f->_wide_data->_IO_read_ptr;\n-      f->_wide_data->_IO_write_base = f->_wide_data->_IO_write_ptr;\n-      f->_wide_data->_IO_write_end = f->_wide_data->_IO_buf_end;\n-      f->_wide_data->_IO_read_base = f->_wide_data->_IO_read_ptr =\n-\tf->_wide_data->_IO_read_end;\n-\n-      f->_IO_write_ptr = f->_IO_read_ptr;\n-      f->_IO_write_base = f->_IO_write_ptr;\n-      f->_IO_write_end = f->_IO_buf_end;\n-      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n-\n-      f->_flags |= _IO_CURRENTLY_PUTTING;\n-      if (f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\tf->_wide_data->_IO_write_end = f->_wide_data->_IO_write_ptr;\n-    }\n-  if (wch == WEOF)\n-    return _IO_do_flush (f);\n-  if (f->_wide_data->_IO_write_ptr == f->_wide_data->_IO_buf_end)\n-    /* Buffer is really full */\n-    if (_IO_do_flush (f) == WEOF)\n-      return WEOF;\n-  *f->_wide_data->_IO_write_ptr++ = wch;\n-  if ((f->_flags & _IO_UNBUFFERED)\n-      || ((f->_flags & _IO_LINE_BUF) && wch == L'\\n'))\n-    if (_IO_do_flush (f) == WEOF)\n-      return WEOF;\n-  return wch;\n-}\n-\n-wint_t\n-_IO_wfile_sync (fp)\n-     _IO_FILE *fp;\n-{\n-  _IO_ssize_t delta;\n-  wint_t retval = 0;\n-\n-  /*    char* ptr = cur_ptr(); */\n-  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n-    if (_IO_do_flush (fp))\n-      return WEOF;\n-  delta = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n-  if (delta != 0)\n-    {\n-      /* We have to find out how many bytes we have to go back in the\n-\t external buffer.  */\n-      struct _IO_codecvt *cv = fp->_codecvt;\n-      _IO_off64_t new_pos;\n-\n-      int clen = (*cv->__codecvt_do_encoding) (cv);\n-\n-      if (clen > 0)\n-\t/* It is easy, a fixed number of input bytes are used for each\n-\t   wide character.  */\n-\tdelta *= clen;\n-      else\n-\t{\n-\t  /* We have to find out the hard way how much to back off.\n-             To do this we determine how much input we needed to\n-             generate the wide characters up to the current reading\n-             position.  */\n-\t  int nread;\n-\n-\t  fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n-\t  nread = (*cv->__codecvt_do_length) (cv, &fp->_wide_data->_IO_state,\n-\t\t\t\t\t      fp->_IO_read_base,\n-\t\t\t\t\t      fp->_IO_read_end, delta);\n-\t  fp->_IO_read_ptr = fp->_IO_read_base + nread;\n-\t  delta = -(fp->_IO_read_end - fp->_IO_read_base - nread);\n-\t}\n-\n-      new_pos = _IO_SYSSEEK (fp, delta, 1);\n-      if (new_pos != (_IO_off64_t) EOF)\n-\t{\n-\t  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n-\t  fp->_IO_read_end = fp->_IO_read_ptr;\n-\t}\n-#ifdef ESPIPE\n-      else if (errno == ESPIPE)\n-\t; /* Ignore error from unseekable devices. */\n-#endif\n-      else\n-\tretval = WEOF;\n-    }\n-  if (retval != WEOF)\n-    fp->_offset = _IO_pos_BAD;\n-  /* FIXME: Cleanup - can this be shared? */\n-  /*    setg(base(), ptr, ptr); */\n-  return retval;\n-}\n-\n-_IO_off64_t\n-_IO_wfile_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off64_t offset;\n-     int dir;\n-     int mode;\n-{\n-  _IO_off64_t result;\n-  _IO_off64_t delta, new_offset;\n-  long int count;\n-  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n-     offset of the underlying file must be exact.  */\n-  int must_be_exact = ((fp->_wide_data->_IO_read_base\n-\t\t\t== fp->_wide_data->_IO_read_end)\n-\t\t       && (fp->_wide_data->_IO_write_base\n-\t\t\t   == fp->_wide_data->_IO_write_ptr));\n-\n-  if (mode == 0)\n-    dir = _IO_seek_cur, offset = 0; /* Don't move any pointers. */\n-\n-  /* Flush unwritten characters.\n-     (This may do an unneeded write if we seek within the buffer.\n-     But to be able to switch to reading, we would need to set\n-     egptr to ptr.  That can't be done in the current design,\n-     which assumes file_ptr() is eGptr.  Anyway, since we probably\n-     end up flushing when we close(), it doesn't make much difference.)\n-     FIXME: simulate mem-papped files. */\n-\n-  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base\n-      || _IO_in_put_mode (fp))\n-    if (_IO_switch_to_wget_mode (fp))\n-      return WEOF;\n-\n-  if (fp->_wide_data->_IO_buf_base == NULL)\n-    {\n-      /* It could be that we already have a pushback buffer.  */\n-      if (fp->_wide_data->_IO_read_base != NULL)\n-\t{\n-\t  free (fp->_wide_data->_IO_read_base);\n-\t  fp->_flags &= ~_IO_IN_BACKUP;\n-\t}\n-      _IO_doallocbuf (fp);\n-      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n-\t\t fp->_wide_data->_IO_buf_base);\n-      _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n-\t\t fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n-    }\n-\n-  switch (dir)\n-    {\n-      struct _IO_codecvt *cv;\n-      int clen;\n-\n-    case _IO_seek_cur:\n-      /* Adjust for read-ahead (bytes is buffer).  To do this we must\n-         find out which position in the external buffer corresponds to\n-         the current position in the internal buffer.  */\n-      cv = fp->_codecvt;\n-      clen = (*cv->__codecvt_do_encoding) (cv);\n-\n-      if (clen > 0)\n-\toffset -= (fp->_wide_data->_IO_read_end\n-\t\t   - fp->_wide_data->_IO_read_ptr) * clen;\n-      else\n-\t{\n-\t  int nread;\n-\n-\t  delta = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n-\t  fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n-\t  nread = (*cv->__codecvt_do_length) (cv, &fp->_wide_data->_IO_state,\n-\t\t\t\t\t      fp->_IO_read_base,\n-\t\t\t\t\t      fp->_IO_read_end, delta);\n-\t  fp->_IO_read_ptr = fp->_IO_read_base + nread;\n-\t  offset -= fp->_IO_read_end - fp->_IO_read_base - nread;\n-\t}\n-\n-      if (fp->_offset == _IO_pos_BAD)\n-\tgoto dumb;\n-      /* Make offset absolute, assuming current pointer is file_ptr(). */\n-      offset += fp->_offset;\n-\n-      dir = _IO_seek_set;\n-      break;\n-    case _IO_seek_set:\n-      break;\n-    case _IO_seek_end:\n-      {\n-\tstruct _G_stat64 st;\n-\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n-\t  {\n-\t    offset += st.st_size;\n-\t    dir = _IO_seek_set;\n-\t  }\n-\telse\n-\t  goto dumb;\n-      }\n-    }\n-  /* At this point, dir==_IO_seek_set. */\n-\n-  /* If we are only interested in the current position we've found it now.  */\n-  if (mode == 0)\n-    return offset;\n-\n-  /* If destination is within current buffer, optimize: */\n-  if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n-      && !_IO_in_backup (fp))\n-    {\n-      /* Offset relative to start of main get area. */\n-      _IO_off64_t rel_offset = (offset - fp->_offset\n-\t\t\t\t+ (fp->_IO_read_end - fp->_IO_read_base));\n-      if (rel_offset >= 0)\n-\t{\n-#if 0\n-\t  if (_IO_in_backup (fp))\n-\t    _IO_switch_to_main_get_area (fp);\n-#endif\n-\t  if (rel_offset <= fp->_IO_read_end - fp->_IO_read_base)\n-\t    {\n-\t      fp->_IO_read_ptr = fp->_IO_read_base + rel_offset;\n-\t      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-\n-\t      /* Now set the pointer for the internal buffer.  This\n-                 might be an iterative process.  Though the read\n-                 pointer is somewhere in the current external buffer\n-                 this does not mean we can convert this whole buffer\n-                 at once fitting in the internal buffer.  */\n-\t      do\n-\t\t{\n-\n-\t\t}\n-\t      while (0);\n-\n-\t      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-\t      goto resync;\n-\t    }\n-#ifdef TODO\n-\t    /* If we have streammarkers, seek forward by reading ahead. */\n-\t    if (_IO_have_markers (fp))\n-\t      {\n-\t\tint to_skip = rel_offset\n-\t\t  - (fp->_IO_read_ptr - fp->_IO_read_base);\n-\t\tif (ignore (to_skip) != to_skip)\n-\t\t  goto dumb;\n-\t\t_IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-\t\tgoto resync;\n-\t      }\n-#endif\n-\t}\n-#ifdef TODO\n-      if (rel_offset < 0 && rel_offset >= Bbase () - Bptr ())\n-\t{\n-\t  if (!_IO_in_backup (fp))\n-\t    _IO_switch_to_backup_area (fp);\n-\t  gbump (fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n-\t  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-\t  goto resync;\n-\t}\n-#endif\n-    }\n-\n-#ifdef TODO\n-  _IO_unsave_markers (fp);\n-#endif\n-\n-  if (fp->_flags & _IO_NO_READS)\n-    goto dumb;\n-\n-  /* Try to seek to a block boundary, to improve kernel page management. */\n-  new_offset = offset & ~(fp->_IO_buf_end - fp->_IO_buf_base - 1);\n-  delta = offset - new_offset;\n-  if (delta > fp->_IO_buf_end - fp->_IO_buf_base)\n-    {\n-      new_offset = offset;\n-      delta = 0;\n-    }\n-  result = _IO_SYSSEEK (fp, new_offset, 0);\n-  if (result < 0)\n-    return EOF;\n-  if (delta == 0)\n-    count = 0;\n-  else\n-    {\n-      count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n-\t\t\t   (must_be_exact\n-\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n-      if (count < delta)\n-\t{\n-\t  /* We weren't allowed to read, but try to seek the remainder. */\n-\t  offset = count == EOF ? delta : delta-count;\n-\t  dir = _IO_seek_cur;\n-\t  goto dumb;\n-\t}\n-    }\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n-\t    fp->_IO_buf_base + count);\n-  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-  fp->_offset = result + count;\n-  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-  return offset;\n- dumb:\n-\n-  _IO_unsave_markers (fp);\n-  result = _IO_SYSSEEK (fp, offset, dir);\n-  if (result != EOF)\n-    {\n-      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-      fp->_offset = result;\n-      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-    }\n-  return result;\n-\n-resync:\n-  /* We need to do it since it is possible that the file offset in\n-     the kernel may be changed behind our back. It may happen when\n-     we fopen a file and then do a fork. One process may access the\n-     the file and the kernel file offset will be changed. */\n-  if (fp->_offset >= 0)\n-    _IO_SYSSEEK (fp, fp->_offset, 0);\n-\n-  return offset;\n-}\n-\n-\n-_IO_size_t\n-_IO_wfile_xsputn (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_size_t n;\n-{\n-  register const wchar_t *s = (const wchar_t *) data;\n-  _IO_size_t to_do = n;\n-  int must_flush = 0;\n-  _IO_size_t count;\n-\n-  if (n <= 0)\n-    return 0;\n-  /* This is an optimized implementation.\n-     If the amount to be written straddles a block boundary\n-     (or the filebuf is unbuffered), use sys_write directly. */\n-\n-  /* First figure out how much space is available in the buffer. */\n-  count = f->_wide_data->_IO_write_end - f->_wide_data->_IO_write_ptr;\n-  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n-    {\n-      count = f->_wide_data->_IO_buf_end - f->_wide_data->_IO_write_ptr;\n-      if (count >= n)\n-\t{\n-\t  register const wchar_t *p;\n-\t  for (p = s + n; p > s; )\n-\t    {\n-\t      if (*--p == L'\\n')\n-\t\t{\n-\t\t  count = p - s + 1;\n-\t\t  must_flush = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-  /* Then fill the buffer. */\n-  if (count > 0)\n-    {\n-      if (count > to_do)\n-\tcount = to_do;\n-      if (count > 20)\n-\t{\n-#ifdef _LIBC\n-\t  f->_wide_data->_IO_write_ptr =\n-\t    __wmempcpy (f->_wide_data->_IO_write_ptr, s, count);\n-#else\n-\t  wmemcpy (f->_wide_data->_IO_write_ptr, s, count);\n-\t  f->_wide_data->_IO_write_ptr += count;\n-#endif\n-\t  s += count;\n-\t}\n-      else\n-\t{\n-\t  register wchar_t *p = f->_wide_data->_IO_write_ptr;\n-\t  register int i = (int) count;\n-\t  while (--i >= 0)\n-\t    *p++ = *s++;\n-\t  f->_wide_data->_IO_write_ptr = p;\n-\t}\n-      to_do -= count;\n-    }\n-  if (to_do > 0)\n-    to_do -= _IO_wdefault_xsputn (f, s, to_do);\n-  if (must_flush\n-      && f->_wide_data->_IO_write_ptr != f->_wide_data->_IO_write_base)\n-    _IO_wdo_write (f, f->_wide_data->_IO_write_base,\n-\t\t   f->_wide_data->_IO_write_ptr\n-\t\t   - f->_wide_data->_IO_write_base);\n-\n-  return n - to_do;\n-}\n-\n-\n-struct _IO_jump_t _IO_wfile_jumps =\n-{\n-  JUMP_INIT_DUMMY,\n-  JUMP_INIT(finish, _IO_new_file_finish),\n-  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),\n-  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),\n-  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),\n-  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),\n-  JUMP_INIT(xsputn, _IO_wfile_xsputn),\n-  JUMP_INIT(xsgetn, _IO_file_xsgetn),\n-  JUMP_INIT(seekoff, _IO_wfile_seekoff),\n-  JUMP_INIT(seekpos, _IO_default_seekpos),\n-  JUMP_INIT(setbuf, _IO_new_file_setbuf),\n-  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),\n-  JUMP_INIT(doallocate, _IO_wfile_doallocate),\n-  JUMP_INIT(read, _IO_file_read),\n-  JUMP_INIT(write, _IO_new_file_write),\n-  JUMP_INIT(seek, _IO_file_seek),\n-  JUMP_INIT(close, _IO_file_close),\n-  JUMP_INIT(stat, _IO_file_stat),\n-  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n-  JUMP_INIT(imbue, _IO_default_imbue)\n-};\n-\n-#endif /* _GLIBCPP_USE_WCHAR_T */"}, {"sha": "748545242953f907276edd038c042ddffa4a8a94", "filename": "libstdc++-v3/libio/wgenops.c", "status": "removed", "additions": 0, "deletions": 756, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fwgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad93a347592606340d535571e43943199cc3ab8/libstdc%2B%2B-v3%2Flibio%2Fwgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fwgenops.c?ref=3ad93a347592606340d535571e43943199cc3ab8", "patch": "@@ -1,756 +0,0 @@\n-/* Copyright (C) 1993, 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n-   This file is part of the GNU IO Library.\n-   Written by Ulrich Drepper <drepper@cygnus.com>.\n-   Based on the single byte version by Per Bothner <bothner@cygnus.com>.\n-\n-   This library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU General Public License as\n-   published by the Free Software Foundation; either version 2, or (at\n-   your option) any later version.\n-\n-   This library is distributed in the hope that it will be useful, but\n-   WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this library; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n-   MA 02111-1307, USA.\n-\n-   As a special exception, if you link this library with files\n-   compiled with a GNU compiler to produce an executable, this does\n-   not cause the resulting executable to be covered by the GNU General\n-   Public License.  This exception does not however invalidate any\n-   other reasons why the executable file might be covered by the GNU\n-   General Public License.  */\n-\n-/* Generic or default I/O operations. */\n-\n-#include \"libioP.h\"\n-#ifdef _GLIBCPP_USE_WCHAR_T\n-#ifdef __STDC__\n-#include <stdlib.h>\n-#endif\n-#include <string.h>\n-#include <wchar.h>\n-\n-\n-#ifndef _LIBC\n-# define __wmemcpy(dst, src, n) wmemcpy (dst, src, n)\n-#endif\n-\n-\n-static int save_for_wbackup __P ((_IO_FILE *fp, wchar_t *end_p))\n-#ifdef _LIBC\n-     internal_function\n-#endif\n-     ;\n-\n-/* Return minimum _pos markers\n-   Assumes the current get area is the main get area. */\n-_IO_ssize_t _IO_least_wmarker __P ((_IO_FILE *fp, wchar_t *end_p));\n-\n-_IO_ssize_t\n-_IO_least_wmarker (fp, end_p)\n-     _IO_FILE *fp;\n-     wchar_t *end_p;\n-{\n-  _IO_ssize_t least_so_far = end_p - fp->_wide_data->_IO_read_base;\n-  struct _IO_marker *mark;\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    if (mark->_pos < least_so_far)\n-      least_so_far = mark->_pos;\n-  return least_so_far;\n-}\n-\n-/* Switch current get area from backup buffer to (start of) main get area. */\n-void\n-_IO_switch_to_main_wget_area (fp)\n-     _IO_FILE *fp;\n-{\n-  wchar_t *tmp;\n-  fp->_flags &= ~_IO_IN_BACKUP;\n-  /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_wide_data->_IO_read_end;\n-  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_save_end;\n-  fp->_wide_data->_IO_save_end= tmp;\n-  /* Swap _IO_read_base and _IO_save_base. */\n-  tmp = fp->_wide_data->_IO_read_base;\n-  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_save_base;\n-  fp->_wide_data->_IO_save_base = tmp;\n-  /* Set _IO_read_ptr. */\n-  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_base;\n-}\n-\n-\n-/* Switch current get area from main get area to (end of) backup area. */\n-void\n-_IO_switch_to_wbackup_area (fp)\n-     _IO_FILE *fp;\n-{\n-  wchar_t *tmp;\n-  fp->_flags |= _IO_IN_BACKUP;\n-  /* Swap _IO_read_end and _IO_save_end. */\n-  tmp = fp->_wide_data->_IO_read_end;\n-  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_save_end;\n-  fp->_wide_data->_IO_save_end = tmp;\n-  /* Swap _IO_read_base and _IO_save_base. */\n-  tmp = fp->_wide_data->_IO_read_base;\n-  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_save_base;\n-  fp->_wide_data->_IO_save_base = tmp;\n-  /* Set _IO_read_ptr.  */\n-  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n-}\n-\n-\n-void\n-_IO_wsetb (f, b, eb, a)\n-     _IO_FILE *f;\n-     wchar_t *b;\n-     wchar_t *eb;\n-     int a;\n-{\n-  if (f->_wide_data->_IO_buf_base && !(f->_flags & _IO_USER_BUF))\n-    FREE_BUF (f->_wide_data->_IO_buf_base, _IO_wblen (f));\n-  f->_wide_data->_IO_buf_base = b;\n-  f->_wide_data->_IO_buf_end = eb;\n-  if (a)\n-    f->_flags &= ~_IO_USER_BUF;\n-  else\n-    f->_flags |= _IO_USER_BUF;\n-}\n-\n-\n-wint_t\n-_IO_wdefault_pbackfail (fp, c)\n-     _IO_FILE *fp;\n-     wint_t c;\n-{\n-  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n-      && !_IO_in_backup (fp)\n-      && (wint_t) fp->_IO_read_ptr[-1] == c)\n-    --fp->_IO_read_ptr;\n-  else\n-    {\n-      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n-      if (!_IO_in_backup (fp))\n-\t{\n-\t  /* We need to keep the invariant that the main get area\n-\t     logically follows the backup area.  */\n-\t  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n-\t      && _IO_have_wbackup (fp))\n-\t    {\n-\t      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_ptr))\n-\t\treturn WEOF;\n-\t    }\n-\t  else if (!_IO_have_wbackup (fp))\n-\t    {\n-\t      /* No backup buffer: allocate one. */\n-\t      /* Use nshort buffer, if unused? (probably not)  FIXME */\n-\t      int backup_size = 128;\n-\t      wchar_t *bbuf = (wchar_t *) malloc (backup_size\n-\t\t\t\t\t\t  * sizeof (wchar_t));\n-\t      if (bbuf == NULL)\n-\t\treturn WEOF;\n-\t      fp->_wide_data->_IO_save_base = bbuf;\n-\t      fp->_wide_data->_IO_save_end = (fp->_wide_data->_IO_save_base\n-\t\t\t\t\t      + backup_size);\n-\t      fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_save_end;\n-\t    }\n-\t  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr;\n-\t  _IO_switch_to_wbackup_area (fp);\n-\t}\n-      else if (fp->_wide_data->_IO_read_ptr <= fp->_wide_data->_IO_read_base)\n-\t{\n-\t  /* Increase size of existing backup buffer. */\n-\t  _IO_size_t new_size;\n-\t  _IO_size_t old_size = (fp->_wide_data->_IO_read_end\n-\t\t\t\t - fp->_wide_data->_IO_read_base);\n-\t  wchar_t *new_buf;\n-\t  new_size = 2 * old_size;\n-\t  new_buf = (wchar_t *) malloc (new_size * sizeof (wchar_t));\n-\t  if (new_buf == NULL)\n-\t    return WEOF;\n-\t  __wmemcpy (new_buf + (new_size - old_size),\n-\t\t     fp->_wide_data->_IO_read_base, old_size);\n-\t  free (fp->_wide_data->_IO_read_base);\n-\t  _IO_wsetg (fp, new_buf, new_buf + (new_size - old_size),\n-\t\t     new_buf + new_size);\n-\t  fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_read_ptr;\n-\t}\n-\n-      *--fp->_wide_data->_IO_read_ptr = c;\n-    }\n-  return c;\n-}\n-\n-\n-void\n-_IO_wdefault_finish (fp, dummy)\n-     _IO_FILE *fp;\n-     int dummy;\n-{\n-  struct _IO_marker *mark;\n-  if (fp->_wide_data->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n-    {\n-      FREE_BUF (fp->_wide_data->_IO_buf_base,\n-\t\t_IO_wblen (fp) * sizeof (wchar_t));\n-      fp->_wide_data->_IO_buf_base = fp->_wide_data->_IO_buf_end = NULL;\n-    }\n-\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    mark->_sbuf = NULL;\n-\n-  if (fp->_IO_save_base)\n-    {\n-      free (fp->_wide_data->_IO_save_base);\n-      fp->_IO_save_base = NULL;\n-    }\n-\n-#ifdef _IO_MTSAFE_IO\n-  _IO_lock_fini (*fp->_lock);\n-#endif\n-\n-  _IO_un_link ((struct _IO_FILE_plus *) fp);\n-}\n-\n-\n-wint_t\n-_IO_wdefault_uflow (fp)\n-     _IO_FILE *fp;\n-{\n-  wint_t wch;\n-  wch = _IO_UNDERFLOW (fp);\n-  if (wch == WEOF)\n-    return WEOF;\n-  return *fp->_wide_data->_IO_read_ptr++;\n-}\n-\n-\n-wint_t\n-__woverflow (f, wch)\n-     _IO_FILE *f;\n-     wint_t wch;\n-{\n-  if (f->_mode == 0)\n-    _IO_fwide (f, 1);\n-  return _IO_OVERFLOW (f, wch);\n-}\n-\n-\n-wint_t\n-__wuflow (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n-    return WEOF;\n-\n-  if (fp->_mode == 0)\n-    _IO_fwide (fp, 1);\n-  if (_IO_in_put_mode (fp))\n-    if (_IO_switch_to_wget_mode (fp) == EOF)\n-      return WEOF;\n-  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n-    return *fp->_wide_data->_IO_read_ptr++;\n-  if (_IO_in_backup (fp))\n-    {\n-      _IO_switch_to_main_wget_area (fp);\n-      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n-\treturn *fp->_wide_data->_IO_read_ptr++;\n-    }\n-  if (_IO_have_markers (fp))\n-    {\n-      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_end))\n-\treturn WEOF;\n-    }\n-  else if (_IO_have_wbackup (fp))\n-    _IO_free_wbackup_area (fp);\n-  return _IO_UFLOW (fp);\n-}\n-\n-\n-wint_t\n-__wunderflow (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n-    return WEOF;\n-\n-  if (fp->_mode == 0)\n-    _IO_fwide (fp, 1);\n-  if (_IO_in_put_mode (fp))\n-    if (_IO_switch_to_wget_mode (fp) == EOF)\n-      return WEOF;\n-  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n-    return *fp->_wide_data->_IO_read_ptr;\n-  if (_IO_in_backup (fp))\n-    {\n-      _IO_switch_to_main_wget_area (fp);\n-      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n-\treturn *fp->_wide_data->_IO_read_ptr;\n-    }\n-  if (_IO_have_markers (fp))\n-    {\n-      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_end))\n-\treturn WEOF;\n-    }\n-  else if (_IO_have_backup (fp))\n-    _IO_free_wbackup_area (fp);\n-  return _IO_UNDERFLOW (fp);\n-}\n-\n-\n-_IO_size_t\n-_IO_wdefault_xsputn (f, data, n)\n-     _IO_FILE *f;\n-     const void *data;\n-     _IO_size_t n;\n-{\n-  const wchar_t *s = (const wchar_t *) data;\n-  _IO_size_t more = n;\n-  if (more <= 0)\n-    return 0;\n-  for (;;)\n-    {\n-      /* Space available. */\n-      _IO_ssize_t count = (f->_wide_data->_IO_write_end\n-\t\t\t   - f->_wide_data->_IO_write_ptr);\n-      if (count > 0)\n-\t{\n-\t  if ((_IO_size_t) count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-#ifdef _LIBC\n-\t      f->_wide_data->_IO_write_ptr =\n-\t\t__wmempcpy (f->_wide_data->_IO_write_ptr, s, count);\n-#else\n-\t      memcpy (f->_wide_data->_IO_write_ptr, s, count);\n-\t      f->_wide_data->_IO_write_ptr += count;\n-#endif\n-\t      s += count;\n-            }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      wchar_t *p = f->_wide_data->_IO_write_ptr;\n-\t      _IO_ssize_t i;\n-\t      for (i = count; --i >= 0; )\n-\t\t*p++ = *s++;\n-\t      f->_wide_data->_IO_write_ptr = p;\n-            }\n-\t  more -= count;\n-        }\n-      if (more == 0 || __woverflow (f, *s++) == WEOF)\n-\tbreak;\n-      more--;\n-    }\n-  return n - more;\n-}\n-\n-\n-_IO_size_t\n-_IO_wdefault_xsgetn (fp, data, n)\n-     _IO_FILE *fp;\n-     void *data;\n-     _IO_size_t n;\n-{\n-  _IO_size_t more = n;\n-  wchar_t *s = (wchar_t*) data;\n-  for (;;)\n-    {\n-      /* Data available. */\n-      _IO_ssize_t count = (fp->_wide_data->_IO_read_end\n-\t\t\t   - fp->_wide_data->_IO_read_ptr);\n-      if (count > 0)\n-\t{\n-\t  if ((_IO_size_t) count > more)\n-\t    count = more;\n-\t  if (count > 20)\n-\t    {\n-#ifdef _LIBC\n-\t      s = __wmempcpy (s, fp->_wide_data->_IO_read_ptr, count);\n-#else\n-\t      memcpy (s, fp->_wide_data->_IO_read_ptr, count);\n-\t      s += count;\n-#endif\n-\t      fp->_wide_data->_IO_read_ptr += count;\n-\t    }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n-\t    {\n-\t      wchar_t *p = fp->_wide_data->_IO_read_ptr;\n-\t      int i = (int) count;\n-\t      while (--i >= 0)\n-\t\t*s++ = *p++;\n-\t      fp->_wide_data->_IO_read_ptr = p;\n-            }\n-            more -= count;\n-        }\n-      if (more == 0 || __wunderflow (fp) == WEOF)\n-\tbreak;\n-    }\n-  return n - more;\n-}\n-\n-\n-void\n-_IO_wdoallocbuf (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_wide_data->_IO_buf_base)\n-    return;\n-  if (!(fp->_flags & _IO_UNBUFFERED))\n-    if (_IO_DOALLOCATE (fp) != WEOF)\n-      return;\n-  _IO_wsetb (fp, fp->_wide_data->_shortbuf, fp->_wide_data->_shortbuf + 1, 0);\n-}\n-\n-\n-_IO_FILE *\n-_IO_wdefault_setbuf (fp, p, len)\n-     _IO_FILE *fp;\n-     wchar_t *p;\n-     _IO_ssize_t len;\n-{\n-  if (_IO_SYNC (fp) == EOF)\n-    return NULL;\n-  if (p == NULL || len == 0)\n-    {\n-      fp->_flags |= _IO_UNBUFFERED;\n-      _IO_wsetb (fp, fp->_wide_data->_shortbuf, fp->_wide_data->_shortbuf + 1,\n-\t\t 0);\n-    }\n-  else\n-    {\n-      fp->_flags &= ~_IO_UNBUFFERED;\n-      _IO_wsetb (fp, p, p + len, 0);\n-    }\n-  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n-    = fp->_wide_data->_IO_write_end = 0;\n-  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr\n-    = fp->_wide_data->_IO_read_end = 0;\n-  return fp;\n-}\n-\n-\n-int\n-_IO_wdefault_doallocate (fp)\n-     _IO_FILE *fp;\n-{\n-  wchar_t *buf;\n-\n-  ALLOC_WBUF (buf, _IO_BUFSIZ, EOF);\n-  _IO_wsetb (fp, buf, buf + _IO_BUFSIZ, 1);\n-  return 1;\n-}\n-\n-\n-int\n-_IO_switch_to_wget_mode (fp)\n-     _IO_FILE *fp;\n-{\n-  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n-    if (_IO_OVERFLOW (fp, WEOF) == WEOF)\n-      return EOF;\n-  if (_IO_in_backup (fp))\n-    fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_backup_base;\n-  else\n-    {\n-      fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_buf_base;\n-      if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_read_end)\n-\tfp->_wide_data->_IO_read_end = fp->_wide_data->_IO_write_ptr;\n-    }\n-  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_write_ptr;\n-\n-  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n-    = fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_read_ptr;\n-\n-  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n-  return 0;\n-}\n-\n-void\n-_IO_free_wbackup_area (fp)\n-     _IO_FILE *fp;\n-{\n-  if (_IO_in_backup (fp))\n-    _IO_switch_to_main_wget_area (fp);  /* Just in case. */\n-  free (fp->_wide_data->_IO_save_base);\n-  fp->_wide_data->_IO_save_base = NULL;\n-  fp->_wide_data->_IO_save_end = NULL;\n-  fp->_wide_data->_IO_backup_base = NULL;\n-}\n-\n-#if 0\n-int\n-_IO_switch_to_wput_mode (fp)\n-     _IO_FILE *fp;\n-{\n-  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_read_ptr;\n-  fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_read_ptr;\n-  /* Following is wrong if line- or un-buffered? */\n-  fp->_wide_data->_IO_write_end = (fp->_flags & _IO_IN_BACKUP\n-\t\t\t\t   ? fp->_wide_data->_IO_read_end\n-\t\t\t\t   : fp->_wide_data->_IO_buf_end);\n-\n-  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n-  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_end;\n-\n-  fp->_flags |= _IO_CURRENTLY_PUTTING;\n-  return 0;\n-}\n-#endif\n-\n-\n-static int\n-#ifdef _LIBC\n-internal_function\n-#endif\n-save_for_wbackup (fp, end_p)\n-     _IO_FILE *fp;\n-     wchar_t *end_p;\n-{\n-  /* Append [_IO_read_base..end_p] to backup area. */\n-  _IO_ssize_t least_mark = _IO_least_wmarker (fp, end_p);\n-  /* needed_size is how much space we need in the backup area. */\n-  _IO_size_t needed_size = ((end_p - fp->_wide_data->_IO_read_base)\n-\t\t\t    - least_mark);\n-  /* FIXME: Dubious arithmetic if pointers are NULL */\n-  _IO_size_t current_Bsize = (fp->_wide_data->_IO_save_end\n-\t\t\t      - fp->_wide_data->_IO_save_base);\n-  _IO_size_t avail; /* Extra space available for future expansion. */\n-  _IO_ssize_t delta;\n-  struct _IO_marker *mark;\n-  if (needed_size > current_Bsize)\n-    {\n-      wchar_t *new_buffer;\n-      avail = 100;\n-      new_buffer = (wchar_t *) malloc ((avail + needed_size)\n-\t\t\t\t       * sizeof (wchar_t));\n-      if (new_buffer == NULL)\n-\treturn EOF;\t\t/* FIXME */\n-      if (least_mark < 0)\n-\t{\n-#ifdef _LIBC\n-\t  __wmempcpy (__wmempcpy (new_buffer + avail,\n-\t\t\t\t  fp->_wide_data->_IO_save_end + least_mark,\n-\t\t\t\t  -least_mark),\n-\t\t      fp->_wide_data->_IO_read_base,\n-\t\t      end_p - fp->_wide_data->_IO_read_base);\n-#else\n-\t  memcpy (new_buffer + avail,\n-\t\t  fp->_wide_data->_IO_save_end + least_mark,\n-\t\t  -least_mark * sizeof (wchar_t));\n-\t  memcpy (new_buffer + avail - least_mark,\n-\t\t  fp->_wide_data->_IO_read_base,\n-\t\t  (end_p - fp->_wide_data->_IO_read_base) * sizeof (wchar_t));\n-#endif\n-\t}\n-      else\n-\t{\n-#ifdef _LIBC\n-\t  __wmemcpy (new_buffer + avail,\n-\t\t     fp->_wide_data->_IO_read_base + least_mark,\n-\t\t     needed_size);\n-#else\n-\t  memcpy (new_buffer + avail,\n-\t\t  fp->_wide_data->_IO_read_base + least_mark,\n-\t\t  needed_size * sizeof (wchar_t));\n-#endif\n-\t}\n-      if (fp->_wide_data->_IO_save_base)\n-\tfree (fp->_wide_data->_IO_save_base);\n-      fp->_wide_data->_IO_save_base = new_buffer;\n-      fp->_wide_data->_IO_save_end = new_buffer + avail + needed_size;\n-    }\n-  else\n-    {\n-      avail = current_Bsize - needed_size;\n-      if (least_mark < 0)\n-\t{\n-#ifdef _LIBC\n-\t  __wmemmove (fp->_wide_data->_IO_save_base + avail,\n-\t\t      fp->_wide_data->_IO_save_end + least_mark,\n-\t\t      -least_mark);\n-\t  __wmemcpy (fp->_wide_data->_IO_save_base + avail - least_mark,\n-\t\t     fp->_wide_data->_IO_read_base,\n-\t\t     end_p - fp->_wide_data->_IO_read_base);\n-#else\n-\t  memmove (fp->_wide_data->_IO_save_base + avail,\n-\t\t   fp->_wide_data->_IO_save_end + least_mark,\n-\t\t   -least_mark * sizeof (wchar_t));\n-\t  memcpy (fp->_wide_data->_IO_save_base + avail - least_mark,\n-\t\t  fp->_wide_data->_IO_read_base,\n-\t\t  (end_p - fp->_wide_data->_IO_read_base) * sizeof (wchar_t));\n-#endif\n-\t}\n-      else if (needed_size > 0)\n-#ifdef _LIBC\n-\t__wmemcpy (fp->_wide_data->_IO_save_base + avail,\n-\t\t   fp->_wide_data->_IO_read_base + least_mark,\n-\t\t   needed_size);\n-#else\n-\tmemcpy (fp->_wide_data->_IO_save_base + avail,\n-\t\tfp->_wide_data->_IO_read_base + least_mark,\n-\t\tneeded_size * sizeof (wchar_t));\n-#endif\n-    }\n-  fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_save_base + avail;\n-  /* Adjust all the streammarkers. */\n-  delta = end_p - fp->_wide_data->_IO_read_base;\n-  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n-    mark->_pos -= delta;\n-  return 0;\n-}\n-\n-wint_t\n-_IO_sputbackwc (fp, c)\n-     _IO_FILE *fp;\n-     wint_t c;\n-{\n-  wint_t result;\n-\n-  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n-      && (wchar_t)fp->_wide_data->_IO_read_ptr[-1] == (wchar_t) c)\n-    {\n-      fp->_wide_data->_IO_read_ptr--;\n-      result = c;\n-    }\n-  else\n-    result = _IO_PBACKFAIL (fp, c);\n-\n-  if (result != EOF)\n-    fp->_flags &= ~_IO_EOF_SEEN;\n-\n-  return result;\n-}\n-\n-wint_t\n-_IO_sungetwc (fp)\n-     _IO_FILE *fp;\n-{\n-  int result;\n-\n-  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base)\n-    {\n-      fp->_wide_data->_IO_read_ptr--;\n-      result = *fp->_wide_data->_IO_read_ptr;\n-    }\n-  else\n-    result = _IO_PBACKFAIL (fp, EOF);\n-\n-  if (result != WEOF)\n-    fp->_flags &= ~_IO_EOF_SEEN;\n-\n-  return result;\n-}\n-\n-\n-unsigned\n-_IO_adjust_wcolumn (start, line, count)\n-     unsigned start;\n-     const wchar_t *line;\n-     int count;\n-{\n-  const wchar_t *ptr = line + count;\n-  while (ptr > line)\n-    if (*--ptr == L'\\n')\n-      return line + count - ptr - 1;\n-  return start + count;\n-}\n-\n-void\n-_IO_init_wmarker (marker, fp)\n-     struct _IO_marker *marker;\n-     _IO_FILE *fp;\n-{\n-  marker->_sbuf = fp;\n-  if (_IO_in_put_mode (fp))\n-    _IO_switch_to_wget_mode (fp);\n-  if (_IO_in_backup (fp))\n-    marker->_pos = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n-  else\n-    marker->_pos = (fp->_wide_data->_IO_read_ptr\n-\t\t    - fp->_wide_data->_IO_read_base);\n-\n-  /* Should perhaps sort the chain? */\n-  marker->_next = fp->_markers;\n-  fp->_markers = marker;\n-}\n-\n-#define BAD_DELTA EOF\n-\n-/* Return difference between MARK and current position of MARK's stream. */\n-int\n-_IO_wmarker_delta (mark)\n-     struct _IO_marker *mark;\n-{\n-  int cur_pos;\n-  if (mark->_sbuf == NULL)\n-    return BAD_DELTA;\n-  if (_IO_in_backup (mark->_sbuf))\n-    cur_pos = (mark->_sbuf->_wide_data->_IO_read_ptr\n-\t       - mark->_sbuf->_wide_data->_IO_read_end);\n-  else\n-    cur_pos = (mark->_sbuf->_wide_data->_IO_read_ptr\n-\t       - mark->_sbuf->_wide_data->_IO_read_base);\n-  return mark->_pos - cur_pos;\n-}\n-\n-int\n-_IO_seekwmark (fp, mark, delta)\n-     _IO_FILE *fp;\n-     struct _IO_marker *mark;\n-     int delta;\n-{\n-  if (mark->_sbuf != fp)\n-    return EOF;\n- if (mark->_pos >= 0)\n-    {\n-      if (_IO_in_backup (fp))\n-\t_IO_switch_to_main_wget_area (fp);\n-      fp->_wide_data->_IO_read_ptr = (fp->_wide_data->_IO_read_base\n-\t\t\t\t      + mark->_pos);\n-    }\n-  else\n-    {\n-      if (!_IO_in_backup (fp))\n-\t_IO_switch_to_wbackup_area (fp);\n-      fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end + mark->_pos;\n-    }\n-  return 0;\n-}\n-\n-void\n-_IO_unsave_wmarkers (fp)\n-     _IO_FILE *fp;\n-{\n-  struct _IO_marker *mark = fp->_markers;\n-  if (mark)\n-    {\n-#ifdef TODO\n-      streampos offset = seekoff (0, ios::cur, ios::in);\n-      if (offset != EOF)\n-\t{\n-\t  offset += eGptr () - Gbase ();\n-\t  for ( ; mark != NULL; mark = mark->_next)\n-\t    mark->set_streampos (mark->_pos + offset);\n-\t}\n-    else\n-      {\n-\tfor ( ; mark != NULL; mark = mark->_next)\n-\t  mark->set_streampos (EOF);\n-      }\n-#endif\n-      fp->_markers = 0;\n-    }\n-\n-  if (_IO_have_backup (fp))\n-    _IO_free_wbackup_area (fp);\n-}\n-\n-#endif /* _GLIBCPP_USE_WCHAR_T */"}, {"sha": "b5b32d65908c4c36286204f57997a41e5783a86f", "filename": "libstdc++-v3/libmath/Makefile.in", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibmath%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n # Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n@@ -70,7 +70,6 @@ AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -97,7 +96,6 @@ GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n LIBMATHOBJS = @LIBMATHOBJS@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n@@ -127,6 +125,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_builddir = @glibcpp_builddir@\n@@ -138,7 +137,6 @@ glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n gxx_include_dir = @gxx_include_dir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n "}, {"sha": "6e6729581c8da3183bd8eea8a9802472d6db2574", "filename": "libstdc++-v3/libsupc++/Makefile.in", "status": "modified", "additions": 56, "deletions": 18, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -1,4 +1,4 @@\n-# Makefile.in generated automatically by automake 1.4-p5 from Makefile.am\n+# Makefile.in generated automatically by automake 1.4-p6 from Makefile.am\n \n # Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n@@ -69,7 +69,6 @@ ATOMICITY_INC_SRCDIR = @ATOMICITY_INC_SRCDIR@\n AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -94,7 +93,6 @@ EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@\n GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n LIBMATHOBJS = @LIBMATHOBJS@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_PICFLAGS = @LIBSUPCXX_PICFLAGS@\n@@ -124,6 +122,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_builddir = @glibcpp_builddir@\n@@ -135,7 +134,6 @@ glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n gxx_include_dir = @gxx_include_dir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n \n@@ -164,11 +162,13 @@ OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@\n # These bits are all figured out from configure. Look in acinclude.m4\n # or configure.in to see how they are set. See GLIBCPP_EXPORT_FLAGS\n # NB: DEBUGFLAGS have to be at the end so that -O2 can be overridden.\n-CONFIG_CXXFLAGS =  \t@SECTION_FLAGS@ @EXTRA_CXX_FLAGS@\n+CONFIG_CXXFLAGS = \\\n+\t@SECTION_FLAGS@ @EXTRA_CXX_FLAGS@\n \n \n # Warning flags to use.\n-WARN_CXXFLAGS =  \t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n+WARN_CXXFLAGS = \\\n+\t@WARN_FLAGS@ $(WERROR) -fdiagnostics-show-location=once\n \n \n LIBSUPCXX_CXXFLAGS = @LIBSUPCXX_PICFLAGS@\n@@ -178,13 +178,41 @@ GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n GCC_INCLUDES = -I$(toplevel_srcdir)/gcc -I$(toplevel_srcdir)/include\n \n-INCLUDES =  \t$(GCC_INCLUDES) $(GLIBCPP_INCLUDES) $(LIBSUPCXX_INCLUDES)\n-\n-\n-headers =  \texception new typeinfo cxxabi.h exception_defines.h \n-\n-\n-sources =  \tdel_op.cc \tdel_opnt.cc \tdel_opv.cc \tdel_opvnt.cc \teh_alloc.cc \teh_aux_runtime.cc \teh_catch.cc \teh_exception.cc \teh_globals.cc \teh_personality.cc \teh_term_handler.cc \teh_terminate.cc \teh_throw.cc \teh_type.cc \teh_unex_handler.cc \tguard.cc \tnew_handler.cc \tnew_op.cc \tnew_opnt.cc \tnew_opv.cc \tnew_opvnt.cc \tpure.cc \ttinfo.cc \ttinfo2.cc \tvec.cc \tvterminate.cc\n+INCLUDES = \\\n+\t$(GCC_INCLUDES) $(GLIBCPP_INCLUDES) $(LIBSUPCXX_INCLUDES)\n+\n+\n+headers = \\\n+\texception new typeinfo cxxabi.h exception_defines.h \n+\n+\n+sources = \\\n+\tdel_op.cc \\\n+\tdel_opnt.cc \\\n+\tdel_opv.cc \\\n+\tdel_opvnt.cc \\\n+\teh_alloc.cc \\\n+\teh_aux_runtime.cc \\\n+\teh_catch.cc \\\n+\teh_exception.cc \\\n+\teh_globals.cc \\\n+\teh_personality.cc \\\n+\teh_term_handler.cc \\\n+\teh_terminate.cc \\\n+\teh_throw.cc \\\n+\teh_type.cc \\\n+\teh_unex_handler.cc \\\n+\tguard.cc \\\n+\tnew_handler.cc \\\n+\tnew_op.cc \\\n+\tnew_opnt.cc \\\n+\tnew_opv.cc \\\n+\tnew_opvnt.cc \\\n+\tpure.cc \\\n+\ttinfo.cc \\\n+\ttinfo2.cc \\\n+\tvec.cc \\\n+\tvterminate.cc\n \n \n libsupc___la_SOURCES = $(sources) \n@@ -198,10 +226,16 @@ glibcppinstall_HEADERS = $(headers)\n # set this option because CONFIG_CXXFLAGS has to be after\n # OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden\n # as the occasion call for it. \n-AM_CXXFLAGS =  \t-fno-implicit-templates \t$(LIBSUPCXX_CXXFLAGS) \t$(WARN_CXXFLAGS) \t$(OPTIMIZE_CXXFLAGS) \t$(CONFIG_CXXFLAGS) \n+AM_CXXFLAGS = \\\n+\t-fno-implicit-templates \\\n+\t$(LIBSUPCXX_CXXFLAGS) \\\n+\t$(WARN_CXXFLAGS) \\\n+\t$(OPTIMIZE_CXXFLAGS) \\\n+\t$(CONFIG_CXXFLAGS) \n \n \n-AM_MAKEFLAGS =  \t\"gxx_include_dir=$(gxx_include_dir)\"\n+AM_MAKEFLAGS = \\\n+\t\"gxx_include_dir=$(gxx_include_dir)\"\n \n \n # libstdc++ libtool notes\n@@ -225,7 +259,9 @@ AM_MAKEFLAGS =  \t\"gxx_include_dir=$(gxx_include_dir)\"\n #\n # We have to put --tag disable-shared after --tag CXX lest things\n # CXX undo the affect of disable-shared.\n-LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared                --mode=compile $(CXX) $(INCLUDES) \t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n+LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared \\\n+               --mode=compile $(CXX) $(INCLUDES) \\\n+\t       $(AM_CPPFLAGS) $(CPPFLAGS) $(CXXFLAGS) $(AM_CXXFLAGS) \n \n \n # 3) We'd have a problem when building the shared libstdc++ object if\n@@ -234,7 +270,9 @@ LTCXXCOMPILE = $(LIBTOOL) --tag CXX --tag disable-shared                --mode=c\n # course is problematic at this point.  So, we get the top-level\n # directory to configure libstdc++-v3 to use gcc as the C++\n # compilation driver.\n-CXXLINK = $(LIBTOOL) --tag CXX --tag disable-shared           --mode=link $(CXX)           @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = $(LIBTOOL) --tag CXX --tag disable-shared \\\n+          --mode=link $(CXX) \\\n+          @OPT_LDFLAGS@ @SECTION_LDFLAGS@ $(AM_CXXFLAGS) $(LDFLAGS) -o $@\n \n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = \n@@ -271,7 +309,7 @@ DIST_COMMON =  Makefile.am Makefile.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n SOURCES = $(libsupc__convenience_la_SOURCES) $(libsupc___la_SOURCES)\n OBJECTS = $(libsupc__convenience_la_OBJECTS) $(libsupc___la_OBJECTS)"}, {"sha": "8a630518ed68e1b817b9b5a69af76c1098fc6d99", "filename": "libstdc++-v3/po/Makefile.in", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fpo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpo%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -70,7 +70,6 @@ AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -97,7 +96,6 @@ GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n LIBMATHOBJS = @LIBMATHOBJS@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n@@ -128,6 +126,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_builddir = @glibcpp_builddir@\n@@ -138,7 +137,6 @@ glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n gxx_include_dir = @gxx_include_dir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n \n@@ -159,7 +157,9 @@ LOCALE_OUT = @glibcpp_MOFILES@\n MSGFMT = msgfmt\n \n # Necessary files.\n-DISTFILES =  \tMakefile.am Makefile.in string_literals.cc POTFILES.in $(PACKAGE).pot \t$(LOCALE_IN) \n+DISTFILES = \\\n+\tMakefile.am Makefile.in string_literals.cc POTFILES.in $(PACKAGE).pot \\\n+\t$(LOCALE_IN) \n \n \n # Specify what gets cleaned up on a 'make clean'\n@@ -174,15 +174,15 @@ LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n DIST_COMMON =  Makefile.am Makefile.in\n \n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n all: all-redirect\n .SUFFIXES:\n .SUFFIXES: .mo .po\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n-\tcd $(top_srcdir) && $(AUTOMAKE) --gnu po/Makefile\n+\tcd $(top_srcdir) && $(AUTOMAKE) --cygnus po/Makefile\n \n-Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status $(BUILT_SOURCES)\n+Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status\n \tcd $(top_builddir) \\\n \t  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status\n \n@@ -195,13 +195,8 @@ distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)\n subdir = po\n \n distdir: $(DISTFILES)\n-\there=`cd $(top_builddir) && pwd`; \\\n-\ttop_distdir=`cd $(top_distdir) && pwd`; \\\n-\tdistdir=`cd $(distdir) && pwd`; \\\n-\tcd $(top_srcdir) \\\n-\t  && $(AUTOMAKE) --include-deps --build-dir=$$here --srcdir-name=$(top_srcdir) --output-dir=$$top_distdir --gnu po/Makefile\n \t@for file in $(DISTFILES); do \\\n-\t  d=$(srcdir); \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n \t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n@@ -214,10 +209,12 @@ info-am:\n info: info-am\n dvi-am:\n dvi: dvi-am\n-check-am: all-am\n+check-am:\n check: check-am\n installcheck-am:\n installcheck: installcheck-am\n+install-info-am: \n+install-info: install-info-am\n install-exec-am:\n install-exec: install-exec-am\n \n@@ -266,11 +263,12 @@ maintainer-clean-am:  maintainer-clean-generic distclean-am\n maintainer-clean: maintainer-clean-am\n \n .PHONY: tags distdir info-am info dvi-am dvi check check-am \\\n-installcheck-am installcheck install-exec-am install-exec \\\n-install-data-local install-data-am install-data install-am install \\\n-uninstall-am uninstall all-local all-redirect all-am all installdirs \\\n-mostlyclean-generic distclean-generic clean-generic \\\n-maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n+installcheck-am installcheck install-info-am install-info \\\n+install-exec-am install-exec install-data-local install-data-am \\\n+install-data install-am install uninstall-am uninstall all-local \\\n+all-redirect all-am all installdirs mostlyclean-generic \\\n+distclean-generic clean-generic maintainer-clean-generic clean \\\n+mostlyclean distclean maintainer-clean\n \n \n .po.mo:"}, {"sha": "a3aabfcde2c5328fbe4b0828a7b3e1227ab4b6bf", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -62,13 +62,12 @@ WARN_CXXFLAGS = \\\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n INCLUDES = \\\n \t-nostdinc++ \\\n \t$(GLIBCPP_INCLUDES) \\\n-\t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \\\n+\t$(LIBSUPCXX_INCLUDES) $(LIBMATH_INCLUDES) \\\n \t$(TOPLEVEL_INCLUDES)\n \n # Source files linked in via configuration/make substitution for a\n@@ -151,7 +150,7 @@ VPATH = $(top_srcdir)/src:$(top_srcdir)\n libstdc___la_SOURCES = $(sources)\n \n libstdc___la_LIBADD = \\\n-\t$(top_builddir)/libmath/libmath.la @libio_la@ \\\n+\t$(top_builddir)/libmath/libmath.la \\\n \t$(top_builddir)/libsupc++/libsupc++convenience.la\n \n libstdc___la_DEPENDENCIES = libstdc++-symbol.ver $(libstdc___la_LIBADD)"}, {"sha": "370f7308a4efcad3013dcf525ec3080a0a30c470", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -69,7 +69,6 @@ AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -131,7 +130,6 @@ glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n gxx_include_dir = @gxx_include_dir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n \n@@ -169,13 +167,12 @@ WARN_CXXFLAGS = \\\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@\n \n INCLUDES = \\\n \t-nostdinc++ \\\n \t$(GLIBCPP_INCLUDES) \\\n-\t$(LIBSUPCXX_INCLUDES) $(LIBIO_INCLUDES) $(LIBMATH_INCLUDES) \\\n+\t$(LIBSUPCXX_INCLUDES) $(LIBMATH_INCLUDES) \\\n \t$(TOPLEVEL_INCLUDES)\n \n \n@@ -235,7 +232,7 @@ VPATH = $(top_srcdir)/src:$(top_srcdir)\n libstdc___la_SOURCES = $(sources)\n \n libstdc___la_LIBADD = \\\n-\t$(top_builddir)/libmath/libmath.la @libio_la@ \\\n+\t$(top_builddir)/libmath/libmath.la \\\n \t$(top_builddir)/libsupc++/libsupc++convenience.la\n \n "}, {"sha": "3c6cd842bbdd0887d504f2808fe957743238249c", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58ac1d7f0ed6264255737ccba13f32d70fb79d22/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=58ac1d7f0ed6264255737ccba13f32d70fb79d22", "patch": "@@ -70,7 +70,6 @@ AWK = @AWK@\n BASIC_FILE_CC = @BASIC_FILE_CC@\n BASIC_FILE_H = @BASIC_FILE_H@\n CC = @CC@\n-CCODECVT_C = @CCODECVT_C@\n CCODECVT_CC = @CCODECVT_CC@\n CCODECVT_H = @CCODECVT_H@\n CCOLLATE_CC = @CCOLLATE_CC@\n@@ -96,7 +95,6 @@ GCJ = @GCJ@\n GCJFLAGS = @GCJFLAGS@\n GLIBCPP_INCLUDES = @GLIBCPP_INCLUDES@\n GLIBCPP_IS_CROSS_COMPILING = @GLIBCPP_IS_CROSS_COMPILING@\n-LIBIO_INCLUDES = @LIBIO_INCLUDES@\n LIBMATHOBJS = @LIBMATHOBJS@\n LIBMATH_INCLUDES = @LIBMATH_INCLUDES@\n LIBSUPCXX_INCLUDES = @LIBSUPCXX_INCLUDES@\n@@ -128,6 +126,7 @@ enable_shared = @enable_shared@\n enable_static = @enable_static@\n glibcpp_CXX = @glibcpp_CXX@\n glibcpp_MOFILES = @glibcpp_MOFILES@\n+glibcpp_PCHFLAGS = @glibcpp_PCHFLAGS@\n glibcpp_POFILES = @glibcpp_POFILES@\n glibcpp_basedir = @glibcpp_basedir@\n glibcpp_builddir = @glibcpp_builddir@\n@@ -139,39 +138,48 @@ glibcpp_toolexecdir = @glibcpp_toolexecdir@\n glibcpp_toolexeclibdir = @glibcpp_toolexeclibdir@\n gxx_include_dir = @gxx_include_dir@\n ifGNUmake = @ifGNUmake@\n-libio_la = @libio_la@\n libtool_VERSION = @libtool_VERSION@\n toplevel_srcdir = @toplevel_srcdir@\n \n AUTOMAKE_OPTIONS = cygnus dejagnu\n \n DEJATOOL = libstdc++-v3\n \n-EXPECT = `if [ -f @glibcpp_builddir@/../../expect/expect ] ; then             echo @glibcpp_builddir@/../../expect/expect ;           else echo expect ; fi`\n+EXPECT = `if [ -f @glibcpp_builddir@/../../expect/expect ] ; then \\\n+            echo @glibcpp_builddir@/../../expect/expect ; \\\n+          else echo expect ; fi`\n \n \n-RUNTEST = `if [ -f @glibcpp_srcdir@/../dejagnu/runtest ] ; then \t       echo @glibcpp_srcdir@/../dejagnu/runtest ; \t    else echo runtest; fi`\n+RUNTEST = `if [ -f @glibcpp_srcdir@/../dejagnu/runtest ] ; then \\\n+\t       echo @glibcpp_srcdir@/../dejagnu/runtest ; \\\n+\t    else echo runtest; fi`\n \n \n AM_RUNTESTFLAGS = \n RUNTESTFLAGS = \n \n CXX_build = @glibcpp_CXX@ \n CXX = `echo \"$(CXX_build)\" | sed 's,gcc/xgcc ,gcc/g++ ,'`\n-CXXLINK =  \tLD_RUN_PATH=$${LD_RUN_PATH:+$$LD_RUN_PATH:}${glibcpp_builddir}/src/.libs \t$(LIBTOOL) --tag=CXX --mode=link $(CXX) \t$(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@\n+CXXLINK = \\\n+\tLD_RUN_PATH=$${LD_RUN_PATH:+$$LD_RUN_PATH:}${glibcpp_builddir}/src/.libs\\\n+\t$(LIBTOOL) --tag=CXX --mode=link $(CXX) \\\n+\t$(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@\n \n \n-INCLUDES =  \t-nostdinc++ \t@GLIBCPP_INCLUDES@ @LIBSUPCXX_INCLUDES@ @TOPLEVEL_INCLUDES@ \n+INCLUDES = \\\n+\t-nostdinc++ \\\n+\t@GLIBCPP_INCLUDES@ @LIBSUPCXX_INCLUDES@ @TOPLEVEL_INCLUDES@ \n \n \n noinst_LIBRARIES = libv3test.a\n libv3test_a_SOURCES = testsuite_hooks.cc testsuite_allocator.cc\n-@GLIBCPP_BUILD_ABI_CHECK_TRUE@noinst_PROGRAMS = abi_check\n+@GLIBCPP_BUILD_ABI_CHECK_TRUE@noinst_PROGRAMS = @GLIBCPP_BUILD_ABI_CHECK_TRUE@abi_check\n @GLIBCPP_BUILD_ABI_CHECK_FALSE@noinst_PROGRAMS = \n abi_check_SOURCES = abi_check.cc\n \n # By adding these files here, automake will remove them for 'make clean'\n-CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \t     testsuite_* site.exp abi_check \n+CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n+\t     testsuite_* site.exp abi_check \n \n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n CONFIG_HEADER = ../config.h\n@@ -197,12 +205,12 @@ CXXFLAGS = @CXXFLAGS@\n CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n CXXLD = $(CXX)\n-DIST_COMMON =  README Makefile.am Makefile.in\n+DIST_COMMON =  Makefile.am Makefile.in\n \n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n SOURCES = $(libv3test_a_SOURCES) $(abi_check_SOURCES)\n OBJECTS = $(libv3test_a_OBJECTS) $(abi_check_OBJECTS)\n@@ -313,7 +321,7 @@ TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)\n \t  awk '    { files[$$0] = 1; } \\\n \t       END { for (i in files) print i; }'`; \\\n \ttest -z \"$(ETAGS_ARGS)$$unique$(LISP)$$tags\" \\\n-\t  || (cd $(srcdir) && etags -o $$here/TAGS $(ETAGS_ARGS) $$tags  $$unique $(LISP))\n+\t  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)\n \n mostlyclean-tags:\n \n@@ -370,7 +378,7 @@ site.exp: Makefile\n \t@echo 'set build_alias $(build_alias)' >> $@-t\n \t@echo 'set build_triplet $(build_triplet)' >> $@-t\n \t@echo '## All variables above are generated by configure. Do Not Edit ##' >> $@-t\n-\t@test ! -f $(srcdir)/site.exp || sed '1,/^## All variables above are.*##/ d' $(srcdir)/site.exp >> $@-t\n+\t@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> $@-t\n \t@test ! -f site.exp || mv site.exp site.bak\n \t@mv $@-t site.exp\n info-am:"}]}