{"sha": "8dd5e93af60784985b22b8af909469d57ee6abdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRkNWU5M2FmNjA3ODQ5ODViMjJiOGFmOTA5NDY5ZDU3ZWU2YWJkYg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2008-11-01T11:29:06Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-01T11:29:06Z"}, "message": "shared_ptr.h: Update comparisons to match WP.\n\n2008-11-01  Jonathan Wakely  <jwakely.gcc@gmail.com>\n\n        * include/bits/shared_ptr.h: Update comparisons to match WP.\n        (_Sp_counted_ptr): Make copy and assignment members deleted.\n        (_Sp_counted_deleter): Remove private copy and assignment members.\n        (__shared_count::_M_less,__weak_count::_M_less,operator<): Replace\n        friend operator< with overloaded _M_less member functions to allow\n        comparison with either shared_count or weak_count.\n        (__shared_ptr::_M_less,__weak_ptr::_M_less): Replace with...\n        (__shared_ptr::owner_before,__weak_ptr::owner_before): New overloads\n        for ownership-based ordering.\n        (operator<(__shared_ptr,__shared_ptr)): Compare stored pointers,\n        make non-friend.\n        (operator==(__shared_ptr,__shared_ptr)): Make non-friend.\n        (operator!=(__shared_ptr,__shared_ptr)): Likewise.\n        (less<__shared_ptr<>>,less<shared_ptr<>>,_Sp_less): Explicitly call\n        pointer specialization.\n        (__weak_ptr::operator<,weak_ptr::operator<=,weak_ptr::operator>,\n        weak_ptr::operator>=): Remove operator< and delete all comparisons.\n        (_Sp_owner_less,owner_less): Predicate for ownership-based ordering.\n        (operator<(shared_ptr,shared_ptr): Overload for derived shared_ptr.\n        (operator==(shared_ptr,shared_ptr): Likewise.\n        (operator!=(shared_ptr,shared_ptr): Likewise.\n        (swap(shared_ptr,shared_ptr)): Fix parameter types.\n        (swap(weak_ptr,weak_ptr)): Add missing overload.\n        * testsuite/20_util/owner_less/cmp.cc: New.\n        * testsuite/20_util/shared_ptr/comparison/cmp.cc: Test other ops.\n        * testsuite/20_util/shared_ptr/comparison/less.cc: New.\n        * testsuite/20_util/shared_ptr/observers/owner_before.cc: New.\n        * testsuite/20_util/weak_ptr/observers/owner_before.cc: New.\n        * testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: New.\n\nFrom-SVN: r141512", "tree": {"sha": "14906af50b00e041275a9ac91a01e1c0105ad5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14906af50b00e041275a9ac91a01e1c0105ad5d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dd5e93af60784985b22b8af909469d57ee6abdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd5e93af60784985b22b8af909469d57ee6abdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd5e93af60784985b22b8af909469d57ee6abdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd5e93af60784985b22b8af909469d57ee6abdb/comments", "author": null, "committer": null, "parents": [{"sha": "1b867ae782244908713c24c26f526e65a35f6d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b867ae782244908713c24c26f526e65a35f6d12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b867ae782244908713c24c26f526e65a35f6d12"}], "stats": {"total": 793, "additions": 693, "deletions": 100}, "files": [{"sha": "06fd7a45de5722bbb5250335d037708ebdfd5b63", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -1,3 +1,35 @@\n+2008-11-01  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+        * include/bits/shared_ptr.h: Update comparisons to match WP.\n+        (_Sp_counted_ptr): Make copy and assignment members deleted.\n+        (_Sp_counted_deleter): Remove private copy and assignment members.\n+        (__shared_count::_M_less,__weak_count::_M_less,operator<): Replace\n+        friend operator< with overloaded _M_less member functions to allow\n+        comparison with either shared_count or weak_count.\n+        (__shared_ptr::_M_less,__weak_ptr::_M_less): Replace with...\n+        (__shared_ptr::owner_before,__weak_ptr::owner_before): New overloads\n+        for ownership-based ordering.\n+        (operator<(__shared_ptr,__shared_ptr)): Compare stored pointers,\n+        make non-friend.\n+        (operator==(__shared_ptr,__shared_ptr)): Make non-friend.\n+        (operator!=(__shared_ptr,__shared_ptr)): Likewise.\n+        (less<__shared_ptr<>>,less<shared_ptr<>>,_Sp_less): Explicitly call\n+        pointer specialization.\n+        (__weak_ptr::operator<,weak_ptr::operator<=,weak_ptr::operator>,\n+        weak_ptr::operator>=): Remove operator< and delete all comparisons.\n+        (_Sp_owner_less,owner_less): Predicate for ownership-based ordering.\n+        (operator<(shared_ptr,shared_ptr): Overload for derived shared_ptr.\n+        (operator==(shared_ptr,shared_ptr): Likewise.\n+        (operator!=(shared_ptr,shared_ptr): Likewise.\n+        (swap(shared_ptr,shared_ptr)): Fix parameter types.\n+        (swap(weak_ptr,weak_ptr)): Add missing overload.\n+        * testsuite/20_util/owner_less/cmp.cc: New.\n+        * testsuite/20_util/shared_ptr/comparison/cmp.cc: Test other ops.\n+        * testsuite/20_util/shared_ptr/comparison/less.cc: New.\n+        * testsuite/20_util/shared_ptr/observers/owner_before.cc: New.\n+        * testsuite/20_util/weak_ptr/observers/owner_before.cc: New.\n+        * testsuite/20_util/weak_ptr/comparison/cmp_neg.cc: New.\n+\n 2008-10-31  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR libstdc++/37958"}, {"sha": "c017dcf6fc6e4b80633da4cf0652d748ae3fd53b", "filename": "libstdc++-v3/include/bits/shared_ptr.h", "status": "modified", "additions": 192, "deletions": 58, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr.h?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -82,9 +82,8 @@ namespace std\n       _M_get_deleter(const std::type_info& __ti)\n       { return 0; }\n       \n-    private:\n-      _Sp_counted_ptr(const _Sp_counted_ptr&);\n-      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&);\n+      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;\n+      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;\n       \n     protected:\n       _Ptr             _M_ptr;  // copy constructor must not throw\n@@ -143,10 +142,6 @@ namespace std\n       _M_get_deleter(const std::type_info& __ti)\n       { return __ti == typeid(_Deleter) ? &_M_del._M_del : 0; }\n       \n-    private:\n-      _Sp_counted_deleter(const _Sp_counted_deleter&);\n-      _Sp_counted_deleter& operator=(const _Sp_counted_deleter&);\n-      \n     protected:\n       _My_Deleter      _M_del;  // copy constructor must not throw\n     };\n@@ -365,18 +360,23 @@ namespace std\n       _M_unique() const // nothrow\n       { return this->_M_get_use_count() == 1; }\n \n-      friend inline bool\n-      operator==(const __shared_count& __a, const __shared_count& __b)\n-      { return __a._M_pi == __b._M_pi; }\n-  \n-      friend inline bool\n-      operator<(const __shared_count& __a, const __shared_count& __b)\n-      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n-  \n       void*\n       _M_get_deleter(const std::type_info& __ti) const\n       { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }\n \n+      bool\n+      _M_less(const __shared_count& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      bool\n+      _M_less(const __weak_count<_Lp>& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      // friend function injected into enclosing namespace and found by ADL\n+      friend inline bool\n+      operator==(const __shared_count& __a, const __shared_count& __b)\n+      { return __a._M_pi == __b._M_pi; }\n+  \n     private:\n       friend class __weak_count<_Lp>;\n \n@@ -468,13 +468,18 @@ namespace std\n       _M_get_use_count() const // nothrow\n       { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }\n \n+      bool\n+      _M_less(const __weak_count& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      bool\n+      _M_less(const __shared_count<_Lp>& __rhs) const\n+      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }\n+\n+      // friend function injected into enclosing namespace and found by ADL\n       friend inline bool\n-      operator==(const __weak_count<_Lp>& __a, const __weak_count<_Lp>& __b)\n+      operator==(const __weak_count& __a, const __weak_count& __b)\n       { return __a._M_pi == __b._M_pi; }\n-      \n-      friend inline bool\n-      operator<(const __weak_count<_Lp>& __a, const __weak_count<_Lp>& __b)\n-      { return std::less<_Sp_counted_base<_Lp>*>()(__a._M_pi, __b._M_pi); }\n \n     private:\n       friend class __shared_count<_Lp>;\n@@ -838,6 +843,16 @@ namespace std\n \t_M_refcount._M_swap(__other._M_refcount);\n       }\n \n+      template<typename _Tp1>\n+        bool\n+        owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const\n+        { return _M_refcount._M_less(__rhs._M_refcount); }\n+\n+      template<typename _Tp1>\n+        bool\n+        owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const\n+        { return _M_refcount._M_less(__rhs._M_refcount); }\n+\n     protected:\n       // This constructor is non-standard, it is used by allocate_shared.\n       template<typename _Alloc, typename... _Args>\n@@ -862,37 +877,70 @@ namespace std\n       _M_get_deleter(const std::type_info& __ti) const\n       { return _M_refcount._M_get_deleter(__ti); }\n \n-      template<typename _Tp1, _Lock_policy _Lp1>\n-        bool\n-        _M_less(const __shared_ptr<_Tp1, _Lp1>& __rhs) const\n-        { return _M_refcount < __rhs._M_refcount; }\n-\n       template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n       template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n \n       template<typename _Del, typename _Tp1, _Lock_policy _Lp1>\n         friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);\n \n-      // Friends injected into enclosing namespace and found by ADL:\n-      template<typename _Tp1>\n-        friend inline bool\n-        operator==(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n-        { return __a.get() == __b.get(); }\n-\n-      template<typename _Tp1>\n-        friend inline bool\n-        operator!=(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n-        { return __a.get() != __b.get(); }\n-\n-      template<typename _Tp1>\n-        friend inline bool\n-        operator<(const __shared_ptr& __a, const __shared_ptr<_Tp1, _Lp>& __b)\n-        { return __a._M_less(__b); }\n-\n       _Tp*         \t   _M_ptr;         // Contained pointer.\n       __shared_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n \n+  // 20.8.13.2.7 shared_ptr comparisons\n+  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+    inline bool\n+    operator==(const __shared_ptr<_Tp1, _Lp>& __a,\n+        const __shared_ptr<_Tp2, _Lp>& __b)\n+    { return __a.get() == __b.get(); }\n+\n+  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+    inline bool\n+    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,\n+        const __shared_ptr<_Tp2, _Lp>& __b)\n+    { return __a.get() != __b.get(); }\n+\n+  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>\n+    inline bool\n+    operator<(const __shared_ptr<_Tp1, _Lp>& __a,\n+        const __shared_ptr<_Tp2, _Lp>& __b)\n+    { return __a.get() < __b.get(); }\n+\n+  template<typename _Sp>\n+    struct _Sp_less : public binary_function<_Sp, _Sp, bool>\n+    {\n+      bool\n+      operator()(const _Sp& __lhs, const _Sp& __rhs) const\n+      {\n+        return std::less<typename _Sp::element_type*>()(__lhs.get(),\n+            __rhs.get());\n+      }\n+    };\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    struct less<__shared_ptr<_Tp, _Lp>>\n+    : public _Sp_less<__shared_ptr<_Tp, _Lp>>\n+    { };\n+\n+  // XXX LessThanComparable<_Tp> concept should provide >, >= and <=\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    operator>(const __shared_ptr<_Tp, _Lp>& __a,\n+        const __shared_ptr<_Tp, _Lp>& __b)\n+    { return __a.get() > __b.get(); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    operator>=(const __shared_ptr<_Tp, _Lp>& __a,\n+        const __shared_ptr<_Tp, _Lp>& __b)\n+    { return __a.get() >= __b.get(); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    operator<=(const __shared_ptr<_Tp, _Lp>& __a,\n+        const __shared_ptr<_Tp, _Lp>& __b)\n+    { return __a.get() <= __b.get(); }\n+\n   // 2.2.3.8 shared_ptr specialized algorithms.\n   template<typename _Tp, _Lock_policy _Lp>\n     inline void\n@@ -1053,7 +1101,17 @@ namespace std\n       bool\n       expired() const // never throws\n       { return _M_refcount._M_get_use_count() == 0; }\n-      \n+\n+      template<typename _Tp1>\n+        bool\n+        owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const\n+        { return _M_refcount._M_less(__rhs._M_refcount); }\n+\n+      template<typename _Tp1>\n+        bool\n+        owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n+        { return _M_refcount._M_less(__rhs._M_refcount); }\n+\n       void\n       reset() // never throws\n       { __weak_ptr().swap(*this); }\n@@ -1065,6 +1123,16 @@ namespace std\n \t_M_refcount._M_swap(__s._M_refcount);\n       }\n \n+      // comparisons\n+      template<typename _Tp1>\n+        bool operator<(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+      template<typename _Tp1>\n+        bool operator<=(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+      template<typename _Tp1>\n+        bool operator>(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+      template<typename _Tp1>\n+        bool operator>=(const __weak_ptr<_Tp1, _Lp>&) const = delete;\n+\n     private:\n       // Used by __enable_shared_from_this.\n       void\n@@ -1074,32 +1142,49 @@ namespace std\n \t_M_refcount = __refcount;\n       }\n \n-      template<typename _Tp1>\n-        bool\n-        _M_less(const __weak_ptr<_Tp1, _Lp>& __rhs) const\n-        { return _M_refcount < __rhs._M_refcount; }\n-\n       template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;\n       template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;\n       friend class __enable_shared_from_this<_Tp, _Lp>;\n       friend class enable_shared_from_this<_Tp>;\n \n-      // Friend injected into namespace and found by ADL.\n-      template<typename _Tp1>\n-        friend inline bool\n-        operator<(const __weak_ptr& __lhs, const __weak_ptr<_Tp1, _Lp>& __rhs)\n-        { return __lhs._M_less(__rhs); }\n-\n       _Tp*       \t _M_ptr;         // Contained pointer.\n       __weak_count<_Lp>  _M_refcount;    // Reference counter.\n     };\n \n-  // 2.2.4.7 weak_ptr specialized algorithms.\n+  // 20.8.13.3.7 weak_ptr specialized algorithms.\n   template<typename _Tp, _Lock_policy _Lp>\n     inline void\n     swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)\n     { __a.swap(__b); }\n \n+  /// owner_less\n+  template<typename _Tp> struct owner_less;\n+\n+  template<typename _Tp, typename _Tp1>\n+    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __lhs, const _Tp& __rhs) const\n+      { return __lhs.owner_before(__rhs); }\n+      bool\n+      operator()(const _Tp& __lhs, const _Tp1& __rhs) const\n+      { return __lhs.owner_before(__rhs); }\n+      bool\n+      operator()(const _Tp1& __lhs, const _Tp& __rhs) const\n+      { return __lhs.owner_before(__rhs); }\n+    };\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    struct owner_less<__shared_ptr<_Tp, _Lp>>\n+    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>\n+    { };\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    struct owner_less<__weak_ptr<_Tp, _Lp>>\n+    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>\n+    {\n+    };\n+\n \n   template<typename _Tp, _Lock_policy _Lp>\n     class __enable_shared_from_this\n@@ -1262,22 +1347,44 @@ namespace std\n         allocate_shared(_Alloc __a, _Args&&... __args);\n     };\n \n-  // 20.7.12.2.9 shared_ptr specialized algorithms.\n+  // 20.8.13.2.7 shared_ptr comparisons\n+  template<typename _Tp1, typename _Tp2>\n+    inline bool\n+    operator==(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)\n+    { return __a.get() == __b.get(); }\n+\n+  template<typename _Tp1, typename _Tp2>\n+    inline bool\n+    operator!=(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)\n+    { return __a.get() != __b.get(); }\n+\n+  template<typename _Tp1, typename _Tp2>\n+    inline bool\n+    operator<(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)\n+    { return __a.get() < __b.get(); }\n+\n+  template<typename _Tp>\n+    struct less<shared_ptr<_Tp>>\n+    : public _Sp_less<shared_ptr<_Tp>>\n+    { };\n+\n+  // 20.8.13.2.9 shared_ptr specialized algorithms.\n   template<typename _Tp>\n     inline void\n-    swap(__shared_ptr<_Tp>& __a, __shared_ptr<_Tp>& __b)\n+    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b)\n     { __a.swap(__b); }\n \n   template<typename _Tp>\n     inline void\n-    swap(__shared_ptr<_Tp>&& __a, __shared_ptr<_Tp>& __b)\n+    swap(shared_ptr<_Tp>&& __a, shared_ptr<_Tp>& __b)\n     { __a.swap(__b); }\n \n   template<typename _Tp>\n     inline void\n-    swap(__shared_ptr<_Tp>& __a, __shared_ptr<_Tp>&& __b)\n+    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>&& __b)\n     { __a.swap(__b); }\n \n+  // 20.8.13.2.10 shared_ptr casts.\n   template<typename _Tp, typename _Tp1>\n     inline shared_ptr<_Tp>\n     static_pointer_cast(const shared_ptr<_Tp1>& __r)\n@@ -1353,8 +1460,35 @@ namespace std\n \t                       : shared_ptr<_Tp>(*this);\n #endif\n       }\n+\n+      // comparisons\n+      template<typename _Tp1>\n+        bool operator<(const weak_ptr<_Tp1>&) const = delete;\n+      template<typename _Tp1>\n+        bool operator<=(const weak_ptr<_Tp1>&) const = delete;\n+      template<typename _Tp1>\n+        bool operator>(const weak_ptr<_Tp1>&) const = delete;\n+      template<typename _Tp1>\n+        bool operator>=(const weak_ptr<_Tp1>&) const = delete;\n     };\n \n+  // 20.8.13.3.7 weak_ptr specialized algorithms.\n+  template<typename _Tp>\n+    inline void\n+    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b)\n+    { __a.swap(__b); }\n+\n+  /// owner_less\n+  template<typename _Tp>\n+    struct owner_less<shared_ptr<_Tp>>\n+    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>\n+    { };\n+\n+  template<typename _Tp>\n+    struct owner_less<weak_ptr<_Tp>>\n+    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>\n+    { };\n+\n   /// enable_shared_from_this\n   template<typename _Tp>\n     class enable_shared_from_this"}, {"sha": "6369da775894f218a8bb46b7817aafd8eb0348b1", "filename": "libstdc++-v3/testsuite/20_util/owner_less/cmp.cc", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fowner_less%2Fcmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fowner_less%2Fcmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fowner_less%2Fcmp.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -0,0 +1,128 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.8.13.4 Template class owner_less [util.smartptr.ownerless]\n+\n+#include <memory>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+struct B { A a[2]; };\n+\n+// 20.8.13.4 Template class owner_less [util.smartptr.ownerless]\n+\n+int\n+test01()\n+{\n+    // test empty shared_ptrs compare equivalent\n+    std::owner_less<std::shared_ptr<A>> less;\n+    std::owner_less<std::weak_ptr<A>> wless;\n+    std::shared_ptr<A> p1;\n+    std::shared_ptr<A> p2;\n+    VERIFY( !less(p1, p2) && !less(p2, p1) );\n+    std::weak_ptr<A> p3;\n+    VERIFY( !less(p1, p3) && !less(p3, p1) );\n+    VERIFY( !wless(p1, p3) && !wless(p3, p1) );\n+    return 0;\n+}\n+\n+\n+// Construction from pointer\n+int\n+test02()\n+{\n+  std::owner_less<std::shared_ptr<A>> less;\n+  std::owner_less<std::weak_ptr<A>> wless;\n+\n+  std::shared_ptr<A> empty;\n+\n+  std::shared_ptr<A> a1(new A);\n+  VERIFY( less(empty, a1) || less(a1, empty) );\n+\n+  std::shared_ptr<A> a2(new A);\n+  VERIFY( less(a1, a2) || less(a2, a1) );\n+\n+  std::weak_ptr<A> w1(a1);\n+  VERIFY( !less(a1, w1) && !less(w1, a1) );\n+\n+  std::weak_ptr<A> w2(a2);\n+  VERIFY( wless(w1, w2) || wless(w2, w1) );\n+\n+  a1.reset();\n+  VERIFY( !less(empty, a1) && !less(a1, empty) );\n+  VERIFY( less(a1, w1) || less(w1, a1) );\n+\n+  a2.reset();\n+  VERIFY( !less(a2, a1) && !less(a1, a2) );\n+\n+  return 0;\n+}\n+\n+// aliasing\n+int\n+test03()\n+{\n+  std::owner_less<std::shared_ptr<A>> less;\n+  std::owner_less<std::weak_ptr<A>> wless;\n+\n+  std::shared_ptr<B> b(new B);\n+  std::shared_ptr<A> a0(b, &b->a[0]);\n+  std::shared_ptr<A> a1(b, &b->a[1]);\n+  // values are different but owners are equivalent:\n+  VERIFY( a0 < a1 && !less(a0, a1) && !less(a1, a0) );\n+\n+  std::weak_ptr<A> w0(a0);\n+  std::weak_ptr<A> w1(a1);\n+  VERIFY( !wless(w0, w1) && !wless(w1, w0) );\n+  VERIFY( !less(a0, w1) && !less(w1, a0) );\n+  VERIFY( !wless(w0, a1) && !wless(a1, w0) );\n+\n+  return 0;\n+}\n+\n+// strict weak ordering\n+int\n+test04()\n+{\n+  std::owner_less<std::shared_ptr<A>> less;\n+\n+  std::shared_ptr<A> a[3];\n+  a[0].reset(new A);\n+  a[1].reset(new A);\n+  a[2].reset(new A);\n+  std::sort(a, a+3, less);\n+  VERIFY( !less(a[0], a[0]) );\n+  VERIFY( less(a[0], a[1]) && !less(a[1], a[0]) );\n+  VERIFY( less(a[0], a[1]) && less(a[1], a[2]) && less(a[0], a[2]) );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}, {"sha": "8b623e1d8ea1c68e5c8c768e37227dae30c91c7d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/comparison/cmp.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fcmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fcmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fcmp.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -76,10 +76,24 @@ test02()\n   return 0;\n }\n \n+int\n+test03()\n+{\n+  std::shared_ptr<A> p1;\n+\n+  // check other operators are defined\n+  VERIFY( p1 <= p1 );\n+  VERIFY( p1 >= p1 );\n+  VERIFY( !(p1 > p1) );\n+\n+  return 0;\n+}\n+\n int \n main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "8e96b11c4249acd74baf1242c23abebbb5c19578", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/comparison/less.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fless.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fless.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fcomparison%2Fless.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -0,0 +1,97 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.8.13.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+namespace std\n+{\n+  template<>\n+    struct less<A*> : binary_function<A*,A*,bool>\n+    {\n+      static int count;\n+      bool operator()(A* l, A* r) { ++count; return l < r; }\n+    };\n+  int less<A*>::count = 0;\n+}\n+\n+// 20.8.13.2.7 shared_ptr comparison [util.smartptr.shared.cmp]\n+\n+\n+int\n+test01()\n+{\n+  std::less<std::shared_ptr<A>> less;\n+  // test empty shared_ptrs compare equivalent\n+  std::shared_ptr<A> p1;\n+  std::shared_ptr<A> p2;\n+  VERIFY( !less(p1, p2) && !less(p2, p1) );\n+  VERIFY( std::less<A*>::count == 2 );\n+  return 0;\n+}\n+\n+\n+// Construction from pointer\n+int\n+test02()\n+{\n+  std::less<std::shared_ptr<A>> less;\n+\n+  std::shared_ptr<A> empty;\n+  std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(new A);\n+\n+  VERIFY( less(p1, p2) || less(p2, p1) );\n+  VERIFY( !(less(p1, p2) && less(p2, p1)) );\n+\n+  p1.reset();\n+  VERIFY( !less(p1, empty) && !less(empty, p1) );\n+\n+  p2.reset();\n+  VERIFY( !less(p1, p2) && !less(p2, p1) );\n+\n+  return 0;\n+}\n+\n+// Aliasing\n+int\n+test03()\n+{\n+  std::less<std::shared_ptr<A>> less;\n+\n+  A a;\n+  std::shared_ptr<A> p1(new A);\n+  std::shared_ptr<A> p2(p1, &a);\n+  VERIFY( less(p1, p2) || less(p2, p1) );\n+\n+  return 0;\n+}\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "77d830326a02d695bff281c4c0af92e2921f35bf", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/bool_conv.cc", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fbool_conv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fbool_conv.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+// Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -28,7 +28,7 @@ struct A { };\n // 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n \n // conversion to bool\n-int\n+void\n test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -37,11 +37,9 @@ test01()\n   VERIFY( p1 == false );\n   const std::shared_ptr<A> p2(p1);\n   VERIFY( p2 == false );\n-\n-  return 0;\n }\n \n-int\n+void\n test02()\n {\n   bool test __attribute__((unused)) = true;\n@@ -53,11 +51,9 @@ test02()\n   p1.reset();\n   VERIFY( !p1 );\n   VERIFY( p2 );\n-\n-  return 0;\n }\n \n-int\n+void\n test03()\n {\n   bool test __attribute__((unused)) = true;\n@@ -67,8 +63,6 @@ test03()\n   p2.reset(new A);\n   VERIFY( p1 );\n   VERIFY( p2 );\n-\n-  return 0;\n }\n \n "}, {"sha": "55cd8cdb713f532e51f9f485e8a7d4deb7b719b5", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/get.cc", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fget.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fget.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fget.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+// Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -32,46 +32,38 @@ struct A\n // 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n \n // get\n-int\n+void\n test01()\n {\n   bool test __attribute__((unused)) = true;\n \n   A * const a = new A;\n   const std::shared_ptr<A> p(a);\n   VERIFY( p.get() == a );\n-\n-  return 0;\n }\n \n // operator*\n-int\n+void\n test02()\n {\n   bool test __attribute__((unused)) = true;\n \n   A * const a = new A;\n   const std::shared_ptr<A> p(a);\n   VERIFY( &*p == a );\n-\n-  return 0;\n }\n \n-\n // operator->\n-int\n+void\n test03()\n {\n   bool test __attribute__((unused)) = true;\n \n   A * const a = new A;\n   const std::shared_ptr<A> p(a);\n   VERIFY( &p->i == &a->i );\n-\n-  return 0;\n }\n \n-\n int \n main()\n {"}, {"sha": "73d7724cfabbd82dd8b6a9bff2d81ce5ed0b706b", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/owner_before.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fowner_before.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fowner_before.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fowner_before.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -0,0 +1,95 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.8.13.2 Template class shared_ptr [util.smartptr.shared]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A\n+{\n+  int i;\n+  virtual ~A() { }\n+};\n+\n+struct B : A\n+{\n+};\n+\n+// 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n+\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // test empty shared_ptrs compare equivalent\n+  std::shared_ptr<A> p1;\n+  std::shared_ptr<B> p2;\n+  VERIFY( !p1.owner_before(p2) && !p2.owner_before(p1) );\n+}\n+\n+\n+// Construction from pointer\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> a0;\n+\n+  std::shared_ptr<A> a1(new A);\n+  VERIFY( a1.owner_before(a0) || a0.owner_before(a1) );\n+  VERIFY( !(a1.owner_before(a0) && a0.owner_before(a1)) );\n+\n+  std::shared_ptr<B> b1(new B);\n+  VERIFY( a1.owner_before(b1) || b1.owner_before(a1) );\n+  VERIFY( !(a1.owner_before(b1) && b1.owner_before(a1)) );\n+\n+  std::shared_ptr<A> a2(a1);\n+  VERIFY( !a1.owner_before(a2) && !a2.owner_before(a1) );\n+  a2 = b1;\n+  VERIFY( !b1.owner_before(a2) && !a2.owner_before(b1) );\n+\n+  std::weak_ptr<A> w1(a1);\n+  VERIFY( !a1.owner_before(w1) && !w1.owner_before(a1) );\n+  std::weak_ptr<A> w2(a2);\n+  VERIFY( !b1.owner_before(w2) && !w2.owner_before(b1) );\n+}\n+\n+// Aliasing\n+void\n+test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::shared_ptr<A> p1(new A());\n+  std::shared_ptr<int> p2(p1, &p1->i);\n+  VERIFY( !p1.owner_before(p2) && !p2.owner_before(p1) );\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "c619705af5a01003c8b2bfb0001ca3554e79435d", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/unique.cc", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Funique.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Funique.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Funique.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+// Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -28,7 +28,7 @@ struct A { };\n // 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n \n // unique\n-int\n+void\n test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -37,11 +37,9 @@ test01()\n   VERIFY( !p1.unique() );\n   const std::shared_ptr<A> p2(p1);\n   VERIFY( !p1.unique() );\n-\n-  return 0;\n }\n \n-int\n+void\n test02()\n {\n   bool test __attribute__((unused)) = true;\n@@ -53,11 +51,9 @@ test02()\n   p1.reset();\n   VERIFY( !p1.unique() );\n   VERIFY( p2.unique() );\n-\n-  return 0;\n }\n \n-int\n+void\n test03()\n {\n   bool test __attribute__((unused)) = true;\n@@ -67,8 +63,6 @@ test03()\n   p2.reset(new A);\n   VERIFY( p1.unique() );\n   VERIFY( p2.unique() );\n-\n-  return 0;\n }\n \n "}, {"sha": "e2666c5e88088398f5bc8c4b33c68dbfc852c451", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/observers/use_count.cc", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fuse_count.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fobservers%2Fuse_count.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -1,6 +1,6 @@\n // { dg-options \"-std=gnu++0x\" }\n \n-// Copyright (C) 2005, 2006, 2007 Free Software Foundation\n+// Copyright (C) 2005, 2006, 2007, 2008 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -29,7 +29,7 @@ struct B : A { };\n // 20.6.6.2.5 shared_ptr observers [util.smartptr.shared.obs]\n \n // use_count\n-int\n+void\n test01()\n {\n   bool test __attribute__((unused)) = true;\n@@ -38,11 +38,9 @@ test01()\n   VERIFY( p1.use_count() == 0 );\n   const std::shared_ptr<A> p2(p1);\n   VERIFY( p1.use_count() == 0 );\n-\n-  return 0;\n }\n \n-int\n+void\n test02()\n {\n   bool test __attribute__((unused)) = true;\n@@ -52,11 +50,9 @@ test02()\n   p1.reset();\n   VERIFY( p1.use_count() == 0 );\n   VERIFY( p2.use_count() == 1 );\n-\n-  return 0;\n }\n \n-int\n+void\n test03()\n {\n   bool test __attribute__((unused)) = true;\n@@ -66,8 +62,6 @@ test03()\n   p2.reset(new B);\n   VERIFY( p1.use_count() == 1 );\n   VERIFY( p2.use_count() == 1 );\n-\n-  return 0;\n }\n \n "}, {"sha": "aa7399f3cba150214c50dd18d313159d6fdd2d9c", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/comparison/cmp_neg.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fcomparison%2Fcmp_neg.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -0,0 +1,45 @@\n+// { dg-options \"-std=gnu++0x \" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.6.6.3 Template class weak_ptr [util.smartptr.weak]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+\n+// 20.8.13.3.6 weak_ptr comparison [util.smartptr.weak.cmp] (removed)\n+\n+int\n+test01()\n+{\n+    std::weak_ptr<A> p1;\n+    // { dg-excess-errors \"deleted function\" }\n+    p1 < p1;  // { dg-error \"used here\" }\n+    return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "52e1199b05d9527ac9c4afb01007474bbb817e91", "filename": "libstdc++-v3/testsuite/20_util/weak_ptr/observers/owner_before.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fobservers%2Fowner_before.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dd5e93af60784985b22b8af909469d57ee6abdb/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fobservers%2Fowner_before.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fweak_ptr%2Fobservers%2Fowner_before.cc?ref=8dd5e93af60784985b22b8af909469d57ee6abdb", "patch": "@@ -0,0 +1,74 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 20.8.13.3 Template class weak_ptr [util.smartptr.weak]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct A { };\n+struct B { };\n+\n+// 20.6.6.3.5 weak_ptr observers [util.smartptr.weak.obs]\n+\n+int\n+test01()\n+{\n+  // test empty weak_ptrs compare equivalent\n+  std::weak_ptr<A> p1;\n+  std::weak_ptr<B> p2;\n+  VERIFY( !p1.owner_before(p2) && !p2.owner_before(p1) );\n+\n+  std::shared_ptr<B> p3;\n+  VERIFY( !p1.owner_before(p3) && !p3.owner_before(p1) );\n+\n+  return 0;\n+}\n+\n+\n+int\n+test02()\n+{\n+  std::shared_ptr<A> a0;\n+  std::weak_ptr<A> w0(a0);\n+\n+  std::shared_ptr<A> a1(new A);\n+  std::weak_ptr<A> w1(a1);\n+  VERIFY( !a1.owner_before(w1) && !w1.owner_before(a1) );\n+\n+  VERIFY( w1.owner_before(w0) || w0.owner_before(w1) );\n+  VERIFY( !(w1.owner_before(w0) && w0.owner_before(w1)) );\n+\n+  VERIFY( w1.owner_before(a0) || a0.owner_before(w1) );\n+  VERIFY( !(w1.owner_before(a0) && a0.owner_before(w1)) );\n+\n+  std::shared_ptr<B> b1(new B);\n+  VERIFY( w1.owner_before(b1) || b1.owner_before(w1) );\n+\n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}]}