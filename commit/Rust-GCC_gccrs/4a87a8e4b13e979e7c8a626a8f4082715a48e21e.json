{"sha": "4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "node_id": "C_kwDOANBUbNoAKDRhODdhOGU0YjEzZTk3OWU3YzhhNjI2YThmNDA4MjcxNWE0OGUyMWU", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2021-11-16T10:32:35Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2021-12-10T10:45:09Z"}, "message": "amdgcn: Change offload variable table discovery\n\nUp to now the libgomp GCN plugin has been finding the offload variables\nby using a symbol lookup, but the AMD runtime requires that the symbols are\nglobal for that to work. This was ensured by mkoffload as a post-procssing\nstep, but the LLVM 13 assembler no longer accepts this in the case where the\nvariable was previously declared differently.\n\nThis patch switches to locating the symbols directly from the\noffload_var_table, which means that only one symbol needs to be forced\nglobal.\n\nThis changes breaks the libgomp image compatibility so GOMP_VERSION_GCN has\nalso been bumped.\n\ngcc/ChangeLog:\n\n\t* config/gcn/mkoffload.c (process_asm): Process the variable table\n\tcompletely differently.\n\t(process_obj): Encode the varaible data differently.\n\ninclude/ChangeLog:\n\n\t* gomp-constants.h (GOMP_VERSION_GCN): Bump.\n\nlibgomp/ChangeLog:\n\n\t* plugin/plugin-gcn.c (struct gcn_image_desc): Remove global_variables.\n\t(GOMP_OFFLOAD_load_image): Locate the offload variables via the\n\ttable, not individual symbols.", "tree": {"sha": "2f91529327ffcb7d066bcef4e4da203af311d13f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f91529327ffcb7d066bcef4e4da203af311d13f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5f65cf7ad640ae398eba7a45c712322ce841809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5f65cf7ad640ae398eba7a45c712322ce841809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5f65cf7ad640ae398eba7a45c712322ce841809"}], "stats": {"total": 92, "additions": 41, "deletions": 51}, "files": [{"sha": "d609b7a6f9cafd0390ef7c053a180ff6d6ff97e3", "filename": "gcc/config/gcn/mkoffload.c", "status": "modified", "additions": 19, "deletions": 32, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/gcc%2Fconfig%2Fgcn%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.c?ref=4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "patch": "@@ -495,10 +495,8 @@ static void\n process_asm (FILE *in, FILE *out, FILE *cfile)\n {\n   int fn_count = 0, var_count = 0, dims_count = 0, regcount_count = 0;\n-  struct obstack fns_os, vars_os, varsizes_os, dims_os, regcounts_os;\n+  struct obstack fns_os, dims_os, regcounts_os;\n   obstack_init (&fns_os);\n-  obstack_init (&vars_os);\n-  obstack_init (&varsizes_os);\n   obstack_init (&dims_os);\n   obstack_init (&regcounts_os);\n \n@@ -567,16 +565,11 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t    unsigned varsize;\n \t    if (sscanf (buf, \" .8byte %ms\\n\", &varname))\n \t      {\n-\t\tobstack_ptr_grow (&vars_os, varname);\n+\t\tfputs (buf, out);\n \t\tfgets (buf, sizeof (buf), in);\n \t\tif (!sscanf (buf, \" .8byte %u\\n\", &varsize))\n \t\t  abort ();\n-\t\tobstack_int_grow (&varsizes_os, varsize);\n \t\tvar_count++;\n-\n-\t\t/* The HSA Runtime cannot locate the symbol if it is not\n-\t\t   exported from the kernel.  */\n-\t\tfprintf (out, \"\\t.global %s\\n\", varname);\n \t      }\n \t    break;\n \t  }\n@@ -595,7 +588,19 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \n       char dummy;\n       if (sscanf (buf, \" .section .gnu.offload_vars%c\", &dummy) > 0)\n-\tstate = IN_VARS;\n+\t{\n+\t  state = IN_VARS;\n+\n+\t  /* Add a global symbol to allow plugin-gcn.c to locate the table\n+\t     at runtime.  It can't use the \"offload_var_table.N\" emitted by\n+\t     the compiler because a) they're not global, and b) there's one\n+\t     for each input file combined into the binary.  */\n+\t  fputs (buf, out);\n+\t  fputs (\"\\t.global .offload_var_table\\n\"\n+\t\t \"\\t.type .offload_var_table, @object\\n\"\n+\t\t \".offload_var_table:\\n\",\n+\t\t out);\n+\t}\n       else if (sscanf (buf, \" .section .gnu.offload_funcs%c\", &dummy) > 0)\n \tstate = IN_FUNCS;\n       else if (sscanf (buf, \" .amdgpu_metadata%c\", &dummy) > 0)\n@@ -622,7 +627,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t  regcount.sgpr_count = regcount.vgpr_count = -1;\n \t}\n \n-      if (state == IN_CODE || state == IN_METADATA)\n+      if (state == IN_CODE || state == IN_METADATA || state == IN_VARS)\n \tfputs (buf, out);\n     }\n \n@@ -633,24 +638,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n   fprintf (cfile, \"#include <stdlib.h>\\n\");\n   fprintf (cfile, \"#include <stdbool.h>\\n\\n\");\n \n-  char **vars = XOBFINISH (&vars_os, char **);\n-  unsigned *varsizes = XOBFINISH (&varsizes_os, unsigned *);\n-  fprintf (cfile,\n-\t   \"static const struct global_var_info {\\n\"\n-\t   \"  const char *name;\\n\"\n-\t   \"  void *address;\\n\"\n-\t   \"} vars[] = {\\n\");\n-  int i;\n-  for (i = 0; i < var_count; ++i)\n-    {\n-      const char *sep = i < var_count - 1 ? \",\" : \" \";\n-      fprintf (cfile, \"  { \\\"%s\\\", NULL }%s /* size: %u */\\n\", vars[i], sep,\n-\t       varsizes[i]);\n-    }\n-  fprintf (cfile, \"};\\n\\n\");\n-\n-  obstack_free (&vars_os, NULL);\n-  obstack_free (&varsizes_os, NULL);\n+  fprintf (cfile, \"static const int gcn_num_vars = %d;\\n\\n\", var_count);\n \n   /* Dump out function idents.  */\n   fprintf (cfile, \"static const struct hsa_kernel_description {\\n\"\n@@ -661,6 +649,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n \t   \"} gcn_kernels[] = {\\n  \");\n   dim.d[0] = dim.d[1] = dim.d[2] = 0;\n   const char *comma;\n+  int i;\n   for (comma = \"\", i = 0; i < fn_count; comma = \",\\n  \", i++)\n     {\n       /* Find if we recorded dimensions for this function.  */\n@@ -732,13 +721,11 @@ process_obj (FILE *in, FILE *cfile)\n \t   \"  unsigned kernel_count;\\n\"\n \t   \"  const struct hsa_kernel_description *kernel_infos;\\n\"\n \t   \"  unsigned global_variable_count;\\n\"\n-\t   \"  const struct global_var_info *global_variables;\\n\"\n \t   \"} target_data = {\\n\"\n \t   \"  &gcn_image,\\n\"\n \t   \"  sizeof (gcn_kernels) / sizeof (gcn_kernels[0]),\\n\"\n \t   \"  gcn_kernels,\\n\"\n-\t   \"  sizeof (vars) / sizeof (vars[0]),\\n\"\n-\t   \"  vars\\n\"\n+\t   \"  gcn_num_vars\\n\"\n \t   \"};\\n\\n\");\n \n   fprintf (cfile,"}, {"sha": "2cf0919a7fb6c6190d8208bf1b1b3822e2e3db61", "filename": "include/gomp-constants.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "patch": "@@ -274,7 +274,7 @@ enum gomp_map_kind\n #define GOMP_VERSION\t1\n #define GOMP_VERSION_NVIDIA_PTX 1\n #define GOMP_VERSION_INTEL_MIC 0\n-#define GOMP_VERSION_GCN 1\n+#define GOMP_VERSION_GCN 2\n \n #define GOMP_VERSION_PACK(LIB, DEV) (((LIB) << 16) | (DEV))\n #define GOMP_VERSION_LIB(PACK) (((PACK) >> 16) & 0xffff)"}, {"sha": "694862b97f4f3cbd412d4968a24d61a62c46edbb", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a87a8e4b13e979e7c8a626a8f4082715a48e21e/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=4a87a8e4b13e979e7c8a626a8f4082715a48e21e", "patch": "@@ -392,7 +392,6 @@ struct gcn_image_desc\n   const unsigned kernel_count;\n   struct hsa_kernel_description *kernel_infos;\n   const unsigned global_variable_count;\n-  struct global_var_info *global_variables;\n };\n \n /* This enum mirrors the corresponding LLVM enum's values for all ISAs that we\n@@ -3365,37 +3364,41 @@ GOMP_OFFLOAD_load_image (int ord, unsigned version, const void *target_data,\n   if (!create_and_finalize_hsa_program (agent))\n     return -1;\n \n-  for (unsigned i = 0; i < var_count; i++)\n+  if (var_count > 0)\n     {\n-      struct global_var_info *v = &image_desc->global_variables[i];\n-      GCN_DEBUG (\"Looking for variable %s\\n\", v->name);\n-\n       hsa_status_t status;\n       hsa_executable_symbol_t var_symbol;\n       status = hsa_fns.hsa_executable_get_symbol_fn (agent->executable, NULL,\n-\t\t\t\t\t\t     v->name, agent->id,\n+\t\t\t\t\t\t     \".offload_var_table\",\n+\t\t\t\t\t\t     agent->id,\n \t\t\t\t\t\t     0, &var_symbol);\n \n       if (status != HSA_STATUS_SUCCESS)\n \thsa_fatal (\"Could not find symbol for variable in the code object\",\n \t\t   status);\n \n-      uint64_t var_addr;\n-      uint32_t var_size;\n+      uint64_t var_table_addr;\n       status = hsa_fns.hsa_executable_symbol_get_info_fn\n-\t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS, &var_addr);\n+\t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS,\n+\t &var_table_addr);\n       if (status != HSA_STATUS_SUCCESS)\n \thsa_fatal (\"Could not extract a variable from its symbol\", status);\n-      status = hsa_fns.hsa_executable_symbol_get_info_fn\n-\t(var_symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_SIZE, &var_size);\n-      if (status != HSA_STATUS_SUCCESS)\n-\thsa_fatal (\"Could not extract a variable size from its symbol\", status);\n \n-      pair->start = var_addr;\n-      pair->end = var_addr + var_size;\n-      GCN_DEBUG (\"Found variable %s at %p with size %u\\n\", v->name,\n-\t\t (void *)var_addr, var_size);\n-      pair++;\n+      struct {\n+\tuint64_t addr;\n+\tuint64_t size;\n+      } var_table[var_count];\n+      GOMP_OFFLOAD_dev2host (agent->device_id, var_table,\n+\t\t\t     (void*)var_table_addr, sizeof (var_table));\n+\n+      for (unsigned i = 0; i < var_count; i++)\n+\t{\n+\t  pair->start = var_table[i].addr;\n+\t  pair->end = var_table[i].addr + var_table[i].size;\n+\t  GCN_DEBUG (\"Found variable at %p with size %lu\\n\",\n+\t\t     (void *)var_table[i].addr, var_table[i].size);\n+\t  pair++;\n+\t}\n     }\n \n   GCN_DEBUG (\"Looking for variable %s\\n\", STRINGX (GOMP_DEVICE_NUM_VAR));"}]}