{"sha": "835532b871f829d54eaf4198e50ed8cfb1f6a7e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM1NTMyYjg3MWY4MjlkNTRlYWY0MTk4ZTUwZWQ4Y2ZiMWY2YTdlNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-09T11:30:54Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-08-09T11:30:54Z"}, "message": "(widen_operand): New function.\n\n(expand_binop, expand_unop): Call it.\n\nFrom-SVN: r5118", "tree": {"sha": "8c568b4758789c5047b4a2e0d2d18910ddca1afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c568b4758789c5047b4a2e0d2d18910ddca1afe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/835532b871f829d54eaf4198e50ed8cfb1f6a7e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/835532b871f829d54eaf4198e50ed8cfb1f6a7e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/835532b871f829d54eaf4198e50ed8cfb1f6a7e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/835532b871f829d54eaf4198e50ed8cfb1f6a7e5/comments", "author": null, "committer": null, "parents": [{"sha": "2e9effae27bd4227a8d8504ead761e96364e95a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e9effae27bd4227a8d8504ead761e96364e95a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e9effae27bd4227a8d8504ead761e96364e95a9"}], "stats": {"total": 128, "additions": 57, "deletions": 71}, "files": [{"sha": "2ff6d2bd0436566f4da2c18f649e1984e6c08b52", "filename": "gcc/optabs.c", "status": "modified", "additions": 57, "deletions": 71, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/835532b871f829d54eaf4198e50ed8cfb1f6a7e5/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/835532b871f829d54eaf4198e50ed8cfb1f6a7e5/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=835532b871f829d54eaf4198e50ed8cfb1f6a7e5", "patch": "@@ -1,5 +1,5 @@\n /* Expand the basic unary and binary arithmetic operations, for GNU compiler.\n-   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -207,6 +207,7 @@ rtxfun bcc_gen_fctn[NUM_RTX_CODE];\n enum insn_code setcc_gen_code[NUM_RTX_CODE];\n \n static int add_equal_note\tPROTO((rtx, rtx, enum rtx_code, rtx, rtx));\n+static rtx widen_operand\tPROTO((rtx, enum machine_mode, int, int));\n static void emit_float_lib_cmp\tPROTO((rtx, rtx, enum rtx_code));\n static enum insn_code can_fix_p\tPROTO((enum machine_mode, enum machine_mode,\n \t\t\t\t       int, int *));\n@@ -273,6 +274,43 @@ add_equal_note (seq, target, code, op0, op1)\n   return 1;\n }\n \f\n+/* Widen OP to MODE and return the rtx for the widened operand.  UNSIGNEDP\n+   says whether OP is signed or unsigned.  NO_EXTEND is nonzero if we need\n+   not actually do a sign-extend or zero-extend, but can leave the \n+   higher-order bits of the result rtx undefined, for example, in the case\n+   of logical operations, but not right shifts.  */\n+\n+static rtx\n+widen_operand (op, mode, unsignedp, no_extend)\n+     rtx op;\n+     enum machine_mode mode;\n+     int unsignedp;\n+     int no_extend;\n+{\n+  rtx result;\n+\n+  /* If we must extend do so.  If OP is either a constant or a SUBREG\n+     for a promoted object, also extend since it will be more efficient to\n+     do so.  */\n+  if (! no_extend\n+      || GET_MODE (op) == VOIDmode\n+      || (GET_CODE (op) == SUBREG && SUBREG_PROMOTED_VAR_P (op)))\n+    return convert_to_mode (mode, op, unsignedp);\n+\n+  /* If MODE is no wider than a single word, we return a paradoxical\n+     SUBREG.  */\n+  if (GET_MODE_SIZE (mode) <= UNITS_PER_WORD)\n+    return gen_rtx (SUBREG, mode, force_reg (GET_MODE (op), op), 0);\n+\n+  /* Otherwise, get an object of MODE, clobber it, and set the low-order\n+     part to OP.  */\n+\n+  result = gen_reg_rtx (mode);\n+  emit_insn (gen_rtx (CLOBBER, VOIDmode, result));\n+  emit_move_insn (gen_lowpart (GET_MODE (op), result), op);\n+  return result;\n+}\n+\f\n /* Generate code to perform an operation specified by BINOPTAB\n    on operands OP0 and OP1, with result having machine-mode MODE.\n \n@@ -477,40 +515,18 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t    /* For certain integer operations, we need not actually extend\n \t       the narrow operands, as long as we will truncate\n-\t       the results to the same narrowness.  Don't do this when\n-\t       WIDER_MODE is wider than a word since a paradoxical SUBREG\n-\t       isn't valid for such modes.  */\n+\t       the results to the same narrowness.   */\n \n \t    if ((binoptab == ior_optab || binoptab == and_optab\n \t\t || binoptab == xor_optab\n \t\t || binoptab == add_optab || binoptab == sub_optab\n \t\t || binoptab == smul_optab\n \t\t || binoptab == ashl_optab || binoptab == lshl_optab)\n-\t\t&& class == MODE_INT\n-\t\t&& GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD)\n+\t\t&& class == MODE_INT)\n \t      no_extend = 1;\n \n-\t    /* If an operand is a constant integer, we might as well\n-\t       convert it since that is more efficient than using a SUBREG,\n-\t       unlike the case for other operands.  Similarly for\n-\t       SUBREGs that were made due to promoted objects.  */\n-\n-\t    if (no_extend && GET_MODE (xop0) != VOIDmode\n-\t\t&& ! (GET_CODE (xop0) == SUBREG\n-\t\t      && SUBREG_PROMOTED_VAR_P (xop0)))\n-\t      xop0 = gen_rtx (SUBREG, wider_mode,\n-\t\t\t      force_reg (GET_MODE (xop0), xop0), 0);\n-\t    else\n-\t      xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n-\n-\t    if (no_extend && GET_MODE (xop1) != VOIDmode\n-\t\t&& ! (GET_CODE (xop1) == SUBREG\n-\t\t      && SUBREG_PROMOTED_VAR_P (xop1)))\n-\t      xop1 = gen_rtx (SUBREG, wider_mode,\n-\t\t\t\tforce_reg (GET_MODE (xop1), xop1), 0);\n-\t    else\n-\t      xop1 = convert_to_mode (wider_mode, xop1, unsignedp);\n-\n+\t    xop0 = widen_operand (xop0, wider_mode, unsignedp, no_extend);\n+\t    xop1 = widen_operand (xop1, wider_mode, unsignedp, no_extend);\n \t    temp = expand_binop (wider_mode, binoptab, xop0, xop1, NULL_RTX,\n \t\t\t\t unsignedp, OPTAB_DIRECT);\n \t    if (temp)\n@@ -1392,39 +1408,18 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t      /* For certain integer operations, we need not actually extend\n \t\t the narrow operands, as long as we will truncate\n-\t\t the results to the same narrowness.  Don't do this when\n-\t\t WIDER_MODE is wider than a word since a paradoxical SUBREG\n-\t\t isn't valid for such modes.  */\n+\t\t the results to the same narrowness.  */\n \n \t      if ((binoptab == ior_optab || binoptab == and_optab\n \t\t   || binoptab == xor_optab\n \t\t   || binoptab == add_optab || binoptab == sub_optab\n \t\t   || binoptab == smul_optab\n \t\t   || binoptab == ashl_optab || binoptab == lshl_optab)\n-\t\t  && class == MODE_INT\n-\t\t  && GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD)\n+\t\t  && class == MODE_INT)\n \t\tno_extend = 1;\n \n-\t      /* If an operand is a constant integer, we might as well\n-\t\t convert it since that is more efficient than using a SUBREG,\n-\t\t unlike the case for other operands.  Similarly for\n-\t\t SUBREGs that were made due to promoted objects.*/\n-\n-\t      if (no_extend && GET_MODE (xop0) != VOIDmode\n-\t\t&& ! (GET_CODE (xop0) == SUBREG\n-\t\t      && SUBREG_PROMOTED_VAR_P (xop0)))\n-\t\txop0 = gen_rtx (SUBREG, wider_mode,\n-\t\t\t\tforce_reg (GET_MODE (xop0), xop0), 0);\n-\t      else\n-\t\txop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n-\n-\t      if (no_extend && GET_MODE (xop1) != VOIDmode\n-\t\t&& ! (GET_CODE (xop1) == SUBREG\n-\t\t      && SUBREG_PROMOTED_VAR_P (xop1)))\n-\t\txop1 = gen_rtx (SUBREG, wider_mode,\n-\t\t\t\tforce_reg (GET_MODE (xop1), xop1), 0);\n-\t      else\n-\t\txop1 = convert_to_mode (wider_mode, xop1, unsignedp);\n+\t      xop0 = widen_operand (xop0, wider_mode, unsignedp, no_extend);\n+\t      xop1 = widen_operand (xop1, wider_mode, unsignedp, no_extend);\n \n \t      temp = expand_binop (wider_mode, binoptab, xop0, xop1, NULL_RTX,\n \t\t\t\t   unsignedp, methods);\n@@ -1728,17 +1723,12 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \n \t    /* For certain operations, we need not actually extend\n \t       the narrow operand, as long as we will truncate the\n-\t       results to the same narrowness.  But it is faster to\n-\t       convert a SUBREG due to mode promotion.  */\n-\n-\t    if ((unoptab == neg_optab || unoptab == one_cmpl_optab)\n-\t\t&& GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD\n-\t\t&& class == MODE_INT\n-\t\t&& ! (GET_CODE (xop0) == SUBREG\n-\t\t      && SUBREG_PROMOTED_VAR_P (xop0)))\n-\t      xop0 = gen_rtx (SUBREG, wider_mode, force_reg (mode, xop0), 0);\n-\t    else\n-\t      xop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\t       results to the same narrowness.  */\n+\n+\t    xop0 = widen_operand (xop0, wider_mode, unsignedp,\n+\t\t\t\t  (unoptab == neg_optab\n+\t\t\t\t   || unoptab == one_cmpl_optab)\n+\t\t\t\t  && class == MODE_INT);\n \t      \n \t    temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\tunsignedp);\n@@ -1876,14 +1866,10 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \t\t the narrow operand, as long as we will truncate the\n \t\t results to the same narrowness.  */\n \n-\t      if ((unoptab == neg_optab || unoptab == one_cmpl_optab)\n-\t\t  && GET_MODE_SIZE (wider_mode) <= UNITS_PER_WORD\n-\t\t  && class == MODE_INT\n-\t\t  && ! (GET_CODE (xop0) == SUBREG\n-\t\t\t&& SUBREG_PROMOTED_VAR_P (xop0)))\n-\t\txop0 = gen_rtx (SUBREG, wider_mode, force_reg (mode, xop0), 0);\n-\t      else\n-\t\txop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\t      xop0 = widen_operand (xop0, wider_mode, unsignedp,\n+\t\t\t\t    (unoptab == neg_optab\n+\t\t\t\t     || unoptab == one_cmpl_optab)\n+\t\t\t\t    && class == MODE_INT);\n \t      \n \t      temp = expand_unop (wider_mode, unoptab, xop0, NULL_RTX,\n \t\t\t\t  unsignedp);"}]}