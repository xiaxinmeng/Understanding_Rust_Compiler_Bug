{"sha": "fcae5121154d1c3382b056bcc2c563cedac28e74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNhZTUxMjExNTRkMWMzMzgyYjA1NmJjYzJjNTYzY2VkYWMyOGU3NA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-06T16:53:09Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-10-06T17:03:13Z"}, "message": "Hybrid EVRP and testcases\n\nProvide a hybrid EVRP pass which uses legacy EVRP and adds additonal\nenhancements from the new ranger infrastructure.\nA New option is also provided, -fevrp-mode=\nAnd adjust testcases\n\ngcc/ChangeLog:\n\n2020-10-06  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* flag-types.h (enum evrp_mode): New enumerated type EVRP_MODE_*.\n\t* common.opt (fevrp-mode): New undocumented flag.\n\t* gimple-ssa-evrp.c: Include gimple-range.h\n\t(class rvrp_folder): EVRP folding using ranger exclusively.\n\t(rvrp_folder::rvrp_folder): New.\n\t(rvrp_folder::~rvrp_folder): New.\n\t(rvrp_folder::value_of_expr): New.  Use rangers value_of_expr.\n\t(rvrp_folder::value_on_edge): New.  Use rangers value_on_edge.\n\t(rvrp_folder::value_of_Stmt): New.  Use rangers value_of_stmt.\n\t(rvrp_folder::fold_stmt): New.  Call the simplifier.\n\t(class hybrid_folder): EVRP folding using both engines.\n\t(hybrid_folder::hybrid_folder): New.\n\t(hybrid_folder::~hybrid_folder): New.\n\t(hybrid_folder::fold_stmt): New.  Simplify with one engne, then the\n\tother.\n\t(hybrid_folder::value_of_expr): New.  Use both value routines.\n\t(hybrid_folder::value_on_edge): New.  Use both value routines.\n\t(hybrid_folder::value_of_stmt): New.  Use both value routines.\n\t(hybrid_folder::choose_value): New.  Choose between range_analzyer and\n\trangers values.\n\t(execute_early_vrp): Choose a folder based on flag_evrp_mode.\n\t* vr-values.c (simplify_using_ranges::fold_cond): Try range_of_stmt\n\tfirst to see if it returns a value.\n\t(simplify_using_ranges::simplify_switch_using_ranges): Return true if\n\tany changes were made to the switch.\n\ngcc/testsuite/ChangeLog:\n\n2020-10-06  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* gcc.dg/pr81192.c: Disable EVRP pass.\n\t* gcc.dg/tree-ssa/pr77445-2.c: Ditto.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-6.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Ditto.", "tree": {"sha": "7f1a992410f82963ee9df115586cf45e39a53583", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f1a992410f82963ee9df115586cf45e39a53583"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcae5121154d1c3382b056bcc2c563cedac28e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcae5121154d1c3382b056bcc2c563cedac28e74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcae5121154d1c3382b056bcc2c563cedac28e74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcae5121154d1c3382b056bcc2c563cedac28e74/comments", "author": null, "committer": null, "parents": [{"sha": "90e88fd376bb9ad6223a1f5ccd803d1bd9539b05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90e88fd376bb9ad6223a1f5ccd803d1bd9539b05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90e88fd376bb9ad6223a1f5ccd803d1bd9539b05"}], "stats": {"total": 381, "additions": 365, "deletions": 16}, "files": [{"sha": "e2bd90c450d3ae6b6a8474004e7700558b34b6b9", "filename": "gcc/common.opt", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -2870,6 +2870,37 @@ ftree-vrp\n Common Report Var(flag_tree_vrp) Init(0) Optimization\n Perform Value Range Propagation on trees.\n \n+fevrp-mode=\n+Common Undocumented Joined RejectNegative Enum(evrp_mode) Var(flag_evrp_mode) Init(EVRP_MODE_EVRP_FIRST) Optimization\n+-fevrp-mode=[legacy|ranger|legacy-first|ranger-first|ranger-trace|ranger-debug|trace|debug] Specifies the mode Early VRP should operate in.\n+\n+Enum\n+Name(evrp_mode) Type(enum evrp_mode) UnknownError(unknown evrp mode %qs)\n+\n+EnumValue\n+Enum(evrp_mode) String(legacy) Value(EVRP_MODE_EVRP_ONLY)\n+\n+EnumValue\n+Enum(evrp_mode) String(ranger) Value(EVRP_MODE_RVRP_ONLY)\n+\n+EnumValue\n+Enum(evrp_mode) String(legacy-first) Value(EVRP_MODE_EVRP_FIRST)\n+\n+EnumValue\n+Enum(evrp_mode) String(ranger-first) Value(EVRP_MODE_RVRP_FIRST)\n+\n+EnumValue\n+Enum(evrp_mode) String(ranger-trace) Value(EVRP_MODE_RVRP_TRACE)\n+\n+EnumValue\n+Enum(evrp_mode) String(ranger-debug) Value(EVRP_MODE_RVRP_DEBUG)\n+\n+EnumValue\n+Enum(evrp_mode) String(trace) Value(EVRP_MODE_TRACE)\n+\n+EnumValue\n+Enum(evrp_mode) String(debug) Value(EVRP_MODE_DEBUG)\n+\n fsplit-paths\n Common Report Var(flag_split_paths) Init(0) Optimization\n Split paths leading to loop backedges."}, {"sha": "cd0f7f8f959c18abcf15206f3b0dc22fdd4d23b8", "filename": "gcc/flag-types.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -382,4 +382,17 @@ enum parloops_schedule_type\n   PARLOOPS_SCHEDULE_RUNTIME\n };\n \n+/* EVRP mode.  */\n+enum evrp_mode\n+{\n+  EVRP_MODE_EVRP_FIRST = 0,\n+  EVRP_MODE_EVRP_ONLY = 1,\n+  EVRP_MODE_RVRP_ONLY = 2,\n+  EVRP_MODE_RVRP_FIRST = 3,\n+  EVRP_MODE_TRACE = 4,\n+  EVRP_MODE_DEBUG = 8 | EVRP_MODE_TRACE,\n+  EVRP_MODE_RVRP_TRACE = EVRP_MODE_RVRP_ONLY | EVRP_MODE_TRACE,\n+  EVRP_MODE_RVRP_DEBUG = EVRP_MODE_RVRP_ONLY | EVRP_MODE_DEBUG\n+};\n+\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "6be32d7a3f614b98590294bc1546bb6361a3810f", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 218, "deletions": 3, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -41,6 +41,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfgcleanup.h\"\n #include \"vr-values.h\"\n #include \"gimple-ssa-evrp-analyze.h\"\n+#include \"gimple-range.h\"\n+\n+// This is the classic EVRP folder which uses a dominator walk and pushes\n+// ranges into the next block if it is a single predecessor block.\n \n class evrp_folder : public substitute_and_fold_engine\n {\n@@ -98,12 +102,195 @@ class evrp_folder : public substitute_and_fold_engine\n     m_range_analyzer.set_defs_to_varying (stmt);\n   }\n \n-private:\n+protected:\n   DISABLE_COPY_AND_ASSIGN (evrp_folder);\n   evrp_range_analyzer m_range_analyzer;\n   simplify_using_ranges simplifier;\n };\n \n+// This is a ranger based folder which continues to use the dominator\n+// walk to access the substitute and fold machinery.  Ranges are calculated\n+// on demand.\n+\n+class rvrp_folder : public substitute_and_fold_engine\n+{\n+public:\n+\n+  rvrp_folder () : substitute_and_fold_engine (), m_simplifier ()\n+  { \n+    if (flag_evrp_mode & EVRP_MODE_TRACE)\n+      m_ranger = new trace_ranger ();\n+    else\n+      m_ranger = new gimple_ranger ();\n+    m_simplifier.set_range_query (m_ranger);\n+  }\n+      \n+  ~rvrp_folder ()\n+  {\n+    if (dump_file && (dump_flags & TDF_DETAILS))\n+      m_ranger->dump (dump_file);\n+    delete m_ranger;\n+  }\n+\n+  tree value_of_expr (tree name, gimple *s = NULL) OVERRIDE\n+  {\n+    return m_ranger->value_of_expr (name, s);\n+  }\n+\n+  tree value_on_edge (edge e, tree name) OVERRIDE\n+  {\n+    return m_ranger->value_on_edge (e, name);\n+  }\n+\n+  tree value_of_stmt (gimple *s, tree name = NULL) OVERRIDE\n+  {\n+    return m_ranger->value_of_stmt (s, name);\n+  }\n+\n+  bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n+  {\n+    return m_simplifier.simplify (gsi);\n+  }\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (rvrp_folder);\n+  gimple_ranger *m_ranger;\n+  simplify_using_ranges m_simplifier;\n+};\n+\n+// In a hybrid folder, start with an EVRP folder, and add the required\n+// fold_stmt bits to either try the ranger first or second.\n+//\n+// The 3 value_* routines will always query both EVRP and the ranger for\n+// a result, and ensure they return the same value.  If either returns a value\n+// when the other doesn't, it is flagged in the listing, and the discoverd\n+// value is returned.\n+//\n+// The simplifier is unable to process 2 different sources, thus we try to \n+// use one engine, and if it fails to simplify, try using the other engine.\n+// It is reported when the first attempt fails and the second succeeds.\n+\n+class hybrid_folder : public evrp_folder\n+{\n+public:\n+  hybrid_folder (bool evrp_first)\n+  {\n+    if (flag_evrp_mode & EVRP_MODE_TRACE)\n+      m_ranger = new trace_ranger ();\n+    else\n+      m_ranger = new gimple_ranger ();\n+\n+    if (evrp_first)\n+      {\n+\tfirst = &m_range_analyzer;\n+\tsecond = m_ranger;\n+      }\n+     else\n+      {\n+\tfirst = m_ranger;\n+\tsecond = &m_range_analyzer;\n+      }\n+  }\n+\n+  ~hybrid_folder ()\n+  {\n+    if (dump_file && (dump_flags & TDF_DETAILS))\n+      m_ranger->dump (dump_file);\n+    delete m_ranger;\n+  }\n+\n+  bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n+    {\n+      simplifier.set_range_query (first);\n+      if (simplifier.simplify (gsi))\n+\treturn true;\n+\n+      simplifier.set_range_query (second);\n+      if (simplifier.simplify (gsi))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"EVRP:hybrid: Second query simplifed stmt\\n\");\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  tree value_of_expr (tree name, gimple *) OVERRIDE;\n+  tree value_on_edge (edge, tree name) OVERRIDE;\n+  tree value_of_stmt (gimple *, tree name) OVERRIDE;\n+\n+private:\n+  DISABLE_COPY_AND_ASSIGN (hybrid_folder);\n+  gimple_ranger *m_ranger;\n+  range_query *first;\n+  range_query *second;\n+  tree choose_value (tree evrp_val, tree ranger_val);\n+};\n+\n+\n+tree\n+hybrid_folder::value_of_expr (tree op, gimple *stmt)\n+{\n+  tree evrp_ret = evrp_folder::value_of_expr (op, stmt);\n+  tree ranger_ret = m_ranger->value_of_expr (op, stmt);\n+  return choose_value (evrp_ret, ranger_ret);\n+}\n+\n+tree\n+hybrid_folder::value_on_edge (edge e, tree op)\n+{\n+  tree evrp_ret = evrp_folder::value_on_edge (e, op);\n+  tree ranger_ret = m_ranger->value_on_edge (e, op);\n+  return choose_value (evrp_ret, ranger_ret);\n+}\n+\n+tree\n+hybrid_folder::value_of_stmt (gimple *stmt, tree op) \n+{\n+  tree evrp_ret = evrp_folder::value_of_stmt (stmt, op);\n+  tree ranger_ret = m_ranger->value_of_stmt (stmt, op);\n+  return choose_value (evrp_ret, ranger_ret);\n+}\n+\n+// Given trees returned by EVRP and Ranger, choose/report the value to use\n+// by the folder.\n+\n+tree\n+hybrid_folder::choose_value (tree evrp_val, tree ranger_val)\n+{\n+  if (!ranger_val)\n+    {\n+      // If neither returned a value, return NULL_TREE.\n+      if (!evrp_val)\n+\treturn NULL_TREE;\n+\n+      // Otherwise EVRP found something.\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"EVRP:hybrid: EVRP found singleton \");\n+\t  print_generic_expr (dump_file, evrp_val);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return evrp_val;\n+    }\n+\n+  // Otherwise ranger found a value, if they match we're good.\n+  if (evrp_val && !compare_values (evrp_val, ranger_val))\n+    return evrp_val;\n+\n+  // We should never get different singletons.\n+  gcc_checking_assert (!evrp_val);\n+\n+  // Now ranger has found a value, but EVRP did not.\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"EVRP:hybrid: RVRP found singleton \");\n+      print_generic_expr (dump_file, ranger_val);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  return ranger_val;\n+}\n+\n /* Main entry point for the early vrp pass which is a simplified non-iterative\n    version of vrp where basic blocks are visited in dominance order.  Value\n    ranges discovered in early vrp will also be used by ipa-vrp.  */\n@@ -120,8 +307,36 @@ execute_early_vrp ()\n   scev_initialize ();\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  evrp_folder folder;\n-  folder.substitute_and_fold ();\n+  // only the last 2 bits matter for choosing the folder.\n+  switch (flag_evrp_mode & EVRP_MODE_RVRP_FIRST)\n+    {\n+    case EVRP_MODE_EVRP_ONLY:\n+      {\n+\tevrp_folder folder;\n+\tfolder.substitute_and_fold ();\n+\tbreak;\n+      }\n+    case EVRP_MODE_RVRP_ONLY:\n+      {\n+\trvrp_folder folder;\n+\tfolder.substitute_and_fold ();\n+\tbreak;\n+      }\n+    case EVRP_MODE_EVRP_FIRST:\n+      {\n+\thybrid_folder folder (true);\n+\tfolder.substitute_and_fold ();\n+\tbreak;\n+      }\n+    case EVRP_MODE_RVRP_FIRST:\n+      {\n+\thybrid_folder folder (false);\n+\tfolder.substitute_and_fold ();\n+\tbreak;\n+      }\n+    default:\n+      gcc_unreachable ();\n+    }\n \n   scev_finalize ();\n   loop_optimizer_finalize ();"}, {"sha": "71bbc13a0e91e56b87bc69f579250b65fc1e6a06", "filename": "gcc/testsuite/gcc.dg/pr81192.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81192.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81192.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr81192.c?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -1,4 +1,20 @@\n-/* { dg-options \"-Os -fdump-tree-pre-details\" } */\n+/* { dg-options \"-Os -fdump-tree-pre-details -fdisable-tree-evrp\" } */\n+\n+/* Disable tree-evrp because the new version of evrp sees\n+<bb 3> :\n+  if (j_8(D) != 2147483647)\n+    goto <bb 4>; [50.00%]\n+  else\n+    goto <bb 5>; [50.00%]\n+<bb 4> :\n+  iftmp.2_11 = j_8(D) + 1;\n+<bb 5> :\n+  # iftmp.2_12 = PHI <j_8(D)(3), iftmp.2_11(4)>\n+\n+EVRP now recognizes a constant can be propagated into the 3->5 edge and\n+produces\n+  # iftmp.2_12 = PHI <2147483647(3), iftmp.2_11(4)> \n+which causes the situation being tested to dissapear before we get to PRE.  */\n \n #if __SIZEOF_INT__ == 2\n #define unsigned __UINT32_TYPE__"}, {"sha": "cf74e156109cf5cefd5939c08ab0840ae1bdaf3b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr77445-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr77445-2.c?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread-details-blocks-stats\" } */\n+/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-thread-details-blocks-stats\" } */\n typedef enum STATES {\n \tSTART=0,\n \tINVALID,"}, {"sha": "16a9ef4e28aa2f831c55fd0b4429853a2a9b2705", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -1,7 +1,41 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-thread1-details -fdump-tree-thread2-details\" } */\n-/* { dg-final { scan-tree-dump-times \"FSM\" 3 \"thread1\" } } */\n-/* { dg-final { scan-tree-dump-times \"FSM\" 5 \"thread2\" } } */\n+\n+/* All the threads in the thread1 dump start on a X->BB12 edge, as can\n+   be seen in the dump:\n+\n+     Registering FSM jump thread: (x, 12) incoming edge; ...\n+     etc\n+     etc\n+\n+   Before the new evrp, we were threading paths that started at the\n+   following edges:\n+\n+      Registering FSM jump thread: (10, 12) incoming edge\n+      Registering FSM jump thread:  (6, 12) incoming edge\n+      Registering FSM jump thread:  (9, 12) incoming edge\n+\n+   This was because the PHI at BB12 had constant values coming in from\n+   BB10, BB6, and BB9:\n+\n+   # state_10 = PHI <state_11(7), 0(10), state_11(5), 1(6), state_11(8), 2(9), state_11(11)>\n+\n+   Now with the new evrp, we get:\n+\n+   # state_10 = PHI <0(7), 0(10), state_11(5), 1(6), 0(8), 2(9), 1(11)>\n+\n+   Thus, we have 3 more paths that are known to be constant and can be\n+   threaded.  Which means that by the second threading pass, we can\n+   only find one profitable path.\n+\n+   For the record, all these extra constants are better paths coming\n+   out of switches.  For example:\n+\n+     SWITCH_BB -> BBx -> BBy -> BBz -> PHI\n+\n+   We now know the value of the switch index at PHI.  */\n+/* { dg-final { scan-tree-dump-times \"FSM\" 6 \"thread1\" } } */\n+/* { dg-final { scan-tree-dump-times \"FSM\" 1 \"thread2\" } } */\n \n int sum0, sum1, sum2, sum3;\n int foo (char *s, char **ret)"}, {"sha": "bad5bc1d00379e35302b79928ed999af5e06157f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -1,20 +1,31 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-thread1-stats -fdump-tree-thread2-stats -fdump-tree-dom2-stats -fdump-tree-thread3-stats -fdump-tree-dom3-stats -fdump-tree-vrp2-stats -fno-guess-branch-probability\" } */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 16\"  \"thread1\" } } */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 9\" \"thread2\" } } */\n+\n+/* Here we have the same issue as was commented in ssa-dom-thread-6.c.\n+   The PHI coming into the threader has a lot more constants, so the\n+   threader can thread more paths.\n+\n+$ diff clean/a.c.105t.mergephi2 a.c.105t.mergephi2 \n+252c252\n+<   # s_50 = PHI <s_49(10), 5(14), s_51(18), s_51(22), 1(26), 1(29), 1(31), s_51(5), 4(12), 1(15), 5(17), 1(19), 3(21), 1(23), 6(25), 7(28), s_51(30)>\n+---\n+>   # s_50 = PHI <s_49(10), 5(14), 4(18), 5(22), 1(26), 1(29), 1(31), s_51(5), 4(12), 1(15), 5(17), 1(19), 3(21), 1(23), 6(25), 7(28), 7(30)>\n+272a273\n+\n+  I spot checked a few and they all have the same pattern.  We are\n+  basically tracking the switch index better through multiple\n+  paths.  */\n+\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 19\"  \"thread1\" } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 8\" \"thread2\" } } */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom2\" } } */\n+\n /* aarch64 has the highest CASE_VALUES_THRESHOLD in GCC.  It's high enough\n    to change decisions in switch expansion which in turn can expose new\n    jump threading opportunities.  Skip the later tests on aarch64.  */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom3\" { target { ! aarch64*-*-* } } } } */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"vrp2\" { target { ! aarch64*-*-* } } } } */\n \n-/* Most architectures get 3 threadable paths here, whereas aarch64 and\n-   possibly others get 5.  We really should rewrite threading tests to\n-   test a specific IL sequence, not gobs of code whose IL can vary\n-   from architecture to architecture.  */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: \\[35\\]\" \"thread3\" } } */\n-\n enum STATE {\n   S0=0,\n   SI,"}, {"sha": "88aa672466ce8a456d30ae8f1b3e9e69c621da14", "filename": "gcc/vr-values.c", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcae5121154d1c3382b056bcc2c563cedac28e74/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=fcae5121154d1c3382b056bcc2c563cedac28e74", "patch": "@@ -3606,6 +3606,35 @@ simplify_using_ranges::fold_cond (gcond *cond)\n      some point we should merge all variants of this code.  */\n   edge taken_edge;\n   vrp_visit_cond_stmt (cond, &taken_edge);\n+\n+  int_range_max r;\n+  if (query->range_of_stmt (r, cond) && r.singleton_p ())\n+    {\n+      // COND has already been folded if arguments are constant.\n+      if (TREE_CODE (gimple_cond_lhs (cond)) != SSA_NAME\n+\t  && TREE_CODE (gimple_cond_rhs (cond)) != SSA_NAME)\n+\treturn false;\n+\n+      if (r.zero_p ())\n+\t{\n+\t  gcc_checking_assert (!taken_edge\n+\t\t\t       || taken_edge->flags & EDGE_FALSE_VALUE);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) && !taken_edge)\n+\t    fprintf (dump_file, \"\\nPredicate evaluates to: 0\\n\");\n+\t  gimple_cond_make_false (cond);\n+\t}\n+      else\n+\t{\n+\t  gcc_checking_assert (!taken_edge\n+\t\t\t       || taken_edge->flags & EDGE_TRUE_VALUE);\n+\t  if (dump_file && (dump_flags & TDF_DETAILS) && !taken_edge)\n+\t    fprintf (dump_file, \"\\nPredicate evaluates to: 1\\n\");\n+\t  gimple_cond_make_true (cond);\n+\t}\n+      update_stmt (cond);\n+      return true;\n+    }\n+\n   if (taken_edge)\n     {\n       if (taken_edge->flags & EDGE_TRUE_VALUE)\n@@ -3947,7 +3976,7 @@ simplify_using_ranges::simplify_switch_using_ranges (gswitch *stmt)\n   su.stmt = stmt;\n   su.vec = vec2;\n   to_update_switch_stmts.safe_push (su);\n-  return false;\n+  return true;\n }\n \n void"}]}