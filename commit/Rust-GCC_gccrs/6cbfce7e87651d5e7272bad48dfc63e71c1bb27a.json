{"sha": "6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiZmNlN2U4NzY1MWQ1ZTcyNzJiYWQ0OGRmYzYzZTcxYzFiYjI3YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:48:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-27T09:48:45Z"}, "message": "[multiple changes]\n\n2017-04-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model): Adapt to\n\tmodifications in functional containers.\n\t* a-cofuba.ads, a-cofuma.ads, a-cofuse.ads, a-cofuve.ads Reformat\n\tto improve readablity. Subprograms are separated between basic\n\toperations, constructors and properties. Universally quantified\n\tformulas in contracts are factorized in independant functions\n\twith a name and a comment.  Names of parameters are improved.\n\n2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_spark.adb, sem_elab.adb: Minor reformatting and typo fix.\n\n2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_res.adb (Resolve_Type_Conversion): Do not\n\tinstall a predicate check here since this is already done during\n\tthe expansion phase. Verify whether the operand satisfies the\n\tstatic predicate (if any) of the target type.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Do\n\tnot install a predicate check if the object is initialized by\n\tmeans of a type conversion because the conversion is subjected\n\tto the same check.\n\n2017-04-27  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise.c (__gnat_builtin_longjmp): Remove.\n\t(__gnat_bracktrace):\n\tAdd a dummy definition for the compiler (__gnat_eh_personality,\n\t__gnat_rcheck_04, __gnat_rcheck_10) (__gnat_rcheck_19,\n\t__gnat_rcheck_20, __gnat_rcheck_21) (__gnat_rcheck_30,\n\t__gnat_rcheck_31, __gnat_rcheck_32): Likewise.\n\t* a-exexpr.adb: Renamed from a-exexpr-gcc.adb\n\t* a-except.ads, a-except.adb: Renamed from a-except-2005.ads\n\tand a-except-2005.adb.\n\t* raise-gcc.c: Allow build in compiler, compiled as a C++\n\tfile.\n\t(__gnat_Unwind_ForcedUnwind): Adjust prototype.\n\t(db): Constify msg_format.\n\t(get_call_site_action_for): Don't use void arithmetic.\n\t* system.ads (Frontend_Exceptions): Set to False.\n\t(ZCX_By_Default): Set to True.\n\t(GCC_ZC_Support): Set to True.\n\t* gcc-interface/Makefile.in: No more variants for a-exexpr.adb and\n\ta-except.ad[sb].\n\t* gcc-interface/Make-lang.in: Add support for backend zcx exceptions\n\tin gnat1 and gnatbind.\n\t* gnat1, gnatbind: link with raise-gcc.o, a-exctra.o, s-addima.o,\n\ts-excmac.o, s-imgint.o, s-traceb.o, s-trasym.o, s-wchstw.o\n\t* s-excmac.ads, s-excmac.adb: Copy of variants.\n\t* a-except.o: Adjust preequisites.\n\tAdd handling of s-excmac-arm.adb and s-excmac-gcc.adb.\n\nFrom-SVN: r247301", "tree": {"sha": "1b8bba33017bf56868f71410e9917dde0ac8c621", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b8bba33017bf56868f71410e9917dde0ac8c621"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/comments", "author": null, "committer": null, "parents": [{"sha": "de3b531c9aa93592f98ebd99c6b35be632e3c1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de3b531c9aa93592f98ebd99c6b35be632e3c1b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de3b531c9aa93592f98ebd99c6b35be632e3c1b3"}], "stats": {"total": 6596, "additions": 2497, "deletions": 4099}, "files": [{"sha": "8bffbec10ff6f8444c9cde8488183f4b6b80e344", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -1,3 +1,87 @@\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model): Adapt to\n+\tmodifications in functional containers.\n+\t* a-cofuba.ads, a-cofuma.ads, a-cofuse.ads, a-cofuve.ads Reformat\n+\tto improve readablity. Subprograms are separated between basic\n+\toperations, constructors and properties. Universally quantified\n+\tformulas in contracts are factorized in independant functions\n+\twith a name and a comment.  Names of parameters are improved.\n+\n+2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_spark.adb, sem_elab.adb: Minor reformatting and typo fix.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Type_Conversion): Do not\n+\tinstall a predicate check here since this is already done during\n+\tthe expansion phase. Verify whether the operand satisfies the\n+\tstatic predicate (if any) of the target type.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Do\n+\tnot install a predicate check if the object is initialized by\n+\tmeans of a type conversion because the conversion is subjected\n+\tto the same check.\n+\n+2017-04-27  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise.c (__gnat_builtin_longjmp): Remove.\n+\t(__gnat_bracktrace):\n+\tAdd a dummy definition for the compiler (__gnat_eh_personality,\n+\t__gnat_rcheck_04, __gnat_rcheck_10) (__gnat_rcheck_19,\n+\t__gnat_rcheck_20, __gnat_rcheck_21) (__gnat_rcheck_30,\n+\t__gnat_rcheck_31, __gnat_rcheck_32): Likewise.\n+\t* a-exexpr.adb: Renamed from a-exexpr-gcc.adb\n+\t* a-except.ads, a-except.adb: Renamed from a-except-2005.ads\n+\tand a-except-2005.adb.\n+\t* raise-gcc.c: Allow build in compiler, compiled as a C++\n+\tfile.\n+\t(__gnat_Unwind_ForcedUnwind): Adjust prototype.\n+\t(db): Constify msg_format.\n+\t(get_call_site_action_for): Don't use void arithmetic.\n+\t* system.ads (Frontend_Exceptions): Set to False.\n+\t(ZCX_By_Default): Set to True.\n+\t(GCC_ZC_Support): Set to True.\n+\t* gcc-interface/Makefile.in: No more variants for a-exexpr.adb and\n+\ta-except.ad[sb].\n+\t* gcc-interface/Make-lang.in: Add support for backend zcx exceptions\n+\tin gnat1 and gnatbind.\n+\t* gnat1, gnatbind: link with raise-gcc.o, a-exctra.o, s-addima.o,\n+\ts-excmac.o, s-imgint.o, s-traceb.o, s-trasym.o, s-wchstw.o\n+\t* s-excmac.ads, s-excmac.adb: Copy of variants.\n+\t* a-except.o: Adjust preequisites.\n+\tAdd handling of s-excmac-arm.adb and s-excmac-gcc.adb.\n+\n+2017-04-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.adb, a-cfdlli.ads (Formal_Model): Adapt to\n+\tmodifications in functional containers.\n+\t* a-cofuba.ads, a-cofuma.ads, a-cofuse.ads, a-cofuve.ads Reformat\n+\tto improve readablity. Subprograms are separated between basic\n+\toperations, constructors and properties. Universally quantified\n+\tformulas in contracts are factorized in independant functions\n+\twith a name and a comment.  Names of parameters are improved.\n+\n+2017-04-27  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* exp_spark.adb, sem_elab.adb: Minor reformatting and typo fix.\n+\n+2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Type_Conversion): Do not\n+\tinstall a predicate check here since this is already done during\n+\tthe expansion phase. Verify whether the operand satisfies the\n+\tstatic predicate (if any) of the target type.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Do\n+\tnot install a predicate check if the object is initialized by\n+\tmeans of a type conversion because the conversion is subjected\n+\tto the same check.\n+\n+2017-04-27  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* a-except.ads, a-except.adb, a-exexpr.adb: Removed (will be\n+\treplaced by their variants).\n+\n 2017-04-27  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_prag.adb, a-cofuse.adb, a-cofuse.ads, einfo.adb, sem_prag.adb,"}, {"sha": "d799dccb3fe1ef4df4f2f8339eda03903f9e6406", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 56, "deletions": 125, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -496,73 +496,19 @@ is\n \n       procedure Lift_Abstraction_Level (Container : List) is null;\n \n-      -------------------------\n-      -- M_Elements_Contains --\n-      -------------------------\n-\n-      function M_Elements_Contains\n-        (S   : M.Sequence;\n-         Fst : Positive_Count_Type;\n-         Lst : Count_Type;\n-         E   : Element_Type)\n-         return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if Element (S, I) = E then\n-               return True;\n-            end if;\n-         end loop;\n-         return False;\n-      end M_Elements_Contains;\n-\n-      --------------------\n-      -- M_Elements_Cst --\n-      --------------------\n-\n-      function M_Elements_Cst\n-        (S   : M.Sequence;\n-         Fst : Positive_Count_Type;\n-         Lst : Count_Type;\n-         E   : Element_Type)\n-         return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if Element (S, I) /= E then\n-               return False;\n-            end if;\n-         end loop;\n-         return True;\n-      end M_Elements_Cst;\n-\n-      ----------------------\n-      -- M_Elements_Equal --\n-      ----------------------\n-\n-      function M_Elements_Equal\n-        (S1, S2   : M.Sequence;\n-         Fst      : Positive_Count_Type;\n-         Lst      : Count_Type)\n-         return Boolean\n-      is\n-      begin\n-         return M_Elements_Shifted (S1, S2, Fst, Lst, 0);\n-      end M_Elements_Equal;\n-\n       -------------------------\n       -- M_Elements_Reversed --\n       -------------------------\n \n-      function M_Elements_Reversed (S1, S2 : M.Sequence) return Boolean is\n-         L : constant Count_Type := M.Length (S1);\n+      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean is\n+         L : constant Count_Type := M.Length (Left);\n       begin\n-         if L /= M.Length (S2) then\n+         if L /= M.Length (Right) then\n             return False;\n          end if;\n \n          for I in 1 .. L loop\n-            if Element (S1, I) /= Element (S2, L - I + 1)\n+            if Element (Left, I) /= Element (Right, L - I + 1)\n             then\n                return False;\n             end if;\n@@ -571,36 +517,16 @@ is\n          return True;\n       end M_Elements_Reversed;\n \n-      ------------------------\n-      -- M_Elements_Shifted --\n-      ------------------------\n-\n-      function M_Elements_Shifted\n-        (S1, S2   : M.Sequence;\n-         Fst      : Positive_Count_Type;\n-         Lst      : Count_Type;\n-         Offset   : Count_Type'Base := 1)\n-         return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if Element (S1, I) /= Element (S2, I + Offset) then\n-               return False;\n-            end if;\n-         end loop;\n-         return True;\n-      end M_Elements_Shifted;\n-\n       -------------------------\n       -- M_Elements_Shuffled --\n       -------------------------\n \n       function M_Elements_Shuffle\n-        (S1, S2   : M.Sequence;\n-         Fst      : Positive_Count_Type;\n-         Lst      : Count_Type;\n-         Offset   : Count_Type'Base)\n-         return Boolean\n+        (Left   : M.Sequence;\n+         Right  : M.Sequence;\n+         Fst    : Positive_Count_Type;\n+         Lst    : Count_Type;\n+         Offset : Count_Type'Base) return Boolean\n       is\n       begin\n          for I in Fst .. Lst loop\n@@ -609,7 +535,7 @@ is\n                J     : Count_Type := Fst;\n             begin\n                while not Found and J <= Lst loop\n-                  if Element (S1, I) = Element (S2, J + Offset) then\n+                  if Element (Left, I) = Element (Right, J + Offset) then\n                      Found := True;\n                   end if;\n                   J := J + 1;\n@@ -628,21 +554,21 @@ is\n       ------------------------\n \n       function M_Elements_Swapped\n-        (S1, S2 : M.Sequence;\n-         X, Y   : Positive_Count_Type)\n-      return Boolean\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X, Y  : Positive_Count_Type) return Boolean\n       is\n       begin\n-         if M.Length (S1) /= M.Length (S2)\n-           or else Element (S1, X) /= Element (S2, Y)\n-           or else Element (S1, Y) /= Element (S2, X)\n+         if M.Length (Left) /= M.Length (Right)\n+           or else Element (Left, X) /= Element (Right, Y)\n+           or else Element (Left, Y) /= Element (Right, X)\n          then\n             return False;\n          end if;\n \n-         for I in 1 .. M.Length (S1) loop\n+         for I in 1 .. M.Length (Left) loop\n             if I /= X and then I /= Y\n-              and then Element (S1, I) /= Element (S2, I)\n+              and then Element (Left, I) /= Element (Right, I)\n             then\n                return False;\n             end if;\n@@ -673,22 +599,25 @@ is\n       -----------------------\n \n       function Mapping_Preserved\n-        (S1, S2 : M.Sequence;\n-         M1, M2 : P.Map) return Boolean is\n-\n+        (M_Left  : M.Sequence;\n+         M_Right : M.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n+      is\n       begin\n-         for C of M1 loop\n-            if not P.Mem (M2, C)\n-              or else P.Get (M1, C) > M.Length (S1)\n-              or else P.Get (M2, C) > M.Length (S2)\n-              or else M.Get (S1, P.Get (M1, C)) /= M.Get (S2, P.Get (M2, C))\n+         for C of P_Left loop\n+            if not P.Has_Key (P_Right, C)\n+              or else P.Get (P_Left, C) > M.Length (M_Left)\n+              or else P.Get (P_Right, C) > M.Length (M_Right)\n+              or else M.Get (M_Left, P.Get (P_Left, C))\n+                   /= M.Get (M_Right, P.Get (P_Right, C))\n             then\n                return False;\n             end if;\n          end loop;\n \n-         for C of M2 loop\n-            if not P.Mem (M1, C) then\n+         for C of P_Right loop\n+            if not P.Has_Key (P_Left, C) then\n                return False;\n             end if;\n          end loop;\n@@ -708,7 +637,7 @@ is\n       is\n       begin\n          for Cu of Small loop\n-            if not P.Mem (Big, Cu) then\n+            if not P.Has_Key (Big, Cu) then\n                return False;\n             end if;\n          end loop;\n@@ -718,18 +647,18 @@ is\n                Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n             begin\n                if Pos < Cut then\n-                  if not P.Mem (Small, Cu) or else Pos /= P.Get (Small, Cu)\n+                  if not P.Has_Key (Small, Cu) or else Pos /= P.Get (Small, Cu)\n                   then\n                      return False;\n                   end if;\n                elsif Pos >= Cut + Count then\n-                  if not P.Mem (Small, Cu)\n+                  if not P.Has_Key (Small, Cu)\n                     or else Pos /= P.Get (Small, Cu) + Count\n                   then\n                      return False;\n                   end if;\n                else\n-                  if P.Mem (Small, Cu) then\n+                  if P.Has_Key (Small, Cu) then\n                      return False;\n                   end if;\n                end if;\n@@ -743,31 +672,33 @@ is\n       -------------------------\n \n       function P_Positions_Swapped\n-        (M1, M2 : P.Map;\n-         C1, C2 : Cursor) return Boolean\n+        (Left  : P.Map;\n+         Right : P.Map;\n+         X, Y  : Cursor) return Boolean\n       is\n       begin\n-         if not P.Mem (M1, C1) or not P.Mem (M1, C2)\n-           or not P.Mem (M2, C1) or not P.Mem (M2, C2)\n+         if not P.Has_Key (Left, X) or not P.Has_Key (Left, Y)\n+           or not P.Has_Key (Right, X) or not P.Has_Key (Right, Y)\n          then\n             return False;\n          end if;\n \n-         if P.Get (M1, C1) /= P.Get (M2, C2)\n-             or P.Get (M1, C2) /= P.Get (M2, C1)\n+         if P.Get (Left, X) /= P.Get (Right, Y)\n+             or P.Get (Left, Y) /= P.Get (Right, X)\n          then\n             return False;\n          end if;\n \n-         for C of M1 loop\n-            if not P.Mem (M2, C) then\n+         for C of Left loop\n+            if not P.Has_Key (Right, C) then\n                return False;\n             end if;\n          end loop;\n \n-         for C of M2 loop\n-            if not P.Mem (M1, C)\n-              or else (C /= C1 and C /= C2 and P.Get (M1, C) /= P.Get (M2, C))\n+         for C of Right loop\n+            if not P.Has_Key (Left, C)\n+              or else (C /= X and C /= Y\n+                       and P.Get (Left, C) /= P.Get (Right, C))\n             then\n                return False;\n             end if;\n@@ -788,7 +719,7 @@ is\n       is\n       begin\n          for Cu of Small loop\n-            if not P.Mem (Big, Cu) then\n+            if not P.Has_Key (Big, Cu) then\n                return False;\n             end if;\n          end loop;\n@@ -798,13 +729,13 @@ is\n                Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n             begin\n                if Pos < Cut then\n-                  if not P.Mem (Small, Cu) or else Pos /= P.Get (Small, Cu)\n+                  if not P.Has_Key (Small, Cu) or else Pos /= P.Get (Small, Cu)\n                   then\n                      return False;\n                   end if;\n                elsif Pos >= Cut + Count then\n                   return False;\n-               elsif P.Mem (Small, Cu) then\n+               elsif P.Has_Key (Small, Cu) then\n                   return False;\n                end if;\n             end;\n@@ -907,18 +838,18 @@ is\n       -- M_Elements_Sorted --\n       -----------------------\n \n-      function M_Elements_Sorted (S : M.Sequence) return Boolean is\n+      function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n       begin\n-         if M.Length (S) = 0 then\n+         if M.Length (Container) = 0 then\n             return True;\n          end if;\n \n          declare\n-            E1 : Element_Type := Element (S, 1);\n+            E1 : Element_Type := Element (Container, 1);\n          begin\n-            for I in 2 .. M.Length (S) loop\n+            for I in 2 .. M.Length (Container) loop\n                declare\n-                  E2 : constant Element_Type := Element (S, I);\n+                  E2 : constant Element_Type := Element (Container, I);\n                begin\n                   if E2 < E1 then\n                      return False;"}, {"sha": "0fce67383e0c957e91cd9c0ed554a9d6b641b1a3", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 301, "deletions": 339, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -71,120 +71,59 @@ is\n       function \"<\" (Left, Right : M.Sequence) return Boolean renames M.\"<\";\n       function \"<=\" (Left, Right : M.Sequence) return Boolean renames M.\"<=\";\n \n-      function M_Elements_Contains\n-        (S   : M.Sequence;\n-         Fst : Positive_Count_Type;\n-         Lst : Count_Type;\n-         E   : Element_Type)\n-      return Boolean\n-      --  E appears in the slice from Fst to Lst in S\n-      with\n-        Global => null,\n-        Pre    => Lst <= M.Length (S),\n-        Post   =>\n-          M_Elements_Contains'Result =\n-            (for some I in Fst .. Lst => Element (S, I) = E);\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Contains);\n-\n-      function M_Elements_Cst\n-        (S   : M.Sequence;\n-         Fst : Positive_Count_Type;\n-         Lst : Count_Type;\n-         E   : Element_Type)\n-      return Boolean\n-      --  Every element of the slice from Fst to Lst in S is E.\n-      with\n-        Global => null,\n-        Pre    => Lst <= M.Length (S),\n-        Post   =>\n-          M_Elements_Cst'Result =\n-            (for all I in Fst .. Lst => Element (S, I) = E);\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Cst);\n-\n-      function M_Elements_Equal\n-        (S1, S2 : M.Sequence;\n-         Fst    : Positive_Count_Type;\n-         Lst    : Count_Type)\n-      return Boolean\n-      --  The slice from Fst to Lst is the same in S1 and S2\n-      with\n-        Global => null,\n-        Pre    => Lst <= M.Length (S1) and Lst <= M.Length (S2),\n-        Post   =>\n-          M_Elements_Equal'Result =\n-            (for all I in Fst .. Lst => Element (S1, I) = Element (S2, I));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Equal);\n-\n       function M_Elements_Shuffle\n-        (S1, S2 : M.Sequence;\n+        (Left   : M.Sequence;\n+         Right  : M.Sequence;\n          Fst    : Positive_Count_Type;\n          Lst    : Count_Type;\n          Offset : Count_Type'Base)\n       return Boolean\n-      --  The slice from Fst to Lst in S1 contains the same elements than the\n-      --  same slide shifted by Offset in S2\n+      --  The slice from Fst to Lst in Left contains the same elements than the\n+      --  same slide shifted by Offset in Right\n       with\n         Global => null,\n         Pre    =>\n-          Lst <= M.Length (S1)\n-            and Offset in 1 - Fst .. M.Length (S2) - Lst,\n+          Lst <= M.Length (Left)\n+            and Offset in 1 - Fst .. M.Length (Right) - Lst,\n         Post   =>\n           M_Elements_Shuffle'Result =\n           (for all J in Fst + Offset .. Lst + Offset =>\n              (for some I in Fst .. Lst =>\n-                    Element (S1, I) = Element (S2, J)));\n+                    Element (Left, I) = Element (Right, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Shuffle);\n \n-      function M_Elements_Reversed (S1, S2 : M.Sequence) return Boolean\n-      --  S2 is S1 in reverse order\n+      function M_Elements_Reversed (Left, Right : M.Sequence) return Boolean\n+      --  Right is Left in reverse order\n       with\n         Global => null,\n         Post   =>\n           M_Elements_Reversed'Result =\n-              (M.Length (S1) = M.Length (S2)\n-               and (for all I in 1 .. M.Length (S1) =>\n-                   Element (S1, I) = Element (S2, M.Length (S1) - I + 1))\n-               and (for all I in 1 .. M.Length (S1) =>\n-                   Element (S2, I) = Element (S1, M.Length (S1) - I + 1)));\n+              (M.Length (Left) = M.Length (Right)\n+               and\n+                 (for all I in 1 .. M.Length (Left) =>\n+                      Element (Left, I)\n+                    = Element (Right, M.Length (Left) - I + 1))\n+               and\n+                 (for all I in 1 .. M.Length (Left) =>\n+                      Element (Right, I)\n+                    = Element (Left, M.Length (Left) - I + 1)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n \n-      function M_Elements_Shifted\n-        (S1, S2   : M.Sequence;\n-         Fst      : Positive_Count_Type;\n-         Lst      : Count_Type;\n-         Offset   : Count_Type'Base := 1)\n-      return Boolean\n-      --  The slice from Fst to Lst in S1 has been shifted by Offset in S2.\n-      with\n-          Global => null,\n-        Pre    =>\n-          Lst <= M.Length (S1)\n-            and Offset in 1 - Fst .. M.Length (S2) - Lst,\n-        Post   =>\n-          M_Elements_Shifted'Result =\n-            ((for all I in Fst .. Lst =>\n-                      Element (S1, I) = Element (S2, I + Offset))\n-             and (for all I in Fst + Offset .. Lst + Offset =>\n-                          Element (S1, I - Offset) = Element (S2, I)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Shifted);\n-\n       function M_Elements_Swapped\n-        (S1, S2 : M.Sequence;\n-         X, Y   : Positive_Count_Type)\n+        (Left  : M.Sequence;\n+         Right : M.Sequence;\n+         X, Y  : Positive_Count_Type)\n       return Boolean\n-      --  Elements stored at X and Y are reversed in S1 and S2\n+      --  Elements stored at X and Y are reversed in Left and Right\n       with\n         Global => null,\n-        Pre    => X <= M.Length (S1) and Y <= M.Length (S1),\n+        Pre    => X <= M.Length (Left) and Y <= M.Length (Left),\n         Post   =>\n           M_Elements_Swapped'Result =\n-            (M.Length (S1) = M.Length (S2)\n-             and Element (S1, X) = Element (S2, Y)\n-             and Element (S1, Y) = Element (S2, X)\n-             and\n-               (for all I in 1 .. M.Length (S1) =>\n-                 (if I /= X and I /= Y\n-                    then Element (S1, I) = Element (S2, I))));\n+            (M.Length (Left) = M.Length (Right)\n+             and Element (Left, X) = Element (Right, Y)\n+             and Element (Left, Y) = Element (Right, X)\n+             and M.Equal_Except (Left, Right, X, Y));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n \n       package P is new Ada.Containers.Functional_Maps\n@@ -205,7 +144,7 @@ is\n           P_Positions_Shifted'Result =\n \n          --  Big contains all cursors of Small\n-        ((for all I of Small => P.Mem (Big, I))\n+        (P.Keys_Included (Small, Big)\n \n          --  Cursors located before Cut are not moved, cursors located after\n          --  are shifted by Count.\n@@ -218,28 +157,25 @@ is\n          --  New cursors of Big (if any) are between Cut and Cut - 1 + Count\n          and\n            (for all I of Big =>\n-                 P.Mem (Small, I)\n+                 P.Has_Key (Small, I)\n               or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n \n       function P_Positions_Swapped\n-        (M1, M2 : P.Map;\n-         C1, C2 : Cursor) return Boolean\n-      --  M1 and M2 contain the same cursors, but the positions of C1 and C2\n+        (Left  : P.Map;\n+         Right : P.Map;\n+         X, Y  : Cursor) return Boolean\n+      --  Left and Right contain the same cursors, but the positions of X and Y\n       --  are reversed.\n       with\n         Ghost,\n         Global => null,\n         Post   =>\n           P_Positions_Swapped'Result =\n-              ((for all C of M1 => P.Mem (M2, C))\n-               and (for all C of M2 => P.Mem (M1, C))\n-               and\n-                 (for all C of M1 =>\n-                    (if C /= C1 and C /= C2\n-                     then P.Get (M1, C) = P.Get (M2, C)))\n-               and P.Mem (M1, C1) and P.Mem (M1, C2)\n-               and P.Get (M1, C1) = P.Get (M2, C2)\n-               and P.Get (M1, C2) = P.Get (M2, C1));\n+              (P.Same_Keys (Left, Right)\n+               and P.Elements_Equal_Except (Left, Right, X, Y)\n+               and P.Has_Key (Left, X) and P.Has_Key (Left, Y)\n+               and P.Get (Left, X) = P.Get (Right, Y)\n+               and P.Get (Left, Y) = P.Get (Right, X));\n \n       function P_Positions_Truncated\n         (Small : P.Map;\n@@ -252,40 +188,34 @@ is\n         Post   =>\n           P_Positions_Truncated'Result =\n \n-         --  Big contains all cursors of Small\n-        ((for all I of Small => P.Mem (Big, I))\n-\n-         --  The cursors of Small are all bellow Cut\n-         and (for all I of Small => P.Get (Small, I) < Cut)\n-\n-         --  The cursors have the same position in Big and Small\n-         and (for all I of Small => P.Get (Big, I) = P.Get (Small, I))\n+         --  Big contains all cursors of Small at the same position\n+        (Small <= Big\n \n          --  New cursors of Big (if any) are between Cut and Cut - 1 + Count\n          and\n            (for all I of Big =>\n-                P.Mem (Small, I)\n+                P.Has_Key (Small, I)\n              or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n \n       function Mapping_Preserved\n-        (S1, S2 : M.Sequence;\n-         M1, M2 : P.Map) return Boolean\n+        (M_Left  : M.Sequence;\n+         M_Right : M.Sequence;\n+         P_Left  : P.Map;\n+         P_Right : P.Map) return Boolean\n       with\n         Ghost,\n         Global => null,\n         Post   =>\n             (if Mapping_Preserved'Result then\n \n-            --  M1 contains all cursors of M2\n-            (for all I of M2 => P.Mem (M1, I))\n-\n-            --  M2 contains all cursors of M1\n-            and (for all I of M1 => P.Mem (M2, I))\n+             --  Left and Right contain the same cursors\n+             P.Same_Keys (P_Left, P_Right)\n \n-            --  Mappings from cursors to elements induced by S1, M1 and S2, M2\n-            --  are the same.\n-            and (for all I of M1 =>\n-                       M.Get (S1, P.Get (M1, I)) = M.Get (S2, P.Get (M2, I))));\n+             --  Mappings from cursors to elements induced by M_Left, P_Left\n+             --  and M_Right, P_Right are the same.\n+             and (for all C of P_Left =>\n+                          M.Get (M_Left, P.Get (P_Left, C))\n+                        = M.Get (M_Right, P.Get (P_Right, C))));\n \n       function Model (Container : List) return M.Sequence with\n       --  The highlevel model of a list is a sequence of elements. Cursors are\n@@ -302,7 +232,7 @@ is\n \n         Ghost,\n         Global => null,\n-        Post   => not P.Mem (Positions'Result, No_Element)\n+        Post   => not P.Has_Key (Positions'Result, No_Element)\n         --  Positions of cursors are smaller than the container's length.\n         and then\n           (for all I of Positions'Result =>\n@@ -388,12 +318,14 @@ is\n      --  Cursors are preserved.\n      and Positions (Container)'Old = Positions (Container)\n \n-     --  The element at the position of Position in Container is replaced by\n-     --  New_Item.\n-     and M.Is_Set (Model (Container)'Old,\n-                   P.Get (Positions (Container), Position),\n-                   New_Item,\n-                   Model (Container));\n+     --  The element at the position of Position in Container is New_Item\n+     and Element (Model (Container), P.Get (Positions (Container), Position))\n+       = New_Item\n+\n+     --  Other elements are preserved\n+     and M.Equal_Except (Model (Container)'Old,\n+                         Model (Container),\n+                         P.Get (Positions (Container), Position));\n \n    procedure Move (Target : in out List; Source : in out List) with\n      Global => null,\n@@ -417,25 +349,35 @@ is\n \n           --  Positions contains a new mapping from the last cursor of\n           --  Container to its length.\n-          P.Is_Add\n-            (Positions (Container)'Old, Last (Container), Length (Container),\n-             Result => Positions (Container))\n+          P.Get (Positions (Container), Last (Container)) = Length (Container)\n+\n+          --  Other cursors come from Container'Old\n+          and P.Keys_Included_Except\n+            (Left    => Positions (Container),\n+             Right   => Positions (Container)'Old,\n+             New_Key => Last (Container))\n+\n+          --  Cursors of Container'Old keep the same position\n+          and Positions (Container)'Old <= Positions (Container)\n \n           --  Model contains a new element New_Item at the end\n-          and M.Is_Add (Model (Container)'Old, New_Item, Model (Container)),\n+          and Element (Model (Container), Length (Container)) = New_Item\n+\n+          --  Elements of Container'Old are preserved\n+          and Model (Container)'Old <= Model (Container),\n         others              =>\n \n           --  The elements of Container located before Before are preserved.\n-          M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container)'Old, Before) - 1)\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n \n           --  Other elements are shifted by 1.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container)'Old, Before),\n              Lst    => Length (Container)'Old,\n              Offset => 1)\n@@ -468,18 +410,18 @@ is\n        (Before = No_Element =>\n \n           --  The elements of Container are preserved\n-          M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => Length (Container)'Old)\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => Length (Container)'Old)\n \n           --  Container contains Count times New_Item at the end\n-          and M_Elements_Cst\n-            (S   => Model (Container),\n-             Fst => Length (Container)'Old + 1,\n-             Lst => Length (Container),\n-             E   => New_Item)\n+          and M.Constant_Range\n+            (Container => Model (Container),\n+             Fst       => Length (Container)'Old + 1,\n+             Lst       => Length (Container),\n+             Item      => New_Item)\n \n           --  A Count cursors have been inserted at the end of Container\n           and P_Positions_Truncated\n@@ -490,26 +432,27 @@ is\n         others              =>\n \n           --  The elements of Container located before Before are preserved\n-          M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container)'Old, Before) - 1)\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n \n           --  Other elements are shifted by Count.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container)'Old, Before),\n              Lst    => Length (Container)'Old,\n              Offset => Count)\n \n           --  Container contains Count times New_Item after position Before\n-          and M_Elements_Cst\n-            (S   => Model (Container),\n-             Fst => P.Get (Positions (Container)'Old, Before),\n-             Lst => P.Get (Positions (Container)'Old, Before) - 1 + Count,\n-             E   => New_Item)\n+          and M.Constant_Range\n+            (Container => Model (Container),\n+             Fst       => P.Get (Positions (Container)'Old, Before),\n+             Lst       =>\n+               P.Get (Positions (Container)'Old, Before) - 1 + Count,\n+             Item      => New_Item)\n \n           --  Count cursors have been inserted at position Before in Container\n           and P_Positions_Shifted\n@@ -535,24 +478,24 @@ is\n           --  Positions is valid in Container and it is located either before\n           --  Before if it is valid in Container or at the end if it is\n           --  No_Element.\n-          and P.Mem (Positions (Container), Position)\n+          and P.Has_Key (Positions (Container), Position)\n           and (if Before = No_Element\n                then P.Get (Positions (Container), Position)\n                   = Length (Container)\n                else P.Get (Positions (Container), Position)\n                   = P.Get (Positions (Container)'Old, Before))\n \n           --  The elements of Container located before Position are preserved.\n-          and M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container), Position) - 1)\n+          and M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container), Position) - 1)\n \n           --  Other elements are shifted by 1.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container), Position),\n              Lst    => Length (Container)'Old,\n              Offset => 1)\n@@ -590,34 +533,34 @@ is\n           --  Positions is valid in Container and it is located either before\n           --  Before if it is valid in Container or at the end if it is\n           --  No_Element.\n-          P.Mem (Positions (Container), Position)\n+          P.Has_Key (Positions (Container), Position)\n           and (if Before = No_Element\n                then P.Get (Positions (Container), Position)\n                   = Length (Container)'Old + 1\n                else P.Get (Positions (Container), Position)\n                   = P.Get (Positions (Container)'Old, Before))\n \n           --  The elements of Container located before Position are preserved.\n-          and M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container), Position) - 1)\n+          and M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container), Position) - 1)\n \n           --  Other elements are shifted by Count.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container), Position),\n              Lst    => Length (Container)'Old,\n              Offset => Count)\n \n           --  Container contains Count times New_Item after position Position\n-          and M_Elements_Cst\n-            (S   => Model (Container),\n-             Fst => P.Get (Positions (Container), Position),\n-             Lst => P.Get (Positions (Container), Position) - 1 + Count,\n-             E   => New_Item)\n+          and M.Constant_Range\n+            (Container => Model (Container),\n+             Fst       => P.Get (Positions (Container), Position),\n+             Lst       => P.Get (Positions (Container), Position) - 1 + Count,\n+             Item      => New_Item)\n \n           --  Count cursor have been inserted at Position in Container\n           and P_Positions_Shifted\n@@ -636,9 +579,9 @@ is\n        Length (Container) = Length (Container)'Old + 1\n \n           --  Elements are shifted by 1\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => 1,\n              Lst    => Length (Container)'Old,\n              Offset => 1)\n@@ -663,19 +606,19 @@ is\n        Length (Container) = Length (Container)'Old + Count\n \n           --  Elements are shifted by Count.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left     => Model (Container)'Old,\n+             Right     => Model (Container),\n              Fst    => 1,\n              Lst    => Length (Container)'Old,\n              Offset => Count)\n \n           --  Container starts with Count times New_Item\n-          and M_Elements_Cst\n-            (S   => Model (Container),\n-             Fst => 1,\n-             Lst => Count,\n-             E   => New_Item)\n+          and M.Constant_Range\n+            (Container => Model (Container),\n+             Fst       => 1,\n+             Lst       => Count,\n+             Item      => New_Item)\n \n           --  Count cursors have been inserted at the beginning of Container\n           and P_Positions_Shifted\n@@ -694,12 +637,23 @@ is\n \n           --  Positions contains a new mapping from the last cursor of\n           --  Container to its length.\n-          and P.Is_Add\n-            (Positions (Container)'Old, Last (Container), Length (Container),\n-             Result => Positions (Container))\n+          and P.Get (Positions (Container), Last (Container))\n+            = Length (Container)\n+\n+          --  Other cursors come from Container'Old\n+          and P.Keys_Included_Except\n+            (Left    => Positions (Container),\n+             Right   => Positions (Container)'Old,\n+             New_Key => Last (Container))\n+\n+          --  Cursors of Container'Old keep the same position\n+          and Positions (Container)'Old <= Positions (Container)\n \n           --  Model contains a new element New_Item at the end\n-          and M.Is_Add (Model (Container)'Old, New_Item, Model (Container));\n+          and Element (Model (Container), Length (Container)) = New_Item\n+\n+          --  Elements of Container'Old are preserved\n+          and Model (Container)'Old <= Model (Container);\n \n    procedure Append\n      (Container : in out List;\n@@ -715,11 +669,11 @@ is\n           and Model (Container)'Old <= Model (Container)\n \n           --  Container contains Count times New_Item at the end\n-          and M_Elements_Cst\n-            (S   => Model (Container),\n-             Fst => Length (Container)'Old + 1,\n-             Lst => Length (Container),\n-             E   => New_Item)\n+          and M.Constant_Range\n+            (Container => Model (Container),\n+             Fst       => Length (Container)'Old + 1,\n+             Lst       => Length (Container),\n+             Item      => New_Item)\n \n           --  Count cursors have been inserted at the end of Container\n           and P_Positions_Truncated\n@@ -741,16 +695,16 @@ is\n           and Position = No_Element\n \n           --  The elements of Container located before Position are preserved.\n-          and M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container)'Old, Position'Old) - 1)\n+          and M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n \n           --  The elements located after Position are shifted by 1\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container)'Old, Position'Old) + 1,\n              Lst    => Length (Container)'Old,\n              Offset => -1)\n@@ -776,11 +730,11 @@ is\n           and Position = No_Element\n \n           --  The elements of Container located before Position are preserved.\n-          and M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container)'Old, Position'Old) - 1),\n+          and M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n      Contract_Cases =>\n \n        --  All the elements after Position have been erased\n@@ -800,9 +754,9 @@ is\n           Length (Container) = Length (Container)'Old - Count\n \n           --  Other elements are shifted by Count\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    =>\n                P.Get (Positions (Container)'Old, Position'Old) + Count,\n              Lst    => Length (Container)'Old,\n@@ -823,9 +777,9 @@ is\n        Length (Container) = Length (Container)'Old - 1\n \n           --  The elements of Container are shifted by 1\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => 2,\n              Lst    => Length (Container)'Old,\n              Offset => -1)\n@@ -849,9 +803,9 @@ is\n           Length (Container) = Length (Container)'Old - Count\n \n           --  Elements of Container are shifted by Count\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => Count + 1,\n              Lst    => Length (Container)'Old,\n              Offset => -Count)\n@@ -874,8 +828,16 @@ is\n           and Model (Container) <= Model (Container)'Old\n \n           --  The last cursor of Container has been removed\n-          and P.Is_Add (Positions (Container), Last (Container)'Old,\n-                        Length (Container)'Old, Positions (Container)'Old);\n+          and not P.Has_Key (Positions (Container), Last (Container)'Old)\n+\n+          --  Other cursors are still valid\n+          and P.Keys_Included_Except\n+            (Left    => Positions (Container)'Old,\n+             Right   => Positions (Container)'Old,\n+             New_Key => Last (Container)'Old)\n+\n+          --  The positions of other cursors are preserved\n+          and Positions (Container) <= Positions (Container)'Old;\n \n    procedure Delete_Last\n      (Container : in out List;\n@@ -949,17 +911,17 @@ is\n        (Before = No_Element =>\n \n           --  The elements of Target are preserved\n-          M_Elements_Equal\n-            (S1  => Model (Target)'Old,\n-             S2  => Model (Target),\n-             Fst => 1,\n-             Lst => Length (Target)'Old)\n+          M.Range_Equal\n+            (Left  => Model (Target)'Old,\n+             Right => Model (Target),\n+             Fst   => 1,\n+             Lst   => Length (Target)'Old)\n \n           --  The elements of Source are appended to target, the order is not\n           --  specified.\n           and M_Elements_Shuffle\n-            (S1     => Model (Source)'Old,\n-             S2     => Model (Target),\n+            (Left   => Model (Source)'Old,\n+             Right  => Model (Target),\n              Fst    => 1,\n              Lst    => Length (Source)'Old,\n              Offset => Length (Target)'Old)\n@@ -973,25 +935,25 @@ is\n         others              =>\n \n           --  The elements of Target located before Before are preserved\n-          M_Elements_Equal\n-            (S1  => Model (Target)'Old,\n-             S2  => Model (Target),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Target)'Old, Before) - 1)\n+          M.Range_Equal\n+            (Left  => Model (Target)'Old,\n+             Right => Model (Target),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Target)'Old, Before) - 1)\n \n           --  The elements of Source are inserted before Before, the order is\n           --  not specified.\n           and M_Elements_Shuffle\n-            (S1     => Model (Source)'Old,\n-             S2     => Model (Target),\n+            (Left   => Model (Source)'Old,\n+             Right  => Model (Target),\n              Fst    => 1,\n              Lst    => Length (Source)'Old,\n              Offset => P.Get (Positions (Target)'Old, Before) - 1)\n \n           --  Other elements are shifted by the length of Source\n-          and M_Elements_Shifted\n-            (S1     => Model (Target)'Old,\n-             S2     => Model (Target),\n+          and M.Range_Shifted\n+            (Left   => Model (Target)'Old,\n+             Right  => Model (Target),\n              Fst    => P.Get (Positions (Target)'Old, Before),\n              Lst    => Length (Target)'Old,\n              Offset => Length (Source)'Old)\n@@ -1021,16 +983,16 @@ is\n           and Length (Source) = Length (Source)'Old - 1\n \n           --  The elements of Source located before Position are preserved.\n-          and M_Elements_Equal\n-            (S1  => Model (Source)'Old,\n-             S2  => Model (Source),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Source)'Old, Position'Old) - 1)\n+          and M.Range_Equal\n+            (Left  => Model (Source)'Old,\n+             Right => Model (Source),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n \n           --  The elements located after Position are shifted by 1\n-          and M_Elements_Shifted\n-            (S1     => Model (Source)'Old,\n-             S2     => Model (Source),\n+          and M.Range_Shifted\n+            (Left   => Model (Source)'Old,\n+             Right  => Model (Source),\n              Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n              Lst    => Length (Source)'Old,\n              Offset => -1)\n@@ -1044,24 +1006,24 @@ is\n           --  Positions is valid in Target and it is located either before\n           --  Before if it is valid in Target or at the end if it is\n           --  No_Element.\n-          and P.Mem (Positions (Target), Position)\n+          and P.Has_Key (Positions (Target), Position)\n           and (if Before = No_Element\n                then P.Get (Positions (Target), Position)\n                   = Length (Target)\n                else P.Get (Positions (Target), Position)\n                   = P.Get (Positions (Target)'Old, Before))\n \n           --  The elements of Target located before Position are preserved.\n-          and M_Elements_Equal\n-            (S1  => Model (Target)'Old,\n-             S2  => Model (Target),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Target), Position) - 1)\n+          and M.Range_Equal\n+            (Left  => Model (Target)'Old,\n+             Right => Model (Target),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Target), Position) - 1)\n \n           --  Other elements are shifted by 1.\n-          and M_Elements_Shifted\n-            (S1     => Model (Target)'Old,\n-             S2     => Model (Target),\n+          and M.Range_Shifted\n+            (Left   => Model (Target)'Old,\n+             Right  => Model (Target),\n              Fst    => P.Get (Positions (Target), Position),\n              Lst    => Length (Target)'Old,\n              Offset => 1)\n@@ -1095,16 +1057,16 @@ is\n         Before = No_Element =>\n \n           --  The elements located before Position are preserved\n-          M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => P.Get (Positions (Container)'Old, Position) - 1)\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => P.Get (Positions (Container)'Old, Position) - 1)\n \n           --  The elements located after Position are shifted by 1\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n              Lst    => Length (Container)'Old,\n              Offset => -1)\n@@ -1117,45 +1079,45 @@ is\n \n           --  Cursors from Container continue designating the same elements\n           and Mapping_Preserved\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n-             M1     => Positions (Container)'Old,\n-             M2     => Positions (Container)),\n+            (M_Left  => Model (Container)'Old,\n+             M_Right => Model (Container),\n+             P_Left  => Positions (Container)'Old,\n+             P_Right => Positions (Container)),\n \n         others              =>\n \n           --  The elements located before Position and Before are preserved\n-          M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => 1,\n-             Lst => Count_Type'Min\n-                      (P.Get (Positions (Container)'Old, Position) - 1,\n-                       P.Get (Positions (Container)'Old, Before) - 1))\n+          M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => 1,\n+             Lst   => Count_Type'Min\n+               (P.Get (Positions (Container)'Old, Position) - 1,\n+                P.Get (Positions (Container)'Old, Before) - 1))\n \n           --  The elements located after Position and Before are preserved\n-          and M_Elements_Equal\n-            (S1  => Model (Container)'Old,\n-             S2  => Model (Container),\n-             Fst => Count_Type'Max\n-                      (P.Get (Positions (Container)'Old, Position) + 1,\n-                       P.Get (Positions (Container)'Old, Before) + 1),\n-             Lst => Length (Container))\n+          and M.Range_Equal\n+            (Left  => Model (Container)'Old,\n+             Right => Model (Container),\n+             Fst   => Count_Type'Max\n+               (P.Get (Positions (Container)'Old, Position) + 1,\n+                P.Get (Positions (Container)'Old, Before) + 1),\n+             Lst   => Length (Container))\n \n           --  The elements located after Before and before Position are shifted\n           --  by 1 to the right.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n              Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n              Offset => 1)\n \n           --  The elements located after Position and before Before are shifted\n           --  by 1 to the left.\n-          and M_Elements_Shifted\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n+          and M.Range_Shifted\n+            (Left   => Model (Container)'Old,\n+             Right  => Model (Container),\n              Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n              Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n              Offset => -1)\n@@ -1168,10 +1130,10 @@ is\n \n           --  Cursors from Container continue designating the same elements\n           and Mapping_Preserved\n-            (S1     => Model (Container)'Old,\n-             S2     => Model (Container),\n-             M1     => Positions (Container)'Old,\n-             M2     => Positions (Container)));\n+            (M_Left  => Model (Container)'Old,\n+             M_Right => Model (Container),\n+             P_Left  => Positions (Container)'Old,\n+             P_Right => Positions (Container)));\n \n    function First (Container : List) return Cursor with\n      Global         => null,\n@@ -1260,18 +1222,18 @@ is\n \n        --  If Item is not is not contained in Container after Position, Find\n        --  returns No_Element.\n-       (not M_Elements_Contains\n-          (S   => Model (Container),\n-           Fst => (if Position = No_Element then 1\n-                   else P.Get (Positions (Container), Position)),\n-           Lst => Length (Container),\n-           E   => Item)\n+       (not M.Contains\n+          (Container => Model (Container),\n+           Fst       => (if Position = No_Element then 1\n+                         else P.Get (Positions (Container), Position)),\n+           Lst       => Length (Container),\n+           Item      => Item)\n         =>\n           Find'Result = No_Element,\n \n         --  Otherwise, Find returns a valid cusror in Container\n         others =>\n-          P.Mem (Positions (Container), Find'Result)\n+          P.Has_Key (Positions (Container), Find'Result)\n \n         --  The element designated by the result of Find is Item\n         and Element (Model (Container),\n@@ -1283,12 +1245,12 @@ is\n                >= P.Get (Positions (Container), Position))\n \n         --  It is the first occurence of Item in this slice\n-        and not M_Elements_Contains\n-          (S   => Model (Container),\n-           Fst => (if Position = No_Element then 1\n-                   else P.Get (Positions (Container), Position)),\n-           Lst => P.Get (Positions (Container), Find'Result) - 1,\n-           E   => Item));\n+        and not M.Contains\n+          (Container => Model (Container),\n+           Fst       => (if Position = No_Element then 1\n+                         else P.Get (Positions (Container), Position)),\n+           Lst       => P.Get (Positions (Container), Find'Result) - 1,\n+           Item      => Item));\n \n    function Reverse_Find\n      (Container : List;\n@@ -1302,18 +1264,18 @@ is\n \n        --  If Item is not is not contained in Container before Position, Find\n        --  returns No_Element.\n-       (not M_Elements_Contains\n-          (S   => Model (Container),\n-           Fst => 1,\n-           Lst => (if Position = No_Element then Length (Container)\n-                   else P.Get (Positions (Container), Position)),\n-           E   => Item)\n+       (not M.Contains\n+          (Container => Model (Container),\n+           Fst       => 1,\n+           Lst       => (if Position = No_Element then Length (Container)\n+                         else P.Get (Positions (Container), Position)),\n+           Item      => Item)\n         =>\n           Reverse_Find'Result = No_Element,\n \n         --  Otherwise, Find returns a valid cusror in Container\n         others =>\n-          P.Mem (Positions (Container), Reverse_Find'Result)\n+          P.Has_Key (Positions (Container), Reverse_Find'Result)\n \n         --  The element designated by the result of Find is Item\n         and Element (Model (Container),\n@@ -1325,42 +1287,42 @@ is\n                <= P.Get (Positions (Container), Position))\n \n         --  It is the last occurence of Item in this slice\n-        and not M_Elements_Contains\n-          (S   => Model (Container),\n-           Fst => P.Get (Positions (Container), Reverse_Find'Result) + 1,\n-           Lst => (if Position = No_Element then Length (Container)\n-                   else P.Get (Positions (Container), Position)),\n-           E   => Item));\n+        and not M.Contains\n+          (Container => Model (Container),\n+           Fst       => P.Get (Positions (Container), Reverse_Find'Result) + 1,\n+           Lst       => (if Position = No_Element then Length (Container)\n+                         else P.Get (Positions (Container), Position)),\n+           Item      => Item));\n \n    function Contains\n      (Container : List;\n       Item      : Element_Type) return Boolean\n    with\n      Global => null,\n-     Post   => Contains'Result =\n-         M_Elements_Contains\n-          (S   => Model (Container),\n-           Fst => 1,\n-           Lst => Length (Container),\n-           E   => Item);\n+     Post   =>\n+         Contains'Result = M.Contains (Container => Model (Container),\n+                                       Fst       => 1,\n+                                       Lst       => Length (Container),\n+                                       Item      => Item);\n \n    function Has_Element (Container : List; Position : Cursor) return Boolean\n    with\n      Global => null,\n-     Post   => Has_Element'Result = P.Mem (Positions (Container), Position);\n+     Post   =>\n+         Has_Element'Result = P.Has_Key (Positions (Container), Position);\n    pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n \n    generic\n       with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n    package Generic_Sorting with SPARK_Mode is\n-      function M_Elements_Sorted (S : M.Sequence) return Boolean with\n+      function M_Elements_Sorted (Container : M.Sequence) return Boolean with\n         Ghost,\n         Global => null,\n         Post   => M_Elements_Sorted'Result =\n-          (for all I in 1 .. M.Length (S) =>\n-             (for all J in I + 1 .. M.Length (S) =>\n-                  Element (S, I) = Element (S, J)\n-               or Element (S, I) < Element (S, J)));\n+          (for all I in 1 .. M.Length (Container) =>\n+             (for all J in I + 1 .. M.Length (Container) =>\n+                  Element (Container, I) = Element (Container, J)\n+               or Element (Container, I) < Element (Container, J)));\n       pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n \n       function Is_Sorted (Container : List) return Boolean with"}, {"sha": "39759f486816bfff15227d22ace4763dedf04a52", "filename": "gcc/ada/a-cofuma.adb", "status": "modified", "additions": 149, "deletions": 67, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -38,21 +38,21 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (M1 : Map; M2 : Map) return Boolean is\n-     (M1.Keys <= M2.Keys and M2 <= M1);\n+   function \"=\" (Left : Map; Right : Map) return Boolean is\n+     (Left.Keys <= Right.Keys and Right <= Left);\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (M1 : Map; M2 : Map) return Boolean is\n+   function \"<=\" (Left : Map; Right : Map) return Boolean is\n       I2 : Count_Type;\n \n    begin\n-      for I1 in 1 .. Length (M1.Keys) loop\n-         I2 := Find (M2.Keys, Get (M1.Keys, I1));\n+      for I1 in 1 .. Length (Left.Keys) loop\n+         I2 := Find (Right.Keys, Get (Left.Keys, I1));\n          if I2 = 0\n-           or else Get (M2.Elements, I2) /= Get (M1.Elements, I1)\n+           or else Get (Right.Elements, I2) /= Get (Left.Elements, I1)\n          then\n             return False;\n          end if;\n@@ -64,103 +64,185 @@ package body Ada.Containers.Functional_Maps with SPARK_Mode => Off is\n    -- Add --\n    ---------\n \n-   function Add (M : Map; K : Key_Type; E : Element_Type) return Map is\n+   function Add\n+     (Container : Map;\n+      New_Key   : Key_Type;\n+      New_Item  : Element_Type) return Map\n+   is\n    begin\n       return\n-        (Keys     => Add (M.Keys, Length (M.Keys) + 1, K),\n-         Elements => Add (M.Elements, Length (M.Elements) + 1, E));\n+        (Keys     =>\n+           Add (Container.Keys, Length (Container.Keys) + 1, New_Key),\n+         Elements =>\n+           Add\n+             (Container.Elements, Length (Container.Elements) + 1, New_Item));\n    end Add;\n \n+   ---------------------------\n+   -- Elements_Equal_Except --\n+   ---------------------------\n+\n+   function Elements_Equal_Except\n+     (Left    : Map;\n+      Right   : Map;\n+      New_Key : Key_Type) return Boolean\n+   is\n+   begin\n+      for I in 1 .. Length (Left.Keys) loop\n+         declare\n+            K : constant Key_Type := Get (Left.Keys, I);\n+         begin\n+            if not Equivalent_Keys (K, New_Key)\n+              and then Get (Right.Elements, Find (Right.Keys, K))\n+                    /= Get (Left.Elements, I)\n+            then\n+               return False;\n+            end if;\n+         end;\n+      end loop;\n+      return True;\n+   end Elements_Equal_Except;\n+\n+   function Elements_Equal_Except\n+     (Left  : Map;\n+      Right : Map;\n+      X, Y  : Key_Type) return Boolean\n+   is\n+   begin\n+      for I in 1 .. Length (Left.Keys) loop\n+         declare\n+            K : constant Key_Type := Get (Left.Keys, I);\n+         begin\n+            if not Equivalent_Keys (K, X)\n+              and then not Equivalent_Keys (K, Y)\n+              and then Get (Right.Elements, Find (Right.Keys, K))\n+                    /= Get (Left.Elements, I)\n+            then\n+               return False;\n+            end if;\n+         end;\n+      end loop;\n+      return True;\n+   end Elements_Equal_Except;\n+\n    ---------\n    -- Get --\n    ---------\n \n-   function Get (M : Map; K : Key_Type) return Element_Type is\n+   function Get (Container : Map; Key : Key_Type) return Element_Type is\n    begin\n-      return Get (M.Elements, Find (M.Keys, K));\n+      return Get (Container.Elements, Find (Container.Keys, Key));\n    end Get;\n \n-   ------------\n-   -- Is_Add --\n-   ------------\n+   -------------\n+   -- Has_Key --\n+   -------------\n \n-   function Is_Add\n-     (M      : Map;\n-      K      : Key_Type;\n-      E      : Element_Type;\n-      Result : Map) return Boolean\n-   is\n+   function Has_Key (Container : Map; Key : Key_Type) return Boolean is\n    begin\n-      if Mem (M, K) or not Mem (Result, K) or Get (Result, K) /= E then\n-         return False;\n-      end if;\n-\n-      for K of M loop\n-         if not Mem (Result, K) or else Get (Result, K) /= Get (M, K) then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      for KK of Result loop\n-         if KK /= K and not Mem (M, KK) then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Is_Add;\n+      return Find (Container.Keys, Key) > 0;\n+   end Has_Key;\n \n    --------------\n    -- Is_Empty --\n    --------------\n \n-   function Is_Empty (M : Map) return Boolean is\n+   function Is_Empty (Container : Map) return Boolean is\n    begin\n-      return Length (M.Keys) = 0;\n+      return Length (Container.Keys) = 0;\n    end Is_Empty;\n \n-   ------------\n-   -- Is_Set --\n-   ------------\n+   -------------------\n+   -- Keys_Included --\n+   -------------------\n+\n+   function Keys_Included (Left : Map; Right : Map) return Boolean is\n+   begin\n+      for I in 1 .. Length (Left.Keys) loop\n+         declare\n+            K : constant Key_Type := Get (Left.Keys, I);\n+         begin\n+            if Find (Right.Keys, K) = 0 then\n+               return False;\n+            end if;\n+         end;\n+      end loop;\n+      return True;\n+   end Keys_Included;\n+\n+   --------------------------\n+   -- Keys_Included_Except --\n+   --------------------------\n+\n+   function Keys_Included_Except\n+     (Left    : Map;\n+      Right   : Map;\n+      New_Key : Key_Type) return Boolean\n+   is\n+   begin\n+      for I in 1 .. Length (Left.Keys) loop\n+         declare\n+            K : constant Key_Type := Get (Left.Keys, I);\n+         begin\n+            if not Equivalent_Keys (K, New_Key)\n+              and then Find (Right.Keys, K) = 0\n+            then\n+               return False;\n+            end if;\n+         end;\n+      end loop;\n+      return True;\n+   end Keys_Included_Except;\n \n-   function Is_Set\n-     (M      : Map;\n-      K      : Key_Type;\n-      E      : Element_Type;\n-      Result : Map) return Boolean\n+   function Keys_Included_Except\n+     (Left  : Map;\n+      Right : Map;\n+      X, Y  : Key_Type) return Boolean\n    is\n-     (Mem (M, K)\n-       and then Mem (Result, K)\n-       and then Get (Result, K) = E\n-       and then (for all KK of M =>\n-                   Mem (Result, KK)\n-                     and then\n-                       (if K /= KK then Get (Result, KK) = Get (M, KK)))\n-       and then (for all K of Result => Mem (M, K)));\n+   begin\n+      for I in 1 .. Length (Left.Keys) loop\n+         declare\n+            K : constant Key_Type := Get (Left.Keys, I);\n+         begin\n+            if not Equivalent_Keys (K, X)\n+              and then not Equivalent_Keys (K, Y)\n+              and then Find (Right.Keys, K) = 0\n+            then\n+               return False;\n+            end if;\n+         end;\n+      end loop;\n+      return True;\n+   end Keys_Included_Except;\n \n    ------------\n    -- Length --\n    ------------\n \n-   function Length (M : Map) return Count_Type is\n+   function Length (Container : Map) return Count_Type is\n    begin\n-      return Length (M.Elements);\n+      return Length (Container.Elements);\n    end Length;\n \n-   ---------\n-   -- Mem --\n-   ---------\n+   ---------------\n+   -- Same_Keys --\n+   ---------------\n \n-   function Mem (M : Map; K : Key_Type) return Boolean is\n-   begin\n-      return Find (M.Keys, K) > 0;\n-   end Mem;\n+   function Same_Keys (Left : Map; Right : Map) return Boolean is\n+      (Keys_Included (Left, Right)\n+            and Keys_Included (Left => Right, Right => Left));\n \n    ---------\n    -- Set --\n    ---------\n \n-   function Set (M : Map; K : Key_Type; E : Element_Type) return Map is\n-     (Keys => M.Keys, Elements => Set (M.Elements, Find (M.Keys, K), E));\n+   function Set\n+     (Container : Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type) return Map\n+   is\n+     (Keys     => Container.Keys,\n+      Elements =>\n+         Set (Container.Elements, Find (Container.Keys, Key), New_Item));\n \n end Ada.Containers.Functional_Maps;"}, {"sha": "89adcb29e51f028dc86ded33a3470a90e057c812", "filename": "gcc/ada/a-cofuma.ads", "status": "modified", "additions": 164, "deletions": 79, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuma.ads?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -36,12 +36,8 @@ generic\n    type Key_Type (<>) is private;\n    type Element_Type (<>)  is private;\n    with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n package Ada.Containers.Functional_Maps with SPARK_Mode is\n \n-   pragma Assertion_Policy (Post => Ignore);\n-\n    type Map is private with\n      Default_Initial_Condition => Is_Empty (Map) and Length (Map) = 0,\n      Iterable                  => (First       => Iter_First,\n@@ -52,121 +48,205 @@ package Ada.Containers.Functional_Maps with SPARK_Mode is\n    --  \"For in\" quantification over maps should not be used.\n    --  \"For of\" quantification over maps iterates over keys.\n \n-   --  Maps are axiomatized using Mem and Get, encoding respectively the\n+   -----------------------\n+   --  Basic operations --\n+   -----------------------\n+\n+   --  Maps are axiomatized using Has_Key and Get, encoding respectively the\n    --  presence of a key in a map and an accessor to elements associated to its\n    --  keys. The length of a map is also added to protect Add against overflows\n    --  but it is not actually modeled.\n \n-   function Mem (M : Map; K : Key_Type) return Boolean with\n+   function Has_Key (Container : Map; Key : Key_Type) return Boolean with\n      Global => null;\n+   --  Return True if Key is present in Container\n \n-   function Get (M : Map; K : Key_Type) return Element_Type with\n+   function Get (Container : Map; Key : Key_Type) return Element_Type with\n      Global => null,\n-     Pre    => Mem (M, K);\n+     Pre    => Has_Key (Container, Key);\n+   --  Return the element associated to Key is present in Container\n \n-   function Length (M : Map) return Count_Type with\n+   function Length (Container : Map) return Count_Type with\n      Global => null;\n+   --  Return the number of mappings in Container\n \n-   function \"<=\" (M1 : Map; M2 : Map) return Boolean with\n+   ------------------------\n+   -- Property Functions --\n+   ------------------------\n+\n+   function \"<=\" (Left : Map; Right : Map) return Boolean with\n    --  Map inclusion\n \n      Global => null,\n-     Post   => \"<=\"'Result =\n-       (for all K of M1 =>\n-          Mem (M2, K) and then Get (M2, K) = Get (M1, K));\n+     Post   =>\n+       \"<=\"'Result =\n+         (for all Key of Left =>\n+            Has_Key (Right, Key) and then Get (Right, Key) = Get (Left, Key));\n \n-   function \"=\" (M1 : Map; M2 : Map) return Boolean with\n+   function \"=\" (Left : Map; Right : Map) return Boolean with\n    --  Extensional equality over maps\n \n      Global => null,\n-     Post   => \"=\"'Result =\n-       ((for all K of M1 => Mem (M2, K) and then Get (M2, K) = Get (M1, K))\n-           and (for all K of M2 => Mem (M1, K)));\n-\n-   pragma Warnings (Off, \"unused variable \"\"K\"\"\");\n-   function Is_Empty (M : Map) return Boolean with\n+     Post   =>\n+       \"=\"'Result =\n+         ((for all Key of Left =>\n+                   Has_Key (Right, Key)\n+           and then Get (Right, Key) = Get (Left, Key))\n+          and (for all Key of Right => Has_Key (Left, Key)));\n+\n+   pragma Warnings (Off, \"unused variable \"\"Key\"\"\");\n+   function Is_Empty (Container : Map) return Boolean with\n    --  A map is empty if it contains no key\n+\n+     Global => null,\n+     Post   => Is_Empty'Result = (for all Key of Container => False);\n+   pragma Warnings (On, \"unused variable \"\"Key\"\"\");\n+\n+   function Keys_Included (Left : Map; Right : Map) return Boolean\n+   --  Returns True if every Key of Left is in Right\n+\n+   with\n+     Global => null,\n+     Post   =>\n+       Keys_Included'Result = (for all Key of Left => Has_Key (Right, Key));\n+\n+   function Same_Keys (Left : Map; Right : Map) return Boolean\n+   --  Returns True if Left and Right have the same keys\n+\n+   with\n+     Global => null,\n+     Post   =>\n+       Same_Keys'Result =\n+           (Keys_Included (Left, Right)\n+            and Keys_Included (Left => Right, Right => Left));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Same_Keys);\n+\n+   function Keys_Included_Except\n+     (Left    : Map;\n+      Right   : Map;\n+      New_Key : Key_Type) return Boolean\n+   --  Returns True if Left contains only keys of Right and possibly New_Key\n+\n+   with\n      Global => null,\n-     Post   => Is_Empty'Result = (for all K of M => False);\n-   pragma Warnings (On, \"unused variable \"\"K\"\"\");\n+     Post   =>\n+         Keys_Included_Except'Result =\n+           (for all Key of Left =>\n+              (if not Equivalent_Keys (Key, New_Key)\n+               then Has_Key (Right, Key)));\n \n-   function Is_Add\n-     (M      : Map;\n-      K      : Key_Type;\n-      E      : Element_Type;\n-      Result : Map) return Boolean\n-   --  Returns True if Result is M augmented with the mapping K -> E\n+   function Keys_Included_Except\n+     (Left  : Map;\n+      Right : Map;\n+      X, Y  : Key_Type) return Boolean\n+   --  Returns True if Left contains only keys of Right and possibly X and Y\n+\n+   with\n+     Global => null,\n+     Post   =>\n+         Keys_Included_Except'Result =\n+           (for all Key of Left =>\n+              (if not Equivalent_Keys (Key, X) and not Equivalent_Keys (Key, Y)\n+               then Has_Key (Right, Key)));\n+\n+   function Elements_Equal_Except\n+     (Left    : Map;\n+      Right   : Map;\n+      New_Key : Key_Type) return Boolean\n+   --  Returns True if all the keys of Left are mapped to the same elements in\n+   --  Left and Right except New_Key.\n \n    with\n      Global => null,\n+     Pre    => Keys_Included_Except (Left, Right, New_Key),\n      Post   =>\n-       Is_Add'Result =\n-         (not Mem (M, K)\n-            and then Mem (Result, K)\n-            and then Get (Result, K) = E\n-            and then (for all K of M =>\n-                        Mem (Result, K) and then Get (Result, K) = Get (M, K))\n-            and then (for all KK of Result =>\n-                        Equivalent_Keys (KK, K) or Mem (M, KK)));\n-\n-   function Add (M : Map; K : Key_Type; E : Element_Type) return Map with\n-   --  Returns M augmented with the mapping K -> E.\n-   --  Is_Add (M, K, E, Result) should be used instead of\n-   --  Result = Add (M, K, E) whenever possible both for execution and for\n-   --  proof.\n+       Elements_Equal_Except'Result =\n+         (for all Key of Left =>\n+            (if not Equivalent_Keys (Key, New_Key)\n+             then Get (Left, Key) = Get (Right, Key)));\n+\n+   function Elements_Equal_Except\n+     (Left  : Map;\n+      Right : Map;\n+      X, Y  : Key_Type) return Boolean\n+   --  Returns True if all the keys of Left are mapped to the same elements in\n+   --  Left and Right except X and Y.\n \n+   with\n      Global => null,\n-     Pre    => not Mem (M, K) and Length (M) < Count_Type'Last,\n-     Post   => Length (M) + 1 = Length (Add'Result)\n-               and Is_Add (M, K, E, Add'Result);\n+     Pre    => Keys_Included_Except (Left, Right, X, Y),\n+     Post   =>\n+       Elements_Equal_Except'Result =\n+         (for all Key of Left =>\n+            (if not Equivalent_Keys (Key, X) and not Equivalent_Keys (Key, Y)\n+             then Get (Left, Key) = Get (Right, Key)));\n+\n+   ----------------------------\n+   -- Construction Functions --\n+   ----------------------------\n \n-   function Is_Set\n-     (M : Map; K : Key_Type; E : Element_Type; Result : Map) return Boolean\n-   --  Returns True if Result is M, where the element associated to K has been\n-   --  replaced by E.\n+   --  For better efficiency of both proofs and execution, avoid using\n+   --  construction functions in annotations and rather use property functions.\n+\n+   function Add\n+     (Container : Map;\n+      New_Key   : Key_Type;\n+      New_Item  : Element_Type) return Map\n+   --  Returns Container augmented with the mapping Key -> New_Item.\n \n    with\n      Global => null,\n-     Post   => Is_Set'Result =\n-         (Mem (M, K)\n-          and then Mem (Result, K)\n-          and then Get (Result, K) = E\n-          and then (for all KK of M => Mem (Result, KK)\n-               and then (if not Equivalent_Keys (K, KK)\n-                         then Get (Result, KK) = Get (M, KK)))\n-          and then (for all K of Result => Mem (M, K)));\n-\n-   function Set (M : Map; K : Key_Type; E : Element_Type) return Map with\n-   --  Returns M, where the element associated to K has been replaced by E.\n-   --  Is_Set (M, K, E, Result) should be used instead of\n-   --  Result = Set (M, K, E) whenever possible both for execution and for\n-   --  proof.\n+     Pre    =>\n+         not Has_Key (Container, New_Key)\n+       and Length (Container) < Count_Type'Last,\n+     Post   =>\n+       Length (Container) + 1 = Length (Add'Result)\n+       and Has_Key (Add'Result, New_Key)\n+       and Get (Add'Result, New_Key) = New_Item\n+       and Container <= Add'Result\n+       and Keys_Included_Except (Add'Result, Container, New_Key);\n+\n+   function Set\n+     (Container : Map;\n+      Key       : Key_Type;\n+      New_Item  : Element_Type) return Map\n+   --  Returns Container, where the element associated to Key has been replaced\n+   --  by New_Item.\n \n+   with\n      Global => null,\n-     Pre    => Mem (M, K),\n+     Pre    => Has_Key (Container, Key),\n      Post   =>\n-       Length (M) = Length (Set'Result) and Is_Set (M, K, E, Set'Result);\n+       Length (Container) = Length (Set'Result)\n+       and Get (Set'Result, Key) = New_Item\n+       and Same_Keys (Container, Set'Result)\n+       and Elements_Equal_Except (Container, Set'Result, Key);\n \n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------\n \n    type Private_Key is private;\n \n-   function Iter_First (M : Map) return Private_Key with\n+   function Iter_First (Container : Map) return Private_Key with\n      Global => null;\n \n-   function Iter_Has_Element (M : Map; K : Private_Key) return Boolean with\n+   function Iter_Has_Element\n+     (Container : Map;\n+      Key       : Private_Key) return Boolean\n+   with\n      Global => null;\n \n-   function Iter_Next (M : Map; K : Private_Key) return Private_Key with\n+   function Iter_Next (Container : Map; Key : Private_Key) return Private_Key\n+   with\n      Global => null,\n-     Pre    => Iter_Has_Element (M, K);\n+     Pre    => Iter_Has_Element (Container, Key);\n \n-   function Iter_Element (M : Map; K : Private_Key) return Key_Type with\n+   function Iter_Element (Container : Map; Key : Private_Key) return Key_Type\n+   with\n      Global => null,\n-     Pre    => Iter_Has_Element (M, K);\n-   pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Mem);\n+     Pre    => Iter_Has_Element (Container, Key);\n+   pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Has_Key);\n \n private\n \n@@ -193,15 +273,20 @@ private\n \n    type Private_Key is new Count_Type;\n \n-   function Iter_First (M : Map) return Private_Key is (1);\n+   function Iter_First (Container : Map) return Private_Key is (1);\n \n-   function Iter_Has_Element (M : Map; K : Private_Key) return Boolean is\n-     (Count_Type (K) in 1 .. Key_Containers.Length (M.Keys));\n+   function Iter_Has_Element\n+     (Container : Map;\n+      Key       : Private_Key) return Boolean\n+   is\n+     (Count_Type (Key) in 1 .. Key_Containers.Length (Container.Keys));\n \n-   function Iter_Next (M : Map; K : Private_Key) return Private_Key is\n-     (if K = Private_Key'Last then 0 else K + 1);\n+   function Iter_Next (Container : Map; Key : Private_Key) return Private_Key\n+   is\n+     (if Key = Private_Key'Last then 0 else Key + 1);\n \n-   function Iter_Element (M : Map; K : Private_Key) return Key_Type is\n-     (Key_Containers.Get (M.Keys, Count_Type (K)));\n+   function Iter_Element (Container : Map; Key : Private_Key) return Key_Type\n+   is\n+     (Key_Containers.Get (Container.Keys, Count_Type (Key)));\n \n end Ada.Containers.Functional_Maps;"}, {"sha": "d9b4c1dbe78e83c9c1c884db2c1296ccb87f2358", "filename": "gcc/ada/a-cofuse.adb", "status": "modified", "additions": 58, "deletions": 52, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -38,101 +38,107 @@ package body Ada.Containers.Functional_Sets with SPARK_Mode => Off is\n    -- \"=\" --\n    ---------\n \n-   function \"=\" (S1 : Set; S2 : Set) return Boolean is\n-     (S1.Content <= S2.Content and S2.Content <= S1.Content);\n+   function \"=\" (Left : Set; Right : Set) return Boolean is\n+     (Left.Content <= Right.Content and Right.Content <= Left.Content);\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (S1 : Set; S2 : Set) return Boolean is\n-     (S1.Content <= S2.Content);\n+   function \"<=\" (Left : Set; Right : Set) return Boolean is\n+     (Left.Content <= Right.Content);\n \n    ---------\n    -- Add --\n    ---------\n \n-   function Add (S : Set; E : Element_Type) return Set is\n-     (Content => Add (S.Content, Length (S.Content) + 1, E));\n+   function Add (Container : Set; Item : Element_Type) return Set is\n+     (Content =>\n+         Add (Container.Content, Length (Container.Content) + 1, Item));\n \n-   ------------------\n-   -- Intersection --\n-   ------------------\n+   --------------\n+   -- Contains --\n+   --------------\n \n-   function Intersection (S1 : Set; S2 : Set) return Set is\n-     (Content => Intersection (S1.Content, S2.Content));\n+   function Contains (Container : Set; Item : Element_Type) return Boolean is\n+     (Find (Container.Content, Item) > 0);\n \n-   ------------\n-   -- Is_Add --\n-   ------------\n+   ---------------------\n+   -- Included_Except --\n+   ---------------------\n \n-   function Is_Add (S : Set; E : Element_Type; Result : Set) return Boolean\n+   function Included_Except\n+     (Left  : Set;\n+      Right : Set;\n+      Item  : Element_Type) return Boolean\n    is\n-     (Mem (Result, E)\n-        and (for all F of Result => Mem (S, F) or F = E)\n-        and (for all E of S => Mem (Result, E)));\n+     (for all E of Left =>\n+         Equivalent_Elements (E, Item) or Contains (Right, E));\n \n-   --------------\n-   -- Is_Empty --\n-   --------------\n+   -----------------------\n+   -- Included_In_Union --\n+   -----------------------\n \n-   function Is_Empty (S : Set) return Boolean is (Length (S.Content) = 0);\n+   function Included_In_Union\n+     (Container : Set;\n+      Left      : Set;\n+      Right     : Set) return Boolean\n+   is\n+     (for all Item of Container =>\n+         Contains (Left, Item) or Contains (Right, Item));\n \n-   ---------------------\n-   -- Is_Intersection --\n-   ---------------------\n+   ---------------------------\n+   -- Includes_Intersection --\n+   ---------------------------\n \n-   function Is_Intersection\n-     (S1     : Set;\n-      S2     : Set;\n-      Result : Set) return Boolean\n+   function Includes_Intersection\n+     (Container : Set;\n+      Left      : Set;\n+      Right     : Set) return Boolean\n    is\n-     ((for all E of Result =>\n-         Mem (S1, E)\n-           and Mem (S2, E))\n-           and (for all E of S1 => (if Mem (S2, E) then Mem (Result, E))));\n+     (for all Item of Left =>\n+        (if Contains (Right, Item) then Contains (Container, Item)));\n+\n+   ------------------\n+   -- Intersection --\n+   ------------------\n+\n+   function Intersection (Left : Set; Right : Set) return Set is\n+     (Content => Intersection (Left.Content, Right.Content));\n \n    --------------\n-   -- Is_Union --\n+   -- Is_Empty --\n    --------------\n \n-   function Is_Union (S1 : Set; S2 : Set; Result : Set) return Boolean is\n-     ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n-         and (for all E of S1 => Mem (Result, E))\n-         and (for all E of S2 => Mem (Result, E)));\n+   function Is_Empty (Container : Set) return Boolean is\n+     (Length (Container.Content) = 0);\n \n    ------------\n    -- Length --\n    ------------\n \n-   function Length (S : Set) return Count_Type is (Length (S.Content));\n-\n-   ---------\n-   -- Mem --\n-   ---------\n-\n-   function Mem (S : Set; E : Element_Type) return Boolean is\n-     (Find (S.Content, E) > 0);\n+   function Length (Container : Set) return Count_Type is\n+     (Length (Container.Content));\n \n    ------------------\n    -- Num_Overlaps --\n    ------------------\n \n-   function Num_Overlaps (S1 : Set; S2 : Set) return Count_Type is\n-     (Num_Overlaps (S1.Content, S2.Content));\n+   function Num_Overlaps (Left : Set; Right : Set) return Count_Type is\n+     (Num_Overlaps (Left.Content, Right.Content));\n \n    ------------\n    -- Remove --\n    ------------\n \n-   function Remove (S : Set; E : Element_Type) return Set is\n-     (Content => Remove (S.Content, Find (S.Content, E)));\n+   function Remove (Container : Set; Item : Element_Type) return Set is\n+     (Content => Remove (Container.Content, Find (Container.Content, Item)));\n \n    -----------\n    -- Union --\n    -----------\n \n-   function Union (S1 : Set; S2 : Set) return Set is\n-     (Content => Union (S1.Content, S2.Content));\n+   function Union (Left : Set; Right : Set) return Set is\n+     (Content => Union (Left.Content, Right.Content));\n \n end Ada.Containers.Functional_Sets;"}, {"sha": "f9848f9d4ed986f08d4e7c25b6cacfe128a11dfe", "filename": "gcc/ada/a-cofuse.ads", "status": "modified", "additions": 125, "deletions": 89, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuse.ads?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -34,12 +34,10 @@ private with Ada.Containers.Functional_Base;\n \n generic\n    type Element_Type (<>) is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n+   with\n+     function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n package Ada.Containers.Functional_Sets with SPARK_Mode is\n \n-   pragma Assertion_Policy (Post => Ignore);\n-\n    type Set is private with\n      Default_Initial_Condition => Is_Empty (Set) and Length (Set) = 0,\n      Iterable                  => (First       => Iter_First,\n@@ -50,151 +48,182 @@ package Ada.Containers.Functional_Sets with SPARK_Mode is\n    --  \"For in\" quantification over sets should not be used.\n    --  \"For of\" quantification over sets iterates over elements.\n \n-   --  Sets are axiomatized using Mem, which encodes whether an element is\n+   -----------------------\n+   --  Basic operations --\n+   -----------------------\n+\n+   --  Sets are axiomatized using Contains, which encodes whether an element is\n    --  contained in a set. The length of a set is also added to protect Add\n    --  against overflows but it is not actually modeled.\n \n-   function Mem (S : Set; E : Element_Type) return Boolean with\n+   function Contains (Container : Set; Item : Element_Type) return Boolean with\n      Global => null;\n+   --  Return True if Item is contained in Container\n \n-   function Length (S : Set) return Count_Type with\n+   function Length (Container : Set) return Count_Type with\n      Global => null;\n+   --  Return the number of elements in Container\n+\n+   ------------------------\n+   -- Property Functions --\n+   ------------------------\n \n-   function \"<=\" (S1 : Set; S2 : Set) return Boolean with\n+   function \"<=\" (Left : Set; Right : Set) return Boolean with\n    --  Set inclusion\n \n      Global => null,\n-     Post   => \"<=\"'Result = (for all E of S1 => Mem (S2, E));\n+     Post   => \"<=\"'Result = (for all Item of Left => Contains (Right, Item));\n \n-   function \"=\" (S1 : Set; S2 : Set) return Boolean with\n+   function \"=\" (Left : Set; Right : Set) return Boolean with\n    --  Extensional equality over sets\n \n      Global => null,\n      Post   =>\n        \"=\"'Result =\n-         ((for all E of S1 => Mem (S2, E))\n-             and (for all E of S2 => Mem (S1, E)));\n+         ((for all Item of Left => Contains (Right, Item))\n+             and (for all Item of Right => Contains (Left, Item)));\n \n-   pragma Warnings (Off, \"unused variable \"\"E\"\"\");\n-   function Is_Empty (S : Set) return Boolean with\n+   pragma Warnings (Off, \"unused variable \"\"Item\"\"\");\n+   function Is_Empty (Container : Set) return Boolean with\n    --  A set is empty if it contains no element\n \n      Global => null,\n-     Post   => Is_Empty'Result = (for all E of S => False);\n-   pragma Warnings (On, \"unused variable \"\"E\"\"\");\n+     Post   => Is_Empty'Result = (for all Item of Container => False);\n+   pragma Warnings (On, \"unused variable \"\"Item\"\"\");\n \n-   function Is_Add (S : Set; E : Element_Type; Result : Set) return Boolean\n-   --  Returns True if Result is S augmented with E\n+   function Included_Except\n+     (Left  : Set;\n+      Right : Set;\n+      Item  : Element_Type) return Boolean\n+   --  Return True if Left contains only elements of Right except possibly\n+   --  Item.\n \n    with\n      Global => null,\n      Post   =>\n-       Is_Add'Result =\n-         (Mem (Result, E)\n-            and not Mem (S, E)\n-            and (for all F of Result => Mem (S, F) or F = E)\n-            and (for all E of S => Mem (Result, E)));\n-\n-   function Add (S : Set; E : Element_Type) return Set with\n-   --  Returns S augmented with E.\n-   --  Is_Add (S, E, Result) should be used instead of Result = Add (S, E)\n-   --  whenever possible both for execution and for proof.\n+       Included_Except'Result =\n+           (for all E of Left =>\n+              Contains (Right, E) or Equivalent_Elements (E, Item));\n+\n+   function Includes_Intersection\n+     (Container : Set;\n+      Left      : Set;\n+      Right     : Set) return Boolean\n+   with\n+   --  Return True if every element of the intersection of Left and Right is\n+   --  in Container.\n \n      Global => null,\n-     Pre    => not Mem (S, E) and Length (S) < Count_Type'Last,\n      Post   =>\n-       Length (Add'Result) = Length (S) + 1\n-         and Is_Add (S, E, Add'Result);\n-\n-   function Remove (S : Set; E : Element_Type) return Set with\n-   --  Returns S without E.\n-   --  Is_Add (Result, E, S) should be used instead of Result = Remove (S, E)\n-   --  whenever possible both for execution and for proof.\n+       Includes_Intersection'Result =\n+         (for all Item of Left =>\n+             (if Contains (Right, Item) then Contains (Container, Item)));\n+\n+   function Included_In_Union\n+     (Container : Set;\n+      Left      : Set;\n+      Right     : Set) return Boolean\n+   with\n+   --  Return True if every element of Container is the union of Left and Right\n \n      Global => null,\n-     Pre    => Mem (S, E),\n      Post   =>\n-       Length (Remove'Result) = Length (S) - 1\n-         and Is_Add (Remove'Result, E, S);\n+       Included_In_Union'Result =\n+         (for all Item of Container =>\n+            Contains (Left, Item) or Contains (Right, Item));\n \n-   function Is_Intersection\n-     (S1     : Set;\n-      S2     : Set;\n-      Result : Set) return Boolean\n-   with\n-   --  Returns True if Result is the intersection of S1 and S2\n+   function Num_Overlaps (Left : Set; Right : Set) return Count_Type with\n+   --  Number of elements that are both in Left and Right\n \n      Global => null,\n      Post   =>\n-       Is_Intersection'Result =\n-         ((for all E of Result => Mem (S1, E) and Mem (S2, E))\n-             and (for all E of S1 => (if Mem (S2, E) then Mem (Result, E))));\n+       Num_Overlaps'Result <= Length (Left)\n+         and Num_Overlaps'Result <= Length (Right)\n+         and (if Num_Overlaps'Result = 0 then\n+               (for all Item of Left => not Contains (Right, Item)));\n+\n+   ----------------------------\n+   -- Construction Functions --\n+   ----------------------------\n \n-   function Num_Overlaps (S1 : Set; S2 : Set) return Count_Type with\n-   --  Number of elements that are both in S1 and S2\n+   --  For better efficiency of both proofs and execution, avoid using\n+   --  construction functions in annotations and rather use property functions.\n+\n+   function Add (Container : Set; Item : Element_Type) return Set with\n+   --  Return a new set containing all the elements of Container plus E\n \n      Global => null,\n+     Pre    =>\n+       not Contains (Container, Item)\n+       and Length (Container) < Count_Type'Last,\n      Post   =>\n-       Num_Overlaps'Result <= Length (S1)\n-         and Num_Overlaps'Result <= Length (S2)\n-         and (if Num_Overlaps'Result = 0 then\n-               (for all E of S1 => not Mem (S2, E)));\n+       Length (Add'Result) = Length (Container) + 1\n+       and Contains (Add'Result, Item)\n+       and Container <= Add'Result\n+       and Included_Except (Add'Result, Container, Item);\n \n-   function Intersection (S1 : Set; S2 : Set) return Set with\n-   --  Returns the intersection of S1 and S2.\n-   --  Intersection (S1, S2, Result) should be used instead of\n-   --  Result = Intersection (S1, S2) whenever possible both for execution and\n-   --  for proof.\n+   function Remove (Container : Set; Item : Element_Type) return Set with\n+   --  Return a new set containing all the elements of Container except E\n \n      Global => null,\n+     Pre    => Contains (Container, Item),\n      Post   =>\n-       Length (Intersection'Result) = Num_Overlaps (S1, S2)\n-         and Is_Intersection (S1, S2, Intersection'Result);\n+       Length (Remove'Result) = Length (Container) - 1\n+       and not Contains (Remove'Result, Item)\n+       and Remove'Result <= Container\n+       and Included_Except (Container, Remove'Result, Item);\n \n-   function Is_Union (S1 : Set; S2 : Set; Result : Set) return Boolean with\n-   --  Returns True if Result is the union of S1 and S2\n+   function Intersection (Left : Set; Right : Set) return Set with\n+   --  Returns the intersection of Left and Right\n \n      Global => null,\n      Post   =>\n-       Is_Union'Result =\n-         ((for all E of Result => Mem (S1, E) or Mem (S2, E))\n-             and (for all E of S1 => Mem (Result, E))\n-             and (for all E of S2 => Mem (Result, E)));\n+       Length (Intersection'Result) = Num_Overlaps (Left, Right)\n+         and Intersection'Result <= Left\n+         and Intersection'Result <= Right\n+         and Includes_Intersection (Intersection'Result, Left, Right);\n \n-   function Union (S1 : Set; S2 : Set) return Set with\n-   --  Returns the union of S1 and S2.\n-   --  Is_Union (S1, S2, Result) should be used instead of\n-   --  Result = Union (S1, S2) whenever possible both for execution and for\n-   --  proof.\n+   function Union (Left : Set; Right : Set) return Set with\n+   --  Returns the union of Left and Right\n \n      Global => null,\n      Pre    =>\n-       Length (S1) - Num_Overlaps (S1, S2) <= Count_Type'Last - Length (S2),\n+       Length (Left) - Num_Overlaps (Left, Right)\n+         <= Count_Type'Last - Length (Right),\n      Post   =>\n        Length (Union'Result) =\n-         Length (S1) - Num_Overlaps (S1, S2) + Length (S2)\n-           and Is_Union (S1, S2, Union'Result);\n+         Length (Left) - Num_Overlaps (Left, Right) + Length (Right)\n+           and Left <= Union'Result\n+           and Right <= Union'Result\n+           and Included_In_Union (Union'Result, Left, Right);\n \n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------\n \n    type Private_Key is private;\n \n-   function Iter_First (S : Set) return Private_Key with\n+   function Iter_First (Container : Set) return Private_Key with\n      Global => null;\n \n-   function Iter_Has_Element (S : Set; K : Private_Key) return Boolean with\n+   function Iter_Has_Element\n+     (Container : Set;\n+      Key       : Private_Key) return Boolean\n+   with\n      Global => null;\n \n-   function Iter_Next (S : Set; K : Private_Key) return Private_Key with\n+   function Iter_Next (Container : Set; Key : Private_Key) return Private_Key\n+   with\n      Global => null,\n-     Pre    => Iter_Has_Element (S, K);\n+     Pre    => Iter_Has_Element (Container, Key);\n \n-   function Iter_Element (S : Set; K : Private_Key) return Element_Type with\n+   function Iter_Element\n+     (Container : Set;\n+      Key       : Private_Key) return Element_Type\n+   with\n      Global => null,\n-     Pre    => Iter_Has_Element (S, K);\n-   pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Mem);\n+     Pre    => Iter_Has_Element (Container, Key);\n+   pragma Annotate (GNATprove, Iterable_For_Proof, \"Contains\", Contains);\n \n private\n \n@@ -212,15 +241,22 @@ private\n \n    type Private_Key is new Count_Type;\n \n-   function Iter_First (S : Set) return Private_Key is (1);\n+   function Iter_First (Container : Set) return Private_Key is (1);\n \n-   function Iter_Has_Element (S : Set; K : Private_Key) return Boolean is\n-     (Count_Type (K) in 1 .. Containers.Length (S.Content));\n+   function Iter_Has_Element\n+     (Container : Set;\n+      Key       : Private_Key) return Boolean\n+   is\n+     (Count_Type (Key) in 1 .. Containers.Length (Container.Content));\n \n-   function Iter_Next (S : Set; K : Private_Key) return Private_Key is\n-     (if K = Private_Key'Last then 0 else K + 1);\n+   function Iter_Next (Container : Set; Key : Private_Key) return Private_Key\n+   is\n+     (if Key = Private_Key'Last then 0 else Key + 1);\n \n-   function Iter_Element (S : Set; K : Private_Key) return Element_Type is\n-     (Containers.Get (S.Content, Count_Type (K)));\n+   function Iter_Element\n+     (Container : Set;\n+      Key       : Private_Key) return Element_Type\n+   is\n+     (Containers.Get (Container.Content, Count_Type (Key)));\n \n end Ada.Containers.Functional_Sets;"}, {"sha": "e8f8757468b1216888e6eaf9d4712f21607ba8e3", "filename": "gcc/ada/a-cofuve.adb", "status": "modified", "additions": 166, "deletions": 80, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -33,130 +33,216 @@ pragma Ada_2012;\n package body Ada.Containers.Functional_Vectors with SPARK_Mode => Off is\n    use Containers;\n \n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (S1 : Sequence; S2 : Sequence) return Boolean is\n-     (S1.Content = S2.Content);\n-\n    ---------\n    -- \"<\" --\n    ---------\n \n-   function \"<\" (S1 : Sequence; S2 : Sequence) return Boolean is\n-     (Length (S1.Content) < Length (S2.Content)\n-       and then (for all I in Index_Type'First .. Last (S1) =>\n-                   Get (S1.Content, I) = Get (S2.Content, I)));\n+   function \"<\" (Left : Sequence; Right : Sequence) return Boolean is\n+     (Length (Left.Content) < Length (Right.Content)\n+       and then (for all I in Index_Type'First .. Last (Left) =>\n+                   Get (Left.Content, I) = Get (Right.Content, I)));\n \n    ----------\n    -- \"<=\" --\n    ----------\n \n-   function \"<=\" (S1 : Sequence; S2 : Sequence) return Boolean is\n-     (Length (S1.Content) <= Length (S2.Content)\n-       and then (for all I in Index_Type'First .. Last (S1) =>\n-                   Get (S1.Content, I) = Get (S2.Content, I)));\n+   function \"<=\" (Left : Sequence; Right : Sequence) return Boolean is\n+     (Length (Left.Content) <= Length (Right.Content)\n+       and then (for all I in Index_Type'First .. Last (Left) =>\n+                   Get (Left.Content, I) = Get (Right.Content, I)));\n \n    ---------\n-   -- Add --\n+   -- \"=\" --\n    ---------\n \n-   function Add (S : Sequence; E : Element_Type) return Sequence is\n-     (Content => Add (S.Content,\n-                      Index_Type'Val\n-                        (Index_Type'Pos (Index_Type'First) +\n-                             Length (S.Content)),\n-                      E));\n+   function \"=\" (Left : Sequence; Right : Sequence) return Boolean is\n+     (Left.Content = Right.Content);\n \n    ---------\n-   -- Get --\n+   -- Add --\n    ---------\n \n-   function Get (S : Sequence; N : Extended_Index) return Element_Type is\n-     (Get (S.Content, N));\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   function Insert\n-     (S : Sequence;\n-      N : Index_Type;\n-      E : Element_Type) return Sequence\n+   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n    is\n-     (Content => Add (S.Content, N, E));\n-\n-   ------------\n-   -- Is_Add --\n-   ------------\n+     (Content => Add (Container.Content,\n+                      Index_Type'Val\n+                        (Index_Type'Pos (Index_Type'First) +\n+                             Length (Container.Content)),\n+                      New_Item));\n \n-   function Is_Add\n-     (S      : Sequence;\n-      E      : Element_Type;\n-      Result : Sequence) return Boolean\n+   function Add\n+     (Container : Sequence;\n+      Position  : Index_Type;\n+      New_Item  : Element_Type) return Sequence\n+   is\n+     (Content => Add (Container.Content, Position, New_Item));\n+\n+   --------------------\n+   -- Constant_Range --\n+   --------------------\n+\n+   function Constant_Range\n+     (Container : Sequence;\n+      Fst       : Index_Type;\n+      Lst       : Extended_Index;\n+      Item      : Element_Type) return Boolean is\n+   begin\n+      for I in Fst .. Lst loop\n+         if Get (Container.Content, I) /= Item then\n+            return False;\n+         end if;\n+      end loop;\n+      return True;\n+   end Constant_Range;\n+\n+   --------------\n+   -- Contains --\n+   --------------\n+\n+   function Contains\n+     (Container : Sequence;\n+      Fst       : Index_Type;\n+      Lst       : Extended_Index;\n+      Item      : Element_Type) return Boolean\n    is\n-     (Length (Result) = Length (S) + 1\n-       and then Get (Result, Index_Type'Val\n-                      ((Index_Type'Pos (Index_Type'First) - 1) +\n-                          Length (Result))) = E\n-      and then\n-        (for all M in Index_Type'First ..\n-           (Index_Type'Val\n-              ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))) =>\n-                  Get (Result, M) = Get (S, M)));\n+   begin\n+      for I in Fst .. Lst loop\n+         if Get (Container.Content, I) = Item then\n+            return True;\n+         end if;\n+      end loop;\n+      return False;\n+   end Contains;\n+\n+   ------------------\n+   -- Range_Except --\n+   ------------------\n+\n+   function Equal_Except\n+     (Left     : Sequence;\n+      Right    : Sequence;\n+      Position : Index_Type) return Boolean\n+   is\n+   begin\n+      if Length (Left.Content) /= Length (Right.Content) then\n+         return False;\n+      end if;\n+\n+      for I in Index_Type'First .. Last (Left) loop\n+         if I /= Position\n+           and then Get (Left.Content, I) /= Get (Right.Content, I)\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Equal_Except;\n+\n+   function Equal_Except\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      X, Y  : Index_Type) return Boolean\n+   is\n+   begin\n+      if Length (Left.Content) /= Length (Right.Content) then\n+         return False;\n+      end if;\n+\n+      for I in Index_Type'First .. Last (Left) loop\n+         if I /= X and then I /= Y\n+           and then Get (Left.Content, I) /= Get (Right.Content, I)\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Equal_Except;\n \n-   ------------\n-   -- Is_Set --\n-   ------------\n+   ---------\n+   -- Get --\n+   ---------\n \n-   function Is_Set\n-     (S      : Sequence;\n-      N      : Index_Type;\n-      E      : Element_Type;\n-      Result : Sequence) return Boolean\n+   function Get (Container : Sequence;\n+                 Position  : Extended_Index) return Element_Type\n    is\n-     (N in Index_Type'First ..\n-             (Index_Type'Val\n-                  ((Index_Type'Pos (Index_Type'First) - 1) + Length (S)))\n-      and then Length (Result) = Length (S)\n-      and then Get (Result, N) = E\n-      and then\n-        (for all M in  Index_Type'First ..\n-             (Index_Type'Val\n-                  ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))) =>\n-             (if M /= N then Get (Result, M) = Get (S, M))));\n+     (Get (Container.Content, Position));\n \n    ----------\n    -- Last --\n    ----------\n \n-   function Last (S : Sequence) return Extended_Index is\n-     (Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) + Length (S)));\n+   function Last (Container : Sequence) return Extended_Index is\n+     (Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1)\n+                      + Length (Container)));\n \n    ------------\n    -- Length --\n    ------------\n \n-   function Length (S : Sequence) return Count_Type is\n-     (Length (S.Content));\n+   function Length (Container : Sequence) return Count_Type is\n+     (Length (Container.Content));\n+\n+   -----------------\n+   -- Range_Equal --\n+   -----------------\n+\n+   function Range_Equal\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      Fst   : Index_Type;\n+      Lst   : Extended_Index) return Boolean\n+   is\n+   begin\n+      for I in Fst .. Lst loop\n+         if Get (Left, I) /= Get (Right, I) then\n+            return False;\n+         end if;\n+      end loop;\n+      return True;\n+   end Range_Equal;\n+\n+   -------------------\n+   -- Range_Shifted --\n+   -------------------\n+\n+   function Range_Shifted\n+     (Left   : Sequence;\n+      Right  : Sequence;\n+      Fst    : Index_Type;\n+      Lst    : Extended_Index;\n+      Offset : Count_Type'Base) return Boolean\n+   is\n+   begin\n+      for I in Fst .. Lst loop\n+         if Get (Left, I)\n+           /= Get (Right, Index_Type'Val (Index_Type'Pos (I) + Offset))\n+         then\n+            return False;\n+         end if;\n+      end loop;\n+      return True;\n+   end Range_Shifted;\n \n    ------------\n    -- Remove --\n    ------------\n \n-   function Remove (S : Sequence; N : Index_Type) return Sequence is\n-     (Content => Remove (S.Content, N));\n+   function Remove (Container : Sequence;\n+                    Position : Index_Type) return Sequence\n+   is\n+     (Content => Remove (Container.Content, Position));\n \n    ---------\n    -- Set --\n    ---------\n \n    function Set\n-     (S : Sequence;\n-      N : Index_Type;\n-      E : Element_Type) return Sequence\n+     (Container : Sequence;\n+      Position  : Index_Type;\n+      New_Item  : Element_Type) return Sequence\n    is\n-     (Content => Set (S.Content, N, E));\n+     (Content => Set (Container.Content, Position, New_Item));\n \n end Ada.Containers.Functional_Vectors;"}, {"sha": "ad359b41e101b15ae97a05d4debc45d5b31a869a", "filename": "gcc/ada/a-cofuve.ads", "status": "modified", "additions": 231, "deletions": 115, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofuve.ads?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -38,12 +38,8 @@ generic\n    --  should have at least one more element at the low end than Index_Type.\n \n    type Element_Type (<>) is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n package Ada.Containers.Functional_Vectors with SPARK_Mode is\n \n-   pragma Assertion_Policy (Post => Ignore);\n-\n    subtype Extended_Index is Index_Type'Base range\n      Index_Type'Pred (Index_Type'First) .. Index_Type'Last;\n    --  Index_Type with one more element at the low end of the range.\n@@ -60,178 +56,299 @@ package Ada.Containers.Functional_Vectors with SPARK_Mode is\n    --  Quantification over sequences can be done using the regular\n    --  quantification over its range or directly on its elements with \"for of\".\n \n+   -----------------------\n+   --  Basic operations --\n+   -----------------------\n+\n    --  Sequences are axiomatized using Length and Get, providing respectively\n    --  the length of a sequence and an accessor to its Nth element:\n \n-   function Length (S : Sequence) return Count_Type with\n+   function Length (Container : Sequence) return Count_Type with\n+   --  Length of a sequence\n+\n      Global => null,\n      Post   =>\n        (Index_Type'Pos (Index_Type'First) - 1) + Length'Result <=\n           Index_Type'Pos (Index_Type'Last);\n \n-   function Last (S : Sequence) return Extended_Index with\n+   function Get\n+     (Container : Sequence;\n+      Position  : Extended_Index) return Element_Type\n+   --  Access the Element at position Position in Container\n+\n+   with\n      Global => null,\n-     Post   =>\n+     Pre    => Position in Index_Type'First .. Last (Container);\n+\n+   function Last (Container : Sequence) return Extended_Index with\n+   --  Last index of a sequence\n+\n+     Global => null,\n+     Post =>\n        Last'Result =\n-         Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1) + Length (S));\n+         Index_Type'Val ((Index_Type'Pos (Index_Type'First) - 1)\n+                         + Length (Container));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Last);\n \n    function First return Extended_Index is (Index_Type'First);\n+   --  First index of a sequence\n \n-   function Get (S : Sequence; N : Extended_Index) return Element_Type\n-   --  Get ranges over Extended_Index so that it can be used for iteration\n+   ------------------------\n+   -- Property Functions --\n+   ------------------------\n \n-   with\n-     Global => null,\n-     Pre    => N in Index_Type'First .. Last (S);\n-\n-   function \"=\" (S1 : Sequence; S2 : Sequence) return Boolean with\n+   function \"=\" (Left : Sequence; Right : Sequence) return Boolean with\n    --  Extensional equality over sequences\n \n      Global => null,\n      Post   =>\n        \"=\"'Result =\n-         (Length (S1) = Length (S2)\n-            and then (for all N in Index_Type'First .. Last (S1) =>\n-                        Get (S1, N) = Get (S2, N)));\n+         (Length (Left) = Length (Right)\n+          and then (for all N in Index_Type'First .. Last (Left) =>\n+              Get (Left, N) = Get (Right, N)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, \"=\");\n \n-   function \"<\" (S1 : Sequence; S2 : Sequence) return Boolean with\n-   --  S1 is a strict subsequence of S2\n+   function \"<\" (Left : Sequence; Right : Sequence) return Boolean with\n+   --  Left is a strict subsequence of Right\n \n      Global => null,\n      Post   =>\n        \"<\"'Result =\n-         (Length (S1) < Length (S2)\n-            and then (for all N in Index_Type'First .. Last (S1) =>\n-                        Get (S1, N) = Get (S2, N)));\n+         (Length (Left) < Length (Right)\n+          and then (for all N in Index_Type'First .. Last (Left) =>\n+              Get (Left, N) = Get (Right, N)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, \"<\");\n \n-   function \"<=\" (S1 : Sequence; S2 : Sequence) return Boolean with\n-   --  S1 is a subsequence of S2\n+   function \"<=\" (Left : Sequence; Right : Sequence) return Boolean with\n+   --  Left is a subsequence of Right\n \n      Global => null,\n      Post   =>\n        \"<=\"'Result =\n-         (Length (S1) <= Length (S2)\n-            and then (for all N in Index_Type'First .. Last (S1) =>\n-                        Get (S1, N) = Get (S2, N)));\n-\n-   function Is_Set\n-     (S      : Sequence;\n-      N      : Index_Type;\n-      E      : Element_Type;\n-      Result : Sequence) return Boolean\n-   --  Returns True if Result is S, where the Nth element has been replaced by\n-   --  E.\n+         (Length (Left) <= Length (Right)\n+          and then (for all N in Index_Type'First .. Last (Left) =>\n+              Get (Left, N) = Get (Right, N)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, \"<=\");\n+\n+   function Contains\n+     (Container : Sequence;\n+      Fst       : Index_Type;\n+      Lst       : Extended_Index;\n+      Item      : Element_Type)\n+         return Boolean\n+   --  Returns True if Item occurs in the range from Fst to Lst of Container\n \n    with\n      Global => null,\n+     Pre    => Lst <= Last (Container),\n      Post   =>\n-       Is_Set'Result =\n-         (N in Index_Type'First .. Last (S)\n-           and then Length (Result) = Length (S)\n-           and then Get (Result, N) = E\n-           and then (for all M in Index_Type'First .. Last (S) =>\n-                       (if M /= N then Get (Result, M) = Get (S, M))));\n+       Contains'Result =\n+         (for some I in Fst .. Lst => Get (Container, I) = Item);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n+\n+   function Constant_Range\n+     (Container : Sequence;\n+      Fst       : Index_Type;\n+      Lst       : Extended_Index;\n+      Item      : Element_Type)\n+         return Boolean\n+   --  Returns True if every element of the range from Fst to Lst of Container\n+   --  is equal to Item.\n \n-   function Set\n-     (S : Sequence;\n-      N : Index_Type;\n-      E : Element_Type) return Sequence\n-   --  Returns S, where the Nth element has been replaced by E.\n-   --  Is_Set (S, N, E, Result) should be used instead of\n-   --  Result = Set (S, N, E) whenever possible both for execution and for\n-   --  proof.\n+   with\n+     Global => null,\n+     Pre    => Lst <= Last (Container),\n+     Post   =>\n+       Constant_Range'Result =\n+         (for all I in Fst .. Lst => Get (Container, I) = Item);\n+   pragma Annotate (GNATprove, Inline_For_Proof, Constant_Range);\n+\n+   function Equal_Except\n+     (Left     : Sequence;\n+      Right    : Sequence;\n+      Position : Index_Type) return Boolean\n+   --  Returns True is Left and Right are the same except at position Position\n+\n+   with\n+     Global => null,\n+     Pre    => Position <= Last (Left),\n+     Post   =>\n+       Equal_Except'Result =\n+         (Length (Left) = Length (Right)\n+          and then (for all I in Index_Type'First .. Last (Left) =>\n+              (if I /= Position then Get (Left, I) = Get (Right, I))));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n+\n+   function Equal_Except\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      X, Y  : Index_Type) return Boolean\n+   --  Returns True is Left and Right are the same except at positions X and Y\n \n    with\n      Global => null,\n-     Pre    => N in Index_Type'First .. Last (S),\n-     Post   => Is_Set (S, N, E, Set'Result);\n+     Pre    => X <= Last (Left) and Y <= Last (Left),\n+     Post   =>\n+       Equal_Except'Result =\n+         (Length (Left) = Length (Right)\n+          and then (for all I in Index_Type'First .. Last (Left) =>\n+              (if I /= X and I /= Y then Get (Left, I) = Get (Right, I))));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n+\n+   function Range_Equal\n+     (Left  : Sequence;\n+      Right : Sequence;\n+      Fst   : Index_Type;\n+      Lst   : Extended_Index) return Boolean\n+   --  Returns True if the ranges from Fst to Lst contain the same elements in\n+   --  Left and Right.\n \n-   function Is_Add\n-     (S      : Sequence;\n-      E      : Element_Type;\n-      Result : Sequence) return Boolean\n-   --  Returns True if Result is S appended with E\n+   with\n+     Global => null,\n+     Pre    => Lst <= Last (Left) and Lst <= Last (Right),\n+     Post   =>\n+       Range_Equal'Result =\n+         (for all I in Fst .. Lst => Get (Left, I) = Get (Right, I));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Range_Equal);\n+\n+   function Range_Shifted\n+     (Left   : Sequence;\n+      Right  : Sequence;\n+      Fst    : Index_Type;\n+      Lst    : Extended_Index;\n+      Offset : Count_Type'Base) return Boolean\n+   --  Returns True if the range from Fst to Lst in Left contains the same\n+   --  elements as the range from Fst + Offset to Lst + Offset in Right.\n \n    with\n      Global => null,\n+     Pre    => Lst <= Last (Left)\n+           and Offset in\n+              Index_Type'Pos (Index_Type'First) - Index_Type'Pos (Fst) ..\n+                   (Index_Type'Pos (Index_Type'First) - 1)\n+                  + Length (Right) - Index_Type'Pos (Lst),\n      Post   =>\n-       Is_Add'Result =\n-         (Length (Result) = Length (S) + 1\n-           and then Get (Result, Last (Result)) = E\n-           and then (for all M in Index_Type'First .. Last (S) =>\n-                       Get (Result, M) = Get (S, M)));\n+       Range_Shifted'Result =\n+         ((for all I in Fst .. Lst =>\n+                   Get (Left, I)\n+           = Get (Right, Index_Type'Val (Index_Type'Pos (I) + Offset)))\n+          and\n+            (for all I in Index_Type'Val (Index_Type'Pos (Fst) + Offset) ..\n+               Index_Type'Val (Index_Type'Pos (Lst) + Offset) =>\n+                 Get (Left, Index_Type'Val (Index_Type'Pos (I) - Offset))\n+             = Get (Right, I)));\n+   pragma Annotate (GNATprove, Inline_For_Proof, Range_Shifted);\n+\n+   ----------------------------\n+   -- Construction Functions --\n+   ----------------------------\n+\n+   --  For better efficiency of both proofs and execution, avoid using\n+   --  construction functions in annotations and rather use property functions.\n \n-   function Add (S : Sequence; E : Element_Type) return Sequence with\n-   --  Returns S appended with E.\n-   --  Is_Add (S, E, Result) should be used instead of Result = Add (S, E)\n-   --  whenever possible both for execution and for proof.\n+   function Set\n+     (Container : Sequence;\n+      Position  : Index_Type;\n+      New_Item  : Element_Type) return Sequence\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  except for the one at position Position which is replaced by New_Item.\n \n+   with\n      Global => null,\n-     Pre    => Length (S) < Count_Type'Last and Last (S) < Index_Type'Last,\n-     Post   => Is_Add (S, E, Add'Result);\n+     Pre    => Position in Index_Type'First .. Last (Container),\n+     Post   => Get (Set'Result, Position) = New_Item\n+     and then Equal_Except (Container, Set'Result, Position);\n \n-   function Insert\n-     (S : Sequence;\n-      N : Index_Type;\n-      E : Element_Type) return Sequence\n+   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  plus New_Item at the end.\n+\n+   with\n+     Global => null,\n+     Pre    =>\n+       Length (Container) < Count_Type'Last\n+         and then Last (Container) < Index_Type'Last,\n+     Post   =>\n+       Length (Add'Result) = Length (Container) + 1\n+         and then Get (Add'Result, Last (Add'Result)) = New_Item\n+         and then Container <= Add'Result;\n+\n+   function Add\n+     (Container : Sequence;\n+      Position  : Index_Type;\n+      New_Item  : Element_Type) return Sequence\n    with\n-   --  Returns S with E inserted at index I\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  except that New_Item has been inserted at position Position.\n \n      Global => null,\n      Pre    =>\n-       Length (S) < Count_Type'Last\n-         and then Last (S) < Index_Type'Last\n-         and then N <= Extended_Index'Succ (Last (S)),\n+       Length (Container) < Count_Type'Last\n+         and then Last (Container) < Index_Type'Last\n+         and then Position <= Extended_Index'Succ (Last (Container)),\n      Post   =>\n-       Length (Insert'Result) = Length (S) + 1\n-         and then Get (Insert'Result, N) = E\n+       Length (Add'Result) = Length (Container) + 1\n+         and then Get (Add'Result, Position) = New_Item\n          and then\n-           (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n-              Get (Insert'Result, M) = Get (S, M))\n+            Range_Equal (Left  => Container,\n+                         Right =>  Add'Result,\n+                         Fst   => Index_Type'First,\n+                         Lst   => Index_Type'Pred (Position))\n          and then\n-           (for all M in Extended_Index'Succ (N) ..  Last (Insert'Result) =>\n-              Get (Insert'Result, M) = Get (S, Extended_Index'Pred (M)))\n-         and then\n-           (for all M in N .. Last (S) =>\n-              Get (Insert'Result, Extended_Index'Succ (M)) = Get (S, M));\n-\n-   function Remove (S : Sequence; N : Index_Type) return Sequence with\n-   --  Returns S without the element at index N\n+            Range_Shifted (Left   => Container,\n+                           Right  => Add'Result,\n+                           Fst    => Position,\n+                           Lst    => Last (Container),\n+                           Offset => 1);\n+\n+   function Remove\n+     (Container : Sequence;\n+      Position : Index_Type) return Sequence\n+   --  Returns a new sequence which contains the same elements as Container\n+   --  except that the element at position Position has been removed.\n \n+   with\n      Global => null,\n      Pre    =>\n-       Length (S) < Count_Type'Last\n-         and Last (S) < Index_Type'Last\n-         and N in Index_Type'First .. Last (S),\n+       Length (Container) < Count_Type'Last\n+         and Last (Container) < Index_Type'Last\n+         and Position in Index_Type'First .. Last (Container),\n      Post   =>\n-       Length (Remove'Result) = Length (S) - 1\n-         and then\n-           (for all M in Index_Type'First .. Extended_Index'Pred (N) =>\n-              Get (Remove'Result, M) = Get (S, M))\n+       Length (Remove'Result) = Length (Container) - 1\n          and then\n-           (for all M in N .. Last (Remove'Result) =>\n-              Get (Remove'Result, M) = Get (S, Extended_Index'Succ (M)))\n+            Range_Equal (Left  => Container,\n+                         Right => Remove'Result,\n+                         Fst   => Index_Type'First,\n+                         Lst   => Index_Type'Pred (Position))\n          and then\n-           (for all M in Extended_Index'Succ (N) .. Last (S) =>\n-              Get (Remove'Result, Extended_Index'Pred (M)) = Get (S, M));\n+            Range_Shifted (Left   => Remove'Result,\n+                           Right  => Container,\n+                           Fst    => Position,\n+                           Lst    => Last (Remove'Result),\n+                           Offset => 1);\n \n    ---------------------------\n    --  Iteration Primitives --\n    ---------------------------\n \n-   function Iter_First (S : Sequence) return Extended_Index with\n+   function Iter_First (Container : Sequence) return Extended_Index with\n      Global => null;\n \n-   function Iter_Has_Element (S : Sequence; I : Extended_Index) return Boolean\n+   function Iter_Has_Element\n+     (Container : Sequence;\n+      Position  : Extended_Index) return Boolean\n    with\n      Global => null,\n-     Post   => Iter_Has_Element'Result = (I in Index_Type'First .. Last (S));\n+     Post   => Iter_Has_Element'Result =\n+         (Position in Index_Type'First .. Last (Container));\n    pragma Annotate (GNATprove, Inline_For_Proof, Iter_Has_Element);\n \n-   function Iter_Next (S : Sequence; I : Extended_Index) return Extended_Index\n+   function Iter_Next\n+     (Container : Sequence;\n+      Position  : Extended_Index) return Extended_Index\n    with\n      Global => null,\n-     Pre    => Iter_Has_Element (S, I);\n+     Pre    => Iter_Has_Element (Container, Position);\n \n private\n \n@@ -245,22 +362,21 @@ private\n       Content : Containers.Container;\n    end record;\n \n-   function Iter_First (S : Sequence) return Extended_Index is\n+   function Iter_First (Container : Sequence) return Extended_Index is\n      (Index_Type'First);\n-\n    function Iter_Next\n-     (S : Sequence;\n-      I : Extended_Index) return Extended_Index\n+     (Container : Sequence;\n+      Position  : Extended_Index) return Extended_Index\n    is\n-     (if I = Extended_Index'Last then Extended_Index'First\n-      else Extended_Index'Succ (I));\n+     (if Position = Extended_Index'Last then Extended_Index'First\n+      else Extended_Index'Succ (Position));\n \n    function Iter_Has_Element\n-     (S : Sequence;\n-      I : Extended_Index) return Boolean\n+     (Container : Sequence;\n+      Position  : Extended_Index) return Boolean\n    is\n-     (I in Index_Type'First ..\n-       (Index_Type'Val\n-         ((Index_Type'Pos (Index_Type'First) - 1) + Length (S))));\n+     (Position in Index_Type'First ..\n+        (Index_Type'Val\n+           ((Index_Type'Pos (Index_Type'First) - 1) + Length (Container))));\n \n end Ada.Containers.Functional_Vectors;"}, {"sha": "a346494f6c4b3a34cccb0be6e3150f05eb4d223a", "filename": "gcc/ada/a-except-2005.adb", "status": "removed", "additions": 0, "deletions": 1748, "changes": 1748, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de3b531c9aa93592f98ebd99c6b35be632e3c1b3/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de3b531c9aa93592f98ebd99c6b35be632e3c1b3/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=de3b531c9aa93592f98ebd99c6b35be632e3c1b3", "patch": "@@ -1,1748 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                       A D A . E X C E P T I O N S                        --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-pragma Style_Checks (All_Checks);\n---  No subprogram ordering check, due to logical grouping\n-\n-pragma Polling (Off);\n---  We must turn polling off for this unit, because otherwise we get\n---  elaboration circularities with System.Exception_Tables.\n-\n-with System;                  use System;\n-with System.Exceptions;       use System.Exceptions;\n-with System.Exceptions_Debug; use System.Exceptions_Debug;\n-with System.Standard_Library; use System.Standard_Library;\n-with System.Soft_Links;       use System.Soft_Links;\n-with System.WCh_Con;          use System.WCh_Con;\n-with System.WCh_StW;          use System.WCh_StW;\n-\n-pragma Warnings (Off);\n---  Suppress complaints about Symbolic not being referenced, and about it not\n---  having pragma Preelaborate.\n-with System.Traceback.Symbolic;\n---  Bring Symbolic into the closure. If it is the s-trasym-dwarf.adb version,\n---  it will install symbolic tracebacks as the default decorator. Otherwise,\n---  symbolic tracebacks are not supported, and we fall back to hexadecimal\n---  addresses.\n-pragma Warnings (On);\n-\n-package body Ada.Exceptions is\n-\n-   pragma Suppress (All_Checks);\n-   --  We definitely do not want exceptions occurring within this unit, or\n-   --  we are in big trouble. If an exceptional situation does occur, better\n-   --  that it not be raised, since raising it can cause confusing chaos.\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  Note: the exported subprograms in this package body are called directly\n-   --  from C clients using the given external name, even though they are not\n-   --  technically visible in the Ada sense.\n-\n-   function Code_Address_For_AAA return System.Address;\n-   function Code_Address_For_ZZZ return System.Address;\n-   --  Return start and end of procedures in this package\n-   --\n-   --  These procedures are used to provide exclusion bounds in\n-   --  calls to Call_Chain at exception raise points from this unit. The\n-   --  purpose is to arrange for the exception tracebacks not to include\n-   --  frames from subprograms involved in the raise process, as these are\n-   --  meaningless from the user's standpoint.\n-   --\n-   --  For these bounds to be meaningful, we need to ensure that the object\n-   --  code for the subprograms involved in processing a raise is located\n-   --  after the object code Code_Address_For_AAA and before the object\n-   --  code Code_Address_For_ZZZ. This will indeed be the case as long as\n-   --  the following rules are respected:\n-   --\n-   --  1) The bodies of the subprograms involved in processing a raise\n-   --     are located after the body of Code_Address_For_AAA and before the\n-   --     body of Code_Address_For_ZZZ.\n-   --\n-   --  2) No pragma Inline applies to any of these subprograms, as this\n-   --     could delay the corresponding assembly output until the end of\n-   --     the unit.\n-\n-   procedure Call_Chain (Excep : EOA);\n-   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n-   --  call chain.\n-\n-   function Image (Index : Integer) return String;\n-   --  Return string image corresponding to Index\n-\n-   procedure To_Stderr (S : String);\n-   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n-   --  Little routine to output string to stderr that is also used\n-   --  in the tasking run time.\n-\n-   procedure To_Stderr (C : Character);\n-   pragma Inline (To_Stderr);\n-   pragma Export (Ada, To_Stderr, \"__gnat_to_stderr_char\");\n-   --  Little routine to output a character to stderr, used by some of\n-   --  the separate units below.\n-\n-   package Exception_Data is\n-\n-      -----------------------------------\n-      -- Exception Message Subprograms --\n-      -----------------------------------\n-\n-      procedure Set_Exception_C_Msg\n-        (Excep  : EOA;\n-         Id     : Exception_Id;\n-         Msg1   : System.Address;\n-         Line   : Integer        := 0;\n-         Column : Integer        := 0;\n-         Msg2   : System.Address := System.Null_Address);\n-      --  This routine is called to setup the exception referenced by X\n-      --  to contain the indicated Id value and message. Msg1 is a null\n-      --  terminated string which is generated as the exception message. If\n-      --  line is non-zero, then a colon and the decimal representation of\n-      --  this integer is appended to the message. Ditto for Column. When Msg2\n-      --  is non-null, a space and this additional null terminated string is\n-      --  added to the message.\n-\n-      procedure Set_Exception_Msg\n-        (Excep   : EOA;\n-         Id      : Exception_Id;\n-         Message : String);\n-      --  This routine is called to setup the exception referenced by X\n-      --  to contain the indicated Id value and message. Message is a string\n-      --  which is generated as the exception message.\n-\n-      ---------------------------------------\n-      -- Exception Information Subprograms --\n-      ---------------------------------------\n-\n-      function Untailored_Exception_Information\n-        (X : Exception_Occurrence) return String;\n-      --  This is used by Stream_Attributes.EO_To_String to convert an\n-      --  Exception_Occurrence to a String for the stream attributes.\n-      --  String_To_EO understands the format, as documented here.\n-      --\n-      --  The format of the string is as follows:\n-      --\n-      --    raised <exception name> : <message>\n-      --    (\" : <message>\" is present only if Exception_Message is not empty)\n-      --    PID=nnnn (only if nonzero)\n-      --    Call stack traceback locations:  (only if at least one location)\n-      --    <0xyyyyyyyy 0xyyyyyyyy ...>      (is recorded)\n-      --\n-      --  The lines are separated by a ASCII.LF character.\n-      --  The nnnn is the partition Id given as decimal digits.\n-      --  The 0x... line represents traceback program counter locations, in\n-      --  execution order with the first one being the exception location.\n-      --\n-      --  The Exception_Name and Message lines are omitted in the abort\n-      --  signal case, since this is not really an exception.\n-      --\n-      --  Note: If the format of the generated string is changed, please note\n-      --  that an equivalent modification to the routine String_To_EO must be\n-      --  made to preserve proper functioning of the stream attributes.\n-\n-      function Exception_Information (X : Exception_Occurrence) return String;\n-      --  This is the implementation of Ada.Exceptions.Exception_Information,\n-      --  as defined in the Ada RM.\n-      --\n-      --  If no traceback decorator (see GNAT.Exception_Traces) is currently\n-      --  in place, this is the same as Untailored_Exception_Information.\n-      --  Otherwise, the decorator is used to produce a symbolic traceback\n-      --  instead of hexadecimal addresses.\n-      --\n-      --  Note that unlike Untailored_Exception_Information, there is no need\n-      --  to keep the output of Exception_Information stable for streaming\n-      --  purposes, and in fact the output differs across platforms.\n-\n-   end Exception_Data;\n-\n-   package Exception_Traces is\n-\n-      -------------------------------------------------\n-      -- Run-Time Exception Notification Subprograms --\n-      -------------------------------------------------\n-\n-      --  These subprograms provide a common run-time interface to trigger the\n-      --  actions required when an exception is about to be propagated (e.g.\n-      --  user specified actions or output of exception information). They are\n-      --  exported to be usable by the Ada exception handling personality\n-      --  routine when the GCC 3 mechanism is used.\n-\n-      procedure Notify_Handled_Exception (Excep : EOA);\n-      pragma Export\n-        (C, Notify_Handled_Exception, \"__gnat_notify_handled_exception\");\n-      --  This routine is called for a handled occurrence is about to be\n-      --  propagated.\n-\n-      procedure Notify_Unhandled_Exception (Excep : EOA);\n-      pragma Export\n-        (C, Notify_Unhandled_Exception, \"__gnat_notify_unhandled_exception\");\n-      --  This routine is called when an unhandled occurrence is about to be\n-      --  propagated.\n-\n-      procedure Unhandled_Exception_Terminate (Excep : EOA);\n-      pragma No_Return (Unhandled_Exception_Terminate);\n-      --  This procedure is called to terminate execution following an\n-      --  unhandled exception. The exception information, including\n-      --  traceback if available is output, and execution is then\n-      --  terminated. Note that at the point where this routine is\n-      --  called, the stack has typically been destroyed.\n-\n-   end Exception_Traces;\n-\n-   package Exception_Propagation is\n-\n-      ---------------------------------------\n-      -- Exception Propagation Subprograms --\n-      ---------------------------------------\n-\n-      function Allocate_Occurrence return EOA;\n-      --  Allocate an exception occurrence (as well as the machine occurrence)\n-\n-      procedure Propagate_Exception (Excep : EOA);\n-      pragma No_Return (Propagate_Exception);\n-      --  This procedure propagates the exception represented by Excep\n-\n-   end Exception_Propagation;\n-\n-   package Stream_Attributes is\n-\n-      ----------------------------------\n-      -- Stream Attribute Subprograms --\n-      ----------------------------------\n-\n-      function EId_To_String (X : Exception_Id) return String;\n-      function String_To_EId (S : String) return Exception_Id;\n-      --  Functions for implementing Exception_Id stream attributes\n-\n-      function EO_To_String (X : Exception_Occurrence) return String;\n-      function String_To_EO (S : String) return Exception_Occurrence;\n-      --  Functions for implementing Exception_Occurrence stream\n-      --  attributes\n-\n-   end Stream_Attributes;\n-\n-   procedure Complete_Occurrence (X : EOA);\n-   --  Finish building the occurrence: save the call chain and notify the\n-   --  debugger.\n-\n-   procedure Complete_And_Propagate_Occurrence (X : EOA);\n-   pragma No_Return (Complete_And_Propagate_Occurrence);\n-   --  This is a simple wrapper to Complete_Occurrence and\n-   --  Exception_Propagation.Propagate_Exception.\n-\n-   function Create_Occurrence_From_Signal_Handler\n-     (E : Exception_Id;\n-      M : System.Address) return EOA;\n-   --  Create and build an exception occurrence using exception id E and\n-   --  nul-terminated message M.\n-\n-   function Create_Machine_Occurrence_From_Signal_Handler\n-     (E : Exception_Id;\n-      M : System.Address) return System.Address;\n-   pragma Export (C, Create_Machine_Occurrence_From_Signal_Handler,\n-                  \"__gnat_create_machine_occurrence_from_signal_handler\");\n-   --  Create and build an exception occurrence using exception id E and\n-   --  nul-terminated message M. Return the machine occurrence.\n-\n-   procedure Raise_Exception_No_Defer\n-     (E       : Exception_Id;\n-      Message : String := \"\");\n-   pragma Export\n-    (Ada, Raise_Exception_No_Defer,\n-     \"ada__exceptions__raise_exception_no_defer\");\n-   pragma No_Return (Raise_Exception_No_Defer);\n-   --  Similar to Raise_Exception, but with no abort deferral\n-\n-   procedure Raise_With_Msg (E : Exception_Id);\n-   pragma No_Return (Raise_With_Msg);\n-   pragma Export (C, Raise_With_Msg, \"__gnat_raise_with_msg\");\n-   --  Raises an exception with given exception id value. A message\n-   --  is associated with the raise, and has already been stored in the\n-   --  exception occurrence referenced by the Current_Excep in the TSD.\n-   --  Abort is deferred before the raise call.\n-\n-   procedure Raise_With_Location_And_Msg\n-     (E : Exception_Id;\n-      F : System.Address;\n-      L : Integer;\n-      C : Integer := 0;\n-      M : System.Address := System.Null_Address);\n-   pragma No_Return (Raise_With_Location_And_Msg);\n-   --  Raise an exception with given exception id value. A filename and line\n-   --  number is associated with the raise and is stored in the exception\n-   --  occurrence and in addition a column and a string message M may be\n-   --  appended to this (if not null/0).\n-\n-   procedure Raise_Constraint_Error (File : System.Address; Line : Integer);\n-   pragma No_Return (Raise_Constraint_Error);\n-   pragma Export (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n-   --  Raise constraint error with file:line information\n-\n-   procedure Raise_Constraint_Error_Msg\n-     (File   : System.Address;\n-      Line   : Integer;\n-      Column : Integer;\n-      Msg    : System.Address);\n-   pragma No_Return (Raise_Constraint_Error_Msg);\n-   pragma Export\n-     (C, Raise_Constraint_Error_Msg, \"__gnat_raise_constraint_error_msg\");\n-   --  Raise constraint error with file:line:col + msg information\n-\n-   procedure Raise_Program_Error (File : System.Address; Line : Integer);\n-   pragma No_Return (Raise_Program_Error);\n-   pragma Export (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n-   --  Raise program error with file:line information\n-\n-   procedure Raise_Program_Error_Msg\n-     (File : System.Address;\n-      Line : Integer;\n-      Msg  : System.Address);\n-   pragma No_Return (Raise_Program_Error_Msg);\n-   pragma Export\n-     (C, Raise_Program_Error_Msg, \"__gnat_raise_program_error_msg\");\n-   --  Raise program error with file:line + msg information\n-\n-   procedure Raise_Storage_Error (File : System.Address; Line : Integer);\n-   pragma No_Return (Raise_Storage_Error);\n-   pragma Export (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n-   --  Raise storage error with file:line information\n-\n-   procedure Raise_Storage_Error_Msg\n-     (File : System.Address;\n-      Line : Integer;\n-      Msg  : System.Address);\n-   pragma No_Return (Raise_Storage_Error_Msg);\n-   pragma Export\n-     (C, Raise_Storage_Error_Msg, \"__gnat_raise_storage_error_msg\");\n-   --  Raise storage error with file:line + reason msg information\n-\n-   --  The exception raising process and the automatic tracing mechanism rely\n-   --  on some careful use of flags attached to the exception occurrence. The\n-   --  graph below illustrates the relations between the Raise_ subprograms\n-   --  and identifies the points where basic flags such as Exception_Raised\n-   --  are initialized.\n-\n-   --  (i) signs indicate the flags initialization points. R stands for Raise,\n-   --  W for With, and E for Exception.\n-\n-   --                   R_No_Msg    R_E   R_Pe  R_Ce  R_Se\n-   --                       |        |     |     |     |\n-   --                       +--+  +--+     +---+ | +---+\n-   --                          |  |            | | |\n-   --     R_E_No_Defer(i)    R_W_Msg(i)       R_W_Loc\n-   --           |               |              |   |\n-   --           +------------+  |  +-----------+   +--+\n-   --                        |  |  |                  |\n-   --                        |  |  |             Set_E_C_Msg(i)\n-   --                        |  |  |\n-   --            Complete_And_Propagate_Occurrence\n-\n-   procedure Reraise;\n-   pragma No_Return (Reraise);\n-   pragma Export (C, Reraise, \"__gnat_reraise\");\n-   --  Reraises the exception referenced by the Current_Excep field\n-   --  of the TSD (all fields of this exception occurrence are set).\n-   --  Abort is deferred before the reraise operation. Called from\n-   --  System.Tasking.RendezVous.Exceptional_Complete_RendezVous\n-\n-   procedure Transfer_Occurrence\n-     (Target : Exception_Occurrence_Access;\n-      Source : Exception_Occurrence);\n-   pragma Export (C, Transfer_Occurrence, \"__gnat_transfer_occurrence\");\n-   --  Called from s-tasren.adb:Local_Complete_RendezVous and\n-   --  s-tpobop.adb:Exceptional_Complete_Entry_Body to setup Target from\n-   --  Source as an exception to be propagated in the caller task. Target is\n-   --  expected to be a pointer to the fixed TSD occurrence for this task.\n-\n-   --------------------------------\n-   -- Run-Time Check Subprograms --\n-   --------------------------------\n-\n-   --  These subprograms raise a specific exception with a reason message\n-   --  attached. The parameters are the file name and line number in each\n-   --  case. The names are defined by Exp_Ch11.Get_RT_Exception_Name.\n-\n-   procedure Rcheck_CE_Access_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Null_Access_Parameter\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Discriminant_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Divide_By_Zero\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Explicit_Raise\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Index_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Invalid_Data\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Length_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Null_Exception_Id\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Null_Not_Allowed\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Overflow_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Partition_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Range_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Tag_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Access_Before_Elaboration\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Accessibility_Check\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Address_Of_Intrinsic\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Aliased_Parameters\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_All_Guards_Closed\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Bad_Predicated_Generic_Type\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Current_Task_In_Entry_Body\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Duplicated_Entry_Address\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Explicit_Raise\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Implicit_Return\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Misaligned_Address_Value\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Missing_Return\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Non_Transportable_Actual\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Overlaid_Controlled_Object\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Potentially_Blocking_Operation\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Stubbed_Subprogram_Called\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Unchecked_Union_Restriction\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Empty_Storage_Pool\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Explicit_Raise\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Infinite_Recursion\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Object_Too_Large\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Stream_Operation_Not_Allowed\n-     (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Access_Check_Ext\n-     (File : System.Address; Line, Column : Integer);\n-   procedure Rcheck_CE_Index_Check_Ext\n-     (File : System.Address; Line, Column, Index, First, Last : Integer);\n-   procedure Rcheck_CE_Invalid_Data_Ext\n-     (File : System.Address; Line, Column, Index, First, Last : Integer);\n-   procedure Rcheck_CE_Range_Check_Ext\n-     (File : System.Address; Line, Column, Index, First, Last : Integer);\n-\n-   procedure Rcheck_PE_Finalize_Raised_Exception\n-     (File : System.Address; Line : Integer);\n-   --  This routine is separated out because it has quite different behavior\n-   --  from the others. This is the \"finalize/adjust raised exception\". This\n-   --  subprogram is always called with abort deferred, unlike all other\n-   --  Rcheck_* subprograms, it needs to call Raise_Exception_No_Defer.\n-\n-   pragma Export (C, Rcheck_CE_Access_Check,\n-                  \"__gnat_rcheck_CE_Access_Check\");\n-   pragma Export (C, Rcheck_CE_Null_Access_Parameter,\n-                  \"__gnat_rcheck_CE_Null_Access_Parameter\");\n-   pragma Export (C, Rcheck_CE_Discriminant_Check,\n-                  \"__gnat_rcheck_CE_Discriminant_Check\");\n-   pragma Export (C, Rcheck_CE_Divide_By_Zero,\n-                  \"__gnat_rcheck_CE_Divide_By_Zero\");\n-   pragma Export (C, Rcheck_CE_Explicit_Raise,\n-                  \"__gnat_rcheck_CE_Explicit_Raise\");\n-   pragma Export (C, Rcheck_CE_Index_Check,\n-                  \"__gnat_rcheck_CE_Index_Check\");\n-   pragma Export (C, Rcheck_CE_Invalid_Data,\n-                  \"__gnat_rcheck_CE_Invalid_Data\");\n-   pragma Export (C, Rcheck_CE_Length_Check,\n-                  \"__gnat_rcheck_CE_Length_Check\");\n-   pragma Export (C, Rcheck_CE_Null_Exception_Id,\n-                  \"__gnat_rcheck_CE_Null_Exception_Id\");\n-   pragma Export (C, Rcheck_CE_Null_Not_Allowed,\n-                  \"__gnat_rcheck_CE_Null_Not_Allowed\");\n-   pragma Export (C, Rcheck_CE_Overflow_Check,\n-                  \"__gnat_rcheck_CE_Overflow_Check\");\n-   pragma Export (C, Rcheck_CE_Partition_Check,\n-                  \"__gnat_rcheck_CE_Partition_Check\");\n-   pragma Export (C, Rcheck_CE_Range_Check,\n-                  \"__gnat_rcheck_CE_Range_Check\");\n-   pragma Export (C, Rcheck_CE_Tag_Check,\n-                  \"__gnat_rcheck_CE_Tag_Check\");\n-   pragma Export (C, Rcheck_PE_Access_Before_Elaboration,\n-                  \"__gnat_rcheck_PE_Access_Before_Elaboration\");\n-   pragma Export (C, Rcheck_PE_Accessibility_Check,\n-                  \"__gnat_rcheck_PE_Accessibility_Check\");\n-   pragma Export (C, Rcheck_PE_Address_Of_Intrinsic,\n-                  \"__gnat_rcheck_PE_Address_Of_Intrinsic\");\n-   pragma Export (C, Rcheck_PE_Aliased_Parameters,\n-                  \"__gnat_rcheck_PE_Aliased_Parameters\");\n-   pragma Export (C, Rcheck_PE_All_Guards_Closed,\n-                  \"__gnat_rcheck_PE_All_Guards_Closed\");\n-   pragma Export (C, Rcheck_PE_Bad_Predicated_Generic_Type,\n-                  \"__gnat_rcheck_PE_Bad_Predicated_Generic_Type\");\n-   pragma Export (C, Rcheck_PE_Current_Task_In_Entry_Body,\n-                  \"__gnat_rcheck_PE_Current_Task_In_Entry_Body\");\n-   pragma Export (C, Rcheck_PE_Duplicated_Entry_Address,\n-                  \"__gnat_rcheck_PE_Duplicated_Entry_Address\");\n-   pragma Export (C, Rcheck_PE_Explicit_Raise,\n-                  \"__gnat_rcheck_PE_Explicit_Raise\");\n-   pragma Export (C, Rcheck_PE_Finalize_Raised_Exception,\n-                  \"__gnat_rcheck_PE_Finalize_Raised_Exception\");\n-   pragma Export (C, Rcheck_PE_Implicit_Return,\n-                  \"__gnat_rcheck_PE_Implicit_Return\");\n-   pragma Export (C, Rcheck_PE_Misaligned_Address_Value,\n-                  \"__gnat_rcheck_PE_Misaligned_Address_Value\");\n-   pragma Export (C, Rcheck_PE_Missing_Return,\n-                  \"__gnat_rcheck_PE_Missing_Return\");\n-   pragma Export (C, Rcheck_PE_Non_Transportable_Actual,\n-                  \"__gnat_rcheck_PE_Non_Transportable_Actual\");\n-   pragma Export (C, Rcheck_PE_Overlaid_Controlled_Object,\n-                  \"__gnat_rcheck_PE_Overlaid_Controlled_Object\");\n-   pragma Export (C, Rcheck_PE_Potentially_Blocking_Operation,\n-                  \"__gnat_rcheck_PE_Potentially_Blocking_Operation\");\n-   pragma Export (C, Rcheck_PE_Stream_Operation_Not_Allowed,\n-                  \"__gnat_rcheck_PE_Stream_Operation_Not_Allowed\");\n-   pragma Export (C, Rcheck_PE_Stubbed_Subprogram_Called,\n-                  \"__gnat_rcheck_PE_Stubbed_Subprogram_Called\");\n-   pragma Export (C, Rcheck_PE_Unchecked_Union_Restriction,\n-                  \"__gnat_rcheck_PE_Unchecked_Union_Restriction\");\n-   pragma Export (C, Rcheck_SE_Empty_Storage_Pool,\n-                  \"__gnat_rcheck_SE_Empty_Storage_Pool\");\n-   pragma Export (C, Rcheck_SE_Explicit_Raise,\n-                  \"__gnat_rcheck_SE_Explicit_Raise\");\n-   pragma Export (C, Rcheck_SE_Infinite_Recursion,\n-                  \"__gnat_rcheck_SE_Infinite_Recursion\");\n-   pragma Export (C, Rcheck_SE_Object_Too_Large,\n-                  \"__gnat_rcheck_SE_Object_Too_Large\");\n-\n-   pragma Export (C, Rcheck_CE_Access_Check_Ext,\n-                  \"__gnat_rcheck_CE_Access_Check_ext\");\n-   pragma Export (C, Rcheck_CE_Index_Check_Ext,\n-                  \"__gnat_rcheck_CE_Index_Check_ext\");\n-   pragma Export (C, Rcheck_CE_Invalid_Data_Ext,\n-                  \"__gnat_rcheck_CE_Invalid_Data_ext\");\n-   pragma Export (C, Rcheck_CE_Range_Check_Ext,\n-                  \"__gnat_rcheck_CE_Range_Check_ext\");\n-\n-   --  None of these procedures ever returns (they raise an exception). By\n-   --  using pragma No_Return, we ensure that any junk code after the call,\n-   --  such as normal return epilogue stuff, can be eliminated).\n-\n-   pragma No_Return (Rcheck_CE_Access_Check);\n-   pragma No_Return (Rcheck_CE_Null_Access_Parameter);\n-   pragma No_Return (Rcheck_CE_Discriminant_Check);\n-   pragma No_Return (Rcheck_CE_Divide_By_Zero);\n-   pragma No_Return (Rcheck_CE_Explicit_Raise);\n-   pragma No_Return (Rcheck_CE_Index_Check);\n-   pragma No_Return (Rcheck_CE_Invalid_Data);\n-   pragma No_Return (Rcheck_CE_Length_Check);\n-   pragma No_Return (Rcheck_CE_Null_Exception_Id);\n-   pragma No_Return (Rcheck_CE_Null_Not_Allowed);\n-   pragma No_Return (Rcheck_CE_Overflow_Check);\n-   pragma No_Return (Rcheck_CE_Partition_Check);\n-   pragma No_Return (Rcheck_CE_Range_Check);\n-   pragma No_Return (Rcheck_CE_Tag_Check);\n-   pragma No_Return (Rcheck_PE_Access_Before_Elaboration);\n-   pragma No_Return (Rcheck_PE_Accessibility_Check);\n-   pragma No_Return (Rcheck_PE_Address_Of_Intrinsic);\n-   pragma No_Return (Rcheck_PE_Aliased_Parameters);\n-   pragma No_Return (Rcheck_PE_All_Guards_Closed);\n-   pragma No_Return (Rcheck_PE_Bad_Predicated_Generic_Type);\n-   pragma No_Return (Rcheck_PE_Current_Task_In_Entry_Body);\n-   pragma No_Return (Rcheck_PE_Duplicated_Entry_Address);\n-   pragma No_Return (Rcheck_PE_Explicit_Raise);\n-   pragma No_Return (Rcheck_PE_Implicit_Return);\n-   pragma No_Return (Rcheck_PE_Misaligned_Address_Value);\n-   pragma No_Return (Rcheck_PE_Missing_Return);\n-   pragma No_Return (Rcheck_PE_Non_Transportable_Actual);\n-   pragma No_Return (Rcheck_PE_Overlaid_Controlled_Object);\n-   pragma No_Return (Rcheck_PE_Potentially_Blocking_Operation);\n-   pragma No_Return (Rcheck_PE_Stream_Operation_Not_Allowed);\n-   pragma No_Return (Rcheck_PE_Stubbed_Subprogram_Called);\n-   pragma No_Return (Rcheck_PE_Unchecked_Union_Restriction);\n-   pragma No_Return (Rcheck_PE_Finalize_Raised_Exception);\n-   pragma No_Return (Rcheck_SE_Empty_Storage_Pool);\n-   pragma No_Return (Rcheck_SE_Explicit_Raise);\n-   pragma No_Return (Rcheck_SE_Infinite_Recursion);\n-   pragma No_Return (Rcheck_SE_Object_Too_Large);\n-\n-   pragma No_Return (Rcheck_CE_Access_Check_Ext);\n-   pragma No_Return (Rcheck_CE_Index_Check_Ext);\n-   pragma No_Return (Rcheck_CE_Invalid_Data_Ext);\n-   pragma No_Return (Rcheck_CE_Range_Check_Ext);\n-\n-   ---------------------------------------------\n-   -- Reason Strings for Run-Time Check Calls --\n-   ---------------------------------------------\n-\n-   --  These strings are null-terminated and are used by Rcheck_nn. The\n-   --  strings correspond to the definitions for Types.RT_Exception_Code.\n-\n-   use ASCII;\n-\n-   Rmsg_00 : constant String := \"access check failed\"              & NUL;\n-   Rmsg_01 : constant String := \"access parameter is null\"         & NUL;\n-   Rmsg_02 : constant String := \"discriminant check failed\"        & NUL;\n-   Rmsg_03 : constant String := \"divide by zero\"                   & NUL;\n-   Rmsg_04 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_05 : constant String := \"index check failed\"               & NUL;\n-   Rmsg_06 : constant String := \"invalid data\"                     & NUL;\n-   Rmsg_07 : constant String := \"length check failed\"              & NUL;\n-   Rmsg_08 : constant String := \"null Exception_Id\"                & NUL;\n-   Rmsg_09 : constant String := \"null-exclusion check failed\"      & NUL;\n-   Rmsg_10 : constant String := \"overflow check failed\"            & NUL;\n-   Rmsg_11 : constant String := \"partition check failed\"           & NUL;\n-   Rmsg_12 : constant String := \"range check failed\"               & NUL;\n-   Rmsg_13 : constant String := \"tag check failed\"                 & NUL;\n-   Rmsg_14 : constant String := \"access before elaboration\"        & NUL;\n-   Rmsg_15 : constant String := \"accessibility check failed\"       & NUL;\n-   Rmsg_16 : constant String := \"attempt to take address of\"       &\n-                                \" intrinsic subprogram\"            & NUL;\n-   Rmsg_17 : constant String := \"aliased parameters\"               & NUL;\n-   Rmsg_18 : constant String := \"all guards closed\"                & NUL;\n-   Rmsg_19 : constant String := \"improper use of generic subtype\"  &\n-                                \" with predicate\"                  & NUL;\n-   Rmsg_20 : constant String := \"Current_Task referenced in entry\" &\n-                                \" body\"                            & NUL;\n-   Rmsg_21 : constant String := \"duplicated entry address\"         & NUL;\n-   Rmsg_22 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_23 : constant String := \"finalize/adjust raised exception\" & NUL;\n-   Rmsg_24 : constant String := \"implicit return with No_Return\"   & NUL;\n-   Rmsg_25 : constant String := \"misaligned address value\"         & NUL;\n-   Rmsg_26 : constant String := \"missing return\"                   & NUL;\n-   Rmsg_27 : constant String := \"overlaid controlled object\"       & NUL;\n-   Rmsg_28 : constant String := \"potentially blocking operation\"   & NUL;\n-   Rmsg_29 : constant String := \"stubbed subprogram called\"        & NUL;\n-   Rmsg_30 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_31 : constant String := \"actual/returned class-wide\"       &\n-                                \" value not transportable\"         & NUL;\n-   Rmsg_32 : constant String := \"empty storage pool\"               & NUL;\n-   Rmsg_33 : constant String := \"explicit raise\"                   & NUL;\n-   Rmsg_34 : constant String := \"infinite recursion\"               & NUL;\n-   Rmsg_35 : constant String := \"object too large\"                 & NUL;\n-   Rmsg_36 : constant String := \"stream operation not allowed\"     & NUL;\n-\n-   -----------------------\n-   -- Polling Interface --\n-   -----------------------\n-\n-   type Unsigned is mod 2 ** 32;\n-\n-   Counter : Unsigned := 0;\n-   pragma Warnings (Off, Counter);\n-   --  This counter is provided for convenience. It can be used in Poll to\n-   --  perform periodic but not systematic operations.\n-\n-   procedure Poll is separate;\n-   --  The actual polling routine is separate, so that it can easily be\n-   --  replaced with a target dependent version.\n-\n-   --------------------------\n-   -- Code_Address_For_AAA --\n-   --------------------------\n-\n-   --  This function gives us the start of the PC range for addresses within\n-   --  the exception unit itself. We hope that gigi/gcc keep all the procedures\n-   --  in their original order.\n-\n-   function Code_Address_For_AAA return System.Address is\n-   begin\n-      --  We are using a label instead of Code_Address_For_AAA'Address because\n-      --  on some platforms the latter does not yield the address we want, but\n-      --  the address of a stub or of a descriptor instead. This is the case at\n-      --  least on PA-HPUX.\n-\n-      <<Start_Of_AAA>>\n-      return Start_Of_AAA'Address;\n-   end Code_Address_For_AAA;\n-\n-   ----------------\n-   -- Call_Chain --\n-   ----------------\n-\n-   procedure Call_Chain (Excep : EOA) is separate;\n-   --  The actual Call_Chain routine is separate, so that it can easily\n-   --  be dummied out when no exception traceback information is needed.\n-\n-   -------------------\n-   -- EId_To_String --\n-   -------------------\n-\n-   function EId_To_String (X : Exception_Id) return String\n-     renames Stream_Attributes.EId_To_String;\n-\n-   ------------------\n-   -- EO_To_String --\n-   ------------------\n-\n-   --  We use the null string to represent the null occurrence, otherwise we\n-   --  output the Untailored_Exception_Information string for the occurrence.\n-\n-   function EO_To_String (X : Exception_Occurrence) return String\n-     renames Stream_Attributes.EO_To_String;\n-\n-   ------------------------\n-   -- Exception_Identity --\n-   ------------------------\n-\n-   function Exception_Identity\n-     (X : Exception_Occurrence) return Exception_Id\n-   is\n-   begin\n-      --  Note that the following test used to be here for the original\n-      --  Ada 95 semantics, but these were modified by AI-241 to require\n-      --  returning Null_Id instead of raising Constraint_Error.\n-\n-      --  if X.Id = Null_Id then\n-      --     raise Constraint_Error;\n-      --  end if;\n-\n-      return X.Id;\n-   end Exception_Identity;\n-\n-   ---------------------------\n-   -- Exception_Information --\n-   ---------------------------\n-\n-   function Exception_Information (X : Exception_Occurrence) return String is\n-   begin\n-      if X.Id = Null_Id then\n-         raise Constraint_Error;\n-      else\n-         return Exception_Data.Exception_Information (X);\n-      end if;\n-   end Exception_Information;\n-\n-   -----------------------\n-   -- Exception_Message --\n-   -----------------------\n-\n-   function Exception_Message (X : Exception_Occurrence) return String is\n-   begin\n-      if X.Id = Null_Id then\n-         raise Constraint_Error;\n-      else\n-         return X.Msg (1 .. X.Msg_Length);\n-      end if;\n-   end Exception_Message;\n-\n-   --------------------\n-   -- Exception_Name --\n-   --------------------\n-\n-   function Exception_Name (Id : Exception_Id) return String is\n-   begin\n-      if Id = null then\n-         raise Constraint_Error;\n-      else\n-         return To_Ptr (Id.Full_Name) (1 .. Id.Name_Length - 1);\n-      end if;\n-   end Exception_Name;\n-\n-   function Exception_Name (X : Exception_Occurrence) return String is\n-   begin\n-      return Exception_Name (X.Id);\n-   end Exception_Name;\n-\n-   ---------------------------\n-   -- Exception_Name_Simple --\n-   ---------------------------\n-\n-   function Exception_Name_Simple (X : Exception_Occurrence) return String is\n-      Name : constant String := Exception_Name (X);\n-      P    : Natural;\n-\n-   begin\n-      P := Name'Length;\n-      while P > 1 loop\n-         exit when Name (P - 1) = '.';\n-         P := P - 1;\n-      end loop;\n-\n-      --  Return result making sure lower bound is 1\n-\n-      declare\n-         subtype Rname is String (1 .. Name'Length - P + 1);\n-      begin\n-         return Rname (Name (P .. Name'Length));\n-      end;\n-   end Exception_Name_Simple;\n-\n-   --------------------\n-   -- Exception_Data --\n-   --------------------\n-\n-   package body Exception_Data is separate;\n-   --  This package can be easily dummied out if we do not want the basic\n-   --  support for exception messages (such as in Ada 83).\n-\n-   ---------------------------\n-   -- Exception_Propagation --\n-   ---------------------------\n-\n-   package body Exception_Propagation is separate;\n-   --  Depending on the actual exception mechanism used (front-end or\n-   --  back-end based), the implementation will differ, which is why this\n-   --  package is separated.\n-\n-   ----------------------\n-   -- Exception_Traces --\n-   ----------------------\n-\n-   package body Exception_Traces is separate;\n-   --  Depending on the underlying support for IO the implementation will\n-   --  differ. Moreover we would like to dummy out this package in case we\n-   --  do not want any exception tracing support. This is why this package\n-   --  is separated.\n-\n-   --------------------------------------\n-   -- Get_Exception_Machine_Occurrence --\n-   --------------------------------------\n-\n-   function Get_Exception_Machine_Occurrence\n-     (X : Exception_Occurrence) return System.Address\n-   is\n-   begin\n-      return X.Machine_Occurrence;\n-   end Get_Exception_Machine_Occurrence;\n-\n-   -----------\n-   -- Image --\n-   -----------\n-\n-   function Image (Index : Integer) return String is\n-      Result : constant String := Integer'Image (Index);\n-   begin\n-      if Result (1) = ' ' then\n-         return Result (2 .. Result'Last);\n-      else\n-         return Result;\n-      end if;\n-   end Image;\n-\n-   -----------------------\n-   -- Stream Attributes --\n-   -----------------------\n-\n-   package body Stream_Attributes is separate;\n-   --  This package can be easily dummied out if we do not want the\n-   --  support for streaming Exception_Ids and Exception_Occurrences.\n-\n-   ----------------------------\n-   -- Raise_Constraint_Error --\n-   ----------------------------\n-\n-   procedure Raise_Constraint_Error (File : System.Address; Line : Integer) is\n-   begin\n-      Raise_With_Location_And_Msg (Constraint_Error_Def'Access, File, Line);\n-   end Raise_Constraint_Error;\n-\n-   --------------------------------\n-   -- Raise_Constraint_Error_Msg --\n-   --------------------------------\n-\n-   procedure Raise_Constraint_Error_Msg\n-     (File   : System.Address;\n-      Line   : Integer;\n-      Column : Integer;\n-      Msg    : System.Address)\n-   is\n-   begin\n-      Raise_With_Location_And_Msg\n-        (Constraint_Error_Def'Access, File, Line, Column, Msg);\n-   end Raise_Constraint_Error_Msg;\n-\n-   -------------------------\n-   -- Complete_Occurrence --\n-   -------------------------\n-\n-   procedure Complete_Occurrence (X : EOA) is\n-   begin\n-      --  Compute the backtrace for this occurrence if the corresponding\n-      --  binder option has been set. Call_Chain takes care of the reraise\n-      --  case.\n-\n-      --  ??? Using Call_Chain here means we are going to walk up the stack\n-      --  once only for backtracing purposes before doing it again for the\n-      --  propagation per se.\n-\n-      --  The first inspection is much lighter, though, as it only requires\n-      --  partial unwinding of each frame. Additionally, although we could use\n-      --  the personality routine to record the addresses while propagating,\n-      --  this method has two drawbacks:\n-\n-      --  1) the trace is incomplete if the exception is handled since we\n-      --  don't walk past the frame with the handler,\n-\n-      --    and\n-\n-      --  2) we would miss the frames for which our personality routine is not\n-      --  called, e.g. if C or C++ calls are on the way.\n-\n-      Call_Chain (X);\n-\n-      --  Notify the debugger\n-      Debug_Raise_Exception\n-        (E       => SSL.Exception_Data_Ptr (X.Id),\n-         Message => X.Msg (1 .. X.Msg_Length));\n-   end Complete_Occurrence;\n-\n-   ---------------------------------------\n-   -- Complete_And_Propagate_Occurrence --\n-   ---------------------------------------\n-\n-   procedure Complete_And_Propagate_Occurrence (X : EOA) is\n-   begin\n-      Complete_Occurrence (X);\n-      Exception_Propagation.Propagate_Exception (X);\n-   end Complete_And_Propagate_Occurrence;\n-\n-   ---------------------\n-   -- Raise_Exception --\n-   ---------------------\n-\n-   procedure Raise_Exception\n-     (E       : Exception_Id;\n-      Message : String := \"\")\n-   is\n-      EF : Exception_Id := E;\n-   begin\n-      --  Raise CE if E = Null_ID (AI-446)\n-\n-      if E = null then\n-         EF := Constraint_Error'Identity;\n-      end if;\n-\n-      --  Go ahead and raise appropriate exception\n-\n-      Raise_Exception_Always (EF, Message);\n-   end Raise_Exception;\n-\n-   ----------------------------\n-   -- Raise_Exception_Always --\n-   ----------------------------\n-\n-   procedure Raise_Exception_Always\n-     (E       : Exception_Id;\n-      Message : String := \"\")\n-   is\n-      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-\n-   begin\n-      Exception_Data.Set_Exception_Msg (X, E, Message);\n-\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Complete_And_Propagate_Occurrence (X);\n-   end Raise_Exception_Always;\n-\n-   ------------------------------\n-   -- Raise_Exception_No_Defer --\n-   ------------------------------\n-\n-   procedure Raise_Exception_No_Defer\n-     (E       : Exception_Id;\n-      Message : String := \"\")\n-   is\n-      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-\n-   begin\n-      Exception_Data.Set_Exception_Msg (X, E, Message);\n-\n-      --  Do not call Abort_Defer.all, as specified by the spec\n-\n-      Complete_And_Propagate_Occurrence (X);\n-   end Raise_Exception_No_Defer;\n-\n-   -------------------------------------\n-   -- Raise_From_Controlled_Operation --\n-   -------------------------------------\n-\n-   procedure Raise_From_Controlled_Operation\n-     (X : Ada.Exceptions.Exception_Occurrence)\n-   is\n-      Prefix             : constant String := \"adjust/finalize raised \";\n-      Orig_Msg           : constant String := Exception_Message (X);\n-      Orig_Prefix_Length : constant Natural :=\n-                             Integer'Min (Prefix'Length, Orig_Msg'Length);\n-\n-      Orig_Prefix : String renames\n-        Orig_Msg (Orig_Msg'First .. Orig_Msg'First + Orig_Prefix_Length - 1);\n-\n-   begin\n-      --  Message already has the proper prefix, just re-raise\n-\n-      if Orig_Prefix = Prefix then\n-         Raise_Exception_No_Defer\n-           (E       => Program_Error'Identity,\n-            Message => Orig_Msg);\n-\n-      else\n-         declare\n-            New_Msg  : constant String := Prefix & Exception_Name (X);\n-\n-         begin\n-            --  No message present, just provide our own\n-\n-            if Orig_Msg = \"\" then\n-               Raise_Exception_No_Defer\n-                 (E       => Program_Error'Identity,\n-                  Message => New_Msg);\n-\n-            --  Message present, add informational prefix\n-\n-            else\n-               Raise_Exception_No_Defer\n-                 (E       => Program_Error'Identity,\n-                  Message => New_Msg & \": \" & Orig_Msg);\n-            end if;\n-         end;\n-      end if;\n-   end Raise_From_Controlled_Operation;\n-\n-   -------------------------------------------\n-   -- Create_Occurrence_From_Signal_Handler --\n-   -------------------------------------------\n-\n-   function Create_Occurrence_From_Signal_Handler\n-     (E : Exception_Id;\n-      M : System.Address) return EOA\n-   is\n-      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-\n-   begin\n-      Exception_Data.Set_Exception_C_Msg (X, E, M);\n-\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Complete_Occurrence (X);\n-      return X;\n-   end Create_Occurrence_From_Signal_Handler;\n-\n-   ---------------------------------------------------\n-   -- Create_Machine_Occurrence_From_Signal_Handler --\n-   ---------------------------------------------------\n-\n-   function Create_Machine_Occurrence_From_Signal_Handler\n-     (E : Exception_Id;\n-      M : System.Address) return System.Address\n-   is\n-   begin\n-      return Create_Occurrence_From_Signal_Handler (E, M).Machine_Occurrence;\n-   end Create_Machine_Occurrence_From_Signal_Handler;\n-\n-   -------------------------------\n-   -- Raise_From_Signal_Handler --\n-   -------------------------------\n-\n-   procedure Raise_From_Signal_Handler\n-     (E : Exception_Id;\n-      M : System.Address)\n-   is\n-   begin\n-      Exception_Propagation.Propagate_Exception\n-        (Create_Occurrence_From_Signal_Handler (E, M));\n-   end Raise_From_Signal_Handler;\n-\n-   -------------------------\n-   -- Raise_Program_Error --\n-   -------------------------\n-\n-   procedure Raise_Program_Error\n-     (File : System.Address;\n-      Line : Integer)\n-   is\n-   begin\n-      Raise_With_Location_And_Msg (Program_Error_Def'Access, File, Line);\n-   end Raise_Program_Error;\n-\n-   -----------------------------\n-   -- Raise_Program_Error_Msg --\n-   -----------------------------\n-\n-   procedure Raise_Program_Error_Msg\n-     (File : System.Address;\n-      Line : Integer;\n-      Msg  : System.Address)\n-   is\n-   begin\n-      Raise_With_Location_And_Msg\n-        (Program_Error_Def'Access, File, Line, M => Msg);\n-   end Raise_Program_Error_Msg;\n-\n-   -------------------------\n-   -- Raise_Storage_Error --\n-   -------------------------\n-\n-   procedure Raise_Storage_Error\n-     (File : System.Address;\n-      Line : Integer)\n-   is\n-   begin\n-      Raise_With_Location_And_Msg (Storage_Error_Def'Access, File, Line);\n-   end Raise_Storage_Error;\n-\n-   -----------------------------\n-   -- Raise_Storage_Error_Msg --\n-   -----------------------------\n-\n-   procedure Raise_Storage_Error_Msg\n-     (File : System.Address;\n-      Line : Integer;\n-      Msg  : System.Address)\n-   is\n-   begin\n-      Raise_With_Location_And_Msg\n-        (Storage_Error_Def'Access, File, Line, M => Msg);\n-   end Raise_Storage_Error_Msg;\n-\n-   ---------------------------------\n-   -- Raise_With_Location_And_Msg --\n-   ---------------------------------\n-\n-   procedure Raise_With_Location_And_Msg\n-     (E : Exception_Id;\n-      F : System.Address;\n-      L : Integer;\n-      C : Integer := 0;\n-      M : System.Address := System.Null_Address)\n-   is\n-      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-   begin\n-      Exception_Data.Set_Exception_C_Msg (X, E, F, L, C, M);\n-\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Complete_And_Propagate_Occurrence (X);\n-   end Raise_With_Location_And_Msg;\n-\n-   --------------------\n-   -- Raise_With_Msg --\n-   --------------------\n-\n-   procedure Raise_With_Msg (E : Exception_Id) is\n-      Excep : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-      Ex    : constant Exception_Occurrence_Access := Get_Current_Excep.all;\n-   begin\n-      Excep.Exception_Raised := False;\n-      Excep.Id               := E;\n-      Excep.Num_Tracebacks   := 0;\n-      Excep.Pid              := Local_Partition_ID;\n-\n-      --  Copy the message from the current exception\n-      --  Change the interface to be called with an occurrence ???\n-\n-      Excep.Msg_Length                  := Ex.Msg_Length;\n-      Excep.Msg (1 .. Excep.Msg_Length) := Ex.Msg (1 .. Ex.Msg_Length);\n-\n-      --  The following is a common pattern, should be abstracted\n-      --  into a procedure call ???\n-\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Complete_And_Propagate_Occurrence (Excep);\n-   end Raise_With_Msg;\n-\n-   -----------------------------------------\n-   -- Calls to Run-Time Check Subprograms --\n-   -----------------------------------------\n-\n-   procedure Rcheck_CE_Access_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_00'Address);\n-   end Rcheck_CE_Access_Check;\n-\n-   procedure Rcheck_CE_Null_Access_Parameter\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_01'Address);\n-   end Rcheck_CE_Null_Access_Parameter;\n-\n-   procedure Rcheck_CE_Discriminant_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_02'Address);\n-   end Rcheck_CE_Discriminant_Check;\n-\n-   procedure Rcheck_CE_Divide_By_Zero\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_03'Address);\n-   end Rcheck_CE_Divide_By_Zero;\n-\n-   procedure Rcheck_CE_Explicit_Raise\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_04'Address);\n-   end Rcheck_CE_Explicit_Raise;\n-\n-   procedure Rcheck_CE_Index_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_05'Address);\n-   end Rcheck_CE_Index_Check;\n-\n-   procedure Rcheck_CE_Invalid_Data\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_06'Address);\n-   end Rcheck_CE_Invalid_Data;\n-\n-   procedure Rcheck_CE_Length_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_07'Address);\n-   end Rcheck_CE_Length_Check;\n-\n-   procedure Rcheck_CE_Null_Exception_Id\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_08'Address);\n-   end Rcheck_CE_Null_Exception_Id;\n-\n-   procedure Rcheck_CE_Null_Not_Allowed\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_09'Address);\n-   end Rcheck_CE_Null_Not_Allowed;\n-\n-   procedure Rcheck_CE_Overflow_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_10'Address);\n-   end Rcheck_CE_Overflow_Check;\n-\n-   procedure Rcheck_CE_Partition_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_11'Address);\n-   end Rcheck_CE_Partition_Check;\n-\n-   procedure Rcheck_CE_Range_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_12'Address);\n-   end Rcheck_CE_Range_Check;\n-\n-   procedure Rcheck_CE_Tag_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_13'Address);\n-   end Rcheck_CE_Tag_Check;\n-\n-   procedure Rcheck_PE_Access_Before_Elaboration\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_14'Address);\n-   end Rcheck_PE_Access_Before_Elaboration;\n-\n-   procedure Rcheck_PE_Accessibility_Check\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_15'Address);\n-   end Rcheck_PE_Accessibility_Check;\n-\n-   procedure Rcheck_PE_Address_Of_Intrinsic\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_16'Address);\n-   end Rcheck_PE_Address_Of_Intrinsic;\n-\n-   procedure Rcheck_PE_Aliased_Parameters\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_17'Address);\n-   end Rcheck_PE_Aliased_Parameters;\n-\n-   procedure Rcheck_PE_All_Guards_Closed\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_18'Address);\n-   end Rcheck_PE_All_Guards_Closed;\n-\n-   procedure Rcheck_PE_Bad_Predicated_Generic_Type\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_19'Address);\n-   end Rcheck_PE_Bad_Predicated_Generic_Type;\n-\n-   procedure Rcheck_PE_Current_Task_In_Entry_Body\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_20'Address);\n-   end Rcheck_PE_Current_Task_In_Entry_Body;\n-\n-   procedure Rcheck_PE_Duplicated_Entry_Address\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_21'Address);\n-   end Rcheck_PE_Duplicated_Entry_Address;\n-\n-   procedure Rcheck_PE_Explicit_Raise\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_22'Address);\n-   end Rcheck_PE_Explicit_Raise;\n-\n-   procedure Rcheck_PE_Implicit_Return\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_24'Address);\n-   end Rcheck_PE_Implicit_Return;\n-\n-   procedure Rcheck_PE_Misaligned_Address_Value\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_25'Address);\n-   end Rcheck_PE_Misaligned_Address_Value;\n-\n-   procedure Rcheck_PE_Missing_Return\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_26'Address);\n-   end Rcheck_PE_Missing_Return;\n-\n-   procedure Rcheck_PE_Non_Transportable_Actual\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_31'Address);\n-   end Rcheck_PE_Non_Transportable_Actual;\n-\n-   procedure Rcheck_PE_Overlaid_Controlled_Object\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_27'Address);\n-   end Rcheck_PE_Overlaid_Controlled_Object;\n-\n-   procedure Rcheck_PE_Potentially_Blocking_Operation\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_28'Address);\n-   end Rcheck_PE_Potentially_Blocking_Operation;\n-\n-   procedure Rcheck_PE_Stream_Operation_Not_Allowed\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_36'Address);\n-   end Rcheck_PE_Stream_Operation_Not_Allowed;\n-\n-   procedure Rcheck_PE_Stubbed_Subprogram_Called\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_29'Address);\n-   end Rcheck_PE_Stubbed_Subprogram_Called;\n-\n-   procedure Rcheck_PE_Unchecked_Union_Restriction\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_30'Address);\n-   end Rcheck_PE_Unchecked_Union_Restriction;\n-\n-   procedure Rcheck_SE_Empty_Storage_Pool\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_32'Address);\n-   end Rcheck_SE_Empty_Storage_Pool;\n-\n-   procedure Rcheck_SE_Explicit_Raise\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_33'Address);\n-   end Rcheck_SE_Explicit_Raise;\n-\n-   procedure Rcheck_SE_Infinite_Recursion\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_34'Address);\n-   end Rcheck_SE_Infinite_Recursion;\n-\n-   procedure Rcheck_SE_Object_Too_Large\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Storage_Error_Msg (File, Line, Rmsg_35'Address);\n-   end Rcheck_SE_Object_Too_Large;\n-\n-   procedure Rcheck_CE_Access_Check_Ext\n-     (File : System.Address; Line, Column : Integer)\n-   is\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, Column, Rmsg_00'Address);\n-   end Rcheck_CE_Access_Check_Ext;\n-\n-   procedure Rcheck_CE_Index_Check_Ext\n-     (File : System.Address; Line, Column, Index, First, Last : Integer)\n-   is\n-      Msg : constant String :=\n-              Rmsg_05 (Rmsg_05'First .. Rmsg_05'Last - 1) & ASCII.LF\n-              & \"index \" & Image (Index) & \" not in \" & Image (First)\n-              & \"..\" & Image (Last) & ASCII.NUL;\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, Column, Msg'Address);\n-   end Rcheck_CE_Index_Check_Ext;\n-\n-   procedure Rcheck_CE_Invalid_Data_Ext\n-     (File : System.Address; Line, Column, Index, First, Last : Integer)\n-   is\n-      Msg : constant String :=\n-              Rmsg_06 (Rmsg_06'First .. Rmsg_06'Last - 1) & ASCII.LF\n-              & \"value \" & Image (Index) & \" not in \" & Image (First)\n-              & \"..\" & Image (Last) & ASCII.NUL;\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, Column, Msg'Address);\n-   end Rcheck_CE_Invalid_Data_Ext;\n-\n-   procedure Rcheck_CE_Range_Check_Ext\n-     (File : System.Address; Line, Column, Index, First, Last : Integer)\n-   is\n-      Msg : constant String :=\n-              Rmsg_12 (Rmsg_12'First .. Rmsg_12'Last - 1) & ASCII.LF\n-              & \"value \" & Image (Index) & \" not in \" & Image (First)\n-              & \"..\" & Image (Last) & ASCII.NUL;\n-   begin\n-      Raise_Constraint_Error_Msg (File, Line, Column, Msg'Address);\n-   end Rcheck_CE_Range_Check_Ext;\n-\n-   procedure Rcheck_PE_Finalize_Raised_Exception\n-     (File : System.Address; Line : Integer)\n-   is\n-      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-\n-   begin\n-      --  This is \"finalize/adjust raised exception\". This subprogram is always\n-      --  called with abort deferred, unlike all other Rcheck_* subprograms, it\n-      --  needs to call Raise_Exception_No_Defer.\n-\n-      --  This is consistent with Raise_From_Controlled_Operation\n-\n-      Exception_Data.Set_Exception_C_Msg\n-        (X, Program_Error_Def'Access, File, Line, 0, Rmsg_23'Address);\n-      Complete_And_Propagate_Occurrence (X);\n-   end Rcheck_PE_Finalize_Raised_Exception;\n-\n-   -------------\n-   -- Reraise --\n-   -------------\n-\n-   procedure Reraise is\n-      Excep    : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-      Saved_MO : constant System.Address := Excep.Machine_Occurrence;\n-\n-   begin\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Save_Occurrence (Excep.all, Get_Current_Excep.all.all);\n-      Excep.Machine_Occurrence := Saved_MO;\n-      Complete_And_Propagate_Occurrence (Excep);\n-   end Reraise;\n-\n-   --------------------------------------\n-   -- Reraise_Library_Exception_If_Any --\n-   --------------------------------------\n-\n-   procedure Reraise_Library_Exception_If_Any is\n-      LE : Exception_Occurrence;\n-\n-   begin\n-      if Library_Exception_Set then\n-         LE := Library_Exception;\n-\n-         if LE.Id = Null_Id then\n-            Raise_Exception_No_Defer\n-              (E       => Program_Error'Identity,\n-               Message => \"finalize/adjust raised exception\");\n-         else\n-            Raise_From_Controlled_Operation (LE);\n-         end if;\n-      end if;\n-   end Reraise_Library_Exception_If_Any;\n-\n-   ------------------------\n-   -- Reraise_Occurrence --\n-   ------------------------\n-\n-   procedure Reraise_Occurrence (X : Exception_Occurrence) is\n-   begin\n-      if X.Id = null then\n-         return;\n-      else\n-         Reraise_Occurrence_Always (X);\n-      end if;\n-   end Reraise_Occurrence;\n-\n-   -------------------------------\n-   -- Reraise_Occurrence_Always --\n-   -------------------------------\n-\n-   procedure Reraise_Occurrence_Always (X : Exception_Occurrence) is\n-   begin\n-      if not ZCX_By_Default then\n-         Abort_Defer.all;\n-      end if;\n-\n-      Reraise_Occurrence_No_Defer (X);\n-   end Reraise_Occurrence_Always;\n-\n-   ---------------------------------\n-   -- Reraise_Occurrence_No_Defer --\n-   ---------------------------------\n-\n-   procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence) is\n-      Excep    : constant EOA := Exception_Propagation.Allocate_Occurrence;\n-      Saved_MO : constant System.Address := Excep.Machine_Occurrence;\n-   begin\n-      Save_Occurrence (Excep.all, X);\n-      Excep.Machine_Occurrence := Saved_MO;\n-      Complete_And_Propagate_Occurrence (Excep);\n-   end Reraise_Occurrence_No_Defer;\n-\n-   ---------------------\n-   -- Save_Occurrence --\n-   ---------------------\n-\n-   procedure Save_Occurrence\n-     (Target : out Exception_Occurrence;\n-      Source : Exception_Occurrence)\n-   is\n-   begin\n-      --  As the machine occurrence might be a data that must be finalized\n-      --  (outside any Ada mechanism), do not copy it\n-\n-      Target.Id                 := Source.Id;\n-      Target.Machine_Occurrence := System.Null_Address;\n-      Target.Msg_Length         := Source.Msg_Length;\n-      Target.Num_Tracebacks     := Source.Num_Tracebacks;\n-      Target.Pid                := Source.Pid;\n-\n-      Target.Msg (1 .. Target.Msg_Length) :=\n-        Source.Msg (1 .. Target.Msg_Length);\n-\n-      Target.Tracebacks (1 .. Target.Num_Tracebacks) :=\n-        Source.Tracebacks (1 .. Target.Num_Tracebacks);\n-   end Save_Occurrence;\n-\n-   function Save_Occurrence (Source : Exception_Occurrence) return EOA is\n-      Target : constant EOA := new Exception_Occurrence;\n-   begin\n-      Save_Occurrence (Target.all, Source);\n-      return Target;\n-   end Save_Occurrence;\n-\n-   -------------------\n-   -- String_To_EId --\n-   -------------------\n-\n-   function String_To_EId (S : String) return Exception_Id\n-     renames Stream_Attributes.String_To_EId;\n-\n-   ------------------\n-   -- String_To_EO --\n-   ------------------\n-\n-   function String_To_EO (S : String) return Exception_Occurrence\n-     renames Stream_Attributes.String_To_EO;\n-\n-   ---------------\n-   -- To_Stderr --\n-   ---------------\n-\n-   procedure To_Stderr (C : Character) is\n-      procedure Put_Char_Stderr (C : Character);\n-      pragma Import (C, Put_Char_Stderr, \"put_char_stderr\");\n-   begin\n-      Put_Char_Stderr (C);\n-   end To_Stderr;\n-\n-   procedure To_Stderr (S : String) is\n-   begin\n-      for J in S'Range loop\n-         if S (J) /= ASCII.CR then\n-            To_Stderr (S (J));\n-         end if;\n-      end loop;\n-   end To_Stderr;\n-\n-   -------------------------\n-   -- Transfer_Occurrence --\n-   -------------------------\n-\n-   procedure Transfer_Occurrence\n-     (Target : Exception_Occurrence_Access;\n-      Source : Exception_Occurrence)\n-   is\n-   begin\n-      Save_Occurrence (Target.all, Source);\n-   end Transfer_Occurrence;\n-\n-   ------------------------\n-   -- Triggered_By_Abort --\n-   ------------------------\n-\n-   function Triggered_By_Abort return Boolean is\n-      Ex : constant Exception_Occurrence_Access := Get_Current_Excep.all;\n-   begin\n-      return Ex /= null\n-        and then Exception_Identity (Ex.all) = Standard'Abort_Signal'Identity;\n-   end Triggered_By_Abort;\n-\n-   -------------------------\n-   -- Wide_Exception_Name --\n-   -------------------------\n-\n-   WC_Encoding : Character;\n-   pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n-   --  Encoding method for source, as exported by binder\n-\n-   function Wide_Exception_Name\n-     (Id : Exception_Id) return Wide_String\n-   is\n-      S : constant String := Exception_Name (Id);\n-      W : Wide_String (1 .. S'Length);\n-      L : Natural;\n-   begin\n-      String_To_Wide_String\n-        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n-      return W (1 .. L);\n-   end Wide_Exception_Name;\n-\n-   function Wide_Exception_Name\n-     (X : Exception_Occurrence) return Wide_String\n-   is\n-      S : constant String := Exception_Name (X);\n-      W : Wide_String (1 .. S'Length);\n-      L : Natural;\n-   begin\n-      String_To_Wide_String\n-        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n-      return W (1 .. L);\n-   end Wide_Exception_Name;\n-\n-   ----------------------------\n-   -- Wide_Wide_Exception_Name --\n-   -----------------------------\n-\n-   function Wide_Wide_Exception_Name\n-     (Id : Exception_Id) return Wide_Wide_String\n-   is\n-      S : constant String := Exception_Name (Id);\n-      W : Wide_Wide_String (1 .. S'Length);\n-      L : Natural;\n-   begin\n-      String_To_Wide_Wide_String\n-        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n-      return W (1 .. L);\n-   end Wide_Wide_Exception_Name;\n-\n-   function Wide_Wide_Exception_Name\n-     (X : Exception_Occurrence) return Wide_Wide_String\n-   is\n-      S : constant String := Exception_Name (X);\n-      W : Wide_Wide_String (1 .. S'Length);\n-      L : Natural;\n-   begin\n-      String_To_Wide_Wide_String\n-        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n-      return W (1 .. L);\n-   end Wide_Wide_Exception_Name;\n-\n-   --------------------------\n-   -- Code_Address_For_ZZZ --\n-   --------------------------\n-\n-   --  This function gives us the end of the PC range for addresses\n-   --  within the exception unit itself. We hope that gigi/gcc keeps all the\n-   --  procedures in their original order.\n-\n-   function Code_Address_For_ZZZ return System.Address is\n-   begin\n-      <<Start_Of_ZZZ>>\n-      return Start_Of_ZZZ'Address;\n-   end Code_Address_For_ZZZ;\n-\n-end Ada.Exceptions;"}, {"sha": "cb2b2976e4aa193b6fc12c5827023b0fc6cc6466", "filename": "gcc/ada/a-except-2005.ads", "status": "removed", "additions": 0, "deletions": 349, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de3b531c9aa93592f98ebd99c6b35be632e3c1b3/gcc%2Fada%2Fa-except-2005.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de3b531c9aa93592f98ebd99c6b35be632e3c1b3/gcc%2Fada%2Fa-except-2005.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.ads?ref=de3b531c9aa93592f98ebd99c6b35be632e3c1b3", "patch": "@@ -1,349 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT RUN-TIME COMPONENTS                         --\n---                                                                          --\n---                       A D A . E X C E P T I O N S                        --\n---                                                                          --\n---                                 S p e c                                  --\n---                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This version of Ada.Exceptions fully supports Ada 95 and later language\n---  versions.  It is used in all situations except for the build of the\n---  compiler and other basic tools. For these latter builds, we use an\n---  Ada 95-only version.\n-\n---  The reason for this splitting off of a separate version is to support\n---  older bootstrap compilers that do not support Ada 2005 features, and\n---  Ada.Exceptions is part of the compiler sources.\n-\n-pragma Polling (Off);\n---  We must turn polling off for this unit, because otherwise we get\n---  elaboration circularities with ourself.\n-\n-with System;\n-with System.Parameters;\n-with System.Standard_Library;\n-with System.Traceback_Entries;\n-\n-package Ada.Exceptions is\n-   pragma Preelaborate;\n-   --  In accordance with Ada 2005 AI-362.\n-\n-   type Exception_Id is private;\n-   pragma Preelaborable_Initialization (Exception_Id);\n-\n-   Null_Id : constant Exception_Id;\n-\n-   type Exception_Occurrence is limited private;\n-   pragma Preelaborable_Initialization (Exception_Occurrence);\n-\n-   type Exception_Occurrence_Access is access all Exception_Occurrence;\n-\n-   Null_Occurrence : constant Exception_Occurrence;\n-\n-   function Exception_Name (Id : Exception_Id) return String;\n-\n-   function Exception_Name (X : Exception_Occurrence) return String;\n-\n-   function Wide_Exception_Name\n-     (Id : Exception_Id) return Wide_String;\n-   pragma Ada_05 (Wide_Exception_Name);\n-\n-   function Wide_Exception_Name\n-     (X : Exception_Occurrence) return Wide_String;\n-   pragma Ada_05 (Wide_Exception_Name);\n-\n-   function Wide_Wide_Exception_Name\n-     (Id : Exception_Id) return Wide_Wide_String;\n-   pragma Ada_05 (Wide_Wide_Exception_Name);\n-\n-   function Wide_Wide_Exception_Name\n-     (X : Exception_Occurrence) return Wide_Wide_String;\n-   pragma Ada_05 (Wide_Wide_Exception_Name);\n-\n-   procedure Raise_Exception (E : Exception_Id; Message : String := \"\");\n-   pragma No_Return (Raise_Exception);\n-   --  Note: In accordance with AI-466, CE is raised if E = Null_Id\n-\n-   function Exception_Message (X : Exception_Occurrence) return String;\n-\n-   procedure Reraise_Occurrence (X : Exception_Occurrence);\n-   --  Note: it would be really nice to give a pragma No_Return for this\n-   --  procedure, but it would be wrong, since Reraise_Occurrence does return\n-   --  if the argument is the null exception occurrence. See also procedure\n-   --  Reraise_Occurrence_Always in the private part of this package.\n-\n-   function Exception_Identity (X : Exception_Occurrence) return Exception_Id;\n-\n-   function Exception_Information (X : Exception_Occurrence) return String;\n-   --  The format of the exception information is as follows:\n-   --\n-   --    exception name (as in Exception_Name)\n-   --    message (or a null line if no message)\n-   --    PID=nnnn\n-   --    0xyyyyyyyy 0xyyyyyyyy ...\n-   --\n-   --  The lines are separated by a ASCII.LF character\n-   --\n-   --  The nnnn is the partition Id given as decimal digits\n-   --\n-   --  The 0x... line represents traceback program counter locations,\n-   --  in order with the first one being the exception location.\n-\n-   --  Note on ordering: the compiler uses the Save_Occurrence procedure, but\n-   --  not the function from Rtsfind, so it is important that the procedure\n-   --  come first, since Rtsfind finds the first matching entity.\n-\n-   procedure Save_Occurrence\n-     (Target : out Exception_Occurrence;\n-      Source : Exception_Occurrence);\n-\n-   function Save_Occurrence\n-     (Source : Exception_Occurrence)\n-      return   Exception_Occurrence_Access;\n-\n-   --  Ada 2005 (AI-438): The language revision introduces the following\n-   --  subprograms and attribute definitions. We do not provide them\n-   --  explicitly. instead, the corresponding stream attributes are made\n-   --  available through a pragma Stream_Convert in the private part.\n-\n-   --  procedure Read_Exception_Occurrence\n-   --    (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n-   --     Item   : out Exception_Occurrence);\n-\n-   --  procedure Write_Exception_Occurrence\n-   --    (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n-   --     Item   : Exception_Occurrence);\n-\n-   --  for Exception_Occurrence'Read use Read_Exception_Occurrence;\n-   --  for Exception_Occurrence'Write use Write_Exception_Occurrence;\n-\n-private\n-   package SSL renames System.Standard_Library;\n-   package SP renames System.Parameters;\n-\n-   subtype EOA is Exception_Occurrence_Access;\n-\n-   Exception_Msg_Max_Length : constant := SP.Default_Exception_Msg_Max_Length;\n-\n-   ------------------\n-   -- Exception_Id --\n-   ------------------\n-\n-   subtype Code_Loc is System.Address;\n-   --  Code location used in building exception tables and for call addresses\n-   --  when propagating an exception. Values of this type are created by using\n-   --  Label'Address or extracted from machine states using Get_Code_Loc.\n-\n-   Null_Loc : constant Code_Loc := System.Null_Address;\n-   --  Null code location, used to flag outer level frame\n-\n-   type Exception_Id is new SSL.Exception_Data_Ptr;\n-\n-   function EId_To_String (X : Exception_Id) return String;\n-   function String_To_EId (S : String) return Exception_Id;\n-   pragma Stream_Convert (Exception_Id, String_To_EId, EId_To_String);\n-   --  Functions for implementing Exception_Id stream attributes\n-\n-   Null_Id : constant Exception_Id := null;\n-\n-   -------------------------\n-   -- Private Subprograms --\n-   -------------------------\n-\n-   function Exception_Name_Simple (X : Exception_Occurrence) return String;\n-   --  Like Exception_Name, but returns the simple non-qualified name of the\n-   --  exception. This is used to implement the Exception_Name function in\n-   --  Current_Exceptions (the DEC compatible unit). It is called from the\n-   --  compiler generated code (using Rtsfind, which does not respect the\n-   --  private barrier, so we can place this function in the private part\n-   --  where the compiler can find it, but the spec is unchanged.)\n-\n-   procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n-   pragma No_Return (Raise_Exception_Always);\n-   pragma Export (Ada, Raise_Exception_Always, \"__gnat_raise_exception\");\n-   --  This differs from Raise_Exception only in that the caller has determined\n-   --  that for sure the parameter E is not null, and that therefore no check\n-   --  for Null_Id is required. The expander converts Raise_Exception calls to\n-   --  Raise_Exception_Always if it can determine this is the case. The Export\n-   --  allows this routine to be accessed from Pure units.\n-\n-   procedure Raise_From_Signal_Handler\n-     (E : Exception_Id;\n-      M : System.Address);\n-   pragma Export\n-     (Ada, Raise_From_Signal_Handler,\n-           \"ada__exceptions__raise_from_signal_handler\");\n-   pragma No_Return (Raise_From_Signal_Handler);\n-   --  This routine is used to raise an exception from a signal handler. The\n-   --  signal handler has already stored the machine state (i.e. the state that\n-   --  corresponds to the location at which the signal was raised). E is the\n-   --  Exception_Id specifying what exception is being raised, and M is a\n-   --  pointer to a null-terminated string which is the message to be raised.\n-   --  Note that this routine never returns, so it is permissible to simply\n-   --  jump to this routine, rather than call it. This may be appropriate for\n-   --  systems where the right way to get out of signal handler is to alter the\n-   --  PC value in the machine state or in some other way ask the operating\n-   --  system to return here rather than to the original location.\n-\n-   procedure Raise_From_Controlled_Operation\n-     (X : Ada.Exceptions.Exception_Occurrence);\n-   pragma No_Return (Raise_From_Controlled_Operation);\n-   pragma Export\n-     (Ada, Raise_From_Controlled_Operation,\n-           \"__gnat_raise_from_controlled_operation\");\n-   --  Raise Program_Error, providing information about X (an exception raised\n-   --  during a controlled operation) in the exception message.\n-\n-   procedure Reraise_Library_Exception_If_Any;\n-   pragma Export\n-     (Ada, Reraise_Library_Exception_If_Any,\n-           \"__gnat_reraise_library_exception_if_any\");\n-   --  If there was an exception raised during library-level finalization,\n-   --  reraise the exception.\n-\n-   procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n-   pragma No_Return (Reraise_Occurrence_Always);\n-   --  This differs from Raise_Occurrence only in that the caller guarantees\n-   --  that for sure the parameter X is not the null occurrence, and that\n-   --  therefore this procedure cannot return. The expander uses this routine\n-   --  in the translation of a raise statement with no parameter (reraise).\n-\n-   procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence);\n-   pragma No_Return (Reraise_Occurrence_No_Defer);\n-   --  Exactly like Reraise_Occurrence, except that abort is not deferred\n-   --  before the call and the parameter X is known not to be the null\n-   --  occurrence. This is used in generated code when it is known that abort\n-   --  is already deferred.\n-\n-   function Triggered_By_Abort return Boolean;\n-   --  Determine whether the current exception (if it exists) is an instance of\n-   --  Standard'Abort_Signal.\n-\n-   -----------------------\n-   -- Polling Interface --\n-   -----------------------\n-\n-   --  The GNAT compiler has an option to generate polling calls to the Poll\n-   --  routine in this package. Specifying the -gnatP option for a compilation\n-   --  causes a call to Ada.Exceptions.Poll to be generated on every subprogram\n-   --  entry and on every iteration of a loop, thus avoiding the possibility of\n-   --  a case of unbounded time between calls.\n-\n-   --  This polling interface may be used for instrumentation or debugging\n-   --  purposes (e.g. implementing watchpoints in software or in the debugger).\n-\n-   --  In the GNAT technology itself, this interface is used to implement\n-   --  immediate asynchronous transfer of control and immediate abort on\n-   --  targets which do not provide for one thread interrupting another.\n-\n-   --  Note: this used to be in a separate unit called System.Poll, but that\n-   --  caused horrible circular elaboration problems between System.Poll and\n-   --  Ada.Exceptions.\n-\n-   procedure Poll;\n-   --  Check for asynchronous abort. Note that we do not inline the body.\n-   --  This makes the interface more useful for debugging purposes.\n-\n-   --------------------------\n-   -- Exception_Occurrence --\n-   --------------------------\n-\n-   package TBE renames System.Traceback_Entries;\n-\n-   Max_Tracebacks : constant := 50;\n-   --  Maximum number of trace backs stored in exception occurrence\n-\n-   subtype Tracebacks_Array is TBE.Tracebacks_Array (1 .. Max_Tracebacks);\n-   --  Traceback array stored in exception occurrence\n-\n-   type Exception_Occurrence is record\n-      Id : Exception_Id;\n-      --  Exception_Identity for this exception occurrence\n-\n-      Machine_Occurrence : System.Address;\n-      --  The underlying machine occurrence. For GCC, this corresponds to the\n-      --  _Unwind_Exception structure address.\n-\n-      Msg_Length : Natural := 0;\n-      --  Length of message (zero = no message)\n-\n-      Msg : String (1 .. Exception_Msg_Max_Length);\n-      --  Characters of message\n-\n-      Exception_Raised : Boolean := False;\n-      --  Set to true to indicate that this exception occurrence has actually\n-      --  been raised. When an exception occurrence is first created, this is\n-      --  set to False, then when it is processed by Raise_Current_Exception,\n-      --  it is set to True. If Raise_Current_Exception is used to raise an\n-      --  exception for which this flag is already True, then it knows that\n-      --  it is dealing with the reraise case (which is useful to distinguish\n-      --  for exception tracing purposes).\n-\n-      Pid : Natural := 0;\n-      --  Partition_Id for partition raising exception\n-\n-      Num_Tracebacks : Natural range 0 .. Max_Tracebacks := 0;\n-      --  Number of traceback entries stored\n-\n-      Tracebacks : Tracebacks_Array;\n-      --  Stored tracebacks (in Tracebacks (1 .. Num_Tracebacks))\n-   end record;\n-\n-   function \"=\" (Left, Right : Exception_Occurrence) return Boolean\n-     is abstract;\n-   --  Don't allow comparison on exception occurrences, we should not need\n-   --  this, and it would not work right, because of the Msg and Tracebacks\n-   --  fields which have unused entries not copied by Save_Occurrence.\n-\n-   function Get_Exception_Machine_Occurrence\n-     (X : Exception_Occurrence) return System.Address;\n-   pragma Export (Ada, Get_Exception_Machine_Occurrence,\n-                  \"__gnat_get_exception_machine_occurrence\");\n-   --  Get the machine occurrence corresponding to an exception occurrence.\n-   --  It is Null_Address if there is no machine occurrence (in runtimes that\n-   --  doesn't use GCC mechanism) or if it has been lost (Save_Occurrence\n-   --  doesn't save the machine occurrence).\n-\n-   function EO_To_String (X : Exception_Occurrence) return String;\n-   function String_To_EO (S : String) return Exception_Occurrence;\n-   pragma Stream_Convert (Exception_Occurrence, String_To_EO, EO_To_String);\n-   --  Functions for implementing Exception_Occurrence stream attributes\n-\n-   Null_Occurrence : constant Exception_Occurrence := (\n-     Id                 => null,\n-     Machine_Occurrence => System.Null_Address,\n-     Msg_Length         => 0,\n-     Msg                => (others => ' '),\n-     Exception_Raised   => False,\n-     Pid                => 0,\n-     Num_Tracebacks     => 0,\n-     Tracebacks         => (others => TBE.Null_TB_Entry));\n-\n-end Ada.Exceptions;"}, {"sha": "1b8e625b51e6e0fa12cd447580ef94e8e3dd5941", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 582, "deletions": 488, "changes": 1070, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,8 +29,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Compiler_Unit_Warning;\n-\n pragma Style_Checks (All_Checks);\n --  No subprogram ordering check, due to logical grouping\n \n@@ -39,16 +37,29 @@ pragma Polling (Off);\n --  elaboration circularities with System.Exception_Tables.\n \n with System;                  use System;\n+with System.Exceptions;       use System.Exceptions;\n with System.Exceptions_Debug; use System.Exceptions_Debug;\n with System.Standard_Library; use System.Standard_Library;\n with System.Soft_Links;       use System.Soft_Links;\n+with System.WCh_Con;          use System.WCh_Con;\n+with System.WCh_StW;          use System.WCh_StW;\n+\n+pragma Warnings (Off);\n+--  Suppress complaints about Symbolic not being referenced, and about it not\n+--  having pragma Preelaborate.\n+with System.Traceback.Symbolic;\n+--  Bring Symbolic into the closure. If it is the s-trasym-dwarf.adb version,\n+--  it will install symbolic tracebacks as the default decorator. Otherwise,\n+--  symbolic tracebacks are not supported, and we fall back to hexadecimal\n+--  addresses.\n+pragma Warnings (On);\n \n package body Ada.Exceptions is\n \n    pragma Suppress (All_Checks);\n-   --  We definitely do not want exceptions occurring within this unit, or we\n-   --  are in big trouble. If an exceptional situation does occur, better that\n-   --  it not be raised, since raising it can cause confusing chaos.\n+   --  We definitely do not want exceptions occurring within this unit, or\n+   --  we are in big trouble. If an exceptional situation does occur, better\n+   --  that it not be raised, since raising it can cause confusing chaos.\n \n    -----------------------\n    -- Local Subprograms --\n@@ -58,22 +69,47 @@ package body Ada.Exceptions is\n    --  from C clients using the given external name, even though they are not\n    --  technically visible in the Ada sense.\n \n-   procedure Process_Raise_Exception (E : Exception_Id);\n-   pragma No_Return (Process_Raise_Exception);\n-   --  This is the lowest level raise routine. It raises the exception\n-   --  referenced by Current_Excep.all in the TSD, without deferring abort\n-   --  (the caller must ensure that abort is deferred on entry).\n+   function Code_Address_For_AAA return System.Address;\n+   function Code_Address_For_ZZZ return System.Address;\n+   --  Return start and end of procedures in this package\n+   --\n+   --  These procedures are used to provide exclusion bounds in\n+   --  calls to Call_Chain at exception raise points from this unit. The\n+   --  purpose is to arrange for the exception tracebacks not to include\n+   --  frames from subprograms involved in the raise process, as these are\n+   --  meaningless from the user's standpoint.\n+   --\n+   --  For these bounds to be meaningful, we need to ensure that the object\n+   --  code for the subprograms involved in processing a raise is located\n+   --  after the object code Code_Address_For_AAA and before the object\n+   --  code Code_Address_For_ZZZ. This will indeed be the case as long as\n+   --  the following rules are respected:\n+   --\n+   --  1) The bodies of the subprograms involved in processing a raise\n+   --     are located after the body of Code_Address_For_AAA and before the\n+   --     body of Code_Address_For_ZZZ.\n+   --\n+   --  2) No pragma Inline applies to any of these subprograms, as this\n+   --     could delay the corresponding assembly output until the end of\n+   --     the unit.\n+\n+   procedure Call_Chain (Excep : EOA);\n+   --  Store up to Max_Tracebacks in Excep, corresponding to the current\n+   --  call chain.\n+\n+   function Image (Index : Integer) return String;\n+   --  Return string image corresponding to Index\n \n    procedure To_Stderr (S : String);\n    pragma Export (Ada, To_Stderr, \"__gnat_to_stderr\");\n-   --  Little routine to output string to stderr that is also used in the\n-   --  tasking run time.\n+   --  Little routine to output string to stderr that is also used\n+   --  in the tasking run time.\n \n    procedure To_Stderr (C : Character);\n    pragma Inline (To_Stderr);\n    pragma Export (Ada, To_Stderr, \"__gnat_to_stderr_char\");\n-   --  Little routine to output a character to stderr, used by some of the\n-   --  separate units below.\n+   --  Little routine to output a character to stderr, used by some of\n+   --  the separate units below.\n \n    package Exception_Data is\n \n@@ -88,22 +124,21 @@ package body Ada.Exceptions is\n          Line   : Integer        := 0;\n          Column : Integer        := 0;\n          Msg2   : System.Address := System.Null_Address);\n-      --  This routine is called to setup the exception referenced by the\n-      --  Current_Excep field in the TSD to contain the indicated Id value\n-      --  and message. Msg1 is a null terminated string which is generated\n-      --  as the exception message. If line is non-zero, then a colon and\n-      --  the decimal representation of this integer is appended to the\n-      --  message. Ditto for Column. When Msg2 is non-null, a space and this\n-      --  additional null terminated string is added to the message.\n+      --  This routine is called to setup the exception referenced by X\n+      --  to contain the indicated Id value and message. Msg1 is a null\n+      --  terminated string which is generated as the exception message. If\n+      --  line is non-zero, then a colon and the decimal representation of\n+      --  this integer is appended to the message. Ditto for Column. When Msg2\n+      --  is non-null, a space and this additional null terminated string is\n+      --  added to the message.\n \n       procedure Set_Exception_Msg\n         (Excep   : EOA;\n          Id      : Exception_Id;\n          Message : String);\n-      --  This routine is called to setup the exception referenced by the\n-      --  Current_Excep field in the TSD to contain the indicated Id value and\n-      --  message. Message is a string which is generated as the exception\n-      --  message.\n+      --  This routine is called to setup the exception referenced by X\n+      --  to contain the indicated Id value and message. Message is a string\n+      --  which is generated as the exception message.\n \n       ---------------------------------------\n       -- Exception Information Subprograms --\n@@ -176,14 +211,29 @@ package body Ada.Exceptions is\n \n       procedure Unhandled_Exception_Terminate (Excep : EOA);\n       pragma No_Return (Unhandled_Exception_Terminate);\n-      --  This procedure is called to terminate program execution following an\n-      --  unhandled exception. The exception information, including traceback\n-      --  if available is output, and execution is then terminated. Note that\n-      --  at the point where this routine is called, the stack has typically\n-      --  been destroyed.\n+      --  This procedure is called to terminate execution following an\n+      --  unhandled exception. The exception information, including\n+      --  traceback if available is output, and execution is then\n+      --  terminated. Note that at the point where this routine is\n+      --  called, the stack has typically been destroyed.\n \n    end Exception_Traces;\n \n+   package Exception_Propagation is\n+\n+      ---------------------------------------\n+      -- Exception Propagation Subprograms --\n+      ---------------------------------------\n+\n+      function Allocate_Occurrence return EOA;\n+      --  Allocate an exception occurrence (as well as the machine occurrence)\n+\n+      procedure Propagate_Exception (Excep : EOA);\n+      pragma No_Return (Propagate_Exception);\n+      --  This procedure propagates the exception represented by Excep\n+\n+   end Exception_Propagation;\n+\n    package Stream_Attributes is\n \n       ----------------------------------\n@@ -201,18 +251,32 @@ package body Ada.Exceptions is\n \n    end Stream_Attributes;\n \n-   procedure Raise_Current_Excep (E : Exception_Id);\n-   pragma No_Return (Raise_Current_Excep);\n-   pragma Export (C, Raise_Current_Excep, \"__gnat_raise_nodefer_with_msg\");\n-   --  This is a simple wrapper to Process_Raise_Exception.\n-   --\n-   --  This external name for Raise_Current_Excep is historical, and probably\n-   --  should be changed but for now we keep it, because gdb and gigi know\n-   --  about it.\n+   procedure Complete_Occurrence (X : EOA);\n+   --  Finish building the occurrence: save the call chain and notify the\n+   --  debugger.\n+\n+   procedure Complete_And_Propagate_Occurrence (X : EOA);\n+   pragma No_Return (Complete_And_Propagate_Occurrence);\n+   --  This is a simple wrapper to Complete_Occurrence and\n+   --  Exception_Propagation.Propagate_Exception.\n+\n+   function Create_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address) return EOA;\n+   --  Create and build an exception occurrence using exception id E and\n+   --  nul-terminated message M.\n+\n+   function Create_Machine_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address) return System.Address;\n+   pragma Export (C, Create_Machine_Occurrence_From_Signal_Handler,\n+                  \"__gnat_create_machine_occurrence_from_signal_handler\");\n+   --  Create and build an exception occurrence using exception id E and\n+   --  nul-terminated message M. Return the machine occurrence.\n \n    procedure Raise_Exception_No_Defer\n-      (E       : Exception_Id;\n-       Message : String := \"\");\n+     (E       : Exception_Id;\n+      Message : String := \"\");\n    pragma Export\n     (Ada, Raise_Exception_No_Defer,\n      \"ada__exceptions__raise_exception_no_defer\");\n@@ -222,45 +286,41 @@ package body Ada.Exceptions is\n    procedure Raise_With_Msg (E : Exception_Id);\n    pragma No_Return (Raise_With_Msg);\n    pragma Export (C, Raise_With_Msg, \"__gnat_raise_with_msg\");\n-   --  Raises an exception with given exception id value. A message is\n-   --  associated with the raise, and has already been stored in the exception\n-   --  occurrence referenced by the Current_Excep in the TSD. Abort is deferred\n-   --  before the raise call.\n+   --  Raises an exception with given exception id value. A message\n+   --  is associated with the raise, and has already been stored in the\n+   --  exception occurrence referenced by the Current_Excep in the TSD.\n+   --  Abort is deferred before the raise call.\n \n    procedure Raise_With_Location_And_Msg\n      (E : Exception_Id;\n       F : System.Address;\n       L : Integer;\n+      C : Integer := 0;\n       M : System.Address := System.Null_Address);\n    pragma No_Return (Raise_With_Location_And_Msg);\n    --  Raise an exception with given exception id value. A filename and line\n    --  number is associated with the raise and is stored in the exception\n-   --  occurrence and in addition a string message M is appended to this\n-   --  if M is not null.\n+   --  occurrence and in addition a column and a string message M may be\n+   --  appended to this (if not null/0).\n \n-   procedure Raise_Constraint_Error\n-     (File : System.Address;\n-      Line : Integer);\n+   procedure Raise_Constraint_Error (File : System.Address; Line : Integer);\n    pragma No_Return (Raise_Constraint_Error);\n-   pragma Export\n-     (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n+   pragma Export (C, Raise_Constraint_Error, \"__gnat_raise_constraint_error\");\n    --  Raise constraint error with file:line information\n \n    procedure Raise_Constraint_Error_Msg\n-     (File : System.Address;\n-      Line : Integer;\n-      Msg  : System.Address);\n+     (File   : System.Address;\n+      Line   : Integer;\n+      Column : Integer;\n+      Msg    : System.Address);\n    pragma No_Return (Raise_Constraint_Error_Msg);\n    pragma Export\n      (C, Raise_Constraint_Error_Msg, \"__gnat_raise_constraint_error_msg\");\n-   --  Raise constraint error with file:line + msg information\n+   --  Raise constraint error with file:line:col + msg information\n \n-   procedure Raise_Program_Error\n-     (File : System.Address;\n-      Line : Integer);\n+   procedure Raise_Program_Error (File : System.Address; Line : Integer);\n    pragma No_Return (Raise_Program_Error);\n-   pragma Export\n-     (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n+   pragma Export (C, Raise_Program_Error, \"__gnat_raise_program_error\");\n    --  Raise program error with file:line information\n \n    procedure Raise_Program_Error_Msg\n@@ -272,12 +332,9 @@ package body Ada.Exceptions is\n      (C, Raise_Program_Error_Msg, \"__gnat_raise_program_error_msg\");\n    --  Raise program error with file:line + msg information\n \n-   procedure Raise_Storage_Error\n-     (File : System.Address;\n-      Line : Integer);\n+   procedure Raise_Storage_Error (File : System.Address; Line : Integer);\n    pragma No_Return (Raise_Storage_Error);\n-   pragma Export\n-     (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n+   pragma Export (C, Raise_Storage_Error, \"__gnat_raise_storage_error\");\n    --  Raise storage error with file:line information\n \n    procedure Raise_Storage_Error_Msg\n@@ -294,10 +351,10 @@ package body Ada.Exceptions is\n    --  graph below illustrates the relations between the Raise_ subprograms\n    --  and identifies the points where basic flags such as Exception_Raised\n    --  are initialized.\n-   --\n+\n    --  (i) signs indicate the flags initialization points. R stands for Raise,\n    --  W for With, and E for Exception.\n-   --\n+\n    --                   R_No_Msg    R_E   R_Pe  R_Ce  R_Se\n    --                       |        |     |     |     |\n    --                       +--+  +--+     +---+ | +---+\n@@ -308,23 +365,24 @@ package body Ada.Exceptions is\n    --                        |  |  |                  |\n    --                        |  |  |             Set_E_C_Msg(i)\n    --                        |  |  |\n-   --                   Raise_Current_Excep\n+   --            Complete_And_Propagate_Occurrence\n \n    procedure Reraise;\n    pragma No_Return (Reraise);\n    pragma Export (C, Reraise, \"__gnat_reraise\");\n-   --  Reraises the exception referenced by the Current_Excep field of the TSD\n-   --  (all fields of this exception occurrence are set). Abort is deferred\n-   --  before the reraise operation.\n+   --  Reraises the exception referenced by the Current_Excep field\n+   --  of the TSD (all fields of this exception occurrence are set).\n+   --  Abort is deferred before the reraise operation. Called from\n+   --  System.Tasking.RendezVous.Exceptional_Complete_RendezVous\n \n    procedure Transfer_Occurrence\n      (Target : Exception_Occurrence_Access;\n       Source : Exception_Occurrence);\n    pragma Export (C, Transfer_Occurrence, \"__gnat_transfer_occurrence\");\n-   --  Called from System.Tasking.RendezVous.Exceptional_Complete_RendezVous\n-   --  to setup Target from Source as an exception to be propagated in the\n-   --  caller task. Target is expected to be a pointer to the fixed TSD\n-   --  occurrence for this task.\n+   --  Called from s-tasren.adb:Local_Complete_RendezVous and\n+   --  s-tpobop.adb:Exceptional_Complete_Entry_Body to setup Target from\n+   --  Source as an exception to be propagated in the caller task. Target is\n+   --  expected to be a pointer to the fixed TSD occurrence for this task.\n \n    --------------------------------\n    -- Run-Time Check Subprograms --\n@@ -334,91 +392,88 @@ package body Ada.Exceptions is\n    --  attached. The parameters are the file name and line number in each\n    --  case. The names are defined by Exp_Ch11.Get_RT_Exception_Name.\n \n-   --  Note on ordering of these subprograms. Normally in the Ada.Exceptions\n-   --  units we do not care about the ordering of entries for Rcheck\n-   --  subprograms, and the normal approach is to keep them in the same\n-   --  order as declarations in Types.\n-\n-   --  This section is an IMPORTANT EXCEPTION. It is required by the .Net\n-   --  runtime that the routine Rcheck_PE_Finalize_Raise_Exception is at the\n-   --  end of the list (for reasons that are documented in the exceptmsg.awk\n-   --  script which takes care of generating the required exception data).\n-\n-   procedure Rcheck_CE_Access_Check                   -- 00\n+   procedure Rcheck_CE_Access_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Null_Access_Parameter          -- 01\n+   procedure Rcheck_CE_Null_Access_Parameter\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Discriminant_Check             -- 02\n+   procedure Rcheck_CE_Discriminant_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Divide_By_Zero                 -- 03\n+   procedure Rcheck_CE_Divide_By_Zero\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Explicit_Raise                 -- 04\n+   procedure Rcheck_CE_Explicit_Raise\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Index_Check                    -- 05\n+   procedure Rcheck_CE_Index_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Invalid_Data                   -- 06\n+   procedure Rcheck_CE_Invalid_Data\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Length_Check                   -- 07\n+   procedure Rcheck_CE_Length_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Null_Exception_Id              -- 08\n+   procedure Rcheck_CE_Null_Exception_Id\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Null_Not_Allowed               -- 09\n+   procedure Rcheck_CE_Null_Not_Allowed\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Overflow_Check                 -- 10\n+   procedure Rcheck_CE_Overflow_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Partition_Check                -- 11\n+   procedure Rcheck_CE_Partition_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Range_Check                    -- 12\n+   procedure Rcheck_CE_Range_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_CE_Tag_Check                      -- 13\n+   procedure Rcheck_CE_Tag_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Access_Before_Elaboration      -- 14\n+   procedure Rcheck_PE_Access_Before_Elaboration\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Accessibility_Check            -- 15\n+   procedure Rcheck_PE_Accessibility_Check\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Address_Of_Intrinsic           -- 16\n+   procedure Rcheck_PE_Address_Of_Intrinsic\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Aliased_Parameters             -- 17\n+   procedure Rcheck_PE_Aliased_Parameters\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_All_Guards_Closed              -- 18\n+   procedure Rcheck_PE_All_Guards_Closed\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Bad_Predicated_Generic_Type    -- 19\n+   procedure Rcheck_PE_Bad_Predicated_Generic_Type\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Current_Task_In_Entry_Body     -- 20\n+   procedure Rcheck_PE_Current_Task_In_Entry_Body\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Duplicated_Entry_Address       -- 21\n+   procedure Rcheck_PE_Duplicated_Entry_Address\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Explicit_Raise                 -- 22\n+   procedure Rcheck_PE_Explicit_Raise\n      (File : System.Address; Line : Integer);\n-\n-   procedure Rcheck_PE_Implicit_Return                -- 24\n+   procedure Rcheck_PE_Implicit_Return\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Misaligned_Address_Value       -- 25\n+   procedure Rcheck_PE_Misaligned_Address_Value\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Missing_Return                 -- 26\n+   procedure Rcheck_PE_Missing_Return\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Overlaid_Controlled_Object     -- 27\n+   procedure Rcheck_PE_Non_Transportable_Actual\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Potentially_Blocking_Operation -- 28\n+   procedure Rcheck_PE_Overlaid_Controlled_Object\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Stubbed_Subprogram_Called      -- 29\n+   procedure Rcheck_PE_Potentially_Blocking_Operation\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Unchecked_Union_Restriction    -- 30\n+   procedure Rcheck_PE_Stubbed_Subprogram_Called\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Non_Transportable_Actual       -- 31\n+   procedure Rcheck_PE_Unchecked_Union_Restriction\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Empty_Storage_Pool             -- 32\n+   procedure Rcheck_SE_Empty_Storage_Pool\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Explicit_Raise                 -- 33\n+   procedure Rcheck_SE_Explicit_Raise\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Infinite_Recursion             -- 34\n+   procedure Rcheck_SE_Infinite_Recursion\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_SE_Object_Too_Large               -- 35\n+   procedure Rcheck_SE_Object_Too_Large\n      (File : System.Address; Line : Integer);\n-   procedure Rcheck_PE_Stream_Operation_Not_Allowed   -- 36\n+   procedure Rcheck_PE_Stream_Operation_Not_Allowed\n      (File : System.Address; Line : Integer);\n+   procedure Rcheck_CE_Access_Check_Ext\n+     (File : System.Address; Line, Column : Integer);\n+   procedure Rcheck_CE_Index_Check_Ext\n+     (File : System.Address; Line, Column, Index, First, Last : Integer);\n+   procedure Rcheck_CE_Invalid_Data_Ext\n+     (File : System.Address; Line, Column, Index, First, Last : Integer);\n+   procedure Rcheck_CE_Range_Check_Ext\n+     (File : System.Address; Line, Column, Index, First, Last : Integer);\n \n-   procedure Rcheck_PE_Finalize_Raised_Exception      -- 23\n+   procedure Rcheck_PE_Finalize_Raised_Exception\n      (File : System.Address; Line : Integer);\n    --  This routine is separated out because it has quite different behavior\n    --  from the others. This is the \"finalize/adjust raised exception\". This\n@@ -500,6 +555,15 @@ package body Ada.Exceptions is\n    pragma Export (C, Rcheck_SE_Object_Too_Large,\n                   \"__gnat_rcheck_SE_Object_Too_Large\");\n \n+   pragma Export (C, Rcheck_CE_Access_Check_Ext,\n+                  \"__gnat_rcheck_CE_Access_Check_ext\");\n+   pragma Export (C, Rcheck_CE_Index_Check_Ext,\n+                  \"__gnat_rcheck_CE_Index_Check_ext\");\n+   pragma Export (C, Rcheck_CE_Invalid_Data_Ext,\n+                  \"__gnat_rcheck_CE_Invalid_Data_ext\");\n+   pragma Export (C, Rcheck_CE_Range_Check_Ext,\n+                  \"__gnat_rcheck_CE_Range_Check_ext\");\n+\n    --  None of these procedures ever returns (they raise an exception). By\n    --  using pragma No_Return, we ensure that any junk code after the call,\n    --  such as normal return epilogue stuff, can be eliminated).\n@@ -530,8 +594,8 @@ package body Ada.Exceptions is\n    pragma No_Return (Rcheck_PE_Implicit_Return);\n    pragma No_Return (Rcheck_PE_Misaligned_Address_Value);\n    pragma No_Return (Rcheck_PE_Missing_Return);\n-   pragma No_Return (Rcheck_PE_Overlaid_Controlled_Object);\n    pragma No_Return (Rcheck_PE_Non_Transportable_Actual);\n+   pragma No_Return (Rcheck_PE_Overlaid_Controlled_Object);\n    pragma No_Return (Rcheck_PE_Potentially_Blocking_Operation);\n    pragma No_Return (Rcheck_PE_Stream_Operation_Not_Allowed);\n    pragma No_Return (Rcheck_PE_Stubbed_Subprogram_Called);\n@@ -542,124 +606,10 @@ package body Ada.Exceptions is\n    pragma No_Return (Rcheck_SE_Infinite_Recursion);\n    pragma No_Return (Rcheck_SE_Object_Too_Large);\n \n-   --  For compatibility with previous version of GNAT, to preserve bootstrap\n-\n-   procedure Rcheck_00 (File : System.Address; Line : Integer);\n-   procedure Rcheck_01 (File : System.Address; Line : Integer);\n-   procedure Rcheck_02 (File : System.Address; Line : Integer);\n-   procedure Rcheck_03 (File : System.Address; Line : Integer);\n-   procedure Rcheck_04 (File : System.Address; Line : Integer);\n-   procedure Rcheck_05 (File : System.Address; Line : Integer);\n-   procedure Rcheck_06 (File : System.Address; Line : Integer);\n-   procedure Rcheck_07 (File : System.Address; Line : Integer);\n-   procedure Rcheck_08 (File : System.Address; Line : Integer);\n-   procedure Rcheck_09 (File : System.Address; Line : Integer);\n-   procedure Rcheck_10 (File : System.Address; Line : Integer);\n-   procedure Rcheck_11 (File : System.Address; Line : Integer);\n-   procedure Rcheck_12 (File : System.Address; Line : Integer);\n-   procedure Rcheck_13 (File : System.Address; Line : Integer);\n-   procedure Rcheck_14 (File : System.Address; Line : Integer);\n-   procedure Rcheck_15 (File : System.Address; Line : Integer);\n-   procedure Rcheck_16 (File : System.Address; Line : Integer);\n-   procedure Rcheck_17 (File : System.Address; Line : Integer);\n-   procedure Rcheck_18 (File : System.Address; Line : Integer);\n-   procedure Rcheck_19 (File : System.Address; Line : Integer);\n-   procedure Rcheck_20 (File : System.Address; Line : Integer);\n-   procedure Rcheck_21 (File : System.Address; Line : Integer);\n-   procedure Rcheck_22 (File : System.Address; Line : Integer);\n-   procedure Rcheck_23 (File : System.Address; Line : Integer);\n-   procedure Rcheck_24 (File : System.Address; Line : Integer);\n-   procedure Rcheck_25 (File : System.Address; Line : Integer);\n-   procedure Rcheck_26 (File : System.Address; Line : Integer);\n-   procedure Rcheck_27 (File : System.Address; Line : Integer);\n-   procedure Rcheck_28 (File : System.Address; Line : Integer);\n-   procedure Rcheck_29 (File : System.Address; Line : Integer);\n-   procedure Rcheck_30 (File : System.Address; Line : Integer);\n-   procedure Rcheck_31 (File : System.Address; Line : Integer);\n-   procedure Rcheck_32 (File : System.Address; Line : Integer);\n-   procedure Rcheck_33 (File : System.Address; Line : Integer);\n-   procedure Rcheck_34 (File : System.Address; Line : Integer);\n-   procedure Rcheck_35 (File : System.Address; Line : Integer);\n-   procedure Rcheck_36 (File : System.Address; Line : Integer);\n-\n-   pragma Export (C, Rcheck_00, \"__gnat_rcheck_00\");\n-   pragma Export (C, Rcheck_01, \"__gnat_rcheck_01\");\n-   pragma Export (C, Rcheck_02, \"__gnat_rcheck_02\");\n-   pragma Export (C, Rcheck_03, \"__gnat_rcheck_03\");\n-   pragma Export (C, Rcheck_04, \"__gnat_rcheck_04\");\n-   pragma Export (C, Rcheck_05, \"__gnat_rcheck_05\");\n-   pragma Export (C, Rcheck_06, \"__gnat_rcheck_06\");\n-   pragma Export (C, Rcheck_07, \"__gnat_rcheck_07\");\n-   pragma Export (C, Rcheck_08, \"__gnat_rcheck_08\");\n-   pragma Export (C, Rcheck_09, \"__gnat_rcheck_09\");\n-   pragma Export (C, Rcheck_10, \"__gnat_rcheck_10\");\n-   pragma Export (C, Rcheck_11, \"__gnat_rcheck_11\");\n-   pragma Export (C, Rcheck_12, \"__gnat_rcheck_12\");\n-   pragma Export (C, Rcheck_13, \"__gnat_rcheck_13\");\n-   pragma Export (C, Rcheck_14, \"__gnat_rcheck_14\");\n-   pragma Export (C, Rcheck_15, \"__gnat_rcheck_15\");\n-   pragma Export (C, Rcheck_16, \"__gnat_rcheck_16\");\n-   pragma Export (C, Rcheck_17, \"__gnat_rcheck_17\");\n-   pragma Export (C, Rcheck_18, \"__gnat_rcheck_18\");\n-   pragma Export (C, Rcheck_19, \"__gnat_rcheck_19\");\n-   pragma Export (C, Rcheck_20, \"__gnat_rcheck_20\");\n-   pragma Export (C, Rcheck_21, \"__gnat_rcheck_21\");\n-   pragma Export (C, Rcheck_22, \"__gnat_rcheck_22\");\n-   pragma Export (C, Rcheck_23, \"__gnat_rcheck_23\");\n-   pragma Export (C, Rcheck_24, \"__gnat_rcheck_24\");\n-   pragma Export (C, Rcheck_25, \"__gnat_rcheck_25\");\n-   pragma Export (C, Rcheck_26, \"__gnat_rcheck_26\");\n-   pragma Export (C, Rcheck_27, \"__gnat_rcheck_27\");\n-   pragma Export (C, Rcheck_28, \"__gnat_rcheck_28\");\n-   pragma Export (C, Rcheck_29, \"__gnat_rcheck_29\");\n-   pragma Export (C, Rcheck_30, \"__gnat_rcheck_30\");\n-   pragma Export (C, Rcheck_31, \"__gnat_rcheck_31\");\n-   pragma Export (C, Rcheck_32, \"__gnat_rcheck_32\");\n-   pragma Export (C, Rcheck_33, \"__gnat_rcheck_33\");\n-   pragma Export (C, Rcheck_34, \"__gnat_rcheck_34\");\n-   pragma Export (C, Rcheck_35, \"__gnat_rcheck_35\");\n-   pragma Export (C, Rcheck_36, \"__gnat_rcheck_36\");\n-\n-   --  None of these procedures ever returns (they raise an exception). By\n-   --  using pragma No_Return, we ensure that any junk code after the call,\n-   --  such as normal return epilogue stuff, can be eliminated).\n-\n-   pragma No_Return (Rcheck_00);\n-   pragma No_Return (Rcheck_01);\n-   pragma No_Return (Rcheck_02);\n-   pragma No_Return (Rcheck_03);\n-   pragma No_Return (Rcheck_04);\n-   pragma No_Return (Rcheck_05);\n-   pragma No_Return (Rcheck_06);\n-   pragma No_Return (Rcheck_07);\n-   pragma No_Return (Rcheck_08);\n-   pragma No_Return (Rcheck_09);\n-   pragma No_Return (Rcheck_10);\n-   pragma No_Return (Rcheck_11);\n-   pragma No_Return (Rcheck_12);\n-   pragma No_Return (Rcheck_13);\n-   pragma No_Return (Rcheck_14);\n-   pragma No_Return (Rcheck_15);\n-   pragma No_Return (Rcheck_16);\n-   pragma No_Return (Rcheck_17);\n-   pragma No_Return (Rcheck_18);\n-   pragma No_Return (Rcheck_19);\n-   pragma No_Return (Rcheck_20);\n-   pragma No_Return (Rcheck_21);\n-   pragma No_Return (Rcheck_22);\n-   pragma No_Return (Rcheck_23);\n-   pragma No_Return (Rcheck_24);\n-   pragma No_Return (Rcheck_25);\n-   pragma No_Return (Rcheck_26);\n-   pragma No_Return (Rcheck_27);\n-   pragma No_Return (Rcheck_28);\n-   pragma No_Return (Rcheck_29);\n-   pragma No_Return (Rcheck_30);\n-   pragma No_Return (Rcheck_32);\n-   pragma No_Return (Rcheck_33);\n-   pragma No_Return (Rcheck_34);\n-   pragma No_Return (Rcheck_35);\n-   pragma No_Return (Rcheck_36);\n+   pragma No_Return (Rcheck_CE_Access_Check_Ext);\n+   pragma No_Return (Rcheck_CE_Index_Check_Ext);\n+   pragma No_Return (Rcheck_CE_Invalid_Data_Ext);\n+   pragma No_Return (Rcheck_CE_Range_Check_Ext);\n \n    ---------------------------------------------\n    -- Reason Strings for Run-Time Check Calls --\n@@ -727,6 +677,33 @@ package body Ada.Exceptions is\n    --  The actual polling routine is separate, so that it can easily be\n    --  replaced with a target dependent version.\n \n+   --------------------------\n+   -- Code_Address_For_AAA --\n+   --------------------------\n+\n+   --  This function gives us the start of the PC range for addresses within\n+   --  the exception unit itself. We hope that gigi/gcc keep all the procedures\n+   --  in their original order.\n+\n+   function Code_Address_For_AAA return System.Address is\n+   begin\n+      --  We are using a label instead of Code_Address_For_AAA'Address because\n+      --  on some platforms the latter does not yield the address we want, but\n+      --  the address of a stub or of a descriptor instead. This is the case at\n+      --  least on PA-HPUX.\n+\n+      <<Start_Of_AAA>>\n+      return Start_Of_AAA'Address;\n+   end Code_Address_For_AAA;\n+\n+   ----------------\n+   -- Call_Chain --\n+   ----------------\n+\n+   procedure Call_Chain (Excep : EOA) is separate;\n+   --  The actual Call_Chain routine is separate, so that it can easily\n+   --  be dummied out when no exception traceback information is needed.\n+\n    -------------------\n    -- EId_To_String --\n    -------------------\n@@ -752,9 +729,9 @@ package body Ada.Exceptions is\n      (X : Exception_Occurrence) return Exception_Id\n    is\n    begin\n-      --  Note that the following test used to be here for the original Ada 95\n-      --  semantics, but these were modified by AI-241 to require returning\n-      --  Null_Id instead of raising Constraint_Error.\n+      --  Note that the following test used to be here for the original\n+      --  Ada 95 semantics, but these were modified by AI-241 to require\n+      --  returning Null_Id instead of raising Constraint_Error.\n \n       --  if X.Id = Null_Id then\n       --     raise Constraint_Error;\n@@ -784,9 +761,9 @@ package body Ada.Exceptions is\n    begin\n       if X.Id = Null_Id then\n          raise Constraint_Error;\n+      else\n+         return X.Msg (1 .. X.Msg_Length);\n       end if;\n-\n-      return X.Msg (1 .. X.Msg_Length);\n    end Exception_Message;\n \n    --------------------\n@@ -797,9 +774,9 @@ package body Ada.Exceptions is\n    begin\n       if Id = null then\n          raise Constraint_Error;\n+      else\n+         return To_Ptr (Id.Full_Name) (1 .. Id.Name_Length - 1);\n       end if;\n-\n-      return To_Ptr (Id.Full_Name) (1 .. Id.Name_Length - 1);\n    end Exception_Name;\n \n    function Exception_Name (X : Exception_Occurrence) return String is\n@@ -839,15 +816,49 @@ package body Ada.Exceptions is\n    --  This package can be easily dummied out if we do not want the basic\n    --  support for exception messages (such as in Ada 83).\n \n+   ---------------------------\n+   -- Exception_Propagation --\n+   ---------------------------\n+\n+   package body Exception_Propagation is separate;\n+   --  Depending on the actual exception mechanism used (front-end or\n+   --  back-end based), the implementation will differ, which is why this\n+   --  package is separated.\n+\n    ----------------------\n    -- Exception_Traces --\n    ----------------------\n \n    package body Exception_Traces is separate;\n    --  Depending on the underlying support for IO the implementation will\n-   --  differ. Moreover we would like to dummy out this package in case we do\n-   --  not want any exception tracing support. This is why this package is\n-   --  separated.\n+   --  differ. Moreover we would like to dummy out this package in case we\n+   --  do not want any exception tracing support. This is why this package\n+   --  is separated.\n+\n+   --------------------------------------\n+   -- Get_Exception_Machine_Occurrence --\n+   --------------------------------------\n+\n+   function Get_Exception_Machine_Occurrence\n+     (X : Exception_Occurrence) return System.Address\n+   is\n+   begin\n+      return X.Machine_Occurrence;\n+   end Get_Exception_Machine_Occurrence;\n+\n+   -----------\n+   -- Image --\n+   -----------\n+\n+   function Image (Index : Integer) return String is\n+      Result : constant String := Integer'Image (Index);\n+   begin\n+      if Result (1) = ' ' then\n+         return Result (2 .. Result'Last);\n+      else\n+         return Result;\n+      end if;\n+   end Image;\n \n    -----------------------\n    -- Stream Attributes --\n@@ -857,101 +868,74 @@ package body Ada.Exceptions is\n    --  This package can be easily dummied out if we do not want the\n    --  support for streaming Exception_Ids and Exception_Occurrences.\n \n-   -----------------------------\n-   -- Process_Raise_Exception --\n-   -----------------------------\n-\n-   procedure Process_Raise_Exception (E : Exception_Id) is\n-      pragma Inspection_Point (E);\n-      --  This is so the debugger can reliably inspect the parameter\n-\n-      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n-      Excep       : constant EOA := Get_Current_Excep.all;\n-\n-      procedure builtin_longjmp (buffer : Address; Flag : Integer);\n-      pragma No_Return (builtin_longjmp);\n-      pragma Import (C, builtin_longjmp, \"_gnat_builtin_longjmp\");\n-\n-   begin\n-      --  WARNING: There should be no exception handler for this body because\n-      --  this would cause gigi to prepend a setup for a new jmpbuf to the\n-      --  sequence of statements in case of built-in sjljl. We would then\n-      --  always get this new buf in Jumpbuf_Ptr instead of the one for the\n-      --  exception we are handling, which would completely break the whole\n-      --  design of this procedure.\n-\n-      --  If the jump buffer pointer is non-null, transfer control using it.\n-      --  Otherwise announce an unhandled exception (note that this means that\n-      --  we have no finalizations to do other than at the outer level).\n-      --  Perform the necessary notification tasks in both cases.\n-\n-      if Jumpbuf_Ptr /= Null_Address then\n-         if not Excep.Exception_Raised then\n-            Excep.Exception_Raised := True;\n-            Exception_Traces.Notify_Handled_Exception (Excep);\n-         end if;\n-\n-         builtin_longjmp (Jumpbuf_Ptr, 1);\n-\n-      else\n-         Exception_Traces.Notify_Unhandled_Exception (Excep);\n-         Exception_Traces.Unhandled_Exception_Terminate (Excep);\n-      end if;\n-   end Process_Raise_Exception;\n-\n    ----------------------------\n    -- Raise_Constraint_Error --\n    ----------------------------\n \n-   procedure Raise_Constraint_Error\n-     (File : System.Address;\n-      Line : Integer)\n-   is\n+   procedure Raise_Constraint_Error (File : System.Address; Line : Integer) is\n    begin\n-      Raise_With_Location_And_Msg\n-        (Constraint_Error_Def'Access, File, Line);\n+      Raise_With_Location_And_Msg (Constraint_Error_Def'Access, File, Line);\n    end Raise_Constraint_Error;\n \n    --------------------------------\n    -- Raise_Constraint_Error_Msg --\n    --------------------------------\n \n    procedure Raise_Constraint_Error_Msg\n-     (File : System.Address;\n-      Line : Integer;\n-      Msg  : System.Address)\n+     (File   : System.Address;\n+      Line   : Integer;\n+      Column : Integer;\n+      Msg    : System.Address)\n    is\n    begin\n       Raise_With_Location_And_Msg\n-        (Constraint_Error_Def'Access, File, Line, Msg);\n+        (Constraint_Error_Def'Access, File, Line, Column, Msg);\n    end Raise_Constraint_Error_Msg;\n \n    -------------------------\n-   -- Raise_Current_Excep --\n+   -- Complete_Occurrence --\n    -------------------------\n \n-   procedure Raise_Current_Excep (E : Exception_Id) is\n+   procedure Complete_Occurrence (X : EOA) is\n+   begin\n+      --  Compute the backtrace for this occurrence if the corresponding\n+      --  binder option has been set. Call_Chain takes care of the reraise\n+      --  case.\n+\n+      --  ??? Using Call_Chain here means we are going to walk up the stack\n+      --  once only for backtracing purposes before doing it again for the\n+      --  propagation per se.\n+\n+      --  The first inspection is much lighter, though, as it only requires\n+      --  partial unwinding of each frame. Additionally, although we could use\n+      --  the personality routine to record the addresses while propagating,\n+      --  this method has two drawbacks:\n+\n+      --  1) the trace is incomplete if the exception is handled since we\n+      --  don't walk past the frame with the handler,\n \n-      pragma Inspection_Point (E);\n-      --  This is so the debugger can reliably inspect the parameter when\n-      --  inserting a breakpoint at the start of this procedure.\n+      --    and\n \n-      Id : Exception_Id := E;\n-      pragma Volatile (Id);\n-      pragma Warnings (Off, Id);\n-      --  In order to provide support for breakpoints on unhandled exceptions,\n-      --  the debugger will also need to be able to inspect the value of E from\n-      --  another (inner) frame. So we need to make sure that if E is passed in\n-      --  a register, its value is also spilled on stack. For this, we store\n-      --  the parameter value in a local variable, and add a pragma Volatile to\n-      --  make sure it is spilled. The pragma Warnings (Off) is needed because\n-      --  the compiler knows that Id is not referenced and that this use of\n-      --  pragma Volatile is peculiar.\n+      --  2) we would miss the frames for which our personality routine is not\n+      --  called, e.g. if C or C++ calls are on the way.\n \n+      Call_Chain (X);\n+\n+      --  Notify the debugger\n+      Debug_Raise_Exception\n+        (E       => SSL.Exception_Data_Ptr (X.Id),\n+         Message => X.Msg (1 .. X.Msg_Length));\n+   end Complete_Occurrence;\n+\n+   ---------------------------------------\n+   -- Complete_And_Propagate_Occurrence --\n+   ---------------------------------------\n+\n+   procedure Complete_And_Propagate_Occurrence (X : EOA) is\n    begin\n-      Debug_Raise_Exception (E => SSL.Exception_Data_Ptr (E), Message => \"\");\n-      Process_Raise_Exception (E);\n-   end Raise_Current_Excep;\n+      Complete_Occurrence (X);\n+      Exception_Propagation.Propagate_Exception (X);\n+   end Complete_And_Propagate_Occurrence;\n \n    ---------------------\n    -- Raise_Exception --\n@@ -961,8 +945,7 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n-      EF    : Exception_Id := E;\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      EF : Exception_Id := E;\n    begin\n       --  Raise CE if E = Null_ID (AI-446)\n \n@@ -972,9 +955,7 @@ package body Ada.Exceptions is\n \n       --  Go ahead and raise appropriate exception\n \n-      Exception_Data.Set_Exception_Msg (Excep, EF, Message);\n-      Abort_Defer.all;\n-      Raise_Current_Excep (EF);\n+      Raise_Exception_Always (EF, Message);\n    end Raise_Exception;\n \n    ----------------------------\n@@ -985,11 +966,16 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+\n    begin\n-      Exception_Data.Set_Exception_Msg (Excep, E, Message);\n-      Abort_Defer.all;\n-      Raise_Current_Excep (E);\n+      Exception_Data.Set_Exception_Msg (X, E, Message);\n+\n+      if not ZCX_By_Default then\n+         Abort_Defer.all;\n+      end if;\n+\n+      Complete_And_Propagate_Occurrence (X);\n    end Raise_Exception_Always;\n \n    ------------------------------\n@@ -1000,13 +986,14 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+\n    begin\n-      Exception_Data.Set_Exception_Msg (Excep, E, Message);\n+      Exception_Data.Set_Exception_Msg (X, E, Message);\n \n       --  Do not call Abort_Defer.all, as specified by the spec\n \n-      Raise_Current_Excep (E);\n+      Complete_And_Propagate_Occurrence (X);\n    end Raise_Exception_No_Defer;\n \n    -------------------------------------\n@@ -1019,11 +1006,13 @@ package body Ada.Exceptions is\n       Prefix             : constant String := \"adjust/finalize raised \";\n       Orig_Msg           : constant String := Exception_Message (X);\n       Orig_Prefix_Length : constant Natural :=\n-        Integer'Min (Prefix'Length, Orig_Msg'Length);\n-      Orig_Prefix        : String renames Orig_Msg\n-        (Orig_Msg'First ..  Orig_Msg'First + Orig_Prefix_Length - 1);\n+                             Integer'Min (Prefix'Length, Orig_Msg'Length);\n+\n+      Orig_Prefix : String renames\n+        Orig_Msg (Orig_Msg'First .. Orig_Msg'First + Orig_Prefix_Length - 1);\n+\n    begin\n-      --  Message already has proper prefix, just re-reraise\n+      --  Message already has the proper prefix, just re-raise\n \n       if Orig_Prefix = Prefix then\n          Raise_Exception_No_Defer\n@@ -1053,6 +1042,39 @@ package body Ada.Exceptions is\n       end if;\n    end Raise_From_Controlled_Operation;\n \n+   -------------------------------------------\n+   -- Create_Occurrence_From_Signal_Handler --\n+   -------------------------------------------\n+\n+   function Create_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address) return EOA\n+   is\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+\n+   begin\n+      Exception_Data.Set_Exception_C_Msg (X, E, M);\n+\n+      if not ZCX_By_Default then\n+         Abort_Defer.all;\n+      end if;\n+\n+      Complete_Occurrence (X);\n+      return X;\n+   end Create_Occurrence_From_Signal_Handler;\n+\n+   ---------------------------------------------------\n+   -- Create_Machine_Occurrence_From_Signal_Handler --\n+   ---------------------------------------------------\n+\n+   function Create_Machine_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address) return System.Address\n+   is\n+   begin\n+      return Create_Occurrence_From_Signal_Handler (E, M).Machine_Occurrence;\n+   end Create_Machine_Occurrence_From_Signal_Handler;\n+\n    -------------------------------\n    -- Raise_From_Signal_Handler --\n    -------------------------------\n@@ -1061,11 +1083,9 @@ package body Ada.Exceptions is\n      (E : Exception_Id;\n       M : System.Address)\n    is\n-      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n-      Exception_Data.Set_Exception_C_Msg (Excep, E, M);\n-      Abort_Defer.all;\n-      Process_Raise_Exception (E);\n+      Exception_Propagation.Propagate_Exception\n+        (Create_Occurrence_From_Signal_Handler (E, M));\n    end Raise_From_Signal_Handler;\n \n    -------------------------\n@@ -1077,8 +1097,7 @@ package body Ada.Exceptions is\n       Line : Integer)\n    is\n    begin\n-      Raise_With_Location_And_Msg\n-        (Program_Error_Def'Access, File, Line);\n+      Raise_With_Location_And_Msg (Program_Error_Def'Access, File, Line);\n    end Raise_Program_Error;\n \n    -----------------------------\n@@ -1092,7 +1111,7 @@ package body Ada.Exceptions is\n    is\n    begin\n       Raise_With_Location_And_Msg\n-        (Program_Error_Def'Access, File, Line, Msg);\n+        (Program_Error_Def'Access, File, Line, M => Msg);\n    end Raise_Program_Error_Msg;\n \n    -------------------------\n@@ -1104,8 +1123,7 @@ package body Ada.Exceptions is\n       Line : Integer)\n    is\n    begin\n-      Raise_With_Location_And_Msg\n-        (Storage_Error_Def'Access, File, Line);\n+      Raise_With_Location_And_Msg (Storage_Error_Def'Access, File, Line);\n    end Raise_Storage_Error;\n \n    -----------------------------\n@@ -1119,7 +1137,7 @@ package body Ada.Exceptions is\n    is\n    begin\n       Raise_With_Location_And_Msg\n-        (Storage_Error_Def'Access, File, Line, Msg);\n+        (Storage_Error_Def'Access, File, Line, M => Msg);\n    end Raise_Storage_Error_Msg;\n \n    ---------------------------------\n@@ -1130,29 +1148,47 @@ package body Ada.Exceptions is\n      (E : Exception_Id;\n       F : System.Address;\n       L : Integer;\n+      C : Integer := 0;\n       M : System.Address := System.Null_Address)\n    is\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n    begin\n-      Exception_Data.Set_Exception_C_Msg (Excep, E, F, L, Msg2 => M);\n-      Abort_Defer.all;\n-      Raise_Current_Excep (E);\n+      Exception_Data.Set_Exception_C_Msg (X, E, F, L, C, M);\n+\n+      if not ZCX_By_Default then\n+         Abort_Defer.all;\n+      end if;\n+\n+      Complete_And_Propagate_Occurrence (X);\n    end Raise_With_Location_And_Msg;\n \n    --------------------\n    -- Raise_With_Msg --\n    --------------------\n \n    procedure Raise_With_Msg (E : Exception_Id) is\n-      Excep : constant EOA := Get_Current_Excep.all;\n-\n+      Excep : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+      Ex    : constant Exception_Occurrence_Access := Get_Current_Excep.all;\n    begin\n       Excep.Exception_Raised := False;\n       Excep.Id               := E;\n       Excep.Num_Tracebacks   := 0;\n       Excep.Pid              := Local_Partition_ID;\n-      Abort_Defer.all;\n-      Raise_Current_Excep (E);\n+\n+      --  Copy the message from the current exception\n+      --  Change the interface to be called with an occurrence ???\n+\n+      Excep.Msg_Length                  := Ex.Msg_Length;\n+      Excep.Msg (1 .. Excep.Msg_Length) := Ex.Msg (1 .. Ex.Msg_Length);\n+\n+      --  The following is a common pattern, should be abstracted\n+      --  into a procedure call ???\n+\n+      if not ZCX_By_Default then\n+         Abort_Defer.all;\n+      end if;\n+\n+      Complete_And_Propagate_Occurrence (Excep);\n    end Raise_With_Msg;\n \n    -----------------------------------------\n@@ -1163,98 +1199,98 @@ package body Ada.Exceptions is\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_00'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_00'Address);\n    end Rcheck_CE_Access_Check;\n \n    procedure Rcheck_CE_Null_Access_Parameter\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_01'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_01'Address);\n    end Rcheck_CE_Null_Access_Parameter;\n \n    procedure Rcheck_CE_Discriminant_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_02'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_02'Address);\n    end Rcheck_CE_Discriminant_Check;\n \n    procedure Rcheck_CE_Divide_By_Zero\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_03'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_03'Address);\n    end Rcheck_CE_Divide_By_Zero;\n \n    procedure Rcheck_CE_Explicit_Raise\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_04'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_04'Address);\n    end Rcheck_CE_Explicit_Raise;\n \n    procedure Rcheck_CE_Index_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_05'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_05'Address);\n    end Rcheck_CE_Index_Check;\n \n    procedure Rcheck_CE_Invalid_Data\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_06'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_06'Address);\n    end Rcheck_CE_Invalid_Data;\n \n    procedure Rcheck_CE_Length_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_07'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_07'Address);\n    end Rcheck_CE_Length_Check;\n \n    procedure Rcheck_CE_Null_Exception_Id\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_08'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_08'Address);\n    end Rcheck_CE_Null_Exception_Id;\n \n    procedure Rcheck_CE_Null_Not_Allowed\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_09'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_09'Address);\n    end Rcheck_CE_Null_Not_Allowed;\n \n    procedure Rcheck_CE_Overflow_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_10'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_10'Address);\n    end Rcheck_CE_Overflow_Check;\n \n    procedure Rcheck_CE_Partition_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_11'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_11'Address);\n    end Rcheck_CE_Partition_Check;\n \n    procedure Rcheck_CE_Range_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_12'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_12'Address);\n    end Rcheck_CE_Range_Check;\n \n    procedure Rcheck_CE_Tag_Check\n      (File : System.Address; Line : Integer)\n    is\n    begin\n-      Raise_Constraint_Error_Msg (File, Line, Rmsg_13'Address);\n+      Raise_Constraint_Error_Msg (File, Line, 0, Rmsg_13'Address);\n    end Rcheck_CE_Tag_Check;\n \n    procedure Rcheck_PE_Access_Before_Elaboration\n@@ -1341,6 +1377,13 @@ package body Ada.Exceptions is\n       Raise_Program_Error_Msg (File, Line, Rmsg_26'Address);\n    end Rcheck_PE_Missing_Return;\n \n+   procedure Rcheck_PE_Non_Transportable_Actual\n+     (File : System.Address; Line : Integer)\n+   is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_31'Address);\n+   end Rcheck_PE_Non_Transportable_Actual;\n+\n    procedure Rcheck_PE_Overlaid_Controlled_Object\n      (File : System.Address; Line : Integer)\n    is\n@@ -1355,6 +1398,13 @@ package body Ada.Exceptions is\n       Raise_Program_Error_Msg (File, Line, Rmsg_28'Address);\n    end Rcheck_PE_Potentially_Blocking_Operation;\n \n+   procedure Rcheck_PE_Stream_Operation_Not_Allowed\n+     (File : System.Address; Line : Integer)\n+   is\n+   begin\n+      Raise_Program_Error_Msg (File, Line, Rmsg_36'Address);\n+   end Rcheck_PE_Stream_Operation_Not_Allowed;\n+\n    procedure Rcheck_PE_Stubbed_Subprogram_Called\n      (File : System.Address; Line : Integer)\n    is\n@@ -1369,13 +1419,6 @@ package body Ada.Exceptions is\n       Raise_Program_Error_Msg (File, Line, Rmsg_30'Address);\n    end Rcheck_PE_Unchecked_Union_Restriction;\n \n-   procedure Rcheck_PE_Non_Transportable_Actual\n-     (File : System.Address; Line : Integer)\n-   is\n-   begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_31'Address);\n-   end Rcheck_PE_Non_Transportable_Actual;\n-\n    procedure Rcheck_SE_Empty_Storage_Pool\n      (File : System.Address; Line : Integer)\n    is\n@@ -1404,116 +1447,79 @@ package body Ada.Exceptions is\n       Raise_Storage_Error_Msg (File, Line, Rmsg_35'Address);\n    end Rcheck_SE_Object_Too_Large;\n \n-   procedure Rcheck_PE_Stream_Operation_Not_Allowed\n-     (File : System.Address; Line : Integer)\n+   procedure Rcheck_CE_Access_Check_Ext\n+     (File : System.Address; Line, Column : Integer)\n    is\n    begin\n-      Raise_Program_Error_Msg (File, Line, Rmsg_36'Address);\n-   end Rcheck_PE_Stream_Operation_Not_Allowed;\n+      Raise_Constraint_Error_Msg (File, Line, Column, Rmsg_00'Address);\n+   end Rcheck_CE_Access_Check_Ext;\n+\n+   procedure Rcheck_CE_Index_Check_Ext\n+     (File : System.Address; Line, Column, Index, First, Last : Integer)\n+   is\n+      Msg : constant String :=\n+              Rmsg_05 (Rmsg_05'First .. Rmsg_05'Last - 1) & ASCII.LF\n+              & \"index \" & Image (Index) & \" not in \" & Image (First)\n+              & \"..\" & Image (Last) & ASCII.NUL;\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Column, Msg'Address);\n+   end Rcheck_CE_Index_Check_Ext;\n+\n+   procedure Rcheck_CE_Invalid_Data_Ext\n+     (File : System.Address; Line, Column, Index, First, Last : Integer)\n+   is\n+      Msg : constant String :=\n+              Rmsg_06 (Rmsg_06'First .. Rmsg_06'Last - 1) & ASCII.LF\n+              & \"value \" & Image (Index) & \" not in \" & Image (First)\n+              & \"..\" & Image (Last) & ASCII.NUL;\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Column, Msg'Address);\n+   end Rcheck_CE_Invalid_Data_Ext;\n+\n+   procedure Rcheck_CE_Range_Check_Ext\n+     (File : System.Address; Line, Column, Index, First, Last : Integer)\n+   is\n+      Msg : constant String :=\n+              Rmsg_12 (Rmsg_12'First .. Rmsg_12'Last - 1) & ASCII.LF\n+              & \"value \" & Image (Index) & \" not in \" & Image (First)\n+              & \"..\" & Image (Last) & ASCII.NUL;\n+   begin\n+      Raise_Constraint_Error_Msg (File, Line, Column, Msg'Address);\n+   end Rcheck_CE_Range_Check_Ext;\n \n    procedure Rcheck_PE_Finalize_Raised_Exception\n      (File : System.Address; Line : Integer)\n    is\n-      E     : constant Exception_Id := Program_Error_Def'Access;\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n \n    begin\n       --  This is \"finalize/adjust raised exception\". This subprogram is always\n-      --  called with abort deferred, unlike all other Rcheck_* subprograms,\n-      --  itneeds to call Raise_Exception_No_Defer.\n+      --  called with abort deferred, unlike all other Rcheck_* subprograms, it\n+      --  needs to call Raise_Exception_No_Defer.\n \n       --  This is consistent with Raise_From_Controlled_Operation\n \n-      Exception_Data.Set_Exception_C_Msg (Excep, E, File, Line, 0,\n-                                          Rmsg_23'Address);\n-      Raise_Current_Excep (E);\n+      Exception_Data.Set_Exception_C_Msg\n+        (X, Program_Error_Def'Access, File, Line, 0, Rmsg_23'Address);\n+      Complete_And_Propagate_Occurrence (X);\n    end Rcheck_PE_Finalize_Raised_Exception;\n \n-   procedure Rcheck_00 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Access_Check;\n-   procedure Rcheck_01 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Null_Access_Parameter;\n-   procedure Rcheck_02 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Discriminant_Check;\n-   procedure Rcheck_03 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Divide_By_Zero;\n-   procedure Rcheck_04 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Explicit_Raise;\n-   procedure Rcheck_05 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Index_Check;\n-   procedure Rcheck_06 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Invalid_Data;\n-   procedure Rcheck_07 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Length_Check;\n-   procedure Rcheck_08 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Null_Exception_Id;\n-   procedure Rcheck_09 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Null_Not_Allowed;\n-   procedure Rcheck_10 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Overflow_Check;\n-   procedure Rcheck_11 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Partition_Check;\n-   procedure Rcheck_12 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Range_Check;\n-   procedure Rcheck_13 (File : System.Address; Line : Integer)\n-     renames Rcheck_CE_Tag_Check;\n-   procedure Rcheck_14 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Access_Before_Elaboration;\n-   procedure Rcheck_15 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Accessibility_Check;\n-   procedure Rcheck_16 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Address_Of_Intrinsic;\n-   procedure Rcheck_17 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Aliased_Parameters;\n-   procedure Rcheck_18 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_All_Guards_Closed;\n-   procedure Rcheck_19 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Bad_Predicated_Generic_Type;\n-   procedure Rcheck_20 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Current_Task_In_Entry_Body;\n-   procedure Rcheck_21 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Duplicated_Entry_Address;\n-   procedure Rcheck_22 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Explicit_Raise;\n-   procedure Rcheck_23 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Finalize_Raised_Exception;\n-   procedure Rcheck_24 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Implicit_Return;\n-   procedure Rcheck_25 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Misaligned_Address_Value;\n-   procedure Rcheck_26 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Missing_Return;\n-   procedure Rcheck_27 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Overlaid_Controlled_Object;\n-   procedure Rcheck_28 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Potentially_Blocking_Operation;\n-   procedure Rcheck_29 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Stubbed_Subprogram_Called;\n-   procedure Rcheck_30 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Unchecked_Union_Restriction;\n-   procedure Rcheck_31 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Non_Transportable_Actual;\n-   procedure Rcheck_32 (File : System.Address; Line : Integer)\n-     renames Rcheck_SE_Empty_Storage_Pool;\n-   procedure Rcheck_33 (File : System.Address; Line : Integer)\n-     renames Rcheck_SE_Explicit_Raise;\n-   procedure Rcheck_34 (File : System.Address; Line : Integer)\n-     renames Rcheck_SE_Infinite_Recursion;\n-   procedure Rcheck_35 (File : System.Address; Line : Integer)\n-     renames Rcheck_SE_Object_Too_Large;\n-   procedure Rcheck_36 (File : System.Address; Line : Integer)\n-     renames Rcheck_PE_Stream_Operation_Not_Allowed;\n-\n    -------------\n    -- Reraise --\n    -------------\n \n    procedure Reraise is\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      Excep    : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+      Saved_MO : constant System.Address := Excep.Machine_Occurrence;\n \n    begin\n-      Abort_Defer.all;\n-      Raise_Current_Excep (Excep.Id);\n+      if not ZCX_By_Default then\n+         Abort_Defer.all;\n+      end if;\n+\n+      Save_Occurrence (Excep.all, Get_Current_Excep.all.all);\n+      Excep.Machine_Occurrence := Saved_MO;\n+      Complete_And_Propagate_Occurrence (Excep);\n    end Reraise;\n \n    --------------------------------------\n@@ -1522,10 +1528,18 @@ package body Ada.Exceptions is\n \n    procedure Reraise_Library_Exception_If_Any is\n       LE : Exception_Occurrence;\n+\n    begin\n       if Library_Exception_Set then\n          LE := Library_Exception;\n-         Raise_From_Controlled_Operation (LE);\n+\n+         if LE.Id = Null_Id then\n+            Raise_Exception_No_Defer\n+              (E       => Program_Error'Identity,\n+               Message => \"finalize/adjust raised exception\");\n+         else\n+            Raise_From_Controlled_Operation (LE);\n+         end if;\n       end if;\n    end Reraise_Library_Exception_If_Any;\n \n@@ -1535,10 +1549,10 @@ package body Ada.Exceptions is\n \n    procedure Reraise_Occurrence (X : Exception_Occurrence) is\n    begin\n-      if X.Id /= null then\n-         Abort_Defer.all;\n-         Save_Occurrence (Get_Current_Excep.all.all, X);\n-         Raise_Current_Excep (X.Id);\n+      if X.Id = null then\n+         return;\n+      else\n+         Reraise_Occurrence_Always (X);\n       end if;\n    end Reraise_Occurrence;\n \n@@ -1548,19 +1562,24 @@ package body Ada.Exceptions is\n \n    procedure Reraise_Occurrence_Always (X : Exception_Occurrence) is\n    begin\n-      Abort_Defer.all;\n-      Save_Occurrence (Get_Current_Excep.all.all, X);\n-      Raise_Current_Excep (X.Id);\n+      if not ZCX_By_Default then\n+         Abort_Defer.all;\n+      end if;\n+\n+      Reraise_Occurrence_No_Defer (X);\n    end Reraise_Occurrence_Always;\n \n    ---------------------------------\n    -- Reraise_Occurrence_No_Defer --\n    ---------------------------------\n \n    procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence) is\n+      Excep    : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+      Saved_MO : constant System.Address := Excep.Machine_Occurrence;\n    begin\n-      Save_Occurrence (Get_Current_Excep.all.all, X);\n-      Raise_Current_Excep (X.Id);\n+      Save_Occurrence (Excep.all, X);\n+      Excep.Machine_Occurrence := Saved_MO;\n+      Complete_And_Propagate_Occurrence (Excep);\n    end Reraise_Occurrence_No_Defer;\n \n    ---------------------\n@@ -1572,10 +1591,14 @@ package body Ada.Exceptions is\n       Source : Exception_Occurrence)\n    is\n    begin\n-      Target.Id             := Source.Id;\n-      Target.Msg_Length     := Source.Msg_Length;\n-      Target.Num_Tracebacks := Source.Num_Tracebacks;\n-      Target.Pid            := Source.Pid;\n+      --  As the machine occurrence might be a data that must be finalized\n+      --  (outside any Ada mechanism), do not copy it\n+\n+      Target.Id                 := Source.Id;\n+      Target.Machine_Occurrence := System.Null_Address;\n+      Target.Msg_Length         := Source.Msg_Length;\n+      Target.Num_Tracebacks     := Source.Num_Tracebacks;\n+      Target.Pid                := Source.Pid;\n \n       Target.Msg (1 .. Target.Msg_Length) :=\n         Source.Msg (1 .. Target.Msg_Length);\n@@ -1610,13 +1633,10 @@ package body Ada.Exceptions is\n    ---------------\n \n    procedure To_Stderr (C : Character) is\n-      type int is new Integer;\n-\n-      procedure put_char_stderr (C : int);\n-      pragma Import (C, put_char_stderr, \"put_char_stderr\");\n-\n+      procedure Put_Char_Stderr (C : Character);\n+      pragma Import (C, Put_Char_Stderr, \"put_char_stderr\");\n    begin\n-      put_char_stderr (Character'Pos (C));\n+      Put_Char_Stderr (C);\n    end To_Stderr;\n \n    procedure To_Stderr (S : String) is\n@@ -1651,4 +1671,78 @@ package body Ada.Exceptions is\n         and then Exception_Identity (Ex.all) = Standard'Abort_Signal'Identity;\n    end Triggered_By_Abort;\n \n+   -------------------------\n+   -- Wide_Exception_Name --\n+   -------------------------\n+\n+   WC_Encoding : Character;\n+   pragma Import (C, WC_Encoding, \"__gl_wc_encoding\");\n+   --  Encoding method for source, as exported by binder\n+\n+   function Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_String\n+   is\n+      S : constant String := Exception_Name (Id);\n+      W : Wide_String (1 .. S'Length);\n+      L : Natural;\n+   begin\n+      String_To_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n+   end Wide_Exception_Name;\n+\n+   function Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_String\n+   is\n+      S : constant String := Exception_Name (X);\n+      W : Wide_String (1 .. S'Length);\n+      L : Natural;\n+   begin\n+      String_To_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n+   end Wide_Exception_Name;\n+\n+   ----------------------------\n+   -- Wide_Wide_Exception_Name --\n+   -----------------------------\n+\n+   function Wide_Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_Wide_String\n+   is\n+      S : constant String := Exception_Name (Id);\n+      W : Wide_Wide_String (1 .. S'Length);\n+      L : Natural;\n+   begin\n+      String_To_Wide_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n+   end Wide_Wide_Exception_Name;\n+\n+   function Wide_Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_Wide_String\n+   is\n+      S : constant String := Exception_Name (X);\n+      W : Wide_Wide_String (1 .. S'Length);\n+      L : Natural;\n+   begin\n+      String_To_Wide_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n+   end Wide_Wide_Exception_Name;\n+\n+   --------------------------\n+   -- Code_Address_For_ZZZ --\n+   --------------------------\n+\n+   --  This function gives us the end of the PC range for addresses\n+   --  within the exception unit itself. We hope that gigi/gcc keeps all the\n+   --  procedures in their original order.\n+\n+   function Code_Address_For_ZZZ return System.Address is\n+   begin\n+      <<Start_Of_ZZZ>>\n+      return Start_Of_ZZZ'Address;\n+   end Code_Address_For_ZZZ;\n+\n end Ada.Exceptions;"}, {"sha": "ff99e351ab695e26867f4480f995e3d0716f0e81", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 67, "deletions": 30, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -33,24 +33,15 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This version of Ada.Exceptions is used only for building the compiler\n---  and certain basic tools. The \"real\" version of Ada.Exceptions is in\n---  a-except-2005.ads/adb, and is used for all other builds where full Ada\n---  functionality is required. In particular, it is used for building run\n---  times on all targets.\n-\n---  This version is limited to Ada 95 features. It omits Ada 2005 features\n---  such as the additional definitions of Exception_Name returning\n---  Wide_[Wide_]String. It differs from the version specified in the Ada 95 RM\n---  only in that it is declared Preelaborate (see declaration below for why\n---  this is done).\n+--  This version of Ada.Exceptions fully supports Ada 95 and later language\n+--  versions.  It is used in all situations except for the build of the\n+--  compiler and other basic tools. For these latter builds, we use an\n+--  Ada 95-only version.\n \n --  The reason for this splitting off of a separate version is to support\n --  older bootstrap compilers that do not support Ada 2005 features, and\n --  Ada.Exceptions is part of the compiler sources.\n \n-pragma Compiler_Unit_Warning;\n-\n pragma Polling (Off);\n --  We must turn polling off for this unit, because otherwise we get\n --  elaboration circularities with ourself.\n@@ -62,25 +53,39 @@ with System.Traceback_Entries;\n \n package Ada.Exceptions is\n    pragma Preelaborate;\n-   --  We make this preelaborable. If we did not do this, then run time units\n-   --  used by the compiler (e.g. s-soflin.ads) would run into trouble.\n-   --  Conformance with Ada 95 is not an issue, since this version is used\n-   --  only by the compiler.\n+   --  In accordance with Ada 2005 AI-362.\n \n    type Exception_Id is private;\n+   pragma Preelaborable_Initialization (Exception_Id);\n \n    Null_Id : constant Exception_Id;\n \n    type Exception_Occurrence is limited private;\n+   pragma Preelaborable_Initialization (Exception_Occurrence);\n \n    type Exception_Occurrence_Access is access all Exception_Occurrence;\n \n    Null_Occurrence : constant Exception_Occurrence;\n \n+   function Exception_Name (Id : Exception_Id) return String;\n+\n    function Exception_Name (X : Exception_Occurrence) return String;\n-   --  Same as Exception_Name (Exception_Identity (X))\n \n-   function Exception_Name (Id : Exception_Id) return String;\n+   function Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_String;\n+   pragma Ada_05 (Wide_Exception_Name);\n+\n+   function Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_String;\n+   pragma Ada_05 (Wide_Exception_Name);\n+\n+   function Wide_Wide_Exception_Name\n+     (Id : Exception_Id) return Wide_Wide_String;\n+   pragma Ada_05 (Wide_Wide_Exception_Name);\n+\n+   function Wide_Wide_Exception_Name\n+     (X : Exception_Occurrence) return Wide_Wide_String;\n+   pragma Ada_05 (Wide_Wide_Exception_Name);\n \n    procedure Raise_Exception (E : Exception_Id; Message : String := \"\");\n    pragma No_Return (Raise_Exception);\n@@ -105,7 +110,9 @@ package Ada.Exceptions is\n    --    0xyyyyyyyy 0xyyyyyyyy ...\n    --\n    --  The lines are separated by a ASCII.LF character\n-   --  The nnnn is the partition Id given as decimal digits.\n+   --\n+   --  The nnnn is the partition Id given as decimal digits\n+   --\n    --  The 0x... line represents traceback program counter locations,\n    --  in order with the first one being the exception location.\n \n@@ -121,6 +128,22 @@ package Ada.Exceptions is\n      (Source : Exception_Occurrence)\n       return   Exception_Occurrence_Access;\n \n+   --  Ada 2005 (AI-438): The language revision introduces the following\n+   --  subprograms and attribute definitions. We do not provide them\n+   --  explicitly. instead, the corresponding stream attributes are made\n+   --  available through a pragma Stream_Convert in the private part.\n+\n+   --  procedure Read_Exception_Occurrence\n+   --    (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+   --     Item   : out Exception_Occurrence);\n+\n+   --  procedure Write_Exception_Occurrence\n+   --    (Stream : not null access Ada.Streams.Root_Stream_Type'Class;\n+   --     Item   : Exception_Occurrence);\n+\n+   --  for Exception_Occurrence'Read use Read_Exception_Occurrence;\n+   --  for Exception_Occurrence'Write use Write_Exception_Occurrence;\n+\n private\n    package SSL renames System.Standard_Library;\n    package SP renames System.Parameters;\n@@ -216,8 +239,8 @@ private\n    pragma No_Return (Reraise_Occurrence_No_Defer);\n    --  Exactly like Reraise_Occurrence, except that abort is not deferred\n    --  before the call and the parameter X is known not to be the null\n-   --  occurrence. This is used in generated code when it is known that\n-   --  abort is already deferred.\n+   --  occurrence. This is used in generated code when it is known that abort\n+   --  is already deferred.\n \n    function Triggered_By_Abort return Boolean;\n    --  Determine whether the current exception (if it exists) is an instance of\n@@ -264,6 +287,10 @@ private\n       Id : Exception_Id;\n       --  Exception_Identity for this exception occurrence\n \n+      Machine_Occurrence : System.Address;\n+      --  The underlying machine occurrence. For GCC, this corresponds to the\n+      --  _Unwind_Exception structure address.\n+\n       Msg_Length : Natural := 0;\n       --  Length of message (zero = no message)\n \n@@ -295,18 +322,28 @@ private\n    --  this, and it would not work right, because of the Msg and Tracebacks\n    --  fields which have unused entries not copied by Save_Occurrence.\n \n+   function Get_Exception_Machine_Occurrence\n+     (X : Exception_Occurrence) return System.Address;\n+   pragma Export (Ada, Get_Exception_Machine_Occurrence,\n+                  \"__gnat_get_exception_machine_occurrence\");\n+   --  Get the machine occurrence corresponding to an exception occurrence.\n+   --  It is Null_Address if there is no machine occurrence (in runtimes that\n+   --  doesn't use GCC mechanism) or if it has been lost (Save_Occurrence\n+   --  doesn't save the machine occurrence).\n+\n    function EO_To_String (X : Exception_Occurrence) return String;\n    function String_To_EO (S : String) return Exception_Occurrence;\n    pragma Stream_Convert (Exception_Occurrence, String_To_EO, EO_To_String);\n    --  Functions for implementing Exception_Occurrence stream attributes\n \n    Null_Occurrence : constant Exception_Occurrence := (\n-     Id               => null,\n-     Msg_Length       => 0,\n-     Msg              => (others => ' '),\n-     Exception_Raised => False,\n-     Pid              => 0,\n-     Num_Tracebacks   => 0,\n-     Tracebacks       => (others => TBE.Null_TB_Entry));\n+     Id                 => null,\n+     Machine_Occurrence => System.Null_Address,\n+     Msg_Length         => 0,\n+     Msg                => (others => ' '),\n+     Exception_Raised   => False,\n+     Pid                => 0,\n+     Num_Tracebacks     => 0,\n+     Tracebacks         => (others => TBE.Null_TB_Entry));\n \n end Ada.Exceptions;"}, {"sha": "91fb5f5cd67043dfdcde8f63cd71151cbe154d33", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de3b531c9aa93592f98ebd99c6b35be632e3c1b3/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de3b531c9aa93592f98ebd99c6b35be632e3c1b3/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=de3b531c9aa93592f98ebd99c6b35be632e3c1b3", "patch": "@@ -1,439 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---  A D A . E X C E P T I O N S . E X C E P T I O N _ P R O P A G A T I O N --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the version using the GCC EH mechanism\n-\n-with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n-\n-with System.Storage_Elements;   use System.Storage_Elements;\n-with System.Exceptions.Machine; use System.Exceptions.Machine;\n-\n-separate (Ada.Exceptions)\n-package body Exception_Propagation is\n-\n-   use Exception_Traces;\n-\n-   Foreign_Exception : aliased System.Standard_Library.Exception_Data;\n-   pragma Import (Ada, Foreign_Exception,\n-                  \"system__exceptions__foreign_exception\");\n-   --  Id for foreign exceptions\n-\n-   --------------------------------------------------------------\n-   -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n-   --------------------------------------------------------------\n-\n-   procedure GNAT_GCC_Exception_Cleanup\n-     (Reason : Unwind_Reason_Code;\n-      Excep  : not null GNAT_GCC_Exception_Access);\n-   pragma Convention (C, GNAT_GCC_Exception_Cleanup);\n-   --  Procedure called when a GNAT GCC exception is free.\n-\n-   procedure Propagate_GCC_Exception\n-     (GCC_Exception : not null GCC_Exception_Access);\n-   pragma No_Return (Propagate_GCC_Exception);\n-   --  Propagate a GCC exception\n-\n-   procedure Reraise_GCC_Exception\n-     (GCC_Exception : not null GCC_Exception_Access);\n-   pragma No_Return (Reraise_GCC_Exception);\n-   pragma Export (C, Reraise_GCC_Exception, \"__gnat_reraise_zcx\");\n-   --  Called to implement raise without exception, ie reraise. Called\n-   --  directly from gigi.\n-\n-   function Setup_Current_Excep\n-     (GCC_Exception : not null GCC_Exception_Access) return EOA;\n-   pragma Export (C, Setup_Current_Excep, \"__gnat_setup_current_excep\");\n-   --  Write Get_Current_Excep.all from GCC_Exception. Called by the\n-   --  personality routine.\n-\n-   procedure Unhandled_Except_Handler\n-     (GCC_Exception : not null GCC_Exception_Access);\n-   pragma No_Return (Unhandled_Except_Handler);\n-   pragma Export (C, Unhandled_Except_Handler,\n-                  \"__gnat_unhandled_except_handler\");\n-   --  Called for handle unhandled exceptions, ie the last chance handler\n-   --  on platforms (such as SEH) that never returns after throwing an\n-   --  exception. Called directly by gigi.\n-\n-   function CleanupUnwind_Handler\n-     (UW_Version   : Integer;\n-      UW_Phases    : Unwind_Action;\n-      UW_Eclass    : Exception_Class;\n-      UW_Exception : not null GCC_Exception_Access;\n-      UW_Context   : System.Address;\n-      UW_Argument  : System.Address) return Unwind_Reason_Code;\n-   pragma Import (C, CleanupUnwind_Handler,\n-                  \"__gnat_cleanupunwind_handler\");\n-   --  Hook called at each step of the forced unwinding we perform to trigger\n-   --  cleanups found during the propagation of an unhandled exception.\n-\n-   --  GCC runtime functions used. These are C non-void functions, actually,\n-   --  but we ignore the return values. See raise.c as to why we are using\n-   --  __gnat stubs for these.\n-\n-   procedure Unwind_RaiseException\n-     (UW_Exception : not null GCC_Exception_Access);\n-   pragma Import (C, Unwind_RaiseException, \"__gnat_Unwind_RaiseException\");\n-\n-   procedure Unwind_ForcedUnwind\n-     (UW_Exception : not null GCC_Exception_Access;\n-      UW_Handler   : System.Address;\n-      UW_Argument  : System.Address);\n-   pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n-\n-   procedure Set_Exception_Parameter\n-     (Excep         : EOA;\n-      GCC_Exception : not null GCC_Exception_Access);\n-   pragma Export\n-     (C, Set_Exception_Parameter, \"__gnat_set_exception_parameter\");\n-   --  Called inserted by gigi to set the exception choice parameter from the\n-   --  gcc occurrence.\n-\n-   procedure Set_Foreign_Occurrence (Excep : EOA; Mo : System.Address);\n-   --  Utility routine to initialize occurrence Excep from a foreign exception\n-   --  whose machine occurrence is Mo. The message is empty, the backtrace\n-   --  is empty too and the exception identity is Foreign_Exception.\n-\n-   --  Hooks called when entering/leaving an exception handler for a given\n-   --  occurrence, aimed at handling the stack of active occurrences. The\n-   --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n-\n-   procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access);\n-   pragma Export (C, Begin_Handler, \"__gnat_begin_handler\");\n-\n-   procedure End_Handler (GCC_Exception : GCC_Exception_Access);\n-   pragma Export (C, End_Handler, \"__gnat_end_handler\");\n-\n-   --------------------------------------------------------------------\n-   -- Accessors to Basic Components of a GNAT Exception Data Pointer --\n-   --------------------------------------------------------------------\n-\n-   --  As of today, these are only used by the C implementation of the GCC\n-   --  propagation personality routine to avoid having to rely on a C\n-   --  counterpart of the whole exception_data structure, which is both\n-   --  painful and error prone. These subprograms could be moved to a more\n-   --  widely visible location if need be.\n-\n-   function Is_Handled_By_Others (E : Exception_Data_Ptr) return Boolean;\n-   pragma Export (C, Is_Handled_By_Others, \"__gnat_is_handled_by_others\");\n-   pragma Warnings (Off, Is_Handled_By_Others);\n-\n-   function Language_For (E : Exception_Data_Ptr) return Character;\n-   pragma Export (C, Language_For, \"__gnat_language_for\");\n-\n-   function Foreign_Data_For (E : Exception_Data_Ptr) return Address;\n-   pragma Export (C, Foreign_Data_For, \"__gnat_foreign_data_for\");\n-\n-   function EID_For (GNAT_Exception : not null GNAT_GCC_Exception_Access)\n-     return Exception_Id;\n-   pragma Export (C, EID_For, \"__gnat_eid_for\");\n-\n-   ---------------------------------------------------------------------------\n-   -- Objects to materialize \"others\" and \"all others\" in the GCC EH tables --\n-   ---------------------------------------------------------------------------\n-\n-   --  Currently, these only have their address taken and compared so there is\n-   --  no real point having whole exception data blocks allocated. Note that\n-   --  there are corresponding declarations in gigi (trans.c) which must be\n-   --  kept properly synchronized.\n-\n-   Others_Value : constant Character := 'O';\n-   pragma Export (C, Others_Value, \"__gnat_others_value\");\n-\n-   All_Others_Value : constant Character := 'A';\n-   pragma Export (C, All_Others_Value, \"__gnat_all_others_value\");\n-\n-   Unhandled_Others_Value : constant Character := 'U';\n-   pragma Export (C, Unhandled_Others_Value, \"__gnat_unhandled_others_value\");\n-   --  Special choice (emitted by gigi) to catch and notify unhandled\n-   --  exceptions on targets which always handle exceptions (such as SEH).\n-   --  The handler will simply call Unhandled_Except_Handler.\n-\n-   -------------------------\n-   -- Allocate_Occurrence --\n-   -------------------------\n-\n-   function Allocate_Occurrence return EOA is\n-      Res : GNAT_GCC_Exception_Access;\n-\n-   begin\n-      Res := New_Occurrence;\n-      Res.Header.Cleanup := GNAT_GCC_Exception_Cleanup'Address;\n-      Res.Occurrence.Machine_Occurrence := Res.all'Address;\n-\n-      return Res.Occurrence'Access;\n-   end Allocate_Occurrence;\n-\n-   --------------------------------\n-   -- GNAT_GCC_Exception_Cleanup --\n-   --------------------------------\n-\n-   procedure GNAT_GCC_Exception_Cleanup\n-     (Reason : Unwind_Reason_Code;\n-      Excep  : not null GNAT_GCC_Exception_Access)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      procedure Free is new Unchecked_Deallocation\n-        (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n-\n-      Copy : GNAT_GCC_Exception_Access := Excep;\n-\n-   begin\n-      --  Simply free the memory\n-\n-      Free (Copy);\n-   end GNAT_GCC_Exception_Cleanup;\n-\n-   ----------------------------\n-   -- Set_Foreign_Occurrence --\n-   ----------------------------\n-\n-   procedure Set_Foreign_Occurrence (Excep : EOA; Mo : System.Address) is\n-   begin\n-      Excep.all := (\n-        Id                 => Foreign_Exception'Access,\n-        Machine_Occurrence => Mo,\n-        Msg                => <>,\n-        Msg_Length         => 0,\n-        Exception_Raised   => True,\n-        Pid                => Local_Partition_ID,\n-        Num_Tracebacks     => 0,\n-        Tracebacks         => <>);\n-   end Set_Foreign_Occurrence;\n-\n-   -------------------------\n-   -- Setup_Current_Excep --\n-   -------------------------\n-\n-   function Setup_Current_Excep\n-     (GCC_Exception : not null GCC_Exception_Access) return EOA\n-   is\n-      Excep : constant EOA := Get_Current_Excep.all;\n-\n-   begin\n-      --  Setup the exception occurrence\n-\n-      if GCC_Exception.Class = GNAT_Exception_Class then\n-\n-         --  From the GCC exception\n-\n-         declare\n-            GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n-                                To_GNAT_GCC_Exception (GCC_Exception);\n-         begin\n-            Excep.all := GNAT_Occurrence.Occurrence;\n-            return GNAT_Occurrence.Occurrence'Access;\n-         end;\n-\n-      else\n-         --  A default one\n-\n-         Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n-\n-         return Excep;\n-      end if;\n-   end Setup_Current_Excep;\n-\n-   -------------------\n-   -- Begin_Handler --\n-   -------------------\n-\n-   procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access) is\n-      pragma Unreferenced (GCC_Exception);\n-   begin\n-      null;\n-   end Begin_Handler;\n-\n-   -----------------\n-   -- End_Handler --\n-   -----------------\n-\n-   procedure End_Handler (GCC_Exception : GCC_Exception_Access) is\n-   begin\n-      if GCC_Exception /= null then\n-\n-         --  The exception might have been reraised, in this case the cleanup\n-         --  mustn't be called.\n-\n-         Unwind_DeleteException (GCC_Exception);\n-      end if;\n-   end End_Handler;\n-\n-   -----------------------------\n-   -- Reraise_GCC_Exception --\n-   -----------------------------\n-\n-   procedure Reraise_GCC_Exception\n-     (GCC_Exception : not null GCC_Exception_Access)\n-   is\n-   begin\n-      --  Simply propagate it\n-\n-      Propagate_GCC_Exception (GCC_Exception);\n-   end Reraise_GCC_Exception;\n-\n-   -----------------------------\n-   -- Propagate_GCC_Exception --\n-   -----------------------------\n-\n-   --  Call Unwind_RaiseException to actually throw, taking care of handling\n-   --  the two phase scheme it implements.\n-\n-   procedure Propagate_GCC_Exception\n-     (GCC_Exception : not null GCC_Exception_Access)\n-   is\n-      Excep : EOA;\n-\n-   begin\n-      --  Perform a standard raise first. If a regular handler is found, it\n-      --  will be entered after all the intermediate cleanups have run. If\n-      --  there is no regular handler, it will return.\n-\n-      Unwind_RaiseException (GCC_Exception);\n-\n-      --  If we get here we know the exception is not handled, as otherwise\n-      --  Unwind_RaiseException arranges for the handler to be entered. Take\n-      --  the necessary steps to enable the debugger to gain control while the\n-      --  stack is still intact.\n-\n-      Excep := Setup_Current_Excep (GCC_Exception);\n-      Notify_Unhandled_Exception (Excep);\n-\n-      --  Now, un a forced unwind to trigger cleanups. Control should not\n-      --  resume there, if there are cleanups and in any cases as the\n-      --  unwinding hook calls Unhandled_Exception_Terminate when end of\n-      --  stack is reached.\n-\n-      Unwind_ForcedUnwind\n-        (GCC_Exception,\n-         CleanupUnwind_Handler'Address,\n-         System.Null_Address);\n-\n-      --  We get here in case of error. The debugger has been notified before\n-      --  the second step above.\n-\n-      Unhandled_Except_Handler (GCC_Exception);\n-   end Propagate_GCC_Exception;\n-\n-   -------------------------\n-   -- Propagate_Exception --\n-   -------------------------\n-\n-   procedure Propagate_Exception (Excep : EOA) is\n-   begin\n-      Propagate_GCC_Exception (To_GCC_Exception (Excep.Machine_Occurrence));\n-   end Propagate_Exception;\n-\n-   -----------------------------\n-   -- Set_Exception_Parameter --\n-   -----------------------------\n-\n-   procedure Set_Exception_Parameter\n-     (Excep         : EOA;\n-      GCC_Exception : not null GCC_Exception_Access)\n-   is\n-   begin\n-      --  Setup the exception occurrence\n-\n-      if GCC_Exception.Class = GNAT_Exception_Class then\n-\n-         --  From the GCC exception\n-\n-         declare\n-            GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n-                                To_GNAT_GCC_Exception (GCC_Exception);\n-         begin\n-            Save_Occurrence (Excep.all, GNAT_Occurrence.Occurrence);\n-         end;\n-\n-      else\n-         --  A default one\n-\n-         Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n-      end if;\n-   end Set_Exception_Parameter;\n-\n-   ------------------------------\n-   -- Unhandled_Except_Handler --\n-   ------------------------------\n-\n-   procedure Unhandled_Except_Handler\n-     (GCC_Exception : not null GCC_Exception_Access)\n-   is\n-      Excep : EOA;\n-   begin\n-      Excep := Setup_Current_Excep (GCC_Exception);\n-      Unhandled_Exception_Terminate (Excep);\n-   end Unhandled_Except_Handler;\n-\n-   -------------\n-   -- EID_For --\n-   -------------\n-\n-   function EID_For\n-     (GNAT_Exception : not null GNAT_GCC_Exception_Access) return Exception_Id\n-   is\n-   begin\n-      return GNAT_Exception.Occurrence.Id;\n-   end EID_For;\n-\n-   ----------------------\n-   -- Foreign_Data_For --\n-   ----------------------\n-\n-   function Foreign_Data_For\n-     (E : SSL.Exception_Data_Ptr) return Address\n-   is\n-   begin\n-      return E.Foreign_Data;\n-   end Foreign_Data_For;\n-\n-   --------------------------\n-   -- Is_Handled_By_Others --\n-   --------------------------\n-\n-   function Is_Handled_By_Others (E : SSL.Exception_Data_Ptr) return Boolean is\n-   begin\n-      return not E.all.Not_Handled_By_Others;\n-   end Is_Handled_By_Others;\n-\n-   ------------------\n-   -- Language_For --\n-   ------------------\n-\n-   function Language_For (E : SSL.Exception_Data_Ptr) return Character is\n-   begin\n-      return E.all.Lang;\n-   end Language_For;\n-\n-end Exception_Propagation;"}, {"sha": "91fb5f5cd67043dfdcde8f63cd71151cbe154d33", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 375, "deletions": 35, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,71 +29,411 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This is the default version, using the __builtin_setjmp/longjmp EH\n---  mechanism.\n+--  This is the version using the GCC EH mechanism\n \n with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n+with System.Storage_Elements;   use System.Storage_Elements;\n+with System.Exceptions.Machine; use System.Exceptions.Machine;\n \n separate (Ada.Exceptions)\n package body Exception_Propagation is\n \n-   --  Common binding to __builtin_longjmp for sjlj variants.\n+   use Exception_Traces;\n+\n+   Foreign_Exception : aliased System.Standard_Library.Exception_Data;\n+   pragma Import (Ada, Foreign_Exception,\n+                  \"system__exceptions__foreign_exception\");\n+   --  Id for foreign exceptions\n+\n+   --------------------------------------------------------------\n+   -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n+   --------------------------------------------------------------\n+\n+   procedure GNAT_GCC_Exception_Cleanup\n+     (Reason : Unwind_Reason_Code;\n+      Excep  : not null GNAT_GCC_Exception_Access);\n+   pragma Convention (C, GNAT_GCC_Exception_Cleanup);\n+   --  Procedure called when a GNAT GCC exception is free.\n+\n+   procedure Propagate_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access);\n+   pragma No_Return (Propagate_GCC_Exception);\n+   --  Propagate a GCC exception\n+\n+   procedure Reraise_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access);\n+   pragma No_Return (Reraise_GCC_Exception);\n+   pragma Export (C, Reraise_GCC_Exception, \"__gnat_reraise_zcx\");\n+   --  Called to implement raise without exception, ie reraise. Called\n+   --  directly from gigi.\n+\n+   function Setup_Current_Excep\n+     (GCC_Exception : not null GCC_Exception_Access) return EOA;\n+   pragma Export (C, Setup_Current_Excep, \"__gnat_setup_current_excep\");\n+   --  Write Get_Current_Excep.all from GCC_Exception. Called by the\n+   --  personality routine.\n+\n+   procedure Unhandled_Except_Handler\n+     (GCC_Exception : not null GCC_Exception_Access);\n+   pragma No_Return (Unhandled_Except_Handler);\n+   pragma Export (C, Unhandled_Except_Handler,\n+                  \"__gnat_unhandled_except_handler\");\n+   --  Called for handle unhandled exceptions, ie the last chance handler\n+   --  on platforms (such as SEH) that never returns after throwing an\n+   --  exception. Called directly by gigi.\n+\n+   function CleanupUnwind_Handler\n+     (UW_Version   : Integer;\n+      UW_Phases    : Unwind_Action;\n+      UW_Eclass    : Exception_Class;\n+      UW_Exception : not null GCC_Exception_Access;\n+      UW_Context   : System.Address;\n+      UW_Argument  : System.Address) return Unwind_Reason_Code;\n+   pragma Import (C, CleanupUnwind_Handler,\n+                  \"__gnat_cleanupunwind_handler\");\n+   --  Hook called at each step of the forced unwinding we perform to trigger\n+   --  cleanups found during the propagation of an unhandled exception.\n+\n+   --  GCC runtime functions used. These are C non-void functions, actually,\n+   --  but we ignore the return values. See raise.c as to why we are using\n+   --  __gnat stubs for these.\n+\n+   procedure Unwind_RaiseException\n+     (UW_Exception : not null GCC_Exception_Access);\n+   pragma Import (C, Unwind_RaiseException, \"__gnat_Unwind_RaiseException\");\n+\n+   procedure Unwind_ForcedUnwind\n+     (UW_Exception : not null GCC_Exception_Access;\n+      UW_Handler   : System.Address;\n+      UW_Argument  : System.Address);\n+   pragma Import (C, Unwind_ForcedUnwind, \"__gnat_Unwind_ForcedUnwind\");\n+\n+   procedure Set_Exception_Parameter\n+     (Excep         : EOA;\n+      GCC_Exception : not null GCC_Exception_Access);\n+   pragma Export\n+     (C, Set_Exception_Parameter, \"__gnat_set_exception_parameter\");\n+   --  Called inserted by gigi to set the exception choice parameter from the\n+   --  gcc occurrence.\n+\n+   procedure Set_Foreign_Occurrence (Excep : EOA; Mo : System.Address);\n+   --  Utility routine to initialize occurrence Excep from a foreign exception\n+   --  whose machine occurrence is Mo. The message is empty, the backtrace\n+   --  is empty too and the exception identity is Foreign_Exception.\n+\n+   --  Hooks called when entering/leaving an exception handler for a given\n+   --  occurrence, aimed at handling the stack of active occurrences. The\n+   --  calls are generated by gigi in tree_transform/N_Exception_Handler.\n+\n+   procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access);\n+   pragma Export (C, Begin_Handler, \"__gnat_begin_handler\");\n+\n+   procedure End_Handler (GCC_Exception : GCC_Exception_Access);\n+   pragma Export (C, End_Handler, \"__gnat_end_handler\");\n+\n+   --------------------------------------------------------------------\n+   -- Accessors to Basic Components of a GNAT Exception Data Pointer --\n+   --------------------------------------------------------------------\n+\n+   --  As of today, these are only used by the C implementation of the GCC\n+   --  propagation personality routine to avoid having to rely on a C\n+   --  counterpart of the whole exception_data structure, which is both\n+   --  painful and error prone. These subprograms could be moved to a more\n+   --  widely visible location if need be.\n+\n+   function Is_Handled_By_Others (E : Exception_Data_Ptr) return Boolean;\n+   pragma Export (C, Is_Handled_By_Others, \"__gnat_is_handled_by_others\");\n+   pragma Warnings (Off, Is_Handled_By_Others);\n+\n+   function Language_For (E : Exception_Data_Ptr) return Character;\n+   pragma Export (C, Language_For, \"__gnat_language_for\");\n+\n+   function Foreign_Data_For (E : Exception_Data_Ptr) return Address;\n+   pragma Export (C, Foreign_Data_For, \"__gnat_foreign_data_for\");\n+\n+   function EID_For (GNAT_Exception : not null GNAT_GCC_Exception_Access)\n+     return Exception_Id;\n+   pragma Export (C, EID_For, \"__gnat_eid_for\");\n+\n+   ---------------------------------------------------------------------------\n+   -- Objects to materialize \"others\" and \"all others\" in the GCC EH tables --\n+   ---------------------------------------------------------------------------\n \n-   procedure builtin_longjmp (buffer : System.Address; Flag : Integer);\n-   pragma No_Return (builtin_longjmp);\n-   pragma Import (Intrinsic, builtin_longjmp, \"__builtin_longjmp\");\n+   --  Currently, these only have their address taken and compared so there is\n+   --  no real point having whole exception data blocks allocated. Note that\n+   --  there are corresponding declarations in gigi (trans.c) which must be\n+   --  kept properly synchronized.\n \n-   procedure Propagate_Continue (E : Exception_Id);\n-   pragma No_Return (Propagate_Continue);\n-   pragma Export (C, Propagate_Continue, \"__gnat_raise_nodefer_with_msg\");\n-   --  A call to this procedure is inserted automatically by GIGI, in order\n-   --  to continue the propagation when the exception was not handled.\n-   --  The linkage name is historical.\n+   Others_Value : constant Character := 'O';\n+   pragma Export (C, Others_Value, \"__gnat_others_value\");\n+\n+   All_Others_Value : constant Character := 'A';\n+   pragma Export (C, All_Others_Value, \"__gnat_all_others_value\");\n+\n+   Unhandled_Others_Value : constant Character := 'U';\n+   pragma Export (C, Unhandled_Others_Value, \"__gnat_unhandled_others_value\");\n+   --  Special choice (emitted by gigi) to catch and notify unhandled\n+   --  exceptions on targets which always handle exceptions (such as SEH).\n+   --  The handler will simply call Unhandled_Except_Handler.\n \n    -------------------------\n    -- Allocate_Occurrence --\n    -------------------------\n \n    function Allocate_Occurrence return EOA is\n+      Res : GNAT_GCC_Exception_Access;\n+\n    begin\n-      return Get_Current_Excep.all;\n+      Res := New_Occurrence;\n+      Res.Header.Cleanup := GNAT_GCC_Exception_Cleanup'Address;\n+      Res.Occurrence.Machine_Occurrence := Res.all'Address;\n+\n+      return Res.Occurrence'Access;\n    end Allocate_Occurrence;\n \n+   --------------------------------\n+   -- GNAT_GCC_Exception_Cleanup --\n+   --------------------------------\n+\n+   procedure GNAT_GCC_Exception_Cleanup\n+     (Reason : Unwind_Reason_Code;\n+      Excep  : not null GNAT_GCC_Exception_Access)\n+   is\n+      pragma Unreferenced (Reason);\n+\n+      procedure Free is new Unchecked_Deallocation\n+        (GNAT_GCC_Exception, GNAT_GCC_Exception_Access);\n+\n+      Copy : GNAT_GCC_Exception_Access := Excep;\n+\n+   begin\n+      --  Simply free the memory\n+\n+      Free (Copy);\n+   end GNAT_GCC_Exception_Cleanup;\n+\n+   ----------------------------\n+   -- Set_Foreign_Occurrence --\n+   ----------------------------\n+\n+   procedure Set_Foreign_Occurrence (Excep : EOA; Mo : System.Address) is\n+   begin\n+      Excep.all := (\n+        Id                 => Foreign_Exception'Access,\n+        Machine_Occurrence => Mo,\n+        Msg                => <>,\n+        Msg_Length         => 0,\n+        Exception_Raised   => True,\n+        Pid                => Local_Partition_ID,\n+        Num_Tracebacks     => 0,\n+        Tracebacks         => <>);\n+   end Set_Foreign_Occurrence;\n+\n+   -------------------------\n+   -- Setup_Current_Excep --\n+   -------------------------\n+\n+   function Setup_Current_Excep\n+     (GCC_Exception : not null GCC_Exception_Access) return EOA\n+   is\n+      Excep : constant EOA := Get_Current_Excep.all;\n+\n+   begin\n+      --  Setup the exception occurrence\n+\n+      if GCC_Exception.Class = GNAT_Exception_Class then\n+\n+         --  From the GCC exception\n+\n+         declare\n+            GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n+                                To_GNAT_GCC_Exception (GCC_Exception);\n+         begin\n+            Excep.all := GNAT_Occurrence.Occurrence;\n+            return GNAT_Occurrence.Occurrence'Access;\n+         end;\n+\n+      else\n+         --  A default one\n+\n+         Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n+\n+         return Excep;\n+      end if;\n+   end Setup_Current_Excep;\n+\n+   -------------------\n+   -- Begin_Handler --\n+   -------------------\n+\n+   procedure Begin_Handler (GCC_Exception : not null GCC_Exception_Access) is\n+      pragma Unreferenced (GCC_Exception);\n+   begin\n+      null;\n+   end Begin_Handler;\n+\n+   -----------------\n+   -- End_Handler --\n+   -----------------\n+\n+   procedure End_Handler (GCC_Exception : GCC_Exception_Access) is\n+   begin\n+      if GCC_Exception /= null then\n+\n+         --  The exception might have been reraised, in this case the cleanup\n+         --  mustn't be called.\n+\n+         Unwind_DeleteException (GCC_Exception);\n+      end if;\n+   end End_Handler;\n+\n+   -----------------------------\n+   -- Reraise_GCC_Exception --\n+   -----------------------------\n+\n+   procedure Reraise_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access)\n+   is\n+   begin\n+      --  Simply propagate it\n+\n+      Propagate_GCC_Exception (GCC_Exception);\n+   end Reraise_GCC_Exception;\n+\n+   -----------------------------\n+   -- Propagate_GCC_Exception --\n+   -----------------------------\n+\n+   --  Call Unwind_RaiseException to actually throw, taking care of handling\n+   --  the two phase scheme it implements.\n+\n+   procedure Propagate_GCC_Exception\n+     (GCC_Exception : not null GCC_Exception_Access)\n+   is\n+      Excep : EOA;\n+\n+   begin\n+      --  Perform a standard raise first. If a regular handler is found, it\n+      --  will be entered after all the intermediate cleanups have run. If\n+      --  there is no regular handler, it will return.\n+\n+      Unwind_RaiseException (GCC_Exception);\n+\n+      --  If we get here we know the exception is not handled, as otherwise\n+      --  Unwind_RaiseException arranges for the handler to be entered. Take\n+      --  the necessary steps to enable the debugger to gain control while the\n+      --  stack is still intact.\n+\n+      Excep := Setup_Current_Excep (GCC_Exception);\n+      Notify_Unhandled_Exception (Excep);\n+\n+      --  Now, un a forced unwind to trigger cleanups. Control should not\n+      --  resume there, if there are cleanups and in any cases as the\n+      --  unwinding hook calls Unhandled_Exception_Terminate when end of\n+      --  stack is reached.\n+\n+      Unwind_ForcedUnwind\n+        (GCC_Exception,\n+         CleanupUnwind_Handler'Address,\n+         System.Null_Address);\n+\n+      --  We get here in case of error. The debugger has been notified before\n+      --  the second step above.\n+\n+      Unhandled_Except_Handler (GCC_Exception);\n+   end Propagate_GCC_Exception;\n+\n    -------------------------\n    -- Propagate_Exception --\n    -------------------------\n \n    procedure Propagate_Exception (Excep : EOA) is\n-      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+   begin\n+      Propagate_GCC_Exception (To_GCC_Exception (Excep.Machine_Occurrence));\n+   end Propagate_Exception;\n+\n+   -----------------------------\n+   -- Set_Exception_Parameter --\n+   -----------------------------\n \n+   procedure Set_Exception_Parameter\n+     (Excep         : EOA;\n+      GCC_Exception : not null GCC_Exception_Access)\n+   is\n    begin\n-      --  If the jump buffer pointer is non-null, transfer control using\n-      --  it. Otherwise announce an unhandled exception (note that this\n-      --  means that we have no finalizations to do other than at the outer\n-      --  level). Perform the necessary notification tasks in both cases.\n+      --  Setup the exception occurrence\n+\n+      if GCC_Exception.Class = GNAT_Exception_Class then\n \n-      if Jumpbuf_Ptr /= Null_Address then\n-         if not Excep.Exception_Raised then\n-            Excep.Exception_Raised := True;\n-            Exception_Traces.Notify_Handled_Exception (Excep);\n-         end if;\n+         --  From the GCC exception\n \n-         builtin_longjmp (Jumpbuf_Ptr, 1);\n+         declare\n+            GNAT_Occurrence : constant GNAT_GCC_Exception_Access :=\n+                                To_GNAT_GCC_Exception (GCC_Exception);\n+         begin\n+            Save_Occurrence (Excep.all, GNAT_Occurrence.Occurrence);\n+         end;\n \n       else\n-         Exception_Traces.Notify_Unhandled_Exception (Excep);\n-         Exception_Traces.Unhandled_Exception_Terminate (Excep);\n+         --  A default one\n+\n+         Set_Foreign_Occurrence (Excep, GCC_Exception.all'Address);\n       end if;\n-   end Propagate_Exception;\n+   end Set_Exception_Parameter;\n+\n+   ------------------------------\n+   -- Unhandled_Except_Handler --\n+   ------------------------------\n+\n+   procedure Unhandled_Except_Handler\n+     (GCC_Exception : not null GCC_Exception_Access)\n+   is\n+      Excep : EOA;\n+   begin\n+      Excep := Setup_Current_Excep (GCC_Exception);\n+      Unhandled_Exception_Terminate (Excep);\n+   end Unhandled_Except_Handler;\n+\n+   -------------\n+   -- EID_For --\n+   -------------\n+\n+   function EID_For\n+     (GNAT_Exception : not null GNAT_GCC_Exception_Access) return Exception_Id\n+   is\n+   begin\n+      return GNAT_Exception.Occurrence.Id;\n+   end EID_For;\n+\n+   ----------------------\n+   -- Foreign_Data_For --\n+   ----------------------\n+\n+   function Foreign_Data_For\n+     (E : SSL.Exception_Data_Ptr) return Address\n+   is\n+   begin\n+      return E.Foreign_Data;\n+   end Foreign_Data_For;\n+\n+   --------------------------\n+   -- Is_Handled_By_Others --\n+   --------------------------\n+\n+   function Is_Handled_By_Others (E : SSL.Exception_Data_Ptr) return Boolean is\n+   begin\n+      return not E.all.Not_Handled_By_Others;\n+   end Is_Handled_By_Others;\n \n-   ------------------------\n-   -- Propagate_Continue --\n-   ------------------------\n+   ------------------\n+   -- Language_For --\n+   ------------------\n \n-   procedure Propagate_Continue (E : Exception_Id) is\n-      pragma Unreferenced (E);\n+   function Language_For (E : SSL.Exception_Data_Ptr) return Character is\n    begin\n-      Propagate_Exception (Get_Current_Excep.all);\n-   end Propagate_Continue;\n+      return E.all.Lang;\n+   end Language_For;\n \n end Exception_Propagation;"}, {"sha": "abc79f3df94270bf092dc3149fa7b85860089885", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -54,7 +54,7 @@ package body Exp_SPARK is\n    --  System.Storage_Elements.To_Address\n \n    procedure Expand_SPARK_N_Object_Declaration (N : Node_Id);\n-   --  Perform object declaration-specific expansion\n+   --  Perform object-declaration-specific expansion\n \n    procedure Expand_SPARK_N_Object_Renaming_Declaration (N : Node_Id);\n    --  Perform name evaluation for a renamed object\n@@ -86,7 +86,7 @@ package body Exp_SPARK is\n             Qualify_Entity_Names (N);\n \n          --  Replace occurrences of System'To_Address by calls to\n-         --  System.Storage_Elements.To_Address\n+         --  System.Storage_Elements.To_Address.\n \n          when N_Attribute_Reference =>\n             Expand_SPARK_N_Attribute_Reference (N);"}, {"sha": "10c865f457da081dea001023074c39aee5f4f675", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -99,6 +99,8 @@ ADA_TOOLS=gnatbind gnatchop gnat gnatkr gnatlink gnatls gnatmake \\\n ada-warn = $(ADA_CFLAGS) $(filter-out -pedantic, $(STRICT_WARN))\n # Unresolved warnings in specific files.\n ada/adaint.o-warn = -Wno-error\n+# For unwind-pe.h\n+CFLAGS-ada/raise-gcc.o += -I$(srcdir)/../libgcc -Iinclude\n \n ada/%.o: ada/gcc-interface/%.c\n \t$(COMPILE) $<\n@@ -223,6 +225,7 @@ GCC_LLINK=$(LLINKER) $(GCC_LINKERFLAGS) $(LDFLAGS)\n # Object files for gnat1 from C sources.\n GNAT1_C_OBJS = ada/adadecode.o ada/adaint.o ada/argv.o ada/cio.o \\\n  ada/cstreams.o ada/env.o ada/init.o ada/initialize.o ada/raise.o \\\n+ ada/raise-gcc.o \\\n  ada/seh_init.o ada/targext.o ada/cuintp.o ada/decl.o ada/rtfinal.o \\\n  ada/rtinit.o ada/misc.o ada/utils.o ada/utils2.o ada/trans.o ada/targtyps.o\n \n@@ -232,6 +235,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/a-chlat1.o\t\\\n  ada/a-elchha.o\t\\\n  ada/a-except.o\t\\\n+ ada/a-exctra.o \\\n  ada/a-ioexce.o\t\\\n  ada/ada.o\t\\\n  ada/spark_xrefs.o\t\\\n@@ -334,6 +338,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/rident.o\t\\\n  ada/rtsfind.o\t\\\n  ada/s-addope.o\t\\\n+ ada/s-addima.o \\\n  ada/s-assert.o\t\\\n  ada/s-bitops.o\t\\\n  ada/s-carun8.o\t\\\n@@ -351,9 +356,11 @@ GNAT_ADA_OBJS =\t\\\n  ada/s-excdeb.o\t\\\n  ada/s-except.o\t\\\n  ada/s-exctab.o\t\\\n+ ada/s-excmac.o \\\n  ada/s-htable.o\t\\\n  ada/s-imenne.o\t\\\n  ada/s-imgenu.o\t\\\n+ ada/s-imgint.o \\\n  ada/s-mastop.o\t\\\n  ada/s-memory.o\t\\\n  ada/s-os_lib.o\t\\\n@@ -372,7 +379,9 @@ GNAT_ADA_OBJS =\t\\\n  ada/s-strhas.o\t\\\n  ada/s-string.o\t\\\n  ada/s-strops.o\t\\\n+ ada/s-traceb.o \\\n  ada/s-traent.o\t\\\n+ ada/s-trasym.o \\\n  ada/s-unstyp.o\t\\\n  ada/s-utf_32.o\t\\\n  ada/s-valint.o\t\\\n@@ -381,6 +390,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/s-wchcnv.o\t\\\n  ada/s-wchcon.o\t\\\n  ada/s-wchjis.o\t\\\n+ ada/s-wchstw.o \\\n  ada/scans.o\t\\\n  ada/scil_ll.o\t\\\n  ada/scn.o\t\\\n@@ -514,6 +524,7 @@ GNATBIND_OBJS = \\\n  ada/osint.o      \\\n  ada/output.o     \\\n  ada/raise.o      \\\n+ ada/raise-gcc.o  \\\n  ada/restrict.o   \\\n  ada/rident.o     \\\n  ada/rtfinal.o    \\\n@@ -534,10 +545,12 @@ GNATBIND_OBJS = \\\n  ada/s-crtl.o     \\\n  ada/s-excdeb.o   \\\n  ada/s-except.o   \\\n+ ada/s-excmac.o   \\\n  ada/s-exctab.o   \\\n  ada/s-htable.o   \\\n  ada/s-imenne.o   \\\n  ada/s-imgenu.o   \\\n+ ada/s-imgint.o   \\\n  ada/s-mastop.o   \\\n  ada/s-memory.o   \\\n  ada/s-os_lib.o   \\\n@@ -555,11 +568,13 @@ GNATBIND_OBJS = \\\n  ada/s-string.o   \\\n  ada/s-strops.o   \\\n  ada/s-traent.o   \\\n+ ada/s-traceb.o   \\\n  ada/s-unstyp.o   \\\n  ada/s-utf_32.o   \\\n  ada/s-wchcnv.o   \\\n  ada/s-wchcon.o   \\\n  ada/s-wchjis.o   \\\n+ ada/s-wchstw.o   \\\n  ada/scans.o      \\\n  ada/scil_ll.o    \\\n  ada/scng.o       \\\n@@ -594,6 +609,21 @@ ADA_BACKEND = $(BACKEND) attribs.o\n # List of target dependent sources, overridden below as necessary\n TARGET_ADA_SRCS =\n \n+# Select the right s-excmac according to exception layout (Itanium or arm)\n+host_cpu=$(word 1, $(subst -, ,$(host)))\n+EH_MECHANISM=-gcc\n+ifeq ($(strip $(filter-out arm%,$(host_cpu))),)\n+EH_MECHANISM=-arm\n+endif\n+\n+ada/s-excmac.o: ada/s-excmac.ads ada/s-excmac.adb\n+\n+ada/s-excmac.ads: $(srcdir)/ada/s-excmac$(EH_MECHANISM).ads\n+\t$(CP) $< $@\n+\n+ada/s-excmac.adb: $(srcdir)/ada/s-excmac$(EH_MECHANISM).adb\n+\t$(CP) $< $@\n+\n # Needs to be built with CC=gcc\n # Since the RTL should be built with the latest compiler, remove the\n #  stamp target in the parent directory whenever gnat1 is rebuilt\n@@ -976,12 +1006,12 @@ ada/sdefault.o : ada/ada.ads ada/a-except.ads ada/a-unccon.ads \\\n \n # Special flags - see gcc-interface/Makefile.in for the template.\n \n-ada/a-except.o  : ada/a-except.adb ada/a-except.ads\n+ada/a-except.o : ada/a-except.adb ada/a-except.ads ada/s-excmac.ads ada/s-excmac.adb\n \t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O1 -fno-inline \\\n \t $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n \t@$(ADA_DEPS)\n \n-ada/s-excdeb.o  : ada/s-excdeb.adb ada/s-excdeb.ads\n+ada/s-excdeb.o : ada/s-excdeb.adb ada/s-excdeb.ads\n \t$(CC) -c $(ALL_ADAFLAGS) $(FORCE_DEBUG_ADAFLAGS) -O0 \\\n \t $(ADA_INCLUDES) $< $(OUTPUT_OPTION)\n \t@$(ADA_DEPS)"}, {"sha": "b65ec2c75062a4888b49606a40b8ca110908d942", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -2427,32 +2427,20 @@ endif\n \n ifeq ($(EH_MECHANISM),-gcc)\n   LIBGNAT_TARGET_PAIRS += \\\n-    a-exexpr.adb<a-exexpr-gcc.adb \\\n-    s-excmac.ads<s-excmac-gcc.ads\n+    s-excmac.ads<s-excmac-gcc.ads \\\n+    s-excmac.adb<s-excmac-gcc.adb\n   EXTRA_LIBGNAT_OBJS+=raise-gcc.o\n   EXTRA_GNATRTL_NONTASKING_OBJS+=g-cppexc.o s-excmac.o\n endif\n \n ifeq ($(EH_MECHANISM),-arm)\n   LIBGNAT_TARGET_PAIRS += \\\n-    a-exexpr.adb<a-exexpr-gcc.adb \\\n-    s-excmac.ads<s-excmac-arm.ads\n+    s-excmac.ads<s-excmac-arm.ads \\\n+    s-excmac.adb<s-excmac-arm.adb\n   EXTRA_LIBGNAT_OBJS+=raise-gcc.o\n   EXTRA_GNATRTL_NONTASKING_OBJS+=g-cppexc.o s-excmac.o\n endif\n \n-# Use the Ada 2005 version of Ada.Exceptions by default, unless specified\n-# explicitly already. The base files (a-except.ad?) are used only for building\n-# the compiler and other basic tools.\n-# These base versions lack Ada 2005 additions which would cause bootstrap\n-# problems if included in the compiler and other basic tools.\n-\n-ifeq ($(filter a-except%,$(LIBGNAT_TARGET_PAIRS)),)\n-  LIBGNAT_TARGET_PAIRS += \\\n-    a-except.ads<a-except-2005.ads \\\n-    a-except.adb<a-except-2005.adb\n-endif\n-\n # Configuration of host tools\n \n # Under linux, host tools need to be linked with -ldl"}, {"sha": "cb35842b061544be50d6c0bd30fc350645560372", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *             Copyright (C) 1992-2016, Free Software Foundation, Inc.      *\n+ *             Copyright (C) 1992-2017, Free Software Foundation, Inc.      *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -32,10 +32,6 @@\n /* Code related to the integration of the GCC mechanism for exception\n    handling.  */\n \n-#ifndef IN_RTS\n-#error \"RTS unit only\"\n-#endif\n-\n #ifndef CERT\n #include \"tconfig.h\"\n #include \"tsystem.h\"\n@@ -45,9 +41,14 @@\n #endif\n \n #include <stdarg.h>\n+\n+#ifdef __cplusplus\n+# include <cstdlib>\n+#else\n typedef char bool;\n # define true 1\n # define false 0\n+#endif\n \n #include \"raise.h\"\n \n@@ -72,14 +73,18 @@ typedef char bool;\n \n #include \"unwind.h\"\n \n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n typedef struct _Unwind_Context _Unwind_Context;\n typedef struct _Unwind_Exception _Unwind_Exception;\n \n _Unwind_Reason_Code\n __gnat_Unwind_RaiseException (_Unwind_Exception *);\n \n _Unwind_Reason_Code\n-__gnat_Unwind_ForcedUnwind (_Unwind_Exception *, void *, void *);\n+__gnat_Unwind_ForcedUnwind (_Unwind_Exception *, _Unwind_Stop_Fn, void *);\n \n extern struct Exception_Occurrence *__gnat_setup_current_excep\n  (_Unwind_Exception *);\n@@ -209,7 +214,7 @@ db_indent (int requests)\n }\n \n static void ATTRIBUTE_PRINTF_2\n-db (int db_code, char * msg_format, ...)\n+db (int db_code, const char * msg_format, ...)\n {\n   if (db_accepted_codes () & db_code)\n     {\n@@ -816,8 +821,8 @@ get_call_site_action_for (_Unwind_Ptr ip,\n \n       db (DB_CSITE,\n \t  \"c_site @ %p (+%p), len = %p, lpad @ %p (+%p)\\n\",\n-\t  (void *)region->base + cs_start, (void *)cs_start, (void *)cs_len,\n-\t  (void *)region->lp_base + cs_lp, (void *)cs_lp);\n+\t  (char *)region->base + cs_start, (void *)cs_start, (void *)cs_len,\n+\t  (char *)region->lp_base + cs_lp, (void *)cs_lp);\n \n       /* The table is sorted, so if we've passed the IP, stop.  */\n       if (ip < region->base + cs_start)\n@@ -1399,7 +1404,7 @@ __gnat_Unwind_RaiseException (_Unwind_Exception *e)\n \n _Unwind_Reason_Code\n __gnat_Unwind_ForcedUnwind (_Unwind_Exception *e ATTRIBUTE_UNUSED,\n-\t\t\t    void *handler ATTRIBUTE_UNUSED,\n+\t\t\t    _Unwind_Stop_Fn handler ATTRIBUTE_UNUSED,\n \t\t\t    void *argument ATTRIBUTE_UNUSED)\n {\n #ifdef __USING_SJLJ_EXCEPTIONS__\n@@ -1609,3 +1614,7 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \n const int __gnat_unwind_exception_size = sizeof (_Unwind_Exception);\n #endif\n+\n+#ifdef __cplusplus\n+}\n+#endif"}, {"sha": "8434b67293d28128bc1690eeebd7d0b635c17e0f", "filename": "gcc/ada/raise.c", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fraise.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fraise.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise.c?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *             Copyright (C) 1992-2012, Free Software Foundation, Inc.      *\n+ *             Copyright (C) 1992-2017, Free Software Foundation, Inc.      *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -47,20 +47,6 @@\n extern \"C\" {\n #endif\n \n-/*  Wrapper to builtin_longjmp.  This is for the compiler eh only, as the sjlj\n-    runtime library interfaces directly to the intrinsic.  We can't yet do\n-    this for the compiler itself, because this capability relies on changes\n-    made in April 2008 and we need to preserve the possibility to bootstrap\n-    with an older base version.  */\n-\n-#if defined (IN_GCC) && !defined (IN_RTS)\n-void\n-_gnat_builtin_longjmp (void *ptr, int flag ATTRIBUTE_UNUSED)\n-{\n-   __builtin_longjmp (ptr, 1);\n-}\n-#endif\n-\n /* When an exception is raised for which no handler exists, the procedure\n    Ada.Exceptions.Unhandled_Exception is called, which performs the call to\n    adafinal to complete finalization, and then prints out the error messages\n@@ -84,6 +70,71 @@ __gnat_unhandled_terminate (void)\n   __gnat_os_exit (1);\n }\n \n+#ifndef IN_RTS\n+int\n+__gnat_backtrace (void **array ATTRIBUTE_UNUSED,\n+                  int size ATTRIBUTE_UNUSED,\n+                  void *exclude_min ATTRIBUTE_UNUSED,\n+                  void *exclude_max ATTRIBUTE_UNUSED,\n+                  int skip_frames ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n+void\n+__gnat_eh_personality (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_04 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_10 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_19 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_20 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_21 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_30 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_31 (void)\n+{\n+  abort ();\n+}\n+\n+void\n+__gnat_rcheck_32 (void)\n+{\n+  abort ();\n+}\n+#endif\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "316457422e9b9675588a70be0b281a8d9690ce4c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -4195,6 +4195,14 @@ package body Sem_Ch3 is\n          if No (E) and then Is_Null_Record_Type (T) then\n             null;\n \n+         --  Do not generate a predicate check if the initialization expression\n+         --  is a type conversion because the conversion has been subjected to\n+         --  the same check. This is a small optimization which avoid redundant\n+         --  checks.\n+\n+         elsif Present (E) and then Nkind (E) = N_Type_Conversion then\n+            null;\n+\n          else\n             Insert_After (N,\n               Make_Predicate_Check (T, New_Occurrence_Of (Id, Loc)));"}, {"sha": "676c1460161a34f2a41eb1b8c1dfbb31fde399f6", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -688,7 +688,7 @@ package body Sem_Elab is\n       --  see whether an elaboration check is required.\n \n       Is_DIC : Boolean;\n-      --  Flag set when the subprogram being invoked the procedure generated\n+      --  Flag set when the subprogram being invoked is the procedure generated\n       --  for pragma Default_Initial_Condition.\n \n       SPARK_Elab_Errors : Boolean;"}, {"sha": "0595b0b08355f23ea08b92717f622a3db0830fce", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -11065,22 +11065,11 @@ package body Sem_Res is\n          end;\n       end if;\n \n-      --  Ada 2012: if target type has predicates, the result requires a\n-      --  predicate check. If the context is a call to another predicate\n-      --  check we must prevent infinite recursion.\n+      --  Ada 2012: once the type conversion is resolved, check whether the\n+      --  operand statisfies the static predicate of the target type.\n \n       if Has_Predicates (Target_Typ) then\n-         if Nkind (Parent (N)) = N_Function_Call\n-           and then Present (Name (Parent (N)))\n-           and then (Is_Predicate_Function (Entity (Name (Parent (N))))\n-                       or else\n-                     Is_Predicate_Function_M (Entity (Name (Parent (N)))))\n-         then\n-            null;\n-\n-         else\n-            Apply_Predicate_Check (N, Target_Typ);\n-         end if;\n+         Check_Expression_Against_Static_Predicate (N, Target_Typ);\n       end if;\n \n       --  If at this stage we have a real to integer conversion, make sure that"}, {"sha": "c35ee7cab2761aa7c720588e0fb99eec5e173c72", "filename": "gcc/ada/system.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbfce7e87651d5e7272bad48dfc63e71c1bb27a/gcc%2Fada%2Fsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem.ads?ref=6cbfce7e87651d5e7272bad48dfc63e71c1bb27a", "patch": "@@ -7,7 +7,7 @@\n --                                 S p e c                                  --\n --                            (Compiler Version)                            --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -163,8 +163,8 @@ private\n    Always_Compatible_Rep     : constant Boolean := True;\n    Suppress_Standard_Library : constant Boolean := False;\n    Use_Ada_Main_Program_Name : constant Boolean := False;\n-   Frontend_Exceptions       : constant Boolean := True;\n-   ZCX_By_Default            : constant Boolean := False;\n+   Frontend_Exceptions       : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n \n    --  Obsolete entries, to be removed eventually (bootstrap issues)\n \n@@ -173,6 +173,6 @@ private\n    Long_Shifts_Inlined       : constant Boolean := True;\n    Functions_Return_By_DSP   : constant Boolean := False;\n    Support_64_Bit_Divides    : constant Boolean := True;\n-   GCC_ZCX_Support           : constant Boolean := False;\n+   GCC_ZCX_Support           : constant Boolean := True;\n \n end System;"}]}