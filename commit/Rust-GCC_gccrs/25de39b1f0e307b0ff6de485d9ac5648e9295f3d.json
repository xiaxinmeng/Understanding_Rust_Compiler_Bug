{"sha": "25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjVkZTM5YjFmMGUzMDdiMGZmNmRlNDg1ZDlhYzU2NDhlOTI5NWYzZA==", "commit": {"author": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-11-14T13:26:11Z"}, "committer": {"name": "SimplyTheOther", "email": "simplytheother@gmail.com", "date": "2020-12-08T13:10:29Z"}, "message": "Added more expr stripping", "tree": {"sha": "0d04c7e5319acad5f6b8abc773c0edd12006de28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d04c7e5319acad5f6b8abc773c0edd12006de28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5ae2781823b3a2bcded1ac3446de83cc52403a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ae2781823b3a2bcded1ac3446de83cc52403a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ae2781823b3a2bcded1ac3446de83cc52403a9"}], "stats": {"total": 399, "additions": 316, "deletions": 83}, "files": [{"sha": "31c89e499f791da1cafdf41c4e447c21097561ba", "filename": "gcc/rust/analysis/rust-scan.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fanalysis%2Frust-scan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-scan.cc?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -353,7 +353,7 @@ TopLevelScan::visit (AST::UseDeclaration &use_decl)\n void\n TopLevelScan::visit (AST::Function &function)\n {\n-  functions[function.function_name] = &function;\n+  functions[function.get_function_name ()] = &function;\n }\n \n void"}, {"sha": "c3a5587c854959ccf6ccceb2966fdc1d244a3b93", "filename": "gcc/rust/analysis/rust-type-resolution.cc", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-type-resolution.cc?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -471,7 +471,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n \t  AST::StructField *declField = NULL;\n \t  for (auto &df : decl->get_fields ())\n \t    {\n-\t      if (identifierBuffer->compare (df.field_name) == 0)\n+\t      if (identifierBuffer->compare (df.get_field_name ()) == 0)\n \t\t{\n \t\t  declField = &df;\n \t\t  break;\n@@ -485,7 +485,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n \t      return;\n \t    }\n \n-\t  if (!typesAreCompatible (declField->field_type.get (), inferedType,\n+\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n \t\t\t\t   expr.get_locus_slow ()))\n \t    return;\n \t}\n@@ -505,7 +505,7 @@ TypeResolution::visit (AST::StructExprStructFields &expr)\n \t      return;\n \t    }\n \n-\t  if (!typesAreCompatible (declField->field_type.get (), inferedType,\n+\t  if (!typesAreCompatible (declField->get_field_type ().get (), inferedType,\n \t\t\t\t   expr.get_locus_slow ()))\n \t    return;\n \t}\n@@ -561,41 +561,41 @@ void\n TypeResolution::visit (AST::CallExpr &expr)\n {\n   // this look up should probably be moved to name resolution\n-  auto fndecl = lookupFndecl (expr.function.get ());\n+  auto fndecl = lookupFndecl (expr.get_function_expr ().get ());\n   if (fndecl == NULL)\n     return;\n \n   // check num args match\n-  if (fndecl->function_params.size () != expr.params.size ())\n+  if (fndecl->get_function_params ().size () != expr.get_params ().size ())\n     {\n       rust_error_at (expr.get_locus_slow (),\n \t\t     \"differing number of arguments vs parameters to function\");\n       return;\n     }\n \n-  typeBuffer.push_back (fndecl->return_type.get ());\n+  typeBuffer.push_back (fndecl->get_return_type ().get ());\n   expr.fndeclRef = fndecl;\n \n   auto before = typeBuffer.size ();\n-  for (auto &item : expr.params)\n+  for (auto &item : expr.get_params ())\n     item->accept_vis (*this);\n \n   auto numInferedParams = typeBuffer.size () - before;\n-  if (numInferedParams != expr.params.size ())\n+  if (numInferedParams != expr.get_params ().size ())\n     {\n       rust_error_at (expr.get_locus (), \"Failed to infer all parameters\");\n       return;\n     }\n \n   auto offs = numInferedParams - 1;\n-  for (auto it = fndecl->function_params.rbegin ();\n-       it != fndecl->function_params.rend (); ++it)\n+  for (auto it = fndecl->get_function_params ().rbegin ();\n+       it != fndecl->get_function_params ().rend (); ++it)\n     {\n       AST::Type *argument = typeBuffer.back ();\n       typeBuffer.pop_back ();\n \n       if (!typesAreCompatible (it->type.get (), argument,\n-\t\t\t       expr.params[offs]->get_locus_slow ()))\n+\t\t\t       expr.get_params ()[offs]->get_locus_slow ()))\n \treturn;\n       offs--;\n     }\n@@ -762,11 +762,11 @@ TypeResolution::visit (AST::Function &function)\n {\n   // always emit the function with return type in the event of nil return type\n   // its  a marker for a void function\n-  scope.InsertType (function.function_name, function.return_type.get ());\n-  scope.InsertFunction (function.function_name, &function);\n+  scope.InsertType (function.get_function_name (), function.get_return_type ().get ());\n+  scope.InsertFunction (function.get_function_name (), &function);\n   scope.Push ();\n \n-  for (auto &param : function.function_params)\n+  for (auto &param : function.get_function_params ())\n     {\n       if (!isTypeInScope (param.type.get (), param.get_locus ()))\n \treturn;\n@@ -787,12 +787,12 @@ TypeResolution::visit (AST::Function &function)\n   // ensure the return type is resolved\n   if (function.has_function_return_type ())\n     {\n-      if (!isTypeInScope (function.return_type.get (), function.get_locus ()))\n+      if (!isTypeInScope (function.get_return_type ().get (), function.get_locus ()))\n \treturn;\n     }\n \n   // walk the expression body\n-  for (auto &stmt : function.function_body->statements)\n+  for (auto &stmt : function.get_definition ()->statements)\n     {\n       stmt->accept_vis (*this);\n     }\n@@ -813,7 +813,7 @@ TypeResolution::visit (AST::StructStruct &struct_item)\n {\n   for (auto &field : struct_item.get_fields ())\n     {\n-      if (!isTypeInScope (field.field_type.get (),\n+      if (!isTypeInScope (field.get_field_type ().get (),\n \t\t\t  Linemap::unknown_location ()))\n \t{\n \t  rust_fatal_error (Linemap::unknown_location (),\n@@ -822,7 +822,7 @@ TypeResolution::visit (AST::StructStruct &struct_item)\n \t}\n     }\n \n-  scope.InsertStruct (struct_item.struct_name, &struct_item);\n+  scope.InsertStruct (struct_item.get_struct_name (), &struct_item);\n }\n \n void"}, {"sha": "f9dd99c3c2c0b3d40e03488238798c7e4b06caba", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -3721,9 +3721,7 @@ StructExprTuple::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n\" + indent_spaces (stay) + attr.as_string ();\n-\t}\n     }\n   indent_spaces (out);\n   indent_spaces (out);\n@@ -3749,9 +3747,7 @@ StructExprStruct::as_string () const\n       /* note that this does not print them with \"inner attribute\" syntax -\n        * just the body */\n       for (const auto &attr : inner_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   return str;\n@@ -3761,13 +3757,9 @@ std::string\n StructBase::as_string () const\n {\n   if (base_struct != nullptr)\n-    {\n       return base_struct->as_string ();\n-    }\n   else\n-    {\n       return \"ERROR_MARK_STRING - invalid struct base had as string applied\";\n-    }\n }\n \n std::string\n@@ -3802,24 +3794,58 @@ StructExprStructFields::as_string () const\n   else\n     {\n       for (const auto &field : fields)\n-\t{\n \t  str += \"\\n  \" + field->as_string ();\n-\t}\n     }\n \n   str += \"\\n Struct base: \";\n   if (!has_struct_base ())\n+      str += \"none\";\n+  else\n+      str += struct_base.as_string ();\n+\n+  return str;\n+}\n+\n+std::string\n+EnumExprStruct::as_string () const\n+{\n+  std::string str (\"StructExprStruct (or subclass): \");\n+\n+  str += \"\\n Path: \" + get_enum_variant_path ().as_string ();\n+\n+  str += \"\\n Fields: \";\n+  if (fields.empty ())\n     {\n       str += \"none\";\n     }\n   else\n     {\n-      str += struct_base.as_string ();\n+      for (const auto &field : fields)\n+\t  str += \"\\n  \" + field->as_string ();\n     }\n \n   return str;\n }\n \n+std::string\n+EnumExprFieldWithVal::as_string () const\n+{\n+  // used to get value string\n+  return value->as_string ();\n+}\n+\n+std::string\n+EnumExprFieldIdentifierValue::as_string () const\n+{\n+  return field_name + \" : \" + EnumExprFieldWithVal::as_string ();\n+}\n+\n+std::string\n+EnumExprFieldIndexValue::as_string () const\n+{\n+  return std::to_string (index) + \" : \" + EnumExprFieldWithVal::as_string ();\n+}\n+\n std::string\n EnumItem::as_string () const\n {\n@@ -3834,9 +3860,7 @@ EnumItem::as_string () const\n       /* note that this does not print them with \"outer attribute\" syntax -\n        * just the body */\n       for (const auto &attr : outer_attrs)\n-\t{\n \t  str += \"\\n  \" + attr.as_string ();\n-\t}\n     }\n \n   str += \"\\n\" + variant_name;"}, {"sha": "6f685429edbc1b0d0e9bc00a19875a8b270e352c", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 73, "deletions": 20, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -1849,6 +1849,8 @@ class EnumExprField\n     return std::unique_ptr<EnumExprField> (clone_enum_expr_field_impl ());\n   }\n \n+  virtual std::string as_string () const = 0;\n+\n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n protected:\n@@ -1870,6 +1872,8 @@ class EnumExprFieldIdentifier : public EnumExprField\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  std::string as_string () const override { return field_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -1908,6 +1912,15 @@ class EnumExprFieldWithVal : public EnumExprField\n   // move constructors\n   EnumExprFieldWithVal (EnumExprFieldWithVal &&other) = default;\n   EnumExprFieldWithVal &operator= (EnumExprFieldWithVal &&other) = default;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_value () {\n+    rust_assert (value != nullptr);\n+    return value;\n+  }\n };\n \n // Identifier and value variant of EnumExprField AST node\n@@ -1924,6 +1937,8 @@ class EnumExprFieldIdentifierValue : public EnumExprFieldWithVal\n       field_name (std::move (field_name))\n   {}\n \n+  std::string as_string () const override;\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n@@ -1949,6 +1964,8 @@ class EnumExprFieldIndexValue : public EnumExprFieldWithVal\n     : EnumExprFieldWithVal (std::move (field_value)), index (field_index)\n   {}\n \n+  std::string as_string () const override;\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n protected:\n@@ -1971,10 +1988,6 @@ class EnumExprStruct : public EnumVariantExpr\n public:\n   std::string as_string () const override;\n \n-  /*inline std::vector<std::unique_ptr<EnumExprField>> get_fields() const\n-  { return fields;\n-  }*/\n-\n   EnumExprStruct (PathInExpression enum_variant_path,\n \t\t  std::vector<std::unique_ptr<EnumExprField> > variant_fields,\n \t\t  std::vector<Attribute> outer_attribs, Location locus)\n@@ -2037,10 +2050,6 @@ class EnumExprTuple : public EnumVariantExpr\n public:\n   std::string as_string () const override;\n \n-  /*inline std::vector<std::unique_ptr<Expr>> get_values() const {\n-      return values;\n-  }*/\n-\n   EnumExprTuple (PathInExpression enum_variant_path,\n \t\t std::vector<std::unique_ptr<Expr> > variant_values,\n \t\t std::vector<Attribute> outer_attribs, Location locus)\n@@ -2080,6 +2089,9 @@ class EnumExprTuple : public EnumVariantExpr\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  const std::vector<std::unique_ptr<Expr> > &get_elems () const { return values; }\n+  std::vector<std::unique_ptr<Expr> > &get_elems () { return values; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2128,21 +2140,17 @@ class Function;\n // Function call expression AST node\n class CallExpr : public ExprWithoutBlock\n {\n-public:\n   std::unique_ptr<Expr> function;\n   // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n \n+public:\n   Function *fndeclRef;\n \n   std::string as_string () const override;\n \n-  /*inline std::vector<std::unique_ptr<Expr>> get_params() const {\n-      return params;\n-  }*/\n-\n   CallExpr (std::unique_ptr<Expr> function_expr,\n \t    std::vector<std::unique_ptr<Expr> > function_params,\n \t    std::vector<Attribute> outer_attribs, Location locus)\n@@ -2199,6 +2207,16 @@ class CallExpr : public ExprWithoutBlock\n   void mark_for_strip () override { function = nullptr; }\n   bool is_marked_for_strip () const override { return function == nullptr; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Expr> > &get_params () const { return params; }\n+  std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_function_expr () {\n+    rust_assert (function != nullptr);\n+    return function;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2221,10 +2239,6 @@ class MethodCallExpr : public ExprWithoutBlock\n public:\n   std::string as_string () const override;\n \n-  /*inline std::vector<std::unique_ptr<Expr>> get_params() const {\n-      return params;\n-  }*/\n-\n   MethodCallExpr (std::unique_ptr<Expr> call_receiver,\n \t\t  PathExprSegment method_path,\n \t\t  std::vector<std::unique_ptr<Expr> > method_params,\n@@ -2281,6 +2295,18 @@ class MethodCallExpr : public ExprWithoutBlock\n   void mark_for_strip () override { receiver = nullptr; }\n   bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Expr> > &get_params () const { return params; }\n+  std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_receiver_expr () {\n+    rust_assert (receiver != nullptr);\n+    return receiver;\n+  }\n+\n+  PathExprSegment get_method_name () const { return method_name; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2349,6 +2375,14 @@ class FieldAccessExpr : public ExprWithoutBlock\n   void mark_for_strip () override { receiver = nullptr; }\n   bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_receiver_expr () {\n+    rust_assert (receiver != nullptr);\n+    return receiver;\n+  }\n+\n+  Identifier get_field_name () const { return field; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */\n@@ -2362,6 +2396,7 @@ class FieldAccessExpr : public ExprWithoutBlock\n struct ClosureParam\n {\n private:\n+  std::vector<Attribute> outer_attrs;\n   std::unique_ptr<Pattern> pattern;\n \n   // bool has_type_given;\n@@ -2373,15 +2408,18 @@ struct ClosureParam\n   // Returns whether the type of the parameter has been given.\n   bool has_type_given () const { return type != nullptr; }\n \n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n   // Constructor for closure parameter\n   ClosureParam (std::unique_ptr<Pattern> param_pattern,\n-\t\tstd::unique_ptr<Type> param_type = nullptr)\n-    : pattern (std::move (param_pattern)), type (std::move (param_type))\n+\t\tstd::unique_ptr<Type> param_type = nullptr, std::vector<Attribute> outer_attrs = {})\n+    : outer_attrs (std::move(outer_attrs)), pattern (std::move (param_pattern)), \n+      type (std::move (param_type))\n   {}\n \n   // Copy constructor required due to cloning as a result of unique_ptrs\n   ClosureParam (ClosureParam const &other)\n-    : pattern (other.pattern->clone_pattern ())\n+    : outer_attrs (other.outer_attrs)\n   {\n     // guard to protect from null pointer dereference\n     if (other.pattern != nullptr)\n@@ -2395,6 +2433,8 @@ struct ClosureParam\n   // Assignment operator must be overloaded to clone as well\n   ClosureParam &operator= (ClosureParam const &other)\n   {\n+    outer_attrs = other.outer_attrs;\n+\n     // guard to protect from null pointer dereference\n     if (other.pattern != nullptr)\n       pattern = other.pattern->clone_pattern ();\n@@ -2419,6 +2459,9 @@ struct ClosureParam\n   static ClosureParam create_error () { return ClosureParam (nullptr); }\n \n   std::string as_string () const;\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n };\n \n // Base closure definition expression AST node - abstract\n@@ -2443,6 +2486,10 @@ class ClosureExpr : public ExprWithoutBlock\n \n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<ClosureParam> &get_params () const { return params; }\n+  std::vector<ClosureParam> &get_params () { return params; }\n };\n \n // Represents a non-type-specified closure expression AST node\n@@ -2500,6 +2547,12 @@ class ClosureExprInner : public ClosureExpr\n   void mark_for_strip () override { closure_inner = nullptr; }\n   bool is_marked_for_strip () const override { return closure_inner == nullptr; }\n \n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_definition_expr () {\n+    rust_assert (closure_inner != nullptr);\n+    return closure_inner;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "5891383ca7264e394f8f70b1a673ba71cd3fe77e", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -1266,7 +1266,6 @@ class LetStmt;\n // Rust function declaration AST node\n class Function : public VisItem, public InherentImplItem, public TraitImplItem\n {\n-public:\n   FunctionQualifiers qualifiers;\n   Identifier function_name;\n \n@@ -1288,6 +1287,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location locus;\n \n+public:\n   std::vector<LetStmt *> locals;\n \n   std::string as_string () const override;\n@@ -1396,6 +1396,22 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n     return function_body;\n   }\n \n+  FunctionQualifiers get_qualifiers () const { return qualifiers; }\n+\n+  Identifier get_function_name () const { return function_name; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause () {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type () {\n+    rust_assert (return_type != nullptr);\n+    return return_type;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -1518,7 +1534,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n // Rust base struct declaration AST node - abstract base class\n class Struct : public VisItem\n {\n-public:\n+protected:\n   // protected to enable access by derived classes - allows better as_string\n   Identifier struct_name;\n \n@@ -1529,8 +1545,10 @@ class Struct : public VisItem\n   // bool has_where_clause;\n   WhereClause where_clause;\n \n+private:\n   Location locus;\n \n+public:\n   // Returns whether struct has generic parameters.\n   bool has_generics () const { return !generic_params.empty (); }\n \n@@ -1543,6 +1561,8 @@ class Struct : public VisItem\n   void mark_for_strip () override { struct_name = \"\"; }\n   bool is_marked_for_strip () const override { return struct_name.empty (); }\n \n+  Identifier get_struct_name () const { return struct_name; }\n+\n protected:\n   Struct (Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -1587,7 +1607,7 @@ class Struct : public VisItem\n // A single field in a struct\n struct StructField\n {\n-public:\n+private:\n   // bool has_outer_attributes;\n   std::vector<Attribute> outer_attrs;\n \n@@ -1599,6 +1619,7 @@ struct StructField\n \n   // should this store location info?\n \n+public:\n   // Returns whether struct field has any outer attributes.\n   bool has_outer_attributes () const { return !outer_attrs.empty (); }\n \n@@ -1662,6 +1683,16 @@ struct StructField\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n   const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  Identifier get_field_name () const { return field_name; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_field_type () {\n+    rust_assert (field_type != nullptr);\n+    return field_type;\n+  }\n+\n+  Visibility get_visibility () const { return visibility; }\n };\n \n // Rust struct declaration with true struct type AST node"}, {"sha": "12ce47f67b1b43e14a3cfaf220b0957bac483a2d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -538,7 +538,7 @@ Compilation::visit (AST::StructExprFieldIdentifierValue &field)\n   bool found = false;\n   for (auto &df : decl->get_fields ())\n     {\n-      if (field.get_field_name ().compare (df.field_name) == 0)\n+      if (field.get_field_name ().compare (df.get_field_name ()) == 0)\n \t{\n \t  found = true;\n \t  break;\n@@ -651,15 +651,15 @@ void\n Compilation::visit (AST::CallExpr &expr)\n {\n   Bexpression *fn = NULL;\n-  VISIT_POP (expr.function->get_locus_slow (), expr.function, fn, exprs);\n+  VISIT_POP (expr.get_function_expr ()->get_locus_slow (), expr.get_function_expr (), fn, exprs);\n   if (fn == NULL)\n     {\n-      rust_error_at (expr.function->get_locus_slow (), \"failed to resolve\");\n+      rust_error_at (expr.get_function_expr ()->get_locus_slow (), \"failed to resolve\");\n       return;\n     }\n \n   std::vector<Bexpression *> args;\n-  for (auto &param : expr.params)\n+  for (auto &param : expr.get_params ())\n     {\n       Bexpression *arg = NULL;\n       VISIT_POP (param->get_locus_slow (), param, arg, exprs);\n@@ -949,7 +949,7 @@ Compilation::visit (AST::Function &function)\n   std::vector<Backend::Btyped_identifier> parameters;\n   std::vector<Backend::Btyped_identifier> results;\n \n-  for (auto &param : function.function_params)\n+  for (auto &param : function.get_function_params ())\n     {\n       // translate the type\n       translatedType = NULL;\n@@ -983,7 +983,7 @@ Compilation::visit (AST::Function &function)\n   if (function.has_function_return_type ())\n     {\n       translatedType = NULL;\n-      function.return_type->accept_vis (*this);\n+      function.get_return_type ()->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n \t  rust_fatal_error (function.get_locus (),\n@@ -1000,10 +1000,10 @@ Compilation::visit (AST::Function &function)\n   Btype *fntype = backend->function_type (receiver, parameters, results, NULL,\n \t\t\t\t\t  function.get_locus ());\n   Bfunction *fndecl\n-    = backend->function (fntype, function.function_name, \"\" /* asm_name */,\n+    = backend->function (fntype, function.get_function_name (), \"\" /* asm_name */,\n \t\t\t 0 /* flags */, function.get_locus ());\n \n-  scope.InsertFunction (function.function_name, fndecl, returnType);\n+  scope.InsertFunction (function.get_function_name (), fndecl, returnType);\n   scope.Push ();\n \n   // setup the params\n@@ -1039,10 +1039,10 @@ Compilation::visit (AST::Function &function)\n   Bblock *enclosingScope = NULL;\n   Location start_location = function.get_locus ();\n   Location end_location;\n-  if (function.function_body->statements.size () > 0)\n+  if (function.get_definition ()->statements.size () > 0)\n     {\n       end_location\n-\t= function.function_body->statements.back ()->get_locus_slow ();\n+\t= function.get_definition ()->statements.back ()->get_locus_slow ();\n     }\n \n   auto code_block = backend->block (fndecl, enclosingScope, vars,\n@@ -1060,10 +1060,10 @@ Compilation::visit (AST::Function &function)\n \t\t\t\t\t     function.get_locus (), &ret_var_stmt);\n       scope.AddStatement (ret_var_stmt);\n     }\n-  scope.PushCurrentFunction (function.function_name, fndecl, returnType,\n+  scope.PushCurrentFunction (function.get_function_name (), fndecl, returnType,\n \t\t\t     retDecl);\n \n-  for (auto &stmt : function.function_body->statements)\n+  for (auto &stmt : function.get_definition ()->statements)\n     stmt->accept_vis (*this);\n \n   scope.PopBlock ();\n@@ -1092,7 +1092,7 @@ Compilation::visit (AST::StructStruct &struct_item)\n   for (auto &field : struct_item.get_fields ())\n     {\n       translatedType = NULL;\n-      field.field_type->accept_vis (*this);\n+      field.get_field_type ()->accept_vis (*this);\n       if (translatedType == NULL)\n \t{\n \t  rust_fatal_error (\n@@ -1102,12 +1102,12 @@ Compilation::visit (AST::StructStruct &struct_item)\n \t}\n \n       fields.push_back (Backend::Btyped_identifier (\n-\tfield.field_name, translatedType,\n+\tfield.get_field_name (), translatedType,\n \tstruct_item.get_locus () /* StructField is mi sing locus */));\n     }\n \n   auto compiledStruct\n-    = backend->placeholder_struct_type (struct_item.struct_name,\n+    = backend->placeholder_struct_type (struct_item.get_struct_name (),\n \t\t\t\t\tstruct_item.get_locus ());\n   bool ok = backend->set_placeholder_struct_type (compiledStruct, fields);\n   if (!ok)\n@@ -1117,8 +1117,8 @@ Compilation::visit (AST::StructStruct &struct_item)\n     }\n \n   type_decls.push_back (compiledStruct);\n-  scope.InsertType (struct_item.struct_name, compiledStruct);\n-  scope.InsertStructDecl (struct_item.struct_name, &struct_item);\n+  scope.InsertType (struct_item.get_struct_name (), compiledStruct);\n+  scope.InsertStructDecl (struct_item.get_struct_name (), &struct_item);\n }\n \n void"}, {"sha": "ed5f36563ee897c0cca29a661a91b20990516675", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "modified", "additions": 133, "deletions": 10, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -512,10 +512,18 @@ namespace Rust {\n             }\n         }\n         void visit(AST::EnumExprFieldIdentifier& field) override {\n-            \n+            // as no attrs (at moment, at least), no stripping possible\n+        }\n+        void visit(AST::EnumExprFieldIdentifierValue& field) override {\n+            /* as no attrs possible (at moment, at least), only sub-expression\n+             * stripping is possible */\n+            field.get_value()->accept_vis(*this);\n+        }\n+        void visit(AST::EnumExprFieldIndexValue& field) override {\n+            /* as no attrs possible (at moment, at least), only sub-expression\n+             * stripping is possible */\n+            field.get_value()->accept_vis(*this);\n         }\n-        void visit(AST::EnumExprFieldIdentifierValue& field) override {}\n-        void visit(AST::EnumExprFieldIndexValue& field) override {}\n         void visit(AST::EnumExprStruct& expr) override {\n             // initial strip test based on outer attrs\n             expander.expand_cfg_attrs(expr.get_outer_attrs());\n@@ -535,13 +543,128 @@ namespace Rust {\n                 // shouldn't strip in this\n             }\n         }\n-        void visit(AST::EnumExprTuple& expr) override {}\n-        void visit(AST::EnumExprFieldless& expr) override {}\n-        void visit(AST::CallExpr& expr) override {}\n-        void visit(AST::MethodCallExpr& expr) override {}\n-        void visit(AST::FieldAccessExpr& expr) override {}\n-        void visit(AST::ClosureExprInner& expr) override {}\n-        void visit(AST::BlockExpr& expr) override {}\n+        void visit(AST::EnumExprTuple& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            // supposedly spec doesn't allow inner attributes in enum exprs\n+\n+            /* spec says outer attributes are specifically allowed for elements \n+             * of tuple-style enum expressions, so full stripping possible */\n+            auto& values = expr.get_elems();\n+            for (int i = 0; i < values.size();) {\n+                auto& value = values[i];\n+\n+                // mark for stripping if required\n+                value->accept_vis(*this);\n+\n+                if (value->is_marked_for_strip())\n+                    values.erase(values.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::EnumExprFieldless& expr) override {\n+            // can't be stripped as no attrs\n+        }\n+        void visit(AST::CallExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* should not be outer attrs on \"function\" expression - outer attrs \n+             * should be associated with call expr as a whole. only sub-expr \n+             * expansion is possible. */\n+            expr.get_function_expr()->accept_vis(*this);\n+\n+            /* spec says outer attributes are specifically allowed for elements \n+             * of call expressions, so full stripping possible */\n+            auto& params = expr.get_params();\n+            for (int i = 0; i < params.size();) {\n+                auto& param = params[i];\n+\n+                // mark for stripping if required\n+                param->accept_vis(*this);\n+\n+                if (param->is_marked_for_strip())\n+                    params.erase(params.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::MethodCallExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* should not be outer attrs on \"receiver\" expression - outer attrs \n+             * should be associated with call expr as a whole. only sub-expr \n+             * expansion is possible. */\n+            expr.get_receiver_expr()->accept_vis(*this);\n+\n+            // no outer attrs on paths possible\n+\n+            /* spec says outer attributes are specifically allowed for elements \n+             * of method call expressions, so full stripping possible */\n+            auto& params = expr.get_params();\n+            for (int i = 0; i < params.size();) {\n+                auto& param = params[i];\n+\n+                // mark for stripping if required\n+                param->accept_vis(*this);\n+\n+                if (param->is_marked_for_strip())\n+                    params.erase(params.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::FieldAccessExpr& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* should not be outer attrs on \"receiver\" expression - outer attrs \n+             * should be associated with call expr as a whole. only sub-expr \n+             * expansion is possible. */\n+            expr.get_receiver_expr()->accept_vis(*this);\n+        }\n+        void visit(AST::ClosureExprInner& expr) override {\n+            // initial strip test based on outer attrs\n+            expander.expand_cfg_attrs(expr.get_outer_attrs());\n+            if (expander.fails_cfg(expr.get_outer_attrs())) {\n+                expr.mark_for_strip();\n+                return;\n+            }\n+\n+            /* strip closure parameters if required - this is specifically\n+             * allowed by spec */\n+            auto& params = expr.get_params();\n+            for (int i = 0; i < params.size();) {\n+                auto& param_attrs = params[i].get_outer_attrs();\n+                expander.expand_cfg_attrs(param_attrs);\n+                if (expander.fails_cfg(param_attrs))\n+                    params.erase(params.begin() + i);\n+                else\n+                    i++;\n+            }\n+        }\n+        void visit(AST::BlockExpr& expr) override {\n+            \n+        }\n         void visit(AST::ClosureExprInnerTyped& expr) override {}\n         void visit(AST::ContinueExpr& expr) override {}\n         void visit(AST::BreakExpr& expr) override {}"}, {"sha": "769cf41e083de47f18d6f4437fdbfa010ee0deec", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25de39b1f0e307b0ff6de485d9ac5648e9295f3d/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=25de39b1f0e307b0ff6de485d9ac5648e9295f3d", "patch": "@@ -8512,6 +8512,8 @@ template <typename ManagedTokenSource>\n AST::ClosureParam\n Parser<ManagedTokenSource>::parse_closure_param ()\n {\n+  std::vector<AST::Attribute> outer_attrs = parse_outer_attributes ();\n+\n   // parse pattern (which is required)\n   std::unique_ptr<AST::Pattern> pattern = parse_pattern ();\n   if (pattern == nullptr)\n@@ -8537,7 +8539,7 @@ Parser<ManagedTokenSource>::parse_closure_param ()\n \t}\n     }\n \n-  return AST::ClosureParam (std::move (pattern), std::move (type));\n+  return AST::ClosureParam (std::move (pattern), std::move (type), std::move (outer_attrs));\n }\n \n // Parses a grouped or tuple expression (disambiguates)."}]}