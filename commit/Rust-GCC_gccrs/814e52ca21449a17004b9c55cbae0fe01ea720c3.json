{"sha": "814e52ca21449a17004b9c55cbae0fe01ea720c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE0ZTUyY2EyMTQ0OWExNzAwNGI5YzU1Y2JhZTBmZTAxZWE3MjBjMw==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2015-09-17T19:23:26Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2015-09-17T19:23:26Z"}, "message": "2015-09-17  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/debug/formatter.h\n\t(_Error_formatter::_Parameter::_M_print_field): Deprecate.\n\t(_Error_formatter::_Parameter::_M_print_description): Likewise.\n\t(_Error_formatter::_M_format_word): Likewise.\n\t(_Error_formatter::_M_print_word): Likewise.\n\t(_Error_formatter::_M_print_string): Likewise.\n\t(_Error_formatter::_M_get_max_length): Likewise.\n\t(_Error_formatter::_M_max_length): Delete.\n\t(_Error_formatter::_M_indent): Likewise.\n\t(_Error_formatter::_M_column): Likewise.\n\t(_Error_formatter::_M_first_line): Likewise.\n\t(_Error_formatter::_M_wordwrap): Likewise.\n\t* src/c++11/debug.cc: Adapt.\n\nFrom-SVN: r227885", "tree": {"sha": "8b3be8b5de1616824451433611f199313bd6565d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b3be8b5de1616824451433611f199313bd6565d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/814e52ca21449a17004b9c55cbae0fe01ea720c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/814e52ca21449a17004b9c55cbae0fe01ea720c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/814e52ca21449a17004b9c55cbae0fe01ea720c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/814e52ca21449a17004b9c55cbae0fe01ea720c3/comments", "author": null, "committer": null, "parents": [{"sha": "378b307d0d7e789c69570cba4a9388b781c3f062", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378b307d0d7e789c69570cba4a9388b781c3f062", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378b307d0d7e789c69570cba4a9388b781c3f062"}], "stats": {"total": 949, "additions": 514, "deletions": 435}, "files": [{"sha": "b11698426b4e7a081cc5a1b1fd564d3a59b6c140", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/814e52ca21449a17004b9c55cbae0fe01ea720c3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/814e52ca21449a17004b9c55cbae0fe01ea720c3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=814e52ca21449a17004b9c55cbae0fe01ea720c3", "patch": "@@ -1,3 +1,19 @@\n+2015-09-17  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/debug/formatter.h\n+\t(_Error_formatter::_Parameter::_M_print_field): Deprecate.\n+\t(_Error_formatter::_Parameter::_M_print_description): Likewise.\n+\t(_Error_formatter::_M_format_word): Likewise.\n+\t(_Error_formatter::_M_print_word): Likewise.\n+\t(_Error_formatter::_M_print_string): Likewise.\n+\t(_Error_formatter::_M_get_max_length): Likewise.\n+\t(_Error_formatter::_M_max_length): Delete.\n+\t(_Error_formatter::_M_indent): Likewise.\n+\t(_Error_formatter::_M_column): Likewise.\n+\t(_Error_formatter::_M_first_line): Likewise.\n+\t(_Error_formatter::_M_wordwrap): Likewise.\n+\t* src/c++11/debug.cc: Adapt.\n+\n 2015-09-17  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/65913"}, {"sha": "72735bbf9e82219393c26b245a29cca5473e29e1", "filename": "libstdc++-v3/include/debug/formatter.h", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/814e52ca21449a17004b9c55cbae0fe01ea720c3/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/814e52ca21449a17004b9c55cbae0fe01ea720c3/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h?ref=814e52ca21449a17004b9c55cbae0fe01ea720c3", "patch": "@@ -132,6 +132,13 @@ namespace __gnu_debug\n \n   class _Error_formatter\n   {\n+    // Tags denoting the type of parameter for construction\n+    struct _Is_iterator { };\n+    struct _Is_iterator_value_type { };\n+    struct _Is_sequence { };\n+    struct _Is_instance { };\n+\n+  public:\n     /// Whether an iterator is constant, mutable, or unknown\n     enum _Constness\n     {\n@@ -153,13 +160,6 @@ namespace __gnu_debug\n       __last_state\n     };\n \n-    // Tags denoting the type of parameter for construction\n-    struct _Is_iterator { };\n-    struct _Is_iterator_value_type { };\n-    struct _Is_sequence { };\n-    struct _Is_instance { };\n-\n-  public:\n     // A parameter that may be referenced by an error message\n     struct _Parameter\n     {\n@@ -375,15 +375,16 @@ namespace __gnu_debug\n \n       void\n       _M_print_field(const _Error_formatter* __formatter,\n-\t\t     const char* __name) const;\n+\t\t     const char* __name) const _GLIBCXX_DEPRECATED;\n \n       void\n-      _M_print_description(const _Error_formatter* __formatter) const;\n+      _M_print_description(const _Error_formatter* __formatter)\n+\tconst _GLIBCXX_DEPRECATED;\n     };\n \n     template<typename _Iterator>\n-      const _Error_formatter&\n-      _M_iterator(const _Iterator& __it, const char* __name = 0)  const\n+      _Error_formatter&\n+      _M_iterator(const _Iterator& __it, const char* __name = 0)\n       {\n \tif (_M_num_parameters < std::size_t(__max_parameters))\n \t  _M_parameters[_M_num_parameters++] = _Parameter(__it, __name,\n@@ -392,98 +393,98 @@ namespace __gnu_debug\n       }\n \n     template<typename _Iterator>\n-      const _Error_formatter&\n+      _Error_formatter&\n       _M_iterator_value_type(const _Iterator& __it,\n-\t\t\t     const char* __name = 0)  const\n+\t\t\t     const char* __name = 0)\n       {\n-\tif (_M_num_parameters < std::size_t(__max_parameters))\n+\tif (_M_num_parameters < __max_parameters)\n \t  _M_parameters[_M_num_parameters++] =\n \t    _Parameter(__it, __name, _Is_iterator_value_type());\n \treturn *this;\n       }\n \n-    const _Error_formatter&\n-    _M_integer(long __value, const char* __name = 0) const\n+    _Error_formatter&\n+    _M_integer(long __value, const char* __name = 0)\n     {\n-      if (_M_num_parameters < std::size_t(__max_parameters))\n+      if (_M_num_parameters < __max_parameters)\n \t_M_parameters[_M_num_parameters++] = _Parameter(__value, __name);\n       return *this;\n     }\n \n-    const _Error_formatter&\n-    _M_string(const char* __value, const char* __name = 0) const\n+    _Error_formatter&\n+    _M_string(const char* __value, const char* __name = 0)\n     {\n-      if (_M_num_parameters < std::size_t(__max_parameters))\n+      if (_M_num_parameters < __max_parameters)\n \t_M_parameters[_M_num_parameters++] = _Parameter(__value, __name);\n       return *this;\n     }\n \n     template<typename _Sequence>\n-      const _Error_formatter&\n-      _M_sequence(const _Sequence& __seq, const char* __name = 0) const\n+      _Error_formatter&\n+      _M_sequence(const _Sequence& __seq, const char* __name = 0)\n       {\n-\tif (_M_num_parameters < std::size_t(__max_parameters))\n+\tif (_M_num_parameters < __max_parameters)\n \t  _M_parameters[_M_num_parameters++] = _Parameter(__seq, __name,\n \t\t\t\t\t\t\t  _Is_sequence());\n \treturn *this;\n       }\n \n     template<typename _Type>\n-      const _Error_formatter&\n-      _M_instance(const _Type& __inst, const char* __name = 0) const\n+      _Error_formatter&\n+      _M_instance(const _Type& __inst, const char* __name = 0)\n       {\n-\tif (_M_num_parameters < std::size_t(__max_parameters))\n+\tif (_M_num_parameters < __max_parameters)\n \t  _M_parameters[_M_num_parameters++] = _Parameter(__inst, __name,\n \t\t\t\t\t\t\t  _Is_instance());\n \treturn *this;\n       }\n \n-    const _Error_formatter&\n-    _M_message(const char* __text) const\n+    _Error_formatter&\n+    _M_message(const char* __text)\n     { _M_text = __text; return *this; }\n \n-    const _Error_formatter&\n+    // Kept const qualifier for backward compatibility, to keep the same\n+    // exported symbol.\n+    _Error_formatter&\n     _M_message(_Debug_msg_id __id) const throw ();\n \n     _GLIBCXX_NORETURN void\n     _M_error() const;\n \n     template<typename _Tp>\n       void\n-      _M_format_word(char*, int, const char*, _Tp) const throw ();\n+      _M_format_word(char*, int, const char*, _Tp)\n+      const throw () _GLIBCXX_DEPRECATED;\n \n     void\n-    _M_print_word(const char* __word) const;\n+    _M_print_word(const char* __word) const _GLIBCXX_DEPRECATED;\n \n     void\n-    _M_print_string(const char* __string) const;\n+    _M_print_string(const char* __string) const _GLIBCXX_DEPRECATED;\n \n   private:\n-    _Error_formatter(const char* __file, std::size_t __line)\n-    : _M_file(__file), _M_line(__line), _M_num_parameters(0), _M_text(0),\n-      _M_max_length(78), _M_column(1), _M_first_line(true), _M_wordwrap(false)\n-    { _M_get_max_length(); }\n+    _Error_formatter(const char* __file, unsigned int __line)\n+    : _M_file(__file), _M_line(__line), _M_num_parameters(0), _M_text(0)\n+    { }\n \n     void\n-    _M_get_max_length() const throw ();\n+    _M_get_max_length() const throw () _GLIBCXX_DEPRECATED;\n \n     enum { __max_parameters = 9 };\n \n     const char*\t\t_M_file;\n-    std::size_t\t\t_M_line;\n-    mutable _Parameter\t_M_parameters[__max_parameters];\n-    mutable std::size_t\t_M_num_parameters;\n-    mutable const char*\t_M_text;\n-    mutable std::size_t\t_M_max_length;\n-    enum { _M_indent = 4 } ;\n-    mutable std::size_t\t_M_column;\n-    mutable bool\t_M_first_line;\n-    mutable bool\t_M_wordwrap;\n+    unsigned int\t_M_line;\n+    _Parameter\t\t_M_parameters[__max_parameters];\n+    unsigned int\t_M_num_parameters;\n+    const char*\t\t_M_text;\n \n   public:\n-    static _Error_formatter\n-    _M_at(const char* __file, std::size_t __line)\n-    { return _Error_formatter(__file, __line); }\n+    static _Error_formatter&\n+    _M_at(const char* __file, unsigned int __line)\n+    {\n+      static _Error_formatter __formatter(__file, __line);\n+      return __formatter;\n+    }\n   };\n } // namespace __gnu_debug\n "}, {"sha": "ae56c30273ff71b4faa406b147bd86e8c92d9a3b", "filename": "libstdc++-v3/src/c++11/debug.cc", "status": "modified", "additions": 448, "deletions": 386, "changes": 834, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/814e52ca21449a17004b9c55cbae0fe01ea720c3/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/814e52ca21449a17004b9c55cbae0fe01ea720c3/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fdebug.cc?ref=814e52ca21449a17004b9c55cbae0fe01ea720c3", "patch": "@@ -22,18 +22,19 @@\n // see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n // <http://www.gnu.org/licenses/>.\n \n-#include <debug/debug.h>\n+#include <bits/move.h>\n+#include <bits/stl_iterator_base_types.h>\n+\n+#include <debug/formatter.h>\n #include <debug/safe_base.h>\n #include <debug/safe_unordered_base.h>\n #include <debug/safe_iterator.h>\n #include <debug/safe_local_iterator.h>\n-#include <algorithm>\n+\n #include <cassert>\n-#include <cstring>\n-#include <cctype>\n-#include <cstdio>\n-#include <cstdlib>\n-#include <functional>\n+\n+#include <algorithm> // for std::min\n+#include <functional> // for _Hash_impl\n \n #include <cxxabi.h> // for __cxa_demangle\n \n@@ -524,339 +525,533 @@ namespace __gnu_debug\n \n namespace\n {\n+  using _Error_formatter = __gnu_debug::_Error_formatter;\n+  using _Parameter = __gnu_debug::_Error_formatter::_Parameter;\n+\n+  template<typename _Tp>\n+    int\n+    format_word(char* buf, int n, const char* fmt, _Tp s)\n+    { return std::min(__builtin_snprintf(buf, n, fmt, s), n - 1); }\n+\n   void\n-  print_type(const __gnu_debug::_Error_formatter* __formatter,\n-\t     const type_info* __info,\n-\t     const char* __unknown_name)\n+  get_max_length(std::size_t& max_length)\n   {\n-    if (!__info)\n-      __formatter->_M_print_word(__unknown_name);\n-    else\n+    const char* nptr = std::getenv(\"GLIBCXX_DEBUG_MESSAGE_LENGTH\");\n+    if (nptr)\n       {\n-\tint __status;\n-\tchar* __demangled_name =\n-\t  __cxxabiv1::__cxa_demangle(__info->name(), NULL, NULL, &__status);\n-\t__formatter->_M_print_word(__status == 0\n-\t\t\t\t   ? __demangled_name : __info->name());\n-\tfree(__demangled_name);\n+\tchar* endptr;\n+\tconst unsigned long ret = std::strtoul(nptr, &endptr, 0);\n+\tif (*nptr != '\\0' && *endptr == '\\0')\n+\t  max_length = ret;\n       }\n   }\n \n-  bool\n-  print_field(\n-    const __gnu_debug::_Error_formatter* __formatter,\n-    const char* __name,\n-    const __gnu_debug::_Error_formatter::_Parameter::_Type& __variant)\n+  struct PrintContext\n   {\n-    if (strcmp(__name, \"name\") == 0)\n-      {\n-\tassert(__variant._M_name);\n-\t__formatter->_M_print_word(__variant._M_name);\n-      }\n-    else if (strcmp(__name, \"type\") == 0)\n-      print_type(__formatter, __variant._M_type, \"<unknown type>\");\n-    else\n-      return false;\n-\n-    return true;\n-  }\n+    PrintContext()\n+      : _M_max_length(78), _M_column(1), _M_first_line(true), _M_wordwrap(false)\n+    { get_max_length(_M_max_length); }\n+\n+    std::size_t\t_M_max_length;\n+    enum { _M_indent = 4 } ;\n+    std::size_t\t_M_column;\n+    bool\t_M_first_line;\n+    bool\t_M_wordwrap;\n+  };\n \n-  bool\n-  print_field(\n-    const __gnu_debug::_Error_formatter* __formatter,\n-    const char* __name,\n-    const __gnu_debug::_Error_formatter::_Parameter::_Instance& __variant)\n+  void\n+  print_word(PrintContext& ctx, const char* word,\n+\t     std::ptrdiff_t count = -1)\n   {\n-    const __gnu_debug::_Error_formatter::_Parameter::_Type& __type = __variant;\n-    if (print_field(__formatter, __name, __type))\n-      { }\n-    else if (strcmp(__name, \"address\") == 0)\n+    size_t length = count >= 0 ? count : __builtin_strlen(word);\n+    if (length == 0)\n+      return;\n+\n+    // Consider first '\\n' at begining cause it impacts column.\n+    if (word[0] == '\\n')\n       {\n-\tconst int __bufsize = 64;\n-\tchar __buf[__bufsize];\n-\t__formatter->_M_format_word(__buf, __bufsize, \"%p\",\n-\t\t\t\t    __variant._M_address);\n-\t__formatter->_M_print_word(__buf);\n-      }\n-    else\n-      return false;\n+\tfprintf(stderr, \"\\n\");\n+\tctx._M_column = 1;\n+\t++word;\n+\t--length;\n \n-    return true;\n-  }\n+\tif (length == 0)\n+\t  return;\n+      }\n \n-  void\n-  print_description(\n-\tconst __gnu_debug::_Error_formatter* __formatter,\n-\tconst __gnu_debug::_Error_formatter::_Parameter::_Type& __variant)\n-  {\n-    if (__variant._M_name)\n+    size_t visual_length\n+      = isspace(word[length - 1]) ? length - 1 : length;\n+    if (visual_length == 0\n+\t|| !ctx._M_wordwrap\n+\t|| (ctx._M_column + visual_length < ctx._M_max_length)\n+\t|| (visual_length >= ctx._M_max_length && ctx._M_column == 1))\n       {\n-\tconst int __bufsize = 64;\n-\tchar __buf[__bufsize];\n-\t__formatter->_M_format_word(__buf, __bufsize, \"\\\"%s\\\"\",\n-\t\t\t\t    __variant._M_name);\n-\t__formatter->_M_print_word(__buf);\n-      }\n+\t// If this isn't the first line, indent\n+\tif (ctx._M_column == 1 && !ctx._M_first_line)\n+\t  {\n+\t    char spacing[ctx._M_indent + 1];\n+\t    for (int i = 0; i < ctx._M_indent; ++i)\n+\t      spacing[i] = ' ';\n+\t    spacing[ctx._M_indent] = '\\0';\n+\t    fprintf(stderr, \"%s\", spacing);\n+\t    ctx._M_column += ctx._M_indent;\n+\t  }\n \n-    __formatter->_M_print_word(\" {\\n\");\n+\tint written = fprintf(stderr, \"%s\", word);\n \n-    if (__variant._M_type)\n+\tif (word[length - 1] == '\\n')\n+\t  {\n+\t    ctx._M_first_line = false;\n+\t    ctx._M_column = 1;\n+\t  }\n+\telse\n+\t  ctx._M_column += written;\n+      }\n+    else\n       {\n-\t__formatter->_M_print_word(\"  type = \");\n-\tprint_type(__formatter, __variant._M_type, \"<unknown type>\");\n-\t__formatter->_M_print_word(\";\\n\");\n+\tprint_word(ctx, \"\\n\", 1);\n+\tprint_word(ctx, word, count);\n       }\n   }\n \n-\n   void\n-  print_description(\n-\tconst __gnu_debug::_Error_formatter* __formatter,\n-\tconst __gnu_debug::_Error_formatter::_Parameter::_Instance& __variant)\n+  print_type(PrintContext& ctx,\n+\t     const type_info* info,\n+\t     const char* unknown_name)\n   {\n-    const int __bufsize = 64;\n-    char __buf[__bufsize];\n+    if (!info)\n+      print_word(ctx, unknown_name);\n+    else\n+      {\n+\tint status;\n+\tchar* demangled_name =\n+\t  __cxxabiv1::__cxa_demangle(info->name(), NULL, NULL, &status);\n+\tprint_word(ctx, status == 0 ? demangled_name : info->name());\n+\tfree(demangled_name);\n+      }\n+  }\n \n-    if (__variant._M_name)\n+  bool\n+  print_field(PrintContext& ctx,\n+\t      const char* name, const _Parameter::_Type& type)\n+  {\n+    if (__builtin_strcmp(name, \"name\") == 0)\n       {\n-\t__formatter->_M_format_word(__buf, __bufsize, \"\\\"%s\\\" \",\n-\t\t\t\t    __variant._M_name);\n-\t__formatter->_M_print_word(__buf);\n+\tassert(type._M_name);\n+\tprint_word(ctx, type._M_name);\n       }\n+    else if (__builtin_strcmp(name, \"type\") == 0)\n+      print_type(ctx, type._M_type, \"<unknown type>\");\n+    else\n+      return false;\n \n-    __formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p {\\n\",\n-\t\t\t\t__variant._M_address);\n-    __formatter->_M_print_word(__buf);\n+    return true;\n+  }\n \n-    if (__variant._M_type)\n+  bool\n+  print_field(PrintContext& ctx,\n+\t      const char* name, const _Parameter::_Instance& inst)\n+  {\n+    const _Parameter::_Type& type = inst;\n+    if (print_field(ctx, name, type))\n+      { }\n+    else if (__builtin_strcmp(name, \"address\") == 0)\n       {\n-\t__formatter->_M_print_word(\"  type = \");\n-\tprint_type(__formatter, __variant._M_type, \"<unknown type>\");\n+\tchar buf[64];\n+\tint ret = __builtin_sprintf(buf, \"%p\", inst._M_address);\n+\tprint_word(ctx, buf, ret);\n       }\n+    else\n+      return false;\n+\n+    return true;\n   }\n-}\n \n-namespace __gnu_debug\n-{\n   void\n-  _Error_formatter::_Parameter::\n-  _M_print_field(const _Error_formatter* __formatter, const char* __name) const\n+  print_field(PrintContext& ctx, const _Parameter& param, const char* name)\n   {\n-    assert(this->_M_kind != _Parameter::__unused_param);\n-    const int __bufsize = 64;\n-    char __buf[__bufsize];\n+    assert(param._M_kind != _Parameter::__unused_param);\n+    const int bufsize = 64;\n+    char buf[bufsize];\n \n-    switch (_M_kind)\n+    const auto& variant = param._M_variant;\n+    switch (param._M_kind)\n     {\n-    case __iterator:\n-      if (print_field(__formatter, __name, _M_variant._M_iterator))\n-\t{ }\n-      else if (strcmp(__name, \"constness\") == 0)\n-\t{\n-\t  static const char* __constness_names[__last_constness] =\n-\t    {\n-\t      \"<unknown>\",\n-\t      \"constant\",\n-\t      \"mutable\"\n-\t    };\n-\t  __formatter->_M_print_word(__constness_names[_M_variant.\n-\t\t\t\t\t\t       _M_iterator.\n-\t\t\t\t\t\t       _M_constness]);\n-\t}\n-      else if (strcmp(__name, \"state\") == 0)\n-\t{\n-\t  static const char* __state_names[__last_state] =\n-\t    {\n-\t      \"<unknown>\",\n-\t      \"singular\",\n-\t      \"dereferenceable (start-of-sequence)\",\n-\t      \"dereferenceable\",\n-\t      \"past-the-end\",\n-\t      \"before-begin\"\n-\t    };\n-\t  __formatter->_M_print_word(__state_names[_M_variant.\n-\t\t\t\t\t\t   _M_iterator._M_state]);\n-\t}\n-      else if (strcmp(__name, \"sequence\") == 0)\n-\t{\n-\t  assert(_M_variant._M_iterator._M_sequence);\n-\t  __formatter->_M_format_word(__buf, __bufsize, \"%p\",\n-\t\t\t\t      _M_variant._M_iterator._M_sequence);\n-\t  __formatter->_M_print_word(__buf);\n-\t}\n-      else if (strcmp(__name, \"seq_type\") == 0)\n-\tprint_type(__formatter, _M_variant._M_iterator._M_seq_type,\n-\t\t   \"<unknown seq_type>\");\n-      else\n-\tassert(false);\n+    case _Parameter::__iterator:\n+      {\n+\tconst auto& iterator = variant._M_iterator;\n+\tif (print_field(ctx, name, iterator))\n+\t  { }\n+\telse if (__builtin_strcmp(name, \"constness\") == 0)\n+\t  {\n+\t    static const char*\n+\t      constness_names[_Error_formatter::__last_constness] =\n+\t      {\n+\t\t\"<unknown>\",\n+\t\t\"constant\",\n+\t\t\"mutable\"\n+\t      };\n+\t    print_word(ctx, constness_names[iterator._M_constness]);\n+\t  }\n+\telse if (__builtin_strcmp(name, \"state\") == 0)\n+\t  {\n+\t    static const char*\n+\t      state_names[_Error_formatter::__last_state] =\n+\t      {\n+\t\t\"<unknown>\",\n+\t\t\"singular\",\n+\t\t\"dereferenceable (start-of-sequence)\",\n+\t\t\"dereferenceable\",\n+\t\t\"past-the-end\",\n+\t\t\"before-begin\"\n+\t      };\n+\t    print_word(ctx, state_names[iterator._M_state]);\n+\t  }\n+\telse if (__builtin_strcmp(name, \"sequence\") == 0)\n+\t  {\n+\t    assert(iterator._M_sequence);\n+\t    int written = __builtin_sprintf(buf, \"%p\", iterator._M_sequence);\n+\t    print_word(ctx, buf, written);\n+\t  }\n+\telse if (__builtin_strcmp(name, \"seq_type\") == 0)\n+\t  print_type(ctx, iterator._M_seq_type, \"<unknown seq_type>\");\n+\telse\n+\t  assert(false);\n+      }\n       break;\n-    case __sequence:\n-      if (!print_field(__formatter, __name, _M_variant._M_sequence))\n+\n+    case _Parameter::__sequence:\n+      if (!print_field(ctx, name, variant._M_sequence))\n \tassert(false);\n       break;\n-    case __integer:\n-      if (strcmp(__name, \"name\") == 0)\n+\n+    case _Parameter::__integer:\n+      if (__builtin_strcmp(name, \"name\") == 0)\n \t{\n-\t  assert(_M_variant._M_integer._M_name);\n-\t  __formatter->_M_print_word(_M_variant._M_integer._M_name);\n+\t  assert(variant._M_integer._M_name);\n+\t  print_word(ctx, variant._M_integer._M_name);\n \t}\n       else\n \tassert(false);\n       break;\n-    case __string:\n-      if (strcmp(__name, \"name\") == 0)\n+\n+    case _Parameter::__string:\n+      if (__builtin_strcmp(name, \"name\") == 0)\n \t{\n-\t  assert(_M_variant._M_string._M_name);\n-\t  __formatter->_M_print_word(_M_variant._M_string._M_name);\n+\t  assert(variant._M_string._M_name);\n+\t  print_word(ctx, variant._M_string._M_name);\n \t}\n       else\n \tassert(false);\n       break;\n-    case __instance:\n-      if (!print_field(__formatter, __name, _M_variant._M_instance))\n+\n+    case _Parameter::__instance:\n+      if (!print_field(ctx, name, variant._M_instance))\n \tassert(false);\n       break;\n-    case __iterator_value_type:\n-      if (!print_field(__formatter, __name, _M_variant._M_iterator_value_type))\n+\n+    case _Parameter::__iterator_value_type:\n+      if (!print_field(ctx, name, variant._M_iterator_value_type))\n \tassert(false);\n       break;\n+\n     default:\n       assert(false);\n       break;\n     }\n   }\n \n   void\n-  _Error_formatter::_Parameter::\n-  _M_print_description(const _Error_formatter* __formatter) const\n+  print_description(PrintContext& ctx, const _Parameter::_Type& type)\n+  {\n+    if (type._M_name)\n+      {\n+\tconst int bufsize = 64;\n+\tchar buf[bufsize];\n+\tint written\n+\t  = format_word(buf, bufsize, \"\\\"%s\\\"\", type._M_name);\n+\tprint_word(ctx, buf, written);\n+      }\n+\n+    print_word(ctx, \" {\\n\");\n+\n+    if (type._M_type)\n+      {\n+\tprint_word(ctx, \"  type = \");\n+\tprint_type(ctx, type._M_type, \"<unknown type>\");\n+\tprint_word(ctx, \";\\n\");\n+      }\n+  }\n+\n+  void\n+  print_description(PrintContext& ctx, const _Parameter::_Instance& inst)\n   {\n-    const int __bufsize = 128;\n-    char __buf[__bufsize];\n+    const int bufsize = 64;\n+    char buf[bufsize];\n \n-    switch (_M_kind)\n+    if (inst._M_name)\n       {\n-      case __iterator:\n-\t__formatter->_M_print_word(\"iterator \");\n-\tprint_description(__formatter, _M_variant._M_iterator);\n+\tint written\n+\t  = format_word(buf, bufsize, \"\\\"%s\\\" \", inst._M_name);\n+\tprint_word(ctx, buf, written);\n+      }\n \n-\tif (_M_variant._M_iterator._M_type)\n-\t  {\n-\t    if (_M_variant._M_iterator._M_constness != __unknown_constness)\n-\t      {\n-\t\t__formatter->_M_print_word(\" (\");\n-\t\t_M_print_field(__formatter, \"constness\");\n-\t\t__formatter->_M_print_word(\" iterator)\");\n-\t      }\n-\t    __formatter->_M_print_word(\";\\n\");\n-\t  }\n+    int written\n+      = __builtin_sprintf(buf, \"@ 0x%p {\\n\", inst._M_address);\n+    print_word(ctx, buf, written);\n \n-\tif (_M_variant._M_iterator._M_state != __unknown_state)\n-\t  {\n-\t    __formatter->_M_print_word(\"  state = \");\n-\t    _M_print_field(__formatter, \"state\");\n-\t    __formatter->_M_print_word(\";\\n\");\n-\t  }\n+    if (inst._M_type)\n+      {\n+\tprint_word(ctx, \"  type = \");\n+\tprint_type(ctx, inst._M_type, \"<unknown type>\");\n+      }\n+  }\n \n-\tif (_M_variant._M_iterator._M_sequence)\n-\t  {\n-\t    __formatter->_M_print_word(\"  references sequence \");\n-\t    if (_M_variant._M_iterator._M_seq_type)\n-\t      {\n-\t\t__formatter->_M_print_word(\"with type `\");\n-\t\t_M_print_field(__formatter, \"seq_type\");\n-\t\t__formatter->_M_print_word(\"' \");\n-\t      }\n+  void\n+  print_description(PrintContext& ctx, const _Parameter& param)\n+  {\n+    const int bufsize = 128;\n+    char buf[bufsize];\n \n-\t    __formatter->_M_format_word(__buf, __bufsize, \"@ 0x%p\\n\",\n-\t\t\t\t\t_M_variant._M_iterator._M_sequence);\n-\t    __formatter->_M_print_word(__buf);\n-\t  }\n+    const auto& variant = param._M_variant;\n+    switch (param._M_kind)\n+      {\n+      case _Parameter::__iterator:\n+\t{\n+\t  const auto& ite = variant._M_iterator;\n+\n+\t  print_word(ctx, \"iterator \");\n+\t  print_description(ctx, ite);\n \n-\t__formatter->_M_print_word(\"}\\n\");\n+\t  if (ite._M_type)\n+\t    {\n+\t      if (ite._M_constness != _Error_formatter::__unknown_constness)\n+\t\t{\n+\t\t  print_word(ctx, \" (\");\n+\t\t  print_field(ctx, param, \"constness\");\n+\t\t  print_word(ctx, \" iterator)\");\n+\t\t}\n+\n+\t      print_word(ctx, \";\\n\");\n+\t    }\n+\n+\t  if (ite._M_state != _Error_formatter::__unknown_state)\n+\t    {\n+\t      print_word(ctx, \"  state = \");\n+\t      print_field(ctx, param, \"state\");\n+\t      print_word(ctx, \";\\n\");\n+\t    }\n+\n+\t  if (ite._M_sequence)\n+\t    {\n+\t      print_word(ctx, \"  references sequence \");\n+\t      if (ite._M_seq_type)\n+\t\t{\n+\t\t  print_word(ctx, \"with type '\");\n+\t\t  print_field(ctx, param, \"seq_type\");\n+\t\t  print_word(ctx, \"' \");\n+\t\t}\n+\n+\t      int written\n+\t\t= __builtin_sprintf(buf, \"@ 0x%p\\n\", ite._M_sequence);\n+\t      print_word(ctx, buf, written);\n+\t    }\n+\n+\t  print_word(ctx, \"}\\n\", 2);\n+\t}\n \tbreak;\n-      case __sequence:\n-\t__formatter->_M_print_word(\"sequence \");\n-\tprint_description(__formatter, _M_variant._M_sequence);\n \n-\tif (_M_variant._M_sequence._M_type)\n-\t  __formatter->_M_print_word(\";\\n\");\n+      case _Parameter::__sequence:\n+\tprint_word(ctx, \"sequence \");\n+\tprint_description(ctx, variant._M_sequence);\n \n-\t__formatter->_M_print_word(\"}\\n\");\n+\tif (variant._M_sequence._M_type)\n+\t  print_word(ctx, \";\\n\", 2);\n+\n+\tprint_word(ctx, \"}\\n\", 2);\n \tbreak;\n-      case __instance:\n-\t__formatter->_M_print_word(\"instance \");\n-\tprint_description(__formatter, _M_variant._M_instance);\n \n-\tif (_M_variant._M_instance._M_type)\n-\t  __formatter->_M_print_word(\";\\n\");\n+      case _Parameter::__instance:\n+\tprint_word(ctx, \"instance \");\n+\tprint_description(ctx, variant._M_instance);\n+\n+\tif (variant._M_instance._M_type)\n+\t  print_word(ctx, \";\\n\", 2);\n \n-\t__formatter->_M_print_word(\"}\\n\");\n+\tprint_word(ctx, \"}\\n\", 2);\n \tbreak;\n-      case __iterator_value_type:\n-\t__formatter->_M_print_word(\"iterator::value_type \");\n-\tprint_description(__formatter, _M_variant._M_iterator_value_type);\n-\t__formatter->_M_print_word(\"}\\n\");\n+\n+      case _Parameter::__iterator_value_type:\n+\tprint_word(ctx, \"iterator::value_type \");\n+\tprint_description(ctx, variant._M_iterator_value_type);\n+\tprint_word(ctx, \"}\\n\", 2);\n \tbreak;\n+\n       default:\n \tbreak;\n       }\n   }\n \n-  const _Error_formatter&\n+  void\n+  print_string(PrintContext& ctx, const char* string,\n+\t       const _Parameter* parameters, std::size_t num_parameters)\n+  {\n+    const char* start = string;\n+    const int bufsize = 128;\n+    char buf[bufsize];\n+    int bufindex = 0;\n+\n+    while (*start)\n+      {\n+\tif (isspace(*start))\n+\t  {\n+\t    buf[bufindex++] = *start++;\n+\t    buf[bufindex] = '\\0';\n+\t    print_word(ctx, buf, bufindex);\n+\t    bufindex = 0;\n+\t    continue;\n+\t  }\n+\n+\tif (*start != '%')\n+\t  {\n+\t    // Normal char.\n+\t    buf[bufindex++] = *start++;\n+\t    continue;\n+\t  }\n+\n+\tif (*++start == '%')\n+\t  {\n+\t    // Escaped '%'\n+\t    buf[bufindex++] = *start++;\n+\t    continue;\n+\t  }\n+\n+\t// We are on a parameter property reference, we need to flush buffer\n+\t// first.\n+\tif (bufindex != 0)\n+\t  {\n+\t    buf[bufindex] = '\\0';\n+\t    print_word(ctx, buf, bufindex);\n+\t    bufindex = 0;\n+\t  }\n+\n+\t// Get the parameter number\n+\tassert(*start >= '1' && *start <= '9');\n+\tsize_t param_index = *start - '0' - 1;\n+\tassert(param_index < num_parameters);\n+\tconst auto& param = parameters[param_index];\n+\n+\t// '.' separates the parameter number from the field\n+\t// name, if there is one.\n+\t++start;\n+\tif (*start != '.')\n+\t  {\n+\t    assert(*start == ';');\n+\t    ++start;\n+\t    if (param._M_kind == _Parameter::__integer)\n+\t      {\n+\t\tint written\n+\t\t  = __builtin_sprintf(buf, \"%ld\",\n+\t\t\t\t      param._M_variant._M_integer._M_value);\n+\t\tprint_word(ctx, buf, written);\n+\t      }\n+\t    else if (param._M_kind == _Parameter::__string)\n+\t      print_string(ctx, param._M_variant._M_string._M_value,\n+\t\t\t   parameters, num_parameters);\n+\t    continue;\n+\t  }\n+\n+\t// Extract the field name we want\n+\tconst int max_field_len = 16;\n+\tchar field[max_field_len];\n+\tint field_idx = 0;\n+\t++start;\n+\twhile (*start != ';')\n+\t  {\n+\t    assert(*start);\n+\t    assert(field_idx < max_field_len - 1);\n+\t    field[field_idx++] = *start++;\n+\t  }\n+\t++start;\n+\tfield[field_idx] = '\\0';\n+\n+\tprint_field(ctx, param, field);\n+      }\n+\n+    // Might need to flush.\n+    if (bufindex)\n+      {\n+\tbuf[bufindex] = '\\0';\n+\tprint_word(ctx, buf, bufindex);\n+      }\n+  }\n+}\n+\n+namespace __gnu_debug\n+{\n+  _Error_formatter&\n   _Error_formatter::_M_message(_Debug_msg_id __id) const throw ()\n-  { return this->_M_message(_S_debug_messages[__id]); }\n+  {\n+    return const_cast<_Error_formatter*>(this)\n+      ->_M_message(_S_debug_messages[__id]);\n+  }\n \n   void\n   _Error_formatter::_M_error() const\n   {\n-    const int __bufsize = 128;\n-    char __buf[__bufsize];\n+    const int bufsize = 128;\n+    char buf[bufsize];\n \n     // Emit file & line number information\n-    _M_column = 1;\n-    _M_wordwrap = false;\n+    bool go_to_next_line = false;\n+    PrintContext ctx;\n     if (_M_file)\n       {\n-\t_M_format_word(__buf, __bufsize, \"%s:\", _M_file);\n-\t_M_print_word(__buf);\n-\t_M_column += strlen(__buf);\n+\tint written = format_word(buf, bufsize, \"%s:\", _M_file);\n+\tprint_word(ctx, buf, written);\n+\tgo_to_next_line = true;\n       }\n \n     if (_M_line > 0)\n       {\n-\t_M_format_word(__buf, __bufsize, \"%u:\", _M_line);\n-\t_M_print_word(__buf);\n-\t_M_column += strlen(__buf);\n+\tint written = __builtin_sprintf(buf, \"%u:\", _M_line);\n+\tprint_word(ctx, buf, written);\n+\tgo_to_next_line = true;\n       }\n \n-    if (_M_max_length)\n-      _M_wordwrap = true;\n-    _M_print_word(\"error: \");\n+    if (go_to_next_line)\n+      print_word(ctx, \"\\n\", 1);\n+\n+    if (ctx._M_max_length)\n+      ctx._M_wordwrap = true;\n+\n+    print_word(ctx, \"Error: \");\n \n     // Print the error message\n     assert(_M_text);\n-    _M_print_string(_M_text);\n-    _M_print_word(\".\\n\");\n+    print_string(ctx, _M_text, _M_parameters, _M_num_parameters);\n+    print_word(ctx, \".\\n\", 2);\n \n     // Emit descriptions of the objects involved in the operation\n-    _M_wordwrap = false;\n-    bool __has_noninteger_parameters = false;\n-    for (unsigned int __i = 0; __i < _M_num_parameters; ++__i)\n+    ctx._M_first_line = true;\n+    ctx._M_wordwrap = false;\n+    bool has_header = false;\n+    for (unsigned int i = 0; i < _M_num_parameters; ++i)\n       {\n-\tswitch (_M_parameters[__i]._M_kind)\n+\tswitch (_M_parameters[i]._M_kind)\n \t  {\n \t  case _Parameter::__iterator:\n \t  case _Parameter::__sequence:\n \t  case _Parameter::__instance:\n \t  case _Parameter::__iterator_value_type:\n-\t    if (!__has_noninteger_parameters)\n+\t    if (!has_header)\n \t      {\n-\t\t_M_first_line = true;\n-\t\t_M_print_word(\"\\nObjects involved in the operation:\\n\");\n-\t\t__has_noninteger_parameters = true;\n+\t\tprint_word(ctx, \"\\nObjects involved in the operation:\\n\");\n+\t\thas_header = true;\n \t      }\n-\t    _M_parameters[__i]._M_print_description(this);\n+\t    print_description(ctx, _M_parameters[i]);\n \t    break;\n+\n \t  default:\n \t    break;\n \t  }\n@@ -865,172 +1060,39 @@ namespace __gnu_debug\n     abort();\n   }\n \n-  template<typename _Tp>\n-    void\n-    _Error_formatter::_M_format_word(char* __buf,\n-\t\t\t\t     int __n __attribute__ ((__unused__)),\n-\t\t\t\t     const char* __fmt, _Tp __s) const throw ()\n-    {\n-#ifdef _GLIBCXX_USE_C99\n-      std::snprintf(__buf, __n, __fmt, __s);\n-#else\n-      std::sprintf(__buf, __fmt, __s);\n-#endif\n-    }\n-\n+  // Deprecated methods kept for backward compatibility.\n   void\n-  _Error_formatter::_M_print_word(const char* __word) const\n-  {\n-    if (!_M_wordwrap)\n-      {\n-\tfprintf(stderr, \"%s\", __word);\n-\treturn;\n-      }\n-\n-    size_t __length = strlen(__word);\n-    if (__length == 0)\n-      return;\n-\n-    size_t __visual_length\n-      = __word[__length - 1] == '\\n' ? __length - 1 : __length;\n-    if (__visual_length == 0\n-\t|| (_M_column + __visual_length < _M_max_length)\n-\t|| (__visual_length >= _M_max_length && _M_column == 1))\n-      {\n-\t// If this isn't the first line, indent\n-\tif (_M_column == 1 && !_M_first_line)\n-\t  {\n-\t    char __spacing[_M_indent + 1];\n-\t    for (int i = 0; i < _M_indent; ++i)\n-\t      __spacing[i] = ' ';\n-\t    __spacing[_M_indent] = '\\0';\n-\t    fprintf(stderr, \"%s\", __spacing);\n-\t    _M_column += _M_indent;\n-\t  }\n-\n-\tfprintf(stderr, \"%s\", __word);\n-\n-\tif (__word[__length - 1] == '\\n')\n-\t  {\n-\t    _M_first_line = false;\n-\t    _M_column = 1;\n-\t  }\n-\telse\n-\t  _M_column += __length;\n-      }\n-    else\n-      {\n-\t_M_print_word(\"\\n\");\n-\t_M_print_word(__word);\n-      }\n-  }\n+  _Error_formatter::_Parameter::_M_print_field(\n+\tconst _Error_formatter*, const char*) const\n+  { }\n \n   void\n-  _Error_formatter::\n-  _M_print_string(const char* __string) const\n-  {\n-    const char* __start = __string;\n-    const char* __finish = __start;\n-    const int __bufsize = 128;\n-    char __buf[__bufsize];\n+  _Error_formatter::_Parameter::_M_print_description(const _Error_formatter*) const\n+  { }\n \n-    while (*__start)\n-      {\n-\tif (*__start != '%')\n-\t  {\n-\t    // [__start, __finish) denotes the next word\n-\t    __finish = __start;\n-\t    while (isalnum(*__finish))\n-\t      ++__finish;\n-\t    if (__start == __finish)\n-\t      ++__finish;\n-\t    if (isspace(*__finish))\n-\t      ++__finish;\n-\n-\t    const ptrdiff_t __len = __finish - __start;\n-\t    assert(__len < __bufsize);\n-\t    memcpy(__buf, __start, __len);\n-\t    __buf[__len] = '\\0';\n-\t    _M_print_word(__buf);\n-\t    __start = __finish;\n-\n-\t    // Skip extra whitespace\n-\t    while (*__start == ' ')\n-\t      ++__start;\n-\n-\t    continue;\n-\t  }\n-\n-\t++__start;\n-\tassert(*__start);\n-\tif (*__start == '%')\n-\t  {\n-\t    _M_print_word(\"%\");\n-\t    ++__start;\n-\t    continue;\n-\t  }\n-\n-\t// Get the parameter number\n-\tassert(*__start >= '1' && *__start <= '9');\n-\tsize_t __param_index = *__start - '0' - 1;\n-\tassert(__param_index < _M_num_parameters);\n-\tconst auto& __param = _M_parameters[__param_index];\n-\n-\t// '.' separates the parameter number from the field\n-\t// name, if there is one.\n-\t++__start;\n-\tif (*__start != '.')\n-\t  {\n-\t    assert(*__start == ';');\n-\t    ++__start;\n-\t    __buf[0] = '\\0';\n-\t    if (__param._M_kind == _Parameter::__integer)\n-\t      {\n-\t\t_M_format_word(__buf, __bufsize, \"%ld\",\n-\t\t\t       __param._M_variant._M_integer._M_value);\n-\t\t_M_print_word(__buf);\n-\t      }\n-\t    else if (__param._M_kind == _Parameter::__string)\n-\t      _M_print_string(__param._M_variant._M_string._M_value);\n-\t    continue;\n-\t  }\n+  template<typename _Tp>\n+    void\n+    _Error_formatter::_M_format_word(char*, int, const char*, _Tp)\n+    const throw ()\n+    { }\n \n-\t// Extract the field name we want\n-\tenum { __max_field_len = 16 };\n-\tchar __field[__max_field_len];\n-\tint __field_idx = 0;\n-\t++__start;\n-\twhile (*__start != ';')\n-\t  {\n-\t    assert(*__start);\n-\t    assert(__field_idx < __max_field_len-1);\n-\t    __field[__field_idx++] = *__start++;\n-\t  }\n-\t++__start;\n-\t__field[__field_idx] = 0;\n+  void\n+  _Error_formatter::_M_print_word(const char*) const\n+  { }\n \n-\t__param._M_print_field(this, __field);\n-      }\n-  }\n+  void\n+  _Error_formatter::_M_print_string(const char*) const\n+  { }\n \n   void\n   _Error_formatter::_M_get_max_length() const throw ()\n-  {\n-    const char* __nptr = std::getenv(\"GLIBCXX_DEBUG_MESSAGE_LENGTH\");\n-    if (__nptr)\n-      {\n-\tchar* __endptr;\n-\tconst unsigned long __ret = std::strtoul(__nptr, &__endptr, 0);\n-\tif (*__nptr != '\\0' && *__endptr == '\\0')\n-\t  _M_max_length = __ret;\n-      }\n-  }\n+  { }\n \n   // Instantiations.\n   template\n     void\n     _Error_formatter::_M_format_word(char*, int, const char*,\n-\t\t\t\t     const void*) const;\n+                                    const void*) const;\n \n   template\n     void\n@@ -1039,10 +1101,10 @@ namespace __gnu_debug\n   template\n     void\n     _Error_formatter::_M_format_word(char*, int, const char*,\n-\t\t\t\t     std::size_t) const;\n+                                    std::size_t) const;\n \n   template\n     void\n     _Error_formatter::_M_format_word(char*, int, const char*,\n-\t\t\t\t     const char*) const;\n+                                    const char*) const;\n } // namespace __gnu_debug"}]}