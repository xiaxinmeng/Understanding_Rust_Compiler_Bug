{"sha": "9e49570050ef3c92c5ade5430af73f6280177005", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU0OTU3MDA1MGVmM2M5MmM1YWRlNTQzMGFmNzNmNjI4MDE3NzAwNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-09-25T04:02:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-09-25T04:02:20Z"}, "message": "alpha.c (alpha_emit_conditional_branch): Handle TFmode unordered compares properly.\n\n        * config/alpha/alpha.c (alpha_emit_conditional_branch): Handle\n        TFmode unordered compares properly.  Revalidate integer compare\n        operands.\n        (alpha_emit_setcc): New.\n        (alpha_emit_conditional_move): Revalidate integer compare operands.\n        * config/alpha/alpha-protos.h: Update.\n        * config/alpha/alpha.md (cmpdi): Allow general operands.\n        (sne): Use alpha_emit_setcc.\n        (seq, slt, sle, sgt, sge, sltu, sleu, sgtu, sgeu): Likewise.\n        (sunordered, sordered): New.\n\nFrom-SVN: r36598", "tree": {"sha": "f4745a1e1d65b89112431de72816580c6873cabb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f4745a1e1d65b89112431de72816580c6873cabb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e49570050ef3c92c5ade5430af73f6280177005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e49570050ef3c92c5ade5430af73f6280177005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e49570050ef3c92c5ade5430af73f6280177005", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e49570050ef3c92c5ade5430af73f6280177005/comments", "author": null, "committer": null, "parents": [{"sha": "2ed4af6f2d51d7296784159f679fed504795ae9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed4af6f2d51d7296784159f679fed504795ae9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed4af6f2d51d7296784159f679fed504795ae9a"}], "stats": {"total": 274, "additions": 170, "deletions": 104}, "files": [{"sha": "0d8923e6bc90a1910cad7e812f664a91ed8d1022", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e49570050ef3c92c5ade5430af73f6280177005", "patch": "@@ -1,3 +1,16 @@\n+2000-09-24  Richard Henderson  <rth@cygnus.com>\n+\n+\t* config/alpha/alpha.c (alpha_emit_conditional_branch): Handle\n+\tTFmode unordered compares properly.  Revalidate integer compare\n+\toperands.\n+\t(alpha_emit_setcc): New.\n+\t(alpha_emit_conditional_move): Revalidate integer compare operands.\n+\t* config/alpha/alpha-protos.h: Update.\n+\t* config/alpha/alpha.md (cmpdi): Allow general operands.\n+\t(sne): Use alpha_emit_setcc.\n+\t(seq, slt, sle, sgt, sge, sltu, sleu, sgtu, sgeu): Likewise.\n+\t(sunordered, sordered): New.\n+\n 2000-09-24  Richard Henderson  <rth@cygnus.com>\n \n \t* config/ia64/ia64-protos.h: Update."}, {"sha": "d70ac7fe821a9bdc00e84f14dcdfe6321579f52c", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=9e49570050ef3c92c5ade5430af73f6280177005", "patch": "@@ -83,6 +83,7 @@ extern rtx alpha_emit_set_long_const PARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t     HOST_WIDE_INT));\n extern void alpha_emit_floatuns PARAMS ((rtx[]));\n extern rtx alpha_emit_conditional_branch PARAMS ((enum rtx_code));\n+extern rtx alpha_emit_setcc PARAMS ((enum rtx_code));\n extern rtx alpha_emit_conditional_move PARAMS ((rtx, enum machine_mode));\n extern int alpha_split_conditional_move PARAMS ((enum rtx_code, rtx, rtx,\n \t\t\t\t\t\t rtx, rtx));"}, {"sha": "20a494d3ccb152f25fd198371229b97a94c7df3f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 132, "deletions": 9, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=9e49570050ef3c92c5ade5430af73f6280177005", "patch": "@@ -1620,10 +1620,21 @@ alpha_emit_conditional_branch (code)\n \t    1  true\n \t Convert the compare against the raw return value.  */\n \n-      op0 = alpha_emit_xfloating_compare (code, op0, op1);\n+      if (code == UNORDERED || code == ORDERED)\n+\tcmp_code = EQ;\n+      else\n+\tcmp_code = code;\n+\n+      op0 = alpha_emit_xfloating_compare (cmp_code, op0, op1);\n       op1 = const0_rtx;\n       alpha_compare.fp_p = 0;\n-      code = GT;\n+\n+      if (code == UNORDERED)\n+\tcode = LT;\n+      else if (code == ORDERED)\n+\tcode = GE;\n+      else\n+        code = GT;\n     }\n \n   /* The general case: fold the comparison code to the types of compares\n@@ -1713,11 +1724,12 @@ alpha_emit_conditional_branch (code)\n \t\t}\n \t    }\n \t}\n-    }\n \n-  /* Force op0 into a register.  */\n-  if (GET_CODE (op0) != REG)\n-    op0 = force_reg (cmp_mode, op0);\n+      if (!reg_or_0_operand (op0, DImode))\n+\top0 = force_reg (DImode, op0);\n+      if (cmp_code != PLUS && !reg_or_8bit_operand (op1, DImode))\n+\top1 = force_reg (DImode, op1);\n+    }\n \n   /* Emit an initial compare instruction, if necessary.  */\n   tem = op0;\n@@ -1734,6 +1746,111 @@ alpha_emit_conditional_branch (code)\n   return gen_rtx_fmt_ee (branch_code, branch_mode, tem, CONST0_RTX (cmp_mode));\n }\n \n+/* Certain simplifications can be done to make invalid setcc operations\n+   valid.  Return the final comparison, or NULL if we can't work.  */\n+\n+rtx\n+alpha_emit_setcc (code)\n+     enum rtx_code code;\n+{\n+  enum rtx_code cmp_code;\n+  rtx op0 = alpha_compare.op0, op1 = alpha_compare.op1;\n+  int fp_p = alpha_compare.fp_p;\n+  rtx tmp;\n+\n+  /* Zero the operands.  */\n+  memset (&alpha_compare, 0, sizeof (alpha_compare));\n+\n+  if (fp_p && GET_MODE (op0) == TFmode)\n+    {\n+      if (! TARGET_HAS_XFLOATING_LIBS)\n+\tabort ();\n+\n+      /* X_floating library comparison functions return\n+\t   -1  unordered\n+\t    0  false\n+\t    1  true\n+\t Convert the compare against the raw return value.  */\n+\n+      if (code == UNORDERED || code == ORDERED)\n+\tcmp_code = EQ;\n+      else\n+\tcmp_code = code;\n+\n+      op0 = alpha_emit_xfloating_compare (cmp_code, op0, op1);\n+      op1 = const0_rtx;\n+      fp_p = 0;\n+\n+      if (code == UNORDERED)\n+\tcode = LT;\n+      else if (code == ORDERED)\n+\tcode = GE;\n+      else\n+        code = GT;\n+    }\n+\n+  if (fp_p && !TARGET_FIX)\n+    return NULL_RTX;\n+\n+  /* The general case: fold the comparison code to the types of compares\n+     that we have, choosing the branch as necessary.  */\n+\n+  cmp_code = NIL;\n+  switch (code)\n+    {\n+    case EQ:  case LE:  case LT:  case LEU:  case LTU:\n+    case UNORDERED:\n+      /* We have these compares.  */\n+      if (fp_p)\n+\tcmp_code = code, code = NE;\n+      break;\n+\n+    case NE:\n+      if (!fp_p && op1 == const0_rtx)\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case ORDERED:\n+      cmp_code = reverse_condition (code);\n+      code = EQ;\n+      break;\n+\n+    case GE:  case GT: case GEU:  case GTU:\n+      code = swap_condition (code);\n+      if (fp_p)\n+\tcmp_code = code, code = NE;\n+      tmp = op0, op0 = op1, op1 = tmp;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (!fp_p)\n+    {\n+      if (!reg_or_0_operand (op0, DImode))\n+\top0 = force_reg (DImode, op0);\n+      if (!reg_or_8bit_operand (op1, DImode))\n+\top1 = force_reg (DImode, op1);\n+    }\n+\n+  /* Emit an initial compare instruction, if necessary.  */\n+  if (cmp_code != NIL)\n+    {\n+      enum machine_mode mode = fp_p ? DFmode : DImode;\n+\n+      tmp = gen_reg_rtx (mode);\n+      emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t      gen_rtx_fmt_ee (cmp_code, mode, op0, op1)));\n+\n+      op0 = fp_p ? gen_lowpart (DImode, tmp) : tmp;\n+      op1 = const0_rtx;\n+    }\n+\n+  /* Return the setcc comparison.  */\n+  return gen_rtx_fmt_ee (code, DImode, op0, op1);\n+}\n+\n \n /* Rewrite a comparison against zero CMP of the form\n    (CODE (cc0) (const_int 0)) so it can be written validly in\n@@ -1836,17 +1953,23 @@ alpha_emit_conditional_move (cmp, mode)\n       break;\n \n     case GE:  case GT:  case GEU:  case GTU:\n-      /* These must be swapped.  Make sure the new first operand is in\n-\t a register.  */\n+      /* These must be swapped.  */\n       code = swap_condition (code);\n       tem = op0, op0 = op1, op1 = tem;\n-      op0 = force_reg (cmp_mode, op0);\n       break;\n \n     default:\n       abort ();\n     }\n \n+  if (!fp_p)\n+    {\n+      if (!reg_or_0_operand (op0, DImode))\n+\top0 = force_reg (DImode, op0);\n+      if (!reg_or_8bit_operand (op1, DImode))\n+\top1 = force_reg (DImode, op1);\n+    }\n+\n   /* ??? We mark the branch mode to be CCmode to prevent the compare\n      and cmov from being combined, since the compare insn follows IEEE\n      rules that the cmov does not.  */"}, {"sha": "23d0365b5c37604548502b47c4a92bf6a7d3c14c", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 24, "deletions": 95, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e49570050ef3c92c5ade5430af73f6280177005/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=9e49570050ef3c92c5ade5430af73f6280177005", "patch": "@@ -3349,8 +3349,8 @@\n }\")\n \n (define_expand \"cmpdi\"\n-  [(set (cc0) (compare (match_operand:DI 0 \"reg_or_0_operand\" \"\")\n-\t\t       (match_operand:DI 1 \"reg_or_8bit_operand\" \"\")))]\n+  [(set (cc0) (compare (match_operand:DI 0 \"general_operand\" \"\")\n+\t\t       (match_operand:DI 1 \"general_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -3460,144 +3460,73 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_EQ (DImode, alpha_compare.op0, alpha_compare.op1);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (EQ)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sne\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(match_dup 1))\n-   (set (match_dup 0) (xor:DI (match_dup 0) (const_int 1)))]\n+\t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  if (alpha_compare.op1 == const0_rtx)\n-    {\n-      operands[1] = gen_rtx_NE (DImode, alpha_compare.op0, alpha_compare.op1);\n-      alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-  operands[1] = gen_rtx_EQ (DImode, alpha_compare.op0, alpha_compare.op1);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (NE)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"slt\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LT (DImode, alpha_compare.op0, alpha_compare.op1);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (LT)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sle\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LE (DImode, alpha_compare.op0, alpha_compare.op1);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (LE)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sgt\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LT (DImode, force_reg (DImode, alpha_compare.op1),\n-\t\t\t    alpha_compare.op0);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (GT)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sge\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LE (DImode, force_reg (DImode, alpha_compare.op1),\n-\t\t\t    alpha_compare.op0);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (GE)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sltu\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LTU (DImode, alpha_compare.op0, alpha_compare.op1);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (LTU)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sleu\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LEU (DImode, alpha_compare.op0, alpha_compare.op1);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (LEU)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sgtu\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n-\n-  operands[1] = gen_rtx_LTU (DImode, force_reg (DImode, alpha_compare.op1),\n-\t\t\t     alpha_compare.op0);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+  \"{ if ((operands[1] = alpha_emit_setcc (GTU)) == NULL_RTX) FAIL; }\")\n \n (define_expand \"sgeu\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n   \"\"\n-  \"\n-{\n-  if (alpha_compare.fp_p)\n-    FAIL;\n+  \"{ if ((operands[1] = alpha_emit_setcc (GEU)) == NULL_RTX) FAIL; }\")\n \n-  operands[1] = gen_rtx_LEU (DImode, force_reg (DImode, alpha_compare.op1),\n-\t\t\t     alpha_compare.op0);\n-  alpha_compare.op0 = alpha_compare.op1 = NULL_RTX;\n-}\")\n+(define_expand \"sunordered\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"{ if ((operands[1] = alpha_emit_setcc (UNORDERED)) == NULL_RTX) FAIL; }\")\n+\n+(define_expand \"sordered\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"{ if ((operands[1] = alpha_emit_setcc (ORDERED)) == NULL_RTX) FAIL; }\")\n \f\n ;; These are the main define_expand's used to make conditional moves.\n "}]}