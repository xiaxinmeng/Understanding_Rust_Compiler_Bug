{"sha": "84c3c7ce881a20095532baff121d38848efe2a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRjM2M3Y2U4ODFhMjAwOTU1MzJiYWZmMTIxZDM4ODQ4ZWZlMmEwYQ==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2012-09-10T16:23:02Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2012-09-10T16:23:02Z"}, "message": "tree-ssa-forwprop.c (simplify_permutation): Handle CONSTRUCTOR.\n\n2012-09-10  Marc Glisse  <marc.glisse@inria.fr>\n\ngcc/\n        * tree-ssa-forwprop.c (simplify_permutation): Handle CONSTRUCTOR.\n\ngcc/testsuite/\n        * gcc.dg/tree-ssa/forwprop-20.c: New testcase.\n\nFrom-SVN: r191151", "tree": {"sha": "b5ee6578dd0401f986e2af4fc65d080cbb9de3e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5ee6578dd0401f986e2af4fc65d080cbb9de3e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84c3c7ce881a20095532baff121d38848efe2a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c3c7ce881a20095532baff121d38848efe2a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84c3c7ce881a20095532baff121d38848efe2a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84c3c7ce881a20095532baff121d38848efe2a0a/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dfea20f1a4ea6f8296f7e857d9f911474ae278fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfea20f1a4ea6f8296f7e857d9f911474ae278fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfea20f1a4ea6f8296f7e857d9f911474ae278fa"}], "stats": {"total": 173, "additions": 155, "deletions": 18}, "files": [{"sha": "c550f8b61ec5ea26e33f6f6313c04351065fac43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84c3c7ce881a20095532baff121d38848efe2a0a", "patch": "@@ -1,3 +1,7 @@\n+2012-09-10  Marc Glisse  <marc.glisse@inria.fr>\n+\n+        * tree-ssa-forwprop.c (simplify_permutation): Handle CONSTRUCTOR.\n+\n 2012-09-10  Martin Jambor  <mjambor@suse.cz>\n \n \t* params.def (PARAM_IPA_MAX_AGG_ITEMS): New parameter."}, {"sha": "720e7116013c5ff61da7a6e4dc620ee82470d42f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84c3c7ce881a20095532baff121d38848efe2a0a", "patch": "@@ -1,3 +1,7 @@\n+2012-09-10  Marc Glisse  <marc.glisse@inria.fr>\n+\n+        * gcc.dg/tree-ssa/forwprop-20.c: New testcase.\n+\n 2012-09-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/54520"}, {"sha": "5b0e8ee980662838e353cfa1c1390e0ac8c00441", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-20.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-20.c?ref=84c3c7ce881a20095532baff121d38848efe2a0a", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target double64 } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" }  */\n+\n+#include <stdint.h>\n+\n+/* All of these optimizations happen for unsupported vector modes as a\n+   consequence of the lowering pass. We need to test with a vector mode\n+   that is supported by default on at least some architectures, or make\n+   the test target specific so we can pass a flag like -mavx.  */\n+\n+typedef double vecf __attribute__ ((vector_size (2 * sizeof (double))));\n+typedef int64_t veci __attribute__ ((vector_size (2 * sizeof (int64_t))));\n+\n+void f (double d, vecf* r)\n+{\n+  vecf x = { -d, 5 };\n+  vecf y = {  1, 4 };\n+  veci m = {  2, 0 };\n+  *r = __builtin_shuffle (x, y, m); // { 1, -d }\n+}\n+\n+void g (float d, vecf* r)\n+{\n+  vecf x = { d, 5 };\n+  vecf y = { 1, 4 };\n+  veci m = { 2, 1 };\n+  *r = __builtin_shuffle (x, y, m); // { 1, 5 }\n+}\n+\n+void h (double d, vecf* r)\n+{\n+  vecf x = { d + 1, 5 };\n+  vecf y = {   1  , 4 };\n+  veci m = {   2  , 0 };\n+  *r = __builtin_shuffle (y, x, m); // { d + 1, 1 }\n+}\n+\n+void i (float d, vecf* r)\n+{\n+  vecf x = { d, 5 };\n+  veci m = { 1, 0 };\n+  *r = __builtin_shuffle (x, m); // { 5, d }\n+}\n+\n+void j (vecf* r)\n+{\n+  vecf y = {  1, 2 };\n+  veci m = {  0, 0 };\n+  *r = __builtin_shuffle (y, m); // { 1, 1 }\n+}\n+\n+void k (vecf* r)\n+{\n+  vecf x = {  3, 4 };\n+  vecf y = {  1, 2 };\n+  veci m = {  3, 0 };\n+  *r = __builtin_shuffle (x, y, m); // { 2, 3 }\n+}\n+\n+void l (double d, vecf* r)\n+{\n+  vecf x = { -d, 5 };\n+  vecf y = {  d, 4 };\n+  veci m = {  2, 0 };\n+  *r = __builtin_shuffle (x, y, m); // { d, -d }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"VEC_PERM_EXPR\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "72217ecbdd5e31e5b4e1939fa40536f847807540", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 77, "deletions": 18, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84c3c7ce881a20095532baff121d38848efe2a0a/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=84c3c7ce881a20095532baff121d38848efe2a0a", "patch": "@@ -2606,45 +2606,52 @@ is_combined_permutation_identity (tree mask1, tree mask2)\n   return maybe_identity1 ? 1 : maybe_identity2 ? 2 : 0;\n }\n \n-/* Combine two shuffles in a row.  Returns 1 if there were any changes\n-   made, 2 if cfg-cleanup needs to run.  Else it returns 0.  */\n+/* Combine a shuffle with its arguments.  Returns 1 if there were any\n+   changes made, 2 if cfg-cleanup needs to run.  Else it returns 0.  */\n  \n static int\n simplify_permutation (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n   gimple def_stmt;\n-  tree op0, op1, op2, op3;\n-  enum tree_code code = gimple_assign_rhs_code (stmt);\n-  enum tree_code code2;\n+  tree op0, op1, op2, op3, arg0, arg1;\n+  enum tree_code code;\n \n-  gcc_checking_assert (code == VEC_PERM_EXPR);\n+  gcc_checking_assert (gimple_assign_rhs_code (stmt) == VEC_PERM_EXPR);\n \n   op0 = gimple_assign_rhs1 (stmt);\n   op1 = gimple_assign_rhs2 (stmt);\n   op2 = gimple_assign_rhs3 (stmt);\n \n-  if (TREE_CODE (op0) != SSA_NAME)\n-    return 0;\n-\n   if (TREE_CODE (op2) != VECTOR_CST)\n     return 0;\n \n-  if (op0 != op1)\n-    return 0;\n+  if (TREE_CODE (op0) == VECTOR_CST)\n+    {\n+      code = VECTOR_CST;\n+      arg0 = op0;\n+    }\n+  else if (TREE_CODE (op0) == SSA_NAME)\n+    {\n+      def_stmt = SSA_NAME_DEF_STMT (op0);\n+      if (!def_stmt || !is_gimple_assign (def_stmt)\n+\t  || !can_propagate_from (def_stmt))\n+\treturn 0;\n \n-  def_stmt = SSA_NAME_DEF_STMT (op0);\n-  if (!def_stmt || !is_gimple_assign (def_stmt)\n-      || !can_propagate_from (def_stmt))\n+      code = gimple_assign_rhs_code (def_stmt);\n+      arg0 = gimple_assign_rhs1 (def_stmt);\n+    }\n+  else\n     return 0;\n \n-  code2 = gimple_assign_rhs_code (def_stmt);\n-\n   /* Two consecutive shuffles.  */\n-  if (code2 == VEC_PERM_EXPR)\n+  if (code == VEC_PERM_EXPR)\n     {\n       tree orig;\n       int ident;\n+\n+      if (op0 != op1)\n+\treturn 0;\n       op3 = gimple_assign_rhs3 (def_stmt);\n       if (TREE_CODE (op3) != VECTOR_CST)\n \treturn 0;\n@@ -2660,7 +2667,59 @@ simplify_permutation (gimple_stmt_iterator *gsi)\n       return remove_prop_source_from_use (op0) ? 2 : 1;\n     }\n \n-  return false;\n+  /* Shuffle of a constructor.  */\n+  else if (code == CONSTRUCTOR || code == VECTOR_CST)\n+    {\n+      tree opt;\n+      bool ret = false;\n+      if (op0 != op1)\n+\t{\n+\t  if (TREE_CODE (op0) == SSA_NAME && !has_single_use (op0))\n+\t    return 0;\n+\n+\t  if (TREE_CODE (op1) == VECTOR_CST)\n+\t    arg1 = op1;\n+\t  else if (TREE_CODE (op1) == SSA_NAME)\n+\t    {\n+\t      enum tree_code code2;\n+\n+\t      if (!has_single_use (op1))\n+\t\treturn 0;\n+\n+\t      gimple def_stmt2 = SSA_NAME_DEF_STMT (op1);\n+\t      if (!def_stmt2 || !is_gimple_assign (def_stmt2)\n+\t\t  || !can_propagate_from (def_stmt2))\n+\t\treturn 0;\n+\n+\t      code2 = gimple_assign_rhs_code (def_stmt2);\n+\t      if (code2 != CONSTRUCTOR && code2 != VECTOR_CST)\n+\t\treturn 0;\n+\t      arg1 = gimple_assign_rhs1 (def_stmt2);\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else\n+\t{\n+\t  /* Already used twice in this statement.  */\n+\t  if (TREE_CODE (op0) == SSA_NAME && num_imm_uses (op0) > 2)\n+\t    return 0;\n+\t  arg1 = arg0;\n+\t}\n+      opt = fold_ternary (VEC_PERM_EXPR, TREE_TYPE(op0), arg0, arg1, op2);\n+      if (!opt\n+\t  || (TREE_CODE (opt) != CONSTRUCTOR && TREE_CODE(opt) != VECTOR_CST))\n+\treturn 0;\n+      gimple_assign_set_rhs_from_tree (gsi, opt);\n+      update_stmt (gsi_stmt (*gsi));\n+      if (TREE_CODE (op0) == SSA_NAME)\n+\tret = remove_prop_source_from_use (op0);\n+      if (op0 != op1 && TREE_CODE (op1) == SSA_NAME)\n+\tret |= remove_prop_source_from_use (op1);\n+      return ret ? 2 : 1;\n+    }\n+\n+  return 0;\n }\n \n /* Main entry point for the forward propagation and statement combine"}]}