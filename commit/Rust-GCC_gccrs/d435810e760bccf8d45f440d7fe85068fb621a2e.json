{"sha": "d435810e760bccf8d45f440d7fe85068fb621a2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzNTgxMGU3NjBiY2NmOGQ0NWY0NDBkN2ZlODUwNjhmYjYyMWEyZQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2009-12-10T18:03:05Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2009-12-10T18:03:05Z"}, "message": "re PR rtl-optimization/42216 (changes in scheduling regress 464.h264ref 20%)\n\n\tPR rtl-opt/42216\n\t* regrename.c: Error out if MAX_RECOG_OPERANDS is larger than\n\tHOST_BITS_PER_WIDE_INT.\n\t(verify_reg_in_set): New function, broken out of verify_reg_tracked.\n\t(verify_reg_tracked): Use it.\n\t(scan_rtx_reg): When seeing a use involving a superset of the\n\tregisters in an existing chain, enlarge that chain.  Otherwise,\n\tallow subsets and set fail_current_block for all other kinds of\n\toverlap.\n\t(hide_operands): New argument UNTRACKED_OPERANDS; callers changed.\n\tDo not modify operands when the bit with the corresponding number\n\tis set in that bitmap.\n\t(build_def_use): When we see matching operands with different\n\tmodes, don't set fail_current_block, but keep track of such\n\toperands in a bitmap if their registers aren't already tracked\n\tin an open chain.  Pass this bitmap to all hide_operands calls.\n\nFrom-SVN: r155134", "tree": {"sha": "3b8366558ed3afbd3865c46fc4d7d6f3644d04eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b8366558ed3afbd3865c46fc4d7d6f3644d04eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d435810e760bccf8d45f440d7fe85068fb621a2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d435810e760bccf8d45f440d7fe85068fb621a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d435810e760bccf8d45f440d7fe85068fb621a2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d435810e760bccf8d45f440d7fe85068fb621a2e/comments", "author": null, "committer": null, "parents": [{"sha": "574f366488bbe1bf3075735278242a92be85f40b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574f366488bbe1bf3075735278242a92be85f40b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574f366488bbe1bf3075735278242a92be85f40b"}], "stats": {"total": 127, "additions": 94, "deletions": 33}, "files": [{"sha": "2e53db23cd47ca174782b034f9b03dc2e9d23d0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435810e760bccf8d45f440d7fe85068fb621a2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435810e760bccf8d45f440d7fe85068fb621a2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d435810e760bccf8d45f440d7fe85068fb621a2e", "patch": "@@ -1,3 +1,22 @@\n+2009-12-10  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\tPR rtl-opt/42216\n+\t* regrename.c: Error out if MAX_RECOG_OPERANDS is larger than\n+\tHOST_BITS_PER_WIDE_INT.\n+\t(verify_reg_in_set): New function, broken out of verify_reg_tracked.\n+\t(verify_reg_tracked): Use it.\n+\t(scan_rtx_reg): When seeing a use involving a superset of the\n+\tregisters in an existing chain, enlarge that chain.  Otherwise,\n+\tallow subsets and set fail_current_block for all other kinds of\n+\toverlap.\n+\t(hide_operands): New argument UNTRACKED_OPERANDS; callers changed.\n+\tDo not modify operands when the bit with the corresponding number\n+\tis set in that bitmap.\n+\t(build_def_use): When we see matching operands with different\n+\tmodes, don't set fail_current_block, but keep track of such\n+\toperands in a bitmap if their registers aren't already tracked\n+\tin an open chain.  Pass this bitmap to all hide_operands calls.\n+\n 2009-12-10  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/42337"}, {"sha": "e003fd4d34b04cbed56b2d24c3e93b9ba99596d0", "filename": "gcc/regrename.c", "status": "modified", "additions": 75, "deletions": 33, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d435810e760bccf8d45f440d7fe85068fb621a2e/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d435810e760bccf8d45f440d7fe85068fb621a2e/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=d435810e760bccf8d45f440d7fe85068fb621a2e", "patch": "@@ -40,6 +40,10 @@\n #include \"tree-pass.h\"\n #include \"df.h\"\n \n+#if HOST_BITS_PER_WIDE_INT <= MAX_RECOG_OPERANDS\n+#error \"Use a different bitmap implementation for untracked_operands.\"\n+#endif\n+   \n /* We keep linked lists of DU_HEAD structures, each of which describes\n    a chain of occurrences of a reg.  */\n struct du_head\n@@ -434,21 +438,23 @@ static unsigned current_id;\n static struct du_head *open_chains;\n static struct du_head *closed_chains;\n \n-/* Conflict bitmaps, tracking the live chains and the live hard registers.\n-   The bits set in open_chains_set always match the list found in\n+/* Bitmap of open chains.  The bits set always match the list found in\n    open_chains.  */\n static bitmap_head open_chains_set;\n-static HARD_REG_SET live_hard_regs;\n \n-/* Record the registers being tracked in open_chains.  The intersection\n-   between this and live_hard_regs is empty.  */\n+/* Record the registers being tracked in open_chains.  */\n static HARD_REG_SET live_in_chains;\n \n-/* Return true if OP is a reg that is being tracked already in some form.\n-   May set fail_current_block if it sees an unhandled case of overlap.  */\n+/* Record the registers that are live but not tracked.  The intersection\n+   between this and live_in_chains is empty.  */\n+static HARD_REG_SET live_hard_regs;\n+\n+/* Return true if OP is a reg for which all bits are set in PSET, false\n+   if all bits are clear.\n+   In other cases, set fail_current_block and return false.  */\n \n static bool\n-verify_reg_tracked (rtx op)\n+verify_reg_in_set (rtx op, HARD_REG_SET *pset)\n {\n   unsigned regno, nregs;\n   bool all_live, all_dead;\n@@ -459,7 +465,7 @@ verify_reg_tracked (rtx op)\n   nregs = hard_regno_nregs[regno][GET_MODE (op)];\n   all_live = all_dead = true;\n   while (nregs-- > 0)\n-    if (TEST_HARD_REG_BIT (live_hard_regs, regno + nregs))\n+    if (TEST_HARD_REG_BIT (*pset, regno + nregs))\n       all_dead = false;\n     else\n       all_live = false;\n@@ -468,24 +474,17 @@ verify_reg_tracked (rtx op)\n       fail_current_block = true;\n       return false;\n     }\n+  return all_live;\n+}\n \n-  if (all_live)\n-    return true;\n-\n-  nregs = hard_regno_nregs[regno][GET_MODE (op)];\n-  all_live = all_dead = true;\n-  while (nregs-- > 0)\n-    if (TEST_HARD_REG_BIT (live_in_chains, regno + nregs))\n-      all_dead = false;\n-    else\n-      all_live = false;\n-  if (!all_dead && !all_live)\n-    {\n-      fail_current_block = true;\n-      return false;\n-    }\n+/* Return true if OP is a reg that is being tracked already in some form.\n+   May set fail_current_block if it sees an unhandled case of overlap.  */\n \n-  return all_live;\n+static bool\n+verify_reg_tracked (rtx op)\n+{\n+  return (verify_reg_in_set (op, &live_hard_regs)\n+\t  || verify_reg_in_set (op, &live_in_chains));\n }\n \n /* Called through note_stores.  DATA points to a rtx_code, either SET or\n@@ -584,6 +583,8 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t\t\t && head->nregs == this_nregs);\n       int superset = (this_regno <= head->regno\n \t\t      && this_regno + this_nregs >= head->regno + head->nregs);\n+      int subset = (this_regno >= head->regno\n+\t\t      && this_regno + this_nregs <= head->regno + head->nregs);\n \n       if (head->terminated\n \t  || head->regno + head->nregs <= this_regno\n@@ -607,6 +608,25 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t\t\t reg_names[head->regno], head->id, INSN_UID (insn),\n \t\t\t scan_actions_name[(int) action]);\n \t      head->cannot_rename = 1;\n+\t      if (superset)\n+\t\t{\n+\t\t  unsigned nregs = this_nregs;\n+\t\t  head->regno = this_regno;\n+\t\t  head->nregs = this_nregs;\n+\t\t  while (nregs-- > 0)\n+\t\t    SET_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Widening register in chain %s (%d) at insn %d\\n\",\n+\t\t\t     reg_names[head->regno], head->id, INSN_UID (insn));\n+\t\t}\n+\t      else if (!subset)\n+\t\t{\n+\t\t  fail_current_block = true;\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"Failing basic block due to unhandled overlap\\n\");\n+\t\t}\n \t    }\n \t  else\n \t    {\n@@ -919,12 +939,13 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n /* Hide operands of the current insn (of which there are N_OPS) by\n    substituting cc0 for them.\n    Previous values are stored in the OLD_OPERANDS and OLD_DUPS.\n+   For every bit set in DO_NOT_HIDE, we leave the operand alone.\n    If INOUT_AND_EC_ONLY is set, we only do this for OP_INOUT type operands\n    and earlyclobbers.  */\n \n static void\n hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n-\t       bool inout_and_ec_only)\n+\t       unsigned HOST_WIDE_INT do_not_hide, bool inout_and_ec_only)\n {\n   int i;\n   int alt = which_alternative;\n@@ -936,6 +957,8 @@ hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n \t reachable by proper operands.  */\n       if (recog_data.constraints[i][0] == '\\0')\n \tcontinue;\n+      if (do_not_hide & (1 << i))\n+\tcontinue;\n       if (!inout_and_ec_only || recog_data.operand_type[i] == OP_INOUT\n \t  || recog_op_alt[i][alt].earlyclobber)\n \t*recog_data.operand_loc[i] = cc0_rtx;\n@@ -944,6 +967,8 @@ hide_operands (int n_ops, rtx *old_operands, rtx *old_dups,\n     {\n       int opn = recog_data.dup_num[i];\n       old_dups[i] = *recog_data.dup_loc[i];\n+      if (do_not_hide & (1 << opn))\n+\tcontinue;\n       if (!inout_and_ec_only || recog_data.operand_type[opn] == OP_INOUT\n \t  || recog_op_alt[opn][alt].earlyclobber)\n \t*recog_data.dup_loc[i] = cc0_rtx;\n@@ -1018,6 +1043,7 @@ build_def_use (basic_block bb)\n {\n   rtx insn;\n   df_ref *def_rec;\n+  unsigned HOST_WIDE_INT untracked_operands;\n \n   open_chains = closed_chains = NULL;\n \n@@ -1077,6 +1103,7 @@ build_def_use (basic_block bb)\n \t  preprocess_constraints ();\n \t  alt = which_alternative;\n \t  n_ops = recog_data.n_operands;\n+\t  untracked_operands = 0;\n \n \t  /* Simplify the code below by rewriting things to reflect\n \t     matching constraints.  Also promote OP_OUT to OP_INOUT in\n@@ -1094,11 +1121,21 @@ build_def_use (basic_block bb)\n \t          || (predicated && recog_data.operand_type[i] == OP_OUT\n \t\t      && verify_reg_tracked (recog_data.operand[i])))\n \t\t{\n+\t\t  rtx op = recog_data.operand[i];\n \t\t  recog_data.operand_type[i] = OP_INOUT;\n+\t\t  /* A special case to deal with instruction patterns that\n+\t\t     have matching operands with different modes.  If we're\n+\t\t     not already tracking such a reg, we won't start here,\n+\t\t     and we must instead make sure to make the operand visible\n+\t\t     to the machinery that tracks hard registers.  */\n \t\t  if (matches >= 0\n \t\t      && (GET_MODE_SIZE (recog_data.operand_mode[i])\n-\t\t\t  != GET_MODE_SIZE (recog_data.operand_mode[matches])))\n-\t\t    fail_current_block = true;\n+\t\t\t  != GET_MODE_SIZE (recog_data.operand_mode[matches]))\n+\t\t      && !verify_reg_in_set (op, &live_in_chains))\n+\t\t    {\n+\t\t      untracked_operands |= 1 << i;\n+\t\t      untracked_operands |= 1 << matches;\n+\t\t    }\n \t\t}\n \t    }\n \n@@ -1107,7 +1144,8 @@ build_def_use (basic_block bb)\n \n \t  /* Step 1a: Mark hard registers that are clobbered in this insn,\n \t     outside an operand, as live.  */\n-\t  hide_operands (n_ops, old_operands, old_dups, false);\n+\t  hide_operands (n_ops, old_operands, old_dups, untracked_operands,\n+\t\t\t false);\n \t  note_stores (PATTERN (insn), note_sets_clobbers, &clobber_code);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n@@ -1120,7 +1158,8 @@ build_def_use (basic_block bb)\n \t     We do this by munging all operands into CC0, and closing\n \t     everything remaining.  */\n \n-\t  hide_operands (n_ops, old_operands, old_dups, false);\n+\t  hide_operands (n_ops, old_operands, old_dups, untracked_operands,\n+\t\t\t false);\n \t  scan_rtx (insn, &PATTERN (insn), NO_REGS, mark_all_read, OP_IN);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n@@ -1157,7 +1196,8 @@ build_def_use (basic_block bb)\n \t      /* Don't scan match_operand here, since we've no reg class\n \t\t information to pass down.  Any operands that we could\n \t\t substitute in will be represented elsewhere.  */\n-\t      if (recog_data.constraints[opn][0] == '\\0')\n+\t      if (recog_data.constraints[opn][0] == '\\0'\n+\t\t  || untracked_operands & (1 << opn))\n \t\tcontinue;\n \n \t      if (recog_op_alt[opn][alt].is_address)\n@@ -1202,13 +1242,15 @@ build_def_use (basic_block bb)\n \t     the previous insn at the latest, as such operands cannot\n \t     possibly overlap with any input operands.  */\n \n-\t  hide_operands (n_ops, old_operands, old_dups, true);\n+\t  hide_operands (n_ops, old_operands, old_dups, untracked_operands,\n+\t\t\t true);\n \t  scan_rtx (insn, &PATTERN (insn), NO_REGS, terminate_write, OP_IN);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n \n \t  /* Step 6a: Mark hard registers that are set in this insn,\n \t     outside an operand, as live.  */\n-\t  hide_operands (n_ops, old_operands, old_dups, false);\n+\t  hide_operands (n_ops, old_operands, old_dups, untracked_operands,\n+\t\t\t false);\n \t  note_stores (PATTERN (insn), note_sets_clobbers, &set_code);\n \t  restore_operands (insn, n_ops, old_operands, old_dups);\n "}]}