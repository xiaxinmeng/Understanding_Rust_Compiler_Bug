{"sha": "cbe5f3b371c07c282d48d135cc5041092e1de28d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JlNWYzYjM3MWMwN2MyODJkNDhkMTM1Y2M1MDQxMDkyZTFkZTI4ZA==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-18T11:17:52Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-08-18T11:17:52Z"}, "message": "diagnostics.c (permerror_at): Rename as permerror.\n\n2008-08-18  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\t* diagnostics.c (permerror_at): Rename as permerror.\n\t(permerror): Delete.\n\t* toplev.h: Likewise.\ncp/\t\n\t* typeck.c: Update all callers.\n\t* init.c: Likewise.\n\t* class.c: Likewise.\n\t* decl.c: Likewise.\n\t* call.c: Likewise.\n\t* except.c: Likewise.\n\t* cvt.c: Likewise.\n\t* typeck2.c: Likewise.\n\t* pt.c: Likewise.\n\t* semantics.c: Likewise.\n\t* name-lookup.c: Likewise.\n\t* lex.c: Likewise.\n\t* decl2.c: Likewise.\n\t* parser.c: Likewise.\n\nFrom-SVN: r139193", "tree": {"sha": "6e8f62722b8c096a18c7f96bbbf77c9c7fc8a01c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e8f62722b8c096a18c7f96bbbf77c9c7fc8a01c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbe5f3b371c07c282d48d135cc5041092e1de28d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe5f3b371c07c282d48d135cc5041092e1de28d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe5f3b371c07c282d48d135cc5041092e1de28d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe5f3b371c07c282d48d135cc5041092e1de28d/comments", "author": null, "committer": null, "parents": [{"sha": "79a141784a7f10d72c756aa309eb6aa9a7bd92c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a141784a7f10d72c756aa309eb6aa9a7bd92c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a141784a7f10d72c756aa309eb6aa9a7bd92c5"}], "stats": {"total": 278, "additions": 141, "deletions": 137}, "files": [{"sha": "514915f0fd1aa94659319f5ab7fcec53a073683d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -1,3 +1,9 @@\n+2008-08-18  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* diagnostics.c (permerror_at): Rename as permerror.\n+\t(permerror): Delete.\n+\t* toplev.h: Likewise.\n+\n 2008-08-18  Richard Guenther  <rguenther@suse.de>\n \n \t* passes.c (init_optimization_passes): Remove cleanup_cfg1,"}, {"sha": "436804f5a8bef62e1f02d1fcfc48fb85291d6fff", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -1,3 +1,20 @@\n+2008-08-18  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\t* typeck.c: Update all callers of permerror.\n+\t* init.c: Likewise.\n+\t* class.c: Likewise.\n+\t* decl.c: Likewise.\n+\t* call.c: Likewise.\n+\t* except.c: Likewise.\n+\t* cvt.c: Likewise.\n+\t* typeck2.c: Likewise.\n+\t* pt.c: Likewise.\n+\t* semantics.c: Likewise.\n+\t* name-lookup.c: Likewise.\n+\t* lex.c: Likewise.\n+\t* decl2.c: Likewise.\n+\t* parser.c: Likewise.\n+\n 2008-08-14  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/34485"}, {"sha": "ccfce6466b79514c0a853233f2db43d7057209bd", "filename": "gcc/cp/call.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -4038,7 +4038,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  /* Look for an `operator++ (int)'.  If they didn't have\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n-\t    permerror (\"no %<%D(int)%> declared for postfix %qs, \"\n+\t    permerror (input_location, \"no %<%D(int)%> declared for postfix %qs, \"\n \t\t       \"trying prefix operator instead\",\n \t\t       fnname,\n \t\t       operator_name_info[code].name);\n@@ -4535,9 +4535,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t}\n       if (complain & tf_error)\n \t{\n-\t  permerror (\"invalid conversion from %qT to %qT\", TREE_TYPE (expr), totype);\n+\t  permerror (input_location, \"invalid conversion from %qT to %qT\", TREE_TYPE (expr), totype);\n \t  if (fn)\n-\t    permerror (\"  initializing argument %P of %qD\", argnum, fn);\n+\t    permerror (input_location, \"  initializing argument %P of %qD\", argnum, fn);\n \t}\n       else\n \treturn error_mark_node;\n@@ -5191,7 +5191,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n       if (convs[i]->bad_p)\n \t{\n \t  if (complain & tf_error)\n-\t    permerror (\"passing %qT as %<this%> argument of %q#D discards qualifiers\",\n+\t    permerror (input_location, \"passing %qT as %<this%> argument of %q#D discards qualifiers\",\n \t\t       TREE_TYPE (argtype), fn);\n \t  else\n \t    return error_mark_node;"}, {"sha": "d0033c7347ba92fe2ba43a2fc504e44aa0817203", "filename": "gcc/cp/class.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -2497,27 +2497,27 @@ finish_struct_anon (tree t)\n \t      if (TREE_CODE (elt) != FIELD_DECL)\n \t\t{\n \t\t  if (is_union)\n-\t\t    permerror (\"%q+#D invalid; an anonymous union can \"\n+\t\t    permerror (input_location, \"%q+#D invalid; an anonymous union can \"\n \t\t\t       \"only have non-static data members\", elt);\n \t\t  else\n-\t\t    permerror (\"%q+#D invalid; an anonymous struct can \"\n+\t\t    permerror (input_location, \"%q+#D invalid; an anonymous struct can \"\n \t\t\t       \"only have non-static data members\", elt);\n \t\t  continue;\n \t\t}\n \n \t      if (TREE_PRIVATE (elt))\n \t\t{\n \t\t  if (is_union)\n-\t\t    permerror (\"private member %q+#D in anonymous union\", elt);\n+\t\t    permerror (input_location, \"private member %q+#D in anonymous union\", elt);\n \t\t  else\n-\t\t    permerror (\"private member %q+#D in anonymous struct\", elt);\n+\t\t    permerror (input_location, \"private member %q+#D in anonymous struct\", elt);\n \t\t}\n \t      else if (TREE_PROTECTED (elt))\n \t\t{\n \t\t  if (is_union)\n-\t\t    permerror (\"protected member %q+#D in anonymous union\", elt);\n+\t\t    permerror (input_location, \"protected member %q+#D in anonymous union\", elt);\n \t\t  else\n-\t\t    permerror (\"protected member %q+#D in anonymous struct\", elt);\n+\t\t    permerror (input_location, \"protected member %q+#D in anonymous struct\", elt);\n \t\t}\n \n \t      TREE_PRIVATE (elt) = TREE_PRIVATE (field);\n@@ -3048,7 +3048,7 @@ check_field_decls (tree t, tree *access_decls,\n \t user-declared constructor.  */\n       if (constructor_name_p (DECL_NAME (x), t)\n \t  && TYPE_HAS_USER_CONSTRUCTOR (t))\n-\tpermerror (\"field %q+#D with same name as class\", x);\n+\tpermerror (input_location, \"field %q+#D with same name as class\", x);\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n \t If the type and width are valid, we'll also set DECL_BIT_FIELD.  */\n@@ -6171,7 +6171,7 @@ resolve_address_of_overloaded_function (tree target_type,\n       if (!(flags & tf_error))\n \treturn error_mark_node;\n \n-      permerror (\"assuming pointer to member %qD\", fn);\n+      permerror (input_location, \"assuming pointer to member %qD\", fn);\n       if (!explained)\n \t{\n \t  inform (\"(a pointer to member can only be formed with %<&%E%>)\", fn);\n@@ -6534,8 +6534,8 @@ note_name_declared_in_class (tree name, tree decl)\n \t A name N used in a class S shall refer to the same declaration\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n-      permerror (\"declaration of %q#D\", decl);\n-      permerror (\"changes meaning of %qD from %q+#D\",\n+      permerror (input_location, \"declaration of %q#D\", decl);\n+      permerror (input_location, \"changes meaning of %qD from %q+#D\",\n \t       DECL_NAME (OVL_CURRENT (decl)), (tree) n->value);\n     }\n }"}, {"sha": "fed4ab2910c4a570b779a9e70cc59a22e6f378b8", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -379,7 +379,7 @@ warn_ref_binding (tree reftype, tree intype, tree decl)\n \t  msg = \"conversion to non-const reference type %q#T from\"\n \t    \" rvalue of type %qT\";\n \n-      permerror (msg, reftype, intype);\n+      permerror (input_location, msg, reftype, intype);\n     }\n }\n \n@@ -449,7 +449,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \n \t  if (! (convtype & CONV_CONST)\n \t\t   && !at_least_as_qualified_p (ttl, ttr))\n-\t    permerror (\"conversion from %qT to %qT discards qualifiers\",\n+\t    permerror (input_location, \"conversion from %qT to %qT discards qualifiers\",\n \t\t       ttr, reftype);\n \t}\n \n@@ -649,7 +649,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t      || TREE_CODE (intype) == POINTER_TYPE)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n-\t\tpermerror (\"conversion from %q#T to %q#T\", intype, type);\n+\t\tpermerror (input_location, \"conversion from %q#T to %q#T\", intype, type);\n \n \t      if (!flag_permissive)\n \t\treturn error_mark_node;"}, {"sha": "34059ff8c24f1f2df7ada806fc8970116304e346", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -1055,8 +1055,8 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n     return;\n \n   name = DECL_ASSEMBLER_NAME (newdecl);\n-  permerror (\"%qD was declared %<extern%> and later %<static%>\", newdecl);\n-  permerror (\"previous declaration of %q+D\", olddecl);\n+  permerror (input_location, \"%qD was declared %<extern%> and later %<static%>\", newdecl);\n+  permerror (input_location, \"previous declaration of %q+D\", olddecl);\n }\n \n /* NEW_DECL is a redeclaration of OLD_DECL; both are functions or\n@@ -1539,9 +1539,9 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t\tif (1 == simple_cst_equal (TREE_PURPOSE (t1),\n \t\t\t\t\t   TREE_PURPOSE (t2)))\n \t\t  {\n-\t\t    permerror (\"default argument given for parameter %d of %q#D\",\n+\t\t    permerror (input_location, \"default argument given for parameter %d of %q#D\",\n \t\t\t       i, newdecl);\n-\t\t    permerror (\"after previous specification in %q+#D\", olddecl);\n+\t\t    permerror (input_location, \"after previous specification in %q+#D\", olddecl);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -2448,11 +2448,11 @@ static void\n identify_goto (tree decl, const location_t *locus)\n {\n   if (decl)\n-    permerror (\"jump to label %qD\", decl);\n+    permerror (input_location, \"jump to label %qD\", decl);\n   else\n-    permerror (\"jump to case label\");\n+    permerror (input_location, \"jump to case label\");\n   if (locus)\n-    permerror (\"%H  from here\", locus);\n+    permerror (input_location, \"%H  from here\", locus);\n }\n \n /* Check that a single previously seen jump to a newly defined label\n@@ -2494,7 +2494,7 @@ check_previous_goto_1 (tree decl, struct cp_binding_level* level, tree names,\n \t  if (problem > 1)\n \t    error (\"  crosses initialization of %q+#D\", new_decls);\n \t  else\n-\t    permerror (\"  enters scope of non-POD %q+#D\", new_decls);\n+\t    permerror (input_location, \"  enters scope of non-POD %q+#D\", new_decls);\n \t}\n \n       if (b == level)\n@@ -2590,8 +2590,8 @@ check_goto (tree decl)\n   if (ent->in_try_scope || ent->in_catch_scope\n       || ent->in_omp_scope || ent->bad_decls)\n     {\n-      permerror (\"jump to label %q+D\", decl);\n-      permerror (\"  from here\");\n+      permerror (input_location, \"jump to label %q+D\", decl);\n+      permerror (input_location, \"  from here\");\n       identified = true;\n     }\n \n@@ -2609,7 +2609,7 @@ check_goto (tree decl)\n       else if (u > 1)\n \terror (\"  skips initialization of %q+#D\", b);\n       else\n-\tpermerror (\"  enters scope of non-POD %q+#D\", b);\n+\tpermerror (input_location, \"  enters scope of non-POD %q+#D\", b);\n     }\n \n   if (ent->in_try_scope)\n@@ -2630,8 +2630,8 @@ check_goto (tree decl)\n \t    {\n \t      if (!identified)\n \t\t{\n-\t\t  permerror (\"jump to label %q+D\", decl);\n-\t\t  permerror (\"  from here\");\n+\t\t  permerror (input_location, \"jump to label %q+D\", decl);\n+\t\t  permerror (input_location, \"  from here\");\n \t\t  identified = true;\n \t\t}\n \t      error (\"  exits OpenMP structured block\");\n@@ -2683,7 +2683,7 @@ define_label (location_t location, tree name)\n     p->more_cleanups_ok = 0;\n \n   if (name == get_identifier (\"wchar_t\"))\n-    permerror (\"label named wchar_t\");\n+    permerror (input_location, \"label named wchar_t\");\n \n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {\n@@ -3766,7 +3766,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n   else if (declspecs->redefined_builtin_type)\n     {\n       if (!in_system_header)\n-\tpermerror (\"redeclaration of C++ built-in type %qT\",\n+\tpermerror (input_location, \"redeclaration of C++ built-in type %qT\",\n \t\t   declspecs->redefined_builtin_type);\n       return NULL_TREE;\n     }\n@@ -3780,7 +3780,7 @@ check_tag_decl (cp_decl_specifier_seq *declspecs)\n   else if (declspecs->type == error_mark_node)\n     error_p = true;\n   if (declared_type == NULL_TREE && ! saw_friend && !error_p)\n-    permerror (\"declaration does not declare anything\");\n+    permerror (input_location, \"declaration does not declare anything\");\n   /* Check for an anonymous union.  */\n   else if (declared_type && RECORD_OR_UNION_CODE_P (TREE_CODE (declared_type))\n \t   && TYPE_ANONYMOUS_P (declared_type))\n@@ -4056,7 +4056,7 @@ start_decl (const cp_declarator *declarator,\n \t      if (DECL_CONTEXT (field) != context)\n \t\t{\n \t\t  if (!same_type_p (DECL_CONTEXT (field), context))\n-\t\t    permerror (\"ISO C++ does not permit %<%T::%D%> \"\n+\t\t    permerror (input_location, \"ISO C++ does not permit %<%T::%D%> \"\n \t\t\t       \"to be defined as %<%T::%D%>\",\n \t\t\t       DECL_CONTEXT (field), DECL_NAME (decl),\n \t\t\t       context, DECL_NAME (decl));\n@@ -4112,7 +4112,7 @@ start_decl (const cp_declarator *declarator,\n \t}\n \n       if (DECL_EXTERNAL (decl) && ! DECL_TEMPLATE_SPECIALIZATION (decl))\n-\tpermerror (\"declaration of %q#D outside of class is not definition\",\n+\tpermerror (input_location, \"declaration of %q#D outside of class is not definition\",\n \t\t   decl);\n     }\n \n@@ -6377,7 +6377,7 @@ check_class_member_definition_namespace (tree decl)\n      The definition for a static data member shall appear in a\n      namespace scope enclosing the member's class definition.  */\n   if (!is_ancestor (current_namespace, DECL_CONTEXT (decl)))\n-    permerror (\"definition of %qD is not in namespace enclosing %qT\",\n+    permerror (input_location, \"definition of %qD is not in namespace enclosing %qT\",\n \t       decl, DECL_CONTEXT (decl));\n }\n \n@@ -6611,16 +6611,16 @@ grokfndecl (tree ctype,\n \t\t/* Allow this; it's pretty common in C.  */;\n \t      else\n \t\t{\n-\t\t  permerror (\"non-local function %q#D uses anonymous type\",\n+\t\t  permerror (input_location, \"non-local function %q#D uses anonymous type\",\n \t\t\t      decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n-\t\t    permerror (\"%q+#D does not refer to the unqualified \"\n+\t\t    permerror (input_location, \"%q+#D does not refer to the unqualified \"\n \t\t\t       \"type, so it is not used for linkage\",\n \t\t\t       TYPE_NAME (t));\n \t\t}\n \t    }\n \t  else\n-\t    permerror (\"non-local function %q#D uses local type %qT\", decl, t);\n+\t    permerror (input_location, \"non-local function %q#D uses local type %qT\", decl, t);\n \t}\n     }\n \n@@ -7765,7 +7765,7 @@ grokdeclarator (const cp_declarator *declarator,\n       else if (in_system_header || flag_ms_extensions)\n \t/* Allow it, sigh.  */;\n       else if (! is_main)\n-\tpermerror (\"ISO C++ forbids declaration of %qs with no type\", name);\n+\tpermerror (input_location, \"ISO C++ forbids declaration of %qs with no type\", name);\n       else if (pedantic)\n \tpedwarn (OPT_pedantic,\n \t\t \"ISO C++ forbids declaration of %qs with no type\", name);\n@@ -8211,7 +8211,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t      explicitp = 2;\n \t\t    if (virtualp)\n \t\t      {\n-\t\t\tpermerror (\"constructors cannot be declared virtual\");\n+\t\t\tpermerror (input_location, \"constructors cannot be declared virtual\");\n \t\t\tvirtualp = 0;\n \t\t      }\n \t\t    if (decl_context == FIELD\n@@ -8434,11 +8434,11 @@ grokdeclarator (const cp_declarator *declarator,\n \t{\n \t  if (friendp)\n \t    {\n-\t      permerror (\"member functions are implicitly friends of their class\");\n+\t      permerror (input_location, \"member functions are implicitly friends of their class\");\n \t      friendp = 0;\n \t    }\n \t  else\n-\t    permerror_at (declarator->id_loc, \n+\t    permerror (declarator->id_loc, \n \t\t\t  \"extra qualification %<%T::%> on member %qs\",\n \t\t\t  ctype, name);\n \t}\n@@ -8624,7 +8624,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    DECL_ABSTRACT (decl) = 1;\n \t}\n       else if (constructor_name_p (unqualified_id, current_class_type))\n-\tpermerror (\"ISO C++ forbids nested type %qD with same name \"\n+\tpermerror (input_location, \"ISO C++ forbids nested type %qD with same name \"\n \t\t   \"as enclosing class\",\n \t\t   unqualified_id);\n \n@@ -8749,13 +8749,13 @@ grokdeclarator (const cp_declarator *declarator,\n \t    {\n \t      /* Don't allow friend declaration without a class-key.  */\n \t      if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)\n-\t\tpermerror (\"template parameters cannot be friends\");\n+\t\tpermerror (input_location, \"template parameters cannot be friends\");\n \t      else if (TREE_CODE (type) == TYPENAME_TYPE)\n-\t\tpermerror (\"friend declaration requires class-key, \"\n+\t\tpermerror (input_location, \"friend declaration requires class-key, \"\n \t\t\t   \"i.e. %<friend class %T::%D%>\",\n \t\t\t   TYPE_CONTEXT (type), TYPENAME_TYPE_FULLNAME (type));\n \t      else\n-\t\tpermerror (\"friend declaration requires class-key, \"\n+\t\tpermerror (input_location, \"friend declaration requires class-key, \"\n \t\t\t   \"i.e. %<friend %#T%>\",\n \t\t\t   type);\n \t    }\n@@ -9077,9 +9077,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t       the rest of the compiler does not correctly\n \t\t       handle the initialization unless the member is\n \t\t       static so we make it static below.  */\n-\t\t    permerror (\"ISO C++ forbids initialization of member %qD\",\n+\t\t    permerror (input_location, \"ISO C++ forbids initialization of member %qD\",\n \t\t\t       unqualified_id);\n-\t\t    permerror (\"making %qD static\", unqualified_id);\n+\t\t    permerror (input_location, \"making %qD static\", unqualified_id);\n \t\t    staticp = 1;\n \t\t  }\n \n@@ -9203,7 +9203,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t       declaring main to be static.  */\n \t    if (TREE_CODE (type) == METHOD_TYPE)\n \t      {\n-\t\tpermerror (\"cannot declare member function %qD to have \"\n+\t\tpermerror (input_location, \"cannot declare member function %qD to have \"\n \t\t\t   \"static linkage\", decl);\n \t\tinvalid_static = 1;\n \t      }\n@@ -9240,7 +9240,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t    DECL_CONTEXT (decl) = ctype;\n \t    if (staticp == 1)\n \t      {\n-\t\tpermerror (\"%<static%> may not be used when defining \"\n+\t\tpermerror (input_location, \"%<static%> may not be used when defining \"\n \t\t\t   \"(as opposed to declaring) a static data member\");\n \t\tstaticp = 0;\n \t\tstorage_class = sc_none;"}, {"sha": "677597ec4226562d838935760dcc2737504b47ea", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -718,7 +718,7 @@ finish_static_data_member_decl (tree decl,\n     VEC_safe_push (tree, gc, pending_statics, decl);\n \n   if (LOCAL_CLASS_P (current_class_type))\n-    permerror (\"local class %q#T shall not have static data member %q#D\",\n+    permerror (input_location, \"local class %q#T shall not have static data member %q#D\",\n \t       current_class_type, decl);\n \n   /* Static consts need not be initialized in the class definition.  */\n@@ -1260,15 +1260,15 @@ build_anon_union_vars (tree type, tree object)\n \tcontinue;\n       if (TREE_CODE (field) != FIELD_DECL)\n \t{\n-\t  permerror (\"%q+#D invalid; an anonymous union can only \"\n+\t  permerror (input_location, \"%q+#D invalid; an anonymous union can only \"\n \t\t     \"have non-static data members\", field);\n \t  continue;\n \t}\n \n       if (TREE_PRIVATE (field))\n-\tpermerror (\"private member %q+#D in anonymous union\", field);\n+\tpermerror (input_location, \"private member %q+#D in anonymous union\", field);\n       else if (TREE_PROTECTED (field))\n-\tpermerror (\"protected member %q+#D in anonymous union\", field);\n+\tpermerror (input_location, \"protected member %q+#D in anonymous union\", field);\n \n       if (processing_template_decl)\n \tref = build_min_nt (COMPONENT_REF, object,\n@@ -1403,7 +1403,7 @@ coerce_new_type (tree type)\n     e = 2;\n \n   if (e == 2)\n-    permerror (\"%<operator new%> takes type %<size_t%> (%qT) \"\n+    permerror (input_location, \"%<operator new%> takes type %<size_t%> (%qT) \"\n \t       \"as first parameter\", size_type_node);\n \n   switch (e)"}, {"sha": "7813d087405a1c982611f0bfa3e9b2a277cfa01c", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -1028,7 +1028,7 @@ check_handlers (tree handlers)\n \tif (tsi_end_p (i))\n \t  break;\n \tif (TREE_TYPE (handler) == NULL_TREE)\n-\t  permerror (\"%H%<...%> handler must be the last handler for\"\n+\t  permerror (input_location, \"%H%<...%> handler must be the last handler for\"\n \t\t     \" its try block\", EXPR_LOCUS (handler));\n \telse\n \t  check_handlers_1 (handler, i);"}, {"sha": "609747f6216c36a9135ed18520dfb01a2ac9589d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -522,7 +522,7 @@ perform_member_init (tree member, tree init)\n \t      && !type_has_user_provided_default_constructor (type))\n \t    /* TYPE_NEEDS_CONSTRUCTING can be set just because we have a\n \t       vtable; still give this diagnostic.  */\n-\t    permerror (\"%Juninitialized member %qD with %<const%> type %qT\",\n+\t    permerror (input_location, \"%Juninitialized member %qD with %<const%> type %qT\",\n \t\t       current_function_decl, member, type);\n \t  finish_expr_stmt (build_aggr_init (decl, init, 0, \n \t\t\t\t\t     tf_warning_or_error));\n@@ -542,10 +542,10 @@ perform_member_init (tree member, tree init)\n \t    }\n \t  /* member traversal: note it leaves init NULL */\n \t  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-\t    permerror (\"%Juninitialized reference member %qD\",\n+\t    permerror (input_location, \"%Juninitialized reference member %qD\",\n \t\t       current_function_decl, member);\n \t  else if (CP_TYPE_CONST_P (type))\n-\t    permerror (\"%Juninitialized member %qD with %<const%> type %qT\",\n+\t    permerror (input_location, \"%Juninitialized member %qD with %<const%> type %qT\",\n \t\t       current_function_decl, member, type);\n \t}\n       else if (TREE_CODE (init) == TREE_LIST)\n@@ -2171,7 +2171,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t  if (init)\n             {\n               if (complain & tf_error)\n-                permerror (\"ISO C++ forbids initialization in array new\");\n+                permerror (input_location, \"ISO C++ forbids initialization in array new\");\n               else\n                 return error_mark_node;\n             }\n@@ -2387,7 +2387,7 @@ build_new (tree placement, tree type, tree nelts, tree init,\n       if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, nelts, false))\n         {\n           if (complain & tf_error)\n-            permerror (\"size in array new must have integral type\");\n+            permerror (input_location, \"size in array new must have integral type\");\n           else\n             return error_mark_node;\n         }"}, {"sha": "4b7f6148d1c89451336ec2a69eadea3fb35717b8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -481,7 +481,7 @@ unqualified_fn_lookup_error (tree name)\n \t Note that we have the exact wording of the following message in\n \t the manual (trouble.texi, node \"Name lookup\"), so they need to\n \t be kept in synch.  */\n-      permerror (\"there are no arguments to %qD that depend on a template \"\n+      permerror (input_location, \"there are no arguments to %qD that depend on a template \"\n \t\t \"parameter, so a declaration of %qD must be available\",\n \t\t name, name);\n "}, {"sha": "180860e733516a7d6ec8bdb5428bcbd6ec193d16", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -890,8 +890,8 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t      && TREE_CODE (decl) == TREE_CODE (x)\n \t      && !same_type_p (TREE_TYPE (x), TREE_TYPE (decl)))\n \t    {\n-\t      permerror (\"type mismatch with previous external decl of %q#D\", x);\n-\t      permerror (\"previous external decl of %q+#D\", decl);\n+\t      permerror (input_location, \"type mismatch with previous external decl of %q#D\", x);\n+\t      permerror (input_location, \"previous external decl of %q+#D\", decl);\n \t    }\n \t}\n \n@@ -1217,10 +1217,10 @@ check_for_out_of_scope_variable (tree decl)\n     }\n   else\n     {\n-      permerror (\"name lookup of %qD changed for ISO %<for%> scoping\",\n+      permerror (input_location, \"name lookup of %qD changed for ISO %<for%> scoping\",\n \t         DECL_NAME (decl));\n       if (flag_permissive)\n-        permerror (\"  using obsolete binding at %q+D\", decl);\n+        permerror (input_location, \"  using obsolete binding at %q+D\", decl);\n       else\n \t{\n \t  static bool hint;"}, {"sha": "21904cac2df62e901d32ecf0574a548cc3a41f53", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -4142,7 +4142,7 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t  && !(TREE_CODE (new_scope) == TYPENAME_TYPE\n \t       && (TREE_CODE (TYPENAME_TYPE_FULLNAME (new_scope))\n \t\t   == TEMPLATE_ID_EXPR)))\n-\tpermerror (TYPE_P (new_scope)\n+\tpermerror (input_location, TYPE_P (new_scope)\n \t\t   ? \"%qT is not a template\"\n \t\t   : \"%qD is not a template\",\n \t\t   new_scope);\n@@ -9046,8 +9046,8 @@ cp_parser_mem_initializer (cp_parser* parser)\n   /* Find out what is being initialized.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n-      permerror (\"%Hanachronistic old-style base class initializer\",\n-                 &token->location);\n+      permerror (token->location,\n+\t\t \"anachronistic old-style base class initializer\");\n       mem_initializer_id = NULL_TREE;\n     }\n   else\n@@ -9980,8 +9980,8 @@ cp_parser_template_id (cp_parser *parser,\n \t}\n       /* Otherwise, emit an error about the invalid digraph, but continue\n \t parsing because we got our argument list.  */\n-      if (permerror (\"%H%<<::%> cannot begin a template-argument list\",\n-\t\t     &next_token->location))\n+      if (permerror (next_token->location,\n+\t\t     \"%<<::%> cannot begin a template-argument list\"))\n \t{\n \t  static bool hint = false;\n \t  inform (\"%H%<<:%> is an alternate spelling for %<[%>. Insert whitespace \"\n@@ -11358,7 +11358,7 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n       tag_type = typename_type;\n       /* The `typename' keyword is only allowed in templates.  */\n       if (!processing_template_decl)\n-\tpermerror (\"using %<typename%> outside of template\");\n+\tpermerror (input_location, \"using %<typename%> outside of template\");\n     }\n   /* Otherwise it must be a class-key.  */\n   else\n@@ -15031,7 +15031,7 @@ cp_parser_class_head (cp_parser* parser,\n \t class member of a namespace outside of its namespace.  */\n       if (scope == nested_name_specifier)\n \t{\n-\t  permerror (\"%Hextra qualification not allowed\",\n+\t  permerror (input_location, \"%Hextra qualification not allowed\",\n \t\t     &nested_name_specifier_token_start->location);\n \t  nested_name_specifier = NULL_TREE;\n \t  num_templates = 0;\n@@ -18469,7 +18469,7 @@ static void\n cp_parser_check_class_key (enum tag_types class_key, tree type)\n {\n   if ((TREE_CODE (type) == UNION_TYPE) != (class_key == union_type))\n-    permerror (\"%qs tag used in naming %q#T\",\n+    permerror (input_location, \"%qs tag used in naming %q#T\",\n \t    class_key == union_type ? \"union\"\n \t     : class_key == record_type ? \"struct\" : \"class\",\n \t     type);"}, {"sha": "51a8abf4a8b3c3f6f108327aa94c5c1b0703c614", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -710,8 +710,8 @@ check_specialization_namespace (tree tmpl)\n     return true;\n   else\n     {\n-      permerror (\"specialization of %qD in different namespace\", tmpl);\n-      permerror (\"  from definition of %q+#D\", tmpl);\n+      permerror (input_location, \"specialization of %qD in different namespace\", tmpl);\n+      permerror (input_location, \"  from definition of %q+#D\", tmpl);\n       return false;\n     }\n }\n@@ -728,7 +728,7 @@ check_explicit_instantiation_namespace (tree spec)\n      namespace of its template.  */\n   ns = decl_namespace_context (spec);\n   if (!is_ancestor (current_namespace, ns))\n-    permerror (\"explicit instantiation of %qD in namespace %qD \"\n+    permerror (input_location, \"explicit instantiation of %qD in namespace %qD \"\n \t       \"(which does not enclose namespace %qD)\",\n \t       spec, current_namespace, ns);\n }\n@@ -811,8 +811,8 @@ maybe_process_partial_specialization (tree type)\n \t  if (current_namespace\n \t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n \t    {\n-\t      permerror (\"specializing %q#T in different namespace\", type);\n-\t      permerror (\"  from definition of %q+#D\",\n+\t      permerror (input_location, \"specializing %q#T in different namespace\", type);\n+\t      permerror (input_location, \"  from definition of %q+#D\",\n \t\t         CLASSTYPE_TI_TEMPLATE (type));\n \t    }\n \n@@ -2002,8 +2002,8 @@ check_explicit_specialization (tree declarator,\n       for (; t; t = TREE_CHAIN (t))\n \tif (TREE_PURPOSE (t))\n \t  {\n-\t    permerror\n-\t      (\"default argument specified in explicit specialization\");\n+\t    permerror (input_location, \n+\t\t       \"default argument specified in explicit specialization\");\n \t    break;\n \t  }\n     }\n@@ -4942,7 +4942,7 @@ convert_template_argument (tree parm,\n   if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n     {\n-      permerror (\"to refer to a type member of a template parameter, \"\n+      permerror (input_location, \"to refer to a type member of a template parameter, \"\n \t         \"use %<typename %E%>\", orig_arg);\n \n       orig_arg = make_typename_type (TREE_OPERAND (arg, 0),\n@@ -14591,7 +14591,7 @@ do_decl_instantiation (tree decl, tree storage)\n \t the first instantiation was `extern' and the second is not,\n \t and EXTERN_P for the opposite case.  */\n       if (DECL_NOT_REALLY_EXTERN (result) && !extern_p)\n-\tpermerror (\"duplicate explicit instantiation of %q#D\", result);\n+\tpermerror (input_location, \"duplicate explicit instantiation of %q#D\", result);\n       /* If an \"extern\" explicit instantiation follows an ordinary\n \t explicit instantiation, the template is instantiated.  */\n       if (extern_p)\n@@ -14604,7 +14604,7 @@ do_decl_instantiation (tree decl, tree storage)\n     }\n   else if (!DECL_TEMPLATE_INFO (result))\n     {\n-      permerror (\"explicit instantiation of non-template %q#D\", result);\n+      permerror (input_location, \"explicit instantiation of non-template %q#D\", result);\n       return;\n     }\n \n@@ -14756,7 +14756,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \n       if (!previous_instantiation_extern_p && !extern_p\n \t  && (complain & tf_error))\n-\tpermerror (\"duplicate explicit instantiation of %q#T\", t);\n+\tpermerror (input_location, \"duplicate explicit instantiation of %q#T\", t);\n \n       /* If we've already instantiated the template, just return now.  */\n       if (!CLASSTYPE_INTERFACE_ONLY (t))\n@@ -15200,8 +15200,8 @@ instantiate_decl (tree d, int defer_ok,\n \t   member function or static data member of a class template\n \t   shall be present in every translation unit in which it is\n \t   explicitly instantiated.  */\n-\tpermerror\n-\t  (\"explicit instantiation of %qD but no definition available\", d);\n+\tpermerror (input_location,  \"explicit instantiation of %qD \"\n+\t\t   \"but no definition available\", d);\n \n       /* ??? Historically, we have instantiated inline functions, even\n \t when marked as \"extern template\".  */"}, {"sha": "c7565a00620e10b6359bf20574b92d4bd9bf8a4d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -2191,7 +2191,7 @@ finish_template_type_parm (tree aggr, tree identifier)\n {\n   if (aggr != class_type_node)\n     {\n-      permerror (\"template type parameters must use the keyword %<class%> or %<typename%>\");\n+      permerror (input_location, \"template type parameters must use the keyword %<class%> or %<typename%>\");\n       aggr = class_type_node;\n     }\n "}, {"sha": "fbf9884c0bb4063ff819e2f644639fcb0df7bef1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -435,7 +435,7 @@ composite_pointer_type_r (tree t1, tree t2, const char* location,\n   else\n     {\n       if (complain & tf_error)\n-\tpermerror (\"%s between distinct pointer types %qT and %qT \"\n+\tpermerror (input_location, \"%s between distinct pointer types %qT and %qT \"\n \t\t   \"lacks a cast\",\n \t\t   location, t1, t2);\n       result_type = void_type_node;\n@@ -450,7 +450,7 @@ composite_pointer_type_r (tree t1, tree t2, const char* location,\n       if (!same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n \t\t\tTYPE_PTRMEM_CLASS_TYPE (t2))\n \t  && (complain & tf_error))\n-\tpermerror (\"%s between distinct pointer types %qT and %qT \"\n+\tpermerror (input_location, \"%s between distinct pointer types %qT and %qT \"\n \t\t   \"lacks a cast\",\n \t\t   location, t1, t2);\n       result_type = build_ptrmem_type (TYPE_PTRMEM_CLASS_TYPE (t1),\n@@ -1357,7 +1357,7 @@ cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n   else if (is_overloaded_fn (e))\n     {\n       if (complain & tf_error)\n-        permerror (\"ISO C++ forbids applying %<sizeof%> to an expression of \"\n+        permerror (input_location, \"ISO C++ forbids applying %<sizeof%> to an expression of \"\n                    \"function type\");\n       else\n         return error_mark_node;\n@@ -1417,7 +1417,7 @@ cxx_alignof_expr (tree e, tsubst_flags_t complain)\n   else if (is_overloaded_fn (e))\n     {\n       if (complain & tf_error)\n-        permerror (\"ISO C++ forbids applying %<__alignof%> to an expression of \"\n+        permerror (input_location, \"ISO C++ forbids applying %<__alignof%> to an expression of \"\n                    \"function type\");\n       else\n         return error_mark_node;\n@@ -2136,7 +2136,7 @@ check_template_keyword (tree decl)\n       && TREE_CODE (decl) != TEMPLATE_ID_EXPR)\n     {\n       if (!is_overloaded_fn (decl))\n-\tpermerror (\"%qD is not a template\", decl);\n+\tpermerror (input_location, \"%qD is not a template\", decl);\n       else\n \t{\n \t  tree fns;\n@@ -2156,7 +2156,7 @@ check_template_keyword (tree decl)\n \t      fns = OVL_NEXT (fns);\n \t    }\n \t  if (!fns)\n-\t    permerror (\"%qD is not a template\", decl);\n+\t    permerror (input_location, \"%qD is not a template\", decl);\n \t}\n     }\n }\n@@ -3235,7 +3235,7 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (t != error_mark_node)\n \t{\n \t  if (complain & tf_error)\n-\t    permerror (\"assuming cast to type %qT from overloaded function\",\n+\t    permerror (input_location, \"assuming cast to type %qT from overloaded function\",\n \t\t       TREE_TYPE (t));\n \t  op0 = t;\n \t}\n@@ -3246,7 +3246,7 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (t != error_mark_node)\n \t{\n \t  if (complain & tf_error)\n-\t    permerror (\"assuming cast to type %qT from overloaded function\",\n+\t    permerror (input_location, \"assuming cast to type %qT from overloaded function\",\n \t\t       TREE_TYPE (t));\n \t  op1 = t;\n \t}\n@@ -3521,15 +3521,15 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  result_type = type0;\n \t  if (complain & tf_error) \n-            permerror (\"ISO C++ forbids comparison between pointer and integer\");\n+            permerror (input_location, \"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n \t  if (complain & tf_error)\n-\t    permerror (\"ISO C++ forbids comparison between pointer and integer\");\n+\t    permerror (input_location, \"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n@@ -3709,15 +3709,15 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t{\n \t  result_type = type0;\n \t  if (complain & tf_error)\n-\t    permerror (\"ISO C++ forbids comparison between pointer and integer\");\n+\t    permerror (input_location, \"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n \t  if (complain & tf_error)\n-\t    permerror (\"ISO C++ forbids comparison between pointer and integer\");\n+\t    permerror (input_location, \"ISO C++ forbids comparison between pointer and integer\");\n           else\n             return error_mark_node;\n \t}\n@@ -3930,11 +3930,11 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n     return error_mark_node;\n \n   if (TREE_CODE (target_type) == VOID_TYPE)\n-    permerror (\"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n+    permerror (input_location, \"ISO C++ forbids using pointer of type %<void *%> in subtraction\");\n   if (TREE_CODE (target_type) == FUNCTION_TYPE)\n-    permerror (\"ISO C++ forbids using pointer to a function in subtraction\");\n+    permerror (input_location, \"ISO C++ forbids using pointer to a function in subtraction\");\n   if (TREE_CODE (target_type) == METHOD_TYPE)\n-    permerror (\"ISO C++ forbids using pointer to a method in subtraction\");\n+    permerror (input_location, \"ISO C++ forbids using pointer to a method in subtraction\");\n \n   /* First do the subtraction as integers;\n      then drop through to build the divide operator.  */\n@@ -4299,7 +4299,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \tif (TREE_CODE (argtype) == ENUMERAL_TYPE)\n           {\n             if (complain & tf_error)\n-              permerror ((code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n+              permerror (input_location, (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n                          ? G_(\"ISO C++ forbids incrementing an enum\")\n                          : G_(\"ISO C++ forbids decrementing an enum\"));\n             else\n@@ -4327,7 +4327,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t\t     && !TYPE_PTROB_P (argtype)) \n               {\n                 if (complain & tf_error)\n-                  permerror ((code == PREINCREMENT_EXPR\n+                  permerror (input_location, (code == PREINCREMENT_EXPR\n                               || code == POSTINCREMENT_EXPR)\n                              ? G_(\"ISO C++ forbids incrementing a pointer of type %qT\")\n                              : G_(\"ISO C++ forbids decrementing a pointer of type %qT\"),\n@@ -4388,7 +4388,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n         {\n           /* ARM $3.4 */\n           if (complain & tf_error)\n-            permerror (\"ISO C++ forbids taking address of function %<::main%>\");\n+            permerror (input_location, \"ISO C++ forbids taking address of function %<::main%>\");\n           else\n             return error_mark_node;\n         }\n@@ -4449,12 +4449,12 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t      else if (current_class_type\n                        && TREE_OPERAND (arg, 0) == current_class_ref)\n                   /* An expression like &memfn.  */\n-                permerror (\"ISO C++ forbids taking the address of an unqualified\"\n+                permerror (input_location, \"ISO C++ forbids taking the address of an unqualified\"\n                            \" or parenthesized non-static member function to form\"\n                            \" a pointer to member function.  Say %<&%T::%D%>\",\n                            base, name);\n \t      else\n-\t\tpermerror (\"ISO C++ forbids taking the address of a bound member\"\n+\t\tpermerror (input_location, \"ISO C++ forbids taking the address of a bound member\"\n \t\t\t   \" function to form a pointer to member function.\"\n \t\t\t   \"  Say %<&%T::%D%>\",\n \t\t\t   base, name);\n@@ -4483,7 +4483,7 @@ cp_build_unary_op (enum tree_code code, tree xarg, int noconvert,\n \t  if (! lvalue_p (arg) && complain == tf_none)\n             {\n               if (complain & tf_error)\n-                permerror (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n+                permerror (input_location, \"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n               else\n                 return error_mark_node;\n             }\n@@ -4820,7 +4820,7 @@ tree build_x_compound_expr_from_list (tree list, const char *msg)\n   if (TREE_CHAIN (list))\n     {\n       if (msg)\n-\tpermerror (\"%s expression list treated as compound expression\", msg);\n+\tpermerror (input_location, \"%s expression list treated as compound expression\", msg);\n \n       for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n \texpr = build_x_compound_expr (expr, TREE_VALUE (list), \n@@ -5372,7 +5372,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n         {\n           if (complain & tf_error)\n-            permerror (\"cast from %qT to %qT loses precision\",\n+            permerror (input_location, \"cast from %qT to %qT loses precision\",\n                        intype, type);\n           else\n             return error_mark_node;\n@@ -5649,7 +5649,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n           if (complain & tf_error)\n-            permerror (\"ISO C++ forbids casting to an array type %qT\", type);\n+            permerror (input_location, \"ISO C++ forbids casting to an array type %qT\", type);\n           else\n             return error_mark_node;\n \t  type = build_pointer_type (TREE_TYPE (type));\n@@ -6775,7 +6775,7 @@ check_return_expr (tree retval, bool *no_warning)\n      that's supposed to return a value.  */\n   if (!retval && fn_returns_value_p)\n     {\n-      permerror (\"return-statement with no value, in function returning %qT\",\n+      permerror (input_location, \"return-statement with no value, in function returning %qT\",\n \t         valtype);\n       /* Clear this, so finish_function won't say that we reach the\n \t end of a non-void function (which we don't, we gave a\n@@ -6796,7 +6796,7 @@ check_return_expr (tree retval, bool *no_warning)\n \t   its side-effects.  */\n \t  finish_expr_stmt (retval);\n       else\n-\tpermerror (\"return-statement with a value, in function \"\n+\tpermerror (input_location, \"return-statement with a value, in function \"\n \t\t   \"returning 'void'\");\n       current_function_returns_null = 1;\n "}, {"sha": "c9053862a6859a7302ef575a3e7fe1888f8bb908", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -777,7 +777,7 @@ digest_init_r (tree type, tree init, bool nested)\n \t\t counted in the length of the constant, but in C++ this would\n \t\t be invalid.  */\n \t      if (size < TREE_STRING_LENGTH (init))\n-\t\tpermerror (\"initializer-string for array of chars is too long\");\n+\t\tpermerror (input_location, \"initializer-string for array of chars is too long\");\n \t    }\n \t  return init;\n \t}"}, {"sha": "dfd3c9d1b083c4b5cc986d06f261439561f93338", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -586,7 +586,7 @@ pedwarn (int opt, const char *gmsgid, ...)\n    Returns true if the warning was printed, false if it was inhibited.  */\n \n bool\n-permerror_at (location_t location, const char *gmsgid, ...)\n+permerror (location_t location, const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n@@ -599,23 +599,6 @@ permerror_at (location_t location, const char *gmsgid, ...)\n   return report_diagnostic (&diagnostic);\n }\n \n-/* Equivalent to permerror_at (input_location, ...).  */\n-\n-bool\n-permerror (const char *gmsgid, ...)\n-{\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n-\t\t       permissive_error_kind ());\n-  diagnostic.option_index = OPT_fpermissive;\n-  va_end (ap);\n-  return report_diagnostic (&diagnostic);\n-}\n-\n-\n /* A hard error: the code is definitely ill-formed, and an object file\n    will not be produced.  */\n void"}, {"sha": "435cc97efb23f22241178d19a33faf28d8ccf8b7", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbe5f3b371c07c282d48d135cc5041092e1de28d/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=cbe5f3b371c07c282d48d135cc5041092e1de28d", "patch": "@@ -67,9 +67,7 @@ extern void fatal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n extern bool pedwarn (int, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern bool pedwarn_at (location_t, int, const char *, ...) \n      ATTRIBUTE_GCC_DIAG(3,4);\n-extern bool permerror (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n-extern bool permerror_at (location_t, const char *, ...)\n-     ATTRIBUTE_GCC_DIAG(2,3);\n+extern bool permerror (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n extern void sorry (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void inform (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void verbatim (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);"}]}