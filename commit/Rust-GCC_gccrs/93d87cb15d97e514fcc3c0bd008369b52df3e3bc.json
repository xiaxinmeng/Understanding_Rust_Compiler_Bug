{"sha": "93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNkODdjYjE1ZDk3ZTUxNGZjYzNjMGJkMDA4MzY5YjUyZGYzZTNiYw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2000-07-09T22:51:25Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2000-07-09T22:51:25Z"}, "message": "diagnostic.c (wrap_text): New function.\n\n2000-07-10  Gabriel Dos Reis  <gdr@codesourcery.com>\n\n\t* diagnostic.c (wrap_text): New function.\n\t(maybe_wrap_text): Likewise.\n\t(output_add_string): Use it.\n\t(output_format): Likewise.\n\t(count_error): Use verbatim instead of notice.\n\t(report_error_function): Likewise. Don't use plain fprintf.\n\t(finish_diagnostic): New function.\n\t(output_do_verbatim): Tweak.  Commonalize functionalities in\n\toutput_verbatim and verbatim.\n\t(output_verbatim): Adjust.\n\t(verbatim): Likewise.\n\t(report_diagnostic): Define.\n\n\t* diagnostic.h (report_diagnostic): Prototype.\n\nFrom-SVN: r34935", "tree": {"sha": "9417a2efda36818d8132dfa3ca02f99703f76eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9417a2efda36818d8132dfa3ca02f99703f76eca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/comments", "author": null, "committer": null, "parents": [{"sha": "66267cdb85cc3c32c160b48bf1fba73f0b9aaa44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66267cdb85cc3c32c160b48bf1fba73f0b9aaa44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66267cdb85cc3c32c160b48bf1fba73f0b9aaa44"}], "stats": {"total": 190, "additions": 140, "deletions": 50}, "files": [{"sha": "a9874bef954fc7b2d65a620bc6177a7520abdffb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "patch": "@@ -1,3 +1,20 @@\n+2000-07-10  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* diagnostic.c (wrap_text): New function.\n+\t(maybe_wrap_text): Likewise.\n+\t(output_add_string): Use it.\n+\t(output_format): Likewise.\n+\t(count_error): Use verbatim instead of notice.\n+\t(report_error_function): Likewise. Don't use plain fprintf.\n+\t(finish_diagnostic): New function.\n+\t(output_do_verbatim): Tweak.  Commonalize functionalities in\n+\toutput_verbatim and verbatim.\n+\t(output_verbatim): Adjust.\n+\t(verbatim): Likewise.\n+\t(report_diagnostic): Define.\n+\n+\t* diagnostic.h (report_diagnostic): Prototype.\n+\t\n 2000-07-09  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cppexp.c (_cpp_parse_expr): Don't use unary plus."}, {"sha": "f79c740e461a6368ab8a84e697ff7ee6c26bc199", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 121, "deletions": 50, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "patch": "@@ -67,7 +67,9 @@ typedef struct\n /* Prototypes. */\n static int doing_line_wrapping PARAMS ((void));\n \n-static void output_do_verbatim PARAMS ((output_buffer *));\n+static void finish_diagnostic PARAMS ((void));\n+static void output_do_verbatim PARAMS ((output_buffer *,\n+                                        const char *, va_list));\n static void output_to_stream PARAMS ((output_buffer *, FILE *));\n static void output_format PARAMS ((output_buffer *));\n \n@@ -116,6 +118,9 @@ static void output_long_octal PARAMS ((output_buffer *, long int));\n static void output_hexadecimal PARAMS ((output_buffer *, int));\n static void output_long_hexadecimal PARAMS ((output_buffer *, long int));\n static void output_append_r PARAMS ((output_buffer *, const char *, int));\n+static void wrap_text PARAMS ((output_buffer *, const char *, const char *));\n+static void maybe_wrap_text PARAMS ((output_buffer *, const char *,\n+                                     const char *));\n \n extern int rtl_dump_and_exit;\n extern int inhibit_warnings;\n@@ -488,40 +493,64 @@ output_append (buffer, start, end)\n   output_append_r (buffer, start, end - start);\n }\n \n-/* Wrap a STRing into BUFFER.  */\n-\n-void\n-output_add_string (buffer, str)\n+/* Wrap a text delimited by START and END into BUFFER.  */\n+static void\n+wrap_text (buffer, start, end)\n      output_buffer *buffer;\n-     const char *str;\n+     const char *start;\n+     const char *end;\n {\n-  const char *p = str;\n-\n-  if (!output_is_line_wrapping (buffer))\n-    output_append (buffer, str, str + strlen (str));\n-  else while (*str)\n+  while (start != end)\n     {\n-      while (*p && *p != ' ' && *p != '\\n')\n-        ++p;\n-      \n-      if (p - str < output_space_left (buffer))\n-        output_append (buffer, str, p);\n-      else\n-        {\n+      /* Dump anything bodered by whitespaces.  */ \n+      {\n+        const char *p = start;\n+        while (p != end && *p != ' ' && *p != '\\n')\n+          ++p;\n+        if (p - start >= output_space_left (buffer))\n           output_add_newline (buffer);\n-          output_append (buffer, str, p);\n+        output_append (buffer, start, p);\n+        start = p;\n+      }\n+\n+      if (start != end && *start == ' ')\n+        {\n+          output_add_space (buffer);\n+          ++start;\n         }\n-      \n-      while (*p && *p == '\\n')\n+      if (start != end && *start == '\\n')\n         {\n           output_add_newline (buffer);\n-          ++p;\n+          ++start;\n         }\n-\n-      str = p++;\n     }\n }\n \n+/* Same as wrap_text but wrap text only when in line-wrapping mode.  */\n+static void\n+maybe_wrap_text (buffer, start, end)\n+     output_buffer *buffer;\n+     const char *start;\n+     const char *end;\n+{\n+  if (output_is_line_wrapping (buffer))\n+    wrap_text (buffer, start, end);\n+  else\n+    output_append (buffer, start, end);\n+}\n+\n+\n+/* Append a STRING to BUFFER; the STRING maybe be line-wrapped if in\n+   appropriate mode.  */\n+\n+void\n+output_add_string (buffer, str)\n+     output_buffer *buffer;\n+     const char *str;\n+{\n+  maybe_wrap_text (buffer, str, str + (str ? strlen (str) : 0));\n+}\n+\n /* Flush the content of BUFFER onto FILE and reinitialize BUFFER.  */\n \n static void\n@@ -555,11 +584,15 @@ output_format (buffer)\n     {\n       int long_integer = 0;\n       /* Ignore text.  */\n-      if (*buffer->cursor != '%')\n-        {\n-          output_add_character (buffer, *buffer->cursor);\n-          continue;\n-        }\n+      {\n+        const char *p = buffer->cursor;\n+        while (*p && *p != '%')\n+          ++p;\n+        maybe_wrap_text (buffer, buffer->cursor, p);\n+        buffer->cursor = p;\n+      }\n+      if (!*buffer->cursor)\n+        break;\n \n       /* We got a '%'.  Let's see what happens. Record whether we're\n          parsing a long integer format specifier.  */\n@@ -643,7 +676,6 @@ output_format (buffer)\n             }\n         }\n     }\n-  output_finish (buffer);\n }\n \n static char *\n@@ -1221,7 +1253,7 @@ count_error (warningp)\n \n       if (warningp && !warning_message)\n \t{\n-\t  notice (\"%s: warnings being treated as errors\\n\", progname);\n+\t  verbatim (\"%s: warnings being treated as errors\\n\", progname);\n \t  warning_message = 1;\n \t}\n       errorcount++;\n@@ -1456,7 +1488,7 @@ report_error_function (file)\n \n   if (need_error_newline)\n     {\n-      fprintf (stderr, \"\\n\");\n+      verbatim (\"\\n\");\n       need_error_newline = 0;\n     }\n \n@@ -1465,10 +1497,10 @@ report_error_function (file)\n     {\n       for (p = input_file_stack->next; p; p = p->next)\n \tif (p == input_file_stack->next)\n-\t  notice (\"In file included from %s:%d\", p->name, p->line);\n+\t  verbatim (\"In file included from %s:%d\", p->name, p->line);\n \telse\n-\t  notice (\",\\n                 from %s:%d\", p->name, p->line);\n-      fprintf (stderr, \":\\n\");\n+\t  verbatim (\",\\n                 from %s:%d\", p->name, p->line);\n+      verbatim (\":\\n\");\n       last_error_tick = input_file_stack_tick;\n     }\n \n@@ -1721,16 +1753,34 @@ restore_output_state (state, buffer)\n   va_copy (buffer->format_args, state->format_args);\n }\n \n+/* Flush diagnostic_buffer content on stderr.  */\n+static void\n+finish_diagnostic ()\n+{\n+  output_to_stream (diagnostic_buffer, stderr);\n+  fputc ('\\n', stderr);\n+  fflush (stderr);\n+}\n+\n /* Helper subroutine of output_verbatim and verbatim. Do the approriate\n    settings needed by BUFFER for a verbatim formatting.  */\n static void\n-output_do_verbatim (buffer)\n+output_do_verbatim (buffer, msg, args)\n      output_buffer *buffer;\n+     const char *msg;\n+     va_list args;\n {\n+  output_state os;\n+\n+  save_output_state (buffer, &os);\n   buffer->prefix = NULL;\n   buffer->prefixing_rule = DIAGNOSTICS_SHOW_PREFIX_NEVER;\n+  buffer->cursor = msg;\n+  va_copy (buffer->format_args, args);\n   output_set_maximum_length (buffer, 0);\n   output_format (buffer);\n+  va_end (buffer->format_args);\n+  restore_output_state (&os, buffer);\n }\n \n /* Output MESSAGE verbatim into BUFFER.  */\n@@ -1741,20 +1791,14 @@ output_verbatim VPARAMS ((output_buffer *buffer, const char *msg, ...))\n   output_buffer *buffer;\n   const char *msg;\n #endif\n-  output_state previous_state;\n   va_list ap;\n \n   VA_START (ap, msg);\n #ifndef ANSI_PROTOTYPES\n   buffer = va_arg (ap, output_buffer *);\n   msg = va_arg (ap, const char *);\n #endif\n-  save_output_state (buffer, &previous_state);\n-  buffer->cursor = msg;\n-  va_copy (buffer->format_args, ap);\n-  output_do_verbatim(buffer);\n-  va_end (buffer->format_args);\n-  restore_output_state (&previous_state, buffer);\n+  output_do_verbatim (buffer, msg, ap);\n }\n \n /* Same as above but use diagnostic_buffer.  */\n@@ -1764,15 +1808,42 @@ verbatim VPARAMS ((const char *msg, ...))\n #ifndef ANSI_PROTOTYPES\n   const char *msg;\n #endif\n-  output_state previous_state;\n-  save_output_state (diagnostic_buffer, &previous_state);\n-  VA_START (diagnostic_args, msg);\n+  va_list ap;\n+\n+  VA_START (ap, msg);\n #ifndef ANSI_PROTOTYPES\n-  msg = va_arg (diagnostic_args, const char *);\n+  msg = va_arg (ap, const char *);\n #endif\n-  diagnostic_msg = msg;\n-  output_do_verbatim (diagnostic_buffer);\n+  output_do_verbatim (diagnostic_buffer, msg, ap);\n   output_to_stream (diagnostic_buffer, stderr);\n+}\n+\n+/* Report a diagnostic MESSAGE (an error or a WARNING) involving\n+   entities in ARGUMENTS.  FILE and LINE indicate where the diagnostic\n+   occurs.  This function is *the* subroutine in terms of which front-ends\n+   should implement their specific diagnostic handling modules.  */\n+void\n+report_diagnostic (msg, args, file, line, warn)\n+     const char *msg;\n+     va_list args;\n+     const char *file;\n+     int line;\n+     int warn;\n+{\n+  output_state os;\n+\n+  save_output_state (diagnostic_buffer, &os);\n+  diagnostic_msg = msg;\n+  va_copy (diagnostic_args, args);\n+  if (count_error (warn))\n+    {\n+      report_error_function (file);\n+      output_set_prefix\n+        (diagnostic_buffer, context_as_prefix (file, line, warn));\n+      output_format (diagnostic_buffer);\n+      finish_diagnostic();\n+      output_destroy_prefix (diagnostic_buffer);\n+    }\n   va_end (diagnostic_args);\n-  restore_output_state (&previous_state, diagnostic_buffer);\n+  restore_output_state (&os, diagnostic_buffer);\n }"}, {"sha": "5b082a2e089094470a9a2474170939d0b8d1faf8", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93d87cb15d97e514fcc3c0bd008369b52df3e3bc/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=93d87cb15d97e514fcc3c0bd008369b52df3e3bc", "patch": "@@ -94,6 +94,8 @@ extern int diagnostic_message_length_per_line;\n extern output_buffer *diagnostic_buffer;\n \n /* Prototypes */\n+void report_diagnostic          PARAMS ((const char *, va_list,\n+                                         const char *, int, int));\n void initialize_diagnostics     PARAMS ((void));\n void reshape_diagnostic_buffer  PARAMS ((void));\n void default_initialize_buffer  PARAMS ((output_buffer *));"}]}