{"sha": "2238de654fe0eb5e098c7986aaa9148b627ee441", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjIzOGRlNjU0ZmUwZWI1ZTA5OGM3OTg2YWFhOTE0OGI2MjdlZTQ0MQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-05-09T22:46:58Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-05-09T22:46:58Z"}, "message": "StringBuffer.java (toString): Don't mark buffer as shared.\n\n\t* java/lang/StringBuffer.java (toString): Don't mark buffer as\n\tshared.\n\t(insert(int,char[],int,int): New method.\n\t(delete): New method from Classpath.\n\t(deleteCharAt): Likewise.\n\t(substring): Likewise.\n\t(shared): No longer private.\n\tAdded JavaDoc comments from Classpath.\n\t* java/lang/String.java (String(StringBuffer)): Ensure `buffer' is\n\tshared.\n\nFrom-SVN: r33809", "tree": {"sha": "de72dd5dd18b7b0636515b1b9b44a061b0dc4179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de72dd5dd18b7b0636515b1b9b44a061b0dc4179"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2238de654fe0eb5e098c7986aaa9148b627ee441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2238de654fe0eb5e098c7986aaa9148b627ee441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2238de654fe0eb5e098c7986aaa9148b627ee441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2238de654fe0eb5e098c7986aaa9148b627ee441/comments", "author": null, "committer": null, "parents": [{"sha": "4c3f1588d49c1657bfb48b55c6211759e3b2f4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c3f1588d49c1657bfb48b55c6211759e3b2f4c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c3f1588d49c1657bfb48b55c6211759e3b2f4c2"}], "stats": {"total": 845, "additions": 618, "deletions": 227}, "files": [{"sha": "040fd2f701b7f0643e918b9a1e1ffdf55c11755f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2238de654fe0eb5e098c7986aaa9148b627ee441/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2238de654fe0eb5e098c7986aaa9148b627ee441/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=2238de654fe0eb5e098c7986aaa9148b627ee441", "patch": "@@ -1,3 +1,16 @@\n+2000-05-09  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* java/lang/StringBuffer.java (toString): Don't mark buffer as\n+\tshared.\n+\t(insert(int,char[],int,int): New method.\n+\t(delete): New method from Classpath.\n+\t(deleteCharAt): Likewise.\n+\t(substring): Likewise.\n+\t(shared): No longer private.\n+\tAdded JavaDoc comments from Classpath.\n+\t* java/lang/String.java (String(StringBuffer)): Ensure `buffer' is\n+\tshared.\n+\n 2000-05-07  Tom Tromey  <tromey@cygnus.com>\n \n \t* Makefile.in: Rebuilt."}, {"sha": "54be314b07b66fd7e5fd38e2ebac9ec62495cf65", "filename": "libjava/java/lang/String.java", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2238de654fe0eb5e098c7986aaa9148b627ee441/libjava%2Fjava%2Flang%2FString.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2238de654fe0eb5e098c7986aaa9148b627ee441/libjava%2Fjava%2Flang%2FString.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FString.java?ref=2238de654fe0eb5e098c7986aaa9148b627ee441", "patch": "@@ -38,7 +38,11 @@ public String (String value)\n \n   public String (StringBuffer buffer)\n   {\n-    init (buffer.value, 0, buffer.count, true);\n+    synchronized (buffer)\n+      {\n+\tbuffer.shared = true;\n+\tinit (buffer.value, 0, buffer.count, true);\n+      }\n   }\n \n   public String (char[] data)"}, {"sha": "15f6271ecf59d8d75a29b5ceb82dc0226ba0493b", "filename": "libjava/java/lang/StringBuffer.java", "status": "modified", "additions": 600, "deletions": 226, "changes": 826, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2238de654fe0eb5e098c7986aaa9148b627ee441/libjava%2Fjava%2Flang%2FStringBuffer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2238de654fe0eb5e098c7986aaa9148b627ee441/libjava%2Fjava%2Flang%2FStringBuffer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStringBuffer.java?ref=2238de654fe0eb5e098c7986aaa9148b627ee441", "patch": "@@ -17,277 +17,651 @@\n  */\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n+ * Updated using online JDK 1.2 docs.\n+ * Believed complete and correct to JDK 1.2.\n+ * Merged with Classpath.\n  */\n \n+/**\n+ * <code>StringBuffer</code> represents a changeable <code>String</code>.\n+ * It provides the operations required to modify the\n+ * <code>StringBuffer</code> including insert, replace, delete, append,\n+ * and reverse.\n+ * <P>\n+ *\n+ * <code>StringBuffer</code>s are variable-length in nature, so even if\n+ * you initialize them to a certain size, they can still grow larger than\n+ * that.  <EM>Capacity</EM> indicates the number of characters the\n+ * <code>StringBuffer</code> can have in it before it has to grow (growing\n+ * the char array is an expensive operation involving <code>new</code>).\n+ * <P>\n+ *\n+ * Incidentally, the String operator \"+\" actually is turned into a\n+ * <code>StringBuffer</code> operation:\n+ * <BR>\n+ * <code>a + b</code>\n+ * <BR>\n+ * is the same as\n+ * <BR>\n+ * <code>new StringBuffer(a).append(b).toString()</code>.\n+ *\n+ * @implnote Classpath's StringBuffer is capable of sharing memory with\n+ *           Strings for efficiency.  This will help in two instances:\n+ *           first, when a StringBuffer is created from a String but is\n+ *           never changed, and second, when a StringBuffer is converted\n+ *           to a String and the StringBuffer is not changed after that.\n+ *\n+ * @since JDK1.0\n+ * @author Paul Fisher\n+ * @author John Keiser\n+ * @author Tom Tromey\n+ * @see java.lang.String\n+ */\n public final class StringBuffer implements Serializable\n {\n+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param bool the <code>boolean</code> to convert and append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(boolean)\n+   */\n   public StringBuffer append (boolean bool)\n-    {\n-      return append (String.valueOf(bool));\n-    }\n-\n+  {\n+    return append (String.valueOf(bool));\n+  }\n+\n+  /** Append the <code>char</code> to this <code>StringBuffer</code>.\n+   *  @param c the <code>char</code> to append.\n+   *  @return this <code>StringBuffer</code>.\n+   */\n   public synchronized StringBuffer append (char ch)\n-    {\n-      ensureCapacity_unsynchronized (count + 1);\n-      value[count++] = ch;\n-      return this;\n-    }\n-\n+  {\n+    ensureCapacity_unsynchronized (count + 1);\n+    value[count++] = ch;\n+    return this;\n+  }\n+\n+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param inum the <code>int</code> to convert and append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(int)\n+   */\n   public StringBuffer append (int inum)\n-    {\n-      return append (String.valueOf(inum));\n-    }\n-\n+  {\n+    return append (String.valueOf(inum));\n+  }\n+\n+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param lnum the <code>long</code> to convert and append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(long)\n+   */\n   public StringBuffer append (long lnum)\n-    {\n-      return append (String.valueOf(lnum));\n-    }\n-\n+  {\n+    return append (String.valueOf(lnum));\n+  }\n+\n+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param fnum the <code>float</code> to convert and append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(float)\n+   */\n   public StringBuffer append (float fnum)\n-    {\n-      return append (String.valueOf(fnum));\n-    }\n-\n+  {\n+    return append (String.valueOf(fnum));\n+  }\n+\n+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param dnum the <code>double</code> to convert and append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(double)\n+   */\n   public StringBuffer append (double dnum)\n-    {\n-      return append (String.valueOf(dnum));\n-    }\n-\n+  {\n+    return append (String.valueOf(dnum));\n+  }\n+\n+  /** Append the <code>String</code> value of the argument to this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param obj the <code>Object</code> to convert and append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(java.lang.Object)\n+   */\n   public StringBuffer append (Object obj)\n-    {\n-      return append (String.valueOf(obj));\n-    }\n-\n+  {\n+    return append (String.valueOf(obj));\n+  }\n+\n+  /** Append the <code>String</code> to this <code>StringBuffer</code>.\n+   *  @param str the <code>String</code> to append.\n+   *  @return this <code>StringBuffer</code>.\n+   */\n   public synchronized StringBuffer append (String str)\n-    {\n-      if (str == null)\n-\tstr = \"null\";\n-      int len = str.length();\n-      ensureCapacity_unsynchronized (count + len);\n-      str.getChars(0, len, value, count);\n-      count += len;\n-      return this;\n-    }\n-\n+  {\n+    if (str == null)\n+      str = \"null\";\n+    int len = str.length();\n+    ensureCapacity_unsynchronized (count + len);\n+    str.getChars(0, len, value, count);\n+    count += len;\n+    return this;\n+  }\n+\n+  /** Append the <code>char</code> array to this <code>StringBuffer</code>.\n+   *  @param data the <code>char[]</code> to append.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception NullPointerException if <code>str</code> is <code>null</code>.\n+   */\n   public StringBuffer append (char[] data)\n-    {\n-      return append (data, 0, data.length);\n-    }\n-\n+  {\n+    return append (data, 0, data.length);\n+  }\n+\n+  /** Append the <code>char</code> array to this <code>StringBuffer</code>.\n+   *  @param data the <code>char[]</code> to append.\n+   *  @param offset the place to start grabbing characters from\n+   *         <code>str</code>.\n+   *  @param count the number of characters to get from <code>str</code>.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception NullPointerException if <code>str</code> is <code>null</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> or\n+   *             <code>offset+len</code> is out of range.\n+   */\n   public synchronized StringBuffer append (char[] data, int offset, int count)\n-    {\n-      ensureCapacity_unsynchronized (this.count + count);\n-      System.arraycopy(data, offset, value, this.count, count);\n-      this.count += count;\n-      return this;\n-    } \n-\n+  {\n+    ensureCapacity_unsynchronized (this.count + count);\n+    System.arraycopy(data, offset, value, this.count, count);\n+    this.count += count;\n+    return this;\n+  } \n+\n+  /** Get the total number of characters this <code>StringBuffer</code>\n+   *  can support before it must be grown.  Not to be confused with\n+   *  <em>length</em>.\n+   *  @return the capacity of this <code>StringBuffer</code>\n+   *  @see #length()\n+   *  @see #ensureCapacity(int)\n+   */\n   public int capacity ()\n-    {\n-      return value.length;\n-    }\n-\n+  {\n+    return value.length;\n+  }\n+\n+  /** Get the character at the specified index.\n+   *  @param index the index of the character to get, starting at 0.\n+   *  @return the character at the specified index.\n+   *  @exception IndexOutOfBoundsException if the desired character index\n+   *             is not between 0 and length() - 1 (inclusive).\n+   */\n   public synchronized char charAt (int index)\n-    {\n-      if (index >= count)\n-\tthrow new StringIndexOutOfBoundsException (index);\n-      return value[index];\n-    }\n-\n+  {\n+    if (index >= count)\n+      throw new StringIndexOutOfBoundsException (index);\n+    return value[index];\n+  }\n+\n+  /** Delete characters from this <code>StringBuffer</code>.\n+   *  <code>delete(10, 12)</code> will delete 10 and 11, but not 12.\n+   *  @param start the first character to delete.\n+   *  @param end the index after the last character to delete.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception StringIndexOutOfBoundsException if <code>start</code>\n+   *             or <code>end-1</code> are out of bounds, or if\n+   *             <code>start > end</code>.\n+   */\n+  public synchronized StringBuffer delete (int start, int end)\n+  {\n+    if (start < 0 || start > count || start > end)\n+      throw new StringIndexOutOfBoundsException (start);\n+    if (end > count)\n+      end = count;\n+    // This will unshare if required.\n+    ensureCapacity_unsynchronized (count);\n+    count -= (end - start);\n+    System.arraycopy (value, end - 1, value, start, end - start);\n+    return this;\n+  }\n+\n+  /** Delete a character from this <code>StringBuffer</code>.\n+   *  @param index the index of the character to delete.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception StringIndexOutOfBoundsException if <code>index</code>\n+   *             is out of bounds.\n+   */\n+  public StringBuffer deleteCharAt(int index)\n+  {\n+    return delete (index, index + 1);\n+  }\n+\n+  /** Increase the capacity of this <code>StringBuffer</code>.\n+   *  This will ensure that an expensive growing operation will not occur\n+   *  until <code>minimumCapacity</code> is reached.\n+   *  If the capacity is actually already greater than <code>minimumCapacity</code>\n+   *  @param minimumCapacity the new capacity.\n+   *  @see #capacity()\n+   */\n   public synchronized void ensureCapacity (int minimumCapacity)\n-    {\n-      if (shared || minimumCapacity > value.length)\n-\t{\n-\t  // We don't want to make a larger vector when `shared' is\n-\t  // set.  If we do, then setLength becomes very inefficient\n-\t  // when repeatedly reusing a StringBuffer in a loop.\n-\t  int max = (minimumCapacity > value.length\n-\t\t     ? value.length*2+2\n-\t\t     : value.length);\n-\t  minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n-\t  char[] nb = new char[minimumCapacity];\n-\t  System.arraycopy(value, 0, nb, 0, count);\n-\t  value = nb;\n-\t  shared = false;\n-\t}\n-    }\n+  {\n+    if (shared || minimumCapacity > value.length)\n+      {\n+\t// We don't want to make a larger vector when `shared' is\n+\t// set.  If we do, then setLength becomes very inefficient\n+\t// when repeatedly reusing a StringBuffer in a loop.\n+\tint max = (minimumCapacity > value.length\n+\t\t   ? value.length*2+2\n+\t\t   : value.length);\n+\tminimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n+\tchar[] nb = new char[minimumCapacity];\n+\tSystem.arraycopy(value, 0, nb, 0, count);\n+\tvalue = nb;\n+\tshared = false;\n+      }\n+  }\n \n   // ensureCapacity is used by several synchronized methods in StringBuffer.\n   // There's no need to synchronize again.\n   private void ensureCapacity_unsynchronized (int minimumCapacity)\n-    {\n-      if (shared || minimumCapacity > value.length)\n-\t{\n-\t  // We don't want to make a larger vector when `shared' is\n-\t  // set.  If we do, then setLength becomes very inefficient\n-\t  // when repeatedly reusing a StringBuffer in a loop.\n-\t  int max = (minimumCapacity > value.length\n-\t\t     ? value.length*2+2\n-\t\t     : value.length);\n-\t  minimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n-\t  char[] nb = new char[minimumCapacity];\n-\t  System.arraycopy(value, 0, nb, 0, count);\n-\t  value = nb;\n-\t  shared = false;\n-\t}\n-    }\n-\n+  {\n+    if (shared || minimumCapacity > value.length)\n+      {\n+\t// We don't want to make a larger vector when `shared' is\n+\t// set.  If we do, then setLength becomes very inefficient\n+\t// when repeatedly reusing a StringBuffer in a loop.\n+\tint max = (minimumCapacity > value.length\n+\t\t   ? value.length*2+2\n+\t\t   : value.length);\n+\tminimumCapacity = (minimumCapacity < max ? max : minimumCapacity);\n+\tchar[] nb = new char[minimumCapacity];\n+\tSystem.arraycopy(value, 0, nb, 0, count);\n+\tvalue = nb;\n+\tshared = false;\n+      }\n+  }\n+\n+  /** Get the specified array of characters.\n+   *  The characters will be copied into the array you pass in.\n+   *  @param srcOffset the index to start copying from in the\n+   *         <code>StringBuffer</code>.\n+   *  @param srcEnd the number of characters to copy.\n+   *  @param dst the array to copy into.\n+   *  @param dstOffset the index to start copying into <code>dst</code>.\n+   *  @exception NullPointerException if dst is null.\n+   *  @exception IndexOutOfBoundsException if any source or target\n+   *             indices are out of range.\n+   *  @see java.lang.System#arrayCopy(java.lang.Object,int,java.lang.Object,int,int)\n+   */\n   public synchronized void getChars (int srcOffset, int srcEnd,\n \t\t\t\t     char[] dst, int dstOffset)\n-    {\n-      if (srcOffset < 0 || srcOffset > srcEnd)\n-\tthrow new StringIndexOutOfBoundsException (srcOffset);\n-      int todo = srcEnd - srcOffset;\n-      if (srcEnd > count || dstOffset + todo > count)\n-\tthrow new StringIndexOutOfBoundsException (srcEnd);\n-      System.arraycopy(value, srcOffset, dst, dstOffset, todo);\n-    }\n-\n+  {\n+    if (srcOffset < 0 || srcOffset > srcEnd)\n+      throw new StringIndexOutOfBoundsException (srcOffset);\n+    int todo = srcEnd - srcOffset;\n+    if (srcEnd > count || dstOffset + todo > count)\n+      throw new StringIndexOutOfBoundsException (srcEnd);\n+    System.arraycopy(value, srcOffset, dst, dstOffset, todo);\n+  }\n+\n+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param offset the place to insert.\n+   *  @param bool the <code>boolean</code> to convert and insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(boolean)\n+   */\n   public StringBuffer insert (int offset, boolean bool)\n-    {\n-      return insert (offset, bool ? \"true\" : \"false\");\n-    }\n-\n+  {\n+    return insert (offset, bool ? \"true\" : \"false\");\n+  }\n+\n+  /** Insert the <code>char</code> argument into this <code>StringBuffer</code>.\n+   *  @param offset the place to insert.\n+   *  @param ch the <code>char</code> to insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   */\n   public synchronized StringBuffer insert (int offset, char ch)\n-    {\n-      if (offset < 0 || offset > count)\n-\tthrow new StringIndexOutOfBoundsException (offset);\n-      ensureCapacity_unsynchronized (count+1);\n-      System.arraycopy(value, offset, value, offset+1, count-offset);\n-      value[offset] = ch;\n-      count++;\n-      return this;\n-    }\n-\n+  {\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException (offset);\n+    ensureCapacity_unsynchronized (count+1);\n+    System.arraycopy(value, offset, value, offset+1, count-offset);\n+    value[offset] = ch;\n+    count++;\n+    return this;\n+  }\n+\n+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param offset the place to insert.\n+   *  @param inum the <code>int</code> to convert and insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(int)\n+   */\n   public StringBuffer insert (int offset, int inum)\n-    {\n-      return insert (offset, String.valueOf(inum));\n-    }\n-\n+  {\n+    return insert (offset, String.valueOf(inum));\n+  }\n+\n+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param offset the place to insert.\n+   *  @param lnum the <code>long</code> to convert and insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(long)\n+   */\n   public StringBuffer insert (int offset, long lnum)\n-    {\n-      return insert (offset, String.valueOf(lnum));\n-    }\n-\n+  {\n+    return insert (offset, String.valueOf(lnum));\n+  }\n+\n+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param offset the place to insert.\n+   *  @param fnum the <code>float</code> to convert and insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(float)\n+   */\n   public StringBuffer insert (int offset, float fnum)\n-    {\n-      return insert (offset, String.valueOf(fnum));\n-    }\n-\n+  {\n+    return insert (offset, String.valueOf(fnum));\n+  }\n+\n+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param offset the place to insert.\n+   *  @param dnum the <code>double</code> to convert and insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(double)\n+   */\n   public StringBuffer insert (int offset, double dnum)\n-    {\n-      return insert (offset, String.valueOf(dnum));\n-    }\n-\n+  {\n+    return insert (offset, String.valueOf(dnum));\n+  }\n+\n+  /** Insert the <code>String</code> value of the argument into this <code>StringBuffer</code>.\n+   *  Uses <code>String.valueOf()</code> to convert to\n+   *  <code>String</code>.\n+   *  @param offset the place to insert.\n+   *  @param obj the <code>Object</code> to convert and insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   *  @see java.lang.String#valueOf(java.lang.Object)\n+   */\n   public StringBuffer insert (int offset, Object obj)\n-    {\n-      return insert (offset, String.valueOf(obj));\n-    }\n-\n+  {\n+    return insert (offset, String.valueOf(obj));\n+  }\n+\n+  /** Insert the <code>String</code> argument into this <code>StringBuffer</code>.\n+   *  @param offset the place to insert.\n+   *  @param str the <code>String</code> to insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   */\n   public synchronized StringBuffer insert (int offset, String str)\n-    {\n-      if (offset < 0 || offset > count)\n-\tthrow new StringIndexOutOfBoundsException (offset);\n-      // Note that using `null' is from JDK 1.2.\n-      if (str == null)\n-\tstr = \"null\";\n-      int len = str.length();\n-      ensureCapacity_unsynchronized (count+len);\n-      System.arraycopy(value, offset, value, offset+len, count-offset);\n-      str.getChars(0, len, value, offset);\n-      count += len;\n-      return this;\n-    }\n-\n-  public synchronized StringBuffer insert (int offset, char[] data)\n-    {\n-      if (offset < 0 || offset > count)\n-\tthrow new StringIndexOutOfBoundsException (offset);\n-      int len = data.length;\n-      ensureCapacity_unsynchronized (count+len);\n-      System.arraycopy(value, offset, value, offset+len, count-offset);\n-      System.arraycopy(data, 0, value, offset, len);\n-      count += len;\n-      return this;\n-    }\n-\n+  {\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException (offset);\n+    // Note that using `null' is from JDK 1.2.\n+    if (str == null)\n+      str = \"null\";\n+    int len = str.length();\n+    ensureCapacity_unsynchronized (count+len);\n+    System.arraycopy(value, offset, value, offset+len, count-offset);\n+    str.getChars(0, len, value, offset);\n+    count += len;\n+    return this;\n+  }\n+\n+  /** Insert the <code>char[]</code> argument into this\n+   *  <code>StringBuffer</code>. \n+   *  @param offset the place to insert.\n+   *  @param data the <code>char[]</code> to insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception NullPointerException if <code>data</code> is\n+   *             <code>null</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range for this <code>StringBuffer</code>.\n+   */\n+  public StringBuffer insert (int offset, char[] data)\n+  {\n+    return insert (offset, data, 0, data.length);\n+  }\n+\n+  /** Insert the <code>char[]</code> argument into this\n+   *  <code>StringBuffer</code>.\n+   *  @param offset the place to insert.\n+   *  @param str the <code>char[]</code> to insert.\n+   *  @param str_offset the index in <code>str</code> to start inserting\n+   *         from.\n+   *  @param len the number of characters to insert.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception NullPointerException if <code>str</code> is <code>null</code>.\n+   *  @exception IndexOutOfBoundsException if <code>offset</code> is out\n+   *             of range, for this <code>StringBuffer</code>, or if\n+   *             <code>str_offset</code> or <code>str_offset+len</code>\n+   *             are out of range for <code>str</code>.\n+   */\n+  public synchronized StringBuffer insert(int offset, char[] str,\n+\t\t\t\t\t  int str_offset, int len)\n+  {\n+    if (offset < 0 || offset > count)\n+      throw new StringIndexOutOfBoundsException (offset);\n+    if (len < 0)\n+      throw new StringIndexOutOfBoundsException (len);\n+    if (str_offset < 0 || str_offset + len > str.length)\n+      throw new StringIndexOutOfBoundsException (str_offset);\n+    ensureCapacity_unsynchronized (count + len);\n+    System.arraycopy(value, offset, value, offset + len, count - offset);\n+    System.arraycopy(str, str_offset, value, offset, len);\n+    count += len;\n+    return this;\n+  }\n+\n+  /** Get the length of the <code>String</code> this\n+   *  <code>StringBuffer</code> would create.  Not to be confused with the\n+   *  <em>capacity</em> of the <code>StringBuffer</code>.\n+   *  @return the length of this <code>StringBuffer</code>.\n+   *  @see #capacity()\n+   *  @see #setLength()\n+   */\n   public int length ()\n-    {\n-      return count;\n-    }\n-\n+  {\n+    return count;\n+  }\n+\n+  /** Delete a character from this <code>StringBuffer</code>.\n+   *  @param index the index of the character to delete.\n+   *  @return this <code>StringBuffer</code>.\n+   *  @exception StringIndexOutOfBoundsException if <code>index</code>\n+   *             is out of bounds.\n+   */\n+  public synchronized StringBuffer replace (int start, int end, String str)\n+  {\n+    // FIXME: this is inefficient.\n+    delete (start, end);\n+    return insert (start, str);\n+  }\n+\n+  /** Reverse the characters in this StringBuffer.\n+   *  @return this <code>StringBuffer</code>.\n+   */\n   public synchronized StringBuffer reverse ()\n-    {\n-      for (int i = 0; i < count / 2; ++i)\n-\t{\n-\t  char c = value[i];\n-\t  value[i] = value[count - i - 1];\n-\t  value[count - i - 1] = c;\n-\t}\n-      return this;\n-    }\n-\n+  {\n+    for (int i = 0; i < count / 2; ++i)\n+      {\n+\tchar c = value[i];\n+\tvalue[i] = value[count - i - 1];\n+\tvalue[count - i - 1] = c;\n+      }\n+    return this;\n+  }\n+\n+  /** Set the character at the specified index.\n+   *  @param index the index of the character to set starting at 0.\n+   *  @param ch the value to set that character to.\n+   *  @exception IndexOutOfBoundsException if the specified character\n+   *             index is not between 0 and length() - 1 (inclusive).\n+   */\n   public synchronized void setCharAt (int index, char ch)\n-    {\n-      if (index < 0 || index >= count)\n-\tthrow new StringIndexOutOfBoundsException (index);\n-      // Call ensureCapacity to enforce copy-on-write.\n-      ensureCapacity_unsynchronized (count);\n-      value[index] = ch;\n-    }\n-\n+  {\n+    if (index < 0 || index >= count)\n+      throw new StringIndexOutOfBoundsException (index);\n+    // Call ensureCapacity to enforce copy-on-write.\n+    ensureCapacity_unsynchronized (count);\n+    value[index] = ch;\n+  }\n+\n+  /** Set the length of this StringBuffer.\n+   *  <P>\n+   *  If the new length is greater than the current length, all the new\n+   *  characters are set to '\\0'.\n+   *  <P>\n+   *  If the new length is less than the current length, the first\n+   *  <code>newLength</code> characters of the old array will be\n+   * @param newLength the new length\n+   * @exception IndexOutOfBoundsException if the new length is\n+   *            negative.\n+   * @see #length()\n+   */\n   public synchronized void setLength (int newLength)\n-    {\n-      if (newLength < 0)\n-\tthrow new StringIndexOutOfBoundsException (newLength);\n-\n-      ensureCapacity_unsynchronized (newLength);\n-      for (int i = count; i < newLength; ++i)\n-\tvalue[i] = '\\0';\n-      count = newLength;\n-    }\n-\n+  {\n+    if (newLength < 0)\n+      throw new StringIndexOutOfBoundsException (newLength);\n+\n+    ensureCapacity_unsynchronized (newLength);\n+    for (int i = count; i < newLength; ++i)\n+      value[i] = '\\0';\n+    count = newLength;\n+  }\n+\n+  /** Create a new StringBuffer with default capacity 16.\n+   *  @see JLS 20.13.1\n+   */\n   public StringBuffer ()\n-    {\n-      this (16);\n-    }\n+  {\n+    this (DEFAULT_CAPACITY);\n+  }\n \n+  /** Create an empty <code>StringBuffer</code> with the specified initial capacity.\n+   *  @param capacity the initial capacity.\n+   */\n   public StringBuffer (int capacity)\n-    {\n-      count = 0;\n-      value = new char[capacity];\n-      shared = false;\n-    }\n-\n+  {\n+    count = 0;\n+    value = new char[capacity];\n+    shared = false;\n+  }\n+\n+  /** Create a new <code>StringBuffer</code> with the characters in the specified <code>String</code>.\n+   *  Initial capacity will be the size of the String plus 16.\n+   *  @param str the <code>String</code> to make a <code>StringBuffer</code> out of.\n+   *  @XXX optimize for sharing.\n+   */\n   public StringBuffer (String str)\n-    {\n-      // The documentation is not clear, but experimentation with\n-      // other implementations indicates that StringBuffer(null)\n-      // should throw a NullPointerException.\n-      count = str.length();\n-      // JLS: The initial capacity of the string buffer is 16 plus the\n-      // length of the argument string.\n-      value = new char[count + 16];\n-      str.getChars(0, count, value, 0);\n-      shared = false;\n-    }\n-\n+  {\n+    // The documentation is not clear, but experimentation with\n+    // other implementations indicates that StringBuffer(null)\n+    // should throw a NullPointerException.\n+    count = str.length();\n+    // JLS: The initial capacity of the string buffer is 16 plus the\n+    // length of the argument string.\n+    value = new char[count + 16];\n+    str.getChars(0, count, value, 0);\n+    shared = false;\n+  }\n+\n+  /**\n+   * Creates a substring of this StringBuffer, starting at a specified index\n+   * and ending at the end of this StringBuffer.\n+   *\n+   * @param beginIndex index to start substring (base 0)\n+   * \n+   * @return new String which is a substring of this StringBuffer\n+   *\n+   * @exception StringIndexOutOfBoundsException \n+   *   if (beginIndex < 0 || beginIndex > this.length())\n+   */\n+  public String substring (int beginIndex)\n+  {\n+    return substring (beginIndex, count);\n+  }\n+\n+  /**\n+   * Creates a substring of this StringBuffer, starting at a specified index\n+   * and ending at one character before a specified index.\n+   *\n+   * @param beginIndex index to start substring (base 0)\n+   * @param endIndex index after the last character to be \n+   *   copied into the substring\n+   * \n+   * @return new String which is a substring of this StringBuffer\n+   *\n+   * @exception StringIndexOutOfBoundsException \n+   *   if (beginIndex < 0 || endIndex > this.length() || beginIndex > endIndex)\n+   */\n+  public synchronized String substring (int beginIndex, int endIndex) \n+  {\n+    if (beginIndex < 0 || endIndex > count || beginIndex > endIndex)\n+      throw new StringIndexOutOfBoundsException ();\n+    // FIXME: for libgcj it would be possible, and more efficient, to\n+    // enable sharing here.\n+    return new String (value, beginIndex, endIndex - beginIndex);\n+  }\n+\n+  /** Convert this <code>StringBuffer</code> to a <code>String</code>.\n+   *  @return the characters in this StringBuffer\n+   */\n   public String toString ()\n-    {\n-      shared = true;\n-      return new String (this);\n-    }\n-\n-  // The buffer.  Note that this has permissions set this way so that\n-  // String can get the value.\n-  char[] value;\n+  {\n+    // Note: in libgcj this causes the StringBuffer to be shared.  In\n+    // Classpath it does not.\n+    return new String (this);\n+  }\n \n   // Index of next available character.  Note that this has\n   // permissions set this way so that String can get the value.\n   int count;\n \n+  // The buffer.  Note that this has permissions set this way so that\n+  // String can get the value.\n+  char[] value;\n+\n   // True if we need to copy the buffer before writing to it again.\n   // FIXME: JDK 1.2 doesn't specify this.  The new buffer-growing\n-  // semantics make this less useful in that case, too.\n-  private boolean shared;\n+  // semantics make this less useful in that case, too.  Note that\n+  // this has permissions set this way so that String can get the\n+  // value.\n+  boolean shared;\n+\n+  static final long serialVersionUID = 3388685877147921107L;\n+  private final static int DEFAULT_CAPACITY = 16; // JLS 20.13.1\n }"}]}