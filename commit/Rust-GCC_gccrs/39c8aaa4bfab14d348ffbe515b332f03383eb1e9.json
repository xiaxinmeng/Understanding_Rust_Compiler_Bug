{"sha": "39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzljOGFhYTRiZmFiMTRkMzQ4ZmZiZTUxNWIzMzJmMDMzODNlYjFlOQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-08-07T10:44:14Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-08-07T10:44:14Z"}, "message": "convert the rest of the users of pointer_map to hash_map\n\ngcc/\n\n\t* hash-map.h (default_hashmap_traits): Adjust overloads of hash\n\tfunction to not conflict.\n\t* alias.c, cfgexpand.c, dse.c, except.h, gimple-expr.c,\n\tgimple-ssa-strength-reduction.c, gimple-ssa.h, ifcvt.c,\n\tlto-streamer-out.c, lto-streamer.h, tree-affine.c, tree-affine.h,\n\ttree-predcom.c, tree-scalar-evolution.c, tree-ssa-loop-im.c,\n\ttree-ssa-loop-niter.c, tree-ssa.c, value-prof.c: Use hash_map instead\n\tof pointer_map.\n\ngcc/cp/\n\n\t* cp-tree.h, pt.c: Use hash_map instead of pointer_map.\n\ngcc/lto/\n\n\t* lto-partition.c, lto.c: Use hash_map instead of pointer_map.\n\nFrom-SVN: r213703", "tree": {"sha": "e1ee8dbd0c20ebb30d7feede4036d428ac99a76f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1ee8dbd0c20ebb30d7feede4036d428ac99a76f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/comments", "author": null, "committer": null, "parents": [{"sha": "66b5e890ec57bcd04ccde2b69cdd88810697667e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66b5e890ec57bcd04ccde2b69cdd88810697667e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66b5e890ec57bcd04ccde2b69cdd88810697667e"}], "stats": {"total": 381, "additions": 193, "deletions": 188}, "files": [{"sha": "4c14de25edb6479ba1ca26704c0bd52356d19d43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1,3 +1,14 @@\n+2014-08-07  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* hash-map.h (default_hashmap_traits): Adjust overloads of hash\n+\tfunction to not conflict.\n+\t* alias.c, cfgexpand.c, dse.c, except.h, gimple-expr.c,\n+\tgimple-ssa-strength-reduction.c, gimple-ssa.h, ifcvt.c,\n+\tlto-streamer-out.c, lto-streamer.h, tree-affine.c, tree-affine.h,\n+\ttree-predcom.c, tree-scalar-evolution.c, tree-ssa-loop-im.c,\n+\ttree-ssa-loop-niter.c, tree-ssa.c, value-prof.c: Use hash_map instead\n+\tof pointer_map.\n+\n 2014-08-07  Marek Polacek  <polacek@redhat.com>\n \n \t* fold-const.c (fold_binary_loc): Add folding of "}, {"sha": "d8e10dbde85301798b5ea3f0771dd87838baccf6", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -302,10 +302,9 @@ ao_ref_from_mem (ao_ref *ref, const_rtx mem)\n       && ! is_global_var (base)\n       && cfun->gimple_df->decls_to_pointers != NULL)\n     {\n-      void *namep;\n-      namep = pointer_map_contains (cfun->gimple_df->decls_to_pointers, base);\n+      tree *namep = cfun->gimple_df->decls_to_pointers->get (base);\n       if (namep)\n-\tref->base = build_simple_mem_ref (*(tree *)namep);\n+\tref->base = build_simple_mem_ref (*namep);\n     }\n \n   ref->ref_alias_set = MEM_ALIAS_SET (mem);"}, {"sha": "5ac22a21765bf68801717b5df075e62ac7582366", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -216,7 +216,7 @@ struct stack_var\n static struct stack_var *stack_vars;\n static size_t stack_vars_alloc;\n static size_t stack_vars_num;\n-static struct pointer_map_t *decl_to_stack_part;\n+static hash_map<tree, size_t> *decl_to_stack_part;\n \n /* Conflict bitmaps go on this obstack.  This allows us to destroy\n    all of them in one big sweep.  */\n@@ -300,10 +300,10 @@ add_stack_var (tree decl)\n \t= XRESIZEVEC (struct stack_var, stack_vars, stack_vars_alloc);\n     }\n   if (!decl_to_stack_part)\n-    decl_to_stack_part = pointer_map_create ();\n+    decl_to_stack_part = new hash_map<tree, size_t>;\n \n   v = &stack_vars[stack_vars_num];\n-  * (size_t *)pointer_map_insert (decl_to_stack_part, decl) = stack_vars_num;\n+  decl_to_stack_part->put (decl, stack_vars_num);\n \n   v->decl = decl;\n   v->size = tree_to_uhwi (DECL_SIZE_UNIT (SSAVAR (decl)));\n@@ -375,7 +375,7 @@ visit_op (gimple, tree op, tree, void *data)\n       && DECL_P (op)\n       && DECL_RTL_IF_SET (op) == pc_rtx)\n     {\n-      size_t *v = (size_t *) pointer_map_contains (decl_to_stack_part, op);\n+      size_t *v = decl_to_stack_part->get (op);\n       if (v)\n \tbitmap_set_bit (active, *v);\n     }\n@@ -395,8 +395,7 @@ visit_conflict (gimple, tree op, tree, void *data)\n       && DECL_P (op)\n       && DECL_RTL_IF_SET (op) == pc_rtx)\n     {\n-      size_t *v =\n-\t(size_t *) pointer_map_contains (decl_to_stack_part, op);\n+      size_t *v = decl_to_stack_part->get (op);\n       if (v && bitmap_set_bit (active, *v))\n \t{\n \t  size_t num = *v;\n@@ -447,8 +446,7 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \t  if (TREE_CODE (lhs) != VAR_DECL)\n \t    continue;\n \t  if (DECL_RTL_IF_SET (lhs) == pc_rtx\n-\t      && (v = (size_t *)\n-\t\t  pointer_map_contains (decl_to_stack_part, lhs)))\n+\t      && (v = decl_to_stack_part->get (lhs)))\n \t    bitmap_clear_bit (work, *v);\n \t}\n       else if (!is_gimple_debug (stmt))\n@@ -587,14 +585,34 @@ stack_var_cmp (const void *a, const void *b)\n   return 0;\n }\n \n+struct part_traits : default_hashmap_traits\n+{\n+  template<typename T>\n+    static bool\n+    is_deleted (T &e)\n+    { return e.m_value == reinterpret_cast<void *> (1); }\n+\n+  template<typename T> static bool is_empty (T &e) { return e.m_value == NULL; }\n+  template<typename T>\n+    static void\n+    mark_deleted (T &e)\n+    { e.m_value = reinterpret_cast<T> (1); }\n+\n+  template<typename T>\n+    static void\n+    mark_empty (T &e)\n+      { e.m_value = NULL; }\n+};\n+\n+typedef hash_map<size_t, bitmap, part_traits> part_hashmap;\n \n /* If the points-to solution *PI points to variables that are in a partition\n    together with other variables add all partition members to the pointed-to\n    variables bitmap.  */\n \n static void\n add_partitioned_vars_to_ptset (struct pt_solution *pt,\n-\t\t\t       struct pointer_map_t *decls_to_partitions,\n+\t\t\t       part_hashmap *decls_to_partitions,\n \t\t\t       hash_set<bitmap> *visited, bitmap temp)\n {\n   bitmap_iterator bi;\n@@ -616,8 +634,7 @@ add_partitioned_vars_to_ptset (struct pt_solution *pt,\n   EXECUTE_IF_SET_IN_BITMAP (pt->vars, 0, i, bi)\n     if ((!temp\n \t || !bitmap_bit_p (temp, i))\n-\t&& (part = (bitmap *) pointer_map_contains (decls_to_partitions,\n-\t\t\t\t\t\t    (void *)(size_t) i)))\n+\t&& (part = decls_to_partitions->get (i)))\n       bitmap_ior_into (temp, *part);\n   if (!bitmap_empty_p (temp))\n     bitmap_ior_into (pt->vars, temp);\n@@ -631,7 +648,7 @@ add_partitioned_vars_to_ptset (struct pt_solution *pt,\n static void\n update_alias_info_with_stack_vars (void)\n {\n-  struct pointer_map_t *decls_to_partitions = NULL;\n+  part_hashmap *decls_to_partitions = NULL;\n   size_t i, j;\n   tree var = NULL_TREE;\n \n@@ -648,8 +665,8 @@ update_alias_info_with_stack_vars (void)\n \n       if (!decls_to_partitions)\n \t{\n-\t  decls_to_partitions = pointer_map_create ();\n-\t  cfun->gimple_df->decls_to_pointers = pointer_map_create ();\n+\t  decls_to_partitions = new part_hashmap;\n+\t  cfun->gimple_df->decls_to_pointers = new hash_map<tree, tree>;\n \t}\n \n       /* Create an SSA_NAME that points to the partition for use\n@@ -667,10 +684,8 @@ update_alias_info_with_stack_vars (void)\n \t  tree decl = stack_vars[j].decl;\n \t  unsigned int uid = DECL_PT_UID (decl);\n \t  bitmap_set_bit (part, uid);\n-\t  *((bitmap *) pointer_map_insert (decls_to_partitions,\n-\t\t\t\t\t   (void *)(size_t) uid)) = part;\n-\t  *((tree *) pointer_map_insert (cfun->gimple_df->decls_to_pointers,\n-\t\t\t\t\t decl)) = name;\n+\t  decls_to_partitions->put (uid, part);\n+\t  cfun->gimple_df->decls_to_pointers->put (decl, name);\n \t  if (TREE_ADDRESSABLE (decl))\n \t    TREE_ADDRESSABLE (name) = 1;\n \t}\n@@ -703,7 +718,7 @@ update_alias_info_with_stack_vars (void)\n       add_partitioned_vars_to_ptset (&cfun->gimple_df->escaped,\n \t\t\t\t     decls_to_partitions, &visited, temp);\n \n-      pointer_map_destroy (decls_to_partitions);\n+      delete decls_to_partitions;\n       BITMAP_FREE (temp);\n     }\n }\n@@ -1530,7 +1545,7 @@ init_vars_expansion (void)\n   bitmap_obstack_initialize (&stack_var_bitmap_obstack);\n \n   /* A map from decl to stack partition.  */\n-  decl_to_stack_part = pointer_map_create ();\n+  decl_to_stack_part = new hash_map<tree, size_t>;\n \n   /* Initialize local stack smashing state.  */\n   has_protected_decls = false;\n@@ -1549,7 +1564,7 @@ fini_vars_expansion (void)\n   stack_vars = NULL;\n   stack_vars_sorted = NULL;\n   stack_vars_alloc = stack_vars_num = 0;\n-  pointer_map_destroy (decl_to_stack_part);\n+  delete decl_to_stack_part;\n   decl_to_stack_part = NULL;\n }\n \n@@ -1666,7 +1681,6 @@ expand_used_vars (void)\n   tree var, outer_block = DECL_INITIAL (current_function_decl);\n   vec<tree> maybe_local_decls = vNULL;\n   rtx var_end_seq = NULL_RTX;\n-  struct pointer_map_t *ssa_name_decls;\n   unsigned i;\n   unsigned len;\n   bool gen_stack_protect_signal = false;\n@@ -1686,7 +1700,7 @@ expand_used_vars (void)\n \n   init_vars_expansion ();\n \n-  ssa_name_decls = pointer_map_create ();\n+  hash_map<tree, tree> ssa_name_decls;\n   for (i = 0; i < SA.map->num_partitions; i++)\n     {\n       tree var = partition_to_var (SA.map, i);\n@@ -1697,10 +1711,10 @@ expand_used_vars (void)\n          we could have coalesced (those with the same type).  */\n       if (SSA_NAME_VAR (var) == NULL_TREE)\n \t{\n-\t  void **slot = pointer_map_insert (ssa_name_decls, TREE_TYPE (var));\n+\t  tree *slot = &ssa_name_decls.get_or_insert (TREE_TYPE (var));\n \t  if (!*slot)\n-\t    *slot = (void *) create_tmp_reg (TREE_TYPE (var), NULL);\n-\t  replace_ssa_name_symbol (var, (tree) *slot);\n+\t    *slot = create_tmp_reg (TREE_TYPE (var), NULL);\n+\t  replace_ssa_name_symbol (var, *slot);\n \t}\n \n       /* Always allocate space for partitions based on VAR_DECLs.  But for\n@@ -1727,7 +1741,6 @@ expand_used_vars (void)\n \t    }\n \t}\n     }\n-  pointer_map_destroy (ssa_name_decls);\n \n   if (flag_stack_protect == SPCT_FLAG_STRONG)\n       gen_stack_protect_signal\n@@ -1957,7 +1970,7 @@ maybe_dump_rtl_for_gimple_stmt (gimple stmt, rtx since)\n \n /* Maps the blocks that do not contain tree labels to rtx labels.  */\n \n-static struct pointer_map_t *lab_rtx_for_bb;\n+static hash_map<basic_block, rtx> *lab_rtx_for_bb;\n \n /* Returns the label_rtx expression for a label starting basic block BB.  */\n \n@@ -1967,14 +1980,13 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n   gimple_stmt_iterator gsi;\n   tree lab;\n   gimple lab_stmt;\n-  void **elt;\n \n   if (bb->flags & BB_RTL)\n     return block_label (bb);\n \n-  elt = pointer_map_contains (lab_rtx_for_bb, bb);\n+  rtx *elt = lab_rtx_for_bb->get (bb);\n   if (elt)\n-    return (rtx) *elt;\n+    return *elt;\n \n   /* Find the tree label if it is present.  */\n \n@@ -1991,9 +2003,9 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n       return label_rtx (lab);\n     }\n \n-  elt = pointer_map_insert (lab_rtx_for_bb, bb);\n-  *elt = gen_label_rtx ();\n-  return (rtx) *elt;\n+  rtx l = gen_label_rtx ();\n+  lab_rtx_for_bb->put (bb, l);\n+  return l;\n }\n \n \n@@ -4878,7 +4890,6 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n   rtx note, last;\n   edge e;\n   edge_iterator ei;\n-  void **elt;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\n;; Generating RTL for gimple basic block %d\\n\",\n@@ -4922,7 +4933,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \tstmt = NULL;\n     }\n \n-  elt = pointer_map_contains (lab_rtx_for_bb, bb);\n+  rtx *elt = lab_rtx_for_bb->get (bb);\n \n   if (stmt || elt)\n     {\n@@ -4935,7 +4946,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t}\n \n       if (elt)\n-\temit_label ((rtx) *elt);\n+\temit_label (*elt);\n \n       /* Java emits line number notes in the top of labels.\n \t ??? Make this go away once line number notes are obsoleted.  */\n@@ -5792,7 +5803,7 @@ pass_expand::execute (function *fun)\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (fun)->succs)\n     e->flags &= ~EDGE_EXECUTABLE;\n \n-  lab_rtx_for_bb = pointer_map_create ();\n+  lab_rtx_for_bb = new hash_map<basic_block, rtx>;\n   FOR_BB_BETWEEN (bb, init_block->next_bb, EXIT_BLOCK_PTR_FOR_FN (fun),\n \t\t  next_bb)\n     bb = expand_gimple_basic_block (bb, var_ret_seq != NULL_RTX);\n@@ -5816,7 +5827,7 @@ pass_expand::execute (function *fun)\n \n   /* Expansion is used by optimization passes too, set maybe_hot_insn_p\n      conservatively to true until they are all profile aware.  */\n-  pointer_map_destroy (lab_rtx_for_bb);\n+  delete lab_rtx_for_bb;\n   free_histograms ();\n \n   construct_exit_block ();"}, {"sha": "d218152f17bf1ac84584afb34d8a28f54c39d5bd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1,3 +1,7 @@\n+2014-08-07  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* cp-tree.h, pt.c: Use hash_map instead of pointer_map.\n+\n 2014-08-06  Jason Merrill  <jason@redhat.com>\n \n \t* init.c (build_vec_init): Fix constant initialization of"}, {"sha": "ec79c232ec6d0acadb0f83b72e6009b2855c325b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"hashtab.h\"\n #include \"vec.h\"\n+#include \"hash-map.h\"\n \n /* In order for the format checking to accept the C++ front end\n    diagnostic framework extensions, you must include this file before\n@@ -1064,7 +1065,7 @@ struct GTY(()) saved_scope {\n   cp_binding_level *class_bindings;\n   cp_binding_level *bindings;\n \n-  struct pointer_map_t *x_local_specializations;\n+  hash_map<tree, tree> *GTY((skip)) x_local_specializations;\n \n   struct saved_scope *prev;\n };"}, {"sha": "5fa33b906c7f349595ced5143604077d8b83f506", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1112,13 +1112,11 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)\n static tree\n retrieve_local_specialization (tree tmpl)\n {\n-  void **slot;\n-\n   if (local_specializations == NULL)\n     return NULL_TREE;\n \n-  slot = pointer_map_contains (local_specializations, tmpl);\n-  return slot ? (tree) *slot : NULL_TREE;\n+  tree *slot = local_specializations->get (tmpl);\n+  return slot ? *slot : NULL_TREE;\n }\n \n /* Returns nonzero iff DECL is a specialization of TMPL.  */\n@@ -1730,10 +1728,7 @@ reregister_specialization (tree spec, tree tinfo, tree new_spec)\n static void\n register_local_specialization (tree spec, tree tmpl)\n {\n-  void **slot;\n-\n-  slot = pointer_map_insert (local_specializations, tmpl);\n-  *slot = spec;\n+  local_specializations->put (tmpl, spec);\n }\n \n /* TYPE is a class type.  Returns true if TYPE is an explicitly\n@@ -9772,7 +9767,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n   bool unsubstituted_packs = false;\n   int i, len = -1;\n   tree result;\n-  struct pointer_map_t *saved_local_specializations = NULL;\n+  hash_map<tree, tree> *saved_local_specializations = NULL;\n   bool need_local_specializations = false;\n   int levels;\n \n@@ -9926,7 +9921,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t case of recursive unification) might have bindings that we don't\n \t want to use or alter.  */\n       saved_local_specializations = local_specializations;\n-      local_specializations = pointer_map_create ();\n+      local_specializations = new hash_map<tree, tree>;\n     }\n \n   /* For each argument in each argument pack, substitute into the\n@@ -9975,7 +9970,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \n   if (need_local_specializations)\n     {\n-      pointer_map_destroy (local_specializations);\n+      delete local_specializations;\n       local_specializations = saved_local_specializations;\n     }\n   \n@@ -20089,7 +20084,7 @@ instantiate_decl (tree d, int defer_ok,\n     synthesize_method (d);\n   else if (TREE_CODE (d) == FUNCTION_DECL)\n     {\n-      struct pointer_map_t *saved_local_specializations;\n+      hash_map<tree, tree> *saved_local_specializations;\n       tree subst_decl;\n       tree tmpl_parm;\n       tree spec_parm;\n@@ -20100,7 +20095,7 @@ instantiate_decl (tree d, int defer_ok,\n       saved_local_specializations = local_specializations;\n \n       /* Set up the list of local specializations.  */\n-      local_specializations = pointer_map_create ();\n+      local_specializations = new hash_map<tree, tree>;\n \n       /* Set up context.  */\n       if (DECL_OMP_DECLARE_REDUCTION_P (code_pattern)\n@@ -20164,7 +20159,7 @@ instantiate_decl (tree d, int defer_ok,\n \t}\n \n       /* We don't need the local specializations any more.  */\n-      pointer_map_destroy (local_specializations);\n+      delete local_specializations;\n       local_specializations = saved_local_specializations;\n \n       /* Finish the function.  */"}, {"sha": "6370c97b9de57902ad3c3e0eda394859fc7e8687", "filename": "gcc/dse.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -986,10 +986,9 @@ local_variable_can_escape (tree decl)\n      of the escape analysis.  */\n   if (cfun->gimple_df->decls_to_pointers != NULL)\n     {\n-      void *namep\n-\t= pointer_map_contains (cfun->gimple_df->decls_to_pointers, decl);\n+      tree *namep = cfun->gimple_df->decls_to_pointers->get (decl);\n       if (namep)\n-\treturn TREE_ADDRESSABLE (*(tree *)namep);\n+\treturn TREE_ADDRESSABLE (*namep);\n     }\n \n   return false;"}, {"sha": "9bdb6bd2627d5c8c6b64043bcf1e74b437ddce89", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -30,7 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n \n struct function;\n struct eh_region_d;\n-struct pointer_map_t;\n \n /* The type of an exception region.  */\n enum eh_region_type"}, {"sha": "73285b282a79a29b6279351a16358bbf9cd78a25", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -883,10 +883,9 @@ mark_addressable (tree x)\n       && cfun->gimple_df != NULL\n       && cfun->gimple_df->decls_to_pointers != NULL)\n     {\n-      void *namep\n-\t= pointer_map_contains (cfun->gimple_df->decls_to_pointers, x); \n+      tree *namep = cfun->gimple_df->decls_to_pointers->get (x);\n       if (namep)\n-\tTREE_ADDRESSABLE (*(tree *)namep) = 1;\n+\tTREE_ADDRESSABLE (*namep) = 1;\n     }\n }\n "}, {"sha": "a9e01613150eb086843d7a668b34211e9f9a30c8", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -434,7 +434,7 @@ cand_chain_hasher::equal (const value_type *chain1, const compare_type *chain2)\n static hash_table<cand_chain_hasher> *base_cand_map;\n \f\n /* Pointer map used by tree_to_aff_combination_expand.  */\n-static struct pointer_map_t *name_expansions;\n+static hash_map<tree, name_expansion *> *name_expansions;\n /* Pointer map embodying a mapping from bases to alternative bases.  */\n static hash_map<tree, tree> *alt_base_map;\n "}, {"sha": "d2e62a94b378d074ecdace5ccd52f9aa8da8524c", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GIMPLE_SSA_H\n #define GCC_GIMPLE_SSA_H\n \n+#include \"hash-map.h\"\n #include \"tree-ssa-operands.h\"\n \n /* This structure is used to map a gimple statement to a label,\n@@ -53,7 +54,7 @@ struct GTY(()) gimple_df {\n \n   /* A map of decls to artificial ssa-names that point to the partition\n      of the decl.  */\n-  struct pointer_map_t * GTY((skip(\"\"))) decls_to_pointers;\n+  hash_map<tree, tree> * GTY((skip(\"\"))) decls_to_pointers;\n \n   /* Free list of SSA_NAMEs.  */\n   vec<tree, va_gc> *free_ssanames;"}, {"sha": "d2eed337ad4530ed9484cba927f80a955b5f8afd", "filename": "gcc/hash-map.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -36,12 +36,9 @@ struct default_hashmap_traits\n       return uintptr_t(p) >> 3;\n     }\n \n-  /* The right thing to do here would be using is_integral to only allow\n-     template arguments of integer type, but reimplementing that is a pain, so\n-     we'll just promote everything to [u]int64_t and truncate to hashval_t.  */\n+  /* If the value converts to hashval_t just use it.  */\n \n-  static hashval_t hash (uint64_t v) { return v; }\n-  static hashval_t hash (int64_t v) { return v; }\n+  template<typename T> static hashval_t hash (T v) { return v; }\n \n   /* Return true if the two keys passed as arguments are equal.  */\n "}, {"sha": "e9f56c12d1dae29026b4ca74723699ee2d3cfecf", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -2727,7 +2727,7 @@ noce_process_if_block (struct noce_if_info *if_info)\n \n static int\n check_cond_move_block (basic_block bb,\n-\t\t       struct pointer_map_t *vals,\n+\t\t       hash_map<rtx, rtx> *vals,\n \t\t       vec<rtx> *regs,\n \t\t       rtx cond)\n {\n@@ -2742,7 +2742,6 @@ check_cond_move_block (basic_block bb,\n   FOR_BB_INSNS (bb, insn)\n     {\n       rtx set, dest, src;\n-      void **slot;\n \n       if (!NONDEBUG_INSN_P (insn) || JUMP_P (insn))\n \tcontinue;\n@@ -2769,14 +2768,14 @@ check_cond_move_block (basic_block bb,\n       /* Don't try to handle this if the source register was\n \t modified earlier in the block.  */\n       if ((REG_P (src)\n-\t   && pointer_map_contains (vals, src))\n+\t   && vals->get (src))\n \t  || (GET_CODE (src) == SUBREG && REG_P (SUBREG_REG (src))\n-\t      && pointer_map_contains (vals, SUBREG_REG (src))))\n+\t      && vals->get (SUBREG_REG (src))))\n \treturn FALSE;\n \n       /* Don't try to handle this if the destination register was\n \t modified earlier in the block.  */\n-      if (pointer_map_contains (vals, dest))\n+      if (vals->get (dest))\n \treturn FALSE;\n \n       /* Don't try to handle this if the condition uses the\n@@ -2790,8 +2789,7 @@ check_cond_move_block (basic_block bb,\n \t  && modified_between_p (src, insn, NEXT_INSN (BB_END (bb))))\n \treturn FALSE;\n \n-      slot = pointer_map_insert (vals, (void *) dest);\n-      *slot = (void *) src;\n+      vals->put (dest, src);\n \n       regs->safe_push (dest);\n     }\n@@ -2809,8 +2807,8 @@ check_cond_move_block (basic_block bb,\n static bool\n cond_move_convert_if_block (struct noce_if_info *if_infop,\n \t\t\t    basic_block bb, rtx cond,\n-\t\t\t    struct pointer_map_t *then_vals,\n-\t\t\t    struct pointer_map_t *else_vals,\n+\t\t\t    hash_map<rtx, rtx> *then_vals,\n+\t\t\t    hash_map<rtx, rtx> *else_vals,\n \t\t\t    bool else_block_p)\n {\n   enum rtx_code code;\n@@ -2823,7 +2821,6 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n   FOR_BB_INSNS (bb, insn)\n     {\n       rtx set, target, dest, t, e;\n-      void **then_slot, **else_slot;\n \n       /* ??? Maybe emit conditional debug insn?  */\n       if (!NONDEBUG_INSN_P (insn) || JUMP_P (insn))\n@@ -2833,10 +2830,10 @@ cond_move_convert_if_block (struct noce_if_info *if_infop,\n \n       dest = SET_DEST (set);\n \n-      then_slot = pointer_map_contains (then_vals, dest);\n-      else_slot = pointer_map_contains (else_vals, dest);\n-      t = then_slot ? (rtx) *then_slot : NULL_RTX;\n-      e = else_slot ? (rtx) *else_slot : NULL_RTX;\n+      rtx *then_slot = then_vals->get (dest);\n+      rtx *else_slot = else_vals->get (dest);\n+      t = then_slot ? *then_slot : NULL_RTX;\n+      e = else_slot ? *else_slot : NULL_RTX;\n \n       if (else_block_p)\n \t{\n@@ -2882,22 +2879,20 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   rtx seq, loc_insn;\n   rtx reg;\n   int c;\n-  struct pointer_map_t *then_vals;\n-  struct pointer_map_t *else_vals;\n   vec<rtx> then_regs = vNULL;\n   vec<rtx> else_regs = vNULL;\n   unsigned int i;\n   int success_p = FALSE;\n \n   /* Build a mapping for each block to the value used for each\n      register.  */\n-  then_vals = pointer_map_create ();\n-  else_vals = pointer_map_create ();\n+  hash_map<rtx, rtx> then_vals;\n+  hash_map<rtx, rtx> else_vals;\n \n   /* Make sure the blocks are suitable.  */\n-  if (!check_cond_move_block (then_bb, then_vals, &then_regs, cond)\n+  if (!check_cond_move_block (then_bb, &then_vals, &then_regs, cond)\n       || (else_bb\n-\t  && !check_cond_move_block (else_bb, else_vals, &else_regs, cond)))\n+\t  && !check_cond_move_block (else_bb, &else_vals, &else_regs, cond)))\n     goto done;\n \n   /* Make sure the blocks can be used together.  If the same register\n@@ -2909,16 +2904,16 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   c = 0;\n   FOR_EACH_VEC_ELT (then_regs, i, reg)\n     {\n-      void **then_slot = pointer_map_contains (then_vals, reg);\n-      void **else_slot = pointer_map_contains (else_vals, reg);\n+      rtx *then_slot = then_vals.get (reg);\n+      rtx *else_slot = else_vals.get (reg);\n \n       gcc_checking_assert (then_slot);\n       if (!else_slot)\n \t++c;\n       else\n \t{\n-\t  rtx then_val = (rtx) *then_slot;\n-\t  rtx else_val = (rtx) *else_slot;\n+\t  rtx then_val = *then_slot;\n+\t  rtx else_val = *else_slot;\n \t  if (!CONSTANT_P (then_val) && !CONSTANT_P (else_val)\n \t      && !rtx_equal_p (then_val, else_val))\n \t    goto done;\n@@ -2928,8 +2923,8 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   /* Finish off c for MAX_CONDITIONAL_EXECUTE.  */\n   FOR_EACH_VEC_ELT (else_regs, i, reg)\n     {\n-      gcc_checking_assert (pointer_map_contains (else_vals, reg));\n-      if (!pointer_map_contains (then_vals, reg))\n+      gcc_checking_assert (else_vals.get (reg));\n+      if (!then_vals.get (reg))\n \t++c;\n     }\n \n@@ -2944,10 +2939,10 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n      then do anything left in the else blocks.  */\n   start_sequence ();\n   if (!cond_move_convert_if_block (if_info, then_bb, cond,\n-\t\t\t\t   then_vals, else_vals, false)\n+\t\t\t\t   &then_vals, &else_vals, false)\n       || (else_bb\n \t  && !cond_move_convert_if_block (if_info, else_bb, cond,\n-\t\t\t\t\t  then_vals, else_vals, true)))\n+\t\t\t\t\t  &then_vals, &else_vals, true)))\n     {\n       end_sequence ();\n       goto done;\n@@ -2988,8 +2983,6 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   success_p = TRUE;\n \n done:\n-  pointer_map_destroy (then_vals);\n-  pointer_map_destroy (else_vals);\n   then_regs.release ();\n   else_regs.release ();\n   return success_p;"}, {"sha": "d6fec4c29f5396335b8dbb1a52276ad85e0d5968", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -475,15 +475,14 @@ class DFS\n   hash_scc (struct output_block *ob, unsigned first, unsigned size);\n \n   unsigned int next_dfs_num;\n-  struct pointer_map_t *sccstate;\n+  hash_map<tree, sccs *> sccstate;\n   struct obstack sccstate_obstack;\n };\n \n DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n \t  bool single_p)\n {\n   sccstack.create (0);\n-  sccstate = pointer_map_create ();\n   gcc_obstack_init (&sccstate_obstack);\n   next_dfs_num = 1;\n   DFS_write_tree (ob, NULL, expr, ref_p, this_ref_p, single_p);\n@@ -492,7 +491,6 @@ DFS::DFS (struct output_block *ob, tree expr, bool ref_p, bool this_ref_p,\n DFS::~DFS ()\n {\n   sccstack.release ();\n-  pointer_map_destroy (sccstate);\n   obstack_free (&sccstate_obstack, NULL);\n }\n \n@@ -1314,7 +1312,6 @@ DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n \t\t     tree expr, bool ref_p, bool this_ref_p, bool single_p)\n {\n   unsigned ix;\n-  sccs **slot;\n \n   /* Handle special cases.  */\n   if (expr == NULL_TREE)\n@@ -1328,7 +1325,7 @@ DFS::DFS_write_tree (struct output_block *ob, sccs *from_state,\n   if (streamer_tree_cache_lookup (ob->writer_cache, expr, &ix))\n     return;\n \n-  slot = (sccs **)pointer_map_insert (sccstate, expr);\n+  sccs **slot = &sccstate.get_or_insert (expr);\n   sccs *cstate = *slot;\n   if (!cstate)\n     {"}, {"sha": "f304ba2098f1d25ca2dfe627776500bbf163d8da", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -561,7 +561,7 @@ struct GTY(()) lto_file_decl_data\n   struct gcov_ctr_summary GTY((skip)) profile_info;\n \n   /* Map assigning declarations their resolutions.  */\n-  pointer_map_t * GTY((skip)) resolution_map;\n+  hash_map<tree, ld_plugin_symbol_resolution> * GTY((skip)) resolution_map;\n };\n \n typedef struct lto_file_decl_data *lto_file_decl_data_ptr;"}, {"sha": "20f81b111207dd713d6abc1b60fcc234875e975b", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1,3 +1,7 @@\n+2014-08-07  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* lto-partition.c, lto.c: Use hash_map instead of pointer_map.\n+\n 2014-08-02  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* lto-partition.c, lto-partition.h: Use hash_set instead of"}, {"sha": "1837b99f3843fde71a086a68e56036071861a84f", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -268,13 +268,10 @@ lto_1_to_1_map (void)\n {\n   symtab_node *node;\n   struct lto_file_decl_data *file_data;\n-  struct pointer_map_t *pmap;\n+  hash_map<lto_file_decl_data *, ltrans_partition> pmap;\n   ltrans_partition partition;\n-  void **slot;\n   int npartitions = 0;\n \n-  pmap = pointer_map_create ();\n-\n   FOR_EACH_SYMBOL (node)\n     {\n       if (node->get_partitioning_class () != SYMBOL_PARTITION\n@@ -285,13 +282,12 @@ lto_1_to_1_map (void)\n \n       if (file_data)\n \t{\n-          slot = pointer_map_contains (pmap, file_data);\n-          if (slot)\n-\t    partition = (ltrans_partition) *slot;\n+          ltrans_partition *slot = &pmap.get_or_insert (file_data);\n+          if (*slot)\n+\t    partition = *slot;\n \t  else\n \t    {\n \t      partition = new_partition (file_data->file_name);\n-\t      slot = pointer_map_insert (pmap, file_data);\n \t      *slot = partition;\n \t      npartitions++;\n \t    }\n@@ -301,8 +297,7 @@ lto_1_to_1_map (void)\n       else\n \t{\n \t  partition = new_partition (\"\");\n-\t  slot = pointer_map_insert (pmap, NULL);\n-\t  *slot = partition;\n+\t  pmap.put (NULL, partition);\n \t  npartitions++;\n \t}\n \n@@ -314,8 +309,6 @@ lto_1_to_1_map (void)\n   if (!npartitions)\n     new_partition (\"empty\");\n \n-  pointer_map_destroy (pmap);\n-\n }\n \n /* Maximal partitioning.  Put every new symbol into new partition if possible.  */"}, {"sha": "6f864d90fa7236240901ebacb3eea78c553bf2bb", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1007,8 +1007,9 @@ register_resolution (struct lto_file_decl_data *file_data, tree decl,\n   if (resolution == LDPR_UNKNOWN)\n     return;\n   if (!file_data->resolution_map)\n-    file_data->resolution_map = pointer_map_create ();\n-  *pointer_map_insert (file_data->resolution_map, decl) = (void *)(size_t)resolution;\n+    file_data->resolution_map\n+      = new hash_map<tree, ld_plugin_symbol_resolution>;\n+  file_data->resolution_map->put (decl, resolution);\n }\n \n /* Register DECL with the global symbol table and change its\n@@ -2887,7 +2888,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   FILE *resolution;\n   int count = 0;\n   struct lto_file_decl_data **decl_data;\n-  void **res;\n   symtab_node *snode;\n \n   init_cgraph ();\n@@ -3014,18 +3014,17 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n   /* Store resolutions into the symbol table.  */\n \n+  ld_plugin_symbol_resolution_t *res;\n   FOR_EACH_SYMBOL (snode)\n     if (snode->real_symbol_p ()\n \t&& snode->lto_file_data\n \t&& snode->lto_file_data->resolution_map\n-\t&& (res = pointer_map_contains (snode->lto_file_data->resolution_map,\n-\t\t\t\t\tsnode->decl)))\n-      snode->resolution\n-\t= (enum ld_plugin_symbol_resolution)(size_t)*res;\n+\t&& (res = snode->lto_file_data->resolution_map->get (snode->decl)))\n+      snode->resolution = *res;\n   for (i = 0; all_file_decl_data[i]; i++)\n     if (all_file_decl_data[i]->resolution_map)\n       {\n-        pointer_map_destroy (all_file_decl_data[i]->resolution_map);\n+        delete all_file_decl_data[i]->resolution_map;\n         all_file_decl_data[i]->resolution_map = NULL;\n       }\n   "}, {"sha": "5c894ea6f78f2326fb2ac8a3ea340962b4274dee", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -621,14 +621,13 @@ struct name_expansion\n \n void\n aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n-\t\t\tstruct pointer_map_t **cache ATTRIBUTE_UNUSED)\n+\t\t\thash_map<tree, name_expansion *> **cache)\n {\n   unsigned i;\n   aff_tree to_add, current, curre;\n   tree e, rhs;\n   gimple def;\n   widest_int scale;\n-  void **slot;\n   struct name_expansion *exp;\n \n   aff_combination_zero (&to_add, comb->type);\n@@ -664,9 +663,9 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n \tcontinue;\n \n       if (!*cache)\n-\t*cache = pointer_map_create ();\n-      slot = pointer_map_insert (*cache, e);\n-      exp = (struct name_expansion *) *slot;\n+\t*cache = new hash_map<tree, name_expansion *>;\n+      name_expansion **slot = &(*cache)->get_or_insert (e);\n+      exp = *slot;\n \n       if (!exp)\n \t{\n@@ -732,36 +731,33 @@ aff_combination_expand (aff_tree *comb ATTRIBUTE_UNUSED,\n \n void\n tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n-\t\t\t\tstruct pointer_map_t **cache)\n+\t\t\t\thash_map<tree, name_expansion *> **cache)\n {\n   tree_to_aff_combination (expr, type, comb);\n   aff_combination_expand (comb, cache);\n }\n \n /* Frees memory occupied by struct name_expansion in *VALUE.  Callback for\n-   pointer_map_traverse.  */\n+   hash_map::traverse.  */\n \n-static bool\n-free_name_expansion (const void *key ATTRIBUTE_UNUSED, void **value,\n-\t\t     void *data ATTRIBUTE_UNUSED)\n+bool\n+free_name_expansion (tree const &, name_expansion **value, void *)\n {\n-  struct name_expansion *const exp = (struct name_expansion *) *value;\n-\n-  free (exp);\n+  free (*value);\n   return true;\n }\n \n /* Frees memory allocated for the CACHE used by\n    tree_to_aff_combination_expand.  */\n \n void\n-free_affine_expand_cache (struct pointer_map_t **cache)\n+free_affine_expand_cache (hash_map<tree, name_expansion *> **cache)\n {\n   if (!*cache)\n     return;\n \n-  pointer_map_traverse (*cache, free_name_expansion, NULL);\n-  pointer_map_destroy (*cache);\n+  (*cache)->traverse<void *, free_name_expansion> (NULL);\n+  delete (*cache);\n   *cache = NULL;\n }\n "}, {"sha": "48dd2a79f19d25016b8f905b2f1d4ccb9b742659", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -20,6 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Affine combination of trees.  We keep track of at most MAX_AFF_ELTS elements\n    to make things simpler; this is sufficient in most cases.  */\n \n+#include \"hash-map.h\"\n #include \"wide-int.h\"\n \n #define MAX_AFF_ELTS 8\n@@ -60,6 +61,8 @@ struct aff_tree\n   tree rest;\n };\n \n+struct name_expansion;\n+\n widest_int wide_int_ext_for_comb (const widest_int &, aff_tree *);\n void aff_combination_const (aff_tree *, tree, const widest_int &);\n void aff_combination_elt (aff_tree *, tree, tree);\n@@ -73,11 +76,11 @@ void tree_to_aff_combination (tree, tree, aff_tree *);\n tree aff_combination_to_tree (aff_tree *);\n void unshare_aff_combination (aff_tree *);\n bool aff_combination_constant_multiple_p (aff_tree *, aff_tree *, widest_int *);\n-void aff_combination_expand (aff_tree *, struct pointer_map_t **);\n+void aff_combination_expand (aff_tree *, hash_map<tree, name_expansion *> **);\n void tree_to_aff_combination_expand (tree, tree, aff_tree *,\n-\t\t\t\t     struct pointer_map_t **);\n+\t\t\t\t     hash_map<tree, name_expansion *> **);\n tree get_inner_reference_aff (tree, aff_tree *, widest_int *);\n-void free_affine_expand_cache (struct pointer_map_t **);\n+void free_affine_expand_cache (hash_map<tree, name_expansion *> **);\n bool aff_comb_cannot_overlap_p (aff_tree *, const widest_int &,\n \t\t\t\tconst widest_int &);\n "}, {"sha": "73489851e4614b28fcc8e009b8e176d19f8a4a18", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -350,7 +350,7 @@ static bitmap looparound_phis;\n \n /* Cache used by tree_to_aff_combination_expand.  */\n \n-static struct pointer_map_t *name_expansions;\n+static hash_map<tree, name_expansion *> *name_expansions;\n \n /* Dumps data reference REF to FILE.  */\n "}, {"sha": "3c40b003f023e0571e7674f531ad3fde0d221a43", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1403,7 +1403,7 @@ simplify_peeled_chrec (struct loop *loop, tree arg, tree init_cond)\n {\n   aff_tree aff1, aff2;\n   tree ev, left, right, type, step_val;\n-  pointer_map_t *peeled_chrec_map = NULL;\n+  hash_map<tree, name_expansion *> *peeled_chrec_map = NULL;\n \n   ev = instantiate_parameters (loop, analyze_scalar_evolution (loop, arg));\n   if (ev == NULL_TREE || TREE_CODE (ev) != POLYNOMIAL_CHREC)"}, {"sha": "6239a7085f3ac6afc38353515dd47454fc0a9e17", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -200,7 +200,7 @@ static struct\n   vec<bitmap_head> all_refs_stored_in_loop;\n \n   /* Cache for expanding memory addresses.  */\n-  struct pointer_map_t *ttae_cache;\n+  hash_map<tree, name_expansion *> *ttae_cache;\n } memory_accesses;\n \n /* Obstack for the bitmaps in the above data structures.  */\n@@ -1610,7 +1610,7 @@ analyze_memory_references (void)\n \n static bool\n mem_refs_may_alias_p (mem_ref_p mem1, mem_ref_p mem2,\n-\t\t      struct pointer_map_t **ttae_cache)\n+\t\t      hash_map<tree, name_expansion *> **ttae_cache)\n {\n   /* Perform BASE + OFFSET analysis -- if MEM1 and MEM2 are based on the same\n      object and their offset differ in such a way that the locations cannot"}, {"sha": "c95cde840360ac868907340b9d276089d829f72c", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -3108,14 +3108,12 @@ bound_index (vec<widest_int> bounds, const widest_int &bound)\n static void\n discover_iteration_bound_by_body_walk (struct loop *loop)\n {\n-  pointer_map_t *bb_bounds;\n   struct nb_iter_bound *elt;\n   vec<widest_int> bounds = vNULL;\n   vec<vec<basic_block> > queues = vNULL;\n   vec<basic_block> queue = vNULL;\n   ptrdiff_t queue_index;\n   ptrdiff_t latch_index = 0;\n-  pointer_map_t *block_priority;\n \n   /* Discover what bounds may interest us.  */\n   for (elt = loop->bounds; elt; elt = elt->next)\n@@ -3150,7 +3148,7 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n   /* For every basic block record the lowest bound that is guaranteed to\n      terminate the loop.  */\n \n-  bb_bounds = pointer_map_create ();\n+  hash_map<basic_block, ptrdiff_t> bb_bounds;\n   for (elt = loop->bounds; elt; elt = elt->next)\n     {\n       widest_int bound = elt->bound;\n@@ -3166,17 +3164,15 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n \t  || wi::ltu_p (bound, loop->nb_iterations_upper_bound))\n \t{\n \t  ptrdiff_t index = bound_index (bounds, bound);\n-\t  void **entry = pointer_map_contains (bb_bounds,\n-\t\t\t\t\t       gimple_bb (elt->stmt));\n+\t  ptrdiff_t *entry = bb_bounds.get (gimple_bb (elt->stmt));\n \t  if (!entry)\n-\t    *pointer_map_insert (bb_bounds,\n-\t\t\t\t gimple_bb (elt->stmt)) = (void *)index;\n+\t    bb_bounds.put (gimple_bb (elt->stmt), index);\n \t  else if ((ptrdiff_t)*entry > index)\n-\t    *entry = (void *)index;\n+\t    *entry = index;\n \t}\n     }\n \n-  block_priority = pointer_map_create ();\n+  hash_map<basic_block, ptrdiff_t> block_priority;\n \n   /* Perform shortest path discovery loop->header ... loop->latch.\n \n@@ -3199,7 +3195,7 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n   queues.safe_grow_cleared (queue_index + 1);\n   queue.safe_push (loop->header);\n   queues[queue_index] = queue;\n-  *pointer_map_insert (block_priority, loop->header) = (void *)queue_index;\n+  block_priority.put (loop->header, queue_index);\n \n   for (; queue_index >= 0; queue_index--)\n     {\n@@ -3209,44 +3205,42 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n \t    {\n \t      basic_block bb;\n \t      ptrdiff_t bound_index = queue_index;\n-\t      void **entry;\n               edge e;\n               edge_iterator ei;\n \n \t      queue = queues[queue_index];\n \t      bb = queue.pop ();\n \n \t      /* OK, we later inserted the BB with lower priority, skip it.  */\n-\t      if ((ptrdiff_t)*pointer_map_contains (block_priority, bb) > queue_index)\n+\t      if (*block_priority.get (bb) > queue_index)\n \t\tcontinue;\n \n \t      /* See if we can improve the bound.  */\n-\t      entry = pointer_map_contains (bb_bounds, bb);\n-\t      if (entry && (ptrdiff_t)*entry < bound_index)\n-\t\tbound_index = (ptrdiff_t)*entry;\n+\t      ptrdiff_t *entry = bb_bounds.get (bb);\n+\t      if (entry && *entry < bound_index)\n+\t\tbound_index = *entry;\n \n \t      /* Insert succesors into the queue, watch for latch edge\n \t\t and record greatest index we saw.  */\n \t      FOR_EACH_EDGE (e, ei, bb->succs)\n \t\t{\n \t\t  bool insert = false;\n-\t\t  void **entry;\n \n \t\t  if (loop_exit_edge_p (loop, e))\n \t\t    continue;\n \n \t\t  if (e == loop_latch_edge (loop)\n \t\t      && latch_index < bound_index)\n \t\t    latch_index = bound_index;\n-\t\t  else if (!(entry = pointer_map_contains (block_priority, e->dest)))\n+\t\t  else if (!(entry = block_priority.get (e->dest)))\n \t\t    {\n \t\t      insert = true;\n-\t\t      *pointer_map_insert (block_priority, e->dest) = (void *)bound_index;\n+\t\t      block_priority.put (e->dest, bound_index);\n \t\t    }\n-\t\t  else if ((ptrdiff_t)*entry < bound_index)\n+\t\t  else if (*entry < bound_index)\n \t\t    {\n \t\t      insert = true;\n-\t\t      *entry = (void *)bound_index;\n+\t\t      *entry = bound_index;\n \t\t    }\n \t\t    \n \t\t  if (insert)\n@@ -3271,8 +3265,6 @@ discover_iteration_bound_by_body_walk (struct loop *loop)\n \n   queues.release ();\n   bounds.release ();\n-  pointer_map_destroy (bb_bounds);\n-  pointer_map_destroy (block_priority);\n }\n \n /* See if every path cross the loop goes through a statement that is known"}, {"sha": "fd12be7070fc25b94d1fbe33eef9ccfc8d726aa7", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1158,7 +1158,7 @@ delete_tree_ssa (void)\n   cfun->gimple_df->default_defs = NULL;\n   pt_solution_reset (&cfun->gimple_df->escaped);\n   if (cfun->gimple_df->decls_to_pointers != NULL)\n-    pointer_map_destroy (cfun->gimple_df->decls_to_pointers);\n+    delete cfun->gimple_df->decls_to_pointers;\n   cfun->gimple_df->decls_to_pointers = NULL;\n   cfun->gimple_df->modified_noreturn_calls = NULL;\n   cfun->gimple_df = NULL;"}, {"sha": "e3579678b71cc44f0d534dde6415089703206517", "filename": "gcc/value-prof.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39c8aaa4bfab14d348ffbe515b332f03383eb1e9/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=39c8aaa4bfab14d348ffbe515b332f03383eb1e9", "patch": "@@ -1209,7 +1209,22 @@ gimple_mod_subtract_transform (gimple_stmt_iterator *si)\n   return true;\n }\n \n-static pointer_map_t *cgraph_node_map = 0;\n+struct profile_id_traits : default_hashmap_traits\n+{\n+  template<typename T>\n+  static bool\n+  is_deleted (T &e)\n+    {\n+      return e.m_key == UINT_MAX;\n+    }\n+\n+  template<typename T> static bool is_empty (T &e) { return e.m_key == 0; }\n+  template<typename T> static void mark_deleted (T &e) { e.m_key = UINT_MAX; }\n+  template<typename T> static void mark_empty (T &e) { e.m_key = 0; }\n+};\n+\n+static hash_map<unsigned int, cgraph_node *, profile_id_traits> *\n+cgraph_node_map = 0;\n \n /* Returns true if node graph is initialized. This\n    is used to test if profile_id has been created\n@@ -1229,17 +1244,17 @@ void\n init_node_map (bool local)\n {\n   struct cgraph_node *n;\n-  cgraph_node_map = pointer_map_create ();\n+  cgraph_node_map\n+    = new hash_map<unsigned int, cgraph_node *, profile_id_traits>;\n \n   FOR_EACH_DEFINED_FUNCTION (n)\n     if (n->has_gimple_body_p ())\n       {\n-\tvoid **val;\n+\tcgraph_node **val;\n \tif (local)\n \t  {\n \t    n->profile_id = coverage_compute_profile_id (n);\n-\t    while ((val = pointer_map_contains (cgraph_node_map,\n-\t\t\t\t\t\t(void *)(size_t)n->profile_id))\n+\t    while ((val = cgraph_node_map->get (n->profile_id))\n \t\t   || !n->profile_id)\n \t      {\n \t\tif (dump_file)\n@@ -1248,8 +1263,8 @@ init_node_map (bool local)\n \t\t\t   n->profile_id,\n \t\t\t   n->name (),\n \t\t\t   n->order,\n-\t\t\t   (*(symtab_node **)val)->name (),\n-\t\t\t   (*(symtab_node **)val)->order);\n+\t\t\t   (*val)->name (),\n+\t\t\t   (*val)->order);\n \t\tn->profile_id = (n->profile_id + 1) & 0x7fffffff;\n \t      }\n \t  }\n@@ -1263,8 +1278,7 @@ init_node_map (bool local)\n \t\t       n->order);\n \t    continue;\n \t  }\n-\telse if ((val = pointer_map_contains (cgraph_node_map,\n-\t\t\t\t\t      (void *)(size_t)n->profile_id)))\n+\telse if ((val = cgraph_node_map->get (n->profile_id)))\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file,\n@@ -1276,8 +1290,7 @@ init_node_map (bool local)\n \t    *val = NULL;\n \t    continue;\n \t  }\n-\t*pointer_map_insert (cgraph_node_map,\n-\t\t\t     (void *)(size_t)n->profile_id) = (void *)n;\n+\tcgraph_node_map->put (n->profile_id, n);\n       }\n }\n \n@@ -1286,18 +1299,17 @@ init_node_map (bool local)\n void\n del_node_map (void)\n {\n-  pointer_map_destroy (cgraph_node_map);\n+  delete cgraph_node_map;\n }\n \n /* Return cgraph node for function with pid */\n \n struct cgraph_node*\n find_func_by_profile_id (int profile_id)\n {\n-  void **val = pointer_map_contains (cgraph_node_map,\n-\t\t\t\t     (void *)(size_t)profile_id);\n+  cgraph_node **val = cgraph_node_map->get (profile_id);\n   if (val)\n-    return (struct cgraph_node *)*val;\n+    return *val;\n   else\n     return NULL;\n }"}]}