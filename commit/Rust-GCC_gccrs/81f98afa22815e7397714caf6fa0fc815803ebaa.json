{"sha": "81f98afa22815e7397714caf6fa0fc815803ebaa", "node_id": "C_kwDOANBUbNoAKDgxZjk4YWZhMjI4MTVlNzM5NzcxNGNhZjZmYTBmYzgxNTgwM2ViYWE", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-01T12:41:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-01T12:41:57Z"}, "message": "libstdc++: std::from_chars std::{,b}float16_t support\n\nThe following patch adds std::from_chars support, similarly to the\nprevious std::to_chars patch through APIs that use float instead of\nthe 16-bit floating point formats as container.\nThe patch uses the fast_float library and doesn't need any changes\nto it, like the previous patch it introduces wrapper classes around\nfloat that represent the float holding float16_t or bfloat16_t value,\nand specializes binary_format etc. from fast_float for these classes.\n\nThe new test verifies exhaustively to_chars and from_chars afterward\nresults in the original value (except for nans) in all the fmt cases.\n\n2022-11-01  Jakub Jelinek  <jakub@redhat.com>\n\n\t* include/std/charconv (__from_chars_float16_t,\n\t__from_chars_bfloat16_t): Declare.\n\t(from_chars): Add _Float16 and __gnu_cxx::__bfloat16_t overloads.\n\t* config/abi/pre/gnu.ver (GLIBCXX_3.4.31): Export\n\t_ZSt22__from_chars_float16_tPKcS0_RfSt12chars_format and\n\t_ZSt23__from_chars_bfloat16_tPKcS0_RfSt12chars_format.\n\t* src/c++17/floating_from_chars.cc\n\t(fast_float::floating_type_float16_t,\n\tfast_float::floating_type_bfloat16_t): New classes.\n\t(fast_float::binary_format<floating_type_float16_t>,\n\tfast_float::binary_format<floating_type_bfloat16_t>): New\n\tspecializations.\n\t(fast_float::to_float<floating_type_float16_t>,\n\tfast_float::to_float<floating_type_bfloat16_t>,\n\tfast_float::to_extended<floating_type_float16_t>,\n\tfast_float::to_extended<floating_type_bfloat16_t>): Likewise.\n\t(fast_float::from_chars_16): New template function.\n\t(__floating_from_chars_hex): Allow instantiation with\n\tfast_float::floating_type_{,b}float16_t.\n\t(from_chars): Formatting fixes for float/double/long double overloads.\n\t(__from_chars_float16_t, __from_chars_bfloat16_t): New functions.\n\t* testsuite/20_util/to_chars/float16_c++23.cc: New test.", "tree": {"sha": "582a423d7f04db8e004af5371a0026d8c2bc33e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/582a423d7f04db8e004af5371a0026d8c2bc33e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/81f98afa22815e7397714caf6fa0fc815803ebaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f98afa22815e7397714caf6fa0fc815803ebaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f98afa22815e7397714caf6fa0fc815803ebaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f98afa22815e7397714caf6fa0fc815803ebaa/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ae26533b3e26866f4130d40ec0659c273552643", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ae26533b3e26866f4130d40ec0659c273552643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ae26533b3e26866f4130d40ec0659c273552643"}], "stats": {"total": 520, "additions": 491, "deletions": 29}, "files": [{"sha": "1c714fba0aea41d453cee0b79e86a355f5c911db", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=81f98afa22815e7397714caf6fa0fc815803ebaa", "patch": "@@ -2448,6 +2448,8 @@ GLIBCXX_3.4.31 {\n     _ZNSt7__cxx1112basic_stringI[cw]St11char_traitsI[cw]ESaI[cw]EE15_M_replace_cold*;\n     _ZSt20__to_chars_float16_tPcS_fSt12chars_format;\n     _ZSt21__to_chars_bfloat16_tPcS_fSt12chars_format;\n+    _ZSt22__from_chars_float16_tPKcS0_RfSt12chars_format;\n+    _ZSt23__from_chars_bfloat16_tPKcS0_RfSt12chars_format;\n } GLIBCXX_3.4.30;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "e9bf953cdcc6277700591cf2cc657652d2bdb991", "filename": "libstdc++-v3/include/std/charconv", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcharconv?ref=81f98afa22815e7397714caf6fa0fc815803ebaa", "patch": "@@ -673,6 +673,32 @@ namespace __detail\n   from_chars(const char* __first, const char* __last, long double& __value,\n \t     chars_format __fmt = chars_format::general) noexcept;\n \n+  // Library routines for 16-bit extended floating point formats\n+  // using float as interchange format.\n+  from_chars_result\n+  __from_chars_float16_t(const char* __first, const char* __last,\n+\t\t\t float& __value,\n+\t\t\t chars_format __fmt = chars_format::general) noexcept;\n+  from_chars_result\n+  __from_chars_bfloat16_t(const char* __first, const char* __last,\n+\t\t\t  float& __value,\n+\t\t\t  chars_format __fmt = chars_format::general) noexcept;\n+\n+#if defined(__STDCPP_FLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32) \\\n+    && defined(__cpp_lib_to_chars)\n+  inline from_chars_result\n+  from_chars(const char* __first, const char* __last, _Float16& __value,\n+\t     chars_format __fmt = chars_format::general) noexcept\n+  {\n+    float __val;\n+    from_chars_result __res\n+      = __from_chars_float16_t(__first, __last, __val, __fmt);\n+    if (__res.ec == errc{})\n+      __value = __val;\n+    return __res;\n+  }\n+#endif\n+\n #if defined(__STDCPP_FLOAT32_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32)\n   inline from_chars_result\n   from_chars(const char* __first, const char* __last, _Float32& __value,\n@@ -711,6 +737,22 @@ namespace __detail\n     return __res;\n   }\n #endif\n+\n+#if defined(__STDCPP_BFLOAT16_T__) && defined(_GLIBCXX_FLOAT_IS_IEEE_BINARY32) \\\n+    && defined(__cpp_lib_to_chars)\n+  inline from_chars_result\n+  from_chars(const char* __first, const char* __last,\n+\t     __gnu_cxx::__bfloat16_t & __value,\n+\t     chars_format __fmt = chars_format::general) noexcept\n+  {\n+    float __val;\n+    from_chars_result __res\n+      = __from_chars_bfloat16_t(__first, __last, __val, __fmt);\n+    if (__res.ec == errc{})\n+      __value = __val;\n+    return __res;\n+  }\n+#endif\n #endif\n \n #if defined __cpp_lib_to_chars"}, {"sha": "a25ac5ce3aaf7f535c3e0253cd76076e035f1e26", "filename": "libstdc++-v3/src/c++17/floating_from_chars.cc", "status": "modified", "additions": 371, "deletions": 29, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_from_chars.cc?ref=81f98afa22815e7397714caf6fa0fc815803ebaa", "patch": "@@ -75,6 +75,272 @@ extern \"C\" __ieee128 __strtoieee128(const char*, char**);\n namespace\n {\n # include \"fast_float/fast_float.h\"\n+\n+namespace fast_float\n+{\n+\n+  // Wrappers around float for std::{,b}float16_t promoted to float.\n+  struct floating_type_float16_t\n+  {\n+    float* x;\n+    uint16_t bits;\n+  };\n+  struct floating_type_bfloat16_t\n+  {\n+    float* x;\n+    uint16_t bits;\n+  };\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::mantissa_explicit_bits()\n+  { return 10; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::mantissa_explicit_bits()\n+  { return 7; }\n+\n+  // 10 bits of stored mantissa, pow(5,q) <= 0x4p+10 implies q <= 5\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::max_exponent_round_to_even()\n+  { return 5; }\n+\n+  // 7 bits of stored mantissa, pow(5,q) <= 0x4p+7 implies q <= 3\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::max_exponent_round_to_even()\n+  { return 3; }\n+\n+  // 10 bits of stored mantissa, pow(5,-q) < 0x1p+64 / 0x1p+11 implies q >= -22\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::min_exponent_round_to_even()\n+  { return -22; }\n+\n+  // 7 bits of stored mantissa, pow(5,-q) < 0x1p+64 / 0x1p+8 implies q >= -24\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::min_exponent_round_to_even()\n+  { return -24; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::minimum_exponent()\n+  { return -15; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::minimum_exponent()\n+  { return -127; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::infinite_power()\n+  { return 0x1F; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::infinite_power()\n+  { return 0xFF; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::sign_index()\n+  { return 15; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::sign_index()\n+  { return 15; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::largest_power_of_ten()\n+  { return 4; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::largest_power_of_ten()\n+  { return 38; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_float16_t>::smallest_power_of_ten()\n+  { return -27; }\n+\n+  template<>\n+  constexpr int\n+  binary_format<floating_type_bfloat16_t>::smallest_power_of_ten()\n+  { return -60; }\n+\n+  template<>\n+  constexpr size_t\n+  binary_format<floating_type_float16_t>::max_digits()\n+  { return 22; }\n+\n+  template<>\n+  constexpr size_t\n+  binary_format<floating_type_bfloat16_t>::max_digits()\n+  { return 98; }\n+\n+  // negative_digit_comp converts adjusted_mantissa to the (originally only)\n+  // floating type and immediately back with slight tweaks (e.g. explicit\n+  // leading bit instead of implicit for normals).\n+  // Avoid going through the floating point type.\n+  template<>\n+  fastfloat_really_inline void\n+  to_float<floating_type_float16_t>(bool negative, adjusted_mantissa am,\n+\t\t\t\t    floating_type_float16_t &value)\n+  {\n+    constexpr int mantissa_bits\n+      = binary_format<floating_type_float16_t>::mantissa_explicit_bits();\n+    value.bits = (am.mantissa\n+\t\t  | (uint16_t(am.power2) << mantissa_bits)\n+\t\t  | (negative ? 0x8000 : 0));\n+  }\n+\n+  template<>\n+  fastfloat_really_inline void\n+  to_float<floating_type_bfloat16_t>(bool negative, adjusted_mantissa am,\n+\t\t\t\t     floating_type_bfloat16_t &value)\n+  {\n+    constexpr int mantissa_bits\n+      = binary_format<floating_type_bfloat16_t>::mantissa_explicit_bits();\n+    value.bits = (am.mantissa\n+\t\t  | (uint16_t(am.power2) << mantissa_bits)\n+\t\t  | (negative ? 0x8000 : 0));\n+  }\n+\n+  template <>\n+  fastfloat_really_inline adjusted_mantissa\n+  to_extended<floating_type_float16_t>(floating_type_float16_t value) noexcept\n+  {\n+    adjusted_mantissa am;\n+    constexpr int mantissa_bits\n+      = binary_format<floating_type_float16_t>::mantissa_explicit_bits();\n+    int32_t bias\n+      = (mantissa_bits\n+\t - binary_format<floating_type_float16_t>::minimum_exponent());\n+    constexpr uint16_t exponent_mask = 0x7C00;\n+    constexpr uint16_t mantissa_mask = 0x03FF;\n+    constexpr uint16_t hidden_bit_mask = 0x0400;\n+    if ((value.bits & exponent_mask) == 0) {\n+      // denormal\n+      am.power2 = 1 - bias;\n+      am.mantissa = value.bits & mantissa_mask;\n+    } else {\n+      // normal\n+      am.power2 = int32_t((value.bits & exponent_mask) >> mantissa_bits);\n+      am.power2 -= bias;\n+      am.mantissa = (value.bits & mantissa_mask) | hidden_bit_mask;\n+    }\n+    return am;\n+  }\n+\n+  template <>\n+  fastfloat_really_inline adjusted_mantissa\n+  to_extended<floating_type_bfloat16_t>(floating_type_bfloat16_t value) noexcept\n+  {\n+    adjusted_mantissa am;\n+    constexpr int mantissa_bits\n+      = binary_format<floating_type_bfloat16_t>::mantissa_explicit_bits();\n+    int32_t bias\n+      = (mantissa_bits\n+\t - binary_format<floating_type_bfloat16_t>::minimum_exponent());\n+    constexpr uint16_t exponent_mask = 0x7F80;\n+    constexpr uint16_t mantissa_mask = 0x007F;\n+    constexpr uint16_t hidden_bit_mask = 0x0080;\n+    if ((value.bits & exponent_mask) == 0) {\n+      // denormal\n+      am.power2 = 1 - bias;\n+      am.mantissa = value.bits & mantissa_mask;\n+    } else {\n+      // normal\n+      am.power2 = int32_t((value.bits & exponent_mask) >> mantissa_bits);\n+      am.power2 -= bias;\n+      am.mantissa = (value.bits & mantissa_mask) | hidden_bit_mask;\n+    }\n+    return am;\n+  }\n+\n+  // Like fast_float.h from_chars_advanced, but for 16-bit float.\n+  template<typename T>\n+  from_chars_result\n+  from_chars_16(const char* first, const char* last, T &value,\n+\t\tchars_format fmt) noexcept\n+  {\n+    parse_options options{fmt};\n+\n+    from_chars_result answer;\n+    if (first == last)\n+      {\n+\tanswer.ec = std::errc::invalid_argument;\n+\tanswer.ptr = first;\n+\treturn answer;\n+      }\n+\n+    parsed_number_string pns = parse_number_string(first, last, options);\n+    if (!pns.valid)\n+      return detail::parse_infnan(first, last, *value.x);\n+\n+    answer.ec = std::errc();\n+    answer.ptr = pns.lastmatch;\n+\n+    adjusted_mantissa am\n+      = compute_float<binary_format<T>>(pns.exponent, pns.mantissa);\n+    if (pns.too_many_digits && am.power2 >= 0)\n+      {\n+\tif (am != compute_float<binary_format<T>>(pns.exponent,\n+\t\t\t\t\t\t  pns.mantissa + 1))\n+\t  am = compute_error<binary_format<T>>(pns.exponent, pns.mantissa);\n+      }\n+\n+    // If we called compute_float<binary_format<T>>(pns.exponent, pns.mantissa)\n+    // and we have an invalid power (am.power2 < 0),\n+    // then we need to go the long way around again.  This is very uncommon.\n+    if (am.power2 < 0)\n+      am = digit_comp<T>(pns, am);\n+\n+    if ((pns.mantissa != 0 && am.mantissa == 0 && am.power2 == 0)\n+\t|| am.power2 == binary_format<T>::infinite_power())\n+      {\n+\t// In case of over/underflow, return result_out_of_range and don't\n+\t// modify value, as per [charconv.from.chars]/1.  Note that LWG 3081 wants\n+\t// to modify value in this case too.\n+\tanswer.ec = std::errc::result_out_of_range;\n+\treturn answer;\n+      }\n+\n+    // Transform the {,b}float16_t to float32_t before to_float.\n+    if constexpr (std::is_same_v<T, floating_type_float16_t>)\n+      {\n+\tif (am.power2 == 0)\n+\t  {\n+\t    if (am.mantissa)\n+\t      {\n+\t\tint n = (std::numeric_limits<unsigned int>::digits\n+\t\t\t - __builtin_clz (am.mantissa)) - 1;\n+\t\tam.mantissa &= ~(static_cast<decltype(am.mantissa)>(1) << n);\n+\t\tam.mantissa <<= (binary_format<float>::mantissa_explicit_bits()\n+\t\t\t\t - n);\n+\t\tam.power2 = n + 0x67;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    am.mantissa <<= 13;\n+\t    am.power2 += 0x70;\n+\t  }\n+      }\n+    else\n+      am.mantissa <<= 16;\n+    to_float(pns.negative, am, *value.x);\n+    return answer;\n+  }\n+} // fast_float\n+\n } // anon namespace\n #endif\n \n@@ -490,11 +756,14 @@ namespace\n   from_chars_result\n   __floating_from_chars_hex(const char* first, const char* last, T& value)\n   {\n-    static_assert(is_same_v<T, float> || is_same_v<T, double>);\n-\n-    using uint_t = conditional_t<is_same_v<T, float>, uint32_t, uint64_t>;\n-    constexpr int mantissa_bits = is_same_v<T, float> ? 23 : 52;\n-    constexpr int exponent_bits = is_same_v<T, float> ? 8 : 11;\n+    using uint_t = conditional_t<is_same_v<T, float>, uint32_t,\n+\t\t\t\t conditional_t<is_same_v<T, double>, uint64_t,\n+\t\t\t\t\t       uint16_t>>;\n+    constexpr int mantissa_bits\n+      = fast_float::binary_format<T>::mantissa_explicit_bits();\n+    constexpr int exponent_bits\n+      = is_same_v<T, double> ? 11\n+\t: is_same_v<T, fast_float::floating_type_float16_t> ? 5 : 8;\n     constexpr int exponent_bias = (1 << (exponent_bits - 1)) - 1;\n \n     __glibcxx_requires_valid_range(first, last);\n@@ -520,12 +789,21 @@ namespace\n \t      if (starts_with_ci(first, last, \"inity\"sv))\n \t\tfirst += strlen(\"inity\");\n \n-\t      uint_t result = 0;\n-\t      result |= sign_bit;\n-\t      result <<= exponent_bits;\n-\t      result |= (1ull << exponent_bits) - 1;\n-\t      result <<= mantissa_bits;\n-\t      memcpy(&value, &result, sizeof(result));\n+\t      if constexpr (is_same_v<T, float> || is_same_v<T, double>)\n+\t\t{\n+\t\t  uint_t result = 0;\n+\t\t  result |= sign_bit;\n+\t\t  result <<= exponent_bits;\n+\t\t  result |= (1ull << exponent_bits) - 1;\n+\t\t  result <<= mantissa_bits;\n+\t\t  memcpy(&value, &result, sizeof(result));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // float +/-Inf.\n+\t\t  uint32_t result = 0x7F800000 | (sign_bit ? 0x80000000U : 0);\n+\t\t  memcpy(value.x, &result, sizeof(result));\n+\t\t}\n \n \t      return {first, errc{}};\n \t    }\n@@ -566,12 +844,21 @@ namespace\n \n \t      // We make the implementation-defined decision of ignoring the\n \t      // sign bit and the n-char-sequence when assembling the NaN.\n-\t      uint_t result = 0;\n-\t      result <<= exponent_bits;\n-\t      result |= (1ull << exponent_bits) - 1;\n-\t      result <<= mantissa_bits;\n-\t      result |= (1ull << (mantissa_bits - 1)) | 1;\n-\t      memcpy(&value, &result, sizeof(result));\n+\t      if constexpr (is_same_v<T, float> || is_same_v<T, double>)\n+\t\t{\n+\t\t  uint_t result = 0;\n+\t\t  result <<= exponent_bits;\n+\t\t  result |= (1ull << exponent_bits) - 1;\n+\t\t  result <<= mantissa_bits;\n+\t\t  result |= (1ull << (mantissa_bits - 1)) | 1;\n+\t\t  memcpy(&value, &result, sizeof(result));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // float qNaN.\n+\t\t  uint32_t result = 0x7FC00001;\n+\t\t  memcpy(value.x, &result, sizeof(result));\n+\t\t}\n \n \t      return {first, errc{}};\n \t    }\n@@ -633,18 +920,27 @@ namespace\n \t  mantissa |= uint_t(hexit) << mantissa_idx;\n \telse if (mantissa_idx >= -4)\n \t  {\n-\t    if constexpr (is_same_v<T, float>)\n+\t    if constexpr (is_same_v<T, float>\n+\t\t\t  || is_same_v<T,\n+\t\t\t\t       fast_float::floating_type_bfloat16_t>)\n \t      {\n \t\t__glibcxx_assert(mantissa_idx == -1);\n \t\tmantissa |= hexit >> 1;\n \t\tmidpoint_bit = (hexit & 0b0001) != 0;\n \t      }\n-\t    else\n+\t    else if constexpr (is_same_v<T, double>)\n \t      {\n \t\t__glibcxx_assert(mantissa_idx == -4);\n \t\tmidpoint_bit = (hexit & 0b1000) != 0;\n \t\tnonzero_tail = (hexit & 0b0111) != 0;\n \t      }\n+\t    else\n+\t      {\n+\t\t__glibcxx_assert(mantissa_idx == -2);\n+\t\tmantissa |= hexit >> 2;\n+\t\tmidpoint_bit = (hexit & 0b0010) != 0;\n+\t\tnonzero_tail = (hexit & 0b0001) != 0;\n+\t      }\n \t  }\n \telse\n \t  nonzero_tail |= (hexit != 0x0);\n@@ -808,7 +1104,34 @@ namespace\n \t__glibcxx_assert(((mantissa & (1ull << mantissa_bits)) != 0)\n \t\t\t == (biased_exponent != 0));\n       }\n-    memcpy(&value, &result, sizeof(result));\n+    if constexpr (is_same_v<T, float> || is_same_v<T, double>)\n+      memcpy(&value, &result, sizeof(result));\n+    else if constexpr (is_same_v<T, fast_float::floating_type_bfloat16_t>)\n+      {\n+\tuint32_t res = uint32_t{result} << 16;\n+\tmemcpy(value.x, &res, sizeof(res));\n+      }\n+    else\n+      {\n+\t// Otherwise float16_t which needs to be converted to float32_t.\n+\tuint32_t res;\n+\tif ((result & 0x7FFF) == 0)\n+\t  res = uint32_t{result} << 16;\t\t// +/-0.0f16\n+\telse if ((result & 0x7C00) == 0)\n+\t  {\t\t\t\t\t// denormal\n+\t    unsigned n = (std::numeric_limits<unsigned int>::digits\n+\t\t\t  - __builtin_clz (result & 0x3FF) - 1);\n+\t    res = uint32_t{result} & 0x3FF & ~(uint32_t{1} << n);\n+\t    res <<= 23 - n;\n+\t    res |= (((uint32_t{n} + 0x67) << 23)\n+\t\t    | ((uint32_t{result} & 0x8000) << 16));\n+\t  }\n+\telse\n+\t  res = (((uint32_t{result} & 0x3FF) << 13)\n+\t\t | ((((uint32_t{result} >> 10) & 0x1F) + 0x70) << 23)\n+\t\t | ((uint32_t{result} & 0x8000) << 16));\n+\tmemcpy(value.x, &res, sizeof(res));\n+      }\n \n     return {first, errc{}};\n   }\n@@ -826,9 +1149,7 @@ from_chars(const char* first, const char* last, float& value,\n   if (fmt == chars_format::hex)\n     return __floating_from_chars_hex(first, last, value);\n   else\n-    {\n-      return fast_float::from_chars(first, last, value, fmt);\n-    }\n+    return fast_float::from_chars(first, last, value, fmt);\n #else\n   return from_chars_strtod(first, last, value, fmt);\n #endif\n@@ -842,9 +1163,7 @@ from_chars(const char* first, const char* last, double& value,\n   if (fmt == chars_format::hex)\n     return __floating_from_chars_hex(first, last, value);\n   else\n-    {\n-      return fast_float::from_chars(first, last, value, fmt);\n-    }\n+    return fast_float::from_chars(first, last, value, fmt);\n #else\n   return from_chars_strtod(first, last, value, fmt);\n #endif\n@@ -863,9 +1182,7 @@ from_chars(const char* first, const char* last, long double& value,\n   if (fmt == chars_format::hex)\n     result = __floating_from_chars_hex(first, last, dbl_value);\n   else\n-    {\n-      result = fast_float::from_chars(first, last, dbl_value, fmt);\n-    }\n+    result = fast_float::from_chars(first, last, dbl_value, fmt);\n   if (result.ec == errc{})\n     value = dbl_value;\n   return result;\n@@ -874,6 +1191,31 @@ from_chars(const char* first, const char* last, long double& value,\n #endif\n }\n \n+#if USE_LIB_FAST_FLOAT\n+// Entrypoints for 16-bit floats.\n+[[gnu::cold]] from_chars_result\n+__from_chars_float16_t(const char* first, const char* last, float& value,\n+\t\t       chars_format fmt) noexcept\n+{\n+  struct fast_float::floating_type_float16_t val{ &value, 0 };\n+  if (fmt == chars_format::hex)\n+    return __floating_from_chars_hex(first, last, val);\n+  else\n+    return fast_float::from_chars_16(first, last, val, fmt);\n+}\n+\n+[[gnu::cold]] from_chars_result\n+__from_chars_bfloat16_t(const char* first, const char* last, float& value,\n+\t\t\tchars_format fmt) noexcept\n+{\n+  struct fast_float::floating_type_bfloat16_t val{ &value, 0 };\n+  if (fmt == chars_format::hex)\n+    return __floating_from_chars_hex(first, last, val);\n+  else\n+    return fast_float::from_chars_16(first, last, val, fmt);\n+}\n+#endif\n+\n #ifdef _GLIBCXX_LONG_DOUBLE_COMPAT\n // Make std::from_chars for 64-bit long double an alias for the overload\n // for double."}, {"sha": "db935377c1c087c06a1a3f4e11f6016809bb9d47", "filename": "libstdc++-v3/testsuite/20_util/to_chars/float16_c++23.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Ffloat16_c%2B%2B23.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/81f98afa22815e7397714caf6fa0fc815803ebaa/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Ffloat16_c%2B%2B23.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Ffloat16_c%2B%2B23.cc?ref=81f98afa22815e7397714caf6fa0fc815803ebaa", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2b\" }\n+// { dg-do run { target c++23 } }\n+// { dg-require-effective-target ieee_floats }\n+// { dg-require-effective-target size32plus }\n+// { dg-add-options ieee }\n+\n+#include <charconv>\n+#include <stdfloat>\n+#include <iostream>\n+#include <cmath>\n+#include <testsuite_hooks.h>\n+\n+template<typename T>\n+void\n+test(std::chars_format fmt = std::chars_format{})\n+{\n+  char str1[128], str2[128], str3[128];\n+  union U { unsigned short s; T f; } u, v;\n+  for (int i = 0; i <= (unsigned short) ~0; ++i)\n+    {\n+      u.s = i;\n+      auto [ptr1, ec1] = std::to_chars(str1, str1 + sizeof(str1), u.f, fmt);\n+      auto [ptr2, ec2] = std::to_chars(str2, str2 + sizeof(str2), std::float32_t(u.f), fmt);\n+      VERIFY( ec1 == std::errc() && ec2 == std::errc());\n+//    std::cout << i << ' ' << std::string_view (str1, ptr1)\n+//\t<< '\\t' << std::string_view (str2, ptr2) << '\\n';\n+      if (fmt == std::chars_format::fixed)\n+\t{\n+\t  auto [ptr3, ec3] = std::to_chars(str3, str3 + (ptr1 - str1), u.f, fmt);\n+\t  VERIFY( ec3 == std::errc() && ptr3 - str3 == ptr1 - str1 );\n+\t  auto [ptr4, ec4] = std::to_chars(str3, str3 + (ptr1 - str1 - 1), u.f, fmt);\n+\t  VERIFY( ec4 != std::errc() );\n+\t}\n+      auto [ptr5, ec5] = std::from_chars(str1, ptr1, v.f,\n+\t\t\t\t\t fmt == std::chars_format{}\n+\t\t\t\t\t ? std::chars_format::general : fmt);\n+      VERIFY( ec5 == std::errc() && ptr5 == ptr1 );\n+      VERIFY( u.s == v.s || (std::isnan(u.f) && std::isnan(v.f)) );\n+    }\n+}\n+\n+int\n+main()\n+{\n+#ifdef __STDCPP_FLOAT16_T__\n+  test<std::float16_t>();\n+  test<std::float16_t>(std::chars_format::fixed);\n+  test<std::float16_t>(std::chars_format::scientific);\n+  test<std::float16_t>(std::chars_format::general);\n+  test<std::float16_t>(std::chars_format::hex);\n+#endif\n+#ifdef __STDCPP_BFLOAT16_T__\n+  test<std::bfloat16_t>();\n+  test<std::bfloat16_t>(std::chars_format::fixed);\n+  test<std::bfloat16_t>(std::chars_format::scientific);\n+  test<std::bfloat16_t>(std::chars_format::general);\n+  test<std::bfloat16_t>(std::chars_format::hex);\n+#endif\n+}"}]}