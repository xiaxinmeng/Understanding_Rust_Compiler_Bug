{"sha": "46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZjMjUxNGU4MmJmNWY2ZWQ0NWVmNmFjOGIxMjNjOTI4M2JmOGQ2YQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-09-13T20:18:38Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-09-13T20:18:38Z"}, "message": "c-common.c (fname_as_string): Update.\n\ngcc\n\t* c-common.c (fname_as_string): Update.\n\t* c-parser.c (c_parser) <lex_untranslated_string>: New field.\n\t(c_lex_one_token): Update.  Add 'parser' argument.\n\t(c_parser_simple_asm_expr): Update.\n\t(c_parser_attributes): Update.\n\t(c_parser_asm_statement): Update.\n\t(c_parser_asm_operands): Update.\n\t(c_parser_peek_token): Update.\n\t(c_parser_peek_2nd_token): Update.\n\t* c-lex.c (c_lex_string_translate): Remove.\n\t(c_lex_return_raw_strings): Likewise.\n\t(c_lex_with_flags): Added 'lex_flags' argument.\n\t(lex_string): Added 'translate' argument.\n\t* c-pragma.h (c_lex_with_flags): Update.\n\t(c_lex_string_translate, c_lex_return_raw_strings): Remove.\n\t(C_LEX_STRING_NO_TRANSLATE): New define.\n\t(C_LEX_RAW_STRINGS): Likewise.\ngcc/cp\n\t* parser.c (cp_lexer_new_main): Don't use\n\tc_lex_return_raw_strings.\n\t(cp_lexer_get_preprocessor_token): Update.  Add special case when\n\tlexer is NULL.\n\nFrom-SVN: r128479", "tree": {"sha": "13e4924b9d71b04792c65b0f96e8b0a51e4b8ecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13e4924b9d71b04792c65b0f96e8b0a51e4b8ecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/comments", "author": null, "committer": null, "parents": [{"sha": "76896993c25ad2143fbb0a1d7fbfcbdea30e41f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76896993c25ad2143fbb0a1d7fbfcbdea30e41f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76896993c25ad2143fbb0a1d7fbfcbdea30e41f0"}], "stats": {"total": 190, "additions": 92, "deletions": 98}, "files": [{"sha": "e23de7abab359893b377a5b12c811bc36304719c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -1,3 +1,23 @@\n+2007-09-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* c-common.c (fname_as_string): Update.\n+\t* c-parser.c (c_parser) <lex_untranslated_string>: New field.\n+\t(c_lex_one_token): Update.  Add 'parser' argument.\n+\t(c_parser_simple_asm_expr): Update.\n+\t(c_parser_attributes): Update.\n+\t(c_parser_asm_statement): Update.\n+\t(c_parser_asm_operands): Update.\n+\t(c_parser_peek_token): Update.\n+\t(c_parser_peek_2nd_token): Update.\n+\t* c-lex.c (c_lex_string_translate): Remove.\n+\t(c_lex_return_raw_strings): Likewise.\n+\t(c_lex_with_flags): Added 'lex_flags' argument.\n+\t(lex_string): Added 'translate' argument.\n+\t* c-pragma.h (c_lex_with_flags): Update.\n+\t(c_lex_string_translate, c_lex_return_raw_strings): Remove.\n+\t(C_LEX_STRING_NO_TRANSLATE): New define.\n+\t(C_LEX_RAW_STRINGS): Likewise.\n+\n 2007-09-13  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tFrom Jie Zhang:"}, {"sha": "0f4d69530d448a686b0f418721948d57635cb1b6", "filename": "gcc/c-common.c", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -756,7 +756,8 @@ fname_as_string (int pretty_p)\n {\n   const char *name = \"top level\";\n   char *namep;\n-  int vrb = 2;\n+  int vrb = 2, len;\n+  cpp_string cstr = { 0, 0 }, strname;\n \n   if (!pretty_p)\n     {\n@@ -767,24 +768,18 @@ fname_as_string (int pretty_p)\n   if (current_function_decl)\n     name = lang_hooks.decl_printable_name (current_function_decl, vrb);\n \n-  if (c_lex_string_translate)\n-    {\n-      int len = strlen (name) + 3; /* Two for '\"'s.  One for NULL.  */\n-      cpp_string cstr = { 0, 0 }, strname;\n+  len = strlen (name) + 3; /* Two for '\"'s.  One for NULL.  */\n \n-      namep = XNEWVEC (char, len);\n-      snprintf (namep, len, \"\\\"%s\\\"\", name);\n-      strname.text = (unsigned char *) namep;\n-      strname.len = len - 1;\n+  namep = XNEWVEC (char, len);\n+  snprintf (namep, len, \"\\\"%s\\\"\", name);\n+  strname.text = (unsigned char *) namep;\n+  strname.len = len - 1;\n \n-      if (cpp_interpret_string (parse_in, &strname, 1, &cstr, false))\n-\t{\n-\t  XDELETEVEC (namep);\n-\t  return (const char *) cstr.text;\n-\t}\n+  if (cpp_interpret_string (parse_in, &strname, 1, &cstr, false))\n+    {\n+      XDELETEVEC (namep);\n+      return (const char *) cstr.text;\n     }\n-  else\n-    namep = xstrdup (name);\n \n   return namep;\n }"}, {"sha": "5cad2609a4a0376064f89b7a70894a424c7f0839", "filename": "gcc/c-lex.c", "status": "modified", "additions": 9, "deletions": 39, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -49,24 +49,14 @@ static splay_tree file_info_tree;\n int pending_lang_change; /* If we need to switch languages - C++ only */\n int c_header_level;\t /* depth in C headers - C++ only */\n \n-/* If we need to translate characters received.  This is tri-state:\n-   0 means use only the untranslated string; 1 means use only\n-   the translated string; -1 means chain the translated string\n-   to the untranslated one.  */\n-int c_lex_string_translate = 1;\n-\n-/* True if strings should be passed to the caller of c_lex completely\n-   unmolested (no concatenation, no translation).  */\n-bool c_lex_return_raw_strings = false;\n-\n static tree interpret_integer (const cpp_token *, unsigned int);\n static tree interpret_float (const cpp_token *, unsigned int);\n static tree interpret_fixed (const cpp_token *, unsigned int);\n static enum integer_type_kind narrowest_unsigned_type\n \t(unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, unsigned int);\n static enum integer_type_kind narrowest_signed_type\n \t(unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT, unsigned int);\n-static enum cpp_ttype lex_string (const cpp_token *, tree *, bool);\n+static enum cpp_ttype lex_string (const cpp_token *, tree *, bool, bool);\n static tree lex_charconst (const cpp_token *);\n static void update_header_times (const char *);\n static int dump_one_header (splay_tree_node, void *);\n@@ -329,7 +319,8 @@ cb_undef (cpp_reader * ARG_UNUSED (pfile), source_location loc,\n    non-NULL.  */\n \n enum cpp_ttype\n-c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n+c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n+\t\t  int lex_flags)\n {\n   static bool no_more_pch;\n   const cpp_token *tok;\n@@ -411,7 +402,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n \n \t    case CPP_STRING:\n \t    case CPP_WSTRING:\n-\t      type = lex_string (tok, value, true);\n+\t      type = lex_string (tok, value, true, true);\n \t      break;\n \n \t    case CPP_NAME:\n@@ -467,9 +458,10 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n-      if (!c_lex_return_raw_strings)\n+      if ((lex_flags & C_LEX_RAW_STRINGS) == 0)\n \t{\n-\t  type = lex_string (tok, value, false);\n+\t  type = lex_string (tok, value, false,\n+\t\t\t     (lex_flags & C_LEX_STRING_NO_TRANSLATE) == 0);\n \t  break;\n \t}\n       *value = build_string (tok->val.str.len, (const char *) tok->val.str.text);\n@@ -890,7 +882,7 @@ interpret_fixed (const cpp_token *token, unsigned int flags)\n    we must arrange to provide.  */\n \n static enum cpp_ttype\n-lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n+lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n {\n   tree value;\n   bool wide = false;\n@@ -948,34 +940,12 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n     warning (OPT_Wtraditional,\n \t     \"traditional C rejects string constant concatenation\");\n \n-  if ((c_lex_string_translate\n+  if ((translate\n        ? cpp_interpret_string : cpp_interpret_string_notranslate)\n       (parse_in, strs, concats + 1, &istr, wide))\n     {\n       value = build_string (istr.len, (const char *) istr.text);\n       free (CONST_CAST (unsigned char *, istr.text));\n-\n-      if (c_lex_string_translate == -1)\n-\t{\n-\t  int xlated = cpp_interpret_string_notranslate (parse_in, strs,\n-\t\t\t\t\t\t\t concats + 1,\n-\t\t\t\t\t\t\t &istr, wide);\n-\t  /* Assume that, if we managed to translate the string above,\n-\t     then the untranslated parsing will always succeed.  */\n-\t  gcc_assert (xlated);\n-\n-\t  if (TREE_STRING_LENGTH (value) != (int) istr.len\n-\t      || 0 != strncmp (TREE_STRING_POINTER (value),\n-\t\t\t       (const char *) istr.text, istr.len))\n-\t    {\n-\t      /* Arrange for us to return the untranslated string in\n-\t\t *valp, but to set up the C type of the translated\n-\t\t one.  */\n-\t      *valp = build_string (istr.len, (const char *) istr.text);\n-\t      valp = &TREE_CHAIN (*valp);\n-\t    }\n-\t  free (CONST_CAST (unsigned char *, istr.text));\n-\t}\n     }\n   else\n     {"}, {"sha": "bdf96ca6d920781e5f99adc33cacc342cafaecec", "filename": "gcc/c-parser.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -280,6 +280,8 @@ typedef struct c_parser GTY(())\n   /* True if we're processing a pragma, and shouldn't automatically\n      consume CPP_PRAGMA_EOL.  */\n   BOOL_BITFIELD in_pragma : 1;\n+  /* True if we want to lex an untranslated string.  */\n+  BOOL_BITFIELD lex_untranslated_string : 1;\n   /* Objective-C specific parser/lexer information.  */\n   BOOL_BITFIELD objc_pq_context : 1;\n   /* The following flag is needed to contextualize Objective-C lexical\n@@ -303,7 +305,9 @@ c_lex_one_token (c_parser *parser, c_token *token)\n {\n   timevar_push (TV_LEX);\n \n-  token->type = c_lex_with_flags (&token->value, &token->location, NULL);\n+  token->type = c_lex_with_flags (&token->value, &token->location, NULL,\n+\t\t\t\t  (parser->lex_untranslated_string\n+\t\t\t\t   ? C_LEX_STRING_NO_TRANSLATE : 0));\n   token->id_kind = C_ID_NONE;\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;\n@@ -2731,8 +2735,8 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n      string-literal\n \n    ??? At present, following the old parser, the caller needs to have\n-   set c_lex_string_translate to 0.  It would be better to follow the\n-   C++ parser rather than using the c_lex_string_translate kludge.  */\n+   set lex_untranslated_string to 1.  It would be better to follow the\n+   C++ parser rather than using this kludge.  */\n \n static tree\n c_parser_asm_string_literal (c_parser *parser)\n@@ -2771,16 +2775,16 @@ c_parser_simple_asm_expr (c_parser *parser)\n   tree str;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_ASM));\n   /* ??? Follow the C++ parser rather than using the\n-     c_lex_string_translate kludge.  */\n-  c_lex_string_translate = 0;\n+     lex_untranslated_string kludge.  */\n+  parser->lex_untranslated_string = true;\n   c_parser_consume_token (parser);\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n       return NULL_TREE;\n     }\n   str = c_parser_asm_string_literal (parser);\n-  c_lex_string_translate = 1;\n+  parser->lex_untranslated_string = false;\n   if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n@@ -2823,17 +2827,17 @@ c_parser_attributes (c_parser *parser)\n   while (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n     {\n       /* ??? Follow the C++ parser rather than using the\n-\t c_lex_string_translate kludge.  */\n-      c_lex_string_translate = 0;\n+\t lex_untranslated_string kludge.  */\n+      parser->lex_untranslated_string = true;\n       c_parser_consume_token (parser);\n       if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t{\n-\t  c_lex_string_translate = 1;\n+\t  parser->lex_untranslated_string = false;\n \t  return attrs;\n \t}\n       if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t{\n-\t  c_lex_string_translate = 1;\n+\t  parser->lex_untranslated_string = false;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n \t  return attrs;\n \t}\n@@ -2933,7 +2937,7 @@ c_parser_attributes (c_parser *parser)\n \t    c_parser_consume_token (parser);\n \t  else\n \t    {\n-\t      c_lex_string_translate = 1;\n+\t      parser->lex_untranslated_string = false;\n \t      c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t\t \"expected %<)%>\");\n \t      return attrs;\n@@ -2944,7 +2948,7 @@ c_parser_attributes (c_parser *parser)\n \tc_parser_consume_token (parser);\n       else\n \t{\n-\t  c_lex_string_translate = 1;\n+\t  parser->lex_untranslated_string = false;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  return attrs;\n@@ -2953,12 +2957,12 @@ c_parser_attributes (c_parser *parser)\n \tc_parser_consume_token (parser);\n       else\n \t{\n-\t  c_lex_string_translate = 1;\n+\t  parser->lex_untranslated_string = false;\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n \t\t\t\t     \"expected %<)%>\");\n \t  return attrs;\n \t}\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n     }\n   return attrs;\n }\n@@ -4139,11 +4143,11 @@ c_parser_asm_statement (c_parser *parser)\n   else\n     quals = NULL_TREE;\n   /* ??? Follow the C++ parser rather than using the\n-     c_lex_string_translate kludge.  */\n-  c_lex_string_translate = 0;\n+     lex_untranslated_string kludge.  */\n+  parser->lex_untranslated_string = true;\n   if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n     {\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n       return NULL_TREE;\n     }\n   str = c_parser_asm_string_literal (parser);\n@@ -4157,7 +4161,7 @@ c_parser_asm_statement (c_parser *parser)\n     }\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%> or %<)%>\"))\n     {\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n       return NULL_TREE;\n     }\n@@ -4176,7 +4180,7 @@ c_parser_asm_statement (c_parser *parser)\n     }\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%> or %<)%>\"))\n     {\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n       return NULL_TREE;\n     }\n@@ -4193,14 +4197,14 @@ c_parser_asm_statement (c_parser *parser)\n     }\n   if (!c_parser_require (parser, CPP_COLON, \"expected %<:%> or %<)%>\"))\n     {\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n       return NULL_TREE;\n     }\n   /* Parse clobbers.  */\n   clobbers = c_parser_asm_clobbers (parser);\n  done_asm:\n-  c_lex_string_translate = 1;\n+  parser->lex_untranslated_string = false;\n   if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n     {\n       c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n@@ -4258,16 +4262,16 @@ c_parser_asm_operands (c_parser *parser, bool convert_p)\n       str = c_parser_asm_string_literal (parser);\n       if (str == NULL_TREE)\n \treturn NULL_TREE;\n-      c_lex_string_translate = 1;\n+      parser->lex_untranslated_string = false;\n       if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n \t{\n-\t  c_lex_string_translate = 0;\n+\t  parser->lex_untranslated_string = true;\n \t  return NULL_TREE;\n \t}\n       expr = c_parser_expression (parser);\n       if (convert_p)\n \texpr = default_function_array_conversion (expr);\n-      c_lex_string_translate = 0;\n+      parser->lex_untranslated_string = true;\n       if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n \t{\n \t  c_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);"}, {"sha": "9896f434bd32869345d10528623511aa09aa2807", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -110,19 +110,18 @@ extern void add_to_renaming_pragma_list (tree, tree);\n \n extern enum cpp_ttype pragma_lex (tree *);\n \n+/* Flags for use with c_lex_with_flags.  The values here were picked\n+   so that 0 means to translate and join strings.  */\n+#define C_LEX_STRING_NO_TRANSLATE 1 /* Do not lex strings into\n+\t\t\t\t       execution character set.  */\n+#define C_LEX_RAW_STRINGS         2 /* Return raw strings -- no\n+\t\t\t\t       concatenation, no\n+\t\t\t\t       translation.  */\n+\n /* This is not actually available to pragma parsers.  It's merely a\n    convenient location to declare this function for c-lex, after\n    having enum cpp_ttype declared.  */\n-extern enum cpp_ttype c_lex_with_flags (tree *, location_t *, unsigned char *);\n-\n-/* If 1, then lex strings into the execution character set.\n-   If 0, lex strings into the host character set.\n-   If -1, lex both, and chain them together, such that the former\n-   is the TREE_CHAIN of the latter.  */\n-extern int c_lex_string_translate;\n-\n-/* If true, strings should be passed to the caller of c_lex completely\n-   unmolested (no concatenation, no translation).  */\n-extern bool c_lex_return_raw_strings;\n+extern enum cpp_ttype c_lex_with_flags (tree *, location_t *, unsigned char *,\n+\t\t\t\t\tint);\n \n #endif /* GCC_C_PRAGMA_H */"}, {"sha": "dfcbb02271f7e494faaa984c615e36d0334fea51", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -1,3 +1,10 @@\n+2007-09-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* parser.c (cp_lexer_new_main): Don't use\n+\tc_lex_return_raw_strings.\n+\t(cp_lexer_get_preprocessor_token): Update.  Add special case when\n+\tlexer is NULL.\n+\n 2007-09-11  Jan Hubicka <jh@suse.cz>\n \n \t* method.c (use_thunk): Use tree_rest_of_compilation"}, {"sha": "ede0d7e324467ef3e5ee9b822e1ad0b83e1f6d7a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=46c2514e82bf5f6ed45ef6ac8b123c9283bf8d6a", "patch": "@@ -277,9 +277,6 @@ cp_lexer_new_main (void)\n      allocating any memory.  */\n   cp_parser_initial_pragma (&first_token);\n \n-  /* Tell c_lex_with_flags not to merge string constants.  */\n-  c_lex_return_raw_strings = true;\n-\n   c_common_no_more_pch ();\n \n   /* Allocate the memory.  */\n@@ -402,17 +399,19 @@ cp_lexer_saving_tokens (const cp_lexer* lexer)\n }\n \n /* Store the next token from the preprocessor in *TOKEN.  Return true\n-   if we reach EOF.  */\n+   if we reach EOF.  If LEXER is NULL, assume we are handling an\n+   initial #pragma pch_preprocess, and thus want the lexer to return\n+   processed strings.  */\n \n static void\n-cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n-\t\t\t\t cp_token *token)\n+cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n {\n   static int is_extern_c = 0;\n \n    /* Get a new token from the preprocessor.  */\n   token->type\n-    = c_lex_with_flags (&token->u.value, &token->location, &token->flags);\n+    = c_lex_with_flags (&token->u.value, &token->location, &token->flags,\n+\t\t\tlexer == NULL ? 0 : C_LEX_RAW_STRINGS);\n   token->input_file_stack_index = input_file_stack_tick;\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;"}]}