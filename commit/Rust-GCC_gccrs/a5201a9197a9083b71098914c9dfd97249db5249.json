{"sha": "a5201a9197a9083b71098914c9dfd97249db5249", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUyMDFhOTE5N2E5MDgzYjcxMDk4OTE0YzlkZmQ5NzI0OWRiNTI0OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-10-27T02:23:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-10-27T02:23:16Z"}, "message": "re PR c++/18093 (bogus conflict in namespace aliasing)\n\n\tPR c++/18093\n\t* search.c (current_scope): Return the innermost non-block scope,\n\tnot the innermost non-block, non-namespace scope.\n\t(at_namespace_scope_p): Adjust accordingly.\n\t(dfs_accessible_post): Do not pass namespaces to is_friend.\n\t(dfs_walk_once_accessible_r): Likewise.\n\t* decl.c (grokvardecl): Adjust call to current_scope.\n\t(build_enumerator): Likewise.\n\t* parser.c (cp_parser_using_declaration): Likewise.\n\t(cp_parser_direct_declarator): Use at_namespace_scope_p instead of\n\tcurrent_scope.\n\t(cp_parser_class_head): Adjust call to current_scope.\n\t* name-lookup.c (do_namespace_alias): Set the DECL_CONTEXT for the\n\talias.\n\n\tPR c++/18020\n\t* pt.c (tusbst_copy_and_build): Resolve enumeration constants to\n\ttheir underlying values.\n\n\tPR c++/18161\n\t* typeck.c (build_binary_op): Honor build_type, even when in a\n\ttemplate.\n\n\tPR c++/18093\n\t* g++.dg/lookup/ns2.C: New test.\n\n\tPR c++/18020\n\t* g++.dg/template/enum4.C: New test.\n\n\tPR c++/18161\n\t* g++.dg/template/expr1.C: New test.\n\nFrom-SVN: r89627", "tree": {"sha": "62c200d8b2b8702e81da0dc741d655791644796a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62c200d8b2b8702e81da0dc741d655791644796a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5201a9197a9083b71098914c9dfd97249db5249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5201a9197a9083b71098914c9dfd97249db5249", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5201a9197a9083b71098914c9dfd97249db5249", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5201a9197a9083b71098914c9dfd97249db5249/comments", "author": null, "committer": null, "parents": [{"sha": "0a3d71f54af134bcafea29a8f8021d8bbf24cfb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a3d71f54af134bcafea29a8f8021d8bbf24cfb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a3d71f54af134bcafea29a8f8021d8bbf24cfb4"}], "stats": {"total": 178, "additions": 131, "deletions": 47}, "files": [{"sha": "d9e8ce777ce22d0e7daeea00dbaa043a0702eff6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -1,3 +1,28 @@\n+2004-10-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18093\n+\t* search.c (current_scope): Return the innermost non-block scope,\n+\tnot the innermost non-block, non-namespace scope.\n+\t(at_namespace_scope_p): Adjust accordingly.\n+\t(dfs_accessible_post): Do not pass namespaces to is_friend.\n+\t(dfs_walk_once_accessible_r): Likewise.\n+\t* decl.c (grokvardecl): Adjust call to current_scope.\n+\t(build_enumerator): Likewise.\n+\t* parser.c (cp_parser_using_declaration): Likewise.\n+\t(cp_parser_direct_declarator): Use at_namespace_scope_p instead of\n+\tcurrent_scope.\n+\t(cp_parser_class_head): Adjust call to current_scope.\n+\t* name-lookup.c (do_namespace_alias): Set the DECL_CONTEXT for the\n+\talias.\n+\n+\tPR c++/18020\n+\t* pt.c (tusbst_copy_and_build): Resolve enumeration constants to\n+\ttheir underlying values.\n+\n+\tPR c++/18161\n+\t* typeck.c (build_binary_op): Honor build_type, even when in a\n+\ttemplate.\n+\n 2004-10-26  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* parser.c (cp_lexer_get_preprocessor_token): Remove unneeded"}, {"sha": "9d9f70b7b924988e5b8983f45998b632bbbde70b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -5918,11 +5918,7 @@ grokvardecl (tree type,\n       if (declspecs->storage_class == sc_extern)\n \tscope = current_namespace;\n       else if (!at_function_scope_p ())\n-\t{\n-\t  scope = current_scope ();\n-\t  if (!scope)\n-\t    scope = current_namespace;\n-\t}\n+\tscope = current_scope ();\n     }\n \n   if (scope\n@@ -9746,8 +9742,6 @@ build_enumerator (tree name, tree value, tree enumtype)\n \n   /* C++ associates enums with global, function, or class declarations.  */\n   context = current_scope ();\n-  if (!context)\n-    context = current_namespace;\n \n   /* Build the actual enumeration constant.  Note that the enumeration\n     constants have the type of their initializers until the"}, {"sha": "423a4b9be61b5c51d5d1bcc78774d0ee83f7fe4c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -3227,6 +3227,7 @@ do_namespace_alias (tree alias, tree namespace)\n   alias = build_lang_decl (NAMESPACE_DECL, alias, void_type_node);     \n   DECL_NAMESPACE_ALIAS (alias) = namespace;\n   DECL_EXTERNAL (alias) = 1;\n+  DECL_CONTEXT (alias) = current_scope ();\n   pushdecl (alias);\n \n   /* Emit debug info for namespace alias.  */"}, {"sha": "b6e5432c8b035b6267e53245b1ad7475bb7186dc", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -10047,7 +10047,6 @@ cp_parser_using_declaration (cp_parser* parser)\n   bool global_scope_p;\n   tree decl;\n   tree identifier;\n-  tree scope;\n   tree qscope;\n \n   /* Look for the `using' keyword.  */\n@@ -10106,8 +10105,7 @@ cp_parser_using_declaration (cp_parser* parser)\n     error (\"a template-id may not appear in a using-declaration\");\n   else\n     {\n-      scope = current_scope ();\n-      if (scope && TYPE_P (scope))\n+      if (at_class_scope_p ())\n \t{\n \t  /* Create the USING_DECL.  */\n \t  decl = do_class_using_decl (build_nt (SCOPE_REF,\n@@ -10121,7 +10119,7 @@ cp_parser_using_declaration (cp_parser* parser)\n \t  decl = cp_parser_lookup_name_simple (parser, identifier);\n \t  if (decl == error_mark_node)\n \t    cp_parser_name_lookup_error (parser, identifier, decl, NULL);\n-\t  else if (scope)\n+\t  else if (!at_namespace_scope_p ())\n \t    do_local_using_decl (decl, qscope, identifier);\n \t  else\n \t    do_toplevel_using_decl (decl, qscope, identifier);\n@@ -10982,7 +10980,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      break;\n \t    }\n \n-\t  if (TREE_CODE (id) == SCOPE_REF && !current_scope ())\n+\t  if (TREE_CODE (id) == SCOPE_REF && at_namespace_scope_p ())\n \t    {\n \t      tree scope = TREE_OPERAND (id, 0);\n \n@@ -12560,8 +12558,6 @@ cp_parser_class_head (cp_parser* parser,\n       tree scope;\n       /* Figure out in what scope the declaration is being placed.  */\n       scope = current_scope ();\n-      if (!scope)\n-\tscope = current_namespace;\n       /* If that scope does not contain the scope in which the\n \t class was originally declared, the program is invalid.  */\n       if (scope && !is_ancestor (scope, nested_name_specifier))"}, {"sha": "99f4e7b960219a7c096a22c3e9a6c2e350b07ef1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -8761,6 +8761,14 @@ tsubst_copy_and_build (tree t,\n \treturn stmt_expr;\n       }\n \n+    case CONST_DECL:\n+      t = tsubst_copy (t, args, complain, in_decl);\n+      /* As in finish_id_expression, we resolve enumeration constants\n+\t to their underlying values.  */\n+      if (TREE_CODE (t) == CONST_DECL)\n+\treturn DECL_INITIAL (t);\n+      return t;\n+\n     default:\n       return tsubst_copy (t, args, complain, in_decl);\n     }"}, {"sha": "5f8f0815013bc37dbf64c7e247ce711147444a78", "filename": "gcc/cp/search.c", "status": "modified", "additions": 45, "deletions": 32, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -497,38 +497,40 @@ lookup_field_1 (tree type, tree name, bool want_type)\n   return NULL_TREE;\n }\n \n-/* There are a number of cases we need to be aware of here:\n+/* Return the FUNCTION_DECL, RECORD_TYPE, UNION_TYPE, or\n+   NAMESPACE_DECL corresponding to the innermost non-block scope.  */  \n+\n+tree\n+current_scope ()\n+{\n+  /* There are a number of cases we need to be aware of here:\n \t\t\t current_class_type\tcurrent_function_decl\n      global\t\t\tNULL\t\t\tNULL\n      fn-local\t\t\tNULL\t\t\tSET\n      class-local\t\tSET\t\t\tNULL\n      class->fn\t\t\tSET\t\t\tSET\n      fn->class\t\t\tSET\t\t\tSET\n \n-   Those last two make life interesting.  If we're in a function which is\n-   itself inside a class, we need decls to go into the fn's decls (our\n-   second case below).  But if we're in a class and the class itself is\n-   inside a function, we need decls to go into the decls for the class.  To\n-   achieve this last goal, we must see if, when both current_class_ptr and\n-   current_function_decl are set, the class was declared inside that\n-   function.  If so, we know to put the decls into the class's scope.  */\n-\n-tree\n-current_scope (void)\n-{\n-  if (current_function_decl == NULL_TREE)\n-    return current_class_type;\n-  if (current_class_type == NULL_TREE)\n+     Those last two make life interesting.  If we're in a function which is\n+     itself inside a class, we need decls to go into the fn's decls (our\n+     second case below).  But if we're in a class and the class itself is\n+     inside a function, we need decls to go into the decls for the class.  To\n+     achieve this last goal, we must see if, when both current_class_ptr and\n+     current_function_decl are set, the class was declared inside that\n+     function.  If so, we know to put the decls into the class's scope.  */\n+  if (current_function_decl && current_class_type\n+      && ((DECL_FUNCTION_MEMBER_P (current_function_decl)\n+\t   && same_type_p (DECL_CONTEXT (current_function_decl),\n+\t\t\t   current_class_type))\n+\t  || (DECL_FRIEND_CONTEXT (current_function_decl)\n+\t      && same_type_p (DECL_FRIEND_CONTEXT (current_function_decl),\n+\t\t\t      current_class_type))))\n     return current_function_decl;\n-  if ((DECL_FUNCTION_MEMBER_P (current_function_decl)\n-       && same_type_p (DECL_CONTEXT (current_function_decl),\n-\t\t       current_class_type))\n-      || (DECL_FRIEND_CONTEXT (current_function_decl)\n-\t  && same_type_p (DECL_FRIEND_CONTEXT (current_function_decl),\n-\t\t\t  current_class_type)))\n+  if (current_class_type)\n+    return current_class_type;\n+  if (current_function_decl)\n     return current_function_decl;\n-\n-  return current_class_type;\n+  return current_namespace;\n }\n \n /* Returns nonzero if we are currently in a function scope.  Note\n@@ -556,9 +558,8 @@ at_class_scope_p (void)\n bool\n at_namespace_scope_p (void)\n {\n-  /* We are in a namespace scope if we are not it a class scope or a\n-     function scope.  */\n-  return !current_scope();\n+  tree cs = current_scope ();\n+  return cs && TREE_CODE (cs) == NAMESPACE_DECL;\n }\n \n /* Return the scope of DECL, as appropriate when doing name-lookup.  */\n@@ -833,9 +834,13 @@ friend_accessible_p (tree scope, tree decl, tree binfo)\n static tree\n dfs_accessible_post (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n-  if (BINFO_ACCESS (binfo) != ak_none\n-      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n-    return binfo;\n+  if (BINFO_ACCESS (binfo) != ak_none)\n+    {\n+      tree scope = current_scope ();\n+      if (scope && TREE_CODE (scope) != NAMESPACE_DECL\n+\t  && is_friend (BINFO_TYPE (binfo), scope))\n+\treturn binfo;\n+    }\n   \n   return NULL_TREE;\n }\n@@ -1700,9 +1705,17 @@ dfs_walk_once_accessible_r (tree binfo, bool friends_p, bool once,\n       /* If the base is inherited via private or protected\n      \t inheritance, then we can't see it, unless we are a friend of\n      \t the current binfo.  */\n-      if (BINFO_BASE_ACCESS (binfo, ix) != access_public_node\n-\t  && !(friends_p && is_friend (BINFO_TYPE (binfo), current_scope ())))\n-\tcontinue;\n+      if (BINFO_BASE_ACCESS (binfo, ix) != access_public_node)\n+\t{\n+\t  tree scope;\n+\t  if (!friends_p)\n+\t    continue;\n+\t  scope = current_scope ();\n+\t  if (!scope \n+\t      || TREE_CODE (scope) == NAMESPACE_DECL\n+\t      || !is_friend (BINFO_TYPE (binfo), scope))\n+\t    continue;\n+\t}\n \n       if (mark)\n \tBINFO_MARKED (base_binfo) = 1;"}, {"sha": "5e7bf90b5522e57134b5e78ebf873667391e262b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -3201,7 +3201,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* If we're in a template, the only thing we need to know is the\n      RESULT_TYPE.  */\n   if (processing_template_decl)\n-    return build2 (resultcode, result_type, op0, op1);\n+    return build2 (resultcode, \n+\t\t   build_type ? build_type : result_type, \n+\t\t   op0, op1);\n \n   if (arithmetic_types_p)\n     {"}, {"sha": "e248aef39b7979727c70f2cf3fc96333e98ad424", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -1,3 +1,14 @@\n+2004-10-26  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18093\n+\t* g++.dg/lookup/ns2.C: New test.\n+\n+\tPR c++/18020\n+\t* g++.dg/template/enum4.C: New test.\n+\n+\tPR c++/18161\n+\t* g++.dg/template/expr1.C: New test.\n+\n 2004-10-26  Ben Elliston  <bje@au.ibm.com>\n \n \t* gcc.dg/tree-ssa/20030922-2.c: Now passing, so remove xfail."}, {"sha": "2ad2ec0e3acde15013acf79e9611479f6b74f527", "filename": "gcc/testsuite/g++.dg/lookup/ns2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fns2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fns2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fns2.C?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/18161\n+\n+namespace m\n+{\n+  namespace n\n+  {\n+  }\n+}\n+\n+namespace n\n+{\n+}\n+\n+namespace o\n+{\n+  namespace n = ::m::n;\n+}"}, {"sha": "97e0b848d47b68f7e6ac220b776e248f6aead224", "filename": "gcc/testsuite/g++.dg/template/enum4.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fenum4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fenum4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fenum4.C?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/18020\n+\n+template <typename> struct bar {\n+  enum {\n+    e1 = 1,\n+    e2 = ~e1\n+  };\n+};\n+template struct bar<int>;"}, {"sha": "079865d4eb511afc79b11bdbb6d9a0bcd19160df", "filename": "gcc/testsuite/g++.dg/template/expr1.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexpr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5201a9197a9083b71098914c9dfd97249db5249/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexpr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fexpr1.C?ref=a5201a9197a9083b71098914c9dfd97249db5249", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/18161\n+// { dg-options \"\" }\n+\n+template <class T> struct Y;\n+template <> struct Y<bool> {};\n+\n+template <typename T = typeof (1 == 1)> struct X { Y<T> a; };\n+template struct X <>; "}]}