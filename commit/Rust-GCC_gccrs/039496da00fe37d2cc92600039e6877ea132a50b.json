{"sha": "039496da00fe37d2cc92600039e6877ea132a50b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM5NDk2ZGEwMGZlMzdkMmNjOTI2MDAwMzllNjg3N2VhMTMyYTUwYg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2012-05-31T19:46:43Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2012-05-31T19:46:43Z"}, "message": "re PR tree-optimization/52558 (write introduction incorrect wrt the C++11 memory model)\n\n        PR tree-optimization/52558\n        * cfg.c (alloc_aux_for_edge): Fix comment.\n        (alloc_aux_for_edge): Remove static.\n        * basic-block.h (alloc_aux_for_edge): Protoize.\n        * tree-ssa-loop-im.c (execute_sm_if_changed): New.\n        (execute_sm_if_changed_flag): New.\n        (execute_sm_if_changed_flag_set): New.\n        (execute_sm): Do not generate data races unless requested.\n        (tree_ssa_lim_initialize): Call alloc_aux_for_edges.\n        (tree_ssa_lim_finalize): Call free_aux_for_edges.\n        * gimple.h (block_in_transaction): New.\n        (gimple_in_transaction): Use block_in_transaction.\n\nFrom-SVN: r188081", "tree": {"sha": "1ad67e950a74a6bc950bbf5f91748e6acbf640b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ad67e950a74a6bc950bbf5f91748e6acbf640b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/039496da00fe37d2cc92600039e6877ea132a50b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039496da00fe37d2cc92600039e6877ea132a50b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039496da00fe37d2cc92600039e6877ea132a50b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039496da00fe37d2cc92600039e6877ea132a50b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "19af62dbf23ba8ad8ca2b317d0886e38545af4e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19af62dbf23ba8ad8ca2b317d0886e38545af4e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19af62dbf23ba8ad8ca2b317d0886e38545af4e6"}], "stats": {"total": 320, "additions": 305, "deletions": 15}, "files": [{"sha": "0a1dc1835a5cc8e411d6d68217bcd02c4ec88cad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -1,3 +1,18 @@\n+2012-05-31  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\tPR tree-optimization/52558\n+\t* cfg.c (alloc_aux_for_edge): Fix comment.\n+\t(alloc_aux_for_edge): Remove static.\n+\t* basic-block.h (alloc_aux_for_edge): Protoize.\n+\t* tree-ssa-loop-im.c (execute_sm_if_changed): New.\n+\t(execute_sm_if_changed_flag): New.\n+\t(execute_sm_if_changed_flag_set): New.\n+\t(execute_sm): Do not generate data races unless requested.\n+\t(tree_ssa_lim_initialize): Call alloc_aux_for_edges.\n+\t(tree_ssa_lim_finalize): Call free_aux_for_edges.\n+\t* gimple.h (block_in_transaction): New.\n+\t(gimple_in_transaction): Use block_in_transaction.\n+\n 2012-05-31  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/51345"}, {"sha": "418914a3718a2672c80c308d28d7c3e5d5aa75ef", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -802,6 +802,7 @@ extern basic_block alloc_block (void);\n extern void alloc_aux_for_blocks (int);\n extern void clear_aux_for_blocks (void);\n extern void free_aux_for_blocks (void);\n+extern void alloc_aux_for_edge (edge, int);\n extern void alloc_aux_for_edges (int);\n extern void clear_aux_for_edges (void);\n extern void free_aux_for_edges (void);"}, {"sha": "6342c13e152c60b7604896e20b4e9ffd387b4291", "filename": "gcc/cfg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -814,10 +814,10 @@ free_aux_for_blocks (void)\n   clear_aux_for_blocks ();\n }\n \n-/* Allocate a memory edge of SIZE as BB->aux.  The obstack must\n+/* Allocate a memory edge of SIZE as E->aux.  The obstack must\n    be first initialized by alloc_aux_for_edges.  */\n \n-static void\n+void\n alloc_aux_for_edge (edge e, int size)\n {\n   /* Verify that aux field is clear.  */"}, {"sha": "8fd64da61dbf009b9dd92becf8224ce680bdb34c", "filename": "gcc/gimple.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -1588,12 +1588,20 @@ gimple_set_has_volatile_ops (gimple stmt, bool volatilep)\n     stmt->gsbase.has_volatile_ops = (unsigned) volatilep;\n }\n \n+/* Return true if BB is in a transaction.  */\n+\n+static inline bool\n+block_in_transaction (basic_block bb)\n+{\n+  return bb->flags & BB_IN_TRANSACTION;\n+}\n+\n /* Return true if STMT is in a transaction.  */\n \n static inline bool\n gimple_in_transaction (gimple stmt)\n {\n-  return gimple_bb (stmt)->flags & BB_IN_TRANSACTION;\n+  return block_in_transaction (gimple_bb (stmt));\n }\n \n /* Return true if statement STMT may access memory.  */"}, {"sha": "c34ad0655d35489dbb777059a01e5477d87b3b62", "filename": "gcc/testsuite/gcc.dg/pr52558-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52558-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52558-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52558-1.c?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"--param allow-store-data-races=0 -O2 -fdump-tree-lim1\" } */\n+\n+/* Test that `count' is not written to unless p->data > 0.  */\n+\n+int count;\n+\n+struct obj {\n+    int data;\n+    struct obj *next;\n+} *q;\n+\n+void func()\n+{\n+  struct obj *p;\n+  for (p = q; p; p = p->next)\n+    if (p->data > 0)\n+      count++;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MEM count_lsm.. count_lsm_flag\" 1 \"lim1\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim1\" } } */"}, {"sha": "6d5f51c4f0c4f830c08de62d547ca64b02de0919", "filename": "gcc/testsuite/gcc.dg/pr52558-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52558-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52558-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr52558-2.c?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"--param allow-store-data-races=0 -O2 -fdump-tree-lim1\" } */\n+\n+/* Test that g_2 is not written to unless !g_1.  */\n+\n+int g_1 = 1;\n+int g_2 = 0;\n+\n+int func_1(void)\n+{\n+ int l;\n+ for (l = 0; l < 1234; l++)\n+ {\n+   if (g_1)\n+     return l;\n+   else\n+     g_2 = 0;\n+ }\n+ return 999;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MEM.*g_2_lsm_flag\" 1 \"lim1\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim1\" } } */"}, {"sha": "337c29f6c6e3d27c08d9c3cb35b7a56a63c01940", "filename": "gcc/testsuite/gcc.dg/tm/reg-promotion.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Freg-promotion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Freg-promotion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Freg-promotion.c?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O2 -fdump-tree-lim1\" } */\n+\n+/* Test that `count' is not written to unless p->data>0.  */\n+\n+int count;\n+\n+struct obj {\n+    int data;\n+    struct obj *next;\n+} *q;\n+\n+void func()\n+{\n+  struct obj *p;\n+  __transaction_atomic {\n+    for (p = q; p; p = p->next)\n+      if (p->data > 0)\n+\tcount++;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MEM count_lsm.. count_lsm_flag\" 1 \"lim1\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim1\" } } */"}, {"sha": "c9221444d59bd7278d305ee0d7d612246116826e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 209, "deletions": 12, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039496da00fe37d2cc92600039e6877ea132a50b/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=039496da00fe37d2cc92600039e6877ea132a50b", "patch": "@@ -52,7 +52,7 @@ along with GCC; see the file COPYING3.  If not see\n \t }\n      }\n \n-   Where COND and INV are is invariants, but evaluating INV may trap or be\n+   Where COND and INV are invariants, but evaluating INV may trap or be\n    invalid from some other reason if !COND.  This may be transformed to\n \n    if (cond)\n@@ -1626,6 +1626,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n \t  fprintf (dump_file, \"\\n\");\n \t}\n     }\n+\n   if (is_stored)\n     mark_ref_stored (ref, loop);\n \n@@ -1956,6 +1957,173 @@ get_lsm_tmp_name (tree ref, unsigned n)\n   return lsm_tmp_name;\n }\n \n+struct prev_flag_edges {\n+  /* Edge to insert new flag comparison code.  */\n+  edge append_cond_position;\n+\n+  /* Edge for fall through from previous flag comparison.  */\n+  edge last_cond_fallthru;\n+};\n+\n+/* Helper function for execute_sm.  Emit code to store TMP_VAR into\n+   MEM along edge EX.\n+\n+   The store is only done if MEM has changed.  We do this so no\n+   changes to MEM occur on code paths that did not originally store\n+   into it.\n+\n+   The common case for execute_sm will transform:\n+\n+     for (...) {\n+       if (foo)\n+         stuff;\n+       else\n+         MEM = TMP_VAR;\n+     }\n+\n+   into:\n+\n+     lsm = MEM;\n+     for (...) {\n+       if (foo)\n+         stuff;\n+       else\n+         lsm = TMP_VAR;\n+     }\n+     MEM = lsm;\n+\n+  This function will generate:\n+\n+     lsm = MEM;\n+\n+     lsm_flag = false;\n+     ...\n+     for (...) {\n+       if (foo)\n+         stuff;\n+       else {\n+         lsm = TMP_VAR;\n+         lsm_flag = true;\n+       }\n+     }\n+     if (lsm_flag)\t<--\n+       MEM = lsm;\t<--\n+*/\n+\n+static void\n+execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n+{\n+  basic_block new_bb, then_bb, old_dest;\n+  bool loop_has_only_one_exit;\n+  edge then_old_edge, orig_ex = ex;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt;\n+  struct prev_flag_edges *prev_edges = (struct prev_flag_edges *) ex->aux;\n+\n+  /* ?? Insert store after previous store if applicable.  See note\n+     below.  */\n+  if (prev_edges)\n+    ex = prev_edges->append_cond_position;\n+\n+  loop_has_only_one_exit = single_pred_p (ex->dest);\n+\n+  if (loop_has_only_one_exit)\n+    ex = split_block_after_labels (ex->dest);\n+\n+  old_dest = ex->dest;\n+  new_bb = split_edge (ex);\n+  then_bb = create_empty_bb (new_bb);\n+  if (current_loops && new_bb->loop_father)\n+    add_bb_to_loop (then_bb, new_bb->loop_father);\n+\n+  gsi = gsi_start_bb (new_bb);\n+  stmt = gimple_build_cond (NE_EXPR, flag, boolean_false_node,\n+\t\t\t    NULL_TREE, NULL_TREE);\n+  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+  gsi = gsi_start_bb (then_bb);\n+  /* Insert actual store.  */\n+  stmt = gimple_build_assign (unshare_expr (mem), tmp_var);\n+  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+\n+  make_edge (new_bb, then_bb, EDGE_TRUE_VALUE);\n+  make_edge (new_bb, old_dest, EDGE_FALSE_VALUE);\n+  then_old_edge = make_edge (then_bb, old_dest, EDGE_FALLTHRU);\n+\n+  set_immediate_dominator (CDI_DOMINATORS, then_bb, new_bb);\n+\n+  if (prev_edges)\n+    {\n+      basic_block prevbb = prev_edges->last_cond_fallthru->src;\n+      redirect_edge_succ (prev_edges->last_cond_fallthru, new_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, new_bb, prevbb);\n+      set_immediate_dominator (CDI_DOMINATORS, old_dest,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, old_dest));\n+    }\n+\n+  /* ?? Because stores may alias, they must happen in the exact\n+     sequence they originally happened.  Save the position right after\n+     the (_lsm) store we just created so we can continue appending after\n+     it and maintain the original order.  */\n+  {\n+    struct prev_flag_edges *p;\n+\n+    if (orig_ex->aux)\n+      orig_ex->aux = NULL;\n+    alloc_aux_for_edge (orig_ex, sizeof (struct prev_flag_edges));\n+    p = (struct prev_flag_edges *) orig_ex->aux;\n+    p->append_cond_position = then_old_edge;\n+    p->last_cond_fallthru = find_edge (new_bb, old_dest);\n+    orig_ex->aux = (void *) p;\n+  }\n+\n+  if (!loop_has_only_one_exit)\n+    for (gsi = gsi_start_phis (old_dest); !gsi_end_p (gsi); gsi_next (&gsi))\n+      {\n+\tgimple phi = gsi_stmt (gsi);\n+\tunsigned i;\n+\n+\tfor (i = 0; i < gimple_phi_num_args (phi); i++)\n+\t  if (gimple_phi_arg_edge (phi, i)->src == new_bb)\n+\t    {\n+\t      tree arg = gimple_phi_arg_def (phi, i);\n+\t      add_phi_arg (phi, arg, then_old_edge, UNKNOWN_LOCATION);\n+\t      update_stmt (phi);\n+\t    }\n+      }\n+  /* Remove the original fall through edge.  This was the\n+     single_succ_edge (new_bb).  */\n+  EDGE_SUCC (new_bb, 0)->flags &= ~EDGE_FALLTHRU;\n+}\n+\n+/* Helper function for execute_sm.  On every location where REF is\n+   set, set an appropriate flag indicating the store.  */\n+\n+static tree\n+execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n+{\n+  unsigned i;\n+  mem_ref_loc_p loc;\n+  tree flag;\n+  VEC (mem_ref_loc_p, heap) *locs = NULL;\n+  char *str = get_lsm_tmp_name (ref->mem, ~0);\n+\n+  lsm_tmp_name_add (\"_flag\");\n+  flag = make_rename_temp (boolean_type_node, str);\n+  get_all_locs_in_loop (loop, ref, &locs);\n+  FOR_EACH_VEC_ELT (mem_ref_loc_p, locs, i, loc)\n+    {\n+      gimple_stmt_iterator gsi;\n+      gimple stmt;\n+\n+      gsi = gsi_for_stmt (loc->stmt);\n+      stmt = gimple_build_assign (flag, boolean_true_node);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+    }\n+  VEC_free (mem_ref_loc_p, heap, locs);\n+  return flag;\n+}\n+\n /* Executes store motion of memory reference REF from LOOP.\n    Exits from the LOOP are stored in EXITS.  The initialization of the\n    temporary variable is put to the preheader of the loop, and assignments\n@@ -1964,12 +2132,13 @@ get_lsm_tmp_name (tree ref, unsigned n)\n static void\n execute_sm (struct loop *loop, VEC (edge, heap) *exits, mem_ref_p ref)\n {\n-  tree tmp_var;\n+  tree tmp_var, store_flag;\n   unsigned i;\n-  gimple load, store;\n+  gimple load;\n   struct fmt_data fmt_data;\n-  edge ex;\n+  edge ex, latch_edge;\n   struct lim_aux_data *lim_data;\n+  bool multi_threaded_model_p = false;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1985,23 +2154,47 @@ execute_sm (struct loop *loop, VEC (edge, heap) *exits, mem_ref_p ref)\n   fmt_data.orig_loop = loop;\n   for_each_index (&ref->mem, force_move_till, &fmt_data);\n \n+  if ((flag_tm && block_in_transaction (loop_preheader_edge (loop)->src))\n+      || !PARAM_VALUE (PARAM_ALLOW_STORE_DATA_RACES))\n+    multi_threaded_model_p = true;\n+\n+  if (multi_threaded_model_p)\n+    store_flag = execute_sm_if_changed_flag_set (loop, ref);\n+\n   rewrite_mem_refs (loop, ref, tmp_var);\n \n-  /* Emit the load & stores.  */\n+  /* Emit the load code into the latch, so that we are sure it will\n+     be processed after all dependencies.  */\n+  latch_edge = loop_latch_edge (loop);\n+\n+  /* FIXME/TODO: For the multi-threaded variant, we could avoid this\n+     load altogether, since the store is predicated by a flag.  We\n+     could, do the load only if it was originally in the loop.  */\n   load = gimple_build_assign (tmp_var, unshare_expr (ref->mem));\n   lim_data = init_lim_data (load);\n   lim_data->max_loop = loop;\n   lim_data->tgt_loop = loop;\n+  gsi_insert_on_edge (latch_edge, load);\n \n-  /* Put this into the latch, so that we are sure it will be processed after\n-     all dependencies.  */\n-  gsi_insert_on_edge (loop_latch_edge (loop), load);\n-\n-  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n+  if (multi_threaded_model_p)\n     {\n-      store = gimple_build_assign (unshare_expr (ref->mem), tmp_var);\n-      gsi_insert_on_edge (ex, store);\n+      load = gimple_build_assign (store_flag, boolean_false_node);\n+      lim_data = init_lim_data (load);\n+      lim_data->max_loop = loop;\n+      lim_data->tgt_loop = loop;\n+      gsi_insert_on_edge (latch_edge, load);\n     }\n+\n+  /* Sink the store to every exit from the loop.  */\n+  FOR_EACH_VEC_ELT (edge, exits, i, ex)\n+    if (!multi_threaded_model_p)\n+      {\n+\tgimple store;\n+\tstore = gimple_build_assign (unshare_expr (ref->mem), tmp_var);\n+\tgsi_insert_on_edge (ex, store);\n+      }\n+    else\n+      execute_sm_if_changed (ex, ref->mem, tmp_var, store_flag);\n }\n \n /* Hoists memory references MEM_REFS out of LOOP.  EXITS is the list of exit\n@@ -2410,6 +2603,8 @@ tree_ssa_lim_initialize (void)\n \n   if (flag_tm)\n     compute_transaction_bits ();\n+\n+  alloc_aux_for_edges (0);\n }\n \n /* Cleans up after the invariant motion pass.  */\n@@ -2421,6 +2616,8 @@ tree_ssa_lim_finalize (void)\n   unsigned i;\n   bitmap b;\n \n+  free_aux_for_edges ();\n+\n   FOR_EACH_BB (bb)\n     SET_ALWAYS_EXECUTED_IN (bb, NULL);\n "}]}