{"sha": "e73922ef9f07c511c383cc37532d0324a1138d99", "node_id": "C_kwDOANBUbNoAKGU3MzkyMmVmOWYwN2M1MTFjMzgzY2MzNzUzMmQwMzI0YTExMzhkOTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-05T11:38:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-05T11:38:05Z"}, "message": "Merge #794\n\n794: Fix unhandled type bounds in TypeAlias r=philberty a=philberty\n\nThis adds support for trait-object-types and desugars HIR::TraitObjectTypeOneBound into a single\r\nHIR::TraitObjectType. This also adds the missing cases of the generic arguments to the TypeBoundPredicates.\r\n\r\nIt also contains cleanup for helpers used during monomorphization and a recursion limiter which is likely set too\r\nlow but it is good enough for the test-cases we have now to get good back-traces. \r\n\r\nFixes #786 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "cbb57b666f3a9907175d710134d6783f130e7049", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cbb57b666f3a9907175d710134d6783f130e7049"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e73922ef9f07c511c383cc37532d0324a1138d99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhhRedCRBK7hj4Ov3rIwAAThUIAAzoRqgyajSykgl6ZNjRtEMU\n6HQ1IiwJp10drEJu1AVhyl91gfDag3LuNtxbJ45bWgycUIB4Mu2z0EFEg5VFmWg/\nelwEMScf3Mmjh+/68aqqmu0WbAO+6LuV3vvu1fTIoHudp3/C6NwcP9mxRpgdL7NC\nzyGtAuLZlFLosZ28uiE03tZfqXiRz3kcIVb307JGxNpjvF1mwhsu9ULDXWgOqa+B\nzW6Sn1rM8s5AxoxxFzVfqLwq5mSNL7VgWJyO11xRtj7+SDZ2H20vQYYN6sEaiHMR\nhXrJi4tRMBpxQD8bxeswfkmEMg0IFlfTGsPDW/J4i1B7Mwu4IqU4aXQlxxvtZVY=\n=PK8f\n-----END PGP SIGNATURE-----\n", "payload": "tree cbb57b666f3a9907175d710134d6783f130e7049\nparent 8e992e371bbd896c8b605e1ebade5cad80b1b411\nparent f4c200fcfec75b3841640263609d2133ead0c518\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1636112285 +0000\ncommitter GitHub <noreply@github.com> 1636112285 +0000\n\nMerge #794\n\n794: Fix unhandled type bounds in TypeAlias r=philberty a=philberty\n\nThis adds support for trait-object-types and desugars HIR::TraitObjectTypeOneBound into a single\r\nHIR::TraitObjectType. This also adds the missing cases of the generic arguments to the TypeBoundPredicates.\r\n\r\nIt also contains cleanup for helpers used during monomorphization and a recursion limiter which is likely set too\r\nlow but it is good enough for the test-cases we have now to get good back-traces. \r\n\r\nFixes #786 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73922ef9f07c511c383cc37532d0324a1138d99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e73922ef9f07c511c383cc37532d0324a1138d99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e73922ef9f07c511c383cc37532d0324a1138d99/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e992e371bbd896c8b605e1ebade5cad80b1b411", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e992e371bbd896c8b605e1ebade5cad80b1b411", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e992e371bbd896c8b605e1ebade5cad80b1b411"}, {"sha": "f4c200fcfec75b3841640263609d2133ead0c518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c200fcfec75b3841640263609d2133ead0c518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4c200fcfec75b3841640263609d2133ead0c518"}], "stats": {"total": 809, "additions": 614, "deletions": 195}, "files": [{"sha": "2414b600c80aeede167056e462dbf9d9ea697cb7", "filename": "gcc/rust/ast/rust-type.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -162,10 +162,7 @@ class ImplTraitType : public Type\n class TraitObjectType : public Type\n {\n   bool has_dyn;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n-\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n   Location locus;\n \n protected:\n@@ -179,7 +176,7 @@ class TraitObjectType : public Type\n public:\n   TraitObjectType (\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    Location locus, bool is_dyn_dispatch = false)\n+    Location locus, bool is_dyn_dispatch)\n     : has_dyn (is_dyn_dispatch),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n@@ -215,6 +212,8 @@ class TraitObjectType : public Type\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  bool is_dyn () const { return has_dyn; }\n+\n   // TODO: mutable getter seems kinda dodgy\n   std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n   {"}, {"sha": "3184e27654aa9409f583b78b93c2e761322819b3", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -177,7 +177,6 @@ class HIRCompileBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitObjectType &type) {}\n   virtual void visit (HIR::ParenthesisedType &type) {}\n   virtual void visit (HIR::ImplTraitTypeOneBound &type) {}\n-  virtual void visit (HIR::TraitObjectTypeOneBound &type) {}\n   virtual void visit (HIR::TupleType &type) {}\n   virtual void visit (HIR::NeverType &type) {}\n   virtual void visit (HIR::RawPointerType &type) {}\n@@ -210,9 +209,12 @@ class HIRCompileBase : public HIR::HIRVisitor\n \t\t\t\t     const TyTy::DynamicObjectType *ty,\n \t\t\t\t     Location locus);\n \n-  Bexpression *\n-  compute_address_for_trait_item (const Resolver::TraitItemReference *ref,\n-\t\t\t\t  const TyTy::BaseType *receiver);\n+  Bexpression *compute_address_for_trait_item (\n+    const Resolver::TraitItemReference *ref,\n+    const TyTy::TypeBoundPredicate *predicate,\n+    std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+      &receiver_bounds,\n+    const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus);\n };\n \n } // namespace Compile"}, {"sha": "396cb10c263e659af35c715bfcfc6983dfdc0bdd", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -367,6 +367,9 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::ParamType &param) override\n   {\n+    recursion_count++;\n+    rust_assert (recursion_count < kDefaultRecusionLimit);\n+\n     param.resolve ()->accept_vis (*this);\n   }\n \n@@ -670,12 +673,16 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n private:\n   TyTyResolveCompile (Context *ctx, bool trait_object_mode)\n-    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr)\n+    : ctx (ctx), trait_object_mode (trait_object_mode), translated (nullptr),\n+      recursion_count (0)\n   {}\n \n   Context *ctx;\n   bool trait_object_mode;\n   ::Btype *translated;\n+  size_t recursion_count;\n+\n+  static const size_t kDefaultRecusionLimit = 5;\n };\n \n } // namespace Compile"}, {"sha": "5fb635b291baef4eeb96adc11d699801ff7decf3", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -331,7 +331,7 @@ class CompileTraitItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (TyTy::BaseType *self, HIR::TraitItem *item,\n+  static Bexpression *Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n \t\t\t       Context *ctx, TyTy::BaseType *concrete,\n \t\t\t       bool is_query_mode = false,\n \t\t\t       Location ref_locus = Location ())\n@@ -575,14 +575,14 @@ class CompileTraitItem : public HIRCompileBase\n   }\n \n private:\n-  CompileTraitItem (TyTy::BaseType *self, Context *ctx,\n+  CompileTraitItem (const TyTy::BaseType *self, Context *ctx,\n \t\t    TyTy::BaseType *concrete, Location ref_locus)\n     : HIRCompileBase (ctx), self (self), concrete (concrete),\n       reference (ctx->get_backend ()->error_expression ()),\n       ref_locus (ref_locus)\n   {}\n \n-  TyTy::BaseType *self;\n+  const TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n   Bexpression *reference;\n   Location ref_locus;"}, {"sha": "e9aca2c34f13a1fc04c347a5f7263b1f078d9911", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n \n namespace Rust {\n@@ -243,8 +244,9 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \n       size_t offs = 0;\n       const Resolver::TraitItemReference *ref = nullptr;\n-      for (auto &item : dyn->get_object_items ())\n+      for (auto &bound : dyn->get_object_items ())\n \t{\n+\t  const Resolver::TraitItemReference *item = bound.first;\n \t  auto t = item->get_tyty ();\n \t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n \t  auto ft = static_cast<TyTy::FnType *> (t);\n@@ -790,18 +792,25 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   // __trait_object_ptr\n   // [list of function ptrs]\n \n+  auto root = actual->get_root ();\n+  std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n+\n   std::vector<Bexpression *> vals;\n   vals.push_back (compiled_ref);\n-  for (auto &item : ty->get_object_items ())\n+  for (auto &bound : ty->get_object_items ())\n     {\n-      // compute the address of each method item\n-      auto address = compute_address_for_trait_item (item, actual->get_root ());\n+      const Resolver::TraitItemReference *item = bound.first;\n+      const TyTy::TypeBoundPredicate *predicate = bound.second;\n+\n+      auto address = compute_address_for_trait_item (item, predicate,\n+\t\t\t\t\t\t     probed_bounds_for_receiver,\n+\t\t\t\t\t\t     actual, root, locus);\n       vals.push_back (address);\n     }\n \n   Bexpression *constructed_trait_object\n     = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n-\n \t\t\t\t\t\t   locus);\n \n   fncontext fnctx = ctx->peek_fn ();\n@@ -851,44 +860,148 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n \n Bexpression *\n HIRCompileBase::compute_address_for_trait_item (\n-  const Resolver::TraitItemReference *trait_item_ref,\n-  const TyTy::BaseType *receiver)\n+  const Resolver::TraitItemReference *ref,\n+  const TyTy::TypeBoundPredicate *predicate,\n+  std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+    &receiver_bounds,\n+  const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus)\n {\n-  TyTy::BaseType *item_type = trait_item_ref->get_tyty ();\n-  rust_assert (item_type->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (item_type);\n-\n-  auto root = receiver->get_root ();\n-  HIR::PathIdentSegment segment_name (trait_item_ref->get_identifier ());\n-  std::vector<Resolver::PathProbeCandidate> candidates\n-    = Resolver::PathProbeType::Probe (root, segment_name, true, false, true);\n-\n-  // FIXME for default trait item resolution\n+  // There are two cases here one where its an item which has an implementation\n+  // within a trait-impl-block. Then there is the case where there is a default\n+  // implementation for this within the trait.\n   //\n-  // if (candidates.size () == 0)\n-  //   {\n-  //     rust_assert (trait_item_ref->is_optional ()); // has definition\n+  // The awkward part here is that this might be a generic trait and we need to\n+  // figure out the correct monomorphized type for this so we can resolve the\n+  // address of the function , this is stored as part of the\n+  // type-bound-predicate\n   //\n-  //     CompileTraitItem::Compile (self_type,\n-  //       \t\t\t trait_item_ref->get_hir_trait_item (), ctx,\n-  //       \t\t\t fntype);\n-  //     if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-  //       {\n-  //         return ctx->get_backend ()->error_expression ();\n-  //       }\n-  //   }\n-\n-  rust_assert (!candidates.empty ());\n-  rust_assert (candidates.size () == 1);\n-\n-  Resolver::PathProbeCandidate *candidate = &candidates.at (0);\n-  rust_assert (candidate->is_impl_candidate ());\n-\n-  HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n-\n-  return CompileInherentImplItem::Compile (receiver->get_root (), impl_item,\n-\t\t\t\t\t   ctx, true, fntype, true,\n-\t\t\t\t\t   Location () /* FIXME */);\n+  // Algo:\n+  // check if there is an impl-item for this trait-item-ref first\n+  // else assert that the trait-item-ref has an implementation\n+\n+  TyTy::TypeBoundPredicateItem predicate_item\n+    = predicate->lookup_associated_item (ref->get_identifier ());\n+  rust_assert (!predicate_item.is_error ());\n+\n+  // this is the expected end type\n+  TyTy::BaseType *trait_item_type = predicate_item.get_tyty_for_receiver (root);\n+  rust_assert (trait_item_type->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *trait_item_fntype\n+    = static_cast<TyTy::FnType *> (trait_item_type);\n+\n+  // find impl-block for this trait-item-ref\n+  HIR::ImplBlock *associated_impl_block = nullptr;\n+  const Resolver::TraitReference *predicate_trait_ref = predicate->get ();\n+  for (auto &item : receiver_bounds)\n+    {\n+      Resolver::TraitReference *trait_ref = item.first;\n+      HIR::ImplBlock *impl_block = item.second;\n+      if (predicate_trait_ref->is_equal (*trait_ref))\n+\t{\n+\t  associated_impl_block = impl_block;\n+\t  break;\n+\t}\n+    }\n+\n+  // FIXME this probably should just return error_mark_node but this helps\n+  // debug for now since we are wrongly returning early on type-resolution\n+  // failures, until we take advantage of more error types and error_mark_node\n+  rust_assert (associated_impl_block != nullptr);\n+\n+  // lookup self for the associated impl\n+  std::unique_ptr<HIR::Type> &self_type_path\n+    = associated_impl_block->get_type ();\n+  TyTy::BaseType *self = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    self_type_path->get_mappings ().get_hirid (), &self);\n+  rust_assert (ok);\n+\n+  // lookup the predicate item from the self\n+  TyTy::TypeBoundPredicate *self_bound = nullptr;\n+  for (auto &bound : self->get_specified_bounds ())\n+    {\n+      const Resolver::TraitReference *bound_ref = bound.get ();\n+      const Resolver::TraitReference *specified_ref = predicate->get ();\n+      if (bound_ref->is_equal (*specified_ref))\n+\t{\n+\t  self_bound = &bound;\n+\t  break;\n+\t}\n+    }\n+  rust_assert (self_bound != nullptr);\n+\n+  // lookup the associated item from the associated impl block\n+  TyTy::TypeBoundPredicateItem associated_self_item\n+    = self_bound->lookup_associated_item (ref->get_identifier ());\n+  rust_assert (!associated_self_item.is_error ());\n+\n+  // apply any generic arguments from this predicate\n+  TyTy::BaseType *mono1 = associated_self_item.get_tyty_for_receiver (self);\n+  TyTy::BaseType *mono2 = nullptr;\n+  if (predicate->has_generic_args ())\n+    {\n+      mono2 = associated_self_item.get_tyty_for_receiver (\n+\tself, predicate->get_generic_args ());\n+    }\n+  else\n+    {\n+      mono2 = associated_self_item.get_tyty_for_receiver (self);\n+    }\n+  rust_assert (mono1 != nullptr);\n+  rust_assert (mono1->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *assocated_item_ty1 = static_cast<TyTy::FnType *> (mono1);\n+\n+  rust_assert (mono2 != nullptr);\n+  rust_assert (mono2->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *assocated_item_ty2 = static_cast<TyTy::FnType *> (mono2);\n+\n+  // Lookup the impl-block for the associated impl_item if it exists\n+  HIR::Function *associated_function = nullptr;\n+  for (auto &impl_item : associated_impl_block->get_impl_items ())\n+    {\n+      bool is_function = impl_item->get_impl_item_type ()\n+\t\t\t == HIR::ImplItem::ImplItemType::FUNCTION;\n+      if (!is_function)\n+\tcontinue;\n+\n+      HIR::Function *fn = static_cast<HIR::Function *> (impl_item.get ());\n+      bool found_associated_item\n+\t= fn->get_function_name ().compare (ref->get_identifier ()) == 0;\n+      if (found_associated_item)\n+\tassociated_function = fn;\n+    }\n+\n+  // we found an impl_item for this\n+  if (associated_function != nullptr)\n+    {\n+      // lookup the associated type for this item\n+      TyTy::BaseType *lookup = nullptr;\n+      bool ok = ctx->get_tyctx ()->lookup_type (\n+\tassociated_function->get_mappings ().get_hirid (), &lookup);\n+      rust_assert (ok);\n+      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *lookup_fntype = static_cast<TyTy::FnType *> (lookup);\n+\n+      if (lookup_fntype->needs_substitution ())\n+\t{\n+\t  TyTy::SubstitutionArgumentMappings mappings\n+\t    = assocated_item_ty1->solve_missing_mappings_from_this (\n+\t      *assocated_item_ty2, *lookup_fntype);\n+\t  lookup_fntype = lookup_fntype->handle_substitions (mappings);\n+\t}\n+\n+      return CompileInherentImplItem::Compile (root, associated_function, ctx,\n+\t\t\t\t\t       true, lookup_fntype, true,\n+\t\t\t\t\t       locus);\n+    }\n+\n+  // we can only compile trait-items with a body\n+  bool trait_item_has_definition = ref->is_optional ();\n+  rust_assert (trait_item_has_definition);\n+\n+  HIR::TraitItem *trait_item = ref->get_hir_trait_item ();\n+  return CompileTraitItem::Compile (root, trait_item, ctx, trait_item_fntype,\n+\t\t\t\t    true, locus);\n }\n \n } // namespace Compile"}, {"sha": "858984c3710b5d7c9d6ef5695caa19e7e175342d", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -293,6 +293,8 @@ class ASTLoweringType : public ASTLoweringBase\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;\n \n+  void visit (AST::TraitObjectType &type) override;\n+\n private:\n   ASTLoweringType () : ASTLoweringBase (), translated (nullptr) {}\n "}, {"sha": "d8d53eb0cc68c00825ad19f21b9ab57dcb7c7a9e", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -517,21 +517,43 @@ ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n void\n ASTLoweringType::visit (AST::TraitObjectTypeOneBound &type)\n {\n-  HIR::TypeParamBound *b\n+  std::vector<std::unique_ptr<HIR::TypeParamBound> > bounds;\n+  HIR::TypeParamBound *translated_bound\n     = ASTLoweringTypeBounds::translate (&type.get_trait_bound ());\n-  rust_assert (b->get_bound_type () == HIR::TypeParamBound::TRAITBOUND);\n-  HIR::TraitBound *bb = static_cast<HIR::TraitBound *> (b);\n-  HIR::TraitBound bound (*bb);\n-  delete bb;\n+  bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (translated_bound));\n \n   auto crate_num = mappings->get_current_crate ();\n   Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n \t\t\t\t mappings->get_next_hir_id (crate_num),\n \t\t\t\t mappings->get_next_localdef_id (crate_num));\n \n-  translated\n-    = new HIR::TraitObjectTypeOneBound (mapping, std::move (bound),\n-\t\t\t\t\ttype.get_locus (), type.is_dyn ());\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+\n+  mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n+\t\t\t     translated);\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectType &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound> > bounds;\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      HIR::TypeParamBound *translated_bound\n+\t= ASTLoweringTypeBounds::translate (bound.get ());\n+      bounds.push_back (\n+\tstd::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n \n   mappings->insert_hir_type (mapping.get_crate_num (), mapping.get_hirid (),\n \t\t\t     translated);"}, {"sha": "3e9d8b24beffaacdbe0a7bf7ff087a3f71e0574a", "filename": "gcc/rust/hir/tree/rust-hir-full-decls.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-decls.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -218,7 +218,6 @@ class ImplTraitType;\n class TraitObjectType;\n class ParenthesisedType;\n class ImplTraitTypeOneBound;\n-class TraitObjectTypeOneBound;\n class TupleType;\n class NeverType;\n class RawPointerType;"}, {"sha": "bacef82ab3e192abeb834c668d38f35d96d55000", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -2892,25 +2892,6 @@ TypePathSegmentGeneric::as_string () const\n   return TypePathSegment::as_string () + \"<\" + generic_args.as_string () + \">\";\n }\n \n-std::string\n-TraitObjectTypeOneBound::as_string () const\n-{\n-  std::string str (\"TraitObjectTypeOneBound: \\n Has dyn dispatch: \");\n-\n-  if (has_dyn)\n-    {\n-      str += \"true\";\n-    }\n-  else\n-    {\n-      str += \"false\";\n-    }\n-\n-  str += \"\\n TraitBound: \" + trait_bound.as_string ();\n-\n-  return str;\n-}\n-\n std::string\n TypePathFunction::as_string () const\n {\n@@ -4461,12 +4442,6 @@ ImplTraitTypeOneBound::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n-void\n-TraitObjectTypeOneBound::accept_vis (HIRVisitor &vis)\n-{\n-  vis.visit (*this);\n-}\n-\n void\n TupleType::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "0dd7ac80b658c2564db0b420b30ef642969e5382", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -1122,6 +1122,11 @@ class Function : public VisItem, public ImplItem\n   // Returns whether function has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n+  ImplItemType get_impl_item_type () const override final\n+  {\n+    return ImplItem::ImplItemType::FUNCTION;\n+  }\n+\n   // Mega-constructor with all possible fields\n   Function (Analysis::NodeMapping mappings, Identifier function_name,\n \t    FunctionQualifiers qualifiers,\n@@ -1273,6 +1278,11 @@ class TypeAlias : public VisItem, public ImplItem\n   // Returns whether type alias has a where clause.\n   bool has_where_clause () const { return !where_clause.is_empty (); }\n \n+  ImplItemType get_impl_item_type () const override final\n+  {\n+    return ImplItem::ImplItemType::TYPE_ALIAS;\n+  }\n+\n   // Mega-constructor with all possible fields\n   TypeAlias (Analysis::NodeMapping mappings, Identifier new_type_name,\n \t     std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -2075,6 +2085,11 @@ class ConstantItem : public VisItem, public ImplItem\n     return get_mappings ();\n   };\n \n+  ImplItemType get_impl_item_type () const override final\n+  {\n+    return ImplItem::ImplItemType::CONSTANT;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "070b76182bba3a51c4b20f8ef0d5085987f860b0", "filename": "gcc/rust/hir/tree/rust-hir-type.h", "status": "modified", "additions": 13, "deletions": 45, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-type.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -145,10 +145,7 @@ class ImplTraitType : public Type\n class TraitObjectType : public Type\n {\n   bool has_dyn;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound> >\n-    type_param_bounds; // inlined form\n-\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n   Location locus;\n \n protected:\n@@ -163,7 +160,7 @@ class TraitObjectType : public Type\n   TraitObjectType (\n     Analysis::NodeMapping mappings,\n     std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n-    Location locus, bool is_dyn_dispatch = false)\n+    Location locus, bool is_dyn_dispatch)\n     : Type (mappings), has_dyn (is_dyn_dispatch),\n       type_param_bounds (std::move (type_param_bounds)), locus (locus)\n   {}\n@@ -199,6 +196,17 @@ class TraitObjectType : public Type\n   Location get_locus () const { return locus; }\n \n   void accept_vis (HIRVisitor &vis) override;\n+\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n };\n \n // A type with parentheses around it, used to avoid ambiguity.\n@@ -305,46 +313,6 @@ class ImplTraitTypeOneBound : public TypeNoBounds\n   void accept_vis (HIRVisitor &vis) override;\n };\n \n-/* A trait object with a single trait bound. The \"trait bound\" is really just\n- * the trait. Basically like using an interface as a type in an OOP language. */\n-class TraitObjectTypeOneBound : public TypeNoBounds\n-{\n-  bool has_dyn;\n-  TraitBound trait_bound;\n-  Location locus;\n-\n-protected:\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TraitObjectTypeOneBound *clone_type_impl () const override\n-  {\n-    return new TraitObjectTypeOneBound (mappings, trait_bound, locus, has_dyn);\n-  }\n-\n-  /* Use covariance to implement clone function as returning this object rather\n-   * than base */\n-  TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n-  {\n-    return new TraitObjectTypeOneBound (mappings, trait_bound, locus, has_dyn);\n-  }\n-\n-public:\n-  TraitObjectTypeOneBound (Analysis::NodeMapping mappings,\n-\t\t\t   TraitBound trait_bound, Location locus,\n-\t\t\t   bool is_dyn_dispatch)\n-    : TypeNoBounds (mappings), has_dyn (is_dyn_dispatch),\n-      trait_bound (std::move (trait_bound)), locus (locus)\n-  {}\n-\n-  std::string as_string () const override;\n-\n-  Location get_locus () const { return locus; }\n-\n-  void accept_vis (HIRVisitor &vis) override;\n-\n-  TraitBound &get_trait_bound () { return trait_bound; }\n-};\n-\n class TypePath; // definition moved to \"rust-path.h\"\n \n /* A type consisting of the \"product\" of others (the tuple's elements) in a"}, {"sha": "04874468cf1dd608e5aacbd06fe3436bf3964aa1", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -149,7 +149,6 @@ class HIRVisitor\n   virtual void visit (TraitObjectType &type) = 0;\n   virtual void visit (ParenthesisedType &type) = 0;\n   virtual void visit (ImplTraitTypeOneBound &type) = 0;\n-  virtual void visit (TraitObjectTypeOneBound &type) = 0;\n   virtual void visit (TupleType &type) = 0;\n   virtual void visit (NeverType &type) = 0;\n   virtual void visit (RawPointerType &type) = 0;"}, {"sha": "af18d804f42c40a093d9cec4af9f674aa6a10df6", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -642,11 +642,14 @@ class TraitItem\n \n class ImplItem\n {\n-protected:\n-  // Clone function implementation as pure virtual method\n-  virtual ImplItem *clone_inherent_impl_item_impl () const = 0;\n-\n public:\n+  enum ImplItemType\n+  {\n+    FUNCTION,\n+    TYPE_ALIAS,\n+    CONSTANT\n+  };\n+\n   virtual ~ImplItem () {}\n \n   // Unique pointer custom clone function\n@@ -662,6 +665,12 @@ class ImplItem\n   virtual Analysis::NodeMapping get_impl_mappings () const = 0;\n \n   virtual Location get_locus () const = 0;\n+\n+  virtual ImplItemType get_impl_item_type () const = 0;\n+\n+protected:\n+  // Clone function implementation as pure virtual method\n+  virtual ImplItem *clone_inherent_impl_item_impl () const = 0;\n };\n \n // A crate HIR object - holds all the data for a single compilation unit"}, {"sha": "b67705bebab119f75c4f9f862f06c4565c766f7d", "filename": "gcc/rust/lint/rust-lint-marklive-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -172,7 +172,6 @@ class MarkLiveBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitObjectType &) override {}\n   virtual void visit (HIR::ParenthesisedType &) override {}\n   virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n-  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n   virtual void visit (HIR::TupleType &) override {}\n   virtual void visit (HIR::NeverType &) override {}\n   virtual void visit (HIR::RawPointerType &) override {}"}, {"sha": "f1d376ac3d9cf011b0d405c0b3272ded0b82531a", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -9065,7 +9065,8 @@ Parser<ManagedTokenSource>::parse_type ()\n \t  = parse_type_param_bounds ();\n \n \treturn std::unique_ptr<AST::TraitObjectType> (\n-\t  new AST::TraitObjectType (std::move (bounds), t->get_locus ()));\n+\t  new AST::TraitObjectType (std::move (bounds), t->get_locus (),\n+\t\t\t\t    false));\n       }\n     case IDENTIFIER:\n     case SUPER:\n@@ -9152,7 +9153,7 @@ Parser<ManagedTokenSource>::parse_type ()\n \t\t}\n \n \t      return std::unique_ptr<AST::TraitObjectType> (\n-\t\tnew AST::TraitObjectType (std::move (bounds), locus));\n+\t\tnew AST::TraitObjectType (std::move (bounds), locus, false));\n \t    }\n \t  default:\n \t    // assume that this is a type path and not an error\n@@ -9422,7 +9423,8 @@ Parser<ManagedTokenSource>::parse_paren_prefixed_type ()\n \t    }\n \n \t  return std::unique_ptr<AST::TraitObjectType> (\n-\t    new AST::TraitObjectType (std::move (bounds), left_delim_locus));\n+\t    new AST::TraitObjectType (std::move (bounds), left_delim_locus,\n+\t\t\t\t      false));\n \t}\n       else\n \t{\n@@ -9532,7 +9534,7 @@ Parser<ManagedTokenSource>::parse_for_prefixed_type ()\n \t  }\n \n \treturn std::unique_ptr<AST::TraitObjectType> (\n-\t  new AST::TraitObjectType (std::move (bounds), for_locus));\n+\t  new AST::TraitObjectType (std::move (bounds), for_locus, false));\n       }\n     default:\n       // error"}, {"sha": "838d17331ea642e0eb13aad194757dbf5edbec9b", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -371,6 +371,8 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;\n \n+  void visit (AST::TraitObjectType &type) override;\n+\n private:\n   ResolveType (NodeId parent, bool canonicalize_type_with_generics)\n     : ResolverBase (parent),"}, {"sha": "af04aeb215164622295ae13c50a13d372783ac7d", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -726,6 +726,17 @@ ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n   ok = bound_resolved_id != UNKNOWN_NODEID;\n }\n \n+void\n+ResolveType::visit (AST::TraitObjectType &type)\n+{\n+  ok = true;\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      /* NodeId bound_resolved_id = */\n+      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+    }\n+}\n+\n // rust-ast-resolve-item.h\n \n void"}, {"sha": "9cbf1ab2df769cb380274b81b339ae6ad07b81e2", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -175,7 +175,6 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitObjectType &) override {}\n   virtual void visit (HIR::ParenthesisedType &) override {}\n   virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n-  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n   virtual void visit (HIR::TupleType &) override {}\n   virtual void visit (HIR::NeverType &) override {}\n   virtual void visit (HIR::RawPointerType &) override {}"}, {"sha": "31ebf8b5323c421fb5134e57967d317238f75c07", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -91,9 +91,7 @@ class TraitItemReference\n \n   TraitItemType get_trait_item_type () const { return type; }\n \n-  const HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n-\n-  HIR::TraitItem *get_hir_trait_item () { return hir_trait_item; }\n+  HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n \n   Location get_locus () const { return locus; }\n "}, {"sha": "eb96fd18e023119ecbc052eb154036e6e68f193c", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -177,7 +177,6 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitObjectType &) override {}\n   virtual void visit (HIR::ParenthesisedType &) override {}\n   virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n-  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n   virtual void visit (HIR::TupleType &) override {}\n   virtual void visit (HIR::NeverType &) override {}\n   virtual void visit (HIR::RawPointerType &) override {}"}, {"sha": "706f649340fd8af32d78633e8d5ce4f1e0ae343e", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -70,12 +70,34 @@ class TypeCheckItem : public TypeCheckBase\n \t  }\n       }\n \n+    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n     TraitReference *trait_reference = &TraitReference::error_node ();\n     if (impl_block.has_trait_ref ())\n       {\n \tstd::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n \ttrait_reference = TraitResolver::Resolve (*ref.get ());\n \trust_assert (!trait_reference->is_error ());\n+\n+\t// setup the bound\n+\tTyTy::TypeBoundPredicate predicate (\n+\t  trait_reference->get_mappings ().get_defid (), ref->get_locus ());\n+\tauto &final_seg = ref->get_final_segment ();\n+\tif (final_seg->is_generic_segment ())\n+\t  {\n+\t    auto final_generic_seg\n+\t      = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+\t    if (final_generic_seg->has_generic_args ())\n+\t      {\n+\t\tHIR::GenericArgs &generic_args\n+\t\t  = final_generic_seg->get_generic_args ();\n+\n+\t\t// this is applying generic arguments to a trait\n+\t\t// reference\n+\t\tpredicate.apply_generic_arguments (&generic_args);\n+\t      }\n+\t  }\n+\n+\tspecified_bounds.push_back (std::move (predicate));\n       }\n \n     TyTy::BaseType *self = nullptr;\n@@ -86,6 +108,8 @@ class TypeCheckItem : public TypeCheckBase\n \t\t       \"failed to resolve Self for ImplBlock\");\n \treturn;\n       }\n+    // inherit the bounds\n+    self->inherit_bounds (specified_bounds);\n \n     bool is_trait_impl_block = !trait_reference->is_error ();\n "}, {"sha": "f1dbb6b4de9a9fabeb6864ab084f0265282e0f32", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -95,7 +95,7 @@ TypeCheckType::visit (HIR::TypePath &path)\n \t\t     \"TypePath %s declares generic arguments but \"\n \t\t     \"the type %s does not have any\",\n \t\t     path.as_string ().c_str (),\n-\t\t     translated->as_string ().c_str ());\n+\t\t     path_type->as_string ().c_str ());\n     }\n   else\n     {\n@@ -525,22 +525,44 @@ TypeCheckType::resolve_segments (\n }\n \n void\n-TypeCheckType::visit (HIR::TraitObjectTypeOneBound &type)\n+TypeCheckType::visit (HIR::TraitObjectType &type)\n {\n   std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      if (bound->get_bound_type ()\n+\t  != HIR::TypeParamBound::BoundType::TRAITBOUND)\n+\tcontinue;\n+\n+      HIR::TypeParamBound &b = *bound.get ();\n+      HIR::TraitBound &trait_bound = static_cast<HIR::TraitBound &> (b);\n+\n+      auto &type_path = trait_bound.get_path ();\n+      TraitReference *trait = resolve_trait_path (type_path);\n+      TyTy::TypeBoundPredicate predicate (trait->get_mappings ().get_defid (),\n+\t\t\t\t\t  trait_bound.get_locus ());\n+      auto &final_seg = type_path.get_final_segment ();\n+      if (final_seg->is_generic_segment ())\n+\t{\n+\t  auto final_generic_seg\n+\t    = static_cast<HIR::TypePathSegmentGeneric *> (final_seg.get ());\n+\t  if (final_generic_seg->has_generic_args ())\n+\t    {\n+\t      HIR::GenericArgs &generic_args\n+\t\t= final_generic_seg->get_generic_args ();\n \n-  HIR::TraitBound &trait_bound = type.get_trait_bound ();\n-  TraitReference *trait = resolve_trait_path (trait_bound.get_path ());\n-  TyTy::TypeBoundPredicate predicate (trait->get_mappings ().get_defid (),\n-\t\t\t\t      trait_bound.get_locus ());\n+\t      // this is applying generic arguments to a trait\n+\t      // reference\n+\t      predicate.apply_generic_arguments (&generic_args);\n+\t    }\n+\t}\n \n-  if (predicate.is_object_safe (true, type.get_locus ()))\n-    {\n-      specified_bounds.push_back (std::move (predicate));\n-      translated\n-\t= new TyTy::DynamicObjectType (type.get_mappings ().get_hirid (),\n-\t\t\t\t       std::move (specified_bounds));\n+      if (predicate.is_object_safe (true, type.get_locus ()))\n+\tspecified_bounds.push_back (std::move (predicate));\n     }\n+\n+  translated = new TyTy::DynamicObjectType (type.get_mappings ().get_hirid (),\n+\t\t\t\t\t    std::move (specified_bounds));\n }\n \n } // namespace Resolver"}, {"sha": "08734cec4d3a00493aca719f60bf5f56479e9839", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -62,13 +62,9 @@ class TypeCheckType : public TypeCheckBase\n \t   std::vector<TyTy::SubstitutionParamMapping> *subst_mappings\n \t   = nullptr)\n   {\n-    TypeCheckType resolver (subst_mappings);\n+    TypeCheckType resolver (type->get_mappings ().get_hirid (), subst_mappings);\n     type->accept_vis (resolver);\n-\n-    if (resolver.translated == nullptr)\n-      resolver.translated\n-\t= new TyTy::ErrorType (type->get_mappings ().get_hirid ());\n-\n+    rust_assert (resolver.translated != nullptr);\n     resolver.context->insert_type (type->get_mappings (), resolver.translated);\n     return resolver.translated;\n   }\n@@ -147,11 +143,13 @@ class TypeCheckType : public TypeCheckBase\n \t\t\t\t      TyTy::InferType::InferTypeKind::GENERAL);\n   }\n \n-  void visit (HIR::TraitObjectTypeOneBound &type) override;\n+  void visit (HIR::TraitObjectType &type) override;\n \n private:\n-  TypeCheckType (std::vector<TyTy::SubstitutionParamMapping> *subst_mappings)\n-    : TypeCheckBase (), subst_mappings (subst_mappings), translated (nullptr)\n+  TypeCheckType (HirId id,\n+\t\t std::vector<TyTy::SubstitutionParamMapping> *subst_mappings)\n+    : TypeCheckBase (), subst_mappings (subst_mappings),\n+      translated (new TyTy::ErrorType (id))\n   {}\n \n   void"}, {"sha": "4595ca334b941ae25555cfe2b0840c02651f7022", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -170,7 +170,6 @@ class SimpleHirVisitor : public HIR::HIRVisitor\n   virtual void visit (HIR::TraitObjectType &) override {}\n   virtual void visit (HIR::ParenthesisedType &) override {}\n   virtual void visit (HIR::ImplTraitTypeOneBound &) override {}\n-  virtual void visit (HIR::TraitObjectTypeOneBound &) override {}\n   virtual void visit (HIR::TupleType &) override {}\n   virtual void visit (HIR::NeverType &) override {}\n   virtual void visit (HIR::RawPointerType &) override {}"}, {"sha": "cfb96bbd0e4fe53c3ec161e2859e8335a49c4377", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -70,7 +70,10 @@ namespace TyTy {\n std::string\n TypeBoundPredicate::as_string () const\n {\n-  return get ()->as_string ();\n+  return get ()->as_string ()\n+\t + (has_generic_args ()\n+\t      ? std::string (\"<\") + args->as_string () + std::string (\">\")\n+\t      : \"\");\n }\n \n const Resolver::TraitReference *\n@@ -135,7 +138,8 @@ TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n }\n \n BaseType *\n-TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n+TypeBoundPredicateItem::get_tyty_for_receiver (\n+  const TyTy::BaseType *receiver, const HIR::GenericArgs *bound_args)\n {\n   TyTy::BaseType *trait_item_tyty = get_raw_item ()->get_tyty ();\n   if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n@@ -166,7 +170,8 @@ TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n     return trait_item_tyty;\n \n   // FIXME LEAK this should really be const\n-  const HIR::GenericArgs *args = parent->get_generic_args ();\n+  const HIR::GenericArgs *args\n+    = (bound_args != nullptr) ? bound_args : parent->get_generic_args ();\n   HIR::GenericArgs *generic_args = new HIR::GenericArgs (*args);\n   TyTy::BaseType *resolved\n     = Resolver::SubstMapper::Resolve (trait_item_tyty, parent->get_locus (),"}, {"sha": "378416ffe905ac1dd43e97528776fccf78aa19c3", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -333,6 +333,16 @@ StructFieldType::clone () const\n \t\t\t      get_field_type ()->clone ());\n }\n \n+bool\n+SubstitutionParamMapping::need_substitution () const\n+{\n+  if (!param->can_resolve ())\n+    return true;\n+\n+  auto resolved = param->resolve ();\n+  return !resolved->is_concrete ();\n+}\n+\n bool\n SubstitutionParamMapping::fill_param_ty (BaseType &type, Location locus)\n {\n@@ -575,6 +585,57 @@ SubstitutionRef::solve_mappings_from_receiver_for_self (\n \t\t\t\t       mappings.get_locus ());\n }\n \n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n+\t\t\t\t\t\t   SubstitutionRef &to)\n+{\n+  rust_assert (!ref.needs_substitution ());\n+  rust_assert (needs_substitution ());\n+  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n+\n+  Location locus = used_arguments.get_locus ();\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &a = substitutions.at (i);\n+      SubstitutionParamMapping &b = ref.substitutions.at (i);\n+\n+      if (a.need_substitution ())\n+\t{\n+\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n+\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n+\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+\n+\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n+\t\t\t\t      b.get_param_ty ()->resolve ()};\n+\t}\n+    }\n+\n+  for (auto it = substs.begin (); it != substs.end (); it++)\n+    {\n+      HirId param_id = it->first;\n+      BaseType *arg = it->second.second;\n+\n+      const SubstitutionParamMapping *associate_param = nullptr;\n+      for (SubstitutionParamMapping &p : to.substitutions)\n+\t{\n+\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n+\t    {\n+\t      associate_param = &p;\n+\t      break;\n+\t    }\n+\t}\n+\n+      rust_assert (associate_param != nullptr);\n+      SubstitutionArg argument (associate_param, arg);\n+      resolved_mappings.push_back (std::move (argument));\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings, locus);\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -1978,7 +2039,7 @@ ParamType::as_string () const\n   bool ok = context->lookup_type (get_ty_ref (), &lookup);\n   rust_assert (ok);\n \n-  return lookup->as_string ();\n+  return get_symbol () + \"=\" + lookup->as_string ();\n }\n \n std::string\n@@ -2503,10 +2564,13 @@ DynamicObjectType::is_equal (const BaseType &other) const\n   return bounds_compatible (other, Location (), false);\n }\n \n-const std::vector<const Resolver::TraitItemReference *>\n+const std::vector<\n+  std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n DynamicObjectType::get_object_items () const\n {\n-  std::vector<const Resolver::TraitItemReference *> items;\n+  std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n+    items;\n   for (auto &bound : get_specified_bounds ())\n     {\n       const Resolver::TraitReference *trait = bound.get ();\n@@ -2515,7 +2579,7 @@ DynamicObjectType::get_object_items () const\n \t  if (item.get_trait_item_type ()\n \t\t== Resolver::TraitItemReference::TraitItemType::FN\n \t      && item.is_object_safe ())\n-\t    items.push_back (&item);\n+\t    items.push_back ({&item, &bound});\n \t}\n \n       for (auto &super_trait : trait->get_super_traits ())\n@@ -2525,7 +2589,7 @@ DynamicObjectType::get_object_items () const\n \t      if (item.get_trait_item_type ()\n \t\t    == Resolver::TraitItemReference::TraitItemType::FN\n \t\t  && item.is_object_safe ())\n-\t\titems.push_back (&item);\n+\t\titems.push_back ({&item, &bound});\n \t    }\n \t}\n     }"}, {"sha": "ae9ff676c19b09144ab38413e987d16ffa6b4bc5", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 114, "deletions": 16, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -166,12 +166,16 @@ class TypeBoundPredicateItem\n     return parent == nullptr || trait_item_ref == nullptr;\n   }\n \n-  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver,\n+\t\t\t\t   const HIR::GenericArgs *bound_args\n+\t\t\t\t   = nullptr);\n \n   const Resolver::TraitItemReference *get_raw_item () const;\n \n   bool needs_implementation () const;\n \n+  const TypeBoundPredicate *get_parent () const { return parent; }\n+\n private:\n   const TypeBoundPredicate *parent;\n   const Resolver::TraitItemReference *trait_item_ref;\n@@ -340,7 +344,7 @@ class BaseType : public TypeBoundsMappings\n \n   virtual bool is_unit () const { return false; }\n \n-  virtual bool is_concrete () const { return true; }\n+  virtual bool is_concrete () const = 0;\n \n   TypeKind get_kind () const { return kind; }\n \n@@ -470,7 +474,7 @@ class InferType : public BaseType\n \n   bool default_type (BaseType **type) const;\n \n-  bool is_concrete () const final override { return false; }\n+  bool is_concrete () const final override { return true; }\n \n private:\n   InferTypeKind infer_kind;\n@@ -503,6 +507,8 @@ class ErrorType : public BaseType\n   BaseType *clone () const final override;\n \n   std::string get_name () const override final { return as_string (); }\n+\n+  bool is_concrete () const final override { return false; }\n };\n \n class SubstitutionArgumentMappings;\n@@ -559,6 +565,11 @@ class ParamType : public BaseType\n     return true;\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    return !contains_type_parameters ();\n+  }\n+\n   ParamType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n private:\n@@ -587,6 +598,8 @@ class StructFieldType\n \n   StructFieldType *clone () const;\n \n+  bool is_concrete () const { return ty->is_concrete (); }\n+\n   void debug () const { rust_debug (\"%s\", as_string ().c_str ()); }\n \n private:\n@@ -710,6 +723,8 @@ class SubstitutionParamMapping\n     return var.get_tyty ();\n   }\n \n+  bool need_substitution () const;\n+\n private:\n   const HIR::TypeParam &generic;\n   ParamType *param;\n@@ -743,8 +758,13 @@ class SubstitutionArg\n \n   bool is_conrete () const\n   {\n-    return argument != nullptr && argument->get_kind () != TyTy::TypeKind::ERROR\n-\t   && argument->get_kind () != TyTy::TypeKind::PARAM;\n+    if (argument != nullptr)\n+      return true;\n+\n+    if (argument->get_kind () == TyTy::TypeKind::PARAM)\n+      return false;\n+\n+    return argument->is_concrete ();\n   }\n \n   std::string as_string () const\n@@ -898,16 +918,12 @@ class SubstitutionRef\n \n   bool needs_substitution () const\n   {\n-    if (!has_substitutions ())\n-      return false;\n-\n-    if (used_arguments.is_error ())\n-      return true;\n-\n-    if (used_arguments.size () != get_num_substitutions ())\n-      return true;\n-\n-    return !used_arguments.is_concrete ();\n+    for (auto &sub : substitutions)\n+      {\n+\tif (sub.need_substitution ())\n+\t  return true;\n+      }\n+    return false;\n   }\n \n   bool was_substituted () const { return !needs_substitution (); }\n@@ -973,6 +989,11 @@ class SubstitutionRef\n   SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n     SubstitutionArgumentMappings &mappings) const;\n \n+  // TODO comment\n+  SubstitutionArgumentMappings\n+  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n+\n+  // TODO comment\n   BaseType *infer_substitions (Location locus)\n   {\n     std::vector<SubstitutionArg> args;\n@@ -1217,6 +1238,19 @@ class ADTType : public BaseType, public SubstitutionRef\n     return identifier + subst_as_string ();\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    for (auto &variant : variants)\n+      {\n+\tfor (auto &field : variant->get_fields ())\n+\t  {\n+\t    if (!field->is_concrete ())\n+\t      return false;\n+\t  }\n+      }\n+    return true;\n+  }\n+\n   BaseType *clone () const final override;\n \n   bool needs_generic_substitutions () const override final\n@@ -1349,6 +1383,17 @@ class FnType : public BaseType, public SubstitutionRef\n     return param_at (0).second;\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    for (const auto &param : params)\n+      {\n+\tconst BaseType *p = param.second;\n+\tif (!p->is_concrete ())\n+\t  return false;\n+      }\n+    return get_return_type ()->is_concrete ();\n+  }\n+\n   std::vector<std::pair<HIR::Pattern *, BaseType *>> &get_params ()\n   {\n     return params;\n@@ -1446,6 +1491,16 @@ class FnPtr : public BaseType\n       }\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    for (auto &p : params)\n+      {\n+\tif (!p.get_tyty ()->is_concrete ())\n+\t  return false;\n+      }\n+    return result_type.get_tyty ()->is_concrete ();\n+  }\n+\n private:\n   std::vector<TyVar> params;\n   TyVar result_type;\n@@ -1498,6 +1553,17 @@ class ClosureType : public BaseType, public SubstitutionRef\n \n   BaseType *clone () const final override;\n \n+  bool is_concrete () const override final\n+  {\n+    for (auto &param : parameter_types)\n+      {\n+\tauto p = param.get_tyty ();\n+\tif (!p->is_concrete ())\n+\t  return false;\n+      }\n+    return result_type.get_tyty ()->is_concrete ();\n+  }\n+\n   bool needs_generic_substitutions () const override final\n   {\n     return needs_substitution ();\n@@ -1591,6 +1657,7 @@ class BoolType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  bool is_concrete () const override final { return true; }\n };\n \n class IntType : public BaseType\n@@ -1632,6 +1699,7 @@ class IntType : public BaseType\n   BaseType *clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n+  bool is_concrete () const override final { return true; }\n \n private:\n   IntKind int_kind;\n@@ -1676,6 +1744,7 @@ class UintType : public BaseType\n   BaseType *clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n+  bool is_concrete () const override final { return true; }\n \n private:\n   UintKind uint_kind;\n@@ -1718,6 +1787,7 @@ class FloatType : public BaseType\n   BaseType *clone () const final override;\n \n   bool is_equal (const BaseType &other) const override;\n+  bool is_concrete () const override final { return true; }\n \n private:\n   FloatKind float_kind;\n@@ -1748,6 +1818,7 @@ class USizeType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  bool is_concrete () const override final { return true; }\n };\n \n class ISizeType : public BaseType\n@@ -1775,6 +1846,7 @@ class ISizeType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  bool is_concrete () const override final { return true; }\n };\n \n class CharType : public BaseType\n@@ -1802,6 +1874,7 @@ class CharType : public BaseType\n   BaseType *cast (BaseType *other) override;\n \n   BaseType *clone () const final override;\n+  bool is_concrete () const override final { return true; }\n };\n \n class ReferenceType : public BaseType\n@@ -1841,6 +1914,11 @@ class ReferenceType : public BaseType\n     return get_base ()->contains_type_parameters ();\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    return !contains_type_parameters ();\n+  }\n+\n   ReferenceType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n   Mutability mutability () const { return mut; }\n@@ -1889,6 +1967,11 @@ class PointerType : public BaseType\n     return get_base ()->contains_type_parameters ();\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    return !contains_type_parameters ();\n+  }\n+\n   PointerType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n   Mutability mutability () const { return mut; }\n@@ -1929,6 +2012,7 @@ class StrType : public BaseType\n   bool is_equal (const BaseType &other) const override;\n \n   BaseType *clone () const final override;\n+  bool is_concrete () const override final { return true; }\n };\n \n // https://doc.rust-lang.org/std/primitive.never.html\n@@ -1968,6 +2052,7 @@ class NeverType : public BaseType\n   std::string get_name () const override final { return as_string (); }\n \n   bool is_unit () const override { return true; }\n+  bool is_concrete () const override final { return true; }\n };\n \n // used at the type in associated types in traits\n@@ -2027,6 +2112,11 @@ class PlaceholderType : public BaseType\n     return resolve ()->contains_type_parameters ();\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    return !contains_type_parameters ();\n+  }\n+\n private:\n   std::string symbol;\n };\n@@ -2092,6 +2182,11 @@ class ProjectionType : public BaseType, public SubstitutionRef\n     return base->contains_type_parameters ();\n   }\n \n+  bool is_concrete () const override final\n+  {\n+    return !contains_type_parameters ();\n+  }\n+\n   ProjectionType *\n   handle_substitions (SubstitutionArgumentMappings mappings) override final;\n \n@@ -2132,8 +2227,11 @@ class DynamicObjectType : public BaseType\n \n   std::string get_name () const override final;\n \n+  bool is_concrete () const override final { return true; }\n+\n   // this returns a flat list of items including super trait bounds\n-  const std::vector<const Resolver::TraitItemReference *>\n+  const std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n   get_object_items () const;\n };\n "}, {"sha": "f8f551ba86d7dd79e1771da2ed67150db124aa20", "filename": "gcc/testsuite/rust/compile/traits10.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits10.rs?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -12,5 +12,4 @@ pub fn main() {\n \n     let b: &dyn Bar = &a;\n     // { dg-error \"trait bound is not object safe\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "d06e47d7e16f03815ff66ac35aa913581d71c54e", "filename": "gcc/testsuite/rust/compile/traits11.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits11.rs?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -16,5 +16,4 @@ pub fn main() {\n \n     let b: &dyn B = &a;\n     // { dg-error \"trait bound is not object safe\" \"\" { target *-*-* } .-1 }\n-    // { dg-error \"expected\" \"\" { target *-*-* } .-2 }\n }"}, {"sha": "f14a966bfba1aedc29c199b63026fa670765bf16", "filename": "gcc/testsuite/rust/execute/torture/trait12.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait12.rs?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait FnLike<A, R> {\n+    fn call(&self, arg: A) -> R;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .arg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;\n+\n+struct Identity;\n+\n+impl<'a, T> FnLike<&'a T, &'a T> for Identity {\n+    fn call(&self, arg: &'a T) -> &'a T {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-2 }\n+        arg\n+    }\n+}\n+\n+fn call_repeatedly(f: &FnObject) {\n+    let x = 3;\n+    let y = f.call(&x);\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *y);\n+    }\n+}\n+\n+fn main() -> i32 {\n+    call_repeatedly(&Identity);\n+\n+    0\n+}"}, {"sha": "76fb09cae82565d714d57220954ba3c874b7d32f", "filename": "gcc/testsuite/rust/execute/torture/trait13.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e73922ef9f07c511c383cc37532d0324a1138d99/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait13.rs?ref=e73922ef9f07c511c383cc37532d0324a1138d99", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-output \"123\\n456\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn qux(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, 456);\n+        }\n+    }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+    t.qux();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(123);\n+\n+    let b: &dyn Bar;\n+    b = &a;\n+    dynamic_dispatch(b);\n+\n+    0\n+}"}]}