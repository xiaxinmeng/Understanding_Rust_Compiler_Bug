{"sha": "4677862a0bfa291cf015559f78ee9cbf7d9f0734", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY3Nzg2MmEwYmZhMjkxY2YwMTU1NTlmNzhlZTljYmY3ZDlmMDczNA==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2003-03-09T19:47:54Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2003-03-09T19:47:54Z"}, "message": "re PR middle-end/9986 ([HP-UX] [3.4 regression] Incorrect transformation of fputs_unlocked to fputc_unlocked)\n\n\tPR middle-end/9986\n\t* c-common.c (c_common_nodes_and_builtins): Initialize target builtins\n\tafter the common builtins.\n\t* pa-hpux.h (DONT_HAVE_FPUTC_UNLOCKED): Define.\n\t* pa.c (TARGET_INIT_BUILTINS): Define.\n\t(pa_init_builtins): New function.\n\t* pa.md (call, call_value, sibcall, sibcall_value): When sufficient\n\tspace has been allocated for the outgoing arguments, set the arg\n\tpointer for a call emitted after virtuals have been instantiated\n\tusing the stack pointer offset, otherwise abort.\n\nFrom-SVN: r64043", "tree": {"sha": "15f04fa68a22dbaa3b962124526e39ef880b4185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15f04fa68a22dbaa3b962124526e39ef880b4185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4677862a0bfa291cf015559f78ee9cbf7d9f0734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4677862a0bfa291cf015559f78ee9cbf7d9f0734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4677862a0bfa291cf015559f78ee9cbf7d9f0734", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4677862a0bfa291cf015559f78ee9cbf7d9f0734/comments", "author": null, "committer": null, "parents": [{"sha": "2de12bc4884b12681c91d25385353b23afef6ecf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2de12bc4884b12681c91d25385353b23afef6ecf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2de12bc4884b12681c91d25385353b23afef6ecf"}], "stats": {"total": 134, "additions": 116, "deletions": 18}, "files": [{"sha": "46f1f23145d688778bc00e95254df78c4f5bfafa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4677862a0bfa291cf015559f78ee9cbf7d9f0734", "patch": "@@ -1,3 +1,17 @@\n+2003-03-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR middle-end/9986\n+\t* c-common.c (c_common_nodes_and_builtins): Initialize target builtins\n+\tafter the common builtins.\n+\t* pa-hpux.h (DONT_HAVE_FPUTC_UNLOCKED): Define.\n+\t* pa.c (TARGET_INIT_BUILTINS): Define.\n+\t(pa_init_builtins): New function.\n+\n+\t* pa.md (call, call_value, sibcall, sibcall_value): When sufficient\n+\tspace has been allocated for the outgoing arguments, set the arg\n+\tpointer for a call emitted after virtuals have been instantiated\n+\tusing the stack pointer offset, otherwise abort.\n+\n 2003-03-09  DJ Delorie  <dj@redhat.com>\n \n \t* config/stormy16/stormy16.h (DWARF_LINE_MIN_INSTR_LENGTH): Revert."}, {"sha": "983cd29100ddab49c57b74ccad0145017e5b1c87", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4677862a0bfa291cf015559f78ee9cbf7d9f0734", "patch": "@@ -3428,8 +3428,6 @@ c_common_nodes_and_builtins ()\n     = build_pointer_type (build_qualified_type\n \t\t\t  (char_type_node, TYPE_QUAL_CONST));\n \n-  (*targetm.init_builtins) ();\n-\n   /* This is special for C++ so functions can be overloaded.  */\n   wchar_type_node = get_identifier (MODIFIED_WCHAR_TYPE);\n   wchar_type_node = TREE_TYPE (identifier_global_value (wchar_type_node));\n@@ -3618,6 +3616,8 @@ c_common_nodes_and_builtins ()\n #include \"builtins.def\"\n #undef DEF_BUILTIN\n \n+  (*targetm.init_builtins) ();\n+\n   main_identifier_node = get_identifier (\"main\");\n }\n "}, {"sha": "a4ed77f983efa789fd4c4a1e206678ebc9bf2e45", "filename": "gcc/config/pa/pa-hpux.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux.h?ref=4677862a0bfa291cf015559f78ee9cbf7d9f0734", "patch": "@@ -96,3 +96,7 @@ Boston, MA 02111-1307, USA.  */\n /* hpux8 and later have C++ compatible include files, so do not\n    pretend they are `extern \"C\"'.  */\n #define NO_IMPLICIT_EXTERN_C\n+\n+/* hpux11 and earlier don't have fputc_unlocked, so we must inhibit the\n+   transformation of fputs_unlocked and fprintf_unlocked to fputc_unlocked.  */\n+#define DONT_HAVE_FPUTC_UNLOCKED"}, {"sha": "d087ed8606bc61247ce1c180d3c3e4529c4962e8", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=4677862a0bfa291cf015559f78ee9cbf7d9f0734", "patch": "@@ -130,6 +130,7 @@ static void pa_asm_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n static void pa_asm_out_constructor PARAMS ((rtx, int));\n static void pa_asm_out_destructor PARAMS ((rtx, int));\n #endif\n+static void pa_init_builtins PARAMS ((void));\n static void copy_fp_args PARAMS ((rtx)) ATTRIBUTE_UNUSED;\n static int length_fp_args PARAMS ((rtx)) ATTRIBUTE_UNUSED;\n static struct deferred_plabel *get_plabel PARAMS ((const char *))\n@@ -222,6 +223,9 @@ static size_t n_deferred_plabels = 0;\n #define TARGET_ASM_DESTRUCTOR pa_asm_out_destructor\n #endif\n \n+#undef TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS pa_init_builtins\n+\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS hppa_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -338,6 +342,14 @@ override_options ()\n     }\n }\n \n+void\n+pa_init_builtins ()\n+{\n+#ifdef DONT_HAVE_FPUTC_UNLOCKED\n+  built_in_decls[(int) BUILT_IN_FPUTC_UNLOCKED] = NULL_TREE;\n+#endif\n+}\n+\n /* Return nonzero only if OP is a register of mode MODE,\n    or CONST0_RTX.  */\n int"}, {"sha": "2673739849f2247b7eba6d72d58fc58d84d1f95d", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 84, "deletions": 16, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4677862a0bfa291cf015559f78ee9cbf7d9f0734/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=4677862a0bfa291cf015559f78ee9cbf7d9f0734", "patch": "@@ -5889,9 +5889,26 @@\n     op = XEXP (operands[0], 0);\n \n   if (TARGET_64BIT)\n-    emit_move_insn (arg_pointer_rtx,\n-\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n-\t\t\t\t  GEN_INT (64)));\n+    {\n+      if (!virtuals_instantiated)\n+\temit_move_insn (arg_pointer_rtx,\n+\t\t\tgen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t      GEN_INT (64)));\n+      else\n+\t{\n+\t  /* The loop pass can generate new libcalls after the virtual\n+\t     registers are instantiated when fpregs are disabled because\n+\t     the only method that we have for doing DImode multiplication\n+\t     is with a libcall.  This could be trouble if we haven't\n+\t     allocated enough space for the outgoing arguments.  */\n+\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n+\t    abort ();\n+\n+\t  emit_move_insn (arg_pointer_rtx,\n+\t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (STACK_POINTER_OFFSET + 64)));\n+\t}\n+    }\n \n   /* Use two different patterns for calls to explicitly named functions\n      and calls through function pointers.  This is necessary as these two\n@@ -6372,9 +6389,26 @@\n     op = XEXP (operands[1], 0);\n \n   if (TARGET_64BIT)\n-    emit_move_insn (arg_pointer_rtx,\n-\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n-\t\t\t\t  GEN_INT (64)));\n+    {\n+      if (!virtuals_instantiated)\n+\temit_move_insn (arg_pointer_rtx,\n+\t\t\tgen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t      GEN_INT (64)));\n+      else\n+\t{\n+\t  /* The loop pass can generate new libcalls after the virtual\n+\t     registers are instantiated when fpregs are disabled because\n+\t     the only method that we have for doing DImode multiplication\n+\t     is with a libcall.  This could be trouble if we haven't\n+\t     allocated enough space for the outgoing arguments.  */\n+\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n+\t    abort ();\n+\n+\t  emit_move_insn (arg_pointer_rtx,\n+\t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (STACK_POINTER_OFFSET + 64)));\n+\t}\n+    }\n \n   /* Use two different patterns for calls to explicitly named functions\n      and calls through function pointers.  This is necessary as these two\n@@ -6868,15 +6902,32 @@\n   \"!TARGET_PORTABLE_RUNTIME\"\n   \"\n {\n-  rtx op;\n-  rtx call_insn;\n+  rtx op, call_insn;\n+  rtx nb = operands[1];\n \n   op = XEXP (operands[0], 0);\n \n   if (TARGET_64BIT)\n-    emit_move_insn (arg_pointer_rtx,\n-\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n-\t\t\t\t  GEN_INT (64)));\n+    {\n+      if (!virtuals_instantiated)\n+\temit_move_insn (arg_pointer_rtx,\n+\t\t\tgen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t      GEN_INT (64)));\n+      else\n+\t{\n+\t  /* The loop pass can generate new libcalls after the virtual\n+\t     registers are instantiated when fpregs are disabled because\n+\t     the only method that we have for doing DImode multiplication\n+\t     is with a libcall.  This could be trouble if we haven't\n+\t     allocated enough space for the outgoing arguments.  */\n+\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n+\t    abort ();\n+\n+\t  emit_move_insn (arg_pointer_rtx,\n+\t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (STACK_POINTER_OFFSET + 64)));\n+\t}\n+    }\n \n   /* Indirect sibling calls are not allowed.  */\n   if (TARGET_64BIT)\n@@ -6933,15 +6984,32 @@\n   \"!TARGET_PORTABLE_RUNTIME\"\n   \"\n {\n-  rtx op;\n-  rtx call_insn;\n+  rtx op, call_insn;\n+  rtx nb = operands[1];\n \n   op = XEXP (operands[1], 0);\n \n   if (TARGET_64BIT)\n-    emit_move_insn (arg_pointer_rtx,\n-\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n-\t\t\t\t  GEN_INT (64)));\n+    {\n+      if (!virtuals_instantiated)\n+\temit_move_insn (arg_pointer_rtx,\n+\t\t\tgen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t      GEN_INT (64)));\n+      else\n+\t{\n+\t  /* The loop pass can generate new libcalls after the virtual\n+\t     registers are instantiated when fpregs are disabled because\n+\t     the only method that we have for doing DImode multiplication\n+\t     is with a libcall.  This could be trouble if we haven't\n+\t     allocated enough space for the outgoing arguments.  */\n+\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n+\t    abort ();\n+\n+\t  emit_move_insn (arg_pointer_rtx,\n+\t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n+\t\t\t\t\tGEN_INT (STACK_POINTER_OFFSET + 64)));\n+\t}\n+    }\n \n   /* Indirect sibling calls are not allowed.  */\n   if (TARGET_64BIT)"}]}