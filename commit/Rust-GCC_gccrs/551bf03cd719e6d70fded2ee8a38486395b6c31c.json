{"sha": "551bf03cd719e6d70fded2ee8a38486395b6c31c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUxYmYwM2NkNzE5ZTZkNzBmZGVkMmVlOGEzODQ4NjM5NWI2YzMxYw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2001-03-15T22:06:12Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-03-15T22:06:12Z"}, "message": "mangle.c (mangle_record_type): Rename 'from_pointer' argument to 'for_pointer'.\n\n\t* mangle.c (mangle_record_type): Rename 'from_pointer' argument\n\tto 'for_pointer'. If this type is for a pointer (argument) mangling,\n\tdon't surround the element with 'N..E' if the type name is\n\tunqualified.\n\nFrom-SVN: r40519", "tree": {"sha": "612b5468feadd19261f86bdb81e018ecc6b1dcc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/612b5468feadd19261f86bdb81e018ecc6b1dcc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/551bf03cd719e6d70fded2ee8a38486395b6c31c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551bf03cd719e6d70fded2ee8a38486395b6c31c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/551bf03cd719e6d70fded2ee8a38486395b6c31c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/551bf03cd719e6d70fded2ee8a38486395b6c31c/comments", "author": null, "committer": null, "parents": [{"sha": "6e8afa9980c0a03d40067e2ce5969ee9d96e1ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e8afa9980c0a03d40067e2ce5969ee9d96e1ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e8afa9980c0a03d40067e2ce5969ee9d96e1ee0"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "848e17559d776fd8f54cd78edf1cba06bf070c9e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551bf03cd719e6d70fded2ee8a38486395b6c31c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551bf03cd719e6d70fded2ee8a38486395b6c31c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=551bf03cd719e6d70fded2ee8a38486395b6c31c", "patch": "@@ -1,3 +1,10 @@\n+2001-03-15  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* mangle.c (mangle_record_type): Rename 'from_pointer' argument\n+\tto 'for_pointer'. If this type is for a pointer (argument) mangling,\n+\tdon't surround the element with 'N..E' if the type name is \n+\tunqualified.\n+\n 2001-03-14  Mark Mitchell  <mark@codesourcery.com>\n \n \t* class.c (build_static_field_ref): Use COPY_DECL_RTL,"}, {"sha": "166d96ba3626e82e1d6f548a0a247c65ae64e0d3", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/551bf03cd719e6d70fded2ee8a38486395b6c31c/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/551bf03cd719e6d70fded2ee8a38486395b6c31c/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=551bf03cd719e6d70fded2ee8a38486395b6c31c", "patch": "@@ -93,7 +93,7 @@ java_mangle_class_field (obstack, type)\n      tree type;\n {\n   init_mangling (obstack);\n-  mangle_record_type (type, /* from_pointer = */ 0);\n+  mangle_record_type (type, /* for_pointer = */ 0);\n   MANGLE_RAW_STRING (\"6class$\");\n   obstack_1grow (mangle_obstack, 'E');\n   return finish_mangling ();\n@@ -106,7 +106,7 @@ java_mangle_vtable (obstack, type)\n {\n   init_mangling (obstack);\n   MANGLE_RAW_STRING (\"TV\");\n-  mangle_record_type (type, /* from_pointer = */ 0);\n+  mangle_record_type (type, /* for_pointer = */ 0);\n   obstack_1grow (mangle_obstack, 'E');\n   return finish_mangling ();\n }\n@@ -120,7 +120,7 @@ mangle_field_decl (decl)\n      tree decl;\n {\n   /* Mangle the name of the this the field belongs to */\n-  mangle_record_type (DECL_CONTEXT (decl), /* from_pointer = */ 0);\n+  mangle_record_type (DECL_CONTEXT (decl), /* for_pointer = */ 0);\n   \n   /* Mangle the name of the field */\n   mangle_member_name (DECL_NAME (decl));\n@@ -140,7 +140,7 @@ mangle_method_decl (mdecl)\n   tree arglist;\n \n   /* Mangle the name of the type that contains mdecl */\n-  mangle_record_type (DECL_CONTEXT (mdecl), /* from_pointer = */ 0);\n+  mangle_record_type (DECL_CONTEXT (mdecl), /* for_pointer = */ 0);\n \n   /* Mangle the function name. There three cases\n        - mdecl is java.lang.Object.Object(), use `C2' for its name\n@@ -347,16 +347,21 @@ find_compression_record_match (type, next_current)\n \n /* Mangle a record type. If a non zero value is returned, it means\n    that a 'N' was emitted (so that a matching 'E' can be emitted if\n-   necessary.)  */\n+   necessary.)  FOR_POINTER indicates that this element is for a pointer\n+   symbol, meaning it was preceded by a 'P'. */\n \n static int\n-mangle_record_type (type, from_pointer)\n+mangle_record_type (type, for_pointer)\n      tree type;\n-     int from_pointer;\n+     int for_pointer;\n {\n   tree current;\n   int match;\n   int nadded_p = 0;\n+  int qualified;\n+  \n+  /* Does this name have a package qualifier? */\n+  qualified = QUALIFIED_P (DECL_NAME (TYPE_NAME (type)));\n \n #define ADD_N() \\\n   do { obstack_1grow (mangle_obstack, 'N'); nadded_p = 1; } while (0)\n@@ -371,17 +376,18 @@ mangle_record_type (type, from_pointer)\n   if (match >= 0)\n     {\n       /* If we had a pointer, and there's more, we need to emit\n-\t 'N' after 'P' (from pointer tells us we already emitted it.) */\n-      if (from_pointer && current)\n+\t 'N' after 'P' (for_pointer tells us we already emitted it.) */\n+      if (for_pointer && current)\n \tADD_N();\n       emit_compression_string (match);\n     }\n   while (current)\n     {\n       /* Add the new type to the table */\n       compression_table_add (TREE_PURPOSE (current));\n-      /* Add 'N' if we never got a chance to. */\n-      if (!nadded_p)\n+      /* Add 'N' if we never got a chance to, but only if we have a qualified\n+         name.  For non-pointer elements, the name is always qualified. */\n+      if ((qualified || !for_pointer) && !nadded_p)\n \tADD_N();\n       /* Use the bare type name for the mangle. */\n       append_gpp_mangled_name (IDENTIFIER_POINTER (TREE_VALUE (current)),"}]}