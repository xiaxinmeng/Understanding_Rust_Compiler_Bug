{"sha": "e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMxYzdlZWM3NzY0ZmI4MDM4YTZmZjBkY2IxZDVlMjBhOTMyOWI5MQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-09T23:12:37Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-09T23:12:37Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r4068", "tree": {"sha": "a3265fee1256568bdcc3087f5933a7d8429c8688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3265fee1256568bdcc3087f5933a7d8429c8688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/comments", "author": null, "committer": null, "parents": [{"sha": "8b40563cd804ed4dac2a294cb417621768c66312", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b40563cd804ed4dac2a294cb417621768c66312", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b40563cd804ed4dac2a294cb417621768c66312"}], "stats": {"total": 5900, "additions": 4159, "deletions": 1741}, "files": [{"sha": "594453d8b00e56dde2fa1a3b8a90f76129f6ebda", "filename": "gcc/c-lex.c", "status": "modified", "additions": 208, "deletions": 120, "changes": 328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91", "patch": "@@ -58,7 +58,7 @@ tree lastiddecl;\n \n int doing_objc_thang;\n \n-extern tree lookup_interface ();\n+extern tree is_class_name ();\n \n extern int yydebug;\n \n@@ -93,15 +93,15 @@ int check_newline ();\n static int ignore_escape_flag = 0;\n \f\n /* C code produced by gperf version 2.5 (GNU C++ version) */\n-/* Command-line: gperf -p -j1 -i 1 -g -o -t -N is_reserved_word -k1,3,$ c-parse.gperf  */ \n+/* Command-line: gperf -p -j1 -i 1 -g -o -t -G -N is_reserved_word -k1,3,$ c-parse.gperf  */\n struct resword { char *name; short token; enum rid rid; };\n \n-#define TOTAL_KEYWORDS 61\n+#define TOTAL_KEYWORDS 79\n #define MIN_WORD_LENGTH 2\n-#define MAX_WORD_LENGTH 13\n+#define MAX_WORD_LENGTH 20\n #define MIN_HASH_VALUE 10\n-#define MAX_HASH_VALUE 95\n-/* maximum key range = 86, duplicates = 0 */\n+#define MAX_HASH_VALUE 144\n+/* maximum key range = 135, duplicates = 0 */\n \n #ifdef __GNUC__\n __inline\n@@ -113,19 +113,19 @@ hash (str, len)\n {\n   static unsigned char asso_values[] =\n     {\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-     96, 96, 96, 96, 96,  1, 96, 15, 13, 23,\n-      1,  6, 32, 36,  3,  5, 96,  1, 20, 29,\n-     31, 44, 19, 96, 13,  2,  1, 54, 39, 11,\n-      5, 96,  3, 96, 96, 96, 96, 96,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145,  25, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145, 145, 145, 145, 145, 145,\n+     145, 145, 145, 145, 145,   1, 145,  46,   8,  15,\n+      61,   6,  36,  48,   3,   5, 145,  18,  63,  25,\n+      29,  76,   1, 145,  13,   2,   1,  51,  37,   9,\n+       9,   1,   3, 145, 145, 145, 145, 145,\n     };\n   register int hval = len;\n \n@@ -141,6 +141,119 @@ hash (str, len)\n   return hval + asso_values[str[len - 1]];\n }\n \n+static struct resword wordlist[] =\n+{\n+  {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+  {\"\",}, \n+  {\"int\",  TYPESPEC, RID_INT},\n+  {\"\",}, {\"\",}, \n+  {\"__typeof__\",  TYPEOF, NORID},\n+  {\"__signed__\",  TYPESPEC, RID_SIGNED},\n+  {\"__imag__\",  IMAGPART, NORID},\n+  {\"switch\",  SWITCH, NORID},\n+  {\"__inline__\",  SCSPEC, RID_INLINE},\n+  {\"else\",  ELSE, NORID},\n+  {\"__iterator__\",  SCSPEC, RID_ITERATOR},\n+  {\"__inline\",  SCSPEC, RID_INLINE},\n+  {\"__extension__\",  EXTENSION, NORID},\n+  {\"struct\",  STRUCT, NORID},\n+  {\"__real__\",  REALPART, NORID},\n+  {\"__const\",  TYPE_QUAL, RID_CONST},\n+  {\"while\",  WHILE, NORID},\n+  {\"__const__\",  TYPE_QUAL, RID_CONST},\n+  {\"case\",  CASE, NORID},\n+  {\"__complex__\",  TYPESPEC, RID_COMPLEX},\n+  {\"__iterator\",  SCSPEC, RID_ITERATOR},\n+  {\"bycopy\",  TYPE_QUAL, RID_BYCOPY},\n+  {\"\",}, {\"\",}, {\"\",}, \n+  {\"__complex\",  TYPESPEC, RID_COMPLEX},\n+  {\"\",}, \n+  {\"in\",  TYPE_QUAL, RID_IN},\n+  {\"break\",  BREAK, NORID},\n+  {\"@defs\",  DEFS, NORID},\n+  {\"\",}, {\"\",}, {\"\",}, \n+  {\"extern\",  SCSPEC, RID_EXTERN},\n+  {\"if\",  IF, NORID},\n+  {\"typeof\",  TYPEOF, NORID},\n+  {\"typedef\",  SCSPEC, RID_TYPEDEF},\n+  {\"__typeof\",  TYPEOF, NORID},\n+  {\"sizeof\",  SIZEOF, NORID},\n+  {\"\",}, \n+  {\"return\",  RETURN, NORID},\n+  {\"const\",  TYPE_QUAL, RID_CONST},\n+  {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n+  {\"@private\",  PRIVATE, NORID},\n+  {\"@selector\",  SELECTOR, NORID},\n+  {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n+  {\"__asm__\",  ASM_KEYWORD, NORID},\n+  {\"\",}, {\"\",}, \n+  {\"continue\",  CONTINUE, NORID},\n+  {\"__alignof__\",  ALIGNOF, NORID},\n+  {\"__imag\",  IMAGPART, NORID},\n+  {\"__attribute__\",  ATTRIBUTE, NORID},\n+  {\"\",}, {\"\",}, \n+  {\"__attribute\",  ATTRIBUTE, NORID},\n+  {\"for\",  FOR, NORID},\n+  {\"\",}, \n+  {\"@encode\",  ENCODE, NORID},\n+  {\"id\",  OBJECTNAME, RID_ID},\n+  {\"static\",  SCSPEC, RID_STATIC},\n+  {\"@interface\",  INTERFACE, NORID},\n+  {\"\",}, \n+  {\"__signed\",  TYPESPEC, RID_SIGNED},\n+  {\"\",}, \n+  {\"__label__\",  LABEL, NORID},\n+  {\"\",}, {\"\",}, \n+  {\"__asm\",  ASM_KEYWORD, NORID},\n+  {\"char\",  TYPESPEC, RID_CHAR},\n+  {\"\",}, \n+  {\"inline\",  SCSPEC, RID_INLINE},\n+  {\"out\",  TYPE_QUAL, RID_OUT},\n+  {\"register\",  SCSPEC, RID_REGISTER},\n+  {\"__real\",  REALPART, NORID},\n+  {\"short\",  TYPESPEC, RID_SHORT},\n+  {\"\",}, \n+  {\"enum\",  ENUM, NORID},\n+  {\"inout\",  TYPE_QUAL, RID_INOUT},\n+  {\"\",}, \n+  {\"oneway\",  TYPE_QUAL, RID_ONEWAY},\n+  {\"union\",  UNION, NORID},\n+  {\"\",}, \n+  {\"__alignof\",  ALIGNOF, NORID},\n+  {\"\",}, \n+  {\"@implementation\",  IMPLEMENTATION, NORID},\n+  {\"\",}, \n+  {\"@class\",  CLASS, NORID},\n+  {\"\",}, \n+  {\"@public\",  PUBLIC, NORID},\n+  {\"asm\",  ASM_KEYWORD, NORID},\n+  {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+  {\"default\",  DEFAULT, NORID},\n+  {\"\",}, \n+  {\"void\",  TYPESPEC, RID_VOID},\n+  {\"\",}, \n+  {\"@protected\",  PROTECTED, NORID},\n+  {\"@protocol\",  PROTOCOL, NORID},\n+  {\"\",}, {\"\",}, {\"\",}, \n+  {\"volatile\",  TYPE_QUAL, RID_VOLATILE},\n+  {\"\",}, {\"\",}, \n+  {\"signed\",  TYPESPEC, RID_SIGNED},\n+  {\"float\",  TYPESPEC, RID_FLOAT},\n+  {\"@end\",  END, NORID},\n+  {\"\",}, {\"\",}, \n+  {\"unsigned\",  TYPESPEC, RID_UNSIGNED},\n+  {\"@compatibility_alias\",  ALIAS, NORID},\n+  {\"double\",  TYPESPEC, RID_DOUBLE},\n+  {\"\",}, {\"\",}, \n+  {\"auto\",  SCSPEC, RID_AUTO},\n+  {\"\",}, \n+  {\"goto\",  GOTO, NORID},\n+  {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+  {\"do\",  DO, NORID},\n+  {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n+  {\"long\",  TYPESPEC, RID_LONG},\n+};\n+\n #ifdef __GNUC__\n __inline\n #endif\n@@ -149,86 +262,6 @@ is_reserved_word (str, len)\n      register char *str;\n      register unsigned int len;\n {\n-  static struct resword wordlist[] =\n-    {\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"\",}, \n-      {\"int\",  TYPESPEC, RID_INT},\n-      {\"\",}, \n-      {\"__signed\",  TYPESPEC, RID_SIGNED},\n-      {\"__typeof__\",  TYPEOF, NORID},\n-      {\"__signed__\",  TYPESPEC, RID_SIGNED},\n-      {\"__imag__\",  IMAGPART, NORID},\n-      {\"switch\",  SWITCH, NORID},\n-      {\"__inline__\",  SCSPEC, RID_INLINE},\n-      {\"else\",  ELSE, NORID},\n-      {\"__iterator__\",  SCSPEC, RID_ITERATOR},\n-      {\"__inline\",  SCSPEC, RID_INLINE},\n-      {\"__extension__\",  EXTENSION, NORID},\n-      {\"struct\",  STRUCT, NORID},\n-      {\"__real__\",  REALPART, NORID},\n-      {\"__asm__\",  ASM_KEYWORD, NORID},\n-      {\"break\",  BREAK, NORID},\n-      {\"\",}, \n-      {\"while\",  WHILE, NORID},\n-      {\"__alignof__\",  ALIGNOF, NORID},\n-      {\"__iterator\",  SCSPEC, RID_ITERATOR},\n-      {\"__attribute__\",  ATTRIBUTE, NORID},\n-      {\"__label__\",  LABEL, NORID},\n-      {\"__const\",  TYPE_QUAL, RID_CONST},\n-      {\"__attribute\",  ATTRIBUTE, NORID},\n-      {\"__const__\",  TYPE_QUAL, RID_CONST},\n-      {\"case\",  CASE, NORID},\n-      {\"__complex__\",  TYPESPEC, RID_COMPLEX},\n-      {\"inline\",  SCSPEC, RID_INLINE},\n-      {\"__complex\",  TYPESPEC, RID_COMPLEX},\n-      {\"if\",  IF, NORID},\n-      {\"__real\",  REALPART, NORID},\n-      {\"default\",  DEFAULT, NORID},\n-      {\"__typeof\",  TYPEOF, NORID},\n-      {\"sizeof\",  SIZEOF, NORID},\n-      {\"extern\",  SCSPEC, RID_EXTERN},\n-      {\"signed\",  TYPESPEC, RID_SIGNED},\n-      {\"static\",  SCSPEC, RID_STATIC},\n-      {\"do\",  DO, NORID},\n-      {\"__imag\",  IMAGPART, NORID},\n-      {\"void\",  TYPESPEC, RID_VOID},\n-      {\"__asm\",  ASM_KEYWORD, NORID},\n-      {\"return\",  RETURN, NORID},\n-      {\"short\",  TYPESPEC, RID_SHORT},\n-      {\"__volatile__\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"\",}, \n-      {\"char\",  TYPESPEC, RID_CHAR},\n-      {\"__volatile\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"__alignof\",  ALIGNOF, NORID},\n-      {\"typeof\",  TYPEOF, NORID},\n-      {\"typedef\",  SCSPEC, RID_TYPEDEF},\n-      {\"const\",  TYPE_QUAL, RID_CONST},\n-      {\"for\",  FOR, NORID},\n-      {\"\",}, {\"\",}, \n-      {\"auto\",  SCSPEC, RID_AUTO},\n-      {\"unsigned\",  TYPESPEC, RID_UNSIGNED},\n-      {\"\",}, \n-      {\"double\",  TYPESPEC, RID_DOUBLE},\n-      {\"continue\",  CONTINUE, NORID},\n-      {\"\",}, \n-      {\"register\",  SCSPEC, RID_REGISTER},\n-      {\"\",}, {\"\",}, \n-      {\"volatile\",  TYPE_QUAL, RID_VOLATILE},\n-      {\"\",}, {\"\",}, \n-      {\"asm\",  ASM_KEYWORD, NORID},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"float\",  TYPESPEC, RID_FLOAT},\n-      {\"\",}, {\"\",}, \n-      {\"goto\",  GOTO, NORID},\n-      {\"\",}, {\"\",}, {\"\",}, {\"\",}, {\"\",}, \n-      {\"long\",  TYPESPEC, RID_LONG},\n-      {\"\",}, \n-      {\"enum\",  ENUM, NORID},\n-      {\"\",}, \n-      {\"union\",  UNION, NORID},\n-    };\n-\n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n     {\n       register int key = hash (str, len);\n@@ -260,6 +293,34 @@ make_pointer_declarator (type_quals, target)\n }\n \f\n void\n+forget_protocol_qualifiers ()\n+{\n+  int i, n = sizeof wordlist / sizeof (struct resword);\n+\n+  for (i = 0; i < n; i++)\n+    if (wordlist[i].rid >= RID_IN && wordlist[i].rid <= RID_ONEWAY)\n+      wordlist[i].name = \"\";\n+}\n+\n+void\n+remember_protocol_qualifiers ()\n+{\n+  int i, n = sizeof wordlist / sizeof (struct resword);\n+\n+  for (i = 0; i < n; i++)\n+    if (wordlist[i].rid == RID_IN)\n+      wordlist[i].name = \"in\";\n+    else if (wordlist[i].rid == RID_OUT)\n+      wordlist[i].name = \"out\";\n+    else if (wordlist[i].rid == RID_INOUT)\n+      wordlist[i].name = \"inout\";\n+    else if (wordlist[i].rid == RID_BYCOPY)\n+      wordlist[i].name = \"bycopy\";\n+    else if (wordlist[i].rid == RID_ONEWAY)\n+      wordlist[i].name = \"oneway\";   \n+}\n+\f\n+void\n init_lex ()\n {\n   /* Make identifier nodes long enough for the language-specific slots.  */\n@@ -296,13 +357,23 @@ init_lex ()\n   ridpointers[(int) RID_REGISTER] = get_identifier (\"register\");\n   ridpointers[(int) RID_ITERATOR] = get_identifier (\"iterator\");\n   ridpointers[(int) RID_COMPLEX] = get_identifier (\"complex\");\n+  ridpointers[(int) RID_ID] = get_identifier (\"id\");\n+  ridpointers[(int) RID_IN] = get_identifier (\"in\");\n+  ridpointers[(int) RID_OUT] = get_identifier (\"out\");\n+  ridpointers[(int) RID_INOUT] = get_identifier (\"inout\");\n+  ridpointers[(int) RID_BYCOPY] = get_identifier (\"bycopy\");\n+  ridpointers[(int) RID_ONEWAY] = get_identifier (\"oneway\");\n+  forget_protocol_qualifiers();\n \n   /* Some options inhibit certain reserved words.\n      Clear those words out of the hash table so they won't be recognized.  */\n #define UNSET_RESERVED_WORD(STRING) \\\n   do { struct resword *s = is_reserved_word (STRING, sizeof (STRING) - 1); \\\n        if (s) s->name = \"\"; } while (0)\n \n+  if (! doing_objc_thang)\n+    UNSET_RESERVED_WORD (\"id\");\n+\n   if (flag_traditional)\n     {\n       UNSET_RESERVED_WORD (\"const\");\n@@ -341,6 +412,7 @@ yyprint (file, yychar, yylval)\n     {\n     case IDENTIFIER:\n     case TYPENAME:\n+    case OBJECTNAME:\n       t = yylval.ttype;\n       if (IDENTIFIER_POINTER (t))\n \tfprintf (file, \" `%s'\", IDENTIFIER_POINTER (t));\n@@ -1005,6 +1077,7 @@ yylex ()\n   register char *p;\n   register int value;\n   int wide_flag = 0;\n+  int objc_flag = 0;\n \n   if (nextchar >= 0)\n     c = nextchar, nextchar = -1;\n@@ -1078,28 +1151,19 @@ yylex ()\n \t  value = c;\n \t  break;\n \t}\n-      p = token_buffer;\n-      *p++ = '@';\n-      c = getc (finput);\n-      while (isalnum (c) || c == '_')\n+      else\n \t{\n-\t  if (p >= token_buffer + maxtoken)\n-\t    p = extend_token_buffer (p);\n-\n-\t  *p++ = c;\n-\t  c = getc (finput);\n+\t  /* '@' may start a constant string object.  */\n+\t  register int c = getc(finput);\n+\t  if (c == '\"')\n+\t    {\n+\t      objc_flag = 1;\n+\t      goto string_constant;\n+\t    }\n+\t  ungetc(c, finput);\n+\t  /* Fall through to treat '@' as the start of an indentifier.  */\n \t}\n \n-      *p = 0;\n-      nextchar = c;\n-      value = recognize_objc_keyword (token_buffer + 1);\n-      if (value != 0)\n-\tbreak;\n-      error (\"invalid Objective C keyword `%s'\", token_buffer);\n-      /* Cause a syntax error--1 is not a valid token type.  */\n-      value = 1;\n-      break;\n-\n     case 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n     case 'F':  case 'G':  case 'H':  case 'I':  case 'J':\n     case 'K':\t\t  case 'M':  case 'N':  case 'O':\n@@ -1147,6 +1211,16 @@ yylex ()\n \t      yylval.ttype = ridpointers[(int) ptr->rid];\n \t    value = (int) ptr->token;\n \n+\t    /* Only return OBJECTNAME if it is a typedef.  */\n+\t    if (doing_objc_thang && value == OBJECTNAME)\n+\t      {\n+\t\tlastiddecl = lookup_name(yylval.ttype);\n+\n+\t\tif (lastiddecl == NULL_TREE\n+\t\t    || TREE_CODE (lastiddecl) != TYPE_DECL)\n+\t\t  value = IDENTIFIER;\n+\t      }\n+\n \t    /* Even if we decided to recognize asm, still perhaps warn.  */\n \t    if (pedantic\n \t\t&& (value == ASM_KEYWORD || value == TYPEOF\n@@ -1162,6 +1236,9 @@ yylex ()\n \n       if (value == IDENTIFIER)\n \t{\n+ \t  if (token_buffer[0] == '@')\n+\t    error(\"invalid identifier `%s'\", token_buffer);\n+\n           yylval.ttype = get_identifier (token_buffer);\n \t  lastiddecl = lookup_name (yylval.ttype);\n \n@@ -1186,7 +1263,7 @@ yylex ()\n \t    }\n           else if (doing_objc_thang)\n             {\n-\t      tree objc_interface_decl = lookup_interface (yylval.ttype);\n+\t      tree objc_interface_decl = is_class_name (yylval.ttype);\n \n \t      if (objc_interface_decl)\n \t\t{\n@@ -1877,17 +1954,28 @@ yylex ()\n #endif\n \t    yylval.ttype = build_string ((len + 1) * WCHAR_BYTES, widep);\n \t    TREE_TYPE (yylval.ttype) = wchar_array_type_node;\n+\t    value = STRING;\n+\t  }\n+\telse if (objc_flag)\n+\t  {\n+\t    extern tree build_objc_string();\n+\t    /* Return an Objective-C @\"...\" constant string object.  */\n+\t    yylval.ttype = build_objc_string (p - token_buffer,\n+\t\t\t\t\t      token_buffer + 1);\n+\t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n+\t    value = OBJC_STRING;\n \t  }\n \telse\n \t  {\n \t    yylval.ttype = build_string (p - token_buffer, token_buffer + 1);\n \t    TREE_TYPE (yylval.ttype) = char_array_type_node;\n+\t    value = STRING;\n \t  }\n \n \t*p++ = '\"';\n \t*p = 0;\n \n-\tvalue = STRING; break;\n+\tbreak;\n       }\n \n     case '+':"}, {"sha": "6b3374a7bb455e5cf96791c7781d0e2e4dc28cc1", "filename": "gcc/c-parse.in", "status": "modified", "additions": 159, "deletions": 70, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91", "patch": "@@ -160,7 +160,11 @@ void yyerror ();\n /* The Objective-C keywords.  These are included in C and in\n    Objective C, so that the token codes are the same in both.  */\n %token INTERFACE IMPLEMENTATION END SELECTOR DEFS ENCODE\n-%token CLASSNAME PUBLIC\n+%token CLASSNAME PUBLIC PRIVATE PROTECTED PROTOCOL OBJECTNAME CLASS ALIAS\n+\n+/* Objective-C string constants in raw form.\n+   yylval is an OBJC_STRING_CST node.  */\n+%token OBJC_STRING\n \n \n %type <code> unop\n@@ -206,7 +210,8 @@ ifobjc\n %type <ttype> keywordexpr keywordarglist keywordarg\n %type <ttype> myparms myparm optparmlist reservedwords objcselectorexpr\n %type <ttype> selectorarg keywordnamelist keywordname objcencodeexpr\n-%type <ttype> CLASSNAME\n+%type <ttype> objc_string protocolrefs identifier_list objcprotocolexpr\n+%type <ttype> CLASSNAME OBJC_STRING OBJECTNAME\n end ifobjc\n \f\n %{\n@@ -350,8 +355,8 @@ identifier:\n \tIDENTIFIER\n \t| TYPENAME\n ifobjc\n+\t| OBJECTNAME\n         | CLASSNAME\n-\t\t{ $$ = CLASS_NAME ($1); }\n end ifobjc\n \t;\n \n@@ -534,14 +539,21 @@ primary:\n \t\t      if (yychar == '(')\n \t\t\t{\n ifobjc\n+\t\t\t  tree decl;\n+\n \t\t\t  if (objc_receiver_context\n \t\t\t      && ! (objc_receiver_context\n \t\t\t\t    && strcmp (IDENTIFIER_POINTER ($1), \"super\")))\n \t\t\t    /* we have a message to super */\n \t\t\t    $$ = get_super_receiver ();\n \t\t\t  else if (objc_method_context\n-\t\t\t\t   && is_ivar (objc_ivar_chain, $1))\n-\t\t\t    $$ = build_ivar_reference ($1);\n+\t\t\t\t   && (decl = is_ivar (objc_ivar_chain, $1)))\n+\t\t\t    {\n+\t\t\t      if (is_private (decl))\n+\t\t\t\t$$ = error_mark_node;\n+\t\t\t      else\n+\t\t\t\t$$ = build_ivar_reference ($1);\n+\t\t\t    }\n \t\t\t  else\n end ifobjc\n \t\t\t    {\n@@ -560,13 +572,20 @@ end ifobjc\n \t\t      else\n \t\t\t{\n ifobjc\n+\t\t\t  tree decl;\n+\n \t\t          if (objc_receiver_context\n \t\t\t      && ! strcmp (IDENTIFIER_POINTER ($1), \"super\"))\n \t\t\t    /* we have a message to super */\n \t\t\t    $$ = get_super_receiver ();\n \t\t\t  else if (objc_method_context\n-\t\t\t\t   && is_ivar (objc_ivar_chain, $1))\n-\t\t\t    $$ = build_ivar_reference ($1);\n+\t\t\t\t   && (decl = is_ivar (objc_ivar_chain, $1)))\n+\t\t\t    {\n+\t\t\t      if (is_private (decl))\n+\t\t\t\t$$ = error_mark_node;\n+\t\t\t      else\n+\t\t\t\t$$ = build_ivar_reference ($1);\n+\t\t\t    }\n \t\t\t  else\n end ifobjc\n \t\t\t    {\n@@ -646,14 +665,21 @@ ifobjc\n \t\t\t  || (objc_receiver_context\n \t\t\t      && strcmp (IDENTIFIER_POINTER ($1), \"super\")))\n                         {\n+\t\t\t  tree decl;\n+\n \t\t\t  if (objc_method_context\n-\t\t\t      && is_ivar (objc_ivar_chain, $1))\n+\t\t\t      && (decl = is_ivar (objc_ivar_chain, $1)))\n                             {\n                               if (IDENTIFIER_LOCAL_VALUE ($1))\n                                 warning (\"local declaration of `%s' hides instance variable\",\n \t                                 IDENTIFIER_POINTER ($1));\n                               else\n-                                $$ = build_ivar_reference ($1);\n+ \t\t\t\t{\n+ \t\t\t\t  if (is_private (decl))\n+ \t\t\t\t    $$ = error_mark_node;\n+ \t\t\t\t  else\n+ \t\t\t\t    $$ = build_ivar_reference ($1);\n+ \t\t\t\t}\n                             }\n \t\t\t}\n                       else /* we have a message to super */\n@@ -756,8 +782,12 @@ ifobjc\n \t\t{ $$ = build_message_expr ($1); }\n \t| objcselectorexpr\n \t\t{ $$ = build_selector_expr ($1); }\n+\t| objcprotocolexpr\n+\t\t{ $$ = build_protocol_expr ($1); }\n \t| objcencodeexpr\n \t\t{ $$ = build_encode_expr ($1); }\n+\t| objc_string\n+\t\t{ $$ = build_objc_string_object ($1); }\n end ifobjc\n \t;\n \n@@ -768,6 +798,16 @@ string:\n \t\t{ $$ = chainon ($1, $2); }\n \t;\n \n+ifobjc\n+/* Produces an OBJC_STRING_CST with prehaps more OBJC_STRING_CSTs chained\n+   onto it.  */\n+objc_string:\n+\t  OBJC_STRING\n+\t| objc_string OBJC_STRING\n+\t\t{ $$ = chainon ($1, $2); }\n+\t;\n+end ifobjc\n+\n xdecls:\n \t/* empty */\n \t| datadecls\n@@ -932,8 +972,10 @@ typespec: TYPESPEC\n \t\t     In case of `foo foo, bar;'.  */\n \t\t  $$ = lookup_name ($1); }\n ifobjc\n-        | CLASSNAME\n-\t\t{ $$ = get_static_reference ($1); }\n+\t| CLASSNAME protocolrefs\n+\t\t{ $$ = get_static_reference ($1, $2); }\n+\t| OBJECTNAME protocolrefs\n+\t\t{ $$ = get_object_reference ($2); }\n end ifobjc\n \t| TYPEOF '(' expr ')'\n \t\t{ $$ = TREE_TYPE ($3); }\n@@ -1074,7 +1116,10 @@ initlist:\n \t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n \t| initlist ',' init\n \t\t{ $$ = tree_cons (NULL_TREE, $3, $1); }\n-\t/* These are for labeled elements.  */\n+\t/* These are for labeled elements.  The syntax for an array element\n+\t   initializer conflicts with the syntax for an Objective-C message,\n+\t   so don't include these productions in the Objective-C grammer.  */\n+ifc\n \t| '[' expr_no_commas ELLIPSIS expr_no_commas ']' init\n \t\t{ $$ = build_tree_list (tree_cons ($2, NULL_TREE,\n \t\t\t\t\t\t   build_tree_list ($4, NULL_TREE)),\n@@ -1088,6 +1133,7 @@ initlist:\n \t\t{ $$ = build_tree_list ($2, $4); }\n \t| initlist ',' '[' expr_no_commas ']' init\n \t\t{ $$ = tree_cons ($4, $6, $1); }\n+end ifc\n \t| identifier ':' init\n \t\t{ $$ = build_tree_list ($1, $3); }\n \t| initlist ',' identifier ':' init\n@@ -1161,6 +1207,9 @@ after_type_declarator:\n \t| '*' type_quals after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| TYPENAME\n+ifobjc\n+\t| OBJECTNAME\n+end ifobjc\n \t;\n \n /* Kinds of declarator that can appear in a parameter list\n@@ -1271,7 +1320,18 @@ component_decl_list2:\t/* empty */\n ifobjc\n \t/* foo(sizeof(struct{ @defs(ClassName)})); */\n \t| DEFS '(' CLASSNAME ')'\n-\t\t{ $$ = get_class_ivars ($3); }\n+\t\t{\n+\t\t  tree interface = lookup_interface ($3);\n+\n+\t\t  if (interface)\n+\t\t    $$ = get_class_ivars (interface);\n+\t\t  else\n+\t\t    {\n+\t\t      error (\"Cannot find interface declaration for `%s'\",\n+\t\t\t     IDENTIFIER_POINTER ($3));\n+\t\t      $$ = NULL_TREE;\n+\t\t    }\n+\t\t}\n end ifobjc\n \t;\n \n@@ -2012,6 +2072,9 @@ ifobjc\n \n objcdef:\n \t  classdef\n+\t| classdecl\n+\t| aliasdecl\n+\t| protocoldef\n \t| methoddef\n \t| END\n \t\t{\n@@ -2026,11 +2089,31 @@ objcdef:\n \t\t}\n \t;\n \n+/* A nonempty list of identifiers.  */\n+identifier_list:\n+\tidentifier\n+\t\t{ $$ = build_tree_list (NULL_TREE, $1); }\n+\t| identifier_list ',' identifier\n+\t\t{ $$ = chainon ($1, build_tree_list (NULL_TREE, $3)); }\n+\t;\n+\n+classdecl:\n+\t  CLASS identifier_list ';'\n+\t\t{\n+\t\t  objc_declare_class ($2);\n+\t\t}\n+\n+aliasdecl:\n+\t  ALIAS identifier identifier ';'\n+\t\t{\n+\t\t  objc_declare_alias ($2, $3);\n+\t\t}\n+\n classdef:\n-\t  INTERFACE identifier '{'\n+\t  INTERFACE identifier protocolrefs '{'\n \t\t{\n \t\t  objc_interface_context = objc_ivar_context\n-\t\t    = start_class (INTERFACE_TYPE, $2, NULL_TREE);\n+\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, NULL_TREE, $3);\n                   objc_public_flag = 0;\n \t\t}\n \t  ivar_decl_list '}'\n@@ -2044,10 +2127,10 @@ classdef:\n \t\t  objc_interface_context = NULL_TREE;\n \t\t}\n \n-\t| INTERFACE identifier\n+\t| INTERFACE identifier protocolrefs\n \t\t{\n \t\t  objc_interface_context\n-\t\t    = start_class (INTERFACE_TYPE, $2, NULL_TREE);\n+\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, NULL_TREE, $3);\n                   continue_class (objc_interface_context);\n \t\t}\n \t  methodprotolist\n@@ -2057,10 +2140,10 @@ classdef:\n \t\t  objc_interface_context = NULL_TREE;\n \t\t}\n \n-\t| INTERFACE identifier ':' identifier '{'\n+\t| INTERFACE identifier ':' identifier protocolrefs '{'\n \t\t{\n \t\t  objc_interface_context = objc_ivar_context\n-\t\t    = start_class (INTERFACE_TYPE, $2, $4);\n+\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, $4, $5);\n                   objc_public_flag = 0;\n \t\t}\n \t  ivar_decl_list '}'\n@@ -2074,10 +2157,10 @@ classdef:\n \t\t  objc_interface_context = NULL_TREE;\n \t\t}\n \n-\t| INTERFACE identifier ':' identifier\n+\t| INTERFACE identifier ':' identifier protocolrefs\n \t\t{\n \t\t  objc_interface_context\n-\t\t    = start_class (INTERFACE_TYPE, $2, $4);\n+\t\t    = start_class (CLASS_INTERFACE_TYPE, $2, $4, $5);\n                   continue_class (objc_interface_context);\n \t\t}\n \t  methodprotolist\n@@ -2090,7 +2173,7 @@ classdef:\n \t| IMPLEMENTATION identifier '{'\n \t\t{\n \t\t  objc_implementation_context = objc_ivar_context\n-\t\t    = start_class (IMPLEMENTATION_TYPE, $2, NULL_TREE);\n+\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, NULL_TREE, NULL_TREE);\n                   objc_public_flag = 0;\n \t\t}\n \t  ivar_decl_list '}'\n@@ -2102,15 +2185,15 @@ classdef:\n \t| IMPLEMENTATION identifier\n \t\t{\n \t\t  objc_implementation_context\n-\t\t    = start_class (IMPLEMENTATION_TYPE, $2, NULL_TREE);\n+\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, NULL_TREE, NULL_TREE);\n                   objc_ivar_chain\n \t\t    = continue_class (objc_implementation_context);\n \t\t}\n \n \t| IMPLEMENTATION identifier ':' identifier '{'\n \t\t{\n \t\t  objc_implementation_context = objc_ivar_context\n-\t\t    = start_class (IMPLEMENTATION_TYPE, $2, $4);\n+\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n                   objc_public_flag = 0;\n \t\t}\n \t  ivar_decl_list '}'\n@@ -2122,15 +2205,15 @@ classdef:\n \t| IMPLEMENTATION identifier ':' identifier\n \t\t{\n \t\t  objc_implementation_context\n-\t\t    = start_class (IMPLEMENTATION_TYPE, $2, $4);\n+\t\t    = start_class (CLASS_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n                   objc_ivar_chain\n \t\t    = continue_class (objc_implementation_context);\n \t\t}\n \n-\t| INTERFACE identifier '(' identifier ')'\n+\t| INTERFACE identifier '(' identifier ')' protocolrefs\n \t\t{\n \t\t  objc_interface_context\n-\t\t    = start_class (PROTOCOL_TYPE, $2, $4);\n+\t\t    = start_class (CATEGORY_INTERFACE_TYPE, $2, $4, $6);\n                   continue_class (objc_interface_context);\n \t\t}\n \t  methodprotolist\n@@ -2143,17 +2226,52 @@ classdef:\n \t| IMPLEMENTATION identifier '(' identifier ')'\n \t\t{\n \t\t  objc_implementation_context\n-\t\t    = start_class (CATEGORY_TYPE, $2, $4);\n+\t\t    = start_class (CATEGORY_IMPLEMENTATION_TYPE, $2, $4, NULL_TREE);\n                   objc_ivar_chain\n \t\t    = continue_class (objc_implementation_context);\n \t\t}\n \t;\n \n+protocoldef:\n+\t  PROTOCOL identifier protocolrefs\n+\t\t{\n+\t\t  remember_protocol_qualifiers ();\n+\t\t  objc_interface_context\n+\t\t    = start_protocol(PROTOCOL_INTERFACE_TYPE, $2, $3);\n+\t\t}\n+\t  methodprotolist END\n+\t\t{\n+\t\t  forget_protocol_qualifiers();\n+\t\t  finish_protocol(objc_interface_context);\n+\t\t  objc_interface_context = NULL_TREE;\n+\t\t}\n+\t;\n+\n+protocolrefs:\n+\t  /* empty */\n+\t\t{\n+\t\t  $$ = NULL_TREE;\n+\t\t}\n+\t| ARITHCOMPARE identifier_list ARITHCOMPARE\n+\t\t{\n+\t\t  if ($1 == LT_EXPR && $3 == GT_EXPR)\n+\t\t    $$ = $2;\n+\t\t  else\n+\t\t    YYERROR1;\n+\t\t}\n+\t;\n+\n ivar_decl_list:\n-          ivar_decls PUBLIC { objc_public_flag = 1; } ivar_decls\n+          ivar_decl_list visibility_spec ivar_decls\n         | ivar_decls\n         ;\n \n+visibility_spec:\n+\t  PRIVATE { objc_public_flag = 2; }\n+\t| PROTECTED { objc_public_flag = 0; }\n+\t| PUBLIC { objc_public_flag = 1; }\n+\t;\n+\n ivar_decls:\n           /* empty */\n \t\t{\n@@ -2225,13 +2343,15 @@ ivar_declarator:\n methoddef:\n \t  '+'\n \t\t{\n+\t\t  remember_protocol_qualifiers ();\n \t\t  if (objc_implementation_context)\n \t\t    objc_inherit_code = CLASS_METHOD_DECL;\n                   else\n \t\t    fatal (\"method definition not in class context\");\n \t\t}\n \t  methoddecl\n \t\t{\n+\t\t  forget_protocol_qualifiers ();\n \t\t  add_class_method (objc_implementation_context, $3);\n \t\t  start_method_def ($3);\n \t\t  objc_method_context = $3;\n@@ -2248,13 +2368,15 @@ methoddef:\n \n \t| '-'\n \t\t{\n+\t\t  remember_protocol_qualifiers ();\n \t\t  if (objc_implementation_context)\n \t\t    objc_inherit_code = INSTANCE_METHOD_DECL;\n                   else\n \t\t    fatal (\"method definition not in class context\");\n \t\t}\n \t  methoddecl\n \t\t{\n+\t\t  forget_protocol_qualifiers ();\n \t\t  add_instance_method (objc_implementation_context, $3);\n \t\t  start_method_def ($3);\n \t\t  objc_method_context = $3;\n@@ -2424,6 +2546,7 @@ keywordselector:\n selector:\n \t  IDENTIFIER\n         | TYPENAME\n+  \t| OBJECTNAME\n \t| reservedwords\n \t;\n \n@@ -2559,6 +2682,13 @@ objcselectorexpr:\n \t\t}\n \t;\n \n+objcprotocolexpr:\n+\t  PROTOCOL '(' identifier ')'\n+\t\t{\n+\t\t  $$ = $3;\n+\t\t}\n+\t;\n+\n /* extension to support C-structures in the archiver */\n \n objcencodeexpr:\n@@ -2570,44 +2700,3 @@ objcencodeexpr:\n \n end ifobjc\n %%\n-ifobjc\n-\n-/* If STRING is the name of an Objective C @-keyword\n-   (not including the @), return the token type for that keyword.\n-   Otherwise return 0.  */\n-\n-int\n-recognize_objc_keyword (string)\n-     char *string;\n-{\n-  switch (string[0])\n-    {\n-    case 'd':\n-      if (!strcmp (string, \"defs\"))\n-\treturn DEFS;\n-      break;\n-    case 'e':\n-      if (!strcmp (string, \"end\"))\n-\treturn END;\n-      if (!strcmp (string, \"encode\"))\n-\treturn ENCODE;\n-      break;\n-    case 'i':\n-      if (!strcmp (string, \"interface\"))\n-\treturn INTERFACE;\n-      if (!strcmp (string, \"implementation\"))\n-\treturn IMPLEMENTATION;\n-      break;\n-    case 'p':\n-      if (!strcmp (string, \"public\"))\n-\treturn PUBLIC;\n-      break;\n-    case 's':\n-      if (!strcmp (string, \"selector\"))\n-\treturn SELECTOR;\n-      break;\n-    }\n-  return 0;\n-}\n-\n-end ifobjc"}, {"sha": "1e5df400982a13f69effe90657e4a37b33727e7f", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 3792, "deletions": 1551, "changes": 5343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=e31c7eec7764fb8038a6ff0dcb1d5e20a9329b91"}]}