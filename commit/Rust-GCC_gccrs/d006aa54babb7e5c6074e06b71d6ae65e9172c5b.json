{"sha": "d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDAwNmFhNTRiYWJiN2U1YzYwNzRlMDZiNzFkNmFlNjVlOTE3MmM1Yg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-10-09T15:50:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-10-09T15:50:25Z"}, "message": "expmed.c (store_bit_field): Pun non-integral str_rtx modes.\n\n        * expmed.c (store_bit_field): Pun non-integral str_rtx modes.\n        Take extra care for op0 now possibly being a subreg.\n        (extract_bit_field): Likewise.\n        * function.c (purge_addressof_1): Revert Oct 4 change.  Drop\n        the reg to memory if there is no equal sized integral mode.\n        * stor-layout.c (int_mode_for_mode): New function.\n        * machmode.h: Prototype it.\n\nFrom-SVN: r22962", "tree": {"sha": "dcc7d4ffbedc5308ac113fce833c31a0318fd188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dcc7d4ffbedc5308ac113fce833c31a0318fd188"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/comments", "author": null, "committer": null, "parents": [{"sha": "3663a3047f7ec94514d5c76483f1b7e8457934cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3663a3047f7ec94514d5c76483f1b7e8457934cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3663a3047f7ec94514d5c76483f1b7e8457934cf"}], "stats": {"total": 122, "additions": 106, "deletions": 16}, "files": [{"sha": "2a0bd6636410ce13084fcc536b5401cf7b75b508", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "patch": "@@ -1,3 +1,13 @@\n+Fri Oct  9 15:49:29 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* expmed.c (store_bit_field): Pun non-integral str_rtx modes.\n+\tTake extra care for op0 now possibly being a subreg.\n+\t(extract_bit_field): Likewise.\n+\t* function.c (purge_addressof_1): Revert Oct 4 change.  Drop\n+\tthe reg to memory if there is no equal sized integral mode.\n+\t* stor-layout.c (int_mode_for_mode): New function.\n+\t* machmode.h: Prototype it.\n+\n Fri Oct  9 14:26:44 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* global.c (build_insn_chain): Verify no real insns exist past the"}, {"sha": "9b285d0e23f680a045c773459756d69ea40ae245", "filename": "gcc/expmed.c", "status": "modified", "additions": 58, "deletions": 4, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "patch": "@@ -261,6 +261,21 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       op0 = SUBREG_REG (op0);\n     }\n \n+  /* Make sure we are playing with integral modes.  Pun with subregs\n+     if we aren't.  */\n+  {\n+    enum machine_mode imode = int_mode_for_mode (GET_MODE (op0));\n+    if (imode != GET_MODE (op0))\n+      {\n+\tif (GET_CODE (op0) == MEM)\n+\t  op0 = change_address (op0, imode, NULL_RTX);\n+\telse if (imode != BLKmode)\n+\t  op0 = gen_lowpart (imode, op0);\n+\telse\n+\t  abort ();\n+      }\n+  }\n+\n   /* If OP0 is a register, BITPOS must count within a word.\n      But as we have it, it counts within whatever size OP0 now has.\n      On a bigendian machine, these are not the same, so convert.  */\n@@ -287,6 +302,18 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t can be done with just SUBREG.  */\n       if (GET_MODE (op0) != fieldmode)\n \t{\n+\t  if (GET_CODE (op0) == SUBREG)\n+\t    {\n+\t      if (GET_MODE (SUBREG_REG (op0)) == fieldmode\n+\t\t  || GET_MODE_CLASS (fieldmode) == MODE_INT\n+\t\t  || GET_MODE_CLASS (fieldmode) == MODE_PARTIAL_INT)\n+\t\top0 = SUBREG_REG (op0);\n+\t      else\n+\t\t/* Else we've got some float mode source being extracted into\n+\t\t   a different float mode destination -- this combination of\n+\t\t   subregs results in Severe Tire Damage.  */\n+\t\tabort ();\n+\t    }\n \t  if (GET_CODE (op0) == REG)\n \t    op0 = gen_rtx_SUBREG (fieldmode, op0, offset);\n \t  else\n@@ -955,6 +982,21 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       op0 = SUBREG_REG (op0);\n     }\n \n+  /* Make sure we are playing with integral modes.  Pun with subregs\n+     if we aren't.  */\n+  {\n+    enum machine_mode imode = int_mode_for_mode (GET_MODE (op0));\n+    if (imode != GET_MODE (op0))\n+      {\n+\tif (GET_CODE (op0) == MEM)\n+\t  op0 = change_address (op0, imode, NULL_RTX);\n+\telse if (imode != BLKmode)\n+\t  op0 = gen_lowpart (imode, op0);\n+\telse\n+\t  abort ();\n+      }\n+  }\n+\n   /* ??? We currently assume TARGET is at least as big as BITSIZE.\n      If that's wrong, the solution is to test for it and set TARGET to 0\n      if needed.  */\n@@ -973,7 +1015,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n      So too extracting a subword value in\n      the least significant part of the register.  */\n \n-  if (((GET_CODE (op0) == REG\n+  if (((GET_CODE (op0) != MEM\n \t&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n \t\t\t\t  GET_MODE_BITSIZE (GET_MODE (op0))))\n        || (GET_CODE (op0) == MEM\n@@ -996,6 +1038,18 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \n       if (mode1 != GET_MODE (op0))\n \t{\n+\t  if (GET_CODE (op0) == SUBREG)\n+\t    {\n+\t      if (GET_MODE (SUBREG_REG (op0)) == mode1\n+\t\t  || GET_MODE_CLASS (mode1) == MODE_INT\n+\t\t  || GET_MODE_CLASS (mode1) == MODE_PARTIAL_INT)\n+\t\top0 = SUBREG_REG (op0);\n+\t      else\n+\t\t/* Else we've got some float mode source being extracted into\n+\t\t   a different float mode destination -- this combination of\n+\t\t   subregs results in Severe Tire Damage.  */\n+\t\tabort ();\n+\t    }\n \t  if (GET_CODE (op0) == REG)\n \t    op0 = gen_rtx_SUBREG (mode1, op0, offset);\n \t  else\n@@ -1088,12 +1142,12 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   /* OFFSET is the number of words or bytes (UNIT says which)\n      from STR_RTX to the first word or byte containing part of the field.  */\n \n-  if (GET_CODE (op0) == REG)\n+  if (GET_CODE (op0) != MEM)\n     {\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n-\top0 = gen_rtx_SUBREG (TYPE_MODE (type_for_size (BITS_PER_WORD, 0)),\n-\t\t       op0, offset);\n+\top0 = gen_rtx_SUBREG (mode_for_size (BITS_PER_WORD, MODE_INT, 0),\n+\t\t              op0, offset);\n       offset = 0;\n     }\n   else"}, {"sha": "5ad113cfc9372cf28961bce14e30cb0fd77a5d8b", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "patch": "@@ -2874,24 +2874,14 @@ purge_addressof_1 (loc, insn, force, store)\n \n \t  /* Don't even consider working with paradoxical subregs,\n \t     or the moral equivalent seen here.  */\n-\t  if (size_x < size_sub)\n+\t  if (size_x < size_sub\n+\t      && int_mode_for_mode (GET_MODE (sub)) != BLKmode)\n \t    {\n \t      /* Do a bitfield insertion to mirror what would happen\n \t\t in memory.  */\n \n \t      rtx val, seq;\n \n-\t      /* We cannot do this if we are trying to pick out\n-\t\t an integral piece, smaller than a word, of a\n-\t\t floating point value.  */\n-\t      if (INTEGRAL_MODE_P (GET_MODE (x))\n-\t\t  && GET_MODE_SIZE (GET_MODE (x)) < UNITS_PER_WORD\n-\t\t  && FLOAT_MODE_P (GET_MODE (sub)))\n-\t\t{\n-\t\t  put_addressof_into_stack (XEXP (x, 0));\n-\t\t  return;\n-\t\t}\n-\n \t      if (store)\n \t\t{\n \t\t  /* If we can't replace with a register, be afraid.  */"}, {"sha": "e8c17e01642e34099d58a5f2f309122599abf6cc", "filename": "gcc/machmode.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "patch": "@@ -211,6 +211,11 @@ extern unsigned char mode_wider_mode[];\n \n extern enum machine_mode mode_for_size PROTO((unsigned int, enum mode_class, int));\n \n+/* Return an integer mode of the exact same size as the input mode,\n+   or BLKmode on failure.  */\n+\n+extern enum machine_mode int_mode_for_mode PROTO((enum machine_mode));\n+\n /* Find the best mode to use to access a bit field.  */\n \n extern enum machine_mode get_best_mode PROTO((int, int, int, enum machine_mode, int));"}, {"sha": "a6bf053ba76d7cd579616fffae784c7e21559dc2", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d006aa54babb7e5c6074e06b71d6ae65e9172c5b/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d006aa54babb7e5c6074e06b71d6ae65e9172c5b", "patch": "@@ -176,6 +176,37 @@ smallest_mode_for_size (size, class)\n   abort ();\n }\n \n+/* Find an integer mode of the exact same size, or BLKmode on failure.  */\n+\n+enum machine_mode\n+int_mode_for_mode (mode)\n+     enum machine_mode mode;\n+{\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_INT:\n+    case MODE_PARTIAL_INT:\n+      break;\n+\n+    case MODE_COMPLEX_INT:\n+    case MODE_COMPLEX_FLOAT:\n+    case MODE_FLOAT:\n+      mode = mode_for_size (GET_MODE_BITSIZE (mode), MODE_INT, 0);\n+      break;\n+\n+    case MODE_RANDOM:\n+      if (mode == BLKmode)\n+        break;\n+      /* FALLTHRU */\n+\n+    case MODE_CC:\n+    default:\n+      abort();\n+    }\n+\n+  return mode;\n+}\n+\n /* Return the value of VALUE, rounded up to a multiple of DIVISOR.  */\n \n tree"}]}