{"sha": "d75691877c4a7521a995d2601021fcaf30f65d94", "node_id": "C_kwDOANBUbNoAKGQ3NTY5MTg3N2M0YTc1MjFhOTk1ZDI2MDEwMjFmY2FmMzBmNjVkOTQ", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-02-13T19:17:53Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-02-16T10:15:02Z"}, "message": "d: Merge upstream dmd 52844d4b1, druntime dbd0c874, phobos 896b1d0e1.\n\nD front-end changes:\n\n    - Parsing and compiling C code is now possible using `import'.\n    - `throw' statements can now be used as an expression.\n    - Improvements to the D template emission strategy when compiling\n      with `-funittest'.\n\nD Runtime changes:\n\n    - New core.int128 module for implementing intrinsics to support\n      128-bit integer types.\n    - C bindings for the kernel and C runtime have been better separated\n      to allow compiling for hybrid targets, such as kFreeBSD.\n\nPhobos changes:\n\n    - The std.experimental.checkedint module has been renamed to\n      std.checkedint.\n\ngcc/d/ChangeLog:\n\n\t* d-builtins.cc (d_build_builtins_module): Set purity of DECL_PURE_P\n\tfunctions to PURE::const_.\n\t* d-gimplify.cc (bit_field_ref): New function.\n\t(d_gimplify_modify_expr): Handle implicit casting for assignments to\n\tbit-fields.\n\t(d_gimplify_unary_expr): New function.\n\t(d_gimplify_binary_expr): New function.\n\t(d_gimplify_expr): Handle UNARY_CLASS_P and BINARY_CLASS_P.\n\t* d-target.cc (Target::_init): Initialize bitFieldStyle.\n\t(TargetCPP::parameterType): Update signature.\n\t(Target::supportsLinkerDirective): New function.\n\t* dmd/MERGE: Merge upstream dmd 52844d4b1.\n\t* expr.cc (ExprVisitor::visit (ThrowExp *)): New function.\n\t* types.cc (d_build_bitfield_integer_type): New function.\n\t(insert_aggregate_bitfield): New function.\n\t(layout_aggregate_members): Handle inserting bit-fields into an\n\taggregate type.\n\nlibphobos/ChangeLog:\n\n\t* Makefile.in: Regenerate.\n\t* libdruntime/MERGE: Merge upstream druntime dbd0c874.\n\t* libdruntime/Makefile.am (DRUNTIME_CSOURCES): Add core/int128.d.\n\t(DRUNTIME_DISOURCES): Add __builtins.di.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 896b1d0e1.\n\t* src/Makefile.am (PHOBOS_DSOURCES): Add std/checkedint.d.\n\t* src/Makefile.in: Regenerate.\n\t* testsuite/testsuite_flags.in: Add -fall-instantiations to\n\t--gdcflags.", "tree": {"sha": "36509d835d63b98ad1130ac9d4695b5033c10428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36509d835d63b98ad1130ac9d4695b5033c10428"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d75691877c4a7521a995d2601021fcaf30f65d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75691877c4a7521a995d2601021fcaf30f65d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d75691877c4a7521a995d2601021fcaf30f65d94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d75691877c4a7521a995d2601021fcaf30f65d94/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "023327643969d5469902a9ecfa6738a315f9e362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/023327643969d5469902a9ecfa6738a315f9e362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/023327643969d5469902a9ecfa6738a315f9e362"}], "stats": {"total": 21336, "additions": 10838, "deletions": 10498}, "files": [{"sha": "73b476666e5d779c9f8b81187c8f3bdbfdbdc386", "filename": "gcc/d/d-builtins.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fd-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fd-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-builtins.cc?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -543,7 +543,7 @@ d_build_builtins_module (Module *m)\n \t   flag_unsafe_math_optimizations.\n \t - Built-ins never use the GC or raise a D exception, and so are always\n \t   marked as `nothrow' and `@nogc'.  */\n-      tf->purity = DECL_PURE_P (decl) ? PURE::strong\n+      tf->purity = DECL_PURE_P (decl) ? PURE::const_\n \t: TREE_READONLY (decl) ? PURE::const_\n \t: DECL_IS_NOVOPS (decl) ? PURE::weak\n \t: !DECL_ASSEMBLER_NAME_SET_P (decl) ? PURE::weak"}, {"sha": "a98089b7ccac604fcaae6cea7ff7e7a1f0da354e", "filename": "gcc/d/d-gimplify.cc", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fd-gimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fd-gimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-gimplify.cc?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -62,6 +62,18 @@ empty_modify_p (tree type, tree op)\n   return empty_aggregate_p (type);\n }\n \n+/* Return TRUE if EXPR is a COMPONENT_REF to a bit-field declaration.  */\n+\n+static bool\n+bit_field_ref (const_tree expr)\n+{\n+  if (TREE_CODE (expr) == COMPONENT_REF\n+      && DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Gimplify assignment from an INIT_EXPR or MODIFY_EXPR.  */\n \n static gimplify_status\n@@ -96,6 +108,13 @@ d_gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       return GS_OK;\n     }\n \n+  /* Same as above, but for bit-field assignments.  */\n+  if (bit_field_ref (op0) && TREE_TYPE (op0) != TREE_TYPE (op1))\n+    {\n+      TREE_OPERAND (*expr_p, 1) = convert (TREE_TYPE (op0), op1);\n+      return GS_OK;\n+    }\n+\n   return GS_UNHANDLED;\n }\n \n@@ -178,6 +197,54 @@ d_gimplify_unsigned_rshift_expr (tree *expr_p)\n   return GS_OK;\n }\n \n+/* Gimplify an unary expression node.  */\n+\n+static gimplify_status\n+d_gimplify_unary_expr (tree *expr_p)\n+{\n+  tree op0 = TREE_OPERAND (*expr_p, 0);\n+\n+  if (error_operand_p (op0))\n+    return GS_UNHANDLED;\n+\n+  /* Front end doesn't know that bit-field types are really different\n+     from basic types, add an explicit conversion in unary expressions.  */\n+  if (bit_field_ref (op0) && TREE_TYPE (op0) != TREE_TYPE (*expr_p))\n+    {\n+      TREE_OPERAND (*expr_p, 0) = convert (TREE_TYPE (*expr_p), op0);\n+      return GS_OK;\n+    }\n+\n+  return GS_UNHANDLED;\n+}\n+\n+/* Gimplify a binary expression node.  */\n+\n+static gimplify_status\n+d_gimplify_binary_expr (tree *expr_p)\n+{\n+  tree op0 = TREE_OPERAND (*expr_p, 0);\n+  tree op1 = TREE_OPERAND (*expr_p, 1);\n+\n+  if (error_operand_p (op0) || error_operand_p (op1))\n+    return GS_UNHANDLED;\n+\n+  /* Front end doesn't know that bit-field types are really different\n+     from basic types, add an explicit conversion in binary expressions.  */\n+  if (bit_field_ref (op0) || bit_field_ref (op1))\n+    {\n+      if (TREE_TYPE (op0) != TREE_TYPE (*expr_p))\n+    \tTREE_OPERAND (*expr_p, 0) = convert (TREE_TYPE (*expr_p), op0);\n+\n+      if (TREE_TYPE (op1) != TREE_TYPE (*expr_p))\n+    \tTREE_OPERAND (*expr_p, 1) = convert (TREE_TYPE (*expr_p), op1);\n+\n+      return GS_OK;\n+    }\n+\n+  return GS_UNHANDLED;\n+}\n+\n /* Implements the lang_hooks.gimplify_expr routine for language D.\n    Do gimplification of D specific expression trees in EXPR_P.  */\n \n@@ -203,6 +270,10 @@ d_gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p)\n       gcc_unreachable ();\n \n     default:\n+      if (UNARY_CLASS_P (*expr_p) && !CONVERT_EXPR_P (*expr_p))\n+\treturn d_gimplify_unary_expr (expr_p);\n+      if (BINARY_CLASS_P (*expr_p))\n+\treturn d_gimplify_binary_expr (expr_p);\n       break;\n     }\n "}, {"sha": "02f7b7424550c8988a547047578590ddb318370c", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -161,6 +161,8 @@ Target::_init (const Param &)\n   this->c.longsize = int_size_in_bytes (long_integer_type_node);\n   this->c.long_doublesize = int_size_in_bytes (long_double_type_node);\n   this->c.wchar_tsize = (WCHAR_TYPE_SIZE / BITS_PER_UNIT);\n+  this->c.bitFieldStyle = targetm.ms_bitfield_layout_p (unknown_type_node)\n+    ? TargetC::BitFieldStyle::MS : TargetC::BitFieldStyle::Gcc_Clang;\n \n   /* Set-up target C++ ABI.  */\n   this->cpp.reverseOverloads = false;\n@@ -379,32 +381,21 @@ TargetCPP::typeMangle (Type *type)\n    ARG to an extern(C++) function.  */\n \n Type *\n-TargetCPP::parameterType (Parameter *arg)\n+TargetCPP::parameterType (Type *type)\n {\n-  Type *t = arg->type->merge2 ();\n-  if (arg->storageClass & (STCout | STCref))\n-    t = t->referenceTo ();\n-  else if (arg->storageClass & STClazy)\n-    {\n-      /* Mangle as delegate.  */\n-      TypeFunction *tf = TypeFunction::create (NULL, t, VARARGnone, LINK::d);\n-      TypeDelegate *td = TypeDelegate::create (tf);\n-      t = td->merge2 ();\n-    }\n-\n   /* Could be a va_list, which we mangle as a pointer.  */\n   Type *tvalist = target.va_listType (Loc (), NULL);\n-  if (t->ty == TY::Tsarray && tvalist->ty == TY::Tsarray)\n+  if (type->ty == TY::Tsarray && tvalist->ty == TY::Tsarray)\n     {\n-      Type *tb = t->toBasetype ()->mutableOf ();\n+      Type *tb = type->toBasetype ()->mutableOf ();\n       if (tb == tvalist)\n \t{\n-\t  tb = t->nextOf ()->pointerTo ();\n-\t  t = tb->castMod (t->mod);\n+\t  tb = type->nextOf ()->pointerTo ();\n+\t  type = tb->castMod (type->mod);\n \t}\n     }\n \n-  return t;\n+  return type;\n }\n \n /* Checks whether TYPE is a vendor-specific fundamental type.  Stores the result\n@@ -579,6 +570,14 @@ Target::libraryObjectMonitors (FuncDeclaration *, Statement *)\n   return true;\n }\n \n+/* Returns true if the target supports `pragma(linkerDirective)'.  */\n+\n+bool\n+Target::supportsLinkerDirective (void) const\n+{\n+  return false;\n+}\n+\n /* Decides whether an `in' parameter of the specified POD type PARAM_TYPE is to\n    be passed by reference or by valie.  This is used only when compiling with\n    `-fpreview=in' enabled.  */"}, {"sha": "91cdc9f0692e67ce9a6c8a4e210133299061f5bb", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-001bfd97b0e75423970260dac54f453be9b57f4c\n+52844d4b1e9d6714bfd2e535f25a72074a046209\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "f613ab28577713c3a400e9eba4f37d984ecd46fd", "filename": "gcc/d/dmd/README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FREADME.md?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -33,6 +33,7 @@ Note that these groups have no strict meaning, the category assignments are a bi\n |-----------------------------------------------------------------------------|-----------------------------------------------------------------------|\n | [mars.d](https://github.com/dlang/dmd/blob/master/src/dmd/mars.d)           | The entry point. Contains `main`.                                     |\n | [cli.d](https://github.com/dlang/dmd/blob/master/src/dmd/cli.d)             | Define the command line interface                                     |\n+| [dmdparams.d](https://github.com/dlang/dmd/blob/master/src/dmd/dmdparams.d) | DMD-specific parameters                                               |\n | [globals.d](https://github.com/dlang/dmd/blob/master/src/dmd/globals.d)     | Define a structure storing command line options                       |\n | [dinifile.d](https://github.com/dlang/dmd/blob/master/src/dmd/dinifile.d)   | Parse settings from .ini file (`sc.ini` / `dmd.conf`)                 |\n | [vsoptions.d](https://github.com/dlang/dmd/blob/master/src/dmd/vsoptions.d) | Detect the Microsoft Visual Studio toolchain for linking              |"}, {"sha": "59c77adf45c629179665a3b3f2703992f4767f1b", "filename": "gcc/d/dmd/access.d", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Faccess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Faccess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Faccess.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -51,15 +51,7 @@ bool checkAccess(AggregateDeclaration ad, Loc loc, Scope* sc, Dsymbol smember)\n \n     if (!symbolIsVisible(sc, smember))\n     {\n-        // when in @safe code or with -preview=dip1000\n-        if (sc.flags & SCOPE.onlysafeaccess)\n-        {\n-            // if there is a func. ask for it's opinion of safety, and if it considers the access @safe accept it.\n-            if (sc.func && !sc.func.setUnsafe())\n-                return false;\n-        }\n-\n-        ad.error(loc, \"%s `%s` is not accessible%s\", smember.kind(), smember.toChars(), (sc.flags & SCOPE.onlysafeaccess) ? \" from `@safe` code\".ptr : \"\".ptr);\n+        ad.error(loc, \"%s `%s` is not accessible\", smember.kind(), smember.toChars());\n         //printf(\"smember = %s %s, vis = %d, semanticRun = %d\\n\",\n         //        smember.kind(), smember.toPrettyChars(), smember.visible() smember.semanticRun);\n         return true;"}, {"sha": "ea10c4e9c40461683889ea8600a966b04c3b7c00", "filename": "gcc/d/dmd/astenums.d", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fastenums.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fastenums.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fastenums.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -134,6 +134,8 @@ enum STC : ulong  // transfer changes to declaration.h\n \n }\n \n+alias StorageClass = ulong;\n+\n /********\n  * Determine if it's the ambigous case of where `return` attaches to.\n  * Params:\n@@ -302,8 +304,7 @@ enum PURE : ubyte\n     impure      = 0,    // not pure at all\n     fwdref      = 1,    // it's pure, but not known which level yet\n     weak        = 2,    // no mutable globals are read or written\n-    const_      = 3,    // parameters are values or const\n-    strong      = 4,    // parameters are values or immutable\n+    const_      = 3,    // parameters are values or const = strongly pure\n }\n \n // Whether alias this dependency is recursive or not\n@@ -389,3 +390,43 @@ enum InitKind : ubyte\n     C_,\n }\n \n+/// A linkage attribute as defined by `extern(XXX)`\n+///\n+/// https://dlang.org/spec/attribute.html#linkage\n+enum LINK : ubyte\n+{\n+    default_,\n+    d,\n+    c,\n+    cpp,\n+    windows,\n+    objc,\n+    system,\n+}\n+\n+/// Whether to mangle an external aggregate as a struct or class, as set by `extern(C++, struct)`\n+enum CPPMANGLE : ubyte\n+{\n+    def,      /// default\n+    asStruct, /// `extern(C++, struct)`\n+    asClass,  /// `extern(C++, class)`\n+}\n+\n+/// Function match levels\n+///\n+/// https://dlang.org/spec/function.html#function-overloading\n+enum MATCH : int\n+{\n+    nomatch,   /// no match\n+    convert,   /// match with conversions\n+    constant,  /// match with conversion to const\n+    exact,     /// exact match\n+}\n+\n+/// Inline setting as defined by `pragma(inline, XXX)`\n+enum PINLINE : ubyte\n+{\n+    default_, /// as specified on the command line\n+    never,    /// never inline\n+    always,   /// always inline\n+}"}, {"sha": "cf9e9ce5a22c21ca0aacf1d24b7971825c4588c7", "filename": "gcc/d/dmd/attrib.d", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fattrib.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fattrib.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fattrib.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -43,6 +43,7 @@ import dmd.identifier;\n import dmd.mtype;\n import dmd.objc; // for objc.addSymbols\n import dmd.common.outbuffer;\n+import dmd.root.array; // for each\n import dmd.target; // for target.systemLinkage\n import dmd.tokens;\n import dmd.visitor;\n@@ -1519,3 +1520,60 @@ extern (C++) final class UserAttributeDeclaration : AttribDeclaration\n         }\n     }\n }\n+\n+/**\n+ * Returns `true` if the given symbol is a symbol declared in\n+ * `core.attribute` and has the given identifier.\n+ *\n+ * This is used to determine if a symbol is a UDA declared in\n+ * `core.attribute`.\n+ *\n+ * Params:\n+ *  sym = the symbol to check\n+ *  ident = the name of the expected UDA\n+ */\n+bool isCoreUda(Dsymbol sym, Identifier ident)\n+{\n+    if (sym.ident != ident || !sym.parent)\n+        return false;\n+\n+    auto _module = sym.parent.isModule();\n+    return _module && _module.isCoreModule(Id.attribute);\n+}\n+\n+/**\n+ * Iterates the UDAs attached to the given symbol.\n+ *\n+ * If `dg` returns `!= 0`, it will stop the iteration and return that\n+ * value, otherwise it will return 0.\n+ *\n+ * Params:\n+ *  sym = the symbol to get the UDAs from\n+ *  sc = scope to use for semantic analysis of UDAs\n+ *  dg = called once for each UDA. If `dg` returns `!= 0`, it will stop the\n+ *      iteration and return that value, otherwise it will return `0`.\n+ */\n+int foreachUda(Dsymbol sym, Scope* sc, int delegate(Expression) dg)\n+{\n+    if (!sym.userAttribDecl)\n+        return 0;\n+\n+    auto udas = sym.userAttribDecl.getAttributes();\n+    arrayExpressionSemantic(udas, sc, true);\n+\n+    return udas.each!((uda) {\n+        if (!uda.isTupleExp())\n+            return 0;\n+\n+        auto exps = uda.isTupleExp().exps;\n+\n+        return exps.each!((e) {\n+            assert(e);\n+\n+            if (auto result = dg(e))\n+                return result;\n+\n+            return 0;\n+        });\n+    });\n+}"}, {"sha": "5132a2dc46aea80997aaf0cb03d62b527b269150", "filename": "gcc/d/dmd/blockexit.d", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fblockexit.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fblockexit.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fblockexit.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -110,8 +110,8 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                 }\n                 if (s.exp.type && s.exp.type.toBasetype().isTypeNoreturn())\n                     result = BE.halt;\n-                if (canThrow(s.exp, func, mustNotThrow))\n-                    result |= BE.throw_;\n+\n+                result |= canThrow(s.exp, func, mustNotThrow);\n             }\n         }\n \n@@ -149,7 +149,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                             else if (!func.getModule().isCFile)\n                             {\n                                 const(char)* gototype = s.isCaseStatement() ? \"case\" : \"default\";\n-                                s.deprecation(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n+                                s.error(\"switch case fallthrough - use 'goto %s;' if intended\", gototype);\n                             }\n                         }\n                     }\n@@ -214,8 +214,8 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                 result = BE.fallthru;\n             if (result & BE.fallthru)\n             {\n-                if (canThrow(s.condition, func, mustNotThrow))\n-                    result |= BE.throw_;\n+                result |= canThrow(s.condition, func, mustNotThrow);\n+\n                 if (!(result & BE.break_) && s.condition.toBool().hasValue(true))\n                     result &= ~BE.fallthru;\n             }\n@@ -233,8 +233,8 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n             }\n             if (s.condition)\n             {\n-                if (canThrow(s.condition, func, mustNotThrow))\n-                    result |= BE.throw_;\n+                result |= canThrow(s.condition, func, mustNotThrow);\n+\n                 const opt = s.condition.toBool();\n                 if (opt.hasValue(true))\n                     result &= ~BE.fallthru;\n@@ -250,15 +250,15 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                     result |= BE.fallthru;\n                 result |= r & ~(BE.fallthru | BE.break_ | BE.continue_);\n             }\n-            if (s.increment && canThrow(s.increment, func, mustNotThrow))\n-                result |= BE.throw_;\n+            if (s.increment)\n+                result |= canThrow(s.increment, func, mustNotThrow);\n         }\n \n         override void visit(ForeachStatement s)\n         {\n             result = BE.fallthru;\n-            if (canThrow(s.aggr, func, mustNotThrow))\n-                result |= BE.throw_;\n+            result |= canThrow(s.aggr, func, mustNotThrow);\n+\n             if (s._body)\n                 result |= blockExit(s._body, func, mustNotThrow) & ~(BE.break_ | BE.continue_);\n         }\n@@ -273,8 +273,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n         {\n             //printf(\"IfStatement::blockExit(%p)\\n\", s);\n             result = BE.none;\n-            if (canThrow(s.condition, func, mustNotThrow))\n-                result |= BE.throw_;\n+            result |= canThrow(s.condition, func, mustNotThrow);\n \n             const opt = s.condition.toBool();\n             if (opt.hasValue(true))\n@@ -313,8 +312,8 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n         override void visit(SwitchStatement s)\n         {\n             result = BE.none;\n-            if (canThrow(s.condition, func, mustNotThrow))\n-                result |= BE.throw_;\n+            result |= canThrow(s.condition, func, mustNotThrow);\n+\n             if (s._body)\n             {\n                 result |= blockExit(s._body, func, mustNotThrow);\n@@ -357,8 +356,8 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n         override void visit(ReturnStatement s)\n         {\n             result = BE.return_;\n-            if (s.exp && canThrow(s.exp, func, mustNotThrow))\n-                result |= BE.throw_;\n+            if (s.exp)\n+                result |= canThrow(s.exp, func, mustNotThrow);\n         }\n \n         override void visit(BreakStatement s)\n@@ -380,8 +379,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n         override void visit(WithStatement s)\n         {\n             result = BE.none;\n-            if (canThrow(s.exp, func, mustNotThrow))\n-                result = BE.throw_;\n+            result |= canThrow(s.exp, func, mustNotThrow);\n             result |= blockExit(s._body, func, mustNotThrow);\n         }\n \n@@ -483,19 +481,7 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n                 return;\n             }\n \n-            Type t = s.exp.type.toBasetype();\n-            ClassDeclaration cd = t.isClassHandle();\n-            assert(cd);\n-\n-            if (cd == ClassDeclaration.errorException || ClassDeclaration.errorException.isBaseOf(cd, null))\n-            {\n-                result = BE.errthrow;\n-                return;\n-            }\n-            if (mustNotThrow)\n-                s.error(\"`%s` is thrown but not caught\", s.exp.type.toChars());\n-\n-            result = BE.throw_;\n+            result = checkThrow(s.loc, s.exp, mustNotThrow);\n         }\n \n         override void visit(GotoStatement s)\n@@ -537,3 +523,32 @@ int blockExit(Statement s, FuncDeclaration func, bool mustNotThrow)\n     s.accept(be);\n     return be.result;\n }\n+\n+/++\n+ + Checks whether `throw <exp>` throws an `Exception` or an `Error`\n+ + and raises an error if this violates `nothrow`.\n+ +\n+ + Params:\n+ +   loc          = location of the `throw`\n+ +   exp          = expression yielding the throwable\n+ +   mustNotThrow = inside of a `nothrow` scope?\n+ +\n+ + Returns: `BE.[err]throw` depending on the type of `exp`\n+ +/\n+BE checkThrow(ref const Loc loc, Expression exp, const bool mustNotThrow)\n+{\n+    import dmd.errors : error;\n+\n+    Type t = exp.type.toBasetype();\n+    ClassDeclaration cd = t.isClassHandle();\n+    assert(cd);\n+\n+    if (cd == ClassDeclaration.errorException || ClassDeclaration.errorException.isBaseOf(cd, null))\n+    {\n+        return BE.errthrow;\n+    }\n+    if (mustNotThrow)\n+        loc.error(\"`%s` is thrown but not caught\", exp.type.toChars());\n+\n+    return BE.throw_;\n+}"}, {"sha": "faf427d67352ab5171426eb9fc6db3fd85fef384", "filename": "gcc/d/dmd/canthrow.d", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fcanthrow.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fcanthrow.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcanthrow.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -18,6 +18,7 @@ import dmd.apply;\n import dmd.arraytypes;\n import dmd.attrib;\n import dmd.astenums;\n+import dmd.blockexit : BE, checkThrow;\n import dmd.declaration;\n import dmd.dsymbol;\n import dmd.expression;\n@@ -29,11 +30,28 @@ import dmd.root.rootobject;\n import dmd.tokens;\n import dmd.visitor;\n \n+/**\n+ * Status indicating what kind of throwable might be caused by an expression.\n+ *\n+ * This is a subset of `BE` restricted to the values actually used by `canThrow`.\n+ */\n+enum CT : BE\n+{\n+    /// Never throws an `Exception` or `Throwable`\n+    none = BE.none,\n+\n+    /// Might throw an `Exception`\n+    exception = BE.throw_,\n+\n+    // Might throw an `Error`\n+    error = BE.errthrow,\n+}\n+\n /********************************************\n  * Returns true if the expression may throw exceptions.\n  * If 'mustNotThrow' is true, generate an error if it throws\n  */\n-extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow)\n+extern (C++) /* CT */ BE canThrow(Expression e, FuncDeclaration func, bool mustNotThrow)\n {\n     //printf(\"Expression::canThrow(%d) %s\\n\", mustNotThrow, toChars());\n     // stop walking if we determine this expression can throw\n@@ -42,6 +60,7 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n         alias visit = typeof(super).visit;\n         FuncDeclaration func;\n         bool mustNotThrow;\n+        CT result;\n \n     public:\n         extern (D) this(FuncDeclaration func, bool mustNotThrow)\n@@ -62,7 +81,7 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n \n                     e.checkOverridenDtor(null, f, dd => dd.type.toTypeFunction().isnothrow, \"not nothrow\");\n                 }\n-                stop = true;  // if any function throws, then the whole expression throws\n+                result |= CT.exception;\n             }\n         }\n \n@@ -72,7 +91,7 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n \n         override void visit(DeclarationExp de)\n         {\n-            stop = Dsymbol_canThrow(de.declaration, func, mustNotThrow);\n+            result |= Dsymbol_canThrow(de.declaration, func, mustNotThrow);\n         }\n \n         override void visit(CallExp ce)\n@@ -83,18 +102,27 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n             if (global.errors && !ce.e1.type)\n                 return; // error recovery\n \n-            import dmd.id : Id;\n-\n-            if (ce.f && ce.f.ident == Id._d_delstruct)\n+            if (ce.f && ce.arguments.dim > 0)\n             {\n-                // Only check if the dtor throws.\n                 Type tb = (*ce.arguments)[0].type.toBasetype();\n-                auto ts = tb.nextOf().baseElemOf().isTypeStruct();\n-                if (ts)\n+                auto tbNext = tb.nextOf();\n+                if (tbNext)\n                 {\n-                    auto sd = ts.sym;\n-                    if (sd.dtor)\n-                        checkFuncThrows(ce, sd.dtor);\n+                    auto ts = tbNext.baseElemOf().isTypeStruct();\n+                    if (ts)\n+                    {\n+                        import dmd.id : Id;\n+\n+                        auto sd = ts.sym;\n+                        if (sd.dtor && ce.f.ident == Id._d_delstruct)\n+                            checkFuncThrows(ce, sd.dtor);\n+                        else if (sd.postblit &&\n+                            (ce.f.ident == Id._d_arrayctor || ce.f.ident == Id._d_arraysetctor))\n+                        {\n+                            checkFuncThrows(ce, sd.postblit);\n+                            return;\n+                        }\n+                    }\n                 }\n             }\n \n@@ -124,7 +152,7 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n                     e1 = pe.e1;\n                 ce.error(\"`%s` is not `nothrow`\", e1.toChars());\n             }\n-            stop = true;\n+            result |= CT.exception;\n         }\n \n         override void visit(NewExp ne)\n@@ -187,25 +215,36 @@ extern (C++) bool canThrow(Expression e, FuncDeclaration func, bool mustNotThrow\n                     checkFuncThrows(ae, postblit);\n         }\n \n+        override void visit(ThrowExp te)\n+        {\n+            const res = checkThrow(te.loc, te.e1, mustNotThrow);\n+            assert((res & ~(CT.exception | CT.error)) == 0);\n+            result |= res;\n+        }\n+\n         override void visit(NewAnonClassExp)\n         {\n             assert(0); // should have been lowered by semantic()\n         }\n     }\n \n     scope CanThrow ct = new CanThrow(func, mustNotThrow);\n-    return walkPostorder(e, ct);\n+    walkPostorder(e, ct);\n+    return ct.result;\n }\n \n /**************************************\n  * Does symbol, when initialized, throw?\n  * Mirrors logic in Dsymbol_toElem().\n  */\n-private bool Dsymbol_canThrow(Dsymbol s, FuncDeclaration func, bool mustNotThrow)\n+private CT Dsymbol_canThrow(Dsymbol s, FuncDeclaration func, bool mustNotThrow)\n {\n+    CT result;\n+\n     int symbolDg(Dsymbol s)\n     {\n-        return Dsymbol_canThrow(s, func, mustNotThrow);\n+        result |= Dsymbol_canThrow(s, func, mustNotThrow);\n+        return 0;\n     }\n \n     //printf(\"Dsymbol_toElem() %s\\n\", s.toChars());\n@@ -225,20 +264,19 @@ private bool Dsymbol_canThrow(Dsymbol s, FuncDeclaration func, bool mustNotThrow\n             if (vd._init)\n             {\n                 if (auto ie = vd._init.isExpInitializer())\n-                    if (canThrow(ie.exp, func, mustNotThrow))\n-                        return true;\n+                    result |= canThrow(ie.exp, func, mustNotThrow);\n             }\n             if (vd.needsScopeDtor())\n-                return canThrow(vd.edtor, func, mustNotThrow);\n+                result |= canThrow(vd.edtor, func, mustNotThrow);\n         }\n     }\n     else if (auto ad = s.isAttribDeclaration())\n     {\n-        return ad.include(null).foreachDsymbol(&symbolDg) != 0;\n+        ad.include(null).foreachDsymbol(&symbolDg);\n     }\n     else if (auto tm = s.isTemplateMixin())\n     {\n-        return tm.members.foreachDsymbol(&symbolDg) != 0;\n+        tm.members.foreachDsymbol(&symbolDg);\n     }\n     else if (auto td = s.isTupleDeclaration())\n     {\n@@ -250,11 +288,10 @@ private bool Dsymbol_canThrow(Dsymbol s, FuncDeclaration func, bool mustNotThrow\n                 Expression eo = cast(Expression)o;\n                 if (auto se = eo.isDsymbolExp())\n                 {\n-                    if (Dsymbol_canThrow(se.s, func, mustNotThrow))\n-                        return true;\n+                    result |= Dsymbol_canThrow(se.s, func, mustNotThrow);\n                 }\n             }\n         }\n     }\n-    return false;\n+    return result;\n }"}, {"sha": "16f7b2f40194995cbbda85bf7f1adf9be517d497", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -120,18 +120,13 @@ UnionExp Not(Type type, Expression e1)\n {\n     UnionExp ue = void;\n     Loc loc = e1.loc;\n+    // BUG: Should be replaced with e1.toBool().get(), but this is apparently\n+    //      executed for some expressions that cannot be const-folded\n+    //      To be fixed in another PR\n     emplaceExp!(IntegerExp)(&ue, loc, e1.toBool().hasValue(false) ? 1 : 0, type);\n     return ue;\n }\n \n-private UnionExp Bool(Type type, Expression e1)\n-{\n-    UnionExp ue = void;\n-    Loc loc = e1.loc;\n-    emplaceExp!(IntegerExp)(&ue, loc, e1.toBool().hasValue(true) ? 1 : 0, type);\n-    return ue;\n-}\n-\n UnionExp Add(const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n     UnionExp ue = void;\n@@ -1093,19 +1088,14 @@ UnionExp Cast(const ref Loc loc, Type type, Type to, Expression e1)\n     }\n     else if (tb.ty == Tbool)\n     {\n-        bool val = void;\n         const opt = e1.toBool();\n-        if (opt.hasValue(true))\n-            val = true;\n-        else if (opt.hasValue(false))\n-            val = false;\n-        else\n+        if (opt.isEmpty())\n         {\n             cantExp(ue);\n             return ue;\n         }\n \n-        emplaceExp!(IntegerExp)(&ue, loc, val, type);\n+        emplaceExp!(IntegerExp)(&ue, loc, opt.get(), type);\n     }\n     else if (type.isintegral())\n     {"}, {"sha": "38a78a0b0139455ee74ea0a4153f749a2d798f1a", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 131, "deletions": 75, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -35,7 +35,8 @@ final class CParser(AST) : Parser!AST\n {\n     AST.Dsymbols* symbols;      // symbols declared in current scope\n \n-    bool addFuncName;             /// add declaration of __func__ to function symbol table\n+    bool addFuncName;           /// add declaration of __func__ to function symbol table\n+    bool importBuiltins;        /// seen use of C compiler builtins, so import __builtins;\n \n     extern (D) this(TARGET)(AST.Module _module, const(char)[] input, bool doDocComment,\n                             const ref TARGET target)\n@@ -72,7 +73,6 @@ final class CParser(AST) : Parser!AST\n     {\n         //printf(\"cparseTranslationUnit()\\n\");\n         symbols = new AST.Dsymbols();\n-        addBuiltinDeclarations();\n         while (1)\n         {\n             if (token.value == TOK.endOfFile)\n@@ -82,6 +82,15 @@ final class CParser(AST) : Parser!AST\n                 auto ld = new AST.LinkDeclaration(token.loc, LINK.c, symbols);\n                 wrap.push(ld);\n \n+                if (importBuiltins)\n+                {\n+                    /* Seen references to C builtin functions.\n+                     * Import their definitions\n+                     */\n+                    auto s = new AST.Import(Loc.initial, null, Id.builtins, null, false);\n+                    wrap.push(s);\n+                }\n+\n                 return wrap;\n             }\n \n@@ -596,6 +605,7 @@ final class CParser(AST) : Parser!AST\n      *    string-literal\n      *    ( expression )\n      *    generic-selection\n+     *    __builtin_va_arg(assign_expression, type)\n      */\n     AST.Expression cparsePrimaryExp()\n     {\n@@ -606,9 +616,20 @@ final class CParser(AST) : Parser!AST\n         switch (token.value)\n         {\n         case TOK.identifier:\n-            if (token.ident is Id.__func__)\n+            const id = token.ident.toString();\n+            if (id.length > 2 && id[0] == '_' && id[1] == '_')  // leading double underscore\n             {\n-                addFuncName = true;     // implicitly declare __func__\n+                if (token.ident is Id.__func__)\n+                {\n+                    addFuncName = true;     // implicitly declare __func__\n+                }\n+                else if (token.ident is Id.builtin_va_arg)\n+                {\n+                    e = cparseBuiltin_va_arg();\n+                    break;\n+                }\n+                else\n+                    importBuiltins = true;  // probably one of those compiler extensions\n             }\n             e = new AST.IdentifierExp(loc, token.ident);\n             nextToken();\n@@ -1449,6 +1470,40 @@ final class CParser(AST) : Parser!AST\n         return cparseAssignExp();\n     }\n \n+    /*****************************\n+     * gcc extension:\n+     *    type __builtin_va_arg(assign-expression, type)\n+     * Rewrite as `va_arg` template from `core.stdc.stdarg`:\n+     *    va_arg!(type)(assign-expression);\n+     * Lexer is on `__builtin_va_arg`\n+     */\n+    private AST.Expression cparseBuiltin_va_arg()\n+    {\n+        importBuiltins = true;  // need core.stdc.stdarg\n+\n+        nextToken();\n+        check(TOK.leftParenthesis);\n+\n+        auto arguments = new AST.Expressions();\n+        auto arg = cparseAssignExp();\n+        arguments.push(arg);\n+\n+        check(TOK.comma);\n+\n+        auto t = cparseTypeName();\n+        auto tiargs = new AST.Objects();\n+        tiargs.push(t);\n+\n+        const loc = loc;\n+        auto ti = new AST.TemplateInstance(loc, Id.va_arg, tiargs);\n+        auto tie = new AST.ScopeExp(loc, ti);\n+\n+        AST.Expression e = new AST.CallExp(loc, tie, arguments);\n+\n+        check(TOK.rightParenthesis);\n+        return e;\n+    }\n+\n     //}\n     /********************************************************************************/\n     /********************************* Declaration Parser ***************************/\n@@ -1481,6 +1536,14 @@ final class CParser(AST) : Parser!AST\n             return;\n         }\n \n+        if (token.value == TOK._import) // import declaration extension\n+        {\n+            auto a = parseImport();\n+            if (a && a.length)\n+                symbols.append(a);\n+            return;\n+        }\n+\n         auto symbolsSave = symbols;\n         Specifier specifier;\n         specifier.packalign = this.packalign;\n@@ -1504,7 +1567,7 @@ final class CParser(AST) : Parser!AST\n              */\n             auto stag = (tt.tok == TOK.struct_) ? new AST.StructDeclaration(tt.loc, tt.id, false) :\n                         (tt.tok == TOK.union_)  ? new AST.UnionDeclaration(tt.loc, tt.id) :\n-                                                  new AST.EnumDeclaration(tt.loc, tt.id, AST.Type.tint32);\n+                                                  new AST.EnumDeclaration(tt.loc, tt.id, tt.base);\n             stag.members = tt.members;\n             if (!symbols)\n                 symbols = new AST.Dsymbols();\n@@ -1550,26 +1613,18 @@ final class CParser(AST) : Parser!AST\n                 case TOK.semicolon:\n                 case TOK.asm_:\n                 case TOK.__attribute__:\n-                    /* This is a data definition, there cannot now be a\n-                     * function definition.\n-                     */\n-                    first = false;\n                     if (token.value == TOK.asm_)\n                         asmname = cparseSimpleAsmExpr();\n                     if (token.value == TOK.__attribute__)\n                     {\n                         cparseGnuAttributes(specifier);\n                         if (token.value == TOK.leftCurly)\n-                        {\n-                            error(\"attributes should be specified before the function definition\");\n-                            auto t = &token;\n-                            if (skipBraces(t))\n-                            {\n-                                token = *t;\n-                                return;\n-                            }\n-                        }\n+                            break;              // function definition\n                     }\n+                    /* This is a data definition, there cannot now be a\n+                     * function definition.\n+                     */\n+                    first = false;\n                     break;\n \n                 default:\n@@ -1636,6 +1691,30 @@ final class CParser(AST) : Parser!AST\n                         isalias = false;\n                     }\n                 }\n+                else if (auto tt = dt.isTypeTag())\n+                {\n+                    if (tt.id || tt.tok == TOK.enum_)\n+                    {\n+                        /* `struct tag;` and `struct tag { ... };`\n+                         * always result in a declaration in the current scope\n+                         */\n+                        auto stag = (tt.tok == TOK.struct_) ? new AST.StructDeclaration(tt.loc, tt.id, false) :\n+                                    (tt.tok == TOK.union_)  ? new AST.UnionDeclaration(tt.loc, tt.id) :\n+                                                              new AST.EnumDeclaration(tt.loc, tt.id, tt.base);\n+                        stag.members = tt.members;\n+                        tt.members = null;\n+                        if (!symbols)\n+                            symbols = new AST.Dsymbols();\n+                        symbols.push(stag);\n+                        if (tt.tok == TOK.enum_)\n+                        {\n+                            if (!tt.members)\n+                                error(tt.loc, \"`enum %s` has no members\", stag.toChars());\n+                            isalias = false;\n+                            s = new AST.AliasDeclaration(token.loc, id, stag);\n+                        }\n+                    }\n+                }\n                 if (isalias)\n                     s = new AST.AliasDeclaration(token.loc, id, dt);\n             }\n@@ -1768,6 +1847,7 @@ final class CParser(AST) : Parser!AST\n             if (pl.varargs != AST.VarArg.none && pl.length)\n                 error(\"function identifier-list cannot end with `...`\");\n             ft.parameterList.varargs = AST.VarArg.variadic;     // but C11 allows extra arguments\n+            importBuiltins = true;                              // will need __va_list_tag\n             auto plLength = pl.length;\n             if (symbols.length != plLength)\n                 error(\"%d identifiers does not match %d declarations\", cast(int)plLength, cast(int)symbols.length);\n@@ -2230,8 +2310,14 @@ final class CParser(AST) : Parser!AST\n             case TKW.xcomplex | TKW.xdouble:               t = AST.Type.tcomplex64; break;\n             case TKW.xcomplex | TKW.xlong | TKW.xdouble:   t = realType(RTFlags.complex); break;\n \n-            case TKW.xident:                    t = new AST.TypeIdentifier(loc, previd);\n+            case TKW.xident:\n+            {\n+                const idx = previd.toString();\n+                if (idx.length > 2 && idx[0] == '_' && idx[1] == '_')  // leading double underscore\n+                    importBuiltins = true;  // probably one of those compiler extensions\n+                t = new AST.TypeIdentifier(loc, previd);\n                 break;\n+            }\n \n             case TKW.xtag:\n                 break;          // t is already set\n@@ -2599,6 +2685,7 @@ final class CParser(AST) : Parser!AST\n         if (token.value == TOK.rightParenthesis)        // func()\n         {\n             nextToken();\n+            importBuiltins = true;                              // will need __va_list_tag\n             return AST.ParameterList(parameters, AST.VarArg.variadic, varargsStc);\n         }\n \n@@ -2613,6 +2700,7 @@ final class CParser(AST) : Parser!AST\n             {\n                 if (parameters.length == 0)     // func(...)\n                     error(\"named parameter required before `...`\");\n+                importBuiltins = true;          // will need __va_list_tag\n                 varargs = AST.VarArg.variadic;  // C-style variadics\n                 nextToken();\n                 check(TOK.rightParenthesis);\n@@ -3011,6 +3099,17 @@ final class CParser(AST) : Parser!AST\n             nextToken();\n         }\n \n+        /* clang extension: add optional base type after the identifier\n+         * https://en.cppreference.com/w/cpp/language/enum\n+         *   enum Identifier : Type\n+         */\n+        AST.Type base = AST.Type.tint32;  // C11 6.7.2.2-4 implementation defined default base type\n+        if (token.value == TOK.colon)\n+        {\n+            nextToken();\n+            base = cparseTypeName();\n+        }\n+\n         AST.Dsymbols* members;\n         if (token.value == TOK.leftCurly)\n         {\n@@ -3084,7 +3183,7 @@ final class CParser(AST) : Parser!AST\n          * redeclaration, or reference to existing declaration.\n          * Defer to the semantic() pass with a TypeTag.\n          */\n-        return new AST.TypeTag(loc, TOK.enum_, tag, members);\n+        return new AST.TypeTag(loc, TOK.enum_, tag, base, members);\n     }\n \n     /*************************************\n@@ -3124,17 +3223,14 @@ final class CParser(AST) : Parser!AST\n         if (token.value == TOK.leftCurly)\n         {\n             nextToken();\n-            auto symbolsSave = symbols;\n-            symbols = new AST.Dsymbols();\n+            members = new AST.Dsymbols();          // so `members` will be non-null even with 0 members\n             while (token.value != TOK.rightCurly)\n             {\n-                cparseStructDeclaration();\n+                cparseStructDeclaration(members);\n \n                 if (token.value == TOK.endOfFile)\n                     break;\n             }\n-            members = symbols;          // `members` will be non-null even with 0 members\n-            symbols = symbolsSave;\n             check(TOK.rightCurly);\n \n             if ((*members).length == 0) // C11 6.7.2.1-8\n@@ -3152,7 +3248,7 @@ final class CParser(AST) : Parser!AST\n          * redeclaration, or reference to existing declaration.\n          * Defer to the semantic() pass with a TypeTag.\n          */\n-        return new AST.TypeTag(loc, structOrUnion, tag, members);\n+        return new AST.TypeTag(loc, structOrUnion, tag, null, members);\n     }\n \n     /*************************************\n@@ -3169,18 +3265,19 @@ final class CParser(AST) : Parser!AST\n      * struct-declarator:\n      *    declarator\n      *    declarator (opt) : constant-expression\n+     * Params:\n+     *    members = where to put the fields (members)\n      */\n-    void cparseStructDeclaration()\n+    void cparseStructDeclaration(AST.Dsymbols* members)\n     {\n         //printf(\"cparseStructDeclaration()\\n\");\n         if (token.value == TOK._Static_assert)\n         {\n             auto s = cparseStaticAssert();\n-            symbols.push(s);\n+            members.push(s);\n             return;\n         }\n \n-        auto symbolsSave = symbols;\n         Specifier specifier;\n         specifier.packalign = this.packalign;\n         auto tspec = cparseSpecifierQualifierList(LVL.member, specifier);\n@@ -3209,10 +3306,8 @@ final class CParser(AST) : Parser!AST\n                  * the containing struct\n                  */\n                 auto ad = new AST.AnonDeclaration(tt.loc, tt.tok == TOK.union_, tt.members);\n-                if (!symbols)\n-                    symbols = new AST.Dsymbols();\n                 auto s = applySpecifier(ad, specifier);\n-                symbols.push(s);\n+                members.push(s);\n                 return;\n             }\n             if (!tt.id && !tt.members)\n@@ -3270,18 +3365,14 @@ final class CParser(AST) : Parser!AST\n             if (token.value == TOK.__attribute__)\n                 cparseGnuAttributes(specifier);\n \n-            AST.Dsymbol s = null;\n-            symbols = symbolsSave;\n-            if (!symbols)\n-                symbols = new AST.Dsymbols;     // lazilly create it\n-\n             if (!tspec && !specifier.scw && !specifier.mod)\n                 error(\"specifier-qualifier-list required\");\n             else if (width)\n             {\n                 if (specifier.alignExps)\n                     error(\"no alignment-specifier for bit field declaration\"); // C11 6.7.5-2\n-                s = new AST.BitFieldDeclaration(width.loc, dt, id, width);\n+                auto s = new AST.BitFieldDeclaration(width.loc, dt, id, width);\n+                members.push(s);\n             }\n             else if (id)\n             {\n@@ -3291,11 +3382,10 @@ final class CParser(AST) : Parser!AST\n                 // declare the symbol\n                 // Give member variables an implicit void initializer\n                 auto initializer = new AST.VoidInitializer(token.loc);\n-                s = new AST.VarDeclaration(token.loc, dt, id, initializer, specifiersToSTC(LVL.member, specifier));\n+                AST.Dsymbol s = new AST.VarDeclaration(token.loc, dt, id, initializer, specifiersToSTC(LVL.member, specifier));\n                 s = applySpecifier(s, specifier);\n+                members.push(s);\n             }\n-            if (s !is null)\n-                symbols.push(s);\n \n             switch (token.value)\n             {\n@@ -4391,39 +4481,5 @@ final class CParser(AST) : Parser!AST\n         return s;\n     }\n \n-    /***********************************\n-     * Add global target-dependent builtin declarations.\n-     */\n-    private void addBuiltinDeclarations()\n-    {\n-        void genBuiltinFunc(Identifier id, AST.VarArg va)\n-        {\n-            auto tva_list = new AST.TypeIdentifier(Loc.initial, Id.builtin_va_list);\n-            auto parameters = new AST.Parameters();\n-            parameters.push(new AST.Parameter(STC.parameter | STC.ref_, tva_list, null, null, null));\n-            auto pl = AST.ParameterList(parameters, va, 0);\n-            auto tf = new AST.TypeFunction(pl, AST.Type.tvoid, LINK.c, 0);\n-            auto s = new AST.FuncDeclaration(Loc.initial, Loc.initial, id, AST.STC.static_, tf, false);\n-            symbols.push(s);\n-        }\n-\n-        /* void __builtin_va_start(__builtin_va_list, ...);\n-         * The second argument is supposed to be of any type, so fake it with the ...\n-         */\n-        genBuiltinFunc(Id.builtin_va_start, AST.VarArg.variadic);\n-\n-        /* void __builtin_va_end(__builtin_va_list);\n-         */\n-        genBuiltinFunc(Id.builtin_va_end, AST.VarArg.none);\n-\n-        /* struct __va_list_tag\n-         * {\n-         *    uint, uint, void*, void*\n-         * }\n-         */\n-        auto s = new AST.StructDeclaration(Loc.initial, Id.va_list_tag, false);\n-        symbols.push(s);\n-    }\n-\n     //}\n }"}, {"sha": "986b53ff74accb34537e3b9543ae289f64fecedc", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1315,7 +1315,18 @@ private final class CppMangleVisitor : Visitor\n \n         foreach (n, fparam; parameterList)\n         {\n-            Type t = target.cpp.parameterType(fparam);\n+            Type t = fparam.type.merge2();\n+            if (fparam.isReference())\n+                t = t.referenceTo();\n+            else if (fparam.storageClass & STC.lazy_)\n+            {\n+                // Mangle as delegate\n+                auto tf = new TypeFunction(ParameterList(), t, LINK.d);\n+                auto td = new TypeDelegate(tf);\n+                t = td.merge();\n+            }\n+            else if (Type cpptype = target.cpp.parameterType(t))\n+                t = cpptype;\n             if (t.ty == Tsarray)\n             {\n                 // Static arrays in D are passed by value; no counterpart in C++"}, {"sha": "91b38618e23a0ffb0f8695cef581a143321bc874", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -858,11 +858,8 @@ MATCH implicitConvTo(Expression e, Type t)\n              * convert to immutable\n              */\n             if (e.f &&\n-                (global.params.useDIP1000 != FeatureState.enabled ||        // lots of legacy code breaks with the following purity check\n-                 e.f.isPure() >= PURE.strong ||\n-                 // Special case exemption for Object.dup() which we assume is implemented correctly\n-                 e.f.ident == Id.dup &&\n-                 e.f.toParent2() == ClassDeclaration.object.toParent()) &&\n+                // lots of legacy code breaks with the following purity check\n+                (global.params.useDIP1000 != FeatureState.enabled || e.f.isPure() >= PURE.const_) &&\n                  e.f.isReturnIsolated() // check isReturnIsolated last, because it is potentially expensive.\n                )\n             {\n@@ -2245,9 +2242,12 @@ Expression castTo(Expression e, Scope* sc, Type t, Type att = null)\n                 ex = ex.castTo(sc, totuple ? (*totuple.arguments)[i].type : t);\n                 (*te.exps)[i] = ex;\n             }\n+            if (totuple)\n+                te.type = totuple;\n             result = te;\n \n-            /* Questionable behavior: In here, result.type is not set to t.\n+            /* Questionable behavior: In here, result.type is not set to t\n+             *  if target type is not a tuple of same length.\n              * Therefoe:\n              *  TypeTuple!(int, int) values;\n              *  auto values2 = cast(long)values;"}, {"sha": "ce463c023f021a27d7f26da1363fc1162c616114", "filename": "gcc/d/dmd/dclass.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdclass.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdclass.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdclass.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -446,6 +446,7 @@ extern (C++) class ClassDeclaration : AggregateDeclaration\n             *poffset = 0;\n         while (cd)\n         {\n+            assert(cd.baseClass || cd.semanticRun >= PASS.semanticdone || cd.isInterfaceDeclaration());\n             if (this == cd.baseClass)\n                 return true;\n "}, {"sha": "494b60f04937aee81c773e6cbaa981a8d2b07378", "filename": "gcc/d/dmd/declaration.d", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdeclaration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdeclaration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1048,7 +1048,6 @@ extern (C++) class VarDeclaration : Declaration\n     uint endlinnum;                 // line number of end of scope that this var lives in\n     uint offset;\n     uint sequenceNumber;            // order the variables are declared\n-    __gshared uint nextSequenceNumber;   // the counter for sequenceNumber\n     structalign_t alignment;\n \n     // When interpreting, these point to the value (NULL if value not determinable)\n@@ -1099,7 +1098,6 @@ extern (C++) class VarDeclaration : Declaration\n         this._init = _init;\n         ctfeAdrOnStack = AdrOnStackNone;\n         this.storage_class = storage_class;\n-        sequenceNumber = ++nextSequenceNumber;\n     }\n \n     static VarDeclaration create(const ref Loc loc, Type type, Identifier ident, Initializer _init, StorageClass storage_class = STC.undefined_)\n@@ -1657,12 +1655,10 @@ extern (C++) class VarDeclaration : Declaration\n         // Sequence numbers work when there are no special VarDeclaration's involved\n         if (!((this.storage_class | v.storage_class) & special))\n         {\n-            // FIXME: VarDeclaration's for parameters are created in semantic3, so\n-            //        they will have a greater sequence number than local variables.\n-            //        Hence reverse the result for mixed comparisons.\n-            const exp = this.isParameter() == v.isParameter();\n+            assert(this.sequenceNumber != this.sequenceNumber.init);\n+            assert(v.sequenceNumber != v.sequenceNumber.init);\n \n-            return (this.sequenceNumber < v.sequenceNumber) == exp;\n+            return (this.sequenceNumber < v.sequenceNumber);\n         }\n \n         // Assume that semantic produces temporaries according to their lifetime"}, {"sha": "90e48f84d23b4edcd1144ad7eec6ad945714bbcd", "filename": "gcc/d/dmd/denum.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdenum.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdenum.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdenum.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -16,6 +16,7 @@ module dmd.denum;\n \n import core.stdc.stdio;\n \n+import dmd.astenums;\n import dmd.attrib;\n import dmd.gluelayer;\n import dmd.declaration;\n@@ -60,7 +61,7 @@ extern (C++) final class EnumDeclaration : ScopeDsymbol\n     extern (D) this(const ref Loc loc, Identifier ident, Type memtype)\n     {\n         super(loc, ident);\n-        //printf(\"EnumDeclaration() %s\\n\", toChars());\n+        //printf(\"EnumDeclaration() %p %s : %s\\n\", this, toChars(), memtype.toChars());\n         type = new TypeEnum(this);\n         this.memtype = memtype;\n         visibility = Visibility(Visibility.Kind.undefined);"}, {"sha": "b55b98160fffc06ba4e8493a0e20b9df1cd98205", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -99,7 +99,15 @@ public Expression ctfeInterpret(Expression e)\n \n     Expression result = interpret(e, null);\n \n-    result = copyRegionExp(result);\n+    // Report an error if the expression contained a `ThrowException` and\n+    // hence generated an uncaught exception\n+    if (auto tee = result.isThrownExceptionExp())\n+    {\n+        tee.generateUncaughtError();\n+        result = CTFEExp.cantexp;\n+    }\n+    else\n+        result = copyRegionExp(result);\n \n     if (!CTFEExp.isCantExp(result))\n         result = scrubReturnValue(e.loc, result);\n@@ -1601,14 +1609,20 @@ public:\n             istate.start = null;\n         }\n \n-        incUsageCtfe(istate, s.loc);\n+        interpretThrow(s.exp, s.loc);\n+    }\n+\n+    /// Interpret `throw <exp>` found at the specified location `loc`\n+    private void interpretThrow(Expression exp, const ref Loc loc)\n+    {\n+        incUsageCtfe(istate, loc);\n \n-        Expression e = interpretRegion(s.exp, istate);\n+        Expression e = interpretRegion(exp, istate);\n         if (exceptionOrCant(e))\n             return;\n \n         assert(e.op == EXP.classReference);\n-        result = ctfeEmplaceExp!ThrownExceptionExp(s.loc, e.isClassReferenceExp());\n+        result = ctfeEmplaceExp!ThrownExceptionExp(loc, e.isClassReferenceExp());\n     }\n \n     override void visit(ScopeGuardStatement s)\n@@ -6149,6 +6163,15 @@ public:\n         return;\n     }\n \n+    override void visit(ThrowExp te)\n+    {\n+        debug (LOG)\n+        {\n+            printf(\"%s ThrowExpression::interpret()\\n\", e.loc.toChars());\n+        }\n+        interpretThrow(te.e1, te.loc);\n+    }\n+\n     override void visit(PtrExp e)\n     {\n         debug (LOG)"}, {"sha": "2a3777b3df0216df54a0935756f68dbbde29772c", "filename": "gcc/d/dmd/dscope.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdscope.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -59,7 +59,6 @@ enum SCOPE\n     compile       = 0x0100,   /// inside __traits(compile)\n     ignoresymbolvisibility    = 0x0200,   /// ignore symbol visibility\n                                           /// https://issues.dlang.org/show_bug.cgi?id=15907\n-    onlysafeaccess = 0x0400,  /// unsafe access is not allowed for @safe code\n     Cfile         = 0x0800,   /// C semantics apply\n     free          = 0x8000,   /// is on free list\n \n@@ -74,7 +73,7 @@ enum SCOPE\n /// Flags that are carried along with a scope push()\n private enum PersistentFlags =\n     SCOPE.contract | SCOPE.debug_ | SCOPE.ctfe | SCOPE.compile | SCOPE.constraint |\n-    SCOPE.noaccesscheck | SCOPE.onlysafeaccess | SCOPE.ignoresymbolvisibility |\n+    SCOPE.noaccesscheck | SCOPE.ignoresymbolvisibility |\n     SCOPE.printf | SCOPE.scanf | SCOPE.Cfile;\n \n struct Scope"}, {"sha": "7823351b57951c2ff498f73931820dbd42ba5ba0", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2345,7 +2345,7 @@ extern (C++) final class DsymbolTable : RootObject\n Dsymbol handleTagSymbols(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n {\n     enum log = false;\n-    if (log) printf(\"handleTagSymbols('%s')\\n\", s.toChars());\n+    if (log) printf(\"handleTagSymbols('%s') add %p existing %p\\n\", s.toChars(), s, s2);\n     auto sd = s.isScopeDsymbol(); // new declaration\n     auto sd2 = s2.isScopeDsymbol(); // existing declaration\n "}, {"sha": "1cb167ae18c89b368735cb1d5d4a3b165d762e60", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -356,6 +356,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         if (sc && sc.inunion && sc.inunion.isAnonDeclaration())\n             dsym.overlapped = true;\n \n+        dsym.sequenceNumber = global.varSequenceNumber++;\n+\n         Scope* scx = null;\n         if (dsym._scope)\n         {\n@@ -1636,7 +1638,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n \n         // Should be merged with PragmaStatement\n         //printf(\"\\tPragmaDeclaration::semantic '%s'\\n\", pd.toChars());\n-        if (target.mscoff)\n+        if (target.supportsLinkerDirective())\n         {\n             if (pd.ident == Id.linkerDirective)\n             {\n@@ -2177,7 +2179,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         {\n             /* C11 6.7.2.2\n              */\n-            ed.memtype = Type.tint32; // C11 6.7.2.2-4 implementation defined\n+            assert(ed.memtype);\n             int nextValue = 0;        // C11 6.7.2.2-3 first member value defaults to 0\n \n             void emSemantic(EnumMember em, ref int nextValue)\n@@ -3457,9 +3459,11 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     }\n                 }\n \n-                /* These quirky conditions mimic what VC++ appears to do\n+                /* These quirky conditions mimic what happens when virtual\n+                   inheritance is implemented by producing a virtual base table\n+                   with offsets to each of the virtual bases.\n                  */\n-                if (target.mscoff && cd.classKind == ClassKind.cpp &&\n+                if (target.cpp.splitVBasetable && cd.classKind == ClassKind.cpp &&\n                     cd.baseClass && cd.baseClass.vtbl.dim)\n                 {\n                     /* if overriding an interface function, then this is not\n@@ -3557,7 +3561,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                             goto Lintro;\n                     }\n \n-                    if (fdv.isDeprecated)\n+                    if (fdv.isDeprecated && !funcdecl.isDeprecated)\n                         deprecation(funcdecl.loc, \"`%s` is overriding the deprecated method `%s`\",\n                                     funcdecl.toPrettyChars, fdv.toPrettyChars);\n \n@@ -3646,11 +3650,17 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                         funcdecl.tintro = fdv.tintro;\n                     else if (!funcdecl.type.equals(fdv.type))\n                     {\n+                        auto tnext = funcdecl.type.nextOf();\n+                        if (auto handle = tnext.isClassHandle())\n+                        {\n+                            if (handle.semanticRun < PASS.semanticdone && !handle.isBaseInfoComplete())\n+                                handle.dsymbolSemantic(null);\n+                        }\n                         /* Only need to have a tintro if the vptr\n                          * offsets differ\n                          */\n                         int offset;\n-                        if (fdv.type.nextOf().isBaseOf(funcdecl.type.nextOf(), &offset))\n+                        if (fdv.type.nextOf().isBaseOf(tnext, &offset))\n                         {\n                             funcdecl.tintro = fdv.type;\n                         }\n@@ -3812,7 +3822,8 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n                     deprecation(funcdecl.loc,\n                                 \"`%s` cannot be annotated with `@disable` because it is overriding a function in the base class\",\n                                 funcdecl.toPrettyChars);\n-                if (funcdecl.isDeprecated)\n+\n+                if (funcdecl.isDeprecated && !(funcdecl.foverrides.length && funcdecl.foverrides[0].isDeprecated))\n                     deprecation(funcdecl.loc,\n                                 \"`%s` cannot be marked as `deprecated` because it is overriding a function in the base class\",\n                                 funcdecl.toPrettyChars);"}, {"sha": "9fe8472b11ec08bf96a1fd8a31ab51e5821d30f7", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 73, "deletions": 103, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -6223,114 +6223,62 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n      */\n     final bool needsCodegen()\n     {\n-        if (!minst)\n-        {\n-            // If this is a speculative instantiation,\n-            // 1. do codegen if ancestors really needs codegen.\n-            // 2. become non-speculative if siblings are not speculative\n-\n-            TemplateInstance tnext = this.tnext;\n-            TemplateInstance tinst = this.tinst;\n-            // At first, disconnect chain first to prevent infinite recursion.\n-            this.tnext = null;\n-            this.tinst = null;\n+        // minst is finalized after the 1st invocation.\n+        // tnext and tinst are only needed for the 1st invocation and\n+        // cleared for further invocations.\n+        TemplateInstance tnext = this.tnext;\n+        TemplateInstance tinst = this.tinst;\n+        this.tnext = null;\n+        this.tinst = null;\n \n-            // Determine necessity of tinst before tnext.\n-            if (tinst && tinst.needsCodegen())\n-            {\n-                minst = tinst.minst; // cache result\n-                if (global.params.allInst && minst)\n-                {\n-                    return true;\n-                }\n-                assert(minst);\n-                assert(minst.isRoot() || minst.rootImports());\n-                return true;\n-            }\n-            if (tnext && (tnext.needsCodegen() || tnext.minst))\n-            {\n-                minst = tnext.minst; // cache result\n-                if (global.params.allInst && minst)\n-                {\n-                    return true;\n-                }\n-                assert(minst);\n-                return minst.isRoot() || minst.rootImports();\n-            }\n-\n-            // Elide codegen because this is really speculative.\n-            return false;\n-        }\n-\n-        if (global.params.allInst)\n-        {\n-            return true;\n-        }\n-\n-        if (isDiscardable())\n+        if (errors || (inst && inst.isDiscardable()))\n         {\n+            minst = null; // mark as speculative\n             return false;\n         }\n \n-        /* Even when this is reached to the codegen pass,\n-         * a non-root nested template should not generate code,\n-         * due to avoid ODR violation.\n-         */\n-        if (enclosing && enclosing.inNonRoot())\n+        if (global.params.allInst)\n         {\n-            if (tinst)\n-            {\n-                auto r = tinst.needsCodegen();\n-                minst = tinst.minst; // cache result\n-                return r;\n-            }\n-            if (tnext)\n-            {\n-                auto r = tnext.needsCodegen();\n-                minst = tnext.minst; // cache result\n-                return r;\n-            }\n-            return false;\n-        }\n+            // Do codegen if there is an instantiation from a root module, to maximize link-ability.\n \n-        if (global.params.useUnitTests)\n-        {\n-            // Prefer instantiations from root modules, to maximize link-ability.\n-            if (minst.isRoot())\n+            // Do codegen if `this` is instantiated from a root module.\n+            if (minst && minst.isRoot())\n                 return true;\n \n-            TemplateInstance tnext = this.tnext;\n-            TemplateInstance tinst = this.tinst;\n-            this.tnext = null;\n-            this.tinst = null;\n-\n+            // Do codegen if the ancestor needs it.\n             if (tinst && tinst.needsCodegen())\n             {\n                 minst = tinst.minst; // cache result\n                 assert(minst);\n-                assert(minst.isRoot() || minst.rootImports());\n+                assert(minst.isRoot());\n                 return true;\n             }\n-            if (tnext && tnext.needsCodegen())\n+\n+            // Do codegen if a sibling needs it.\n+            if (tnext)\n             {\n-                minst = tnext.minst; // cache result\n-                assert(minst);\n-                assert(minst.isRoot() || minst.rootImports());\n-                return true;\n+                if (tnext.needsCodegen())\n+                {\n+                    minst = tnext.minst; // cache result\n+                    assert(minst);\n+                    assert(minst.isRoot());\n+                    return true;\n+                }\n+                else if (!minst && tnext.minst)\n+                {\n+                    minst = tnext.minst; // cache result from non-speculative sibling\n+                    return false;\n+                }\n             }\n \n-            // https://issues.dlang.org/show_bug.cgi?id=2500 case\n-            if (minst.rootImports())\n-                return true;\n-\n-            // Elide codegen because this is not included in root instances.\n+            // Elide codegen because there's no instantiation from any root modules.\n             return false;\n         }\n         else\n         {\n-            // Prefer instantiations from non-root module, to minimize object code size.\n+            // Prefer instantiations from non-root modules, to minimize object code size.\n \n-            /* If a TemplateInstance is ever instantiated by non-root modules,\n+            /* If a TemplateInstance is ever instantiated from a non-root module,\n              * we do not have to generate code for it,\n              * because it will be generated when the non-root module is compiled.\n              *\n@@ -6341,22 +6289,51 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n              * or the compilation of B do the actual instantiation?\n              *\n              * See https://issues.dlang.org/show_bug.cgi?id=2500.\n+             *\n+             * => Elide codegen if there is at least one instantiation from a non-root module\n+             *    which doesn't import any root modules.\n              */\n-            if (!minst.isRoot() && !minst.rootImports())\n-                return false;\n \n-            TemplateInstance tnext = this.tnext;\n-            this.tnext = null;\n-\n-            if (tnext && !tnext.needsCodegen() && tnext.minst)\n+            // If the ancestor isn't speculative,\n+            // 1. do codegen if the ancestor needs it\n+            // 2. elide codegen if the ancestor doesn't need it (non-root instantiation of ancestor incl. subtree)\n+            if (tinst)\n             {\n-                minst = tnext.minst; // cache result\n-                assert(!minst.isRoot());\n+                const needsCodegen = tinst.needsCodegen(); // sets tinst.minst\n+                if (tinst.minst) // not speculative\n+                {\n+                    minst = tinst.minst; // cache result\n+                    return needsCodegen;\n+                }\n+            }\n+\n+            // Elide codegen if `this` doesn't need it.\n+            if (minst && !minst.isRoot() && !minst.rootImports())\n                 return false;\n+\n+            // Elide codegen if a (non-speculative) sibling doesn't need it.\n+            if (tnext)\n+            {\n+                const needsCodegen = tnext.needsCodegen(); // sets tnext.minst\n+                if (tnext.minst) // not speculative\n+                {\n+                    if (!needsCodegen)\n+                    {\n+                        minst = tnext.minst; // cache result\n+                        assert(!minst.isRoot() && !minst.rootImports());\n+                        return false;\n+                    }\n+                    else if (!minst)\n+                    {\n+                        minst = tnext.minst; // cache result from non-speculative sibling\n+                        return true;\n+                    }\n+                }\n             }\n \n-            // Do codegen because this is not included in non-root instances.\n-            return true;\n+            // Unless `this` is still speculative (=> all further siblings speculative too),\n+            // do codegen because we found no guaranteed-codegen'd non-root instantiation.\n+            return minst !is null;\n         }\n     }\n \n@@ -7311,7 +7288,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                 if ((td && td.literal) || (ti && ti.enclosing) || (d && !d.isDataseg() && !(d.storage_class & STC.manifest) && (!d.isFuncDeclaration() || d.isFuncDeclaration().isNested()) && !isTemplateMixin()))\n                 {\n                     Dsymbol dparent = sa.toParent2();\n-                    if (!dparent)\n+                    if (!dparent || dparent.isModule)\n                         goto L1;\n                     else if (!enclosing)\n                         enclosing = dparent;\n@@ -7370,13 +7347,6 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n     {\n         Module mi = minst; // instantiated . inserted module\n \n-        if (global.params.useUnitTests)\n-        {\n-            // Turn all non-root instances to speculative\n-            if (mi && !mi.isRoot())\n-                mi = null;\n-        }\n-\n         //printf(\"%s.appendToModuleMember() enclosing = %s mi = %s\\n\",\n         //    toPrettyChars(),\n         //    enclosing ? enclosing.toPrettyChars() : null,"}, {"sha": "5871ada466d3e860a502d77c01afad2b70eab736", "filename": "gcc/d/dmd/dtoh.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdtoh.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fdtoh.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtoh.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -16,6 +16,7 @@ import core.stdc.string;\n import core.stdc.ctype;\n \n import dmd.astcodegen;\n+import dmd.astenums;\n import dmd.arraytypes;\n import dmd.attrib;\n import dmd.dsymbol;"}, {"sha": "d2a90609c1628755a76ae46cf5578be317d4666c", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 6, "deletions": 29, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -691,11 +691,8 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n             }\n \n             // If va's lifetime encloses v's, then error\n-            if (va &&\n-                (va.enclosesLifetimeOf(v) && !(v.storage_class & (STC.parameter | STC.temp)) ||\n-                 // va is class reference\n-                 ae.e1.isDotVarExp() && va.type.toBasetype().isTypeClass() && (va.enclosesLifetimeOf(v) ||\n-                 !va.isScope()) ||\n+            if (va && !va.isDataseg() &&\n+                (va.enclosesLifetimeOf(v) && !(v.storage_class & STC.temp) ||\n                  vaIsRef ||\n                  va.isReference() && !(v.storage_class & (STC.parameter | STC.temp))) &&\n                 fd.setUnsafe())\n@@ -768,7 +765,6 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag)\n         }\n     }\n \n-ByRef:\n     foreach (VarDeclaration v; er.byref)\n     {\n         if (log) printf(\"byref: %s\\n\", v.toChars());\n@@ -797,8 +793,7 @@ ByRef:\n \n         // If va's lifetime encloses v's, then error\n         if (va &&\n-            (va.enclosesLifetimeOf(v) && !(v.isParameter() && v.isRef()) ||\n-             va.isDataseg()) &&\n+            (va.enclosesLifetimeOf(v) || (va.isRef() && !(va.storage_class & STC.temp)) || va.isDataseg()) &&\n             fd.setUnsafe())\n         {\n             if (!gag)\n@@ -807,26 +802,6 @@ ByRef:\n             continue;\n         }\n \n-        if (va && v.isReference())\n-        {\n-            Dsymbol pva = va.toParent2();\n-            for (Dsymbol pv = p; pv; )\n-            {\n-                pv = pv.toParent2();\n-                if (pva == pv)  // if v is nested inside pva\n-                {\n-                    if (fd.setUnsafe())\n-                    {\n-                        if (!gag)\n-                            error(ae.loc, \"reference `%s` assigned to `%s` with longer lifetime\", v.toChars(), va.toChars());\n-                        result = true;\n-                        continue ByRef;\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n         if (!(va && va.isScope()))\n             notMaybeScope(v);\n \n@@ -1323,7 +1298,9 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                     msg = \"returning `%s` escapes a reference to parameter `%s`\";\n                     supplemental = vsr == ScopeRef.Ref_ReturnScope\n                                               ? \"perhaps remove `scope` parameter annotation so `return` applies to `ref`\"\n-                                              : \"perhaps annotate the parameter with `return`\";\n+                                              : v.ident is Id.This\n+                                                    ? \"perhaps annotate the function with `return`\"\n+                                                    : \"perhaps annotate the parameter with `return`\";\n                 }\n                 else\n                 {"}, {"sha": "4258e9ba49ecd9f7ab48c33ad5aa706683f86bd1", "filename": "gcc/d/dmd/expression.d", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fexpression.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fexpression.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -25,7 +25,6 @@ import dmd.arraytypes;\n import dmd.astenums;\n import dmd.ast_node;\n import dmd.gluelayer;\n-import dmd.canthrow;\n import dmd.constfold;\n import dmd.ctfeexpr;\n import dmd.ctorflow;\n@@ -466,7 +465,17 @@ private Expression callCpCtor(Scope* sc, Expression e, Type destinationType)\n              */\n             auto tmp = copyToTemp(STC.rvalue, \"__copytmp\", e);\n             if (sd.hasCopyCtor && destinationType)\n-                tmp.type = destinationType;\n+            {\n+                // https://issues.dlang.org/show_bug.cgi?id=22619\n+                // If the destination type is inout we can preserve it\n+                // only if inside an inout function; if we are not inside\n+                // an inout function, then we will preserve the type of\n+                // the source\n+                if (destinationType.hasWild && !(sc.func.storage_class & STC.wild))\n+                    tmp.type = e.type;\n+                else\n+                    tmp.type = destinationType;\n+            }\n             tmp.storage_class |= STC.nodtor;\n             tmp.dsymbolSemantic(sc);\n             Expression de = new DeclarationExp(e.loc, tmp);\n@@ -4680,6 +4689,31 @@ extern (C++) final class AssertExp : UnaExp\n     }\n }\n \n+/***********************************************************\n+ * `throw <e1>` as proposed by DIP 1034.\n+ *\n+ * Replacement for the deprecated `ThrowStatement` that can be nested\n+ * in other expression.\n+ */\n+extern (C++) final class ThrowExp : UnaExp\n+{\n+    extern (D) this(const ref Loc loc, Expression e)\n+    {\n+        super(loc, EXP.throw_, __traits(classInstanceSize, ThrowExp), e);\n+        this.type = Type.tnoreturn;\n+    }\n+\n+    override ThrowExp syntaxCopy()\n+    {\n+        return new ThrowExp(loc, e1.syntaxCopy());\n+    }\n+\n+    override void accept(Visitor v)\n+    {\n+        v.visit(this);\n+    }\n+}\n+\n /***********************************************************\n  */\n extern (C++) final class DotIdExp : UnaExp"}, {"sha": "18ef90a56a7f6116fd8d3a20f417fb0d811e9205", "filename": "gcc/d/dmd/expression.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fexpression.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fexpression.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -48,7 +48,9 @@ struct Symbol;          // back end symbol\n void expandTuples(Expressions *exps);\n bool isTrivialExp(Expression *e);\n bool hasSideEffect(Expression *e, bool assumeImpureCalls = false);\n-bool canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow);\n+\n+enum BE : int32_t;\n+BE canThrow(Expression *e, FuncDeclaration *func, bool mustNotThrow);\n \n typedef unsigned char OwnedBy;\n enum\n@@ -742,6 +744,14 @@ class AssertExp : public UnaExp\n     void accept(Visitor *v) { v->visit(this); }\n };\n \n+class ThrowExp : public UnaExp\n+{\n+public:\n+    ThrowExp *syntaxCopy();\n+\n+    void accept(Visitor *v) { v->visit(this); }\n+};\n+\n class DotIdExp : public UnaExp\n {\n public:"}, {"sha": "6eda688807750e7d2aceb09ec52a2261bfad682b", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 93, "deletions": 17, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3604,16 +3604,21 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 {\n                     if (!cdthis)\n                     {\n+                        if (!sc.hasThis)\n+                        {\n+                            string msg = \"cannot construct \" ~\n+                            (cd.isAnonymous ? \"anonymous nested class\" : \"nested class `%s`\") ~\n+                            \" because no implicit `this` reference to outer class\" ~\n+                            (cdn.isAnonymous ? \"\" : \" `%s`\") ~ \" is available\\0\";\n+\n+                            exp.error(msg.ptr, cd.toChars, cdn.toChars);\n+                            return setError();\n+                        }\n+\n                         // Supply an implicit 'this' and try again\n                         exp.thisexp = new ThisExp(exp.loc);\n                         for (Dsymbol sp = sc.parent; 1; sp = sp.toParentLocal())\n                         {\n-                            if (!sp)\n-                            {\n-                                exp.error(\"outer class `%s` `this` needed to `new` nested class `%s`\",\n-                                    cdn.toChars(), cd.toChars());\n-                                return setError();\n-                            }\n                             ClassDeclaration cdp = sp.isClassDeclaration();\n                             if (!cdp)\n                                 continue;\n@@ -5702,12 +5707,6 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     || global.params.useDeprecated != DiagnosticReporting.error;\n                 const bool preventAliasThis = e.targ.hasDeprecatedAliasThis && !deprecationAllowed;\n \n-                // baseClass might not be set if either targ or tspec is forward referenced.\n-                if (auto tc = e.targ.isTypeClass())\n-                    tc.sym.dsymbolSemantic(null);\n-                if (auto tc = e.tspec.isTypeClass())\n-                    tc.sym.dsymbolSemantic(null);\n-\n                 if (preventAliasThis && e.targ.ty == Tstruct)\n                 {\n                     if ((cast(TypeStruct) e.targ).implicitConvToWithoutAliasThis(e.tspec))\n@@ -6396,6 +6395,16 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             : Expression.combine(temporariesPrefix, exp).expressionSemantic(sc);\n     }\n \n+    override void visit(ThrowExp te)\n+    {\n+        import dmd.statementsem;\n+\n+        if (StatementSemanticVisitor.throwSemantic(te.loc, te.e1, sc))\n+            result = te;\n+        else\n+            setError();\n+    }\n+\n     override void visit(DotIdExp exp)\n     {\n         static if (LOGSEMANTIC)\n@@ -6913,6 +6922,18 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             exp.error(\"cannot take address of `%s`\", exp.e1.toChars());\n             return setError();\n         }\n+        if (auto dve = exp.e1.isDotVarExp())\n+        {\n+            /* https://issues.dlang.org/show_bug.cgi?id=22749\n+             * Error about taking address of any bit-field, regardless of\n+             * whether SCOPE.Cfile is set.\n+             */\n+            if (auto bf = dve.var.isBitFieldDeclaration())\n+            {\n+                exp.error(\"cannot take address of bit-field `%s`\", bf.toChars());\n+                return setError();\n+            }\n+        }\n \n         bool hasOverloads;\n         if (auto f = isFuncAddress(exp, &hasOverloads))\n@@ -7511,6 +7532,17 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         // https://issues.dlang.org/show_bug.cgi?id=19954\n         if (exp.e1.type.ty == Ttuple)\n         {\n+            if (exp.to)\n+            {\n+                if (TypeTuple tt = exp.to.isTypeTuple())\n+                {\n+                    if (exp.e1.type.implicitConvTo(tt))\n+                    {\n+                        result = exp.e1.castTo(sc, tt);\n+                        return;\n+                    }\n+                }\n+            }\n             TupleExp te = exp.e1.isTupleExp();\n             if (te.exps.dim == 1)\n                 exp.e1 = (*te.exps)[0];\n@@ -7531,7 +7563,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n         if (exp.to.ty == Ttuple)\n         {\n-            exp.error(\"cannot cast `%s` to tuple type `%s`\", exp.e1.toChars(), exp.to.toChars());\n+            exp.error(\"cannot cast `%s` of type `%s` to tuple type `%s`\", exp.e1.toChars(), exp.e1.type.toChars(), exp.to.toChars());\n             return setError();\n         }\n \n@@ -8016,7 +8048,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 Expression el = new ArrayLengthExp(exp.loc, exp.e1);\n                 el = el.expressionSemantic(sc);\n                 el = el.optimize(WANTvalue);\n-                if (el.op == EXP.int64)\n+                if (el.op == EXP.int64 && t1b.ty == Tsarray)\n                 {\n                     // Array length is known at compile-time. Upper is in bounds if it fits length.\n                     dinteger_t length = el.toInteger();\n@@ -9894,7 +9926,6 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 Expression id = new IdentifierExp(exp.loc, Id.empty);\n                 id = new DotIdExp(exp.loc, id, Id.object);\n                 id = new DotIdExp(exp.loc, id, func);\n-                id = id.expressionSemantic(sc);\n \n                 auto arguments = new Expressions();\n                 arguments.push(new CastExp(ae.loc, ae.e1, ae.e1.type.nextOf.arrayOf).expressionSemantic(sc));\n@@ -11355,7 +11386,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n         }\n \n-        EXP cmpop;\n+\n+        EXP cmpop = exp.op;\n         if (auto e = exp.op_overload(sc, &cmpop))\n         {\n             if (!e.type.isscalar() && e.type.equals(exp.e1.type))\n@@ -11365,13 +11397,46 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             }\n             if (e.op == EXP.call)\n             {\n+\n+                if (t1.ty == Tclass && t2.ty == Tclass)\n+                {\n+                    // Lower to object.__cmp(e1, e2)\n+                    Expression cl = new IdentifierExp(exp.loc, Id.empty);\n+                    cl = new DotIdExp(exp.loc, cl, Id.object);\n+                    cl = new DotIdExp(exp.loc, cl, Id.__cmp);\n+                    cl = cl.expressionSemantic(sc);\n+\n+                    auto arguments = new Expressions();\n+                    // Check if op_overload found a better match by calling e2.opCmp(e1)\n+                    // If the operands were swapped, then the result must be reversed\n+                    // e1.opCmp(e2) == -e2.opCmp(e1)\n+                    // cmpop takes care of this\n+                    if (exp.op == cmpop)\n+                    {\n+                        arguments.push(exp.e1);\n+                        arguments.push(exp.e2);\n+                    }\n+                    else\n+                    {\n+                        // Use better match found by op_overload\n+                        arguments.push(exp.e2);\n+                        arguments.push(exp.e1);\n+                    }\n+\n+                    cl = new CallExp(exp.loc, cl, arguments);\n+                    cl = new CmpExp(cmpop, exp.loc, cl, new IntegerExp(0));\n+                    result = cl.expressionSemantic(sc);\n+                    return;\n+                }\n+\n                 e = new CmpExp(cmpop, exp.loc, e, IntegerExp.literal!0);\n                 e = e.expressionSemantic(sc);\n             }\n             result = e;\n             return;\n         }\n \n+\n         if (Expression ex = typeCombine(exp, sc))\n         {\n             result = ex;\n@@ -13213,7 +13278,16 @@ Expression getVarExp(EnumMember em, const ref Loc loc, Scope* sc)\n     if (em.errors)\n         return ErrorExp.get();\n     Expression e = new VarExp(loc, em);\n-    return e.expressionSemantic(sc);\n+    e = e.expressionSemantic(sc);\n+    if (!(sc.flags & SCOPE.Cfile) && em.isCsymbol())\n+    {\n+        /* C11 types them as int. But if in D file,\n+         * type qualified names as the enum\n+         */\n+        e.type = em.parent.isEnumDeclaration().type;\n+        assert(e.type);\n+    }\n+    return e;\n }\n \n \n@@ -13245,6 +13319,8 @@ Expression toBoolean(Expression exp, Scope* sc)\n         case EXP.assign:\n         case EXP.construct:\n         case EXP.blit:\n+            if (sc.flags & SCOPE.Cfile)\n+                return exp;\n             // Things like:\n             //  if (a = b) ...\n             // are usually mistakes."}, {"sha": "f3aeb0ff3dcd3867399a9530bc4f34239ff71fbe", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3052,7 +3052,7 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n         // all of overloads are templates\n         if (td)\n         {\n-            .error(loc, \"%s `%s.%s` cannot deduce function from argument types `!(%s)%s`\",\n+            .error(loc, \"none of the overloads of %s `%s.%s` are callable using argument types `!(%s)%s`\",\n                    td.kind(), td.parent.toPrettyChars(), td.ident.toChars(),\n                    tiargsBuf.peekChars(), fargsBuf.peekChars());\n "}, {"sha": "eccd1ee183dfe7ac0ee93de38ee03bdbcbfbe0d8", "filename": "gcc/d/dmd/globals.d", "status": "modified", "additions": 1, "deletions": 43, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fglobals.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fglobals.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -327,6 +327,7 @@ extern (C++) struct Global\n     Array!Identifier* debugids;   /// command line debug versions and predefined versions\n \n     bool hasMainFunction; /// Whether a main function has already been compiled in (for -main switch)\n+    uint varSequenceNumber = 1; /// Relative lifetime of `VarDeclaration` within a function, used for `scope` checks\n \n     enum recursionLimit = 500; /// number of recursive template expansions before abort\n \n@@ -614,48 +615,5 @@ nothrow:\n     }\n }\n \n-/// A linkage attribute as defined by `extern(XXX)`\n-///\n-/// https://dlang.org/spec/attribute.html#linkage\n-enum LINK : ubyte\n-{\n-    default_,\n-    d,\n-    c,\n-    cpp,\n-    windows,\n-    objc,\n-    system,\n-}\n-\n-/// Whether to mangle an external aggregate as a struct or class, as set by `extern(C++, struct)`\n-enum CPPMANGLE : ubyte\n-{\n-    def,      /// default\n-    asStruct, /// `extern(C++, struct)`\n-    asClass,  /// `extern(C++, class)`\n-}\n-\n-/// Function match levels\n-///\n-/// https://dlang.org/spec/function.html#function-overloading\n-enum MATCH : int\n-{\n-    nomatch,   /// no match\n-    convert,   /// match with conversions\n-    constant,  /// match with conversion to const\n-    exact,     /// exact match\n-}\n-\n-/// Inline setting as defined by `pragma(inline, XXX)`\n-enum PINLINE : ubyte\n-{\n-    default_, /// as specified on the command line\n-    never,    /// never inline\n-    always,   /// always inline\n-}\n-\n-alias StorageClass = ulong;\n-\n /// Collection of global state\n extern (C++) __gshared Global global;"}, {"sha": "49fa5b98e9548ce5d4aeed71699d436f474b291f", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -290,6 +290,7 @@ struct Global\n     Array<class Identifier*>* debugids;   // command line debug versions and predefined versions\n \n     bool hasMainFunction;\n+    unsigned varSequenceNumber;\n \n     /* Start gagging. Return the current number of gagged errors\n      */"}, {"sha": "43b63f147ce7e097c41d68ea2e5e82b030bca381", "filename": "gcc/d/dmd/hdrgen.d", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fhdrgen.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fhdrgen.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2364,6 +2364,12 @@ public:\n         buf.writeByte(')');\n     }\n \n+    override void visit(ThrowExp e)\n+    {\n+        buf.writestring(\"throw \");\n+        expToBuffer(e.e1, PREC.unary, buf, hgs);\n+    }\n+\n     override void visit(DotIdExp e)\n     {\n         expToBuffer(e.e1, PREC.primary, buf, hgs);\n@@ -3896,6 +3902,11 @@ private void typeToBufferx(Type t, OutBuffer* buf, HdrGenState* hgs)\n         buf.writeByte(' ');\n         if (t.id)\n             buf.writestring(t.id.toChars());\n+        if (t.base.ty != TY.Tint32)\n+        {\n+            buf.writestring(\" : \");\n+            visitWithMask(t.base, t.mod, buf, hgs);\n+        }\n     }\n \n     void visitTuple(TypeTuple t)"}, {"sha": "7f51e929ad4dd018489a8ed3148c2a67fb4e62d9", "filename": "gcc/d/dmd/id.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fid.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -478,6 +478,7 @@ immutable Msgtable[] msgtable =\n     { \"hasCopyConstructor\" },\n     { \"isCopyable\" },\n     { \"toType\" },\n+    { \"parameters\" },\n \n     // For C++ mangling\n     { \"allocator\" },\n@@ -507,12 +508,11 @@ immutable Msgtable[] msgtable =\n     { \"__func__\" },\n     { \"noreturn\" },\n     { \"__pragma\", \"pragma\" },\n+    { \"builtins\", \"__builtins\" },\n     { \"builtin_va_list\", \"__builtin_va_list\" },\n-    { \"builtin_va_start\", \"__builtin_va_start\" },\n     { \"builtin_va_arg\", \"__builtin_va_arg\" },\n-    { \"builtin_va_copy\", \"__builtin_va_copy\" },\n-    { \"builtin_va_end\", \"__builtin_va_end\" },\n     { \"va_list_tag\", \"__va_list_tag\" },\n+    { \"va_arg\" },\n     { \"pack\" },\n     { \"show\" },\n     { \"push\" },"}, {"sha": "3183c8dbb79a4dfeac8b4f22df49f9b5e31f6f36", "filename": "gcc/d/dmd/json.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -302,8 +302,7 @@ public:\n             //property(name, \"impure\");\n             break;\n         case PURE.weak:     return property(name, \"weak\");\n-        case PURE.const_:   return property(name, \"const\");\n-        case PURE.strong:   return property(name, \"strong\");\n+        case PURE.const_:   return property(name, \"strong\");\n         case PURE.fwdref:   return property(name, \"fwdref\");\n         }\n     }"}, {"sha": "fefad2823fe9256e33807e572e911f2728a87c16", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 72, "deletions": 80, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -230,6 +230,57 @@ bool isSomeChar(TY ty) pure nothrow @nogc @safe\n     return ty == Tchar || ty == Twchar || ty == Tdchar;\n }\n \n+/************************************\n+ * Determine mutability of indirections in (ref) t.\n+ *\n+ * Returns: When the type has any mutable indirections, returns 0.\n+ * When all indirections are immutable, returns 2.\n+ * Otherwise, when the type has const/inout indirections, returns 1.\n+ *\n+ * Params:\n+ *      isref = if true, check `ref t`; otherwise, check just `t`\n+ *      t = the type that is being checked\n+ */\n+int mutabilityOfType(bool isref, Type t)\n+{\n+    if (isref)\n+    {\n+        if (t.mod & MODFlags.immutable_)\n+            return 2;\n+        if (t.mod & (MODFlags.const_ | MODFlags.wild))\n+            return 1;\n+        return 0;\n+    }\n+\n+    t = t.baseElemOf();\n+\n+    if (!t.hasPointers() || t.mod & MODFlags.immutable_)\n+        return 2;\n+\n+    /* Accept immutable(T)[] and immutable(T)* as being strongly pure\n+     */\n+    if (t.ty == Tarray || t.ty == Tpointer)\n+    {\n+        Type tn = t.nextOf().toBasetype();\n+        if (tn.mod & MODFlags.immutable_)\n+            return 2;\n+        if (tn.mod & (MODFlags.const_ | MODFlags.wild))\n+            return 1;\n+    }\n+\n+    /* The rest of this is too strict; fix later.\n+     * For example, the only pointer members of a struct may be immutable,\n+     * which would maintain strong purity.\n+     * (Just like for dynamic arrays and pointers above.)\n+     */\n+    if (t.mod & (MODFlags.const_ | MODFlags.wild))\n+        return 1;\n+\n+    /* Should catch delegates and function pointers, and fold in their purity\n+     */\n+    return 0;\n+}\n+\n /****************\n  * dotExp() bit flags\n  */\n@@ -4217,54 +4268,11 @@ extern (C++) final class TypeFunction : TypeNext\n         if (tf.purity != PURE.fwdref)\n             return;\n \n-        /* Determine purity level based on mutability of t\n-         * and whether it is a 'ref' type or not.\n-         */\n-        static PURE purityOfType(bool isref, Type t)\n-        {\n-            if (isref)\n-            {\n-                if (t.mod & MODFlags.immutable_)\n-                    return PURE.strong;\n-                if (t.mod & (MODFlags.const_ | MODFlags.wild))\n-                    return PURE.const_;\n-                return PURE.weak;\n-            }\n-\n-            t = t.baseElemOf();\n-\n-            if (!t.hasPointers() || t.mod & MODFlags.immutable_)\n-                return PURE.strong;\n-\n-            /* Accept immutable(T)[] and immutable(T)* as being strongly pure\n-             */\n-            if (t.ty == Tarray || t.ty == Tpointer)\n-            {\n-                Type tn = t.nextOf().toBasetype();\n-                if (tn.mod & MODFlags.immutable_)\n-                    return PURE.strong;\n-                if (tn.mod & (MODFlags.const_ | MODFlags.wild))\n-                    return PURE.const_;\n-            }\n-\n-            /* The rest of this is too strict; fix later.\n-             * For example, the only pointer members of a struct may be immutable,\n-             * which would maintain strong purity.\n-             * (Just like for dynamic arrays and pointers above.)\n-             */\n-            if (t.mod & (MODFlags.const_ | MODFlags.wild))\n-                return PURE.const_;\n-\n-            /* Should catch delegates and function pointers, and fold in their purity\n-             */\n-            return PURE.weak;\n-        }\n-\n-        purity = PURE.strong; // assume strong until something weakens it\n+        purity = PURE.const_; // assume strong until something weakens it\n \n         /* Evaluate what kind of purity based on the modifiers for the parameters\n          */\n-    Lloop: foreach (i, fparam; tf.parameterList)\n+        foreach (i, fparam; tf.parameterList)\n         {\n             Type t = fparam.type;\n             if (!t)\n@@ -4275,33 +4283,11 @@ extern (C++) final class TypeFunction : TypeNext\n                 purity = PURE.weak;\n                 break;\n             }\n-            switch (purityOfType((fparam.storageClass & STC.ref_) != 0, t))\n-            {\n-                case PURE.weak:\n-                    purity = PURE.weak;\n-                    break Lloop; // since PURE.weak, no need to check further\n-\n-                case PURE.const_:\n-                    purity = PURE.const_;\n-                    continue;\n-\n-                case PURE.strong:\n-                    continue;\n-\n-                default:\n-                    assert(0);\n-            }\n+            const pref = (fparam.storageClass & STC.ref_) != 0;\n+            if (mutabilityOfType(pref, t) == 0)\n+                purity = PURE.weak;\n         }\n \n-        if (purity > PURE.weak && tf.nextOf())\n-        {\n-            /* Adjust purity based on mutability of return type.\n-             * https://issues.dlang.org/show_bug.cgi?id=15862\n-             */\n-            const purity2 = purityOfType(tf.isref, tf.nextOf());\n-            if (purity2 < purity)\n-                purity = purity2;\n-        }\n         tf.purity = purity;\n     }\n \n@@ -6306,10 +6292,7 @@ extern (C++) final class TypeClass : Type\n \n     extern (D) MATCH implicitConvToWithoutAliasThis(Type to)\n     {\n-        MATCH m = constConv(to);\n-        if (m > MATCH.nomatch)\n-            return m;\n-\n+        // Run semantic before checking whether class is convertible\n         ClassDeclaration cdto = to.isClassHandle();\n         if (cdto)\n         {\n@@ -6318,11 +6301,15 @@ extern (C++) final class TypeClass : Type\n                 cdto.dsymbolSemantic(null);\n             if (sym.semanticRun < PASS.semanticdone && !sym.isBaseInfoComplete())\n                 sym.dsymbolSemantic(null);\n-            if (cdto.isBaseOf(sym, null) && MODimplicitConv(mod, to.mod))\n-            {\n-                //printf(\"'to' is base\\n\");\n-                return MATCH.convert;\n-            }\n+        }\n+        MATCH m = constConv(to);\n+        if (m > MATCH.nomatch)\n+            return m;\n+\n+        if (cdto && cdto.isBaseOf(sym, null) && MODimplicitConv(mod, to.mod))\n+        {\n+            //printf(\"'to' is base\\n\");\n+            return MATCH.convert;\n         }\n         return MATCH.nomatch;\n     }\n@@ -6373,6 +6360,9 @@ extern (C++) final class TypeClass : Type\n \n     override MOD deduceWild(Type t, bool isRef)\n     {\n+        // If sym is forward referenced:\n+        if (sym.semanticRun < PASS.semanticdone && !sym.isBaseInfoComplete())\n+            sym.dsymbolSemantic(null);\n         ClassDeclaration cd = t.isClassHandle();\n         if (cd && (sym == cd || cd.isBaseOf(sym, null)))\n             return Type.deduceWild(t, isRef);\n@@ -6760,19 +6750,21 @@ extern (C++) final class TypeTag : Type\n     Loc loc;                /// location of declaration\n     TOK tok;                /// TOK.struct_, TOK.union_, TOK.enum_\n     Identifier id;          /// tag name identifier\n+    Type base;              /// base type for enums otherwise null\n     Dsymbols* members;      /// members of struct, null if none\n \n     Type resolved;          /// type after semantic() in case there are more others\n                             /// pointing to this instance, which can happen with\n                             ///   struct S { int a; } s1, *s2;\n \n-    extern (D) this(const ref Loc loc, TOK tok, Identifier id, Dsymbols* members)\n+    extern (D) this(const ref Loc loc, TOK tok, Identifier id, Type base, Dsymbols* members)\n     {\n         //printf(\"TypeTag %p\\n\", this);\n         super(Ttag);\n         this.loc = loc;\n         this.tok = tok;\n         this.id = id;\n+        this.base = base;\n         this.members = members;\n     }\n "}, {"sha": "cb6023696eedda08bfc9f444ae43d6314851b5a9", "filename": "gcc/d/dmd/mtype.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fmtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fmtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -553,7 +553,6 @@ enum class PURE : unsigned char\n     fwdref = 1,     // it's pure, but not known which level yet\n     weak = 2,       // no mutable globals are read or written\n     const_ = 3,     // parameters are values or const\n-    strong = 4      // parameters are values or immutable\n };\n \n class Parameter : public ASTNode"}, {"sha": "f25e779a6899a295f992fc467946299817788572", "filename": "gcc/d/dmd/nogc.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fnogc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fnogc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnogc.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -71,6 +71,7 @@ public:\n         if (!e.f)\n             return;\n \n+        // Treat lowered hook calls as their original expressions.\n         auto fd = stripHookTraceImpl(e.f);\n         if (fd.ident == Id._d_arraysetlengthT)\n         {"}, {"sha": "40f2676d88f5e14a2edce7871f1ba45c6903e57f", "filename": "gcc/d/dmd/nspace.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fnspace.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fnspace.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fnspace.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -48,6 +48,7 @@ module dmd.nspace;\n \n import dmd.aggregate;\n import dmd.arraytypes;\n+import dmd.astenums;\n import dmd.dscope;\n import dmd.dsymbol;\n import dmd.dsymbolsem;"}, {"sha": "9e92212ada1bb106c5b62309f65448252b9fe82a", "filename": "gcc/d/dmd/objc.d", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fobjc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fobjc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fobjc.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -818,64 +818,6 @@ extern(C++) private final class Supported : Objc\n         expression.errorSupplemental(\"`tupleof` is not available for members \" ~\n             \"of Objective-C classes. Please use the Objective-C runtime instead\");\n     }\n-\n-extern(D) private:\n-\n-    /**\n-     * Returns `true` if the given symbol is a symbol declared in\n-     * `core.attribute` and has the given identifier.\n-     *\n-     * This is used to determine if a symbol is a UDA declared in\n-     * `core.attribute`.\n-     *\n-     * Params:\n-     *  sd = the symbol to check\n-     *  ident = the name of the expected UDA\n-     */\n-    bool isCoreUda(ScopeDsymbol sd, Identifier ident) const\n-    {\n-        if (sd.ident != ident || !sd.parent)\n-            return false;\n-\n-        auto _module = sd.parent.isModule();\n-        return _module && _module.isCoreModule(Id.attribute);\n-    }\n-\n-    /**\n-     * Iterates the UDAs attached to the given function declaration.\n-     *\n-     * If `dg` returns `!= 0`, it will stop the iteration and return that\n-     * value, otherwise it will return 0.\n-     *\n-     * Params:\n-     *  fd = the function declaration to get the UDAs from\n-     *  dg = called once for each UDA. If `dg` returns `!= 0`, it will stop the\n-     *      iteration and return that value, otherwise it will return `0`.\n-     */\n-    int foreachUda(FuncDeclaration fd, Scope* sc, int delegate(Expression) dg) const\n-    {\n-        if (!fd.userAttribDecl)\n-            return 0;\n-\n-        auto udas = fd.userAttribDecl.getAttributes();\n-        arrayExpressionSemantic(udas, sc, true);\n-\n-        return udas.each!((uda) {\n-            if (!uda.isTupleExp())\n-                return 0;\n-\n-            auto exps = uda.isTupleExp().exps;\n-\n-            return exps.each!((e) {\n-                assert(e);\n-\n-                if (auto result = dg(e))\n-                    return result;\n-\n-                return 0;\n-            });\n-        });\n-    }\n }\n \n /*"}, {"sha": "5d6128b014c98b559bc615ee64f5bc1adc3a4d91", "filename": "gcc/d/dmd/opover.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fopover.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fopover.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fopover.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -853,11 +853,11 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                         {\n                             // Rewrite (e1 op e2) as e2.opfunc(e1)\n                             result = build_overload(e.loc, sc, e.e2, e.e1, m.lastf ? m.lastf : s);\n+                            // When reversing operands of comparison operators,\n+                            // need to reverse the sense of the op\n+                            if (pop)\n+                                *pop = reverseRelation(e.op);\n                         }\n-                        // When reversing operands of comparison operators,\n-                        // need to reverse the sense of the op\n-                        if (pop)\n-                            *pop = reverseRelation(e.op);\n                         return;\n                     }\n                 }\n@@ -1052,7 +1052,7 @@ Expression op_overload(Expression e, Scope* sc, EXP* pop = null)\n                 e.e2 = new DotIdExp(e.loc, e.e2, Id._tupleof);\n \n                 auto sc2 = sc.push();\n-                sc2.flags = (sc2.flags & ~SCOPE.onlysafeaccess) | SCOPE.noaccesscheck;\n+                sc2.flags |= SCOPE.noaccesscheck;\n                 result = e.expressionSemantic(sc2);\n                 sc2.pop();\n "}, {"sha": "5b4ebd78223bef56ec09bd19459ca7c2d8d6dde0", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1130,8 +1130,8 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n             const e1Opt = e.e1.toBool();\n             if (e.e2.isConst())\n             {\n-                bool n1 = e1Opt.hasValue(true);\n-                bool n2 = e.e2.toBool().hasValue(true);\n+                bool n1 = e1Opt.get();\n+                bool n2 = e.e2.toBool().get();\n                 ret = new IntegerExp(e.loc, oror ? (n1 || n2) : (n1 && n2), e.type);\n             }\n             else if (e1Opt.hasValue(!oror))"}, {"sha": "63afeb22a4b44be272c4d4e1e1b1c865d4b4dd59", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 363, "deletions": 242, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -128,6 +128,7 @@ immutable PREC[EXP.max + 1] precedence =\n     EXP.new_ : PREC.unary,\n     EXP.newAnonymousClass : PREC.unary,\n     EXP.cast_ : PREC.unary,\n+    EXP.throw_ : PREC.unary,\n \n     EXP.vector : PREC.unary,\n     EXP.pow : PREC.pow,\n@@ -443,6 +444,13 @@ class Parser(AST) : Lexer\n         }\n \n         decldefs = parseDeclDefs(0, &lastDecl);\n+\n+        if (token.value == TOK.rightCurly)\n+        {\n+            error(token.loc, \"unmatched closing brace\");\n+            goto Lerr;\n+        }\n+\n         if (token.value != TOK.endOfFile)\n         {\n             error(token.loc, \"unrecognized declaration\");\n@@ -643,7 +651,43 @@ class Parser(AST) : Lexer\n                 goto Lerror;\n \n             case TOK.unittest_:\n-                if (global.params.useUnitTests || global.params.doDocComments || global.params.doHdrGeneration)\n+                /**\n+                 * Ignore unittests in non-root modules.\n+                 *\n+                 * This mainly means that unittests *inside templates* are only\n+                 * ever instantiated if the module lexically declaring the\n+                 * template is one of the root modules.\n+                 *\n+                 * E.g., compiling some project with `-unittest` does NOT\n+                 * compile and later run any unittests in instantiations of\n+                 * templates declared in other libraries.\n+                 *\n+                 * Declaring unittests *inside* templates is considered an anti-\n+                 * pattern. In almost all cases, the unittests don't depend on\n+                 * the template parameters, but instantiate the template with\n+                 * fixed arguments (e.g., Nullable!T unittests instantiating\n+                 * Nullable!int), so compiling and running identical tests for\n+                 * each template instantiation is hardly desirable.\n+                 * But adding a unittest right below some function being tested\n+                 * is arguably good for locality, so unittests end up inside\n+                 * templates.\n+                 * To make sure a template's unittests are run, it should be\n+                 * instantiated in the same module, e.g., some module-level\n+                 * unittest.\n+                 *\n+                 * Another reason for ignoring unittests in templates from non-\n+                 * root modules is for template codegen culling via\n+                 * TemplateInstance.needsCodegen(). If the compiler decides not\n+                 * to emit some Nullable!bool because there's an existing\n+                 * instantiation in some non-root module, it has no idea whether\n+                 * that module was compiled with -unittest too, and so whether\n+                 * Nullable!int (instantiated in some unittest inside the\n+                 * Nullable template) can be culled too. By ignoring unittests\n+                 * in non-root modules, the compiler won't consider any\n+                 * template instantiations in these unittests as candidates for\n+                 * further codegen culling.\n+                 */\n+                if (mod.isRoot() && (global.params.useUnitTests || global.params.doDocComments || global.params.doHdrGeneration))\n                 {\n                     s = parseUnitTest(pAttrs);\n                     if (*pLastDecl)\n@@ -1530,6 +1574,8 @@ class Parser(AST) : Lexer\n \n             case TOK.return_:\n                 stc = STC.return_;\n+                if (peekNext() == TOK.scope_)\n+                    stc |= STC.returnScope;     // recognize `return scope`\n                 break;\n \n             case TOK.scope_:\n@@ -2880,7 +2926,7 @@ class Parser(AST) : Lexer\n         StorageClass varargsStc;\n \n         // Attributes allowed for ...\n-        enum VarArgsStc = STC.const_ | STC.immutable_ | STC.shared_ | STC.scope_ | STC.return_;\n+        enum VarArgsStc = STC.const_ | STC.immutable_ | STC.shared_ | STC.scope_ | STC.return_ | STC.returnScope;\n \n         check(TOK.leftParenthesis);\n         while (1)\n@@ -2988,6 +3034,8 @@ class Parser(AST) : Lexer\n \n                 case TOK.return_:\n                     stc = STC.return_;\n+                    if (peekNext() == TOK.scope_)\n+                        stc |= STC.returnScope;\n                     goto L2;\n                 L2:\n                     storageClass = appendStorageClass(storageClass, stc);\n@@ -3491,7 +3539,7 @@ class Parser(AST) : Lexer\n         return baseclasses;\n     }\n \n-    private AST.Dsymbols* parseImport()\n+    AST.Dsymbols* parseImport()\n     {\n         auto decldefs = new AST.Dsymbols();\n         Identifier aliasid = null;\n@@ -4453,7 +4501,6 @@ class Parser(AST) : Lexer\n     private AST.Dsymbols* parseDeclarations(bool autodecl, PrefixAttributes!AST* pAttrs, const(char)* comment)\n     {\n         StorageClass storage_class = STC.undefined_;\n-        TOK tok = TOK.reserved;\n         LINK link = linkage;\n         Loc linkloc = this.linkLoc;\n         bool setAlignment = false;\n@@ -4464,245 +4511,22 @@ class Parser(AST) : Lexer\n         if (!comment)\n             comment = token.blockComment.ptr;\n \n-        /* Look for AliasAssignment:\n-         *   identifier = type;\n+        /* Look for AliasReassignment\n          */\n         if (token.value == TOK.identifier && peekNext() == TOK.assign)\n-        {\n-            const loc = token.loc;\n-            auto ident = token.ident;\n-            nextToken();\n-            nextToken();        // advance past =\n-            auto t = parseType();\n-            AST.Dsymbol s = new AST.AliasAssign(loc, ident, t, null);\n-            check(TOK.semicolon);\n-            addComment(s, comment);\n-            auto a = new AST.Dsymbols();\n-            a.push(s);\n-            return a;\n-        }\n+            return parseAliasReassignment(comment);\n \n+        /* Declarations that start with `alias`\n+         */\n+        bool isAliasDeclaration = false;\n         if (token.value == TOK.alias_)\n         {\n-            const loc = token.loc;\n-            tok = token.value;\n-            nextToken();\n-\n-            /* Look for:\n-             *   alias identifier this;\n-             */\n-            if (token.value == TOK.identifier && peekNext() == TOK.this_)\n-            {\n-                auto s = new AST.AliasThis(loc, token.ident);\n-                nextToken();\n-                check(TOK.this_);\n-                check(TOK.semicolon);\n-                auto a = new AST.Dsymbols();\n-                a.push(s);\n-                addComment(s, comment);\n+            if (auto a = parseAliasDeclarations(comment))\n                 return a;\n-            }\n-            version (none)\n-            {\n-                /* Look for:\n-                 *  alias this = identifier;\n-                 */\n-                if (token.value == TOK.this_ && peekNext() == TOK.assign && peekNext2() == TOK.identifier)\n-                {\n-                    check(TOK.this_);\n-                    check(TOK.assign);\n-                    auto s = new AliasThis(loc, token.ident);\n-                    nextToken();\n-                    check(TOK.semicolon);\n-                    auto a = new Dsymbols();\n-                    a.push(s);\n-                    addComment(s, comment);\n-                    return a;\n-                }\n-            }\n-            /* Look for:\n-             *  alias identifier = type;\n-             *  alias identifier(...) = type;\n+            /* Handle these later:\n+             *   alias StorageClasses type ident;\n              */\n-            if (token.value == TOK.identifier && hasOptionalParensThen(peek(&token), TOK.assign))\n-            {\n-                auto a = new AST.Dsymbols();\n-                while (1)\n-                {\n-                    auto ident = token.ident;\n-                    nextToken();\n-                    AST.TemplateParameters* tpl = null;\n-                    if (token.value == TOK.leftParenthesis)\n-                        tpl = parseTemplateParameterList();\n-                    check(TOK.assign);\n-\n-                    bool hasParsedAttributes;\n-                    void parseAttributes()\n-                    {\n-                        if (hasParsedAttributes) // only parse once\n-                            return;\n-                        hasParsedAttributes = true;\n-                        udas = null;\n-                        storage_class = STC.undefined_;\n-                        link = linkage;\n-                        linkloc = this.linkLoc;\n-                        setAlignment = false;\n-                        ealign = null;\n-                        parseStorageClasses(storage_class, link, setAlignment, ealign, udas, linkloc);\n-                    }\n-\n-                    if (token.value == TOK.at)\n-                        parseAttributes;\n-\n-                    AST.Declaration v;\n-                    AST.Dsymbol s;\n-\n-                    // try to parse function type:\n-                    // TypeCtors? BasicType ( Parameters ) MemberFunctionAttributes\n-                    bool attributesAppended;\n-                    const StorageClass funcStc = parseTypeCtor();\n-                    Token* tlu = &token;\n-                    Token* tk;\n-                    if (token.value != TOK.function_ &&\n-                        token.value != TOK.delegate_ &&\n-                        isBasicType(&tlu) && tlu &&\n-                        tlu.value == TOK.leftParenthesis)\n-                    {\n-                        AST.Type tret = parseBasicType();\n-                        auto parameterList = parseParameterList(null);\n-\n-                        parseAttributes();\n-                        if (udas)\n-                            error(\"user-defined attributes not allowed for `alias` declarations\");\n-\n-                        attributesAppended = true;\n-                        storage_class = appendStorageClass(storage_class, funcStc);\n-                        AST.Type tf = new AST.TypeFunction(parameterList, tret, link, storage_class);\n-                        v = new AST.AliasDeclaration(loc, ident, tf);\n-                    }\n-                    else if (token.value == TOK.function_ ||\n-                        token.value == TOK.delegate_ ||\n-                        token.value == TOK.leftParenthesis &&\n-                            skipAttributes(peekPastParen(&token), &tk) &&\n-                            (tk.value == TOK.goesTo || tk.value == TOK.leftCurly) ||\n-                        token.value == TOK.leftCurly ||\n-                        token.value == TOK.identifier && peekNext() == TOK.goesTo ||\n-                        token.value == TOK.ref_ && peekNext() == TOK.leftParenthesis &&\n-                            skipAttributes(peekPastParen(peek(&token)), &tk) &&\n-                            (tk.value == TOK.goesTo || tk.value == TOK.leftCurly)\n-                       )\n-                    {\n-                        // function (parameters) { statements... }\n-                        // delegate (parameters) { statements... }\n-                        // (parameters) { statements... }\n-                        // (parameters) => expression\n-                        // { statements... }\n-                        // identifier => expression\n-                        // ref (parameters) { statements... }\n-                        // ref (parameters) => expression\n-\n-                        s = parseFunctionLiteral();\n-\n-                        if (udas !is null)\n-                        {\n-                            if (storage_class != 0)\n-                                error(\"Cannot put a storage-class in an alias declaration.\");\n-                            // parseAttributes shouldn't have set these variables\n-                            assert(link == linkage && !setAlignment && ealign is null);\n-                            auto tpl_ = cast(AST.TemplateDeclaration) s;\n-                            assert(tpl_ !is null && tpl_.members.dim == 1);\n-                            auto fd = cast(AST.FuncLiteralDeclaration) (*tpl_.members)[0];\n-                            auto tf = cast(AST.TypeFunction) fd.type;\n-                            assert(tf.parameterList.parameters.dim > 0);\n-                            auto as = new AST.Dsymbols();\n-                            (*tf.parameterList.parameters)[0].userAttribDecl = new AST.UserAttributeDeclaration(udas, as);\n-                        }\n-\n-                        v = new AST.AliasDeclaration(loc, ident, s);\n-                    }\n-                    else\n-                    {\n-                        parseAttributes();\n-                        // type\n-                        if (udas)\n-                            error(\"user-defined attributes not allowed for `%s` declarations\", Token.toChars(tok));\n-\n-                        auto t = parseType();\n-\n-                        // Disallow meaningless storage classes on type aliases\n-                        if (storage_class)\n-                        {\n-                            // Don't raise errors for STC that are part of a function/delegate type, e.g.\n-                            // `alias F = ref pure nothrow @nogc @safe int function();`\n-                            auto tp = t.isTypePointer;\n-                            const isFuncType = (tp && tp.next.isTypeFunction) || t.isTypeDelegate;\n-                            const remStc = isFuncType ? (storage_class & ~STC.FUNCATTR) : storage_class;\n-\n-                            if (remStc)\n-                            {\n-                                OutBuffer buf;\n-                                AST.stcToBuffer(&buf, remStc);\n-                                // @@@DEPRECATED_2.093@@@\n-                                // Deprecated in 2020-07, can be made an error in 2.103\n-                                deprecation(\"storage class `%s` has no effect in type aliases\", buf.peekChars());\n-                            }\n-                        }\n-\n-                        v = new AST.AliasDeclaration(loc, ident, t);\n-                    }\n-                    if (!attributesAppended)\n-                        storage_class = appendStorageClass(storage_class, funcStc);\n-                    v.storage_class = storage_class;\n-\n-                    s = v;\n-                    if (tpl)\n-                    {\n-                        auto a2 = new AST.Dsymbols();\n-                        a2.push(s);\n-                        auto tempdecl = new AST.TemplateDeclaration(loc, ident, tpl, null, a2);\n-                        s = tempdecl;\n-                    }\n-                    if (link != linkage)\n-                    {\n-                        auto a2 = new AST.Dsymbols();\n-                        a2.push(s);\n-                        s = new AST.LinkDeclaration(linkloc, link, a2);\n-                    }\n-                    a.push(s);\n-\n-                    switch (token.value)\n-                    {\n-                    case TOK.semicolon:\n-                        nextToken();\n-                        addComment(s, comment);\n-                        break;\n-\n-                    case TOK.comma:\n-                        nextToken();\n-                        addComment(s, comment);\n-                        if (token.value != TOK.identifier)\n-                        {\n-                            error(\"identifier expected following comma, not `%s`\", token.toChars());\n-                            break;\n-                        }\n-                        if (peekNext() != TOK.assign && peekNext() != TOK.leftParenthesis)\n-                        {\n-                            error(\"`=` expected following identifier\");\n-                            nextToken();\n-                            break;\n-                        }\n-                        continue;\n-\n-                    default:\n-                        error(\"semicolon expected to close `%s` declaration\", Token.toChars(tok));\n-                        break;\n-                    }\n-                    break;\n-                }\n-                return a;\n-            }\n-\n-            // alias StorageClasses type ident;\n+            isAliasDeclaration = true;\n         }\n \n         AST.Type ts;\n@@ -4839,7 +4663,7 @@ class Parser(AST) : Lexer\n             else if (!isThis && (t != AST.Type.terror))\n                 error(\"no identifier for declarator `%s`\", t.toChars());\n \n-            if (tok == TOK.alias_)\n+            if (isAliasDeclaration)\n             {\n                 AST.Declaration v;\n                 AST.Initializer _init = null;\n@@ -4852,7 +4676,7 @@ class Parser(AST) : Lexer\n                  */\n \n                 if (udas)\n-                    error(\"user-defined attributes not allowed for `%s` declarations\", Token.toChars(tok));\n+                    error(\"user-defined attributes not allowed for `alias` declarations\");\n \n                 if (token.value == TOK.assign)\n                 {\n@@ -4901,7 +4725,7 @@ class Parser(AST) : Lexer\n                     continue;\n \n                 default:\n-                    error(\"semicolon expected to close `%s` declaration\", Token.toChars(tok));\n+                    error(\"semicolon expected to close `alias` declaration\");\n                     break;\n                 }\n             }\n@@ -5018,7 +4842,15 @@ class Parser(AST) : Lexer\n                     continue;\n \n                 default:\n-                    error(\"semicolon expected, not `%s`\", token.toChars());\n+                    if (loc.linnum != token.loc.linnum)\n+                    {\n+                        error(\"semicolon needed to end declaration of `%s`, instead of `%s`\", v.toChars(), token.toChars());\n+                        errorSupplemental(loc, \"`%s` declared here\", v.toChars());\n+                    }\n+                    else\n+                    {\n+                        error(\"semicolon needed to end declaration of `%s` instead of `%s`\", v.toChars(), token.toChars());\n+                    }\n                     break;\n                 }\n             }\n@@ -5027,6 +4859,271 @@ class Parser(AST) : Lexer\n         return a;\n     }\n \n+    /********************************\n+     * Parse AliasReassignment:\n+     *   identifier = type;\n+     * Parser is sitting on the identifier.\n+     * https://dlang.org/spec/declaration.html#alias-reassignment\n+     * Params:\n+     *  comment = if not null, comment to attach to symbol\n+     * Returns:\n+     *  array of symbols\n+     */\n+    private AST.Dsymbols* parseAliasReassignment(const(char)* comment)\n+    {\n+        const loc = token.loc;\n+        auto ident = token.ident;\n+        nextToken();\n+        nextToken();        // advance past =\n+        auto t = parseType();\n+        AST.Dsymbol s = new AST.AliasAssign(loc, ident, t, null);\n+        check(TOK.semicolon);\n+        addComment(s, comment);\n+        auto a = new AST.Dsymbols();\n+        a.push(s);\n+        return a;\n+    }\n+\n+    /********************************\n+     * Parse declarations that start with `alias`\n+     * Parser is sitting on the `alias`.\n+     * https://dlang.org/spec/declaration.html#alias\n+     * Params:\n+     *  comment = if not null, comment to attach to symbol\n+     * Returns:\n+     *  array of symbols\n+     */\n+    private AST.Dsymbols* parseAliasDeclarations(const(char)* comment)\n+    {\n+        const loc = token.loc;\n+        nextToken();\n+        Loc linkloc = this.linkLoc;\n+        AST.Expressions* udas;\n+        LINK link = linkage;\n+        StorageClass storage_class = STC.undefined_;\n+        AST.Expression ealign;\n+        bool setAlignment = false;\n+\n+        /* Look for:\n+         *   alias Identifier this;\n+         * https://dlang.org/spec/class.html#alias-this\n+         */\n+        if (token.value == TOK.identifier && peekNext() == TOK.this_)\n+        {\n+            auto s = new AST.AliasThis(loc, token.ident);\n+            nextToken();\n+            check(TOK.this_);\n+            check(TOK.semicolon);\n+            auto a = new AST.Dsymbols();\n+            a.push(s);\n+            addComment(s, comment);\n+            return a;\n+        }\n+        version (none)\n+        {\n+            /* Look for:\n+             *  alias this = identifier;\n+             */\n+            if (token.value == TOK.this_ && peekNext() == TOK.assign && peekNext2() == TOK.identifier)\n+            {\n+                check(TOK.this_);\n+                check(TOK.assign);\n+                auto s = new AliasThis(loc, token.ident);\n+                nextToken();\n+                check(TOK.semicolon);\n+                auto a = new Dsymbols();\n+                a.push(s);\n+                addComment(s, comment);\n+                return a;\n+            }\n+        }\n+        /* Look for:\n+         *  alias identifier = type;\n+         *  alias identifier(...) = type;\n+         * https://dlang.org/spec/declaration.html#alias\n+         */\n+        if (token.value == TOK.identifier && hasOptionalParensThen(peek(&token), TOK.assign))\n+        {\n+            auto a = new AST.Dsymbols();\n+            while (1)\n+            {\n+                auto ident = token.ident;\n+                nextToken();\n+                AST.TemplateParameters* tpl = null;\n+                if (token.value == TOK.leftParenthesis)\n+                    tpl = parseTemplateParameterList();\n+                check(TOK.assign);\n+\n+                bool hasParsedAttributes;\n+                void parseAttributes()\n+                {\n+                    if (hasParsedAttributes) // only parse once\n+                        return;\n+                    hasParsedAttributes = true;\n+                    udas = null;\n+                    storage_class = STC.undefined_;\n+                    link = linkage;\n+                    linkloc = this.linkLoc;\n+                    setAlignment = false;\n+                    ealign = null;\n+                    parseStorageClasses(storage_class, link, setAlignment, ealign, udas, linkloc);\n+                }\n+\n+                if (token.value == TOK.at)\n+                    parseAttributes;\n+\n+                AST.Declaration v;\n+                AST.Dsymbol s;\n+\n+                // try to parse function type:\n+                // TypeCtors? BasicType ( Parameters ) MemberFunctionAttributes\n+                bool attributesAppended;\n+                const StorageClass funcStc = parseTypeCtor();\n+                Token* tlu = &token;\n+                Token* tk;\n+                if (token.value != TOK.function_ &&\n+                    token.value != TOK.delegate_ &&\n+                    isBasicType(&tlu) && tlu &&\n+                    tlu.value == TOK.leftParenthesis)\n+                {\n+                    AST.Type tret = parseBasicType();\n+                    auto parameterList = parseParameterList(null);\n+\n+                    parseAttributes();\n+                    if (udas)\n+                        error(\"user-defined attributes not allowed for `alias` declarations\");\n+\n+                    attributesAppended = true;\n+                    storage_class = appendStorageClass(storage_class, funcStc);\n+                    AST.Type tf = new AST.TypeFunction(parameterList, tret, link, storage_class);\n+                    v = new AST.AliasDeclaration(loc, ident, tf);\n+                }\n+                else if (token.value == TOK.function_ ||\n+                    token.value == TOK.delegate_ ||\n+                    token.value == TOK.leftParenthesis &&\n+                        skipAttributes(peekPastParen(&token), &tk) &&\n+                        (tk.value == TOK.goesTo || tk.value == TOK.leftCurly) ||\n+                    token.value == TOK.leftCurly ||\n+                    token.value == TOK.identifier && peekNext() == TOK.goesTo ||\n+                    token.value == TOK.ref_ && peekNext() == TOK.leftParenthesis &&\n+                        skipAttributes(peekPastParen(peek(&token)), &tk) &&\n+                        (tk.value == TOK.goesTo || tk.value == TOK.leftCurly)\n+                   )\n+                {\n+                    // function (parameters) { statements... }\n+                    // delegate (parameters) { statements... }\n+                    // (parameters) { statements... }\n+                    // (parameters) => expression\n+                    // { statements... }\n+                    // identifier => expression\n+                    // ref (parameters) { statements... }\n+                    // ref (parameters) => expression\n+\n+                    s = parseFunctionLiteral();\n+\n+                    if (udas !is null)\n+                    {\n+                        if (storage_class != 0)\n+                            error(\"Cannot put a storage-class in an alias declaration.\");\n+                        // parseAttributes shouldn't have set these variables\n+                        assert(link == linkage && !setAlignment && ealign is null);\n+                        auto tpl_ = cast(AST.TemplateDeclaration) s;\n+                        assert(tpl_ !is null && tpl_.members.dim == 1);\n+                        auto fd = cast(AST.FuncLiteralDeclaration) (*tpl_.members)[0];\n+                        auto tf = cast(AST.TypeFunction) fd.type;\n+                        assert(tf.parameterList.parameters.dim > 0);\n+                        auto as = new AST.Dsymbols();\n+                        (*tf.parameterList.parameters)[0].userAttribDecl = new AST.UserAttributeDeclaration(udas, as);\n+                    }\n+\n+                    v = new AST.AliasDeclaration(loc, ident, s);\n+                }\n+                else\n+                {\n+                    parseAttributes();\n+                    // type\n+                    if (udas)\n+                        error(\"user-defined attributes not allowed for alias declarations\");\n+\n+                    auto t = parseType();\n+\n+                    // Disallow meaningless storage classes on type aliases\n+                    if (storage_class)\n+                    {\n+                        // Don't raise errors for STC that are part of a function/delegate type, e.g.\n+                        // `alias F = ref pure nothrow @nogc @safe int function();`\n+                        auto tp = t.isTypePointer;\n+                        const isFuncType = (tp && tp.next.isTypeFunction) || t.isTypeDelegate;\n+                        const remStc = isFuncType ? (storage_class & ~STC.FUNCATTR) : storage_class;\n+\n+                        if (remStc)\n+                        {\n+                            OutBuffer buf;\n+                            AST.stcToBuffer(&buf, remStc);\n+                            // @@@DEPRECATED_2.093@@@\n+                            // Deprecated in 2020-07, can be made an error in 2.103\n+                            deprecation(\"storage class `%s` has no effect in type aliases\", buf.peekChars());\n+                        }\n+                    }\n+\n+                    v = new AST.AliasDeclaration(loc, ident, t);\n+                }\n+                if (!attributesAppended)\n+                    storage_class = appendStorageClass(storage_class, funcStc);\n+                v.storage_class = storage_class;\n+\n+                s = v;\n+                if (tpl)\n+                {\n+                    auto a2 = new AST.Dsymbols();\n+                    a2.push(s);\n+                    auto tempdecl = new AST.TemplateDeclaration(loc, ident, tpl, null, a2);\n+                    s = tempdecl;\n+                }\n+                if (link != linkage)\n+                {\n+                    auto a2 = new AST.Dsymbols();\n+                    a2.push(s);\n+                    s = new AST.LinkDeclaration(linkloc, link, a2);\n+                }\n+                a.push(s);\n+\n+                switch (token.value)\n+                {\n+                case TOK.semicolon:\n+                    nextToken();\n+                    addComment(s, comment);\n+                    break;\n+\n+                case TOK.comma:\n+                    nextToken();\n+                    addComment(s, comment);\n+                    if (token.value != TOK.identifier)\n+                    {\n+                        error(\"identifier expected following comma, not `%s`\", token.toChars());\n+                        break;\n+                    }\n+                    if (peekNext() != TOK.assign && peekNext() != TOK.leftParenthesis)\n+                    {\n+                        error(\"`=` expected following identifier\");\n+                        nextToken();\n+                        break;\n+                    }\n+                    continue;\n+\n+                default:\n+                    error(\"semicolon expected to close `alias` declaration\");\n+                    break;\n+                }\n+                break;\n+            }\n+            return a;\n+        }\n+\n+        // alias StorageClasses type ident;\n+        return null;\n+    }\n+\n     private AST.Dsymbol parseFunctionLiteral()\n     {\n         const loc = token.loc;\n@@ -5390,6 +5487,7 @@ class Parser(AST) : Lexer\n         check(TOK.leftParenthesis);\n \n         auto parameters = new AST.Parameters();\n+        Identifier lastai;\n         while (1)\n         {\n             Identifier ai = null;\n@@ -5465,8 +5563,9 @@ class Parser(AST) : Lexer\n             if (token.value == TOK.identifier)\n             {\n                 const tv = peekNext();\n-                if (tv == TOK.comma || tv == TOK.semicolon)\n+                if (tv == TOK.comma || tv == TOK.semicolon || tv == TOK.rightParenthesis)\n                 {\n+                    lastai = token.ident;\n                     ai = token.ident;\n                     at = null; // infer argument type\n                     nextToken();\n@@ -5486,7 +5585,17 @@ class Parser(AST) : Lexer\n             }\n             break;\n         }\n-        check(TOK.semicolon);\n+        if (token.value != TOK.semicolon)\n+        {\n+            error(\"missing `; expression` before `)` of `foreach`\");\n+            nextToken();\n+            if (lastai && parameters.length >= 2)\n+            {\n+                errorSupplemental(loc, \"perhaps the `;` goes before `%s`\", lastai.toChars());\n+            }\n+            return null;\n+        }\n+        nextToken();\n \n         AST.Expression aggr = parseExpression();\n         if (token.value == TOK.slice && parameters.dim == 1)\n@@ -8473,6 +8582,7 @@ LagainStc:\n                 e = new AST.FuncExp(loc, s);\n                 break;\n             }\n+\n         default:\n             error(\"expression expected, not `%s`\", token.toChars());\n         Lerr:\n@@ -8766,6 +8876,17 @@ LagainStc:\n                 e = parsePostExp(e);\n                 break;\n             }\n+        case TOK.throw_:\n+            {\n+                nextToken();\n+                // Deviation from the DIP:\n+                // Parse AssignExpression instead of Expression to avoid conflicts for comma\n+                // separated lists, e.g. function arguments\n+                AST.Expression exp = parseAssignExp();\n+                e = new AST.ThrowExp(loc, exp);\n+                break;\n+            }\n+\n         default:\n             e = parsePrimaryExp();\n             e = parsePostExp(e);"}, {"sha": "7d5e19da9ee349a7757a77b09d81202a885707a8", "filename": "gcc/d/dmd/parsetimevisitor.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparsetimevisitor.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -220,6 +220,7 @@ public:\n     void visit(AST.CallExp e) { visit(cast(AST.UnaExp)e); }\n     void visit(AST.DotIdExp e) { visit(cast(AST.UnaExp)e); }\n     void visit(AST.AssertExp e) { visit(cast(AST.UnaExp)e); }\n+    void visit(AST.ThrowExp e) { visit(cast(AST.UnaExp)e); }\n     void visit(AST.ImportExp e) { visit(cast(AST.UnaExp)e); }\n     void visit(AST.DotTemplateInstanceExp e) { visit(cast(AST.UnaExp)e); }\n     void visit(AST.ArrayExp e) { visit(cast(AST.UnaExp)e); }"}, {"sha": "464f338912728ee7895982ddb8488c74cd26c4de", "filename": "gcc/d/dmd/root/README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Froot%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2FREADME.md?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -13,6 +13,7 @@\n | [hash.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/hash.d)               | Calculate a hash for a byte array                                                          |\n | [longdouble.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/longdouble.d)   | 80-bit floating point number implementation in case they are not natively supported        |\n | [man.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/man.d)                 | Opens an online manual page                                                                |\n+| [optional.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/optional.d)       | Implementation of an 'Optional' type                                                       |\n | [port.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/port.d)               | Portable routines for functions that have different implementations on different platforms |\n | [region.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/region.d)           | A region allocator                                                                         |\n | [response.d](https://github.com/dlang/dmd/blob/master/src/dmd/root/response.d)       | Parse command line arguments from response files                                           |"}, {"sha": "f2f7389efd26efb76484e39b498f0674973781a9", "filename": "gcc/d/dmd/root/optional.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Froot%2Foptional.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Froot%2Foptional.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foptional.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /**\n- * Optional implementation.\n+ * Implementation of an 'Optional' type\n  *\n  * Copyright:   Copyright (C) 1999-2022 by The D Language Foundation, All Rights Reserved\n  * Authors:     $(LINK2 https://www.digitalmars.com, Walter Bright)"}, {"sha": "5691f3b75b627e8cd4523cea9300e6c31fcf5c72", "filename": "gcc/d/dmd/sideeffect.d", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fsideeffect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fsideeffect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsideeffect.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -94,8 +94,9 @@ extern (C++) bool hasSideEffect(Expression e, bool assumeImpureCalls = false)\n  * Determine if the call of f, or function type or delegate type t1, has any side effects.\n  * Returns:\n  *      0   has any side effects\n- *      1   nothrow + constant purity\n- *      2   nothrow + strong purity\n+ *      1   nothrow + strongly pure\n+ *      2   nothrow + strongly pure + only immutable indirections in the return\n+ *          type\n  */\n int callSideEffectLevel(FuncDeclaration f)\n {\n@@ -106,15 +107,18 @@ int callSideEffectLevel(FuncDeclaration f)\n         return 0;\n     assert(f.type.ty == Tfunction);\n     TypeFunction tf = cast(TypeFunction)f.type;\n-    if (tf.isnothrow)\n+    if (!tf.isnothrow)\n+        return 0;\n+    final switch (f.isPure())\n     {\n-        PURE purity = f.isPure();\n-        if (purity == PURE.strong)\n-            return 2;\n-        if (purity == PURE.const_)\n-            return 1;\n+    case PURE.impure:\n+    case PURE.fwdref:\n+    case PURE.weak:\n+        return 0;\n+\n+    case PURE.const_:\n+        return mutabilityOfType(tf.isref, tf.next) == 2 ? 2 : 1;\n     }\n-    return 0;\n }\n \n int callSideEffectLevel(Type t)\n@@ -141,10 +145,9 @@ int callSideEffectLevel(Type t)\n             purity = PURE.const_;\n     }\n \n-    if (purity == PURE.strong)\n-        return 2;\n     if (purity == PURE.const_)\n-        return 1;\n+        return mutabilityOfType(tf.isref, tf.next) == 2 ? 2 : 1;\n+\n     return 0;\n }\n \n@@ -178,6 +181,7 @@ private bool lambdaHasSideEffect(Expression e, bool assumeImpureCalls = false)\n     case EXP.remove:\n     case EXP.assert_:\n     case EXP.halt:\n+    case EXP.throw_:\n     case EXP.delete_:\n     case EXP.new_:\n     case EXP.newAnonymousClass:"}, {"sha": "8b271f8862fd7d12812fb70835f5c756896c7c80", "filename": "gcc/d/dmd/statement.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstatement.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstatement.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -21,7 +21,6 @@ import dmd.arraytypes;\n import dmd.astenums;\n import dmd.ast_node;\n import dmd.gluelayer;\n-import dmd.canthrow;\n import dmd.cond;\n import dmd.dclass;\n import dmd.declaration;"}, {"sha": "66eddd8ab5580a883ab439ec572ec85f79f6400b", "filename": "gcc/d/dmd/statement.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstatement.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstatement.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatement.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -45,7 +45,7 @@ struct code;\n \n /* How a statement exits; this is returned by blockExit()\n  */\n-enum BE\n+enum BE : int32_t\n {\n     BEnone =     0,\n     BEfallthru = 1,"}, {"sha": "1f7f3e4bc806c7903ffb0780f87afc5642f93c85", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -122,8 +122,10 @@ private LabelStatement checkLabeledLoop(Scope* sc, Statement statement)\n  * Returns:\n  *  `e` or ErrorExp.\n  */\n-private Expression checkAssignmentAsCondition(Expression e)\n+private Expression checkAssignmentAsCondition(Expression e, Scope* sc)\n {\n+    if (sc.flags & SCOPE.Cfile)\n+        return e;\n     auto ec = lastComma(e);\n     if (ec.op == EXP.assign)\n     {\n@@ -148,7 +150,7 @@ extern(C++) Statement statementSemantic(Statement s, Scope* sc)\n     return v.result;\n }\n \n-private extern (C++) final class StatementSemanticVisitor : Visitor\n+package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n {\n     alias visit = Visitor.visit;\n \n@@ -550,7 +552,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n             (cast(DotIdExp)ds.condition).noderef = true;\n \n         // check in syntax level\n-        ds.condition = checkAssignmentAsCondition(ds.condition);\n+        ds.condition = checkAssignmentAsCondition(ds.condition, sc);\n \n         ds.condition = ds.condition.expressionSemantic(sc);\n         ds.condition = resolveProperties(sc, ds.condition);\n@@ -623,7 +625,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n                 (cast(DotIdExp)fs.condition).noderef = true;\n \n             // check in syntax level\n-            fs.condition = checkAssignmentAsCondition(fs.condition);\n+            fs.condition = checkAssignmentAsCondition(fs.condition, sc);\n \n             fs.condition = fs.condition.expressionSemantic(sc);\n             fs.condition = resolveProperties(sc, fs.condition);\n@@ -1867,7 +1869,7 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n          */\n \n         // check in syntax level\n-        ifs.condition = checkAssignmentAsCondition(ifs.condition);\n+        ifs.condition = checkAssignmentAsCondition(ifs.condition, sc);\n \n         auto sym = new ScopeDsymbol();\n         sym.parent = sc.scopesym;\n@@ -3732,44 +3734,61 @@ private extern (C++) final class StatementSemanticVisitor : Visitor\n          */\n \n         //printf(\"ThrowStatement::semantic()\\n\");\n+        if (throwSemantic(ts.loc, ts.exp, sc))\n+            result = ts;\n+        else\n+            setError();\n+\n+    }\n \n+    /**\n+     * Run semantic on `throw <exp>`.\n+     *\n+     * Params:\n+     *   loc = location of the `throw`\n+     *   exp = value to be thrown\n+     *   sc  = enclosing scope\n+     *\n+     * Returns: true if the `throw` is valid, or false if an error was found\n+     */\n+    extern(D) static bool throwSemantic(const ref Loc loc, ref Expression exp, Scope* sc)\n+    {\n         if (!global.params.useExceptions)\n         {\n-            ts.error(\"Cannot use `throw` statements with -betterC\");\n-            return setError();\n+            loc.error(\"Cannot use `throw` statements with -betterC\");\n+            return false;\n         }\n \n         if (!ClassDeclaration.throwable)\n         {\n-            ts.error(\"Cannot use `throw` statements because `object.Throwable` was not declared\");\n-            return setError();\n+            loc.error(\"Cannot use `throw` statements because `object.Throwable` was not declared\");\n+            return false;\n         }\n \n-        FuncDeclaration fd = sc.parent.isFuncDeclaration();\n-        fd.hasReturnExp |= 2;\n+        if (FuncDeclaration fd = sc.parent.isFuncDeclaration())\n+            fd.hasReturnExp |= 2;\n \n-        if (ts.exp.op == EXP.new_)\n+        if (exp.op == EXP.new_)\n         {\n-            NewExp ne = cast(NewExp)ts.exp;\n+            NewExp ne = cast(NewExp) exp;\n             ne.thrownew = true;\n         }\n \n-        ts.exp = ts.exp.expressionSemantic(sc);\n-        ts.exp = resolveProperties(sc, ts.exp);\n-        ts.exp = checkGC(sc, ts.exp);\n-        if (ts.exp.op == EXP.error)\n-            return setError();\n+        exp = exp.expressionSemantic(sc);\n+        exp = resolveProperties(sc, exp);\n+        exp = checkGC(sc, exp);\n+        if (exp.op == EXP.error)\n+            return false;\n \n-        checkThrowEscape(sc, ts.exp, false);\n+        checkThrowEscape(sc, exp, false);\n \n-        ClassDeclaration cd = ts.exp.type.toBasetype().isClassHandle();\n+        ClassDeclaration cd = exp.type.toBasetype().isClassHandle();\n         if (!cd || ((cd != ClassDeclaration.throwable) && !ClassDeclaration.throwable.isBaseOf(cd, null)))\n         {\n-            ts.error(\"can only throw class objects derived from `Throwable`, not type `%s`\", ts.exp.type.toChars());\n-            return setError();\n+            loc.error(\"can only throw class objects derived from `Throwable`, not type `%s`\", exp.type.toChars());\n+            return false;\n         }\n-\n-        result = ts;\n+        return true;\n     }\n \n     override void visit(DebugStatement ds)"}, {"sha": "0cbdd963afaa3b2d549d179ed2b0ec97740af81a", "filename": "gcc/d/dmd/staticcond.d", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstaticcond.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fstaticcond.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstaticcond.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -109,18 +109,16 @@ bool evalStaticCondition(Scope* sc, Expression original, Expression e, out bool\n         e = e.ctfeInterpret();\n \n         const opt = e.toBool();\n-        if (opt.hasValue(true))\n-            return true;\n-        else if (opt.hasValue(false))\n+        if (opt.isEmpty())\n         {\n-            if (negatives)\n-                negatives.push(before);\n+            e.error(\"expression `%s` is not constant\", e.toChars());\n+            errors = true;\n             return false;\n         }\n \n-        e.error(\"expression `%s` is not constant\", e.toChars());\n-        errors = true;\n-        return false;\n+        if (negatives && !opt.get())\n+            negatives.push(before);\n+        return opt.get();\n     }\n     return impl(e);\n }"}, {"sha": "e95462568af615c7a7bd6424f3d0d3d1a020634d", "filename": "gcc/d/dmd/target.d", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -61,8 +61,8 @@ extern (C++) struct Target\n     import dmd.dscope : Scope;\n     import dmd.expression : Expression;\n     import dmd.func : FuncDeclaration;\n-    import dmd.globals : LINK, Loc, d_int64;\n-    import dmd.astenums : TY;\n+    import dmd.globals : Loc, d_int64;\n+    import dmd.astenums : LINK, TY;\n     import dmd.mtype : Type, TypeFunction, TypeTuple;\n     import dmd.root.ctfloat : real_t;\n     import dmd.statement : Statement;\n@@ -119,7 +119,7 @@ extern (C++) struct Target\n     const(char)[] lib_ext;    /// extension for static library files\n     const(char)[] dll_ext;    /// extension for dynamic library files\n     bool run_noext;           /// allow -run sources without extensions\n-    bool mscoff = false;      // for Win32: write MsCoff object files instead of OMF\n+    bool omfobj = false;      // for Win32: write OMF object files instead of MsCoff\n     /**\n      * Values representing all properties for floating point types\n      */\n@@ -293,6 +293,13 @@ extern (C++) struct Target\n      *      `false` if the target backend handles synchronizing monitors.\n      */\n     extern (C++) bool libraryObjectMonitors(FuncDeclaration fd, Statement fbody);\n+\n+    /**\n+     * Returns true if the target supports `pragma(linkerDirective)`.\n+     * Returns:\n+     *      `false` if the target does not support `pragma(linkerDirective)`.\n+     */\n+    extern (C++) bool supportsLinkerDirective() const;\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -340,7 +347,7 @@ struct TargetCPP\n     import dmd.dsymbol : Dsymbol;\n     import dmd.dclass : ClassDeclaration;\n     import dmd.func : FuncDeclaration;\n-    import dmd.mtype : Parameter, Type;\n+    import dmd.mtype : Type;\n \n     enum Runtime : ubyte\n     {\n@@ -354,6 +361,7 @@ struct TargetCPP\n     bool reverseOverloads;    /// set if overloaded functions are grouped and in reverse order (such as in dmc and cl)\n     bool exceptions;          /// set if catching C++ exceptions is supported\n     bool twoDtorInVtable;     /// target C++ ABI puts deleting and non-deleting destructor into vtable\n+    bool splitVBasetable;     /// set if C++ ABI uses separate tables for virtual functions and virtual bases\n     bool wrapDtorInExternD;   /// set if C++ dtors require a D wrapper to be callable from runtime\n     Runtime runtime;          /// vendor of the C++ runtime to link against\n \n@@ -398,13 +406,13 @@ struct TargetCPP\n \n     /**\n      * Get the type that will really be used for passing the given argument\n-     * to an `extern(C++)` function.\n+     * to an `extern(C++)` function, or `null` if unhandled.\n      * Params:\n-     *      p = parameter to be passed.\n+     *      t = type to be passed.\n      * Returns:\n-     *      `Type` to use for parameter `p`.\n+     *      `Type` to use for type `t`.\n      */\n-    extern (C++) Type parameterType(Parameter p);\n+    extern (C++) Type parameterType(Type t);\n \n     /**\n      * Checks whether type is a vendor-specific fundamental type."}, {"sha": "fdae14c9dea4f50747b25e8efb111ef1b76e4b4d", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -20,7 +20,6 @@ class ClassDeclaration;\n class Dsymbol;\n class Expression;\n class FuncDeclaration;\n-class Parameter;\n class Statement;\n class Type;\n class TypeTuple;\n@@ -92,14 +91,15 @@ struct TargetCPP\n     bool reverseOverloads;    // with dmc and cl, overloaded functions are grouped and in reverse order\n     bool exceptions;          // set if catching C++ exceptions is supported\n     bool twoDtorInVtable;     // target C++ ABI puts deleting and non-deleting destructor into vtable\n+    bool splitVBasetable;     // set if C++ ABI uses separate tables for virtual functions and virtual bases\n     bool wrapDtorInExternD;   // set if C++ dtors require a D wrapper to be callable from runtime\n     Runtime runtime;\n \n     const char *toMangle(Dsymbol *s);\n     const char *typeInfoMangle(ClassDeclaration *cd);\n     const char *thunkMangle(FuncDeclaration *fd, int offset);\n     const char *typeMangle(Type *t);\n-    Type *parameterType(Parameter *p);\n+    Type *parameterType(Type *p);\n     bool fundamentalType(const Type *t, bool& isFundamental);\n     unsigned derivedClassOffset(ClassDeclaration *baseClass);\n };\n@@ -160,7 +160,7 @@ struct Target\n     DString lib_ext;    /// extension for static library files\n     DString dll_ext;    /// extension for dynamic library files\n     bool run_noext;     /// allow -run sources without extensions\n-    bool mscoff;        /// for Win32: write COFF object files instead of OMF\n+    bool omfobj;        /// for Win32: write OMF object files instead of COFF\n \n     template <typename T>\n     struct FPTypeProperties\n@@ -205,6 +205,7 @@ struct Target\n     Expression *getTargetInfo(const char* name, const Loc& loc);\n     bool isCalleeDestroyingArgs(TypeFunction* tf);\n     bool libraryObjectMonitors(FuncDeclaration *fd, Statement *fbody);\n+    bool supportsLinkerDirective() const;\n     void addPredefinedGlobalIdentifiers() const;\n };\n "}, {"sha": "42517f6403cfd84c7469d743555a72af05e8409a", "filename": "gcc/d/dmd/template.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftemplate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftemplate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftemplate.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -284,6 +284,7 @@ class TemplateInstance : public ScopeDsymbol\n     Identifier *getIdent();\n     hash_t toHash();\n \n+    bool isDiscardable();\n     bool needsCodegen();\n \n     TemplateInstance *isTemplateInstance() { return this; }"}, {"sha": "20b8711a1cfe61232bd8b13c377495e48ed55c97", "filename": "gcc/d/dmd/tokens.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftokens.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftokens.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -278,6 +278,7 @@ enum TOK : ubyte\n     _Thread_local,\n \n     // C only extended keywords\n+    _import,\n     __cdecl,\n     __declspec,\n     __attribute__,\n@@ -585,6 +586,7 @@ private immutable TOK[] keywords =\n     TOK._Thread_local,\n \n     // C only extended keywords\n+    TOK._import,\n     TOK.__cdecl,\n     TOK.__declspec,\n     TOK.__attribute__,\n@@ -615,7 +617,7 @@ static immutable TOK[TOK.max + 1] Ckeywords =\n                        restrict, return_, int16, signed, sizeof_, static_, struct_, switch_, typedef_,\n                        union_, unsigned, void_, volatile, while_, asm_,\n                        _Alignas, _Alignof, _Atomic, _Bool, _Complex, _Generic, _Imaginary, _Noreturn,\n-                       _Static_assert, _Thread_local, __cdecl, __declspec, __attribute__ ];\n+                       _Static_assert, _Thread_local, _import, __cdecl, __declspec, __attribute__ ];\n \n         foreach (kw; Ckwds)\n             tab[kw] = cast(TOK) kw;\n@@ -891,6 +893,7 @@ extern (C++) struct Token\n         TOK._Thread_local  : \"_Thread_local\",\n \n         // C only extended keywords\n+        TOK._import       : \"__import\",\n         TOK.__cdecl        : \"__cdecl\",\n         TOK.__declspec     : \"__declspec\",\n         TOK.__attribute__  : \"__attribute__\","}, {"sha": "a7c9aa55bba0428b4fb16dcf9acd9efd6e57f1fd", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -287,6 +287,7 @@ enum class TOK : unsigned char\n     _Thread_local_,\n \n     // C only extended keywords\n+    _import,\n     cdecl,\n     declspec,\n     attribute__,"}, {"sha": "ec86bc576bd651e9176e45bd1ed01b7abbd770e7", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -150,6 +150,7 @@ shared static this()\n         \"hasPostblit\",\n         \"hasCopyConstructor\",\n         \"isCopyable\",\n+        \"parameters\"\n     ];\n \n     StringTable!(bool)* stringTable = cast(StringTable!(bool)*) &traitsStringTable;\n@@ -998,7 +999,7 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n                 e.error(\"`bool` expected as third argument of `__traits(getOverloads)`, not `%s` of type `%s`\", b.toChars(), b.type.toChars());\n                 return ErrorExp.get();\n             }\n-            includeTemplates = b.toBool().hasValue(true);\n+            includeTemplates = b.toBool().get();\n         }\n \n         StringExp se = ex.toStringExp();\n@@ -2090,7 +2091,43 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n         auto tup = new TupleExp(e.loc, exps);\n         return tup.expressionSemantic(sc);\n     }\n+    //https://issues.dlang.org/show_bug.cgi?id=22291\n+    if (e.ident == Id.parameters)\n+    {\n+        //No args are valid\n+        if (e.args)\n+        {\n+            char[] contents = cast(char[]) e.args.toString();\n+            contents = contents[1..$];\n+            contents[$-1] = '\\0';\n+            e.error(\"`__traits(parameters)` cannot have arguments, but `%s` was supplied\", contents.ptr);\n+            return ErrorExp.get();\n+        }\n \n+        if (sc.func is null)\n+        {\n+            e.error(\"`__traits(parameters)` may only be used inside a function\");\n+            return ErrorExp.get();\n+        }\n+        assert(sc.func && sc.parent.isFuncDeclaration());\n+        auto tf = sc.parent.isFuncDeclaration.type.isTypeFunction();\n+        assert(tf);\n+        auto exps = new Expressions(0);\n+        int addParameterDG(size_t idx, Parameter x)\n+        {\n+            assert(x.ident);\n+            exps.push(new IdentifierExp(e.loc, x.ident));\n+            return 0;\n+        }\n+        /*\n+            This is required since not all \"parameters\" actually have a name\n+            until they (tuples) are expanded e.g. an anonymous tuple parameter's\n+            contents get given names but not the tuple itself.\n+        */\n+        Parameter._foreach(tf.parameterList.parameters, &addParameterDG);\n+        auto tup = new TupleExp(e.loc, exps);\n+        return tup.expressionSemantic(sc);\n+    }\n     static const(char)[] trait_search_fp(const(char)[] seed, out int cost)\n     {\n         //printf(\"trait_search_fp('%s')\\n\", seed);"}, {"sha": "8b6ca6545d649c32b0c70fa7c9478ec342f92837", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1141,6 +1141,12 @@ package mixin template ParseVisitMethods(AST)\n         }\n     }\n \n+    override void visit(AST.ThrowExp e)\n+    {\n+        //printf(\"Visiting ThrowExp\\n\");\n+        e.e1.accept(this);\n+    }\n+\n // Template Parameter\n //===========================================================\n "}, {"sha": "e11f1f7810cd365bc35a90ae8ed0e3db2f6e6027", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2062,7 +2062,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             switch (mtype.tok)\n             {\n                 case TOK.enum_:\n-                    auto ed = new EnumDeclaration(mtype.loc, mtype.id, Type.tint32);\n+                    auto ed = new EnumDeclaration(mtype.loc, mtype.id, mtype.base);\n                     declare(ed);\n                     mtype.resolved = visitEnum(new TypeEnum(ed));\n                     break;\n@@ -3940,7 +3940,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n             e = new TupleExp(e.loc, e0, exps);\n             Scope* sc2 = sc.push();\n-            sc2.flags |= global.params.useDIP1000 == FeatureState.enabled ? SCOPE.onlysafeaccess : SCOPE.noaccesscheck;\n+            sc2.flags |= SCOPE.noaccesscheck;\n             e = e.expressionSemantic(sc2);\n             sc2.pop();\n             return e;\n@@ -4201,7 +4201,7 @@ Expression dotExp(Type mt, Scope* sc, Expression e, Identifier ident, int flag)\n \n             e = new TupleExp(e.loc, e0, exps);\n             Scope* sc2 = sc.push();\n-            sc2.flags |= global.params.useDIP1000 == FeatureState.enabled ? SCOPE.onlysafeaccess : SCOPE.noaccesscheck;\n+            sc2.flags |= SCOPE.noaccesscheck;\n             e = e.expressionSemantic(sc2);\n             sc2.pop();\n             return e;"}, {"sha": "5d6b94ccd027459c25aef6384299ca0dbd3215e6", "filename": "gcc/d/dmd/visitor.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fvisitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fdmd%2Fvisitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fvisitor.h?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -220,6 +220,7 @@ class BinAssignExp;\n class MixinExp;\n class ImportExp;\n class AssertExp;\n+class ThrowExp;\n class DotIdExp;\n class DotTemplateExp;\n class DotVarExp;\n@@ -511,6 +512,7 @@ class ParseTimeVisitor\n     virtual void visit(CallExp *e) { visit((UnaExp *)e); }\n     virtual void visit(DotIdExp *e) { visit((UnaExp *)e); }\n     virtual void visit(AssertExp *e) { visit((UnaExp *)e); }\n+    virtual void visit(ThrowExp *e) { visit((UnaExp *)e); }\n     virtual void visit(ImportExp *e) { visit((UnaExp *)e); }\n     virtual void visit(DotTemplateInstanceExp *e) { visit((UnaExp *)e); }\n     virtual void visit(ArrayExp *e) { visit((UnaExp *)e); }"}, {"sha": "dd7ebc842a8109c085068d2938eb455d606cafd2", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1186,6 +1186,14 @@ class ExprVisitor : public Visitor\n     this->result_ = build_assign (modifycode, t1, t2);\n   }\n \n+  /* Build a throw expression.  */\n+\n+  void visit (ThrowExp *e)\n+  {\n+    tree arg = build_expr_dtor (e->e1);\n+    this->result_ = build_libcall (LIBCALL_THROW, Type::tvoid, 1, arg);\n+  }\n+\n   /* Build a postfix expression.  */\n \n   void visit (PostExp *e)"}, {"sha": "8ae6ea1bb781a4b265ae5db2e57cc369ecb8b63a", "filename": "gcc/d/types.cc", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Fd%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Ftypes.cc?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -274,6 +274,72 @@ insert_aggregate_field (tree type, tree field, size_t offset)\n   TYPE_FIELDS (type) = chainon (TYPE_FIELDS (type), field);\n }\n \n+/* Build a bit-field integer type for the given WIDTH and UNSIGNEDP.  */\n+\n+static tree\n+d_build_bitfield_integer_type (unsigned HOST_WIDE_INT width, int unsignedp)\n+{\n+  /* Same as d_type_for_size, but uses exact match for size.  */\n+  if (width == TYPE_PRECISION (d_byte_type))\n+    return unsignedp ? d_ubyte_type : d_byte_type;\n+\n+  if (width == TYPE_PRECISION (d_short_type))\n+    return unsignedp ? d_ushort_type : d_short_type;\n+\n+  if (width == TYPE_PRECISION (d_int_type))\n+    return unsignedp ? d_uint_type : d_int_type;\n+\n+  if (width == TYPE_PRECISION (d_long_type))\n+    return unsignedp ? d_ulong_type : d_long_type;\n+\n+  if (width == TYPE_PRECISION (d_cent_type))\n+    return unsignedp ? d_ucent_type : d_cent_type;\n+\n+  for (int i = 0; i < NUM_INT_N_ENTS; i ++)\n+    {\n+      if (int_n_enabled_p[i] && width == int_n_data[i].bitsize)\n+\t{\n+\t  if (unsignedp)\n+\t    return int_n_trees[i].unsigned_type;\n+\t  else\n+\t    return int_n_trees[i].signed_type;\n+\t}\n+    }\n+\n+  return build_nonstandard_integer_type (width, unsignedp);\n+}\n+\n+/* Adds BITFIELD into the aggregate TYPE at OFFSET+BITOFFSET.  */\n+\n+static void\n+insert_aggregate_bitfield (tree type, tree bitfield, size_t width,\n+\t\t\t   size_t offset, size_t bitoffset)\n+{\n+  DECL_FIELD_CONTEXT (bitfield) = type;\n+  SET_DECL_OFFSET_ALIGN (bitfield, TYPE_ALIGN (TREE_TYPE (bitfield)));\n+  DECL_SIZE (bitfield) = bitsize_int (width);\n+  DECL_FIELD_OFFSET (bitfield) = size_int (offset);\n+  DECL_FIELD_BIT_OFFSET (bitfield) = bitsize_int (bitoffset);\n+\n+  TREE_ADDRESSABLE (bitfield) = TYPE_SHARED (TREE_TYPE (bitfield));\n+\n+  DECL_BIT_FIELD (bitfield) = 1;\n+  DECL_BIT_FIELD_TYPE (bitfield) = TREE_TYPE (bitfield);\n+\n+  layout_decl (bitfield, 0);\n+\n+  /* Give bit-field its proper type after layout_decl.  */\n+  tree orig_type = DECL_BIT_FIELD_TYPE (bitfield);\n+  if (width != TYPE_PRECISION (orig_type))\n+    {\n+      TREE_TYPE (bitfield)\n+    \t= d_build_bitfield_integer_type (width, TYPE_UNSIGNED (orig_type));\n+      SET_DECL_MODE (bitfield, TYPE_MODE (TREE_TYPE (bitfield)));\n+    }\n+\n+  TYPE_FIELDS (type) = chainon (TYPE_FIELDS (type), bitfield);\n+}\n+\n /* For all decls in the FIELDS chain, adjust their field offset by OFFSET.\n    This is done as the frontend puts fields into the outer struct, and so\n    their offset is from the beginning of the aggregate.\n@@ -356,7 +422,16 @@ layout_aggregate_members (Dsymbols *members, tree context, bool inherited_p)\n \t      tree field = create_field_decl (declaration_type (var), ident,\n \t\t\t\t\t      inherited_p, inherited_p);\n \t      apply_user_attributes (var, field);\n-\t      insert_aggregate_field (context, field, var->offset);\n+\n+\t      if (BitFieldDeclaration *bf = var->isBitFieldDeclaration ())\n+\t\t{\n+\t\t  /* Bit-fields come from an ImportC context, and require the\n+\t\t     field be correctly adjusted.  */\n+\t\t  insert_aggregate_bitfield (context, field, bf->fieldWidth,\n+\t\t\t\t\t     bf->offset, bf->bitOffset);\n+\t\t}\n+\t      else\n+  \t\tinsert_aggregate_field (context, field, var->offset);\n \n \t      /* Because the front-end shares field decls across classes, don't\n \t\t create the corresponding back-end symbol unless we are adding"}, {"sha": "c4c2bc8874c2d5a8bfeaab3a7d369c82d9b96cac", "filename": "gcc/testsuite/gdc.test/compilable/casttuple.d", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcasttuple.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcasttuple.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcasttuple.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,31 @@\n+alias tuple(T...) = T;\n+\n+void exactMatch()\n+{\n+    tuple!int tup_1;\n+\n+    auto i = cast() tup_1;\n+    static assert(is(typeof(i) == int));\n+    const i_const = cast(const) tup_1;\n+    static assert(is(typeof(i_const) == const int));\n+\n+    auto totup_1 = cast(tuple!int) tup_1;\n+    static assert(is(typeof(totup_1) == tuple!int));\n+\n+    tuple!(int, int) tup_2;\n+    auto totup_2 = cast(tuple!(int, int)) tup_2;\n+    static assert(is(typeof(totup_2) == tuple!(int, int)));\n+}\n+\n+void implicitConv()\n+{\n+    tuple!short tup_1;\n+    auto totup_1 = cast(tuple!int) tup_1;\n+    static assert(is(typeof(tup_1) == tuple!short));\n+    static assert(is(typeof(totup_1) == tuple!int));\n+\n+    tuple!(short, short) tup_2;\n+    auto totup_2 = cast(tuple!(int, int)) tup_2;\n+    static assert(is(typeof(tup_2) == tuple!(short, short)));\n+    static assert(is(typeof(totup_2) == tuple!(int, int)));\n+}"}, {"sha": "c9da34dbfa73d549bc768cb559ad43c6ba441b07", "filename": "gcc/testsuite/gdc.test/compilable/deprecated_override.d", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdeprecated_override.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdeprecated_override.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fdeprecated_override.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,97 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22668\n+\n+// Overrides with same deprecated'ness are allowed\n+\n+class SameParent\n+{\n+    deprecated void foo() {}\n+    void foo(int) {}\n+\n+    void bar(int) {}\n+    deprecated void bar() {}\n+}\n+\n+class SameChild : SameParent\n+{\n+    deprecated override void foo() {}\n+    override void foo(int) {}\n+\n+    override void bar(int) {}\n+    deprecated override void bar() {}\n+}\n+\n+/**\n+Only the parent declaration is deprecated\n+\n+TEST_OUTPUT:\n+----\n+compilable/deprecated_override.d(44): Deprecation: `deprecated_override.IntroducingChild.foo` is overriding the deprecated method `deprecated_override.IntroducingParent.foo`\n+compilable/deprecated_override.d(48): Deprecation: `deprecated_override.IntroducingChild.bar` is overriding the deprecated method `deprecated_override.IntroducingParent.bar`\n+----\n+**/\n+\n+class IntroducingParent\n+{\n+    deprecated void foo() {}\n+    void foo(int) {}\n+\n+    void bar(int) {}\n+    deprecated void bar() {}\n+}\n+\n+class IntroducingChild : IntroducingParent\n+{\n+    override void foo() {}\n+    override void foo(int) {}\n+\n+    override void bar(int) {}\n+    override void bar() {}\n+}\n+\n+// Unrelated to this path but should this error as well?\n+\n+class IntroducingGrandchild : IntroducingChild\n+{\n+    override void foo() {}\n+    override void foo(int) {}\n+\n+    override void bar(int) {}\n+    override void bar() {}\n+}\n+\n+/**\n+Only the overriding declaration is deprecated\n+\n+TEST_OUTPUT:\n+----\n+compilable/deprecated_override.d(83): Deprecation: `deprecated_override.OverrideChild.foo` cannot be marked as `deprecated` because it is overriding a function in the base class\n+compilable/deprecated_override.d(87): Deprecation: `deprecated_override.OverrideChild.bar` cannot be marked as `deprecated` because it is overriding a function in the base class\n+----\n+**/\n+\n+class OverrideParent\n+{\n+    void foo() {}\n+    void foo(int) {}\n+\n+    void bar(int) {}\n+    void bar() {}\n+}\n+\n+class OverrideChild : OverrideParent\n+{\n+    deprecated override void foo() {}\n+    override void foo(int) {}\n+\n+    override void bar(int) {}\n+    deprecated override void bar() {}\n+}\n+\n+class OverrideGrandChild : OverrideChild\n+{\n+    deprecated override void foo() {}\n+    override void foo(int) {}\n+\n+    override void bar(int) {}\n+    deprecated override void bar() {}\n+}"}, {"sha": "01cf8897bca4e4951531f8c1b943456c4dbaf814", "filename": "gcc/testsuite/gdc.test/compilable/extra-files/header1.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fextra-files%2Fheader1.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -600,3 +600,9 @@ struct Test14UDA4(string v){}\n void test14x(@Test14UDA1 int, @Test14UDA2(\"1\") int, @test14uda3(\"2\") int, @Test14UDA4!\"3\" int) {}\n \n void test15x(@(20) void delegate(int) @safe dg){}\n+\n+T throwStuff(T)(T t)\n+{\n+    if (false) test13x(1, throw new Exception(\"\"), 2);\n+    return t ? t : throw new Exception(\"Bad stuff happens!\");\n+}"}, {"sha": "dd14de148a609e3f9c782e9765fdf76244163633", "filename": "gcc/testsuite/gdc.test/compilable/fix17635.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix17635.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix17635.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix17635.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=17635\n+\n+alias T = immutable int;\n+\n+T** f(const T** input) pure\n+{\n+    T** output;\n+    return output;\n+}\n+\n+void main()\n+{\n+    T i;\n+    T* p = &i;\n+    immutable T** r = f(&p);\n+}"}, {"sha": "4090c5e275882fcdb1ae4f00fc192706f7204c26", "filename": "gcc/testsuite/gdc.test/compilable/fix22291.d", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix22291.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix22291.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ffix22291.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,134 @@\n+//https://issues.dlang.org/show_bug.cgi?id=22291\n+\n+alias AliasSeq(T...) = T;\n+void noParameters()\n+{\n+    static assert(typeof(__traits(parameters)).length == 0);\n+}\n+void noArgs()\n+{\n+    //Arguments are not valid, this should not compile\n+    static assert(!__traits(compiles, __traits(parameters, 456)));\n+}\n+shared static this()\n+{\n+    static assert(typeof(__traits(parameters)).length == 0);\n+}\n+int echoPlusOne(int x)\n+{\n+    __traits(parameters)[0] += 1;\n+    return x;\n+}\n+static assert(echoPlusOne(1) == 2);\n+class Tree {\n+    int opApply(int delegate(size_t, Tree) dg) {\n+        if (dg(0, this)) return 1;\n+        return 0;\n+    }\n+}\n+void useOpApply(Tree top, int x)\n+{\n+    foreach(idx; 0..5)\n+    {\n+        static assert(is(typeof(__traits(parameters)) == AliasSeq!(Tree, int)));\n+    }\n+    foreach(idx, elem; top)\n+    {\n+        static assert(is(typeof(__traits(parameters)) == AliasSeq!(size_t, Tree)));\n+    }\n+}\n+class Test\n+{\n+    static assert(!__traits(compiles, __traits(parameters)));\n+    void handle(int x)\n+    {\n+        static assert(typeof(__traits(parameters)).length == 1);\n+    }\n+}\n+\n+int add(int x, int y)\n+{\n+\treturn x + y;\n+}\n+\n+auto forwardToAdd(int x, int y)\n+{\n+\treturn add(__traits(parameters));\n+}\n+static assert(forwardToAdd(2, 3) == 5);\n+struct TestConstructor\n+{\n+    int x;\n+    string y;\n+    //This parameter will not have a name but it's (tuple) members\n+    //will\n+    this(typeof(this.tupleof))\n+    {\n+        this.tupleof = __traits(parameters);\n+    }\n+}\n+bool test(int x, string y)\n+{\n+    auto s = TestConstructor(2, \"pi\");\n+    return s.x == x && s.y == y;\n+}\n+static assert(test(2, \"pi\"));\n+int testNested(int x)\n+{\n+    static assert(typeof(__traits(parameters)).length == 1);\n+    int add(int x, int y)\n+    {\n+        static assert(typeof(__traits(parameters)).length == 2);\n+        return x + y;\n+    }\n+    return add(x + 2, x + 3);\n+}\n+void testPack(Pack...)(Pack x)\n+{\n+    static assert(is(typeof(__traits(parameters)) == typeof(AliasSeq!(x))));\n+}\n+\n+ref int forwardTest(return ref int x)\n+{\n+    static assert(__traits(isRef, x) == __traits(isRef, __traits(parameters)[0]));\n+    return x;\n+}\n+\n+int testRefness(int x, ref int monkey)\n+{\n+    {\n+        //monkey = x;\n+        __traits(parameters)[1] = __traits(parameters)[0];\n+    }\n+    return x;\n+}\n+int refTest()\n+{\n+    int x;\n+    testRefness(45, x);\n+    return x;\n+}\n+auto packLength(Pack...)(Pack x)\n+{\n+    return typeof(__traits(parameters)).length;\n+}\n+static assert(packLength(2, 3) == 2);\n+alias lambda = (x) => typeof(__traits(parameters)).stringof;\n+static assert(lambda(1) == \"(int)\");\n+static assert(refTest() == 45);\n+\n+T testTemplate(T)(scope T input)\n+{\n+    void chimpInASuit(float set)\n+    {\n+        static assert(is(typeof(__traits(parameters)) == AliasSeq!(float)));\n+    }\n+    {\n+        __traits(parameters) = AliasSeq!(T.max);\n+    }\n+    __traits(parameters) = AliasSeq!(T.init);\n+    return input;\n+}\n+\n+static assert(testTemplate!long(420) == 0);\n+"}, {"sha": "f6aaf3b2a4ae193bfaea86daab9358deae2f9ce1", "filename": "gcc/testsuite/gdc.test/compilable/imports/cstuff3.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcstuff3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcstuff3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fcstuff3.c?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,6 @@\n+// check bugs in importing C files\n+\n+int squared(int a)\n+{\n+    return a * a;\n+}"}, {"sha": "0d18459b3ab5b20a72042bb1e105280a2f55a6b3", "filename": "gcc/testsuite/gdc.test/compilable/imports/imp22625.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp22625.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp22625.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp22625.c?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1 @@\n+typedef struct S { int x; } T;"}, {"sha": "f575cff249e87e9337873004c658388ceb140704", "filename": "gcc/testsuite/gdc.test/compilable/imports/imp22665.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp22665.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp22665.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Fimp22665.c?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1 @@\n+enum E { A };"}, {"sha": "e1854d147262fbcf611e244438878ccc4d218dc5", "filename": "gcc/testsuite/gdc.test/compilable/imports/test22685b.d", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest22685b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest22685b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest22685b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,5 @@\n+module imports.test22685b;\n+\n+import imports.test22685c : overloaded;\n+\n+void overloaded()() { }"}, {"sha": "e2c8ad15910436294445b7c72a11a2c57da48c5c", "filename": "gcc/testsuite/gdc.test/compilable/imports/test22685c.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest22685c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest22685c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fimports%2Ftest22685c.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,3 @@\n+module imports.test22685c;\n+\n+void overloaded()() { }"}, {"sha": "34a631d254127776f5de425e1984d50ade063ef3", "filename": "gcc/testsuite/gdc.test/compilable/issue22130.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue22130.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue22130.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue22130.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,12 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22130\n+\n+int* f(const int* input) pure nothrow @safe\n+{\n+    int* output;\n+    return output;\n+}\n+void main() pure nothrow @safe\n+{\n+    int* c = new int;\n+    immutable int* i = f(c);\n+}"}, {"sha": "5bba9baa72ab518dee01fbabd918ca84d5ebe118", "filename": "gcc/testsuite/gdc.test/compilable/noreturn1.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -20,8 +20,7 @@ static assert(!is(noreturn == void));\n \n static assert(is( typeof(assert(0)) == noreturn ));\n \n-// Does not parse yet\n-// static assert(is( typeof(throw new Exception()) == noreturn ));\n+static assert(is( typeof(throw new Exception(\"\")) == noreturn ));\n \n static assert(is(noreturn == noreturn));\n static assert(!is(noreturn == const noreturn));"}, {"sha": "f19fdb7aa5424b30f11ab46aeacbe6884d1af4b2", "filename": "gcc/testsuite/gdc.test/compilable/test13008.d", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13008.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13008.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest13008.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,10 +1,6 @@\n // REQUIRED_ARGS: -o-\n // PERMUTE_ARGS: -d -de -dw\n-/*\n-TEST_OUTPUT*\n----\n----\n-*/\n+\n deprecated class Dep { }\n deprecated Dep depFunc1(); // error\n deprecated void depFunc2(Dep); // error"}, {"sha": "e6a511c3697ff01512cb4c082ff23b00e4ec4980", "filename": "gcc/testsuite/gdc.test/compilable/test18771.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18771.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18771.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest18771.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// REQUIRED_ARGS : -c\n+// REQUIRED_ARGS: -c\n // EXTRA_FILES: imports/test18771a.d imports/test18771b.d imports/test18771c.d imports/test18771d.d\n // https://issues.dlang.org/show_bug.cgi?id=18771\n "}, {"sha": "4367df153b77d4fec70d9e25f8b51c247031b3dc", "filename": "gcc/testsuite/gdc.test/compilable/test19609.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19609.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19609.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19609.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // https://issues.dlang.org/show_bug.cgi?id=19609\n // EXTRA_FILES: imports/test19609a.d imports/test19609b.d imports/test19609c.d\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n compilable/test19609.d(11): Deprecation: module `imports.test19609a` is deprecated - \n compilable/test19609.d(12): Deprecation: module `imports.test19609b` is deprecated - hello"}, {"sha": "e69b4df35084c35d37603b6df72a4d79eb96c773", "filename": "gcc/testsuite/gdc.test/compilable/test19873.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19873.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19873.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest19873.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// PERMUTE_ARGS -preview=dip1000\n+// PERMUTE_ARGS: -preview=dip1000\n // https://issues.dlang.org/show_bug.cgi?id=19873\n int* ed(scope int* x)\n {"}, {"sha": "12cc579889b1f213886c721af599101995e167e4", "filename": "gcc/testsuite/gdc.test/compilable/test21299a.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21299a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21299a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21299a.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n // EXTRA_SOURCES: imports/test21299/mtype.d imports/test21299/func.d imports/test21299/rootstringtable.d\n // REQUIRED_ARGS: -main\n-// LINK\n+// LINK:\n module test21299a;"}, {"sha": "fd5e894715a8cdf858f88a9e194eef4cd483db25", "filename": "gcc/testsuite/gdc.test/compilable/test22619.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22619.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22619.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22619.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,11 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22619\n+\n+struct W1 {\n+\tint x;\n+\tthis(ref inout W1 rhs) inout { this.x = rhs.x; }\n+}\n+\n+inout(W1) f(inout W1 x) { return x; }\n+void g(W1 x) {\n+\tauto r = f(x);\n+}"}, {"sha": "adf6676a3030b5385e2386f61fa9157a96c7241e", "filename": "gcc/testsuite/gdc.test/compilable/test22625.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22625.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22625.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22625.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,4 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22625\n+// EXTRA_FILES: imports/imp22625.c\n+\n+import imports.imp22625 : S, T;"}, {"sha": "ae44d81f4da5985a46769db0eac3068b9750ee76", "filename": "gcc/testsuite/gdc.test/compilable/test22646.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22646.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22646.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22646.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22646\n+\n+/*\n+TEST_OUTPUT:\n+---\n+true\n+true\n+false\n+false\n+---\n+*/\n+\n+static template Bug(string name)\n+{\n+    enum bool ok = name.length < 3 || name[0..3] != \"pad\";\n+}\n+\n+pragma(msg, Bug!\"x\".ok);\n+pragma(msg, Bug!\"foo\".ok);\n+pragma(msg, Bug!\"pad\".ok);\n+pragma(msg, Bug!\"pad123\".ok);"}, {"sha": "9d55dbbab1ffd8034546d5ca83fd653aa65e57ce", "filename": "gcc/testsuite/gdc.test/compilable/test22665.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22665.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22665.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22665.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,22 @@\n+// EXTRA_FILES: imports/imp22665.c\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22665\n+\n+import imports.imp22665;\n+\n+E foo1(E e)\n+{\n+    return e.A; // with qualification, it is an enum\n+}\n+\n+int foo2()\n+{\n+    return A; // without qualification, it is an int\n+}\n+\n+E foo3(E e)\n+{\n+    return E.A; // with qualification, it is an enum\n+}\n+\n+"}, {"sha": "8adc13243a2535a12f117742948fdf73d0826ed9", "filename": "gcc/testsuite/gdc.test/compilable/test22676.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22676.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22676.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22676.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,25 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22676\n+template fullyQualifiedName(T)\n+{\n+    static if (is(T : real))\n+        enum fullyQualifiedName;\n+\n+    enum fullyQualifiedName = null;\n+}\n+\n+static auto _inst()\n+{\n+    return fullyQualifiedName!(frop);\n+}\n+\n+alias attr = __traits(getAttributes, _inst);\n+\n+class frop\n+{\n+    alias type_id = registry!frop;\n+}\n+\n+template registry(T)\n+{\n+    enum string FOO = fullyQualifiedName!T;\n+}"}, {"sha": "504cc9d508044c36a4bb2e3dadb26e6fed28e3a9", "filename": "gcc/testsuite/gdc.test/compilable/test22685.d", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22685.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22685.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22685.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,11 @@\n+// EXTRA_FILES: imports/test22685b.d imports/test22685c.d\n+\n+module test22685;\n+\n+import imports.test22685b;\n+\n+void twoArgs(alias a, alias b)() { }\n+\n+void main() {\n+    twoArgs!(a => 1, overloaded);\n+}"}, {"sha": "4b413e12e9c99c4a120ce7eda5a0f46fb31420e6", "filename": "gcc/testsuite/gdc.test/compilable/test55.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest55.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest55.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest55.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // COMPILED_IMPORTS: imports/test55a.d\n // PERMUTE_ARGS: -dw\n // REQUIRED_ARGS: -d\n@@ -17,4 +17,3 @@ class Queue2 {\n   alias int ListHead;\n   Arm2 a;\n }\n-"}, {"sha": "89228a9bc4ab96082872f87db15e3dd059e0a182", "filename": "gcc/testsuite/gdc.test/compilable/testcstuff3.d", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestcstuff3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestcstuff3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestcstuff3.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,4 @@\n+// EXTRA_FILES: imports/cstuff3.c\n+import imports.cstuff3;\n+\n+static assert(squared(4) == 16);"}, {"sha": "e0eb3a584fb1d23d64311159ff8f3aae08b99c2d", "filename": "gcc/testsuite/gdc.test/compilable/testos.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestos.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestos.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestos.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,7 @@\n+/* PERMUTE_ARGS: -os=host -os=linux -os=osx -os=freebsd -os=solaris\n+ * DISABLED: win32 win64\n+ */\n+\n+void test()\n+{\n+}"}, {"sha": "7a2c3e4685fddbc38a38fe12177933f3e9a5e8b0", "filename": "gcc/testsuite/gdc.test/fail_compilation/b16967.d", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fb16967.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fb16967.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fb16967.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,9 +1,8 @@\n /*\n- * REQUIRED_ARGS: -c\n  * TEST_OUTPUT:\n ---\n-compilable/b16967.d(16): Deprecation: switch case fallthrough - use 'goto default;' if intended\n-compilable/b16967.d(26): Deprecation: switch case fallthrough - use 'goto default;' if intended\n+fail_compilation/b16967.d(15): Error: switch case fallthrough - use 'goto default;' if intended\n+fail_compilation/b16967.d(25): Error: switch case fallthrough - use 'goto default;' if intended\n ---\n */\n int foo(int x)", "previous_filename": "gcc/testsuite/gdc.test/compilable/b16967.d"}, {"sha": "2063e41492f9b61d239d745d4fe362aaf0fe5872", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug5096.d", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5096.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5096.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug5096.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,14 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/bug5096.d(13): Error: unmatched closing brace\n+---\n+*/\n+void foo(int x)\n+    in {\n+        assert(x > 0);\n+    } do {\n+        x++;\n+    }\n+}\n+void main() {}"}, {"sha": "0edd5e991467dfae4c2d6defc2774d813b3fa9d0", "filename": "gcc/testsuite/gdc.test/fail_compilation/bug9631.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fbug9631.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -91,9 +91,9 @@ TEST_OUTPUT:\n ---\n fail_compilation/bug9631.d(106): Error: function `bug9631.targ.ft!().ft(S _param_0)` is not callable using argument types `(S)`\n fail_compilation/bug9631.d(106):        cannot pass argument `x` of type `bug9631.S` to parameter `bug9631.tem!().S _param_0`\n-fail_compilation/bug9631.d(107): Error: template `bug9631.targ.ft` cannot deduce function from argument types `!()(S)`\n+fail_compilation/bug9631.d(107): Error: none of the overloads of template `bug9631.targ.ft` are callable using argument types `!()(S)`\n fail_compilation/bug9631.d(105):        Candidate is: `ft()(tem!().S)`\n-fail_compilation/bug9631.d(109): Error: template `bug9631.targ.ft2` cannot deduce function from argument types `!()(S, int)`\n+fail_compilation/bug9631.d(109): Error: none of the overloads of template `bug9631.targ.ft2` are callable using argument types `!()(S, int)`\n fail_compilation/bug9631.d(108):        Candidate is: `ft2(T)(S, T)`\n ---\n */"}, {"sha": "d08de08b553c3f0c57c93d48b6b8fc4fbb4d9f7e", "filename": "gcc/testsuite/gdc.test/fail_compilation/casttuple.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcasttuple.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcasttuple.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fcasttuple.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,25 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/casttuple.d(104): Error: cannot cast `__tup1_field_0` of type `int` to tuple type `(string)`\n+fail_compilation/casttuple.d(107): Error: cannot cast `tuple(__tup2_field_0, __tup2_field_1)` of type `(int, int)` to tuple type `(string, string)`\n+fail_compilation/casttuple.d(111): Error: cannot cast `tuple(foo, 123)` of type `(int, int)` to tuple type `(string, string)`\n+---\n+ */\n+\n+alias tuple(T...) = T;\n+\n+#line 100\n+\n+void nomatch()\n+{\n+    tuple!int tup1;\n+    auto x = cast(tuple!string) tup1;\n+\n+    tuple!(int, int) tup2;\n+    auto y = cast(tuple!(string, string)) tup2;\n+\n+    int foo;\n+    alias tup3 = tuple!(foo, 123);\n+    auto z = cast(tuple!(string, string)) tup3;\n+}"}, {"sha": "9f12ae6983544825ae6e8b812687e94922eff8cf", "filename": "gcc/testsuite/gdc.test/fail_compilation/constraints_aggr.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_aggr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_aggr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_aggr.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,12 +2,12 @@\n EXTRA_FILES: imports/constraints.d\n TEST_OUTPUT:\n ---\n-fail_compilation/constraints_aggr.d(32): Error: template `imports.constraints.C.f` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_aggr.d(32): Error: none of the overloads of template `imports.constraints.C.f` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(60):        Candidate is: `f(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       !P!T`\n-fail_compilation/constraints_aggr.d(33): Error: template `imports.constraints.C.g` cannot deduce function from argument types `!()()`\n+fail_compilation/constraints_aggr.d(33): Error: none of the overloads of template `imports.constraints.C.g` are callable using argument types `!()()`\n fail_compilation/imports/constraints.d(63):        Candidate is: `g(this T)()`\n   with `T = imports.constraints.C`\n   must satisfy the following constraint:"}, {"sha": "aac87601eb922406e3e62f8067ec1951bbd73f65", "filename": "gcc/testsuite/gdc.test/fail_compilation/constraints_func1.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func1.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,72 +2,72 @@\n EXTRA_FILES: imports/constraints.d\n TEST_OUTPUT:\n ---\n-fail_compilation/constraints_func1.d(79): Error: template `imports.constraints.test1` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(79): Error: none of the overloads of template `imports.constraints.test1` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(9):        Candidate is: `test1(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func1.d(80): Error: template `imports.constraints.test2` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(80): Error: none of the overloads of template `imports.constraints.test2` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(10):        Candidate is: `test2(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       !P!T`\n-fail_compilation/constraints_func1.d(81): Error: template `imports.constraints.test3` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(81): Error: none of the overloads of template `imports.constraints.test3` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(11):        Candidate is: `test3(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func1.d(82): Error: template `imports.constraints.test4` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(82): Error: none of the overloads of template `imports.constraints.test4` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(12):        Candidate is: `test4(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func1.d(83): Error: template `imports.constraints.test5` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(83): Error: none of the overloads of template `imports.constraints.test5` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(13):        Candidate is: `test5(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        N!T`\n-fail_compilation/constraints_func1.d(84): Error: template `imports.constraints.test6` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(84): Error: none of the overloads of template `imports.constraints.test6` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(14):        Candidate is: `test6(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        N!T\n        !P!T`\n-fail_compilation/constraints_func1.d(85): Error: template `imports.constraints.test7` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(85): Error: none of the overloads of template `imports.constraints.test7` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(15):        Candidate is: `test7(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        N!T`\n-fail_compilation/constraints_func1.d(86): Error: template `imports.constraints.test8` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(86): Error: none of the overloads of template `imports.constraints.test8` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(16):        Candidate is: `test8(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func1.d(87): Error: template `imports.constraints.test9` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(87): Error: none of the overloads of template `imports.constraints.test9` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(17):        Candidate is: `test9(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       !P!T`\n-fail_compilation/constraints_func1.d(88): Error: template `imports.constraints.test10` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(88): Error: none of the overloads of template `imports.constraints.test10` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(18):        Candidate is: `test10(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       !P!T`\n-fail_compilation/constraints_func1.d(89): Error: template `imports.constraints.test11` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(89): Error: none of the overloads of template `imports.constraints.test11` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(19):        Candidate is: `test11(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        !P!T`\n-fail_compilation/constraints_func1.d(90): Error: template `imports.constraints.test12` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func1.d(90): Error: none of the overloads of template `imports.constraints.test12` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(20):        Candidate is: `test12(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       !P!T`\n-fail_compilation/constraints_func1.d(92): Error: template `imports.constraints.test1` cannot deduce function from argument types `!()(int, int)`\n+fail_compilation/constraints_func1.d(92): Error: none of the overloads of template `imports.constraints.test1` are callable using argument types `!()(int, int)`\n fail_compilation/imports/constraints.d(9):        Candidate is: `test1(T)(T v)`\n ---\n */"}, {"sha": "a20426d35dc27d575471fdbcdc3778a10fc2d106", "filename": "gcc/testsuite/gdc.test/fail_compilation/constraints_func2.d", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func2.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,83 +2,83 @@\n EXTRA_FILES: imports/constraints.d\n TEST_OUTPUT:\n ---\n-fail_compilation/constraints_func2.d(94): Error: template `imports.constraints.test13` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(94): Error: none of the overloads of template `imports.constraints.test13` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(23):        Candidate is: `test13(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        !P!T`\n-fail_compilation/constraints_func2.d(95): Error: template `imports.constraints.test14` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(95): Error: none of the overloads of template `imports.constraints.test14` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(24):        Candidate is: `test14(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       !P!T\n        N!T`\n-fail_compilation/constraints_func2.d(96): Error: template `imports.constraints.test15` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(96): Error: none of the overloads of template `imports.constraints.test15` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(25):        Candidate is: `test15(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       !P!T\n        !P!T`\n-fail_compilation/constraints_func2.d(97): Error: template `imports.constraints.test16` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(97): Error: none of the overloads of template `imports.constraints.test16` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(26):        Candidate is: `test16(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        N!T`\n-fail_compilation/constraints_func2.d(98): Error: template `imports.constraints.test17` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(98): Error: none of the overloads of template `imports.constraints.test17` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(27):        Candidate is: `test17(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func2.d(99): Error: template `imports.constraints.test18` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(99): Error: none of the overloads of template `imports.constraints.test18` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(28):        Candidate is: `test18(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        N!T`\n-fail_compilation/constraints_func2.d(100): Error: template `imports.constraints.test19` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(100): Error: none of the overloads of template `imports.constraints.test19` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(29):        Candidate is: `test19(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        !P!T\n        N!T`\n-fail_compilation/constraints_func2.d(101): Error: template `imports.constraints.test20` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(101): Error: none of the overloads of template `imports.constraints.test20` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(30):        Candidate is: `test20(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func2.d(102): Error: template `imports.constraints.test21` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(102): Error: none of the overloads of template `imports.constraints.test21` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(31):        Candidate is: `test21(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       N!T\n        N!T`\n-fail_compilation/constraints_func2.d(103): Error: template `imports.constraints.test22` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(103): Error: none of the overloads of template `imports.constraints.test22` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(32):        Candidate is: `test22(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       !P!T\n        !P!T`\n-fail_compilation/constraints_func2.d(104): Error: template `imports.constraints.test23` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(104): Error: none of the overloads of template `imports.constraints.test23` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(33):        Candidate is: `test23(T)(T v)`\n   with `T = int`\n   must satisfy one of the following constraints:\n `       !P!T\n        N!T\n        !P!T`\n-fail_compilation/constraints_func2.d(105): Error: template `imports.constraints.test24` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(105): Error: none of the overloads of template `imports.constraints.test24` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(34):        Candidate is: `test24(R)(R r)`\n   with `R = int`\n   must satisfy the following constraint:\n `       __traits(hasMember, R, \"stuff\")`\n-fail_compilation/constraints_func2.d(106): Error: template `imports.constraints.test25` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func2.d(106): Error: none of the overloads of template `imports.constraints.test25` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(35):        Candidate is: `test25(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n `       N!T`\n-fail_compilation/constraints_func2.d(107): Error: template `imports.constraints.test26` cannot deduce function from argument types `!(float)(int)`\n+fail_compilation/constraints_func2.d(107): Error: none of the overloads of template `imports.constraints.test26` are callable using argument types `!(float)(int)`\n fail_compilation/imports/constraints.d(36):        Candidate is: `test26(T, U)(U u)`\n   with `T = float,\n        U = int`"}, {"sha": "6f214b9f07e1f602d7f9bda2d4dbb7c5f096cde6", "filename": "gcc/testsuite/gdc.test/fail_compilation/constraints_func3.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func3.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n EXTRA_FILES: imports/constraints.d\n TEST_OUTPUT:\n ---\n-fail_compilation/constraints_func3.d(53): Error: template `imports.constraints.overload` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func3.d(53): Error: none of the overloads of template `imports.constraints.overload` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(39):        Candidates are: `overload(T)(T v)`\n   with `T = int`\n   must satisfy the following constraint:\n@@ -13,7 +13,7 @@ fail_compilation/imports/constraints.d(40):                        `overload(T)(\n `       !P!T`\n fail_compilation/imports/constraints.d(41):                        `overload(T)(T v1, T v2)`\n fail_compilation/imports/constraints.d(42):                        `overload(T, V)(T v1, V v2)`\n-fail_compilation/constraints_func3.d(54): Error: template `imports.constraints.overload` cannot deduce function from argument types `!()(int, string)`\n+fail_compilation/constraints_func3.d(54): Error: none of the overloads of template `imports.constraints.overload` are callable using argument types `!()(int, string)`\n fail_compilation/imports/constraints.d(39):        Candidates are: `overload(T)(T v)`\n fail_compilation/imports/constraints.d(40):                        `overload(T)(T v)`\n fail_compilation/imports/constraints.d(41):                        `overload(T)(T v1, T v2)`\n@@ -23,21 +23,21 @@ fail_compilation/imports/constraints.d(42):                        `overload(T,\n   must satisfy one of the following constraints:\n `       N!T\n        N!V`\n-fail_compilation/constraints_func3.d(56): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()()`\n+fail_compilation/constraints_func3.d(56): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()()`\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n-fail_compilation/constraints_func3.d(57): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func3.d(57): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()(int)`\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n   with `A = int,\n        T = ()`\n   must satisfy the following constraint:\n `       N!int`\n-fail_compilation/constraints_func3.d(58): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()(int, int)`\n+fail_compilation/constraints_func3.d(58): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()(int, int)`\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n   with `A = int,\n        T = (int)`\n   must satisfy the following constraint:\n `       N!int`\n-fail_compilation/constraints_func3.d(59): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()(int, int, int)`\n+fail_compilation/constraints_func3.d(59): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()(int, int, int)`\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n   with `A = int,\n        T = (int, int)`"}, {"sha": "4048baed69cbe5677eac6916d1e2d54e4d3378af", "filename": "gcc/testsuite/gdc.test/fail_compilation/constraints_func4.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func4.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func4.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fconstraints_func4.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3,7 +3,7 @@ EXTRA_FILES: imports/constraints.d\n REQUIRED_ARGS: -verrors=context\n TEST_OUTPUT:\n ---\n-fail_compilation/constraints_func4.d(90): Error: template `imports.constraints.overload` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func4.d(90): Error: none of the overloads of template `imports.constraints.overload` are callable using argument types `!()(int)`\n     overload(0);\n             ^\n fail_compilation/imports/constraints.d(39):        Candidates are: `overload(T)(T v)`\n@@ -24,7 +24,7 @@ void overload(T)(T v1, T v2) if (N!T);\n fail_compilation/imports/constraints.d(42):                        `overload(T, V)(T v1, V v2)`\n void overload(T, V)(T v1, V v2) if (N!T || N!V);\n      ^\n-fail_compilation/constraints_func4.d(91): Error: template `imports.constraints.overload` cannot deduce function from argument types `!()(int, string)`\n+fail_compilation/constraints_func4.d(91): Error: none of the overloads of template `imports.constraints.overload` are callable using argument types `!()(int, string)`\n     overload(0, \"\");\n             ^\n fail_compilation/imports/constraints.d(39):        Candidates are: `overload(T)(T v)`\n@@ -44,13 +44,13 @@ fail_compilation/imports/constraints.d(42):                        `overload(T,\n        N!V`\n void overload(T, V)(T v1, V v2) if (N!T || N!V);\n      ^\n-fail_compilation/constraints_func4.d(93): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()()`\n+fail_compilation/constraints_func4.d(93): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()()`\n     variadic();\n             ^\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n void variadic(A, T...)(A a, T v) if (N!int);\n      ^\n-fail_compilation/constraints_func4.d(94): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()(int)`\n+fail_compilation/constraints_func4.d(94): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()(int)`\n     variadic(0);\n             ^\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n@@ -60,7 +60,7 @@ fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T.\n `       N!int`\n void variadic(A, T...)(A a, T v) if (N!int);\n      ^\n-fail_compilation/constraints_func4.d(95): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()(int, int)`\n+fail_compilation/constraints_func4.d(95): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()(int, int)`\n     variadic(0, 1);\n             ^\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`\n@@ -70,7 +70,7 @@ fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T.\n `       N!int`\n void variadic(A, T...)(A a, T v) if (N!int);\n      ^\n-fail_compilation/constraints_func4.d(96): Error: template `imports.constraints.variadic` cannot deduce function from argument types `!()(int, int, int)`\n+fail_compilation/constraints_func4.d(96): Error: none of the overloads of template `imports.constraints.variadic` are callable using argument types `!()(int, int, int)`\n     variadic(0, 1, 2);\n             ^\n fail_compilation/imports/constraints.d(43):        Candidate is: `variadic(A, T...)(A a, T v)`"}, {"sha": "aa43727101012d79779d26688c58424f55be62b5", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag11819b.d", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11819b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11819b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11819b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,25 +1,24 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag11819b.d(28): Error: unrecognized trait `HasMember`, did you mean `hasMember`?\n-fail_compilation/diag11819b.d(29): Error: unrecognized trait `Identifier`, did you mean `identifier`?\n-fail_compilation/diag11819b.d(30): Error: unrecognized trait `GetProtection`, did you mean `getProtection`?\n-fail_compilation/diag11819b.d(31): Error: unrecognized trait `Parent`, did you mean `parent`?\n-fail_compilation/diag11819b.d(32): Error: unrecognized trait `GetMember`, did you mean `getMember`?\n-fail_compilation/diag11819b.d(33): Error: unrecognized trait `GetOverloads`, did you mean `getOverloads`?\n-fail_compilation/diag11819b.d(34): Error: unrecognized trait `GetVirtualFunctions`, did you mean `getVirtualFunctions`?\n-fail_compilation/diag11819b.d(35): Error: unrecognized trait `GetVirtualMethods`, did you mean `getVirtualMethods`?\n-fail_compilation/diag11819b.d(36): Error: unrecognized trait `ClassInstanceSize`, did you mean `classInstanceSize`?\n-fail_compilation/diag11819b.d(37): Error: unrecognized trait `AllMembers`, did you mean `allMembers`?\n-fail_compilation/diag11819b.d(38): Error: unrecognized trait `DerivedMembers`, did you mean `derivedMembers`?\n-fail_compilation/diag11819b.d(39): Error: unrecognized trait `IsSame`, did you mean `isSame`?\n-fail_compilation/diag11819b.d(40): Error: unrecognized trait `Compiles`, did you mean `compiles`?\n-fail_compilation/diag11819b.d(41): Error: unrecognized trait `Parameters`\n-fail_compilation/diag11819b.d(42): Error: unrecognized trait `GetAliasThis`, did you mean `getAliasThis`?\n-fail_compilation/diag11819b.d(43): Error: unrecognized trait `GetAttributes`, did you mean `getAttributes`?\n-fail_compilation/diag11819b.d(44): Error: unrecognized trait `GetFunctionAttributes`, did you mean `getFunctionAttributes`?\n-fail_compilation/diag11819b.d(45): Error: unrecognized trait `GetUnitTests`, did you mean `getUnitTests`?\n-fail_compilation/diag11819b.d(46): Error: unrecognized trait `GetVirtualIndex`, did you mean `getVirtualIndex`?\n+fail_compilation/diag11819b.d(27): Error: unrecognized trait `HasMember`, did you mean `hasMember`?\n+fail_compilation/diag11819b.d(28): Error: unrecognized trait `Identifier`, did you mean `identifier`?\n+fail_compilation/diag11819b.d(29): Error: unrecognized trait `GetProtection`, did you mean `getProtection`?\n+fail_compilation/diag11819b.d(30): Error: unrecognized trait `Parent`, did you mean `parent`?\n+fail_compilation/diag11819b.d(31): Error: unrecognized trait `GetMember`, did you mean `getMember`?\n+fail_compilation/diag11819b.d(32): Error: unrecognized trait `GetOverloads`, did you mean `getOverloads`?\n+fail_compilation/diag11819b.d(33): Error: unrecognized trait `GetVirtualFunctions`, did you mean `getVirtualFunctions`?\n+fail_compilation/diag11819b.d(34): Error: unrecognized trait `GetVirtualMethods`, did you mean `getVirtualMethods`?\n+fail_compilation/diag11819b.d(35): Error: unrecognized trait `ClassInstanceSize`, did you mean `classInstanceSize`?\n+fail_compilation/diag11819b.d(36): Error: unrecognized trait `AllMembers`, did you mean `allMembers`?\n+fail_compilation/diag11819b.d(37): Error: unrecognized trait `DerivedMembers`, did you mean `derivedMembers`?\n+fail_compilation/diag11819b.d(38): Error: unrecognized trait `IsSame`, did you mean `isSame`?\n+fail_compilation/diag11819b.d(39): Error: unrecognized trait `Compiles`, did you mean `compiles`?\n+fail_compilation/diag11819b.d(40): Error: unrecognized trait `GetAliasThis`, did you mean `getAliasThis`?\n+fail_compilation/diag11819b.d(41): Error: unrecognized trait `GetAttributes`, did you mean `getAttributes`?\n+fail_compilation/diag11819b.d(42): Error: unrecognized trait `GetFunctionAttributes`, did you mean `getFunctionAttributes`?\n+fail_compilation/diag11819b.d(43): Error: unrecognized trait `GetUnitTests`, did you mean `getUnitTests`?\n+fail_compilation/diag11819b.d(44): Error: unrecognized trait `GetVirtualIndex`, did you mean `getVirtualIndex`?\n ---\n */\n \n@@ -38,7 +37,6 @@ void main()\n     if (__traits(DerivedMembers)) { }\n     if (__traits(IsSame)) { }\n     if (__traits(Compiles)) { }\n-    if (__traits(Parameters)) { }\n     if (__traits(GetAliasThis)) { }\n     if (__traits(GetAttributes)) { }\n     if (__traits(GetFunctionAttributes)) { }"}, {"sha": "88e8a9d062256e0ea7ce9c4c157d584c7b490523", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag13333.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13333.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13333.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13333.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-TEST_OUTPUT*\n+TEST_OUTPUT:\n ---\n fail_compilation/diag13333.d(29): Error: template instance `VariantN!(maxSize!(S), T)` recursive template expansion\n fail_compilation/diag13333.d(29): Error: template instance `diag13333.maxSize!(S)` error instantiating"}, {"sha": "aeee10749c15fd890f863ea1fd683be310760dcd", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag13942.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13942.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13942.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag13942.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/diag13942.d(18): Error: template instance `isRawStaticArray!()` does not match template declaration `isRawStaticArray(T, A...)`\n-fail_compilation/diag13942.d(26): Error: template `diag13942.to!double.to` cannot deduce function from argument types `!()()`\n+fail_compilation/diag13942.d(26): Error: none of the overloads of template `diag13942.to!double.to` are callable using argument types `!()()`\n fail_compilation/diag13942.d(17):        Candidate is: `to(A...)(A args)`\n ---\n */"}, {"sha": "e2095937448142b4e96564c2a99418f1cb68ca14", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag16271.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16271.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/diag16271.d(10): Error: found `x` when expecting function literal following `ref`\n ---"}, {"sha": "9d8dcfdca0cd6316a17ea2dab755cd5a72de2bef", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag16977.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16977.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16977.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag16977.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3,7 +3,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/diag16977.d(25): Error: undefined identifier `undefined`, did you mean function `undefinedId`?\n fail_compilation/diag16977.d(26): Error: cannot implicitly convert expression `\"\\x01string\"` of type `string` to `int`\n-fail_compilation/diag16977.d(27): Error: template `diag16977.templ` cannot deduce function from argument types `!()(int)`\n+fail_compilation/diag16977.d(27): Error: none of the overloads of template `diag16977.templ` are callable using argument types `!()(int)`\n fail_compilation/diag16977.d(20):        Candidate is: `templ(S)(S s)`\n   with `S = int`\n   must satisfy the following constraint:"}, {"sha": "a43a7e10e07ac2e5802a8ef1bd545790de9ccd58", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag19225.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag19225.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag19225.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag19225.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -4,7 +4,7 @@ TEST_OUTPUT:\n fail_compilation/diag19225.d(14): Error: basic type expected, not `else`\n fail_compilation/diag19225.d(14):        There's no `static else`, use `else` instead.\n fail_compilation/diag19225.d(14): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n-fail_compilation/diag19225.d(15): Error: unrecognized declaration\n+fail_compilation/diag19225.d(15): Error: unmatched closing brace\n ---\n */\n "}, {"sha": "282665ff8d517aa6bf5242415ce7a45d74dc6a79", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8101.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8101.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -13,12 +13,12 @@ fail_compilation/diag8101.d(38):                        `diag8101.f_2(int, int,\n fail_compilation/diag8101.d(39):                        `diag8101.f_2(int, int, int, int)`\n fail_compilation/diag8101.d(40):                        `diag8101.f_2(int, int, int, int, int)`\n fail_compilation/diag8101.d(59):        ... (1 more, -v to show) ...\n-fail_compilation/diag8101.d(61): Error: template `diag8101.t_0` cannot deduce function from argument types `!()()`\n+fail_compilation/diag8101.d(61): Error: none of the overloads of template `diag8101.t_0` are callable using argument types `!()()`\n fail_compilation/diag8101.d(43):        Candidate is: `t_0(T1)()`\n-fail_compilation/diag8101.d(62): Error: template `diag8101.t_1` cannot deduce function from argument types `!()()`\n+fail_compilation/diag8101.d(62): Error: none of the overloads of template `diag8101.t_1` are callable using argument types `!()()`\n fail_compilation/diag8101.d(45):        Candidates are: `t_1(T1)()`\n fail_compilation/diag8101.d(46):                        `t_1(T1, T2)()`\n-fail_compilation/diag8101.d(63): Error: template `diag8101.t_2` cannot deduce function from argument types `!()()`\n+fail_compilation/diag8101.d(63): Error: none of the overloads of template `diag8101.t_2` are callable using argument types `!()()`\n fail_compilation/diag8101.d(48):        Candidates are: `t_2(T1)()`\n fail_compilation/diag8101.d(49):                        `t_2(T1, T2)()`\n fail_compilation/diag8101.d(50):                        `t_2(T1, T2, T3)()`"}, {"sha": "a04ed7c0a42c1574034f0a8a94d18c5131379f99", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8648.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8648.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8648.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8648.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,13 +2,13 @@\n TEST_OUTPUT:\n ---\n fail_compilation/diag8648.d(18): Error: undefined identifier `X`\n-fail_compilation/diag8648.d(29): Error: template `diag8648.foo` cannot deduce function from argument types `!()(Foo!(int, 1))`\n+fail_compilation/diag8648.d(29): Error: none of the overloads of template `diag8648.foo` are callable using argument types `!()(Foo!(int, 1))`\n fail_compilation/diag8648.d(18):        Candidate is: `foo(T, n)(X!(T, n))`\n fail_compilation/diag8648.d(20): Error: undefined identifier `a`\n-fail_compilation/diag8648.d(31): Error: template `diag8648.bar` cannot deduce function from argument types `!()(Foo!(int, 1))`\n+fail_compilation/diag8648.d(31): Error: none of the overloads of template `diag8648.bar` are callable using argument types `!()(Foo!(int, 1))`\n fail_compilation/diag8648.d(20):        Candidate is: `bar(T)(Foo!(T, a))`\n fail_compilation/diag8648.d(20): Error: undefined identifier `a`\n-fail_compilation/diag8648.d(32): Error: template `diag8648.bar` cannot deduce function from argument types `!()(Foo!(int, f))`\n+fail_compilation/diag8648.d(32): Error: none of the overloads of template `diag8648.bar` are callable using argument types `!()(Foo!(int, f))`\n fail_compilation/diag8648.d(20):        Candidate is: `bar(T)(Foo!(T, a))`\n ---\n */"}, {"sha": "9fbbebfd932d83a408e00958b0e38a3639e121d1", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag8684.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8684.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8684.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag8684.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,8 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag8684.d(11): Error: found `;` when expecting `)`\n-fail_compilation/diag8684.d(12): Error: semicolon expected, not `for`\n+fail_compilation/diag8684.d(12): Error: found `;` when expecting `)`\n+fail_compilation/diag8684.d(13): Error: semicolon needed to end declaration of `x`, instead of `for`\n+fail_compilation/diag8684.d(12):        `x` declared here\n ---\n */\n "}, {"sha": "37d5bd84f32b4e6df8b853fd056eba4e358c9734", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag9004.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9004.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9004.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9004.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag9004.d(21): Error: template `diag9004.bar` cannot deduce function from argument types `!()(Foo!int, int)`\n+fail_compilation/diag9004.d(21): Error: none of the overloads of template `diag9004.bar` are callable using argument types `!()(Foo!int, int)`\n fail_compilation/diag9004.d(14):        Candidate is: `bar(FooT)(FooT foo, FooT.T x)`\n ---\n */"}, {"sha": "92cb47f9500e867a08583d80beda46b4ea8fd5bf", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag9420.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9420.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9420.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag9420.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/diag9420.d(21): Error: function `diag9420.S.t3!().tx()` is not callable using argument types `(int)`\n fail_compilation/diag9420.d(21):        expected 0 argument(s), not 1"}, {"sha": "eb88a23151a76b4d71cdbbe8c4fee8e8ac72cabd", "filename": "gcc/testsuite/gdc.test/fail_compilation/diagin.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiagin.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -4,7 +4,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/diagin.d(14): Error: function `diagin.foo(in int)` is not callable using argument types `()`\n fail_compilation/diagin.d(14):        missing argument for parameter #1: `in int`\n-fail_compilation/diagin.d(16): Error: template `diagin.foo1` cannot deduce function from argument types `!()(bool[])`\n+fail_compilation/diagin.d(16): Error: none of the overloads of template `diagin.foo1` are callable using argument types `!()(bool[])`\n fail_compilation/diagin.d(20):        Candidate is: `foo1(T)(in T v, string)`\n ---\n  */"}, {"sha": "4e803bebfd43735ede61e091eb34d2811111a94c", "filename": "gcc/testsuite/gdc.test/fail_compilation/dip25.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdip25.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3,7 +3,7 @@ REQUIRED_ARGS: -de\n TEST_OUTPUT:\n ---\n fail_compilation/dip25.d(17): Deprecation: returning `this.buffer[]` escapes a reference to parameter `this`\n-fail_compilation/dip25.d(17):        perhaps annotate the parameter with `return`\n+fail_compilation/dip25.d(17):        perhaps annotate the function with `return`\n fail_compilation/dip25.d(22): Error: returning `identity(x)` escapes a reference to local variable `x`\n fail_compilation/dip25.d(23): Deprecation: returning `identity(x)` escapes a reference to parameter `x`\n fail_compilation/dip25.d(23):        perhaps annotate the parameter with `return`"}, {"sha": "de3673f7860de589119d005b02fc0f046019489d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail10964.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10964.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10964.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail10964.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -5,8 +5,8 @@ fail_compilation/fail10964.d(28): Error: function `fail10964.S.__postblit` is no\n fail_compilation/fail10964.d(29): Error: function `fail10964.S.__postblit` is not `nothrow`\n fail_compilation/fail10964.d(30): Error: function `fail10964.S.__postblit` is not `nothrow`\n fail_compilation/fail10964.d(33): Error: function `fail10964.S.__postblit` is not `nothrow`\n-fail_compilation/fail10964.d(34): Error: function `core.internal.array.construction._d_arraysetctor!(S[], S)._d_arraysetctor` is not `nothrow`\n-fail_compilation/fail10964.d(35): Error: function `core.internal.array.construction._d_arrayctor!(S[], S)._d_arrayctor` is not `nothrow`\n+fail_compilation/fail10964.d(34): Error: function `fail10964.S.__postblit` is not `nothrow`\n+fail_compilation/fail10964.d(35): Error: function `fail10964.S.__postblit` is not `nothrow`\n fail_compilation/fail10964.d(22): Error: `nothrow` function `fail10964.foo` may throw\n ---\n */"}, {"sha": "379e86bf5f3473813060d6bfd98d5489d0e71c00", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11453a.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11453a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11453a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11453a.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // REQUIRED_ARGS: -Ifail_compilation/extra-files\n // EXTRA_SOURCES: extra-files/foo11453.d extra-files/bar11453.d\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/extra-files/bar11453.d(1): Error: package name 'foo11453' conflicts with usage as a module name in file fail_compilation/extra-files/foo11453.d\n ---"}, {"sha": "4e99395ac67b8aeb345fa70703d4702480f4fd88", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11453b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11453b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11453b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11453b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // REQUIRED_ARGS: -Ifail_compilation/extra-files\n // EXTRA_SOURCES: extra-files/bar11453.d extra-files/foo11453.d\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/extra-files/foo11453.d(1): Error: module `foo11453` from file fail_compilation/extra-files/foo11453.d conflicts with package name foo11453\n ---"}, {"sha": "4eeb9bea521768e58a6d092a4be0749e81d63e0c", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail11653.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11653.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11653.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail11653.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,9 +1,8 @@\n-// REQUIRED_ARGS: -de\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail11653.d(19): Deprecation: switch case fallthrough - use 'goto case;' if intended\n-fail_compilation/fail11653.d(24): Deprecation: switch case fallthrough - use 'goto default;' if intended\n+fail_compilation/fail11653.d(18): Error: switch case fallthrough - use 'goto case;' if intended\n+fail_compilation/fail11653.d(23): Error: switch case fallthrough - use 'goto default;' if intended\n ---\n */\n "}, {"sha": "2056c0e2a27d60f95fba4944038be30305ac0880", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail12744.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12744.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12744.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail12744.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -14,10 +14,10 @@ fail_compilation/fail12744.d(61): Error: template instance `fail12744.bar12744L!\n fail_compilation/fail12744.d(40): Error: incompatible parameter storage classes `lazy` and `out`\n fail_compilation/fail12744.d(62): Error: template instance `fail12744.bar12744L!(foo12744O)` error instantiating\n fail_compilation/fail12744.d(41): Error: incompatible parameter storage classes `auto ref` and `out`\n-fail_compilation/fail12744.d(67): Error: template `fail12744.bar12744A` cannot deduce function from argument types `!(foo12744O)(int)`\n+fail_compilation/fail12744.d(67): Error: none of the overloads of template `fail12744.bar12744A` are callable using argument types `!(foo12744O)(int)`\n fail_compilation/fail12744.d(41):        Candidate is: `bar12744A(alias f)(auto ref PTT12744!f args)`\n fail_compilation/fail12744.d(41): Error: incompatible parameter storage classes `auto ref` and `lazy`\n-fail_compilation/fail12744.d(68): Error: template `fail12744.bar12744A` cannot deduce function from argument types `!(foo12744L)(int)`\n+fail_compilation/fail12744.d(68): Error: none of the overloads of template `fail12744.bar12744A` are callable using argument types `!(foo12744L)(int)`\n fail_compilation/fail12744.d(41):        Candidate is: `bar12744A(alias f)(auto ref PTT12744!f args)`\n ---\n */"}, {"sha": "58ce8a1a6bc04e65ca371291abf5d8dea825326b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail132.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail132.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail132.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail132.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail132.d(19): Error: outer class `A` `this` needed to `new` nested class `B`\n+fail_compilation/fail132.d(19): Error: cannot construct nested class `B` because no implicit `this` reference to outer class `A` is available\n ---\n */\n "}, {"sha": "be72663b28e48e66f7d3da89d25714aabd4aadb6", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail14669.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14669.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14669.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail14669.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -4,7 +4,7 @@ TEST_OUTPUT:\n fail_compilation/fail14669.d(11): Error: `auto` can only be used as part of `auto ref` for template function parameters\n fail_compilation/fail14669.d(16): Error: template instance `fail14669.foo1!()` error instantiating\n fail_compilation/fail14669.d(12): Error: `auto` can only be used as part of `auto ref` for template function parameters\n-fail_compilation/fail14669.d(17): Error: template `fail14669.foo2` cannot deduce function from argument types `!()(int)`\n+fail_compilation/fail14669.d(17): Error: none of the overloads of template `fail14669.foo2` are callable using argument types `!()(int)`\n fail_compilation/fail14669.d(12):        Candidate is: `foo2()(auto int a)`\n ---\n */"}, {"sha": "a537f108e28dc8915b5ca283ad3487f0c75c9631", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail162.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail162.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail162.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail162.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail162.d(25): Error: template `fail162.testHelper` cannot deduce function from argument types `!()(string, string)`\n+fail_compilation/fail162.d(25): Error: none of the overloads of template `fail162.testHelper` are callable using argument types `!()(string, string)`\n fail_compilation/fail162.d(10):        Candidate is: `testHelper(A...)()`\n fail_compilation/fail162.d(30): Error: template instance `fail162.test!(\"hello\", \"world\")` error instantiating\n ---"}, {"sha": "7da7bd1d597f379c2c4a0df0eca2994a1dc03c67", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail18417.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18417.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18417.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail18417.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// REQUIRED_ARGS : -de\n+// REQUIRED_ARGS: -de\n /*\n TEST_OUTPUT:\n ---"}, {"sha": "c7b28cf8521844f5e5bc17a04e394fbeefeed4b9", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail196.d", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail196.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail196.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail196.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,23 +1,24 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail196.d(26): Error: delimited string must end in )\"\n-fail_compilation/fail196.d(26): Error: Implicit string concatenation is error-prone and disallowed in D\n-fail_compilation/fail196.d(26):        Use the explicit syntax instead (concatenating literals is `@nogc`): \"foo(xxx)\" ~ \";\\x0a    assert(s == \"\n-fail_compilation/fail196.d(27): Error: semicolon expected, not `foo`\n-fail_compilation/fail196.d(27): Error: found `\");\\x0a\\x0a    s = q\"` when expecting `;` following statement\n-fail_compilation/fail196.d(29): Error: found `\";\\x0a    assert(s == \"` when expecting `;` following statement\n-fail_compilation/fail196.d(30): Error: found `\");\\x0a\\x0a    s = q\"` when expecting `;` following statement\n-fail_compilation/fail196.d(32): Error: found `{` when expecting `;` following statement\n-fail_compilation/fail196.d(32): Error: found `}` when expecting `;` following statement\n-fail_compilation/fail196.d(33): Error: found `foo` when expecting `;` following statement\n+fail_compilation/fail196.d(27): Error: delimited string must end in )\"\n+fail_compilation/fail196.d(27): Error: Implicit string concatenation is error-prone and disallowed in D\n+fail_compilation/fail196.d(27):        Use the explicit syntax instead (concatenating literals is `@nogc`): \"foo(xxx)\" ~ \";\\x0a    assert(s == \"\n+fail_compilation/fail196.d(28): Error: semicolon needed to end declaration of `s`, instead of `foo`\n+fail_compilation/fail196.d(27):        `s` declared here\n+fail_compilation/fail196.d(28): Error: found `\");\\x0a\\x0a    s = q\"` when expecting `;` following statement\n+fail_compilation/fail196.d(30): Error: found `\";\\x0a    assert(s == \"` when expecting `;` following statement\n+fail_compilation/fail196.d(31): Error: found `\");\\x0a\\x0a    s = q\"` when expecting `;` following statement\n+fail_compilation/fail196.d(33): Error: found `{` when expecting `;` following statement\n fail_compilation/fail196.d(33): Error: found `}` when expecting `;` following statement\n-fail_compilation/fail196.d(35): Error: found `<` when expecting `;` following statement\n-fail_compilation/fail196.d(36): Error: found `foo` when expecting `;` following statement\n-fail_compilation/fail196.d(36): Error: found `<` instead of statement\n-fail_compilation/fail196.d(42): Error: unterminated string constant starting at fail_compilation/fail196.d(42)\n-fail_compilation/fail196.d(44): Error: found `End of File` when expecting `}` following compound statement\n-fail_compilation/fail196.d(44): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/fail196.d(34): Error: found `foo` when expecting `;` following statement\n+fail_compilation/fail196.d(34): Error: found `}` when expecting `;` following statement\n+fail_compilation/fail196.d(36): Error: found `<` when expecting `;` following statement\n+fail_compilation/fail196.d(37): Error: found `foo` when expecting `;` following statement\n+fail_compilation/fail196.d(37): Error: found `<` instead of statement\n+fail_compilation/fail196.d(43): Error: unterminated string constant starting at fail_compilation/fail196.d(43)\n+fail_compilation/fail196.d(45): Error: found `End of File` when expecting `}` following compound statement\n+fail_compilation/fail196.d(45): Error: found `End of File` when expecting `}` following compound statement\n ---\n */\n "}, {"sha": "d2e146c79eed023c8bc97b866eb00d074b3e9443", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19609.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19609.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19609.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19609.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // https://issues.dlang.org/show_bug.cgi?id=19609\n /*\n EXTRA_FILES: imports/fail19609a.d imports/fail19609b.d imports/fail19609c.d imports/fail19609d.d\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/imports/fail19609a.d(1): Error: `string` expected for deprecation message, not `([\"\"])` of type `string[]`\n fail_compilation/fail19609.d(16): Deprecation: module `imports.fail19609a` is deprecated"}, {"sha": "4f5804bc7130508c0cb4cc30eaf728d6d1c392d4", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail19897.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19897.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19897.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail19897.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/fail19897.d(9): Error: cannot implicitly convert expression `[]` of type `const(char[0])` to `const(char)`\n ---"}, {"sha": "2fec197c04bfcc0cceb30accd9cc4f6e97aefcbc", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail207.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail207.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail207.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail207.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,8 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail207.d(10): Error: found end of file instead of initializer\n-fail_compilation/fail207.d(10): Error: semicolon expected, not `End of File`\n+fail_compilation/fail207.d(11): Error: found end of file instead of initializer\n+fail_compilation/fail207.d(11): Error: semicolon needed to end declaration of `x`, instead of `End of File`\n+fail_compilation/fail207.d(10):        `x` declared here\n ---\n */\n "}, {"sha": "00dd9fd7cba48e50f0bfa4b81a3e534c0d085f77", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20730b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20730b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20730b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20730b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3,7 +3,7 @@ REQUIRED_ARGS: -verrors=spec -o-\n TEST_OUTPUT:\n ---\n (spec:1) fail_compilation/fail20730b.d-mixin-43(43): Error: C style cast illegal, use `cast(int)mod`\n-fail_compilation/fail20730b.d(26): Error: template `fail20730b.atomicOp` cannot deduce function from argument types `!(\"+=\")(shared(uint), int)`\n+fail_compilation/fail20730b.d(26): Error: none of the overloads of template `fail20730b.atomicOp` are callable using argument types `!(\"+=\")(shared(uint), int)`\n fail_compilation/fail20730b.d(41):        Candidate is: `atomicOp(string op, T, V1)(shared ref T val, V1 mod)`\n   with `op = \"+=\",\n        T = uint,"}, {"sha": "2e0f84b7777cd878da08596b35501cc01e77d3bb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21830.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21830.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21830.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21830.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /* REQUIRED_ARGS: -de -unittest\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/fail21830.d(24): Deprecation: struct `fail21830.OldS21830` is deprecated - Deprecated type\n fail_compilation/fail21830.d(24): Deprecation: template `fail21830.test21830(T)(T t) if (is(T == OldS21830))` is deprecated - Deprecated template"}, {"sha": "39551332e934d66f09bdc573dbea6e902592fb29", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21831.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21831.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21831.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21831.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /* REQUIRED_ARGS: -de -unittest\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/fail21831.d(19): Deprecation: struct `fail21831.S21831` is deprecated - Deprecated type\n fail_compilation/fail21831.d(19): Deprecation: template `fail21831.test21831(T)(T t) if (__traits(isDeprecated, T))` is deprecated - Deprecated template"}, {"sha": "98f3df71a15c01f208f77475fe2e66280930b2df", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail21832.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21832.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21832.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail21832.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // REQUIRED_ARGS: -de\n // EXTRA_FILES: imports/imp21832.d\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/fail21832.d(4): Deprecation: function `imports.imp21832.fun` is deprecated\n fail_compilation/fail21832.d(10): Deprecation: template `imports.imp21832.tpl()(char a)` is deprecated"}, {"sha": "d3905d7fece623220097171bbfef5eab08a507bb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail220.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail220.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail220.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail220.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -5,7 +5,7 @@ fail_compilation/fail220.d(12): Error: identifier expected for template value pa\n fail_compilation/fail220.d(12): Error: found `==` when expecting `)`\n fail_compilation/fail220.d(12): Error: found `class` when expecting `)`\n fail_compilation/fail220.d(12): Error: declaration expected, not `)`\n-fail_compilation/fail220.d(16): Error: unrecognized declaration\n+fail_compilation/fail220.d(16): Error: unmatched closing brace\n ---\n */\n template types (T) {"}, {"sha": "2e67b4dbea943f052b3c327f70292f548a6a568e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22035.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22035.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22035.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22035.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n // https://issues.dlang.org/show_bug.cgi?id=22035\n-/* TEST_OUTPUT\n+/* TEST_OUTPUT:\n ---\n fail_compilation/fail22035.d(10): Error: found `2` when expecting `:`\n fail_compilation/fail22035.d(10): Error: found `:` instead of statement"}, {"sha": "b0ae7224da52f4d74d6cf0c9409ad100f58516a4", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22084.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22084.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22084.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22084.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // https://issues.dlang.org/show_bug.cgi?id=22084\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/fail22084.d(22): Error: cannot pass types that need destruction as variadic arguments\n ---"}, {"sha": "a30d430f694673f61365be32b32e8b69d8166f99", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22133.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22133.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22133.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22133.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // https://issues.dlang.org/show_bug.cgi?id=22133\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/fail22133.d(16): Error: `s.popFront()()` has no effect\n fail_compilation/fail22133.d(17): Error: template `s.popFront()()` has no type"}, {"sha": "694c1e9955e9a3905902a1ecccd2eece8f1550d5", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22144.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22144.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22144.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22144.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n // https://issues.dlang.org/show_bug.cgi?id=22144\n-/* TEST_OUTPUT\n+/* TEST_OUTPUT:\n ---\n fail_compilation/fail22144.d(12): Error: cannot cast expression `zarray1` of type `int[0]` to `int[0][]` since sizes don't line up\n ---"}, {"sha": "56ccac64fae2a551ebc8b51c5c5233e4b77ccfea", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22749.d", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22749.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22749.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22749.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,13 @@\n+// EXTRA_FILES: imports/imp22749.c\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/fail22749.d(12): Error: cannot take address of bit-field `field`\n+---\n+*/\n+import imports.imp22749;\n+\n+void test22749()\n+{\n+    S22749 s;\n+    void* ptr = &s.field;\n+}"}, {"sha": "626ec0090f13f68ccac7060bbeb414b62f872722", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail236.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail236.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail236.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail236.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail236.d(14): Error: undefined identifier `x`\n-fail_compilation/fail236.d(22): Error: template `fail236.Templ2` cannot deduce function from argument types `!()(int)`\n+fail_compilation/fail236.d(22): Error: none of the overloads of template `fail236.Templ2` are callable using argument types `!()(int)`\n fail_compilation/fail236.d(12):        Candidate is: `Templ2(alias a)(x)`\n ---\n */"}, {"sha": "b5a99a9b9807769eee2a1aaa4e0eaf46ec58c2a0", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail276.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail276.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail276.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail276.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/fail276.d(19): Error: `this` has no effect\n-fail_compilation/fail276.d(15): Error: `this` is only defined in non-static member functions, not `__anonclass2`\n+fail_compilation/fail276.d(15): Error: cannot construct anonymous nested class because no implicit `this` reference to outer class is available\n ---\n */\n "}, {"sha": "8a95b34e891efb66e544b838dd6cd19192cbe60f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail4269e.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269e.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269e.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail4269e.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail4269e.d(10): Error: semicolon expected, not `X5`\n+fail_compilation/fail4269e.d(10): Error: semicolon needed to end declaration of `Y` instead of `X5`\n fail_compilation/fail4269e.d(10): Error: no identifier for declarator `X5`\n ---\n */"}, {"sha": "536049561deae7cdd1017b079827f05d8a4203fb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail59.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail59.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail59.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail59.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail59.d(50): Error: outer class `C1` `this` needed to `new` nested class `C2`\n+fail_compilation/fail59.d(50): Error: cannot construct nested class `C2` because no implicit `this` reference to outer class `C1` is available\n ---\n */\n "}, {"sha": "137dfa9eb52093bbec229084f35f5be13484e86d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail60.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail60.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail60.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail60.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail60.d(14): Error: `this` is only defined in non-static member functions, not `A`\n+fail_compilation/fail60.d(14): Error: cannot construct nested class `B` because no implicit `this` reference to outer class `A` is available\n ---\n */\n class A"}, {"sha": "235e4809d145f0decbdef9307b847b221136bcc4", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail8009.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail8009.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail8009.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail8009.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail8009.d(9): Error: template `fail8009.filter` cannot deduce function from argument types `!()(void)`\n+fail_compilation/fail8009.d(9): Error: none of the overloads of template `fail8009.filter` are callable using argument types `!()(void)`\n fail_compilation/fail8009.d(8):        Candidate is: `filter(R)(scope bool delegate(ref BAD!R) func)`\n ---\n */"}, {"sha": "7057a01bf0bb5e9361fabf89fe54395345a142b9", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail95.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail95.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail95.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail95.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail95.d(19): Error: template `fail95.A` cannot deduce function from argument types `!()(int)`\n+fail_compilation/fail95.d(19): Error: none of the overloads of template `fail95.A` are callable using argument types `!()(int)`\n fail_compilation/fail95.d(11):        Candidate is: `A(alias T)(T)`\n ---\n */"}, {"sha": "27f55e065073e80bc1e32dff0ec92866a04cf9d3", "filename": "gcc/testsuite/gdc.test/fail_compilation/fix17635.d", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix17635.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix17635.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix17635.d?ref=023327643969d5469902a9ecfa6738a315f9e362", "patch": "@@ -1,23 +0,0 @@\n-/* REQUIRED_ARGS: -preview=dip1000\n-TEST_OUTPUT:\n----\n-fail_compilation/fix17635.d(22): Error: cannot implicitly convert expression `f(& p)` of type `immutable(int)**` to `immutable(int**)`\n----\n-*/\n-// https://issues.dlang.org/show_bug.cgi?id=17635\n-// https://issues.dlang.org/show_bug.cgi?id=15660\n-\n-alias T = immutable int;\n-\n-T** f(const T** input) pure\n-{\n-    T** output;\n-    return output;\n-}\n-\n-void main()\n-{\n-    T i;\n-    T* p = &i;\n-    immutable T** r = f(&p);\n-}"}, {"sha": "1e51a06ef7335bf3d822f14f45f4ae915cd21e19", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice11856_0.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_0.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_0.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_0.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice11856_0.d(19): Error: template `ice11856_0.f` cannot deduce function from argument types `!()(int)`\n+fail_compilation/ice11856_0.d(19): Error: none of the overloads of template `ice11856_0.f` are callable using argument types `!()(int)`\n fail_compilation/ice11856_0.d(13):        Candidates are: `f(T)(T t)`\n fail_compilation/ice11856_0.d(16):                        `f(T)(T t)`\n   with `T = int`"}, {"sha": "d2a1d1dbcc5e5652f3394f254061866f5b1c8622", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice11856_1.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_1.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice11856_1.d(13): Error: template `ice11856_1.g` cannot deduce function from argument types `!()(A)`\n+fail_compilation/ice11856_1.d(13): Error: none of the overloads of template `ice11856_1.g` are callable using argument types `!()(A)`\n fail_compilation/ice11856_1.d(11):        Candidate is: `g(T)(T x)`\n ---\n */"}, {"sha": "c64fb848484198f2a1e0499b1ee421d88c4275bd", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice14130.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14130.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14130.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14130.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/ice14130.d(10): Error: undefined identifier `Undef`\n-fail_compilation/ice14130.d(14): Error: template `ice14130.foo` cannot deduce function from argument types `!()(int)`\n+fail_compilation/ice14130.d(14): Error: none of the overloads of template `ice14130.foo` are callable using argument types `!()(int)`\n fail_compilation/ice14130.d(10):        Candidate is: `foo(R, F = Undef)(R r, F s = 0)`\n ---\n */"}, {"sha": "e1d7aac9f3c1729a083d7b54cfc8907aee21159d", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice14907.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14907.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14907.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice14907.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -6,7 +6,7 @@ fail_compilation/ice14907.d(19):        while looking for match for `S!()`\n fail_compilation/ice14907.d(15): Error: template `ice14907.f(int v = f)()` recursive template expansion\n fail_compilation/ice14907.d(20):        while looking for match for `f!()`\n fail_compilation/ice14907.d(15): Error: template `ice14907.f(int v = f)()` recursive template expansion\n-fail_compilation/ice14907.d(21): Error: template `ice14907.f` cannot deduce function from argument types `!()()`\n+fail_compilation/ice14907.d(21): Error: none of the overloads of template `ice14907.f` are callable using argument types `!()()`\n fail_compilation/ice14907.d(15):        Candidate is: `f(int v = f)()`\n ---\n */"}, {"sha": "f7c639d500a22fa20e5656d2e669dae25ca22b49", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice6538.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice6538.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice6538.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice6538.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -7,7 +7,7 @@\n TEST_OUTPUT:\n ---\n fail_compilation/ice6538.d(23): Error: expression `super` is not a valid template value argument\n-fail_compilation/ice6538.d(28): Error: template `ice6538.D.foo` cannot deduce function from argument types `!()()`\n+fail_compilation/ice6538.d(28): Error: none of the overloads of template `ice6538.D.foo` are callable using argument types `!()()`\n fail_compilation/ice6538.d(23):        Candidate is: `foo()()`\n ---\n */"}, {"sha": "00602d2de81168a612590f4625515e7ede0ca773", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice9284.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9284.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9284.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice9284.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice9284.d(14): Error: template `ice9284.C.__ctor` cannot deduce function from argument types `!()(int)`\n+fail_compilation/ice9284.d(14): Error: none of the overloads of template `ice9284.C.__ctor` are callable using argument types `!()(int)`\n fail_compilation/ice9284.d(12):        Candidate is: `__ctor()(string)`\n fail_compilation/ice9284.d(20): Error: template instance `ice9284.C.__ctor!()` error instantiating\n ---"}, {"sha": "9f2a855b9a657c944fea974ada9c27c2e18e0f57", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/imp18554.d", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp18554.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp18554.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp18554.d?ref=023327643969d5469902a9ecfa6738a315f9e362", "patch": "@@ -1,4 +0,0 @@\n-struct S\n-{\n-    private int i;\n-}"}, {"sha": "7c1850e2bcce28371320eee78d4fcba55fa7d8f0", "filename": "gcc/testsuite/gdc.test/fail_compilation/imports/imp22749.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp22749.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp22749.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fimports%2Fimp22749.c?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,4 @@\n+struct S22749\n+{\n+    int field : 1;\n+};"}, {"sha": "a37aa042e1f28bef1da0ff0482e93fd472180671", "filename": "gcc/testsuite/gdc.test/fail_compilation/issue21936.d", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue21936.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue21936.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue21936.d?ref=023327643969d5469902a9ecfa6738a315f9e362", "patch": "@@ -1,32 +0,0 @@\n-/* REQUIRED_ARGS: -preview=dip1000 -Ifail_compilation/imports\n-TEST_OUTPUT:\n----\n-fail_compilation/issue21936.d(15): Error: struct `issue21936s.S` variable `field` is not accessible from `@safe` code\n-fail_compilation/issue21936.d(15): Error: struct `issue21936s.S` variable `field` is not accessible from `@safe` code\n-fail_compilation/issue21936.d(11): Error: template instance `issue21936.constructImplicit!(S)` error instantiating\n-fail_compilation/issue21936.d(7):        instantiated from here: `registerConstructors!(S)`\n-fail_compilation/issue21936.d(21):        instantiated from here: `registerType!(S)`\n----\n-*/\n-#line 2\n-module issue21936;\n-import issue21936s;\n-struct Handlers {\n-    void registerType(T)()\n-    {\n-        registerConstructors!T;\n-    }\n-    void registerConstructors(T)()\n-    {\n-        constructImplicit!T;\n-    }\n-}\n-\n-auto constructImplicit(T)(typeof(T.init.tupleof) x = T.init.tupleof)\n-{\n-}\n-\n-void registerHandlersDateTime(Handlers handlers)\n-{\n-\thandlers.registerType!(S);\n-}"}, {"sha": "696081a36b6521fe5ee5ad5c829ef68ed59348cf", "filename": "gcc/testsuite/gdc.test/fail_compilation/noreturn.d", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -16,8 +16,8 @@ fail_compilation\\noreturn.d(69): Error: `\"Accessed expression of type `noreturn`\n fail_compilation\\noreturn.d(79):        called from here: `casting(1)`\n fail_compilation\\noreturn.d(72): Error: `\"Accessed expression of type `noreturn`\"`\n fail_compilation\\noreturn.d(80):        called from here: `casting(2)`\n+fail_compilation/noreturn.d(120): Error: uncaught CTFE exception `object.Exception(\"\")`\n ---\n-\n https://github.com/dlang/DIPs/blob/master/DIPs/accepted/DIP1034.md\n */\n \n@@ -116,3 +116,5 @@ int inClassRef()\n \n enum forceInClassRef = inClassRef();\n */\n+\n+enum throwEnum = throw new Exception(\"\");"}, {"sha": "2d27d6d84348462c1f633d516c13481d2c937c63", "filename": "gcc/testsuite/gdc.test/fail_compilation/noreturn2.d", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnoreturn2.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -88,3 +88,54 @@ auto returnVoid3(int i)\n     else\n         return doStuff();\n }\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(104): Error: `object.Exception` is thrown but not caught\n+fail_compilation/noreturn2.d(100): Error: `nothrow` function `noreturn2.doesNestedThrow` may throw\n+---\n++/\n+\n+int doesNestedThrow(int i) nothrow\n+{\n+    // Weird formatting is intended to check the loc\n+    return i ? i++ :\n+            throw\n+            new\n+            Exception(\"\")\n+    ;\n+}\n+\n+int doesNestedThrowThrowable(int i) nothrow\n+{\n+    return i ? i++ : throw new Error(\"\");\n+}\n+\n+/+\n+TEST_OUTPUT:\n+---\n+fail_compilation/noreturn2.d(130): Error: cannot create instance of interface `I`\n+fail_compilation/noreturn2.d(133): Error: can only throw class objects derived from `Throwable`, not type `int[]`\n+fail_compilation/noreturn2.d(138): Error: undefined identifier `UnkownException`\n+---\n++/\n+\n+int throwInvalid(int i) nothrow\n+{\n+    static interface I {}\n+    // Weird formatting is intended to check the loc\n+    return\n+            throw\n+            new\n+            I()\n+        ?\n+            throw\n+            new\n+            int[4]\n+        :\n+            throw\n+            new\n+            UnkownException(\"\")\n+    ;\n+}"}, {"sha": "b4d3cd7889cbe720fa73f0cfb75f254332311fbb", "filename": "gcc/testsuite/gdc.test/fail_compilation/objc_class2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_class2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_class2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_class2.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// EXTRA_OBJC_SOURCES\n+// EXTRA_OBJC_SOURCES:\n /*\n TEST_OUTPUT:\n ---"}, {"sha": "cf2480e9549f6215abb7f2ee75089c9ba5f7c884", "filename": "gcc/testsuite/gdc.test/fail_compilation/objc_class3.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_class3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_class3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_class3.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// EXTRA_OBJC_SOURCES\n+// EXTRA_OBJC_SOURCES:\n /*\n TEST_OUTPUT:\n ---"}, {"sha": "9956212d1db25b6b1b3b8af447aba3006d75f3b5", "filename": "gcc/testsuite/gdc.test/fail_compilation/objc_non_objc_base.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_non_objc_base.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_non_objc_base.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fobjc_non_objc_base.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// EXTRA_OBJC_SOURCES\n+// EXTRA_OBJC_SOURCES:\n /*\n TEST_OUTPUT:\n ---"}, {"sha": "86e37e725fda04cbca23b4a2bcaf8c6af584c381", "filename": "gcc/testsuite/gdc.test/fail_compilation/reg6769.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freg6769.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freg6769.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freg6769.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/reg6769.d(14): Error: reinterpreting cast from `int[]` to `int[7]*` is not supported in CTFE\n fail_compilation/reg6769.d(27):        called from here: `reg6769a([0, 1, 2, 3, 4, 5, 6])`"}, {"sha": "eeea28c9ee21a8d93b484653509f509d21d37e9e", "filename": "gcc/testsuite/gdc.test/fail_compilation/reserved_version.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -115,6 +115,7 @@ fail_compilation/reserved_version.d(216): Error: version identifier `D_PIE` is r\n fail_compilation/reserved_version.d(217): Error: version identifier `AVR` is reserved and cannot be set\n fail_compilation/reserved_version.d(218): Error: version identifier `D_PreConditions` is reserved and cannot be set\n fail_compilation/reserved_version.d(219): Error: version identifier `D_PostConditions` is reserved and cannot be set\n+fail_compilation/reserved_version.d(220): Error: version identifier `D_ProfileGC` is reserved and cannot be set\n ---\n */\n \n@@ -236,6 +237,7 @@ version = D_PIE;\n version = AVR;\n version = D_PreConditions;\n version = D_PostConditions;\n+version = D_ProfileGC;\n \n // This should work though\n debug = DigitalMars;\n@@ -346,3 +348,4 @@ debug = MSP430;\n debug = AVR;\n debug = D_PreConditions;\n debug = D_PostConditions;\n+debug = D_ProfileGC;"}, {"sha": "792ea0a6874c85942c5944a9a2070092750ce763", "filename": "gcc/testsuite/gdc.test/fail_compilation/reserved_version_switch.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version_switch.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version_switch.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Freserved_version_switch.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -105,6 +105,7 @@\n // REQUIRED_ARGS: -version=none\n // REQUIRED_ARGS: -version=D_PreConditions\n // REQUIRED_ARGS: -version=D_PostConditions\n+// REQUIRED_ARGS: -version=D_ProfileGC\n // REQUIRED_ARGS: -debug=DigitalMars\n // REQUIRED_ARGS: -debug=GNU\n // REQUIRED_ARGS: -debug=LDC\n@@ -207,6 +208,7 @@\n // REQUIRED_ARGS: -debug=none\n // REQUIRED_ARGS: -debug=D_PreConditions\n // REQUIRED_ARGS: -debug=D_PostConditions\n+// REQUIRED_ARGS: -debug=D_ProfileGC\n /*\n TEST_OUTPUT:\n ---\n@@ -315,5 +317,6 @@ Error: version identifier `all` is reserved and cannot be set\n Error: version identifier `none` is reserved and cannot be set\n Error: version identifier `D_PreConditions` is reserved and cannot be set\n Error: version identifier `D_PostConditions` is reserved and cannot be set\n+Error: version identifier `D_ProfileGC` is reserved and cannot be set\n ---\n */"}, {"sha": "0625d8e14a05a961727e8f1cbe9f94e7deaccded", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope5.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope5.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope5.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope5.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -5,7 +5,7 @@ REQUIRED_ARGS: -preview=dip1000\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/retscope5.d(5010): Error: reference `t` assigned to `p` with longer lifetime\n+fail_compilation/retscope5.d(5010): Error: address of variable `t` assigned to `p` with longer lifetime\n ---\n */\n "}, {"sha": "fea9fb7958c405514f6ef7a643274cd135e8b5fd", "filename": "gcc/testsuite/gdc.test/fail_compilation/test15191.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest15191.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /* TEST_OUTPUT:\n-PERMUTE_ARGS -dip1000\n+PERMUTE_ARGS: -dip1000\n ---\n fail_compilation/test15191.d(31): Error: returning `&identity(x)` escapes a reference to local variable `x`\n fail_compilation/test15191.d(37): Error: returning `&identityPtr(x)` escapes a reference to local variable `x`"}, {"sha": "87c55ea4b2f0b6fc3b9155791100c5648c5bf261", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16188.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16188.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/test16188.d(1): Error: no identifier for declarator `TEST_OUTPUT`\n fail_compilation/test16188.d(1): Error: declaration expected, not `:`\n-fail_compilation/test16188.d(18): Error: unrecognized declaration\n+fail_compilation/test16188.d(18): Error: unmatched closing brace\n ---\n  */\n "}, {"sha": "0e860815eb750ed5dfb92978924924da6df3ed4e", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16589.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16589.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16589.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16589.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -3,9 +3,9 @@ REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n fail_compilation/test16589.d(26): Error: returning `&this.data` escapes a reference to parameter `this`\n-fail_compilation/test16589.d(26):        perhaps annotate the parameter with `return`\n+fail_compilation/test16589.d(26):        perhaps annotate the function with `return`\n fail_compilation/test16589.d(31): Error: returning `&this` escapes a reference to parameter `this`\n-fail_compilation/test16589.d(31):        perhaps annotate the parameter with `return`\n+fail_compilation/test16589.d(31):        perhaps annotate the function with `return`\n fail_compilation/test16589.d(37): Error: returning `&s.data` escapes a reference to parameter `s`\n fail_compilation/test16589.d(37):        perhaps annotate the parameter with `return`\n fail_compilation/test16589.d(42): Error: returning `&s` escapes a reference to parameter `s`"}, {"sha": "ef19a56192061e92dda87a0355d80c1a55b78966", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17284.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17284.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17284.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17284.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@ TEST_OUTPUT:\n ---\n fail_compilation/test17284.d(1): Error: no identifier for declarator `TEST_OUTPUT`\n fail_compilation/test17284.d(1): Error: declaration expected, not `:`\n-fail_compilation/test17284.d(12): Error: unrecognized declaration\n+fail_compilation/test17284.d(12): Error: unmatched closing brace\n ---\n */\n "}, {"sha": "f350cbdd331d7bfe0b4daa37e1fac44b254357e2", "filename": "gcc/testsuite/gdc.test/fail_compilation/test17450.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17450.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17450.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest17450.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -5,7 +5,7 @@ TEST_OUTPUT:\n fail_compilation/test17450.d(17): Error: returning `&s.bar` escapes a reference to parameter `s`\n fail_compilation/test17450.d(17):        perhaps annotate the parameter with `return`\n fail_compilation/test17450.d(20): Error: returning `&this.bar` escapes a reference to parameter `this`\n-fail_compilation/test17450.d(20):        perhaps annotate the parameter with `return`\n+fail_compilation/test17450.d(20):        perhaps annotate the function with `return`\n ---\n */\n // https://issues.dlang.org/show_bug.cgi?id=17450"}, {"sha": "acbda50c8c37f801fa75c3280efae6bdaeaa96e5", "filename": "gcc/testsuite/gdc.test/fail_compilation/test18554.d", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest18554.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/023327643969d5469902a9ecfa6738a315f9e362/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest18554.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest18554.d?ref=023327643969d5469902a9ecfa6738a315f9e362", "patch": "@@ -1,24 +0,0 @@\n-/* REQUIRED_ARGS: -preview=dip1000\n-EXTRA_FILES: imports/imp18554.d\n-TEST_OUTPUT:\n----\n-fail_compilation/test18554.d(16): Error: struct `imp18554.S` variable `i` is not accessible from `@safe` code\n----\n-*/\n-\n-// https://issues.dlang.org/show_bug.cgi?id=18554\n-\n-import imports.imp18554;\n-\n-void test1() @safe\n-{\n-    S s;\n-    s.tupleof[0] = 1;\n-}\n-\n-void test2()\n-{\n-    S s;\n-    s.tupleof[0] = 1;\n-}\n-"}, {"sha": "93d86bf381bccd5bf6f77746e1c73487d434ff28", "filename": "gcc/testsuite/gdc.test/fail_compilation/test19107.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19107.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19107.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19107.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n EXTRA_FILES: imports/imp19661.d imports/test19107a.d imports/test19107b.d\n TEST_OUTPUT:\n ---\n-fail_compilation/test19107.d(24): Error: template `test19107.all` cannot deduce function from argument types `!((c) => c)(string[])`\n+fail_compilation/test19107.d(24): Error: none of the overloads of template `test19107.all` are callable using argument types `!((c) => c)(string[])`\n fail_compilation/test19107.d(18):        Candidate is: `all(alias pred, T)(T t)`\n   with `pred = __lambda2,\n        T = string[]`"}, {"sha": "e75d90e5a9266d94b7d053c71294c418d808e238", "filename": "gcc/testsuite/gdc.test/fail_compilation/test19193.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19193.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19193.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest19193.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n /*\n REQUIRED_ARGS: -de\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/test19193.d(13): Deprecation: enum member `test19193.T19193!int.A.b` is deprecated\n ---"}, {"sha": "5bb92a352a1fa9ae70cee2183e19c95d79de9de3", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21912.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n /*\n PERMUTE_ARGS: -preview=dip1000\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/test21912.d(24): Error: function `test21912.escapeParam` is `@nogc` yet allocates closures with the GC\n fail_compilation/test21912.d(26):        test21912.escapeParam.__lambda2 closes over variable i at fail_compilation/test21912.d(24)"}, {"sha": "cdb1a3eb508368abe4d3263ad2ec9b397cec34fd", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22298.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22298.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22298.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22298.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,30 @@\n+/*\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22298.d(18): Error: scope variable `i` assigned to `p` with longer lifetime\n+fail_compilation/test22298.d(29): Error: scope variable `y` assigned to `x` with longer lifetime\n+---\n+*/\n+\n+void g(scope void delegate(scope int*) @safe cb) @safe {\n+\tint x = 42;\n+\tcb(&x);\n+}\n+\n+void main() @safe {\n+\tint* p;\n+\tvoid f(scope int* i) @safe {\n+\t\tp = i;\n+\t}\n+\n+\tg(&f);\n+\t// address of x has escaped g\n+\tassert(*p == 42);\n+}\n+\n+void f() @safe {\n+    mixin(\"scope int* x;\");\n+    scope int* y;\n+    x = y;\n+}"}, {"sha": "910db0a955b9afe1c6c551daf3c7594d9fc2b215", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22541.d", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22541.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22541.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22541.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,18 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22541.d(104): Error: returning `i` escapes a reference to parameter `i`\n+fail_compilation/test22541.d(104):        perhaps annotate the parameter with `return`\n+---\n+ */\n+\n+/* https://issues.dlang.org/show_bug.cgi?id=22541\n+ */\n+\n+#line 100\n+\n+@safe\n+ref int newe(ref return scope int i) // ref, error\n+{\n+    return i;\n+}"}, {"sha": "dd5258e0b376593c16a526de0333bb7453dc3f21", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22709.d", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22709.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22709.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22709.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,29 @@\n+/*\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test22709.d(15): Error: address of variable `local` assigned to `arr` with longer lifetime\n+fail_compilation/test22709.d(20): Error: address of variable `local` assigned to `arr` with longer lifetime\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22709\n+@safe:\n+\n+void escape(ref ubyte[] arr, ref ubyte[64] local)\n+{\n+    arr = local[];\n+}\n+\n+void escape1(ref ubyte[64] local, ref ubyte[] arr)\n+{\n+    arr = local[];\n+}\n+\n+ubyte[] getArr()\n+{\n+    ubyte[64] blob;\n+    ubyte[] arr;\n+    escape(arr, blob[]);\n+    return arr;\n+}"}, {"sha": "c66db85a930d7ecd864dfc2afb645297301b64ec", "filename": "gcc/testsuite/gdc.test/fail_compilation/test3818.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest3818.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest3818.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest3818.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,27 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test3818.d(104): Error: missing `; expression` before `)` of `foreach`\n+fail_compilation/test3818.d(104):        perhaps the `;` goes before `a`\n+fail_compilation/test3818.d(109): Error: missing `; expression` before `)` of `foreach`\n+fail_compilation/test3818.d(109):        perhaps the `;` goes before `c`\n+fail_compilation/test3818.d(110): Error: declaration expected, not `{`\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=3818\n+\n+#line 100\n+\n+void test1()\n+{\n+    int[10] a;\n+    foreach (i, x, a)\n+    {\n+    }\n+}\n+\n+static foreach (a, b, c)\n+{\n+}\n+\n+"}, {"sha": "a0310c413fbe0bcb838b52136879961bbcad49d9", "filename": "gcc/testsuite/gdc.test/fail_compilation/test9701.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest9701.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest9701.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest9701.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/test9701.d(38): Error: `@safe` is not a valid attribute for enum members\n fail_compilation/test9701.d(39): Error: `@system` is not a valid attribute for enum members"}, {"sha": "725a4cd0ea6a537b89193b023430c9b641cc8645", "filename": "gcc/testsuite/gdc.test/fail_compilation/test9701b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest9701b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest9701b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest9701b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n /*\n REQUIRED_ARGS: -de\n-TEST_OUTPUT\n+TEST_OUTPUT:\n ---\n fail_compilation/test9701b.d(20): Deprecation: enum member `test9701b.Enum.e0` is deprecated\n fail_compilation/test9701b.d(21): Deprecation: enum member `test9701b.Enum.e1` is deprecated - message"}, {"sha": "5021c540b2986ccbffc950c927f7b2365a0f1295", "filename": "gcc/testsuite/gdc.test/fail_compilation/traits_parameters.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_parameters.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_parameters.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftraits_parameters.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,10 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/traits_parameters.d(9): Error: `__traits(parameters)` cannot have arguments, but `234` was supplied\n+fail_compilation/traits_parameters.d(10): Error: `__traits(parameters)` may only be used inside a function\n+---\n+*/\n+\n+typeof(__traits(parameters, 234)) xyz;\n+typeof(__traits(parameters)) x;"}, {"sha": "c8ed60db6755ca501efa90ef312bf2737e77e0b7", "filename": "gcc/testsuite/gdc.test/runnable/a18.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fa18.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fa18.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fa18.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-COMPILE_SEPARATELY\n+COMPILE_SEPARATELY:\n EXTRA_SOURCES: imports/a18a.d\n PERMUTE_ARGS:\n RUN_OUTPUT:"}, {"sha": "3681d97d7938f3af138b94dab583cca2a71a8f9e", "filename": "gcc/testsuite/gdc.test/runnable/a19.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fa19.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fa19.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fa19.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/a19a.d\n // PERMUTE_ARGS:\n "}, {"sha": "b80d0724ba92b7542bb5a379679053bd10e41604", "filename": "gcc/testsuite/gdc.test/runnable/b26.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fb26.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fb26.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fb26.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/b26a.d\n // PERMUTE_ARGS:\n "}, {"sha": "43f31ac563ebdbae21bdb1a6db6277fca9995b50", "filename": "gcc/testsuite/gdc.test/runnable/class_opCmp.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fclass_opCmp.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fclass_opCmp.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fclass_opCmp.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,25 @@\n+class A\n+{\n+    int x;\n+    this(int a) { x = a; }\n+\n+    alias opCmp = Object.opCmp;\n+    alias opCmp = my_cmp;\n+\n+    final int my_cmp(A a)\n+    {\n+        return x - a.x;\n+    }\n+}\n+\n+void main()\n+{\n+    auto a1 = new A(1);\n+    auto a2 = new A(2);\n+    A a_null = null;\n+    assert(a1 > a_null);\n+    assert(a_null < a1);\n+    assert(!(a1 < a1));\n+    assert(a1 < a2);\n+    assert(a2 > a1);\n+}"}, {"sha": "542899f5e9b728b14f536e5f025a5bb7340adca8", "filename": "gcc/testsuite/gdc.test/runnable/fix22624.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffix22624.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffix22624.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ffix22624.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,19 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22624\n+// EXTRA_FILES: imports/imp22624.c\n+\n+import core.stdc.stdio;\n+import imports.imp22624;\n+\n+struct S\n+{\n+    B b;\n+    ulong y = 0x1234_0000_5678;\n+}\n+\n+int main()\n+{\n+    S s;\n+    //printf(\"%llx\\n\", s.y);\n+    assert(s.y == 0x1234_0000_5678);\n+    return 0;\n+}"}, {"sha": "95b8c274c0088b015f82e95a5d50f4b2ec8c8158", "filename": "gcc/testsuite/gdc.test/runnable/ice15138.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15138.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15138.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15138.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // EXTRA_SOURCES: imports/ice15138a.d\n // PERMUTE_ARGS: -unittest -inline\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n import imports.ice15138a;\n "}, {"sha": "b47b4ec03cc93bd5cbb2202cd7bc00910ccebe70", "filename": "gcc/testsuite/gdc.test/runnable/ice15176.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15176.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15176.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15176.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n // EXTRA_SOURCES: imports/ice15176a.d imports/ice15176b.d\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n import imports.ice15176a;\n "}, {"sha": "2e1abbea4e2385064fe32e189e882a1cf6604aac", "filename": "gcc/testsuite/gdc.test/runnable/ice15200.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15200.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15200.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fice15200.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n // EXTRA_SOURCES: imports/ice15200a.d imports/ice15200b.d\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n module ice15200;\n "}, {"sha": "ea726d3e3f3a6e7b21a8bce337e974bf205569db", "filename": "gcc/testsuite/gdc.test/runnable/imports/imp22624.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Fimp22624.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Fimp22624.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fimports%2Fimp22624.c?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,6 @@\n+\n+struct B\n+{\n+    unsigned int x : 1;\n+//    unsigned int x;\n+};"}, {"sha": "0d59882065a542da0a833990ea187670c8cdb1f5", "filename": "gcc/testsuite/gdc.test/runnable/issue16995.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fissue16995.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fissue16995.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fissue16995.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n // REQUIRED_ARGS: -unittest\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/module_with_tests.d imports/another_module_with_tests.d\n \n import imports.module_with_tests;"}, {"sha": "d0825165765d03ebdf588acd77fc5c062768051f", "filename": "gcc/testsuite/gdc.test/runnable/link10425.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink10425.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink10425.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink10425.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/bug10425.d\n \n import imports.bug10425;"}, {"sha": "33992d177b373e028b864efc127f02e235233cf1", "filename": "gcc/testsuite/gdc.test/runnable/link11069b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink11069b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink11069b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink11069b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/link11069x.d\n // EXTRA_SOURCES: imports/link11069y.d\n // EXTRA_SOURCES: imports/link11069z.d"}, {"sha": "160225e99e16317ab2509fcaa0f909fbcc3067d2", "filename": "gcc/testsuite/gdc.test/runnable/link11395.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink11395.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink11395.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink11395.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // EXTRA_SOURCES: imports/link11395a.d\n // PERMUTE_ARGS:\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n module link11395;\n import imports.link11395a;\n "}, {"sha": "fc838d80f89dcf25cca404fe69894d29d12b905b", "filename": "gcc/testsuite/gdc.test/runnable/link12010.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink12010.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink12010.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink12010.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/a12010.d\n // EXTRA_FILES: imports/std12010container.d\n // REQUIRED_ARGS: -release"}, {"sha": "8af0d36590f97b837b0e9a9f60208303ae64466c", "filename": "gcc/testsuite/gdc.test/runnable/link13394.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13394.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13394.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13394.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/link13394a.d\n \n module link13394;"}, {"sha": "3fc4dfb0b2e5f268b4e40fb9446a058c57d0e8dd", "filename": "gcc/testsuite/gdc.test/runnable/link13400.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13400.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13400.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13400.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/link13400a.d\n \n import imports.link13400a;"}, {"sha": "000ece33e4eb3bd79bcf485b7724e1446141108e", "filename": "gcc/testsuite/gdc.test/runnable/link13415.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13415.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13415.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink13415.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2,7 +2,7 @@\n EXTRA_SOURCES: imports/link13415a.d\n REQUIRED_ARGS: -inline\n PERMUTE_ARGS: -allinst -unittest -debug\n-COMPILE_SEPARATELY\n+COMPILE_SEPARATELY:\n RUN_OUTPUT:\n ---\n i = 77;"}, {"sha": "cfc81574ca3466a3497b1cc743c136ce33d03d2a", "filename": "gcc/testsuite/gdc.test/runnable/link14588.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink14588.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink14588.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink14588.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // EXTRA_SOURCES: imports/link14588a.d\n // PERMUTE_ARGS: -allinst -unittest -debug -inline\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n import imports.link14588a;\n "}, {"sha": "10b6b6d3794069c1caf30270f7bb5aa9a99222b0", "filename": "gcc/testsuite/gdc.test/runnable/link14814.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink14814.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink14814.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink14814.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // EXTRA_SOURCES: imports/link14814a.d\n // PERMUTE_ARGS: -inline -release -g -O -fPIC\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n import imports.link14814a;\n "}, {"sha": "5d395479a481a4b4a5fa23cd75d13002487473c5", "filename": "gcc/testsuite/gdc.test/runnable/link15017.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink15017.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink15017.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink15017.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/std15017variant.d\n /*\n TEST_OUTPUT:"}, {"sha": "a0fdad53448b2cb7230f0f3139f566bfabaf3ef5", "filename": "gcc/testsuite/gdc.test/runnable/link7745.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink7745.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink7745.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink7745.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/link7745b.d\n // PERMUTE_ARGS:\n "}, {"sha": "e92b1504fe9809b7b620755a728e6533129c9a11", "filename": "gcc/testsuite/gdc.test/runnable/link8023.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink8023.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink8023.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink8023.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/link8023b.d\n // PERMUTE_ARGS: -inline -release\n "}, {"sha": "caa9c78405e3a21f42ed4a6c4c5345d2d2bfa446", "filename": "gcc/testsuite/gdc.test/runnable/link9571.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink9571.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink9571.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flink9571.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/link9571a.d\n \n import imports.link9571a;"}, {"sha": "508e094310be8f0bee65df555e734d6e4b2b9b32", "filename": "gcc/testsuite/gdc.test/runnable/linktypeinfo.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flinktypeinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flinktypeinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flinktypeinfo.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // EXTRA_SOURCES: imports/linktypeinfo_file.d\n // PERMUTE_ARGS: -g -inline -unittest -debug\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n import imports.linktypeinfo_file;\n "}, {"sha": "7d15b54a213de0ad5abfee4bfcb7e7cd279b83e5", "filename": "gcc/testsuite/gdc.test/runnable/noreturn1.d", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -112,10 +112,162 @@ void test3()\n     }\n }\n \n+/*****************************************/\n+\n+Exception collectException(void function() f)\n+{\n+    try\n+    {\n+        f();\n+        return null;\n+    }\n+    catch (Exception e)\n+        return e;\n+}\n+\n+\n+int return_()\n+{\n+    return throw new Exception(\"Return\");\n+}\n+\n+void ternary(int i)\n+{\n+    i > 0 ? i++ : throw new Exception(\"Ternary\");\n+}\n+\n+void call()\n+{\n+    ternary(throw new Exception(\"Call\"));\n+}\n+\n+void arrayLiteral()\n+{\n+    int[] arr = [\n+        1,\n+        throw new Exception(\"ArrayLiteral\"),\n+        2\n+    ];\n+}\n+\n+void assocArrayLiteral()\n+{\n+    int[string] arr = [\n+        \"A\": 1,\n+        \"B\": throw new Exception(\"AssocArrayLiteral\"),\n+        \"C\": 2\n+    ];\n+}\n+\n+void testThrowExpression()\n+{\n+    Exception ae = collectException({ return_(); });\n+    assert(ae);\n+\n+    ae = collectException({ ternary(1); });\n+    assert(!ae);\n+\n+    ae = collectException({ ternary(-1); });\n+    assert(ae);\n+\n+    ae = collectException(&call);\n+    assert(ae);\n+    assert(ae.msg == \"Call\");\n+\n+    ae = collectException(&arrayLiteral);\n+    assert(ae);\n+\n+    ae = collectException(&assocArrayLiteral);\n+    assert(ae);\n+}\n+\n+\n+/*****************************************/\n+\n+/// Verify that throws does not screw with side effects\n+void testThrowSideEffect()\n+{\n+    static void foo(bool, void*, int) {}\n+\n+    bool b;\n+    int i;\n+\n+    try\n+    {\n+        foo(b = true, throw new Exception(\"\"), i++);\n+        assert(false);\n+    }\n+    catch (Exception) {}\n+\n+    assert(b == true);\n+    assert(i == 0);\n+}\n+\n+/// Verify that throws does not screw with dtors\n+void testThrowDtor()\n+{\n+    static struct S\n+    {\n+        __gshared int destructed;\n+        int id;\n+\n+        ~this()\n+        {\n+            assert(!(destructed & id));\n+            destructed |= id;\n+        }\n+\n+        string getMessage()\n+        {\n+            // Force runtime dependency\n+            return destructed ? \"Already destructed\" : \"Valid\";\n+        }\n+    }\n+\n+    static void fooD(S, int, S) {}\n+    bool caught;\n+\n+    try\n+    {\n+        fooD(S(1), throw new Exception(S(2).getMessage()), S(4));\n+        assert(false);\n+    }\n+    catch (Exception e)\n+    {\n+        caught = true;\n+        assert(e.msg == \"Valid\");\n+    }\n+    assert(caught);\n+    assert(S.destructed == (1 | 2));\n+\n+\n+    static void fooC(S, int, S) {}\n+    caught = false;\n+    S.destructed = 0;\n+\n+    try\n+    {\n+        fooC(S(1), throw new Exception(S(2).getMessage()), S(4));\n+        assert(false);\n+    }\n+    catch (Exception e)\n+    {\n+        caught = true;\n+        assert(e.msg == \"Valid\");\n+    }\n+    assert(caught);\n+    assert(S.destructed == (1 | 2));\n+}\n+\n+/*****************************************/\n+\n int main()\n {\n     test1();\n     test2();\n     test3();\n+    testThrowExpression();\n+    testThrowSideEffect();\n+    testThrowDtor();\n     return 0;\n }"}, {"sha": "cc5cdba0504fc72cfb4cb0530b46b507734e8b79", "filename": "gcc/testsuite/gdc.test/runnable/test11039.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11039.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11039.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11039.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n \n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test11039b.d\n \n import imports.test11039b;"}, {"sha": "34202357772bd50db23741d5c52ee00152f34edb", "filename": "gcc/testsuite/gdc.test/runnable/test11239.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11239.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11239.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11239.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,6 +1,6 @@\n // EXTRA_SOURCES: imports/inc11239.d\n // REQUIRED_ARGS: -debug\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // PERMUTE_ARGS:\n \n import imports.inc11239;"}, {"sha": "b4e7b1fb0888ef071075007ada3cbc199ff55e7e", "filename": "gcc/testsuite/gdc.test/runnable/test11447a.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447a.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/a11447.d\n // PERMUTE_ARGS: -allinst\n "}, {"sha": "5e37a5ab6b253a08720e2e938869776f6aa33fb2", "filename": "gcc/testsuite/gdc.test/runnable/test11447b.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447b.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447b.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447b.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/b11447.d\n // PERMUTE_ARGS: -allinst\n "}, {"sha": "d3958fec4c0699a6d7ad171fdfb593ba80d19904", "filename": "gcc/testsuite/gdc.test/runnable/test11447c.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447c.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447c.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11447c.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/c11447.d\n // REQUIRED_ARGS: -w\n // PERMUTE_ARGS: -allinst -debug -g"}, {"sha": "9039fdb4ed21889a8567c9b151a690ff68a36d0a", "filename": "gcc/testsuite/gdc.test/runnable/test11863.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11863.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11863.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11863.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/std11863conv.d\n // EXTRA_FILES: imports/std11863bitmanip.d imports/std11863format.d\n "}, {"sha": "599344a86d6b0c23feb62355a9dee8efb2f2f6f5", "filename": "gcc/testsuite/gdc.test/runnable/test14901.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest14901.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest14901.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest14901.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // REQUIRED_ARGS:\n // PERMUTE_ARGS: -unittest\n // EXTRA_SOURCES: imports/test14901a.d imports/test14901b.d imports/test14901c.d imports/test14901d.d\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n \n module test14901;\n "}, {"sha": "26d5c66c379bf8a7e297a1dd307eee7befb8b3ba", "filename": "gcc/testsuite/gdc.test/runnable/test18868.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18868.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18868.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18868.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-COMPILE_SEPARATELY\n+COMPILE_SEPARATELY:\n EXTRA_SOURCES: imports/test18868_a.d imports/test18868_fls.d\n PERMUTE_ARGS:\n */"}, {"sha": "9c0a8d02ecbf77cacef5655e1b3715298c4f8437", "filename": "gcc/testsuite/gdc.test/runnable/test27.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest27.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest27.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest27.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test27a.d\n // PERMUTE_ARGS:\n "}, {"sha": "5ca1eef60131afa5a0b328b15af4307aaac45148", "filename": "gcc/testsuite/gdc.test/runnable/test29.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest29.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest29.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest29.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-COMPILE_SEPARATELY\n+COMPILE_SEPARATELY:\n EXTRA_SOURCES: imports/test29a.d imports/test29b.d\n PERMUTE_ARGS:\n RUN_OUTPUT:"}, {"sha": "ea181047306f8d1de41196946292b9db85e4cf4e", "filename": "gcc/testsuite/gdc.test/runnable/test31.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest31.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest31.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest31.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test31a.d\n // PERMUTE_ARGS:\n "}, {"sha": "d98d46875a90c1789ff9018231904dd4a41e1526", "filename": "gcc/testsuite/gdc.test/runnable/test32.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest32.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest32.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest32.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test32a.d\n // PERMUTE_ARGS:\n "}, {"sha": "b38b9b911cc6b78f9c36296e07bffa2b43bef30e", "filename": "gcc/testsuite/gdc.test/runnable/test38.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest38.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest38.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest38.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-COMPILE_SEPARATELY\n+COMPILE_SEPARATELY:\n EXTRA_SOURCES: imports/test38a.d\n PERMUTE_ARGS:\n RUN_OUTPUT:"}, {"sha": "f5089a75fec25e7624d99757a8ebeeeaf24d899e", "filename": "gcc/testsuite/gdc.test/runnable/test46.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest46.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest46.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest46.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test46b.d imports/test46a.d imports/test46c.d\n // PERMUTE_ARGS:\n "}, {"sha": "9ef1da4f7ccb6f8ed56f7f16736bcf77a633239e", "filename": "gcc/testsuite/gdc.test/runnable/test49.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest49.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest49.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest49.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,5 +1,5 @@\n /*\n-COMPILE_SEPARATELY\n+COMPILE_SEPARATELY:\n EXTRA_SOURCES: imports/test49a.d\n PERMUTE_ARGS:\n RUN_OUTPUT:"}, {"sha": "54cf67295c313785a6a2050dc41a636b5f837519", "filename": "gcc/testsuite/gdc.test/runnable/test57.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest57.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest57.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest57.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test57a.d imports/test57b.d\n // PERMUTE_ARGS:\n // REQUIRED_ARGS: -inline -release"}, {"sha": "ad9532aa2b80e2540a86fd91fdbfb74667c4696b", "filename": "gcc/testsuite/gdc.test/runnable/test7494.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest7494.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest7494.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest7494.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test7494a.d\n // PERMUTE_ARGS:\n // REQUIRED_ARGS:"}, {"sha": "cc0213287798e00f9adac54bd5d6601cfd8bcf0a", "filename": "gcc/testsuite/gdc.test/runnable/test8997.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8997.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8997.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8997.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/test8997a.d\n \n module test8997;"}, {"sha": "43d13d0b827f7452f4a68a3d6bb5be4f928866d7", "filename": "gcc/testsuite/gdc.test/runnable/testmod1.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestmod1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestmod1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestmod1.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/testmod1a.d imports/testmod1b.d\n // PERMUTE_ARGS:\n "}, {"sha": "6acffb46bfdaa666162428b759eb0c4b4a6064ea", "filename": "gcc/testsuite/gdc.test/runnable/tls_dup.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftls_dup.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftls_dup.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftls_dup.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,7 +1,7 @@\n // NOTE: this is a dup of runnable/tls.d strictly to test the same code compiled\n // separately rather than together like the original is.\n \n-// COMPILE_SEPARATELY\n+// COMPILE_SEPARATELY:\n // EXTRA_SOURCES: imports/tlsa.d\n // PERMUTE_ARGS:\n "}, {"sha": "cd36bf223028ba3e9a1e31b458fe9ae6739507f3", "filename": "gcc/testsuite/gdc.test/runnable_cxx/cppa.d", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable_cxx%2Fcppa.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -9,6 +9,9 @@\n \n // N.B MSVC doesn't have a C++11 switch, but it defaults to the latest fully-supported standard\n \n+// Broken for unknown reasons since the OMF => MsCOFF switch\n+// DISABLED: win32omf\n+\n import core.stdc.stdio;\n import core.stdc.stdarg;\n import core.stdc.config;"}, {"sha": "2e9360a5238c8913fb49fa55a153083df40d7ca9", "filename": "libphobos/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2FMakefile.in?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -15,7 +15,7 @@\n @SET_MAKE@\n \n # Makefile for the toplevel directory of the D Standard library.\n-# Copyright (C) 2006-2021 Free Software Foundation, Inc.\n+# Copyright (C) 2006-2022 Free Software Foundation, Inc.\n #\n # GCC is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by"}, {"sha": "251d78de19b821e8c96ce932b7c1b8dd8d2fa75d", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-759e60231a12482a1e1df5f891964e270dae0a1b\n+dbd0c874a345438b8b4379a67525a933436d039a\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "ba641315664c83aea896a409d923e7aea4682241", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -170,7 +170,7 @@ DRUNTIME_CSOURCES = core/stdc/errno_.c\n DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/builtins.d core/checkedint.d core/cpuid.d core/demangle.d \\\n \tcore/exception.d core/gc/config.d core/gc/gcinterface.d \\\n-\tcore/gc/registry.d core/internal/abort.d \\\n+\tcore/gc/registry.d core/int128.d core/internal/abort.d \\\n \tcore/internal/array/appending.d core/internal/array/capacity.d \\\n \tcore/internal/array/casting.d core/internal/array/comparison.d \\\n \tcore/internal/array/concatenation.d core/internal/array/construction.d \\\n@@ -425,4 +425,4 @@ DRUNTIME_DSOURCES_WINDOWS = core/sys/windows/accctrl.d \\\n \tcore/sys/windows/winuser.d core/sys/windows/winver.d \\\n \tcore/sys/windows/wtsapi32.d core/sys/windows/wtypes.d\n \n-DRUNTIME_DISOURCES = __main.di\n+DRUNTIME_DISOURCES = __builtins.di __main.di"}, {"sha": "1c64d35b164dabd27265e7f88c02ee4294bd3376", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -15,7 +15,7 @@\n @SET_MAKE@\n \n # Makefile for the D runtime library.\n-# Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+# Copyright (C) 2012-2022 Free Software Foundation, Inc.\n #\n # GCC is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -190,7 +190,7 @@ am__dirstamp = $(am__leading_dot)dirstamp\n am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/builtins.lo core/checkedint.lo core/cpuid.lo \\\n \tcore/demangle.lo core/exception.lo core/gc/config.lo \\\n-\tcore/gc/gcinterface.lo core/gc/registry.lo \\\n+\tcore/gc/gcinterface.lo core/gc/registry.lo core/int128.lo \\\n \tcore/internal/abort.lo core/internal/array/appending.lo \\\n \tcore/internal/array/capacity.lo core/internal/array/casting.lo \\\n \tcore/internal/array/comparison.lo \\\n@@ -834,7 +834,7 @@ DRUNTIME_CSOURCES = core/stdc/errno_.c\n DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/builtins.d core/checkedint.d core/cpuid.d core/demangle.d \\\n \tcore/exception.d core/gc/config.d core/gc/gcinterface.d \\\n-\tcore/gc/registry.d core/internal/abort.d \\\n+\tcore/gc/registry.d core/int128.d core/internal/abort.d \\\n \tcore/internal/array/appending.d core/internal/array/capacity.d \\\n \tcore/internal/array/casting.d core/internal/array/comparison.d \\\n \tcore/internal/array/concatenation.d core/internal/array/construction.d \\\n@@ -1089,7 +1089,7 @@ DRUNTIME_DSOURCES_WINDOWS = core/sys/windows/accctrl.d \\\n \tcore/sys/windows/winuser.d core/sys/windows/winver.d \\\n \tcore/sys/windows/wtsapi32.d core/sys/windows/wtypes.d\n \n-DRUNTIME_DISOURCES = __main.di\n+DRUNTIME_DISOURCES = __builtins.di __main.di\n all: all-am\n \n .SUFFIXES:\n@@ -1187,6 +1187,7 @@ core/gc/$(am__dirstamp):\n core/gc/config.lo: core/gc/$(am__dirstamp)\n core/gc/gcinterface.lo: core/gc/$(am__dirstamp)\n core/gc/registry.lo: core/gc/$(am__dirstamp)\n+core/int128.lo: core/$(am__dirstamp)\n core/internal/$(am__dirstamp):\n \t@$(MKDIR_P) core/internal\n \t@: > core/internal/$(am__dirstamp)"}, {"sha": "cd64881529e0737a70d99a48c3965ae7ac5270e6", "filename": "libphobos/libdruntime/__builtins.di", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2F__builtins.di", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2F__builtins.di", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2F__builtins.di?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,40 @@\n+/* This D file is implicitly imported by all ImportC source files.\n+ * It provides definitions for C compiler builtin functions and declarations.\n+ * The purpose is to make it unnecessary to hardwire them into the compiler.\n+ * As the leading double underscore suggests, this is for internal use only.\n+ *\n+ * Copyright: Copyright Digital Mars 2022\n+ * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n+ * Authors:   Walter Bright\n+ * Source: $(DRUNTIMESRC __builtins.d)\n+ */\n+\n+\n+module __builtins;\n+\n+/* gcc relies on internal __builtin_xxxx functions and templates to\n+ * accomplish <stdarg.h>. D does the same thing with templates in core.stdc.stdarg.\n+ * Here, we redirect the gcc builtin declarations to the equivalent\n+ * ones in core.stdc.stdarg, thereby avoiding having to hardware them\n+ * into the D compiler.\n+ */\n+\n+import core.stdc.stdarg;\n+\n+alias va_list = core.stdc.stdarg.va_list;\n+\n+version (Posix)\n+{\n+    version (X86_64)\n+        alias __va_list_tag = core.stdc.stdarg.__va_list_tag;\n+}\n+\n+alias __builtin_va_start = core.stdc.stdarg.va_start;\n+\n+alias __builtin_va_end = core.stdc.stdarg.va_end;\n+\n+alias __builtin_va_copy = core.stdc.stdarg.va_copy;\n+\n+/* dmd's ImportC rewrites __builtin_va_arg into an instantiation of va_arg\n+ */\n+alias va_arg = core.stdc.stdarg.va_arg;"}, {"sha": "930e0cd9c24f7f159499c097c2f61579ec4ac3a4", "filename": "libphobos/libdruntime/core/demangle.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fdemangle.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2471,7 +2471,7 @@ private template hasPlainMangling(FT) if (is(FT == function))\n {\n     enum lnk = __traits(getLinkage, FT);\n     // C || Windows\n-    enum hasPlainMangling = lnk == \"C\" || lnk == \"Windows\";\n+    enum hasPlainMangling = lnk == \"C\" || lnk == \"Windows\" || lnk == \"System\";\n }\n \n @safe pure nothrow unittest"}, {"sha": "aad2cf239423f70ba3a05b1e80059dc8517e7f5b", "filename": "libphobos/libdruntime/core/int128.d", "status": "added", "additions": 919, "deletions": 0, "changes": 919, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fint128.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -0,0 +1,919 @@\n+/* 128 bit integer arithmetic.\n+ *\n+ * Not optimized for speed.\n+ *\n+ * Copyright: Copyright D Language Foundation 2022.\n+ * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n+ * Authors:   Walter Bright\n+ * Source:    $(DRUNTIMESRC core/_int128.d)\n+ */\n+\n+module core.int128;\n+\n+nothrow:\n+@safe:\n+@nogc:\n+\n+alias I = long;\n+alias U = ulong;\n+enum Ubits = uint(U.sizeof * 8);\n+\n+align(16) struct Cent\n+{\n+    U lo;      // low 64 bits\n+    U hi;      // high 64 bits\n+}\n+\n+enum One = Cent(1);\n+enum Zero = Cent();\n+enum MinusOne = neg(One);\n+\n+/*****************************\n+ * Test against 0\n+ * Params:\n+ *      c = Cent to test\n+ * Returns:\n+ *      true if != 0\n+ */\n+pure\n+bool tst(Cent c)\n+{\n+    return c.hi || c.lo;\n+}\n+\n+\n+/*****************************\n+ * Complement\n+ * Params:\n+ *      c = Cent to complement\n+ * Returns:\n+ *      complemented value\n+ */\n+pure\n+Cent com(Cent c)\n+{\n+    c.lo = ~c.lo;\n+    c.hi = ~c.hi;\n+    return c;\n+}\n+\n+/*****************************\n+ * Negate\n+ * Params:\n+ *      c = Cent to negate\n+ * Returns:\n+ *      negated value\n+ */\n+pure\n+Cent neg(Cent c)\n+{\n+    if (c.lo == 0)\n+        c.hi = -c.hi;\n+    else\n+    {\n+        c.lo = -c.lo;\n+        c.hi = ~c.hi;\n+    }\n+    return c;\n+}\n+\n+/*****************************\n+ * Increment\n+ * Params:\n+ *      c = Cent to increment\n+ * Returns:\n+ *      incremented value\n+ */\n+pure\n+Cent inc(Cent c)\n+{\n+    return add(c, One);\n+}\n+\n+/*****************************\n+ * Decrement\n+ * Params:\n+ *      c = Cent to decrement\n+ * Returns:\n+ *      incremented value\n+ */\n+pure\n+Cent dec(Cent c)\n+{\n+    return sub(c, One);\n+}\n+\n+/*****************************\n+ * Shift left one bit\n+ * Params:\n+ *      c = Cent to shift\n+ * Returns:\n+ *      shifted value\n+ */\n+pure\n+Cent shl1(Cent c)\n+{\n+    c.hi = (c.hi << 1) | (cast(I)c.lo < 0);\n+    c.lo <<= 1;\n+    return c;\n+}\n+\n+/*****************************\n+ * Unsigned shift right one bit\n+ * Params:\n+ *      c = Cent to shift\n+ * Returns:\n+ *      shifted value\n+ */\n+pure\n+Cent shr1(Cent c)\n+{\n+    c.lo = (c.lo >> 1) | ((c.hi & 1) << (Ubits - 1));\n+    c.hi >>= 1;\n+    return c;\n+}\n+\n+\n+/*****************************\n+ * Arithmetic shift right one bit\n+ * Params:\n+ *      c = Cent to shift\n+ * Returns:\n+ *      shifted value\n+ */\n+pure\n+Cent sar1(Cent c)\n+{\n+    c.lo = (c.lo >> 1) | ((c.hi & 1) << (Ubits - 1));\n+    c.hi = cast(I)c.hi >> 1;\n+    return c;\n+}\n+\n+/*****************************\n+ * Shift left n bits\n+ * Params:\n+ *      c = Cent to shift\n+ *      n = number of bits to shift\n+ * Returns:\n+ *      shifted value\n+ */\n+pure\n+Cent shl(Cent c, uint n)\n+{\n+    if (n >= Ubits * 2)\n+        return Zero;\n+\n+    if (n >= Ubits)\n+    {\n+        c.hi = c.lo << (n - Ubits);\n+        c.lo = 0;\n+    }\n+    else\n+    {\n+        c.hi = ((c.hi << n) | (c.lo >> (Ubits - n - 1) >> 1));\n+        c.lo = c.lo << n;\n+    }\n+    return c;\n+}\n+\n+/*****************************\n+ * Unsigned shift right n bits\n+ * Params:\n+ *      c = Cent to shift\n+ *      n = number of bits to shift\n+ * Returns:\n+ *      shifted value\n+ */\n+pure\n+Cent shr(Cent c, uint n)\n+{\n+    if (n >= Ubits * 2)\n+        return Zero;\n+\n+    if (n >= Ubits)\n+    {\n+        c.lo = c.hi >> (n - Ubits);\n+        c.hi = 0;\n+    }\n+    else\n+    {\n+        c.lo = ((c.lo >> n) | (c.hi << (Ubits - n - 1) << 1));\n+        c.hi = c.hi >> n;\n+    }\n+    return c;\n+}\n+\n+/*****************************\n+ * Arithmetic shift right n bits\n+ * Params:\n+ *      c = Cent to shift\n+ *      n = number of bits to shift\n+ * Returns:\n+ *      shifted value\n+ */\n+pure\n+Cent sar(Cent c, uint n)\n+{\n+    const signmask = -(c.hi >> (Ubits - 1));\n+    const signshift = (Ubits * 2) - n;\n+    c = shr(c, n);\n+\n+    // Sign extend all bits beyond the precision of Cent.\n+    if (n >= Ubits * 2)\n+    {\n+        c.hi = signmask;\n+        c.lo = signmask;\n+    }\n+    else if (signshift >= Ubits * 2)\n+    {\n+    }\n+    else if (signshift >= Ubits)\n+    {\n+        c.hi &= ~(U.max << (signshift - Ubits));\n+        c.hi |= signmask << (signshift - Ubits);\n+    }\n+    else\n+    {\n+        c.hi = signmask;\n+        c.lo &= ~(U.max << signshift);\n+        c.lo |= signmask << signshift;\n+    }\n+    return c;\n+}\n+\n+/*****************************\n+ * Rotate left one bit\n+ * Params:\n+ *      c = Cent to rotate\n+ * Returns:\n+ *      rotated value\n+ */\n+pure\n+Cent rol1(Cent c)\n+{\n+    int carry = cast(I)c.hi < 0;\n+\n+    c.hi = (c.hi << 1) | (cast(I)c.lo < 0);\n+    c.lo = (c.lo << 1) | carry;\n+    return c;\n+}\n+\n+/*****************************\n+ * Rotate right one bit\n+ * Params:\n+ *      c = Cent to rotate\n+ * Returns:\n+ *      rotated value\n+ */\n+pure\n+Cent ror1(Cent c)\n+{\n+    int carry = c.lo & 1;\n+    c.lo = (c.lo >> 1) | (cast(U)(c.hi & 1) << (Ubits - 1));\n+    c.hi = (c.hi >> 1) | (cast(U)carry << (Ubits - 1));\n+    return c;\n+}\n+\n+\n+/*****************************\n+ * Rotate left n bits\n+ * Params:\n+ *      c = Cent to rotate\n+ *      n = number of bits to rotate\n+ * Returns:\n+ *      rotated value\n+ */\n+pure\n+Cent rol(Cent c, uint n)\n+{\n+    n &= Ubits * 2 - 1;\n+    Cent l = shl(c, n);\n+    Cent r = shr(c, Ubits * 2 - n);\n+    return or(l, r);\n+}\n+\n+/*****************************\n+ * Rotate right n bits\n+ * Params:\n+ *      c = Cent to rotate\n+ *      n = number of bits to rotate\n+ * Returns:\n+ *      rotated value\n+ */\n+pure\n+Cent ror(Cent c, uint n)\n+{\n+    n &= Ubits * 2 - 1;\n+    Cent r = shr(c, n);\n+    Cent l = shl(c, Ubits * 2 - n);\n+    return or(r, l);\n+}\n+\n+/****************************\n+ * And c1 & c2.\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      c1 & c2\n+ */\n+pure\n+Cent and(Cent c1, Cent c2)\n+{\n+    return Cent(c1.lo & c2.lo, c1.hi & c2.hi);\n+}\n+\n+/****************************\n+ * Or c1 | c2.\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      c1 | c2\n+ */\n+pure\n+Cent or(Cent c1, Cent c2)\n+{\n+    return Cent(c1.lo | c2.lo, c1.hi | c2.hi);\n+}\n+\n+/****************************\n+ * Xor c1 ^ c2.\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      c1 ^ c2\n+ */\n+pure\n+Cent xor(Cent c1, Cent c2)\n+{\n+    return Cent(c1.lo ^ c2.lo, c1.hi ^ c2.hi);\n+}\n+\n+/****************************\n+ * Add c1 to c2.\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      c1 + c2\n+ */\n+pure\n+Cent add(Cent c1, Cent c2)\n+{\n+    U r = cast(U)(c1.lo + c2.lo);\n+    return Cent(r, cast(U)(c1.hi + c2.hi + (r < c1.lo)));\n+}\n+\n+/****************************\n+ * Subtract c2 from c1.\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      c1 - c2\n+ */\n+pure\n+Cent sub(Cent c1, Cent c2)\n+{\n+    return add(c1, neg(c2));\n+}\n+\n+/****************************\n+ * Multiply c1 * c2.\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      c1 * c2\n+ */\n+pure\n+Cent mul(Cent c1, Cent c2)\n+{\n+    enum mulmask = (1UL << (Ubits / 2)) - 1;\n+    enum mulshift = Ubits / 2;\n+\n+    // This algorithm splits the operands into 4 words, then computes and sums\n+    // the partial products of each part.\n+    const c2l0 = c2.lo & mulmask;\n+    const c2l1 = c2.lo >> mulshift;\n+    const c2h0 = c2.hi & mulmask;\n+    const c2h1 = c2.hi >> mulshift;\n+\n+    const c1l0 = c1.lo & mulmask;\n+    U r0 = c1l0 * c2l0;\n+    U r1 = c1l0 * c2l1 + (r0 >> mulshift);\n+    U r2 = c1l0 * c2h0 + (r1 >> mulshift);\n+    U r3 = c1l0 * c2h1 + (r2 >> mulshift);\n+\n+    const c1l1 = c1.lo >> mulshift;\n+    r1 = c1l1 * c2l0 + (r1 & mulmask);\n+    r2 = c1l1 * c2l1 + (r2 & mulmask) + (r1 >> mulshift);\n+    r3 = c1l1 * c2h0 + (r3 & mulmask) + (r2 >> mulshift);\n+\n+    const c1h0 = c1.hi & mulmask;\n+    r2 = c1h0 * c2l0 + (r2 & mulmask);\n+    r3 = c1h0 * c2l1 + (r3 & mulmask) + (r2 >> mulshift);\n+\n+    const c1h1 = c1.hi >> mulshift;\n+    r3 = c1h1 * c2l0 + (r3 & mulmask);\n+\n+    return Cent((r0 & mulmask) + (r1 & mulmask) * (mulmask + 1),\n+                (r2 & mulmask) + (r3 & mulmask) * (mulmask + 1));\n+\n+}\n+\n+\n+/****************************\n+ * Unsigned divide c1 / c2.\n+ * Params:\n+ *      c1 = dividend\n+ *      c2 = divisor\n+ * Returns:\n+ *      quotient c1 / c2\n+ */\n+pure\n+Cent udiv(Cent c1, Cent c2)\n+{\n+    Cent modulus;\n+    return udivmod(c1, c2, modulus);\n+}\n+\n+/****************************\n+ * Unsigned divide c1 / c2. The remainder after division is stored to modulus.\n+ * Params:\n+ *      c1 = dividend\n+ *      c2 = divisor\n+ *      modulus = set to c1 % c2\n+ * Returns:\n+ *      quotient c1 / c2\n+ */\n+pure\n+Cent udivmod(Cent c1, Cent c2, out Cent modulus)\n+{\n+    //printf(\"udiv c1(%llx,%llx) c2(%llx,%llx)\\n\", c1.lo, c1.hi, c2.lo, c2.hi);\n+    // Based on \"Unsigned Doubleword Division\" in Hacker's Delight\n+    import core.bitop;\n+\n+    // Divides a 128-bit dividend by a 64-bit divisor.\n+    // The result must fit in 64 bits.\n+    static U udivmod128_64(Cent c1, U c2, out U modulus)\n+    {\n+        // We work in base 2^^32\n+        enum base = 1UL << 32;\n+        enum divmask = (1UL << (Ubits / 2)) - 1;\n+        enum divshift = Ubits / 2;\n+\n+        // Check for overflow and divide by 0\n+        if (c1.hi >= c2)\n+        {\n+            modulus = 0UL;\n+            return ~0UL;\n+        }\n+\n+        // Computes [num1 num0] / den\n+        static uint udiv96_64(U num1, uint num0, U den)\n+        {\n+            // Extract both digits of the denominator\n+            const den1 = cast(uint)(den >> divshift);\n+            const den0 = cast(uint)(den & divmask);\n+            // Estimate ret as num1 / den1, and then correct it\n+            U ret = num1 / den1;\n+            const t2 = (num1 % den1) * base + num0;\n+            const t1 = ret * den0;\n+            if (t1 > t2)\n+                ret -= (t1 - t2 > den) ? 2 : 1;\n+            return cast(uint)ret;\n+        }\n+\n+        // Determine the normalization factor. We multiply c2 by this, so that its leading\n+        // digit is at least half base. In binary this means just shifting left by the number\n+        // of leading zeros, so that there's a 1 in the MSB.\n+        // We also shift number by the same amount. This cannot overflow because c1.hi < c2.\n+        const shift = (Ubits - 1) - bsr(c2);\n+        c2 <<= shift;\n+        U num2 = c1.hi;\n+        num2 <<= shift;\n+        num2 |= (c1.lo >> (-shift & 63)) & (-cast(I)shift >> 63);\n+        c1.lo <<= shift;\n+\n+        // Extract the low digits of the numerator (after normalizing)\n+        const num1 = cast(uint)(c1.lo >> divshift);\n+        const num0 = cast(uint)(c1.lo & divmask);\n+\n+        // Compute q1 = [num2 num1] / c2\n+        const q1 = udiv96_64(num2, num1, c2);\n+        // Compute the true (partial) remainder\n+        const rem = num2 * base + num1 - q1 * c2;\n+        // Compute q0 = [rem num0] / c2\n+        const q0 = udiv96_64(rem, num0, c2);\n+\n+        modulus = (rem * base + num0 - q0 * c2) >> shift;\n+        return (cast(U)q1 << divshift) | q0;\n+    }\n+\n+    // Special cases\n+    if (!tst(c2))\n+    {\n+        // Divide by zero\n+        modulus = Zero;\n+        return com(modulus);\n+    }\n+    if (c1.hi == 0 && c2.hi == 0)\n+    {\n+        // Single precision divide\n+        modulus = Cent(c1.lo % c2.lo);\n+        return Cent(c1.lo / c2.lo);\n+    }\n+    if (c1.hi == 0)\n+    {\n+        // Numerator is smaller than the divisor\n+        modulus = c1;\n+        return Zero;\n+    }\n+    if (c2.hi == 0)\n+    {\n+        // Divisor is a 64-bit value, so we just need one 128/64 division.\n+        // If c1 / c2 would overflow, break c1 up into two halves.\n+        const q1 = (c1.hi < c2.lo) ? 0 : (c1.hi / c2.lo);\n+        if (q1)\n+            c1.hi = c1.hi % c2.lo;\n+        U rem;\n+        const q0 = udivmod128_64(c1, c2.lo, rem);\n+        modulus = Cent(rem);\n+        return Cent(q0, q1);\n+    }\n+\n+    // Full cent precision division.\n+    // Here c2 >= 2^^64\n+    // We know that c2.hi != 0, so count leading zeros is OK\n+    // We have 0 <= shift <= 63\n+    const shift = (Ubits - 1) - bsr(c2.hi);\n+\n+    // Normalize the divisor so its MSB is 1\n+    // v1 = (c2 << shift) >> 64\n+    U v1 = shl(c2, shift).hi;\n+\n+    // To ensure no overflow.\n+    Cent u1 = shr1(c1);\n+\n+    // Get quotient from divide unsigned operation.\n+    U rem_ignored;\n+    const q1 = udivmod128_64(u1, v1, rem_ignored);\n+\n+    // Undo normalization and division of c1 by 2.\n+    Cent quotient = shr(shl(Cent(q1), shift), 63);\n+\n+    // Make quotient correct or too small by 1\n+    if (tst(quotient))\n+        quotient = dec(quotient);\n+\n+    // Now quotient is correct.\n+    // Compute rem = c1 - (quotient * c2);\n+    Cent rem = sub(c1, mul(quotient, c2));\n+\n+    // Check if remainder is larger than the divisor\n+    if (uge(rem, c2))\n+    {\n+        // Increment quotient\n+        quotient = inc(quotient);\n+        // Subtract c2 from remainder\n+        rem = sub(rem, c2);\n+    }\n+    modulus = rem;\n+    //printf(\"quotient \"); print(quotient);\n+    //printf(\"modulus  \"); print(modulus);\n+    return quotient;\n+}\n+\n+\n+/****************************\n+ * Signed divide c1 / c2.\n+ * Params:\n+ *      c1 = dividend\n+ *      c2 = divisor\n+ * Returns:\n+ *      quotient c1 / c2\n+ */\n+pure\n+Cent div(Cent c1, Cent c2)\n+{\n+    Cent modulus;\n+    return divmod(c1, c2, modulus);\n+}\n+\n+/****************************\n+ * Signed divide c1 / c2. The remainder after division is stored to modulus.\n+ * Params:\n+ *      c1 = dividend\n+ *      c2 = divisor\n+ *      modulus = set to c1 % c2\n+ * Returns:\n+ *      quotient c1 / c2\n+ */\n+pure\n+Cent divmod(Cent c1, Cent c2, out Cent modulus)\n+{\n+    /* Muck about with the signs so we can use the unsigned divide\n+     */\n+    if (cast(I)c1.hi < 0)\n+    {\n+        if (cast(I)c2.hi < 0)\n+        {\n+            Cent r = udivmod(neg(c1), neg(c2), modulus);\n+            modulus = neg(modulus);\n+            return r;\n+        }\n+        Cent r = neg(udivmod(neg(c1), c2, modulus));\n+        modulus = neg(modulus);\n+        return r;\n+    }\n+    else if (cast(I)c2.hi < 0)\n+    {\n+        return neg(udivmod(c1, neg(c2), modulus));\n+    }\n+    else\n+        return udivmod(c1, c2, modulus);\n+}\n+\n+/****************************\n+ * If c1 > c2 unsigned\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 > c2\n+ */\n+pure\n+bool ugt(Cent c1, Cent c2)\n+{\n+    return (c1.hi == c2.hi) ? (c1.lo > c2.lo) : (c1.hi > c2.hi);\n+}\n+\n+/****************************\n+ * If c1 >= c2 unsigned\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 >= c2\n+ */\n+pure\n+bool uge(Cent c1, Cent c2)\n+{\n+    return !ugt(c2, c1);\n+}\n+\n+/****************************\n+ * If c1 < c2 unsigned\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 < c2\n+ */\n+pure\n+bool ult(Cent c1, Cent c2)\n+{\n+    return ugt(c2, c1);\n+}\n+\n+/****************************\n+ * If c1 <= c2 unsigned\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 <= c2\n+ */\n+pure\n+bool ule(Cent c1, Cent c2)\n+{\n+    return !ugt(c1, c2);\n+}\n+\n+/****************************\n+ * If c1 > c2 signed\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 > c2\n+ */\n+pure\n+bool gt(Cent c1, Cent c2)\n+{\n+    return (c1.hi == c2.hi)\n+        ? (c1.lo > c2.lo)\n+        : (cast(I)c1.hi > cast(I)c2.hi);\n+}\n+\n+/****************************\n+ * If c1 >= c2 signed\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 >= c2\n+ */\n+pure\n+bool ge(Cent c1, Cent c2)\n+{\n+    return !gt(c2, c1);\n+}\n+\n+/****************************\n+ * If c1 < c2 signed\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 < c2\n+ */\n+pure\n+bool lt(Cent c1, Cent c2)\n+{\n+    return gt(c2, c1);\n+}\n+\n+/****************************\n+ * If c1 <= c2 signed\n+ * Params:\n+ *      c1 = operand 1\n+ *      c2 = operand 2\n+ * Returns:\n+ *      true if c1 <= c2\n+ */\n+pure\n+bool le(Cent c1, Cent c2)\n+{\n+    return !gt(c1, c2);\n+}\n+\n+/*******************************************************/\n+\n+version (unittest)\n+{\n+    version (none)\n+    {\n+        import core.stdc.stdio;\n+\n+        @trusted\n+        void print(Cent c)\n+        {\n+            printf(\"%lld, %lld\\n\", cast(ulong)c.lo, cast(ulong)c.hi);\n+            printf(\"x%llx, x%llx\\n\", cast(ulong)c.lo, cast(ulong)c.hi);\n+        }\n+    }\n+}\n+\n+unittest\n+{\n+    const C0 = Zero;\n+    const C1 = One;\n+    const C2 = Cent(2);\n+    const C3 = Cent(3);\n+    const C5 = Cent(5);\n+    const C10 = Cent(10);\n+    const C20 = Cent(20);\n+    const C30 = Cent(30);\n+    const C100 = Cent(100);\n+\n+    const Cm1 =  neg(One);\n+    const Cm3 =  neg(C3);\n+    const Cm10 = neg(C10);\n+\n+    const C3_1 = Cent(1,3);\n+    const C3_2 = Cent(2,3);\n+    const C4_8  = Cent(8, 4);\n+    const C5_0  = Cent(0, 5);\n+    const C7_1 = Cent(1,7);\n+    const C7_9 = Cent(9,7);\n+    const C9_3 = Cent(3,9);\n+    const C10_0 = Cent(0,10);\n+    const C10_1 = Cent(1,10);\n+    const C10_3 = Cent(3,10);\n+    const C11_3 = Cent(3,11);\n+    const C20_0 = Cent(0,20);\n+    const C90_30 = Cent(30,90);\n+\n+    const Cm10_0 = inc(com(C10_0)); // Cent(0, -10);\n+    const Cm10_1 = inc(com(C10_1)); // Cent(-1, -11);\n+    const Cm10_3 = inc(com(C10_3)); // Cent(-3, -11);\n+\n+    enum Cs_3 = Cent(3, I.min);\n+\n+    const Cbig_1 = Cent(0xa3ccac1832952398, 0xc3ac542864f652f8);\n+    const Cbig_2 = Cent(0x5267b85f8a42fc20, 0);\n+    const Cbig_3 = Cent(0xf0000000ffffffff, 0);\n+\n+    /************************/\n+\n+    assert( ugt(C1, C0) );\n+    assert( ult(C1, C2) );\n+    assert( uge(C1, C0) );\n+    assert( ule(C1, C2) );\n+\n+    assert( !ugt(C0, C1) );\n+    assert( !ult(C2, C1) );\n+    assert( !uge(C0, C1) );\n+    assert( !ule(C2, C1) );\n+\n+    assert( !ugt(C1, C1) );\n+    assert( !ult(C1, C1) );\n+    assert( uge(C1, C1) );\n+    assert( ule(C2, C2) );\n+\n+    assert( ugt(C10_3, C10_1) );\n+    assert( ugt(C11_3, C10_3) );\n+    assert( !ugt(C9_3, C10_3) );\n+    assert( !ugt(C9_3, C9_3) );\n+\n+    assert( gt(C2, C1) );\n+    assert( !gt(C1, C2) );\n+    assert( !gt(C1, C1) );\n+    assert( gt(C0, Cm1) );\n+    assert( gt(Cm1, neg(C10)));\n+    assert( !gt(Cm1, Cm1) );\n+    assert( !gt(Cm1, C0) );\n+\n+    assert( !lt(C2, C1) );\n+    assert( !le(C2, C1) );\n+    assert( ge(C2, C1) );\n+\n+    assert(neg(C10_0) == Cm10_0);\n+    assert(neg(C10_1) == Cm10_1);\n+    assert(neg(C10_3) == Cm10_3);\n+\n+    assert(add(C7_1,C3_2) == C10_3);\n+    assert(sub(C1,C2) == Cm1);\n+\n+    assert(inc(C3_1) == C3_2);\n+    assert(dec(C3_2) == C3_1);\n+\n+    assert(shl(C10,0) == C10);\n+    assert(shl(C10,Ubits) == C10_0);\n+    assert(shl(C10,1) == C20);\n+    assert(shl(C10,Ubits * 2) == C0);\n+    assert(shr(C10_0,0) == C10_0);\n+    assert(shr(C10_0,Ubits) == C10);\n+    assert(shr(C10_0,Ubits - 1) == C20);\n+    assert(shr(C10_0,Ubits + 1) == C5);\n+    assert(shr(C10_0,Ubits * 2) == C0);\n+    assert(sar(C10_0,0) == C10_0);\n+    assert(sar(C10_0,Ubits) == C10);\n+    assert(sar(C10_0,Ubits - 1) == C20);\n+    assert(sar(C10_0,Ubits + 1) == C5);\n+    assert(sar(C10_0,Ubits * 2) == C0);\n+    assert(sar(Cm1,Ubits * 2) == Cm1);\n+\n+    assert(shl1(C10) == C20);\n+    assert(shr1(C10_0) == C5_0);\n+    assert(sar1(C10_0) == C5_0);\n+    assert(sar1(Cm1) == Cm1);\n+\n+    Cent modulus;\n+\n+    assert(udiv(C10,C2) == C5);\n+    assert(udivmod(C10,C2, modulus) ==  C5);   assert(modulus == C0);\n+    assert(udivmod(C10,C3, modulus) ==  C3);   assert(modulus == C1);\n+    assert(udivmod(C10,C0, modulus) == Cm1);   assert(modulus == C0);\n+    assert(udivmod(C2,C90_30, modulus) == C0); assert(modulus == C2);\n+    assert(udiv(mul(C90_30, C2), C2) == C90_30);\n+    assert(udiv(mul(C90_30, C2), C90_30) == C2);\n+\n+    assert(div(C10,C3) == C3);\n+    assert(divmod( C10,  C3, modulus) ==  C3); assert(modulus ==  C1);\n+    assert(divmod(Cm10,  C3, modulus) == Cm3); assert(modulus == Cm1);\n+    assert(divmod( C10, Cm3, modulus) == Cm3); assert(modulus ==  C1);\n+    assert(divmod(Cm10, Cm3, modulus) ==  C3); assert(modulus == Cm1);\n+    assert(divmod(C2, C90_30, modulus) == C0); assert(modulus == C2);\n+    assert(div(mul(C90_30, C2), C2) == C90_30);\n+    assert(div(mul(C90_30, C2), C90_30) == C2);\n+\n+    assert(divmod(Cbig_1, Cbig_2, modulus) == Cent(0x4496aa309d4d4a2f, U.max));\n+    assert(modulus == Cent(0xd83203d0fdc799b8, U.max));\n+    assert(udivmod(Cbig_1, Cbig_2, modulus) == Cent(0x5fe0e9bace2bedad, 2));\n+    assert(modulus == Cent(0x2c923125a68721f8, 0));\n+    assert(div(Cbig_1, Cbig_3) == Cent(0xbfa6c02b5aff8b86, U.max));\n+    assert(udiv(Cbig_1, Cbig_3) == Cent(0xd0b7d13b48cb350f, 0));\n+\n+    assert(mul(Cm10, C1) == Cm10);\n+    assert(mul(C1, Cm10) == Cm10);\n+    assert(mul(C9_3, C10) == C90_30);\n+    assert(mul(Cs_3, C10) == C30);\n+    assert(mul(Cm10, Cm10) == C100);\n+\n+    assert( or(C4_8, C3_1) == C7_9);\n+    assert(and(C4_8, C7_9) == C4_8);\n+    assert(xor(C4_8, C7_9) == C3_1);\n+\n+    assert(rol(Cm1,  1) == Cm1);\n+    assert(ror(Cm1, 45) == Cm1);\n+    assert(rol(ror(C7_9, 5), 5) == C7_9);\n+    assert(rol(C7_9, 1) == rol1(C7_9));\n+    assert(ror(C7_9, 1) == ror1(C7_9));\n+}\n+\n+"}, {"sha": "87c45fb2872afc3a9060902dbe7c4b9823036c6a", "filename": "libphobos/libdruntime/core/internal/gc/impl/conservative/gc.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -4571,7 +4571,7 @@ string debugTypeName(const(TypeInfo) ti) nothrow\n         else\n             return debugTypeName(ci.next);\n     else\n-        name = ti.classinfo.name;\n+        name = typeid(ti).name;\n     return name;\n }\n "}, {"sha": "091269ac9a19f253373f4c7e0f4c3d844d472947", "filename": "libphobos/libdruntime/core/lifetime.d", "status": "modified", "additions": 357, "deletions": 16, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Flifetime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Flifetime.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -2108,6 +2108,65 @@ private T trustedMoveImpl(T)(return scope ref T source) @trusted\n     move(x, x);\n }\n \n+private enum bool hasContextPointers(T) = {\n+    static if (__traits(isStaticArray, T))\n+    {\n+        return hasContextPointers!(typeof(T.init[0]));\n+    }\n+    else static if (is(T == struct))\n+    {\n+        import core.internal.traits : anySatisfy;\n+        return __traits(isNested, T) || anySatisfy!(hasContextPointers, typeof(T.tupleof));\n+    }\n+    else return false;\n+} ();\n+\n+@safe @nogc nothrow pure unittest\n+{\n+    static assert(!hasContextPointers!int);\n+    static assert(!hasContextPointers!(void*));\n+\n+    static struct S {}\n+    static assert(!hasContextPointers!S);\n+    static assert(!hasContextPointers!(S[1]));\n+\n+    struct Nested\n+    {\n+        void foo() {}\n+    }\n+\n+    static assert(hasContextPointers!Nested);\n+    static assert(hasContextPointers!(Nested[1]));\n+\n+    static struct OneLevel\n+    {\n+        int before;\n+        Nested n;\n+        int after;\n+    }\n+\n+    static assert(hasContextPointers!OneLevel);\n+    static assert(hasContextPointers!(OneLevel[1]));\n+\n+    static struct TwoLevels\n+    {\n+        int before;\n+        OneLevel o;\n+        int after;\n+    }\n+\n+    static assert(hasContextPointers!TwoLevels);\n+    static assert(hasContextPointers!(TwoLevels[1]));\n+\n+    union U\n+    {\n+        Nested n;\n+    }\n+\n+    // unions can have false positives, so this query ignores them\n+    static assert(!hasContextPointers!U);\n+}\n+\n // target must be first-parameter, because in void-functions DMD + dip1000 allows it to take the place of a return-scope\n private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n {\n@@ -2119,9 +2178,10 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n //              \"Cannot move object with internal pointer unless `opPostMove` is defined.\");\n //    }\n \n+    import core.internal.traits : hasElaborateAssign, isAssignable, hasElaborateMove,\n+                                  hasElaborateDestructor, hasElaborateCopyConstructor;\n     static if (is(T == struct))\n     {\n-        import core.internal.traits;\n \n         //  Unsafe when compiling without -preview=dip1000\n         assert((() @trusted => &source !is &target)(), \"source and target must not be identical\");\n@@ -2141,29 +2201,36 @@ private void moveEmplaceImpl(T)(scope ref T target, return scope ref T source)\n         // object in order to avoid double freeing and undue aliasing\n         static if (hasElaborateDestructor!T || hasElaborateCopyConstructor!T)\n         {\n-            // If T is nested struct, keep original context pointer\n-            static if (__traits(isNested, T))\n-                enum sz = T.sizeof - (void*).sizeof;\n-            else\n-                enum sz = T.sizeof;\n-\n+            // If there are members that are nested structs, we must take care\n+            // not to erase any context pointers, so we might have to recurse\n             static if (__traits(isZeroInit, T))\n+                wipe(source);\n+            else\n+                wipe(source, ref () @trusted { return *cast(immutable(T)*) __traits(initSymbol, T).ptr; } ());\n+        }\n+    }\n+    else static if (__traits(isStaticArray, T))\n+    {\n+        static if (T.length)\n+        {\n+            static if (!hasElaborateMove!T &&\n+                       !hasElaborateDestructor!T &&\n+                       !hasElaborateCopyConstructor!T)\n             {\n-                import core.stdc.string : memset;\n-                () @trusted { memset(&source, 0, sz); }();\n+                // Single blit if no special per-instance handling is required\n+                () @trusted\n+                {\n+                    assert(source.ptr !is target.ptr, \"source and target must not be identical\");\n+                    *cast(ubyte[T.sizeof]*) &target = *cast(ubyte[T.sizeof]*) &source;\n+                } ();\n             }\n             else\n             {\n-                import core.stdc.string : memcpy;\n-                () @trusted { memcpy(&source, __traits(initSymbol, T).ptr, sz); }();\n+                for (size_t i = 0; i < source.length; ++i)\n+                    moveEmplaceImpl(target[i], source[i]);\n             }\n         }\n     }\n-    else static if (__traits(isStaticArray, T))\n-    {\n-        for (size_t i = 0; i < source.length; ++i)\n-            moveEmplaceImpl(target[i], source[i]);\n-    }\n     else\n     {\n         // Primitive data (including pointers and arrays) or class -\n@@ -2258,6 +2325,13 @@ pure nothrow @nogc @system unittest\n     f(move(ncarray));\n }\n \n+//debug = PRINTF;\n+\n+debug(PRINTF)\n+{\n+    import core.stdc.stdio;\n+}\n+\n /// Implementation of `_d_delstruct` and `_d_delstructTrace`\n template _d_delstructImpl(T)\n {\n@@ -2361,3 +2435,270 @@ template _d_delstructImpl(T)\n     assert(innerDtors == 2);\n     assert(outerDtors == 1);\n }\n+\n+// issue 25552\n+pure nothrow @system unittest\n+{\n+    int i;\n+    struct Nested\n+    {\n+    pure nothrow @nogc:\n+        char[1] arr; // char.init is not 0\n+        ~this() { ++i; }\n+    }\n+\n+    {\n+        Nested[1] dst = void;\n+        Nested[1] src = [Nested(['a'])];\n+\n+        moveEmplace(src, dst);\n+        assert(i == 0);\n+        assert(dst[0].arr == ['a']);\n+        assert(src[0].arr == [char.init]);\n+        assert(dst[0].tupleof[$-1] is src[0].tupleof[$-1]);\n+    }\n+    assert(i == 2);\n+}\n+\n+// issue 25552\n+@safe unittest\n+{\n+    int i;\n+    struct Nested\n+    {\n+        ~this() { ++i; }\n+    }\n+\n+    static struct NotNested\n+    {\n+        Nested n;\n+    }\n+\n+    static struct Deep\n+    {\n+        NotNested nn;\n+    }\n+\n+    static struct Deeper\n+    {\n+        NotNested[1] nn;\n+    }\n+\n+    static assert(__traits(isZeroInit, Nested));\n+    static assert(__traits(isZeroInit, NotNested));\n+    static assert(__traits(isZeroInit, Deep));\n+    static assert(__traits(isZeroInit, Deeper));\n+\n+    {\n+        auto a = NotNested(Nested());\n+        assert(a.n.tupleof[$-1]);\n+        auto b = move(a);\n+        assert(b.n.tupleof[$-1]);\n+        assert(a.n.tupleof[$-1] is b.n.tupleof[$-1]);\n+\n+        auto c = Deep(NotNested(Nested()));\n+        auto d = move(c);\n+        assert(d.nn.n.tupleof[$-1]);\n+        assert(c.nn.n.tupleof[$-1] is d.nn.n.tupleof[$-1]);\n+\n+        auto e = Deeper([NotNested(Nested())]);\n+        auto f = move(e);\n+        assert(f.nn[0].n.tupleof[$-1]);\n+        assert(e.nn[0].n.tupleof[$-1] is f.nn[0].n.tupleof[$-1]);\n+    }\n+    assert(i == 6);\n+}\n+\n+// issue 25552\n+@safe unittest\n+{\n+    int i;\n+    struct Nested\n+    {\n+        align(32) // better still find context pointer correctly!\n+        int[3] stuff = [0, 1, 2];\n+        ~this() { ++i; }\n+    }\n+\n+    static struct NoAssign\n+    {\n+        int value;\n+        @disable void opAssign(typeof(this));\n+    }\n+\n+    static struct NotNested\n+    {\n+        int before = 42;\n+        align(Nested.alignof * 4) // better still find context pointer correctly!\n+        Nested n;\n+        auto after = NoAssign(43);\n+    }\n+\n+    static struct Deep\n+    {\n+        NotNested nn;\n+    }\n+\n+    static struct Deeper\n+    {\n+        NotNested[1] nn;\n+    }\n+\n+    static assert(!__traits(isZeroInit, Nested));\n+    static assert(!__traits(isZeroInit, NotNested));\n+    static assert(!__traits(isZeroInit, Deep));\n+    static assert(!__traits(isZeroInit, Deeper));\n+\n+    {\n+        auto a = NotNested(1, Nested([3, 4, 5]), NoAssign(2));\n+        auto b = move(a);\n+        assert(b.n.tupleof[$-1]);\n+        assert(a.n.tupleof[$-1] is b.n.tupleof[$-1]);\n+        assert(a.n.stuff == [0, 1, 2]);\n+        assert(a.before == 42);\n+        assert(a.after == NoAssign(43));\n+\n+        auto c = Deep(NotNested(1, Nested([3, 4, 5]), NoAssign(2)));\n+        auto d = move(c);\n+        assert(d.nn.n.tupleof[$-1]);\n+        assert(c.nn.n.tupleof[$-1] is d.nn.n.tupleof[$-1]);\n+        assert(c.nn.n.stuff == [0, 1, 2]);\n+        assert(c.nn.before == 42);\n+        assert(c.nn.after == NoAssign(43));\n+\n+        auto e = Deeper([NotNested(1, Nested([3, 4, 5]), NoAssign(2))]);\n+        auto f = move(e);\n+        assert(f.nn[0].n.tupleof[$-1]);\n+        assert(e.nn[0].n.tupleof[$-1] is f.nn[0].n.tupleof[$-1]);\n+        assert(e.nn[0].n.stuff == [0, 1, 2]);\n+        assert(e.nn[0].before == 42);\n+        assert(e.nn[0].after == NoAssign(43));\n+    }\n+    assert(i == 6);\n+}\n+\n+// wipes source after moving\n+pragma(inline, true)\n+private void wipe(T, Init...)(return scope ref T source, ref const scope Init initializer) @trusted\n+if (!Init.length ||\n+    ((Init.length == 1) && (is(immutable T == immutable Init[0]))))\n+{\n+    static if (__traits(isStaticArray, T) && hasContextPointers!T)\n+    {\n+        for (auto i = 0; i < T.length; i++)\n+            static if (Init.length)\n+                wipe(source[i], initializer[0][i]);\n+            else\n+                wipe(source[i]);\n+    }\n+    else static if (is(T == struct) && hasContextPointers!T)\n+    {\n+        import core.internal.traits : anySatisfy;\n+        static if (anySatisfy!(hasContextPointers, typeof(T.tupleof)))\n+        {\n+            static foreach (i; 0 .. T.tupleof.length - __traits(isNested, T))\n+                static if (Init.length)\n+                    wipe(source.tupleof[i], initializer[0].tupleof[i]);\n+                else\n+                    wipe(source.tupleof[i]);\n+        }\n+        else\n+        {\n+            static if (__traits(isNested, T))\n+                enum sz = T.tupleof[$-1].offsetof;\n+            else\n+                enum sz = T.sizeof;\n+\n+            static if (Init.length)\n+                *cast(ubyte[sz]*) &source = *cast(ubyte[sz]*) &initializer[0];\n+            else\n+                *cast(ubyte[sz]*) &source = 0;\n+        }\n+    }\n+    else\n+    {\n+        import core.internal.traits : hasElaborateAssign, isAssignable;\n+        static if (Init.length)\n+        {\n+            static if (hasElaborateAssign!T || !isAssignable!T)\n+                *cast(ubyte[T.sizeof]*) &source = *cast(ubyte[T.sizeof]*) &initializer[0];\n+            else\n+                source = *cast(T*) &initializer[0];\n+        }\n+        else\n+        {\n+            *cast(ubyte[T.sizeof]*) &source = 0;\n+        }\n+    }\n+}\n+\n+/**\n+ * Allocate an exception of type `T` from the exception pool and call its constructor.\n+ * It has the same interface as `rt.lifetime._d_newclass()`.\n+ * `T` must be Throwable or derived from it, must declare an explicit ctor\n+ * and cannot be a COM or C++ class.\n+ * Returns:\n+ *      constructed instance of the type\n+ */\n+T _d_newThrowable(T, Args...)(auto ref Args args) @trusted\n+    if (is(T : Throwable) && is(typeof(T.__ctor(forward!args))) &&\n+        __traits(getLinkage, T) == \"D\")\n+{\n+    debug(PRINTF) printf(\"_d_newThrowable(%s)\\n\", cast(char*) T.stringof);\n+\n+    import core.stdc.stdlib : malloc;\n+    auto init = __traits(initSymbol, T);\n+    void* p = malloc(init.length);\n+    if (!p)\n+    {\n+        import core.exception : onOutOfMemoryError;\n+        onOutOfMemoryError();\n+    }\n+\n+    debug(PRINTF) printf(\" p = %p\\n\", p);\n+\n+    // initialize it\n+    p[0 .. init.length] = init[];\n+\n+    import core.internal.traits : hasIndirections;\n+    if (hasIndirections!T)\n+    {\n+        // Inform the GC about the pointers in the object instance\n+        import core.memory : GC;\n+        GC.addRange(p, init.length);\n+    }\n+\n+    debug(PRINTF) printf(\"initialization done\\n\");\n+\n+    (cast(Throwable) p).refcount() = 1;\n+\n+    auto t = cast(T) p;\n+    t.__ctor(forward!args);\n+\n+    return t;\n+}\n+\n+@system unittest\n+{\n+    class E : Exception\n+    {\n+        int x;\n+\n+        this(int x, string msg = \"\", Throwable nextInChain = null)\n+        {\n+            super(msg, nextInChain);\n+            this.x = x;\n+        }\n+    }\n+\n+    auto exc = _d_newThrowable!Exception(\"Exception\");\n+    assert(exc.refcount() == 1);\n+    assert(exc.msg == \"Exception\");\n+\n+    static assert(!__traits(compiles, _d_newThrowable!E()));\n+\n+    auto e = _d_newThrowable!E(42, \"E\", null);\n+    assert(e.refcount() == 1);\n+    assert(e.x == 42);\n+    assert(e.msg == \"E\");\n+}"}, {"sha": "6ba569a241cf3ed2c4400325f845207706175499", "filename": "libphobos/libdruntime/core/memory.d", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fmemory.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -459,8 +459,11 @@ extern(C):\n      * Throws:\n      *  OutOfMemoryError on allocation failure.\n      */\n-    pragma(mangle, \"gc_malloc\") static void* malloc(size_t sz, uint ba = 0, const scope TypeInfo ti = null) pure nothrow;\n-\n+    version (D_ProfileGC)\n+        pragma(mangle, \"gc_mallocTrace\") static void* malloc(size_t sz, uint ba = 0, const scope TypeInfo ti = null,\n+            string file = __FILE__, int line = __LINE__, string func = __FUNCTION__) pure nothrow;\n+    else\n+        pragma(mangle, \"gc_malloc\") static void* malloc(size_t sz, uint ba = 0, const scope TypeInfo ti = null) pure nothrow;\n \n     /**\n      * Requests an aligned block of managed memory from the garbage collector.\n@@ -482,7 +485,11 @@ extern(C):\n      * Throws:\n      *  OutOfMemoryError on allocation failure.\n      */\n-    pragma(mangle, \"gc_qalloc\") static BlkInfo qalloc(size_t sz, uint ba = 0, const scope TypeInfo ti = null) pure nothrow;\n+    version (D_ProfileGC)\n+        pragma(mangle, \"gc_qallocTrace\") static BlkInfo qalloc(size_t sz, uint ba = 0, const scope TypeInfo ti = null,\n+            string file = __FILE__, int line = __LINE__, string func = __FUNCTION__) pure nothrow;\n+    else\n+        pragma(mangle, \"gc_qalloc\") static BlkInfo qalloc(size_t sz, uint ba = 0, const scope TypeInfo ti = null) pure nothrow;\n \n \n     /**\n@@ -506,7 +513,11 @@ extern(C):\n      * Throws:\n      *  OutOfMemoryError on allocation failure.\n      */\n-    pragma(mangle, \"gc_calloc\") static void* calloc(size_t sz, uint ba = 0, const TypeInfo ti = null) pure nothrow;\n+    version (D_ProfileGC)\n+        pragma(mangle, \"gc_callocTrace\") static void* calloc(size_t sz, uint ba = 0, const TypeInfo ti = null,\n+            string file = __FILE__, int line = __LINE__, string func = __FUNCTION__) pure nothrow;\n+    else\n+        pragma(mangle, \"gc_calloc\") static void* calloc(size_t sz, uint ba = 0, const TypeInfo ti = null) pure nothrow;\n \n \n     /**\n@@ -551,7 +562,11 @@ extern(C):\n      * Throws:\n      *  `OutOfMemoryError` on allocation failure.\n      */\n-    pragma(mangle, \"gc_realloc\") static void* realloc(return scope void* p, size_t sz, uint ba = 0, const TypeInfo ti = null) pure nothrow;\n+    version (D_ProfileGC)\n+        pragma(mangle, \"gc_reallocTrace\") static void* realloc(return scope void* p, size_t sz, uint ba = 0, const TypeInfo ti = null,\n+            string file = __FILE__, int line = __LINE__, string func = __FUNCTION__) pure nothrow;\n+    else\n+        pragma(mangle, \"gc_realloc\") static void* realloc(return scope void* p, size_t sz, uint ba = 0, const TypeInfo ti = null) pure nothrow;\n \n     // https://issues.dlang.org/show_bug.cgi?id=13111\n     ///\n@@ -593,7 +608,12 @@ extern(C):\n      *  as an indicator of success. $(LREF capacity) should be used to\n      *  retrieve actual usable slice capacity.\n      */\n-    pragma(mangle, \"gc_extend\") static size_t extend(void* p, size_t mx, size_t sz, const TypeInfo ti = null) pure nothrow;\n+    version (D_ProfileGC)\n+        pragma(mangle, \"gc_extendTrace\") static size_t extend(void* p, size_t mx, size_t sz, const TypeInfo ti = null,\n+            string file = __FILE__, int line = __LINE__, string func = __FUNCTION__) pure nothrow;\n+    else\n+        pragma(mangle, \"gc_extend\") static size_t extend(void* p, size_t mx, size_t sz, const TypeInfo ti = null) pure nothrow;\n+\n     /// Standard extending\n     unittest\n     {"}, {"sha": "0c5da0bfefa6734ae23dd3f3524a73981eba4f75", "filename": "libphobos/libdruntime/core/stdc/math.d", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fmath.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -850,59 +850,59 @@ else version (CRuntime_UClibc)\n         FP_FAST_FMAL = 0,\n     }\n \n-    int __fpclassifyf(float x);\n-    int __fpclassify(double x);\n-    int __fpclassifyl(real x);\n+    pure int __fpclassifyf(float x);\n+    pure int __fpclassify(double x);\n+    pure int __fpclassifyl(real x);\n \n-    int __finitef(float x);\n-    int __finite(double x);\n-    int __finitel(real x);\n+    pure int __finitef(float x);\n+    pure int __finite(double x);\n+    pure int __finitel(real x);\n \n-    int __isinff(float x);\n-    int __isinf(double x);\n-    int __isinfl(real x);\n+    pure int __isinff(float x);\n+    pure int __isinf(double x);\n+    pure int __isinfl(real x);\n \n-    int __isnanf(float x);\n-    int __isnan(double x);\n-    int __isnanl(real x);\n+    pure int __isnanf(float x);\n+    pure int __isnan(double x);\n+    pure int __isnanl(real x);\n \n-    int __signbitf(float x);\n-    int __signbit(double x);\n-    int __signbitl(real x);\n+    pure int __signbitf(float x);\n+    pure int __signbit(double x);\n+    pure int __signbitl(real x);\n \n     ///\n-    pragma(mangle, \"__fpclassifyf\") int fpclassify(float x);\n+    pragma(mangle, \"__fpclassifyf\") pure int fpclassify(float x);\n     ///\n-    pragma(mangle, \"__fpclassify\")  int fpclassify(double x);\n+    pragma(mangle, \"__fpclassify\")  pure int fpclassify(double x);\n     ///\n     pragma(mangle, real.sizeof == double.sizeof ? \"__fpclassify\" : \"__fpclassifyl\")\n-    int fpclassify(real x);\n+    pure int fpclassify(real x);\n \n     ///\n-    pragma(mangle, \"__finitef\") int isfinite(float x);\n+    pragma(mangle, \"__finitef\") pure int isfinite(float x);\n     ///\n-    pragma(mangle, \"__finite\")  int isfinite(double x);\n+    pragma(mangle, \"__finite\")  pure int isfinite(double x);\n     ///\n     pragma(mangle, real.sizeof == double.sizeof ? \"__finite\" : \"__finitel\")\n-    int isfinite(real x);\n+    pure int isfinite(real x);\n \n     ///\n-    pragma(mangle, \"__isinff\") int isinf(float x);\n+    pragma(mangle, \"__isinff\") pure int isinf(float x);\n     ///\n-    pragma(mangle, \"__isinf\")  int isinf(double x);\n+    pragma(mangle, \"__isinf\")  pure int isinf(double x);\n     ///\n     pragma(mangle, real.sizeof == double.sizeof ? \"__isinf\" : \"__isinfl\")\n-    int isinf(real x);\n+    pure int isinf(real x);\n \n     ///\n-    pragma(mangle, \"__isnanf\") int isnan(float x);\n+    pragma(mangle, \"__isnanf\") pure int isnan(float x);\n     ///\n-    pragma(mangle, \"__isnan\")  int isnan(double x);\n+    pragma(mangle, \"__isnan\")  pure int isnan(double x);\n     ///\n     pragma(mangle, real.sizeof == double.sizeof ? \"__isnan\" : \"__isnanl\")\n-    int isnan(real x);\n+    pure int isnan(real x);\n \n-  extern (D)\n+  extern (D) pure\n   {\n     ///\n     int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }\n@@ -913,12 +913,12 @@ else version (CRuntime_UClibc)\n   }\n \n     ///\n-    pragma(mangle, \"__signbitf\") int signbit(float x);\n+    pragma(mangle, \"__signbitf\") pure int signbit(float x);\n     ///\n-    pragma(mangle, \"__signbit\")  int signbit(double x);\n+    pragma(mangle, \"__signbit\")  pure int signbit(double x);\n     ///\n     pragma(mangle, real.sizeof == double.sizeof ? \"__signbit\" : \"__signbitl\")\n-    int signbit(real x);\n+    pure int signbit(real x);\n }\n else version (Darwin)\n {\n@@ -3089,7 +3089,7 @@ else version (OpenBSD)\n     ///\n     pure real atanl(real x);\n     ///\n-    real atan2l(real x, real y);\n+    real atan2l(real y, real x);\n     ///\n     pure real cosl(real x);\n     ///\n@@ -3377,7 +3377,7 @@ else version (DragonFlyBSD)\n     pure real acosl(real x);\n     pure real asinl(real x);\n     pure real atanl(real x);\n-    real atan2l(real x, real y);\n+    real atan2l(real y, real x);\n     pure real cosl(real x);\n     pure real sinl(real x);\n     pure real tanl(real x);\n@@ -3872,7 +3872,7 @@ else version (CRuntime_UClibc)\n     ///\n     float   atan2f(float y, float x);\n     ///\n-    extern(D) real atan2l(real y, real x) { return atan2(cast(double) x, cast(double) y); }\n+    extern(D) real atan2l(real y, real x) { return atan2(cast(double) y, cast(double) x); }\n \n     ///\n     pure double  cos(double x);"}, {"sha": "6084f3f01f10661439355b7416f689d8d0a12ff1", "filename": "libphobos/libdruntime/core/sys/darwin/dlfcn.d", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -25,20 +25,6 @@ nothrow:\n \n public import core.sys.posix.dlfcn;\n \n-struct Dl_info\n-{\n-    const(char)* dli_fname;\n-    void*        dli_fbase;\n-    const(char)* dli_sname;\n-    void*        dli_saddr;\n-}\n-\n-int dladdr(const scope void* addr, Dl_info* info);\n-\n-enum RTLD_NOLOAD = 0x10;\n-enum RTLD_NODELETE = 0x80;\n-enum RTLD_FIRST = 0x100;\n-\n enum RTLD_NEXT = cast(void*) -1;\n enum RTLD_DEFAULT = cast(void*) -2;\n enum RTLD_SELF = cast(void*) -3;"}, {"sha": "0e8b15ccf88dd5d00d2300be93af5da5e6fb01a1", "filename": "libphobos/libdruntime/core/sys/dragonflybsd/dlfcn.d", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -14,18 +14,6 @@ public import core.sys.posix.dlfcn;\n \n extern (C) nothrow @nogc @system:\n \n-/*\n- * Modes and flags for dlopen().\n- */\n-static assert(RTLD_LAZY   == 1);\n-static assert(RTLD_NOW    == 2);\n-enum RTLD_MODEMASK        =  0x3;\n-static assert(RTLD_GLOBAL == 0x100);\n-static assert(RTLD_LOCAL  == 0);\n-enum RTLD_TRACE           =  0x200;\n-enum RTLD_NODELETE        =  0x01000;\n-enum RTLD_NOLOAD          =  0x02000;\n-\n /*\n  * Request arguments for dlinfo().\n  */\n@@ -42,17 +30,6 @@ enum RTLD_NEXT    = cast(void *)-1;    /* Search subsequent objects. */\n enum RTLD_DEFAULT = cast(void *)-2;    /* Use default search algorithm. */\n enum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n \n-/*\n- * Structure filled in by dladdr().\n- */\n-struct Dl_info {\n-    const(char)     *dli_fname;     /* Pathname of shared object. */\n-    void            *dli_fbase;     /* Base address of shared object. */\n-    const(char)     *dli_sname;     /* Name of nearest symbol. */\n-    void            *dli_saddr;     /* Address of nearest symbol. */\n-}\n-\n-\n /*\n  * Structures, returned by the RTLD_DI_SERINFO dlinfo() request.\n  */\n@@ -91,7 +68,6 @@ extern(C) {\n }\n \n void*    fdlopen(int, int);\n-int      dladdr(const(void)*, Dl_info*);\n dlfunc_t dlfunc(void*, const(char)*);\n int      dlinfo(void*, int, void*);\n /*void     dllockinit(void* _context,"}, {"sha": "aac41d8e7d659bf20ff5d23bd51375901559bd46", "filename": "libphobos/libdruntime/core/sys/freebsd/dlfcn.d", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Ffreebsd%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -16,18 +16,6 @@ nothrow:\n \n enum __BSD_VISIBLE = true;\n \n-/*\n- * Modes and flags for dlopen().\n- */\n-static assert(RTLD_LAZY   == 1);\n-static assert(RTLD_NOW    == 2);\n-enum RTLD_MODEMASK        =  0x3;\n-static assert(RTLD_GLOBAL == 0x100);\n-static assert(RTLD_LOCAL  == 0);\n-enum RTLD_TRACE           =  0x200;\n-enum RTLD_NODELETE        =  0x01000;\n-enum RTLD_NOLOAD          =  0x02000;\n-\n /*\n  * Request arguments for dlinfo().\n  */\n@@ -46,16 +34,6 @@ enum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n \n static if (__BSD_VISIBLE)\n {\n-    /*\n-     * Structure filled in by dladdr().\n-     */\n-    struct Dl_info {\n-        const(char)     *dli_fname;     /* Pathname of shared object. */\n-        void            *dli_fbase;     /* Base address of shared object. */\n-        const(char)     *dli_sname;     /* Name of nearest symbol. */\n-        void            *dli_saddr;     /* Address of nearest symbol. */\n-    }\n-\n     /*-\n      * The actual type declared by this typedef is immaterial, provided that\n      * it is a function pointer.  Its purpose is to provide a return type for\n@@ -97,7 +75,6 @@ extern(C) {\n static if (__BSD_VISIBLE)\n {\n     void*    fdlopen(int, int);\n-    int      dladdr(const(void)*, Dl_info*);\n     dlfunc_t dlfunc(void*, const(char)*);\n     int      dlinfo(void*, int, void*);\n     void     dllockinit(void* _context,"}, {"sha": "4a1228494719537ee4260899e4192e60e8ad83a3", "filename": "libphobos/libdruntime/core/sys/linux/dlfcn.d", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -34,16 +34,6 @@ import core.sys.linux.config;\n version (X86_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x00001; // POSIX\n-    // enum RTLD_NOW = 0x00002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x00100; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -58,16 +48,6 @@ version (X86_Any)\n else version (HPPA_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/hppa/bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x0004; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -82,16 +62,6 @@ else version (HPPA_Any)\n else version (MIPS_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/mips/bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00008;\n-    enum RTLD_DEEPBIND = 0x00010;\n-\n-    // enum RTLD_GLOBAL = 0x0004; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -106,16 +76,6 @@ else version (MIPS_Any)\n else version (PPC_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x00100; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -130,16 +90,6 @@ else version (PPC_Any)\n else version (ARM_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x00100; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -154,16 +104,6 @@ else version (ARM_Any)\n else version (RISCV_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x00100; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -178,16 +118,6 @@ else version (RISCV_Any)\n else version (SPARC_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x00100; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -202,16 +132,6 @@ else version (SPARC_Any)\n else version (IBMZ_Any)\n {\n     // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n-    // enum RTLD_LAZY = 0x0001; // POSIX\n-    // enum RTLD_NOW = 0x0002; // POSIX\n-    enum RTLD_BINDING_MASK = 0x3;\n-    enum RTLD_NOLOAD = 0x00004;\n-    enum RTLD_DEEPBIND = 0x00008;\n-\n-    // enum RTLD_GLOBAL = 0x00100; // POSIX\n-    // enum RTLD_LOCAL = 0; // POSIX\n-    enum RTLD_NODELETE = 0x01000;\n-\n     static if (__USE_GNU)\n     {\n         RT DL_CALL_FCT(RT, Args...)(RT function(Args) fctp, auto ref Args args)\n@@ -251,15 +171,6 @@ static if (__USE_GNU)\n \n static if (__USE_GNU)\n {\n-    struct Dl_info\n-    {\n-        const(char)* dli_fname;\n-        void* dli_fbase;\n-        const(char)* dli_sname;\n-        void* dli_saddr;\n-    }\n-\n-    int dladdr(const scope void* __address, Dl_info* __info);\n     int dladdr1(void* __address, Dl_info* __info, void** __extra_info, int __flags);\n \n     enum"}, {"sha": "11bdc85cf78d8f1475b12cd4b153dfdb7aa834e6", "filename": "libphobos/libdruntime/core/sys/linux/sys/inotify.d", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Finotify.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Finotify.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Finotify.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -6,7 +6,21 @@\n  */\n module core.sys.linux.sys.inotify;\n \n-version (linux):\n+// The BSDs (including macOS) have a kqueue-backed API-compatible inotify\n+// library in ports. However, inotify is a Linux interface so it lives here.\n+// All BSD people need this library to use inotify:\n+//   https://github.com/libinotify-kqueue/libinotify-kqueue\n+// It is the responsibility of all BSD people to configure the library before\n+// using this interface.\n+\n+version (linux)        version = LinuxOrCompatible;\n+version (Darwin)       version = LinuxOrCompatible;\n+version (FreeBSD)      version = LinuxOrCompatible;\n+version (OpenBSD)      version = LinuxOrCompatible;\n+version (NetBSD)       version = LinuxOrCompatible;\n+version (DragonFlyBSD) version = LinuxOrCompatible;\n+\n+version (LinuxOrCompatible):\n extern (C):\n @system:\n nothrow:"}, {"sha": "3785592fcd6fbd77e43fc80c3e7a3d62483aaec3", "filename": "libphobos/libdruntime/core/sys/netbsd/dlfcn.d", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fnetbsd%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -18,17 +18,6 @@ nothrow:\n \n enum __BSD_VISIBLE = true;\n \n-/*\n- * Modes and flags for dlopen().\n- */\n-static assert(RTLD_LAZY   == 1);\n-static assert(RTLD_NOW    == 2);\n-static assert(RTLD_GLOBAL == 0x100);\n-static assert(RTLD_LOCAL  == 0x200);\n-//enum RTLD_TRACE           =  0x200;\n-enum RTLD_NODELETE        =  0x01000;\n-enum RTLD_NOLOAD          =  0x02000;\n-\n /*\n  * Request arguments for dlinfo().\n  */\n@@ -47,16 +36,6 @@ enum RTLD_SELF    = cast(void *)-3;    /* Search the caller itself. */\n \n static if (__BSD_VISIBLE)\n {\n-    /*\n-     * Structure filled in by dladdr().\n-     */\n-    struct Dl_info {\n-        const(char)     *dli_fname;     /* Pathname of shared object. */\n-        void            *dli_fbase;     /* Base address of shared object. */\n-        const(char)     *dli_sname;     /* Name of nearest symbol. */\n-        void            *dli_saddr;     /* Address of nearest symbol. */\n-    }\n-\n     /*-\n      * The actual type declared by this typedef is immaterial, provided that\n      * it is a function pointer.  Its purpose is to provide a return type for\n@@ -97,16 +76,6 @@ extern(C) {\n \n static if (__BSD_VISIBLE)\n {\n-    //void*    fdlopen(int, int);\n-    int      dladdr(const(void)*, Dl_info*);\n-    //dlfunc_t dlfunc(void*, const(char)*);\n     int      dlinfo(void*, int, void*);\n-    /+void     dllockinit(void* _context,\n-        void* function(void* _context) _lock_create,\n-        void  function(void* _lock)    _rlock_acquire,\n-        void  function(void* _lock)    _wlock_acquire,\n-        void  function(void* _lock)    _lock_release,\n-        void  function(void* _lock)    _lock_destroy,\n-        void  function(void* _context) _context_destroy);+/\n     void*    dlvsym(void*, const(char)*, const(char)*);\n }"}, {"sha": "1227669e6244b24b9d70addfede83180ddb7406e", "filename": "libphobos/libdruntime/core/sys/openbsd/dlfcn.d", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fopenbsd%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -11,13 +11,6 @@ version (OpenBSD):\n extern (C):\n nothrow:\n \n-static assert(RTLD_LAZY   == 1);\n-static assert(RTLD_NOW    == 2);\n-static assert(RTLD_GLOBAL == 0x100);\n-static assert(RTLD_LOCAL  == 0);\n-enum RTLD_TRACE           =  0x200;\n-enum RTLD_NODELETE        =  0x400;\n-\n enum RTLD_NEXT    = cast(void *)-1;\n enum RTLD_DEFAULT = cast(void *)-2;\n enum RTLD_SELF    = cast(void *)-3;"}, {"sha": "bffbc5149a1c485556dda7017d5a3ef5e3ef42ae", "filename": "libphobos/libdruntime/core/sys/posix/dirent.d", "status": "modified", "additions": 114, "deletions": 126, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdirent.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdirent.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdirent.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -37,12 +37,124 @@ nothrow:\n // Required\n //\n /*\n-DIR\n-\n struct dirent\n {\n     char[] d_name;\n }\n+*/\n+\n+version (linux)\n+{\n+    struct dirent\n+    {\n+        ino_t       d_ino;\n+        off_t       d_off;\n+        ushort      d_reclen;\n+        ubyte       d_type;\n+        char[256]   d_name = 0;\n+    }\n+}\n+else version (Darwin)\n+{\n+    // _DARWIN_FEATURE_64_BIT_INODE dirent is default for Mac OSX >10.5 and is\n+    // only meaningful type for other OS X/Darwin variants (e.g. iOS).\n+    // man dir(5) has some info, man stat(2) gives details.\n+    struct dirent\n+    {\n+        ino_t       d_ino;\n+        alias       d_fileno = d_ino;\n+        ulong       d_seekoff;\n+        ushort      d_reclen;\n+        ushort      d_namlen;\n+        ubyte       d_type;\n+        char[1024]  d_name = 0;\n+    }\n+}\n+else version (FreeBSD)\n+{\n+    import core.sys.freebsd.config;\n+\n+    static if (__FreeBSD_version >= 1200000)\n+    {\n+        struct dirent\n+        {\n+            ino_t     d_fileno;\n+            off_t     d_off;\n+            ushort    d_reclen;\n+            ubyte     d_type;\n+            ubyte     d_pad0;\n+            ushort    d_namlen;\n+            ushort    d_pad1;\n+            char[256] d_name = 0;\n+        }\n+    }\n+    else\n+    {\n+        align(4)\n+        struct dirent\n+        {\n+            uint      d_fileno;\n+            ushort    d_reclen;\n+            ubyte     d_type;\n+            ubyte     d_namlen;\n+            char[256] d_name = 0;\n+        }\n+    }\n+}\n+else version (NetBSD)\n+{\n+    struct dirent\n+    {\n+        ulong      d_fileno;\n+        ushort    d_reclen;\n+        ushort    d_namlen;\n+        ubyte     d_type;\n+        char[512] d_name = 0;\n+    }\n+}\n+else version (OpenBSD)\n+{\n+    align(4)\n+    struct dirent\n+    {\n+        ino_t     d_fileno;\n+        off_t     d_off;\n+        ushort    d_reclen;\n+        ubyte     d_type;\n+        ubyte     d_namlen;\n+        ubyte[4]  __d_padding;\n+        char[256] d_name = 0;\n+    }\n+}\n+else version (DragonFlyBSD)\n+{\n+    struct dirent\n+    {\n+        ino_t     d_fileno;       /* file number of entry */\n+        ushort    d_reclen;       /* strlen(d_name) */\n+        ubyte     d_type;         /* file type, see blow */\n+        ubyte     d_unused1;      /* padding, reserved */\n+        uint      d_unused2;      /* reserved */\n+        char[256] d_name = 0;     /* name, NUL-terminated */\n+    }\n+}\n+else version (Solaris)\n+{\n+    struct dirent\n+    {\n+        ino_t d_ino;\n+        off_t d_off;\n+        ushort d_reclen;\n+        char[1] d_name = 0;\n+    }\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+DIR\n \n int     closedir(DIR*);\n DIR*    opendir(const scope char*);\n@@ -67,15 +179,6 @@ version (CRuntime_Glibc)\n         DT_WHT      = 14\n     }\n \n-    struct dirent\n-    {\n-        ino_t       d_ino;\n-        off_t       d_off;\n-        ushort      d_reclen;\n-        ubyte       d_type;\n-        char[256]   d_name = 0;\n-    }\n-\n     struct DIR\n     {\n         // Managed by OS\n@@ -106,20 +209,6 @@ else version (Darwin)\n         DT_WHT      = 14\n     }\n \n-    // _DARWIN_FEATURE_64_BIT_INODE dirent is default for Mac OSX >10.5 and is\n-    // only meaningful type for other OS X/Darwin variants (e.g. iOS).\n-    // man dir(5) has some info, man stat(2) gives details.\n-    struct dirent\n-    {\n-        ino_t       d_ino;\n-        alias       d_fileno = d_ino;\n-        ulong       d_seekoff;\n-        ushort      d_reclen;\n-        ushort      d_namlen;\n-        ubyte       d_type;\n-        char[1024]  d_name = 0;\n-    }\n-\n     struct DIR\n     {\n         // Managed by OS\n@@ -157,33 +246,6 @@ else version (FreeBSD)\n         DT_WHT      = 14\n     }\n \n-    static if (__FreeBSD_version >= 1200000)\n-    {\n-        struct dirent\n-        {\n-            ino_t     d_fileno;\n-            off_t     d_off;\n-            ushort    d_reclen;\n-            ubyte     d_type;\n-            ubyte     d_pad0;\n-            ushort    d_namlen;\n-            ushort    d_pad1;\n-            char[256] d_name = 0;\n-        }\n-    }\n-    else\n-    {\n-        align(4)\n-        struct dirent\n-        {\n-            uint      d_fileno;\n-            ushort    d_reclen;\n-            ubyte     d_type;\n-            ubyte     d_namlen;\n-            char[256] d_name = 0;\n-        }\n-    }\n-\n     alias void* DIR;\n \n     version (GNU)\n@@ -213,15 +275,6 @@ else version (NetBSD)\n         DT_WHT      = 14\n     }\n \n-    struct dirent\n-    {\n-        ulong      d_fileno;\n-        ushort    d_reclen;\n-        ushort    d_namlen;\n-        ubyte     d_type;\n-        char[512] d_name = 0;\n-    }\n-\n     alias void* DIR;\n \n     dirent* __readdir30(DIR*);\n@@ -241,18 +294,6 @@ else version (OpenBSD)\n         DT_SOCK     = 12,\n     }\n \n-    align(4)\n-    struct dirent\n-    {\n-        ino_t     d_fileno;\n-        off_t     d_off;\n-        ushort    d_reclen;\n-        ubyte     d_type;\n-        ubyte     d_namlen;\n-        ubyte[4]  __d_padding;\n-        char[256] d_name = 0;\n-    }\n-\n     alias void* DIR;\n \n     dirent* readdir(DIR*);\n@@ -273,30 +314,12 @@ else version (DragonFlyBSD)\n         DT_DBF      = 15,         /* database record file */\n     }\n \n-    struct dirent\n-    {\n-        ino_t     d_fileno;       /* file number of entry */\n-        ushort    d_reclen;       /* strlen(d_name) */\n-        ubyte     d_type;         /* file type, see blow */\n-        ubyte     d_unused1;      /* padding, reserved */\n-        uint      d_unused2;      /* reserved */\n-        char[256] d_name = 0;     /* name, NUL-terminated */\n-    }\n-\n     alias void* DIR;\n \n     dirent* readdir(DIR*);\n }\n else version (Solaris)\n {\n-    struct dirent\n-    {\n-        ino_t d_ino;\n-        off_t d_off;\n-        ushort d_reclen;\n-        char[1] d_name = 0;\n-    }\n-\n     struct DIR\n     {\n         int dd_fd;\n@@ -338,15 +361,6 @@ else version (CRuntime_Bionic)\n         DT_WHT      = 14\n     }\n \n-    struct dirent\n-    {\n-        ulong       d_ino;\n-        long        d_off;\n-        ushort      d_reclen;\n-        ubyte       d_type;\n-        char[256]   d_name = 0;\n-    }\n-\n     struct DIR\n     {\n     }\n@@ -368,15 +382,6 @@ else version (CRuntime_Musl)\n         DT_WHT      = 14\n     }\n \n-    struct dirent\n-    {\n-        ino_t       d_ino;\n-        off_t       d_off;\n-        ushort      d_reclen;\n-        ubyte       d_type;\n-        char[256]   d_name = 0;\n-    }\n-\n     struct DIR\n     {\n     }\n@@ -408,23 +413,6 @@ else version (CRuntime_UClibc)\n         DT_WHT      = 14\n     }\n \n-    struct dirent\n-    {\n-        static if (__USE_FILE_OFFSET64)\n-        {\n-            ino64_t d_ino;\n-            off64_t d_off;\n-        }\n-        else\n-        {\n-            ino_t d_ino;\n-            off_t d_off;\n-        }\n-        ushort      d_reclen;\n-        ubyte       d_type;\n-        char[256]   d_name = 0;\n-    }\n-\n     struct DIR\n     {\n         // Managed by OS"}, {"sha": "a9519ca234aa9594bd984186644892da50cf0f2e", "filename": "libphobos/libdruntime/core/sys/posix/dlfcn.d", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -66,59 +66,100 @@ version (CRuntime_Glibc)\n {\n     version (X86_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n         enum RTLD_LAZY      = 0x00001;\n         enum RTLD_NOW       = 0x00002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x00100;\n         enum RTLD_LOCAL     = 0x00000;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else version (HPPA_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/hppa/bits/dlfcn.h\n         enum RTLD_LAZY      = 0x0001;\n         enum RTLD_NOW       = 0x0002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x0100;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else version (MIPS_Any)\n     {\n+    // http://sourceware.org/git/?p=glibc.git;a=blob;f=ports/sysdeps/mips/bits/dlfcn.h\n         enum RTLD_LAZY      = 0x0001;\n         enum RTLD_NOW       = 0x0002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00008;\n+        enum RTLD_DEEPBIND  = 0x00010;\n         enum RTLD_GLOBAL    = 0x0004;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else version (PPC_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n         enum RTLD_LAZY      = 0x00001;\n         enum RTLD_NOW       = 0x00002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x00100;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else version (ARM_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n         enum RTLD_LAZY      = 0x00001;\n         enum RTLD_NOW       = 0x00002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x00100;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else version (RISCV_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n         enum RTLD_LAZY      = 0x00001;\n         enum RTLD_NOW       = 0x00002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x00100;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else version (SPARC_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n         enum RTLD_LAZY      = 0x00001;\n         enum RTLD_NOW       = 0x00002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x00100;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n+\n     }\n     else version (IBMZ_Any)\n     {\n+        // http://sourceware.org/git/?p=glibc.git;a=blob;f=bits/dlfcn.h\n         enum RTLD_LAZY      = 0x00001;\n         enum RTLD_NOW       = 0x00002;\n+        enum RTLD_BINDING_MASK = 0x3;\n+        enum RTLD_NOLOAD    = 0x00004;\n+        enum RTLD_DEEPBIND  = 0x00008;\n         enum RTLD_GLOBAL    = 0x00100;\n         enum RTLD_LOCAL     = 0;\n+        enum RTLD_NODELETE  = 0x01000;\n     }\n     else\n         static assert(0, \"unimplemented\");\n@@ -127,13 +168,25 @@ version (CRuntime_Glibc)\n     char* dlerror();\n     void* dlopen(const scope char*, int);\n     void* dlsym(void*, const scope char*);\n+    int dladdr(const scope void*, Dl_info*);\n+\n+    struct Dl_info\n+    {\n+        const(char)* dli_fname;\n+        void* dli_fbase;\n+        const(char)* dli_sname;\n+        void* dli_saddr;\n+    }\n }\n else version (Darwin)\n {\n     enum RTLD_LAZY      = 0x00001;\n     enum RTLD_NOW       = 0x00002;\n+    enum RTLD_NOLOAD    = 0x10;\n+    enum RTLD_NODELETE  = 0x80;\n     enum RTLD_GLOBAL    = 0x00100;\n     enum RTLD_LOCAL     = 0x00000;\n+    enum RTLD_FIRST     = 0x100;\n \n     int   dlclose(void*);\n     char* dlerror();\n@@ -153,8 +206,12 @@ else version (FreeBSD)\n {\n     enum RTLD_LAZY      = 1;\n     enum RTLD_NOW       = 2;\n+    enum RTLD_MODEMASK  =  0x3;\n     enum RTLD_GLOBAL    = 0x100;\n     enum RTLD_LOCAL     = 0;\n+    enum RTLD_TRACE     =  0x200;\n+    enum RTLD_NODELETE  =  0x01000;\n+    enum RTLD_NOLOAD    =  0x02000;\n \n     int   dlclose(void*);\n     char* dlerror();\n@@ -199,6 +256,8 @@ else version (OpenBSD)\n     enum RTLD_NOW       = 2;\n     enum RTLD_GLOBAL    = 0x100;\n     enum RTLD_LOCAL     = 0;\n+    enum RTLD_TRACE     = 0x200;\n+    enum RTLD_NODELETE  = 0x400;\n \n     int   dlclose(void*);\n     char* dlerror();\n@@ -218,8 +277,12 @@ else version (DragonFlyBSD)\n {\n     enum RTLD_LAZY      = 1;\n     enum RTLD_NOW       = 2;\n+    enum RTLD_MODEMASK  =  0x3;\n     enum RTLD_GLOBAL    = 0x100;\n     enum RTLD_LOCAL     = 0;\n+    enum RTLD_TRACE     =  0x200;\n+    enum RTLD_NODELETE  =  0x01000;\n+    enum RTLD_NOLOAD    =  0x02000;\n \n     int   dlclose(void*);\n     char* dlerror();\n@@ -239,8 +302,16 @@ else version (Solaris)\n {\n     enum RTLD_LAZY      = 1;\n     enum RTLD_NOW       = 2;\n+    enum RTLD_NOLOAD    = 0x00004;\n+    enum RTLD_DEEPBIND  = 0x00008;\n     enum RTLD_GLOBAL    = 0x100;\n     enum RTLD_LOCAL     = 0;\n+    enum RTLD_PARENT    = 0x00200;\n+    enum RTLD_GROUP     = 0x00400;\n+    enum RTLD_WORLD     = 0x00800;\n+    enum RTLD_NODELETE  = 0x01000;\n+    enum RTLD_FIRST     = 0x02000;\n+    enum RTLD_CONFGEN   = 0x10000;\n \n     int   dlclose(void*);\n     char* dlerror();\n@@ -343,4 +414,13 @@ else version (CRuntime_UClibc)\n     char* dlerror();\n     void* dlopen(const scope char*, int);\n     void* dlsym(void*, const scope char*);\n+    int dladdr(const scope void*, Dl_info*);\n+\n+    struct Dl_info\n+    {\n+        const(char)* dli_fname;\n+        void* dli_fbase;\n+        const(char)* dli_sname;\n+        void* dli_saddr;\n+    }\n }"}, {"sha": "3c196d29f221ef746bd26dceee9c3be478fc0740", "filename": "libphobos/libdruntime/core/sys/posix/fcntl.d", "status": "modified", "additions": 174, "deletions": 349, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ffcntl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ffcntl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ffcntl.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -96,12 +96,8 @@ struct flock\n     off_t   l_len;\n     pid_t   l_pid;\n }\n-\n-int creat(const scope char*, mode_t);\n-int fcntl(int, int, ...);\n-int open(const scope char*, int, ...);\n */\n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum F_DUPFD        = 0;\n     enum F_GETFD        = 1;\n@@ -121,6 +117,12 @@ version (CRuntime_Glibc)\n     enum F_SETLK        = 6;\n     enum F_SETLKW       = 7;\n   }\n+  else version (PPC64)\n+  {\n+    enum F_GETLK        = 5;\n+    enum F_SETLK        = 6;\n+    enum F_SETLKW       = 7;\n+  }\n   else version (SystemZ)\n   {\n     static assert(off_t.sizeof == 8);\n@@ -163,6 +165,19 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x101000; // octal 04010000\n         enum O_DSYNC        = 0x1000;   // octal   010000\n         enum O_RSYNC        = O_SYNC;\n+\n+        enum O_DIRECTORY    = 0x010000; // octal   0200000\n+        enum O_NOFOLLOW     = 0x020000; // octal   0400000\n+        enum O_DIRECT       = 0x004000; // octal    040000\n+        version (X86_64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x08000; // octal   0100000\n+        enum O_TMPFILE      = 0x410000; // octal 020200000\n+        enum O_ASYNC        = 0x2000;   // octal    020000\n+        enum O_NOATIME      = 0x40000;  // octal  01000000\n+        enum O_PATH         = 0x200000; // octal 010000000\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else version (HPPA_Any)\n     {\n@@ -177,6 +192,16 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x48000;  // octal 01100000\n         enum O_DSYNC        = 0x40000;  // octal 01000000\n         enum O_RSYNC        = 0x80000;  // octal 02000000\n+\n+        enum O_DIRECTORY    = 0x001000; // octal 000010000\n+        enum O_NOFOLLOW     = 0x000080; // octal 000000200\n+        enum O_DIRECT       = 0x004000; // octal    040000\n+        enum O_LARGEFILE    = 0x000800; // octal  00004000\n+        enum O_TMPFILE      = 0x801000; // octal 040010000\n+        enum O_ASYNC        = 0x2000;   // octal    020000\n+        enum O_NOATIME      = 0x100000; // octal 004000000\n+        enum O_PATH         = 0x400000; // octal 020000000\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else version (MIPS_Any)\n     {\n@@ -191,6 +216,19 @@ version (CRuntime_Glibc)\n         enum O_CLOEXEC      = 0x80000;\n         enum O_RSYNC        = O_SYNC;\n         enum O_SYNC         = 0x4010;\n+\n+        enum O_DIRECTORY    = 0x010000;\n+        enum O_NOFOLLOW     = 0x020000;\n+        enum O_DIRECT       = 0x8000;\n+        version (MIPS_N64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x2000;\n+        enum O_TMPFILE      = 0x410000;\n+        enum O_ASYNC        = 0x1000;\n+        enum O_NOATIME      = 0x40000;\n+        enum O_PATH         = 0x200000;\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else version (PPC_Any)\n     {\n@@ -205,6 +243,19 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x101000; // octal 04010000\n         enum O_DSYNC        = 0x1000;   // octal   010000\n         enum O_RSYNC        = O_SYNC;\n+\n+        enum O_DIRECTORY    = 0x004000; // octal    040000\n+        enum O_NOFOLLOW     = 0x008000; // octal   0100000\n+        enum O_DIRECT       = 0x020000; // octal   0400000\n+        version (D_LP64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x10000; // octal   0200000\n+        enum O_TMPFILE      = 0x404000; // octal 020040000\n+        enum O_ASYNC        = 0x2000;   // octal    020000\n+        enum O_NOATIME      = 0x40000;  // octal  01000000\n+        enum O_PATH         = 0x200000;\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else version (ARM_Any)\n     {\n@@ -219,6 +270,19 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x101000; // octal 04010000\n         enum O_DSYNC        = 0x1000;   // octal   010000\n         enum O_RSYNC        = O_SYNC;\n+\n+        enum O_DIRECTORY    = 0x004000; // octal    040000\n+        enum O_NOFOLLOW     = 0x008000; // octal   0100000\n+        enum O_DIRECT       = 0x010000; // octal   0200000\n+        version (D_LP64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x20000; // octal   0400000\n+        enum O_TMPFILE      = 0x404000; // octal 020040000\n+        enum O_ASYNC        = 0x2000;   // octal    020000\n+        enum O_NOATIME      = 0x40000;  // octal  01000000\n+        enum O_PATH         = 0x200000; // octal 010000000\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else version (RISCV_Any)\n     {\n@@ -233,6 +297,19 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x101000; // octal 04010000\n         enum O_DSYNC        = 0x1000;   // octal   010000\n         enum O_RSYNC        = O_SYNC;\n+\n+        enum O_DIRECTORY    = 0x010000;\n+        enum O_NOFOLLOW     = 0x020000;\n+        enum O_DIRECT       = 0x004000;\n+        version (D_LP64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x8000;\n+        enum O_TMPFILE      = 0x410000;\n+        enum O_ASYNC        = 0x2000;\n+        enum O_NOATIME      = 0x40000;\n+        enum O_PATH         = 0x200000;\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else version (SPARC_Any)\n     {\n@@ -247,6 +324,19 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x802000;\n         enum O_DSYNC        = 0x2000;\n         enum O_RSYNC        = O_SYNC;\n+\n+        enum O_DIRECTORY    = 0x10000;\n+        enum O_NOFOLLOW     = 0x20000;\n+        enum O_DIRECT       = 0x100000;\n+        version (D_LP64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x40000;\n+        enum O_TMPFILE      = 0x2010000;\n+        enum O_ASYNC        = 0x0040;\n+        enum O_NOATIME      = 0x200000;\n+        enum O_PATH         = 0x1000000;\n+        enum O_NDELAY       = (0x0004|O_NONBLOCK);\n     }\n     else version (IBMZ_Any)\n     {\n@@ -261,11 +351,33 @@ version (CRuntime_Glibc)\n         enum O_SYNC         = 0x101000; // octal 04010000\n         enum O_DSYNC        = 0x1000;   // octal   010000\n         enum O_RSYNC        = O_SYNC;\n+\n+        enum O_DIRECTORY    = 0x010000; // octal   0200000\n+        enum O_NOFOLLOW     = 0x020000; // octal   0400000\n+        enum O_DIRECT       = 0x004000; // octal    040000\n+        version (D_LP64)\n+            enum O_LARGEFILE = 0;\n+        else\n+            enum O_LARGEFILE = 0x08000; // octal   0100000\n+        enum O_TMPFILE      = 0x410000; // octal 020200000\n+        enum O_ASYNC        = 0x2000;   // octal    020000\n+        enum O_NOATIME      = 0x40000;  // octal  01000000\n+        enum O_PATH         = 0x200000; // octal 010000000\n+        enum O_NDELAY       = O_NONBLOCK;\n     }\n     else\n         static assert(0, \"unimplemented\");\n \n-    enum O_ACCMODE      = 0x3;\n+    version (CRuntime_Musl)\n+    {\n+        enum O_SEARCH   = O_PATH;\n+        enum O_EXEC     = O_PATH;\n+        enum O_ACCMODE  = (3|O_SEARCH);\n+    }\n+    else\n+    {\n+        enum O_ACCMODE  = 0x3;\n+    }\n     enum O_RDONLY       = 0x0;\n     enum O_WRONLY       = 0x1;\n     enum O_RDWR         = 0x2;\n@@ -279,22 +391,11 @@ version (CRuntime_Glibc)\n         pid_t   l_pid;\n     }\n \n-    static if ( __USE_FILE_OFFSET64 )\n-    {\n-        int   creat64(const scope char*, mode_t);\n-        alias creat64 creat;\n-\n-        int   open64(const scope char*, int, ...);\n-        alias open64 open;\n-    }\n-    else\n-    {\n-        int   creat(const scope char*, mode_t);\n-        int   open(const scope char*, int, ...);\n-    }\n-\n     enum AT_SYMLINK_NOFOLLOW = 0x100;\n     enum AT_FDCWD = -100;\n+    enum AT_REMOVEDIR = 0x200;\n+    enum AT_SYMLINK_FOLLOW = 0x400;\n+    enum AT_EACCESS = 0x200;\n }\n else version (Darwin)\n {\n@@ -339,9 +440,6 @@ else version (Darwin)\n         short   l_type;\n         short   l_whence;\n     }\n-\n-    int creat(const scope char*, mode_t);\n-    int open(const scope char*, int, ...);\n }\n else version (FreeBSD)\n {\n@@ -401,9 +499,6 @@ else version (FreeBSD)\n         short   l_whence;\n     }\n \n-    int creat(const scope char*, mode_t);\n-    int open(const scope char*, int, ...);\n-\n     enum AT_SYMLINK_NOFOLLOW = 0x200;\n     enum AT_FDCWD = -100;\n }\n@@ -466,9 +561,6 @@ else version (OpenBSD)\n         short   l_whence;\n     }\n \n-    int creat(const scope char*, mode_t);\n-    int open(const scope char*, int, ...);\n-\n     enum AT_FDCWD            = -100;\n \n     enum AT_EACCESS          = 0x01;\n@@ -524,10 +616,6 @@ else version (NetBSD)\n         short   l_type;\n         short   l_whence;\n     }\n-\n-\n-    int creat(const scope char*, mode_t);\n-    int open(const scope char*, int, ...);\n }\n else version (DragonFlyBSD)\n {\n@@ -612,11 +700,6 @@ else version (DragonFlyBSD)\n     }\n \n     alias oflock = flock;\n-\n-    int creat(const scope char*, mode_t);\n-    int open(const scope char*, int, ...);\n-    //int fcntl(int, int, ...);  /*defined below*/\n-    //int flock(int, int);\n }\n else version (Solaris)\n {\n@@ -700,7 +783,60 @@ else version (Solaris)\n             c_long[4]   l_pad;\n         }\n     }\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+int creat(const scope char*, mode_t);\n+int fcntl(int, int, ...);\n+int open(const scope char*, int, ...);\n+*/\n+version (CRuntime_Glibc)\n+{\n+    static if ( __USE_FILE_OFFSET64 )\n+    {\n+        int   creat64(const scope char*, mode_t);\n+        alias creat64 creat;\n \n+        int   open64(const scope char*, int, ...);\n+        alias open64 open;\n+    }\n+    else\n+    {\n+        int   creat(const scope char*, mode_t);\n+        int   open(const scope char*, int, ...);\n+    }\n+}\n+else version (Darwin)\n+{\n+    int creat(const scope char*, mode_t);\n+    int open(const scope char*, int, ...);\n+}\n+else version (FreeBSD)\n+{\n+    int creat(const scope char*, mode_t);\n+    int open(const scope char*, int, ...);\n+}\n+else version (OpenBSD)\n+{\n+    int creat(const scope char*, mode_t);\n+    int open(const scope char*, int, ...);\n+}\n+else version (NetBSD)\n+{\n+    int creat(const scope char*, mode_t);\n+    int open(const scope char*, int, ...);\n+}\n+else version (DragonFlyBSD)\n+{\n+    int creat(const scope char*, mode_t);\n+    int open(const scope char*, int, ...);\n+}\n+else version (Solaris)\n+{\n     version (D_LP64)\n     {\n         int creat(const scope char*, mode_t);\n@@ -731,323 +867,15 @@ else version (Solaris)\n }\n else version (CRuntime_Bionic)\n {\n-    // All these except for the two functions open and creat really come from\n-    // the linux kernel and can probably be merged.\n-    enum F_DUPFD        = 0;\n-    enum F_GETFD        = 1;\n-    enum F_SETFD        = 2;\n-    enum F_GETFL        = 3;\n-    enum F_SETFL        = 4;\n-    enum F_GETLK        = 5;\n-    enum F_SETLK        = 6;\n-    enum F_SETLKW       = 7;\n-    enum F_SETOWN       = 8;\n-    enum F_GETOWN       = 9;\n-\n-    enum FD_CLOEXEC     = 1;\n-\n-    enum F_RDLCK        = 0;\n-    enum F_WRLCK        = 1;\n-    enum F_UNLCK        = 2;\n-\n-    enum O_CREAT        = 0x40;     // octal     0100\n-    enum O_EXCL         = 0x80;     // octal     0200\n-    enum O_NOCTTY       = 0x100;    // octal     0400\n-    enum O_TRUNC        = 0x200;    // octal    01000\n-\n-    enum O_APPEND       = 0x400;    // octal    02000\n-    enum O_NONBLOCK     = 0x800;    // octal    04000\n-\n-    version (D_LP64)\n-    {\n-        enum O_SYNC     = 0x101000; // octal 04010000\n-    }\n-    else\n-    {\n-        enum O_SYNC     = 0x1000;   // octal   010000\n-    }\n-\n-    enum O_ACCMODE      = 0x3;\n-    enum O_RDONLY       = 0x0;\n-    enum O_WRONLY       = 0x1;\n-    enum O_RDWR         = 0x2;\n-\n-    struct flock\n-    {\n-        short   l_type;\n-        short   l_whence;\n-        off_t   l_start;\n-        off_t   l_len;\n-        pid_t   l_pid;\n-    }\n-\n     int   creat(const scope char*, mode_t);\n     int   open(const scope char*, int, ...);\n-\n-    enum AT_FDCWD = -100;\n }\n else version (CRuntime_Musl)\n {\n-    version (X86_64)\n-    {\n-        enum\n-        {\n-            O_DIRECTORY     = 0x010000, // octal   0200000\n-            O_NOFOLLOW      = 0x020000, // octal   0400000\n-            O_DIRECT        = 0x004000, // octal    040000\n-            O_LARGEFILE     =        0,\n-            O_TMPFILE       = 0x410000, // octal 020200000\n-\n-            F_GETLK        = 5,\n-            F_SETLK        = 6,\n-            F_SETLKW       = 7,\n-        }\n-    }\n-    // Note: Definitions for i386 are in arch/generic/bits/fcntl.h\n-    else version (X86)\n-    {\n-        enum\n-        {\n-            O_DIRECTORY     = 0x010000, // octal   0200000\n-            O_NOFOLLOW      = 0x020000, // octal   0400000\n-            O_DIRECT        = 0x004000, // octal    040000\n-            O_LARGEFILE     = 0x008000, // octal   0100000\n-            O_TMPFILE       = 0x410000, // octal 020200000\n-\n-            F_GETLK        = 12,\n-            F_SETLK        = 13,\n-            F_SETLKW       = 14,\n-        }\n-    }\n-    else version (ARM)\n-    {\n-        enum\n-        {\n-            O_DIRECTORY     = 0x004000, // octal    040000\n-            O_NOFOLLOW      = 0x008000, // octal   0100000\n-            O_DIRECT        = 0x010000, // octal   0200000\n-            O_LARGEFILE     = 0x020000, // octal   0400000\n-            O_TMPFILE       = 0x404000, // octal 020040000\n-\n-            F_GETLK        = 12,\n-            F_SETLK        = 13,\n-            F_SETLKW       = 14,\n-        }\n-    }\n-    else version (AArch64)\n-    {\n-        enum\n-        {\n-            O_DIRECTORY     = 0x004000, // octal    040000\n-            O_NOFOLLOW      = 0x008000, // octal   0100000\n-            O_DIRECT        = 0x010000, // octal   0200000\n-            O_LARGEFILE     = 0x020000, // octal   0400000\n-            O_TMPFILE       = 0x404000, // octal 020040000\n-\n-            F_GETLK        = 5,\n-            F_SETLK        = 6,\n-            F_SETLKW       = 7,\n-        }\n-    }\n-    else version (SystemZ)\n-    {\n-        enum\n-        {\n-            O_DIRECTORY     = 0x010000, // octal   0200000\n-            O_NOFOLLOW      = 0x020000, // octal   0400000\n-            O_DIRECT        = 0x004000, // octal    040000\n-            O_LARGEFILE     = 0x008000, // octal   0100000\n-            O_TMPFILE       = 0x410000, // octal 020200000\n-\n-            F_GETLK        = 5,\n-            F_SETLK        = 6,\n-            F_SETLKW       = 7,\n-        }\n-    }\n-    else version (PPC64)\n-    {\n-        enum\n-        {\n-            O_DIRECTORY     = 0x004000, // octal    040000\n-            O_NOFOLLOW      = 0x008000, // octal   0100000\n-            O_DIRECT        = 0x020000, // octal   0400000\n-            O_LARGEFILE     = 0x010000, // octal   0200000\n-            O_TMPFILE       = 0x410000, // octal 020200000\n-\n-            F_GETLK        = 5,\n-            F_SETLK        = 6,\n-            F_SETLKW       = 7,\n-        }\n-    }\n-    else\n-        static assert(0, \"Platform not supported\");\n-\n-    enum\n-    {\n-        O_CREAT         = 0x40,     // octal     0100\n-        O_EXCL          = 0x80,     // octal     0200\n-        O_NOCTTY        = 0x100,    // octal     0400\n-        O_TRUNC         = 0x200,    // octal    01000\n-\n-        O_APPEND        = 0x400,    // octal    02000\n-        O_NONBLOCK      = 0x800,    // octal    04000\n-        O_DSYNC         = 0x1000,   // octal   010000\n-        O_SYNC          = 0x101000, // octal 04010000\n-        O_RSYNC         = O_SYNC,\n-        O_CLOEXEC       = 0x80000,\n-\n-        O_ASYNC         = 0x2000,\n-        O_NOATIME       = 0x40000,\n-        O_PATH          = 0x200000,\n-        O_NDELAY        = O_NONBLOCK,\n-        O_SEARCH        = O_PATH,\n-        O_EXEC          = O_PATH,\n-\n-        O_ACCMODE       = (3|O_SEARCH),\n-        O_RDONLY        = 0,\n-        O_WRONLY        = 1,\n-        O_RDWR          = 2,\n-    }\n-    enum\n-    {\n-        F_DUPFD        = 0,\n-        F_GETFD        = 1,\n-        F_SETFD        = 2,\n-        F_GETFL        = 3,\n-        F_SETFL        = 4,\n-        // F_GETLK, F_SETLK, F_SETLKW are arch-specific\n-        F_SETOWN       = 8,\n-        F_GETOWN       = 9,\n-    }\n-    enum\n-    {\n-        F_RDLCK        = 0,\n-        F_WRLCK        = 1,\n-        F_UNLCK        = 2,\n-    }\n-    struct flock\n-    {\n-        short   l_type;\n-        short   l_whence;\n-        off_t   l_start;\n-        off_t   l_len;\n-        pid_t   l_pid;\n-    }\n-    enum FD_CLOEXEC     = 1;\n     int open(const scope char*, int, ...);\n-\n-    enum AT_FDCWD = -100;\n-    enum AT_SYMLINK_NOFOLLOW = 0x100;\n-    enum AT_REMOVEDIR = 0x200;\n-    enum AT_SYMLINK_FOLLOW = 0x400;\n-    enum AT_EACCESS = 0x200;\n }\n else version (CRuntime_UClibc)\n {\n-    enum F_DUPFD        = 0;\n-    enum F_GETFD        = 1;\n-    enum F_SETFD        = 2;\n-    enum F_GETFL        = 3;\n-    enum F_SETFL        = 4;\n-\n-    version (X86_64)\n-    {\n-        enum F_GETLK        = 5;\n-        enum F_SETLK        = 6;\n-        enum F_SETLKW       = 7;\n-    }\n-    else static if (__USE_FILE_OFFSET64)\n-    {\n-        enum F_GETLK        = 5;\n-        enum F_SETLK        = 6;\n-        enum F_SETLKW       = 7;\n-    }\n-    else\n-    {\n-        enum F_GETLK        = 12;\n-        enum F_SETLK        = 13;\n-        enum F_SETLKW       = 14;\n-    }\n-\n-    enum F_GETOWN       = 9;\n-    enum F_SETOWN       = 8;\n-\n-    enum FD_CLOEXEC     = 1;\n-\n-    enum F_RDLCK        = 0;\n-    enum F_UNLCK        = 2;\n-    enum F_WRLCK        = 1;\n-\n-    version (X86_Any)\n-    {\n-        enum O_CREAT        = 0x40;     // octal     0100\n-        enum O_EXCL         = 0x80;     // octal     0200\n-        enum O_NOCTTY       = 0x100;    // octal     0400\n-        enum O_TRUNC        = 0x200;    // octal    01000\n-\n-        enum O_APPEND       = 0x400;    // octal    02000\n-        enum O_NONBLOCK     = 0x800;    // octal    04000\n-        enum O_CLOEXEC      = 0x80000;  // octal    02000000\n-        enum O_SYNC         = 0x1000;   // octal    010000\n-        enum O_NDELAY       = O_NONBLOCK;\n-        enum O_FSYNC        = O_SYNC;\n-        enum O_ASYNC        = 0x2000;   // octal    020000\n-    }\n-    else version (MIPS_Any)\n-    {\n-        enum O_CREAT        = 0x0100;\n-        enum O_EXCL         = 0x0400;\n-        enum O_NOCTTY       = 0x0800;\n-        enum O_TRUNC        = 0x0200;\n-\n-        enum O_APPEND       = 0x0008;\n-        enum O_SYNC         = 0x0010;\n-        enum O_NONBLOCK     = 0x0080;\n-        enum O_CLOEXEC      = 0x80000;  // octal    02000000\n-        enum O_NDELAY       = O_NONBLOCK;\n-        enum O_FSYNC        = O_SYNC;\n-        enum O_ASYNC        = 0x1000;\n-    }\n-    else version (ARM_Any)\n-    {\n-        enum O_CREAT        = 0x40;     // octal     0100\n-        enum O_EXCL         = 0x80;     // octal     0200\n-        enum O_NOCTTY       = 0x100;    // octal     0400\n-        enum O_TRUNC        = 0x200;    // octal    01000\n-\n-        enum O_APPEND       = 0x400;    // octal    02000\n-        enum O_NONBLOCK     = 0x800;    // octal    04000\n-        enum O_CLOEXEC      = 0x80000;  // octal    02000000\n-        enum O_SYNC         = 0x1000;   // octal    010000\n-        enum O_NDELAY       = O_NONBLOCK;\n-        enum O_FSYNC        = O_SYNC;\n-        enum O_ASYNC        = 0x2000;     // octal 020000\n-    }\n-    else\n-        static assert(0, \"unimplemented\");\n-\n-    enum O_ACCMODE      = 0x3;\n-    enum O_RDONLY       = 0x0;\n-    enum O_WRONLY       = 0x1;\n-    enum O_RDWR         = 0x2;\n-\n-    struct flock\n-    {\n-        short   l_type;\n-        short   l_whence;\n-        static if (__USE_FILE_OFFSET64)\n-        {\n-            off64_t   l_start;\n-            off64_t   l_len;\n-        }\n-        else\n-        {\n-            off_t   l_start;\n-            off_t   l_len;\n-        }\n-        pid_t   l_pid;\n-    }\n-\n     static if ( __USE_FILE_OFFSET64 )\n     {\n         int   creat64(const scope char*, mode_t);\n@@ -1061,9 +889,6 @@ else version (CRuntime_UClibc)\n         int   creat(const scope char*, mode_t);\n         int   open(const scope char*, int, ...);\n     }\n-\n-    enum AT_SYMLINK_NOFOLLOW    = 0x100;\n-    enum AT_FDCWD               = -100;\n }\n else\n {"}, {"sha": "7c2d5705e4fede875ca68cfdd50aba3ca68dc239", "filename": "libphobos/libdruntime/core/sys/posix/poll.d", "status": "modified", "additions": 141, "deletions": 161, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fpoll.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fpoll.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fpoll.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -44,17 +44,6 @@ struct pollfd\n \n nfds_t\n \n-POLLIN\n-POLLRDNORM\n-POLLRDBAND\n-POLLPRI\n-POLLOUT\n-POLLWRNORM\n-POLLWRBAND\n-POLLERR\n-POLLHUP\n-POLLNVAL\n-\n int poll(pollfd[], nfds_t, int);\n */\n \n@@ -69,6 +58,145 @@ version (CRuntime_Glibc)\n \n     alias c_ulong nfds_t;\n \n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (Darwin)\n+{\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    alias uint nfds_t;\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (FreeBSD)\n+{\n+    alias uint nfds_t;\n+\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (NetBSD)\n+{\n+    alias uint nfds_t;\n+\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (OpenBSD)\n+{\n+    alias uint nfds_t;\n+\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (DragonFlyBSD)\n+{\n+    alias uint nfds_t;\n+\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (Solaris)\n+{\n+    alias c_ulong nfds_t;\n+\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else version (CRuntime_Bionic)\n+{\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    alias uint nfds_t;\n+\n+    int poll(pollfd*, nfds_t, c_long);\n+}\n+else version (CRuntime_Musl)\n+{\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    alias uint nfds_t;\n+\n+    int poll(pollfd*, nfds_t, c_long);\n+}\n+else version (CRuntime_UClibc)\n+{\n+    struct pollfd\n+    {\n+        int     fd;\n+        short   events;\n+        short   revents;\n+    }\n+\n+    alias c_ulong nfds_t;\n+\n+    int poll(pollfd*, nfds_t, int);\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+POLLIN\n+POLLRDNORM\n+POLLRDBAND\n+POLLPRI\n+POLLOUT\n+POLLWRNORM\n+POLLWRBAND\n+POLLERR\n+POLLHUP\n+POLLNVAL\n+*/\n+\n+version (linux)\n+{\n     enum\n     {\n         POLLIN      = 0x001,\n@@ -82,20 +210,9 @@ version (CRuntime_Glibc)\n         POLLHUP     = 0x010,\n         POLLNVAL    = 0x020,\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n else version (Darwin)\n {\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n-    alias uint nfds_t;\n-\n     enum\n     {\n         POLLIN      = 0x0001,\n@@ -116,20 +233,9 @@ else version (Darwin)\n         POLLSTANDARD = (POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\n                         POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n else version (FreeBSD)\n {\n-    alias uint nfds_t;\n-\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n     enum\n     {\n         POLLIN      = 0x0001,\n@@ -150,20 +256,9 @@ else version (FreeBSD)\n         POLLSTANDARD = (POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\n         POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n else version (NetBSD)\n {\n-    alias uint nfds_t;\n-\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n     enum\n     {\n         POLLIN      = 0x0001,\n@@ -184,20 +279,9 @@ else version (NetBSD)\n         POLLSTANDARD = (POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\n         POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n else version (OpenBSD)\n {\n-    alias uint nfds_t;\n-\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n     enum\n     {\n         POLLIN      = 0x0001,\n@@ -215,20 +299,9 @@ else version (OpenBSD)\n         POLLSTANDARD = (POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\n         POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n else version (DragonFlyBSD)\n {\n-    alias uint nfds_t;\n-\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n     enum\n     {\n         POLLIN      = 0x0001,\n@@ -249,20 +322,9 @@ else version (DragonFlyBSD)\n         POLLSTANDARD = (POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\n         POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n else version (Solaris)\n {\n-    alias c_ulong nfds_t;\n-\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n     enum\n     {\n         POLLIN      = 0x0001,\n@@ -276,90 +338,8 @@ else version (Solaris)\n         POLLHUP     = 0x0010,\n         POLLNVAL    = 0x0020,\n     }\n-\n-    int poll(pollfd*, nfds_t, int);\n }\n-else version (CRuntime_Bionic)\n+else\n {\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n-    alias uint nfds_t;\n-\n-    enum\n-    {\n-        POLLIN      = 0x001,\n-        POLLRDNORM  = 0x040,\n-        POLLRDBAND  = 0x080,\n-        POLLPRI     = 0x002,\n-        POLLOUT     = 0x004,\n-        POLLWRNORM  = 0x100,\n-        POLLWRBAND  = 0x200,\n-        POLLERR     = 0x008,\n-        POLLHUP     = 0x010,\n-        POLLNVAL    = 0x020,\n-    }\n-\n-    int poll(pollfd*, nfds_t, c_long);\n-}\n-else version (CRuntime_Musl)\n-{\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n-    alias uint nfds_t;\n-\n-    enum\n-    {\n-        POLLIN      = 0x001,\n-        POLLPRI     = 0x002,\n-        POLLOUT     = 0x004,\n-        POLLERR     = 0x008,\n-        POLLHUP     = 0x010,\n-        POLLNVAL    = 0x020,\n-        POLLRDNORM  = 0x040,\n-        POLLRDBAND  = 0x080,\n-        POLLWRNORM  = 0x100,\n-        POLLWRBAND  = 0x200,\n-    }\n-\n-    int poll(pollfd*, nfds_t, c_long);\n-}\n-else version (CRuntime_UClibc)\n-{\n-    struct pollfd\n-    {\n-        int     fd;\n-        short   events;\n-        short   revents;\n-    }\n-\n-    alias c_ulong nfds_t;\n-\n-    enum\n-    {\n-        POLLIN      = 0x001,\n-        POLLRDNORM  = 0x040,\n-        POLLRDBAND  = 0x080,\n-        POLLPRI     = 0x002,\n-        POLLOUT     = 0x004,\n-        POLLWRNORM  = 0x100,\n-        POLLWRBAND  = 0x200,\n-        POLLMSG     = 0x400,\n-        POLLREMOVE  = 0x1000,\n-        POLLRDHUP   = 0x2000,\n-        POLLERR     = 0x008,\n-        POLLHUP     = 0x010,\n-        POLLNVAL    = 0x020,\n-    }\n-\n-    int poll(pollfd*, nfds_t, int);\n+    static assert(false, \"Unsupported platform\");\n }"}, {"sha": "35463d4fb6c8490d2955ed1caa7220ccd6f06f7d", "filename": "libphobos/libdruntime/core/sys/posix/sched.d", "status": "modified", "additions": 19, "deletions": 42, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsched.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsched.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsched.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -58,27 +58,33 @@ int sched_setparam(pid_t, const scope sched_param*);\n int sched_setscheduler(pid_t, int, const scope sched_param*);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n-    struct sched_param\n+    version (CRuntime_Musl)\n     {\n-        int sched_priority;\n+        struct sched_param\n+        {\n+            int sched_priority;\n+            int __reserved1;\n+            timespec[2] __reserved2;\n+            int __reserved3;\n+        }\n+    }\n+    else\n+    {\n+        struct sched_param\n+        {\n+            int sched_priority;\n+        }\n     }\n \n     enum SCHED_OTHER    = 0;\n     enum SCHED_FIFO     = 1;\n     enum SCHED_RR       = 2;\n     //SCHED_SPORADIC (SS|TSP)\n-}\n-else version (CRuntime_Musl)\n-{\n-    struct sched_param {\n-        int sched_priority;\n-        int sched_ss_low_priority;\n-        timespec sched_ss_repl_period;\n-        timespec sched_ss_init_budget;\n-        int sched_ss_max_repl;\n-    }\n+    enum SCHED_BATCH    = 3;\n+    enum SCHED_IDLE     = 5;\n+    enum SCHED_RESET_ON_FORK = 0x40000000;\n }\n else version (Darwin)\n {\n@@ -87,8 +93,6 @@ else version (Darwin)\n     enum SCHED_RR       = 2;\n     //SCHED_SPORADIC (SS|TSP)\n \n-    private enum __SCHED_PARAM_SIZE__ = 4;\n-\n     struct sched_param\n     {\n         int                             sched_priority;\n@@ -156,33 +160,6 @@ else version (Solaris)\n     enum SCHED_FX = 6;\n     enum _SCHED_NEXT = 7;\n }\n-else version (CRuntime_Bionic)\n-{\n-    struct sched_param\n-    {\n-        int sched_priority;\n-    }\n-\n-    enum SCHED_NORMAL   = 0;\n-    enum SCHED_OTHER    = 0;\n-    enum SCHED_FIFO     = 1;\n-    enum SCHED_RR       = 2;\n-}\n-else version (CRuntime_UClibc)\n-{\n-    struct sched_param\n-    {\n-        int sched_priority;\n-    }\n-\n-    enum SCHED_OTHER    = 0;\n-    enum SCHED_FIFO     = 1;\n-    enum SCHED_RR       = 2;\n-    enum SCHED_BATCH    = 3;\n-    enum SCHED_IDLE     = 5;\n-\n-    enum SCHED_RESET_ON_FORK    = 0x40000000;\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");"}, {"sha": "68aee980ef3b9113ad9f9e991b6dee43041ed085", "filename": "libphobos/libdruntime/core/sys/posix/signal.d", "status": "modified", "additions": 668, "deletions": 1335, "changes": 2003, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -151,13 +151,15 @@ version (Solaris)\n         return sig;\n     }\n }\n-else version (FreeBSD) {\n+else version (FreeBSD)\n+{\n     // Note: it appears that FreeBSD (prior to 7) and OSX do not support realtime signals\n     // https://github.com/freebsd/freebsd/blob/e79c62ff68fc74d88cb6f479859f6fae9baa5101/sys/sys/signal.h#L117\n     enum SIGRTMIN = 65;\n     enum SIGRTMAX = 126;\n }\n-else version (DragonFlyBSD) {\n+else version (DragonFlyBSD)\n+{\n     enum SIGRTMIN = 35;\n     enum SIGRTMAX = 126;\n }\n@@ -540,9 +542,54 @@ else\n     static assert(false, \"Unsupported platform\");\n }\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n-    version (SystemZ)\n+    version (CRuntime_Musl)\n+    {\n+        struct sigaction_t\n+        {\n+            union\n+            {\n+                sigfn_t     sa_handler;\n+                sigactfn_t  sa_sigaction;\n+            }\n+            sigset_t        sa_mask;\n+            int             sa_flags;\n+            void function() sa_restorer;\n+        }\n+    }\n+    else version (CRuntime_Bionic)\n+    {\n+        version (D_LP64)\n+        {\n+            struct sigaction_t\n+            {\n+                int            sa_flags;\n+                union\n+                {\n+                    sigfn_t    sa_handler;\n+                    sigactfn_t sa_sigaction;\n+                }\n+                sigset_t        sa_mask;\n+                void function() sa_restorer;\n+        }\n+        }\n+        else\n+        {\n+            struct sigaction_t\n+            {\n+                union\n+                {\n+                    sigfn_t    sa_handler;\n+                    sigactfn_t sa_sigaction;\n+                }\n+                sigset_t        sa_mask;\n+                int             sa_flags;\n+                void function() sa_restorer;\n+            }\n+        }\n+    }\n+    else version (SystemZ)\n     {\n         struct sigaction_t\n         {\n@@ -558,15 +605,22 @@ version (CRuntime_Glibc)\n             {\n                 sigfn_t     sa_handler;\n             }\n-            int             __glibc_reserved0;\n-            int             sa_flags;\n+            version (CRuntime_Glibc)\n+            {\n+                int         __glibc_reserved0;\n+                int         sa_flags;\n+            }\n+            else\n+            {\n+                c_ulong     sa_flags;\n+            }\n \n             void function() sa_restorer;\n \n             sigset_t        sa_mask;\n         }\n     }\n-    else\n+    else version (HPPA_Any)\n     {\n         struct sigaction_t\n         {\n@@ -582,33 +636,100 @@ version (CRuntime_Glibc)\n             {\n                 sigfn_t     sa_handler;\n             }\n+            version (CRuntime_Glibc)\n+            {\n+                version (D_LP64)\n+                    int     __glibc_reserved0;\n+                int         sa_flags;\n+            }\n+            else\n+            {\n+                c_ulong     sa_flags;\n+            }\n             sigset_t        sa_mask;\n-            int             sa_flags;\n+        }\n+    }\n+    else version (MIPS_Any)\n+    {\n+        struct sigaction_t\n+        {\n+            int sa_flags;\n \n+            static if ( true /* __USE_POSIX199309 */ )\n+            {\n+                union\n+                {\n+                    sigfn_t     sa_handler;\n+                    sigactfn_t  sa_sigaction;\n+                }\n+            }\n+            else\n+            {\n+                sigfn_t     sa_handler;\n+            }\n+            sigset_t        sa_mask;\n             void function() sa_restorer;\n+\n+            version (CRuntime_Glibc)\n+            {\n+                static if ((void*).sizeof < 8)\n+                    int[1]  sa_resv;\n+            }\n         }\n     }\n-}\n-else version (CRuntime_Musl)\n-{\n-    struct sigaction_t\n+    else version (SPARC_Any)\n     {\n-        static if ( true /* __USE_POSIX199309 */ )\n+        struct sigaction_t\n         {\n-            union\n+            static if ( true /* __USE_POSIX199309 */ )\n+            {\n+                union\n+                {\n+                    sigfn_t     sa_handler;\n+                    sigactfn_t  sa_sigaction;\n+                }\n+            }\n+            else\n             {\n                 sigfn_t     sa_handler;\n-                sigactfn_t  sa_sigaction;\n+            }\n+            version (CRuntime_Glibc)\n+            {\n+                sigset_t    sa_mask;\n+                version (D_LP64)\n+                    int     __glibc_reserved0;\n+                int         sa_flags;\n+                void function() sa_restorer;\n+            }\n+            else\n+            {\n+                c_ulong     sa_flags;\n+                void function() sa_restorer;\n+                sigset_t    sa_mask;\n             }\n         }\n-        else\n+    }\n+    else\n+    {\n+        struct sigaction_t\n         {\n-            sigfn_t     sa_handler;\n-        }\n-        sigset_t        sa_mask;\n-        int             sa_flags;\n+            static if ( true /* __USE_POSIX199309 */ )\n+            {\n+                union\n+                {\n+                    sigfn_t     sa_handler;\n+                    sigactfn_t  sa_sigaction;\n+                }\n+            }\n+            else\n+            {\n+                sigfn_t     sa_handler;\n+            }\n+            sigset_t        sa_mask;\n+            int             sa_flags;\n \n-        void function() sa_restorer;\n+            void function() sa_restorer;\n+        }\n     }\n }\n else version (FreeBSD)\n@@ -683,91 +804,6 @@ else version (Solaris)\n             int[2] sa_resv;\n     }\n }\n-else version (CRuntime_UClibc)\n-{\n-    version (ARM)           version = sigaction_common;\n-    else version (X86_64)   version = sigaction_common;\n-\n-    version (sigaction_common)\n-    {\n-        struct sigaction_t\n-        {\n-            static if ( true /* __USE_POSIX199309 */ )\n-            {\n-                union\n-                {\n-                    sigfn_t     sa_handler;\n-                    sigactfn_t  sa_sigaction;\n-                }\n-            }\n-            else\n-            {\n-                sigfn_t     sa_handler;\n-            }\n-            c_ulong     sa_flags;\n-            void function() sa_restorer;\n-            sigset_t    sa_mask;\n-        }\n-    }\n-    else version (MIPS32)\n-    {\n-        struct sigaction_t\n-        {\n-            uint     sa_flags;\n-            static if ( true /* __USE_POSIX199309 */ )\n-            {\n-                union\n-                {\n-                    sigfn_t     sa_handler;\n-                    sigactfn_t  sa_sigaction;\n-                }\n-            }\n-            else\n-            {\n-                sigfn_t     sa_handler;\n-            }\n-            sigset_t    sa_mask;\n-            void function() sa_restorer;\n-        }\n-    }\n-    else\n-    {\n-        static assert(false, \"Architecture not supported.\");\n-    }\n-}\n-else version (CRuntime_Bionic)\n-{\n-    version (D_LP64)\n-    {\n-        struct sigaction_t\n-        {\n-            int            sa_flags;\n-            union\n-            {\n-                sigfn_t    sa_handler;\n-                sigactfn_t sa_sigaction;\n-            }\n-\n-            sigset_t        sa_mask;\n-            void function() sa_restorer;\n-        }\n-    }\n-    else\n-    {\n-        struct sigaction_t\n-        {\n-            union\n-            {\n-                sigfn_t    sa_handler;\n-                sigactfn_t sa_sigaction;\n-            }\n-\n-            sigset_t        sa_mask;\n-            int             sa_flags;\n-            void function() sa_restorer;\n-        }\n-    }\n-}\n else version (Darwin)\n {\n     struct sigaction_t\n@@ -839,26 +875,14 @@ SI_QUEUE\n SI_TIMER\n SI_ASYNCIO\n SI_MESGQ\n-\n-int kill(pid_t, int);\n-int sigaction(int, const scope sigaction_t*, sigaction_t*);\n-int sigaddset(sigset_t*, int);\n-int sigdelset(sigset_t*, int);\n-int sigemptyset(sigset_t*);\n-int sigfillset(sigset_t*);\n-int sigismember(const scope sigset_t*, int);\n-int sigpending(sigset_t*);\n-int sigprocmask(int, const scope sigset_t*, sigset_t*);\n-int sigsuspend(const scope sigset_t*);\n-int sigwait(const scope sigset_t*, int*);\n */\n \n nothrow @nogc\n {\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n-    enum SIG_HOLD = cast(sigfn_t2) 1;\n+    enum SIG_HOLD = cast(sigfn_t2) 2;\n \n     private enum _SIGSET_NWORDS = 1024 / (8 * c_ulong.sizeof);\n \n@@ -867,20 +891,26 @@ version (CRuntime_Glibc)\n         c_ulong[_SIGSET_NWORDS] __val;\n     }\n \n-    // pid_t  (defined in core.sys.types)\n-\n-    //SIGABRT (defined in core.stdc.signal)\n-    //SIGFPE  (defined in core.stdc.signal)\n-    //SIGILL  (defined in core.stdc.signal)\n-    //SIGINT  (defined in core.stdc.signal)\n-    //SIGSEGV (defined in core.stdc.signal)\n-    //SIGTERM (defined in core.stdc.signal)\n-\n     enum SA_NOCLDSTOP   = 1; // (CX|XSI)\n \n-    enum SIG_BLOCK      = 0;\n-    enum SIG_UNBLOCK    = 1;\n-    enum SIG_SETMASK    = 2;\n+    version (MIPS_Any)\n+    {\n+        enum SIG_BLOCK      = 1;\n+        enum SIG_UNBLOCK    = 2;\n+        enum SIG_SETMASK    = 3;\n+    }\n+    else version (SPARC_Any)\n+    {\n+        enum SIG_BLOCK      = 1;\n+        enum SIG_UNBLOCK    = 2;\n+        enum SIG_SETMASK    = 4;\n+    }\n+    else\n+    {\n+        enum SIG_BLOCK      = 0;\n+        enum SIG_UNBLOCK    = 1;\n+        enum SIG_SETMASK    = 2;\n+    }\n \n     private enum __SI_MAX_SIZE = 128;\n \n@@ -895,10 +925,17 @@ version (CRuntime_Glibc)\n \n     struct siginfo_t\n     {\n-        int si_signo;       // Signal number\n-        int si_errno;       // If non-zero, an errno value associated with\n-                            // this signal, as defined in <errno.h>\n-        int si_code;        // Signal code\n+        int si_signo;\n+        version (MIPS_Any)  // __SI_SWAP_ERRNO_CODE\n+        {\n+            int si_code;\n+            int si_errno;\n+        }\n+        else\n+        {\n+            int si_errno;\n+            int si_code;\n+        }\n \n         union _sifields_t\n         {\n@@ -907,46 +944,45 @@ version (CRuntime_Glibc)\n             // kill()\n             struct _kill_t\n             {\n-                pid_t si_pid; // Sending process ID\n-                uid_t si_uid; // Real user ID of sending process\n+                pid_t si_pid;\n+                uid_t si_uid;\n             } _kill_t _kill;\n-\n             // POSIX.1b timers.\n             struct _timer_t\n             {\n-                int    si_tid;     // Timer ID\n-                int    si_overrun; // Overrun count\n-                sigval si_sigval;  // Signal value\n+                int    si_tid;\n+                int    si_overrun;\n+                sigval si_sigval;\n             } _timer_t _timer;\n \n             // POSIX.1b signals\n             struct _rt_t\n             {\n-                pid_t  si_pid;    // Sending process ID\n-                uid_t  si_uid;    // Real user ID of sending process\n-                sigval si_sigval; // Signal value\n+                pid_t  si_pid;\n+                uid_t  si_uid;\n+                sigval si_sigval;\n             } _rt_t _rt;\n \n             // SIGCHLD\n             struct _sigchild_t\n             {\n-                pid_t   si_pid;    // Which child\n-                uid_t   si_uid;    // Real user ID of sending process\n-                int     si_status; // Exit value or signal\n+                pid_t   si_pid;\n+                uid_t   si_uid;\n+                int     si_status;\n                 clock_t si_utime;\n                 clock_t si_stime;\n             } _sigchild_t _sigchld;\n \n             // SIGILL, SIGFPE, SIGSEGV, SIGBUS\n             struct _sigfault_t\n             {\n-                void*     si_addr;  // Faulting insn/memory ref\n+                void*     si_addr;\n             } _sigfault_t _sigfault;\n \n             // SIGPOLL\n             struct _sigpoll_t\n             {\n-                c_long   si_band;   // Band event for SIGPOLL\n+                c_long   si_band;\n                 int      si_fd;\n             } _sigpoll_t _sigpoll;\n         } _sifields_t _sifields;\n@@ -972,32 +1008,12 @@ version (CRuntime_Glibc)\n         SI_USER,\n         SI_KERNEL  = 0x80\n     }\n-\n-    int kill(pid_t, int);\n-    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n-    int sigaddset(sigset_t*, int);\n-    int sigdelset(sigset_t*, int);\n-    int sigemptyset(sigset_t*);\n-    int sigfillset(sigset_t*);\n-    int sigismember(const scope sigset_t*, int);\n-    int sigpending(sigset_t*);\n-    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n-    int sigsuspend(const scope sigset_t*);\n-    int sigwait(const scope sigset_t*, int*);\n }\n else version (Darwin)\n {\n     enum SIG_HOLD = cast(sigfn_t2) 5;\n \n     alias uint sigset_t;\n-    // pid_t  (defined in core.sys.types)\n-\n-    //SIGABRT (defined in core.stdc.signal)\n-    //SIGFPE  (defined in core.stdc.signal)\n-    //SIGILL  (defined in core.stdc.signal)\n-    //SIGINT  (defined in core.stdc.signal)\n-    //SIGSEGV (defined in core.stdc.signal)\n-    //SIGTERM (defined in core.stdc.signal)\n \n     enum SA_NOCLDSTOP = 8; // (CX|XSI)\n \n@@ -1024,18 +1040,6 @@ else version (Darwin)\n     enum SI_TIMER   = 0x10003;\n     enum SI_ASYNCIO = 0x10004;\n     enum SI_MESGQ   = 0x10005;\n-\n-    int kill(pid_t, int);\n-    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n-    int sigaddset(sigset_t*, int);\n-    int sigdelset(sigset_t*, int);\n-    int sigemptyset(sigset_t*);\n-    int sigfillset(sigset_t*);\n-    int sigismember(const scope sigset_t*, int);\n-    int sigpending(sigset_t*);\n-    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n-    int sigsuspend(const scope sigset_t*);\n-    int sigwait(const scope sigset_t*, int*);\n }\n else version (FreeBSD)\n {\n@@ -1102,18 +1106,6 @@ else version (FreeBSD)\n     enum SI_TIMER   = 0x10003;\n     enum SI_ASYNCIO = 0x10004;\n     enum SI_MESGQ   = 0x10005;\n-\n-    int kill(pid_t, int);\n-    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n-    int sigaddset(sigset_t*, int);\n-    int sigdelset(sigset_t*, int);\n-    int sigemptyset(sigset_t *);\n-    int sigfillset(sigset_t *);\n-    int sigismember(const scope sigset_t*, int);\n-    int sigpending(sigset_t *);\n-    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n-    int sigsuspend(const scope sigset_t*);\n-    int sigwait(const scope sigset_t*, int*);\n }\n else version (NetBSD)\n {\n@@ -1188,28 +1180,6 @@ else version (NetBSD)\n     enum SI_TIMER   = -2;\n     enum SI_ASYNCIO = -3;\n     enum SI_MESGQ   = -4;\n-\n-    int kill(pid_t, int);\n-    int __sigaction14(int, const scope sigaction_t*, sigaction_t*);\n-    int __sigaddset14(sigset_t*, int);\n-    int __sigdelset14(sigset_t*, int);\n-    int __sigemptyset14(sigset_t *);\n-    int __sigfillset14(sigset_t *);\n-    int __sigismember14(const scope sigset_t*, int);\n-    int __sigpending14(sigset_t *);\n-    int __sigprocmask14(int, const scope sigset_t*, sigset_t*);\n-    int __sigsuspend14(const scope sigset_t*);\n-    int sigwait(const scope sigset_t*, int*);\n-\n-    alias __sigaction14 sigaction;\n-    alias __sigaddset14 sigaddset;\n-    alias __sigdelset14 sigdelset;\n-    alias __sigemptyset14 sigemptyset;\n-    alias __sigfillset14 sigfillset;\n-    alias __sigismember14 sigismember;\n-    alias __sigpending14 sigpending;\n-    alias __sigprocmask14 sigprocmask;\n-    alias __sigsuspend14 sigsuspend;\n }\n else version (OpenBSD)\n {\n@@ -1274,18 +1244,6 @@ else version (OpenBSD)\n     enum SI_LWP    = -1;\n     enum SI_QUEUE  = -2;\n     enum SI_TIMER  = -3;\n-\n-    int kill(pid_t, int);\n-    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n-    int sigaddset(sigset_t*, int);\n-    int sigdelset(sigset_t*, int);\n-    int sigemptyset(sigset_t *);\n-    int sigfillset(sigset_t *);\n-    int sigismember(const scope sigset_t*, int);\n-    int sigpending(sigset_t *);\n-    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n-    int sigsuspend(const scope sigset_t*);\n-    int sigwait(const scope sigset_t*, int*);\n }\n else version (DragonFlyBSD)\n {\n@@ -1323,18 +1281,6 @@ else version (DragonFlyBSD)\n     enum SI_TIMER     = -2;\n     enum SI_ASYNCIO   = -3;\n     enum SI_MESGQ     = -4;\n-\n-    int kill(pid_t, int);\n-    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n-    int sigaddset(sigset_t*, int);\n-    int sigdelset(sigset_t*, int);\n-    int sigemptyset(sigset_t *);\n-    int sigfillset(sigset_t *);\n-    int sigismember(const scope sigset_t*, int);\n-    int sigpending(sigset_t *);\n-    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n-    int sigsuspend(const scope sigset_t*);\n-    int sigwait(const scope sigset_t*, int*);\n }\n else version (Solaris)\n {\n@@ -1446,9 +1392,122 @@ else version (Solaris)\n     enum SI_TIMER   = -3;\n     enum SI_ASYNCIO = -4;\n     enum SI_MESGQ   = -5;\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n \n-    enum SIGIO = SIGPOLL;\n+/*\n+int kill(pid_t, int);\n+int sigaction(int, const scope sigaction_t*, sigaction_t*);\n+int sigaddset(sigset_t*, int);\n+int sigdelset(sigset_t*, int);\n+int sigemptyset(sigset_t*);\n+int sigfillset(sigset_t*);\n+int sigismember(const scope sigset_t*, int);\n+int sigpending(sigset_t*);\n+int sigprocmask(int, const scope sigset_t*, sigset_t*);\n+int sigsuspend(const scope sigset_t*);\n+int sigwait(const scope sigset_t*, int*);\n+*/\n+\n+version (CRuntime_Glibc)\n+{\n+    int kill(pid_t, int);\n+    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n+    int sigaddset(sigset_t*, int);\n+    int sigdelset(sigset_t*, int);\n+    int sigemptyset(sigset_t*);\n+    int sigfillset(sigset_t*);\n+    int sigismember(const scope sigset_t*, int);\n+    int sigpending(sigset_t*);\n+    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n+    int sigsuspend(const scope sigset_t*);\n+    int sigwait(const scope sigset_t*, int*);\n+}\n+else version (Darwin)\n+{\n+    int kill(pid_t, int);\n+    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n+    int sigaddset(sigset_t*, int);\n+    int sigdelset(sigset_t*, int);\n+    int sigemptyset(sigset_t*);\n+    int sigfillset(sigset_t*);\n+    int sigismember(const scope sigset_t*, int);\n+    int sigpending(sigset_t*);\n+    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n+    int sigsuspend(const scope sigset_t*);\n+    int sigwait(const scope sigset_t*, int*);\n+}\n+else version (FreeBSD)\n+{\n+    int kill(pid_t, int);\n+    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n+    int sigaddset(sigset_t*, int);\n+    int sigdelset(sigset_t*, int);\n+    int sigemptyset(sigset_t *);\n+    int sigfillset(sigset_t *);\n+    int sigismember(const scope sigset_t*, int);\n+    int sigpending(sigset_t *);\n+    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n+    int sigsuspend(const scope sigset_t*);\n+    int sigwait(const scope sigset_t*, int*);\n+}\n+else version (NetBSD)\n+{\n+    int kill(pid_t, int);\n+    int __sigaction14(int, const scope sigaction_t*, sigaction_t*);\n+    int __sigaddset14(sigset_t*, int);\n+    int __sigdelset14(sigset_t*, int);\n+    int __sigemptyset14(sigset_t *);\n+    int __sigfillset14(sigset_t *);\n+    int __sigismember14(const scope sigset_t*, int);\n+    int __sigpending14(sigset_t *);\n+    int __sigprocmask14(int, const scope sigset_t*, sigset_t*);\n+    int __sigsuspend14(const scope sigset_t*);\n+    int sigwait(const scope sigset_t*, int*);\n \n+    alias __sigaction14 sigaction;\n+    alias __sigaddset14 sigaddset;\n+    alias __sigdelset14 sigdelset;\n+    alias __sigemptyset14 sigemptyset;\n+    alias __sigfillset14 sigfillset;\n+    alias __sigismember14 sigismember;\n+    alias __sigpending14 sigpending;\n+    alias __sigprocmask14 sigprocmask;\n+    alias __sigsuspend14 sigsuspend;\n+}\n+else version (OpenBSD)\n+{\n+    int kill(pid_t, int);\n+    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n+    int sigaddset(sigset_t*, int);\n+    int sigdelset(sigset_t*, int);\n+    int sigemptyset(sigset_t *);\n+    int sigfillset(sigset_t *);\n+    int sigismember(const scope sigset_t*, int);\n+    int sigpending(sigset_t *);\n+    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n+    int sigsuspend(const scope sigset_t*);\n+    int sigwait(const scope sigset_t*, int*);\n+}\n+else version (DragonFlyBSD)\n+{\n+    int kill(pid_t, int);\n+    int sigaction(int, const scope sigaction_t*, sigaction_t*);\n+    int sigaddset(sigset_t*, int);\n+    int sigdelset(sigset_t*, int);\n+    int sigemptyset(sigset_t *);\n+    int sigfillset(sigset_t *);\n+    int sigismember(const scope sigset_t*, int);\n+    int sigpending(sigset_t *);\n+    int sigprocmask(int, const scope sigset_t*, sigset_t*);\n+    int sigsuspend(const scope sigset_t*);\n+    int sigwait(const scope sigset_t*, int*);\n+}\n+else version (Solaris)\n+{\n     int kill(pid_t, int);\n     int sigaction(int, const scope sigaction_t*, sigaction_t*);\n     int sigaddset(sigset_t*, int);\n@@ -1467,101 +1526,15 @@ else version (CRuntime_Bionic)\n     import core.stdc.string : memset;\n \n     version (X86)\n-    {\n-        alias uint sigset_t;\n         enum int LONG_BIT = 32;\n-    }\n     else version (ARM)\n-    {\n-        alias uint sigset_t;\n         enum int LONG_BIT = 32;\n-    }\n     else version (AArch64)\n-    {\n-        struct sigset_t { ulong[1] sig; }\n         enum int LONG_BIT = 64;\n-    }\n     else version (X86_64)\n-    {\n-        alias ulong sigset_t;\n         enum int LONG_BIT = 64;\n-    }\n     else\n-    {\n         static assert(false, \"Architecture not supported.\");\n-    }\n-\n-    enum SIG_BLOCK   = 0;\n-    enum SIG_UNBLOCK = 1;\n-    enum SIG_SETMASK = 2;\n-\n-    private enum SI_MAX_SIZE = 128;\n-    private enum SI_PAD_SIZE = ((SI_MAX_SIZE / int.sizeof) - 3);\n-\n-    struct siginfo_t\n-    {\n-        int si_signo;\n-        int si_errno;\n-        int si_code;\n-\n-        union _sifields_t\n-        {\n-            int[SI_PAD_SIZE] _pad;\n-\n-            struct _kill_t\n-            {\n-                pid_t _pid;\n-                uid_t _uid;\n-            } _kill_t _kill;\n-\n-            struct _timer_t\n-            {\n-                timer_t _tid;\n-                int     _overrun;\n-                sigval  _sigval;\n-                int     _sys_private;\n-            } _timer_t _timer;\n-\n-            struct _rt_t\n-            {\n-                pid_t  _pid;\n-                uid_t  _uid;\n-                sigval _sigval;\n-            } _rt_t _rt;\n-\n-            struct _sigchild_t\n-            {\n-                pid_t   _pid;\n-                uid_t   _uid;\n-                int     _status;\n-                clock_t _utime;\n-                clock_t _stime;\n-            } _sigchild_t _sigchld;\n-\n-            struct _sigfault_t\n-            {\n-                void*   _addr;\n-            } _sigfault_t _sigfault;\n-\n-            struct _sigpoll_t\n-            {\n-                c_long _band;\n-                int    _fd;\n-            } _sigpoll_t _sigpoll;\n-        } _sifields_t _sifields;\n-    }\n-\n-    enum\n-    {\n-        SI_TKILL   = -6,\n-        SI_SIGIO,\n-        SI_ASYNCIO,\n-        SI_MESGQ,\n-        SI_TIMER,\n-        SI_QUEUE,\n-        SI_USER,\n-        SI_KERNEL  = 0x80\n-    }\n \n     int kill(pid_t, int);\n     int sigaction(int, const scope sigaction_t*, sigaction_t*);\n@@ -1601,111 +1574,6 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n-    struct sigset_t\n-    {\n-        c_ulong[128/c_long.sizeof] __bits;\n-    }\n-\n-    version (MIPS_Any)\n-    {\n-        enum SIG_BLOCK      = 1;\n-        enum SIG_UNBLOCK    = 2;\n-        enum SIG_SETMASK    = 3;\n-    }\n-    else\n-    {\n-        enum SIG_BLOCK      = 0;\n-        enum SIG_UNBLOCK    = 1;\n-        enum SIG_SETMASK    = 2;\n-    }\n-\n-    struct siginfo_t\n-    {\n-        int si_signo;\n-        version (MIPS_Any)  // __SI_SWAP_ERRNO_CODE\n-        {\n-            int si_code;\n-            int si_errno;\n-        }\n-        else\n-        {\n-            int si_errno;\n-            int si_code;\n-        }\n-        union __si_fields_t\n-        {\n-            char[128 - 2*int.sizeof - c_long.sizeof] __pad = 0;\n-            struct __si_common_t\n-            {\n-                union __first_t\n-                {\n-                    struct __piduid_t\n-                    {\n-                        pid_t si_pid;\n-                        uid_t si_uid;\n-                    }\n-                    __piduid_t __piduid;\n-\n-                    struct __timer_t\n-                    {\n-                        int si_timerid;\n-                        int si_overrun;\n-                    }\n-                    __timer_t __timer;\n-                }\n-                __first_t __first;\n-\n-                union __second_t\n-                {\n-                    sigval si_value;\n-                    struct __sigchld_t\n-                    {\n-                        int si_status;\n-                        clock_t si_utime;\n-                        clock_t si_stime;\n-                    }\n-                    __sigchld_t __sigchld;\n-                }\n-                __second_t __second;\n-            }\n-            __si_common_t __si_common;\n-\n-            struct __sigfault_t\n-            {\n-                void *si_addr;\n-                short si_addr_lsb;\n-                union __first_t\n-                {\n-                    struct __addr_bnd_t\n-                    {\n-                        void *si_lower;\n-                        void *si_upper;\n-                    }\n-                    __addr_bnd_t __addr_bnd;\n-                    uint si_pkey;\n-                }\n-                __first_t __first;\n-            }\n-            __sigfault_t __sigfault;\n-\n-            struct __sigpoll_t\n-            {\n-                c_long si_band;\n-                int si_fd;\n-            }\n-            __sigpoll_t __sigpoll;\n-\n-            struct __sigsys_t\n-            {\n-                void *si_call_addr;\n-                int si_syscall;\n-                uint si_arch;\n-            }\n-            __sigsys_t __sigsys;\n-        }\n-        __si_fields_t __si_fields;\n-    }\n-\n     int kill(pid_t, int);\n     int sigaction(int, const scope sigaction_t*, sigaction_t*);\n     int sigaddset(sigset_t*, int);\n@@ -1720,235 +1588,6 @@ else version (CRuntime_Musl)\n }\n else version (CRuntime_UClibc)\n {\n-    enum SIG_HOLD = cast(sigfn_t2) 2;\n-\n-    version (MIPS32)\n-        private enum _SIGSET_NWORDS = 128 / (8 * c_ulong.sizeof);\n-    else\n-        private enum _SIGSET_NWORDS = 64 / (8 * c_ulong.sizeof);\n-\n-    struct sigset_t\n-    {\n-        c_ulong[_SIGSET_NWORDS] __val;\n-    }\n-\n-    enum SA_NOCLDSTOP   = 1;\n-\n-    enum SIG_BLOCK      = 0;\n-    enum SIG_UNBLOCK    = 1;\n-    enum SIG_SETMASK    = 2;\n-\n-    private enum __SI_MAX_SIZE = 128;\n-\n-    static if ( __WORDSIZE == 64 )\n-    {\n-        private enum __SI_PAD_SIZE = ((__SI_MAX_SIZE / int.sizeof) - 4);\n-    }\n-    else\n-    {\n-        private enum __SI_PAD_SIZE = ((__SI_MAX_SIZE / int.sizeof) - 3);\n-    }\n-\n-    version (ARM)           version = siginfo_common;\n-    else version (X86_64)   version = siginfo_common;\n-\n-    version (siginfo_common)\n-    {\n-        struct siginfo_t\n-        {\n-            int si_signo;       // Signal number\n-            int si_errno;       // If non-zero, an errno value associated with\n-                                // this signal, as defined in <errno.h>\n-            int si_code;        // Signal code\n-\n-            union _sifields_t\n-            {\n-                int[__SI_PAD_SIZE] _pad;\n-\n-                // kill()\n-                struct _kill_t\n-                {\n-                    pid_t si_pid; // Sending process ID\n-                    uid_t si_uid; // Real user ID of sending process\n-                } _kill_t _kill;\n-\n-                // POSIX.1b timers.\n-                struct _timer_t\n-                {\n-                    int    si_tid;     // Timer ID\n-                    int    si_overrun; // Overrun count\n-                    sigval si_sigval;  // Signal value\n-                } _timer_t _timer;\n-\n-                // POSIX.1b signals\n-                struct _rt_t\n-                {\n-                    pid_t  si_pid;    // Sending process ID\n-                    uid_t  si_uid;    // Real user ID of sending process\n-                    sigval si_sigval; // Signal value\n-                } _rt_t _rt;\n-\n-                // SIGCHLD\n-                struct _sigchild_t\n-                {\n-                    pid_t   si_pid;    // Which child\n-                    uid_t   si_uid;    // Real user ID of sending process\n-                    int     si_status; // Exit value or signal\n-                    clock_t si_utime;\n-                    clock_t si_stime;\n-                } _sigchild_t _sigchld;\n-\n-                // SIGILL, SIGFPE, SIGSEGV, SIGBUS\n-                struct _sigfault_t\n-                {\n-                    void*     si_addr;  // Faulting insn/memory ref\n-                } _sigfault_t _sigfault;\n-\n-                // SIGPOLL\n-                struct _sigpoll_t\n-                {\n-                    c_long si_band; // Band event for SIGPOLL;\n-                    int      si_fd;\n-                } _sigpoll_t _sigpoll;\n-\n-                // SIGSYS\n-                struct _sigsys_t\n-                {\n-                    void*   _call_addr;   // Calling user insn.\n-                    int     _syscall;     // Triggering system call number.\n-                    uint    _arch;        // AUDIT_ARCH_* of syscall.\n-                } _sigsys_t _sigsys;\n-\n-            } _sifields_t _sifields;\n-\n-        nothrow @nogc:\n-            @property ref pid_t si_pid()() { return _sifields._kill.si_pid; }\n-            @property ref uid_t si_uid()() { return _sifields._kill.si_uid; }\n-            @property ref int si_timerid()() { return _sifields._timer.si_tid;}\n-            @property ref int si_overrun()() { return _sifields._timer.si_overrun; }\n-            @property ref int si_status()() { return _sifields._sigchld.si_status; }\n-            @property ref clock_t si_utime()() { return _sifields._sigchld.si_utime; }\n-            @property ref clock_t si_stime()() { return _sifields._sigchld.si_stime; }\n-            @property ref sigval si_value()() { return _sifields._rt.si_sigval; }\n-            @property ref int si_int()() { return _sifields._rt.si_sigval.sival_int; }\n-            @property ref void* si_ptr()() { return _sifields._rt.si_sigval.sival_ptr; }\n-            @property ref void* si_addr()() { return _sifields._sigfault.si_addr; }\n-            @property ref c_long si_band()() { return _sifields._sigpoll.si_band; }\n-            @property ref int  si_fd()() { return _sifields._sigpoll.si_fd; }\n-            @property ref void*  si_call_addr()() { return _sifields._sigsys._call_addr; }\n-            @property ref int  si_syscall()() { return _sifields._sigsys._syscall; }\n-            @property ref uint  si_arch()() { return _sifields._sigsys._arch; }\n-        }\n-    }\n-    else version (MIPS32)\n-    {\n-        struct siginfo_t\n-        {\n-            int si_signo;       // Signal number\n-            int si_errno;       // If non-zero, an errno value associated with\n-                                // this signal, as defined in <errno.h>\n-            int si_code;        // Signal code\n-\n-            int[__SI_MAX_SIZE / int.sizeof - __SI_PAD_SIZE - 3] __pad0;\n-\n-            union _sifields_t\n-            {\n-                int[__SI_PAD_SIZE] _pad;\n-\n-                // kill()\n-                struct _kill_t\n-                {\n-                    pid_t si_pid; // Sending process ID\n-                    uid_t si_uid; // Real user ID of sending process\n-                } _kill_t _kill;\n-\n-                // POSIX.1b timers.\n-                struct _timer_t\n-                {\n-                    int    si_tid;     // Timer ID\n-                    int    si_overrun; // Overrun count\n-                    sigval si_sigval;  // Signal value\n-                } _timer_t _timer;\n-\n-                // POSIX.1b signals\n-                struct _rt_t\n-                {\n-                    pid_t  si_pid;    // Sending process ID\n-                    uid_t  si_uid;    // Real user ID of sending process\n-                    sigval si_sigval; // Signal value\n-                } _rt_t _rt;\n-\n-                // SIGCHLD\n-                struct _sigchild_t\n-                {\n-                    pid_t   si_pid;    // Which child\n-                    uid_t   si_uid;    // Real user ID of sending process\n-                    int     si_status; // Exit value or signal\n-                    clock_t si_utime;\n-                    clock_t si_stime;\n-                } _sigchild_t _sigchld;\n-\n-                // SIGILL, SIGFPE, SIGSEGV, SIGBUS\n-                struct _sigfault_t\n-                {\n-                    void*   si_addr;  // Faulting insn/memory ref\n-                    short   si_addr_lsb;\n-                } _sigfault_t _sigfault;\n-\n-                // SIGPOLL\n-                struct _sigpoll_t\n-                {\n-                    c_long si_band; // Band event for SIGPOLL;\n-                    int      si_fd;\n-                } _sigpoll_t _sigpoll;\n-\n-                // SIGSYS\n-                struct _sigsys_t\n-                {\n-                    void*   _call_addr;   // Calling user insn.\n-                    int     _syscall;     // Triggering system call number.\n-                    uint    _arch;        // AUDIT_ARCH_* of syscall.\n-                } _sigsys_t _sigsys;\n-\n-            } _sifields_t _sifields;\n-\n-        nothrow @nogc:\n-            @property ref pid_t si_pid()() { return _sifields._kill.si_pid; }\n-            @property ref uid_t si_uid()() { return _sifields._kill.si_uid; }\n-            @property ref int si_timerid()() { return _sifields._timer.si_tid;}\n-            @property ref int si_overrun()() { return _sifields._timer.si_overrun; }\n-            @property ref int si_status()() { return _sifields._sigchld.si_status; }\n-            @property ref clock_t si_utime()() { return _sifields._sigchld.si_utime; }\n-            @property ref clock_t si_stime()() { return _sifields._sigchld.si_stime; }\n-            @property ref sigval si_value()() { return _sifields._rt.si_sigval; }\n-            @property ref int si_int()() { return _sifields._rt.si_sigval.sival_int; }\n-            @property ref void* si_ptr()() { return _sifields._rt.si_sigval.sival_ptr; }\n-            @property ref void* si_addr()() { return _sifields._sigfault.si_addr; }\n-            @property ref c_long si_band()() { return _sifields._sigpoll.si_band; }\n-            @property ref int  si_fd()() { return _sifields._sigpoll.si_fd; }\n-            @property ref void*  si_call_addr()() { return _sifields._sigsys._call_addr; }\n-            @property ref int  si_syscall()() { return _sifields._sigsys._syscall; }\n-            @property ref uint  si_arch()() { return _sifields._sigsys._arch; }\n-        }\n-    }\n-    else\n-    {\n-        static assert(false, \"Architecture not supported.\");\n-    }\n-\n-    enum\n-    {\n-        SI_ASYNCNL = -60,\n-        SI_TKILL   = -6,\n-        SI_SIGIO,\n-        SI_ASYNCIO,\n-        SI_MESGQ,\n-        SI_TIMER,\n-        SI_QUEUE,\n-        SI_USER,\n-        SI_KERNEL  = 0x80\n-    }\n-\n     int kill(pid_t, int);\n     int sigaction(int, const scope sigaction_t*, sigaction_t*);\n     int sigaddset(sigset_t*, int);\n@@ -1985,26 +1624,6 @@ SA_RESTART\n SA_SIGINFO\n SA_NOCLDWAIT\n SA_NODEFER\n-SS_ONSTACK\n-SS_DISABLE\n-MINSIGSTKSZ\n-SIGSTKSZ\n-\n-ucontext_t // from ucontext\n-mcontext_t // from ucontext\n-\n-struct stack_t\n-{\n-    void*   ss_sp;\n-    size_t  ss_size;\n-    int     ss_flags;\n-}\n-\n-struct sigstack\n-{\n-    int   ss_onstack;\n-    void* ss_sp;\n-}\n \n ILL_ILLOPC\n ILL_ILLOPN\n@@ -2047,20 +1666,9 @@ POLL_MSG\n POLL_ERR\n POLL_PRI\n POLL_HUP\n-\n-sigfn_t bsd_signal(int sig, sigfn_t func);\n-sigfn_t sigset(int sig, sigfn_t func);\n-\n-int killpg(pid_t, int);\n-int sigaltstack(const scope stack_t*, stack_t*);\n-int sighold(int);\n-int sigignore(int);\n-int siginterrupt(int, int);\n-int sigpause(int);\n-int sigrelse(int);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     version (X86_Any)\n     {\n@@ -2145,33 +1753,29 @@ version (CRuntime_Glibc)\n     else\n         static assert(0, \"unimplemented\");\n \n-    enum SA_ONSTACK     = 0x08000000;\n-    enum SA_RESETHAND   = 0x80000000;\n-    enum SA_RESTART     = 0x10000000;\n-    enum SA_SIGINFO     = 4;\n-    enum SA_NOCLDWAIT   = 2;\n-    enum SA_NODEFER     = 0x40000000;\n-    enum SS_ONSTACK     = 1;\n-    enum SS_DISABLE     = 2;\n-    enum MINSIGSTKSZ    = 2048;\n-    enum SIGSTKSZ       = 8192;\n-\n-    //ucontext_t (defined in core.sys.posix.ucontext)\n-    //mcontext_t (defined in core.sys.posix.ucontext)\n-\n-    struct stack_t\n+    version (MIPS_Any)\n     {\n-        void*   ss_sp;\n-        int     ss_flags;\n-        size_t  ss_size;\n+        enum SA_ONSTACK   = 0x08000000;\n+        enum SA_RESETHAND = 0x80000000;\n+        enum SA_RESTART   = 0x10000000;\n+        enum SA_SIGINFO   = 8;\n+        enum SA_NOCLDWAIT = 0x10000;\n+        enum SA_NODEFER   = 0x40000000;\n     }\n-\n-    struct sigstack\n+    else\n     {\n-        void*   ss_sp;\n-        int     ss_onstack;\n+        enum SA_ONSTACK   = 0x08000000;\n+        enum SA_RESETHAND = 0x80000000;\n+        enum SA_RESTART   = 0x10000000;\n+        enum SA_SIGINFO   = 4;\n+        enum SA_NOCLDWAIT = 2;\n+        enum SA_NODEFER   = 0x40000000;\n     }\n \n+    enum SA_NOMASK      = SA_NODEFER;\n+    enum SA_ONESHOT     = SA_RESETHAND;\n+    enum SA_STACK       = SA_ONSTACK;\n+\n     enum\n     {\n         ILL_ILLOPC = 1,\n@@ -2234,22 +1838,6 @@ version (CRuntime_Glibc)\n         POLL_PRI,\n         POLL_HUP\n     }\n-\n-    sigfn_t bsd_signal(int sig, sigfn_t func);\n-    sigfn_t sigset(int sig, sigfn_t func);\n-\n-  nothrow:\n-  @nogc:\n-    sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n-    sigfn_t2 sigset(int sig, sigfn_t2 func);\n-\n-    int killpg(pid_t, int);\n-    int sigaltstack(const scope stack_t*, stack_t*);\n-    int sighold(int);\n-    int sigignore(int);\n-    int siginterrupt(int, int);\n-    int sigpause(int);\n-    int sigrelse(int);\n }\n else version (Darwin)\n {\n@@ -2267,26 +1855,6 @@ else version (Darwin)\n     enum SA_SIGINFO     = 0x0040;\n     enum SA_NOCLDWAIT   = 0x0020;\n     enum SA_NODEFER     = 0x0010;\n-    enum SS_ONSTACK     = 0x0001;\n-    enum SS_DISABLE     = 0x0004;\n-    enum MINSIGSTKSZ    = 32768;\n-    enum SIGSTKSZ       = 131072;\n-\n-    //ucontext_t (defined in core.sys.posix.ucontext)\n-    //mcontext_t (defined in core.sys.posix.ucontext)\n-\n-    struct stack_t\n-    {\n-        void*   ss_sp;\n-        size_t  ss_size;\n-        int     ss_flags;\n-    }\n-\n-    struct sigstack\n-    {\n-        void*   ss_sp;\n-        int     ss_onstack;\n-    }\n \n     enum ILL_ILLOPC = 1;\n     enum ILL_ILLOPN = 4;\n@@ -2344,32 +1912,16 @@ else version (Darwin)\n         POLL_PRI,\n         POLL_HUP\n     }\n-\n-    sigfn_t bsd_signal(int sig, sigfn_t func);\n-    sigfn_t sigset(int sig, sigfn_t func);\n-\n-  nothrow:\n-  @nogc:\n-    sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n-    sigfn_t2 sigset(int sig, sigfn_t2 func);\n-\n-    int killpg(pid_t, int);\n-    int sigaltstack(const scope stack_t*, stack_t*);\n-    int sighold(int);\n-    int sigignore(int);\n-    int siginterrupt(int, int);\n-    int sigpause(int);\n-    int sigrelse(int);\n-}\n-else version (FreeBSD)\n-{\n-    // No SIGPOLL on *BSD\n-    enum SIGPROF        = 27;\n-    enum SIGSYS         = 12;\n-    enum SIGTRAP        = 5;\n-    enum SIGVTALRM      = 26;\n-    enum SIGXCPU        = 24;\n-    enum SIGXFSZ        = 25;\n+}\n+else version (FreeBSD)\n+{\n+    // No SIGPOLL on *BSD\n+    enum SIGPROF        = 27;\n+    enum SIGSYS         = 12;\n+    enum SIGTRAP        = 5;\n+    enum SIGVTALRM      = 26;\n+    enum SIGXCPU        = 24;\n+    enum SIGXFSZ        = 25;\n \n     enum\n     {\n@@ -2381,31 +1933,6 @@ else version (FreeBSD)\n         SA_SIGINFO      = 0x0040,\n     }\n \n-    enum\n-    {\n-        SS_ONSTACK = 0x0001,\n-        SS_DISABLE = 0x0004,\n-    }\n-\n-    enum MINSIGSTKSZ = 512 * 4;\n-    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n-\n-    //ucontext_t (defined in core.sys.posix.ucontext)\n-    //mcontext_t (defined in core.sys.posix.ucontext)\n-\n-    struct stack_t\n-    {\n-        void*   ss_sp;\n-        size_t  ss_size;\n-        int     ss_flags;\n-    }\n-\n-    struct sigstack\n-    {\n-        void*   ss_sp;\n-        int     ss_onstack;\n-    }\n-\n     enum\n     {\n         ILL_ILLOPC = 1,\n@@ -2468,22 +1995,6 @@ else version (FreeBSD)\n         POLL_PRI,\n         POLL_HUP,\n     }\n-\n-    //sigfn_t bsd_signal(int sig, sigfn_t func);\n-    sigfn_t sigset(int sig, sigfn_t func);\n-\n-  nothrow:\n-  @nogc:\n-    //sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n-    sigfn_t2 sigset(int sig, sigfn_t2 func);\n-\n-    int killpg(pid_t, int);\n-    int sigaltstack(const scope stack_t*, stack_t*);\n-    int sighold(int);\n-    int sigignore(int);\n-    int siginterrupt(int, int);\n-    int sigpause(int);\n-    int sigrelse(int);\n }\n else version (NetBSD)\n {\n@@ -2505,31 +2016,6 @@ else version (NetBSD)\n         SA_SIGINFO      = 0x0040,\n     }\n \n-    enum\n-    {\n-        SS_ONSTACK = 0x0001,\n-        SS_DISABLE = 0x0004,\n-    }\n-\n-    enum MINSIGSTKSZ = 8192;\n-    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n-\n-    //ucontext_t (defined in core.sys.posix.ucontext)\n-    //mcontext_t (defined in core.sys.posix.ucontext)\n-\n-    struct stack_t\n-    {\n-        void*   ss_sp;\n-        size_t  ss_size;\n-        int     ss_flags;\n-    }\n-\n-    struct sigstack\n-    {\n-        void*   ss_sp;\n-        int     ss_onstack;\n-    }\n-\n     enum\n     {\n         ILL_ILLOPC = 1,\n@@ -2592,22 +2078,6 @@ else version (NetBSD)\n         POLL_PRI,\n         POLL_HUP,\n     }\n-\n-    //sigfn_t bsd_signal(int sig, sigfn_t func);\n-    sigfn_t sigset(int sig, sigfn_t func);\n-\n-  nothrow:\n-  @nogc:\n-    //sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n-    sigfn_t2 sigset(int sig, sigfn_t2 func);\n-\n-    int killpg(pid_t, int);\n-    int sigaltstack(const scope stack_t*, stack_t*);\n-    int sighold(int);\n-    int sigignore(int);\n-    int siginterrupt(int, int);\n-    int sigpause(int);\n-    int sigrelse(int);\n }\n else version (OpenBSD)\n {\n@@ -2629,25 +2099,6 @@ else version (OpenBSD)\n         SA_SIGINFO      = 0x0040,\n     }\n \n-    enum\n-    {\n-        SS_ONSTACK = 0x0001,\n-        SS_DISABLE = 0x0004,\n-    }\n-\n-    enum MINSIGSTKSZ = 8192;\n-    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n-\n-    //ucontext_t (defined in core.sys.posix.ucontext)\n-    //mcontext_t (defined in core.sys.posix.ucontext)\n-\n-    struct stack_t\n-    {\n-        void*   ss_sp;\n-        size_t  ss_size;\n-        int     ss_flags;\n-    }\n-\n     enum\n     {\n         ILL_ILLOPC = 1,\n@@ -2717,13 +2168,6 @@ else version (OpenBSD)\n         POLL_HUP,\n         NSIGPOLL = POLL_HUP,\n     }\n-\n-  nothrow:\n-  @nogc:\n-    int killpg(pid_t, int);\n-    int sigaltstack(const scope stack_t*, stack_t*);\n-    int siginterrupt(int, int);\n-    int sigpause(int);\n }\n else version (DragonFlyBSD)\n {\n@@ -2745,31 +2189,6 @@ else version (DragonFlyBSD)\n         SA_SIGINFO      = 0x0040,\n     }\n \n-    enum\n-    {\n-        SS_ONSTACK = 0x0001,\n-        SS_DISABLE = 0x0004,\n-    }\n-\n-    enum MINSIGSTKSZ = 8192;\n-    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n-\n-    //ucontext_t (defined in core.sys.posix.ucontext)\n-    //mcontext_t (defined in core.sys.posix.ucontext)\n-\n-    struct stack_t\n-    {\n-        void*   ss_sp;\n-        size_t  ss_size;\n-        int     ss_flags;\n-    }\n-\n-    struct sigstack\n-    {\n-        void*   ss_sp;\n-        int     ss_onstack;\n-    }\n-\n     enum\n     {\n         ILL_ILLOPC = 1,\n@@ -2832,26 +2251,11 @@ else version (DragonFlyBSD)\n         POLL_PRI,\n         POLL_HUP,\n     }\n-\n-    //sigfn_t bsd_signal(int sig, sigfn_t func);\n-    sigfn_t sigset(int sig, sigfn_t func);\n-\n-  nothrow:\n-  @nogc:\n-    //sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n-    sigfn_t2 sigset(int sig, sigfn_t2 func);\n-\n-    int killpg(pid_t, int);\n-    int sigaltstack(const scope stack_t*, stack_t*);\n-    int sighold(int);\n-    int sigignore(int);\n-    int siginterrupt(int, int);\n-    int sigpause(int);\n-    int sigrelse(int);\n }\n else version (Solaris)\n {\n     enum SIGPOLL = 22;\n+    enum SIGIO = SIGPOLL;\n     enum SIGPROF = 29;\n     enum SIGSYS = 12;\n     enum SIGTRAP = 5;\n@@ -2869,28 +2273,6 @@ else version (Solaris)\n         SA_SIGINFO = 0x00008,\n     }\n \n-    enum\n-    {\n-        SS_ONSTACK = 0x0001,\n-        SS_DISABLE = 0x0002,\n-    }\n-\n-    enum MINSIGSTKSZ = 2048;\n-    enum SIGSTKSZ = 8192;\n-\n-    struct stack_t\n-    {\n-        void* ss_sp;\n-        size_t ss_size;\n-        int ss_flags;\n-    }\n-\n-    struct sigstack\n-    {\n-        void* ss_sp;\n-        int ss_onstack;\n-    }\n-\n     enum\n     {\n         ILL_ILLOPC = 1,\n@@ -2958,11 +2340,75 @@ else version (Solaris)\n         POLL_PRI,\n         POLL_HUP,\n     }\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+SS_ONSTACK\n+SS_DISABLE\n+MINSIGSTKSZ\n+SIGSTKSZ\n+\n+ucontext_t // from ucontext\n+mcontext_t // from ucontext\n+\n+struct stack_t\n+{\n+    void*   ss_sp;\n+    size_t  ss_size;\n+    int     ss_flags;\n+}\n+\n+struct sigstack\n+{\n+    int   ss_onstack;\n+    void* ss_sp;\n+}\n+\n+sigfn_t bsd_signal(int sig, sigfn_t func);\n+sigfn_t sigset(int sig, sigfn_t func);\n+\n+int killpg(pid_t, int);\n+int sigaltstack(const scope stack_t*, stack_t*);\n+int sighold(int);\n+int sigignore(int);\n+int siginterrupt(int, int);\n+int sigpause(int);\n+int sigrelse(int);\n+*/\n+\n+version (CRuntime_Glibc)\n+{\n+    enum SS_ONSTACK     = 1;\n+    enum SS_DISABLE     = 2;\n+    enum MINSIGSTKSZ    = 2048;\n+    enum SIGSTKSZ       = 8192;\n+\n+    //ucontext_t (defined in core.sys.posix.ucontext)\n+    //mcontext_t (defined in core.sys.posix.ucontext)\n+\n+    struct stack_t\n+    {\n+        void*   ss_sp;\n+        int     ss_flags;\n+        size_t  ss_size;\n+    }\n+\n+    struct sigstack\n+    {\n+        void*   ss_sp;\n+        int     ss_onstack;\n+    }\n \n+    sigfn_t bsd_signal(int sig, sigfn_t func);\n     sigfn_t sigset(int sig, sigfn_t func);\n \n   nothrow:\n   @nogc:\n+    sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n     sigfn_t2 sigset(int sig, sigfn_t2 func);\n \n     int killpg(pid_t, int);\n@@ -2973,95 +2419,252 @@ else version (Solaris)\n     int sigpause(int);\n     int sigrelse(int);\n }\n-else version (CRuntime_Bionic)\n+else version (Darwin)\n {\n-    enum SIGPOLL   = 29;\n-    enum SIGPROF   = 27;\n-    enum SIGSYS    = 31;\n-    enum SIGTRAP   = 5;\n-    enum SIGVTALRM = 26;\n-    enum SIGXCPU   = 24;\n-    enum SIGXFSZ   = 25;\n-\n-    enum SA_ONSTACK     = 0x08000000;\n-    enum SA_RESETHAND   = 0x80000000;\n-    enum SA_RESTART     = 0x10000000;\n-    enum SA_SIGINFO     = 4;\n-    enum SA_NOCLDWAIT   = 2;\n-    enum SA_NODEFER     = 0x40000000;\n-    enum SS_ONSTACK     = 1;\n-    enum SS_DISABLE     = 2;\n-    enum MINSIGSTKSZ    = 2048;\n-    enum SIGSTKSZ       = 8192;\n+    enum SS_ONSTACK     = 0x0001;\n+    enum SS_DISABLE     = 0x0004;\n+    enum MINSIGSTKSZ    = 32768;\n+    enum SIGSTKSZ       = 131072;\n+\n+    //ucontext_t (defined in core.sys.posix.ucontext)\n+    //mcontext_t (defined in core.sys.posix.ucontext)\n \n     struct stack_t\n     {\n         void*   ss_sp;\n-        int     ss_flags;\n         size_t  ss_size;\n+        int     ss_flags;\n     }\n \n-    enum\n+    struct sigstack\n     {\n-        ILL_ILLOPC = 1,\n-        ILL_ILLOPN,\n-        ILL_ILLADR,\n-        ILL_ILLTRP,\n-        ILL_PRVOPC,\n-        ILL_PRVREG,\n-        ILL_COPROC,\n-        ILL_BADSTK\n+        void*   ss_sp;\n+        int     ss_onstack;\n     }\n \n+    sigfn_t bsd_signal(int sig, sigfn_t func);\n+    sigfn_t sigset(int sig, sigfn_t func);\n+\n+  nothrow:\n+  @nogc:\n+    sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n+    sigfn_t2 sigset(int sig, sigfn_t2 func);\n+\n+    int killpg(pid_t, int);\n+    int sigaltstack(const scope stack_t*, stack_t*);\n+    int sighold(int);\n+    int sigignore(int);\n+    int siginterrupt(int, int);\n+    int sigpause(int);\n+    int sigrelse(int);\n+}\n+else version (FreeBSD)\n+{\n     enum\n     {\n-        FPE_INTDIV = 1,\n-        FPE_INTOVF,\n-        FPE_FLTDIV,\n-        FPE_FLTOVF,\n-        FPE_FLTUND,\n-        FPE_FLTRES,\n-        FPE_FLTINV,\n-        FPE_FLTSUB\n+        SS_ONSTACK = 0x0001,\n+        SS_DISABLE = 0x0004,\n     }\n \n+    enum MINSIGSTKSZ = 512 * 4;\n+    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n+\n+    //ucontext_t (defined in core.sys.posix.ucontext)\n+    //mcontext_t (defined in core.sys.posix.ucontext)\n+\n+    struct stack_t\n+    {\n+        void*   ss_sp;\n+        size_t  ss_size;\n+        int     ss_flags;\n+    }\n+\n+    struct sigstack\n+    {\n+        void*   ss_sp;\n+        int     ss_onstack;\n+    }\n+\n+    //sigfn_t bsd_signal(int sig, sigfn_t func);\n+    sigfn_t sigset(int sig, sigfn_t func);\n+\n+  nothrow:\n+  @nogc:\n+    //sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n+    sigfn_t2 sigset(int sig, sigfn_t2 func);\n+\n+    int killpg(pid_t, int);\n+    int sigaltstack(const scope stack_t*, stack_t*);\n+    int sighold(int);\n+    int sigignore(int);\n+    int siginterrupt(int, int);\n+    int sigpause(int);\n+    int sigrelse(int);\n+}\n+else version (NetBSD)\n+{\n     enum\n     {\n-        SEGV_MAPERR = 1,\n-        SEGV_ACCERR\n+        SS_ONSTACK = 0x0001,\n+        SS_DISABLE = 0x0004,\n     }\n \n+    enum MINSIGSTKSZ = 8192;\n+    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n+\n+    //ucontext_t (defined in core.sys.posix.ucontext)\n+    //mcontext_t (defined in core.sys.posix.ucontext)\n+\n+    struct stack_t\n+    {\n+        void*   ss_sp;\n+        size_t  ss_size;\n+        int     ss_flags;\n+    }\n+\n+    struct sigstack\n+    {\n+        void*   ss_sp;\n+        int     ss_onstack;\n+    }\n+\n+    //sigfn_t bsd_signal(int sig, sigfn_t func);\n+    sigfn_t sigset(int sig, sigfn_t func);\n+\n+  nothrow:\n+  @nogc:\n+    //sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n+    sigfn_t2 sigset(int sig, sigfn_t2 func);\n+\n+    int killpg(pid_t, int);\n+    int sigaltstack(const scope stack_t*, stack_t*);\n+    int sighold(int);\n+    int sigignore(int);\n+    int siginterrupt(int, int);\n+    int sigpause(int);\n+    int sigrelse(int);\n+}\n+else version (OpenBSD)\n+{\n     enum\n     {\n-        BUS_ADRALN = 1,\n-        BUS_ADRERR,\n-        BUS_OBJERR\n+        SS_ONSTACK = 0x0001,\n+        SS_DISABLE = 0x0004,\n     }\n \n+    enum MINSIGSTKSZ = 8192;\n+    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n+\n+    //ucontext_t (defined in core.sys.posix.ucontext)\n+    //mcontext_t (defined in core.sys.posix.ucontext)\n+\n+    struct stack_t\n+    {\n+        void*   ss_sp;\n+        size_t  ss_size;\n+        int     ss_flags;\n+    }\n+\n+  nothrow:\n+  @nogc:\n+    int killpg(pid_t, int);\n+    int sigaltstack(const scope stack_t*, stack_t*);\n+    int siginterrupt(int, int);\n+    int sigpause(int);\n+}\n+else version (DragonFlyBSD)\n+{\n     enum\n     {\n-        TRAP_BRKPT = 1,\n-        TRAP_TRACE\n+        SS_ONSTACK = 0x0001,\n+        SS_DISABLE = 0x0004,\n     }\n \n+    enum MINSIGSTKSZ = 8192;\n+    enum SIGSTKSZ    = (MINSIGSTKSZ + 32768);\n+\n+    //ucontext_t (defined in core.sys.posix.ucontext)\n+    //mcontext_t (defined in core.sys.posix.ucontext)\n+\n+    struct stack_t\n+    {\n+        void*   ss_sp;\n+        size_t  ss_size;\n+        int     ss_flags;\n+    }\n+\n+    struct sigstack\n+    {\n+        void*   ss_sp;\n+        int     ss_onstack;\n+    }\n+\n+    //sigfn_t bsd_signal(int sig, sigfn_t func);\n+    sigfn_t sigset(int sig, sigfn_t func);\n+\n+  nothrow:\n+  @nogc:\n+    //sigfn_t2 bsd_signal(int sig, sigfn_t2 func);\n+    sigfn_t2 sigset(int sig, sigfn_t2 func);\n+\n+    int killpg(pid_t, int);\n+    int sigaltstack(const scope stack_t*, stack_t*);\n+    int sighold(int);\n+    int sigignore(int);\n+    int siginterrupt(int, int);\n+    int sigpause(int);\n+    int sigrelse(int);\n+}\n+else version (Solaris)\n+{\n     enum\n     {\n-        CLD_EXITED = 1,\n-        CLD_KILLED,\n-        CLD_DUMPED,\n-        CLD_TRAPPED,\n-        CLD_STOPPED,\n-        CLD_CONTINUED\n+        SS_ONSTACK = 0x0001,\n+        SS_DISABLE = 0x0002,\n+    }\n+\n+    enum MINSIGSTKSZ = 2048;\n+    enum SIGSTKSZ = 8192;\n+\n+    struct stack_t\n+    {\n+        void* ss_sp;\n+        size_t ss_size;\n+        int ss_flags;\n+    }\n+\n+    struct sigstack\n+    {\n+        void* ss_sp;\n+        int ss_onstack;\n     }\n \n-    enum\n+    sigfn_t sigset(int sig, sigfn_t func);\n+\n+  nothrow:\n+  @nogc:\n+    sigfn_t2 sigset(int sig, sigfn_t2 func);\n+\n+    int killpg(pid_t, int);\n+    int sigaltstack(const scope stack_t*, stack_t*);\n+    int sighold(int);\n+    int sigignore(int);\n+    int siginterrupt(int, int);\n+    int sigpause(int);\n+    int sigrelse(int);\n+}\n+else version (CRuntime_Bionic)\n+{\n+    enum SS_ONSTACK     = 1;\n+    enum SS_DISABLE     = 2;\n+    enum MINSIGSTKSZ    = 2048;\n+    enum SIGSTKSZ       = 8192;\n+\n+    struct stack_t\n     {\n-        POLL_IN = 1,\n-        POLL_OUT,\n-        POLL_MSG,\n-        POLL_ERR,\n-        POLL_PRI,\n-        POLL_HUP\n+        void*   ss_sp;\n+        int     ss_flags;\n+        size_t  ss_size;\n     }\n \n     sigfn_t bsd_signal(int, sigfn_t);\n@@ -3076,41 +2679,6 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n-    version (MIPS_Any)\n-    {\n-        enum SIGPOLL   = 22;\n-        enum SIGPROF   = 29;\n-        enum SIGSYS    = 12;\n-        enum SIGTRAP   = 5;\n-        enum SIGVTALRM = 28;\n-        enum SIGXCPU   = 30;\n-        enum SIGXFSZ   = 31;\n-\n-        enum SA_ONSTACK   = 0x08000000;\n-        enum SA_RESETHAND = 0x80000000;\n-        enum SA_RESTART   = 0x10000000;\n-        enum SA_SIGINFO   = 8;\n-        enum SA_NOCLDWAIT = 0x10000;\n-        enum SA_NODEFER   = 0x40000000;\n-    }\n-    else\n-    {\n-        enum SIGPOLL   = 29;\n-        enum SIGPROF   = 27;\n-        enum SIGSYS    = 31;\n-        enum SIGTRAP   = 5;\n-        enum SIGVTALRM = 26;\n-        enum SIGXCPU   = 24;\n-        enum SIGXFSZ   = 25;\n-\n-        enum SA_ONSTACK   = 0x08000000;\n-        enum SA_RESETHAND = 0x80000000;\n-        enum SA_RESTART   = 0x10000000;\n-        enum SA_SIGINFO   = 4;\n-        enum SA_NOCLDWAIT = 2;\n-        enum SA_NODEFER   = 0x40000000;\n-    }\n-\n     enum SS_ONSTACK = 1;\n     enum SS_DISABLE = 2;\n \n@@ -3169,69 +2737,6 @@ else version (CRuntime_Musl)\n         }\n     }\n \n-    enum\n-    {\n-        ILL_ILLOPC = 1,\n-        ILL_ILLOPN,\n-        ILL_ILLADR,\n-        ILL_ILLTRP,\n-        ILL_PRVOPC,\n-        ILL_PRVREG,\n-        ILL_COPROC,\n-        ILL_BADSTK\n-    }\n-\n-    enum\n-    {\n-        FPE_INTDIV = 1,\n-        FPE_INTOVF,\n-        FPE_FLTDIV,\n-        FPE_FLTOVF,\n-        FPE_FLTUND,\n-        FPE_FLTRES,\n-        FPE_FLTINV,\n-        FPE_FLTSUB\n-    }\n-\n-    enum\n-    {\n-        SEGV_MAPERR = 1,\n-        SEGV_ACCERR\n-    }\n-\n-    enum\n-    {\n-        BUS_ADRALN = 1,\n-        BUS_ADRERR,\n-        BUS_OBJERR\n-    }\n-\n-    enum\n-    {\n-        TRAP_BRKPT = 1,\n-        TRAP_TRACE\n-    }\n-\n-    enum\n-    {\n-        CLD_EXITED = 1,\n-        CLD_KILLED,\n-        CLD_DUMPED,\n-        CLD_TRAPPED,\n-        CLD_STOPPED,\n-        CLD_CONTINUED\n-    }\n-\n-    enum\n-    {\n-        POLL_IN = 1,\n-        POLL_OUT,\n-        POLL_MSG,\n-        POLL_ERR,\n-        POLL_PRI,\n-        POLL_HUP\n-    }\n-\n     sigfn_t bsd_signal(int sig, sigfn_t func);\n     sigfn_t sigset(int sig, sigfn_t func);\n \n@@ -3250,77 +2755,11 @@ else version (CRuntime_Musl)\n }\n else version (CRuntime_UClibc)\n {\n-    version (X86_64)\n-    {\n-        enum SIGTRAP         = 5;\n-        enum SIGIOT          = 6;\n-        enum SIGSTKFLT       = 16;\n-        enum SIGCLD          = SIGCHLD;\n-        enum SIGXCPU         = 24;\n-        enum SIGXFSZ         = 25;\n-        enum SIGVTALRM       = 26;\n-        enum SIGPROF         = 27;\n-        enum SIGWINCH        = 28;\n-        enum SIGPOLL         = SIGIO;\n-        enum SIGIO           = 29;\n-        enum SIGPWR          = 30;\n-        enum SIGSYS          = 31;\n-        enum SIGUNUSED       = 31;\n-    }\n-    else version (MIPS32)\n-    {\n-        enum SIGTRAP = 5;\n-        enum SIGIOT           = 6;\n-        enum SIGEMT           = 7;\n-        enum SIGFPE           = 8;\n-        enum SIGSYS           = 12;\n-        enum SIGCLD           = SIGCHLD;\n-        enum SIGPWR           = 19;\n-        enum SIGWINCH         = 20;\n-        enum SIGIO            = 22;\n-        enum SIGPOLL          = SIGIO;\n-        enum SIGVTALRM        = 28;\n-        enum SIGPROF          = 29;\n-        enum SIGXCPU          = 30;\n-        enum SIGXFSZ          = 31;\n-    }\n-    else version (ARM)\n-    {\n-        enum SIGTRAP = 5;\n-        enum SIGIOT = 6;\n-        enum SIGSTKFLT = 16;\n-        enum SIGCLD = SIGCHLD;\n-        enum SIGXCPU = 24;\n-        enum SIGXFSZ = 25;\n-        enum SIGVTALRM = 26;\n-        enum SIGPROF = 27;\n-        enum SIGWINCH = 28;\n-        enum SIGPOLL = SIGIO;\n-        enum SIGIO = 29;\n-        enum SIGPWR = 30;\n-        enum SIGSYS = 31;\n-        enum SIGUNUSED = 31;\n-    }\n-    else\n-        static assert(0, \"unimplemented\");\n-\n-    enum SA_ONSTACK     = 0x08000000;\n-    enum SA_RESETHAND   = 0x80000000;\n-    enum SA_RESTART     = 0x10000000;\n-    enum SA_SIGINFO     = 4;\n-    enum SA_NOCLDWAIT   = 2;\n-    enum SA_NODEFER     = 0x40000000;\n     enum SS_ONSTACK     = 1;\n     enum SS_DISABLE     = 2;\n     enum MINSIGSTKSZ    = 2048;\n     enum SIGSTKSZ       = 8192;\n \n-    enum SA_INTERRUPT   = 0x20000000;\n-\n-    enum SA_NOMASK      = SA_NODEFER;\n-    enum SA_ONESHOT     = SA_RESETHAND;\n-    enum SA_STACK       = SA_ONSTACK;\n-\n     version (MIPS32)\n     {\n         struct stack_t\n@@ -3346,76 +2785,6 @@ else version (CRuntime_UClibc)\n         int     ss_onstack;\n     }\n \n-    // `si_code' values for SIGILL signal.\n-    enum\n-    {\n-      ILL_ILLOPC = 1,       // Illegal opcode.\n-      ILL_ILLOPN,           // Illegal operand.\n-      ILL_ILLADR,           // Illegal addressing mode.\n-      ILL_ILLTRP,           // Illegal trap.\n-      ILL_PRVOPC,           // Privileged opcode.\n-      ILL_PRVREG,           // Privileged register.\n-      ILL_COPROC,           // Coprocessor error.\n-      ILL_BADSTK            // Internal stack error.\n-    }\n-\n-    // `si_code' values for SIGFPE signal.\n-    enum\n-    {\n-      FPE_INTDIV = 1,       // Integer divide by zero.\n-      FPE_INTOVF,           // Integer overflow.\n-      FPE_FLTDIV,           // Floating point divide by zero.\n-      FPE_FLTOVF,           // Floating point overflow.\n-      FPE_FLTUND,           // Floating point underflow.\n-      FPE_FLTRES,           // Floating point inexact result.\n-      FPE_FLTINV,           // Floating point invalid operation.\n-      FPE_FLTSUB            // Subscript out of range.\n-    }\n-\n-    // `si_code' values for SIGSEGV signal.\n-    enum\n-    {\n-      SEGV_MAPERR = 1,      // Address not mapped to object.\n-      SEGV_ACCERR           // Invalid permissions for mapped object.\n-    }\n-\n-    // `si_code' values for SIGBUS signal.\n-    enum\n-    {\n-      BUS_ADRALN = 1,       // Invalid address alignment.\n-      BUS_ADRERR,           // Non-existant physical address.\n-      BUS_OBJERR            // Object specific hardware error.\n-    }\n-\n-    // `si_code' values for SIGTRAP signal.\n-    enum\n-    {\n-      TRAP_BRKPT = 1,       // Process breakpoint.\n-      TRAP_TRACE            // Process trace trap.\n-    }\n-\n-    // `si_code' values for SIGCHLD signal.\n-    enum\n-    {\n-      CLD_EXITED = 1,       // Child has exited.\n-      CLD_KILLED,           // Child was killed.\n-      CLD_DUMPED,           // Child terminated abnormally.\n-      CLD_TRAPPED,          // Traced child has trapped.\n-      CLD_STOPPED,          // Child has stopped.\n-      CLD_CONTINUED         // Stopped child has continued.\n-    }\n-\n-    // `si_code' values for SIGPOLL signal.\n-    enum\n-    {\n-      POLL_IN = 1,          // Data input available.\n-      POLL_OUT,         // Output buffers available.\n-      POLL_MSG,         // Input message available.\n-      POLL_ERR,         // I/O error.\n-      POLL_PRI,         // High priority input available.\n-      POLL_HUP          // Device disconnected.\n-    }\n-\n     sigfn_t sigset(int sig, sigfn_t func);\n \n   nothrow:\n@@ -3524,16 +2893,12 @@ struct sigevent\n     void(*)(sigval) sigev_notify_function;\n     pthread_attr_t* sigev_notify_attributes;\n }\n-\n-int sigqueue(pid_t, int, const sigval);\n-int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n-int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n */\n \n nothrow:\n @nogc:\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     private enum __SIGEV_MAX_SIZE = 64;\n \n@@ -3552,22 +2917,18 @@ version (CRuntime_Glibc)\n         int         sigev_signo;\n         int         sigev_notify;\n \n-        union _sigev_un_t\n+        union\n         {\n             int[__SIGEV_PAD_SIZE] _pad;\n             pid_t                 _tid;\n \n-            struct _sigev_thread_t\n+            struct\n             {\n-                void function(sigval)   _function;\n-                void*                   _attribute;\n-            } _sigev_thread_t _sigev_thread;\n-        } _sigev_un_t _sigev_un;\n+                void function(sigval) sigev_notify_function;\n+                void*                 sigev_notify_attributes;\n+            }\n+        }\n     }\n-\n-    int sigqueue(pid_t, int, const sigval);\n-    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n-    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n else version (FreeBSD)\n {\n@@ -3576,21 +2937,17 @@ else version (FreeBSD)\n         int             sigev_notify;\n         int             sigev_signo;\n         sigval          sigev_value;\n-        union  _sigev_un\n+        union\n         {\n             lwpid_t _threadid;\n-            struct _sigev_thread\n+            struct\n             {\n-                void function(sigval) _function;\n-                void* _attribute;\n+                void function(sigval) sigev_notify_function;\n+                void* sigev_notify_attributes;\n             }\n             c_long[8] __spare__;\n         }\n     }\n-\n-    int sigqueue(pid_t, int, const sigval);\n-    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n-    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n else version (NetBSD)\n {\n@@ -3602,10 +2959,6 @@ else version (NetBSD)\n         void function(sigval) sigev_notify_function;\n         void /* pthread_attr_t */*sigev_notify_attributes;\n     }\n-\n-    int sigqueue(pid_t, int, const sigval);\n-    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n-    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n else version (OpenBSD)\n {\n@@ -3634,10 +2987,6 @@ else version (DragonFlyBSD)\n         _sigval_t                 sigev_value;\n         void function(_sigval_t)  sigev_notify_function;\n     }\n-\n-    int sigqueue(pid_t, int, const sigval);\n-    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n-    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n else version (Darwin)\n {\n@@ -3661,84 +3010,68 @@ else version (Solaris)\n         pthread_attr_t* sigev_notify_attributes;\n         int __sigev_pad2;\n     }\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+int sigqueue(pid_t, int, const sigval);\n+int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n+int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n+*/\n+\n+nothrow:\n+@nogc:\n \n+version (CRuntime_Glibc)\n+{\n+    int sigqueue(pid_t, int, const sigval);\n+    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n+    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n+}\n+else version (FreeBSD)\n+{\n+    int sigqueue(pid_t, int, const sigval);\n+    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n+    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n+}\n+else version (NetBSD)\n+{\n+    int sigqueue(pid_t, int, const sigval);\n+    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n+    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n+}\n+else version (OpenBSD)\n+{\n+}\n+else version (DragonFlyBSD)\n+{\n+    int sigqueue(pid_t, int, const sigval);\n+    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n+    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n+}\n+else version (Darwin)\n+{\n+}\n+else version (Solaris)\n+{\n     int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n else version (CRuntime_Bionic)\n {\n-    private enum __ARCH_SIGEV_PREAMBLE_SIZE = (int.sizeof * 2) + sigval.sizeof;\n-    private enum SIGEV_MAX_SIZE = 64;\n-    private enum SIGEV_PAD_SIZE = (SIGEV_MAX_SIZE - __ARCH_SIGEV_PREAMBLE_SIZE)\n-                                  / int.sizeof;\n-\n-    struct sigevent\n-    {\n-        sigval      sigev_value;\n-        int         sigev_signo;\n-        int         sigev_notify;\n-\n-        union _sigev_un_t\n-        {\n-            int[SIGEV_PAD_SIZE] _pad;\n-            int                 _tid;\n-\n-            struct _sigev_thread_t\n-            {\n-                void function(sigval) _function;\n-                void*                 _attribute;\n-            } _sigev_thread_t _sigev_thread;\n-        } _sigev_un_t _sigev_un;\n-    }\n }\n else version (CRuntime_Musl)\n {\n-    struct sigevent\n-    {\n-        sigval sigev_value;\n-        int sigev_signo;\n-        int sigev_notify;\n-        void function(sigval) sigev_notify_function;\n-        pthread_attr_t *sigev_notify_attributes;\n-        char[56 - 3 * c_long.sizeof] __pad = void;\n-    }\n+    int sigqueue(pid_t, int, const sigval);\n+    int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n+    int sigwaitinfo(const scope sigset_t*, siginfo_t*);\n }\n else version (CRuntime_UClibc)\n {\n-    private enum __SIGEV_MAX_SIZE = 64;\n-\n-    static if ( __WORDSIZE == 64 )\n-    {\n-        private enum __SIGEV_PAD_SIZE = ((__SIGEV_MAX_SIZE / int.sizeof) - 4);\n-    }\n-    else\n-    {\n-        private enum __SIGEV_PAD_SIZE = ((__SIGEV_MAX_SIZE / int.sizeof) - 3);\n-    }\n-\n-    struct sigevent\n-    {\n-        sigval      sigev_value;\n-        int         sigev_signo;\n-        int         sigev_notify;\n-\n-        union _sigev_un_t\n-        {\n-            int[__SIGEV_PAD_SIZE] _pad;\n-            pid_t                 _tid;\n-\n-            struct _sigev_thread_t\n-            {\n-                void function(sigval)   _function;\n-                void*                   _attribute;\n-            } _sigev_thread_t _sigev_thread;\n-        } _sigev_un_t _sigev_un;\n-    }\n-\n-    @property void function(sigval) sigev_notify_function(ref sigevent _sigevent) { return _sigevent._sigev_un._sigev_thread._function; }\n-    @property void* sigev_notify_attributes(ref sigevent _sigevent) { return  _sigevent._sigev_un._sigev_thread._attribute; }\n-\n     int sigqueue(pid_t, int, const sigval);\n     int sigtimedwait(const scope sigset_t*, siginfo_t*, const scope timespec*);\n     int sigwaitinfo(const scope sigset_t*, siginfo_t*);"}, {"sha": "d48a0ea3edaf25bbfbb9f48bf3a469c21ff4329f", "filename": "libphobos/libdruntime/core/sys/posix/stdc/time.d", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdc%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdc%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdc%2Ftime.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -52,7 +52,27 @@ struct tm\n public import core.sys.posix.sys.types : time_t, clock_t;\n \n ///\n-version (OSX)\n+version (CRuntime_Glibc)\n+{\n+    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n+    clock_t clock();\n+}\n+else version (CRuntime_Musl)\n+{\n+    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n+    clock_t clock();\n+}\n+else version (CRuntime_Bionic)\n+{\n+    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n+    clock_t clock();\n+}\n+else version (CRuntime_UClibc)\n+{\n+    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n+    clock_t clock();\n+}\n+else version (OSX)\n {\n     enum clock_t CLOCKS_PER_SEC = 1_000_000; // was 100 until OSX 10.4/10.5\n     version (X86)\n@@ -90,26 +110,6 @@ else version (Solaris)\n     enum clock_t CLOCKS_PER_SEC = 1_000_000;\n     clock_t clock();\n }\n-else version (CRuntime_Glibc)\n-{\n-    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n-    clock_t clock();\n-}\n-else version (CRuntime_Musl)\n-{\n-    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n-    clock_t clock();\n-}\n-else version (CRuntime_Bionic)\n-{\n-    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n-    clock_t clock();\n-}\n-else version (CRuntime_UClibc)\n-{\n-    enum clock_t CLOCKS_PER_SEC = 1_000_000;\n-    clock_t clock();\n-}\n else\n {\n     static assert(0, \"unsupported system\");"}, {"sha": "077838d50aaf64cb6de6c49dc102da8aa5290b24", "filename": "libphobos/libdruntime/core/sys/posix/stdio.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdio.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -623,35 +623,35 @@ version (CRuntime_Glibc)\n {\n     enum P_tmpdir  = \"/tmp\";\n }\n-version (CRuntime_Musl)\n+else version (CRuntime_Musl)\n {\n     enum P_tmpdir  = \"/tmp\";\n }\n-version (Darwin)\n+else version (Darwin)\n {\n     enum P_tmpdir  = \"/var/tmp\";\n }\n-version (FreeBSD)\n+else version (FreeBSD)\n {\n     enum P_tmpdir  = \"/var/tmp/\";\n }\n-version (NetBSD)\n+else version (NetBSD)\n {\n     enum P_tmpdir  = \"/var/tmp/\";\n }\n-version (OpenBSD)\n+else version (OpenBSD)\n {\n     enum P_tmpdir  = \"/tmp/\";\n }\n-version (DragonFlyBSD)\n+else version (DragonFlyBSD)\n {\n     enum P_tmpdir  = \"/var/tmp/\";\n }\n-version (Solaris)\n+else version (Solaris)\n {\n     enum P_tmpdir  = \"/var/tmp/\";\n }\n-version (CRuntime_UClibc)\n+else version (CRuntime_UClibc)\n {\n     enum P_tmpdir  = \"/tmp\";\n }"}, {"sha": "36d1edc4ebc3702c33568a9495c51ca1e268c7f6", "filename": "libphobos/libdruntime/core/sys/posix/sys/ioctl.d", "status": "modified", "additions": 33, "deletions": 333, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioctl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioctl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fioctl.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -31,7 +31,7 @@ version (Posix):\n extern (C) nothrow @nogc:\n @system:\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     import core.sys.posix.termios; // tcflag_t, speed_t, cc_t\n \n@@ -326,8 +326,6 @@ version (CRuntime_Glibc)\n     enum SIOCDEVPRIVATE = 0x89F0;\n \n     enum SIOCPROTOPRIVATE = 0x89E0;\n-\n-    int ioctl(int __fd, c_ulong __request, ...);\n }\n else version (Darwin)\n {\n@@ -348,8 +346,6 @@ else version (Darwin)\n     enum uint TIOCSSIZE = TIOCSWINSZ;\n \n     public import core.sys.posix.sys.filio; // File related ioctls\n-\n-    int ioctl(int fildes, c_ulong request, ...);\n }\n else version (FreeBSD)\n {\n@@ -358,8 +354,6 @@ else version (FreeBSD)\n         int len;\n         void* buf;\n     }\n-\n-    int ioctl(int, c_ulong, ...);\n }\n else version (NetBSD)\n {\n@@ -370,8 +364,6 @@ else version (NetBSD)\n         ushort ws_xpixel;\n         ushort ws_ypixel;\n     }\n-\n-    int ioctl(int, c_ulong, ...);\n }\n else version (OpenBSD)\n {\n@@ -389,8 +381,6 @@ else version (OpenBSD)\n     }\n \n     public import core.sys.posix.sys.filio; // File related ioctls\n-\n-    int ioctl(int, c_ulong, ...);\n }\n else version (DragonFlyBSD)\n {\n@@ -407,7 +397,38 @@ else version (DragonFlyBSD)\n         ushort ws_xpixel;\n         ushort ws_ypixel;\n     }\n+}\n+else version (Solaris)\n+{\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n \n+///\n+version (CRuntime_Glibc)\n+{\n+    int ioctl(int __fd, c_ulong __request, ...);\n+}\n+else version (Darwin)\n+{\n+    int ioctl(int fildes, c_ulong request, ...);\n+}\n+else version (FreeBSD)\n+{\n+    int ioctl(int, c_ulong, ...);\n+}\n+else version (NetBSD)\n+{\n+    int ioctl(int, c_ulong, ...);\n+}\n+else version (OpenBSD)\n+{\n+    int ioctl(int, c_ulong, ...);\n+}\n+else version (DragonFlyBSD)\n+{\n     int ioctl(int, c_ulong, ...);\n }\n else version (Solaris)\n@@ -420,331 +441,10 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n-\n+    int ioctl(int, int, ...);\n }\n else version (CRuntime_UClibc)\n {\n-    import core.sys.posix.termios;\n-\n-    enum _IOC_NRBITS = 8;\n-    enum _IOC_TYPEBITS = 8;\n-    enum _IOC_SIZEBITS = 14;\n-    enum _IOC_DIRBITS = 2;\n-\n-    enum _IOC_NRMASK = (1 << _IOC_NRBITS) - 1;\n-    enum _IOC_TYPEMASK = (1 << _IOC_TYPEBITS) - 1;\n-    enum _IOC_SIZEMASK = (1 << _IOC_SIZEBITS) - 1;\n-    enum _IOC_DIRMASK = (1 << _IOC_DIRBITS) - 1;\n-\n-    enum _IOC_NRSHIFT = 0;\n-    enum _IOC_TYPESHIFT = _IOC_NRSHIFT + _IOC_NRBITS;\n-    enum _IOC_SIZESHIFT = _IOC_TYPESHIFT + _IOC_TYPEBITS;\n-    enum _IOC_DIRSHIFT = _IOC_SIZESHIFT + _IOC_SIZEBITS;\n-\n-    enum _IOC_NONE = 0;\n-    enum _IOC_WRITE = 1;\n-    enum _IOC_READ = 2;\n-\n-    extern (D) int _IOC(T = typeof(null))(int dir, int type, int nr)\n-    {\n-        return (dir << _IOC_DIRSHIFT) |\n-               (type << _IOC_TYPESHIFT) |\n-               (nr << _IOC_NRSHIFT) |\n-               (is(T == typeof(null)) ? 0 : T.sizeof << _IOC_SIZESHIFT);\n-    }\n-\n-    extern (D) int _IO(int type, int nr)\n-    {\n-        return _IOC(_IOC_NONE, type, nr);\n-    }\n-\n-    extern (D) int _IOR(T)(int type, int nr)\n-    {\n-        return _IOC!T(_IOC_READ, type, nr);\n-    }\n-\n-    extern (D) int _IOW(T)(int type, int nr)\n-    {\n-        return _IOC!T(_IOC_WRITE, type, nr);\n-    }\n-\n-    extern (D) int _IOWR(T)(int type, int nr)\n-    {\n-        return _IOC!T(_IOC_READ | _IOC_WRITE, type, nr);\n-    }\n-\n-    extern (D) int _IOR_BAD(T)(int type, int nr)\n-    {\n-        return _IOC!T(_IOC_READ, type, nr);\n-    }\n-\n-    extern (D) int _IOW_BAD(T)(int type, int nr)\n-    {\n-        return _IOC!T(_IOC_WRITE, type, nr);\n-    }\n-\n-    extern (D) int _IORW_BAD(T)(int type, int nr)\n-    {\n-        return _IOC!T(_IOC_READ | _IOC_WRITE, type, nr);\n-    }\n-\n-    extern (D) int _IOC_DIR(int nr)\n-    {\n-        return (nr >> _IOC_DIRSHIFT) & _IOC_DIRMASK;\n-    }\n-\n-    extern (D) int _IOC_TYPE(int nr)\n-    {\n-        return (nr >> _IOC_TYPESHIFT) & _IOC_TYPEMASK;\n-    }\n-\n-    extern (D) int _IOC_NR(int nr)\n-    {\n-        return (nr >> _IOC_NRSHIFT) & _IOC_NRMASK;\n-    }\n-\n-    extern (D) int _IOC_SIZE(int nr)\n-    {\n-        return (nr >> _IOC_SIZESHIFT) & _IOC_SIZEMASK;\n-    }\n-\n-    enum IOC_IN = _IOC_WRITE << _IOC_DIRSHIFT;\n-    enum IOC_OUT = _IOC_READ << _IOC_DIRSHIFT;\n-    enum IOC_INOUT = (_IOC_READ | _IOC_WRITE) << _IOC_DIRSHIFT;\n-    enum IOCSIZE_MASK = _IOC_SIZEMASK << _IOC_DIRSHIFT;\n-    enum IOCSIZE_SHIFT = _IOC_SIZESHIFT;\n-\n-    enum NCCS = 19;\n-\n-    struct termios\n-    {\n-        tcflag_t c_iflag;\n-        tcflag_t c_oflag;\n-        tcflag_t c_cflag;\n-        tcflag_t c_lflag;\n-        cc_t c_line;\n-        cc_t[NCCS] c_cc;\n-    }\n-\n-    struct termios2\n-    {\n-        tcflag_t c_iflag;\n-        tcflag_t c_oflag;\n-        tcflag_t c_cflag;\n-        tcflag_t c_lflag;\n-        cc_t c_line;\n-        cc_t[NCCS] c_cc;\n-        speed_t c_ispeed;\n-        speed_t c_ospeed;\n-    }\n-\n-    alias termios2 ktermios;\n-\n-    struct winsize\n-    {\n-        ushort ws_row;\n-        ushort ws_col;\n-        ushort ws_xpixel;\n-        ushort ws_ypixel;\n-    }\n-\n-    enum NCC = 8;\n-\n-    struct termio\n-    {\n-        ushort c_iflag;\n-        ushort c_oflag;\n-        ushort c_cflag;\n-        ushort c_lflag;\n-        ubyte c_line;\n-        ubyte[NCC] c_cc;\n-    }\n-\n-    enum TIOCM_LE = 0x001;\n-    enum TIOCM_DTR = 0x002;\n-    enum TIOCM_RTS = 0x004;\n-    enum TIOCM_ST = 0x008;\n-    enum TIOCM_SR = 0x010;\n-    enum TIOCM_CTS = 0x020;\n-    enum TIOCM_CAR = 0x040;\n-    enum TIOCM_RNG = 0x080;\n-    enum TIOCM_DSR = 0x100;\n-    enum TIOCM_CD = TIOCM_CAR;\n-    enum TIOCM_RI = TIOCM_RNG;\n-\n-    enum N_TTY = 0;\n-    enum N_SLIP = 1;\n-    enum N_MOUSE = 2;\n-    enum N_PPP = 3;\n-    enum N_STRIP = 4;\n-    enum N_AX25 = 5;\n-    enum N_X25 = 6;\n-    enum N_6PACK = 7;\n-    enum N_MASC = 8;\n-    enum N_R3964 = 9;\n-    enum N_PROFIBUS_FDL = 10;\n-    enum N_IRDA = 11;\n-    enum N_SMSBLOCK = 12;\n-    enum N_HDLC = 13;\n-    enum N_SYNC_PPP = 14;\n-    enum N_HCI = 15;\n-\n-    enum TCGETS = 0x5401;\n-    enum TCSETS = 0x5402;\n-    enum TCSETSW = 0x5403;\n-    enum TCSETSF = 0x5404;\n-    enum TCGETA = 0x5405;\n-    enum TCSETA = 0x5406;\n-    enum TCSETAW = 0x5407;\n-    enum TCSETAF = 0x5408;\n-    enum TCSBRK = 0x5409;\n-    enum TCXONC = 0x540A;\n-    enum TCFLSH = 0x540B;\n-    enum TIOCEXCL = 0x540C;\n-    enum TIOCNXCL = 0x540D;\n-    enum TIOCSCTTY = 0x540E;\n-    enum TIOCGPGRP = 0x540F;\n-    enum TIOCSPGRP = 0x5410;\n-    enum TIOCOUTQ = 0x5411;\n-    enum TIOCSTI = 0x5412;\n-    enum TIOCGWINSZ = 0x5413;\n-    enum TIOCSWINSZ = 0x5414;\n-    enum TIOCMGET = 0x5415;\n-    enum TIOCMBIS = 0x5416;\n-    enum TIOCMBIC = 0x5417;\n-    enum TIOCMSET = 0x5418;\n-    enum TIOCGSOFTCAR = 0x5419;\n-    enum TIOCSSOFTCAR = 0x541A;\n-    enum FIONREAD = 0x541B;\n-    enum TIOCINQ = FIONREAD;\n-    enum TIOCLINUX = 0x541C;\n-    enum TIOCCONS = 0x541D;\n-    enum TIOCGSERIAL = 0x541E;\n-    enum TIOCSSERIAL = 0x541F;\n-    enum TIOCPKT = 0x5420;\n-    enum FIONBIO = 0x5421;\n-    enum TIOCNOTTY = 0x5422;\n-    enum TIOCSETD = 0x5423;\n-    enum TIOCGETD = 0x5424;\n-    enum TCSBRKP = 0x5425;\n-    enum TIOCSBRK = 0x5427;\n-    enum TIOCCBRK = 0x5428;\n-    enum TIOCGSID = 0x5429;\n-\n-    enum TCGETS2 = _IOR!termios2('T', 0x2A);\n-    enum TCSETS2 = _IOW!termios2('T', 0x2B);\n-    enum TCSETSW2 = _IOW!termios2('T', 0x2C);\n-    enum TCSETSF2 = _IOW!termios2('T', 0x2D);\n-\n-    enum TIOCGRS485 = 0x542E;\n-    enum TIOCSRS485 = 0x542F;\n-\n-    enum TIOCGPTN   = _IOR!uint('T', 0x30);\n-    enum TIOCSPTLCK = _IOW!int('T', 0x31);\n-    enum TIOCGDEV   = _IOR!uint('T', 0x32);\n-\n-    enum TCGETX = 0x5432;\n-    enum TCSETX = 0x5433;\n-    enum TCSETXF = 0x5434;\n-    enum TCSETXW = 0x5435;\n-\n-    enum TIOCSIG = _IOW!int('T', 0x36);\n-\n-    enum TIOCVHANGUP = 0x5437;\n-\n-    enum FIONCLEX = 0x5450;\n-    enum FIOCLEX = 0x5451;\n-    enum FIOASYNC = 0x5452;\n-    enum TIOCSERCONFIG = 0x5453;\n-    enum TIOCSERGWILD = 0x5454;\n-    enum TIOCSERSWILD = 0x5455;\n-    enum TIOCGLCKTRMIOS = 0x5456;\n-    enum TIOCSLCKTRMIOS = 0x5457;\n-    enum TIOCSERGSTRUCT = 0x5458;\n-    enum TIOCSERGETLSR = 0x5459;\n-    enum TIOCSERGETMULTI = 0x545A;\n-    enum TIOCSERSETMULTI = 0x545B;\n-\n-    enum TIOCMIWAIT = 0x545C;\n-    enum TIOCGICOUNT = 0x545D;\n-\n-    enum FIOQSIZE = 0x5460;\n-\n-    enum TIOCPKT_DATA = 0;\n-    enum TIOCPKT_FLUSHREAD = 1;\n-    enum TIOCPKT_FLUSHWRITE = 2;\n-    enum TIOCPKT_STOP = 4;\n-    enum TIOCPKT_START = 8;\n-    enum TIOCPKT_NOSTOP = 16;\n-    enum TIOCPKT_DOSTOP = 32;\n-    enum TIOCPKT_IOCTL = 64;\n-\n-    enum TIOCSER_TEMT = 0x01;\n-\n-    enum SIOCADDRT = 0x890B;\n-    enum SIOCDELRT = 0x890C;\n-    enum SIOCRTMSG = 0x890D;\n-\n-    enum SIOCGIFNAME = 0x8910;\n-    enum SIOCSIFLINK = 0x8911;\n-    enum SIOCGIFCONF = 0x8912;\n-    enum SIOCGIFFLAGS = 0x8913;\n-    enum SIOCSIFFLAGS = 0x8914;\n-    enum SIOCGIFADDR = 0x8915;\n-    enum SIOCSIFADDR = 0x8916;\n-    enum SIOCGIFDSTADDR = 0x8917;\n-    enum SIOCSIFDSTADDR = 0x8918;\n-    enum SIOCGIFBRDADDR = 0x8919;\n-    enum SIOCSIFBRDADDR = 0x891a;\n-    enum SIOCGIFNETMASK = 0x891b;\n-    enum SIOCSIFNETMASK = 0x891c;\n-    enum SIOCGIFMETRIC = 0x891d;\n-    enum SIOCSIFMETRIC = 0x891e;\n-    enum SIOCGIFMEM = 0x891f;\n-    enum SIOCSIFMEM = 0x8920;\n-    enum SIOCGIFMTU = 0x8921;\n-    enum SIOCSIFMTU = 0x8922;\n-    enum SIOCSIFNAME = 0x8923;\n-    enum SIOCSIFHWADDR = 0x8924;\n-    enum SIOCGIFENCAP = 0x8925;\n-    enum SIOCSIFENCAP = 0x8926;\n-    enum SIOCGIFHWADDR = 0x8927;\n-    enum SIOCGIFSLAVE = 0x8929;\n-    enum SIOCSIFSLAVE = 0x8930;\n-    enum SIOCADDMULTI = 0x8931;\n-    enum SIOCDELMULTI = 0x8932;\n-    enum SIOCGIFINDEX = 0x8933;\n-    enum SIOGIFINDEX = SIOCGIFINDEX;\n-    enum SIOCSIFPFLAGS = 0x8934;\n-    enum SIOCGIFPFLAGS = 0x8935;\n-    enum SIOCDIFADDR = 0x8936;\n-    enum SIOCSIFHWBROADCAST = 0x8937;\n-    enum SIOCGIFCOUNT = 0x8938;\n-\n-    enum SIOCGIFBR = 0x8940;\n-    enum SIOCSIFBR = 0x8941;\n-\n-    enum SIOCGIFTXQLEN = 0x8942;\n-    enum SIOCSIFTXQLEN = 0x8943;\n-\n-    enum SIOCDARP = 0x8953;\n-    enum SIOCGARP = 0x8954;\n-    enum SIOCSARP = 0x8955;\n-\n-    enum SIOCDRARP = 0x8960;\n-    enum SIOCGRARP = 0x8961;\n-    enum SIOCSRARP = 0x8962;\n-\n-    enum SIOCGIFMAP = 0x8970;\n-    enum SIOCSIFMAP = 0x8971;\n-\n-    enum SIOCADDDLCI = 0x8980;\n-    enum SIOCDELDLCI = 0x8981;\n-\n-    enum SIOCDEVPRIVATE = 0x89F0;\n-\n-    enum SIOCPROTOPRIVATE = 0x89E0;\n-\n     int ioctl(int __fd, c_ulong __request, ...);\n }\n else"}, {"sha": "18a6cbd4d530f2f9cca51498f14cf5de8c5eb2b2", "filename": "libphobos/libdruntime/core/sys/posix/sys/ipc.d", "status": "modified", "additions": 40, "deletions": 76, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fipc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fipc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fipc.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -52,11 +52,9 @@ IPC_PRIVATE\n IPC_RMID\n IPC_SET\n IPC_STAT\n-\n-key_t ftok(const scope char*, int);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     struct ipc_perm\n     {\n@@ -82,8 +80,6 @@ version (CRuntime_Glibc)\n     enum IPC_RMID       = 0;\n     enum IPC_SET        = 1;\n     enum IPC_STAT       = 2;\n-\n-    key_t ftok(const scope char*, int);\n }\n else version (Darwin)\n {\n@@ -122,8 +118,6 @@ else version (FreeBSD)\n     enum IPC_RMID       = 0;\n     enum IPC_SET        = 1;\n     enum IPC_STAT       = 2;\n-\n-    key_t ftok(const scope char*, int);\n }\n else version (NetBSD)\n {\n@@ -147,8 +141,6 @@ else version (NetBSD)\n     enum IPC_RMID       = 0;\n     enum IPC_SET        = 1;\n     enum IPC_STAT       = 2;\n-\n-    key_t ftok(const scope char*, int);\n }\n else version (OpenBSD)\n {\n@@ -172,8 +164,6 @@ else version (OpenBSD)\n     enum IPC_RMID       = 0;\n     enum IPC_SET        = 1;\n     enum IPC_STAT       = 2;\n-\n-    key_t ftok(const scope char*, int);\n }\n else version (DragonFlyBSD)\n {\n@@ -197,79 +187,53 @@ else version (DragonFlyBSD)\n     enum IPC_RMID       = 0;\n     enum IPC_SET        = 1;\n     enum IPC_STAT       = 2;\n-\n-    key_t ftok(const scope char*, int);\n }\n-else version (CRuntime_Bionic)\n+else\n {\n-    // All except ftok are from the linux kernel headers. Latest Bionic headers\n-    // don't use this legacy definition anymore, consider updating.\n-    version (D_LP64)\n-    {\n-        struct ipc_perm\n-        {\n-            key_t   key;\n-            uint    uid;\n-            uint    gid;\n-            uint    cuid;\n-            uint    cgid;\n-            mode_t  mode;\n-            ushort  seq;\n-        }\n-    }\n-    else\n-    {\n-        struct ipc_perm\n-        {\n-            key_t   key;\n-            ushort  uid;\n-            ushort  gid;\n-            ushort  cuid;\n-            ushort  cgid;\n-            mode_t  mode;\n-            ushort  seq;\n-        }\n-    }\n-\n-    enum IPC_CREAT      = 0x0200; // 01000\n-    enum IPC_EXCL       = 0x0400; // 02000\n-    enum IPC_NOWAIT     = 0x0800; // 04000\n+    static assert(false, \"Unsupported platform\");\n+}\n \n-    enum key_t IPC_PRIVATE = 0;\n+/*\n+key_t ftok(const scope char*, int);\n+*/\n \n-    enum IPC_RMID       = 0;\n-    enum IPC_SET        = 1;\n-    enum IPC_STAT       = 2;\n+version (CRuntime_Glibc)\n+{\n+    key_t ftok(const scope char*, int);\n+}\n+else version (Darwin)\n+{\n \n+}\n+else version (FreeBSD)\n+{\n+    key_t ftok(const scope char*, int);\n+}\n+else version (NetBSD)\n+{\n+    key_t ftok(const scope char*, int);\n+}\n+else version (OpenBSD)\n+{\n+    key_t ftok(const scope char*, int);\n+}\n+else version (DragonFlyBSD)\n+{\n+    key_t ftok(const scope char*, int);\n+}\n+else version (CRuntime_Bionic)\n+{\n+    key_t ftok(const scope char*, int);\n+}\n+else version (CRuntime_Musl)\n+{\n     key_t ftok(const scope char*, int);\n }\n else version (CRuntime_UClibc)\n {\n-    struct ipc_perm\n-    {\n-        key_t   __key;\n-        uid_t   uid;\n-        gid_t   gid;\n-        uid_t   cuid;\n-        gid_t   cgid;\n-        ushort  mode;\n-        ushort  __pad1;\n-        ushort  __seq;\n-        ushort  __pad2;\n-        c_ulong __unused1;\n-        c_ulong __unused2;\n-    }\n-\n-    enum IPC_CREAT      = 0x0200; // 01000\n-    enum IPC_EXCL       = 0x0400; // 02000\n-    enum IPC_NOWAIT     = 0x0800; // 04000\n-\n-    enum key_t IPC_PRIVATE = 0;\n-\n-    enum IPC_RMID       = 0;\n-    enum IPC_SET        = 1;\n-    enum IPC_STAT       = 2;\n-    enum IPC_INFO       = 3;\n-\n     key_t ftok(const scope char*, int);\n }\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}"}, {"sha": "33ce88feb4e7c097b3ae29b6efe754759000d630", "filename": "libphobos/libdruntime/core/sys/posix/sys/mman.d", "status": "modified", "additions": 135, "deletions": 173, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fmman.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fmman.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fmman.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -54,6 +54,53 @@ extern (C) nothrow @nogc:\n int posix_madvise(void*, size_t, int);\n */\n \n+version (CRuntime_Glibc)\n+{\n+    static if (__USE_XOPEN2K)\n+    {\n+        int posix_madvise(void *__addr, size_t __len, int __advice);\n+    }\n+}\n+else version (Darwin)\n+{\n+    int posix_madvise(void *addr, size_t len, int advice);\n+}\n+else version (FreeBSD)\n+{\n+    int posix_madvise(void *addr, size_t len, int advice);\n+}\n+else version (NetBSD)\n+{\n+    int posix_madvise(void *addr, size_t len, int advice);\n+}\n+else version (OpenBSD)\n+{\n+    int posix_madvise(void *addr, size_t len, int advice);\n+}\n+else version (DragonFlyBSD)\n+{\n+    int posix_madvise(void *addr, size_t len, int advice);\n+}\n+else version (Solaris)\n+{\n+}\n+else version (CRuntime_Bionic)\n+{\n+}\n+else version (CRuntime_Musl)\n+{\n+    int posix_madvise(void *, size_t, int);\n+}\n+else version (CRuntime_UClibc)\n+{\n+    int posix_madvise(void *__addr, size_t __len, int __advice);\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+\n //\n // Advisory Information and either Memory Mapped Files or Shared Memory Objects (MC1)\n //\n@@ -65,24 +112,20 @@ POSIX_MADV_WILLNEED\n POSIX_MADV_DONTNEED\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     version (Alpha)\n         private enum __POSIX_MADV_DONTNEED = 6;\n     else\n         private enum __POSIX_MADV_DONTNEED = 4;\n \n-    static if (__USE_XOPEN2K)\n+    enum\n     {\n-        enum\n-        {\n-            POSIX_MADV_NORMAL = 0,\n-            POSIX_MADV_RANDOM = 1,\n-            POSIX_MADV_SEQUENTIAL = 2,\n-            POSIX_MADV_WILLNEED = 3,\n-            POSIX_MADV_DONTNEED = __POSIX_MADV_DONTNEED,\n-        }\n-        int posix_madvise(void *__addr, size_t __len, int __advice);\n+        POSIX_MADV_NORMAL = 0,\n+        POSIX_MADV_RANDOM = 1,\n+        POSIX_MADV_SEQUENTIAL = 2,\n+        POSIX_MADV_WILLNEED = 3,\n+        POSIX_MADV_DONTNEED = __POSIX_MADV_DONTNEED,\n     }\n }\n else version (Darwin)\n@@ -92,7 +135,6 @@ else version (Darwin)\n     enum POSIX_MADV_SEQUENTIAL  = 2;\n     enum POSIX_MADV_WILLNEED    = 3;\n     enum POSIX_MADV_DONTNEED    = 4;\n-    int posix_madvise(void *addr, size_t len, int advice);\n }\n else version (FreeBSD)\n {\n@@ -101,7 +143,6 @@ else version (FreeBSD)\n     enum POSIX_MADV_SEQUENTIAL  = 2;\n     enum POSIX_MADV_WILLNEED    = 3;\n     enum POSIX_MADV_DONTNEED    = 4;\n-    int posix_madvise(void *addr, size_t len, int advice);\n }\n else version (NetBSD)\n {\n@@ -110,7 +151,6 @@ else version (NetBSD)\n     enum POSIX_MADV_SEQUENTIAL  = 2;\n     enum POSIX_MADV_WILLNEED    = 3;\n     enum POSIX_MADV_DONTNEED    = 4;\n-    int posix_madvise(void *addr, size_t len, int advice);\n }\n else version (OpenBSD)\n {\n@@ -119,7 +159,6 @@ else version (OpenBSD)\n     enum POSIX_MADV_SEQUENTIAL  = 2;\n     enum POSIX_MADV_WILLNEED    = 3;\n     enum POSIX_MADV_DONTNEED    = 4;\n-    int posix_madvise(void *addr, size_t len, int advice);\n }\n else version (DragonFlyBSD)\n {\n@@ -128,38 +167,10 @@ else version (DragonFlyBSD)\n     enum POSIX_MADV_SEQUENTIAL  = 2;\n     enum POSIX_MADV_WILLNEED    = 3;\n     enum POSIX_MADV_DONTNEED    = 4;\n-    int posix_madvise(void *addr, size_t len, int advice);\n }\n else version (Solaris)\n {\n }\n-else version (CRuntime_Bionic)\n-{\n-}\n-else version (CRuntime_Musl)\n-{\n-    enum\n-    {\n-        POSIX_MADV_NORMAL = 0,\n-        POSIX_MADV_RANDOM = 1,\n-        POSIX_MADV_SEQUENTIAL = 2,\n-        POSIX_MADV_WILLNEED = 3,\n-        POSIX_MADV_DONTNEED = 4,\n-    }\n-    int posix_madvise(void *, size_t, int);\n-}\n-else version (CRuntime_UClibc)\n-{\n-    enum\n-    {\n-        POSIX_MADV_NORMAL = 0,\n-        POSIX_MADV_RANDOM = 1,\n-        POSIX_MADV_SEQUENTIAL = 2,\n-        POSIX_MADV_WILLNEED = 3,\n-        POSIX_MADV_DONTNEED = 4,\n-    }\n-    int posix_madvise(void *__addr, size_t __len, int __advice);\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");\n@@ -175,7 +186,7 @@ PROT_EXEC\n PROT_NONE\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum PROT_NONE      = 0x0;\n     enum PROT_READ      = 0x1;\n@@ -224,27 +235,6 @@ else version (Solaris)\n     enum PROT_WRITE = 0x02;\n     enum PROT_EXEC = 0x04;\n }\n-else version (CRuntime_Bionic)\n-{\n-    enum PROT_NONE = 0x00;\n-    enum PROT_READ = 0x01;\n-    enum PROT_WRITE = 0x02;\n-    enum PROT_EXEC = 0x04;\n-}\n-else version (CRuntime_Musl)\n-{\n-    enum PROT_NONE      = 0x0;\n-    enum PROT_READ      = 0x1;\n-    enum PROT_WRITE     = 0x2;\n-    enum PROT_EXEC      = 0x4;\n-}\n-else version (CRuntime_UClibc)\n-{\n-    enum PROT_NONE      = 0x0;\n-    enum PROT_READ      = 0x1;\n-    enum PROT_WRITE     = 0x2;\n-    enum PROT_EXEC      = 0x4;\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");\n@@ -337,11 +327,9 @@ MAP_FAILED (MF|SHM)\n MS_ASYNC (MF|SIO)\n MS_SYNC (MF|SIO)\n MS_INVALIDATE (MF|SIO)\n-\n-int msync(void*, size_t, int); (MF|SIO)\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum MAP_SHARED     = 0x01;\n     enum MAP_PRIVATE    = 0x02;\n@@ -405,8 +393,6 @@ version (CRuntime_Glibc)\n         enum MS_INVALIDATE = 2;\n         enum MS_SYNC = 4;\n     }\n-\n-    int msync(void*, size_t, int);\n }\n else version (Darwin)\n {\n@@ -420,8 +406,6 @@ else version (Darwin)\n     enum MS_ASYNC       = 0x0001;\n     enum MS_INVALIDATE  = 0x0002;\n     enum MS_SYNC        = 0x0010;\n-\n-    int msync(void*, size_t, int);\n }\n else version (FreeBSD)\n {\n@@ -435,8 +419,6 @@ else version (FreeBSD)\n     enum MS_SYNC        = 0x0000;\n     enum MS_ASYNC       = 0x0001;\n     enum MS_INVALIDATE  = 0x0002;\n-\n-    int msync(void*, size_t, int);\n }\n else version (NetBSD)\n {\n@@ -450,9 +432,6 @@ else version (NetBSD)\n     enum MS_SYNC        = 0x0004;\n     enum MS_ASYNC       = 0x0001;\n     enum MS_INVALIDATE  = 0x0002;\n-\n-    int __msync13(void*, size_t, int);\n-    alias msync = __msync13;\n }\n else version (OpenBSD)\n {\n@@ -467,8 +446,6 @@ else version (OpenBSD)\n     enum MS_SYNC        = 0x0002;\n     enum MS_ASYNC       = 0x0001;\n     enum MS_INVALIDATE  = 0x0004;\n-\n-    int msync(void*, size_t, int);\n }\n else version (DragonFlyBSD)\n {\n@@ -482,8 +459,6 @@ else version (DragonFlyBSD)\n     enum MS_SYNC        = 0x0000;\n     enum MS_ASYNC       = 0x0001;\n     enum MS_INVALIDATE  = 0x0002;\n-\n-    int msync(void*, size_t, int);\n }\n else version (Solaris)\n {\n@@ -497,72 +472,55 @@ else version (Solaris)\n     enum MS_SYNC = 0x0004;\n     enum MS_ASYNC = 0x0001;\n     enum MS_INVALIDATE  = 0x0002;\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+int msync(void*, size_t, int); (MF|SIO)\n+*/\n \n+version (CRuntime_Glibc)\n+{\n+    int msync(void*, size_t, int);\n+}\n+else version (Darwin)\n+{\n+    int msync(void*, size_t, int);\n+}\n+else version (FreeBSD)\n+{\n+    int msync(void*, size_t, int);\n+}\n+else version (NetBSD)\n+{\n+    int __msync13(void*, size_t, int);\n+    alias msync = __msync13;\n+}\n+else version (OpenBSD)\n+{\n+    int msync(void*, size_t, int);\n+}\n+else version (DragonFlyBSD)\n+{\n+    int msync(void*, size_t, int);\n+}\n+else version (Solaris)\n+{\n     int msync(void*, size_t, int);\n }\n else version (CRuntime_Bionic)\n {\n-    enum MAP_SHARED     = 0x0001;\n-    enum MAP_PRIVATE    = 0x0002;\n-    enum MAP_FIXED      = 0x0010;\n-    enum MAP_ANON       = 0x0020;\n-\n-    enum MAP_FAILED     = cast(void*)-1;\n-\n-    enum MS_SYNC        = 4;\n-    enum MS_ASYNC       = 1;\n-    enum MS_INVALIDATE  = 2;\n-\n     int msync(const scope void*, size_t, int);\n }\n else version (CRuntime_Musl)\n {\n-    enum MAP_SHARED     = 0x01;\n-    enum MAP_PRIVATE    = 0x02;\n-    enum MAP_FIXED      = 0x10;\n-\n-    enum MAP_FAILED     = cast(void*) -1;\n-    enum MAP_ANON = 0x20;\n-    enum MS_ASYNC = 1;\n-    enum MS_INVALIDATE = 2;\n-    enum MS_SYNC = 4;\n     int msync(void*, size_t, int);\n }\n else version (CRuntime_UClibc)\n {\n-    enum MAP_SHARED     = 0x01;\n-    enum MAP_PRIVATE    = 0x02;\n-    enum MAP_FIXED      = 0x10;\n-\n-    enum MAP_FAILED     = cast(void*) -1;\n-\n-    version (X86_64)\n-    {\n-        enum MAP_ANON       = 0x20;\n-        enum MS_ASYNC       = 1;\n-        enum MS_INVALIDATE  = 2;\n-        enum MS_SYNC        = 4;\n-    }\n-    else version (MIPS32)\n-    {\n-        enum MAP_ANON       = 0x0800;\n-        enum MS_ASYNC       = 1;\n-        enum MS_INVALIDATE  = 2;\n-        enum MS_SYNC        = 4;\n-    }\n-    else version (ARM)\n-    {\n-        enum MAP_ANON       = 0x020;\n-        enum MS_ASYNC       = 1;\n-        enum MS_INVALIDATE  = 2;\n-        enum MS_SYNC        = 4;\n-    }\n-    else\n-    {\n-        static assert(false, \"Architecture not supported.\");\n-    }\n-\n-\n     int msync(void*, size_t, int);\n }\n else\n@@ -576,12 +534,9 @@ else\n /*\n MCL_CURRENT\n MCL_FUTURE\n-\n-int mlockall(int);\n-int munlockall();\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     version (SPARC_Any) enum\n     {\n@@ -603,89 +558,96 @@ version (CRuntime_Glibc)\n         MCL_CURRENT = 1,\n         MCL_FUTURE = 2,\n     }\n-\n-    int mlockall(int);\n-    int munlockall();\n-\n }\n else version (Darwin)\n {\n     enum MCL_CURRENT    = 0x0001;\n     enum MCL_FUTURE     = 0x0002;\n-\n-    int mlockall(int);\n-    int munlockall();\n }\n else version (FreeBSD)\n {\n     enum MCL_CURRENT    = 0x0001;\n     enum MCL_FUTURE     = 0x0002;\n-\n-    int mlockall(int);\n-    int munlockall();\n }\n else version (NetBSD)\n {\n     enum MCL_CURRENT    = 0x0001;\n     enum MCL_FUTURE     = 0x0002;\n-\n-    int mlockall(int);\n-    int munlockall();\n }\n else version (OpenBSD)\n {\n     enum MCL_CURRENT    = 0x0001;\n     enum MCL_FUTURE     = 0x0002;\n-\n-    int mlockall(int);\n-    int munlockall();\n }\n else version (DragonFlyBSD)\n {\n     enum MCL_CURRENT    = 0x0001;\n     enum MCL_FUTURE     = 0x0002;\n-\n-    int mlockall(int);\n-    int munlockall();\n }\n else version (Solaris)\n {\n     enum MCL_CURRENT = 0x0001;\n     enum MCL_FUTURE = 0x0002;\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n \n+/*\n+int mlockall(int);\n+int munlockall();\n+*/\n+\n+version (CRuntime_Glibc)\n+{\n+    int mlockall(int);\n+    int munlockall();\n+}\n+else version (Darwin)\n+{\n+    int mlockall(int);\n+    int munlockall();\n+}\n+else version (FreeBSD)\n+{\n+    int mlockall(int);\n+    int munlockall();\n+}\n+else version (NetBSD)\n+{\n+    int mlockall(int);\n+    int munlockall();\n+}\n+else version (OpenBSD)\n+{\n+    int mlockall(int);\n+    int munlockall();\n+}\n+else version (DragonFlyBSD)\n+{\n+    int mlockall(int);\n+    int munlockall();\n+}\n+else version (Solaris)\n+{\n     int mlockall(int);\n     int munlockall();\n }\n else version (CRuntime_Bionic)\n {\n-    enum MCL_CURRENT = 1;\n-    enum MCL_FUTURE  = 2;\n-\n     int mlockall(int);\n     int munlockall();\n }\n else version (CRuntime_Musl)\n {\n-    enum\n-    {\n-        MCL_CURRENT = 1,\n-        MCL_FUTURE = 2,\n-    }\n-\n     int mlockall(int);\n     int munlockall();\n }\n else version (CRuntime_UClibc)\n {\n-    enum\n-    {\n-        MCL_CURRENT = 1,\n-        MCL_FUTURE = 2,\n-    }\n-\n     int mlockall(int);\n     int munlockall();\n-\n }\n else\n {"}, {"sha": "5ab01744067e8fa67d866d6412cc27978f72363b", "filename": "libphobos/libdruntime/core/sys/posix/sys/resource.d", "status": "modified", "additions": 57, "deletions": 218, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fresource.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fresource.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fresource.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -52,12 +52,6 @@ enum\n     RUSAGE_CHILDREN,\n }\n \n-struct rlimit\n-{\n-    rlim_t rlim_cur;\n-    rlim_t rlim_max;\n-}\n-\n struct rusage\n {\n     timeval ru_utime;\n@@ -74,19 +68,10 @@ enum\n     RLIMIT_STACK,\n     RLIMIT_AS,\n }\n-\n-int getpriority(int, id_t);\n-int getrlimit(int, rlimit*);\n-int getrusage(int, rusage*);\n-int setpriority(int, id_t, int);\n-int setrlimit(int, const rlimit*);\n */\n \n-\n-version (CRuntime_Glibc)\n+version (linux)\n {\n-    // rusage and some other constants in the Bionic section below really\n-    // come from the linux kernel headers, but they're all mixed right now.\n     enum\n     {\n         PRIO_PROCESS = 0,\n@@ -111,6 +96,7 @@ version (CRuntime_Glibc)\n     {\n         RUSAGE_SELF     =  0,\n         RUSAGE_CHILDREN = -1,\n+        RUSAGE_THREAD = 1\n     }\n \n     struct rusage\n@@ -131,6 +117,8 @@ version (CRuntime_Glibc)\n         c_long ru_nsignals;\n         c_long ru_nvcsw;\n         c_long ru_nivcsw;\n+        version (CRuntime_Musl)\n+            c_long[16] __reserved;\n     }\n \n     enum\n@@ -200,9 +188,8 @@ else version (FreeBSD)\n     enum\n     {\n         RLIM_INFINITY   = (cast(rlim_t)((cast(ulong) 1 << 63) - 1)),\n-        // FreeBSD explicitly does not define the following:\n-        //RLIM_SAVED_MAX,\n-        //RLIM_SAVED_CUR,\n+        RLIM_SAVED_MAX  = RLIM_INFINITY,\n+        RLIM_SAVED_CUR  = RLIM_INFINITY,\n     }\n \n     enum\n@@ -258,9 +245,8 @@ else version (NetBSD)\n     enum\n     {\n         RLIM_INFINITY   = (cast(rlim_t)((cast(ulong) 1 << 63) - 1)),\n-        // FreeBSD explicitly does not define the following:\n-        //RLIM_SAVED_MAX,\n-        //RLIM_SAVED_CUR,\n+        RLIM_SAVED_MAX = RLIM_INFINITY,\n+        RLIM_SAVED_CUR = RLIM_INFINITY,\n     }\n \n     enum\n@@ -375,9 +361,8 @@ else version (DragonFlyBSD)\n     enum\n     {\n         RLIM_INFINITY   = (cast(rlim_t)((cast(ulong) 1 << 63) - 1)),\n-        // DragonFlyBSD explicitly does not define the following:\n-        //RLIM_SAVED_MAX,\n-        //RLIM_SAVED_CUR,\n+        RLIM_SAVED_MAX  = RLIM_INFINITY,\n+        RLIM_SAVED_CUR  = RLIM_INFINITY,\n     }\n \n     enum\n@@ -474,162 +459,22 @@ else version (Solaris)\n         RLIMIT_AS     = 6,\n     }\n }\n-else version (CRuntime_Bionic)\n-{\n-    enum\n-    {\n-        PRIO_PROCESS = 0,\n-        PRIO_PGRP    = 1,\n-        PRIO_USER    = 2,\n-    }\n-\n-    alias c_ulong rlim_t;\n-    enum RLIM_INFINITY = cast(c_ulong)(~0UL);\n-\n-    enum\n-    {\n-        RUSAGE_SELF     =  0,\n-        RUSAGE_CHILDREN = -1,\n-    }\n+else\n+    static assert (false, \"Unsupported platform\");\n \n-    struct rusage\n-    {\n-        timeval ru_utime;\n-        timeval ru_stime;\n-        c_long ru_maxrss;\n-        c_long ru_ixrss;\n-        c_long ru_idrss;\n-        c_long ru_isrss;\n-        c_long ru_minflt;\n-        c_long ru_majflt;\n-        c_long ru_nswap;\n-        c_long ru_inblock;\n-        c_long ru_oublock;\n-        c_long ru_msgsnd;\n-        c_long ru_msgrcv;\n-        c_long ru_nsignals;\n-        c_long ru_nvcsw;\n-        c_long ru_nivcsw;\n-    }\n-\n-    enum\n-    {\n-        RLIMIT_CORE   = 4,\n-        RLIMIT_CPU    = 0,\n-        RLIMIT_DATA   = 2,\n-        RLIMIT_FSIZE  = 1,\n-        RLIMIT_NOFILE = 7,\n-        RLIMIT_STACK  = 3,\n-        RLIMIT_AS     = 9,\n-    }\n-}\n-else version (CRuntime_Musl)\n+/*\n+struct rlimit\n {\n-    alias ulong rlim_t;\n-    enum RLIM_INFINITY = cast(c_ulong)(~0UL);\n-\n-    int getrlimit(int, rlimit*);\n-    int setrlimit(int, const scope rlimit*);\n-    alias getrlimit getrlimit64;\n-    alias setrlimit setrlimit64;\n-    enum\n-    {\n-        RUSAGE_SELF = 0,\n-        RUSAGE_CHILDREN = -1,\n-        RUSAGE_THREAD = 1\n-    }\n-    struct rusage\n-    {\n-        timeval ru_utime;\n-        timeval ru_stime;\n-        c_long ru_maxrss;\n-        c_long ru_ixrss;\n-        c_long ru_idrss;\n-        c_long ru_isrss;\n-        c_long ru_minflt;\n-        c_long ru_majflt;\n-        c_long ru_nswap;\n-        c_long ru_inblock;\n-        c_long ru_oublock;\n-        c_long ru_msgsnd;\n-        c_long ru_msgrcv;\n-        c_long ru_nsignals;\n-        c_long ru_nvcsw;\n-        c_long ru_nivcsw;\n-        c_long[16] __reserved;\n-    }\n-\n-    enum\n-    {\n-        RLIMIT_CPU    = 0,\n-        RLIMIT_FSIZE  = 1,\n-        RLIMIT_DATA   = 2,\n-        RLIMIT_STACK  = 3,\n-        RLIMIT_CORE   = 4,\n-        RLIMIT_NOFILE = 7,\n-        RLIMIT_AS     = 9,\n-    }\n+    rlim_t rlim_cur;\n+    rlim_t rlim_max;\n }\n-else version (CRuntime_UClibc)\n-{\n-    enum\n-    {\n-        PRIO_PROCESS = 0,\n-        PRIO_PGRP    = 1,\n-        PRIO_USER    = 2,\n-    }\n-\n-    static if (__USE_FILE_OFFSET64)\n-         alias ulong rlim_t;\n-    else\n-         alias c_ulong rlim_t;\n-\n-    static if (__USE_FILE_OFFSET64)\n-        enum RLIM_INFINITY = 0xffffffffffffffffUL;\n-    else\n-        enum RLIM_INFINITY = cast(c_ulong)(~0UL);\n-\n-    enum RLIM_SAVED_MAX = RLIM_INFINITY;\n-    enum RLIM_SAVED_CUR = RLIM_INFINITY;\n-\n-    enum\n-    {\n-        RUSAGE_SELF     =  0,\n-        RUSAGE_CHILDREN = -1,\n-    }\n-\n-    struct rusage\n-    {\n-        timeval ru_utime;\n-        timeval ru_stime;\n-        c_long ru_maxrss;\n-        c_long ru_ixrss;\n-        c_long ru_idrss;\n-        c_long ru_isrss;\n-        c_long ru_minflt;\n-        c_long ru_majflt;\n-        c_long ru_nswap;\n-        c_long ru_inblock;\n-        c_long ru_oublock;\n-        c_long ru_msgsnd;\n-        c_long ru_msgrcv;\n-        c_long ru_nsignals;\n-        c_long ru_nvcsw;\n-        c_long ru_nivcsw;\n-    }\n \n-    enum\n-    {\n-        RLIMIT_CORE   = 4,\n-        RLIMIT_CPU    = 0,\n-        RLIMIT_DATA   = 2,\n-        RLIMIT_FSIZE  = 1,\n-        RLIMIT_NOFILE = 7,\n-        RLIMIT_STACK  = 3,\n-        RLIMIT_AS     = 9,\n-    }\n-}\n-else static assert (false, \"Unsupported platform\");\n+int getpriority(int, id_t);\n+int getrlimit(int, rlimit*);\n+int getrusage(int, rusage*);\n+int setpriority(int, id_t, int);\n+int setrlimit(int, const rlimit*);\n+*/\n \n struct rlimit\n {\n@@ -641,40 +486,6 @@ version (CRuntime_Glibc)\n {\n     int getpriority(int, id_t);\n     int setpriority(int, id_t, int);\n-}\n-else version (FreeBSD)\n-{\n-    int getpriority(int, int);\n-    int setpriority(int, int, int);\n-}\n-else version (DragonFlyBSD)\n-{\n-    int getpriority(int, int);\n-    int setpriority(int, int, int);\n-}\n-else version (CRuntime_Bionic)\n-{\n-    int getpriority(int, int);\n-    int setpriority(int, int, int);\n-}\n-else version (Solaris)\n-{\n-    int getpriority(int, id_t);\n-    int setpriority(int, id_t, int);\n-}\n-else version (Darwin)\n-{\n-    int getpriority(int, id_t);\n-    int setpriority(int, id_t, int);\n-}\n-else version (CRuntime_UClibc)\n-{\n-    int getpriority(int, id_t);\n-    int setpriority(int, id_t, int);\n-}\n-\n-version (CRuntime_Glibc)\n-{\n     static if (__USE_FILE_OFFSET64)\n     {\n         int getrlimit64(int, rlimit*);\n@@ -689,50 +500,76 @@ version (CRuntime_Glibc)\n     }\n     int getrusage(int, rusage*);\n }\n-else version (CRuntime_Bionic)\n+else version (FreeBSD)\n {\n+    int getpriority(int, int);\n     int getrlimit(int, rlimit*);\n     int getrusage(int, rusage*);\n+    int setpriority(int, int, int);\n     int setrlimit(int, const scope rlimit*);\n }\n-else version (Darwin)\n+else version (NetBSD)\n {\n+    int getpriority(int, int);\n     int getrlimit(int, rlimit*);\n     int getrusage(int, rusage*);\n+    int setpriority(int, int, int);\n     int setrlimit(int, const scope rlimit*);\n }\n-else version (FreeBSD)\n+else version (OpenBSD)\n {\n+    int getpriority(int, int);\n     int getrlimit(int, rlimit*);\n     int getrusage(int, rusage*);\n+    int setpriority(int, int, int);\n     int setrlimit(int, const scope rlimit*);\n }\n-else version (NetBSD)\n+else version (DragonFlyBSD)\n {\n+    int getpriority(int, int);\n     int getrlimit(int, rlimit*);\n     int getrusage(int, rusage*);\n+    int setpriority(int, int, int);\n     int setrlimit(int, const scope rlimit*);\n }\n-else version (OpenBSD)\n+else version (CRuntime_Bionic)\n {\n+    int getpriority(int, int);\n     int getrlimit(int, rlimit*);\n     int getrusage(int, rusage*);\n+    int setpriority(int, int, int);\n     int setrlimit(int, const scope rlimit*);\n }\n-else version (DragonFlyBSD)\n+else version (CRuntime_Musl)\n {\n+    int getpriority(int, id_t);\n+    int setpriority(int, id_t, int);\n     int getrlimit(int, rlimit*);\n-    int getrusage(int, rusage*);\n     int setrlimit(int, const scope rlimit*);\n+    alias getrlimit getrlimit64;\n+    alias setrlimit setrlimit64;\n+    int getrusage(int, rusage*);\n }\n else version (Solaris)\n {\n+    int getpriority(int, int);\n     int getrlimit(int, rlimit*);\n     int getrusage(int, rusage*);\n+    int setpriority(int, int, int);\n+    int setrlimit(int, const scope rlimit*);\n+}\n+else version (Darwin)\n+{\n+    int getpriority(int, id_t);\n+    int getrlimit(int, rlimit*);\n+    int getrusage(int, rusage*);\n+    int setpriority(int, id_t, int);\n     int setrlimit(int, const scope rlimit*);\n }\n else version (CRuntime_UClibc)\n {\n+    int getpriority(int, id_t);\n+    int setpriority(int, id_t, int);\n     static if (__USE_FILE_OFFSET64)\n     {\n         int getrlimit64(int, rlimit*);\n@@ -747,3 +584,5 @@ else version (CRuntime_UClibc)\n     }\n     int getrusage(int, rusage*);\n }\n+else\n+    static assert (false, \"Unsupported platform\");"}, {"sha": "ce341418f364b11bff083bad0590034c2ae48322", "filename": "libphobos/libdruntime/core/sys/posix/sys/shm.d", "status": "modified", "additions": 80, "deletions": 86, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fshm.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fshm.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fshm.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -38,8 +38,6 @@ extern (C) nothrow @nogc:\n SHM_RDONLY\n SHM_RND\n \n-SHMLBA\n-\n shmatt_t\n \n struct shmid_ds\n@@ -53,20 +51,13 @@ struct shmid_ds\n     time_t      shm_dtime;\n     time_t      shm_ctime;\n }\n-\n-void* shmat(int, const scope void*, int);\n-int   shmctl(int, int, shmid_ds*);\n-int   shmdt(const scope void*);\n-int   shmget(key_t, size_t, int);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum SHM_RDONLY     = 0x01000; // 010000\n     enum SHM_RND        = 0x02000; // 020000\n-\n-    int   __getpagesize();\n-    alias __getpagesize SHMLBA;\n+    enum SHM_REMAP      = 0x4000; // 040000\n \n     alias c_ulong   shmatt_t;\n \n@@ -87,17 +78,11 @@ version (CRuntime_Glibc)\n         c_ulong     __unused4;\n         c_ulong     __unused5;\n     }\n-\n-    void* shmat(int, const scope void*, int);\n-    int   shmctl(int, int, shmid_ds*);\n-    int   shmdt(const scope void*);\n-    int   shmget(key_t, size_t, int);\n }\n else version (FreeBSD)\n {\n     enum SHM_RDONLY     = 0x01000; // 010000\n     enum SHM_RND        = 0x02000; // 020000\n-    enum SHMLBA         = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)\n \n     alias c_ulong   shmatt_t;\n \n@@ -125,17 +110,11 @@ else version (FreeBSD)\n          time_t      shm_dtime;\n          time_t      shm_ctime;\n     }\n-\n-    void* shmat(int, const scope void*, int);\n-    int   shmctl(int, int, shmid_ds*);\n-    int   shmdt(const scope void*);\n-    int   shmget(key_t, size_t, int);\n }\n else version (NetBSD)\n {\n     enum SHM_RDONLY     = 0x01000; // 010000\n     enum SHM_RND        = 0x02000; // 020000\n-    enum SHMLBA         = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)\n \n     alias c_ulong   shmatt_t;\n \n@@ -151,17 +130,11 @@ else version (NetBSD)\n         time_t          shm_ctime;\n         void*           shm_internal;\n     }\n-\n-    void* shmat(int, const scope void*, int);\n-    int   shmctl(int, int, shmid_ds*);\n-    int   shmdt(const scope void*);\n-    int   shmget(key_t, size_t, int);\n }\n else version (OpenBSD)\n {\n     enum SHM_RDONLY     = 0x01000; // 010000\n     enum SHM_RND        = 0x02000; // 020000\n-    enum SHMLBA         = 1 << _MAX_PAGE_SHIFT;\n \n     alias short shmatt_t;\n \n@@ -180,17 +153,11 @@ else version (OpenBSD)\n         c_long   __shm_ctimensec;\n         void*      shm_internal;\n     }\n-\n-    void* shmat(int, const scope void*, int);\n-    int   shmctl(int, int, shmid_ds*);\n-    int   shmdt(const scope void*);\n-    int   shmget(key_t, size_t, int);\n }\n else version (DragonFlyBSD)\n {\n     enum SHM_RDONLY     = 0x01000; // 010000\n     enum SHM_RND        = 0x02000; // 020000\n-    enum SHMLBA         = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)\n \n     alias c_ulong   shmatt_t;\n \n@@ -206,76 +173,103 @@ else version (DragonFlyBSD)\n          time_t         shm_ctime;\n          private void*  shm_internal;\n     }\n+}\n+else version (Darwin)\n+{\n+\n+}\n+else version (Solaris)\n+{\n+\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+SHMLBA\n+\n+void* shmat(int, const scope void*, int);\n+int   shmctl(int, int, shmid_ds*);\n+int   shmdt(const scope void*);\n+int   shmget(key_t, size_t, int);\n+*/\n+\n+version (CRuntime_Glibc)\n+{\n+    int   __getpagesize();\n+    alias __getpagesize SHMLBA;\n \n     void* shmat(int, const scope void*, int);\n     int   shmctl(int, int, shmid_ds*);\n     int   shmdt(const scope void*);\n     int   shmget(key_t, size_t, int);\n }\n-else version (Darwin)\n+else version (FreeBSD)\n {\n+    enum SHMLBA = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)\n \n+    void* shmat(int, const scope void*, int);\n+    int   shmctl(int, int, shmid_ds*);\n+    int   shmdt(const scope void*);\n+    int   shmget(key_t, size_t, int);\n }\n-else version (CRuntime_UClibc)\n+else version (NetBSD)\n {\n-    enum SHM_RDONLY     = 0x1000; // 010000\n-    enum SHM_RND        = 0x2000; // 020000\n-    enum SHM_REMAP      = 0x4000; // 040000\n+    enum SHMLBA = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)\n \n-    int   __getpagesize();\n-    alias __getpagesize SHMLBA;\n+    void* shmat(int, const scope void*, int);\n+    int   shmctl(int, int, shmid_ds*);\n+    int   shmdt(const scope void*);\n+    int   shmget(key_t, size_t, int);\n+}\n+else version (OpenBSD)\n+{\n+    enum SHMLBA = 1 << _MAX_PAGE_SHIFT;\n \n-    alias c_ulong   shmatt_t;\n+    void* shmat(int, const scope void*, int);\n+    int   shmctl(int, int, shmid_ds*);\n+    int   shmdt(const scope void*);\n+    int   shmget(key_t, size_t, int);\n+}\n+else version (DragonFlyBSD)\n+{\n+    enum SHMLBA = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)\n \n-    version (X86_64)\n-        enum includeUnused  = false;\n-    else version (MIPS32)\n-        enum includeUnused  = false;\n-    else\n-        enum includeUnused  = true;\n+    void* shmat(int, const scope void*, int);\n+    int   shmctl(int, int, shmid_ds*);\n+    int   shmdt(const scope void*);\n+    int   shmget(key_t, size_t, int);\n+}\n+else version (Darwin)\n+{\n \n-    struct shmid_ds\n-    {\n-        ipc_perm    shm_perm;\n-        size_t      shm_segsz;\n-        time_t      shm_atime;\n-        static if (includeUnused) c_ulong     __unused1;\n-        time_t      shm_dtime;\n-        static if (includeUnused) c_ulong     __unused2;\n-        time_t      shm_ctime;\n-        static if (includeUnused) c_ulong     __unused3;\n-        pid_t       shm_cpid;\n-        pid_t       shm_lpid;\n-        shmatt_t    shm_nattch;\n-        c_ulong     __unused4;\n-        c_ulong     __unused5;\n-    }\n+}\n+else version (Solaris)\n+{\n \n-    struct shminfo\n-    {\n-        c_ulong shmmax;\n-        c_ulong shmmin;\n-        c_ulong shmmni;\n-        c_ulong shmseg;\n-        c_ulong shmall;\n-        c_ulong __unused1;\n-        c_ulong __unused2;\n-        c_ulong __unused3;\n-        c_ulong __unused4;\n-    }\n+}\n+else version (CRuntime_Musl)\n+{\n+    enum SHMLBA = 4096;\n \n-    struct shm_info\n-    {\n-        int used_ids;\n-        c_ulong shm_tot;\n-        c_ulong shm_rss;\n-        c_ulong shm_swp;\n-        c_ulong swap_attempts;\n-        c_ulong swap_successes;\n-    }\n+    void* shmat(int, const scope void*, int);\n+    int   shmctl(int, int, shmid_ds*);\n+    int   shmdt(const scope void*);\n+    int   shmget(key_t, size_t, int);\n+}\n+else version (CRuntime_UClibc)\n+{\n+    int   __getpagesize();\n+    alias __getpagesize SHMLBA;\n \n     void* shmat(int, const scope void*, int);\n     int   shmctl(int, int, shmid_ds*);\n     int   shmdt(const scope void*);\n     int   shmget(key_t, size_t, int);\n }\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}"}, {"sha": "670ead73c64700a8507b9bfad13c03590ed025d2", "filename": "libphobos/libdruntime/core/sys/posix/sys/socket.d", "status": "modified", "additions": 177, "deletions": 658, "changes": 835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fsocket.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -137,31 +137,10 @@ AF_UNSPEC\n SHUT_RD\n SHUT_RDWR\n SHUT_WR\n-\n-int     accept(int, sockaddr*, socklen_t*);\n-int     bind(int, const scope sockaddr*, socklen_t);\n-int     connect(int, const scope sockaddr*, socklen_t);\n-int     getpeername(int, sockaddr*, socklen_t*);\n-int     getsockname(int, sockaddr*, socklen_t*);\n-int     getsockopt(int, int, int, void*, socklen_t*);\n-int     listen(int, int);\n-ssize_t recv(int, void*, size_t, int);\n-ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);\n-ssize_t recvmsg(int, msghdr*, int);\n-ssize_t send(int, const scope void*, size_t, int);\n-ssize_t sendmsg(int, const scope msghdr*, int);\n-ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-int     setsockopt(int, int, int, const scope void*, socklen_t);\n-int     shutdown(int, int);\n-int     socket(int, int, int);\n-int     sockatmark(int);\n-int     socketpair(int, int, int, ref int[2]);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n-    // Some of the constants below and from the Bionic section are really from\n-    // the linux kernel headers.\n     alias uint   socklen_t;\n     alias ushort sa_family_t;\n \n@@ -174,14 +153,14 @@ version (CRuntime_Glibc)\n     private enum : size_t\n     {\n         _SS_SIZE    = 128,\n-        _SS_PADSIZE = _SS_SIZE - (c_ulong.sizeof * 2)\n+        _SS_PADSIZE = _SS_SIZE - c_ulong.sizeof - sa_family_t.sizeof\n     }\n \n     struct sockaddr_storage\n     {\n         sa_family_t ss_family;\n-        c_ulong     __ss_align;\n         byte[_SS_PADSIZE] __ss_padding;\n+        c_ulong     __ss_align;\n     }\n \n     struct msghdr\n@@ -200,25 +179,14 @@ version (CRuntime_Glibc)\n         size_t cmsg_len;\n         int    cmsg_level;\n         int    cmsg_type;\n-        static if ( false /* (!is( __STRICT_ANSI__ ) && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L */ )\n-        {\n-            ubyte[1] __cmsg_data;\n-        }\n     }\n \n     enum : uint\n     {\n         SCM_RIGHTS = 0x01\n     }\n \n-    static if ( false /* (!is( __STRICT_ANSI__ ) && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L */ )\n-    {\n-        extern (D) ubyte[1] CMSG_DATA( cmsghdr* cmsg ) pure nothrow @nogc { return cmsg.__cmsg_data; }\n-    }\n-    else\n-    {\n-        extern (D) inout(ubyte)*   CMSG_DATA( return scope inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }\n-    }\n+    extern (D) inout(ubyte)*   CMSG_DATA( return scope inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }\n \n     private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;\n     extern (D)  inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc\n@@ -534,10 +502,19 @@ version (CRuntime_Glibc)\n     else\n         static assert(0, \"unimplemented\");\n \n-    enum\n+    version (CRuntime_Glibc)\n+    {\n+        enum\n+        {\n+            SOMAXCONN   = 4096\n+        }\n+    }\n+    else\n     {\n-        // https://sourceware.org/git/?p=glibc.git;a=commit;f=sysdeps/unix/sysv/linux/bits/socket.h;h=96958e2700f5b4f4d1183a0606b2b9848a53ea44\n-        SOMAXCONN       = 4096\n+        enum\n+        {\n+            SOMAXCONN   = 128\n+        }\n     }\n \n     enum : uint\n@@ -571,25 +548,6 @@ version (CRuntime_Glibc)\n         SHUT_WR,\n         SHUT_RDWR\n     }\n-\n-    int     accept(int, scope sockaddr*, scope socklen_t*);\n-    int     bind(int, const scope sockaddr*, socklen_t);\n-    int     connect(int, const scope sockaddr*, socklen_t);\n-    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n-    int     listen(int, int) @safe;\n-    ssize_t recv(int, scope void*, size_t, int);\n-    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n-    ssize_t recvmsg(int, scope msghdr*, int);\n-    ssize_t send(int, const scope void*, size_t, int);\n-    ssize_t sendmsg(int, const scope msghdr*, int);\n-    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-    int     setsockopt(int, int, int, const scope void*, socklen_t);\n-    int     shutdown(int, int) @safe;\n-    int     socket(int, int, int) @safe;\n-    int     sockatmark(int) @safe;\n-    int     socketpair(int, int, int, ref int[2]) @safe;\n }\n else version (Darwin)\n {\n@@ -727,25 +685,6 @@ else version (Darwin)\n         SHUT_WR,\n         SHUT_RDWR\n     }\n-\n-    int     accept(int, scope sockaddr*, scope socklen_t*);\n-    int     bind(int, const scope sockaddr*, socklen_t);\n-    int     connect(int, const scope sockaddr*, socklen_t);\n-    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n-    int     listen(int, int) @safe;\n-    ssize_t recv(int, scope void*, size_t, int);\n-    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n-    ssize_t recvmsg(int, scope msghdr*, int);\n-    ssize_t send(int, const scope void*, size_t, int);\n-    ssize_t sendmsg(int, const scope msghdr*, int);\n-    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-    int     setsockopt(int, int, int, const scope void*, socklen_t);\n-    int     shutdown(int, int) @safe;\n-    int     socket(int, int, int) @safe;\n-    int     sockatmark(int) @safe;\n-    int     socketpair(int, int, int, ref int[2]) @safe;\n }\n else version (FreeBSD)\n {\n@@ -904,25 +843,6 @@ else version (FreeBSD)\n         SHUT_WR = 1,\n         SHUT_RDWR = 2\n     }\n-\n-    int     accept(int, scope sockaddr*, scope socklen_t*);\n-    int     bind(int, const scope sockaddr*, socklen_t);\n-    int     connect(int, const scope sockaddr*, socklen_t);\n-    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n-    int     listen(int, int) @safe;\n-    ssize_t recv(int, scope void*, size_t, int);\n-    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n-    ssize_t recvmsg(int, scope msghdr*, int);\n-    ssize_t send(int, const scope void*, size_t, int);\n-    ssize_t sendmsg(int, const scope msghdr*, int);\n-    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-    int     setsockopt(int, int, int, const scope void*, socklen_t);\n-    int     shutdown(int, int) @safe;\n-    int     socket(int, int, int) @safe;\n-    int     sockatmark(int) @safe;\n-    int     socketpair(int, int, int, ref int[2]) @safe;\n }\n else version (NetBSD)\n {\n@@ -1101,25 +1021,6 @@ else version (NetBSD)\n         SHUT_WR = 1,\n         SHUT_RDWR = 2\n     }\n-\n-    int     accept(int, scope sockaddr*, scope socklen_t*);\n-    int     bind(int, const scope sockaddr*, socklen_t);\n-    int     connect(int, const scope sockaddr*, socklen_t);\n-    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n-    int     listen(int, int) @safe;\n-    ssize_t recv(int, scope void*, size_t, int);\n-    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n-    ssize_t recvmsg(int, scope msghdr*, int);\n-    ssize_t send(int, const scope void*, size_t, int);\n-    ssize_t sendmsg(int, const scope msghdr*, int);\n-    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-    int     setsockopt(int, int, int, const scope void*, socklen_t);\n-    int     shutdown(int, int) @safe;\n-    int     socket(int, int, int) @safe;\n-    int     sockatmark(int) @safe;\n-    int     socketpair(int, int, int, ref int[2]) @safe;\n }\n else version (OpenBSD)\n {\n@@ -1274,25 +1175,6 @@ else version (OpenBSD)\n         SHUT_WR = 1,\n         SHUT_RDWR = 2\n     }\n-\n-    int     accept(int, scope sockaddr*, scope socklen_t*);\n-    int     bind(int, const scope sockaddr*, socklen_t);\n-    int     connect(int, const scope sockaddr*, socklen_t);\n-    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n-    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n-    int     listen(int, int) @safe;\n-    ssize_t recv(int, scope void*, size_t, int);\n-    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n-    ssize_t recvmsg(int, scope msghdr*, int);\n-    ssize_t send(int, const scope void*, size_t, int);\n-    ssize_t sendmsg(int, const scope msghdr*, int);\n-    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-    int     setsockopt(int, int, int, const scope void*, socklen_t);\n-    int     shutdown(int, int) @safe;\n-    int     socket(int, int, int) @safe;\n-    int     sockatmark(int) @safe;\n-    int     socketpair(int, int, int, ref int[2]) @safe;\n }\n else version (DragonFlyBSD)\n {\n@@ -1493,39 +1375,6 @@ else version (DragonFlyBSD)\n         SHUT_WR             = 1,\n         SHUT_RDWR           = 2\n     }\n-\n-/*\n-    /+ sendfile(2) header/trailer struct +/\n-    struct sf_hdtr {\n-        iovec *             headers;\n-        int                 hdr_cnt;\n-        iovec *             trailers;\n-        int                 trl_cnt;\n-    }\n-*/\n-\n-    int     accept(int, sockaddr*, socklen_t*);\n-//    int     accept4(int, sockaddr*, socklen_t*, int);\n-    int     bind(int, const scope sockaddr*, socklen_t);\n-    int     connect(int, const scope sockaddr*, socklen_t);\n-//    int     extconnect(int, int, sockaddr*, socklen_t);\n-    int     getpeername(int, sockaddr*, socklen_t*);\n-    int     getsockname(int, sockaddr*, socklen_t*);\n-    int     getsockopt(int, int, int, void*, socklen_t*);\n-    int     listen(int, int);\n-    ssize_t recv(int, void*, size_t, int);\n-    ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);\n-    ssize_t recvmsg(int, msghdr*, int);\n-    ssize_t send(int, const scope void*, size_t, int);\n-    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n-    ssize_t sendmsg(int, const scope msghdr*, int);\n-//    int     sendfile(int, int, off_t, size_t, sf_hdtr *, off_t *, int);\n-    int     setsockopt(int, int, int, const scope void*, socklen_t);\n-    int     shutdown(int, int);\n-    int     sockatmark(int);\n-    int     socket(int, int, int);\n-    int     socketpair(int, int, int, ref int[2]);\n-//  void    pfctlinput(int, struct sockaddr *);\n }\n else version (Solaris)\n {\n@@ -1655,7 +1504,35 @@ else version (Solaris)\n         SHUT_WR,\n         SHUT_RDWR\n     }\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+int     accept(int, sockaddr*, socklen_t*);\n+int     bind(int, const scope sockaddr*, socklen_t);\n+int     connect(int, const scope sockaddr*, socklen_t);\n+int     getpeername(int, sockaddr*, socklen_t*);\n+int     getsockname(int, sockaddr*, socklen_t*);\n+int     getsockopt(int, int, int, void*, socklen_t*);\n+int     listen(int, int);\n+ssize_t recv(int, void*, size_t, int);\n+ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);\n+ssize_t recvmsg(int, msghdr*, int);\n+ssize_t send(int, const scope void*, size_t, int);\n+ssize_t sendmsg(int, const scope msghdr*, int);\n+ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+int     setsockopt(int, int, int, const scope void*, socklen_t);\n+int     shutdown(int, int);\n+int     socket(int, int, int);\n+int     sockatmark(int);\n+int     socketpair(int, int, int, ref int[2]);\n+*/\n \n+version (CRuntime_Glibc)\n+{\n     int     accept(int, scope sockaddr*, scope socklen_t*);\n     int     bind(int, const scope sockaddr*, socklen_t);\n     int     connect(int, const scope sockaddr*, socklen_t);\n@@ -1675,148 +1552,138 @@ else version (Solaris)\n     int     sockatmark(int) @safe;\n     int     socketpair(int, int, int, ref int[2]) @safe;\n }\n-else version (CRuntime_Bionic)\n+else version (Darwin)\n+{\n+    int     accept(int, scope sockaddr*, scope socklen_t*);\n+    int     bind(int, const scope sockaddr*, socklen_t);\n+    int     connect(int, const scope sockaddr*, socklen_t);\n+    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n+    int     listen(int, int) @safe;\n+    ssize_t recv(int, scope void*, size_t, int);\n+    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n+    ssize_t recvmsg(int, scope msghdr*, int);\n+    ssize_t send(int, const scope void*, size_t, int);\n+    ssize_t sendmsg(int, const scope msghdr*, int);\n+    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+    int     setsockopt(int, int, int, const scope void*, socklen_t);\n+    int     shutdown(int, int) @safe;\n+    int     socket(int, int, int) @safe;\n+    int     sockatmark(int) @safe;\n+    int     socketpair(int, int, int, ref int[2]) @safe;\n+}\n+else version (FreeBSD)\n+{\n+    int     accept(int, scope sockaddr*, scope socklen_t*);\n+    int     bind(int, const scope sockaddr*, socklen_t);\n+    int     connect(int, const scope sockaddr*, socklen_t);\n+    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n+    int     listen(int, int) @safe;\n+    ssize_t recv(int, scope void*, size_t, int);\n+    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n+    ssize_t recvmsg(int, scope msghdr*, int);\n+    ssize_t send(int, const scope void*, size_t, int);\n+    ssize_t sendmsg(int, const scope msghdr*, int);\n+    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+    int     setsockopt(int, int, int, const scope void*, socklen_t);\n+    int     shutdown(int, int) @safe;\n+    int     socket(int, int, int) @safe;\n+    int     sockatmark(int) @safe;\n+    int     socketpair(int, int, int, ref int[2]) @safe;\n+}\n+else version (NetBSD)\n+{\n+    int     accept(int, scope sockaddr*, scope socklen_t*);\n+    int     bind(int, const scope sockaddr*, socklen_t);\n+    int     connect(int, const scope sockaddr*, socklen_t);\n+    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n+    int     listen(int, int) @safe;\n+    ssize_t recv(int, scope void*, size_t, int);\n+    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n+    ssize_t recvmsg(int, scope msghdr*, int);\n+    ssize_t send(int, const scope void*, size_t, int);\n+    ssize_t sendmsg(int, const scope msghdr*, int);\n+    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+    int     setsockopt(int, int, int, const scope void*, socklen_t);\n+    int     shutdown(int, int) @safe;\n+    int     socket(int, int, int) @safe;\n+    int     sockatmark(int) @safe;\n+    int     socketpair(int, int, int, ref int[2]) @safe;\n+}\n+else version (OpenBSD)\n+{\n+    int     accept(int, scope sockaddr*, scope socklen_t*);\n+    int     bind(int, const scope sockaddr*, socklen_t);\n+    int     connect(int, const scope sockaddr*, socklen_t);\n+    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n+    int     listen(int, int) @safe;\n+    ssize_t recv(int, scope void*, size_t, int);\n+    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n+    ssize_t recvmsg(int, scope msghdr*, int);\n+    ssize_t send(int, const scope void*, size_t, int);\n+    ssize_t sendmsg(int, const scope msghdr*, int);\n+    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+    int     setsockopt(int, int, int, const scope void*, socklen_t);\n+    int     shutdown(int, int) @safe;\n+    int     socket(int, int, int) @safe;\n+    int     sockatmark(int) @safe;\n+    int     socketpair(int, int, int, ref int[2]) @safe;\n+}\n+else version (DragonFlyBSD)\n+{\n+    int     accept(int, sockaddr*, socklen_t*);\n+//    int     accept4(int, sockaddr*, socklen_t*, int);\n+    int     bind(int, const scope sockaddr*, socklen_t);\n+    int     connect(int, const scope sockaddr*, socklen_t);\n+//    int     extconnect(int, int, sockaddr*, socklen_t);\n+    int     getpeername(int, sockaddr*, socklen_t*);\n+    int     getsockname(int, sockaddr*, socklen_t*);\n+    int     getsockopt(int, int, int, void*, socklen_t*);\n+    int     listen(int, int);\n+    ssize_t recv(int, void*, size_t, int);\n+    ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);\n+    ssize_t recvmsg(int, msghdr*, int);\n+    ssize_t send(int, const scope void*, size_t, int);\n+    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+    ssize_t sendmsg(int, const scope msghdr*, int);\n+//    int     sendfile(int, int, off_t, size_t, sf_hdtr *, off_t *, int);\n+    int     setsockopt(int, int, int, const scope void*, socklen_t);\n+    int     shutdown(int, int);\n+    int     sockatmark(int);\n+    int     socket(int, int, int);\n+    int     socketpair(int, int, int, ref int[2]);\n+//  void    pfctlinput(int, struct sockaddr *);\n+}\n+else version (Solaris)\n+{\n+    int     accept(int, scope sockaddr*, scope socklen_t*);\n+    int     bind(int, const scope sockaddr*, socklen_t);\n+    int     connect(int, const scope sockaddr*, socklen_t);\n+    int     getpeername(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockname(int, scope sockaddr*, scope socklen_t*);\n+    int     getsockopt(int, int, int, scope void*, scope socklen_t*);\n+    int     listen(int, int) @safe;\n+    ssize_t recv(int, scope void*, size_t, int);\n+    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);\n+    ssize_t recvmsg(int, scope msghdr*, int);\n+    ssize_t send(int, const scope void*, size_t, int);\n+    ssize_t sendmsg(int, const scope msghdr*, int);\n+    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);\n+    int     setsockopt(int, int, int, const scope void*, socklen_t);\n+    int     shutdown(int, int) @safe;\n+    int     socket(int, int, int) @safe;\n+    int     sockatmark(int) @safe;\n+    int     socketpair(int, int, int, ref int[2]) @safe;\n+}\n+else version (CRuntime_Bionic)\n {\n-    alias int    socklen_t;\n-    alias ushort sa_family_t;\n-\n-    struct sockaddr\n-    {\n-        sa_family_t sa_family;\n-        byte[14]    sa_data;\n-    }\n-\n-    private enum size_t _K_SS_MAXSIZE  = 128;\n-\n-    struct sockaddr_storage\n-    {\n-        ushort ss_family;\n-        byte[_K_SS_MAXSIZE - ushort.sizeof] __data;\n-    }\n-\n-    enum : uint\n-    {\n-        SCM_RIGHTS = 0x01\n-    }\n-\n-    private enum _ALIGNBYTES = c_long.sizeof - 1;\n-\n-    extern (D)\n-    {\n-        size_t CMSG_ALIGN( size_t len )\n-        {\n-            return (len + _ALIGNBYTES) & ~_ALIGNBYTES;\n-        }\n-\n-        void* CMSG_DATA( cmsghdr* cmsg )\n-        {\n-            return cast(void*) (cast(char*) cmsg + CMSG_ALIGN( cmsghdr.sizeof ));\n-        }\n-\n-        cmsghdr* CMSG_NXTHDR( msghdr* mhdr, cmsghdr* cmsg )\n-        {\n-            cmsghdr* __ptr = cast(cmsghdr*) ((cast(ubyte*) cmsg) + CMSG_ALIGN(cmsg.cmsg_len));\n-            return cast(c_ulong)( cast(char*)(__ptr+1) - cast(char*) mhdr.msg_control) > mhdr.msg_controllen ? null : __ptr;\n-        }\n-\n-        cmsghdr* CMSG_FIRSTHDR( msghdr* mhdr )\n-        {\n-            return mhdr.msg_controllen >= cmsghdr.sizeof ? cast(cmsghdr*) mhdr.msg_control : null;\n-        }\n-    }\n-\n-    struct linger\n-    {\n-        int l_onoff;\n-        int l_linger;\n-    }\n-\n-    struct msghdr\n-    {\n-        void*           msg_name;\n-        int             msg_namelen;\n-        iovec*          msg_iov;\n-        __kernel_size_t msg_iovlen;\n-        void*           msg_control;\n-        __kernel_size_t msg_controllen;\n-        uint            msg_flags;\n-    }\n-\n-    struct cmsghdr\n-    {\n-        __kernel_size_t cmsg_len;\n-        int             cmsg_level;\n-        int             cmsg_type;\n-    }\n-\n-    alias size_t __kernel_size_t;\n-\n-    enum\n-    {\n-        SOCK_DGRAM      = 2,\n-        SOCK_SEQPACKET  = 5,\n-        SOCK_STREAM     = 1\n-    }\n-\n-    enum\n-    {\n-        SOL_SOCKET      = 1\n-    }\n-\n-    enum\n-    {\n-        SO_ACCEPTCONN   = 30,\n-        SO_BROADCAST    = 6,\n-        SO_DEBUG        = 1,\n-        SO_DONTROUTE    = 5,\n-        SO_ERROR        = 4,\n-        SO_KEEPALIVE    = 9,\n-        SO_LINGER       = 13,\n-        SO_OOBINLINE    = 10,\n-        SO_RCVBUF       = 8,\n-        SO_RCVLOWAT     = 18,\n-        SO_RCVTIMEO     = 20,\n-        SO_REUSEADDR    = 2,\n-        SO_SNDBUF       = 7,\n-        SO_SNDLOWAT     = 19,\n-        SO_SNDTIMEO     = 21,\n-        SO_TYPE         = 3\n-    }\n-\n-    enum\n-    {\n-        SOMAXCONN       = 128\n-    }\n-\n-    enum : uint\n-    {\n-        MSG_CTRUNC      = 0x08,\n-        MSG_DONTROUTE   = 0x04,\n-        MSG_EOR         = 0x80,\n-        MSG_OOB         = 0x01,\n-        MSG_PEEK        = 0x02,\n-        MSG_TRUNC       = 0x20,\n-        MSG_WAITALL     = 0x100\n-    }\n-\n-    enum\n-    {\n-        AF_APPLETALK    = 5,\n-        AF_INET         = 2,\n-        AF_IPX          = 4,\n-        AF_UNIX         = 1,\n-        AF_UNSPEC       = 0\n-    }\n-\n-    enum\n-    {\n-        SHUT_RD,\n-        SHUT_WR,\n-        SHUT_RDWR\n-    }\n-\n-    enum SOCK_RDM = 4;\n-\n     int     accept(int, scope sockaddr*, scope socklen_t*);\n     int     bind(int, const scope sockaddr*, socklen_t);\n     int     connect(int, const scope sockaddr*, socklen_t);\n@@ -1838,139 +1705,6 @@ else version (CRuntime_Bionic)\n }\n else version (CRuntime_Musl)\n {\n-    alias uint socklen_t;\n-    alias ushort sa_family_t;\n-\n-    struct sockaddr\n-    {\n-        sa_family_t sa_family;\n-        byte[14]    sa_data;\n-    }\n-\n-    private enum : size_t\n-    {\n-        _SS_SIZE    = 128,\n-        _SS_PADSIZE = _SS_SIZE - c_ulong.sizeof - sa_family_t.sizeof\n-    }\n-\n-    struct sockaddr_storage\n-    {\n-        sa_family_t ss_family;\n-        byte[_SS_PADSIZE] __ss_padding;\n-        c_ulong     __ss_align;\n-    }\n-\n-    enum\n-    {\n-        SOCK_STREAM = 1,\n-        SOCK_DGRAM = 2,\n-        SOCK_RDM = 4,\n-        SOCK_SEQPACKET = 5,\n-        SOCK_DCCP = 6,\n-        SOCK_PACKET = 10\n-    }\n-    enum\n-    {\n-        AF_UNSPEC       = 0,\n-        AF_LOCAL        = 1,\n-        AF_UNIX         = AF_LOCAL,\n-        AF_FILE         = AF_LOCAL,\n-        AF_INET         = 2,\n-        AF_AX25         = 3,\n-        AF_IPX          = 4,\n-        AF_APPLETALK    = 5,\n-        PF_APPLETALK    = AF_APPLETALK,\n-        PF_IPX          = AF_IPX\n-    }\n-\n-    enum\n-    {\n-        SHUT_RD,\n-        SHUT_WR,\n-        SHUT_RDWR\n-    }\n-\n-    enum\n-    {\n-        SOL_SOCKET      = 1\n-    }\n-\n-    enum\n-    {\n-        SO_DEBUG        = 1\n-    }\n-\n-    version (MIPS_Any)\n-    {\n-        enum\n-        {\n-            SO_REUSEADDR    = 0x0004,\n-            SO_TYPE         = 0x1008,\n-            SO_ERROR        = 0x1007,\n-            SO_DONTROUTE    = 0x0010,\n-            SO_BROADCAST    = 0x0020,\n-            SO_SNDBUF       = 0x1001,\n-            SO_RCVBUF       = 0x1002,\n-            SO_KEEPALIVE    = 0x0008,\n-            SO_OOBINLINE    = 0x0100,\n-            SO_LINGER       = 0x0080,\n-            SO_REUSEPORT    = 0x0200,\n-            SO_RCVLOWAT     = 0x1004,\n-            SO_SNDLOWAT     = 0x1003,\n-            SO_RCVTIMEO     = 0x1006,\n-            SO_SNDTIMEO     = 0x1005,\n-            SO_ACCEPTCONN   = 0x1009\n-        }\n-    }\n-    else\n-    {\n-        enum\n-        {\n-            SO_REUSEADDR    = 2,\n-            SO_TYPE         = 3,\n-            SO_ERROR        = 4,\n-            SO_DONTROUTE    = 5,\n-            SO_BROADCAST    = 6,\n-            SO_SNDBUF       = 7,\n-            SO_RCVBUF       = 8,\n-            SO_KEEPALIVE    = 9,\n-            SO_OOBINLINE    = 10,\n-            SO_LINGER       = 13,\n-            SO_REUSEPORT    = 15,\n-            SO_RCVLOWAT     = 18,\n-            SO_SNDLOWAT     = 19,\n-            SO_RCVTIMEO     = 20,\n-            SO_SNDTIMEO     = 21,\n-            SO_ACCEPTCONN   = 30\n-        }\n-    }\n-\n-    enum : uint\n-    {\n-        MSG_OOB         = 0x01,\n-        MSG_PEEK        = 0x02,\n-        MSG_DONTROUTE   = 0x04,\n-        MSG_CTRUNC      = 0x08,\n-        MSG_TRUNC       = 0x20,\n-        MSG_EOR         = 0x80,\n-        MSG_WAITALL     = 0x100,\n-        MSG_NOSIGNAL    = 0x4000\n-    }\n-\n-    struct linger\n-    {\n-        int l_onoff;\n-        int l_linger;\n-    }\n-    struct msghdr {\n-        void *msg_name;\n-        socklen_t msg_namelen;\n-        iovec *msg_iov;\n-        int msg_iovlen, __pad1;\n-        void *msg_control;\n-        socklen_t msg_controllen, __pad2;\n-        int msg_flags;\n-    }\n     int     accept(int, sockaddr*, socklen_t*);\n     int     bind(int, const scope sockaddr*, socklen_t);\n     int     connect(int, const scope sockaddr*, socklen_t);\n@@ -1992,182 +1726,6 @@ else version (CRuntime_Musl)\n }\n else version (CRuntime_UClibc)\n {\n-    alias uint   socklen_t;\n-    alias ushort sa_family_t;\n-\n-    struct sockaddr\n-    {\n-        sa_family_t sa_family;\n-        byte[14]    sa_data;\n-    }\n-\n-    private enum : size_t\n-    {\n-        _SS_SIZE    = 128,\n-        _SS_PADSIZE = _SS_SIZE - (c_ulong.sizeof * 2)\n-    }\n-\n-    struct sockaddr_storage\n-    {\n-        sa_family_t ss_family;\n-        c_ulong     __ss_align;\n-        byte[_SS_PADSIZE] __ss_padding;\n-    }\n-\n-    struct msghdr\n-    {\n-        void*     msg_name;\n-        socklen_t msg_namelen;\n-        iovec*    msg_iov;\n-        size_t    msg_iovlen;\n-        void*     msg_control;\n-        size_t    msg_controllen;\n-        int       msg_flags;\n-    }\n-\n-    struct cmsghdr\n-    {\n-        size_t cmsg_len;\n-        int    cmsg_level;\n-        int    cmsg_type;\n-    }\n-\n-    enum : uint\n-    {\n-        SCM_RIGHTS = 0x01\n-    }\n-\n-    extern (D) inout(ubyte)*   CMSG_DATA( inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }\n-\n-    private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;\n-    extern (D)  inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc\n-    {\n-        return __cmsg_nxthdr(msg, cmsg);\n-    }\n-\n-    extern (D) inout(cmsghdr)* CMSG_FIRSTHDR( inout(msghdr)* mhdr ) pure nothrow @nogc\n-    {\n-        return ( cast(size_t)mhdr.msg_controllen >= cmsghdr.sizeof\n-                             ? cast(inout(cmsghdr)*) mhdr.msg_control\n-                             : cast(inout(cmsghdr)*) null );\n-    }\n-\n-    extern (D)\n-    {\n-        size_t CMSG_ALIGN( size_t len ) pure nothrow @nogc\n-        {\n-            return (len + size_t.sizeof - 1) & cast(size_t) (~(size_t.sizeof - 1));\n-        }\n-\n-        size_t CMSG_LEN( size_t len ) pure nothrow @nogc\n-        {\n-            return CMSG_ALIGN(cmsghdr.sizeof) + len;\n-        }\n-    }\n-\n-    extern (D) size_t CMSG_SPACE(size_t len) pure nothrow @nogc\n-    {\n-        return CMSG_ALIGN(len) + CMSG_ALIGN(cmsghdr.sizeof);\n-    }\n-\n-    struct linger\n-    {\n-        int l_onoff;\n-        int l_linger;\n-    }\n-\n-    version (X86_Any)\n-    {\n-        enum\n-        {\n-            SOCK_DGRAM      = 2,\n-            SOCK_SEQPACKET  = 5,\n-            SOCK_STREAM     = 1,\n-            SOCK_CLOEXEC    = 0x80000, // octal 02000000\n-            SOCK_NONBLOCK   = 0x800 // octal 00004000\n-        }\n-    }\n-    else version (MIPS_Any)\n-    {\n-        enum\n-        {\n-            SOCK_DGRAM      = 1,\n-            SOCK_SEQPACKET  = 5,\n-            SOCK_STREAM     = 2,\n-            SOCK_CLOEXEC    = 0x80000, // octal 02000000\n-            SOCK_NONBLOCK   = 0x80 // octal 00000200\n-        }\n-    }\n-    else version (ARM_Any)\n-    {\n-        enum\n-        {\n-            SOCK_DGRAM      = 2,\n-            SOCK_SEQPACKET  = 5,\n-            SOCK_STREAM     = 1,\n-            SOCK_CLOEXEC    = 0x80000, // octal 02000000\n-            SOCK_NONBLOCK   = 0x800 // octal 00004000\n-        }\n-    }\n-    else\n-        static assert(0, \"unimplemented\");\n-\n-    enum\n-    {\n-        SO_ACCEPTCONN   = 30,\n-        SO_BROADCAST    = 6,\n-        SO_DEBUG        = 1,\n-        SO_DONTROUTE    = 5,\n-        SO_ERROR        = 4,\n-        SO_KEEPALIVE    = 9,\n-        SO_LINGER       = 13,\n-        SO_OOBINLINE    = 10,\n-        SO_RCVBUF       = 8,\n-        SO_RCVLOWAT     = 18,\n-        SO_RCVTIMEO     = 20,\n-        SO_REUSEADDR    = 2,\n-        SO_SNDBUF       = 7,\n-        SO_SNDLOWAT     = 19,\n-        SO_SNDTIMEO     = 21,\n-        SO_TYPE         = 3,\n-\n-        SOL_SOCKET      = 1,\n-        SOL_TCP         = 6,\n-        SOMAXCONN       = 128\n-    }\n-\n-    enum : uint\n-    {\n-        MSG_CTRUNC      = 0x08,\n-        MSG_DONTROUTE   = 0x04,\n-        MSG_EOR         = 0x80,\n-        MSG_OOB         = 0x01,\n-        MSG_PEEK        = 0x02,\n-        MSG_TRUNC       = 0x20,\n-        MSG_WAITALL     = 0x100,\n-        MSG_NOSIGNAL    = 0x4000\n-    }\n-\n-    enum\n-    {\n-        AF_APPLETALK    = 5,\n-        AF_INET         = 2,\n-        AF_IPX          = 4,\n-        AF_UNIX         = 1,\n-        AF_UNSPEC       = 0,\n-        PF_APPLETALK    = AF_APPLETALK,\n-        PF_IPX          = AF_IPX\n-    }\n-\n-    enum int SOCK_RDM   = 4;\n-\n-    enum\n-    {\n-        SHUT_RD,\n-        SHUT_WR,\n-        SHUT_RDWR\n-    }\n-\n     int     accept(int, sockaddr*, socklen_t*);\n     int     bind(int, const scope sockaddr*, socklen_t);\n     int     connect(int, const scope sockaddr*, socklen_t);\n@@ -2199,7 +1757,7 @@ else\n AF_INET6\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum\n     {\n@@ -2248,24 +1806,6 @@ else version (Solaris)\n         AF_INET6 = 26,\n     }\n }\n-else version (CRuntime_Bionic)\n-{\n-    enum\n-    {\n-        AF_INET6    = 10\n-    }\n-}\n-else version (CRuntime_Musl)\n-{\n-    enum AF_INET6 = 10;\n-}\n-else version (CRuntime_UClibc)\n-{\n-    enum\n-    {\n-        AF_INET6    = 10\n-    }\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");\n@@ -2278,7 +1818,7 @@ else\n SOCK_RAW\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum\n     {\n@@ -2327,27 +1867,6 @@ else version (Solaris)\n         SOCK_RAW = 4,\n     }\n }\n-else version (CRuntime_Bionic)\n-{\n-    enum\n-    {\n-        SOCK_RAW    = 3\n-    }\n-}\n-else version (CRuntime_Musl)\n-{\n-    enum\n-    {\n-        SOCK_RAW    = 3\n-    }\n-}\n-else version (CRuntime_UClibc)\n-{\n-    enum\n-    {\n-        SOCK_RAW    = 3\n-    }\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");"}, {"sha": "51455a98e6f603d841e5e9a8249e42bfdbafb42f", "filename": "libphobos/libdruntime/core/sys/posix/sys/stat.d", "status": "modified", "additions": 320, "deletions": 817, "changes": 1137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -55,45 +55,16 @@ struct stat\n     time_t  st_ctime;\n }\n \n-S_IRWXU\n-    S_IRUSR\n-    S_IWUSR\n-    S_IXUSR\n-S_IRWXG\n-    S_IRGRP\n-    S_IWGRP\n-    S_IXGRP\n-S_IRWXO\n-    S_IROTH\n-    S_IWOTH\n-    S_IXOTH\n S_ISUID\n S_ISGID\n S_ISVTX\n \n-S_ISBLK(m)\n-S_ISCHR(m)\n-S_ISDIR(m)\n-S_ISFIFO(m)\n-S_ISREG(m)\n-S_ISLNK(m)\n-S_ISSOCK(m)\n-\n S_TYPEISMQ(buf)\n S_TYPEISSEM(buf)\n S_TYPEISSHM(buf)\n-\n-int    chmod(const scope char*, mode_t);\n-int    fchmod(int, mode_t);\n-int    fstat(int, stat*);\n-int    lstat(const scope char*, stat*);\n-int    mkdir(const scope char*, mode_t);\n-int    mkfifo(const scope char*, mode_t);\n-int    stat(const scope char*, stat*);\n-mode_t umask(mode_t);\n  */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     version (X86)\n     {\n@@ -956,41 +927,10 @@ version (CRuntime_Glibc)\n     else\n         static assert(0, \"unimplemented\");\n \n-    enum S_IRUSR    = 0x100; // octal 0400\n-    enum S_IWUSR    = 0x080; // octal 0200\n-    enum S_IXUSR    = 0x040; // octal 0100\n-    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;\n-\n-    enum S_IRGRP    = S_IRUSR >> 3;\n-    enum S_IWGRP    = S_IWUSR >> 3;\n-    enum S_IXGRP    = S_IXUSR >> 3;\n-    enum S_IRWXG    = S_IRWXU >> 3;\n-\n-    enum S_IROTH    = S_IRGRP >> 3;\n-    enum S_IWOTH    = S_IWGRP >> 3;\n-    enum S_IXOTH    = S_IXGRP >> 3;\n-    enum S_IRWXO    = S_IRWXG >> 3;\n-\n     enum S_ISUID    = 0x800; // octal 04000\n     enum S_ISGID    = 0x400; // octal 02000\n     enum S_ISVTX    = 0x200; // octal 01000\n \n-    private\n-    {\n-        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n-        {\n-            return ( mode & S_IFMT ) == mask;\n-        }\n-    }\n-\n-    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n-    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n-    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n-    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n-    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n-    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n-    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n-\n     static if ( true /*__USE_POSIX199309*/ )\n     {\n         extern bool S_TYPEISMQ( stat_t* buf )  { return false; }\n@@ -1000,10 +940,6 @@ version (CRuntime_Glibc)\n \n     enum UTIME_NOW = 0x3fffffff;\n     enum UTIME_OMIT = 0x3ffffffe;\n-\n-    int utimensat(int dirfd, const char *pathname,\n-        ref const(timespec)[2] times, int flags);\n-    int futimens(int fd, ref const(timespec)[2] times);\n }\n else version (Darwin)\n {\n@@ -1049,40 +985,9 @@ else version (Darwin)\n         long[2]     st_qspare;\n     }\n \n-    enum S_IRUSR    = 0x100;  // octal 0400\n-    enum S_IWUSR    = 0x080;  // octal 0200\n-    enum S_IXUSR    = 0x040;  // octal 0100\n-    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;\n-\n-    enum S_IRGRP    = S_IRUSR >> 3;\n-    enum S_IWGRP    = S_IWUSR >> 3;\n-    enum S_IXGRP    = S_IXUSR >> 3;\n-    enum S_IRWXG    = S_IRWXU >> 3;\n-\n-    enum S_IROTH    = S_IRGRP >> 3;\n-    enum S_IWOTH    = S_IWGRP >> 3;\n-    enum S_IXOTH    = S_IXGRP >> 3;\n-    enum S_IRWXO    = S_IRWXG >> 3;\n-\n     enum S_ISUID    = 0x800; // octal 04000\n     enum S_ISGID    = 0x400; // octal 02000\n     enum S_ISVTX    = 0x200; // octal 01000\n-\n-    private\n-    {\n-        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n-        {\n-            return ( mode & S_IFMT ) == mask;\n-        }\n-    }\n-\n-    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n-    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n-    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n-    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n-    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n-    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n-    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n }\n else version (FreeBSD)\n {\n@@ -1164,51 +1069,12 @@ else version (FreeBSD)\n         }\n     }\n \n-    enum S_IRUSR    = 0x100; // octal 0000400\n-    enum S_IWUSR    = 0x080; // octal 0000200\n-    enum S_IXUSR    = 0x040; // octal 0000100\n-    enum S_IRWXU    = 0x1C0; // octal 0000700\n-\n-    enum S_IRGRP    = 0x020;  // octal 0000040\n-    enum S_IWGRP    = 0x010;  // octal 0000020\n-    enum S_IXGRP    = 0x008;  // octal 0000010\n-    enum S_IRWXG    = 0x038;  // octal 0000070\n-\n-    enum S_IROTH    = 0x4; // 0000004\n-    enum S_IWOTH    = 0x2; // 0000002\n-    enum S_IXOTH    = 0x1; // 0000001\n-    enum S_IRWXO    = 0x7; // 0000007\n-\n     enum S_ISUID    = 0x800; // octal 0004000\n     enum S_ISGID    = 0x400; // octal 0002000\n     enum S_ISVTX    = 0x200; // octal 0001000\n \n-    private\n-    {\n-        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n-        {\n-            return ( mode & S_IFMT ) == mask;\n-        }\n-    }\n-\n-    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n-    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n-    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n-    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n-    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n-    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n-    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n-\n     enum UTIME_NOW = -1;\n     enum UTIME_OMIT = -2;\n-\n-    // Since FreeBSD 11:\n-    version (none)\n-    {\n-        int utimensat(int dirfd, const char *pathname,\n-            ref const(timespec)[2] times, int flags);\n-        int futimens(int fd, ref const(timespec)[2] times);\n-    }\n }\n else version (NetBSD)\n {\n@@ -1237,40 +1103,9 @@ else version (NetBSD)\n         uint32_t[2]  st_spare;\n     }\n \n-    enum S_IRUSR    = 0x100; // octal 0000400\n-    enum S_IWUSR    = 0x080; // octal 0000200\n-    enum S_IXUSR    = 0x040; // octal 0000100\n-    enum S_IRWXU    = 0x1C0; // octal 0000700\n-\n-    enum S_IRGRP    = 0x020;  // octal 0000040\n-    enum S_IWGRP    = 0x010;  // octal 0000020\n-    enum S_IXGRP    = 0x008;  // octal 0000010\n-    enum S_IRWXG    = 0x038;  // octal 0000070\n-\n-    enum S_IROTH    = 0x4; // 0000004\n-    enum S_IWOTH    = 0x2; // 0000002\n-    enum S_IXOTH    = 0x1; // 0000001\n-    enum S_IRWXO    = 0x7; // 0000007\n-\n     enum S_ISUID    = 0x800; // octal 0004000\n     enum S_ISGID    = 0x400; // octal 0002000\n     enum S_ISVTX    = 0x200; // octal 0001000\n-\n-    private\n-    {\n-        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n-        {\n-            return ( mode & S_IFMT ) == mask;\n-        }\n-    }\n-\n-    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n-    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n-    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n-    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n-    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n-    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n-    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n }\n else version (OpenBSD)\n {\n@@ -1322,32 +1157,9 @@ else version (OpenBSD)\n       }\n     }\n \n-    enum S_IRUSR    = 0x100; // octal 0000400\n-    enum S_IWUSR    = 0x080; // octal 0000200\n-    enum S_IXUSR    = 0x040; // octal 0000100\n-    enum S_IRWXU    = 0x1C0; // octal 0000700\n-\n-    enum S_IRGRP    = 0x020;  // octal 0000040\n-    enum S_IWGRP    = 0x010;  // octal 0000020\n-    enum S_IXGRP    = 0x008;  // octal 0000010\n-    enum S_IRWXG    = 0x038;  // octal 0000070\n-\n-    enum S_IROTH    = 0x4; // 0000004\n-    enum S_IWOTH    = 0x2; // 0000002\n-    enum S_IXOTH    = 0x1; // 0000001\n-    enum S_IRWXO    = 0x7; // 0000007\n-\n     enum S_ISUID    = 0x800; // octal 0004000\n     enum S_ISGID    = 0x400; // octal 0002000\n     enum S_ISVTX    = 0x200; // octal 0001000\n-\n-    extern (D) bool S_ISBLK(mode_t mode)  { return (mode & S_IFMT) == S_IFBLK;  }\n-    extern (D) bool S_ISCHR(mode_t mode)  { return (mode & S_IFMT) == S_IFCHR;  }\n-    extern (D) bool S_ISDIR(mode_t mode)  { return (mode & S_IFMT) == S_IFDIR;  }\n-    extern (D) bool S_ISFIFO(mode_t mode) { return (mode & S_IFMT) == S_IFIFO;  }\n-    extern (D) bool S_ISREG(mode_t mode)  { return (mode & S_IFMT) == S_IFREG;  }\n-    extern (D) bool S_ISLNK(mode_t mode)  { return (mode & S_IFMT) == S_IFLNK;  }\n-    extern (D) bool S_ISSOCK(mode_t mode) { return (mode & S_IFMT) == S_IFSOCK; }\n }\n else version (DragonFlyBSD)\n {\n@@ -1376,40 +1188,9 @@ else version (DragonFlyBSD)\n             int64_t   st_qspare2;\n     }\n \n-    enum S_IRUSR    = 0x100; // octal 0000400\n-    enum S_IWUSR    = 0x080; // octal 0000200\n-    enum S_IXUSR    = 0x040; // octal 0000100\n-    enum S_IRWXU    = 0x1C0; // octal 0000700\n-\n-    enum S_IRGRP    = 0x020;  // octal 0000040\n-    enum S_IWGRP    = 0x010;  // octal 0000020\n-    enum S_IXGRP    = 0x008;  // octal 0000010\n-    enum S_IRWXG    = 0x038;  // octal 0000070\n-\n-    enum S_IROTH    = 0x4; // 0000004\n-    enum S_IWOTH    = 0x2; // 0000002\n-    enum S_IXOTH    = 0x1; // 0000001\n-    enum S_IRWXO    = 0x7; // 0000007\n-\n     enum S_ISUID    = 0x800; // octal 0004000\n     enum S_ISGID    = 0x400; // octal 0002000\n     enum S_ISVTX    = 0x200; // octal 0001000\n-\n-    private\n-    {\n-        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n-        {\n-            return ( mode & S_IFMT ) == mask;\n-        }\n-    }\n-\n-    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n-    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n-    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n-    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n-    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n-    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n-    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n }\n else version (Solaris)\n {\n@@ -1525,154 +1306,110 @@ else version (Solaris)\n \n     }\n \n-    enum S_IRUSR = 0x100;\n-    enum S_IWUSR = 0x080;\n-    enum S_IXUSR = 0x040;\n-    enum S_IRWXU = 0x1C0;\n-\n-    enum S_IRGRP = 0x020;\n-    enum S_IWGRP = 0x010;\n-    enum S_IXGRP = 0x008;\n-    enum S_IRWXG = 0x038;\n-\n-    enum S_IROTH = 0x4; // 0000004\n-    enum S_IWOTH = 0x2; // 0000002\n-    enum S_IXOTH = 0x1; // 0000001\n-    enum S_IRWXO = 0x7; // 0000007\n-\n     enum S_ISUID = 0x800;\n     enum S_ISGID = 0x400;\n     enum S_ISVTX = 0x200;\n-\n-    private\n-    {\n-        extern (D) bool S_ISTYPE(mode_t mode, uint mask)\n-        {\n-            return (mode & S_IFMT) == mask;\n-        }\n-    }\n-\n-    extern (D) bool S_ISBLK(mode_t mode) { return S_ISTYPE(mode, S_IFBLK); }\n-    extern (D) bool S_ISCHR(mode_t mode) { return S_ISTYPE(mode, S_IFCHR); }\n-    extern (D) bool S_ISDIR(mode_t mode) { return S_ISTYPE(mode, S_IFDIR); }\n-    extern (D) bool S_ISFIFO(mode_t mode) { return S_ISTYPE(mode, S_IFIFO); }\n-    extern (D) bool S_ISREG(mode_t mode) { return S_ISTYPE(mode, S_IFREG); }\n-    extern (D) bool S_ISLNK(mode_t mode) { return S_ISTYPE(mode, S_IFLNK); }\n-    extern (D) bool S_ISSOCK(mode_t mode) { return S_ISTYPE(mode, S_IFSOCK); }\n-    extern (D) bool S_ISDOOR(mode_t mode) { return S_ISTYPE(mode, S_IFDOOR); }\n-    extern (D) bool S_ISPORT(mode_t mode) { return S_ISTYPE(mode, S_IFPORT); }\n }\n-else version (CRuntime_Bionic)\n+else\n {\n-    version (X86)\n-    {\n-        struct stat_t\n-        {\n-            ulong       st_dev;\n-            ubyte[4]    __pad0;\n-            c_ulong     __st_ino;\n-            uint        st_mode;\n-            uint        st_nlink;\n-            c_ulong     st_uid;\n-            c_ulong     st_gid;\n-            ulong       st_rdev;\n-            ubyte[4]    __pad3;\n-\n-            long        st_size;\n-            c_ulong     st_blksize;\n-            ulong       st_blocks;\n-            c_ulong     st_atime;\n-            c_ulong     st_atime_nsec;\n-            c_ulong     st_mtime;\n-            c_ulong     st_mtime_nsec;\n-            c_ulong     st_ctime;\n-            c_ulong     st_ctime_nsec;\n-            ulong       st_ino;\n-        }\n-    }\n-    else version (ARM)\n-    {\n-        struct stat_t\n-        {\n-            ulong       st_dev;\n-            ubyte[4]    __pad0;\n-            c_ulong     __st_ino;\n-            uint        st_mode;\n-            uint        st_nlink;\n-            c_ulong     st_uid;\n-            c_ulong     st_gid;\n-            ulong       st_rdev;\n-            ubyte[4]    __pad3;\n-\n-            long        st_size;\n-            c_ulong     st_blksize;\n-            ulong       st_blocks;\n-            c_ulong     st_atime;\n-            c_ulong     st_atime_nsec;\n-            c_ulong     st_mtime;\n-            c_ulong     st_mtime_nsec;\n-            c_ulong     st_ctime;\n-            c_ulong     st_ctime_nsec;\n-            ulong       st_ino;\n-        }\n-    }\n-    else version (AArch64)\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+S_IRWXU\n+    S_IRUSR\n+    S_IWUSR\n+    S_IXUSR\n+S_IRWXG\n+    S_IRGRP\n+    S_IWGRP\n+    S_IXGRP\n+S_IRWXO\n+    S_IROTH\n+    S_IWOTH\n+    S_IXOTH\n+\n+S_ISBLK(m)\n+S_ISCHR(m)\n+S_ISDIR(m)\n+S_ISFIFO(m)\n+S_ISREG(m)\n+S_ISLNK(m)\n+S_ISSOCK(m)\n+ */\n+\n+version (CRuntime_Glibc)\n+{\n+    enum S_IRUSR    = 0x100; // octal 0400\n+    enum S_IWUSR    = 0x080; // octal 0200\n+    enum S_IXUSR    = 0x040; // octal 0100\n+    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;\n+\n+    enum S_IRGRP    = S_IRUSR >> 3;\n+    enum S_IWGRP    = S_IWUSR >> 3;\n+    enum S_IXGRP    = S_IXUSR >> 3;\n+    enum S_IRWXG    = S_IRWXU >> 3;\n+\n+    enum S_IROTH    = S_IRGRP >> 3;\n+    enum S_IWOTH    = S_IWGRP >> 3;\n+    enum S_IXOTH    = S_IXGRP >> 3;\n+    enum S_IRWXO    = S_IRWXG >> 3;\n+\n+    private\n     {\n-        struct stat_t\n+        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n         {\n-            ulong       st_dev;\n-            ulong       st_ino;\n-            uint        st_mode;\n-            uint        st_nlink;\n-            uid_t       st_uid;\n-            gid_t       st_gid;\n-            ulong       st_rdev;\n-            ulong       __pad1;\n-\n-            long        st_size;\n-            int         st_blksize;\n-            int         __pad2;\n-            long        st_blocks;\n-            long        st_atime;\n-            ulong       st_atime_nsec;\n-            long        st_mtime;\n-            ulong       st_mtime_nsec;\n-            long        st_ctime;\n-            ulong       st_ctime_nsec;\n-            uint        __unused4;\n-            uint        __unused5;\n+            return ( mode & S_IFMT ) == mask;\n         }\n     }\n-    else version (X86_64)\n+\n+    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n+    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n+    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n+    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n+    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n+    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n+    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n+\n+    int utimensat(int dirfd, const char *pathname,\n+        ref const(timespec)[2] times, int flags);\n+    int futimens(int fd, ref const(timespec)[2] times);\n+}\n+else version (Darwin)\n+{\n+    enum S_IRUSR    = 0x100;  // octal 0400\n+    enum S_IWUSR    = 0x080;  // octal 0200\n+    enum S_IXUSR    = 0x040;  // octal 0100\n+    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;\n+\n+    enum S_IRGRP    = S_IRUSR >> 3;\n+    enum S_IWGRP    = S_IWUSR >> 3;\n+    enum S_IXGRP    = S_IXUSR >> 3;\n+    enum S_IRWXG    = S_IRWXU >> 3;\n+\n+    enum S_IROTH    = S_IRGRP >> 3;\n+    enum S_IWOTH    = S_IWGRP >> 3;\n+    enum S_IXOTH    = S_IXGRP >> 3;\n+    enum S_IRWXO    = S_IRWXG >> 3;\n+\n+    private\n     {\n-        struct stat_t\n+        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n         {\n-            ulong       st_dev;\n-            ulong       st_ino;\n-            ulong       st_nlink;\n-            uint        st_mode;\n-            uid_t       st_uid;\n-            gid_t       st_gid;\n-            uint        __pad0;\n-\n-            ulong       st_rdev;\n-            long        st_size;\n-            long        st_blksize;\n-            long        st_blocks;\n-            long        st_atime;\n-            ulong       st_atime_nsec;\n-            long        st_mtime;\n-            ulong       st_mtime_nsec;\n-            long        st_ctime;\n-            ulong       st_ctime_nsec;\n-            long[3]     __pad3;\n+            return ( mode & S_IFMT ) == mask;\n         }\n     }\n-    else\n-    {\n-        static assert(false, \"Architecture not supported.\");\n-    }\n \n+    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n+    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n+    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n+    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n+    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n+    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n+    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n+}\n+else version (FreeBSD)\n+{\n     enum S_IRUSR    = 0x100; // octal 0000400\n     enum S_IWUSR    = 0x080; // octal 0000200\n     enum S_IXUSR    = 0x040; // octal 0000100\n@@ -1688,271 +1425,104 @@ else version (CRuntime_Bionic)\n     enum S_IXOTH    = 0x1; // 0000001\n     enum S_IRWXO    = 0x7; // 0000007\n \n-    enum S_ISUID    = 0x800; // octal 0004000\n-    enum S_ISGID    = 0x400; // octal 0002000\n-    enum S_ISVTX    = 0x200; // octal 0001000\n-\n     private\n     {\n-        extern (D) bool S_ISTYPE( uint mode, uint mask )\n+        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n         {\n             return ( mode & S_IFMT ) == mask;\n         }\n     }\n \n-    extern (D) bool S_ISBLK( uint mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n-    extern (D) bool S_ISCHR( uint mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n-    extern (D) bool S_ISDIR( uint mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n-    extern (D) bool S_ISFIFO( uint mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n-    extern (D) bool S_ISREG( uint mode )  { return S_ISTYPE( mode, S_IFREG );  }\n-    extern (D) bool S_ISLNK( uint mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n-    extern (D) bool S_ISSOCK( uint mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n-\n-    // Added since Lollipop\n-    int utimensat(int dirfd, const char *pathname,\n-        ref const(timespec)[2] times, int flags);\n-}\n-else version (CRuntime_Musl)\n-{\n-    alias __mode_t = uint;\n-    enum {\n-        S_IRUSR    = 0x100, // octal 0400\n-        S_IWUSR    = 0x080, // octal 0200\n-        S_IXUSR    = 0x040, // octal 0100\n-        S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR,\n-\n-        S_IRGRP    = S_IRUSR >> 3,\n-        S_IWGRP    = S_IWUSR >> 3,\n-        S_IXGRP    = S_IXUSR >> 3,\n-        S_IRWXG    = S_IRWXU >> 3,\n-\n-        S_IROTH    = S_IRGRP >> 3,\n-        S_IWOTH    = S_IWGRP >> 3,\n-        S_IXOTH    = S_IXGRP >> 3,\n-        S_IRWXO    = S_IRWXG >> 3,\n-\n-        S_ISUID    = 0x800, // octal 04000\n-        S_ISGID    = 0x400, // octal 02000\n-        S_ISVTX    = 0x200, // octal 01000\n-    }\n-    version (ARM)\n-    {\n-        struct stat_t\n-        {\n-            dev_t st_dev;\n-            int __st_dev_padding;\n-            c_long __st_ino_truncated;\n-            mode_t st_mode;\n-            nlink_t st_nlink;\n-\n-            uid_t st_uid;\n-            gid_t st_gid;\n-            dev_t st_rdev;\n-            int __st_rdev_padding;\n-            off_t st_size;\n-            blksize_t st_blksize;\n-            blkcnt_t st_blocks;\n-\n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n-            ino_t st_ino;\n-\n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n-        }\n-    }\n-    else version (AArch64)\n-    {\n-        struct stat_t\n-        {\n-            dev_t st_dev;\n-            ino_t st_ino;\n-            mode_t st_mode;\n-            nlink_t st_nlink;\n-\n-            uid_t st_uid;\n-            gid_t st_gid;\n-            dev_t st_rdev;\n-            c_ulong __pad;\n-            off_t st_size;\n-            blksize_t st_blksize;\n-            int __pad2;\n-            blkcnt_t st_blocks;\n-\n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n-            uint[2] __unused;\n+    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n+    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n+    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n+    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n+    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n+    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n+    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n \n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n-        }\n-    }\n-    else version (X86_64)\n+    // Since FreeBSD 11:\n+    version (none)\n     {\n-        struct stat_t\n-        {\n-            dev_t st_dev;\n-            ino_t st_ino;\n-            nlink_t st_nlink;\n-\n-            mode_t st_mode;\n-            uid_t st_uid;\n-            gid_t st_gid;\n-            uint   __pad0;\n-            dev_t st_rdev;\n-            off_t st_size;\n-            blksize_t st_blksize;\n-            blkcnt_t st_blocks;\n-\n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n-\n-            c_long[3] __unused;\n-\n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n-        }\n+        int utimensat(int dirfd, const char *pathname,\n+            ref const(timespec)[2] times, int flags);\n+        int futimens(int fd, ref const(timespec)[2] times);\n     }\n-    else version (X86)\n-    {\n-        struct stat_t\n-        {\n-            dev_t st_dev;\n-            int __st_dev_padding;\n-            c_long __st_ino_truncated;\n-            mode_t st_mode;\n-            nlink_t st_nlink;\n+}\n+else version (NetBSD)\n+{\n+    enum S_IRUSR    = 0x100; // octal 0000400\n+    enum S_IWUSR    = 0x080; // octal 0000200\n+    enum S_IXUSR    = 0x040; // octal 0000100\n+    enum S_IRWXU    = 0x1C0; // octal 0000700\n \n-            uid_t st_uid;\n-            gid_t st_gid;\n-            dev_t st_rdev;\n-            int __st_rdev_padding;\n-            off_t st_size;\n-            blksize_t st_blksize;\n-            blkcnt_t st_blocks;\n+    enum S_IRGRP    = 0x020;  // octal 0000040\n+    enum S_IWGRP    = 0x010;  // octal 0000020\n+    enum S_IXGRP    = 0x008;  // octal 0000010\n+    enum S_IRWXG    = 0x038;  // octal 0000070\n \n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n-            ino_t st_ino;\n+    enum S_IROTH    = 0x4; // 0000004\n+    enum S_IWOTH    = 0x2; // 0000002\n+    enum S_IXOTH    = 0x1; // 0000001\n+    enum S_IRWXO    = 0x7; // 0000007\n \n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n-        }\n-    }\n-    else version (MIPS64)\n+    private\n     {\n-        struct stat_t\n+        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n         {\n-            dev_t st_dev;\n-            int[3] __pad1;\n-            ino_t st_ino;\n-            mode_t st_mode;\n-            nlink_t st_nlink;\n-\n-            uid_t st_uid;\n-            gid_t st_gid;\n-            dev_t st_rdev;\n-            uint[2] __pad2;\n-            off_t st_size;\n-            int __pad3;\n-\n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n-            blksize_t st_blksize;\n-            uint __pad4;\n-            blkcnt_t st_blocks;\n-            int[14] __pad5;\n-\n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n+            return ( mode & S_IFMT ) == mask;\n         }\n     }\n-    else version (PPC64)\n-    {\n-        struct stat_t\n-        {\n-            dev_t st_dev;\n-            ino_t st_ino;\n-            nlink_t st_nlink;\n-            mode_t st_mode;\n-\n-            uid_t st_uid;\n-            gid_t st_gid;\n-            dev_t st_rdev;\n-            off_t st_size;\n-            blksize_t st_blksize;\n-            blkcnt_t st_blocks;\n \n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n-            c_ulong[3] __unused;\n+    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n+    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n+    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n+    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n+    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n+    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n+    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n+}\n+else version (OpenBSD)\n+{\n+    enum S_IRUSR    = 0x100; // octal 0000400\n+    enum S_IWUSR    = 0x080; // octal 0000200\n+    enum S_IXUSR    = 0x040; // octal 0000100\n+    enum S_IRWXU    = 0x1C0; // octal 0000700\n \n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n-        }\n-    }\n-    else version (SystemZ)\n-    {\n-        struct stat_t\n-        {\n-            dev_t st_dev;\n-            ino_t st_ino;\n-            nlink_t st_nlink;\n-            mode_t st_mode;\n+    enum S_IRGRP    = 0x020;  // octal 0000040\n+    enum S_IWGRP    = 0x010;  // octal 0000020\n+    enum S_IXGRP    = 0x008;  // octal 0000010\n+    enum S_IRWXG    = 0x038;  // octal 0000070\n \n-            uid_t st_uid;\n-            gid_t st_gid;\n-            dev_t st_rdev;\n-            off_t st_size;\n+    enum S_IROTH    = 0x4; // 0000004\n+    enum S_IWOTH    = 0x2; // 0000002\n+    enum S_IXOTH    = 0x1; // 0000001\n+    enum S_IRWXO    = 0x7; // 0000007\n \n-            timespec st_atim;\n-            timespec st_mtim;\n-            timespec st_ctim;\n+    extern (D) bool S_ISBLK(mode_t mode)  { return (mode & S_IFMT) == S_IFBLK;  }\n+    extern (D) bool S_ISCHR(mode_t mode)  { return (mode & S_IFMT) == S_IFCHR;  }\n+    extern (D) bool S_ISDIR(mode_t mode)  { return (mode & S_IFMT) == S_IFDIR;  }\n+    extern (D) bool S_ISFIFO(mode_t mode) { return (mode & S_IFMT) == S_IFIFO;  }\n+    extern (D) bool S_ISREG(mode_t mode)  { return (mode & S_IFMT) == S_IFREG;  }\n+    extern (D) bool S_ISLNK(mode_t mode)  { return (mode & S_IFMT) == S_IFLNK;  }\n+    extern (D) bool S_ISSOCK(mode_t mode) { return (mode & S_IFMT) == S_IFSOCK; }\n+}\n+else version (DragonFlyBSD)\n+{\n+    enum S_IRUSR    = 0x100; // octal 0000400\n+    enum S_IWUSR    = 0x080; // octal 0000200\n+    enum S_IXUSR    = 0x040; // octal 0000100\n+    enum S_IRWXU    = 0x1C0; // octal 0000700\n \n-            blksize_t st_blksize;\n-            blkcnt_t st_blocks;\n-            c_ulong[3] __unused;\n+    enum S_IRGRP    = 0x020;  // octal 0000040\n+    enum S_IWGRP    = 0x010;  // octal 0000020\n+    enum S_IXGRP    = 0x008;  // octal 0000010\n+    enum S_IRWXG    = 0x038;  // octal 0000070\n \n-            extern(D) @safe @property inout pure nothrow\n-            {\n-                ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-            }\n-        }\n-    }\n-    else\n-        static assert(\"Unsupported platform\");\n+    enum S_IROTH    = 0x4; // 0000004\n+    enum S_IWOTH    = 0x2; // 0000002\n+    enum S_IXOTH    = 0x1; // 0000001\n+    enum S_IRWXO    = 0x7; // 0000007\n \n     private\n     {\n@@ -1969,176 +1539,120 @@ else version (CRuntime_Musl)\n     extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n     extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n     extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n-\n-    int utimensat(int dirfd, const char *pathname,\n-        ref const(timespec)[2] times, int flags);\n }\n-else version (CRuntime_UClibc)\n+else version (Solaris)\n {\n-    version (X86_64)\n-    {\n-        struct stat_t\n-        {\n-            dev_t       st_dev;\n-            ino_t       st_ino;\n-            nlink_t     st_nlink;\n-            mode_t      st_mode;\n-            uid_t       st_uid;\n-            gid_t       st_gid;\n-            uint        __pad0;\n-            dev_t       st_rdev;\n-            off_t       st_size;\n-            blksize_t   st_blksize;\n-            blkcnt_t    st_blocks;\n-            time_t      st_atime;\n-            ulong_t     st_atimensec;\n-            time_t      st_mtime;\n-            ulong_t     st_mtimensec;\n-            time_t      st_ctime;\n-            ulong_t     st_ctimensec;\n-            slong_t[3]     __unused;\n-        }\n-    }\n-    else version (MIPS_O32)\n+    enum S_IRUSR = 0x100;\n+    enum S_IWUSR = 0x080;\n+    enum S_IXUSR = 0x040;\n+    enum S_IRWXU = 0x1C0;\n+\n+    enum S_IRGRP = 0x020;\n+    enum S_IWGRP = 0x010;\n+    enum S_IXGRP = 0x008;\n+    enum S_IRWXG = 0x038;\n+\n+    enum S_IROTH = 0x4; // 0000004\n+    enum S_IWOTH = 0x2; // 0000002\n+    enum S_IXOTH = 0x1; // 0000001\n+    enum S_IRWXO = 0x7; // 0000007\n+\n+    private\n     {\n-        struct stat_t\n+        extern (D) bool S_ISTYPE(mode_t mode, uint mask)\n         {\n-            c_ulong     st_dev;\n-            c_long[3]   st_pad1;\n-            ino_t       st_ino;\n-            mode_t      st_mode;\n-            nlink_t     st_nlink;\n-            uid_t       st_uid;\n-            gid_t       st_gid;\n-            c_ulong     st_rdev;\n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                c_long[2]   st_pad2;\n-                off_t       st_size;\n-                c_long      st_pad3;\n-            }\n-            else\n-            {\n-                c_long[3]   st_pad2;\n-                off_t       st_size;\n-            }\n-            static if (__USE_MISC || __USE_XOPEN2K8)\n-            {\n-                timespec    st_atim;\n-                timespec    st_mtim;\n-                timespec    st_ctim;\n-                extern(D) @safe @property inout pure nothrow\n-                {\n-                    ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n-                    ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n-                    ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n-                }\n-            }\n-            else\n-            {\n-                time_t      st_atime;\n-                c_ulong     st_atimensec;\n-                time_t      st_mtime;\n-                c_ulong     st_mtimensec;\n-                time_t      st_ctime;\n-                c_ulong     st_ctimensec;\n-            }\n-            blksize_t   st_blksize;\n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                blkcnt_t    st_blocks;\n-            }\n-            else\n-            {\n-                c_long      st_pad4;\n-                blkcnt_t    st_blocks;\n-            }\n-            c_long[14]  st_pad5;\n+            return (mode & S_IFMT) == mask;\n         }\n     }\n-    else version (ARM)\n+\n+    extern (D) bool S_ISBLK(mode_t mode) { return S_ISTYPE(mode, S_IFBLK); }\n+    extern (D) bool S_ISCHR(mode_t mode) { return S_ISTYPE(mode, S_IFCHR); }\n+    extern (D) bool S_ISDIR(mode_t mode) { return S_ISTYPE(mode, S_IFDIR); }\n+    extern (D) bool S_ISFIFO(mode_t mode) { return S_ISTYPE(mode, S_IFIFO); }\n+    extern (D) bool S_ISREG(mode_t mode) { return S_ISTYPE(mode, S_IFREG); }\n+    extern (D) bool S_ISLNK(mode_t mode) { return S_ISTYPE(mode, S_IFLNK); }\n+    extern (D) bool S_ISSOCK(mode_t mode) { return S_ISTYPE(mode, S_IFSOCK); }\n+    extern (D) bool S_ISDOOR(mode_t mode) { return S_ISTYPE(mode, S_IFDOOR); }\n+    extern (D) bool S_ISPORT(mode_t mode) { return S_ISTYPE(mode, S_IFPORT); }\n+}\n+else version (CRuntime_Bionic)\n+{\n+    enum S_IRUSR    = 0x100; // octal 0000400\n+    enum S_IWUSR    = 0x080; // octal 0000200\n+    enum S_IXUSR    = 0x040; // octal 0000100\n+    enum S_IRWXU    = 0x1C0; // octal 0000700\n+\n+    enum S_IRGRP    = 0x020;  // octal 0000040\n+    enum S_IWGRP    = 0x010;  // octal 0000020\n+    enum S_IXGRP    = 0x008;  // octal 0000010\n+    enum S_IRWXG    = 0x038;  // octal 0000070\n+\n+    enum S_IROTH    = 0x4; // 0000004\n+    enum S_IWOTH    = 0x2; // 0000002\n+    enum S_IXOTH    = 0x1; // 0000001\n+    enum S_IRWXO    = 0x7; // 0000007\n+\n+    private\n     {\n-        private\n+        extern (D) bool S_ISTYPE( uint mode, uint mask )\n         {\n-            alias __dev_t = ulong;\n-            alias __ino_t = c_ulong;\n-            alias __ino64_t = ulong;\n-            alias __mode_t = uint;\n-            alias __nlink_t = size_t;\n-            alias __uid_t = uint;\n-            alias __gid_t = uint;\n-            alias __off_t = c_long;\n-            alias __off64_t = long;\n-            alias __blksize_t = c_long;\n-            alias __blkcnt_t = c_long;\n-            alias __blkcnt64_t = long;\n-            alias __timespec = timespec;\n-            alias __time_t = time_t;\n+            return ( mode & S_IFMT ) == mask;\n         }\n-        struct stat_t\n-        {\n-            __dev_t st_dev;\n-            ushort __pad1;\n+    }\n \n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                __ino_t st_ino;\n-            }\n-            else\n-            {\n-                __ino_t __st_ino;\n-            }\n-            __mode_t st_mode;\n-            __nlink_t st_nlink;\n-            __uid_t st_uid;\n-            __gid_t st_gid;\n-            __dev_t st_rdev;\n-            ushort __pad2;\n+    extern (D) bool S_ISBLK( uint mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n+    extern (D) bool S_ISCHR( uint mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n+    extern (D) bool S_ISDIR( uint mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n+    extern (D) bool S_ISFIFO( uint mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n+    extern (D) bool S_ISREG( uint mode )  { return S_ISTYPE( mode, S_IFREG );  }\n+    extern (D) bool S_ISLNK( uint mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n+    extern (D) bool S_ISSOCK( uint mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n \n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                __off_t st_size;\n-            }\n-            else\n-            {\n-                __off64_t st_size;\n-            }\n-            __blksize_t st_blksize;\n+    // Added since Lollipop\n+    int utimensat(int dirfd, const char *pathname,\n+        ref const(timespec)[2] times, int flags);\n+}\n+else version (CRuntime_Musl)\n+{\n+    alias __mode_t = uint;\n+    enum {\n+        S_IRUSR    = 0x100, // octal 0400\n+        S_IWUSR    = 0x080, // octal 0200\n+        S_IXUSR    = 0x040, // octal 0100\n+        S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR,\n \n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                __blkcnt_t st_blocks;\n-            }\n-            else\n-            {\n-                __blkcnt64_t st_blocks;\n-            }\n+        S_IRGRP    = S_IRUSR >> 3,\n+        S_IWGRP    = S_IWUSR >> 3,\n+        S_IXGRP    = S_IXUSR >> 3,\n+        S_IRWXG    = S_IRWXU >> 3,\n \n-            __time_t st_atime;\n-            c_ulong st_atimensec;\n-            __time_t st_mtime;\n-            c_ulong st_mtimensec;\n-            __time_t st_ctime;\n-            c_ulong st_ctimensec;\n+        S_IROTH    = S_IRGRP >> 3,\n+        S_IWOTH    = S_IWGRP >> 3,\n+        S_IXOTH    = S_IXGRP >> 3,\n+        S_IRWXO    = S_IRWXG >> 3,\n+    }\n \n-            static if (!__USE_FILE_OFFSET64)\n-            {\n-                c_ulong __unused4;\n-                c_ulong __unused5;\n-            }\n-            else\n-            {\n-                __ino64_t st_ino;\n-            }\n+    private\n+    {\n+        extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n+        {\n+            return ( mode & S_IFMT ) == mask;\n         }\n-        static if (__USE_FILE_OFFSET64)\n-            static assert(stat_t.sizeof == 104);\n-        else\n-            static assert(stat_t.sizeof == 88);\n     }\n-    else\n-        static assert(0, \"unimplemented\");\n \n+    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }\n+    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }\n+    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }\n+    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }\n+    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }\n+    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n+    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n+\n+    int utimensat(int dirfd, const char *pathname,\n+        ref const(timespec)[2] times, int flags);\n+}\n+else version (CRuntime_UClibc)\n+{\n     enum S_IRUSR    = 0x100; // octal 0400\n     enum S_IWUSR    = 0x080; // octal 0200\n     enum S_IXUSR    = 0x040; // octal 0100\n@@ -2154,10 +1668,6 @@ else version (CRuntime_UClibc)\n     enum S_IXOTH    = S_IXGRP >> 3;\n     enum S_IRWXO    = S_IRWXG >> 3;\n \n-    enum S_ISUID    = 0x800; // octal 04000\n-    enum S_ISGID    = 0x400; // octal 02000\n-    enum S_ISVTX    = 0x200; // octal 01000\n-\n     private\n     {\n         extern (D) bool S_ISTYPE( mode_t mode, uint mask )\n@@ -2174,16 +1684,6 @@ else version (CRuntime_UClibc)\n     extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }\n     extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }\n \n-    static if ( true /*__USE_POSIX199309*/ )\n-    {\n-        extern bool S_TYPEISMQ( stat_t* buf )  { return false; }\n-        extern bool S_TYPEISSEM( stat_t* buf ) { return false; }\n-        extern bool S_TYPEISSHM( stat_t* buf ) { return false; }\n-    }\n-\n-    enum UTIME_NOW = 0x3fffffff;\n-    enum UTIME_OMIT = 0x3ffffffe;\n-\n     int utimensat(int dirfd, const char *pathname,\n     ref const(timespec)[2] times, int flags);\n     int futimens(int fd, ref const(timespec)[2] times);\n@@ -2193,6 +1693,17 @@ else\n     static assert(false, \"Unsupported platform\");\n }\n \n+/*\n+int    chmod(const scope char*, mode_t);\n+int    fchmod(int, mode_t);\n+int    fstat(int, stat*);\n+int    lstat(const scope char*, stat*);\n+int    mkdir(const scope char*, mode_t);\n+int    mkfifo(const scope char*, mode_t);\n+int    stat(const scope char*, stat*);\n+mode_t umask(mode_t);\n+*/\n+\n int    chmod(const scope char*, mode_t);\n int    fchmod(int, mode_t);\n //int    fstat(int, stat_t*);\n@@ -2385,11 +1896,9 @@ S_IFREG\n S_IFDIR\n S_IFLNK\n S_IFSOCK\n-\n-int mknod(in 3char*, mode_t, dev_t);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum S_IFMT     = 0xF000; // octal 0170000\n     enum S_IFBLK    = 0x6000; // octal 0060000\n@@ -2399,8 +1908,6 @@ version (CRuntime_Glibc)\n     enum S_IFDIR    = 0x4000; // octal 0040000\n     enum S_IFLNK    = 0xA000; // octal 0120000\n     enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n-    int mknod(const scope char*, mode_t, dev_t);\n }\n else version (Darwin)\n {\n@@ -2412,8 +1919,6 @@ else version (Darwin)\n     enum S_IFDIR    = 0x4000; // octal 0040000\n     enum S_IFLNK    = 0xA000; // octal 0120000\n     enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n-    int mknod(const scope char*, mode_t, dev_t);\n }\n else version (FreeBSD)\n {\n@@ -2425,18 +1930,6 @@ else version (FreeBSD)\n     enum S_IFDIR    = 0x4000; // octal 0040000\n     enum S_IFLNK    = 0xA000; // octal 0120000\n     enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n-    version (GNU)\n-    {\n-        int mknod(const scope char*, mode_t, dev_t);\n-    }\n-    else\n-    {\n-        static if (__FreeBSD_version >= INO64_FIRST)\n-            pragma(mangle, \"mknod@FBSD_1.5\") int mknod(const scope char*, mode_t, dev_t);\n-        else\n-            pragma(mangle, \"mknod@FBSD_1.0\") int mknod(const scope char*, mode_t, dev_t);\n-    }\n }\n else version (NetBSD)\n {\n@@ -2448,8 +1941,6 @@ else version (NetBSD)\n     enum S_IFDIR    = 0x4000; // octal 0040000\n     enum S_IFLNK    = 0xA000; // octal 0120000\n     enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n-    int mknod(const scope char*, mode_t, dev_t);\n }\n else version (OpenBSD)\n {\n@@ -2461,8 +1952,6 @@ else version (OpenBSD)\n     enum S_IFDIR    = 0x4000; // octal 0040000\n     enum S_IFLNK    = 0xA000; // octal 0120000\n     enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n-    int mknod(const scope char*, mode_t, dev_t);\n }\n else version (DragonFlyBSD)\n {\n@@ -2474,8 +1963,6 @@ else version (DragonFlyBSD)\n     enum S_IFDIR    = 0x4000; // octal 0040000\n     enum S_IFLNK    = 0xA000; // octal 0120000\n     enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n-    int mknod(const scope char*, mode_t, dev_t);\n }\n else version (Solaris)\n {\n@@ -2489,48 +1976,64 @@ else version (Solaris)\n     enum S_IFSOCK = 0xC000;\n     enum S_IFDOOR = 0xD000;\n     enum S_IFPORT = 0xE000;\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n \n+/*\n+int mknod(const scope char*, mode_t, dev_t);\n+*/\n+\n+version (CRuntime_Glibc)\n+{\n+    int mknod(const scope char*, mode_t, dev_t);\n+}\n+else version (Darwin)\n+{\n+    int mknod(const scope char*, mode_t, dev_t);\n+}\n+else version (FreeBSD)\n+{\n+    version (GNU)\n+    {\n+        int mknod(const scope char*, mode_t, dev_t);\n+    }\n+    else\n+    {\n+        static if (__FreeBSD_version >= INO64_FIRST)\n+            pragma(mangle, \"mknod@FBSD_1.5\") int mknod(const scope char*, mode_t, dev_t);\n+        else\n+            pragma(mangle, \"mknod@FBSD_1.0\") int mknod(const scope char*, mode_t, dev_t);\n+    }\n+}\n+else version (NetBSD)\n+{\n+    int mknod(const scope char*, mode_t, dev_t);\n+}\n+else version (OpenBSD)\n+{\n+    int mknod(const scope char*, mode_t, dev_t);\n+}\n+else version (DragonFlyBSD)\n+{\n+    int mknod(const scope char*, mode_t, dev_t);\n+}\n+else version (Solaris)\n+{\n     int mknod(const scope char*, mode_t, dev_t);\n }\n else version (CRuntime_Bionic)\n {\n-    enum S_IFMT     = 0xF000; // octal 0170000\n-    enum S_IFBLK    = 0x6000; // octal 0060000\n-    enum S_IFCHR    = 0x2000; // octal 0020000\n-    enum S_IFIFO    = 0x1000; // octal 0010000\n-    enum S_IFREG    = 0x8000; // octal 0100000\n-    enum S_IFDIR    = 0x4000; // octal 0040000\n-    enum S_IFLNK    = 0xA000; // octal 0120000\n-    enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n     int mknod(const scope char*, mode_t, dev_t);\n }\n else version (CRuntime_Musl)\n {\n-    enum {\n-        S_IFMT     = 0xF000, // octal 0170000\n-        S_IFBLK    = 0x6000, // octal 0060000\n-        S_IFCHR    = 0x2000, // octal 0020000\n-        S_IFIFO    = 0x1000, // octal 0010000\n-        S_IFREG    = 0x8000, // octal 0100000\n-        S_IFDIR    = 0x4000, // octal 0040000\n-        S_IFLNK    = 0xA000, // octal 0120000\n-        S_IFSOCK   = 0xC000, // octal 0140000\n-    }\n-\n     int mknod(const scope char*, mode_t, dev_t);\n }\n else version (CRuntime_UClibc)\n {\n-    enum S_IFMT     = 0xF000; // octal 0170000\n-    enum S_IFBLK    = 0x6000; // octal 0060000\n-    enum S_IFCHR    = 0x2000; // octal 0020000\n-    enum S_IFIFO    = 0x1000; // octal 0010000\n-    enum S_IFREG    = 0x8000; // octal 0100000\n-    enum S_IFDIR    = 0x4000; // octal 0040000\n-    enum S_IFLNK    = 0xA000; // octal 0120000\n-    enum S_IFSOCK   = 0xC000; // octal 0140000\n-\n     int mknod(const scope char*, mode_t, dev_t);\n }\n else"}, {"sha": "02cf799ff27a706d8f8b3e75b643a6fd173d53a9", "filename": "libphobos/libdruntime/core/sys/posix/sys/types.d", "status": "modified", "additions": 34, "deletions": 171, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftypes.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftypes.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Ftypes.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -86,7 +86,7 @@ time_t\n uid_t\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n   static if ( __USE_FILE_OFFSET64 )\n   {\n@@ -108,71 +108,40 @@ version (CRuntime_Glibc)\n     alias int       pid_t;\n     //size_t (defined in core.stdc.stddef)\n     alias c_long    ssize_t;\n-    alias slong_t   time_t;\n     alias uint      uid_t;\n-}\n-else version (CRuntime_Musl)\n-{\n-    version (AArch64)\n-    {\n-        alias int    blksize_t;\n-        alias uint   nlink_t;\n-    }\n-    else version (MIPS64)\n-    {\n-        alias c_long blksize_t;\n-        alias uint   nlink_t;\n-    }\n-    else version (RISCV64)\n-    {\n-        alias int    blksize_t;\n-        alias uint   nlink_t;\n+\n+    version (CRuntime_Musl)\n+    {\n+        /**\n+         * Musl versions before v1.2.0 (up to v1.1.24) had different\n+         * definitions for `time_t` for 32 bits.\n+         * This was changed to always be 64 bits in v1.2.0:\n+         * https://musl.libc.org/time64.html\n+         * This change was only for 32 bits system and\n+         * didn't affect 64 bits systems\n+         *\n+         * To check previous definitions, `grep` for `time_t` in `arch/`,\n+         * and the result should be (in v1.1.24):\n+         * ---\n+         * // arch/riscv64/bits/alltypes.h.in:20:TYPEDEF long time_t;\n+         * // arch/s390x/bits/alltypes.h.in:17:TYPEDEF long time_t;\n+         * // arch/sh/bits/alltypes.h.in:21:TYPEDEF long time_t;\n+         * ---\n+         *\n+         * In order to be compatible with old versions of Musl,\n+         * one can recompile druntime with `CRuntime_Musl_Pre_Time64`.\n+         */\n+        version (D_X32)\n+           alias long   time_t;\n+        else version (CRuntime_Musl_Pre_Time64)\n+            alias c_long time_t;\n+        else\n+            alias long  time_t;\n     }\n     else\n     {\n-        alias c_long blksize_t;\n-        alias c_ulong nlink_t;\n-    }\n-    alias long       dev_t;\n-    alias long       blkcnt_t;\n-    alias ulong      ino_t;\n-    alias long       off_t;\n-    alias int        pid_t;\n-    alias uint       uid_t;\n-    alias uint       gid_t;\n-\n-    /**\n-     * Musl versions before v1.2.0 (up to v1.1.24) had different\n-     * definitions for `time_t` for 32 bits.\n-     * This was changed to always be 64 bits in v1.2.0:\n-     * https://musl.libc.org/time64.html\n-     * This change was only for 32 bits system and\n-     * didn't affect 64 bits systems\n-     *\n-     * To check previous definitions, `grep` for `time_t` in `arch/`,\n-     * and the result should be (in v1.1.24):\n-     * ---\n-     * // arch/riscv64/bits/alltypes.h.in:20:TYPEDEF long time_t;\n-     * // arch/s390x/bits/alltypes.h.in:17:TYPEDEF long time_t;\n-     * // arch/sh/bits/alltypes.h.in:21:TYPEDEF long time_t;\n-     * ---\n-     *\n-     * In order to be compatible with old versions of Musl,\n-     * one can recompile druntime with `CRuntime_Musl_Pre_Time64`.\n-     */\n-    version (D_X32)\n-        alias long   time_t;\n-    else version (CRuntime_Musl_Pre_Time64)\n-        alias c_long time_t;\n-    else\n-        alias long   time_t;\n-\n-    alias c_long     clock_t;\n-    alias c_ulong    pthread_t;\n-    version (D_LP64)\n-        alias c_long ssize_t;\n-    else\n-        alias int    ssize_t;\n+        alias slong_t   time_t;\n+    }\n }\n else version (Darwin)\n {\n@@ -311,67 +280,6 @@ else version (Solaris)\n     alias c_long time_t;\n     alias uint uid_t;\n }\n-else version (CRuntime_Bionic)\n-{\n-    alias c_ulong   blkcnt_t;\n-    alias c_ulong   blksize_t;\n-    alias size_t    dev_t;\n-    alias uint      gid_t;\n-    alias c_ulong   ino_t;\n-    alias c_long    off_t;\n-    alias int       pid_t;\n-    alias c_long    ssize_t;\n-    alias c_long    time_t;\n-    alias uint      uid_t;\n-\n-    version (D_LP64)\n-    {\n-        alias uint      mode_t;\n-        alias uint      nlink_t;\n-    }\n-    else\n-    {\n-        alias ushort    mode_t;\n-        alias ushort    nlink_t;\n-    }\n-}\n-else version (CRuntime_UClibc)\n-{\n-    static if ( __USE_FILE_OFFSET64 )\n-    {\n-        alias long      blkcnt_t;\n-        alias ulong     ino_t;\n-        alias long      off_t;\n-    }\n-    else\n-    {\n-        alias slong_t   blkcnt_t;\n-        alias ulong_t   ino_t;\n-        alias slong_t   off_t;\n-    }\n-\n-    version (D_LP64)\n-    {\n-        alias ino_t ino64_t;\n-        alias off_t off64_t;\n-    }\n-    else\n-    {\n-        alias ulong ino64_t;\n-        alias long off64_t;\n-    }\n-\n-    alias slong_t   blksize_t;\n-    alias c_ulong   dev_t;\n-    alias uint      gid_t;\n-    alias uint      mode_t;\n-    alias uint      nlink_t;\n-    alias int       pid_t;\n-    //size_t (defined in core.stdc.stddef)\n-    alias c_long    ssize_t;\n-    alias slong_t   time_t;\n-    alias uint      uid_t;\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");\n@@ -390,7 +298,7 @@ suseconds_t\n useconds_t\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n   static if ( __USE_FILE_OFFSET64 )\n   {\n@@ -483,53 +391,6 @@ else version (Solaris)\n     alias id_t zoneid_t;\n     alias id_t ctid_t;\n }\n-else version (CRuntime_Bionic)\n-{\n-    alias c_ulong  fsblkcnt_t;\n-    alias c_ulong  fsfilcnt_t;\n-    alias c_long   clock_t;\n-    alias uint     id_t;\n-    alias int      key_t;\n-    alias c_long   suseconds_t;\n-    alias uint     useconds_t; // Updated in Lollipop\n-}\n-else version (CRuntime_Musl)\n-{\n-  static if ( __USE_FILE_OFFSET64 )\n-  {\n-    alias ulong     fsblkcnt_t;\n-    alias ulong     fsfilcnt_t;\n-  }\n-  else\n-  {\n-    alias ulong_t   fsblkcnt_t;\n-    alias ulong_t   fsfilcnt_t;\n-  }\n-    alias uint mode_t;\n-    alias uint id_t;\n-    version (D_X32)\n-        alias long susseconds_t;\n-    else\n-        alias c_long suseconds_t;\n-}\n-else version (CRuntime_UClibc)\n-{\n-  static if ( __USE_FILE_OFFSET64 )\n-  {\n-    alias ulong     fsblkcnt_t;\n-    alias ulong     fsfilcnt_t;\n-  }\n-  else\n-  {\n-    alias ulong_t   fsblkcnt_t;\n-    alias ulong_t   fsfilcnt_t;\n-  }\n-    alias slong_t   clock_t;\n-    alias uint      id_t;\n-    alias int       key_t;\n-    alias slong_t   suseconds_t;\n-    alias uint      useconds_t;\n-}\n else\n {\n     static assert(false, \"Unsupported platform\");\n@@ -896,6 +757,8 @@ else version (CRuntime_Musl)\n     }\n \n     alias int pthread_once_t;\n+\n+    alias c_ulong pthread_t;\n }\n else version (Darwin)\n {"}, {"sha": "91b9c9e8409017f74de4be8eeea0ffa50eae1ca1", "filename": "libphobos/libdruntime/core/sys/posix/sys/wait.d", "status": "modified", "additions": 112, "deletions": 105, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fwait.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fwait.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fwait.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -38,30 +38,96 @@ extern (C) nothrow @nogc:\n /*\n WNOHANG\n WUNTRACED\n+*/\n+\n+version (linux)\n+{\n+    enum WNOHANG        = 1;\n+    enum WUNTRACED      = 2;\n+\n+    private\n+    {\n+        enum __W_CONTINUED = 0xFFFF;\n+    }\n+}\n+else version (Darwin)\n+{\n+    enum WNOHANG        = 1;\n+    enum WUNTRACED      = 2;\n+\n+    private\n+    {\n+        enum _WSTOPPED = 0x7F; // octal 0177\n+    }\n+}\n+else version (FreeBSD)\n+{\n+    enum WNOHANG        = 1;\n+    enum WUNTRACED      = 2;\n+\n+    private\n+    {\n+        enum _WSTOPPED = 0x7F; // octal 0177\n+        enum __W_CONTINUED = 0x13;\n+    }\n+}\n+else version (NetBSD)\n+{\n+    enum WNOHANG        = 1;\n+    enum WUNTRACED      = 2;\n+\n+    private\n+    {\n+        enum _WSTOPPED = 0x7F; // octal 0177\n+    }\n+}\n+else version (OpenBSD)\n+{\n+    enum WNOHANG        = 1;\n+    enum WUNTRACED      = 2;\n+\n+    private\n+    {\n+        enum _WSTOPPED   = 0x7F;   // octal 0177\n+        enum _WCONTINUED = 0xFFFF; // octal 0177777\n+    }\n+}\n+else version (DragonFlyBSD)\n+{\n+    enum WNOHANG        = 1;\n+    enum WUNTRACED      = 2;\n \n+    private\n+    {\n+        enum _WSTOPPED = 0x7F; // octal 0177\n+    }\n+}\n+else version (Solaris)\n+{\n+    enum WNOHANG        = 64;\n+    enum WUNTRACED      = 4;\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n WEXITSTATUS\n WIFCONTINUED\n WIFEXITED\n WIFSIGNALED\n WIFSTOPPED\n WSTOPSIG\n WTERMSIG\n-\n-pid_t wait(int*);\n-pid_t waitpid(pid_t, int*, int);\n */\n \n version (CRuntime_Glibc)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n     private\n     {\n-        enum __W_CONTINUED = 0xFFFF;\n-\n         extern (D) int __WTERMSIG( int status ) { return status & 0x7F; }\n     }\n \n@@ -85,14 +151,6 @@ else version (Darwin)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n-    private\n-    {\n-        enum _WSTOPPED = 0x7F; // octal 0177\n-    }\n-\n     extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }\n     extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }\n     extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }\n@@ -109,14 +167,6 @@ else version (FreeBSD)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n-    private\n-    {\n-        enum _WSTOPPED = 0x7F; // octal 0177\n-    }\n-\n     extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }\n     extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }\n     extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }\n@@ -133,14 +183,6 @@ else version (NetBSD)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n-    private\n-    {\n-        enum _WSTOPPED = 0x7F; // octal 0177\n-    }\n-\n     extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }\n     extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }\n     extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }\n@@ -157,15 +199,6 @@ else version (OpenBSD)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n-    private\n-    {\n-        enum _WSTOPPED   = 0x7F;   // octal 0177\n-        enum _WCONTINUED = 0xFFFF; // octal 0177777\n-    }\n-\n     extern (D) int _WSTATUS(int status)         { return (status & 0x7F);                     }\n     extern (D) int  WEXITSTATUS(int status)   { return (status >> 8) & 0xFF;                  }\n     extern (D) int  WIFCONTINUED(int status)  { return (status & _WCONTINUED) == _WCONTINUED; }\n@@ -182,14 +215,6 @@ else version (DragonFlyBSD)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n-    private\n-    {\n-        enum _WSTOPPED = 0x7F; // octal 0177\n-    }\n-\n     extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }\n     extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }\n     extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }\n@@ -206,9 +231,6 @@ else version (Solaris)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 64;\n-    enum WUNTRACED      = 4;\n-\n     extern (D) int WEXITSTATUS(int status) { return (status >> 8) & 0xff; }\n     extern (D) int WIFCONTINUED(int status) { return (status & 0xffff) == 0xffff; }\n     extern (D) bool WIFEXITED(int status) { return (status & 0xff) == 0;     }\n@@ -220,10 +242,6 @@ else version (Solaris)\n else version (CRuntime_Bionic)\n {\n     @safe pure:\n-\n-    enum WNOHANG   = 1;\n-    enum WUNTRACED = 2;\n-\n     extern (D) int  WEXITSTATUS( int status ) { return ( status & 0xFF00 ) >> 8; }\n     extern (D) bool WIFEXITED( int status ) { return WTERMSIG(status) == 0; }\n     extern (D) bool WIFSIGNALED( int status ) { return WTERMSIG(status + 1) >= 2; }\n@@ -234,10 +252,6 @@ else version (CRuntime_Bionic)\n else version (CRuntime_Musl)\n {\n     @safe pure:\n-\n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n     extern (D) int  WEXITSTATUS( int status ) { return ( status & 0xFF00 ) >> 8; }\n     extern (D) int  WIFCONTINUED( int status ) { return status == 0xffff; }\n     extern (D) bool WIFEXITED( int status ) { return WTERMSIG( status ) == 0; }\n@@ -250,13 +264,8 @@ else version (CRuntime_UClibc)\n {\n     @safe pure:\n \n-    enum WNOHANG        = 1;\n-    enum WUNTRACED      = 2;\n-\n     private\n     {\n-        enum __W_CONTINUED = 0xFFFF;\n-\n         extern (D) int __WTERMSIG( int status ) { return status & 0x7F; }\n     }\n \n@@ -288,6 +297,11 @@ else\n     static assert(false, \"Unsupported platform\");\n }\n \n+/*\n+pid_t wait(int*);\n+pid_t waitpid(pid_t, int*, int);\n+*/\n+\n pid_t wait(int*);\n pid_t waitpid(pid_t, int*, int);\n \n@@ -306,11 +320,9 @@ enum idtype_t\n     P_PID,\n     P_PGID\n }\n-\n-int waitid(idtype_t, id_t, siginfo_t*, int);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     enum WEXITED    = 4;\n     enum WSTOPPED   = 2;\n@@ -323,8 +335,6 @@ version (CRuntime_Glibc)\n         P_PID,\n         P_PGID\n     }\n-\n-    int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (Darwin)\n {\n@@ -339,8 +349,6 @@ else version (Darwin)\n         P_PID,\n         P_PGID\n     }\n-\n-    int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (FreeBSD)\n {\n@@ -369,8 +377,6 @@ else version (FreeBSD)\n         P_CPUID,\n         P_PSETID\n     }\n-\n-    int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (NetBSD)\n {\n@@ -419,50 +425,51 @@ else version (Solaris)\n         P_CPUID,        /* CPU identifier.                      */\n         P_PSETID,       /* Processor set identifier             */\n     }\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n+/*\n+int waitid(idtype_t, id_t, siginfo_t*, int);\n+*/\n \n+version (CRuntime_Glibc)\n+{\n+    int waitid(idtype_t, id_t, siginfo_t*, int);\n+}\n+else version (Darwin)\n+{\n+    int waitid(idtype_t, id_t, siginfo_t*, int);\n+}\n+else version (FreeBSD)\n+{\n+    int waitid(idtype_t, id_t, siginfo_t*, int);\n+}\n+else version (NetBSD)\n+{\n+}\n+else version (OpenBSD)\n+{\n+}\n+else version (DragonFlyBSD)\n+{\n+}\n+else version (Solaris)\n+{\n     int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (CRuntime_Bionic)\n {\n-    enum WEXITED    = 4;\n-    enum WSTOPPED   = 2;\n-    enum WCONTINUED = 8;\n-    enum WNOWAIT    = 0x01000000;\n-\n-    alias int idtype_t;\n-\n     int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (CRuntime_Musl)\n {\n-    enum WEXITED    = 4;\n-    enum WSTOPPED   = 2;\n-    enum WCONTINUED = 8;\n-    enum WNOWAIT    = 0x01000000;\n-\n-    enum idtype_t\n-    {\n-        P_ALL,\n-        P_PID,\n-        P_PGID\n-    }\n-\n     int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else version (CRuntime_UClibc)\n {\n-    enum WEXITED    = 4;\n-    enum WSTOPPED   = 2;\n-    enum WCONTINUED = 8;\n-    enum WNOWAIT    = 0x01000000;\n-\n-    enum idtype_t\n-    {\n-        P_ALL,\n-        P_PID,\n-        P_PGID\n-    }\n-\n     int waitid(idtype_t, id_t, siginfo_t*, int);\n }\n else"}, {"sha": "357060bd57f2b70a63ef1b52d1016f436462ce62", "filename": "libphobos/libdruntime/core/sys/posix/termios.d", "status": "modified", "additions": 96, "deletions": 185, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftermios.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftermios.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftermios.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -129,20 +129,9 @@ TCIOFF\n TCION\n TCOOFF\n TCOON\n-\n-speed_t cfgetispeed(const scope termios*);\n-speed_t cfgetospeed(const scope termios*);\n-int     cfsetispeed(termios*, speed_t);\n-int     cfsetospeed(termios*, speed_t);\n-int     tcdrain(int);\n-int     tcflow(int, int);\n-int     tcflush(int, int);\n-int     tcgetattr(int, termios*);\n-int     tcsendbreak(int, int);\n-int     tcsetattr(int, int, const scope termios*);\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n     alias ubyte cc_t;\n     alias uint  speed_t;\n@@ -239,17 +228,6 @@ version (CRuntime_Glibc)\n     enum TCION      = 3;\n     enum TCOOFF     = 0;\n     enum TCOON      = 1;\n-\n-    speed_t cfgetispeed(const scope termios*);\n-    speed_t cfgetospeed(const scope termios*);\n-    int     cfsetispeed(termios*, speed_t);\n-    int     cfsetospeed(termios*, speed_t);\n-    int     tcdrain(int);\n-    int     tcflow(int, int);\n-    int     tcflush(int, int);\n-    int     tcgetattr(int, termios*);\n-    int     tcsendbreak(int, int);\n-    int     tcsetattr(int, int, const scope termios*);\n }\n else version (Darwin)\n {\n@@ -347,18 +325,6 @@ else version (Darwin)\n     enum TCION      = 4;\n     enum TCOOFF     = 1;\n     enum TCOON      = 2;\n-\n-    speed_t cfgetispeed(const scope termios*);\n-    speed_t cfgetospeed(const scope termios*);\n-    int     cfsetispeed(termios*, speed_t);\n-    int     cfsetospeed(termios*, speed_t);\n-    int     tcdrain(int);\n-    int     tcflow(int, int);\n-    int     tcflush(int, int);\n-    int     tcgetattr(int, termios*);\n-    int     tcsendbreak(int, int);\n-    int     tcsetattr(int, int, const scope termios*);\n-\n }\n else version (FreeBSD)\n {\n@@ -456,17 +422,6 @@ else version (FreeBSD)\n     enum TCION      = 4;\n     enum TCOOFF     = 1;\n     enum TCOON      = 2;\n-\n-    speed_t cfgetispeed(const scope termios*);\n-    speed_t cfgetospeed(const scope termios*);\n-    int     cfsetispeed(termios*, speed_t);\n-    int     cfsetospeed(termios*, speed_t);\n-    int     tcdrain(int);\n-    int     tcflow(int, int);\n-    int     tcflush(int, int);\n-    int     tcgetattr(int, termios*);\n-    int     tcsendbreak(int, int);\n-    int     tcsetattr(int, int, const scope termios*);\n }\n else version (DragonFlyBSD)\n {\n@@ -564,17 +519,6 @@ else version (DragonFlyBSD)\n     enum TCION      = 4;\n     enum TCOOFF     = 1;\n     enum TCOON      = 2;\n-\n-    speed_t cfgetispeed(const scope termios*);\n-    speed_t cfgetospeed(const scope termios*);\n-    int     cfsetispeed(termios*, speed_t);\n-    int     cfsetospeed(termios*, speed_t);\n-    int     tcdrain(int);\n-    int     tcflow(int, int);\n-    int     tcflush(int, int);\n-    int     tcgetattr(int, termios*);\n-    int     tcsendbreak(int, int);\n-    int     tcsetattr(int, int, const scope termios*);\n }\n else version (NetBSD)\n {\n@@ -672,17 +616,6 @@ else version (NetBSD)\n     enum TCION      = 4;\n     enum TCOOFF     = 1;\n     enum TCOON      = 2;\n-\n-    speed_t cfgetispeed(const scope termios*);\n-    speed_t cfgetospeed(const scope termios*);\n-    int     cfsetispeed(termios*, speed_t);\n-    int     cfsetospeed(termios*, speed_t);\n-    int     tcdrain(int);\n-    int     tcflow(int, int);\n-    int     tcflush(int, int);\n-    int     tcgetattr(int, termios*);\n-    int     tcsendbreak(int, int);\n-    int     tcsetattr(int, int, const scope termios*);\n }\n else version (OpenBSD)\n {\n@@ -780,17 +713,6 @@ else version (OpenBSD)\n     enum TCION      = 4;\n     enum TCOOFF     = 1;\n     enum TCOON      = 2;\n-\n-    speed_t cfgetispeed(const scope termios*);\n-    speed_t cfgetospeed(const scope termios*);\n-    int     cfsetispeed(termios*, speed_t);\n-    int     cfsetospeed(termios*, speed_t);\n-    int     tcdrain(int);\n-    int     tcflow(int, int);\n-    int     tcflush(int, int);\n-    int     tcgetattr(int, termios*);\n-    int     tcsendbreak(int, int);\n-    int     tcsetattr(int, int, const scope termios*);\n }\n else version (Solaris)\n {\n@@ -909,11 +831,102 @@ else version (Solaris)\n     enum B307200 = 21;\n     enum B460800 = 22;\n     enum B921600 = 23;\n+}\n+\n+/*\n+speed_t cfgetispeed(const scope termios*);\n+speed_t cfgetospeed(const scope termios*);\n+int     cfsetispeed(termios*, speed_t);\n+int     cfsetospeed(termios*, speed_t);\n+int     tcdrain(int);\n+int     tcflow(int, int);\n+int     tcflush(int, int);\n+int     tcgetattr(int, termios*);\n+int     tcsendbreak(int, int);\n+int     tcsetattr(int, int, const scope termios*);\n+*/\n \n-    /*\n-     * POSIX termios functions\n-     * These functions get mapped into ioctls.\n-     */\n+version (CRuntime_Glibc)\n+{\n+    speed_t cfgetispeed(const scope termios*);\n+    speed_t cfgetospeed(const scope termios*);\n+    int     cfsetispeed(termios*, speed_t);\n+    int     cfsetospeed(termios*, speed_t);\n+    int     tcdrain(int);\n+    int     tcflow(int, int);\n+    int     tcflush(int, int);\n+    int     tcgetattr(int, termios*);\n+    int     tcsendbreak(int, int);\n+    int     tcsetattr(int, int, const scope termios*);\n+}\n+else version (Darwin)\n+{\n+    speed_t cfgetispeed(const scope termios*);\n+    speed_t cfgetospeed(const scope termios*);\n+    int     cfsetispeed(termios*, speed_t);\n+    int     cfsetospeed(termios*, speed_t);\n+    int     tcdrain(int);\n+    int     tcflow(int, int);\n+    int     tcflush(int, int);\n+    int     tcgetattr(int, termios*);\n+    int     tcsendbreak(int, int);\n+    int     tcsetattr(int, int, const scope termios*);\n+\n+}\n+else version (FreeBSD)\n+{\n+    speed_t cfgetispeed(const scope termios*);\n+    speed_t cfgetospeed(const scope termios*);\n+    int     cfsetispeed(termios*, speed_t);\n+    int     cfsetospeed(termios*, speed_t);\n+    int     tcdrain(int);\n+    int     tcflow(int, int);\n+    int     tcflush(int, int);\n+    int     tcgetattr(int, termios*);\n+    int     tcsendbreak(int, int);\n+    int     tcsetattr(int, int, const scope termios*);\n+}\n+else version (DragonFlyBSD)\n+{\n+    speed_t cfgetispeed(const scope termios*);\n+    speed_t cfgetospeed(const scope termios*);\n+    int     cfsetispeed(termios*, speed_t);\n+    int     cfsetospeed(termios*, speed_t);\n+    int     tcdrain(int);\n+    int     tcflow(int, int);\n+    int     tcflush(int, int);\n+    int     tcgetattr(int, termios*);\n+    int     tcsendbreak(int, int);\n+    int     tcsetattr(int, int, const scope termios*);\n+}\n+else version (NetBSD)\n+{\n+    speed_t cfgetispeed(const scope termios*);\n+    speed_t cfgetospeed(const scope termios*);\n+    int     cfsetispeed(termios*, speed_t);\n+    int     cfsetospeed(termios*, speed_t);\n+    int     tcdrain(int);\n+    int     tcflow(int, int);\n+    int     tcflush(int, int);\n+    int     tcgetattr(int, termios*);\n+    int     tcsendbreak(int, int);\n+    int     tcsetattr(int, int, const scope termios*);\n+}\n+else version (OpenBSD)\n+{\n+    speed_t cfgetispeed(const scope termios*);\n+    speed_t cfgetospeed(const scope termios*);\n+    int     cfsetispeed(termios*, speed_t);\n+    int     cfsetospeed(termios*, speed_t);\n+    int     tcdrain(int);\n+    int     tcflow(int, int);\n+    int     tcflush(int, int);\n+    int     tcgetattr(int, termios*);\n+    int     tcsendbreak(int, int);\n+    int     tcsetattr(int, int, const scope termios*);\n+}\n+else version (Solaris)\n+{\n     speed_t cfgetospeed(const scope termios*);\n     int     cfsetospeed(termios*, speed_t);\n     speed_t cfgetispeed(const scope termios*);\n@@ -927,108 +940,6 @@ else version (Solaris)\n }\n else version (CRuntime_UClibc)\n {\n-    alias ubyte cc_t;\n-    alias uint  speed_t;\n-    alias uint  tcflag_t;\n-\n-    enum NCCS   = 32;\n-\n-    struct termios\n-    {\n-        tcflag_t   c_iflag;\n-        tcflag_t   c_oflag;\n-        tcflag_t   c_cflag;\n-        tcflag_t   c_lflag;\n-        cc_t       c_line;\n-        cc_t[NCCS] c_cc;\n-        speed_t    c_ispeed;\n-        speed_t    c_ospeed;\n-    }\n-\n-    enum VINTR      = 0;\n-    enum VQUIT      = 1;\n-    enum VERASE     = 2;\n-    enum VKILL      = 3;\n-    enum VEOF       = 4;\n-    enum VTIME      = 5;\n-    enum VMIN       = 6;\n-    enum VSWTC      = 7;\n-    enum VSTART     = 8;\n-    enum VSTOP      = 9;\n-    enum VSUSP      = 10;\n-    enum VEOL       = 11;\n-    enum VREPRINT   = 12;\n-    enum VDISCARD   = 13;\n-    enum VWERASE    = 14;\n-    enum VLNEXT     = 15;\n-    enum VEOL2      = 16;\n-\n-    enum BRKINT     = 0x0000002; // 0000002\n-    enum ICRNL      = 0x0000100; // 0000400\n-    enum IGNBRK     = 0x0000001; // 0000001\n-    enum IGNCR      = 0x0000080; // 0000200\n-    enum IGNPAR     = 0x0000004; // 0000004\n-    enum INLCR      = 0x0000040; // 0000100\n-    enum INPCK      = 0x0000010; // 0000020\n-    enum ISTRIP     = 0x0000020; // 0000040\n-    enum IXOFF      = 0x0001000; // 0010000\n-    enum IXON       = 0x0000400; // 0002000\n-    enum PARMRK     = 0x0000008; // 0000010\n-\n-    enum OPOST      = 0x0000001; // 0000001\n-\n-    enum B0         = 0x0000000; // 0000000\n-    enum B50        = 0x0000001; // 0000001\n-    enum B75        = 0x0000002; // 0000002\n-    enum B110       = 0x0000003; // 0000003\n-    enum B134       = 0x0000004; // 0000004\n-    enum B150       = 0x0000005; // 0000005\n-    enum B200       = 0x0000006; // 0000006\n-    enum B300       = 0x0000007; // 0000007\n-    enum B600       = 0x0000008; // 0000010\n-    enum B1200      = 0x0000009; // 0000011\n-    enum B1800      = 0x000000A; // 0000012\n-    enum B2400      = 0x000000B; // 0000013\n-    enum B4800      = 0x000000C; // 0000014\n-    enum B9600      = 0x000000D; // 0000015\n-    enum B19200     = 0x000000E; // 0000016\n-    enum B38400     = 0x000000F; // 0000017\n-\n-    enum CSIZE      = 0x0000030; // 0000060\n-    enum   CS5      = 0x0000000; // 0000000\n-    enum   CS6      = 0x0000010; // 0000020\n-    enum   CS7      = 0x0000020; // 0000040\n-    enum   CS8      = 0x0000030; // 0000060\n-    enum CSTOPB     = 0x0000040; // 0000100\n-    enum CREAD      = 0x0000080; // 0000200\n-    enum PARENB     = 0x0000100; // 0000400\n-    enum PARODD     = 0x0000200; // 0001000\n-    enum HUPCL      = 0x0000400; // 0002000\n-    enum CLOCAL     = 0x0000800; // 0004000\n-\n-    enum ECHO       = 0x0000008; // 0000010\n-    enum ECHOE      = 0x0000010; // 0000020\n-    enum ECHOK      = 0x0000020; // 0000040\n-    enum ECHONL     = 0x0000040; // 0000100\n-    enum ICANON     = 0x0000002; // 0000002\n-    enum IEXTEN     = 0x0008000; // 0100000\n-    enum ISIG       = 0x0000001; // 0000001\n-    enum NOFLSH     = 0x0000080; // 0000200\n-    enum TOSTOP     = 0x0000100; // 0000400\n-\n-    enum TCSANOW    = 0;\n-    enum TCSADRAIN  = 1;\n-    enum TCSAFLUSH  = 2;\n-\n-    enum TCIFLUSH   = 0;\n-    enum TCOFLUSH   = 1;\n-    enum TCIOFLUSH  = 2;\n-\n-    enum TCIOFF     = 2;\n-    enum TCION      = 3;\n-    enum TCOOFF     = 0;\n-    enum TCOON      = 1;\n-\n     speed_t cfgetispeed(const scope termios*);\n     speed_t cfgetospeed(const scope termios*);\n     int     cfsetispeed(termios*, speed_t);"}, {"sha": "20297f50b9022c922bdbfbf0dc560aaf1aeadbc4", "filename": "libphobos/libdruntime/core/sys/posix/ucontext.d", "status": "modified", "additions": 5, "deletions": 317, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fucontext.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fucontext.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fucontext.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -63,9 +63,8 @@ struct ucontext_t\n }\n */\n \n-version (CRuntime_Glibc)\n+version (linux)\n {\n-\n     version (X86_64)\n     {\n         enum\n@@ -146,7 +145,8 @@ version (CRuntime_Glibc)\n             mcontext_t      uc_mcontext;\n             sigset_t        uc_sigmask;\n             _libc_fpstate   __fpregs_mem;\n-            ulong[4]        __ssp;\n+            version (CRuntime_Glibc)\n+                ulong[4]    __ssp;\n         }\n     }\n     else version (X86)\n@@ -218,7 +218,8 @@ version (CRuntime_Glibc)\n             mcontext_t      uc_mcontext;\n             sigset_t        uc_sigmask;\n             _libc_fpstate   __fpregs_mem;\n-            c_ulong[4]      __ssp;\n+            version (CRuntime_Glibc)\n+                c_ulong[4]  __ssp;\n         }\n     }\n     else version (HPPA)\n@@ -788,139 +789,6 @@ version (CRuntime_Glibc)\n     else\n         static assert(0, \"unimplemented\");\n }\n-else version (CRuntime_Musl)\n-{\n-    version (AArch64)\n-    {\n-        struct mcontext_t\n-        {\n-            real[18+256] __regs;\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong     uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t     uc_stack;\n-            sigset_t    uc_sigmask;\n-            mcontext_t  uc_mcontext;\n-        }\n-    }\n-    else version (ARM)\n-    {\n-        struct mcontext_t\n-        {\n-            c_ulong[21] __regs;\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong     uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t     uc_stack;\n-            mcontext_t  uc_mcontext;\n-            sigset_t    uc_sigmask;\n-            ulong[64]   uc_regspace;\n-        }\n-    }\n-    else version (IBMZ_Any)\n-    {\n-        struct mcontext_t\n-        {\n-            c_ulong[18] __regs1;\n-            uint[18]    __regs2;\n-            double[16]  __regs3;\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong     uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t     uc_stack;\n-            mcontext_t  uc_mcontext;\n-            sigset_t    uc_sigmask;\n-        }\n-    }\n-    else version (MIPS_Any)\n-    {\n-        version (MIPS_N32)\n-        {\n-            struct mcontext_t\n-            {\n-                ulong[32]  __mc1;\n-                double[32] __mc2;\n-                ulong[9]   __mc3;\n-                uint[4]    __mc4;\n-            }\n-        }\n-        else version (MIPS64)\n-        {\n-            struct mcontext_t\n-            {\n-                ulong[32]  __mc1;\n-                double[32] __mc2;\n-                ulong[9]   __mc3;\n-                uint[4]    __mc4;\n-            }\n-        }\n-        else\n-        {\n-            struct mcontext_t\n-            {\n-                uint[2]    __mc1;\n-                ulong[65]  __mc2;\n-                uint[5]    __mc3;\n-                ulong[2]   __mc4;\n-                uint[6]    __mc5;\n-            }\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong     uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t     uc_stack;\n-            mcontext_t  uc_mcontext;\n-            sigset_t    uc_sigmask;\n-        }\n-    }\n-    else version (X86)\n-    {\n-        struct mcontext_t\n-        {\n-            uint[22] __space;\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong     uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t     uc_stack;\n-            mcontext_t  uc_mcontext;\n-            sigset_t    uc_sigmask;\n-            c_ulong[28] __fpregs_mem;\n-        }\n-    }\n-    else version (X86_64)\n-    {\n-        struct mcontext_t\n-        {\n-            ulong[32] __space;\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong     uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t     uc_stack;\n-            mcontext_t  uc_mcontext;\n-            sigset_t    uc_sigmask;\n-            ulong[64]   __fpregs_mem;\n-        }\n-    }\n-    else\n-        static assert(0, \"unimplemented\");\n-}\n else version (Darwin)\n {\n     private\n@@ -1722,186 +1590,6 @@ else version (Solaris)\n         }\n     }\n }\n-else version (CRuntime_UClibc)\n-{\n-    version (X86_64)\n-    {\n-        enum\n-        {\n-            REG_R8 = 0,\n-            REG_R9,\n-            REG_R10,\n-            REG_R11,\n-            REG_R12,\n-            REG_R13,\n-            REG_R14,\n-            REG_R15,\n-            REG_RDI,\n-            REG_RSI,\n-            REG_RBP,\n-            REG_RBX,\n-            REG_RDX,\n-            REG_RAX,\n-            REG_RCX,\n-            REG_RSP,\n-            REG_RIP,\n-            REG_EFL,\n-            REG_CSGSFS,     /* Actually short cs, gs, fs, __pad0.  */\n-            REG_ERR,\n-            REG_TRAPNO,\n-            REG_OLDMASK,\n-            REG_CR2\n-        }\n-\n-        alias sigcontext mcontext_t;\n-\n-        struct ucontext_t\n-        {\n-            c_ulong         uc_flags;\n-            ucontext_t*     uc_link;\n-            stack_t         uc_stack;\n-            mcontext_t      uc_mcontext;\n-            sigset_t        uc_sigmask;\n-        }\n-    }\n-    else version (MIPS32)\n-    {\n-        alias greg_t    = ulong;\n-        enum NGREG      = 32;\n-        enum NFPREG     = 32;\n-        alias gregset_t = greg_t[NGREG];\n-\n-        struct fpregset_t\n-        {\n-            union fp_r\n-            {\n-                double[NFPREG]  fp_dregs;\n-                struct _fp_fregs\n-                {\n-                    float   _fp_fregs;\n-                    uint    _fp_pad;\n-                }\n-                _fp_fregs[NFPREG] fp_fregs;\n-            }\n-        }\n-\n-        version (MIPS_O32)\n-        {\n-            struct mcontext_t\n-            {\n-                uint regmask;\n-                uint status;\n-                greg_t pc;\n-                gregset_t gregs;\n-                fpregset_t fpregs;\n-                uint fp_owned;\n-                uint fpc_csr;\n-                uint fpc_eir;\n-                uint used_math;\n-                uint dsp;\n-                greg_t mdhi;\n-                greg_t mdlo;\n-                c_ulong hi1;\n-                c_ulong lo1;\n-                c_ulong hi2;\n-                c_ulong lo2;\n-                c_ulong hi3;\n-                c_ulong lo3;\n-            }\n-        }\n-        else\n-        {\n-            struct mcontext_t\n-            {\n-                gregset_t gregs;\n-                fpregset_t fpregs;\n-                greg_t mdhi;\n-                greg_t hi1;\n-                greg_t hi2;\n-                greg_t hi3;\n-                greg_t mdlo;\n-                greg_t lo1;\n-                greg_t lo2;\n-                greg_t lo3;\n-                greg_t pc;\n-                uint fpc_csr;\n-                uint used_math;\n-                uint dsp;\n-                uint reserved;\n-            }\n-        }\n-\n-        struct ucontext_t\n-        {\n-            c_ulong uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t uc_stack;\n-            mcontext_t uc_mcontext;\n-            sigset_t uc_sigmask;\n-        }\n-    }\n-    else version (ARM)\n-    {\n-        enum\n-        {\n-            R0 = 0,\n-            R1 = 1,\n-            R2 = 2,\n-            R3 = 3,\n-            R4 = 4,\n-            R5 = 5,\n-            R6 = 6,\n-            R7 = 7,\n-            R8 = 8,\n-            R9 = 9,\n-            R10 = 10,\n-            R11 = 11,\n-            R12 = 12,\n-            R13 = 13,\n-            R14 = 14,\n-            R15 = 15\n-        }\n-\n-        struct sigcontext\n-        {\n-            c_ulong trap_no;\n-            c_ulong error_code;\n-            c_ulong oldmask;\n-            c_ulong arm_r0;\n-            c_ulong arm_r1;\n-            c_ulong arm_r2;\n-            c_ulong arm_r3;\n-            c_ulong arm_r4;\n-            c_ulong arm_r5;\n-            c_ulong arm_r6;\n-            c_ulong arm_r7;\n-            c_ulong arm_r8;\n-            c_ulong arm_r9;\n-            c_ulong arm_r10;\n-            c_ulong arm_fp;\n-            c_ulong arm_ip;\n-            c_ulong arm_sp;\n-            c_ulong arm_lr;\n-            c_ulong arm_pc;\n-            c_ulong arm_cpsr;\n-            c_ulong fault_address;\n-        }\n-\n-        alias sigcontext mcontext_t;\n-\n-        struct ucontext_t\n-        {\n-            c_ulong uc_flags;\n-            ucontext_t* uc_link;\n-            stack_t uc_stack;\n-            mcontext_t uc_mcontext;\n-            sigset_t uc_sigmask;\n-            align(8) c_ulong[128] uc_regspace;\n-        }\n-    }\n-    else\n-        static assert(0, \"unimplemented\");\n-}\n \n //\n // Obsolescent (OB)"}, {"sha": "343f003b50d53a01f23ccb129451033889b530c2", "filename": "libphobos/libdruntime/core/sys/solaris/dlfcn.d", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fdlfcn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fdlfcn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fdlfcn.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -14,21 +14,6 @@ nothrow:\n public import core.sys.posix.dlfcn;\n import core.stdc.config;\n \n-// enum RTLD_LAZY = 0x00001; // POSIX\n-// enum RTLD_NOW = 0x00002; // POSIX\n-enum RTLD_NOLOAD = 0x00004;\n-enum RTLD_DEEPBIND = 0x00008;\n-\n-// enum RTLD_GLOBAL = 0x00100; // POSIX\n-// enum RTLD_LOCAL = 0; // POSIX\n-enum RTLD_PARENT   = 0x00200;\n-enum RTLD_GROUP    = 0x00400;\n-enum RTLD_WORLD    = 0x00800;\n-enum RTLD_NODELETE = 0x01000;\n-enum RTLD_FIRST    = 0x02000;\n-enum RTLD_CONFGEN  = 0x10000;\n-\n-\n enum\n {\n     RTLD_NEXT    = cast(void *)-1,\n@@ -58,21 +43,12 @@ enum\n \n int dldump(const scope char*, const scope char*, int);\n \n-struct Dl_info\n-{\n-    const(char)* dli_fname;\n-    void*        dli_fbase;\n-    const(char)* dli_sname;\n-    void*        dli_saddr;\n-}\n-\n enum\n {\n     RTLD_DL_SYMENT = 1,\n     RTLD_DL_LINKMAP = 2,\n }\n \n-int dladdr(const(void)*, Dl_info*);\n int dladdr1(void*, Dl_info*, void**, int);\n \n enum"}, {"sha": "ba45c27d359d41f701f4df7005b7b7b1ab95026a", "filename": "libphobos/libdruntime/core/sys/windows/wingdi.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwingdi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwingdi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fwingdi.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -4191,8 +4191,8 @@ extern(Windows) nothrow @nogc {\n     DWORD GetGlyphOutlineA(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, PVOID, const(MAT2)*);\n     DWORD GetGlyphOutlineW(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, PVOID, const(MAT2)*);\n     int GetGraphicsMode(HDC);\n-    BOOL GetICMProfileA(HDC, DWORD, LPSTR);\n-    BOOL GetICMProfileW(HDC, DWORD, LPWSTR);\n+    BOOL GetICMProfileA(HDC, LPDWORD, LPSTR);\n+    BOOL GetICMProfileW(HDC, LPDWORD, LPWSTR);\n     DWORD GetKerningPairsA(HDC, DWORD, LPKERNINGPAIR);\n     DWORD GetKerningPairsW(HDC, DWORD, LPKERNINGPAIR);\n     BOOL GetLogColorSpaceA(HCOLORSPACE, LPLOGCOLORSPACEA, DWORD);"}, {"sha": "ca368098b4b642d74da1e0ae3c0ddb9e6977f3e6", "filename": "libphobos/libdruntime/core/thread/osthread.d", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fthread%2Fosthread.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -246,15 +246,6 @@ else\n  */\n class Thread : ThreadBase\n {\n-    //\n-    // Main process thread\n-    //\n-    version (FreeBSD)\n-    {\n-        // set when suspend failed and should be retried, see Issue 13416\n-        private shared bool m_suspendagain;\n-    }\n-\n     //\n     // Standard thread data\n     //\n@@ -2019,7 +2010,6 @@ extern (C) void thread_suspendAll() nothrow\n             // subtract own thread\n             assert(cnt >= 1);\n             --cnt;\n-        Lagain:\n             // wait for semaphore notifications\n             for (; cnt; --cnt)\n             {\n@@ -2030,20 +2020,6 @@ extern (C) void thread_suspendAll() nothrow\n                     errno = 0;\n                 }\n             }\n-            version (FreeBSD)\n-            {\n-                // avoid deadlocks, see Issue 13416\n-                t = ThreadBase.sm_tbeg.toThread;\n-                while (t)\n-                {\n-                    auto tn = t.next;\n-                    if (t.m_suspendagain && suspend(t))\n-                        ++cnt;\n-                    t = tn.toThread;\n-                }\n-                if (cnt)\n-                    goto Lagain;\n-            }\n         }\n     }\n }\n@@ -2480,7 +2456,6 @@ else version (Posix)\n                 status = sigdelset( &sigres, resumeSignalNumber );\n                 assert( status == 0 );\n \n-                version (FreeBSD) obj.m_suspendagain = false;\n                 status = sem_post( &suspendCount );\n                 assert( status == 0 );\n \n@@ -2491,19 +2466,6 @@ else version (Posix)\n                     obj.m_curr.tstack = obj.m_curr.bstack;\n                 }\n             }\n-\n-            // avoid deadlocks on FreeBSD, see Issue 13416\n-            version (FreeBSD)\n-            {\n-                auto obj = Thread.getThis();\n-                if (THR_IN_CRITICAL(obj.m_addr))\n-                {\n-                    obj.m_suspendagain = true;\n-                    if (sem_post(&suspendCount)) assert(0);\n-                    return;\n-                }\n-            }\n-\n             callWithStackShell(&op);\n         }\n \n@@ -2517,29 +2479,6 @@ else version (Posix)\n         {\n \n         }\n-\n-        // HACK libthr internal (thr_private.h) macro, used to\n-        // avoid deadlocks in signal handler, see Issue 13416\n-        version (FreeBSD) bool THR_IN_CRITICAL(pthread_t p) nothrow @nogc\n-        {\n-            import core.sys.posix.config : c_long;\n-            import core.sys.posix.sys.types : lwpid_t;\n-\n-            // If the begin of pthread would be changed in libthr (unlikely)\n-            // we'll run into undefined behavior, compare with thr_private.h.\n-            static struct pthread\n-            {\n-                c_long tid;\n-                static struct umutex { lwpid_t owner; uint flags; uint[2] ceilings; uint[4] spare; }\n-                umutex lock;\n-                uint cycle;\n-                int locklevel;\n-                int critical_count;\n-                // ...\n-            }\n-            auto priv = cast(pthread*)p;\n-            return priv.locklevel > 0 || priv.critical_count > 0;\n-        }\n     }\n }\n else"}, {"sha": "7bb6bec7ed94d3709d024903c405a5e0b60cee00", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 302, "deletions": 81, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -180,7 +180,30 @@ class Object\n     /**\n      * Test whether $(D this) is equal to $(D o).\n      * The default implementation only compares by identity (using the $(D is) operator).\n-     * Generally, overrides for $(D opEquals) should attempt to compare objects by their contents.\n+     * Generally, overrides and overloads for $(D opEquals) should attempt to compare objects by their contents.\n+     * A class will most likely want to add an overload that takes your specific type as the argument\n+     * and does the content comparison. Then you can override this and forward it to your specific\n+     * typed overload with a cast. Remember to check for `null` on the typed overload.\n+     *\n+     * Examples:\n+     * ---\n+     * class Child {\n+     *    int contents;\n+     *    // the typed overload first. It can use all the attribute you want\n+     *    bool opEquals(const Child c) const @safe pure nothrow @nogc\n+     *    {\n+     *        if (c is null)\n+     *            return false;\n+     *        return this.contents == c.contents;\n+     *    }\n+     *\n+     *    // and now the generic override forwards with a cast\n+     *    override bool opEquals(Object o)\n+     *    {\n+     *        return this.opEquals(cast(Child) o);\n+     *    }\n+     * }\n+     * ---\n      */\n     bool opEquals(Object o)\n     {\n@@ -237,41 +260,50 @@ class Object\n     }\n }\n \n-bool opEquals(Object lhs, Object rhs)\n+/++\n+    Implementation for class opEquals override. Calls the class-defined methods after a null check.\n+    Please note this is not nogc right now, even if your implementation is, because of\n+    the typeinfo name string compare. This is because of dmd's dll implementation. However,\n+    it can infer to @safe if your class' opEquals is.\n++/\n+bool opEquals(LHS, RHS)(LHS lhs, RHS rhs) if (is(LHS : const Object) && is(RHS : const Object))\n {\n-    // If aliased to the same object or both null => equal\n-    if (lhs is rhs) return true;\n+    static if (__traits(compiles, lhs.opEquals(rhs)) && __traits(compiles, rhs.opEquals(lhs)))\n+    {\n+        // If aliased to the same object or both null => equal\n+        if (lhs is rhs) return true;\n \n-    // If either is null => non-equal\n-    if (lhs is null || rhs is null) return false;\n+        // If either is null => non-equal\n+        if (lhs is null || rhs is null) return false;\n \n-    if (!lhs.opEquals(rhs)) return false;\n+        if (!lhs.opEquals(rhs)) return false;\n \n-    // If same exact type => one call to method opEquals\n-    if (typeid(lhs) is typeid(rhs) ||\n-        !__ctfe && typeid(lhs).opEquals(typeid(rhs)))\n-            /* CTFE doesn't like typeid much. 'is' works, but opEquals doesn't\n-            (issue 7147). But CTFE also guarantees that equal TypeInfos are\n-            always identical. So, no opEquals needed during CTFE. */\n-    {\n-        return true;\n-    }\n+        // If same exact type => one call to method opEquals\n+        if (typeid(lhs) is typeid(rhs) ||\n+            !__ctfe && typeid(lhs).opEquals(typeid(rhs)))\n+                /* CTFE doesn't like typeid much. 'is' works, but opEquals doesn't\n+                (issue 7147). But CTFE also guarantees that equal TypeInfos are\n+                always identical. So, no opEquals needed during CTFE. */\n+        {\n+            return true;\n+        }\n \n-    // General case => symmetric calls to method opEquals\n-    return rhs.opEquals(lhs);\n-}\n+        // General case => symmetric calls to method opEquals\n+        return rhs.opEquals(lhs);\n+    }\n+    else\n+    {\n+        // this is a compatibility hack for the old const cast behavior\n+        // if none of the new overloads compile, we'll go back plain Object,\n+        // including casting away const. It does this through the pointer\n+        // to bypass any opCast that may be present on the original class.\n+        return .opEquals!(Object, Object)(*cast(Object*) &lhs, *cast(Object*) &rhs);\n \n-/************************\n-* Returns true if lhs and rhs are equal.\n-*/\n-bool opEquals(const Object lhs, const Object rhs)\n-{\n-    // A hack for the moment.\n-    return opEquals(cast()lhs, cast()rhs);\n+    }\n }\n \n /// If aliased to the same object or both null => equal\n-@system unittest\n+@system unittest // this one is not @safe because it goes through the Object base method\n {\n     class F { int flag; this(int flag) { this.flag = flag; } }\n \n@@ -291,7 +323,8 @@ bool opEquals(const Object lhs, const Object rhs)\n }\n \n /// If same exact type => one call to method opEquals\n-@system unittest\n+/// This test passes `@safe` because it defines a new opEquals with `@safe`\n+@safe unittest\n {\n     class F\n     {\n@@ -302,9 +335,9 @@ bool opEquals(const Object lhs, const Object rhs)\n             this.flag = flag;\n         }\n \n-        override bool opEquals(const Object o)\n+        bool opEquals(const F o) const @safe nothrow pure\n         {\n-            return flag == (cast(F) o).flag;\n+            return flag == o.flag;\n         }\n     }\n \n@@ -314,7 +347,7 @@ bool opEquals(const Object lhs, const Object rhs)\n }\n \n /// General case => symmetric calls to method opEquals\n-@system unittest\n+@safe unittest\n {\n     int fEquals, gEquals;\n \n@@ -331,21 +364,21 @@ bool opEquals(const Object lhs, const Object rhs)\n     {\n         this(int flag) { super(flag); }\n \n-        override bool opEquals(const Object o)\n+        bool opEquals(const Base o) @safe\n         {\n             fEquals++;\n-            return flag == (cast(Base) o).flag;\n+            return flag == o.flag;\n         }\n     }\n \n     class G : Base\n     {\n         this(int flag) { super(flag); }\n \n-        override bool opEquals(const Object o)\n+        bool opEquals(const Base o) @safe\n         {\n             gEquals++;\n-            return flag == (cast(Base) o).flag;\n+            return flag == o.flag;\n         }\n     }\n \n@@ -354,6 +387,114 @@ bool opEquals(const Object lhs, const Object rhs)\n     assert(gEquals == 1);\n }\n \n+/++\n+    This test shows an example for a comprehensive inheritance equality chain too.\n++/\n+unittest\n+{\n+    static class Base\n+    {\n+        int member;\n+\n+        this(int member) pure @safe nothrow @nogc\n+        {\n+            this.member = member;\n+        }\n+\n+        override bool opEquals(Object rhs) const\n+        {\n+            return this.opEquals(cast(Base) rhs);\n+        }\n+\n+        bool opEquals(const Base rhs) const @nogc pure nothrow @safe\n+        {\n+            if (rhs is null)\n+                return false;\n+            return this.member == rhs.member;\n+        }\n+    }\n+\n+    // works through the direct class with attributes enabled, except for pure and nogc in the current TypeInfo implementation\n+    bool testThroughBase() nothrow @safe\n+    {\n+        Base b1 = new Base(0);\n+        Base b2 = new Base(0);\n+        assert(b1 == b2);\n+        Base b3 = new Base(1);\n+        assert(b1 != b3);\n+        return true;\n+    }\n+\n+    static assert(testThroughBase());\n+\n+    // also works through the base class interface thanks to the override, but no more attributes\n+    bool testThroughObject()\n+    {\n+        Object o1 = new Base(0);\n+        Object o2 = new Base(0);\n+        assert(o1 == o2);\n+        Object o3 = new Base(1);\n+        assert(o1 != o3);\n+        return true;\n+    }\n+\n+    static assert(testThroughObject());\n+\n+    // Each time you make a child, you want to override all old opEquals\n+    // and add a new overload for the new child.\n+    static class Child : Base\n+    {\n+        int member2;\n+\n+        this(int member, int member2) pure @safe nothrow @nogc\n+        {\n+            super(member);\n+            this.member2 = member2;\n+        }\n+\n+        // override the whole chain so it works consistently though any base\n+        override bool opEquals(Object rhs) const\n+        {\n+            return this.opEquals(cast(Child) rhs);\n+        }\n+        override bool opEquals(const Base rhs) const\n+        {\n+            return this.opEquals(cast(const Child) rhs);\n+        }\n+        // and then add the new overload, if necessary, to handle new members\n+        bool opEquals(const Child rhs) const @nogc pure nothrow @safe\n+        {\n+            if (rhs is null)\n+                return false;\n+            // can call back to the devirtualized base test with implicit conversion\n+            // then compare the new member too. or we could have just compared the base\n+            // member directly here as well.\n+            return Base.opEquals(rhs) && this.member2 == rhs.member2;\n+        }\n+\n+        // a mixin template, of course, could automate this.\n+    }\n+\n+    bool testThroughChild()\n+    {\n+        Child a = new Child(0, 0);\n+        Child b = new Child(0, 1);\n+        assert(a != b);\n+\n+        Base ba = a;\n+        Base bb = b;\n+        assert(ba != bb);\n+\n+        Object oa = a;\n+        Object ob = b;\n+        assert(oa != ob);\n+\n+        return true;\n+    }\n+\n+    static assert(testThroughChild());\n+}\n+\n // To cover const Object opEquals\n @system unittest\n {\n@@ -396,7 +537,8 @@ void setSameMutex(shared Object ownee, shared Object owner)\n  */\n struct Interface\n {\n-    TypeInfo_Class   classinfo;  /// .classinfo for this interface (not for containing class)\n+    /// Class info returned by `typeid` for this interface (not for containing class)\n+    TypeInfo_Class   classinfo;\n     void*[]     vtbl;\n     size_t      offset;     /// offset to Interface 'this' from Object 'this'\n }\n@@ -446,14 +588,18 @@ class TypeInfo\n     }\n \n     override bool opEquals(Object o)\n+    {\n+        return opEquals(cast(TypeInfo) o);\n+    }\n+\n+    bool opEquals(const TypeInfo ti) @safe nothrow const\n     {\n         /* TypeInfo instances are singletons, but duplicates can exist\n          * across DLL's. Therefore, comparing for a name match is\n          * sufficient.\n          */\n-        if (this is o)\n+        if (this is ti)\n             return true;\n-        auto ti = cast(const TypeInfo)o;\n         return ti && this.toString() == ti.toString();\n     }\n \n@@ -462,7 +608,7 @@ class TypeInfo\n         auto anotherObj = new Object();\n \n         assert(typeid(void).opEquals(typeid(void)));\n-        assert(!typeid(void).opEquals(anotherObj));\n+        assert(typeid(void) != anotherObj); // calling .opEquals here directly is a type mismatch\n     }\n \n     /**\n@@ -1397,13 +1543,13 @@ private extern (C) int _d_isbaseof(scope TypeInfo_Class child,\n /**\n  * Runtime type information about a class.\n  * Can be retrieved from an object instance by using the\n- * $(DDSUBLINK spec/property,classinfo, .classinfo) property.\n+ * $(DDSUBLINK spec/expression,typeid_expressions,typeid expression).\n  */\n class TypeInfo_Class : TypeInfo\n {\n     override string toString() const pure { return name; }\n \n-    override bool opEquals(Object o)\n+    override bool opEquals(const TypeInfo o) const\n     {\n         if (this is o)\n             return true;\n@@ -1739,12 +1885,8 @@ class TypeInfo_Struct : TypeInfo\n             return false;\n         else if (xopEquals)\n         {\n-            version (GNU)\n-            {   // BUG: GDC and DMD use different calling conventions\n-                return (*xopEquals)(p2, p1);\n-            }\n-            else\n-                return (*xopEquals)(p1, p2);\n+            const dg = _memberFunc(p2, xopEquals);\n+            return dg.xopEquals(p1);\n         }\n         else if (p1 == p2)\n             return true;\n@@ -1766,12 +1908,8 @@ class TypeInfo_Struct : TypeInfo\n                     return true;\n                 else if (xopCmp)\n                 {\n-                    version (GNU)\n-                    {   // BUG: GDC and DMD use different calling conventions\n-                        return (*xopCmp)(p1, p2);\n-                    }\n-                    else\n-                        return (*xopCmp)(p2, p1);\n+                    const dg = _memberFunc(p1, xopCmp);\n+                    return dg.xopCmp(p2);\n                 }\n                 else\n                     // BUG: relies on the GC not moving objects\n@@ -1876,6 +2014,28 @@ class TypeInfo_Struct : TypeInfo\n         TypeInfo m_arg2;\n     }\n     immutable(void)* m_RTInfo;                // data for precise GC\n+\n+    // The xopEquals and xopCmp members are function pointers to member\n+    // functions, which is not guaranteed to share the same ABI, as it is not\n+    // known whether the `this` parameter is the first or second argument.\n+    // This wrapper is to convert it to a delegate which will always pass the\n+    // `this` parameter in the correct way.\n+    private struct _memberFunc\n+    {\n+        union\n+        {\n+            struct // delegate\n+            {\n+                const void* ptr;\n+                const void* funcptr;\n+            }\n+            @safe pure nothrow\n+            {\n+                bool delegate(in void*) xopEquals;\n+                int delegate(in void*) xopCmp;\n+            }\n+        }\n+    }\n }\n \n @system unittest\n@@ -2715,7 +2875,7 @@ void clear(Value, Key)(Value[Key] aa)\n     _aaClear(*cast(AA *) &aa);\n }\n \n-/* ditto */\n+/** ditto */\n void clear(Value, Key)(Value[Key]* aa)\n {\n     _aaClear(*cast(AA *) aa);\n@@ -2762,30 +2922,30 @@ T rehash(T : Value[Key], Value, Key)(T aa)\n     return aa;\n }\n \n-/* ditto */\n+/** ditto */\n T rehash(T : Value[Key], Value, Key)(T* aa)\n {\n     _aaRehash(cast(AA*)aa, typeid(Value[Key]));\n     return *aa;\n }\n \n-/* ditto */\n+/** ditto */\n T rehash(T : shared Value[Key], Value, Key)(T aa)\n {\n     _aaRehash(cast(AA*)&aa, typeid(Value[Key]));\n     return aa;\n }\n \n-/* ditto */\n+/** ditto */\n T rehash(T : shared Value[Key], Value, Key)(T* aa)\n {\n     _aaRehash(cast(AA*)aa, typeid(Value[Key]));\n     return *aa;\n }\n \n /***********************************\n- * Create a new associative array of the same size and copy the contents of the\n- * associative array into it.\n+ * Creates a new associative array of the same size and copies the contents of\n+ * the associative array into it.\n  * Params:\n  *      aa =     The associative array.\n  */\n@@ -2826,7 +2986,7 @@ V[K] dup(T : V[K], K, V)(T aa)\n     return result;\n }\n \n-/* ditto */\n+/** ditto */\n V[K] dup(T : V[K], K, V)(T* aa)\n {\n     return (*aa).dup;\n@@ -2853,11 +3013,27 @@ private AARange _aaToRange(T: V[K], K, V)(ref T aa) pure nothrow @nogc @safe\n }\n \n /***********************************\n- * Returns a forward range over the keys of the associative array.\n+ * Returns a $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives)\n+ * which will iterate over the keys of the associative array. The keys are\n+ * returned by reference.\n+ *\n+ * If structural changes are made to the array (removing or adding keys), all\n+ * ranges previously obtained through this function are invalidated. The\n+ * following example program will dereference a null pointer:\n+ *\n+ *---\n+ * import std.stdio : writeln;\n+ *\n+ * auto dict = [\"k1\": 1, \"k2\": 2];\n+ * auto keyRange = dict.byKey;\n+ * dict.clear;\n+ * writeln(keyRange.front);    // Segmentation fault\n+ *---\n+ *\n  * Params:\n  *      aa =     The associative array.\n  * Returns:\n- *      A forward range.\n+ *      A forward range referencing the keys of the associative array.\n  */\n auto byKey(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n {\n@@ -2880,7 +3056,7 @@ auto byKey(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n     return Result(_aaToRange(aa));\n }\n \n-/* ditto */\n+/** ditto */\n auto byKey(T : V[K], K, V)(T* aa) pure nothrow @nogc\n {\n     return (*aa).byKey();\n@@ -2889,7 +3065,7 @@ auto byKey(T : V[K], K, V)(T* aa) pure nothrow @nogc\n ///\n @safe unittest\n {\n-    auto dict = [1: 0, 2: 0];\n+    auto dict = [1: \"v1\", 2: \"v2\"];\n     int sum;\n     foreach (v; dict.byKey)\n         sum += v;\n@@ -2898,11 +3074,27 @@ auto byKey(T : V[K], K, V)(T* aa) pure nothrow @nogc\n }\n \n /***********************************\n- * Returns a forward range over the values of the associative array.\n+ * Returns a $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives)\n+ * which will iterate over the values of the associative array. The values are\n+ * returned by reference.\n+ *\n+ * If structural changes are made to the array (removing or adding keys), all\n+ * ranges previously obtained through this function are invalidated. The\n+ * following example program will dereference a null pointer:\n+ *\n+ *---\n+ * import std.stdio : writeln;\n+ *\n+ * auto dict = [\"k1\": 1, \"k2\": 2];\n+ * auto valueRange = dict.byValue;\n+ * dict.clear;\n+ * writeln(valueRange.front);    // Segmentation fault\n+ *---\n+ *\n  * Params:\n  *      aa =     The associative array.\n  * Returns:\n- *      A forward range.\n+ *      A forward range referencing the values of the associative array.\n  */\n auto byValue(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n {\n@@ -2925,7 +3117,7 @@ auto byValue(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n     return Result(_aaToRange(aa));\n }\n \n-/* ditto */\n+/** ditto */\n auto byValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n {\n     return (*aa).byValue();\n@@ -2943,11 +3135,35 @@ auto byValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n }\n \n /***********************************\n- * Returns a forward range over the key value pairs of the associative array.\n+ * Returns a $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives)\n+ * which will iterate over the key-value pairs of the associative array. The\n+ * returned pairs are represented by an opaque type with `.key` and `.value`\n+ * properties for accessing references to the key and value of the pair,\n+ * respectively.\n+ *\n+ * If structural changes are made to the array (removing or adding keys), all\n+ * ranges previously obtained through this function are invalidated. The\n+ * following example program will dereference a null pointer:\n+ *\n+ *---\n+ * import std.stdio : writeln;\n+ *\n+ * auto dict = [\"k1\": 1, \"k2\": 2];\n+ * auto kvRange = dict.byKeyValue;\n+ * dict.clear;\n+ * writeln(kvRange.front.key, \": \", kvRange.front.value);    // Segmentation fault\n+ *---\n+ *\n+ * Note that this is a low-level interface to iterating over the associative\n+ * array and is not compatible withth the\n+ * $(LINK2 $(ROOT_DIR)phobos/std_typecons.html#.Tuple,`Tuple`) type in Phobos.\n+ * For compatibility with `Tuple`, use\n+ * $(LINK2 $(ROOT_DIR)phobos/std_array.html#.byPair,std.array.byPair) instead.\n+ *\n  * Params:\n  *      aa =     The associative array.\n  * Returns:\n- *      A forward range.\n+ *      A forward range referencing the pairs of the associative array.\n  */\n auto byKeyValue(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n {\n@@ -2987,7 +3203,7 @@ auto byKeyValue(T : V[K], K, V)(T aa) pure nothrow @nogc @safe\n     return Result(_aaToRange(aa));\n }\n \n-/* ditto */\n+/** ditto */\n auto byKeyValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n {\n     return (*aa).byKeyValue();\n@@ -2999,18 +3215,21 @@ auto byKeyValue(T : V[K], K, V)(T* aa) pure nothrow @nogc\n     auto dict = [\"k1\": 1, \"k2\": 2];\n     int sum;\n     foreach (e; dict.byKeyValue)\n+    {\n+        assert(e.key[1] == e.value + '0');\n         sum += e.value;\n+    }\n \n     assert(sum == 3);\n }\n \n /***********************************\n- * Returns a dynamic array, the elements of which are the keys in the\n- * associative array.\n+ * Returns a newly allocated dynamic array containing a copy of the keys from\n+ * the associative array.\n  * Params:\n  *      aa =     The associative array.\n  * Returns:\n- *      A dynamic array.\n+ *      A dynamic array containing a copy of the keys.\n  */\n Key[] keys(T : Value[Key], Value, Key)(T aa) @property\n {\n@@ -3028,7 +3247,7 @@ Key[] keys(T : Value[Key], Value, Key)(T aa) @property\n     return res;\n }\n \n-/* ditto */\n+/** ditto */\n Key[] keys(T : Value[Key], Value, Key)(T *aa) @property\n {\n     return (*aa).keys;\n@@ -3089,12 +3308,12 @@ Key[] keys(T : Value[Key], Value, Key)(T *aa) @property\n }\n \n /***********************************\n- * Returns a dynamic array, the elements of which are the values in the\n- * associative array.\n+ * Returns a newly allocated dynamic array containing a copy of the values from\n+ * the associative array.\n  * Params:\n  *      aa =     The associative array.\n  * Returns:\n- *      A dynamic array.\n+ *      A dynamic array containing a copy of the values.\n  */\n Value[] values(T : Value[Key], Value, Key)(T aa) @property\n {\n@@ -3112,7 +3331,7 @@ Value[] values(T : Value[Key], Value, Key)(T aa) @property\n     return res;\n }\n \n-/* ditto */\n+/** ditto */\n Value[] values(T : Value[Key], Value, Key)(T *aa) @property\n {\n     return (*aa).values;\n@@ -3188,12 +3407,13 @@ inout(V) get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)\n     return p ? *p : defaultValue;\n }\n \n-/* ditto */\n+/** ditto */\n inout(V) get(K, V)(inout(V[K])* aa, K key, lazy inout(V) defaultValue)\n {\n     return (*aa).get(key, defaultValue);\n }\n \n+///\n @safe unittest\n {\n     auto aa = [\"k1\": 1];\n@@ -4651,8 +4871,6 @@ public import core.internal.array.construction : _d_arrayctor;\n public import core.internal.array.construction : _d_arraysetctor;\n public import core.internal.array.capacity: _d_arraysetlengthTImpl;\n \n-public import core.lifetime : _d_delstructImpl;\n-\n public import core.internal.dassert: _d_assert_fail;\n \n public import core.internal.destruction: __ArrayDtor;\n@@ -4664,6 +4882,9 @@ public import core.internal.postblit: __ArrayPostblit;\n public import core.internal.switch_: __switch;\n public import core.internal.switch_: __switch_error;\n \n+public import core.lifetime : _d_delstructImpl;\n+public import core.lifetime : _d_newThrowable;\n+\n public @trusted @nogc nothrow pure extern (C) void _d_delThrowable(scope Throwable);\n \n // Compare class and interface objects for ordering."}, {"sha": "47b67f130b89150d173af621419f0105fba82ebc", "filename": "libphobos/libdruntime/rt/dmain2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Frt%2Fdmain2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Frt%2Fdmain2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fdmain2.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -624,7 +624,7 @@ extern (C) void _d_print_throwable(Throwable t)\n             {\n                 WSink caption;\n                 if (t)\n-                    caption.sink(t.classinfo.name);\n+                    caption.sink(typeid(t).name);\n \n                 // Avoid static user32.dll dependency for console applications\n                 // by loading it dynamically as needed"}, {"sha": "26c24c4c8f069df3bf3c1094bb5057de13bd4683", "filename": "libphobos/libdruntime/rt/util/typeinfo.d", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Frt%2Futil%2Ftypeinfo.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Flibdruntime%2Frt%2Futil%2Ftypeinfo.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Futil%2Ftypeinfo.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -367,7 +367,10 @@ detect if we need to override. The overriding initializer should be nonzero.\n private class TypeInfoArrayGeneric(T, Base = T) : Select!(is(T == Base), TypeInfo_Array, TypeInfoArrayGeneric!Base)\n {\n     static if (is(T == Base))\n-        override bool opEquals(Object o) { return TypeInfo.opEquals(o); }\n+        override bool opEquals(const Object o) const @safe nothrow { return TypeInfo.opEquals(cast(const TypeInfo) o); }\n+\n+    alias opEquals = typeof(super).opEquals;\n+    alias opEquals = TypeInfo.opEquals;\n \n     override string toString() const { return (T[]).stringof; }\n "}, {"sha": "2babfbe634794fae2c0298dfcf07c225806d30ac", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -1,4 +1,4 @@\n-4687883231eba3bda7691321f2af107fdb3d0a44\n+896b1d0e1e8b69bccac0e180ecd1b42a70f95d5b\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "75f83974e993c2799e1da966deab5a05b58f01d5", "filename": "libphobos/src/Makefile.am", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.am?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -89,11 +89,12 @@ PHOBOS_DSOURCES = etc/c/curl.d etc/c/zlib.d std/algorithm/comparison.d \\\n \tstd/algorithm/mutation.d std/algorithm/package.d \\\n \tstd/algorithm/searching.d std/algorithm/setops.d \\\n \tstd/algorithm/sorting.d std/array.d std/ascii.d std/base64.d \\\n-\tstd/bigint.d std/bitmanip.d std/compiler.d std/complex.d \\\n-\tstd/concurrency.d std/container/array.d std/container/binaryheap.d \\\n-\tstd/container/dlist.d std/container/package.d std/container/rbtree.d \\\n-\tstd/container/slist.d std/container/util.d std/conv.d std/csv.d \\\n-\tstd/datetime/date.d std/datetime/interval.d std/datetime/package.d \\\n+\tstd/bigint.d std/bitmanip.d std/checkedint.d std/compiler.d \\\n+\tstd/complex.d std/concurrency.d std/container/array.d \\\n+\tstd/container/binaryheap.d std/container/dlist.d \\\n+\tstd/container/package.d std/container/rbtree.d std/container/slist.d \\\n+\tstd/container/util.d std/conv.d std/csv.d std/datetime/date.d \\\n+\tstd/datetime/interval.d std/datetime/package.d \\\n \tstd/datetime/stopwatch.d std/datetime/systime.d \\\n \tstd/datetime/timezone.d std/demangle.d std/digest/crc.d \\\n \tstd/digest/digest.d std/digest/hmac.d std/digest/md.d \\"}, {"sha": "f2395e2caf72764ab8b833b4dbf14db6c9ad95bb", "filename": "libphobos/src/Makefile.in", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMakefile.in?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -159,8 +159,9 @@ am__dirstamp = $(am__leading_dot)dirstamp\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/algorithm/sorting.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/array.lo std/ascii.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/base64.lo std/bigint.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/bitmanip.lo std/compiler.lo \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/complex.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/bitmanip.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/checkedint.lo \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/compiler.lo std/complex.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/concurrency.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/array.lo \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/binaryheap.lo \\\n@@ -549,11 +550,12 @@ libgphobos_la_LINK = $(LIBTOOL) --tag=D $(libgphobos_la_LIBTOOLFLAGS) \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/algorithm/mutation.d std/algorithm/package.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/algorithm/searching.d std/algorithm/setops.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/algorithm/sorting.d std/array.d std/ascii.d std/base64.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/bigint.d std/bitmanip.d std/compiler.d std/complex.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/concurrency.d std/container/array.d std/container/binaryheap.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/dlist.d std/container/package.d std/container/rbtree.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/slist.d std/container/util.d std/conv.d std/csv.d \\\n-@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/date.d std/datetime/interval.d std/datetime/package.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/bigint.d std/bitmanip.d std/checkedint.d std/compiler.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/complex.d std/concurrency.d std/container/array.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/binaryheap.d std/container/dlist.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/package.d std/container/rbtree.d std/container/slist.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/container/util.d std/conv.d std/csv.d std/datetime/date.d \\\n+@ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/interval.d std/datetime/package.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/stopwatch.d std/datetime/systime.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/datetime/timezone.d std/demangle.d std/digest/crc.d \\\n @ENABLE_LIBDRUNTIME_ONLY_FALSE@\tstd/digest/digest.d std/digest/hmac.d std/digest/md.d \\\n@@ -717,6 +719,7 @@ std/ascii.lo: std/$(am__dirstamp)\n std/base64.lo: std/$(am__dirstamp)\n std/bigint.lo: std/$(am__dirstamp)\n std/bitmanip.lo: std/$(am__dirstamp)\n+std/checkedint.lo: std/$(am__dirstamp)\n std/compiler.lo: std/$(am__dirstamp)\n std/complex.lo: std/$(am__dirstamp)\n std/concurrency.lo: std/$(am__dirstamp)"}, {"sha": "cbc173d891dba8f45e875be67546d78bd03fe325", "filename": "libphobos/src/index.dd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Findex.dd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Findex.dd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Findex.dd?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -84,7 +84,7 @@ $(BOOKTABLE ,\n     )\n     $(LEADINGROW Data integrity)\n     $(TR\n-        $(TDNW $(MREF std,experimental,checkedint))\n+        $(TDNW $(MREF std,checkedint))\n         $(TD Checked integral types.)\n     )\n     $(TR"}, {"sha": "b86e0f99225f800a63300104fd4d7da69929e62c", "filename": "libphobos/src/std/array.d", "status": "modified", "additions": 127, "deletions": 6, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Farray.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Farray.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Farray.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94", "patch": "@@ -117,7 +117,7 @@ if (isIterable!Range && !isAutodecodableString!Range && !isInfinite!Range)\n     alias E = ForeachType!Range;\n     static if (hasLength!Range)\n     {\n-        auto length = r.length;\n+        const length = r.length;\n         if (length == 0)\n             return null;\n \n@@ -126,12 +126,35 @@ if (isIterable!Range && !isAutodecodableString!Range && !isInfinite!Range)\n         auto result = (() @trusted => uninitializedArray!(Unqual!E[])(length))();\n \n         // Every element of the uninitialized array must be initialized\n-        size_t i;\n-        foreach (e; r)\n+        size_t cnt; //Number of elements that have been initialized\n+        try\n         {\n-            emplaceRef!E(result[i], e);\n-            ++i;\n+            foreach (e; r)\n+            {\n+                emplaceRef!E(result[cnt], e);\n+                ++cnt;\n+            }\n+        } catch (Exception e)\n+        {\n+            //https://issues.dlang.org/show_bug.cgi?id=22185\n+            //Make any uninitialized elements safely destructible.\n+            foreach (ref elem; result[cnt..$])\n+            {\n+                import core.internal.lifetime : emplaceInitializer;\n+                emplaceInitializer(elem);\n+            }\n+            throw e;\n         }\n+        /*\n+            https://issues.dlang.org/show_bug.cgi?id=22673\n+\n+            We preallocated an array, we should ensure that enough range elements\n+            were gathered such that every slot in the array is filled. If not, the GC\n+            will collect the allocated array, leading to the `length - cnt` left over elements\n+            being collected too - despite their contents having no guarantee of destructibility.\n+         */\n+        assert(length == cnt,\n+               \"Range .length property was not equal to the length yielded by the range before becoming empty\");\n         return (() @trusted => cast(E[]) result)();\n     }\n     else\n@@ -439,6 +462,91 @@ if (isAutodecodableString!String)\n         assert(equal(r, [S(1), S(1)]));\n     });\n }\n+//https://issues.dlang.org/show_bug.cgi?id=22673\n+@system unittest\n+{\n+    struct LyingRange\n+    {\n+        enum size_t length = 100;\n+        enum theRealLength = 50;\n+        size_t idx = 0;\n+        bool empty()\n+        {\n+            return idx <= theRealLength;\n+        }\n+        void popFront()\n+        {\n+            ++idx;\n+        }\n+        size_t front()\n+        {\n+            return idx;\n+        }\n+    }\n+    static assert(hasLength!LyingRange);\n+    LyingRange rng;\n+    import std.exception : assertThrown;\n+    assertThrown!Error(array(rng));\n+}\n+//https://issues.dlang.org/show_bug.cgi?id=22185\n+@system unittest\n+{\n+    import std.stdio;\n+    static struct ThrowingCopy\n+    {\n+        int x = 420;\n+        this(ref return scope ThrowingCopy rhs)\n+        {\n+            rhs.x = 420;\n+            //\n+            throw new Exception(\"This throws\");\n+        }\n+        ~this()\n+        {\n+            /*\n+                Any time this destructor runs, it should be running on \"valid\"\n+                data. This is is mimicked by having a .init other than 0 (the value the memory\n+                practically will be from the GC).\n+            */\n+            if (x != 420)\n+            {\n+                //This will only trigger during GC finalization so avoid writefln for now.\n+                printf(\"Destructor failure in ThrowingCopy(%d) @ %p\", x, &this);\n+                assert(x == 420, \"unittest destructor failed\");\n+            }\n+        }\n+    }\n+    static struct LyingThrowingRange\n+    {\n+        enum size_t length = 100;\n+        enum size_t evilRealLength = 50;\n+        size_t idx;\n+        ThrowingCopy front()\n+        {\n+            return ThrowingCopy(12);\n+        }\n+        bool empty()\n+        {\n+            return idx == evilRealLength;\n+        }\n+        void popFront()\n+        {\n+            ++idx;\n+        }\n+    }\n+    static assert(hasLength!LyingThrowingRange);\n+    import std.exception : assertThrown;\n+    {\n+        assertThrown(array(LyingThrowingRange()));\n+    }\n+    import core.memory : GC;\n+    /*\n+        Force a collection early. Doesn't always actually finalize the bad objects\n+        but trying to collect soon after the allocation is thrown away means any potential failures\n+        will happen earlier.\n+    */\n+    GC.collect();\n+}\n \n /**\n Returns a newly allocated associative array from a range of key/value tuples\n@@ -939,6 +1047,11 @@ if (isDynamicArray!T && allSatisfy!(isIntegral, I))\n // from rt/lifetime.d\n private extern(C) void[] _d_newarrayU(const TypeInfo ti, size_t length) pure nothrow;\n \n+// from rt/tracegc.d\n+version (D_ProfileGC)\n+private extern (C) void[] _d_newarrayUTrace(string file, size_t line,\n+    string funcname, const scope TypeInfo ti, size_t length) pure nothrow;\n+\n private auto arrayAllocImpl(bool minimallyInitialized, T, I...)(I sizes) nothrow\n {\n     static assert(I.length <= nDimensions!T,\n@@ -992,7 +1105,15 @@ private auto arrayAllocImpl(bool minimallyInitialized, T, I...)(I sizes) nothrow\n               _d_newarrayU returns a void[], but with the length set according\n               to E.sizeof.\n             +/\n-            *(cast(void[]*)&ret) = _d_newarrayU(typeid(E[]), size);\n+            version (D_ProfileGC)\n+            {\n+                // FIXME: file, line, function should be propagated from the\n+                // caller, not here.\n+                *(cast(void[]*)&ret) = _d_newarrayUTrace(__FILE__, __LINE__,\n+                    __FUNCTION__, typeid(E[]), size);\n+            }\n+            else\n+                *(cast(void[]*)&ret) = _d_newarrayU(typeid(E[]), size);\n             static if (minimallyInitialized && hasIndirections!E)\n                 // _d_newarrayU would have asserted if the multiplication below\n                 // had overflowed, so we don't have to check it again."}, {"sha": "635c4207fcdd003f4bfb925daf03ddc6bb948ca1", "filename": "libphobos/src/std/checkedint.d", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fcheckedint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fcheckedint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcheckedint.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "485b548b049f29bda8b59aced7279ba7603b9754", "filename": "libphobos/src/std/complex.d", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fcomplex.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fcomplex.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "a10f4da7f9cecfb851884d7849974f36334da230", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "62f848f11fcdee3afdf4b27c88fb3a0364d6d07a", "filename": "libphobos/src/std/experimental/allocator/package.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fallocator%2Fpackage.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "9237341d4182c83d6488ed51fbbf129282c896ac", "filename": "libphobos/src/std/experimental/checkedint.d", "status": "modified", "additions": 12, "deletions": 3465, "changes": 3477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fcheckedint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fcheckedint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fcheckedint.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "afd98add6baf495f64c374fa3c34b5788474097c", "filename": "libphobos/src/std/experimental/logger/core.d", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "a0bea7733cf0b18bff53750e7ac5353617aa248e", "filename": "libphobos/src/std/experimental/logger/filelogger.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "90bfb5820ab0e9aea1e488aff4582fc52c133729", "filename": "libphobos/src/std/experimental/logger/multilogger.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "c974ada2ae875d18c10b5cf5ae18fe4752fbd71b", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 39, "deletions": 65, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "6c9e9ae60049524123f328dbaae0827684f8b72d", "filename": "libphobos/src/std/format/package.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "bc8d368e970d1f1f03a80ba319dc7c45b0bbeb3e", "filename": "libphobos/src/std/functional.d", "status": "modified", "additions": 50, "deletions": 9, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ffunctional.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ffunctional.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffunctional.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "89def0f02f54039fc3955452070f627149c4fdfa", "filename": "libphobos/src/std/json.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fjson.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fjson.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fjson.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "20518b86333979c0d7aa7d6c7c1a23a692e30a6a", "filename": "libphobos/src/std/path.d", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fpath.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fpath.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fpath.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "2c68f36b4e76adcbddd1df922cdacab6187fc8eb", "filename": "libphobos/src/std/process.d", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fprocess.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fprocess.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fprocess.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "91971342d9ac0f0e892cf52d3fed8061f27dabe4", "filename": "libphobos/src/std/range/package.d", "status": "modified", "additions": 186, "deletions": 100, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frange%2Fpackage.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "e24abc50a074e3136093db51ed7207d697c62ad5", "filename": "libphobos/src/std/regex/package.d", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fregex%2Fpackage.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "bc2d3fe421076c1da90a500550eb681331bde72f", "filename": "libphobos/src/std/stdio.d", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstdio.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "596c11cfb00bb4876823dc9259918e6b40771687", "filename": "libphobos/src/std/traits.d", "status": "modified", "additions": 97, "deletions": 4, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftraits.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "28edb9b8c29332249e2ff17090575949e642b1c2", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 67, "deletions": 20, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "5c23684b9ae309f3905ad5674b8bc9d56f21c320", "filename": "libphobos/src/std/utf.d", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Futf.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Futf.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Futf.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "41cd4848b126d667c3d933bb131962a2ccd0e82a", "filename": "libphobos/src/std/variant.d", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fvariant.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Fsrc%2Fstd%2Fvariant.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fvariant.d?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}, {"sha": "528cff4bf13e6694dd5ecdb9f03f956745c6dded", "filename": "libphobos/testsuite/testsuite_flags.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Ftestsuite%2Ftestsuite_flags.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d75691877c4a7521a995d2601021fcaf30f65d94/libphobos%2Ftestsuite%2Ftestsuite_flags.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Ftestsuite_flags.in?ref=d75691877c4a7521a995d2601021fcaf30f65d94"}]}