{"sha": "b38c20a636ec4e92cdabecbfa487b742829ebe93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM4YzIwYTYzNmVjNGU5MmNkYWJlY2JmYTQ4N2I3NDI4MjllYmU5Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T13:32:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-23T13:32:44Z"}, "message": "[multiple changes]\n\n2011-11-23  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-coorse.ads, a-ciorse.ads, a-cborse.ads (Set_Iterator_Interfaces):\n\tRenamed from Ordered_Set_Iterator_Interfaces.\n\t* a-coorse.adb, a-ciorse.adb, a-cborse.adb (Iterator): Declared\n\tIterator type as limited (First, Last): Cursor return value\n\tdepends on iterator node value (Iterate): Use start position as\n\titerator node value (Next, Previous): Forward to corresponding\n\tcursor-based operation.\n\t* a-cohase.ads, a-cohase.adb: Implemented forward iterator.\n\t* a-cihase.adb, a-cbhase.adb (Iterator): Removed unnecessary\n\tnode component (First, Next): Forward call to corresponding\n\tcursor-based operation (Iterate): Representation of iterator no\n\tlonger has node component\n\n2011-11-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_intr.adb (Expand_Unc_Deallocation): Ensure that the\n\tdereference has a proper type before the side effect removal\n\tmechanism kicks in.\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Handle a rare case\n\twhere the base type of the subtype is a private itype created\n\tto act as the partial view of a constrained record type. This\n\tscenario manifests with equivalent class-wide types for records\n\twith unknown discriminants.\n\n2011-11-23  Jerome Guitton  <guitton@adacore.com>\n\n\t* s-osprim-vxworks.adb (Clock): Use Clock_RT_Ada.\n\n2011-11-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-oscons-tmplt.c: Fix unbalanced preprocessor directives Minor\n\treformatting/reorganization.\n\nFrom-SVN: r181666", "tree": {"sha": "e4cb2a009b5464c65617b77964d5b5b7ae9ba450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4cb2a009b5464c65617b77964d5b5b7ae9ba450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b38c20a636ec4e92cdabecbfa487b742829ebe93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38c20a636ec4e92cdabecbfa487b742829ebe93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b38c20a636ec4e92cdabecbfa487b742829ebe93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b38c20a636ec4e92cdabecbfa487b742829ebe93/comments", "author": null, "committer": null, "parents": [{"sha": "24fee494c559f58afeb921b96a755be8d952b1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24fee494c559f58afeb921b96a755be8d952b1d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24fee494c559f58afeb921b96a755be8d952b1d3"}], "stats": {"total": 733, "additions": 549, "deletions": 184}, "files": [{"sha": "42021e58a205d2b863f3dd9376bfa9bae3c560cb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -1,3 +1,38 @@\n+2011-11-23  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-coorse.ads, a-ciorse.ads, a-cborse.ads (Set_Iterator_Interfaces):\n+\tRenamed from Ordered_Set_Iterator_Interfaces.\n+\t* a-coorse.adb, a-ciorse.adb, a-cborse.adb (Iterator): Declared\n+\tIterator type as limited (First, Last): Cursor return value\n+\tdepends on iterator node value (Iterate): Use start position as\n+\titerator node value (Next, Previous): Forward to corresponding\n+\tcursor-based operation.\n+\t* a-cohase.ads, a-cohase.adb: Implemented forward iterator.\n+\t* a-cihase.adb, a-cbhase.adb (Iterator): Removed unnecessary\n+\tnode component (First, Next): Forward call to corresponding\n+\tcursor-based operation (Iterate): Representation of iterator no\n+\tlonger has node component\n+\n+2011-11-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_intr.adb (Expand_Unc_Deallocation): Ensure that the\n+\tdereference has a proper type before the side effect removal\n+\tmechanism kicks in.\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Handle a rare case\n+\twhere the base type of the subtype is a private itype created\n+\tto act as the partial view of a constrained record type. This\n+\tscenario manifests with equivalent class-wide types for records\n+\twith unknown discriminants.\n+\n+2011-11-23  Jerome Guitton  <guitton@adacore.com>\n+\n+\t* s-osprim-vxworks.adb (Clock): Use Clock_RT_Ada.\n+\n+2011-11-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-oscons-tmplt.c: Fix unbalanced preprocessor directives Minor\n+\treformatting/reorganization.\n+\n 2011-11-23  Thomas Quinot  <quinot@adacore.com>\n \n \t* g-htable.ads: Remove old comments."}, {"sha": "1de29ab1a7ecf05738f0775cf70b3b33e40009ef", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -41,7 +41,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n    type Iterator is new Set_Iterator_Interfaces.Forward_Iterator with record\n       Container : Set_Access;\n-      Position  : Cursor;\n    end record;\n \n    overriding function First (Object : Iterator) return Cursor;\n@@ -596,10 +595,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    end First;\n \n    overriding function First (Object : Iterator) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Object.Container.all);\n    begin\n-      return (if Node = 0 then No_Element\n-              else Cursor'(Object.Container, Node));\n+      return Object.Container.First;\n    end First;\n \n    -----------------\n@@ -911,7 +908,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    function Iterate (Container : Set)\n      return Set_Iterator_Interfaces.Forward_Iterator'Class is\n    begin\n-      return Iterator'(Container'Unrestricted_Access, First (Container));\n+      return Iterator'(Container => Container'Unrestricted_Access);\n    end Iterate;\n \n    ------------\n@@ -982,12 +979,16 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Position : Cursor) return Cursor\n    is\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n       if Position.Container /= Object.Container then\n          raise Program_Error with\n-           \"Position cursor designates wrong set\";\n+           \"Position cursor of Next designates wrong set\";\n       end if;\n \n-      return (if Position.Node = 0 then No_Element else Next (Position));\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1599,7 +1600,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n       begin\n          if Node = 0 then\n-            raise Constraint_Error with \"key not in map\";\n+            raise Constraint_Error with \"key not in map\";  -- ??? \"set\"\n          end if;\n \n          return Container.Nodes (Node).Element;"}, {"sha": "62ab5f214701d999c34b6cd2e6cd3338474f4ae1", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 104, "deletions": 20, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -42,9 +42,9 @@ with System; use type System.Address;\n \n package body Ada.Containers.Bounded_Ordered_Sets is\n \n-   type Iterator is new\n-     Ordered_Set_Iterator_Interfaces.Reversible_Iterator with record\n-        Container : access constant Set;\n+   type Iterator is limited new\n+     Set_Iterator_Interfaces.Reversible_Iterator with record\n+        Container : Set_Access;\n         Node      : Count_Type;\n      end record;\n \n@@ -591,9 +591,24 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      return (if Object.Container.First = 0 then No_Element\n-              else Cursor'(Object.Container.all'Unrestricted_Access,\n-                           Object.Container.First));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is 0, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is positive, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Bounded_Ordered_Sets.First (Object.Container.all);\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end First;\n \n    -------------------\n@@ -1206,22 +1221,60 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    end Iterate;\n \n    function Iterate (Container : Set)\n-     return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n    begin\n-      if Container.Length = 0 then\n-         return Iterator'(null, 0);\n-      else\n-         return Iterator'(Container'Unchecked_Access, Container.First);\n-      end if;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is 0 (as is the case here), this means the iterator object\n+      --  was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => 0);\n    end Iterate;\n \n    function Iterate (Container : Set; Start : Cursor)\n-     return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is positive (as is the case here), it means that this\n+      --  is a partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. (Note that\n+      --  the start position has the same value irrespective of whether this\n+      --  is a forward or reverse iteration.)\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ----------\n@@ -1236,9 +1289,24 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      return (if Object.Container.Last = 0 then No_Element\n-              else Cursor'(Object.Container.all'Unrestricted_Access,\n-                           Object.Container.Last));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is 0, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is positive, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = 0 then\n+         return Bounded_Ordered_Sets.Last (Object.Container.all);\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end Last;\n \n    ------------------\n@@ -1323,8 +1391,16 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    end Next;\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong set\";\n+      end if;\n+\n       return Next (Position);\n    end Next;\n \n@@ -1374,8 +1450,16 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    end Previous;\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong set\";\n+      end if;\n+\n       return Previous (Position);\n    end Previous;\n "}, {"sha": "9c4fdb4f31df7834860cc18e6c5109417f44d68e", "filename": "gcc/ada/a-cborse.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cborse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cborse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.ads?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -31,9 +31,9 @@\n -- This unit was originally developed by Matthew J Heaney.                  --\n ------------------------------------------------------------------------------\n \n-with Ada.Iterator_Interfaces;\n private with Ada.Containers.Red_Black_Trees;\n with Ada.Streams; use Ada.Streams;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type is private;\n@@ -62,7 +62,7 @@ package Ada.Containers.Bounded_Ordered_Sets is\n    No_Element : constant Cursor;\n    function Has_Element (Position : Cursor) return Boolean;\n \n-   package Ordered_Set_Iterator_Interfaces is new\n+   package Set_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    type Constant_Reference_Type\n@@ -212,12 +212,12 @@ package Ada.Containers.Bounded_Ordered_Sets is\n \n    function Iterate\n      (Container : Set)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n \n    function Iterate\n      (Container : Set;\n       Start     : Cursor)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n \n    generic\n       type Key_Type (<>) is private;"}, {"sha": "22c5890cea670274e12460131853d1431a92492f", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -41,10 +41,10 @@ with System;  use type System.Address;\n \n package body Ada.Containers.Indefinite_Hashed_Sets is\n \n-   type Iterator is new Set_Iterator_Interfaces.Forward_Iterator with record\n-      Container : Set_Access;\n-      Position  : Cursor;\n-   end record;\n+   type Iterator is limited new\n+     Set_Iterator_Interfaces.Forward_Iterator with record\n+        Container : Set_Access;\n+     end record;\n \n    overriding function First (Object : Iterator) return Cursor;\n \n@@ -649,10 +649,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n-      Node : constant Node_Access := HT_Ops.First (Object.Container.HT);\n    begin\n-      return (if Node = null then No_Element\n-              else Cursor'(Object.Container, Node));\n+      return Object.Container.First;\n    end First;\n \n    ----------\n@@ -1011,7 +1009,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    function Iterate (Container : Set)\n      return Set_Iterator_Interfaces.Forward_Iterator'Class is\n    begin\n-      return Iterator'(Container'Unrestricted_Access, First (Container));\n+      return Iterator'(Container => Container'Unrestricted_Access);\n    end Iterate;\n \n    ------------\n@@ -1072,12 +1070,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Position : Cursor) return Cursor\n    is\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n       if Position.Container /= Object.Container then\n          raise Program_Error with\n-           \"Position cursor designates wrong set\";\n+           \"Position cursor of Next designates wrong set\";\n       end if;\n \n-      return (if Position.Node = null then No_Element else Next (Position));\n+      return Next (Position);\n    end Next;\n \n    -------------\n@@ -1895,7 +1897,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Key_Keys.Delete_Key_Sans_Free (Container.HT, Key, X);\n \n          if X = null then\n-            raise Constraint_Error with \"key not in map\";\n+            raise Constraint_Error with \"key not in map\";  -- ??? \"set\"\n          end if;\n \n          Free (X);\n@@ -1913,7 +1915,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error with \"key not in map\";\n+            raise Constraint_Error with \"key not in map\";  -- ??? \"set\"\n          end if;\n \n          return Node.Element.all;"}, {"sha": "0d3af93f6d8ae1a7f833c6f87192d80e5fe77b75", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 104, "deletions": 17, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -42,9 +42,9 @@ with System; use type System.Address;\n \n package body Ada.Containers.Indefinite_Ordered_Sets is\n \n-   type Iterator is new\n-     Ordered_Set_Iterator_Interfaces.Reversible_Iterator with record\n-        Container : access constant Set;\n+   type Iterator is limited new\n+     Set_Iterator_Interfaces.Reversible_Iterator with record\n+        Container : Set_Access;\n         Node      : Node_Access;\n      end record;\n \n@@ -600,8 +600,24 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      return Cursor'(\n-        Object.Container.all'Unrestricted_Access, Object.Container.Tree.First);\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.First;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end First;\n \n    -------------------\n@@ -1259,22 +1275,62 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Iterate\n      (Container : Set)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+      return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator :=\n-             (Container'Unchecked_Access, Container.Tree.First);\n    begin\n-      return It;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => null);\n    end Iterate;\n \n    function Iterate\n      (Container : Set;\n       Start     : Cursor)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+      return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this is a\n+      --  partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ----------\n@@ -1290,9 +1346,24 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      return (if Object.Container.Tree.Last = null then No_Element\n-              else Cursor'(Object.Container.all'Unrestricted_Access,\n-                           Object.Container.Tree.Last));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.Last;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end Last;\n \n    ------------------\n@@ -1372,8 +1443,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong set\";\n+      end if;\n+\n       return Next (Position);\n    end Next;\n \n@@ -1430,8 +1509,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n      (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong set\";\n+      end if;\n+\n       return Previous (Position);\n    end Previous;\n "}, {"sha": "ac711246542826516d3e95683dda45c819d492e6", "filename": "gcc/ada/a-ciorse.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-ciorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-ciorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.ads?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -64,7 +64,7 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Has_Element (Position : Cursor) return Boolean;\n \n-   package Ordered_Set_Iterator_Interfaces is new\n+   package Set_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    type Constant_Reference_Type\n@@ -233,12 +233,12 @@ package Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Iterate\n      (Container : Set)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n \n    function Iterate\n      (Container : Set;\n       Start     : Cursor)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n \n    generic\n       type Key_Type (<>) is private;"}, {"sha": "fadff195ff582ef7bd52d0e937421b730cda772f", "filename": "gcc/ada/a-cohase.adb", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cohase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cohase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -41,6 +41,17 @@ with System; use type System.Address;\n \n package body Ada.Containers.Hashed_Sets is\n \n+   type Iterator is limited new\n+     Set_Iterator_Interfaces.Forward_Iterator with record\n+        Container : Set_Access;\n+     end record;\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+\n+   overriding function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -601,6 +612,11 @@ package body Ada.Containers.Hashed_Sets is\n       return Cursor'(Container'Unrestricted_Access, Node);\n    end First;\n \n+   function First (Object : Iterator) return Cursor is\n+   begin\n+      return Object.Container.First;\n+   end First;\n+\n    ----------\n    -- Free --\n    ----------\n@@ -920,6 +936,13 @@ package body Ada.Containers.Hashed_Sets is\n       B := B - 1;\n    end Iterate;\n \n+   function Iterate\n+     (Container : Set) return Set_Iterator_Interfaces.Forward_Iterator'Class\n+   is\n+   begin\n+      return Iterator'(Container => Container'Unrestricted_Access);\n+   end Iterate;\n+\n    ------------\n    -- Length --\n    ------------\n@@ -973,6 +996,23 @@ package body Ada.Containers.Hashed_Sets is\n       Position := Next (Position);\n    end Next;\n \n+   function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor\n+   is\n+   begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong set\";\n+      end if;\n+\n+      return Next (Position);\n+   end Next;\n+\n    -------------\n    -- Overlap --\n    -------------\n@@ -1695,7 +1735,7 @@ package body Ada.Containers.Hashed_Sets is\n \n       begin\n          if Node = null then\n-            raise Constraint_Error with \"key not in map\";\n+            raise Constraint_Error with \"key not in map\";  -- ??? \"set\"\n          end if;\n \n          return Node.Element;"}, {"sha": "96944cd2b2f93c48da017efc2e8d8743ba7863bc", "filename": "gcc/ada/a-cohase.ads", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cohase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-cohase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohase.ads?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -34,6 +34,7 @@\n private with Ada.Containers.Hash_Tables;\n private with Ada.Streams;\n private with Ada.Finalization;\n+with Ada.Iterator_Interfaces;\n \n generic\n    type Element_Type is private;\n@@ -49,7 +50,11 @@ package Ada.Containers.Hashed_Sets is\n    pragma Preelaborate;\n    pragma Remote_Types;\n \n-   type Set is tagged private;\n+   type Set is tagged private\n+   with\n+      Default_Iterator  => Iterate,\n+      Iterator_Element  => Element_Type;\n+\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n@@ -63,6 +68,12 @@ package Ada.Containers.Hashed_Sets is\n    --  Cursor objects declared without an initialization expression are\n    --  initialized to the value No_Element.\n \n+   function Has_Element (Position : Cursor) return Boolean;\n+   --  Equivalent to Position /= No_Element\n+\n+   package Set_Iterator_Interfaces is new\n+     Ada.Iterator_Interfaces (Cursor, Has_Element);\n+\n    function \"=\" (Left, Right : Set) return Boolean;\n    --  For each element in Left, set equality attempts to find the equal\n    --  element in Right; if a search fails, then set equality immediately\n@@ -303,9 +314,6 @@ package Ada.Containers.Hashed_Sets is\n    function Contains (Container : Set; Item : Element_Type) return Boolean;\n    --  Equivalent to Find (Container, Item) /= No_Element\n \n-   function Has_Element (Position : Cursor) return Boolean;\n-   --  Equivalent to Position /= No_Element\n-\n    function Equivalent_Elements (Left, Right : Cursor) return Boolean;\n    --  Returns the result of calling Equivalent_Elements with the elements of\n    --  the nodes designated by cursors Left and Right.\n@@ -327,6 +335,9 @@ package Ada.Containers.Hashed_Sets is\n       Process   : not null access procedure (Position : Cursor));\n    --  Calls Process for each node in the set\n \n+   function Iterate\n+     (Container : Set) return Set_Iterator_Interfaces.Forward_Iterator'Class;\n+\n    generic\n       type Key_Type (<>) is private;\n "}, {"sha": "ce004e2d737367240fdec36a5eeea3e8ae1f7194", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 104, "deletions": 20, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -42,9 +42,9 @@ with System; use type System.Address;\n \n package body Ada.Containers.Ordered_Sets is\n \n-   type Iterator is new\n-     Ordered_Set_Iterator_Interfaces.Reversible_Iterator with record\n-        Container : access constant Set;\n+   type Iterator is limited new\n+     Set_Iterator_Interfaces.Reversible_Iterator with record\n+        Container : Set_Access;\n         Node      : Node_Access;\n      end record;\n \n@@ -537,9 +537,24 @@ package body Ada.Containers.Ordered_Sets is\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      return (if Object.Container = null then No_Element\n-              else Cursor'(Object.Container.all'Unrestricted_Access,\n-                           Object.Container.Tree.First));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the First (and Last) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (forward)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  of items (corresponding to Container.First, for a forward iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (forward) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.First;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end First;\n \n    -------------------\n@@ -1165,22 +1180,60 @@ package body Ada.Containers.Ordered_Sets is\n    end Iterate;\n \n    function Iterate (Container : Set)\n-     return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n    begin\n-      if Container.Length = 0 then\n-         return Iterator'(null, null);\n-      else\n-         return Iterator'(Container'Unchecked_Access, Container.Tree.First);\n-      end if;\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is null (as is the case here), this means the iterator\n+      --  object was constructed without a start expression. This is a complete\n+      --  iterator, meaning that the iteration starts from the (logical)\n+      --  beginning of the sequence of items.\n+\n+      --  Note: For a forward iterator, Container.First is the beginning, and\n+      --  for a reverse iterator, Container.Last is the beginning.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => null);\n    end Iterate;\n \n    function Iterate (Container : Set; Start : Cursor)\n-     return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class\n+     return Set_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n-      It : constant Iterator := (Container'Unchecked_Access, Start.Node);\n    begin\n-      return It;\n+      --  It was formerly the case that when Start = No_Element, the partial\n+      --  iterator was defined to behave the same as for a complete iterator,\n+      --  and iterate over the entire sequence of items. However, those\n+      --  semantics were unintuitive and arguably error-prone (it is too easy\n+      --  to accidentally create an endless loop), and so they were changed,\n+      --  per the ARG meeting in Denver on 2011/11. However, there was no\n+      --  consensus about what positive meaning this corner case should have,\n+      --  and so it was decided to simply raise an exception. This does imply,\n+      --  however, that it is not possible to use a partial iterator to specify\n+      --  an empty sequence of items.\n+\n+      if Start = No_Element then\n+         raise Constraint_Error with\n+           \"Start position for iterator equals No_Element\";\n+      end if;\n+\n+      if Start.Container /= Container'Unrestricted_Access then\n+         raise Program_Error with\n+           \"Start cursor of Iterate designates wrong set\";\n+      end if;\n+\n+      pragma Assert (Vet (Container.Tree, Start.Node),\n+                     \"Start cursor of Iterate is bad\");\n+\n+      --  The value of the Node component influences the behavior of the First\n+      --  and Last selector functions of the iterator object. When the Node\n+      --  component is non-null (as is the case here), it means that this is a\n+      --  partial iteration, over a subset of the complete sequence of\n+      --  items. The iterator object was constructed with a start expression,\n+      --  indicating the position from which the iteration begins. Note that\n+      --  the start position has the same value irrespective of whether this is\n+      --  a forward or reverse iteration.\n+\n+      return Iterator'(Container'Unrestricted_Access, Node => Start.Node);\n    end Iterate;\n \n    ----------\n@@ -1196,9 +1249,24 @@ package body Ada.Containers.Ordered_Sets is\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      return (if Object.Container = null then No_Element\n-              else Cursor'(Object.Container.all'Unrestricted_Access,\n-                           Object.Container.Tree.Last));\n+      --  The value of the iterator object's Node component influences the\n+      --  behavior of the Last (and First) selector function.\n+\n+      --  When the Node component is null, this means the iterator object was\n+      --  constructed without a start expression, in which case the (reverse)\n+      --  iteration starts from the (logical) beginning of the entire sequence\n+      --  (corresponding to Container.Last, for a reverse iterator).\n+\n+      --  Otherwise, this is iteration over a partial sequence of items. When\n+      --  the Node component is non-null, the iterator object was constructed\n+      --  with a start expression, that specifies the position from which the\n+      --  (reverse) partial iteration begins.\n+\n+      if Object.Node = null then\n+         return Object.Container.Last;\n+      else\n+         return Cursor'(Object.Container, Object.Node);\n+      end if;\n    end Last;\n \n    ------------------\n@@ -1271,8 +1339,16 @@ package body Ada.Containers.Ordered_Sets is\n    end Next;\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Next designates wrong set\";\n+      end if;\n+\n       return Next (Position);\n    end Next;\n \n@@ -1322,8 +1398,16 @@ package body Ada.Containers.Ordered_Sets is\n    end Previous;\n \n    function Previous (Object : Iterator; Position : Cursor) return Cursor is\n-      pragma Unreferenced (Object);\n    begin\n+      if Position.Container = null then\n+         return No_Element;\n+      end if;\n+\n+      if Position.Container /= Object.Container then\n+         raise Program_Error with\n+           \"Position cursor of Previous designates wrong set\";\n+      end if;\n+\n       return Previous (Position);\n    end Previous;\n "}, {"sha": "39f69f5eff0da21af57577245e02108615371c0f", "filename": "gcc/ada/a-coorse.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-coorse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fa-coorse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.ads?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -65,7 +65,7 @@ package Ada.Containers.Ordered_Sets is\n \n    No_Element : constant Cursor;\n \n-   package Ordered_Set_Iterator_Interfaces is new\n+   package Set_Iterator_Interfaces is new\n      Ada.Iterator_Interfaces (Cursor, Has_Element);\n \n    type Constant_Reference_Type\n@@ -227,12 +227,12 @@ package Ada.Containers.Ordered_Sets is\n \n    function Iterate\n      (Container : Set)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n \n    function Iterate\n      (Container : Set;\n       Start     : Cursor)\n-      return Ordered_Set_Iterator_Interfaces.Reversible_Iterator'class;\n+      return Set_Iterator_Interfaces.Reversible_Iterator'class;\n \n    generic\n       type Key_Type (<>) is private;"}, {"sha": "b116a8a28f0a9bc37914d577a61d14f040cb861a", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -1123,6 +1123,10 @@ package body Exp_Intr is\n                D_Type   : Entity_Id;\n \n             begin\n+               --  Perform minor decoration as it is needed by the side effect\n+               --  removal mechanism.\n+\n+               Set_Etype  (Deref, Desig_T);\n                Set_Parent (Deref, Free_Node);\n                D_Subtyp := Make_Subtype_From_Expr (Deref, Desig_T);\n "}, {"sha": "2bab2b930495200b387b674de1d17ca28505e59c", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 91, "deletions": 90, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -146,7 +146,7 @@ pragma Style_Checks (\"M32766\");\n \n # define NATIVE\n \n-#endif\n+#endif /* DUMMY */\n \n #ifndef TARGET\n # error Please define TARGET\n@@ -213,7 +213,7 @@ int counter = 0;\n   : : \"i\" (__LINE__));\n /* Freeform text */\n \n-#endif\n+#endif /* NATIVE */\n \n #define CST(name,comment) C(#name,String,name,comment)\n \n@@ -1208,55 +1208,6 @@ CND(IP_DROP_MEMBERSHIP, \"Leave a multicast group\")\n #endif\n CND(IP_PKTINFO, \"Get datagram info\")\n \n-#endif /* HAVE_SOCKETS */\n-\n-/*\n-\n-   ------------\n-   -- Clocks --\n-   ------------\n-\n-*/\n-\n-#ifdef CLOCK_REALTIME\n-CND(CLOCK_REALTIME, \"System realtime clock\")\n-#endif\n-\n-#ifdef CLOCK_MONOTONIC\n-CND(CLOCK_MONOTONIC, \"System monotonic clock\")\n-#endif\n-\n-#ifdef CLOCK_FASTEST\n-CND(CLOCK_FASTEST, \"Fastest clock\")\n-#endif\n-\n-#if defined (__sgi)\n-CND(CLOCK_SGI_FAST,  \"SGI fast clock\")\n-CND(CLOCK_SGI_CYCLE, \"SGI CPU clock\")\n-#endif\n-\n-#if defined(__APPLE__)\n-/* There's no clock_gettime or clock_id's on Darwin */\n-# define CLOCK_RT_Ada \"-1\"\n-\n-#elif defined(FreeBSD) || defined(_AIX)\n-/* On these platforms use system provided monotonic clock */\n-# define CLOCK_RT_Ada \"CLOCK_MONOTONIC\"\n-\n-#elif defined(CLOCK_REALTIME)\n-/* By default use CLOCK_REALTIME */\n-# define CLOCK_RT_Ada \"CLOCK_REALTIME\"\n-#endif\n-\n-#ifdef CLOCK_RT_Ada\n-CNS(CLOCK_RT_Ada, \"Ada realtime clock\")\n-#endif\n-\n-#ifndef CLOCK_THREAD_CPUTIME_ID\n-# define CLOCK_THREAD_CPUTIME_ID -1\n-#endif\n-CND(CLOCK_THREAD_CPUTIME_ID, \"Thread CPU clock\")\n-\n /*\n \n    ----------------------\n@@ -1367,58 +1318,67 @@ CST(Inet_Pton_Linkname, \"\")\n \n #endif /* HAVE_SOCKETS */\n \n-/**\n- **  System-specific constants follow\n- **  Each section should be activated if compiling for the corresponding\n- **  platform *or* generating the dummy version for runtime test compilation.\n- **/\n-\n-#if defined (__vxworks) || defined (DUMMY)\n-\n /*\n \n-   --------------------------------\n-   -- VxWorks-specific constants --\n-   --------------------------------\n+   ---------------------\n+   -- Threads support --\n+   ---------------------\n+\n+   --  Clock identifier definitions\n \n-   --  These constants may be used only within the VxWorks version of\n-   --  GNAT.Sockets.Thin.\n */\n \n-CND(OK,    \"VxWorks generic success\")\n-CND(ERROR, \"VxWorks generic error\")\n+#ifdef CLOCK_REALTIME\n+CND(CLOCK_REALTIME, \"System realtime clock\")\n+#endif\n \n+#ifdef CLOCK_MONOTONIC\n+CND(CLOCK_MONOTONIC, \"System monotonic clock\")\n #endif\n \n-#if defined (__MINGW32__) || defined (DUMMY)\n-/*\n+#ifdef CLOCK_FASTEST\n+CND(CLOCK_FASTEST, \"Fastest clock\")\n+#endif\n \n-   ------------------------------\n-   -- MinGW-specific constants --\n-   ------------------------------\n+#if defined (__sgi)\n+CND(CLOCK_SGI_FAST,  \"SGI fast clock\")\n+CND(CLOCK_SGI_CYCLE, \"SGI CPU clock\")\n+#endif\n \n-   --  These constants may be used only within the MinGW version of\n-   --  GNAT.Sockets.Thin.\n-*/\n+#if defined(__APPLE__)\n+/* There's no clock_gettime or clock_id's on Darwin */\n+# define CLOCK_RT_Ada \"-1\"\n \n-CND(WSASYSNOTREADY,     \"System not ready\")\n-CND(WSAVERNOTSUPPORTED, \"Version not supported\")\n-CND(WSANOTINITIALISED,  \"Winsock not initialized\")\n-CND(WSAEDISCON,         \"Disconnected\")\n+#elif defined(FreeBSD) || defined(_AIX)\n+/* On these platforms use system provided monotonic clock */\n+# define CLOCK_RT_Ada \"CLOCK_MONOTONIC\"\n \n+#elif defined(CLOCK_REALTIME)\n+/* By default use CLOCK_REALTIME */\n+# define CLOCK_RT_Ada \"CLOCK_REALTIME\"\n #endif\n \n-#ifdef NATIVE\n-   putchar ('\\n');\n+#ifdef CLOCK_RT_Ada\n+CNS(CLOCK_RT_Ada, \"\")\n+#endif\n+\n+#ifndef CLOCK_THREAD_CPUTIME_ID\n+# define CLOCK_THREAD_CPUTIME_ID -1\n #endif\n+CND(CLOCK_THREAD_CPUTIME_ID, \"Thread CPU clock\")\n \n #if defined (__APPLE__) || defined (__linux__) || defined (DUMMY)\n /*\n \n-   --  Sizes of pthread data types (on Darwin these are padding)\n+   --  Sizes of pthread data types\n+\n */\n \n #if defined (__APPLE__) || defined (DUMMY)\n+/*\n+   --  (on Darwin, these are just placeholders)\n+\n+*/\n #define PTHREAD_SIZE            __PTHREAD_SIZE__\n #define PTHREAD_ATTR_SIZE       __PTHREAD_ATTR_SIZE__\n #define PTHREAD_MUTEXATTR_SIZE  __PTHREAD_MUTEXATTR_SIZE__\n@@ -1440,24 +1400,65 @@ CND(WSAEDISCON,         \"Disconnected\")\n #define PTHREAD_ONCE_SIZE       (sizeof (pthread_once_t))\n #endif\n \n-CND(PTHREAD_SIZE, \"pthread_t\")\n+CND(PTHREAD_SIZE,            \"pthread_t\")\n+CND(PTHREAD_ATTR_SIZE,       \"pthread_attr_t\")\n+CND(PTHREAD_MUTEXATTR_SIZE,  \"pthread_mutexattr_t\")\n+CND(PTHREAD_MUTEX_SIZE,      \"pthread_mutex_t\")\n+CND(PTHREAD_CONDATTR_SIZE,   \"pthread_condattr_t\")\n+CND(PTHREAD_COND_SIZE,       \"pthread_cond_t\")\n+CND(PTHREAD_RWLOCKATTR_SIZE, \"pthread_rwlockattr_t\")\n+CND(PTHREAD_RWLOCK_SIZE,     \"pthread_rwlock_t\")\n+CND(PTHREAD_ONCE_SIZE,       \"pthread_once_t\")\n+\n+#endif /* __APPLE__ || __linux__ */\n \n-CND(PTHREAD_ATTR_SIZE, \"pthread_attr_t\")\n+/**\n+ **  System-specific constants follow\n+ **  Each section should be activated if compiling for the corresponding\n+ **  platform *or* generating the dummy version for runtime test compilation.\n+ **/\n \n-CND(PTHREAD_MUTEXATTR_SIZE, \"pthread_mutexattr_t\")\n+#if defined (__vxworks) || defined (DUMMY)\n \n-CND(PTHREAD_MUTEX_SIZE, \"pthread_mutex_t\")\n+/*\n \n-CND(PTHREAD_CONDATTR_SIZE, \"pthread_condattr_t\")\n+   --------------------------------\n+   -- VxWorks-specific constants --\n+   --------------------------------\n \n-CND(PTHREAD_COND_SIZE, \"pthread_cond_t\")\n+   --  These constants may be used only within the VxWorks version of\n+   --  GNAT.Sockets.Thin.\n+*/\n \n-CND(PTHREAD_RWLOCKATTR_SIZE, \"pthread_rwlockattr_t\")\n+CND(OK,    \"VxWorks generic success\")\n+CND(ERROR, \"VxWorks generic error\")\n \n-CND(PTHREAD_RWLOCK_SIZE, \"pthread_rwlock_t\")\n+#endif /* __vxworks */\n \n-CND(PTHREAD_ONCE_SIZE, \"pthread_once_t\")\n+#if defined (__MINGW32__) || defined (DUMMY)\n+/*\n \n+   ------------------------------\n+   -- MinGW-specific constants --\n+   ------------------------------\n+\n+   --  These constants may be used only within the MinGW version of\n+   --  GNAT.Sockets.Thin.\n+*/\n+\n+CND(WSASYSNOTREADY,     \"System not ready\")\n+CND(WSAVERNOTSUPPORTED, \"Version not supported\")\n+CND(WSANOTINITIALISED,  \"Winsock not initialized\")\n+CND(WSAEDISCON,         \"Disconnected\")\n+\n+#endif /* __MINGW32__ */\n+\n+/**\n+ ** End of constants definitions\n+ **/\n+\n+#ifdef NATIVE\n+   putchar ('\\n');\n #endif\n \n /*"}, {"sha": "1eccae5612aaf069de103e3e7106771934691e48", "filename": "gcc/ada/s-osprim-vxworks.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fs-osprim-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fs-osprim-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osprim-vxworks.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1998-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,13 +37,16 @@ with System.OS_Interface;\n --  set of C imported routines: using Ada routines from this package would\n --  create a dependency on libgnarl in libgnat, which is not desirable.\n \n+with System.OS_Constants;\n with Interfaces.C;\n \n package body System.OS_Primitives is\n \n    use System.OS_Interface;\n    use type Interfaces.C.int;\n \n+   package OSC renames System.OS_Constants;\n+\n    ------------------------\n    -- Internal functions --\n    ------------------------\n@@ -94,7 +97,7 @@ package body System.OS_Primitives is\n       TS     : aliased timespec;\n       Result : int;\n    begin\n-      Result := clock_gettime (CLOCK_REALTIME, TS'Unchecked_Access);\n+      Result := clock_gettime (OSC.CLOCK_RT_Ada, TS'Unchecked_Access);\n       pragma Assert (Result = 0);\n       return Duration (TS.ts_sec) + Duration (TS.ts_nsec) / 10#1#E9;\n    end Clock;"}, {"sha": "16bfbeb539a997ede86488243628855f26930b1b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b38c20a636ec4e92cdabecbfa487b742829ebe93/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=b38c20a636ec4e92cdabecbfa487b742829ebe93", "patch": "@@ -4064,6 +4064,19 @@ package body Sem_Ch3 is\n \n       T := Process_Subtype (Subtype_Indication (N), N, Id, 'P');\n \n+      --  Class-wide equivalent types of records with unknown discriminants\n+      --  involve the generation of an itype which serves as the private view\n+      --  of a constrained record subtype. In such cases the base type of the\n+      --  current subtype we are processing is the private itype. Use the full\n+      --  of the private itype when decorating various attributes.\n+\n+      if Is_Itype (T)\n+        and then Is_Private_Type (T)\n+        and then Present (Full_View (T))\n+      then\n+         T := Full_View (T);\n+      end if;\n+\n       --  Inherit common attributes\n \n       Set_Is_Generic_Type   (Id, Is_Generic_Type   (Base_Type (T)));"}]}