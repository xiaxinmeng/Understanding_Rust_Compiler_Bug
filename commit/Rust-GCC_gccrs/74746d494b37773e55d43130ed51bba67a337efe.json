{"sha": "74746d494b37773e55d43130ed51bba67a337efe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ3NDZkNDk0YjM3NzczZTU1ZDQzMTMwZWQ1MWJiYTY3YTMzN2VmZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-05-26T09:52:10Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-05-26T09:52:10Z"}, "message": "gigi.h (create_type_decl): Adjust prototype.\n\n\t* gcc-interface/gigi.h (create_type_decl): Adjust prototype.\n\t(create_label_decl): Complete prototype.\n\t(process_attributes): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust multiple calls to\n\tcreate_type_decl throughout.\n\t<E_Enumeration_Type>: Do the layout of the type manually and call\n\tprocess_attributes on it.  Reindent.\n\t<E_Enumeration_Subtype>: Minor tweak.\n\t<E_Floating_Point_Subtype>: Reindent.\n\t<E_Array_Subtype>: Call process_attributes on the array type built\n\tfor a packed array type.\n\t<E_Record_Type>: Call process_attributes on the type.\n\t<E_Record_Subtype>: Likewise.\n\t<E_Access_Type>: Likewise.\n\t<E_Subprogram_Type>: Likewise.\n\tLikewise for all types at the end of the processing.\n\t* gcc-interface/utils.c (make_aligning_type): Adjust call to\n\tcreate_type_decl.\n\t(maybe_pad_type): Likewise.\n\t(create_index_type): Likewise.\n\t(create_type_decl): Remove attr_list parameter and associated code.\n\t(create_var_decl_1): Call process_attributes on the variable.\n\t(process_attributes): Take a pointer to the object and add in_place\n\tand gnat_node parameters and adjust throughout.\n\t<ATTR_MACHINE_ATTRIBUTE>: Pass ATTR_FLAG_TYPE_IN_PLACE only on demand\n\tand set the input location.\n\tZap the attribute list at the end.\n\t(create_subprog_decl): Call process_attributes on the subprogram.\n\t(build_unc_object_type): Adjust call to create_type_decl.\n\t(handle_vector_type_attribute): Remove dead code.\n\nFrom-SVN: r199338", "tree": {"sha": "fc4098b21c27a360d99df062bc2d7da27cb3cac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc4098b21c27a360d99df062bc2d7da27cb3cac9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74746d494b37773e55d43130ed51bba67a337efe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74746d494b37773e55d43130ed51bba67a337efe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74746d494b37773e55d43130ed51bba67a337efe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74746d494b37773e55d43130ed51bba67a337efe/comments", "author": null, "committer": null, "parents": [{"sha": "0746af5e6219d9dabd84aa865a056e4e8ae27c3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0746af5e6219d9dabd84aa865a056e4e8ae27c3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0746af5e6219d9dabd84aa865a056e4e8ae27c3d"}], "stats": {"total": 428, "additions": 239, "deletions": 189}, "files": [{"sha": "9eac544c9559ff2006cc7d789cdddc96014f7ae4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=74746d494b37773e55d43130ed51bba67a337efe", "patch": "@@ -1,3 +1,36 @@\n+2013-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (create_type_decl): Adjust prototype.\n+\t(create_label_decl): Complete prototype.\n+\t(process_attributes): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust multiple calls to\n+\tcreate_type_decl throughout.\n+\t<E_Enumeration_Type>: Do the layout of the type manually and call\n+\tprocess_attributes on it.  Reindent.\n+\t<E_Enumeration_Subtype>: Minor tweak.\n+\t<E_Floating_Point_Subtype>: Reindent.\n+\t<E_Array_Subtype>: Call process_attributes on the array type built\n+\tfor a packed array type.\n+\t<E_Record_Type>: Call process_attributes on the type.\n+\t<E_Record_Subtype>: Likewise.\n+\t<E_Access_Type>: Likewise.\n+\t<E_Subprogram_Type>: Likewise.\n+\tLikewise for all types at the end of the processing.\n+\t* gcc-interface/utils.c (make_aligning_type): Adjust call to\n+\tcreate_type_decl.\n+\t(maybe_pad_type): Likewise.\n+\t(create_index_type): Likewise.\n+\t(create_type_decl): Remove attr_list parameter and associated code.\n+\t(create_var_decl_1): Call process_attributes on the variable.\n+\t(process_attributes): Take a pointer to the object and add in_place\n+\tand gnat_node parameters and adjust throughout.\n+\t<ATTR_MACHINE_ATTRIBUTE>: Pass ATTR_FLAG_TYPE_IN_PLACE only on demand\n+\tand set the input location.\n+\tZap the attribute list at the end.\n+\t(create_subprog_decl): Call process_attributes on the subprogram.\n+\t(build_unc_object_type): Adjust call to create_type_decl.\n+\t(handle_vector_type_attribute): Remove dead code.\n+\n 2013-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (make_aligning_type): Adjust prototype."}, {"sha": "36f86444631f3954035d52c9f6c168257d2a7fb7", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 137, "deletions": 131, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=74746d494b37773e55d43130ed51bba67a337efe", "patch": "@@ -692,7 +692,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   never be declared otherwise.  This is necessary to ensure\n \t\t   that its subtrees are properly marked.  */\n \t\tif (gnu_type != orig_type && !DECL_P (TYPE_NAME (gnu_type)))\n-\t\t  create_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL, true,\n+\t\t  create_type_decl (TYPE_NAME (gnu_type), gnu_type, true,\n \t\t\t\t    debug_info_p, gnat_entity);\n \t      }\n \t  }\n@@ -940,7 +940,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       never be declared otherwise.  This is necessary to ensure\n \t       that its subtrees are properly marked.  */\n \t    if (gnu_type != orig_type && !DECL_P (TYPE_NAME (gnu_type)))\n-\t      create_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL, true,\n+\t      create_type_decl (TYPE_NAME (gnu_type), gnu_type, true,\n \t\t\t\tdebug_info_p, gnat_entity);\n \t  }\n \n@@ -1613,7 +1613,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Enumeration_Type:\n       /* A special case: for the types Character and Wide_Character in\n \t Standard, we do not list all the literals.  So if the literals\n-\t are not specified, make this an unsigned type.  */\n+\t are not specified, make this an unsigned integer type.  */\n       if (No (First_Literal (gnat_entity)))\n \t{\n \t  gnu_type = make_unsigned_type (esize);\n@@ -1623,52 +1623,54 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     This is needed by the DWARF-2 back-end to distinguish between\n \t     unsigned integer types and character types.  */\n \t  TYPE_STRING_FLAG (gnu_type) = 1;\n-\t  break;\n \t}\n+      else\n+\t{\n+\t  /* We have a list of enumeral constants in First_Literal.  We make a\n+\t     CONST_DECL for each one and build into GNU_LITERAL_LIST the list\n+\t     to be placed into TYPE_FIELDS.  Each node is itself a TREE_LIST\n+\t     whose TREE_VALUE is the literal name and whose TREE_PURPOSE is the\n+\t     value of the literal.  But when we have a regular boolean type, we\n+\t     simplify this a little by using a BOOLEAN_TYPE.  */\n+\t  const bool is_boolean = Is_Boolean_Type (gnat_entity)\n+\t\t\t\t  && !Has_Non_Standard_Rep (gnat_entity);\n+\t  const bool is_unsigned = Is_Unsigned_Type (gnat_entity);\n+\t  tree gnu_list = NULL_TREE;\n+\t  Entity_Id gnat_literal;\n+\n+\t  gnu_type = make_node (is_boolean ? BOOLEAN_TYPE : ENUMERAL_TYPE);\n+\t  TYPE_PRECISION (gnu_type) = esize;\n+\t  TYPE_UNSIGNED (gnu_type) = is_unsigned;\n+\t  set_min_and_max_values_for_integral_type (gnu_type, esize,\n+\t\t\t\t\t\t    is_unsigned);\n+\t  process_attributes (&gnu_type, &attr_list, true, gnat_entity);\n+\t  layout_type (gnu_type);\n+\n+\t  for (gnat_literal = First_Literal (gnat_entity);\n+\t       Present (gnat_literal);\n+\t       gnat_literal = Next_Literal (gnat_literal))\n+\t    {\n+\t      tree gnu_value\n+\t\t= UI_To_gnu (Enumeration_Rep (gnat_literal), gnu_type);\n+\t      tree gnu_literal\n+\t\t= create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n+\t\t\t\t   gnu_type, gnu_value, true, false, false,\n+\t\t\t\t   false, NULL, gnat_literal);\n+\t      /* Do not generate debug info for individual enumerators.  */\n+\t      DECL_IGNORED_P (gnu_literal) = 1;\n+\t      save_gnu_tree (gnat_literal, gnu_literal, false);\n+\t      gnu_list\n+\t        = tree_cons (DECL_NAME (gnu_literal), gnu_value, gnu_list);\n+\t    }\n \n-      {\n-\t/* We have a list of enumeral constants in First_Literal.  We make a\n-\t   CONST_DECL for each one and build into GNU_LITERAL_LIST the list to\n-\t   be placed into TYPE_FIELDS.  Each node in the list is a TREE_LIST\n-\t   whose TREE_VALUE is the literal name and whose TREE_PURPOSE is the\n-\t   value of the literal.  But when we have a regular boolean type, we\n-\t   simplify this a little by using a BOOLEAN_TYPE.  */\n-\tbool is_boolean = Is_Boolean_Type (gnat_entity)\n-\t\t\t  && !Has_Non_Standard_Rep (gnat_entity);\n-\ttree gnu_literal_list = NULL_TREE;\n-\tEntity_Id gnat_literal;\n-\n-\tif (Is_Unsigned_Type (gnat_entity))\n-\t  gnu_type = make_unsigned_type (esize);\n-\telse\n-\t  gnu_type = make_signed_type (esize);\n-\n-\tTREE_SET_CODE (gnu_type, is_boolean ? BOOLEAN_TYPE : ENUMERAL_TYPE);\n-\n-\tfor (gnat_literal = First_Literal (gnat_entity);\n-\t     Present (gnat_literal);\n-\t     gnat_literal = Next_Literal (gnat_literal))\n-\t  {\n-\t    tree gnu_value\n-\t      = UI_To_gnu (Enumeration_Rep (gnat_literal), gnu_type);\n-\t    tree gnu_literal\n-\t      = create_var_decl (get_entity_name (gnat_literal), NULL_TREE,\n-\t\t\t\t gnu_type, gnu_value, true, false, false,\n-\t\t\t\t false, NULL, gnat_literal);\n-\t    /* Do not generate debug info for individual enumerators.  */\n-\t    DECL_IGNORED_P (gnu_literal) = 1;\n-\t    save_gnu_tree (gnat_literal, gnu_literal, false);\n-\t    gnu_literal_list = tree_cons (DECL_NAME (gnu_literal),\n-\t\t\t\t\t  gnu_value, gnu_literal_list);\n-\t  }\n-\n-\tif (!is_boolean)\n-\t  TYPE_VALUES (gnu_type) = nreverse (gnu_literal_list);\n+\t  if (!is_boolean)\n+\t    TYPE_VALUES (gnu_type) = nreverse (gnu_list);\n \n-\t/* Note that the bounds are updated at the end of this function\n-\t   to avoid an infinite recursion since they refer to the type.  */\n-      }\n-      goto discrete_type;\n+\t  /* Note that the bounds are updated at the end of this function\n+\t     to avoid an infinite recursion since they refer to the type.  */\n+\t  goto discrete_type;\n+\t}\n+      break;\n \n     case E_Signed_Integer_Type:\n     case E_Ordinary_Fixed_Point_Type:\n@@ -1776,6 +1778,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\tdefinition, true,\n \t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n \n+      TYPE_BIASED_REPRESENTATION_P (gnu_type)\n+\t= Has_Biased_Representation (gnat_entity);\n+\n+      /* Inherit our alias set from what we're a subtype of.  Subtypes\n+\t are not different types and a pointer can designate any instance\n+\t within a subtype hierarchy.  */\n+      relate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n+\n       /* One of the above calls might have caused us to be elaborated,\n \t so don't blow up if so.  */\n       if (present_gnu_tree (gnat_entity))\n@@ -1784,18 +1794,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  break;\n \t}\n \n-      TYPE_BIASED_REPRESENTATION_P (gnu_type)\n-\t= Has_Biased_Representation (gnat_entity);\n-\n       /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n       TYPE_STUB_DECL (gnu_type)\n \t= create_type_stub_decl (gnu_entity_name, gnu_type);\n \n-      /* Inherit our alias set from what we're a subtype of.  Subtypes\n-\t are not different types and a pointer can designate any instance\n-\t within a subtype hierarchy.  */\n-      relate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n-\n       /* For a packed array, make the original array type a parallel type.  */\n       if (debug_info_p\n \t  && Is_Packed_Array_Type (gnat_entity)\n@@ -1836,8 +1838,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type) = 1;\n \n \t  /* Create a stripped-down declaration, mainly for debugging.  */\n-\t  create_type_decl (gnu_entity_name, gnu_type, NULL, true,\n-\t\t\t    debug_info_p, gnat_entity);\n+\t  create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n+\t\t\t    gnat_entity);\n \n \t  /* Now save it and build the enclosing record type.  */\n \t  gnu_field_type = gnu_type;\n@@ -1897,8 +1899,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    UI_To_gnu (RM_Size (gnat_entity), bitsizetype));\n \n \t  /* Create a stripped-down declaration, mainly for debugging.  */\n-\t  create_type_decl (gnu_entity_name, gnu_type, NULL, true,\n-\t\t\t    debug_info_p, gnat_entity);\n+\t  create_type_decl (gnu_entity_name, gnu_type, true, debug_info_p,\n+\t\t\t    gnat_entity);\n \n \t  /* Now save it and build the enclosing record type.  */\n \t  gnu_field_type = gnu_type;\n@@ -1954,53 +1956,47 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  break;\n \t}\n \n-      {\n-\tif (!definition\n-\t    && Present (Ancestor_Subtype (gnat_entity))\n-\t    && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n-\t    && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n-\t\t|| !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n-\t  gnat_to_gnu_entity (Ancestor_Subtype (gnat_entity),\n-\t\t\t      gnu_expr, 0);\n-\n-\tgnu_type = make_node (REAL_TYPE);\n-\tTREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n-\tTYPE_PRECISION (gnu_type) = fp_size_to_prec (esize);\n-\tTYPE_GCC_MIN_VALUE (gnu_type)\n-\t  = TYPE_GCC_MIN_VALUE (TREE_TYPE (gnu_type));\n-\tTYPE_GCC_MAX_VALUE (gnu_type)\n-\t  = TYPE_GCC_MAX_VALUE (TREE_TYPE (gnu_type));\n-\tlayout_type (gnu_type);\n-\n-\tSET_TYPE_RM_MIN_VALUE\n-\t  (gnu_type,\n-\t   convert (TREE_TYPE (gnu_type),\n-\t\t    elaborate_expression (Type_Low_Bound (gnat_entity),\n-\t\t\t\t\t  gnat_entity, get_identifier (\"L\"),\n-\t\t\t\t\t  definition, true,\n-\t\t\t\t\t  Needs_Debug_Info (gnat_entity))));\n-\n-\tSET_TYPE_RM_MAX_VALUE\n-\t  (gnu_type,\n-\t   convert (TREE_TYPE (gnu_type),\n-\t\t    elaborate_expression (Type_High_Bound (gnat_entity),\n-\t\t\t\t\t  gnat_entity, get_identifier (\"U\"),\n-\t\t\t\t\t  definition, true,\n-\t\t\t\t\t  Needs_Debug_Info (gnat_entity))));\n-\n-\t/* One of the above calls might have caused us to be elaborated,\n-\t   so don't blow up if so.  */\n-\tif (present_gnu_tree (gnat_entity))\n-\t  {\n-\t    maybe_present = true;\n-\t    break;\n-\t  }\n+      /* See the E_Signed_Integer_Subtype case for the rationale.  */\n+      if (!definition\n+\t  && Present (Ancestor_Subtype (gnat_entity))\n+\t  && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n+\t  && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n+\t      || !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n+\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, 0);\n \n-\t/* Inherit our alias set from what we're a subtype of, as for\n-\t   integer subtypes.  */\n-\trelate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n-      }\n-    break;\n+      gnu_type = make_node (REAL_TYPE);\n+      TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n+      TYPE_PRECISION (gnu_type) = fp_size_to_prec (esize);\n+      TYPE_GCC_MIN_VALUE (gnu_type)\n+\t= TYPE_GCC_MIN_VALUE (TREE_TYPE (gnu_type));\n+      TYPE_GCC_MAX_VALUE (gnu_type)\n+\t= TYPE_GCC_MAX_VALUE (TREE_TYPE (gnu_type));\n+      layout_type (gnu_type);\n+\n+      SET_TYPE_RM_MIN_VALUE\n+\t(gnu_type,\n+\t convert (TREE_TYPE (gnu_type),\n+\t\t  elaborate_expression (Type_Low_Bound (gnat_entity),\n+\t\t\t\t\tgnat_entity, get_identifier (\"L\"),\n+\t\t\t\t\tdefinition, true,\n+\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\n+      SET_TYPE_RM_MAX_VALUE\n+\t(gnu_type,\n+\t convert (TREE_TYPE (gnu_type),\n+\t\t  elaborate_expression (Type_High_Bound (gnat_entity),\n+\t\t\t\t\tgnat_entity, get_identifier (\"U\"),\n+\t\t\t\t\tdefinition, true,\n+\t\t\t\t\tNeeds_Debug_Info (gnat_entity))));\n+\n+      /* Inherit our alias set from what we're a subtype of, as for\n+\t integer subtypes.  */\n+      relate_alias_sets (gnu_type, TREE_TYPE (gnu_type), ALIAS_SET_COPY);\n+\n+      /* One of the above calls might have caused us to be elaborated,\n+\t so don't blow up if so.  */\n+      maybe_present = true;\n+      break;\n \n       /* Array and String Types and Subtypes\n \n@@ -2296,19 +2292,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t       TYPE_SIZE_UNIT (tem));\n \t  }\n \n-\tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"),\n-\t\t\t  tem, NULL, !Comes_From_Source (gnat_entity),\n-\t\t\t  debug_info_p, gnat_entity);\n+\tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"), tem,\n+\t\t\t  !Comes_From_Source (gnat_entity), debug_info_p,\n+\t\t\t  gnat_entity);\n \n \t/* Give the fat pointer type a name.  If this is a packed type, tell\n \t   the debugger how to interpret the underlying bits.  */\n \tif (Present (Packed_Array_Type (gnat_entity)))\n \t  gnat_name = Packed_Array_Type (gnat_entity);\n \telse\n \t  gnat_name = gnat_entity;\n-\tcreate_type_decl (create_concat_name (gnat_name, \"XUP\"),\n-\t\t\t  gnu_fat_type, NULL, !Comes_From_Source (gnat_entity),\n-\t\t\t  debug_info_p, gnat_entity);\n+\tcreate_type_decl (create_concat_name (gnat_name, \"XUP\"), gnu_fat_type,\n+\t\t\t  !Comes_From_Source (gnat_entity), debug_info_p,\n+\t\t\t  gnat_entity);\n \n \t/* Create the type to be designated by thin pointers: a record type for\n \t   the array and its template.  We used to shift the fields to have the\n@@ -2734,18 +2730,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* First finish the type we had been making so that we output\n \t\t debugging information for it.  */\n+\t      process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n \t      if (Treat_As_Volatile (gnat_entity))\n \t\tgnu_type\n \t\t  = build_qualified_type (gnu_type,\n \t\t\t\t\t  TYPE_QUALS (gnu_type)\n \t\t\t\t\t  | TYPE_QUAL_VOLATILE);\n-\n \t      /* Make it artificial only if the base type was artificial too.\n \t\t That's sort of \"morally\" true and will make it possible for\n \t\t the debugger to look it up by name in DWARF, which is needed\n \t\t in order to decode the packed array type.  */\n \t      gnu_decl\n-\t\t= create_type_decl (gnu_entity_name, gnu_type, attr_list,\n+\t\t= create_type_decl (gnu_entity_name, gnu_type,\n \t\t\t\t    !Comes_From_Source (Etype (gnat_entity))\n \t\t\t\t    && !Comes_From_Source (gnat_entity),\n \t\t\t\t    debug_info_p, gnat_entity);\n@@ -2965,6 +2961,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_PACKED (gnu_type) = (packed != 0) || has_rep;\n \tif (Reverse_Storage_Order (gnat_entity))\n \t  sorry (\"non-default Scalar_Storage_Order\");\n+\tprocess_attributes (&gnu_type, &attr_list, true, gnat_entity);\n \n \tif (!definition)\n \t  {\n@@ -3355,6 +3352,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_name;\n \t      TYPE_PACKED (gnu_type) = TYPE_PACKED (gnu_base_type);\n+\t      process_attributes (&gnu_type, &attr_list, true, gnat_entity);\n \n \t      /* Set the size, alignment and alias set of the new type to\n \t\t match that of the old one, doing required substitutions.  */\n@@ -3695,7 +3693,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_type\n \t    = build_pointer_type\n \t      (make_dummy_type (Directly_Designated_Type (gnat_entity)));\n-\t  gnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n+\t  gnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n \t\t\t\t       !Comes_From_Source (gnat_entity),\n \t\t\t\t       debug_info_p, gnat_entity);\n \t  this_made_decl = true;\n@@ -3951,7 +3949,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    else\n \t      gnu_old_desig_type = TREE_TYPE (gnu_type);\n \n-\t    gnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n+\t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n+\t    gnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n \t\t\t\t\t !Comes_From_Source (gnat_entity),\n \t\t\t\t\t debug_info_p, gnat_entity);\n \t    this_made_decl = true;\n@@ -4288,8 +4287,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tif (gnu_return_type != orig_type\n \t\t    && !DECL_P (TYPE_NAME (gnu_return_type)))\n \t\t  create_type_decl (TYPE_NAME (gnu_return_type),\n-\t\t\t\t    gnu_return_type, NULL, true,\n-\t\t\t\t    debug_info_p, gnat_entity);\n+\t\t\t\t    gnu_return_type, true, debug_info_p,\n+\t\t\t\t    gnat_entity);\n \n \t\treturn_by_invisi_ref_p = true;\n \t      }\n@@ -4670,9 +4669,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \telse if (kind == E_Subprogram_Type)\n-\t  gnu_decl\n-\t    = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n-\t\t\t\tartificial_flag, debug_info_p, gnat_entity);\n+\t  {\n+\t    process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n+\t    gnu_decl\n+\t      = create_type_decl (gnu_entity_name, gnu_type, artificial_flag,\n+\t\t\t\t  debug_info_p, gnat_entity);\n+\t  }\n \telse\n \t  {\n \t    if (has_stub)\n@@ -4824,6 +4826,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n      handling alignment and possible padding.  */\n   if (is_type && (!gnu_decl || this_made_decl))\n     {\n+      /* Process the attributes, if not already done.  Note that the type is\n+\t already defined so we cannot pass True for IN_PLACE here.  */\n+      process_attributes (&gnu_type, &attr_list, false, gnat_entity);\n+\n       /* Tell the middle-end that objects of tagged types are guaranteed to\n \t be properly aligned.  This is necessary because conversions to the\n \t class-wide type are translated into conversions to the root type,\n@@ -5068,7 +5074,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tTYPE_UNIVERSAL_ALIASING_P (TYPE_MAIN_VARIANT (gnu_type)) = 1;\n \n       if (!gnu_decl)\n-\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type, attr_list,\n+\tgnu_decl = create_type_decl (gnu_entity_name, gnu_type,\n \t\t\t\t     !Comes_From_Source (gnat_entity),\n \t\t\t\t     debug_info_p, gnat_entity);\n       else\n@@ -5608,8 +5614,8 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \t declared otherwise.  This is necessary to ensure that its subtrees\n \t are properly marked.  */\n       if (gnu_type != orig_type && !DECL_P (TYPE_NAME (gnu_type)))\n-\tcreate_type_decl (TYPE_NAME (gnu_type), gnu_type, NULL, true,\n-\t\t\t  debug_info_p, gnat_array);\n+\tcreate_type_decl (TYPE_NAME (gnu_type), gnu_type, true, debug_info_p,\n+\t\t\t  gnat_array);\n     }\n \n   if (Has_Volatile_Components (gnat_array))\n@@ -6691,8 +6697,8 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t are properly marked.  */\n       if (gnu_field_type != orig_field_type\n \t  && !DECL_P (TYPE_NAME (gnu_field_type)))\n-\tcreate_type_decl (TYPE_NAME (gnu_field_type), gnu_field_type, NULL,\n-\t\t\t  true, debug_info_p, gnat_field);\n+\tcreate_type_decl (TYPE_NAME (gnu_field_type), gnu_field_type, true,\n+\t\t\t  debug_info_p, gnat_field);\n     }\n \n   /* Otherwise (or if there was an error), don't specify a position.  */\n@@ -7092,7 +7098,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t\t the fields associated with these empty variants.  */\n \t      rest_of_record_type_compilation (gnu_variant_type);\n \t      create_type_decl (TYPE_NAME (gnu_variant_type), gnu_variant_type,\n-\t\t\t\tNULL, true, debug_info, gnat_component_list);\n+\t\t\t\ttrue, debug_info, gnat_component_list);\n \n \t      gnu_field\n \t\t= create_field_decl (gnu_inner_name, gnu_variant_type,\n@@ -7138,8 +7144,8 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t      return;\n \t    }\n \n-\t  create_type_decl (TYPE_NAME (gnu_union_type), gnu_union_type,\n-\t\t\t    NULL, true, debug_info, gnat_component_list);\n+\t  create_type_decl (TYPE_NAME (gnu_union_type), gnu_union_type, true,\n+\t\t\t    debug_info, gnat_component_list);\n \n \t  /* Deal with packedness like in gnat_to_gnu_field.  */\n \t  if (union_field_needs_strict_alignment)\n@@ -8458,8 +8464,8 @@ create_variant_part_from (tree old_variant_part,\n \t info thanks to the XVS type.  */\n       finish_record_type (new_variant, nreverse (field_list), 2, false);\n       compute_record_mode (new_variant);\n-      create_type_decl (TYPE_NAME (new_variant), new_variant, NULL,\n-\t\t\ttrue, false, Empty);\n+      create_type_decl (TYPE_NAME (new_variant), new_variant, true, false,\n+\t\t\tEmpty);\n \n       new_field\n \t= create_field_decl_from (old_field, new_variant, new_union_type,\n@@ -8476,8 +8482,8 @@ create_variant_part_from (tree old_variant_part,\n      because VARIANT_LIST has been traversed in reverse order.  */\n   finish_record_type (new_union_type, union_field_list, 2, false);\n   compute_record_mode (new_union_type);\n-  create_type_decl (TYPE_NAME (new_union_type), new_union_type, NULL,\n-\t\t    true, false, Empty);\n+  create_type_decl (TYPE_NAME (new_union_type), new_union_type, true, false,\n+\t\t    Empty);\n \n   new_variant_part\n     = create_field_decl_from (old_variant_part, new_union_type, record_type,"}, {"sha": "799f61db264278b965912331734f2379b7cc922c", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=74746d494b37773e55d43130ed51bba67a337efe", "patch": "@@ -653,10 +653,8 @@ extern tree create_type_stub_decl (tree type_name, tree type);\n    is a declaration that was generated by the compiler.  DEBUG_INFO_P is\n    true if we need to write debug information about this type.  GNAT_NODE\n    is used for the position of the decl.  */\n-extern tree create_type_decl (tree type_name, tree type,\n-                              struct attrib *attr_list,\n-                              bool artificial_p, bool debug_info_p,\n-\t\t\t      Node_Id gnat_node);\n+extern tree create_type_decl (tree type_name, tree type, bool artificial_p,\n+\t\t\t      bool debug_info_p, Node_Id gnat_node);\n \n /* Return a VAR_DECL or CONST_DECL node.\n \n@@ -729,7 +727,7 @@ extern tree create_param_decl (tree param_name, tree param_type,\n \n /* Return a LABEL_DECL with LABEL_NAME.  GNAT_NODE is used for the position\n    of the decl.  */\n-extern tree create_label_decl (tree, Node_Id);\n+extern tree create_label_decl (tree label_name, Node_Id gnat_node);\n \n /* Return a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n    ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n@@ -746,6 +744,12 @@ extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n \t\t\t\t bool artificial_flag,\n \t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n+/* Process the attributes in ATTR_LIST for NODE, which is either a DECL or\n+   a TYPE.  If IN_PLACE is true, the tree pointed to by NODE should not be\n+   changed.  GNAT_NODE is used for the position of error messages.  */\n+extern void process_attributes (tree *node, struct attrib **attr_list,\n+\t\t\t\tbool in_place, Node_Id gnat_node);\n+\n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n    body. This routine needs to be invoked before processing the declarations\n    appearing in the subprogram.  */"}, {"sha": "857905e2c1b8ddade79d10d74080cce6d6d04a30", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 48, "deletions": 53, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=74746d494b37773e55d43130ed51bba67a337efe", "patch": "@@ -233,7 +233,6 @@ static tree split_plus (tree, tree *);\n static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static bool potential_alignment_gap (tree, tree, tree);\n-static void process_attributes (tree, struct attrib *);\n \f\n /* Initialize data structures of the utils.c module.  */\n \n@@ -740,7 +739,7 @@ make_aligning_type (tree type, unsigned int align, tree size,\n \n   /* Declare it now since it will never be declared otherwise.  This is\n      necessary to ensure that its subtrees are properly marked.  */\n-  create_type_decl (name, record_type, NULL, true, false, gnat_node);\n+  create_type_decl (name, record_type, true, false, gnat_node);\n \n   return record_type;\n }\n@@ -1075,7 +1074,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n   /* If requested, complete the original type and give it a name.  */\n   if (is_user_type)\n     create_type_decl (get_entity_name (gnat_entity), type,\n-\t\t      NULL, !Comes_From_Source (gnat_entity),\n+\t\t      !Comes_From_Source (gnat_entity),\n \t\t      !(TYPE_NAME (type)\n \t\t\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t\t\t&& DECL_IGNORED_P (TYPE_NAME (type))),\n@@ -2025,7 +2024,7 @@ create_index_type (tree min, tree max, tree index, Node_Id gnat_node)\n \n   /* Then set the index type.  */\n   SET_TYPE_INDEX_TYPE (type, index);\n-  create_type_decl (NULL_TREE, type, NULL, true, false, gnat_node);\n+  create_type_decl (NULL_TREE, type, true, false, gnat_node);\n \n   return type;\n }\n@@ -2076,8 +2075,8 @@ create_type_stub_decl (tree type_name, tree type)\n    is used for the position of the decl.  */\n \n tree\n-create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n-\t\t  bool artificial_p, bool debug_info_p, Node_Id gnat_node)\n+create_type_decl (tree type_name, tree type, bool artificial_p,\n+\t\t  bool debug_info_p, Node_Id gnat_node)\n {\n   enum tree_code code = TREE_CODE (type);\n   bool named = TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL;\n@@ -2094,17 +2093,14 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n       DECL_NAME (type_decl) = type_name;\n     }\n   else\n-    type_decl = build_decl (input_location,\n-\t\t\t    TYPE_DECL, type_name, type);\n+    type_decl = build_decl (input_location, TYPE_DECL, type_name, type);\n \n   DECL_ARTIFICIAL (type_decl) = artificial_p;\n   TYPE_ARTIFICIAL (type) = artificial_p;\n \n   /* Add this decl to the current binding level.  */\n   gnat_pushdecl (type_decl, gnat_node);\n \n-  process_attributes (type_decl, attr_list);\n-\n   /* If we're naming the type, equate the TYPE_STUB_DECL to the name.\n      This causes the name to be also viewed as a \"tag\" by the debug\n      back-end, with the advantage that no DW_TAG_typedef is emitted\n@@ -2225,17 +2221,21 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n \t   != null_pointer_node)\n     DECL_IGNORED_P (var_decl) = 1;\n \n-  /* Add this decl to the current binding level.  */\n-  gnat_pushdecl (var_decl, gnat_node);\n-\n   if (TREE_SIDE_EFFECTS (var_decl))\n     TREE_ADDRESSABLE (var_decl) = 1;\n \n+  /* ??? Some attributes cannot be applied to CONST_DECLs.  */\n+  if (TREE_CODE (var_decl) == VAR_DECL)\n+    process_attributes (&var_decl, &attr_list, true, gnat_node);\n+\n+  /* Add this decl to the current binding level.  */\n+  gnat_pushdecl (var_decl, gnat_node);\n+\n   if (TREE_CODE (var_decl) == VAR_DECL)\n     {\n       if (asm_name)\n \tSET_DECL_ASSEMBLER_NAME (var_decl, asm_name);\n-      process_attributes (var_decl, attr_list);\n+\n       if (global_bindings_p ())\n \trest_of_decl_compilation (var_decl, true, 0);\n     }\n@@ -2451,65 +2451,71 @@ create_param_decl (tree param_name, tree param_type, bool readonly)\n   return param_decl;\n }\n \f\n-/* Given a DECL and ATTR_LIST, process the listed attributes.  */\n+/* Process the attributes in ATTR_LIST for NODE, which is either a DECL or\n+   a TYPE.  If IN_PLACE is true, the tree pointed to by NODE should not be\n+   changed.  GNAT_NODE is used for the position of error messages.  */\n \n-static void\n-process_attributes (tree decl, struct attrib *attr_list)\n+void\n+process_attributes (tree *node, struct attrib **attr_list, bool in_place,\n+\t\t    Node_Id gnat_node)\n {\n-  for (; attr_list; attr_list = attr_list->next)\n-    switch (attr_list->type)\n+  struct attrib *attr;\n+\n+  for (attr = *attr_list; attr; attr = attr->next)\n+    switch (attr->type)\n       {\n       case ATTR_MACHINE_ATTRIBUTE:\n-\tinput_location = DECL_SOURCE_LOCATION (decl);\n-\tdecl_attributes (&decl, tree_cons (attr_list->name, attr_list->args,\n-\t\t\t\t\t   NULL_TREE),\n-\t\t\t ATTR_FLAG_TYPE_IN_PLACE);\n+\tSloc_to_locus (Sloc (gnat_node), &input_location);\n+\tdecl_attributes (node, tree_cons (attr->name, attr->args, NULL_TREE),\n+\t\t\t in_place ? ATTR_FLAG_TYPE_IN_PLACE : 0);\n \tbreak;\n \n       case ATTR_LINK_ALIAS:\n-        if (! DECL_EXTERNAL (decl))\n+        if (!DECL_EXTERNAL (*node))\n \t  {\n-\t    TREE_STATIC (decl) = 1;\n-\t    assemble_alias (decl, attr_list->name);\n+\t    TREE_STATIC (*node) = 1;\n+\t    assemble_alias (*node, attr->name);\n \t  }\n \tbreak;\n \n       case ATTR_WEAK_EXTERNAL:\n \tif (SUPPORTS_WEAK)\n-\t  declare_weak (decl);\n+\t  declare_weak (*node);\n \telse\n \t  post_error (\"?weak declarations not supported on this target\",\n-\t\t      attr_list->error_point);\n+\t\t      attr->error_point);\n \tbreak;\n \n       case ATTR_LINK_SECTION:\n \tif (targetm_common.have_named_sections)\n \t  {\n-\t    DECL_SECTION_NAME (decl)\n-\t      = build_string (IDENTIFIER_LENGTH (attr_list->name),\n-\t\t\t      IDENTIFIER_POINTER (attr_list->name));\n-\t    DECL_COMMON (decl) = 0;\n+\t    DECL_SECTION_NAME (*node)\n+\t      = build_string (IDENTIFIER_LENGTH (attr->name),\n+\t\t\t      IDENTIFIER_POINTER (attr->name));\n+\t    DECL_COMMON (*node) = 0;\n \t  }\n \telse\n \t  post_error (\"?section attributes are not supported for this target\",\n-\t\t      attr_list->error_point);\n+\t\t      attr->error_point);\n \tbreak;\n \n       case ATTR_LINK_CONSTRUCTOR:\n-\tDECL_STATIC_CONSTRUCTOR (decl) = 1;\n-\tTREE_USED (decl) = 1;\n+\tDECL_STATIC_CONSTRUCTOR (*node) = 1;\n+\tTREE_USED (*node) = 1;\n \tbreak;\n \n       case ATTR_LINK_DESTRUCTOR:\n-\tDECL_STATIC_DESTRUCTOR (decl) = 1;\n-\tTREE_USED (decl) = 1;\n+\tDECL_STATIC_DESTRUCTOR (*node) = 1;\n+\tTREE_USED (*node) = 1;\n \tbreak;\n \n       case ATTR_THREAD_LOCAL_STORAGE:\n-\tDECL_TLS_MODEL (decl) = decl_default_tls_model (decl);\n-\tDECL_COMMON (decl) = 0;\n+\tDECL_TLS_MODEL (*node) = decl_default_tls_model (*node);\n+\tDECL_COMMON (*node) = 0;\n \tbreak;\n       }\n+\n+  *attr_list = NULL;\n }\n \f\n /* Record DECL as a global renaming pointer.  */\n@@ -2695,11 +2701,11 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n \tDECL_NAME (subprog_decl) = main_identifier_node;\n     }\n \n+  process_attributes (&subprog_decl, &attr_list, true, gnat_node);\n+\n   /* Add this decl to the current binding level.  */\n   gnat_pushdecl (subprog_decl, gnat_node);\n \n-  process_attributes (subprog_decl, attr_list);\n-\n   /* Output the assembler code and/or RTL for the declaration.  */\n   rest_of_decl_compilation (subprog_decl, global_bindings_p (), 0);\n \n@@ -4170,7 +4176,7 @@ build_unc_object_type (tree template_type, tree object_type, tree name,\n \n   /* Declare it now since it will never be declared otherwise.  This is\n      necessary to ensure that its subtrees are properly marked.  */\n-  create_type_decl (name, type, NULL, true, debug_info_p, Empty);\n+  create_type_decl (name, type, true, debug_info_p, Empty);\n \n   return type;\n }\n@@ -6358,7 +6364,6 @@ handle_vector_type_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* Vector representative type and size.  */\n   tree rep_type = *node;\n   tree rep_size = TYPE_SIZE_UNIT (rep_type);\n-  tree rep_name;\n \n   /* Vector size in bytes and number of units.  */\n   unsigned HOST_WIDE_INT vec_bytes, vec_units;\n@@ -6369,12 +6374,6 @@ handle_vector_type_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n \n   *no_add_attrs = true;\n \n-  /* Get the representative array type, possibly nested within a\n-     padding record e.g. for alignment purposes.  */\n-\n-  if (TYPE_IS_PADDING_P (rep_type))\n-    rep_type = TREE_TYPE (TYPE_FIELDS (rep_type));\n-\n   if (TREE_CODE (rep_type) != ARRAY_TYPE)\n     {\n       error (\"attribute %qs applies to array types only\",\n@@ -6435,10 +6434,6 @@ handle_vector_type_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   /* Build the vector type and replace.  */\n \n   *node = build_vector_type (elem_type, vec_units);\n-  rep_name = TYPE_NAME (rep_type);\n-  if (TREE_CODE (rep_name) == TYPE_DECL)\n-    rep_name = DECL_NAME (rep_name);\n-  TYPE_NAME (*node) = rep_name;\n   TYPE_REPRESENTATIVE_ARRAY (*node) = rep_type;\n \n   return NULL_TREE;"}, {"sha": "b6bb1b7ed3aeca40256b7b75c9130fb5a9a92e11", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=74746d494b37773e55d43130ed51bba67a337efe", "patch": "@@ -1,3 +1,7 @@\n+2013-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/machine_attribute.ads: New test.\n+\n 2013-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/incomplete3.ad[sb]: New test."}, {"sha": "b38ed643a2210f0ea58f07d76bce947ba8e889ea", "filename": "gcc/testsuite/gnat.dg/specs/machine_attribute.ads", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fmachine_attribute.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74746d494b37773e55d43130ed51bba67a337efe/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fmachine_attribute.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Fmachine_attribute.ads?ref=74746d494b37773e55d43130ed51bba67a337efe", "patch": "@@ -0,0 +1,8 @@\n+-- { dg-do compile }\n+\n+package Machine_Attribute is\n+\n+  type R is null record;\n+  pragma Machine_Attribute (R, \"may_alias\");\n+\n+end Machine_Attribute;"}]}