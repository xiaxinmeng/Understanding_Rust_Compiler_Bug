{"sha": "ae51bd971e8d262b62459d992d7086e42642f168", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU1MWJkOTcxZThkMjYyYjYyNDU5ZDk5MmQ3MDg2ZTQyNjQyZjE2OA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-10-01T19:17:02Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-10-01T19:17:02Z"}, "message": "(SECONDARY_INPUT_RELOAD_CLASS): Also need a temp reg when loading HImode and QImode values from memory to FP_REGS.\n\n(SECONDARY_INPUT_RELOAD_CLASS): Also need a temp reg\nwhen loading HImode and QImode values from memory to FP_REGS.\n(SECONDARY_OUTPUT_RELOAD_CLASS): New macro.  Define this to handle\nHImode and QImode stores from FP_REGS to memory similar to above.\n\nFrom-SVN: r2301", "tree": {"sha": "2e2e8ecc5f4343c59b1030560a2504e3f1ba2199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e2e8ecc5f4343c59b1030560a2504e3f1ba2199"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae51bd971e8d262b62459d992d7086e42642f168", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae51bd971e8d262b62459d992d7086e42642f168", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae51bd971e8d262b62459d992d7086e42642f168", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae51bd971e8d262b62459d992d7086e42642f168/comments", "author": null, "committer": null, "parents": [{"sha": "b9a24ad42e0779007c31c349cf2a5b9a9f905f98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a24ad42e0779007c31c349cf2a5b9a9f905f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a24ad42e0779007c31c349cf2a5b9a9f905f98"}], "stats": {"total": 25, "additions": 19, "deletions": 6}, "files": [{"sha": "169cd678eb70821a60a4554fe51d140267bfb825", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae51bd971e8d262b62459d992d7086e42642f168/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae51bd971e8d262b62459d992d7086e42642f168/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=ae51bd971e8d262b62459d992d7086e42642f168", "patch": "@@ -564,17 +564,30 @@ extern char leaf_reg_backmap[];\n    a register of class CLASS in MODE.\n \n    On the SPARC, when PIC, we need a temporary when loading some addresses\n-   into a register.  */\n+   into a register.\n \n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN) \\\n-  (flag_pic && pic_address_needs_scratch (IN) ? GENERAL_REGS : NO_REGS)\n+   Also, we need a temporary when loading/storing a HImode/QImode value\n+   between memory and the FPU registers.  This can happen when combine puts\n+   a paradoxical subreg in a float/fix conversion insn.  */\n+\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n+  (flag_pic && pic_address_needs_scratch (IN) ? GENERAL_REGS\t\\\n+   : ((CLASS) == FP_REGS && ((MODE) == HImode || (MODE) == QImode)\\\n+      && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n+\t  || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n+\t      && true_regnum (IN) == -1))) ? GENERAL_REGS : NO_REGS)\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n+  ((CLASS) == FP_REGS && ((MODE) == HImode || (MODE) == QImode)\t\\\n+   && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n+       || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n+\t   && true_regnum (IN) == -1)) ? GENERAL_REGS : NO_REGS)\n \n /* On SPARC it is not possible to directly move data between \n    GENERAL_REGS and FP_REGS.  */\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE)  \\\n-  ((CLASS1 == FP_REGS && CLASS2 == GENERAL_REGS)\t\\\n-   || (CLASS1 == GENERAL_REGS && CLASS2 == FP_REGS))\n-\t\n+  (((CLASS1) == FP_REGS && (CLASS2) == GENERAL_REGS)\t\\\n+   || ((CLASS1) == GENERAL_REGS && (CLASS2) == FP_REGS))\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */"}]}