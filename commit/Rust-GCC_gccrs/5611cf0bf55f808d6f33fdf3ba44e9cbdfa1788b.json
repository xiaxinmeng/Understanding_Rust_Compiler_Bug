{"sha": "5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxMWNmMGJmNTVmODA4ZDZmMzNmZGYzYmE0NGU5Y2JkZmExNzg4Yg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-05-08T09:27:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-05-08T09:27:29Z"}, "message": "tree-data-ref.c (dr_analyze_alias): Do not set DR_SUBVARS.\n\n2008-05-08  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-data-ref.c (dr_analyze_alias): Do not set DR_SUBVARS.\n\t* tree-data-ref.h (struct dr_alias): Remove subvars field.\n\t(DR_SUBVARS): Remove.\n\t* tree-dfa.c (dump_subvars_for): Remove.\n\t(debug_subvars_for): Likewise.\n\t(dump_variable): Do not dump subvars.\n\t(remove_referenced_var): Do not remove subvars.\n\t* tree-flow-inline.h (clear_call_clobbered): SFTs no longer exist.\n\t(lookup_subvars_for_var): Remove.\n\t(get_subvars_for_var): Likewise.\n\t(get_subvars_at): Likewise.\n\t(get_first_overlapping_subvar): Likewise.\n\t(overlap_subvar): Likewise.\n\t* tree-flow.h (subvar_t): Remove.\n\t(struct var_ann_d): Remove subvars field.\n\t* tree-ssa-alias.c (mark_aliases_call_clobbered): Remove queued\n\targument.  Remove special handling of SFTs.\n\t(compute_tag_properties): Likewise.\n\t(set_initial_properties): Likewise.\n\t(compute_call_clobbered): Likewise.\n\t(count_mem_refs): Likewise.\n\t(compute_memory_partitions): Likewise.\n\t(compute_flow_insensitive_aliasing): Likewise.\n\t(setup_pointers_and_addressables): Likewise.\n\t(new_type_alias): Likewise.\n\t(struct used_part): Remove.\n\t(used_portions): Likewise.\n\t(struct used_part_map): Likewise.\n\t(used_part_map_eq): Likewise.\n\t(used_part_map_hash): Likewise.\n\t(free_used_part_map): Likewise.\n\t(up_lookup): Likewise.\n\t(up_insert): Likewise.\n\t(get_or_create_used_part_for): Likewise.\n\t(create_sft): Likewise.\n\t(create_overlap_variables_for): Likewise.\n\t(find_used_portions): Likewise.\n\t(create_structure_vars): Likewise.\n\t* tree.def (STRUCT_FIELD_TAG): Remove.\n\t* tree.h (MTAG_P): Adjust.\n\t(struct tree_memory_tag): Remove base_for_components and\n\tunpartitionable flags.\n\t(struct tree_struct_field_tag): Remove.\n\t(SFT_PARENT_VAR): Likewise.\n\t(SFT_OFFSET): Likewise.\n\t(SFT_SIZE): Likewise.\n\t(SFT_NONADDRESSABLE_P): Likewise.\n\t(SFT_ALIAS_SET): Likewise.\n\t(SFT_UNPARTITIONABLE_P): Likewise.\n\t(SFT_BASE_FOR_COMPONENTS_P): Likewise.\n\t(union tree_node): Remove sft field.\n\t* alias.c (get_alias_set): Remove special handling of SFTs.\n\t* print-tree.c (print_node): Remove handling of SFTs.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* tree-into-ssa.c (mark_sym_for_renaming): Likewise.\n\t* tree-nrv.c (dest_safe_for_nrv_p): Remove special handling of SFTs.\n\t* tree-predcom.c (set_alias_info): Do not set subvars.\n\t* tree-pretty-print.c (dump_generic_node): Do not handle SFTs.\n\t* tree-ssa-loop-ivopts.c (get_ref_tag): Likewise.\n\t* tree-ssa-operands.c (access_can_touch_variable): Likewise.\n\t(add_vars_for_offset): Remove.\n\t(add_virtual_operand): Remove special handling of SFTs.\n\t(add_call_clobber_ops): Likewise.\n\t(add_call_read_ops): Likewise.\n\t(get_asm_expr_operands): Likewise.\n\t(get_modify_stmt_operands): Likewise.\n\t(get_expr_operands): Likewise.\n\t(add_to_addressable_set): Likewise.\n\t* tree-ssa.c (verify_ssa_name): Do not handle SFTs.\n\t* tree-tailcall.c (suitable_for_tail_opt_p): Likewise.\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Do not\n\tset subvars.\n\t* tree.c (init_ttree): Remove STRUCT_FIELD_TAG initialization.\n\t(tree_code_size): Remove STRUCT_FIELD_TAG handling.\n\t(tree_node_structure): Likewise.\n\t* tree-ssa-structalias.c (set_uids_in_ptset): Remove special\n\thandling of SFTs.\n\t(find_what_p_points_to): Likewise.\n\nFrom-SVN: r135077", "tree": {"sha": "e452b11cd2f2f07a867f70870559e7b21b003d58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e452b11cd2f2f07a867f70870559e7b21b003d58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e17a4cf37a367bd76e0b7c016a9d090cfef422d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e17a4cf37a367bd76e0b7c016a9d090cfef422d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e17a4cf37a367bd76e0b7c016a9d090cfef422d"}], "stats": {"total": 1474, "additions": 137, "deletions": 1337}, "files": [{"sha": "33d15a6db7b2e190a8a2c4b55e60164dc0e35d96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -1,3 +1,84 @@\n+2008-05-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-data-ref.c (dr_analyze_alias): Do not set DR_SUBVARS.\n+\t* tree-data-ref.h (struct dr_alias): Remove subvars field.\n+\t(DR_SUBVARS): Remove.\n+\t* tree-dfa.c (dump_subvars_for): Remove.\n+\t(debug_subvars_for): Likewise.\n+\t(dump_variable): Do not dump subvars.\n+\t(remove_referenced_var): Do not remove subvars.\n+\t* tree-flow-inline.h (clear_call_clobbered): SFTs no longer exist.\n+\t(lookup_subvars_for_var): Remove.\n+\t(get_subvars_for_var): Likewise.\n+\t(get_subvars_at): Likewise.\n+\t(get_first_overlapping_subvar): Likewise.\n+\t(overlap_subvar): Likewise.\n+\t* tree-flow.h (subvar_t): Remove.\n+\t(struct var_ann_d): Remove subvars field.\n+\t* tree-ssa-alias.c (mark_aliases_call_clobbered): Remove queued\n+\targument.  Remove special handling of SFTs.\n+\t(compute_tag_properties): Likewise.\n+\t(set_initial_properties): Likewise.\n+\t(compute_call_clobbered): Likewise.\n+\t(count_mem_refs): Likewise.\n+\t(compute_memory_partitions): Likewise.\n+\t(compute_flow_insensitive_aliasing): Likewise.\n+\t(setup_pointers_and_addressables): Likewise.\n+\t(new_type_alias): Likewise.\n+\t(struct used_part): Remove.\n+\t(used_portions): Likewise.\n+\t(struct used_part_map): Likewise.\n+\t(used_part_map_eq): Likewise.\n+\t(used_part_map_hash): Likewise.\n+\t(free_used_part_map): Likewise.\n+\t(up_lookup): Likewise.\n+\t(up_insert): Likewise.\n+\t(get_or_create_used_part_for): Likewise.\n+\t(create_sft): Likewise.\n+\t(create_overlap_variables_for): Likewise.\n+\t(find_used_portions): Likewise.\n+\t(create_structure_vars): Likewise.\n+\t* tree.def (STRUCT_FIELD_TAG): Remove.\n+\t* tree.h (MTAG_P): Adjust.\n+\t(struct tree_memory_tag): Remove base_for_components and\n+\tunpartitionable flags.\n+\t(struct tree_struct_field_tag): Remove.\n+\t(SFT_PARENT_VAR): Likewise.\n+\t(SFT_OFFSET): Likewise.\n+\t(SFT_SIZE): Likewise.\n+\t(SFT_NONADDRESSABLE_P): Likewise.\n+\t(SFT_ALIAS_SET): Likewise.\n+\t(SFT_UNPARTITIONABLE_P): Likewise.\n+\t(SFT_BASE_FOR_COMPONENTS_P): Likewise.\n+\t(union tree_node): Remove sft field.\n+\t* alias.c (get_alias_set): Remove special handling of SFTs.\n+\t* print-tree.c (print_node): Remove handling of SFTs.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-into-ssa.c (mark_sym_for_renaming): Likewise.\n+\t* tree-nrv.c (dest_safe_for_nrv_p): Remove special handling of SFTs.\n+\t* tree-predcom.c (set_alias_info): Do not set subvars.\n+\t* tree-pretty-print.c (dump_generic_node): Do not handle SFTs.\n+\t* tree-ssa-loop-ivopts.c (get_ref_tag): Likewise.\n+\t* tree-ssa-operands.c (access_can_touch_variable): Likewise.\n+\t(add_vars_for_offset): Remove.\n+\t(add_virtual_operand): Remove special handling of SFTs.\n+\t(add_call_clobber_ops): Likewise.\n+\t(add_call_read_ops): Likewise.\n+\t(get_asm_expr_operands): Likewise.\n+\t(get_modify_stmt_operands): Likewise.\n+\t(get_expr_operands): Likewise.\n+\t(add_to_addressable_set): Likewise.\n+\t* tree-ssa.c (verify_ssa_name): Do not handle SFTs.\n+\t* tree-tailcall.c (suitable_for_tail_opt_p): Likewise.\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Do not\n+\tset subvars.\n+\t* tree.c (init_ttree): Remove STRUCT_FIELD_TAG initialization.\n+\t(tree_code_size): Remove STRUCT_FIELD_TAG handling.\n+\t(tree_node_structure): Likewise.\n+\t* tree-ssa-structalias.c (set_uids_in_ptset): Remove special\n+\thandling of SFTs.\n+\t(find_what_p_points_to): Likewise.\n+\n 2008-05-08  Sa Liu  <saliu@de.ibm.com>\n \n \t* config/spu/spu.md: Fixed subti3 pattern."}, {"sha": "06ad867d30352c5cc4e8c60e858283cba8da6347", "filename": "gcc/alias.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -584,13 +584,6 @@ get_alias_set (tree t)\n \t    return 0;\n \t}\n \n-      /* For non-addressable fields we return the alias set of the\n-\t outermost object that could have its address taken.  If this\n-\t is an SFT use the precomputed value.  */\n-      if (TREE_CODE (t) == STRUCT_FIELD_TAG\n-\t  && SFT_NONADDRESSABLE_P (t))\n-\treturn SFT_ALIAS_SET (t);\n-\n       /* Otherwise, pick up the outermost object that we could have a pointer\n \t to, processing conversions as above.  */\n       while (component_uses_parent_alias_set (t))"}, {"sha": "4745491de563114379740106ae3ecfc84fa33df9", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -534,15 +534,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  && DECL_HAS_VALUE_EXPR_P (node))\n \tprint_node (file, \"value-expr\", DECL_VALUE_EXPR (node), indent + 4);\n \n-      if (TREE_CODE (node) == STRUCT_FIELD_TAG)\n-\t{\n-\t  fprintf (file, \" sft size \" HOST_WIDE_INT_PRINT_DEC, \n-\t\t   SFT_SIZE (node));\n-\t  fprintf (file, \" sft offset \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t   SFT_OFFSET (node));\n-\t  print_node_brief (file, \"parent var\", SFT_PARENT_VAR (node), \n-\t\t\t    indent + 4);\n-\t}\n       /* Print the decl chain only if decl is at second level.  */\n       if (indent == 4)\n \tprint_node (file, \"chain\", TREE_CHAIN (node), indent + 4);"}, {"sha": "7bca5ed55c072cddba95e8f5b171911308375b44", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -793,8 +793,6 @@ dr_analyze_alias (struct data_reference *dr)\n     }\n \n   DR_SYMBOL_TAG (dr) = smt;\n-  if (smt && var_can_have_subvars (smt))\n-    DR_SUBVARS (dr) = get_subvars_for_var (smt);\n \n   vops = BITMAP_ALLOC (NULL);\n   FOR_EACH_SSA_TREE_OPERAND (op, stmt, it, SSA_OP_VIRTUAL_USES)"}, {"sha": "8db6f7383e817d9ed8ec468de2d047062510dd88", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -88,7 +88,6 @@ struct dr_alias\n   /* The alias information that should be used for new pointers to this\n      location.  SYMBOL_TAG is either a DECL or a SYMBOL_MEMORY_TAG.  */\n   tree symbol_tag;\n-  subvar_t subvars;\n   struct ptr_info_def *ptr_info;\n \n   /* The set of virtual operands corresponding to this memory reference,\n@@ -138,7 +137,6 @@ DEF_VEC_ALLOC_P (data_reference_p, heap);\n #define DR_STEP(DR)                (DR)->innermost.step\n #define DR_SYMBOL_TAG(DR)          (DR)->alias.symbol_tag\n #define DR_PTR_INFO(DR)            (DR)->alias.ptr_info\n-#define DR_SUBVARS(DR)             (DR)->alias.subvars\n #define DR_VOPS(DR)\t\t   (DR)->alias.vops\n #define DR_ALIGNED_TO(DR)          (DR)->innermost.aligned_to\n "}, {"sha": "622930ff5d3d81bf527b0351878be30f687fa5e6", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -272,42 +272,6 @@ debug_referenced_vars (void)\n }\n \n \n-/* Dump sub-variables for VAR to FILE.  */\n-\n-void\n-dump_subvars_for (FILE *file, tree var)\n-{\n-  subvar_t sv = get_subvars_for_var (var);\n-  tree subvar;\n-  unsigned int i;\n-\n-  if (!sv)\n-    return;\n-\n-  fprintf (file, \"{ \");\n-\n-  for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n-    {\n-      print_generic_expr (file, subvar, dump_flags);\n-      fprintf (file, \"@\" HOST_WIDE_INT_PRINT_UNSIGNED, SFT_OFFSET (subvar));\n-      if (SFT_BASE_FOR_COMPONENTS_P (subvar))\n-        fprintf (file, \"[B]\");\n-      fprintf (file, \" \");\n-    }\n-\n-  fprintf (file, \"}\");\n-}\n-\n-\n-/* Dumb sub-variables for VAR to stderr.  */\n-\n-void\n-debug_subvars_for (tree var)\n-{\n-  dump_subvars_for (stderr, var);\n-}\n-\n-\n /* Dump variable VAR and its may-aliases to FILE.  */\n \n void\n@@ -403,12 +367,6 @@ dump_variable (FILE *file, tree var)\n       dump_may_aliases_for (file, var);\n     }\n \n-  if (get_subvars_for_var (var))\n-    {\n-      fprintf (file, \", sub-vars: \");\n-      dump_subvars_for (file, var);\n-    }\n-\n   if (!is_gimple_reg (var))\n     {\n       if (memory_partition (var))\n@@ -422,16 +380,6 @@ dump_variable (FILE *file, tree var)\n \t  fprintf (file, \", partition symbols: \");\n \t  dump_decl_set (file, MPT_SYMBOLS (var));\n \t}\n-\n-      if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n-\t{\n-\t  fprintf (file, \", offset: \" HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t   SFT_OFFSET (var));\n-\t  fprintf (file, \", base for components: %s\",\n-\t\t   SFT_BASE_FOR_COMPONENTS_P (var) ? \"NO\" : \"YES\");\n-\t  fprintf (file, \", partitionable: %s\",\n-\t\t   SFT_UNPARTITIONABLE_P (var) ? \"NO\" : \"YES\");\n-\t}\n     }\n \n   fprintf (file, \"\\n\");\n@@ -766,18 +714,6 @@ remove_referenced_var (tree var)\n   struct tree_decl_minimal in;\n   void **loc;\n   unsigned int uid = DECL_UID (var);\n-  subvar_t sv;\n-\n-  /* If we remove a var, we should also remove its subvars, as we kill\n-     their parent var and its annotation.  */\n-  if (var_can_have_subvars (var)\n-      && (sv = get_subvars_for_var (var)))\n-    {\n-      unsigned int i;\n-      tree subvar;\n-      for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n-        remove_referenced_var (subvar);\n-    }\n \n   clear_call_clobbered (var);\n   if ((v_ann = var_ann (var)))"}, {"sha": "29bcbb416f23bfa616af90a845e5ee0a5e5bb5c0", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -513,7 +513,6 @@ dequeue_and_dump (dump_info_p di)\n       \n     case SYMBOL_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n-    case STRUCT_FIELD_TAG:\n       break;\n \n     case VAR_DECL:"}, {"sha": "7b82ba34090e1086f9c611a6bd91860fdb55cb93", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 163, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -883,7 +883,7 @@ clear_call_clobbered (tree var)\n {\n   var_ann_t ann = var_ann (var);\n   ann->escape_mask = 0;\n-  if (MTAG_P (var) && TREE_CODE (var) != STRUCT_FIELD_TAG)\n+  if (MTAG_P (var))\n     MTAG_GLOBAL (var) = 0;\n   if (!MTAG_P (var))\n     var_ann (var)->call_clobbered = false;\n@@ -1581,121 +1581,6 @@ ref_contains_array_ref (const_tree ref)\n   return false;\n }\n \n-/* Given a variable VAR, lookup and return a pointer to the list of\n-   subvariables for it.  */\n-\n-static inline subvar_t *\n-lookup_subvars_for_var (const_tree var)\n-{\n-  var_ann_t ann = var_ann (var);\n-  gcc_assert (ann);\n-  return &ann->subvars;\n-}\n-\n-/* Given a variable VAR, return a linked list of subvariables for VAR, or\n-   NULL, if there are no subvariables.  */\n-\n-static inline subvar_t\n-get_subvars_for_var (tree var)\n-{\n-  subvar_t subvars;\n-\n-  gcc_assert (SSA_VAR_P (var));  \n-  \n-  if (TREE_CODE (var) == SSA_NAME)\n-    subvars = *(lookup_subvars_for_var (SSA_NAME_VAR (var)));\n-  else\n-    subvars = *(lookup_subvars_for_var (var));\n-  return subvars;\n-}\n-\n-/* Return the subvariable of VAR at offset OFFSET.  */\n-\n-static inline tree\n-get_subvar_at (tree var, unsigned HOST_WIDE_INT offset)\n-{\n-  subvar_t sv = get_subvars_for_var (var);\n-  int low, high;\n-\n-  low = 0;\n-  high = VEC_length (tree, sv) - 1;\n-  while (low <= high)\n-    {\n-      int mid = (low + high) / 2;\n-      tree subvar = VEC_index (tree, sv, mid);\n-      if (SFT_OFFSET (subvar) == offset)\n-\treturn subvar;\n-      else if (SFT_OFFSET (subvar) < offset)\n-\tlow = mid + 1;\n-      else\n-\thigh = mid - 1;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* Return the first subvariable in SV that overlaps [offset, offset + size[.\n-   NULL_TREE is returned, if there is no overlapping subvariable, else *I\n-   is set to the index in the SV vector of the first overlap.  */\n-\n-static inline tree\n-get_first_overlapping_subvar (subvar_t sv, unsigned HOST_WIDE_INT offset,\n-\t\t\t      unsigned HOST_WIDE_INT size, unsigned int *i)\n-{\n-  int low = 0;\n-  int high = VEC_length (tree, sv) - 1;\n-  int mid;\n-  tree subvar;\n-\n-  if (low > high)\n-    return NULL_TREE;\n-\n-  /* Binary search for offset.  */\n-  do\n-    {\n-      mid = (low + high) / 2;\n-      subvar = VEC_index (tree, sv, mid);\n-      if (SFT_OFFSET (subvar) == offset)\n-\t{\n-\t  *i = mid;\n-\t  return subvar;\n-\t}\n-      else if (SFT_OFFSET (subvar) < offset)\n-\tlow = mid + 1;\n-      else\n-\thigh = mid - 1;\n-    }\n-  while (low <= high);\n-\n-  /* As we didn't find a subvar with offset, adjust to return the\n-     first overlapping one.  */\n-  if (SFT_OFFSET (subvar) < offset\n-      && SFT_OFFSET (subvar) + SFT_SIZE (subvar) <= offset)\n-    {\n-      mid += 1;\n-      if ((unsigned)mid >= VEC_length (tree, sv))\n-\treturn NULL_TREE;\n-      subvar = VEC_index (tree, sv, mid);\n-    }\n-  else if (SFT_OFFSET (subvar) > offset\n-\t   && size <= SFT_OFFSET (subvar) - offset)\n-    {\n-      mid -= 1;\n-      if (mid < 0)\n-\treturn NULL_TREE;\n-      subvar = VEC_index (tree, sv, mid);\n-    }\n-\n-  if (overlap_subvar (offset, size, subvar, NULL))\n-    {\n-      *i = mid;\n-      return subvar;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n \n /* Return true if V is a tree that we can have subvars for.\n    Normally, this is any aggregate type.  Also complex\n@@ -1748,53 +1633,6 @@ ranges_overlap_p (unsigned HOST_WIDE_INT pos1,\n   return false;\n }\n \n-\n-/* Return true if OFFSET and SIZE define a range that overlaps with some\n-   portion of the range of SV, a subvar.  If there was an exact overlap,\n-   *EXACT will be set to true upon return. */\n-\n-static inline bool\n-overlap_subvar (unsigned HOST_WIDE_INT offset, unsigned HOST_WIDE_INT size,\n-\t\tconst_tree sv,  bool *exact)\n-{\n-  /* There are three possible cases of overlap.\n-     1. We can have an exact overlap, like so:   \n-     |offset, offset + size             |\n-     |sv->offset, sv->offset + sv->size |\n-     \n-     2. We can have offset starting after sv->offset, like so:\n-     \n-           |offset, offset + size              |\n-     |sv->offset, sv->offset + sv->size  |\n-\n-     3. We can have offset starting before sv->offset, like so:\n-     \n-     |offset, offset + size    |\n-       |sv->offset, sv->offset + sv->size|\n-  */\n-\n-  if (exact)\n-    *exact = false;\n-  if (offset == SFT_OFFSET (sv) && size == SFT_SIZE (sv))\n-    {\n-      if (exact)\n-\t*exact = true;\n-      return true;\n-    }\n-  else if (offset >= SFT_OFFSET (sv) \n-\t   && offset < (SFT_OFFSET (sv) + SFT_SIZE (sv)))\n-    {\n-      return true;\n-    }\n-  else if (offset < SFT_OFFSET (sv) \n-\t   && (size > SFT_OFFSET (sv) - offset))\n-    {\n-      return true;\n-    }\n-  return false;\n-\n-}\n-\n /* Return the memory tag associated with symbol SYM.  */\n \n static inline tree"}, {"sha": "fa1522b2aec935e425b5ae13a1ddc288554c7584", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -327,8 +327,6 @@ enum noalias_state {\n };\n \n \n-typedef VEC(tree,gc) *subvar_t;\n-\n struct var_ann_d GTY(())\n {\n   struct tree_ann_common_d common;\n@@ -395,10 +393,6 @@ struct var_ann_d GTY(())\n   /* During into-ssa and the dominator optimizer, this field holds the\n      current version of this variable (an SSA_NAME).  */\n   tree current_def;\n-\n-  /* If this variable is a structure, this fields holds an array\n-     of symbols representing each of the fields of the structure.  */\n-  VEC(tree,gc) *subvars;\n };\n \n /* Container for variable annotation used by hashtable for annotations for\n@@ -814,8 +808,6 @@ extern void debug_referenced_vars (void);\n extern void dump_referenced_vars (FILE *);\n extern void dump_variable (FILE *, tree);\n extern void debug_variable (tree);\n-extern void dump_subvars_for (FILE *, tree);\n-extern void debug_subvars_for (tree);\n extern tree get_virtual_var (tree);\n extern void add_referenced_var (tree);\n extern void remove_referenced_var (tree);\n@@ -858,16 +850,11 @@ extern struct ptr_info_def *get_ptr_info (tree);\n extern void new_type_alias (tree, tree, tree);\n extern void count_uses_and_derefs (tree, tree, unsigned *, unsigned *,\n \t\t\t\t   unsigned *);\n-static inline subvar_t get_subvars_for_var (tree);\n-static inline tree get_subvar_at (tree, unsigned HOST_WIDE_INT);\n static inline bool ref_contains_array_ref (const_tree);\n static inline bool array_ref_contains_indirect_ref (const_tree);\n extern tree get_ref_base_and_extent (tree, HOST_WIDE_INT *,\n \t\t\t\t     HOST_WIDE_INT *, HOST_WIDE_INT *);\n static inline bool var_can_have_subvars (const_tree);\n-static inline bool overlap_subvar (unsigned HOST_WIDE_INT,\n-\t\t\t\t   unsigned HOST_WIDE_INT,\n-\t\t\t\t   const_tree, bool *);\n extern tree create_tag_raw (enum tree_code, tree, const char *);\n extern void delete_mem_ref_stats (struct function *);\n extern void dump_mem_ref_stats (FILE *);"}, {"sha": "5542ede5503f1e2c4b7121a47ba9fe615f983100", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -2790,19 +2790,6 @@ mark_sym_for_renaming (tree sym)\n   if (need_to_initialize_update_ssa_p)\n     init_update_ssa ();\n \n-  /* FIXME.  Why do we need this?  */\n-  {\n-    subvar_t svars;\n-    if (var_can_have_subvars (sym) && (svars = get_subvars_for_var (sym)))\n-      {\n-        unsigned int i;\n-\ttree subvar;\n-\n-\tfor (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t  mark_sym_for_renaming (subvar);\n-      }\n-  }\n-\n   bitmap_set_bit (syms_to_rename, DECL_UID (sym));\n \n   if (!is_gimple_reg (sym))"}, {"sha": "13febcaf79ba5e12f70ac304f9df7484fb5afd99", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -249,17 +249,13 @@ struct gimple_opt_pass pass_nrv =\n    optimization, where DEST is expected to be the LHS of a modify\n    expression where the RHS is a function returning an aggregate.\n \n-   We search for a base VAR_DECL and look to see if it, or any of its\n-   subvars are clobbered.  Note that we could do better, for example, by\n+   We search for a base VAR_DECL and look to see if it is call clobbered.\n+   Note that we could do better, for example, by\n    attempting to doing points-to analysis on INDIRECT_REFs.  */\n \n static bool\n dest_safe_for_nrv_p (tree dest)\n {\n-  subvar_t sv;\n-  unsigned int i;\n-  tree subvar;\n-\n   while (handled_component_p (dest))\n     dest = TREE_OPERAND (dest, 0);\n \n@@ -272,11 +268,6 @@ dest_safe_for_nrv_p (tree dest)\n   if (is_call_clobbered (dest))\n     return false;\n \n-  sv = get_subvars_for_var (dest);\n-  for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n-    if (is_call_clobbered (subvar))\n-      return false;\n-\n   return true;\n }\n "}, {"sha": "a9b048e566229abf9b6b50667d23e8e49976854c", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -2389,8 +2389,6 @@ set_alias_info (tree ref, struct data_reference *dr)\n     new_type_alias (var, tag, ref);\n   else\n     var_ann (var)->symbol_mem_tag = tag;\n-\n-  var_ann (var)->subvars = DR_SUBVARS (dr);\n }\n \n /* Prepare initializers for CHAIN in LOOP.  Returns false if this is"}, {"sha": "aa493a535cab299fa80b0ea7b495319bcc508f95", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -907,7 +907,6 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case SYMBOL_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n-    case STRUCT_FIELD_TAG:\n     case VAR_DECL:\n     case PARM_DECL:\n     case FIELD_DECL:"}, {"sha": "5e3fb47cf432530ec0e4b79617dda30bf8505cfb", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 11, "deletions": 681, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -385,8 +385,7 @@ add_to_worklist (tree alias, VEC (tree, heap) **worklist,\n \n static void\n mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n-\t\t\t     VEC (int, heap) **worklist2,\n-\t\t\t     bitmap on_worklist, bitmap queued)\n+\t\t\t     VEC (int, heap) **worklist2, bitmap on_worklist)\n {\n   bitmap aliases;\n   bitmap_iterator bi;\n@@ -408,29 +407,13 @@ mark_aliases_call_clobbered (tree tag, VEC (tree, heap) **worklist,\n \t the world a particularly nice place, it is necessary\n \t in order to allow C/C++ tricks that involve\n \t pointer arithmetic to work.  */\n-      if (TREE_CODE (entry) == STRUCT_FIELD_TAG)\n-\tbitmap_set_bit (queued, DECL_UID (SFT_PARENT_VAR (entry)));\n-      else if (!unmodifiable_var_p (entry))\n+      if (!unmodifiable_var_p (entry))\n \t{\n \t  add_to_worklist (entry, worklist, worklist2, ta->escape_mask,\n \t\t\t   on_worklist);\n \t  mark_call_clobbered (entry, ta->escape_mask);\n \t}\n     }\n-  if (!bitmap_empty_p (queued))\n-    {\n-      EXECUTE_IF_SET_IN_BITMAP (queued, 0, i, bi)\n-\t{\n-\t  subvar_t svars = get_subvars_for_var (referenced_var (i));\n-\t  unsigned int i;\n-\t  tree subvar;\n-\n-\t  for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t    if (!unmodifiable_var_p (subvar))\n-\t       mark_call_clobbered (subvar, ta->escape_mask);\n-\t}\n-      bitmap_clear (queued);\n-    }\n }\n \n /* Tags containing global vars need to be marked as global.\n@@ -447,7 +430,7 @@ compute_tag_properties (void)\n \n   FOR_EACH_REFERENCED_VAR (tag, rvi)\n     {\n-      if (!MTAG_P (tag) || TREE_CODE (tag) == STRUCT_FIELD_TAG)\n+      if (!MTAG_P (tag))\n \tcontinue;\n       VEC_safe_push (tree, heap, taglist, tag);\n     }\n@@ -538,17 +521,10 @@ set_initial_properties (struct alias_info *ai)\n   referenced_var_iterator rvi;\n   tree var;\n   tree ptr;\n-  bitmap queued;\n-\n-  /* Temporary bitmap to avoid quadratic behavior in marking\n-     call clobbers.  */\n-  queued = BITMAP_ALLOC (&alias_bitmap_obstack);\n \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      if (is_global_var (var) \n-\t  && (!var_can_have_subvars (var)\n-\t      || get_subvars_for_var (var) == NULL))\n+      if (is_global_var (var))\n \t{\n \t  if (!unmodifiable_var_p (var))\n \t    mark_call_clobbered (var, ESCAPE_IS_GLOBAL);\n@@ -591,26 +567,9 @@ set_initial_properties (struct alias_info *ai)\n \t\t     the world a particularly nice place, it is necessary\n \t\t     in order to allow C/C++ tricks that involve\n \t\t     pointer arithmetic to work.  */\n-\t\t  if (TREE_CODE (alias) == STRUCT_FIELD_TAG)\n-\t\t    bitmap_set_bit (queued, DECL_UID (SFT_PARENT_VAR (alias)));\n-\t\t  else if (!unmodifiable_var_p (alias))\n+\t\t  if (!unmodifiable_var_p (alias))\n \t\t    mark_call_clobbered (alias, pi->escape_mask);\n \t\t}\n-\t      /* Process variables we need to clobber all parts of.  */\n-\t      if (!bitmap_empty_p (queued))\n-\t\t{\n-\t\t  EXECUTE_IF_SET_IN_BITMAP (queued, 0, j, bi)\n-\t\t    {\n-\t\t      subvar_t svars = get_subvars_for_var (referenced_var (j));\n-\t\t      unsigned int i;\n-\t\t      tree subvar;\n-\n-\t\t      for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t\t\tif (!unmodifiable_var_p (subvar))\n-\t\t\t  mark_call_clobbered (subvar, pi->escape_mask);\n-\t\t    }\n-\t\t  bitmap_clear (queued);\n-\t\t}\n \t    }\n \t}\n \n@@ -644,8 +603,6 @@ set_initial_properties (struct alias_info *ai)\n \t  MTAG_GLOBAL (tag) = true;\n \t}\n     }\n-\n-  BITMAP_FREE (queued);\n }\n \n /* Compute which variables need to be marked call clobbered because\n@@ -657,11 +614,10 @@ compute_call_clobbered (struct alias_info *ai)\n {\n   VEC (tree, heap) *worklist = NULL;\n   VEC (int,heap) *worklist2 = NULL;\n-  bitmap on_worklist, queued;\n+  bitmap on_worklist;\n \n   timevar_push (TV_CALL_CLOBBER);\n   on_worklist = BITMAP_ALLOC (NULL);\n-  queued = BITMAP_ALLOC (NULL);\n     \n   set_initial_properties (ai);\n   init_transitive_clobber_worklist (&worklist, &worklist2, on_worklist);\n@@ -672,13 +628,11 @@ compute_call_clobbered (struct alias_info *ai)\n \n       bitmap_clear_bit (on_worklist, DECL_UID (curr));\n       mark_call_clobbered (curr, reason);\n-      mark_aliases_call_clobbered (curr, &worklist, &worklist2,\n-\t\t\t\t   on_worklist, queued);\n+      mark_aliases_call_clobbered (curr, &worklist, &worklist2, on_worklist);\n     }\n   VEC_free (tree, heap, worklist);\n   VEC_free (int, heap, worklist2);\n   BITMAP_FREE (on_worklist);\n-  BITMAP_FREE (queued);\n   compute_tag_properties ();\n   timevar_pop (TV_CALL_CLOBBER);\n }\n@@ -827,13 +781,6 @@ count_mem_refs (long *num_vuses_p, long *num_vdefs_p,\n static inline long\n mem_sym_score (mem_sym_stats_t mp)\n {\n-  /* Unpartitionable SFTs are automatically thrown to the bottom of\n-     the list.  They are not stored in partitions, but they are used\n-     for computing overall statistics.  */\n-  if (TREE_CODE (mp->var) == STRUCT_FIELD_TAG\n-      && SFT_UNPARTITIONABLE_P (mp->var))\n-    return LONG_MAX;\n-\n   return mp->frequency_writes * 64 + mp->frequency_reads * 32\n          + mp->num_direct_writes * 16 + mp->num_direct_reads * 8\n \t + mp->num_indirect_writes * 4 + mp->num_indirect_reads * 2\n@@ -1597,15 +1544,6 @@ compute_memory_partitions (void)\n       if (!need_to_partition_p (mem_ref_stats))\n \tbreak;\n \n-      /* SFTs that are marked unpartitionable should not be added to\n-\t partitions.  These SFTs are special because they mark the\n-\t first SFT into a structure where a pointer is pointing to.\n-\t This is needed by the operand scanner to find adjacent\n-\t fields.  See add_vars_for_offset for details.  */\n-      if (TREE_CODE (mp_p->var) == STRUCT_FIELD_TAG\n-\t  && SFT_UNPARTITIONABLE_P (mp_p->var))\n-\tcontinue;\n-\n       mpt = find_partition_for (mp_p);\n       estimate_vop_reduction (mem_ref_stats, mp_p, mpt);\n     }\n@@ -2424,11 +2362,6 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t     \n \t  if (may_alias_p (p_map->var, p_map->set, var, v_map->set, false))\n \t    {\n-\t      /* We should never have a var with subvars here, because\n-\t         they shouldn't get into the set of addressable vars */\n-\t      gcc_assert (!var_can_have_subvars (var)\n-\t\t\t  || get_subvars_for_var (var) == NULL);\n-\n \t      /* Add VAR to TAG's may-aliases set.  */\n \t      add_may_alias (tag, var);\n \t    }\n@@ -2547,8 +2480,6 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n   FOR_EACH_REFERENCED_VAR_SAFE (var, varvec, srvi)\n     {\n-      subvar_t svars;\n-\n       /* Name memory tags already have flow-sensitive aliasing\n \t information, so they need not be processed by\n \t compute_flow_insensitive_aliasing.  Similarly, symbol memory\n@@ -2558,7 +2489,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          Structure fields, on the other hand, have to have some of this\n          information processed for them, but it's pointless to mark them\n          non-addressable (since they are fake variables anyway).  */\n-      if (MTAG_P (var) && TREE_CODE (var) != STRUCT_FIELD_TAG)\n+      if (MTAG_P (var))\n \tcontinue;\n \n       /* Remove the ADDRESSABLE flag from every addressable variable whose\n@@ -2578,24 +2509,6 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t\t to rename VAR into SSA afterwards.  */\n \t      mark_sym_for_renaming (var);\n \n-\t      /* If VAR can have sub-variables, and any of its\n-\t\t sub-variables has its address taken, then we cannot\n-\t\t remove the addressable flag from VAR.  */\n-\t      if (var_can_have_subvars (var)\n-\t\t  && (svars = get_subvars_for_var (var)))\n-\t\t{\n-\t\t  unsigned int i;\n-\t\t  tree subvar;\n-\n-\t\t  for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t\t    {\t      \n-\t\t      if (bitmap_bit_p (gimple_addressable_vars (cfun),\n-\t\t\t\t\tDECL_UID (subvar)))\n-\t\t\tokay_to_mark = false;\n-\t\t      mark_sym_for_renaming (subvar);\n-\t\t    }\n-\t\t}\n-\n \t      /* The address of VAR is not needed, remove the\n \t\t addressable bit, so that it can be optimized as a\n \t\t regular variable.  */\n@@ -2616,10 +2529,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          entry in ADDRESSABLE_VARS for VAR.  */\n       if (may_be_aliased (var))\n \t{\n-\t  if (!var_can_have_subvars (var)\n-\t      || get_subvars_for_var (var) == NULL)\n-\t    create_alias_map_for (var, ai);\n-\n+\t  create_alias_map_for (var, ai);\n \t  mark_sym_for_renaming (var);\n \t}\n \n@@ -3508,14 +3418,9 @@ new_type_alias (tree ptr, tree var, tree expr)\n {\n   tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n   tree tag;\n-  subvar_t svars;\n   tree ali = NULL_TREE;\n   HOST_WIDE_INT offset, size, maxsize;\n   tree ref;\n-  VEC (tree, heap) *overlaps = NULL;\n-  unsigned int len, i;\n-  tree subvar;\n-\n \n   gcc_assert (symbol_mem_tag (ptr) == NULL_TREE);\n   gcc_assert (!MTAG_P (var));\n@@ -3526,593 +3431,18 @@ new_type_alias (tree ptr, tree var, tree expr)\n   tag = create_memory_tag (tag_type, true);\n   set_symbol_mem_tag (ptr, tag);\n \n-  /* Add VAR to the may-alias set of PTR's new symbol tag.  If VAR has\n-     subvars, add the subvars to the tag instead of the actual var.  */\n-  if (var_can_have_subvars (ref)\n-      && (svars = get_subvars_for_var (ref)))\n-    {\n-      for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t{\n-          bool exact;\n-\n-          if (overlap_subvar (offset, maxsize, subvar, &exact))\n-            VEC_safe_push (tree, heap, overlaps, subvar);\n-        }\n-      gcc_assert (overlaps != NULL);\n-    }\n-  else if (var_can_have_subvars (var)\n-\t   && (svars = get_subvars_for_var (var)))\n-    {\n-      /* If the REF is not a direct access to VAR (e.g., it is a dereference\n-\t of a pointer), we should scan the virtual operands of REF the same\n-\t way as tree-ssa-operands do.  At the moment, this is somewhat\n-\t difficult, so we just give up and add all the subvars of VAR.\n-\t On mem-ssa branch, the scanning for virtual operands have been\n-\t split from the rest of tree-ssa-operands, so it should be much\n-\t easier to fix this problem correctly once mem-ssa is merged.  */\n-      for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\tVEC_safe_push (tree, heap, overlaps, subvar);\n-\n-      gcc_assert (overlaps != NULL);\n-    }\n-  else\n-    ali = add_may_alias_for_new_tag (tag, var);\n-\n-  len = VEC_length (tree, overlaps);\n-  if (len > 0)\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"\\nnumber of overlapping subvars = %u\\n\", len);\n-\n-      if (len == 1)\n-\tali = add_may_alias_for_new_tag (tag, VEC_index (tree, overlaps, 0));\n-      else if (len > 1)\n-\t{\n-\t  unsigned int k;\n-\t  tree sv_var;\n-\n-\t  for (k = 0; VEC_iterate (tree, overlaps, k, sv_var); k++)\n-\t    {\n-\t      ali = add_may_alias_for_new_tag (tag, sv_var);\n-\n-\t      if (ali != tag)\n-\t\t{\n-\t\t  /* Can happen only if 'Case 1' of add_may_alias_for_new_tag\n-\t\t     took place.  Since more than one svar was found, we add \n-\t\t     'ali' as one of the may_aliases of the new tag.  */ \n-\t\t  add_may_alias (tag, ali);\n-\t\t  ali = tag;\n-\t\t}\n-\t    }\n-\t}\n-      VEC_free (tree, heap, overlaps);\n-    }\n+  ali = add_may_alias_for_new_tag (tag, var);\n \n   set_symbol_mem_tag (ptr, ali);\n   TREE_READONLY (tag) = TREE_READONLY (var);\n   MTAG_GLOBAL (tag) = is_global_var (var);\n }\n \n-/* This represents the used range of a variable.  */\n-\n-typedef struct used_part\n-{\n-  HOST_WIDE_INT minused;\n-  HOST_WIDE_INT maxused;\n-  /* True if we have an explicit use/def of some portion of this variable,\n-     even if it is all of it. i.e. a.b = 5 or temp = a.b.  */\n-  bool explicit_uses;\n-  /* True if we have an implicit use/def of some portion of this\n-     variable.  Implicit uses occur when we can't tell what part we\n-     are referencing, and have to make conservative assumptions.  */\n-  bool implicit_uses;\n-  /* True if the structure is only written to or taken its address.  */\n-  bool write_only;\n-} *used_part_t;\n-\n-/* An array of used_part structures, indexed by variable uid.  */\n-\n-static htab_t used_portions;\n-\n-struct used_part_map\n-{\n-  unsigned int uid;\n-  used_part_t to;\n-};\n-\n-/* Return true if the uid in the two used part maps are equal.  */\n-\n-static int\n-used_part_map_eq (const void *va, const void *vb)\n-{\n-  const struct used_part_map *a = (const struct used_part_map *) va;\n-  const struct used_part_map *b = (const struct used_part_map *) vb;\n-  return (a->uid == b->uid);\n-}\n-\n-/* Hash a from uid in a used_part_map.  */\n-\n-static unsigned int\n-used_part_map_hash (const void *item)\n-{\n-  return ((const struct used_part_map *)item)->uid;\n-}\n-\n-/* Free a used part map element.  */\n-\n-static void \n-free_used_part_map (void *item)\n-{\n-  free (((struct used_part_map *)item)->to);\n-  free (item);\n-}\n-\n-/* Lookup a used_part structure for a UID.  */\n-\n-static used_part_t\n-up_lookup (unsigned int uid)\n-{\n-  struct used_part_map *h, in;\n-  in.uid = uid;\n-  h = (struct used_part_map *) htab_find_with_hash (used_portions, &in, uid);\n-  if (!h)\n-    return NULL;\n-  return h->to;\n-}\n-\n-/* Insert the pair UID, TO into the used part hashtable.  */\n- \n-static void \n-up_insert (unsigned int uid, used_part_t to)\n-{ \n-  struct used_part_map *h;\n-  void **loc;\n-\n-  h = XNEW (struct used_part_map);\n-  h->uid = uid;\n-  h->to = to;\n-  loc = htab_find_slot_with_hash (used_portions, h,\n-\t\t\t\t  uid, INSERT);\n-  if (*loc != NULL)\n-    free (*loc);\n-  *(struct used_part_map **)  loc = h;\n-}\n-\n-\n-/* Given a variable uid, UID, get or create the entry in the used portions\n-   table for the variable.  */\n-\n-static used_part_t\n-get_or_create_used_part_for (size_t uid)\n-{\n-  used_part_t up;\n-  if ((up = up_lookup (uid)) == NULL)\n-    {\n-      up = XCNEW (struct used_part);\n-      up->minused = INT_MAX;\n-      up->maxused = 0;\n-      up->explicit_uses = false;\n-      up->implicit_uses = false;\n-      up->write_only = true;\n-    }\n-\n-  return up;\n-}\n-\n-\n-/* Create and return a structure sub-variable for field type FIELD at\n-   offset OFFSET, with size SIZE, of variable VAR.  If ALIAS_SET not\n-   -1 this field is non-addressable and we should use this alias set\n-   with this field.  */\n-\n-static tree\n-create_sft (tree var, tree field, unsigned HOST_WIDE_INT offset,\n-\t    unsigned HOST_WIDE_INT size, alias_set_type alias_set,\n-\t    bool base_for_components)\n-{\n-  tree subvar = create_tag_raw (STRUCT_FIELD_TAG, field, \"SFT\");\n-\n-  /* We need to copy the various flags from VAR to SUBVAR, so that\n-     they are is_global_var iff the original variable was.  */\n-  DECL_CONTEXT (subvar) = DECL_CONTEXT (var);\n-  MTAG_GLOBAL (subvar) = DECL_EXTERNAL (var);\n-  TREE_PUBLIC  (subvar) = TREE_PUBLIC (var);\n-  TREE_STATIC (subvar) = TREE_STATIC (var);\n-  TREE_READONLY (subvar) = TREE_READONLY (var);\n-  TREE_ADDRESSABLE (subvar) = TREE_ADDRESSABLE (var);\n-\n-  /* Add the new variable to REFERENCED_VARS.  */\n-  set_symbol_mem_tag (subvar, NULL);\n-  add_referenced_var (subvar);\n-  SFT_PARENT_VAR (subvar) = var;\n-  SFT_OFFSET (subvar) = offset;\n-  SFT_SIZE (subvar) = size;\n-  SFT_ALIAS_SET (subvar) = alias_set;\n-  SFT_BASE_FOR_COMPONENTS_P (subvar) = base_for_components;\n-  SFT_UNPARTITIONABLE_P (subvar) = false;\n-\n-  return subvar;\n-}\n-\n-\n-/* Given an aggregate VAR, create the subvariables that represent its\n-   fields.  */\n-\n-static void\n-create_overlap_variables_for (tree var)\n-{\n-  VEC(fieldoff_s,heap) *fieldstack = NULL;\n-  used_part_t up;\n-  size_t uid = DECL_UID (var);\n-\n-  up = up_lookup (uid);\n-  if (!up\n-      || up->write_only)\n-    return;\n-\n-  push_fields_onto_fieldstack (TREE_TYPE (var), &fieldstack, 0, NULL,\n-\t\t\t       TREE_TYPE (var));\n-  /* Make sure to not create SFTs for structs we won't generate variable\n-     infos for.  See tree-ssa-structalias.c:create_variable_info_for ().  */\n-  if (VEC_length (fieldoff_s, fieldstack) > 1\n-      && VEC_length (fieldoff_s, fieldstack) <= MAX_FIELDS_FOR_FIELD_SENSITIVE)\n-    {\n-      subvar_t *subvars;\n-      fieldoff_s *fo;\n-      bool notokay = false;\n-      int fieldcount = 0;\n-      int i;\n-      HOST_WIDE_INT lastfooffset = -1;\n-      HOST_WIDE_INT lastfosize = -1;\n-      tree lastfotype = NULL_TREE;\n-\n-      /* Not all fields have DECL_SIZE set, and those that don't, we don't\n-\t know their size, and thus, can't handle.\n-\t The same is true of fields with DECL_SIZE that is not an integer\n-\t constant (such as variable sized fields).\n-\t Fields with offsets which are not constant will have an offset < 0 \n-\t We *could* handle fields that are constant sized arrays, but\n-\t currently don't.  Doing so would require some extra changes to\n-\t tree-ssa-operands.c.  */\n-\n-      for (i = 0; VEC_iterate (fieldoff_s, fieldstack, i, fo); i++)\n-\t{\n-\t  if (!fo->size\n-\t      || TREE_CODE (fo->size) != INTEGER_CST\n-\t      || fo->offset < 0)\n-\t    {\n-\t      notokay = true;\n-\t      break;\n-\t    }\n-          fieldcount++;\n-\t}\n-\n-      /* The current heuristic we use is as follows:\n-\t If the variable has no used portions in this function, no\n-\t structure vars are created for it.\n-\t Otherwise,\n-         If the variable has less than SALIAS_MAX_IMPLICIT_FIELDS,\n-\t we always create structure vars for them.\n-\t If the variable has more than SALIAS_MAX_IMPLICIT_FIELDS, and\n-\t some explicit uses, we create structure vars for them.\n-\t If the variable has more than SALIAS_MAX_IMPLICIT_FIELDS, and\n-\t no explicit uses, we do not create structure vars for them.\n-      */\n-      \n-      if (fieldcount >= SALIAS_MAX_IMPLICIT_FIELDS\n-\t  && !up->explicit_uses)\n-\t{\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"Variable \");\n-\t      print_generic_expr (dump_file, var, 0);\n-\t      fprintf (dump_file, \" has no explicit uses in this function, and is > SALIAS_MAX_IMPLICIT_FIELDS, so skipping\\n\");\n-\t    }\n-\t  notokay = true;\n-\t}\n-      \n-      /* Bail out, if we can't create overlap variables.  */\n-      if (notokay)\n-\t{\n-\t  VEC_free (fieldoff_s, heap, fieldstack);\n-\t  return;\n-\t}\n-      \n-      /* Otherwise, create the variables.  */\n-      subvars = lookup_subvars_for_var (var);\n-      *subvars = VEC_alloc (tree, gc, VEC_length (fieldoff_s, fieldstack));\n- \n-      sort_fieldstack (fieldstack);\n-\n-      for (i = 0; VEC_iterate (fieldoff_s, fieldstack, i, fo); ++i)\n-\t{\n-\t  HOST_WIDE_INT fosize;\n-\t  tree currfotype, subvar;\n-\n-\t  fosize = TREE_INT_CST_LOW (fo->size);\n-\t  currfotype = fo->type;\n-\n-\t  /* If this field isn't in the used portion,\n-\t     or it has the exact same offset and size as the last\n-\t     field, skip it.  Note that we always need the field at\n-\t     offset 0 so we can properly handle pointers to the\n-\t     structure.  */\n-\n-\t  if ((fo->offset != 0\n-\t       && ((fo->offset <= up->minused\n-\t\t    && fo->offset + fosize <= up->minused)\n-\t\t   || fo->offset >= up->maxused))\n-\t      || (fo->offset == lastfooffset\n-\t\t  && fosize == lastfosize\n-\t\t  && currfotype == lastfotype))\n-\t    continue;\n-\t  subvar = create_sft (var, fo->type, fo->offset,\n-\t\t\t       fosize, fo->alias_set, fo->base_for_components);\n-\t  VEC_quick_push (tree, *subvars, subvar);\n-\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"structure field tag %s created for var %s\",\n-\t\t       get_name (subvar), get_name (var));\n-\t      fprintf (dump_file, \" offset \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t       SFT_OFFSET (subvar));\n-\t      fprintf (dump_file, \" size \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t       SFT_SIZE (subvar));\n-\t      fprintf (dump_file, \"\\n\");\n-\t    }\n-\t  \n-\t  lastfotype = currfotype;\n-\t  lastfooffset = fo->offset;\n-\t  lastfosize = fosize;\n-\t}\n-\n-      /* Once we have created subvars, the original is no longer call\n-\t clobbered on its own.  Its call clobbered status depends\n-\t completely on the call clobbered status of the subvars.\n-\n-\t add_referenced_var in the above loop will take care of\n-\t marking subvars of global variables as call clobbered for us\n-\t to start, since they are global as well.  */\n-      clear_call_clobbered (var);\n-    }\n-\n-  VEC_free (fieldoff_s, heap, fieldstack);\n-}\n-\n-\n-/* Find the conservative answer to the question of what portions of what \n-   structures are used by this statement.  We assume that if we have a\n-   component ref with a known size + offset, that we only need that part\n-   of the structure.  For unknown cases, or cases where we do something\n-   to the whole structure, we assume we need to create fields for the \n-   entire structure.  */\n-\n-static tree\n-find_used_portions (tree *tp, int *walk_subtrees, void *lhs_p)\n-{\n-  switch (TREE_CODE (*tp))\n-    {\n-    case GIMPLE_MODIFY_STMT:\n-      /* Recurse manually here to track whether the use is in the\n-\t LHS of an assignment.  */\n-      find_used_portions (&GIMPLE_STMT_OPERAND (*tp, 0), walk_subtrees, tp);\n-      return find_used_portions (&GIMPLE_STMT_OPERAND (*tp, 1),\n-\t  \t\t\t walk_subtrees, NULL);\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-    case COMPONENT_REF:\n-    case ARRAY_REF:\n-      {\n-\tHOST_WIDE_INT bitsize;\n-\tHOST_WIDE_INT bitmaxsize;\n-\tHOST_WIDE_INT bitpos;\n-\ttree ref;\n-\tref = get_ref_base_and_extent (*tp, &bitpos, &bitsize, &bitmaxsize);\n-\tif (DECL_P (ref)\n-\t    && var_can_have_subvars (ref)\n-\t    && bitmaxsize != -1)\n-\t  {\n-\t    size_t uid = DECL_UID (ref);\n-\t    used_part_t up;\n-\n-\t    up = get_or_create_used_part_for (uid);\t    \n-\n-\t    if (bitpos <= up->minused)\n-\t      up->minused = bitpos;\n-\t    if ((bitpos + bitmaxsize >= up->maxused))\n-\t      up->maxused = bitpos + bitmaxsize;\n-\n-\t    if (bitsize == bitmaxsize)\n-\t      up->explicit_uses = true;\n-\t    else\n-\t      up->implicit_uses = true;\n-\t    if (!lhs_p)\n-\t      up->write_only = false;\n-\t    up_insert (uid, up);\n-\n-\t    *walk_subtrees = 0;\n-\t    return NULL_TREE;\n-\t  }\n-      }\n-      break;\n-      /* This is here to make sure we mark the entire base variable as used\n-\t when you take its address.  Because our used portion analysis is\n-\t simple, we aren't looking at casts or pointer arithmetic to see what\n-\t happens when you take the address.  */\n-    case ADDR_EXPR:\n-      {\n-\ttree var = get_base_address (TREE_OPERAND (*tp, 0));\n-\n-\tif (var \n-\t    && DECL_P (var)\n-\t    && DECL_SIZE (var)\n-\t    && var_can_have_subvars (var)\n-\t    && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n-\t  {\n-\t    used_part_t up;\n-\t    size_t uid = DECL_UID (var);\n-\t    \n-\t    up = get_or_create_used_part_for (uid);\n- \n-\t    up->minused = 0;\n-\t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n-\t    up->implicit_uses = true;\n-\t    if (!lhs_p)\n-\t      up->write_only = false;\n-\n-\t    up_insert (uid, up);\n-\t    *walk_subtrees = 0;\n-\t    return NULL_TREE;\n-\t  }\n-      }\n-      break;\n-    case CALL_EXPR:\n-      {\n-\tint i;\n-\tint nargs = call_expr_nargs (*tp);\n-\tfor (i = 0; i < nargs; i++)\n-\t  {\n-\t    tree *arg = &CALL_EXPR_ARG (*tp, i);\n-\t    if (TREE_CODE (*arg) == ADDR_EXPR)\n-              find_used_portions (arg, walk_subtrees, NULL);\n-\t  }\n-\t*walk_subtrees = 0;\n-\treturn NULL_TREE;\n-      }\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-      {\n-\ttree var = *tp;\n-\tif (DECL_SIZE (var)\n-\t    && var_can_have_subvars (var)\n-\t    && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n-\t  {\n-\t    used_part_t up;\n-\t    size_t uid = DECL_UID (var);\n-\t    \n-\t    up = get_or_create_used_part_for (uid);\n- \n-\t    up->minused = 0;\n-\t    up->maxused = TREE_INT_CST_LOW (DECL_SIZE (var));\n-\t    up->implicit_uses = true;\n-\n-\t    up_insert (uid, up);\n-\t    *walk_subtrees = 0;\n-\t    return NULL_TREE;\n-\t  }\n-      }\n-      break;\n-      \n-    default:\n-      break;\n-      \n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Create structure field variables for structures used in this function.  */\n+/* ???  Stub.  */\n \n static unsigned int\n create_structure_vars (void)\n {\n-  basic_block bb;\n-  safe_referenced_var_iterator rvi;\n-  VEC (tree, heap) *varvec = NULL;\n-  tree var;\n-\n-  used_portions = htab_create (10, used_part_map_hash, used_part_map_eq, \n-                               free_used_part_map);\n-  \n-  FOR_EACH_BB (bb)\n-    {\n-      block_stmt_iterator bsi;\n-      tree phi;\n-      \n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  use_operand_p use;\n-\t  ssa_op_iter iter;\n-\n-\t  FOR_EACH_PHI_ARG (use, phi, iter, SSA_OP_USE)\n-\t    {\n-\t      tree op = USE_FROM_PTR (use);\n-\t      walk_tree_without_duplicates (&op, find_used_portions,\n-\t\t\t\t\t    NULL);\n-\t    }\n-\t}\n-\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  walk_tree_without_duplicates (bsi_stmt_ptr (bsi), \n-\t\t\t\t\tfind_used_portions,\n-\t\t\t\t\tNULL);\n-\t}\n-    }\n-  FOR_EACH_REFERENCED_VAR_SAFE (var, varvec, rvi)\n-    {\n-      /* The C++ FE creates vars without DECL_SIZE set, for some reason.  */\n-      if (var \t  \n-\t  && DECL_SIZE (var)\n-\t  && var_can_have_subvars (var)\n-\t  && !MTAG_P (var)\n-\t  && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n-\tcreate_overlap_variables_for (var);\n-    }\n-  htab_delete (used_portions);\n-  VEC_free (tree, heap, varvec);\n-\n-  /* Update SSA operands of statements mentioning variables we split.  */\n-  if (gimple_in_ssa_p (cfun))\n-    FOR_EACH_BB (bb)\n-      {\n-\tblock_stmt_iterator bsi;\n-\tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t  {\n-\t    tree stmt = bsi_stmt (bsi);\n-\t    bool update = false;\n-\t    unsigned int i;\n-\t    bitmap_iterator bi;\n-\n-\t    if (STORED_SYMS (stmt))\n-\t       EXECUTE_IF_SET_IN_BITMAP (STORED_SYMS (stmt), 0, i, bi)\n-\t\t{\n-\t\t  tree sym = referenced_var_lookup (i);\n-\t\t  if (get_subvars_for_var (sym))\n-\t\t    {\n-\t\t      update = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t    if (LOADED_SYMS (stmt) && !update)\n-\t       EXECUTE_IF_SET_IN_BITMAP (LOADED_SYMS (stmt), 0, i, bi)\n-\t\t{\n-\t\t  tree sym = referenced_var_lookup (i);\n-\t\t  if (get_subvars_for_var (sym))\n-\t\t    {\n-\t\t      update = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t    if (stmt_ann (stmt)->addresses_taken && !update)\n-\t       EXECUTE_IF_SET_IN_BITMAP (stmt_ann (stmt)->addresses_taken,\n-\t\t\t\t\t 0, i, bi)\n-\t\t{\n-\t\t  tree sym = referenced_var_lookup (i);\n-\t\t  if (get_subvars_for_var (sym))\n-\t\t    {\n-\t\t      update = true;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\n-\t    if (update)\n-\t      update_stmt (stmt);\n-\t  }\n-      }\n-\n   return TODO_rebuild_alias;\n }\n "}, {"sha": "afa469b9cc34ec47809d0a1d95fabb9f94328087", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -5155,9 +5155,6 @@ get_ref_tag (tree ref, tree orig)\n \tbreak;\n     }\n \n-  if (aref && SSA_VAR_P (aref) && get_subvars_for_var (aref))\n-    return aref;\n-\n   if (!var)\n     return NULL_TREE;\n "}, {"sha": "c6cc6189b3e1fc131026b8a14f9886db7bae902e", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 25, "deletions": 241, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -1210,49 +1210,6 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   if (ref && TREE_CODE (ref) == TARGET_MEM_REF)\n     return true;\n   \n-  /* If ALIAS is an SFT, it can't be touched if the offset     \n-     and size of the access is not overlapping with the SFT offset and\n-     size.  This is only true if we are accessing through a pointer\n-     to a type that is the same as SFT_PARENT_VAR.  Otherwise, we may\n-     be accessing through a pointer to some substruct of the\n-     structure, and if we try to prune there, we will have the wrong\n-     offset, and get the wrong answer.\n-     i.e., we can't prune without more work if we have something like\n-\n-     struct gcc_target\n-     {\n-       struct asm_out\n-       {\n-         const char *byte_op;\n-\t struct asm_int_op\n-\t {    \n-\t   const char *hi;\n-\t } aligned_op;\n-       } asm_out;\n-     } targetm;\n-     \n-     foo = &targetm.asm_out.aligned_op;\n-     return foo->hi;\n-\n-     SFT.1, which represents hi, will have SFT_OFFSET=32 because in\n-     terms of SFT_PARENT_VAR, that is where it is.\n-     However, the access through the foo pointer will be at offset 0.  */\n-  if (size != -1\n-      && TREE_CODE (alias) == STRUCT_FIELD_TAG\n-      && base\n-      && TREE_TYPE (base) == TREE_TYPE (SFT_PARENT_VAR (alias))\n-      && !overlap_subvar (offset, size, alias, NULL))\n-    {\n-#ifdef ACCESS_DEBUGGING\n-      fprintf (stderr, \"Access to \");\n-      print_generic_expr (stderr, ref, 0);\n-      fprintf (stderr, \" may not touch \");\n-      print_generic_expr (stderr, alias, 0);\n-      fprintf (stderr, \" in function %s\\n\", get_name (current_function_decl));\n-#endif\n-      return false;\n-    }\n-\n   /* Without strict aliasing, it is impossible for a component access\n      through a pointer to touch a random variable, unless that\n      variable *is* a structure or a pointer.\n@@ -1308,7 +1265,7 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n      my_char_ref_1 = (char[1:1] &) &my_char;\n      D.874_2 = (*my_char_ref_1)[1]{lb: 1 sz: 1};\n   */\n-  else if (ref \n+  if (ref \n \t   && flag_strict_aliasing\n \t   && TREE_CODE (ref) != INDIRECT_REF\n \t   && !MTAG_P (alias)\n@@ -1366,61 +1323,6 @@ access_can_touch_variable (tree ref, tree alias, HOST_WIDE_INT offset,\n   return true;\n }\n \n-/* Add the actual variables accessed, given a member of a points-to set\n-   that is the SFT VAR, where the access is of SIZE at OFFSET from VAR.\n-   IS_CALL_SITE is true if this is a call, and IS_DEF is true if this is\n-   supposed to be a vdef, and false if this should be a VUSE.\n-\n-   The real purpose of this function is to take a points-to set for a\n-   pointer to a structure, say\n-\n-   struct s {\n-     int a;\n-     int b;\n-   } foo, *foop = &foo;\n-\n-   and discover which variables an access, such as foop->b, can alias.\n-   \n-   This is necessary because foop only actually points to foo's first\n-   member, so that is all the points-to set contains.  However, an access\n-   to foop->a may be touching some single SFT if we have created some\n-   SFT's for a structure.  */\n-\n-static bool\n-add_vars_for_offset (tree var, unsigned HOST_WIDE_INT offset,\n-\t\t     unsigned HOST_WIDE_INT size, bool is_def)\n-{\n-  bool added = false;\n-  tree subvar;\n-  subvar_t sv;\n-  unsigned int i;\n-\n-  /* Adjust offset by the pointed-to location.  */\n-  offset += SFT_OFFSET (var);\n-\n-  /* Add all subvars of var that overlap with the access.\n-     Binary search for the first relevant SFT.  */\n-  sv = get_subvars_for_var (SFT_PARENT_VAR (var));\n-  if (!get_first_overlapping_subvar (sv, offset, size, &i))\n-    return false;\n-\n-  for (; VEC_iterate (tree, sv, i, subvar); ++i)\n-    {\n-      if (SFT_OFFSET (subvar) > offset\n-\t  && size <= SFT_OFFSET (subvar) - offset)\n-\tbreak;\n-\n-      if (is_def)\n-\tappend_vdef (subvar);\n-      else\n-\tappend_vuse (subvar);\n-      added = true;\n-    }\n-\n-  return added;\n-}\n-\n-\n /* Add VAR to the virtual operands array.  FLAGS is as in\n    get_expr_operands.  FULL_REF is a tree that contains the entire\n    pointer dereference expression, if available, or NULL otherwise.\n@@ -1495,50 +1397,24 @@ add_virtual_operand (tree var, stmt_ann_t s_ann, int flags,\n \t{\n \t  tree al = referenced_var (i);\n \n-\t  /* For SFTs we have to consider all subvariables of the parent var\n-\t     if it is a potential points-to location.  */\n-\t  if (TREE_CODE (al) == STRUCT_FIELD_TAG\n-\t      && TREE_CODE (var) == NAME_MEMORY_TAG)\n-\t    {\n-\t      if (SFT_BASE_FOR_COMPONENTS_P (al))\n-\t\t{\n-\t\t  /* If AL is the first SFT of a component, it can be used\n-\t\t     to find other SFTs at [offset, size] adjacent to it.  */\n-\t\t  none_added &= !add_vars_for_offset (al, offset, size,\n-\t\t\t\t\t\t      flags & opf_def);\n-\t\t}\n-\t      else if ((unsigned HOST_WIDE_INT)offset < SFT_SIZE (al))\n-\t\t{\n-\t\t  /* Otherwise, we only need to consider it if\n-\t\t     [offset, size] overlaps with AL.  */\n-\t\t  if (flags & opf_def)\n-\t\t    append_vdef (al);\n-\t\t  else\n-\t\t    append_vuse (al);\n-\t\t  none_added = false;\n-\t\t}\n-\t    }\n+\t  /* Call-clobbered tags may have non-call-clobbered\n+\t     symbols in their alias sets.  Ignore them if we are\n+\t     adding VOPs for a call site.  */\n+\t  if (is_call_site && !is_call_clobbered (al))\n+\t    continue;\n+\n+\t  /* If we do not know the full reference tree or if the access is\n+\t     unspecified [0, -1], we cannot prune it.  Otherwise try doing\n+\t     so using access_can_touch_variable.  */\n+\t  if (full_ref\n+\t      && !access_can_touch_variable (full_ref, al, offset, size))\n+\t    continue;\n+\n+\t  if (flags & opf_def)\n+\t    append_vdef (al);\n \t  else\n-\t    {\n-\t      /* Call-clobbered tags may have non-call-clobbered\n-\t\t symbols in their alias sets.  Ignore them if we are\n-\t\t adding VOPs for a call site.  */\n-\t      if (is_call_site && !is_call_clobbered (al))\n-\t\t continue;\n-\n-\t      /* If we do not know the full reference tree or if the access is\n-\t\t unspecified [0, -1], we cannot prune it.  Otherwise try doing\n-\t\t so using access_can_touch_variable.  */\n-\t      if (full_ref\n-\t\t  && !access_can_touch_variable (full_ref, al, offset, size))\n-\t\tcontinue;\n-\n-\t      if (flags & opf_def)\n-\t\tappend_vdef (al);\n-\t      else\n-\t\tappend_vuse (al);\n-\t      none_added = false;\n-\t    }\n+\t    append_vuse (al);\n+\t  none_added = false;\n \t}\n \n       if (flags & opf_def)\n@@ -1806,11 +1682,6 @@ add_call_clobber_ops (tree stmt, tree callee)\n       tree real_var = var;\n       bool not_read;\n       bool not_written;\n-      \n-      /* Not read and not written are computed on regular vars, not\n-\t subvars, so look at the parent var if this is an SFT. */\n-      if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n-\treal_var = SFT_PARENT_VAR (var);\n \n       not_read = not_read_b\n \t         ? bitmap_bit_p (not_read_b, DECL_UID (real_var))\n@@ -1889,12 +1760,6 @@ add_call_read_ops (tree stmt, tree callee)\n       \n       clobber_stats.readonly_clobbers++;\n \n-      /* Not read and not written are computed on regular vars, not\n-\t subvars, so look at the parent var if this is an SFT. */\n-\n-      if (TREE_CODE (var) == STRUCT_FIELD_TAG)\n-\treal_var = SFT_PARENT_VAR (var);\n-\n       not_read = not_read_b ? bitmap_bit_p (not_read_b, DECL_UID (real_var))\n \t                    : false;\n       \n@@ -2022,16 +1887,6 @@ get_asm_expr_operands (tree stmt)\n \tEXECUTE_IF_SET_IN_BITMAP (gimple_addressable_vars (cfun), 0, i, bi)\n \t  {\n \t    tree var = referenced_var (i);\n-\n-\t    /* Subvars are explicitly represented in this list, so we\n-\t       don't need the original to be added to the clobber ops,\n-\t       but the original *will* be in this list because we keep\n-\t       the addressability of the original variable up-to-date\n-\t       to avoid confusing the back-end.  */\n-\t    if (var_can_have_subvars (var)\n-\t\t&& get_subvars_for_var (var) != NULL)\n-\t      continue;\t\t\n-\n \t    add_stmt_operand (&var, s_ann, opf_def | opf_implicit);\n \t  }\n \tbreak;\n@@ -2052,9 +1907,8 @@ get_modify_stmt_operands (tree stmt, tree expr)\n      a preserving definition (VDEF).\n \n      Preserving definitions are those that modify a part of an\n-     aggregate object for which no subvars have been computed (or the\n-     reference does not correspond exactly to one of them). Stores\n-     through a pointer are also represented with VDEF operators.\n+     aggregate object. Stores through a pointer are also represented\n+     with VDEF operators.\n \n      We used to distinguish between preserving and killing definitions.\n      We always emit preserving definitions now.  */\n@@ -2104,7 +1958,6 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       return;\n \n     case SSA_NAME:\n-    case STRUCT_FIELD_TAG:\n     case SYMBOL_MEMORY_TAG:\n     case NAME_MEMORY_TAG:\n      add_stmt_operand (expr_p, s_ann, flags);\n@@ -2113,25 +1966,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n-      {\n-\tsubvar_t svars;\n-\t\n-\t/* Add the subvars for a variable, if it has subvars, to DEFS\n-\t   or USES.  Otherwise, add the variable itself.  Whether it\n-\t   goes to USES or DEFS depends on the operand flags.  */\n-\tif (var_can_have_subvars (expr)\n-\t    && (svars = get_subvars_for_var (expr)))\n-\t  {\n-\t    unsigned int i;\n-\t    tree subvar;\n-\t    for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t      add_stmt_operand (&subvar, s_ann, flags);\n-\t  }\n-\telse\n-\t  add_stmt_operand (expr_p, s_ann, flags);\n-\n-\treturn;\n-      }\n+      add_stmt_operand (expr_p, s_ann, flags);\n+      return;\n \n     case MISALIGNED_INDIRECT_REF:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n@@ -2154,54 +1990,18 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       {\n \ttree ref;\n \tHOST_WIDE_INT offset, size, maxsize;\n-\tbool none = true;\n \n \tif (TREE_THIS_VOLATILE (expr))\n \t  s_ann->has_volatile_ops = true;\n \n-\t/* This component reference becomes an access to all of the\n-\t   subvariables it can touch, if we can determine that, but\n-\t   *NOT* the real one.  If we can't determine which fields we\n-\t   could touch, the recursion will eventually get to a\n-\t   variable and add *all* of its subvars, or whatever is the\n-\t   minimum correct subset.  */\n \tref = get_ref_base_and_extent (expr, &offset, &size, &maxsize);\n-\tif (SSA_VAR_P (ref) && get_subvars_for_var (ref))\n-\t  {\n-\t    subvar_t svars = get_subvars_for_var (ref);\n-\t    unsigned int i;\n-\t    tree subvar;\n-\n-\t    for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t      {\n-\t\tbool exact;\t\t\n-\n-\t\tif (overlap_subvar (offset, maxsize, subvar, &exact))\n-\t\t  {\n-\t            int subvar_flags = flags;\n-\t\t    none = false;\n-\t\t    add_stmt_operand (&subvar, s_ann, subvar_flags);\n-\t\t  }\n-\t      }\n-\n-\t    if (!none)\n-\t      flags |= opf_no_vops;\n-\n-\t    if ((DECL_P (ref) && TREE_THIS_VOLATILE (ref))\n-\t\t|| (TREE_CODE (ref) == SSA_NAME\n-\t\t    && TREE_THIS_VOLATILE (SSA_NAME_VAR (ref))))\n-\t      s_ann->has_volatile_ops = true;\n-\t  }\n-\telse if (TREE_CODE (ref) == INDIRECT_REF)\n+\tif (TREE_CODE (ref) == INDIRECT_REF)\n \t  {\n \t    get_indirect_ref_operands (stmt, ref, flags, expr, offset,\n \t\t                       maxsize, false);\n \t    flags |= opf_no_vops;\n \t  }\n \n-\t/* Even if we found subvars above we need to ensure to see\n-\t   immediate uses for d in s.a[d].  In case of s.a having\n-\t   a subvar or we would miss it otherwise.  */\n \tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n \t\n \tif (code == COMPONENT_REF)\n@@ -2759,7 +2559,6 @@ void\n add_to_addressable_set (tree ref, bitmap *addresses_taken)\n {\n   tree var;\n-  subvar_t svars;\n \n   gcc_assert (addresses_taken);\n \n@@ -2773,23 +2572,8 @@ add_to_addressable_set (tree ref, bitmap *addresses_taken)\n     {\n       if (*addresses_taken == NULL)\n \t*addresses_taken = BITMAP_GGC_ALLOC ();      \n-      \n-      if (var_can_have_subvars (var)\n-\t  && (svars = get_subvars_for_var (var)))\n-\t{\n-\t  unsigned int i;\n-\t  tree subvar;\n-\t  for (i = 0; VEC_iterate (tree, svars, i, subvar); ++i)\n-\t    {\n-\t      bitmap_set_bit (*addresses_taken, DECL_UID (subvar));\n-\t      TREE_ADDRESSABLE (subvar) = 1;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  bitmap_set_bit (*addresses_taken, DECL_UID (var));\n-\t  TREE_ADDRESSABLE (var) = 1;\n-\t}\n+      bitmap_set_bit (*addresses_taken, DECL_UID (var));\n+      TREE_ADDRESSABLE (var) = 1;\n     }\n }\n "}, {"sha": "b9afe3b22e3d2abc70d562ecdfaa06e54de6711a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 15, "deletions": 70, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -4713,88 +4713,35 @@ set_uids_in_ptset (tree ptr, bitmap into, bitmap from, bool is_derefed,\n {\n   unsigned int i;\n   bitmap_iterator bi;\n-  alias_set_type ptr_alias_set;\n \n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (ptr)));\n-  ptr_alias_set = get_alias_set (TREE_TYPE (TREE_TYPE (ptr)));\n \n   EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n-      alias_set_type var_alias_set;\n \n       /* The only artificial variables that are allowed in a may-alias\n \t set are heap variables.  */\n       if (vi->is_artificial_var && !vi->is_heap_var)\n \tcontinue;\n \n-      if (vi->has_union && get_subvars_for_var (vi->decl) != NULL)\n+      if (TREE_CODE (vi->decl) == VAR_DECL\n+\t  || TREE_CODE (vi->decl) == PARM_DECL\n+\t  || TREE_CODE (vi->decl) == RESULT_DECL)\n \t{\n-\t  unsigned int i;\n-\t  tree subvar;\n-\t  subvar_t sv = get_subvars_for_var (vi->decl);\n-\n-\t  /* Variables containing unions may need to be converted to\n-\t     their SFT's, because SFT's can have unions and we cannot.  */\n-\t  for (i = 0; VEC_iterate (tree, sv, i, subvar); ++i)\n-\t    bitmap_set_bit (into, DECL_UID (subvar));\n-\t}\n-      else if (TREE_CODE (vi->decl) == VAR_DECL\n-\t       || TREE_CODE (vi->decl) == PARM_DECL\n-\t       || TREE_CODE (vi->decl) == RESULT_DECL)\n-\t{\n-\t  subvar_t sv;\n-\t  if (var_can_have_subvars (vi->decl)\n-\t      && (sv = get_subvars_for_var (vi->decl)))\n-\t    {\n-\t      /* If VI->DECL is an aggregate for which we created\n-\t\t SFTs, add the SFT corresponding to VI->OFFSET.\n-\t\t If we didn't do field-sensitive PTA we need to to\n-\t\t add all overlapping SFTs.  */\n-\t      unsigned int j;\n-\t      tree sft = get_first_overlapping_subvar (sv, vi->offset,\n-\t\t\t\t\t\t       vi->size, &j);\n-\t      gcc_assert (sft);\n-\t      for (; VEC_iterate (tree, sv, j, sft); ++j)\n-\t\t{\n-\t\t  if (SFT_OFFSET (sft) > vi->offset\n-\t\t      && vi->size <= SFT_OFFSET (sft) - vi->offset)\n-\t\t    break;\n-\n-\t\t  var_alias_set = get_alias_set (sft);\n-\t\t  if (no_tbaa_pruning\n-\t\t      || (!is_derefed && !vi->directly_dereferenced)\n-\t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n-\t\t    {\n-\t\t      bitmap_set_bit (into, DECL_UID (sft));\n-\t\t      \n-\t\t      /* Pointed-to SFTs are needed by the operand scanner\n-\t\t\t to adjust offsets when adding operands to memory\n-\t\t\t expressions that dereference PTR.  This means\n-\t\t\t that memory partitioning may not partition\n-\t\t\t this SFT because the operand scanner will not\n-\t\t\t be able to find the other SFTs next to this\n-\t\t\t one.  But we only need to do this if the pointed\n-\t\t\t to type is aggregate.  */\n-\t\t      if (SFT_BASE_FOR_COMPONENTS_P (sft))\n-\t\t\tSFT_UNPARTITIONABLE_P (sft) = true;\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  /* Just add VI->DECL to the alias set.\n+\t     Don't type prune artificial vars.  */\n+\t  if (vi->is_artificial_var)\n+\t    bitmap_set_bit (into, DECL_UID (vi->decl));\n \t  else\n \t    {\n-\t      /* Otherwise, just add VI->DECL to the alias set.\n-\t\t Don't type prune artificial vars.  */\n-\t      if (vi->is_artificial_var)\n-\t\tbitmap_set_bit (into, DECL_UID (vi->decl));\n-\t      else\n-\t\t{\n-\t\t  var_alias_set = get_alias_set (vi->decl);\n-\t\t  if (no_tbaa_pruning\n-\t\t      || (!is_derefed && !vi->directly_dereferenced)\n-\t\t      || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n-\t\t    bitmap_set_bit (into, DECL_UID (vi->decl));\n-\t\t}\n+\t      alias_set_type var_alias_set, ptr_alias_set;\n+\t      var_alias_set = get_alias_set (vi->decl);\n+\t      ptr_alias_set = get_alias_set (TREE_TYPE (TREE_TYPE (ptr)));\n+\t      if (no_tbaa_pruning\n+\t\t  || (!is_derefed && !vi->directly_dereferenced)\n+\t\t  || alias_sets_conflict_p (ptr_alias_set, var_alias_set))\n+\t        bitmap_set_bit (into, DECL_UID (vi->decl));\n \t    }\n \t}\n     }\n@@ -4923,9 +4870,7 @@ find_what_p_points_to (tree p)\n \t  /* Nothing currently asks about structure fields directly,\n \t     but when they do, we need code here to hand back the\n \t     points-to set.  */\n-\t  if (!var_can_have_subvars (vi->decl)\n-\t      || get_subvars_for_var (vi->decl) == NULL)\n-\t    return false;\n+\t  return false;\n \t}\n       else\n \t{"}, {"sha": "42d4e4952e8766d9a46866c8481650a512ce83b7", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -254,13 +254,6 @@ verify_ssa_name (tree ssa_name, bool is_virtual)\n       return true;\n     }\n \n-  if (is_virtual && var_ann (SSA_NAME_VAR (ssa_name)) \n-      && get_subvars_for_var (SSA_NAME_VAR (ssa_name)) != NULL)\n-    {\n-      error (\"found real variable when subvariables should have appeared\");\n-      return true;\n-    }\n-\n   if (SSA_NAME_IS_DEFAULT_DEF (ssa_name)\n       && !IS_EMPTY_STMT (SSA_NAME_DEF_STMT (ssa_name)))\n     {"}, {"sha": "7481de593252ee3d4e0e984ccdb0f37d5a464f0a", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -144,7 +144,7 @@ suitable_for_tail_opt_p (void)\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n       if (!is_global_var (var)\n-\t  && (!MTAG_P (var) || TREE_CODE (var) == STRUCT_FIELD_TAG)\n+\t  && !MTAG_P (var)\n \t  && (gimple_aliases_computed_p (cfun) ? is_call_clobbered (var)\n \t      : TREE_ADDRESSABLE (var)))\n \treturn false;"}, {"sha": "cc489811006ed7be682f5789cfecde67c5076c2e", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -1061,8 +1061,6 @@ vect_create_data_ref_ptr (tree stmt, struct loop *at_loop,\n   else\n     set_symbol_mem_tag (vect_ptr, tag);\n \n-  var_ann (vect_ptr)->subvars = DR_SUBVARS (dr);\n-\n   /** Note: If the dataref is in an inner-loop nested in LOOP, and we are\n       vectorizing LOOP (i.e. outer-loop vectorization), we need to create two\n       def-use update cycles for the pointer: One relative to the outer-loop"}, {"sha": "933a2451b9fb5d3cdd640f1cc11506ddbce3e39e", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -263,17 +263,14 @@ init_ttree (void)\n   tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[LABEL_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[FIELD_DECL][TS_DECL_MINIMAL] = 1;\n-  tree_contains_struct[STRUCT_FIELD_TAG][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[NAME_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[SYMBOL_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[MEMORY_PARTITION_TAG][TS_DECL_MINIMAL] = 1;\n \n-  tree_contains_struct[STRUCT_FIELD_TAG][TS_MEMORY_TAG] = 1;\n   tree_contains_struct[NAME_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n   tree_contains_struct[SYMBOL_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n   tree_contains_struct[MEMORY_PARTITION_TAG][TS_MEMORY_TAG] = 1;\n \n-  tree_contains_struct[STRUCT_FIELD_TAG][TS_STRUCT_FIELD_TAG] = 1;\n   tree_contains_struct[MEMORY_PARTITION_TAG][TS_MEMORY_PARTITION_TAG] = 1;\n \n   tree_contains_struct[VAR_DECL][TS_DECL_WITH_VIS] = 1;\n@@ -370,8 +367,6 @@ tree_code_size (enum tree_code code)\n \t  case NAME_MEMORY_TAG:\n \t  case SYMBOL_MEMORY_TAG:\n \t    return sizeof (struct tree_memory_tag);\n-\t  case STRUCT_FIELD_TAG:\n-\t    return sizeof (struct tree_struct_field_tag);\n \t  case MEMORY_PARTITION_TAG:\n \t    return sizeof (struct tree_memory_partition_tag);\n \t  default:\n@@ -2289,7 +2284,6 @@ tree_node_structure (const_tree t)\n \t    return TS_FUNCTION_DECL;\n \t  case SYMBOL_MEMORY_TAG:\n \t  case NAME_MEMORY_TAG:\n-\t  case STRUCT_FIELD_TAG:\n \t  case MEMORY_PARTITION_TAG:\n \t    return TS_MEMORY_TAG;\n \t  default:"}, {"sha": "7eb55b647b5a6f7cb19870e522aa23575922c359", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -363,7 +363,6 @@ DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n \n /* Memory tags used in tree-ssa to represent memory locations in\n    virtual SSA.  */\n-DEFTREECODE (STRUCT_FIELD_TAG, \"struct_field_tag\", tcc_declaration, 0)\n DEFTREECODE (NAME_MEMORY_TAG, \"name_memory_tag\", tcc_declaration, 0)\n DEFTREECODE (SYMBOL_MEMORY_TAG, \"symbol_memory_tag\", tcc_declaration, 0)\n DEFTREECODE (MEMORY_PARTITION_TAG, \"memory_partition_tag\", tcc_declaration, 0)"}, {"sha": "3f1e7b69e128cdfc6b3ed5350ca6daef32346aaa", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5611cf0bf55f808d6f33fdf3ba44e9cbdfa1788b", "patch": "@@ -109,8 +109,7 @@ extern const enum tree_code_class tree_code_type[];\n /* Nonzero if CODE represents a memory tag.  */\n \n #define MTAG_P(CODE) \\\n-  (TREE_CODE (CODE) == STRUCT_FIELD_TAG\t\t\\\n-   || TREE_CODE (CODE) == NAME_MEMORY_TAG\t\\\n+  (TREE_CODE (CODE) == NAME_MEMORY_TAG\t\t\\\n    || TREE_CODE (CODE) == SYMBOL_MEMORY_TAG\t\\\n    || TREE_CODE (CODE) == MEMORY_PARTITION_TAG)\n \n@@ -2544,45 +2543,11 @@ struct tree_memory_tag GTY(())\n \n   /* True if this tag has global scope.  */\n   unsigned int is_global : 1;\n-\n-  /* True if this tag is the first field of an aggregate type that\n-     can be used to find adjacent SFTs belonging to the same aggregate.  */\n-  unsigned int base_for_components : 1;\n-\n-  /* True if this tag should not be grouped into a memory partition.  */\n-  unsigned int unpartitionable : 1;\n };\n \n #define MTAG_GLOBAL(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.is_global)\n #define MTAG_ALIASES(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.aliases)\n \n-struct tree_struct_field_tag GTY(())\n-{\n-  struct tree_memory_tag common;\n-\n-  /* Parent variable.  */\n-  tree parent_var;\n-\n-  /* Offset inside structure.  */\n-  unsigned HOST_WIDE_INT offset;\n-\n-  /* Size of the field.  */\n-  unsigned HOST_WIDE_INT size;\n-\n-  /* Alias set for a DECL_NONADDRESSABLE_P field.  Otherwise -1.  */\n-  alias_set_type alias_set;\n-};\n-#define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.parent_var)\n-#define SFT_OFFSET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.offset)\n-#define SFT_SIZE(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.size)\n-#define SFT_NONADDRESSABLE_P(NODE) \\\n-  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set != -1)\n-#define SFT_ALIAS_SET(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->sft.alias_set)\n-#define SFT_UNPARTITIONABLE_P(NODE) \\\n-  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.common.unpartitionable)\n-#define SFT_BASE_FOR_COMPONENTS_P(NODE) \\\n-  (STRUCT_FIELD_TAG_CHECK (NODE)->sft.common.base_for_components)\n-\n /* Memory Partition Tags (MPTs) group memory symbols under one\n    common name for the purposes of placing memory PHI nodes.  */\n \n@@ -3480,7 +3445,6 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n   struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n   struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n-  struct tree_struct_field_tag GTY ((tag (\"TS_STRUCT_FIELD_TAG\"))) sft;\n   struct tree_omp_clause GTY ((tag (\"TS_OMP_CLAUSE\"))) omp_clause;\n   struct tree_memory_partition_tag GTY ((tag (\"TS_MEMORY_PARTITION_TAG\"))) mpt;\n };"}]}