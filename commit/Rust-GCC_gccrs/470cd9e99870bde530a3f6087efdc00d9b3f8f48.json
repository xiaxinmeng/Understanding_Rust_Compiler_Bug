{"sha": "470cd9e99870bde530a3f6087efdc00d9b3f8f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcwY2Q5ZTk5ODcwYmRlNTMwYTNmNjA4N2VmZGMwMGQ5YjNmOGY0OA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:21:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:21:30Z"}, "message": "a-ngcoty.adb: New pragma Fast_Math\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* a-ngcoty.adb: New pragma Fast_Math\n\n\t* opt.adb: New pragma Fast_Math\n\n\t* par-prag.adb: \n\tAdd Implemented_By_Entry to the list of pragmas which do not require any\n\tspecial processing.\n\t(Favor_Top_Level): New pragma.\n\tNew pragma Fast_Math\n\n\t* exp_attr.adb: Move Wide_[Wide_]Image routines to Exp_Imgv\n\t(Expand_N_Attribute_Reference, Displace_Allocator_Pointer,\n\tExpand_Allocator_Expression): Take into account VM_Target\n\t(Expand_Attribute, case 'Identity):  Handle properly the case where\n\tthe prefix is a task interface.\n\tNew pragma Fast_Math\n\n\t* par.adb (Next_Token_Is): New function\n\t(P_Pragma): Add Skipping parameter\n\t(U_Left_Paren): New procedure\n\t(U_Right_Paren): New procedure\n\tNew pragma Fast_Math\n\n\t* par-ch10.adb (P_Subunit): Unconditional msg for missing ) after\n\tsubunit\n\tNew pragma Fast_Math\n\n\t* sem_prag.adb: Add significance value to table Sig_Flag for pragma\n\tImplemented_By_Entry.\n\t(Analyze_Pragma): Add case for Ada 2005 pragma Implemented_By_Entry.\n\t(Set_Inline_Flags): Do not try to link pragma Inline onto chain of rep\n\titems, since it can apply to more than one overloadable entity. Set\n\tnew flag Has_Pragma_Inline_Always for Inline_Always case.\n\t(Analyze_Pragma, case Complex_Representation): Improve error message.\n\t(Analyze_Pragma, case Assert): When assertions are disabled build the\n\trewritten code with Sloc of expression rather than pragma, so new\n\twarning about failing is not deleted.\n\t(Analyze_Pragma): Allow pragma Preelaborable_Initialization to apply to\n\tprotected types and update error message to reflect that. Test whether\n\tthe protected type is allowed for the pragma (an error is issued if the\n\ttype has any entries, or components that do not have preelaborable\n\tinitialization).\n\tNew pragma Fast_Math\n\t(Analyze_Pragma, case No_Return): Handle generic instance\n\n\t* snames.h, snames.ads, snames.adb: \n\tAdd new predefined name for interface primitive _Disp_Requeue.\n\tNew pragma Fast_Math\n\n\t* a-tags.ads, a-tags.adb: New calling sequence for\n\tString_To_Wide_[Wide_]String\n\t(Secondary_Tag): New subprogram.\n\n\t* exp_imgv.ads, exp_imgv.adb: Move Wide_[Wide_]Image routines here\n\tfrom Exp_Attr\n\tNew calling sequence for String_To_Wide_[Wide_]String\n\t(Expand_Image_Attribute): Major rewrite. New calling sequence avoids\n\tthe use of the secondary stack for image routines.\n\n\t* a-except-2005.adb, s-wchstw.ads, s-wchstw.adb, s-wwdenu.adb: New\n\tcalling sequence for String_To_Wide_[Wide_]String\n\n\t* par-ch3.adb (P_Declarative_Items): Recognize use of Overriding in\n\tAda 95 mode\n\t(P_Unknown_Discriminant_Part_Opt): Handle missing parens gracefully\n\tRemove Atree.Delete_Tree/Delete_Node and Nlist.Delete_List\n\n\t* par-ch6.adb (P_Subprogram): Recognize use of Overriding in Ada 95 mode\n\t(P_Formal_Part): Use Skipping parameter in P_Pragma call\n\tto improve error recovery\n\n\t* par-util.adb (Next_Token_Is): New function\n\t(Signal_Bad_Attribute): Use new Namet.Is_Bad_Spelling_Of function\n\n\t* par-ch2.adb (Skip_Pragma_Semicolon): Do not resynchronize to\n\tsemicolon if missing\n\t(P_Pragma): Implement new Skipping parameter\n\tRemove Atree.Delete_Tree/Delete_Node and Nlist.Delete_List\n\tFix location of flag for unrecognized pragma message\n\n\t* par-tchk.adb (U_Left_Paren): New procedure\n\t(U_Right_Paren): New procedure\n\nFrom-SVN: r130818", "tree": {"sha": "fe74bc1bf6eab08387b00192686ada41e98ef0ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe74bc1bf6eab08387b00192686ada41e98ef0ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/470cd9e99870bde530a3f6087efdc00d9b3f8f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/470cd9e99870bde530a3f6087efdc00d9b3f8f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/470cd9e99870bde530a3f6087efdc00d9b3f8f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/470cd9e99870bde530a3f6087efdc00d9b3f8f48/comments", "author": null, "committer": null, "parents": [{"sha": "b917101e1c2a5318471e217e04f280023cd48c6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b917101e1c2a5318471e217e04f280023cd48c6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b917101e1c2a5318471e217e04f280023cd48c6a"}], "stats": {"total": 3499, "additions": 2072, "deletions": 1427}, "files": [{"sha": "69e6406a634c9cb0effb914343c4f08ac857e0d9", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -1359,17 +1359,27 @@ package body Ada.Exceptions is\n    --  Encoding method for source, as exported by binder\n \n    function Wide_Exception_Name\n-     (Id : Exception_Id) return Wide_String is\n+     (Id : Exception_Id) return Wide_String\n+   is\n+      S : constant String := Exception_Name (Id);\n+      W : Wide_String (1 .. S'Length);\n+      L : Natural;\n    begin\n-      return String_To_Wide_String\n-        (Exception_Name (Id), Get_WC_Encoding_Method (WC_Encoding));\n+      String_To_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n    end Wide_Exception_Name;\n \n    function Wide_Exception_Name\n-     (X : Exception_Occurrence) return Wide_String is\n+     (X : Exception_Occurrence) return Wide_String\n+   is\n+      S : constant String := Exception_Name (X);\n+      W : Wide_String (1 .. S'Length);\n+      L : Natural;\n    begin\n-      return String_To_Wide_String\n-        (Exception_Name (X), Get_WC_Encoding_Method (WC_Encoding));\n+      String_To_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n    end Wide_Exception_Name;\n \n    ----------------------------\n@@ -1379,17 +1389,25 @@ package body Ada.Exceptions is\n    function Wide_Wide_Exception_Name\n      (Id : Exception_Id) return Wide_Wide_String\n    is\n+      S : constant String := Exception_Name (Id);\n+      W : Wide_Wide_String (1 .. S'Length);\n+      L : Natural;\n    begin\n-      return String_To_Wide_Wide_String\n-        (Exception_Name (Id), Get_WC_Encoding_Method (WC_Encoding));\n+      String_To_Wide_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n    end Wide_Wide_Exception_Name;\n \n    function Wide_Wide_Exception_Name\n      (X : Exception_Occurrence) return Wide_Wide_String\n    is\n+      S : constant String := Exception_Name (X);\n+      W : Wide_Wide_String (1 .. S'Length);\n+      L : Natural;\n    begin\n-      return String_To_Wide_Wide_String\n-        (Exception_Name (X), Get_WC_Encoding_Method (WC_Encoding));\n+      String_To_Wide_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n    end Wide_Wide_Exception_Name;\n \n    --------------------------"}, {"sha": "502a47d15ccf78c822e3a0347226343e3c2bba2c", "filename": "gcc/ada/a-ngcoty.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-ngcoty.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-ngcoty.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ngcoty.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -52,16 +52,18 @@ package body Ada.Numerics.Generic_Complex_Types is\n       X := Left.Re * Right.Re - Left.Im * Right.Im;\n       Y := Left.Re * Right.Im + Left.Im * Right.Re;\n \n-      --  If either component overflows, try to scale\n+      --  If either component overflows, try to scale (skip in fast math mode)\n \n-      if abs (X) > R'Last then\n-         X := R'(4.0) * (R'(Left.Re / 2.0)  * R'(Right.Re / 2.0)\n-                - R'(Left.Im / 2.0) * R'(Right.Im / 2.0));\n-      end if;\n+      if not Standard'Fast_Math then\n+         if abs (X) > R'Last then\n+            X := R'(4.0) * (R'(Left.Re / 2.0)  * R'(Right.Re / 2.0)\n+                            - R'(Left.Im / 2.0) * R'(Right.Im / 2.0));\n+         end if;\n \n-      if abs (Y) > R'Last then\n-         Y := R'(4.0) * (R'(Left.Re / 2.0)  * R'(Right.Im / 2.0)\n-                - R'(Left.Im / 2.0) * R'(Right.Re / 2.0));\n+         if abs (Y) > R'Last then\n+            Y := R'(4.0) * (R'(Left.Re / 2.0)  * R'(Right.Im / 2.0)\n+                            - R'(Left.Im / 2.0) * R'(Right.Re / 2.0));\n+         end if;\n       end if;\n \n       return (X, Y);\n@@ -143,7 +145,6 @@ package body Ada.Numerics.Generic_Complex_Types is\n          --  1.0 / infinity, and the closest model number will be zero.\n \n          begin\n-\n             while Exp /= 0 loop\n                if Exp rem 2 /= 0 then\n                   Result := Result * Factor;\n@@ -156,7 +157,6 @@ package body Ada.Numerics.Generic_Complex_Types is\n             return R'(1.0) / Result;\n \n          exception\n-\n             when Constraint_Error =>\n                return (0.0, 0.0);\n          end;"}, {"sha": "522a826fc068964feca4b6ee34cb74cb1bd2d4c3", "filename": "gcc/ada/a-tags.adb", "status": "modified", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -318,6 +318,21 @@ package body Ada.Tags is\n       return This - Offset_To_Top (This);\n    end Base_Address;\n \n+   --------------------\n+   -- Descendant_Tag --\n+   --------------------\n+\n+   function Descendant_Tag (External : String; Ancestor : Tag) return Tag is\n+      Int_Tag : constant Tag := Internal_Tag (External);\n+\n+   begin\n+      if not Is_Descendant_At_Same_Level (Int_Tag, Ancestor) then\n+         raise Tag_Error;\n+      end if;\n+\n+      return Int_Tag;\n+   end Descendant_Tag;\n+\n    --------------\n    -- Displace --\n    --------------\n@@ -434,21 +449,6 @@ package body Ada.Tags is\n       return False;\n    end IW_Membership;\n \n-   --------------------\n-   -- Descendant_Tag --\n-   --------------------\n-\n-   function Descendant_Tag (External : String; Ancestor : Tag) return Tag is\n-      Int_Tag : constant Tag := Internal_Tag (External);\n-\n-   begin\n-      if not Is_Descendant_At_Same_Level (Int_Tag, Ancestor) then\n-         raise Tag_Error;\n-      end if;\n-\n-      return Int_Tag;\n-   end Descendant_Tag;\n-\n    -------------------\n    -- Expanded_Name --\n    -------------------\n@@ -846,6 +846,35 @@ package body Ada.Tags is\n       External_Tag_HTable.Set (T);\n    end Register_Tag;\n \n+   -------------------\n+   -- Secondary_Tag --\n+   -------------------\n+\n+   function Secondary_Tag (T, Iface : Tag) return Tag is\n+      Iface_Table : Interface_Data_Ptr;\n+      Obj_DT      : Dispatch_Table_Ptr;\n+\n+   begin\n+      if not Is_Primary_DT (T) then\n+         raise Program_Error;\n+      end if;\n+\n+      Obj_DT      := DT (T);\n+      Iface_Table := To_Type_Specific_Data_Ptr (Obj_DT.TSD).Interfaces_Table;\n+\n+      if Iface_Table /= null then\n+         for Id in 1 .. Iface_Table.Nb_Ifaces loop\n+            if Iface_Table.Ifaces_Table (Id).Iface_Tag = Iface then\n+               return Iface_Table.Ifaces_Table (Id).Secondary_DT;\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  If the object does not implement the interface we must raise CE\n+\n+      raise Constraint_Error with \"invalid interface conversion\";\n+   end Secondary_Tag;\n+\n    ---------------------\n    -- Set_Entry_Index --\n    ---------------------\n@@ -948,19 +977,27 @@ package body Ada.Tags is\n    --  Encoding method for source, as exported by binder\n \n    function Wide_Expanded_Name (T : Tag) return Wide_String is\n+      S : constant String := Expanded_Name (T);\n+      W : Wide_String (1 .. S'Length);\n+      L : Natural;\n    begin\n-      return String_To_Wide_String\n-        (Expanded_Name (T), Get_WC_Encoding_Method (WC_Encoding));\n+      String_To_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n    end Wide_Expanded_Name;\n \n    -----------------------------\n    -- Wide_Wide_Expanded_Name --\n    -----------------------------\n \n    function Wide_Wide_Expanded_Name (T : Tag) return Wide_Wide_String is\n+      S : constant String := Expanded_Name (T);\n+      W : Wide_Wide_String (1 .. S'Length);\n+      L : Natural;\n    begin\n-      return String_To_Wide_Wide_String\n-        (Expanded_Name (T), Get_WC_Encoding_Method (WC_Encoding));\n+      String_To_Wide_Wide_String\n+        (S, W, L, Get_WC_Encoding_Method (WC_Encoding));\n+      return W (1 .. L);\n    end Wide_Wide_Expanded_Name;\n \n end Ada.Tags;"}, {"sha": "1fc31e8a2337fb80dd25e61cd7560f71b5b5d0e0", "filename": "gcc/ada/a-tags.ads", "status": "modified", "additions": 50, "deletions": 24, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tags.ads?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -122,25 +122,23 @@ private\n \n    --  Structure of the GNAT Secondary Dispatch Table\n \n-   --           +-----------------------+\n-   --           |       table of        |\n-   --           :  predefined primitive :\n-   --           |     ops pointers      |\n-   --           +-----------------------+\n-   --           |       Signature       |\n-   --           +-----------------------+\n-   --           |      Tagged_Kind      |\n-   --           +-----------------------+\n-   --           |     Offset_To_Top     |\n-   --           +-----------------------+\n-   --           |        OSD_Ptr        |---> Object Specific Data\n-   --  Tag ---> +-----------------------+      +---------------+\n-   --           |        table of       |      | num prim ops  |\n-   --           :      primitive op     :      +---------------+\n-   --           |     thunk pointers    |      | table of      |\n-   --           +-----------------------+      +   primitive   |\n-   --                                          |    op offsets |\n-   --                                          +---------------+\n+   --           +--------------------+\n+   --           |      Signature     |\n+   --           +--------------------+\n+   --           |     Tagged_Kind    |\n+   --           +--------------------+                            Predef Prims\n+   --           |    Predef_Prims -----------------------------> +------------+\n+   --           +--------------------+                           |  table of  |\n+   --           |    Offset_To_Top   |                           | predefined |\n+   --           +--------------------+                           | primitives |\n+   --           |       OSD_Ptr      |---> Object Specific Data  |   thunks   |\n+   --  Tag ---> +--------------------+      +---------------+    +------------+\n+   --           |      table of      |      | num prim ops  |\n+   --           :    primitive op    :      +---------------+\n+   --           |   thunk pointers   |      | table of      |\n+   --           +--------------------+      +   primitive   |\n+   --                                       |    op offsets |\n+   --                                       +---------------+\n \n    --  The runtime information kept for each tagged type is separated into two\n    --  objects: the Dispatch Table and the Type Specific Data record.\n@@ -165,12 +163,18 @@ private\n       Static_Offset_To_Top : Boolean;\n       Offset_To_Top_Value  : SSE.Storage_Offset;\n       Offset_To_Top_Func   : Offset_To_Top_Function_Ptr;\n+      Secondary_DT         : Tag;\n    end record;\n    --  If some ancestor of the tagged type has discriminants the field\n    --  Static_Offset_To_Top is False and the field Offset_To_Top_Func\n    --  is used to store the access to the function generated by the\n    --  expander which provides this value; otherwise Static_Offset_To_Top\n    --  is True and such value is stored in the Offset_To_Top_Value field.\n+   --  Secondary_DT references a secondary dispatch table whose contents\n+   --  are pointers to the primitives of the tagged type that cover the\n+   --  interface primitives. Secondary_DT gives support to dispatching\n+   --  calls through interface types associated with Generic Dispatching\n+   --  Constructors.\n \n    type Interfaces_Array is array (Natural range <>) of Interface_Data_Element;\n \n@@ -398,6 +402,11 @@ private\n    --  Ada 2005 (AI-251): Displace \"This\" to point to the secondary dispatch\n    --  table of T.\n \n+   function Secondary_Tag (T, Iface : Tag) return Tag;\n+   --  Ada 2005 (AI-251): Given a primary tag T associated with a tagged type\n+   --  Typ, search for the secondary tag of the interface type Iface covered\n+   --  by Typ.\n+\n    function DT (T : Tag) return Dispatch_Table_Ptr;\n    --  Return the pointer to the TSD record associated with T\n \n@@ -495,16 +504,33 @@ private\n    --  Ada 2005 (AI-251): Set the kind of a primitive operation in T's TSD\n    --  table indexed by Position.\n \n-   Max_Predef_Prims : constant Positive := 15;\n-   --  Number of reserved slots for predefined ada primitives: Size, Alignment,\n-   --  Read, Write, Input, Output, \"=\", assignment, deep adjust, deep finalize,\n-   --  async select, conditional select, prim_op kind, task_id, and timed\n-   --  select. The compiler checks that this value is correct.\n+   Max_Predef_Prims : constant Positive := 16;\n+   --  Number of reserved slots for the following predefined ada primitives:\n+   --\n+   --    1. Size\n+   --    2. Alignment,\n+   --    3. Read\n+   --    4. Write\n+   --    5. Input\n+   --    6. Output\n+   --    7. \"=\"\n+   --    8. assignment\n+   --    9. deep adjust\n+   --   10. deep finalize\n+   --   11. async select\n+   --   12. conditional select\n+   --   13. prim_op kind\n+   --   14. task_id\n+   --   15. dispatching requeue\n+   --   16. timed select\n+   --\n+   --  The compiler checks that the value here is correct\n \n    subtype Predef_Prims_Table  is Address_Array (1 .. Max_Predef_Prims);\n    type Predef_Prims_Table_Ptr is access Predef_Prims_Table;\n    pragma No_Strict_Aliasing (Predef_Prims_Table_Ptr);\n \n    type Addr_Ptr is access System.Address;\n    pragma No_Strict_Aliasing (Addr_Ptr);\n+   --  Why is this needed ???\n end Ada.Tags;"}, {"sha": "4baf55e7e57290590a56fad73b9717e7f107e26d", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 44, "deletions": 63, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -129,7 +129,7 @@ package body Exp_Attr is\n    --  operand with overflow checking required.\n \n    function Get_Index_Subtype (N : Node_Id) return Entity_Id;\n-   --  Used for Last, Last, and Length, when the prefix is an array type,\n+   --  Used for Last, Last, and Length, when the prefix is an array type.\n    --  Obtains the corresponding index subtype.\n \n    procedure Find_Fat_Info\n@@ -838,8 +838,12 @@ package body Exp_Attr is\n          --  generate a call to a run-time subprogram that returns the base\n          --  address of the object.\n \n+         --  This processing is not needed in the VM case, where dispatching\n+         --  issues are taken care of by the virtual machine.\n+\n          elsif Is_Class_Wide_Type (Etype (Pref))\n            and then Is_Interface (Etype (Pref))\n+           and then VM_Target = No_VM\n            and then not (Nkind (Pref) in N_Has_Entity\n                           and then Is_Subprogram (Entity (Pref)))\n          then\n@@ -1923,8 +1927,27 @@ package body Exp_Attr is\n          else\n             Id_Kind := RTE (RO_AT_Task_Id);\n \n-            Rewrite (N,\n-              Unchecked_Convert_To (Id_Kind, Concurrent_Ref (Pref)));\n+            --  If the prefix is a task interface, the Task_Id is obtained\n+            --  dynamically through a dispatching call, as for other task\n+            --  attributes applied to interfaces.\n+\n+            if Ada_Version >= Ada_05\n+              and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n+              and then Is_Interface (Etype (Pref))\n+              and then Is_Task_Interface (Etype (Pref))\n+            then\n+               Rewrite (N,\n+                 Unchecked_Convert_To (Id_Kind,\n+                   Make_Selected_Component (Loc,\n+                     Prefix =>\n+                       New_Copy_Tree (Pref),\n+                     Selector_Name =>\n+                       Make_Identifier (Loc, Name_uDisp_Get_Task_Id))));\n+\n+            else\n+               Rewrite (N,\n+                 Unchecked_Convert_To (Id_Kind, Concurrent_Ref (Pref)));\n+            end if;\n          end if;\n \n          Analyze_And_Resolve (N, Id_Kind);\n@@ -4052,13 +4075,17 @@ package body Exp_Attr is\n             --  Note that Prefix'Address is recursively expanded into a call\n             --  to Base_Address (Obj.Tag)\n \n-            Rewrite (N,\n-              Make_Explicit_Dereference (Loc,\n-                Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix => Relocate_Node (Pref),\n-                    Attribute_Name => Name_Address))));\n-            Analyze_And_Resolve (N, RTE (RE_Tag));\n+            --  Not needed for VM targets, since all handled by the VM\n+\n+            if VM_Target = No_VM then\n+               Rewrite (N,\n+                 Make_Explicit_Dereference (Loc,\n+                   Unchecked_Convert_To (RTE (RE_Tag_Ptr),\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => Relocate_Node (Pref),\n+                       Attribute_Name => Name_Address))));\n+               Analyze_And_Resolve (N, RTE (RE_Tag));\n+            end if;\n \n          else\n             Rewrite (N,\n@@ -4581,66 +4608,19 @@ package body Exp_Attr is\n       -- Wide_Image --\n       ----------------\n \n-      --  We expand typ'Wide_Image (X) into\n-\n-      --    String_To_Wide_String\n-      --      (typ'Image (X), Wide_Character_Encoding_Method)\n+      --  Wide_Image attribute is handled in separate unit Exp_Imgv\n \n-      --  This works in all cases because String_To_Wide_String converts any\n-      --  wide character escape sequences resulting from the Image call to the\n-      --  proper Wide_Character equivalent\n-\n-      --  not quite right for typ = Wide_Character ???\n-\n-      when Attribute_Wide_Image => Wide_Image :\n-      begin\n-         Rewrite (N,\n-           Make_Function_Call (Loc,\n-             Name => New_Reference_To (RTE (RE_String_To_Wide_String), Loc),\n-             Parameter_Associations => New_List (\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         => Pref,\n-                 Attribute_Name => Name_Image,\n-                 Expressions    => Exprs),\n-\n-               Make_Integer_Literal (Loc,\n-                 Intval => Int (Wide_Character_Encoding_Method)))));\n-\n-         Analyze_And_Resolve (N, Standard_Wide_String);\n-      end Wide_Image;\n+      when Attribute_Wide_Image =>\n+         Exp_Imgv.Expand_Wide_Image_Attribute (N);\n \n       ---------------------\n       -- Wide_Wide_Image --\n       ---------------------\n \n-      --  We expand typ'Wide_Wide_Image (X) into\n-\n-      --    String_To_Wide_Wide_String\n-      --      (typ'Image (X), Wide_Character_Encoding_Method)\n-\n-      --  This works in all cases because String_To_Wide_Wide_String converts\n-      --  any wide character escape sequences resulting from the Image call to\n-      --  the proper Wide_Character equivalent\n-\n-      --  not quite right for typ = Wide_Wide_Character ???\n-\n-      when Attribute_Wide_Wide_Image => Wide_Wide_Image :\n-      begin\n-         Rewrite (N,\n-           Make_Function_Call (Loc,\n-             Name => New_Reference_To\n-               (RTE (RE_String_To_Wide_Wide_String), Loc),\n-             Parameter_Associations => New_List (\n-               Make_Attribute_Reference (Loc,\n-                 Prefix         => Pref,\n-                 Attribute_Name => Name_Image,\n-                 Expressions    => Exprs),\n-\n-               Make_Integer_Literal (Loc,\n-                 Intval => Int (Wide_Character_Encoding_Method)))));\n+      --  Wide_Wide_Image attribute is handled in separate unit Exp_Imgv\n \n-         Analyze_And_Resolve (N, Standard_Wide_Wide_String);\n-      end Wide_Wide_Image;\n+      when Attribute_Wide_Wide_Image =>\n+         Exp_Imgv.Expand_Wide_Wide_Image_Attribute (N);\n \n       ----------------\n       -- Wide_Value --\n@@ -4935,6 +4915,7 @@ package body Exp_Attr is\n            Attribute_Emax                         |\n            Attribute_Enabled                      |\n            Attribute_Epsilon                      |\n+           Attribute_Fast_Math                    |\n            Attribute_Has_Access_Values            |\n            Attribute_Has_Discriminants            |\n            Attribute_Large                        |"}, {"sha": "df3d7e8d33cf376234ed0b6bec075aadb43d723a", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 351, "deletions": 74, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -155,14 +155,23 @@ package body Exp_Imgv is\n    -- Expand_Image_Attribute --\n    ----------------------------\n \n-   --  For all non-enumeration types, and for enumeration types declared\n-   --  in packages Standard or System, typ'Image (Val) expands into:\n+   --  For all cases other than user defined enumeration types, the scheme\n+   --  is as follows. First we insert the following code:\n \n-   --     Image_xx (tp (Expr) [, pm])\n+   --    Snn : String (1 .. rt'Width);\n+   --    Pnn : Natural;\n+   --    Image_xx (tv, Snn, Pnn [,pm]);\n+   --\n+   --  and then Expr is replaced by Snn (1 .. Pnn)\n \n-   --  The name xx and type conversion tp (Expr) (called tv below) depend on\n-   --  the root type of Expr. The argument pm is an extra type dependent\n-   --  parameter only used in some cases as follows:\n+   --  In the above expansion:\n+\n+   --    rt is the root type of the expression\n+   --    tv is the expression with the value, usually a type conversion\n+   --    pm is an extra parameter present in some cases\n+\n+   --  The following table shows tv, xx, and (if used) pm for the various\n+   --  possible types of the argument:\n \n    --    For types whose root type is Character\n    --      xx = Character\n@@ -194,57 +203,103 @@ package body Exp_Imgv is\n    --      pm = Boolean, true if Ada 2005 mode, False otherwise\n \n    --    For types whose root type is Wide_Wide_Character\n-   --      xx = Wide_Wide_haracter\n+   --      xx = Wide_Wide_Character\n    --      tv = Wide_Wide_Character (Expr)\n \n    --    For floating-point types\n    --      xx = Floating_Point\n    --      tv = Long_Long_Float (Expr)\n-   --      pm = typ'Digits\n+   --      pm = typ'Digits (typ = subtype of expression)\n \n    --    For ordinary fixed-point types\n    --      xx = Ordinary_Fixed_Point\n    --      tv = Long_Long_Float (Expr)\n-   --      pm = typ'Aft\n+   --      pm = typ'Aft (typ = subtype of expression)\n \n    --    For decimal fixed-point types with size = Integer'Size\n    --      xx = Decimal\n    --      tv = Integer (Expr)\n-   --      pm = typ'Scale\n+   --      pm = typ'Scale (typ = subtype of expression)\n \n    --    For decimal fixed-point types with size > Integer'Size\n    --      xx = Long_Long_Decimal\n-   --      tv = Long_Long_Integer (Expr)\n-   --      pm = typ'Scale\n-\n-   --    Note: for the decimal fixed-point type cases, the conversion is\n-   --    done literally without scaling (i.e. the actual expression that\n-   --    is generated is Image_xx (tp?(Expr) [, pm])\n+   --      tv = Long_Long_Integer?(Expr) [convert with no scaling]\n+   --      pm = typ'Scale (typ = subtype of expression)\n \n    --  For enumeration types other than those declared packages Standard\n-   --  or System, typ'Image (X) expands into:\n+   --  or System, Snn, Pnn, are expanded as above, but the call looks like:\n+\n+   --    Image_Enumeration_NN (rt'Pos (X), Snn, Pnn, typS, typI'Address)\n \n-   --    Image_Enumeration_NN (typ'Pos (X), typS, typI'Address)\n+   --  where rt is the root type of the expression, and typS and typI are\n+   --  the entities constructed as described in the spec for the procedure\n+   --  Build_Enumeration_Image_Tables and NN is 32/16/8 depending on the\n+   --  element type of Lit_Indexes. The rewriting of the expression to\n+   --  Snn (1 .. Pnn) then occurs as in the other cases. A special case is\n+   --  when pragma Discard_Names applies, in which case we replace expr by:\n \n-   --  where typS and typI are the entities constructed as described in\n-   --  the spec for the procedure Build_Enumeration_Image_Tables and NN\n-   --  is 32/16/8 depending on the element type of Lit_Indexes.\n+   --    Missing ???\n \n    procedure Expand_Image_Attribute (N : Node_Id) is\n-      Loc      : constant Source_Ptr := Sloc (N);\n-      Exprs    : constant List_Id    := Expressions (N);\n-      Pref     : constant Node_Id    := Prefix (N);\n-      Ptyp     : constant Entity_Id  := Entity (Pref);\n-      Rtyp     : constant Entity_Id  := Root_Type (Ptyp);\n-      Expr     : constant Node_Id    := Relocate_Node (First (Exprs));\n-      Imid     : RE_Id;\n-      Tent     : Entity_Id;\n-      Arglist  : List_Id;\n-      Func     : RE_Id;\n-      Ttyp     : Entity_Id;\n-      Func_Ent : Entity_Id;\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Exprs     : constant List_Id    := Expressions (N);\n+      Pref      : constant Node_Id    := Prefix (N);\n+      Ptyp      : constant Entity_Id  := Entity (Pref);\n+      Rtyp      : constant Entity_Id  := Root_Type (Ptyp);\n+      Expr      : constant Node_Id    := Relocate_Node (First (Exprs));\n+      Imid      : RE_Id;\n+      Tent      : Entity_Id;\n+      Ttyp      : Entity_Id;\n+      Proc_Ent  : Entity_Id;\n+      Enum_Case : Boolean;\n+\n+      Arg_List : List_Id;\n+      --  List of arguments for run-time procedure call\n+\n+      Ins_List : List_Id;\n+      --  List of actions to be inserted\n+\n+      Snn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('S'));\n+\n+      Pnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('P'));\n \n    begin\n+      --  Build declarations of Snn and Pnn to be inserted\n+\n+      Ins_List := New_List (\n+\n+         --  Snn : String (1 .. typ'Width);\n+\n+         Make_Object_Declaration (Loc,\n+            Defining_Identifier => Snn,\n+            Object_Definition   =>\n+              Make_Subtype_Indication (Loc,\n+                Subtype_Mark => New_Occurrence_Of (Standard_String, Loc),\n+                Constraint   =>\n+                  Make_Index_Or_Discriminant_Constraint (Loc,\n+                    Constraints => New_List (\n+                      Make_Range (Loc,\n+                        Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                        High_Bound =>\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => New_Occurrence_Of (Rtyp, Loc),\n+                            Attribute_Name => Name_Width)))))),\n+\n+         --  Pnn : Natural;\n+\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => Pnn,\n+           Object_Definition   => New_Occurrence_Of (Standard_Natural, Loc)));\n+\n+      --  Set Imid (RE_Id of procedure to call), and Tent, target for the\n+      --  type conversion of the first argument for all possibilities.\n+\n+      Enum_Case := False;\n+\n       if Rtyp = Standard_Boolean then\n          Imid := RE_Image_Boolean;\n          Tent := Rtyp;\n@@ -315,104 +370,131 @@ package body Exp_Imgv is\n                 Attribute_Name =>\n                   Name_Img));\n             Analyze_And_Resolve (N, Standard_String);\n+            return;\n \n          else\n-            --  Here we get the Image of an enumeration type\n+            --  Here for enumeration type case\n \n             Ttyp := Component_Type (Etype (Lit_Indexes (Rtyp)));\n \n             if Ttyp = Standard_Integer_8 then\n-               Func := RE_Image_Enumeration_8;\n+               Imid := RE_Image_Enumeration_8;\n             elsif Ttyp = Standard_Integer_16  then\n-               Func := RE_Image_Enumeration_16;\n+               Imid := RE_Image_Enumeration_16;\n             else\n-               Func := RE_Image_Enumeration_32;\n+               Imid := RE_Image_Enumeration_32;\n             end if;\n \n-            --  Apply a validity check, since it is a bit drastic to\n-            --  get a completely junk image value for an invalid value.\n+            --  Apply a validity check, since it is a bit drastic to get a\n+            --  completely junk image value for an invalid value.\n \n             if not Expr_Known_Valid (Expr) then\n                Insert_Valid_Check (Expr);\n             end if;\n \n-            Rewrite (N,\n-              Make_Function_Call (Loc,\n-                Name => New_Occurrence_Of (RTE (Func), Loc),\n-                Parameter_Associations => New_List (\n-                  Make_Attribute_Reference (Loc,\n-                    Attribute_Name => Name_Pos,\n-                    Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-                    Expressions    => New_List (Expr)),\n-                  New_Occurrence_Of (Lit_Strings (Rtyp), Loc),\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix => New_Occurrence_Of (Lit_Indexes (Rtyp), Loc),\n-                    Attribute_Name => Name_Address))));\n-\n-            Analyze_And_Resolve (N, Standard_String);\n+            Enum_Case := True;\n          end if;\n+      end if;\n \n-         return;\n+      --  Build first argument for call\n+\n+      if Enum_Case then\n+         Arg_List := New_List (\n+           Make_Attribute_Reference (Loc,\n+             Attribute_Name => Name_Pos,\n+             Prefix         => New_Occurrence_Of (Ptyp, Loc),\n+             Expressions    => New_List (Expr)));\n+\n+      else\n+         Arg_List := New_List (Convert_To (Tent, Expr));\n       end if;\n \n-      --  If we fall through, we have one of the cases that is handled by\n-      --  calling one of the System.Img_xx routines and Imid is set to the\n-      --  RE_Id for the function to be called.\n+      --  Append Snn, Pnn arguments\n \n-      Func_Ent := RTE (Imid);\n+      Append_To (Arg_List, New_Occurrence_Of (Snn, Loc));\n+      Append_To (Arg_List, New_Occurrence_Of (Pnn, Loc));\n \n-      --  If the function entity is empty, that means we have a case in\n+      --  Get entity of procedure to call\n+\n+      Proc_Ent := RTE (Imid);\n+\n+      --  If the procedure entity is empty, that means we have a case in\n       --  no run time mode where the operation is not allowed, and an\n       --  appropriate diagnostic has already been issued.\n \n-      if No (Func_Ent) then\n+      if No (Proc_Ent) then\n          return;\n       end if;\n \n-      --  Otherwise prepare arguments for run-time call\n+      --  Otherwise complete preparation of arguments for run-time call\n \n-      Arglist := New_List (Convert_To (Tent, Relocate_Node (Expr)));\n+      --  Add extra arguments for Enumeration case\n+\n+      if Enum_Case then\n+         Append_To (Arg_List, New_Occurrence_Of (Lit_Strings (Rtyp), Loc));\n+         Append_To (Arg_List,\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Occurrence_Of (Lit_Indexes (Rtyp), Loc),\n+             Attribute_Name => Name_Address));\n \n       --  For floating-point types, append Digits argument\n \n-      if Is_Floating_Point_Type (Rtyp) then\n-         Append_To (Arglist,\n+      elsif Is_Floating_Point_Type (Rtyp) then\n+         Append_To (Arg_List,\n            Make_Attribute_Reference (Loc,\n              Prefix         => New_Reference_To (Ptyp, Loc),\n              Attribute_Name => Name_Digits));\n \n       --  For ordinary fixed-point types, append Aft parameter\n \n       elsif Is_Ordinary_Fixed_Point_Type (Rtyp) then\n-         Append_To (Arglist,\n+         Append_To (Arg_List,\n            Make_Attribute_Reference (Loc,\n              Prefix         => New_Reference_To (Ptyp, Loc),\n              Attribute_Name => Name_Aft));\n \n       --  For decimal, append Scale and also set to do literal conversion\n \n       elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n-         Append_To (Arglist,\n+         Append_To (Arg_List,\n            Make_Attribute_Reference (Loc,\n              Prefix => New_Reference_To (Ptyp, Loc),\n              Attribute_Name => Name_Scale));\n \n-         Set_Conversion_OK (First (Arglist));\n-         Set_Etype (First (Arglist), Tent);\n+         Set_Conversion_OK (First (Arg_List));\n+         Set_Etype (First (Arg_List), Tent);\n \n          --  For Wide_Character, append Ada 2005 indication\n \n       elsif Rtyp = Standard_Wide_Character then\n-         Append_To (Arglist,\n+         Append_To (Arg_List,\n            New_Reference_To (Boolean_Literals (Ada_Version >= Ada_05), Loc));\n       end if;\n \n-      Rewrite (N,\n-        Make_Function_Call (Loc,\n-          Name => New_Reference_To (Func_Ent, Loc),\n-          Parameter_Associations => Arglist));\n+      --  Now append the procedure call to the insert list\n+\n+      Append_To (Ins_List,\n+         Make_Procedure_Call_Statement (Loc,\n+          Name                   => New_Reference_To (Proc_Ent, Loc),\n+          Parameter_Associations => Arg_List));\n+\n+      --  Insert declarations of Snn, Pnn, and the procedure call. We suppress\n+      --  checks because we are sure that everything is in range at this stage.\n+\n+      Insert_Actions (N, Ins_List, Suppress => All_Checks);\n+\n+      --  Final step is to rewrite the expression as a slice and analyze,\n+      --  again with no checks, since we are sure that everything is OK.\n \n-      Analyze_And_Resolve (N, Standard_String);\n+      Rewrite (N,\n+        Make_Slice (Loc,\n+          Prefix         => New_Occurrence_Of (Snn, Loc),\n+          Discrete_Range =>\n+            Make_Range (Loc,\n+              Low_Bound  => Make_Integer_Literal (Loc, 1),\n+              High_Bound => New_Occurrence_Of (Pnn, Loc))));\n+\n+      Analyze_And_Resolve (N, Standard_String, Suppress => All_Checks);\n    end Expand_Image_Attribute;\n \n    ----------------------------\n@@ -662,6 +744,201 @@ package body Exp_Imgv is\n       Analyze_And_Resolve (N, Btyp);\n    end Expand_Value_Attribute;\n \n+   ---------------------------------\n+   -- Expand_Wide_Image_Attribute --\n+   ---------------------------------\n+\n+   --  We expand typ'Wide_Image (X) as follows. First we insert this code:\n+\n+   --    Rnn : Wide_String (1 .. rt'Wide_Width);\n+   --    Lnn : Natural;\n+   --    String_To_Wide_String\n+   --      (typ'Image (Expr), Rnn, Lnn, Wide_Character_Encoding_Method);\n+\n+   --  where rt is the root type of the prefix type\n+\n+   --  Now we replace the Wide_Image reference by\n+\n+   --    Rnn (1 .. Lnn)\n+\n+   --  This works in all cases because String_To_Wide_String converts any\n+   --  wide character escape sequences resulting from the Image call to the\n+   --  proper Wide_Character equivalent\n+\n+   --  not quite right for typ = Wide_Character ???\n+\n+   procedure Expand_Wide_Image_Attribute (N : Node_Id) is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Rtyp : constant Entity_Id  := Root_Type (Entity (Prefix (N)));\n+\n+      Rnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('S'));\n+\n+      Lnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('P'));\n+\n+   begin\n+      Insert_Actions (N, New_List (\n+\n+         --  Rnn : Wide_String (1 .. base_typ'Width);\n+\n+         Make_Object_Declaration (Loc,\n+            Defining_Identifier => Rnn,\n+            Object_Definition   =>\n+              Make_Subtype_Indication (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (Standard_Wide_String, Loc),\n+                Constraint   =>\n+                  Make_Index_Or_Discriminant_Constraint (Loc,\n+                    Constraints => New_List (\n+                      Make_Range (Loc,\n+                        Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                        High_Bound =>\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => New_Occurrence_Of (Rtyp, Loc),\n+                            Attribute_Name => Name_Wide_Width)))))),\n+\n+         --  Lnn : Natural;\n+\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => Lnn,\n+           Object_Definition   => New_Occurrence_Of (Standard_Natural, Loc)),\n+\n+         --    String_To_Wide_String\n+         --      (typ'Image (X), Rnn, Lnn, Wide_Character_Encoding_Method);\n+\n+         Make_Procedure_Call_Statement (Loc,\n+           Name =>\n+             New_Reference_To (RTE (RE_String_To_Wide_String), Loc),\n+\n+           Parameter_Associations => New_List (\n+             Make_Attribute_Reference (Loc,\n+               Prefix         => Prefix (N),\n+               Attribute_Name => Name_Image,\n+               Expressions    => Expressions (N)),\n+             New_Reference_To (Rnn, Loc),\n+             New_Reference_To (Lnn, Loc),\n+             Make_Integer_Literal (Loc,\n+               Intval => Int (Wide_Character_Encoding_Method))))),\n+\n+         --  Suppress checks because we know everything is properly in range\n+\n+         Suppress => All_Checks);\n+\n+      --  Final step is to rewrite the expression as a slice and analyze,\n+      --  again with no checks, since we are sure that everything is OK.\n+\n+      Rewrite (N,\n+        Make_Slice (Loc,\n+          Prefix         => New_Occurrence_Of (Rnn, Loc),\n+          Discrete_Range =>\n+            Make_Range (Loc,\n+              Low_Bound  => Make_Integer_Literal (Loc, 1),\n+              High_Bound => New_Occurrence_Of (Lnn, Loc))));\n+\n+      Analyze_And_Resolve (N, Standard_Wide_String, Suppress => All_Checks);\n+   end Expand_Wide_Image_Attribute;\n+\n+   --------------------------------------\n+   -- Expand_Wide_Wide_Image_Attribute --\n+   --------------------------------------\n+\n+   --  We expand typ'Wide_Wide_Image (X) as follows. First we insert this code:\n+\n+   --    Rnn : Wide_Wide_String (1 .. rt'Wide_Wide_Width);\n+   --    Lnn : Natural;\n+   --    String_To_Wide_Wide_String\n+   --      (typ'Image (Expr), Rnn, Lnn, Wide_Character_Encoding_Method);\n+\n+   --  where rt is the root type of the prefix type\n+\n+   --  Now we replace the Wide_Wide_Image reference by\n+\n+   --    Rnn (1 .. Lnn)\n+\n+   --  This works in all cases because String_To_Wide_Wide_String converts any\n+   --  wide character escape sequences resulting from the Image call to the\n+   --  proper Wide_Wide_Character equivalent\n+\n+   --  not quite right for typ = Wide_Wide_Character ???\n+\n+   procedure Expand_Wide_Wide_Image_Attribute (N : Node_Id) is\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Rtyp : constant Entity_Id  := Root_Type (Entity (Prefix (N)));\n+\n+      Rnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('S'));\n+\n+      Lnn : constant Entity_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('P'));\n+\n+   begin\n+      Insert_Actions (N, New_List (\n+\n+         --  Rnn : Wide_Wide_String (1 .. rt'Wide_Wide_Width);\n+\n+         Make_Object_Declaration (Loc,\n+            Defining_Identifier => Rnn,\n+            Object_Definition   =>\n+              Make_Subtype_Indication (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (Standard_Wide_Wide_String, Loc),\n+                Constraint   =>\n+                  Make_Index_Or_Discriminant_Constraint (Loc,\n+                    Constraints => New_List (\n+                      Make_Range (Loc,\n+                        Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                        High_Bound =>\n+                          Make_Attribute_Reference (Loc,\n+                            Prefix         => New_Occurrence_Of (Rtyp, Loc),\n+                            Attribute_Name => Name_Wide_Wide_Width)))))),\n+\n+         --  Lnn : Natural;\n+\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => Lnn,\n+           Object_Definition   => New_Occurrence_Of (Standard_Natural, Loc)),\n+\n+         --    String_To_Wide_Wide_String\n+         --      (typ'Image (X), Rnn, Lnn, Wide_Character_Encoding_Method);\n+\n+         Make_Procedure_Call_Statement (Loc,\n+           Name =>\n+             New_Reference_To (RTE (RE_String_To_Wide_Wide_String), Loc),\n+\n+           Parameter_Associations => New_List (\n+             Make_Attribute_Reference (Loc,\n+               Prefix         => Prefix (N),\n+               Attribute_Name => Name_Image,\n+               Expressions    => Expressions (N)),\n+             New_Reference_To (Rnn, Loc),\n+             New_Reference_To (Lnn, Loc),\n+             Make_Integer_Literal (Loc,\n+               Intval => Int (Wide_Character_Encoding_Method))))),\n+\n+         --  Suppress checks because we know everything is properly in range\n+\n+         Suppress => All_Checks);\n+\n+      --  Final step is to rewrite the expression as a slice and analyze,\n+      --  again with no checks, since we are sure that everything is OK.\n+\n+      Rewrite (N,\n+        Make_Slice (Loc,\n+          Prefix         => New_Occurrence_Of (Rnn, Loc),\n+          Discrete_Range =>\n+            Make_Range (Loc,\n+              Low_Bound  => Make_Integer_Literal (Loc, 1),\n+              High_Bound => New_Occurrence_Of (Lnn, Loc))));\n+\n+      Analyze_And_Resolve\n+        (N, Standard_Wide_Wide_String, Suppress => All_Checks);\n+   end Expand_Wide_Wide_Image_Attribute;\n+\n    ----------------------------\n    -- Expand_Width_Attribute --\n    ----------------------------"}, {"sha": "27b2452ab4ebf523e4b4c8231925418185201f46", "filename": "gcc/ada/exp_imgv.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fexp_imgv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fexp_imgv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.ads?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -73,6 +73,14 @@ package Exp_Imgv is\n    --  This procedure is called from Exp_Attr to expand an occurrence\n    --  of the attribute Image.\n \n+   procedure Expand_Wide_Image_Attribute (N : Node_Id);\n+   --  This procedure is called from Exp_Attr to expand an occurrence\n+   --  of the attribute Wide_Image.\n+\n+   procedure Expand_Wide_Wide_Image_Attribute (N : Node_Id);\n+   --  This procedure is called from Exp_Attr to expand an occurrence\n+   --  of the attribute Wide_Wide_Image.\n+\n    procedure Expand_Value_Attribute (N : Node_Id);\n    --  This procedure is called from Exp_Attr to expand an occurrence\n    --  of the attribute Value."}, {"sha": "df1969b428156e5d4cb6500dca447d32ec433401", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -55,6 +55,7 @@ package body Opt is\n       Extensions_Allowed_Config             := Extensions_Allowed;\n       External_Name_Exp_Casing_Config       := External_Name_Exp_Casing;\n       External_Name_Imp_Casing_Config       := External_Name_Imp_Casing;\n+      Fast_Math_Config                      := Fast_Math;\n       Persistent_BSS_Mode_Config            := Persistent_BSS_Mode;\n       Polling_Required_Config               := Polling_Required;\n       Use_VADS_Size_Config                  := Use_VADS_Size;\n@@ -75,6 +76,7 @@ package body Opt is\n       Extensions_Allowed             := Save.Extensions_Allowed;\n       External_Name_Exp_Casing       := Save.External_Name_Exp_Casing;\n       External_Name_Imp_Casing       := Save.External_Name_Imp_Casing;\n+      Fast_Math                      := Save.Fast_Math;\n       Persistent_BSS_Mode            := Save.Persistent_BSS_Mode;\n       Polling_Required               := Save.Polling_Required;\n       Use_VADS_Size                  := Save.Use_VADS_Size;\n@@ -95,6 +97,7 @@ package body Opt is\n       Save.Extensions_Allowed             := Extensions_Allowed;\n       Save.External_Name_Exp_Casing       := External_Name_Exp_Casing;\n       Save.External_Name_Imp_Casing       := External_Name_Imp_Casing;\n+      Save.Fast_Math                      := Fast_Math;\n       Save.Persistent_BSS_Mode            := Persistent_BSS_Mode;\n       Save.Polling_Required               := Polling_Required;\n       Save.Use_VADS_Size                  := Use_VADS_Size;\n@@ -147,11 +150,13 @@ package body Opt is\n          Extensions_Allowed         := Extensions_Allowed_Config;\n          External_Name_Exp_Casing   := External_Name_Exp_Casing_Config;\n          External_Name_Imp_Casing   := External_Name_Imp_Casing_Config;\n+         Fast_Math                  := Fast_Math_Config;\n          Persistent_BSS_Mode        := Persistent_BSS_Mode_Config;\n          Use_VADS_Size              := Use_VADS_Size_Config;\n       end if;\n \n       Exception_Locations_Suppressed := Exception_Locations_Suppressed_Config;\n+      Fast_Math                      := Fast_Math_Config;\n       Polling_Required               := Polling_Required_Config;\n    end Set_Opt_Config_Switches;\n "}, {"sha": "8fad13e3532376d71669a63c1f7a7ce696a59aca", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -180,7 +180,7 @@ package body Ch10 is\n          Item := P_Pragma;\n \n          if Item = Error\n-           or else Chars (Item) > Last_Configuration_Pragma_Name\n+           or else not Is_Configuration_Pragma_Name (Chars (Item))\n          then\n             Restore_Scan_State (Scan_State);\n             exit;\n@@ -587,19 +587,17 @@ package body Ch10 is\n       while Token = Tok_Pragma loop\n          Save_Scan_State (Scan_State);\n \n-         --  If we are in syntax scan mode allowing multiple units, then\n-         --  start the next unit if we encounter a configuration pragma,\n-         --  or a source reference pragma. We take care not to actually\n-         --  scan the pragma in this case since we don't want it to take\n-         --  effect for the current unit.\n+         --  If we are in syntax scan mode allowing multiple units, then start\n+         --  the next unit if we encounter a configuration pragma, or a source\n+         --  reference pragma. We take care not to actually scan the pragma in\n+         --  this case (we don't want it to take effect for the current unit).\n \n          if Operating_Mode = Check_Syntax then\n             Scan;  -- past Pragma\n \n             if Token = Tok_Identifier\n               and then\n-                (Token_Name in\n-                         First_Pragma_Name .. Last_Configuration_Pragma_Name\n+                (Is_Configuration_Pragma_Name (Token_Name)\n                    or else Token_Name = Name_Source_Reference)\n             then\n                Restore_Scan_State (Scan_State); -- to Pragma\n@@ -1022,9 +1020,9 @@ package body Ch10 is\n       Body_Node := Error; -- in case no good body found\n       Scan; -- past SEPARATE;\n \n-      T_Left_Paren;\n+      U_Left_Paren;\n       Set_Name (Subunit_Node, P_Qualified_Simple_Name);\n-      T_Right_Paren;\n+      U_Right_Paren;\n \n       if Token = Tok_Semicolon then\n          Error_Msg_SC (\"unexpected semicolon ignored\");"}, {"sha": "697cf86d8345f86692d97f47d911ad38d0ee4912", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -227,8 +227,7 @@ package body Ch2 is\n    --  will think there are missing bodies, and try to change ; to IS, when\n    --  in fact the bodies ARE present, supplied by these pragmas.\n \n-   function P_Pragma return Node_Id is\n-\n+   function P_Pragma (Skipping : Boolean := False) return Node_Id is\n       Interface_Check_Required : Boolean := False;\n       --  Set True if check of pragma INTERFACE is required\n \n@@ -259,10 +258,22 @@ package body Ch2 is\n       procedure Skip_Pragma_Semicolon is\n       begin\n          if Token /= Tok_Semicolon then\n-            T_Semicolon;\n-            Resync_Past_Semicolon;\n+\n+            --  If skipping the pragma, ignore a missing semicolon\n+\n+            if Skipping then\n+               null;\n+\n+            --  Otherwise demand a semicolon\n+\n+            else\n+               T_Semicolon;\n+            end if;\n+\n+         --  Scan past semicolon if present\n+\n          else\n-            Scan; -- past semicolon\n+            Scan;\n          end if;\n       end Skip_Pragma_Semicolon;\n \n@@ -284,14 +295,14 @@ package body Ch2 is\n         and then Token = Tok_Interface\n       then\n          Pragma_Name := Name_Interface;\n-         Ident_Node  := Token_Node;\n+         Ident_Node  := Make_Identifier (Token_Ptr, Name_Interface);\n          Scan; -- past INTERFACE\n       else\n          Ident_Node := P_Identifier;\n-         Delete_Node (Ident_Node);\n       end if;\n \n       Set_Chars (Pragma_Node, Pragma_Name);\n+      Set_Pragma_Identifier (Pragma_Node, Ident_Node);\n \n       --  See if special INTERFACE/IMPORT check is required\n \n@@ -336,10 +347,10 @@ package body Ch2 is\n             Scan; -- past comma\n          end loop;\n \n-         --  If we have := for pragma Debug, it is worth special casing\n-         --  the error message (it is easy to think of pragma Debug as\n-         --  taking a statement, and an assignment statement is the most\n-         --  likely candidate for this error)\n+         --  If we have := for pragma Debug, it is worth special casing the\n+         --  error message (it is easy to think of pragma Debug as taking a\n+         --  statement, and an assignment statement is the most likely\n+         --  candidate for this error)\n \n          if Token = Tok_Colon_Equal and then Pragma_Name = Name_Debug then\n             Error_Msg_SC (\"argument for pragma Debug must be procedure call\");\n@@ -394,7 +405,7 @@ package body Ch2 is\n    begin\n       while Token = Tok_Pragma loop\n          Error_Msg_SC (\"pragma not allowed here\");\n-         Discard_Junk_Node (P_Pragma);\n+         Discard_Junk_Node (P_Pragma (Skipping => True));\n       end loop;\n    end P_Pragmas_Misplaced;\n \n@@ -469,7 +480,6 @@ package body Ch2 is\n             Identifier_Seen := True;\n             Scan; -- past arrow\n             Set_Chars (Association, Chars (Identifier_Node));\n-            Delete_Node (Identifier_Node);\n \n             --  Case of argument with no identifier\n "}, {"sha": "381ff922a487b51af5f5b25d7cf847f698ba2598", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -174,7 +174,9 @@ package body Ch3 is\n       if Token = Tok_Identifier then\n \n          --  Ada 2005 (AI-284): Compiling in Ada95 mode we warn that INTERFACE,\n-         --  OVERRIDING, and SYNCHRONIZED are new reserved words.\n+         --  OVERRIDING, and SYNCHRONIZED are new reserved words. Note that\n+         --  in the case where these keywords are misused in Ada 95 mode,\n+         --  this routine will generally not be called at all.\n \n          if Ada_Version = Ada_95\n            and then Warn_On_Ada_2005_Compatibility\n@@ -1128,7 +1130,6 @@ package body Ch3 is\n               Make_Attribute_Reference (Prev_Token_Ptr,\n                 Prefix => Prefix,\n                 Attribute_Name => Token_Name);\n-            Delete_Node (Token_Node);\n             Scan; -- past type attribute identifier\n          end if;\n \n@@ -1279,6 +1280,10 @@ package body Ch3 is\n       --  returns True, otherwise returns False. Includes checking for some\n       --  common error cases.\n \n+      -------------\n+      -- No_List --\n+      -------------\n+\n       procedure No_List is\n       begin\n          if Num_Idents > 1 then\n@@ -1289,6 +1294,10 @@ package body Ch3 is\n          List_OK := False;\n       end No_List;\n \n+      ----------------------\n+      -- Token_Is_Renames --\n+      ----------------------\n+\n       function Token_Is_Renames return Boolean is\n          At_Colon : Saved_Scan_State;\n \n@@ -1922,7 +1931,6 @@ package body Ch3 is\n                 Abstract_Present    => Abstract_Present (Typedef_Node),\n                 Interface_List      => Interface_List (Typedef_Node));\n \n-            Delete_Node (Typedef_Node);\n             return Typedecl_Node;\n \n          --  Derived type definition with record extension part\n@@ -2715,27 +2723,37 @@ package body Ch3 is\n       Scan_State : Saved_Scan_State;\n \n    begin\n-      if Token /= Tok_Left_Paren then\n+      --  If <> right now, then this is missing left paren\n+\n+      if Token = Tok_Box then\n+         U_Left_Paren;\n+\n+      --  If not <> or left paren, then definitely no box\n+\n+      elsif Token /= Tok_Left_Paren then\n          return False;\n \n+      --  Left paren, so might be a box after it\n+\n       else\n          Save_Scan_State (Scan_State);\n          Scan; -- past the left paren\n \n-         if Token = Tok_Box then\n-            if Ada_Version = Ada_83 then\n-               Error_Msg_SC (\"(Ada 83) unknown discriminant not allowed!\");\n-            end if;\n-\n-            Scan; -- past the box\n-            T_Right_Paren; -- must be followed by right paren\n-            return True;\n-\n-         else\n+         if Token /= Tok_Box then\n             Restore_Scan_State (Scan_State);\n             return False;\n          end if;\n       end if;\n+\n+      --  We are now pointing to the box\n+\n+      if Ada_Version = Ada_83 then\n+         Error_Msg_SC (\"(Ada 83) unknown discriminant not allowed!\");\n+      end if;\n+\n+      Scan; -- past the box\n+      U_Right_Paren; -- must be followed by right paren\n+      return True;\n    end P_Unknown_Discriminant_Part_Opt;\n \n    ----------------------------------\n@@ -4039,11 +4057,28 @@ package body Ch3 is\n \n          when Tok_Identifier =>\n             Check_Bad_Layout;\n-            P_Identifier_Declarations (Decls, Done, In_Spec);\n+\n+            --  Special check for misuse of overriding not in Ada 2005 mode\n+\n+            if Token_Name = Name_Overriding\n+              and then not Next_Token_Is (Tok_Colon)\n+            then\n+               Error_Msg_SC (\"overriding indicator is an Ada 2005 extension\");\n+               Error_Msg_SC (\"\\unit must be compiled with -gnat05 switch\");\n+\n+               Token := Tok_Overriding;\n+               Append (P_Subprogram (Pf_Decl_Gins_Pbod_Rnam_Stub), Decls);\n+               Done := False;\n+\n+            --  Normal case, no overriding, or overriding followed by colon\n+\n+            else\n+               P_Identifier_Declarations (Decls, Done, In_Spec);\n+            end if;\n \n          --  Ada2005: A subprogram declaration can start with \"not\" or\n          --  \"overriding\". In older versions, \"overriding\" is handled\n-         --  like an identifier, with the appropriate warning.\n+         --  like an identifier, with the appropriate messages.\n \n          when Tok_Not =>\n             Check_Bad_Layout;"}, {"sha": "fee646514be6a91206cd9c088c778d7d0b8c50ea", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -176,32 +176,49 @@ package body Ch6 is\n       Scope.Table (Scope.Last).Ecol := Start_Column;\n       Scope.Table (Scope.Last).Lreq := False;\n \n-      --  Ada2005: scan leading overriding indicator\n+      --  Ada2005: scan leading NOT OVERRIDING indicator\n \n       if Token = Tok_Not then\n          Scan;  -- past NOT\n \n          if Token = Tok_Overriding then\n             Scan;  --  past OVERRIDING\n             Not_Overriding := True;\n+\n+         --  Overriding keyword used in non Ada 2005 mode\n+\n+         elsif Token = Tok_Identifier\n+           and then Token_Name = Name_Overriding\n+         then\n+            Error_Msg_SC (\"overriding indicator is an Ada 2005 extension\");\n+            Error_Msg_SC (\"\\unit must be compiled with -gnat05 switch\");\n+            Scan;  --  past Overriding\n+            Not_Overriding := True;\n+\n          else\n             Error_Msg_SC (\"OVERRIDING expected!\");\n          end if;\n \n+      --  Ada 2005: scan leading OVERRIDING indicator\n+\n+      --  Note: in the case of OVERRIDING keyword used in Ada 95 mode, the\n+      --  declaration circuit already gave an error message and changed the\n+      --  tokem to Tok_Overriding.\n+\n       elsif Token = Tok_Overriding then\n          Scan;  --  past OVERRIDING\n          Is_Overriding := True;\n       end if;\n \n       if (Is_Overriding or else Not_Overriding) then\n-         if Ada_Version < Ada_05 then\n-            Error_Msg_SP (\" overriding indicator is an Ada 2005 extension\");\n-            Error_Msg_SP (\"\\unit must be compiled with -gnat05 switch\");\n+\n+         --  Note that if we are not in Ada_05 mode, error messages have\n+         --  already been given, so no need to give another message here.\n \n          --  An overriding indicator is allowed for subprogram declarations,\n          --  bodies, renamings, stubs, and instantiations.\n \n-         elsif Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub then\n+         if Pf_Flags /= Pf_Decl_Gins_Pbod_Rnam_Stub then\n             Error_Msg_SC (\"overriding indicator not allowed here!\");\n \n          elsif Token /= Tok_Function\n@@ -1000,7 +1017,8 @@ package body Ch6 is\n       Specification_Loop : loop\n          begin\n             if Token = Tok_Pragma then\n-               P_Pragmas_Misplaced;\n+               Error_Msg_SC (\"pragma not allowed in formal part\");\n+               Discard_Junk_Node (P_Pragma (Skipping => True));\n             end if;\n \n             Ignore (Tok_Left_Paren);"}, {"sha": "2114fd9c9866299bbded2a5f473d182af4026ff8", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -1028,7 +1028,7 @@ begin\n             end;\n \n          else\n-               raise Constraint_Error;\n+            raise Constraint_Error;\n          end if;\n \n       exception\n@@ -1089,9 +1089,12 @@ begin\n            Pragma_Extend_System                 |\n            Pragma_External                      |\n            Pragma_External_Name_Casing          |\n+           Pragma_Favor_Top_Level               |\n+           Pragma_Fast_Math                     |\n            Pragma_Finalize_Storage_Only         |\n            Pragma_Float_Representation          |\n            Pragma_Ident                         |\n+           Pragma_Implemented_By_Entry          |\n            Pragma_Implicit_Packing              |\n            Pragma_Import                        |\n            Pragma_Import_Exception              |"}, {"sha": "3d45932c49fcfdc6fbd53c99948e5bc74005ca16", "filename": "gcc/ada/par-tchk.adb", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-tchk.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-tchk.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-tchk.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -790,6 +790,32 @@ package body Tchk is\n       end if;\n    end TF_Use;\n \n+   ------------------\n+   -- U_Left_Paren --\n+   ------------------\n+\n+   procedure U_Left_Paren is\n+   begin\n+      if Token = Tok_Left_Paren then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\"(\"\"!\");\n+      end if;\n+   end U_Left_Paren;\n+\n+   -------------------\n+   -- U_Right_Paren --\n+   -------------------\n+\n+   procedure U_Right_Paren is\n+   begin\n+      if Token = Tok_Right_Paren then\n+         Scan;\n+      else\n+         Error_Msg_AP (\"missing \"\")\"\"!\");\n+      end if;\n+   end U_Right_Paren;\n+\n    -----------------\n    -- Wrong_Token --\n    -----------------"}, {"sha": "e4b690f1788a12865f20f3acb0c592dabac3ead8", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -23,9 +23,10 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Csets;   use Csets;\n-with Stylesw; use Stylesw;\n-with Uintp;   use Uintp;\n+with Csets;    use Csets;\n+with Namet.Sp; use Namet.Sp;\n+with Stylesw;  use Stylesw;\n+with Uintp;    use Uintp;\n \n with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n \n@@ -586,6 +587,21 @@ package body Util is\n       Scan;\n    end Merge_Identifier;\n \n+   -------------------\n+   -- Next_Token_Is --\n+   -------------------\n+\n+   function Next_Token_Is (Tok : Token_Type) return Boolean is\n+      Scan_State : Saved_Scan_State;\n+      Result     : Boolean;\n+   begin\n+      Save_Scan_State (Scan_State);\n+      Scan;\n+      Result := (Token = Tok);\n+      Restore_Scan_State (Scan_State);\n+      return Result;\n+   end Next_Token_Is;\n+\n    -------------------\n    -- No_Constraint --\n    -------------------\n@@ -677,27 +693,15 @@ package body Util is\n \n       --  Check for possible misspelling\n \n-      Get_Name_String (Token_Name);\n-\n-      declare\n-         AN : constant String := Name_Buffer (1 .. Name_Len);\n-\n-      begin\n-         Error_Msg_Name_1 := First_Attribute_Name;\n-         while Error_Msg_Name_1 <= Last_Attribute_Name loop\n-            Get_Name_String (Error_Msg_Name_1);\n-\n-            if Is_Bad_Spelling_Of\n-                 (AN, Name_Buffer (1 .. Name_Len))\n-            then\n-               Error_Msg_N\n-                 (\"\\possible misspelling of %\", Token_Node);\n-               exit;\n-            end if;\n+      Error_Msg_Name_1 := First_Attribute_Name;\n+      while Error_Msg_Name_1 <= Last_Attribute_Name loop\n+         if Is_Bad_Spelling_Of (Token_Name, Error_Msg_Name_1) then\n+            Error_Msg_N (\"\\possible misspelling of %\", Token_Node);\n+            exit;\n+         end if;\n \n-            Error_Msg_Name_1 := Error_Msg_Name_1 + 1;\n-         end loop;\n-      end;\n+         Error_Msg_Name_1 := Error_Msg_Name_1 + 1;\n+      end loop;\n    end Signal_Bad_Attribute;\n \n    -----------------------------"}, {"sha": "e75051002ebd189f9a451264881fa94e42bcf00e", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -530,7 +530,10 @@ is\n    -------------\n \n    package Ch2 is\n-      function P_Pragma                               return Node_Id;\n+      function P_Pragma (Skipping : Boolean := False) return Node_Id;\n+      --  Scan out a pragma. If Skipping is True, then the caller is skipping\n+      --  the pragma in the context of illegal placement (this is used to avoid\n+      --  some junk cascaded messages).\n \n       function P_Identifier (C : Id_Check := None) return Node_Id;\n       --  Scans out an identifier. The parameter C determines the treatment\n@@ -965,7 +968,7 @@ is\n       procedure T_When;\n       procedure T_With;\n \n-      --  Procedures have names of the form TF_xxx, where Tok_xxx is a token\n+      --  Procedures having names of the form TF_xxx, where Tok_xxx is a token\n       --  name check that the current token matches the required token, and\n       --  if so, scan past it. If not, an error message is issued indicating\n       --  that the required token is not present (xxx expected).\n@@ -987,6 +990,13 @@ is\n       procedure TF_Semicolon;\n       procedure TF_Then;\n       procedure TF_Use;\n+\n+      --  Procedures with names of the form U_xxx, where Tok_xxx is a token\n+      --  name, are just like the corresponding T_xxx procedures except that\n+      --  an error message, if given, is unconditional.\n+\n+      procedure U_Left_Paren;\n+      procedure U_Right_Paren;\n    end Tchk;\n \n    --------------\n@@ -1085,6 +1095,10 @@ is\n       --  conditions are met, an error message is issued, and the merge is\n       --  carried out, modifying the Chars field of Prev.\n \n+      function Next_Token_Is (Tok : Token_Type) return Boolean;\n+      --  Looks at token after current one and returns True if the token type\n+      --  matches Tok. The scan is unconditionally restored on return.\n+\n       procedure No_Constraint;\n       --  Called in a place where no constraint is allowed, but one might\n       --  appear due to a common error (e.g. after the type mark in a procedure\n@@ -1242,7 +1256,7 @@ begin\n \n                   --  Give error if bad pragma\n \n-                  if Chars (P_Node) > Last_Configuration_Pragma_Name\n+                  if not Is_Configuration_Pragma_Name (Chars (P_Node))\n                     and then Chars (P_Node) /= Name_Source_Reference\n                   then\n                      if Is_Pragma_Name (Chars (P_Node)) then"}, {"sha": "33f6674c6cbda71d9db72e6e3da57c163e25d446", "filename": "gcc/ada/s-wchstw.adb", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fs-wchstw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fs-wchstw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchstw.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -121,18 +121,20 @@ package body System.WCh_StW is\n    -- String_To_Wide_String --\n    ---------------------------\n \n-   function String_To_Wide_String\n+   procedure String_To_Wide_String\n      (S  : String;\n-      EM : WC_Encoding_Method) return Wide_String\n+      R  : out Wide_String;\n+      L  : out Natural;\n+      EM : System.WCh_Con.WC_Encoding_Method)\n    is\n-      R  : Wide_String (1 .. S'Length);\n-      RP : Natural;\n       SP : Natural;\n       V  : UTF_32_Code;\n \n    begin\n+      pragma Assert (S'First = 1);\n+\n       SP := S'First;\n-      RP := 0;\n+      L  := 0;\n       while SP <= S'Last loop\n          Get_Next_Code (S, SP, V, EM);\n \n@@ -141,36 +143,34 @@ package body System.WCh_StW is\n               with \"out of range value for wide character\";\n          end if;\n \n-         RP := RP + 1;\n-         R (RP) := Wide_Character'Val (V);\n+         L := L + 1;\n+         R (L) := Wide_Character'Val (V);\n       end loop;\n-\n-      return R (1 .. RP);\n    end String_To_Wide_String;\n \n    --------------------------------\n    -- String_To_Wide_Wide_String --\n    --------------------------------\n \n-   function String_To_Wide_Wide_String\n+   procedure String_To_Wide_Wide_String\n      (S  : String;\n-      EM : WC_Encoding_Method) return Wide_Wide_String\n+      R  : out Wide_Wide_String;\n+      L  : out Natural;\n+      EM : System.WCh_Con.WC_Encoding_Method)\n    is\n-      R  : Wide_Wide_String (1 .. S'Length);\n-      RP : Natural;\n+      pragma Assert (S'First = 1);\n+\n       SP : Natural;\n       V  : UTF_32_Code;\n \n    begin\n       SP := S'First;\n-      RP := 0;\n+      L := 0;\n       while SP <= S'Last loop\n          Get_Next_Code (S, SP, V, EM);\n-         RP := RP + 1;\n-         R (RP) := Wide_Wide_Character'Val (V);\n+         L := L + 1;\n+         R (L) := Wide_Wide_Character'Val (V);\n       end loop;\n-\n-      return R (1 .. RP);\n    end String_To_Wide_Wide_String;\n \n end System.WCh_StW;"}, {"sha": "7bd3529586df22e690e4d313c0fd081553133d1a", "filename": "gcc/ada/s-wchstw.ads", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fs-wchstw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fs-wchstw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wchstw.ads?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,33 +32,39 @@\n ------------------------------------------------------------------------------\n \n --  This package contains the routine used to convert strings to wide (wide)\n---  strings for use by wide (wide) character attributes (value, image etc.)\n+--  strings for use by wide (wide) image attribute.\n \n with System.WCh_Con;\n \n package System.WCh_StW is\n    pragma Pure;\n \n-   function String_To_Wide_String\n+   procedure String_To_Wide_String\n      (S  : String;\n-      EM : System.WCh_Con.WC_Encoding_Method) return Wide_String;\n+      R  : out Wide_String;\n+      L  : out Natural;\n+      EM : System.WCh_Con.WC_Encoding_Method);\n    --  This routine simply takes its argument and converts it to wide string\n-   --  format. In the context of the Wide_Image attribute, the argument is\n-   --  the corresponding 'Image attribute. Any wide character escape sequences\n-   --  in the string are converted to the corresponding wide character value.\n-   --  No syntax checks are made, it is assumed that any such sequences are\n-   --  validly formed (this must be assured by the caller), and results from\n-   --  the fact that Wide_Image is only used on strings that have been built\n-   --  by the compiler, such as images of enumeration literals. If the method\n-   --  for encoding is a shift-in, shift-out convention, then it is assumed\n-   --  that normal (non-wide character) mode holds at the start and end of\n-   --  the argument string. EM indicates the wide character encoding method.\n+   --  format, storing the result in R (1 .. L), with L being set appropriately\n+   --  on return. The caller guarantees that R is long enough to accomodate the\n+   --  result. This is used in the context of the Wide_Image attribute, where\n+   --  the argument is the corresponding 'Image attribute. Any wide character\n+   --  escape sequences in the string are converted to the corresponding wide\n+   --  character value. No syntax checks are made, it is assumed that any such\n+   --  sequences are validly formed (this must be assured by the caller), and\n+   --  results from the fact that Wide_Image is only used on strings that have\n+   --  been built by the compiler, such as images of enumeration literals. If\n+   --  the method for encoding is a shift-in, shift-out convention, then it is\n+   --  assumed that normal (non-wide character) mode holds at the start and end\n+   --  of the argument string. EM indicates the wide character encoding method.\n    --  Note: in the WCEM_Brackets case, the brackets escape sequence is used\n    --  only for codes greater than 16#FF#.\n \n-   function String_To_Wide_Wide_String\n+   procedure String_To_Wide_Wide_String\n      (S  : String;\n-      EM : System.WCh_Con.WC_Encoding_Method) return Wide_Wide_String;\n+      R  : out Wide_Wide_String;\n+      L  : out Natural;\n+      EM : System.WCh_Con.WC_Encoding_Method);\n    --  Same function with Wide_Wide_String output\n \n end System.WCh_StW;"}, {"sha": "47848c549f4a709b63447feec185317f1894c22c", "filename": "gcc/ada/s-wwdenu.adb", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fs-wwdenu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fs-wwdenu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-wwdenu.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -63,12 +63,14 @@ package body System.WWd_Enum is\n       W := 0;\n       for J in Lo .. Hi loop\n          declare\n-            WS : constant Wide_Wide_String :=\n-                   String_To_Wide_Wide_String\n-                     (Names (Natural (IndexesT (J)) ..\n-                             Natural (IndexesT (J + 1)) - 1), EM);\n+            S  : constant String :=\n+                   Names (Natural (IndexesT (J)) ..\n+                          Natural (IndexesT (J + 1)) - 1);\n+            WS : Wide_Wide_String (1 .. S'Length);\n+            L  : Natural;\n          begin\n-            W := Natural'Max (W, WS'Length);\n+            String_To_Wide_Wide_String (S, WS, L, EM);\n+            W := Natural'Max (W, L);\n          end;\n       end loop;\n \n@@ -100,12 +102,14 @@ package body System.WWd_Enum is\n       W := 0;\n       for J in Lo .. Hi loop\n          declare\n-            WS : constant Wide_Wide_String :=\n-                   String_To_Wide_Wide_String\n-                     (Names (Natural (IndexesT (J)) ..\n-                             Natural (IndexesT (J + 1)) - 1), EM);\n+            S  : constant String :=\n+                   Names (Natural (IndexesT (J)) ..\n+                          Natural (IndexesT (J + 1)) - 1);\n+            WS : Wide_Wide_String (1 .. S'Length);\n+            L  : Natural;\n          begin\n-            W := Natural'Max (W, WS'Length);\n+            String_To_Wide_Wide_String (S, WS, L, EM);\n+            W := Natural'Max (W, L);\n          end;\n       end loop;\n \n@@ -137,12 +141,14 @@ package body System.WWd_Enum is\n       W := 0;\n       for J in Lo .. Hi loop\n          declare\n-            WS : constant Wide_Wide_String :=\n-                   String_To_Wide_Wide_String\n-                     (Names (Natural (IndexesT (J)) ..\n-                             Natural (IndexesT (J + 1)) - 1), EM);\n+            S  : constant String :=\n+                   Names (Natural (IndexesT (J)) ..\n+                          Natural (IndexesT (J + 1)) - 1);\n+            WS : Wide_Wide_String (1 .. S'Length);\n+            L  : Natural;\n          begin\n-            W := Natural'Max (W, WS'Length);\n+            String_To_Wide_Wide_String (S, WS, L, EM);\n+            W := Natural'Max (W, L);\n          end;\n       end loop;\n \n@@ -174,12 +180,14 @@ package body System.WWd_Enum is\n       W := 0;\n       for J in Lo .. Hi loop\n          declare\n-            WS : constant Wide_String :=\n-                   String_To_Wide_String\n-                     (Names (Natural (IndexesT (J)) ..\n-                             Natural (IndexesT (J + 1)) - 1), EM);\n+            S  : constant String :=\n+                   Names (Natural (IndexesT (J)) ..\n+                          Natural (IndexesT (J + 1)) - 1);\n+            WS : Wide_String (1 .. S'Length);\n+            L  : Natural;\n          begin\n-            W := Natural'Max (W, WS'Length);\n+            String_To_Wide_String (S, WS, L, EM);\n+            W := Natural'Max (W, L);\n          end;\n       end loop;\n \n@@ -211,12 +219,14 @@ package body System.WWd_Enum is\n       W := 0;\n       for J in Lo .. Hi loop\n          declare\n-            WS : constant Wide_String :=\n-                   String_To_Wide_String\n-                     (Names (Natural (IndexesT (J)) ..\n-                             Natural (IndexesT (J + 1)) - 1), EM);\n+            S  : constant String :=\n+                   Names (Natural (IndexesT (J)) ..\n+                          Natural (IndexesT (J + 1)) - 1);\n+            WS : Wide_String (1 .. S'Length);\n+            L  : Natural;\n          begin\n-            W := Natural'Max (W, WS'Length);\n+            String_To_Wide_String (S, WS, L, EM);\n+            W := Natural'Max (W, L);\n          end;\n       end loop;\n \n@@ -248,12 +258,14 @@ package body System.WWd_Enum is\n       W := 0;\n       for J in Lo .. Hi loop\n          declare\n-            WS : constant Wide_String :=\n-                   String_To_Wide_String\n-                     (Names (Natural (IndexesT (J)) ..\n-                             Natural (IndexesT (J + 1)) - 1), EM);\n+            S  : constant String :=\n+                   Names (Natural (IndexesT (J)) ..\n+                          Natural (IndexesT (J + 1)) - 1);\n+            WS : Wide_String (1 .. S'Length);\n+            L  : Natural;\n          begin\n-            W := Natural'Max (W, WS'Length);\n+            String_To_Wide_String (S, WS, L, EM);\n+            W := Natural'Max (W, L);\n          end;\n       end loop;\n "}, {"sha": "7432a3bd04c029c8a85b7a20263fba178129fa2e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 187, "deletions": 61, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -41,6 +41,7 @@ with Lib;      use Lib;\n with Lib.Writ; use Lib.Writ;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n+with Namet.Sp; use Namet.Sp;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -77,8 +78,6 @@ with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n with Validsw;  use Validsw;\n \n-with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n-\n package body Sem_Prag is\n \n    ----------------------------------------------\n@@ -91,12 +90,12 @@ package body Sem_Prag is\n    --  form and processing:\n \n    --  pragma Export_xxx\n-   --        [Internal                 =>] LOCAL_NAME,\n+   --        [Internal                 =>] LOCAL_NAME\n    --     [, [External                 =>] EXTERNAL_SYMBOL]\n    --     [, other optional parameters   ]);\n \n    --  pragma Import_xxx\n-   --        [Internal                 =>] LOCAL_NAME,\n+   --        [Internal                 =>] LOCAL_NAME\n    --     [, [External                 =>] EXTERNAL_SYMBOL]\n    --     [, other optional parameters   ]);\n \n@@ -420,7 +419,7 @@ package body Sem_Prag is\n \n       procedure Error_Pragma (Msg : String);\n       pragma No_Return (Error_Pragma);\n-      --  Outputs error message for current pragma. The message contains an %\n+      --  Outputs error message for current pragma. The message contains a %\n       --  that will be replaced with the pragma name, and the flag is placed\n       --  on the pragma itself. Pragma_Exit is then raised.\n \n@@ -1725,8 +1724,7 @@ package body Sem_Prag is\n \n                      for Index1 in Names'Range loop\n                         if Is_Bad_Spelling_Of\n-                             (Get_Name_String (Chars (Arg)),\n-                              Get_Name_String (Names (Index1)))\n+                             (Chars (Arg), Names (Index1))\n                         then\n                            Error_Msg_Name_1 := Names (Index1);\n                            Error_Msg_N (\"\\possible misspelling of%\", Arg);\n@@ -2267,6 +2265,8 @@ package body Sem_Prag is\n             Error_Pragma (\"enumeration literal not allowed for pragma%\");\n          end if;\n \n+         --  Check for rep item appearing too early or too late\n+\n          if Etype (E) = Any_Type\n            or else Rep_Item_Too_Early (E, N)\n          then\n@@ -2353,10 +2353,6 @@ package body Sem_Prag is\n                E1 := Homonym (E1);\n                exit when No (E1) or else Scope (E1) /= Current_Scope;\n \n-               --  Note: below we are missing a check for Rep_Item_Too_Late.\n-               --  That is deliberate, we cannot chain the rep item on more\n-               --  than one Rep_Item chain, to be fixed later ???\n-\n                if Comes_From_Source (E1)\n                  and then Comp_Unit = Get_Source_Unit (E1)\n                  and then Nkind (Original_Node (Parent (E1))) /=\n@@ -2821,7 +2817,6 @@ package body Sem_Prag is\n                if Is_Generic_Subprogram (Entity (Arg_Internal)) then\n                   Error_Pragma\n                     (\"pragma% cannot be given for generic subprogram\");\n-\n                else\n                   Error_Pragma\n                     (\"pragma% does not identify local subprogram\");\n@@ -3345,7 +3340,8 @@ package body Sem_Prag is\n          --  corresponding body, if there is one present.\n \n          procedure Set_Inline_Flags (Subp : Entity_Id);\n-         --  Sets Is_Inlined and Has_Pragma_Inline flags for Subp\n+         --  Sets Is_Inlined and Has_Pragma_Inline flags for Subp and also\n+         --  Has_Pragma_Inline_Always for the Inline_Always case.\n \n          function Inlining_Not_Possible (Subp : Entity_Id) return Boolean;\n          --  Returns True if it can be determined at this stage that inlining\n@@ -3354,6 +3350,7 @@ package body Sem_Prag is\n          --  get undefined symbols at link time. This function also emits a\n          --  warning if front-end inlining is enabled and the pragma appears\n          --  too late.\n+         --\n          --  ??? is business with link symbols still valid, or does it relate\n          --  to front end ZCX which is being phased out ???\n \n@@ -3417,7 +3414,16 @@ package body Sem_Prag is\n             Inner_Subp : Entity_Id   := Subp;\n \n          begin\n+            --  Ignore if bad type, avoid cascaded error\n+\n             if Etype (Subp) = Any_Type then\n+               Applies := True;\n+               return;\n+\n+            --  Ignore if all inlining is suppressed\n+\n+            elsif Suppress_All_Inlining then\n+               Applies := True;\n                return;\n \n             --  If inlining is not possible, for now do not treat as an error\n@@ -3515,10 +3521,12 @@ package body Sem_Prag is\n \n             if not Has_Pragma_Inline (Subp) then\n                Set_Has_Pragma_Inline (Subp);\n-               Set_Next_Rep_Item (N, First_Rep_Item (Subp));\n-               Set_First_Rep_Item (Subp, N);\n                Effective := True;\n             end if;\n+\n+            if Prag_Id = Pragma_Inline_Always then\n+               Set_Has_Pragma_Inline_Always (Subp);\n+            end if;\n          end Set_Inline_Flags;\n \n       --  Start of processing for Process_Inline\n@@ -3565,6 +3573,7 @@ package body Sem_Prag is\n \n             elsif not Effective\n               and then Warn_On_Redundant_Constructs\n+              and then not Suppress_All_Inlining\n             then\n                if Inlining_Not_Possible (Subp) then\n                   Error_Msg_NE\n@@ -4519,15 +4528,13 @@ package body Sem_Prag is\n       if not Is_Pragma_Name (Chars (N)) then\n          if Warn_On_Unrecognized_Pragma then\n             Error_Msg_Name_1 := Chars (N);\n-            Error_Msg_N (\"?unrecognized pragma%!\", N);\n+            Error_Msg_N (\"?unrecognized pragma%!\", Pragma_Identifier (N));\n \n             for PN in First_Pragma_Name .. Last_Pragma_Name loop\n-               if Is_Bad_Spelling_Of\n-                 (Get_Name_String (Chars (N)),\n-                  Get_Name_String (PN))\n-               then\n+               if Is_Bad_Spelling_Of (Chars (N), PN) then\n                   Error_Msg_Name_1 := PN;\n-                  Error_Msg_N (\"\\?possible misspelling of %!\", N);\n+                  Error_Msg_N\n+                    (\"\\?possible misspelling of %!\", Pragma_Identifier (N));\n                   exit;\n                end if;\n             end loop;\n@@ -4796,6 +4803,7 @@ package body Sem_Prag is\n \n          when Pragma_Assert => Assert : declare\n             Expr : Node_Id;\n+            Eloc : Source_Ptr;\n \n          begin\n             Ada_2005_Pragma;\n@@ -4816,23 +4824,30 @@ package body Sem_Prag is\n             --       null;\n             --    end if;\n \n-            --  The reason we do this rewriting during semantic analysis\n-            --  rather than as part of normal expansion is that we cannot\n-            --  analyze and expand the code for the boolean expression\n-            --  directly, or it may cause insertion of actions that would\n-            --  escape the attempt to suppress the assertion code.\n+            --  The reason we do this rewriting during semantic analysis rather\n+            --  than as part of normal expansion is that we cannot analyze and\n+            --  expand the code for the boolean expression directly, or it may\n+            --  cause insertion of actions that would escape the attempt to\n+            --  suppress the assertion code.\n+\n+            --  Note that the Sloc for the if statement corresponds to the\n+            --  argument condition, not the pragma itself. The reason for this\n+            --  is that we may generate a warning if the condition is False at\n+            --  compile time, and we do not want to delete this warning when we\n+            --  delete the if statement.\n \n             Expr := Expression (Arg1);\n+            Eloc := Sloc (Expr);\n \n             if Expander_Active and not Assertions_Enabled then\n                Rewrite (N,\n-                 Make_If_Statement (Loc,\n+                 Make_If_Statement (Eloc,\n                    Condition =>\n-                     Make_And_Then (Loc,\n-                       Left_Opnd  => New_Occurrence_Of (Standard_False, Loc),\n+                     Make_And_Then (Eloc,\n+                       Left_Opnd  => New_Occurrence_Of (Standard_False, Eloc),\n                        Right_Opnd => Expr),\n                    Then_Statements => New_List (\n-                     Make_Null_Statement (Loc))));\n+                     Make_Null_Statement (Eloc))));\n \n                Analyze (N);\n \n@@ -5284,7 +5299,7 @@ package body Sem_Prag is\n          -------------------\n \n          --  pragma Common_Object (\n-         --        [Internal =>] LOCAL_NAME,\n+         --        [Internal =>] LOCAL_NAME\n          --     [, [External =>] EXTERNAL_SYMBOL]\n          --     [, [Size     =>] EXTERNAL_SYMBOL]);\n \n@@ -5372,8 +5387,8 @@ package body Sem_Prag is\n               or else Etype (Ent) /= Etype (Next_Entity (Ent))\n             then\n                Error_Pragma_Arg\n-                 (\"record for pragma% must have two fields of same fpt type\",\n-                  Arg1);\n+                 (\"record for pragma% must have two fields of the same \"\n+                  & \"floating-point type\", Arg1);\n \n             else\n                Set_Has_Complex_Representation (Base_Type (E));\n@@ -6179,8 +6194,8 @@ package body Sem_Prag is\n          ----------------------\n \n          --  pragma Export_Exception (\n-         --        [Internal         =>] LOCAL_NAME,\n-         --     [, [External         =>] EXTERNAL_SYMBOL,]\n+         --        [Internal         =>] LOCAL_NAME\n+         --     [, [External         =>] EXTERNAL_SYMBOL]\n          --     [, [Form     =>] Ada | VMS]\n          --     [, [Code     =>] static_integer_EXPRESSION]);\n \n@@ -6219,8 +6234,8 @@ package body Sem_Prag is\n          ---------------------\n \n          --  pragma Export_Function (\n-         --        [Internal         =>] LOCAL_NAME,\n-         --     [, [External         =>] EXTERNAL_SYMBOL,]\n+         --        [Internal         =>] LOCAL_NAME\n+         --     [, [External         =>] EXTERNAL_SYMBOL]\n          --     [, [Parameter_Types  =>] (PARAMETER_TYPES)]\n          --     [, [Result_Type      =>] TYPE_DESIGNATOR]\n          --     [, [Mechanism        =>] MECHANISM]\n@@ -6286,7 +6301,7 @@ package body Sem_Prag is\n          -------------------\n \n          --  pragma Export_Object (\n-         --        [Internal =>] LOCAL_NAME,\n+         --        [Internal =>] LOCAL_NAME\n          --     [, [External =>] EXTERNAL_SYMBOL]\n          --     [, [Size     =>] EXTERNAL_SYMBOL]);\n \n@@ -6341,8 +6356,8 @@ package body Sem_Prag is\n          ----------------------\n \n          --  pragma Export_Procedure (\n-         --        [Internal         =>] LOCAL_NAME,\n-         --     [, [External         =>] EXTERNAL_SYMBOL,]\n+         --        [Internal         =>] LOCAL_NAME\n+         --     [, [External         =>] EXTERNAL_SYMBOL]\n          --     [, [Parameter_Types  =>] (PARAMETER_TYPES)]\n          --     [, [Mechanism        =>] MECHANISM]);\n \n@@ -6419,7 +6434,7 @@ package body Sem_Prag is\n          -----------------------------\n \n          --  pragma Export_Valued_Procedure (\n-         --        [Internal         =>] LOCAL_NAME,\n+         --        [Internal         =>] LOCAL_NAME\n          --     [, [External         =>] EXTERNAL_SYMBOL,]\n          --     [, [Parameter_Types  =>] (PARAMETER_TYPES)]\n          --     [, [Mechanism        =>] MECHANISM]);\n@@ -6613,6 +6628,48 @@ package body Sem_Prag is\n             end case;\n          end External_Name_Casing;\n \n+         --------------------------\n+         -- Favor_Top_Level --\n+         --------------------------\n+\n+         --  pragma Favor_Top_Level (type_NAME);\n+\n+         when Pragma_Favor_Top_Level => Favor_Top_Level : declare\n+               Named_Entity : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_Arg_Count (1);\n+            Check_Arg_Is_Local_Name (Arg1);\n+            Named_Entity := Entity (Expression (Arg1));\n+\n+            --  If it's an access-to-subprogram type (in particular, not a\n+            --  subtype), set the flag on that type.\n+\n+            if Ekind (Named_Entity) in Access_Subprogram_Type_Kind then\n+               Set_Can_Use_Internal_Rep (Named_Entity, False);\n+\n+            --  Otherwise it's an error (name denotes the wrong sort of entity)\n+\n+            else\n+               Error_Pragma_Arg\n+                 (\"access-to-subprogram type expected\", Expression (Arg1));\n+            end if;\n+         end Favor_Top_Level;\n+\n+         ---------------\n+         -- Fast_Math --\n+         ---------------\n+\n+         --  pragma Fast_Math;\n+\n+         when Pragma_Fast_Math =>\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+            Check_Valid_Configuration_Pragma;\n+            Fast_Math := True;\n+\n          ---------------------------\n          -- Finalize_Storage_Only --\n          ---------------------------\n@@ -6862,6 +6919,46 @@ package body Sem_Prag is\n             end;\n          end Ident;\n \n+         --------------------------\n+         -- Implemented_By_Entry --\n+         --------------------------\n+\n+         --  pragma Implemented_By_Entry (DIRECT_NAME);\n+\n+         when Pragma_Implemented_By_Entry => Implemented_By_Entry : declare\n+            Ent : Entity_Id;\n+\n+         begin\n+            Ada_2005_Pragma;\n+            Check_Arg_Count (1);\n+            Check_No_Identifiers;\n+            Check_Arg_Is_Identifier (Arg1);\n+            Check_Arg_Is_Local_Name (Arg1);\n+            Ent := Entity (Expression (Arg1));\n+\n+            --  Pragma Implemented_By_Entry must be applied only to protected\n+            --  synchronized or task interface primitives.\n+\n+            if (Ekind (Ent) /= E_Function\n+                  and then Ekind (Ent) /= E_Procedure)\n+               or else not Present (First_Formal (Ent))\n+               or else not Is_Concurrent_Interface (Etype (First_Formal (Ent)))\n+            then\n+               Error_Pragma_Arg\n+                 (\"pragma % must be applied to a concurrent interface \" &\n+                  \"primitive\", Arg1);\n+\n+            else\n+               if Einfo.Implemented_By_Entry (Ent)\n+                 and then Warn_On_Redundant_Constructs\n+               then\n+                  Error_Pragma (\"?duplicate pragma%!\");\n+               else\n+                  Set_Implemented_By_Entry (Ent);\n+               end if;\n+            end if;\n+         end Implemented_By_Entry;\n+\n          -----------------------\n          -- Implicit_Packing --\n          -----------------------\n@@ -6878,8 +6975,8 @@ package body Sem_Prag is\n          ------------\n \n          --  pragma Import (\n-         --    [   Convention    =>] convention_IDENTIFIER,\n-         --    [   Entity        =>] local_NAME\n+         --       [Convention    =>] convention_IDENTIFIER,\n+         --       [Entity        =>] local_NAME\n          --    [, [External_Name =>] static_string_EXPRESSION ]\n          --    [, [Link_Name     =>] static_string_EXPRESSION ]);\n \n@@ -6899,8 +6996,8 @@ package body Sem_Prag is\n          ----------------------\n \n          --  pragma Import_Exception (\n-         --        [Internal         =>] LOCAL_NAME,\n-         --     [, [External         =>] EXTERNAL_SYMBOL,]\n+         --        [Internal         =>] LOCAL_NAME\n+         --     [, [External         =>] EXTERNAL_SYMBOL]\n          --     [, [Form     =>] Ada | VMS]\n          --     [, [Code     =>] static_integer_EXPRESSION]);\n \n@@ -7012,7 +7109,7 @@ package body Sem_Prag is\n          -------------------\n \n          --  pragma Import_Object (\n-         --        [Internal =>] LOCAL_NAME,\n+         --        [Internal =>] LOCAL_NAME\n          --     [, [External =>] EXTERNAL_SYMBOL]\n          --     [, [Size     =>] EXTERNAL_SYMBOL]);\n \n@@ -7045,7 +7142,7 @@ package body Sem_Prag is\n          ----------------------\n \n          --  pragma Import_Procedure (\n-         --        [Internal                 =>] LOCAL_NAME,\n+         --        [Internal                 =>] LOCAL_NAME\n          --     [, [External                 =>] EXTERNAL_SYMBOL]\n          --     [, [Parameter_Types          =>] (PARAMETER_TYPES)]\n          --     [, [Mechanism                =>] MECHANISM]\n@@ -7108,7 +7205,7 @@ package body Sem_Prag is\n          -----------------------------\n \n          --  pragma Import_Valued_Procedure (\n-         --        [Internal                 =>] LOCAL_NAME,\n+         --        [Internal                 =>] LOCAL_NAME\n          --     [, [External                 =>] EXTERNAL_SYMBOL]\n          --     [, [Parameter_Types          =>] (PARAMETER_TYPES)]\n          --     [, [Mechanism                =>] MECHANISM]\n@@ -8070,9 +8167,9 @@ package body Sem_Prag is\n          -----------------------\n \n          --  pragma Machine_Attribute (\n-         --    [Entity         =>] LOCAL_NAME,\n-         --    [Attribute_Name =>] static_string_EXPRESSION\n-         --  [,[Info           =>] static_string_EXPRESSION] );\n+         --       [Entity         =>] LOCAL_NAME,\n+         --       [Attribute_Name =>] static_string_EXPRESSION\n+         --    [, [Info           =>] static_string_EXPRESSION] );\n \n          when Pragma_Machine_Attribute => Machine_Attribute : declare\n             Def_Id : Entity_Id;\n@@ -8282,6 +8379,13 @@ package body Sem_Prag is\n                     or else Ekind (E) = E_Generic_Procedure\n                   then\n                      Set_No_Return (E);\n+\n+                     --  Set flag on any alias as well\n+\n+                     if Is_Overloadable (E) and then Present (Alias (E)) then\n+                        Set_No_Return (Alias (E));\n+                     end if;\n+\n                      Found := True;\n                   end if;\n \n@@ -8550,13 +8654,13 @@ package body Sem_Prag is\n             No_Run_Time_Mode           := True;\n             Configurable_Run_Time_Mode := True;\n \n-            declare\n-               Word32 : constant Boolean := Ttypes.System_Word_Size = 32;\n-            begin\n-               if Word32 then\n-                  Duration_32_Bits_On_Target := True;\n-               end if;\n-            end;\n+            --  Set Duration to 32 bits if word size is 32\n+\n+            if Ttypes.System_Word_Size = 32 then\n+               Duration_32_Bits_On_Target := True;\n+            end if;\n+\n+            --  Set appropriate restrictions\n \n             Set_Restriction (No_Finalization, N);\n             Set_Restriction (No_Exception_Handlers, N);\n@@ -8744,12 +8848,31 @@ package body Sem_Prag is\n             Check_First_Subtype (Arg1);\n             Ent := Entity (Expression (Arg1));\n \n-            if not Is_Private_Type (Ent) then\n+            if not Is_Private_Type (Ent)\n+              and then not Is_Protected_Type (Ent)\n+            then\n                Error_Pragma_Arg\n-                 (\"pragma % can only be applied to private type\", Arg1);\n+                 (\"pragma % can only be applied to private or protected type\",\n+                  Arg1);\n             end if;\n \n-            Set_Known_To_Have_Preelab_Init (Ent);\n+            --  Give an error if the pragma is applied to a protected type that\n+            --  does not qualify (due to having entries, or due to components\n+            --  that do not qualify).\n+\n+            if Is_Protected_Type (Ent)\n+              and then not Has_Preelaborable_Initialization (Ent)\n+            then\n+               Error_Msg_N\n+                 (\"protected type & does not have preelaborable \" &\n+                  \"initialization\", Ent);\n+\n+            --  Otherwise mark the type as definitely having preelaborable\n+            --  initialization.\n+\n+            else\n+               Set_Known_To_Have_Preelab_Init (Ent);\n+            end if;\n \n             if Has_Pragma_Preelab_Init (Ent)\n               and then Warn_On_Redundant_Constructs\n@@ -11277,10 +11400,13 @@ package body Sem_Prag is\n       Pragma_Extend_System                 => -1,\n       Pragma_Extensions_Allowed            => -1,\n       Pragma_External                      => -1,\n+      Pragma_Favor_Top_Level               => -1,\n       Pragma_External_Name_Casing          => -1,\n+      Pragma_Fast_Math                     => -1,\n       Pragma_Finalize_Storage_Only         =>  0,\n       Pragma_Float_Representation          =>  0,\n       Pragma_Ident                         => -1,\n+      Pragma_Implemented_By_Entry          => -1,\n       Pragma_Implicit_Packing              =>  0,\n       Pragma_Import                        => +2,\n       Pragma_Import_Exception              =>  0,"}, {"sha": "b02f764515452278a57756c970c800c3abaa2cfb", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -93,8 +93,9 @@ package body Snames is\n      \"_disp_asynchronous_select#\" &\n      \"_disp_conditional_select#\" &\n      \"_disp_get_prim_op_kind#\" &\n-     \"_disp_timed_select#\" &\n      \"_disp_get_task_id#\" &\n+     \"_disp_requeue#\" &\n+     \"_disp_timed_select#\" &\n      \"initialize#\" &\n      \"adjust#\" &\n      \"finalize#\" &\n@@ -194,6 +195,7 @@ package body Snames is\n      \"extend_system#\" &\n      \"extensions_allowed#\" &\n      \"external_name_casing#\" &\n+     \"favor_top_level#\" &\n      \"float_representation#\" &\n      \"implicit_packing#\" &\n      \"initialize_scalars#\" &\n@@ -261,6 +263,7 @@ package body Snames is\n      \"external#\" &\n      \"finalize_storage_only#\" &\n      \"ident#\" &\n+     \"implemented_by_entry#\" &\n      \"import#\" &\n      \"import_exception#\" &\n      \"import_function#\" &\n@@ -456,6 +459,7 @@ package body Snames is\n      \"epsilon#\" &\n      \"exponent#\" &\n      \"external_tag#\" &\n+     \"fast_math#\" &\n      \"first#\" &\n      \"first_bit#\" &\n      \"fixed_value#\" &\n@@ -569,7 +573,6 @@ package body Snames is\n      \"priority_queuing#\" &\n      \"edf_across_priorities#\" &\n      \"fifo_within_priorities#\" &\n-     \"non_preemptive_within_priorities#\" &\n      \"round_robin_within_priorities#\" &\n      \"access_check#\" &\n      \"accessibility_check#\" &\n@@ -927,6 +930,8 @@ package body Snames is\n    begin\n       if N = Name_AST_Entry then\n          return Pragma_AST_Entry;\n+      elsif N = Name_Fast_Math then\n+         return Pragma_Fast_Math;\n       elsif N = Name_Interface then\n          return Pragma_Interface;\n       elsif N = Name_Priority then\n@@ -955,8 +960,9 @@ package body Snames is\n    -- Get_Task_Dispatching_Policy_Id --\n    ------------------------------------\n \n-   function Get_Task_Dispatching_Policy_Id (N : Name_Id)\n-     return Task_Dispatching_Policy_Id is\n+   function Get_Task_Dispatching_Policy_Id\n+     (N : Name_Id) return Task_Dispatching_Policy_Id\n+   is\n    begin\n       return Task_Dispatching_Policy_Id'Val\n         (N - First_Task_Dispatching_Policy_Name);\n@@ -972,10 +978,8 @@ package body Snames is\n \n    begin\n       P_Index := Preset_Names'First;\n-\n       loop\n          Name_Len := 0;\n-\n          while Preset_Names (P_Index) /= '#' loop\n             Name_Len := Name_Len + 1;\n             Name_Buffer (Name_Len) := Preset_Names (P_Index);\n@@ -1024,6 +1028,16 @@ package body Snames is\n       return N in First_Attribute_Name .. Last_Attribute_Name;\n    end Is_Attribute_Name;\n \n+   ----------------------------------\n+   -- Is_Configuration_Pragma_Name --\n+   ----------------------------------\n+\n+   function Is_Configuration_Pragma_Name (N : Name_Id) return Boolean is\n+   begin\n+      return N in First_Pragma_Name .. Last_Configuration_Pragma_Name\n+        or else N = Name_Fast_Math;\n+   end Is_Configuration_Pragma_Name;\n+\n    ------------------------\n    -- Is_Convention_Name --\n    ------------------------\n@@ -1109,6 +1123,7 @@ package body Snames is\n    begin\n       return N in First_Pragma_Name .. Last_Pragma_Name\n         or else N = Name_AST_Entry\n+        or else N = Name_Fast_Math\n         or else N = Name_Interface\n         or else N = Name_Priority\n         or else N = Name_Storage_Size"}, {"sha": "494e79f12230573d76b1db4bfc6b549d1442fbf7", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 790, "deletions": 768, "changes": 1558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48"}, {"sha": "131ed99b4c967a60b1f304b538b879544c2e995a", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 260, "deletions": 256, "changes": 516, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/470cd9e99870bde530a3f6087efdc00d9b3f8f48/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=470cd9e99870bde530a3f6087efdc00d9b3f8f48", "patch": "@@ -76,129 +76,130 @@ extern unsigned char Get_Attribute_Id (int);\n #define  Attr_Epsilon                       29\n #define  Attr_Exponent                      30\n #define  Attr_External_Tag                  31\n-#define  Attr_First                         32\n-#define  Attr_First_Bit                     33\n-#define  Attr_Fixed_Value                   34\n-#define  Attr_Fore                          35\n-#define  Attr_Has_Access_Values             36\n-#define  Attr_Has_Discriminants             37\n-#define  Attr_Identity                      38\n-#define  Attr_Img                           39\n-#define  Attr_Integer_Value                 40\n-#define  Attr_Large                         41\n-#define  Attr_Last                          42\n-#define  Attr_Last_Bit                      43\n-#define  Attr_Leading_Part                  44\n-#define  Attr_Length                        45\n-#define  Attr_Machine_Emax                  46\n-#define  Attr_Machine_Emin                  47\n-#define  Attr_Machine_Mantissa              48\n-#define  Attr_Machine_Overflows             49\n-#define  Attr_Machine_Radix                 50\n-#define  Attr_Machine_Rounding              51\n-#define  Attr_Machine_Rounds                52\n-#define  Attr_Machine_Size                  53\n-#define  Attr_Mantissa                      54\n-#define  Attr_Max_Size_In_Storage_Elements  55\n-#define  Attr_Maximum_Alignment             56\n-#define  Attr_Mechanism_Code                57\n-#define  Attr_Mod                           58\n-#define  Attr_Model_Emin                    59\n-#define  Attr_Model_Epsilon                 60\n-#define  Attr_Model_Mantissa                61\n-#define  Attr_Model_Small                   62\n-#define  Attr_Modulus                       63\n-#define  Attr_Null_Parameter                64\n-#define  Attr_Object_Size                   65\n-#define  Attr_Partition_ID                  66\n-#define  Attr_Passed_By_Reference           67\n-#define  Attr_Pool_Address                  68\n-#define  Attr_Pos                           69\n-#define  Attr_Position                      70\n-#define  Attr_Priority                      71\n-#define  Attr_Range                         72\n-#define  Attr_Range_Length                  73\n-#define  Attr_Round                         74\n-#define  Attr_Safe_Emax                     75\n-#define  Attr_Safe_First                    76\n-#define  Attr_Safe_Large                    77\n-#define  Attr_Safe_Last                     78\n-#define  Attr_Safe_Small                    79\n-#define  Attr_Scale                         80\n-#define  Attr_Scaling                       81\n-#define  Attr_Signed_Zeros                  82\n-#define  Attr_Size                          83\n-#define  Attr_Small                         84\n-#define  Attr_Storage_Size                  85\n-#define  Attr_Storage_Unit                  86\n-#define  Attr_Stream_Size                   87\n-#define  Attr_Tag                           88\n-#define  Attr_Target_Name                   89\n-#define  Attr_Terminated                    90\n-#define  Attr_To_Address                    91\n-#define  Attr_Type_Class                    92\n-#define  Attr_UET_Address                   93\n-#define  Attr_Unbiased_Rounding             94\n-#define  Attr_Unchecked_Access              95\n-#define  Attr_Unconstrained_Array           96\n-#define  Attr_Universal_Literal_String      97\n-#define  Attr_Unrestricted_Access           98\n-#define  Attr_VADS_Size                     99\n-#define  Attr_Val                           100\n-#define  Attr_Valid                         101\n-#define  Attr_Value_Size                    102\n-#define  Attr_Version                       103\n-#define  Attr_Wchar_T_Size                  104\n-#define  Attr_Wide_Wide_Width               105\n-#define  Attr_Wide_Width                    106\n-#define  Attr_Width                         107\n-#define  Attr_Word_Size                     108\n-#define  Attr_Adjacent                      109\n-#define  Attr_Ceiling                       110\n-#define  Attr_Copy_Sign                     111\n-#define  Attr_Floor                         112\n-#define  Attr_Fraction                      113\n-#define  Attr_Image                         114\n-#define  Attr_Input                         115\n-#define  Attr_Machine                       116\n-#define  Attr_Max                           117\n-#define  Attr_Min                           118\n-#define  Attr_Model                         119\n-#define  Attr_Pred                          120\n-#define  Attr_Remainder                     121\n-#define  Attr_Rounding                      122\n-#define  Attr_Succ                          123\n-#define  Attr_Truncation                    124\n-#define  Attr_Value                         125\n-#define  Attr_Wide_Image                    126\n-#define  Attr_Wide_Wide_Image               127\n-#define  Attr_Wide_Value                    128\n-#define  Attr_Wide_Wide_Value               129\n-#define  Attr_Output                        130\n-#define  Attr_Read                          131\n-#define  Attr_Write                         132\n-#define  Attr_Elab_Body                     133\n-#define  Attr_Elab_Spec                     134\n-#define  Attr_Storage_Pool                  135\n-#define  Attr_Base                          136\n-#define  Attr_Class                         137\n-#define  Attr_Stub_Type                     138\n+#define  Attr_Fast_Math                     32\n+#define  Attr_First                         33\n+#define  Attr_First_Bit                     34\n+#define  Attr_Fixed_Value                   35\n+#define  Attr_Fore                          36\n+#define  Attr_Has_Access_Values             37\n+#define  Attr_Has_Discriminants             38\n+#define  Attr_Identity                      39\n+#define  Attr_Img                           40\n+#define  Attr_Integer_Value                 41\n+#define  Attr_Large                         42\n+#define  Attr_Last                          43\n+#define  Attr_Last_Bit                      44\n+#define  Attr_Leading_Part                  45\n+#define  Attr_Length                        46\n+#define  Attr_Machine_Emax                  47\n+#define  Attr_Machine_Emin                  48\n+#define  Attr_Machine_Mantissa              49\n+#define  Attr_Machine_Overflows             50\n+#define  Attr_Machine_Radix                 51\n+#define  Attr_Machine_Rounding              52\n+#define  Attr_Machine_Rounds                53\n+#define  Attr_Machine_Size                  54\n+#define  Attr_Mantissa                      55\n+#define  Attr_Max_Size_In_Storage_Elements  56\n+#define  Attr_Maximum_Alignment             57\n+#define  Attr_Mechanism_Code                58\n+#define  Attr_Mod                           59\n+#define  Attr_Model_Emin                    60\n+#define  Attr_Model_Epsilon                 61\n+#define  Attr_Model_Mantissa                62\n+#define  Attr_Model_Small                   63\n+#define  Attr_Modulus                       64\n+#define  Attr_Null_Parameter                65\n+#define  Attr_Object_Size                   66\n+#define  Attr_Partition_ID                  67\n+#define  Attr_Passed_By_Reference           68\n+#define  Attr_Pool_Address                  69\n+#define  Attr_Pos                           70\n+#define  Attr_Position                      71\n+#define  Attr_Priority                      72\n+#define  Attr_Range                         73\n+#define  Attr_Range_Length                  74\n+#define  Attr_Round                         75\n+#define  Attr_Safe_Emax                     76\n+#define  Attr_Safe_First                    77\n+#define  Attr_Safe_Large                    78\n+#define  Attr_Safe_Last                     79\n+#define  Attr_Safe_Small                    80\n+#define  Attr_Scale                         81\n+#define  Attr_Scaling                       82\n+#define  Attr_Signed_Zeros                  83\n+#define  Attr_Size                          84\n+#define  Attr_Small                         85\n+#define  Attr_Storage_Size                  86\n+#define  Attr_Storage_Unit                  87\n+#define  Attr_Stream_Size                   88\n+#define  Attr_Tag                           89\n+#define  Attr_Target_Name                   90\n+#define  Attr_Terminated                    91\n+#define  Attr_To_Address                    92\n+#define  Attr_Type_Class                    93\n+#define  Attr_UET_Address                   94\n+#define  Attr_Unbiased_Rounding             95\n+#define  Attr_Unchecked_Access              96\n+#define  Attr_Unconstrained_Array           97\n+#define  Attr_Universal_Literal_String      98\n+#define  Attr_Unrestricted_Access           99\n+#define  Attr_VADS_Size                     100\n+#define  Attr_Val                           101\n+#define  Attr_Valid                         102\n+#define  Attr_Value_Size                    103\n+#define  Attr_Version                       104\n+#define  Attr_Wchar_T_Size                  105\n+#define  Attr_Wide_Wide_Width               106\n+#define  Attr_Wide_Width                    107\n+#define  Attr_Width                         108\n+#define  Attr_Word_Size                     109\n+#define  Attr_Adjacent                      110\n+#define  Attr_Ceiling                       111\n+#define  Attr_Copy_Sign                     112\n+#define  Attr_Floor                         113\n+#define  Attr_Fraction                      114\n+#define  Attr_Image                         115\n+#define  Attr_Input                         116\n+#define  Attr_Machine                       117\n+#define  Attr_Max                           118\n+#define  Attr_Min                           119\n+#define  Attr_Model                         120\n+#define  Attr_Pred                          121\n+#define  Attr_Remainder                     122\n+#define  Attr_Rounding                      123\n+#define  Attr_Succ                          124\n+#define  Attr_Truncation                    125\n+#define  Attr_Value                         126\n+#define  Attr_Wide_Image                    127\n+#define  Attr_Wide_Wide_Image               128\n+#define  Attr_Wide_Value                    129\n+#define  Attr_Wide_Wide_Value               130\n+#define  Attr_Output                        131\n+#define  Attr_Read                          132\n+#define  Attr_Write                         133\n+#define  Attr_Elab_Body                     134\n+#define  Attr_Elab_Spec                     135\n+#define  Attr_Storage_Pool                  136\n+#define  Attr_Base                          137\n+#define  Attr_Class                         138\n+#define  Attr_Stub_Type                     139\n \n /* Define the numeric values for the conventions.  */\n \n #define  Convention_Ada                           0\n #define  Convention_Intrinsic                     1\n #define  Convention_Entry                         2\n #define  Convention_Protected                     3\n-#define  Convention_Assembler                     4\n-#define  Convention_C                             5\n-#define  Convention_CIL                           6\n-#define  Convention_COBOL                         7\n-#define  Convention_CPP                           8\n-#define  Convention_Fortran                       9\n-#define  Convention_Java                          10\n-#define  Convention_Stdcall                       11\n-#define  Convention_Stubbed                       12\n+#define  Convention_Stubbed                       4\n+#define  Convention_Assembler                     5\n+#define  Convention_C                             6\n+#define  Convention_CIL                           7\n+#define  Convention_COBOL                         8\n+#define  Convention_CPP                           9\n+#define  Convention_Fortran                       10\n+#define  Convention_Java                          11\n+#define  Convention_Stdcall                       12\n \n /* Define the function to check if a Name_Id value is a valid pragma */\n \n@@ -235,145 +236,148 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Extend_System                 17\n #define  Pragma_Extensions_Allowed            18\n #define  Pragma_External_Name_Casing          19\n-#define  Pragma_Float_Representation          20\n-#define  Pragma_Implicit_Packing              21\n-#define  Pragma_Initialize_Scalars            22\n-#define  Pragma_Interrupt_State               23\n-#define  Pragma_License                       24\n-#define  Pragma_Locking_Policy                25\n-#define  Pragma_Long_Float                    26\n-#define  Pragma_No_Run_Time                   27\n-#define  Pragma_No_Strict_Aliasing            28\n-#define  Pragma_Normalize_Scalars             29\n-#define  Pragma_Polling                       30\n-#define  Pragma_Persistent_BSS                31\n-#define  Pragma_Priority_Specific_Dispatching 32\n-#define  Pragma_Profile                       33\n-#define  Pragma_Profile_Warnings              34\n-#define  Pragma_Propagate_Exceptions          35\n-#define  Pragma_Queuing_Policy                36\n-#define  Pragma_Ravenscar                     37\n-#define  Pragma_Restricted_Run_Time           38\n-#define  Pragma_Restrictions                  39\n-#define  Pragma_Restriction_Warnings          40\n-#define  Pragma_Reviewable                    41\n-#define  Pragma_Source_File_Name              42\n-#define  Pragma_Source_File_Name_Project      43\n-#define  Pragma_Style_Checks                  44\n-#define  Pragma_Suppress                      45\n-#define  Pragma_Suppress_Exception_Locations  46\n-#define  Pragma_Task_Dispatching_Policy       47\n-#define  Pragma_Universal_Data                48\n-#define  Pragma_Unsuppress                    49\n-#define  Pragma_Use_VADS_Size                 50\n-#define  Pragma_Validity_Checks               51\n-#define  Pragma_Warnings                      52\n-#define  Pragma_Wide_Character_Encoding       53\n-#define  Pragma_Abort_Defer                   54\n-#define  Pragma_All_Calls_Remote              55\n-#define  Pragma_Annotate                      56\n-#define  Pragma_Assert                        57\n-#define  Pragma_Asynchronous                  58\n-#define  Pragma_Atomic                        59\n-#define  Pragma_Atomic_Components             60\n-#define  Pragma_Attach_Handler                61\n-#define  Pragma_CIL_Constructor               62\n-#define  Pragma_Comment                       63\n-#define  Pragma_Common_Object                 64\n-#define  Pragma_Complete_Representation       65\n-#define  Pragma_Complex_Representation        66\n-#define  Pragma_Controlled                    67\n-#define  Pragma_Convention                    68\n-#define  Pragma_CPP_Class                     69\n-#define  Pragma_CPP_Constructor               70\n-#define  Pragma_CPP_Virtual                   71\n-#define  Pragma_CPP_Vtable                    72\n-#define  Pragma_Debug                         73\n-#define  Pragma_Elaborate                     74\n-#define  Pragma_Elaborate_All                 75\n-#define  Pragma_Elaborate_Body                76\n-#define  Pragma_Export                        77\n-#define  Pragma_Export_Exception              78\n-#define  Pragma_Export_Function               79\n-#define  Pragma_Export_Object                 80\n-#define  Pragma_Export_Procedure              81\n-#define  Pragma_Export_Value                  82\n-#define  Pragma_Export_Valued_Procedure       83\n-#define  Pragma_External                      84\n-#define  Pragma_Finalize_Storage_Only         85\n-#define  Pragma_Ident                         86\n-#define  Pragma_Import                        87\n-#define  Pragma_Import_Exception              88\n-#define  Pragma_Import_Function               89\n-#define  Pragma_Import_Object                 90\n-#define  Pragma_Import_Procedure              91\n-#define  Pragma_Import_Valued_Procedure       92\n-#define  Pragma_Inline                        93\n-#define  Pragma_Inline_Always                 94\n-#define  Pragma_Inline_Generic                95\n-#define  Pragma_Inspection_Point              96\n-#define  Pragma_Interface_Name                97\n-#define  Pragma_Interrupt_Handler             98\n-#define  Pragma_Interrupt_Priority            99\n-#define  Pragma_Java_Constructor              100\n-#define  Pragma_Java_Interface                101\n-#define  Pragma_Keep_Names                    102\n-#define  Pragma_Link_With                     103\n-#define  Pragma_Linker_Alias                  104\n-#define  Pragma_Linker_Constructor            105\n-#define  Pragma_Linker_Destructor             106\n-#define  Pragma_Linker_Options                107\n-#define  Pragma_Linker_Section                108\n-#define  Pragma_List                          109\n-#define  Pragma_Machine_Attribute             110\n-#define  Pragma_Main                          111\n-#define  Pragma_Main_Storage                  112\n-#define  Pragma_Memory_Size                   113\n-#define  Pragma_No_Body                       114\n-#define  Pragma_No_Return                     115\n-#define  Pragma_Obsolescent                   116\n-#define  Pragma_Optimize                      117\n-#define  Pragma_Pack                          118\n-#define  Pragma_Page                          119\n-#define  Pragma_Passive                       120\n-#define  Pragma_Preelaborable_Initialization  121\n-#define  Pragma_Preelaborate                  122\n-#define  Pragma_Preelaborate_05               123\n-#define  Pragma_Psect_Object                  124\n-#define  Pragma_Pure                          125\n-#define  Pragma_Pure_05                       126\n-#define  Pragma_Pure_Function                 127\n-#define  Pragma_Remote_Call_Interface         128\n-#define  Pragma_Remote_Types                  129\n-#define  Pragma_Share_Generic                 130\n-#define  Pragma_Shared                        131\n-#define  Pragma_Shared_Passive                132\n-#define  Pragma_Source_Reference              133\n-#define  Pragma_Static_Elaboration_Desired    134\n-#define  Pragma_Stream_Convert                135\n-#define  Pragma_Subtitle                      136\n-#define  Pragma_Suppress_All                  137\n-#define  Pragma_Suppress_Debug_Info           138\n-#define  Pragma_Suppress_Initialization       139\n-#define  Pragma_System_Name                   140\n-#define  Pragma_Task_Info                     141\n-#define  Pragma_Task_Name                     142\n-#define  Pragma_Task_Storage                  143\n-#define  Pragma_Time_Slice                    144\n-#define  Pragma_Title                         145\n-#define  Pragma_Unchecked_Union               146\n-#define  Pragma_Unimplemented_Unit            147\n-#define  Pragma_Universal_Aliasing            148\n-#define  Pragma_Unreferenced                  149\n-#define  Pragma_Unreferenced_Objects          150\n-#define  Pragma_Unreserve_All_Interrupts      151\n-#define  Pragma_Volatile                      152\n-#define  Pragma_Volatile_Components           153\n-#define  Pragma_Weak_External                 154\n-#define  Pragma_AST_Entry                     155\n-#define  Pragma_Interface                     156\n-#define  Pragma_Priority                      157\n-#define  Pragma_Storage_Size                  158\n-#define  Pragma_Storage_Unit                  159\n+#define  Pragma_Favor_Top_Level               20\n+#define  Pragma_Float_Representation          21\n+#define  Pragma_Implicit_Packing              22\n+#define  Pragma_Initialize_Scalars            23\n+#define  Pragma_Interrupt_State               24\n+#define  Pragma_License                       25\n+#define  Pragma_Locking_Policy                26\n+#define  Pragma_Long_Float                    27\n+#define  Pragma_No_Run_Time                   28\n+#define  Pragma_No_Strict_Aliasing            29\n+#define  Pragma_Normalize_Scalars             30\n+#define  Pragma_Polling                       31\n+#define  Pragma_Persistent_BSS                32\n+#define  Pragma_Priority_Specific_Dispatching 33\n+#define  Pragma_Profile                       34\n+#define  Pragma_Profile_Warnings              35\n+#define  Pragma_Propagate_Exceptions          36\n+#define  Pragma_Queuing_Policy                37\n+#define  Pragma_Ravenscar                     38\n+#define  Pragma_Restricted_Run_Time           39\n+#define  Pragma_Restrictions                  40\n+#define  Pragma_Restriction_Warnings          41\n+#define  Pragma_Reviewable                    42\n+#define  Pragma_Source_File_Name              43\n+#define  Pragma_Source_File_Name_Project      44\n+#define  Pragma_Style_Checks                  45\n+#define  Pragma_Suppress                      46\n+#define  Pragma_Suppress_Exception_Locations  47\n+#define  Pragma_Task_Dispatching_Policy       48\n+#define  Pragma_Universal_Data                49\n+#define  Pragma_Unsuppress                    50\n+#define  Pragma_Use_VADS_Size                 51\n+#define  Pragma_Validity_Checks               52\n+#define  Pragma_Warnings                      53\n+#define  Pragma_Wide_Character_Encoding       54\n+#define  Pragma_Abort_Defer                   55\n+#define  Pragma_All_Calls_Remote              56\n+#define  Pragma_Annotate                      57\n+#define  Pragma_Assert                        58\n+#define  Pragma_Asynchronous                  59\n+#define  Pragma_Atomic                        60\n+#define  Pragma_Atomic_Components             61\n+#define  Pragma_Attach_Handler                62\n+#define  Pragma_CIL_Constructor               63\n+#define  Pragma_Comment                       64\n+#define  Pragma_Common_Object                 65\n+#define  Pragma_Complete_Representation       66\n+#define  Pragma_Complex_Representation        67\n+#define  Pragma_Controlled                    68\n+#define  Pragma_Convention                    69\n+#define  Pragma_CPP_Class                     70\n+#define  Pragma_CPP_Constructor               71\n+#define  Pragma_CPP_Virtual                   72\n+#define  Pragma_CPP_Vtable                    73\n+#define  Pragma_Debug                         74\n+#define  Pragma_Elaborate                     75\n+#define  Pragma_Elaborate_All                 76\n+#define  Pragma_Elaborate_Body                77\n+#define  Pragma_Export                        78\n+#define  Pragma_Export_Exception              79\n+#define  Pragma_Export_Function               80\n+#define  Pragma_Export_Object                 81\n+#define  Pragma_Export_Procedure              82\n+#define  Pragma_Export_Value                  83\n+#define  Pragma_Export_Valued_Procedure       84\n+#define  Pragma_External                      85\n+#define  Pragma_Finalize_Storage_Only         86\n+#define  Pragma_Ident                         87\n+#define  Pragma_Implemented_By_Entry          88\n+#define  Pragma_Import                        89\n+#define  Pragma_Import_Exception              90\n+#define  Pragma_Import_Function               91\n+#define  Pragma_Import_Object                 92\n+#define  Pragma_Import_Procedure              93\n+#define  Pragma_Import_Valued_Procedure       94\n+#define  Pragma_Inline                        95\n+#define  Pragma_Inline_Always                 96\n+#define  Pragma_Inline_Generic                97\n+#define  Pragma_Inspection_Point              98\n+#define  Pragma_Interface_Name                99\n+#define  Pragma_Interrupt_Handler             100\n+#define  Pragma_Interrupt_Priority            101\n+#define  Pragma_Java_Constructor              102\n+#define  Pragma_Java_Interface                103\n+#define  Pragma_Keep_Names                    104\n+#define  Pragma_Link_With                     105\n+#define  Pragma_Linker_Alias                  106\n+#define  Pragma_Linker_Constructor            107\n+#define  Pragma_Linker_Destructor             108\n+#define  Pragma_Linker_Options                109\n+#define  Pragma_Linker_Section                110\n+#define  Pragma_List                          111\n+#define  Pragma_Machine_Attribute             112\n+#define  Pragma_Main                          113\n+#define  Pragma_Main_Storage                  114\n+#define  Pragma_Memory_Size                   115\n+#define  Pragma_No_Body                       116\n+#define  Pragma_No_Return                     117\n+#define  Pragma_Obsolescent                   118\n+#define  Pragma_Optimize                      119\n+#define  Pragma_Pack                          120\n+#define  Pragma_Page                          121\n+#define  Pragma_Passive                       122\n+#define  Pragma_Preelaborable_Initialization  123\n+#define  Pragma_Preelaborate                  124\n+#define  Pragma_Preelaborate_05               125\n+#define  Pragma_Psect_Object                  126\n+#define  Pragma_Pure                          127\n+#define  Pragma_Pure_05                       128\n+#define  Pragma_Pure_Function                 129\n+#define  Pragma_Remote_Call_Interface         130\n+#define  Pragma_Remote_Types                  131\n+#define  Pragma_Share_Generic                 132\n+#define  Pragma_Shared                        133\n+#define  Pragma_Shared_Passive                134\n+#define  Pragma_Source_Reference              135\n+#define  Pragma_Static_Elaboration_Desired    136\n+#define  Pragma_Stream_Convert                137\n+#define  Pragma_Subtitle                      138\n+#define  Pragma_Suppress_All                  139\n+#define  Pragma_Suppress_Debug_Info           140\n+#define  Pragma_Suppress_Initialization       141\n+#define  Pragma_System_Name                   142\n+#define  Pragma_Task_Info                     143\n+#define  Pragma_Task_Name                     144\n+#define  Pragma_Task_Storage                  145\n+#define  Pragma_Time_Slice                    146\n+#define  Pragma_Title                         147\n+#define  Pragma_Unchecked_Union               148\n+#define  Pragma_Unimplemented_Unit            149\n+#define  Pragma_Universal_Aliasing            150\n+#define  Pragma_Unreferenced                  151\n+#define  Pragma_Unreferenced_Objects          152\n+#define  Pragma_Unreserve_All_Interrupts      153\n+#define  Pragma_Volatile                      154\n+#define  Pragma_Volatile_Components           155\n+#define  Pragma_Weak_External                 156\n+#define  Pragma_AST_Entry                     157\n+#define  Pragma_Fast_Math                     158\n+#define  Pragma_Interface                     159\n+#define  Pragma_Priority                      160\n+#define  Pragma_Storage_Size                  161\n+#define  Pragma_Storage_Unit                  162\n \n /* End of snames.h (C version of Snames package spec) */"}]}