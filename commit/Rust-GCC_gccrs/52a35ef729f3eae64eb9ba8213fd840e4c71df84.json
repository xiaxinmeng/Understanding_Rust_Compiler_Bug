{"sha": "52a35ef729f3eae64eb9ba8213fd840e4c71df84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhMzVlZjcyOWYzZWFlNjRlYjliYTgyMTNmZDg0MGU0YzcxZGY4NA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-11-03T14:46:26Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-11-03T14:46:26Z"}, "message": "re PR lto/44965 (lto option code breaks file format with each added option)\n\n2011-11-03  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/44965\n\t* lto-opts.c: Re-implement.\n\t* lto-streamer.h (lto_register_user_option): Remove.\n\t(lto_read_file_options): Likewise.\n\t(lto_reissue_options): Likewise.\n\t(lto_clear_user_options): Likewise.\n\t(lto_clear_file_options): Likewise.\n\t* opts-global.c (post_handling_callback): Remove.\n\t(set_default_handlers): Do not set post_handling_callback.\n\t(decode_options): Remove LTO specific code.\n\t* lto-wrapper.c (merge_and_complain): New function.\n\t(run_gcc): Read all input file options and\n\tprepend a merged set before the linker driver options.\n\t* gcc.c (driver_post_handling_callback): Remove.\n\t(set_option_handlers): Do not set post_handling_callback.\n\t* opts-common.c (handle_option): Do not call post_handling_callback.\n\t* opts.h (struct cl_option_handlers): Remove post_handling_callback.\n\n\tlto/\n\t* lto-lang.c (lto_post_options): Do not read file options.\n\t* lto.c (lto_read_all_file_options): Remove.\n\t(lto_init): Call lto_set_in_hooks here.\n\nFrom-SVN: r180827", "tree": {"sha": "9b93ef15724edc35794595b3bb53fc4cb6c6ae89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b93ef15724edc35794595b3bb53fc4cb6c6ae89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52a35ef729f3eae64eb9ba8213fd840e4c71df84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a35ef729f3eae64eb9ba8213fd840e4c71df84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a35ef729f3eae64eb9ba8213fd840e4c71df84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a35ef729f3eae64eb9ba8213fd840e4c71df84/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fa66fc02ec785e63a40ab808b7e8bf47ceb7770b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa66fc02ec785e63a40ab808b7e8bf47ceb7770b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa66fc02ec785e63a40ab808b7e8bf47ceb7770b"}], "stats": {"total": 759, "additions": 292, "deletions": 467}, "files": [{"sha": "5516c2fbb0a7039b2a63c5ebdbe0e0c3253b9676", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -1,3 +1,23 @@\n+2011-11-03  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44965\n+\t* lto-opts.c: Re-implement.\n+\t* lto-streamer.h (lto_register_user_option): Remove.\n+\t(lto_read_file_options): Likewise.\n+\t(lto_reissue_options): Likewise.\n+\t(lto_clear_user_options): Likewise.\n+\t(lto_clear_file_options): Likewise.\n+\t* opts-global.c (post_handling_callback): Remove.\n+\t(set_default_handlers): Do not set post_handling_callback.\n+\t(decode_options): Remove LTO specific code.\n+\t* lto-wrapper.c (merge_and_complain): New function.\n+\t(run_gcc): Read all input file options and\n+\tprepend a merged set before the linker driver options.\n+\t* gcc.c (driver_post_handling_callback): Remove.\n+\t(set_option_handlers): Do not set post_handling_callback.\n+\t* opts-common.c (handle_option): Do not call post_handling_callback.\n+\t* opts.h (struct cl_option_handlers): Remove post_handling_callback.\n+\n 2011-11-03  Richard Guenther  <rguenther@suse.de>\n \n \t* collect2.c (main): Guard object_nbr variable with TARGET_AIX_VERSION."}, {"sha": "46130dc1001020dccedad7828b55d2463c22db39", "filename": "gcc/gcc.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -3137,16 +3137,6 @@ driver_wrong_lang_callback (const struct cl_decoded_option *decoded,\n \t\t &decoded->canonical_option[1], false);\n }\n \n-/* Note that an option (index OPT_INDEX, argument ARG, value VALUE)\n-   has been successfully handled with a handler for mask MASK.  */\n-\n-static void\n-driver_post_handling_callback (const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n-\t\t\t       unsigned int mask ATTRIBUTE_UNUSED)\n-{\n-  /* Nothing to do here.  */\n-}\n-\n static const char *spec_lang = 0;\n static int last_language_n_infiles;\n \n@@ -3533,7 +3523,6 @@ set_option_handlers (struct cl_option_handlers *handlers)\n {\n   handlers->unknown_option_callback = driver_unknown_option_callback;\n   handlers->wrong_lang_callback = driver_wrong_lang_callback;\n-  handlers->post_handling_callback = driver_post_handling_callback;\n   handlers->num_handlers = 3;\n   handlers->handlers[0].handler = driver_handle_option;\n   handlers->handlers[0].mask = CL_DRIVER;"}, {"sha": "47f73aa01c6b85819f7f88a83cf2b6c7e96274b7", "filename": "gcc/lto-opts.c", "status": "modified", "additions": 68, "deletions": 369, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-opts.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -1,6 +1,6 @@\n /* LTO IL options.\n \n-   Copyright 2009, 2010, 2011 Free Software Foundation, Inc.\n+   Copyright 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n    Contributed by Simon Baldwin <simonb@google.com>\n \n This file is part of GCC.\n@@ -33,390 +33,89 @@ along with GCC; see the file COPYING3.  If not see\n #include \"common/common-target.h\"\n #include \"diagnostic.h\"\n #include \"lto-streamer.h\"\n-\n-/* When a file is initially compiled, the options used when generating\n-   the IL are not necessarily the same as those used when linking the\n-   objects into the final executable.  In general, most build systems\n-   will proceed with something along the lines of:\n-\n-   \t$ gcc <cc-flags> -flto -c f1.c -o f1.o\n-\t$ gcc <cc-flags> -flto -c f2.c -o f2.o\n-\t...\n-\t$ gcc <cc-flags> -flto -c fN.c -o fN.o\n-\n-   And the final link may or may not include the same <cc-flags> used\n-   to generate the initial object files:\n-\n-   \t$ gcc <ld-flags> -flto -o prog f1.o ... fN.o\n-\n-   Since we will be generating final code during the link step, some\n-   of the flags used during the compile step need to be re-applied\n-   during the link step.  For instance, flags in the -m family.\n-\n-   The idea is to save a selected set of <cc-flags> in a special\n-   section of the initial object files.  This section is then read\n-   during linking and the options re-applied.\n-\n-   FIXME lto.  Currently the scheme is limited in that only the\n-   options saved on the first object file (f1.o) are read back during\n-   the link step.  This means that the options used to compile f1.o\n-   will be applied to ALL the object files in the final link step.\n-   More work needs to be done to implement a merging and validation\n-   mechanism, as this will not be enough for all cases.  */\n-\n-/* Saved options hold the type of the option (currently CL_TARGET or\n-   CL_COMMON), and the code, argument, and value.  */\n-\n-typedef struct GTY(()) opt_d\n-{\n-  unsigned int type;\n-  size_t code;\n-  char *arg;\n-  int value;\n-} opt_t;\n-\n-DEF_VEC_O (opt_t);\n-DEF_VEC_ALLOC_O (opt_t, heap);\n-\n-\n-/* Options are held in two vectors, one for those registered by\n-   command line handling code, and the other for those read in from\n-   any LTO IL input.  */\n-static VEC(opt_t, heap) *user_options = NULL;\n-static VEC(opt_t, heap) *file_options = NULL;\n-\n-/* Iterate FROM in reverse, writing option codes not yet in CODES into *TO.\n-   Mark each new option code encountered in CODES.  */\n-\n-static void\n-reverse_iterate_options (VEC(opt_t, heap) *from, VEC(opt_t, heap) **to,\n-\t\t\t bitmap codes)\n-{\n-  int i;\n-\n-  for (i = VEC_length (opt_t, from); i > 0; i--)\n-    {\n-      const opt_t *const o = VEC_index (opt_t, from, i - 1);\n-\n-      if (bitmap_set_bit (codes, o->code))\n-\tVEC_safe_push (opt_t, heap, *to, o);\n-    }\n-}\n-\n-/* Concatenate options vectors FIRST and SECOND, rationalize so that only the\n-   final of any given option remains, and return the result.  */\n-\n-static VEC(opt_t, heap) *\n-concatenate_options (VEC(opt_t, heap) *first, VEC(opt_t, heap) *second)\n-{\n-  VEC(opt_t, heap) *results = NULL;\n-  bitmap codes = lto_bitmap_alloc ();\n-\n-  reverse_iterate_options (second, &results, codes);\n-  reverse_iterate_options (first, &results, codes);\n-\n-  lto_bitmap_free (codes);\n-  return results;\n-}\n-\n-/* Clear the options vector in *OPTS_P and set it to NULL.  */\n-\n-static void\n-clear_options (VEC(opt_t, heap) **opts_p)\n-{\n-  int i;\n-  opt_t *o;\n-\n-  FOR_EACH_VEC_ELT (opt_t, *opts_p, i, o)\n-    free (o->arg);\n-\n-  VEC_free (opt_t, heap, *opts_p);\n-}\n-\n-/* Write LENGTH bytes from ADDR to STREAM.  */\n-\n-static void\n-output_data_stream (struct lto_output_stream *stream,\n-                    const void *addr, size_t length)\n-{\n-  lto_output_data_stream (stream, addr, length);\n-}\n-\n-/* Write string STRING to STREAM.  */\n-\n-static void\n-output_string_stream (struct lto_output_stream *stream, const char *string)\n-{\n-  bool flag = false;\n-\n-  if (string != NULL)\n-    {\n-      const size_t length = strlen (string);\n-\n-      flag = true;\n-      output_data_stream (stream, &flag, sizeof (flag));\n-      output_data_stream (stream, &length, sizeof (length));\n-      output_data_stream (stream, string, length);\n-    }\n-  else\n-    output_data_stream (stream, &flag, sizeof (flag));\n-}\n-\n-/* Return a string from IB.  The string is allocated, and the caller is\n-   responsible for freeing it.  */\n-\n-static char *\n-input_string_block (struct lto_input_block *ib)\n-{\n-  bool flag;\n-\n-  lto_input_data_block (ib, &flag, sizeof (flag));\n-  if (flag)\n-    {\n-      size_t length;\n-      char *string;\n-\n-      lto_input_data_block (ib, &length, sizeof (length));\n-      string = (char *) xcalloc (1, length + 1);\n-      lto_input_data_block (ib, string, length);\n-\n-      return string;\n-    }\n-  else\n-    return NULL;\n-}\n-\n-/* Return true if this option is one we need to save in LTO output files.\n-   At present, we pass along all target options, and common options that\n-   involve position independent code.\n-\n-   TODO This list of options requires expansion and rationalization.\n-   Among others, optimization options may well be appropriate here.  */\n-\n-static bool\n-register_user_option_p (size_t code, unsigned int type)\n-{\n-  if (type == CL_TARGET)\n-    return true;\n-  else if (type == CL_COMMON)\n-    {\n-      return (code == OPT_fPIC\n-\t      || code == OPT_fpic\n-\t      || code == OPT_fPIE\n-\t      || code == OPT_fpie\n-\t      || code == OPT_fcommon\n-\t      || code == OPT_fexceptions);\n-    }\n-\n-  return false;\n-}\n-\n-/* Note command line option with the given TYPE and CODE, ARG, and VALUE.\n-   If relevant to LTO, save it in the user options vector.  */\n-\n-void\n-lto_register_user_option (size_t code, const char *arg, int value,\n-\t\t\t  unsigned int type)\n-{\n-  if (register_user_option_p (code, type))\n-    {\n-      opt_t o;\n-\n-      o.type = type;\n-      o.code = code;\n-      if (arg != NULL)\n-\t{\n-\t  o.arg = (char *) xmalloc (strlen (arg) + 1);\n-\t  strcpy (o.arg, arg);\n-\t}\n-      else\n-\to.arg = NULL;\n-      o.value = value;\n-      VEC_safe_push (opt_t, heap, user_options, &o);\n-    }\n-}\n-\n-/* Empty the saved user options vector.  */\n-\n-void\n-lto_clear_user_options (void)\n-{\n-  clear_options (&user_options);\n-}\n-\n-/* Empty the saved file options vector.  */\n-\n-void\n-lto_clear_file_options (void)\n-{\n-  clear_options (&file_options);\n-}\n-\n-/* Concatenate the user options and any file options read from an LTO IL\n-   file, and serialize them to STREAM.  File options precede user options\n-   so that the latter override the former when reissued.  */\n-\n-static void\n-output_options (struct lto_output_stream *stream)\n-{\n-  VEC(opt_t, heap) *opts = concatenate_options (file_options, user_options);\n-  const size_t length = VEC_length (opt_t, opts);\n-  int i;\n-  opt_t *o;\n-\n-  output_data_stream (stream, &length, sizeof (length));\n-\n-  FOR_EACH_VEC_ELT (opt_t, opts, i, o)\n-    {\n-      output_data_stream (stream, &o->type, sizeof (o->type));\n-      output_data_stream (stream, &o->code, sizeof (o->code));\n-      output_string_stream (stream, o->arg);\n-      output_data_stream (stream, &o->value, sizeof (o->value));\n-    }\n-\n-  VEC_free (opt_t, heap, opts);\n-}\n+#include \"toplev.h\"\n \n /* Write currently held options to an LTO IL section.  */\n \n void\n lto_write_options (void)\n {\n-  char *const section_name = lto_get_section_name (LTO_section_opts, NULL, NULL);\n   struct lto_output_stream stream;\n-  struct lto_simple_header header;\n-  struct lto_output_stream *header_stream;\n-\n-  /* Targets and languages can provide defaults for -fexceptions but\n-     we only process user options from the command-line.  Until we\n-     serialize out a white list of options from the new global state\n-     explicitly append important options as user options here.  */\n-  if (flag_exceptions)\n-    lto_register_user_option (OPT_fexceptions, NULL, 1, CL_COMMON);\n-\n-  lto_begin_section (section_name, !flag_wpa);\n-  free (section_name);\n+  char *section_name;\n+  struct obstack temporary_obstack;\n+  unsigned int i, j;\n+  char *args;\n \n+  section_name = lto_get_section_name (LTO_section_opts, NULL, NULL);\n+  lto_begin_section (section_name, false);\n   memset (&stream, 0, sizeof (stream));\n-  output_options (&stream);\n \n-  memset (&header, 0, sizeof (header));\n-  header.lto_header.major_version = LTO_major_version;\n-  header.lto_header.minor_version = LTO_minor_version;\n-  header.lto_header.section_type = LTO_section_opts;\n-\n-  header.compressed_size = 0;\n-  header.main_size = stream.total_size;\n-\n-  header_stream = ((struct lto_output_stream *)\n-\t\t   xcalloc (1, sizeof (*header_stream)));\n-  lto_output_data_stream (header_stream, &header, sizeof (header));\n-  lto_write_stream (header_stream);\n-  free (header_stream);\n-\n-  lto_write_stream (&stream);\n-  lto_end_section ();\n-}\n-\n-/* Unserialize an options vector from IB, and append to file_options.  */\n-\n-static void\n-input_options (struct lto_input_block *ib)\n-{\n-  size_t length, i;\n-\n-  lto_input_data_block (ib, &length, sizeof (length));\n-\n-  for (i = 0; i < length; i++)\n+  obstack_init (&temporary_obstack);\n+  for (i = 1; i < save_decoded_options_count; ++i)\n     {\n-      opt_t o;\n-\n-      lto_input_data_block (ib, &o.type, sizeof (o.type));\n-      lto_input_data_block (ib, &o.code, sizeof (o.code));\n-      o.arg = input_string_block (ib);\n-      lto_input_data_block (ib, &o.value, sizeof (o.value));\n-      VEC_safe_push (opt_t, heap, file_options, &o);\n-    }\n-}\n-\n-/* Read options from an LTO IL section.  */\n-\n-void\n-lto_read_file_options (struct lto_file_decl_data *file_data)\n-{\n-  size_t len, l, skip;\n-  const char *data, *p;\n-  const struct lto_simple_header *header;\n-  int32_t opts_offset;\n-  struct lto_input_block ib;\n-\n-  data = lto_get_section_data (file_data, LTO_section_opts, NULL, &len);\n-  if (!data)\n-\t  return;\n-\n-  /* Option could be multiple sections merged (through ld -r) \n-     Keep reading all options.  This is ok right now because\n-     the options just get mashed together anyways.\n-     This will have to be done differently once lto-opts knows\n-     how to associate options with different files. */\n-  l = len;\n-  p = data;\n-  do \n-    { \n-      header = (const struct lto_simple_header *) p;\n-      opts_offset = sizeof (*header);\n-\n-      lto_check_version (header->lto_header.major_version,\n-\t\t\t header->lto_header.minor_version);\n-      \n-      LTO_INIT_INPUT_BLOCK (ib, p + opts_offset, 0, header->main_size);\n-      input_options (&ib);\n-      \n-      skip = header->main_size + opts_offset;\n-      l -= skip;\n-      p += skip;\n-    } \n-  while (l > 0);\n-\n-  lto_free_section_data (file_data, LTO_section_opts, 0, data, len);\n-}\n-\n-/* Concatenate the user options and any file options read from an LTO IL\n-   file, and reissue them as if all had just been read in from the command\n-   line.  As with serialization, file options precede user options.  */\n-\n-void\n-lto_reissue_options (void)\n-{\n-  VEC(opt_t, heap) *opts = concatenate_options (file_options, user_options);\n-  int i;\n-  opt_t *o;\n+      struct cl_decoded_option *option = &save_decoded_options[i];\n+      const char *q, *p;\n+\n+      /* Skip frontend and driver specific options here.  */\n+      if (!(cl_options[option->opt_index].flags & (CL_COMMON|CL_TARGET|CL_LTO)))\n+\tcontinue;\n+\n+      /* Drop options created from the gcc driver that will be rejected\n+\t when passed on to the driver again.  */\n+      if (cl_options[option->opt_index].cl_reject_driver)\n+\tcontinue;\n+\n+      /* Also drop all options that are handled by the driver as well,\n+         which includes things like -o and -v or -fhelp for example.\n+\t We do not need those.  Also drop all diagnostic options.  */\n+      if (cl_options[option->opt_index].flags & (CL_DRIVER|CL_WARNING))\n+\tcontinue;\n+\n+      /* Skip explicitly some common options that we do not need.  */\n+      switch (option->opt_index)\n+\t{\n+\tcase OPT_dumpbase:\n+\tcase OPT_SPECIAL_input_file:\n+\t  continue;\n \n-  FOR_EACH_VEC_ELT (opt_t, opts, i, o)\n-    {\n-      void *flag_var = option_flag_var (o->code, &global_options);\n+\tdefault:\n+\t  break;\n+\t}\n \n-      if (flag_var)\n-\tset_option (&global_options, &global_options_set,\n-\t\t    o->code, o->value, o->arg,\n-\t\t    DK_UNSPECIFIED, UNKNOWN_LOCATION, global_dc);\n+      if (i != 1)\n+\tobstack_grow (&temporary_obstack, \" \", 1);\n+      obstack_grow (&temporary_obstack, \"'\", 1);\n+      q = option->canonical_option[0];\n+      while ((p = strchr (q, '\\'')))\n+\t{\n+\t  obstack_grow (&temporary_obstack, q, p - q);\n+\t  obstack_grow (&temporary_obstack, \"'\\\\''\", 4);\n+\t  q = ++p;\n+\t}\n+      obstack_grow (&temporary_obstack, q, strlen (q));\n+      obstack_grow (&temporary_obstack, \"'\", 1);\n \n-      if (o->type == CL_TARGET)\n+      for (j = 1; j < option->canonical_option_num_elements; ++j)\n \t{\n-\t  struct cl_decoded_option decoded;\n-\t  generate_option (o->code, o->arg, o->value, CL_TARGET, &decoded);\n-\t  targetm_common.handle_option (&global_options, &global_options_set,\n-\t\t\t\t\t&decoded, UNKNOWN_LOCATION);\n+\t  obstack_grow (&temporary_obstack, \" '\", 2);\n+\t  q = option->canonical_option[j];\n+\t  while ((p = strchr (q, '\\'')))\n+\t    {\n+\t      obstack_grow (&temporary_obstack, q, p - q);\n+\t      obstack_grow (&temporary_obstack, \"'\\\\''\", 4);\n+\t      q = ++p;\n+\t    }\n+\t  obstack_grow (&temporary_obstack, q, strlen (q));\n+\t  obstack_grow (&temporary_obstack, \"'\", 1);\n \t}\n-      else if (o->type == CL_COMMON)\n-\tgcc_assert (flag_var);\n-      else\n-\tgcc_unreachable ();\n     }\n+  obstack_grow (&temporary_obstack, \"\\0\", 1);\n+  args = XOBFINISH (&temporary_obstack, char *);\n+  lto_output_data_stream (&stream, args, strlen (args) + 1);\n \n-  /* Flag_shlib is usually set by finish_options, but we are issuing flag_pic\n-     too late.  */\n-  if (flag_pic && !flag_pie)\n-    flag_shlib = 1;\n-  VEC_free (opt_t, heap, opts);\n+  lto_write_stream (&stream);\n+  lto_end_section ();\n+\n+  obstack_free (&temporary_obstack, NULL);\n+  free (section_name);\n }"}, {"sha": "58d487485ecd16c913bc0f327a6237db914a7a42", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -882,12 +882,7 @@ extern GTY(()) VEC(tree,gc) *lto_global_var_decls;\n \n \n /* In lto-opts.c.  */\n-extern void lto_register_user_option (size_t, const char *, int, unsigned int);\n-extern void lto_read_file_options (struct lto_file_decl_data *);\n extern void lto_write_options (void);\n-extern void lto_reissue_options (void);\n-void lto_clear_user_options (void);\n-void lto_clear_file_options (void);\n \n \n /* In lto-wpa-fixup.c  */"}, {"sha": "5fb37624810aa5b42235cb9689c2351b30820abf", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -45,6 +45,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"obstack.h\"\n #include \"opts.h\"\n #include \"options.h\"\n+#include \"simple-object.h\"\n+\n+/* From lto-streamer.h which we cannot include with -fkeep-inline-functions.\n+   ???  Split out a lto-streamer-core.h.  */\n+\n+#define LTO_SECTION_NAME_PREFIX         \".gnu.lto_\"\n+\n+/* End of lto-streamer.h copy.  */\n \n int debug;\t\t\t\t/* true if -save-temps.  */\n int verbose;\t\t\t\t/* true if -v.  */\n@@ -336,6 +344,78 @@ get_options_from_collect_gcc_options (const char *collect_gcc,\n   obstack_free (&argv_obstack, NULL);\n }\n \n+/* Append OPTION to the options array DECODED_OPTIONS with size\n+   DECODED_OPTIONS_COUNT.  */\n+\n+static void\n+append_option (struct cl_decoded_option **decoded_options,\n+\t       unsigned int *decoded_options_count,\n+\t       struct cl_decoded_option *option)\n+{\n+  ++*decoded_options_count;\n+  *decoded_options\n+    = (struct cl_decoded_option *)\n+\txrealloc (*decoded_options,\n+\t\t  (*decoded_options_count\n+\t\t   * sizeof (struct cl_decoded_option)));\n+  memcpy (&(*decoded_options)[*decoded_options_count - 1], option,\n+\t  sizeof (struct cl_decoded_option));\n+}\n+\n+/* Try to merge and complain about options FDECODED_OPTIONS when applied\n+   ontop of DECODED_OPTIONS.  */\n+\n+static void\n+merge_and_complain (struct cl_decoded_option **decoded_options,\n+\t\t    unsigned int *decoded_options_count,\n+\t\t    struct cl_decoded_option *fdecoded_options,\n+\t\t    unsigned int fdecoded_options_count)\n+{\n+  unsigned int i, j;\n+\n+  /* ???  Merge options from files.  Most cases can be\n+     handled by either unioning or intersecting\n+     (for example -fwrapv is a case for unioning,\n+     -ffast-math is for intersection).  Most complaints\n+     about real conflicts between different options can\n+     be deferred to the compiler proper.  Options that\n+     we can neither safely handle by intersection nor\n+     unioning would need to be complained about here.\n+     Ideally we'd have a flag in the opt files that\n+     tells whether to union or intersect or reject.\n+     In absence of that it's unclear what a good default is.\n+     It's also difficult to get positional handling correct.  */\n+\n+  /* The following does what the old LTO option code did,\n+     union all target and a selected set of common options.  */\n+  for (i = 0; i < fdecoded_options_count; ++i)\n+    {\n+      struct cl_decoded_option *foption = &fdecoded_options[i];\n+      switch (foption->opt_index)\n+\t{\n+\tdefault:\n+\t  if (!(cl_options[foption->opt_index].flags & CL_TARGET))\n+\t    break;\n+\n+\t  /* Fallthru.  */\n+\tcase OPT_fPIC:\n+\tcase OPT_fpic:\n+\tcase OPT_fpie:\n+\tcase OPT_fcommon:\n+\tcase OPT_fexceptions:\n+\t  /* Do what the old LTO code did - collect exactly one option\n+\t     setting per OPT code, we pick the first we encounter.\n+\t     ???  This doesn't make too much sense, but when it doesn't\n+\t     then we should complain.  */\n+\t  for (j = 0; j < *decoded_options_count; ++j)\n+\t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n+\t      break;\n+\t  if (j == *decoded_options_count)\n+\t    append_option (decoded_options, decoded_options_count, foption);\n+\t  break;\n+\t}\n+    }\n+}\n \n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n \n@@ -351,6 +431,8 @@ run_gcc (unsigned argc, char *argv[])\n   int parallel = 0;\n   int jobserver = 0;\n   bool no_partition = false;\n+  struct cl_decoded_option *fdecoded_options = NULL;\n+  unsigned int fdecoded_options_count = 0;\n   struct cl_decoded_option *decoded_options;\n   unsigned int decoded_options_count;\n   struct obstack argv_obstack;\n@@ -368,11 +450,125 @@ run_gcc (unsigned argc, char *argv[])\n \t\t\t\t\t&decoded_options,\n \t\t\t\t\t&decoded_options_count);\n \n+  /* Look at saved options in the IL files.  */\n+  for (i = 1; i < argc; ++i)\n+    {\n+      char *data, *p;\n+      char *fopts;\n+      int fd;\n+      const char *errmsg;\n+      int err;\n+      off_t file_offset = 0, offset, length;\n+      long loffset;\n+      simple_object_read *sobj;\n+      int consumed;\n+      struct cl_decoded_option *f2decoded_options;\n+      unsigned int f2decoded_options_count;\n+      char *filename = argv[i];\n+      if ((p = strrchr (argv[i], '@'))\n+\t  && p != argv[i] \n+\t  && sscanf (p, \"@%li%n\", &loffset, &consumed) >= 1\n+\t  && strlen (p) == (unsigned int) consumed)\n+\t{\n+\t  filename = XNEWVEC (char, p - argv[i] + 1);\n+\t  memcpy (filename, argv[i], p - argv[i]);\n+\t  filename[p - argv[i]] = '\\0';\n+\t  file_offset = (off_t) loffset;\n+\t}\n+      fd = open (argv[i], O_RDONLY);\n+      if (fd == -1)\n+\tcontinue;\n+      sobj = simple_object_start_read (fd, file_offset, NULL, &errmsg, &err);\n+      if (!sobj)\n+\t{\n+\t  close (fd);\n+\t  continue;\n+\t}\n+      if (!simple_object_find_section (sobj, LTO_SECTION_NAME_PREFIX \".\" \"opts\",\n+\t\t\t\t       &offset, &length, &errmsg, &err))\n+\t{\n+\t  simple_object_release_read (sobj);\n+\t  close (fd);\n+\t  continue;\n+\t}\n+      lseek (fd, file_offset + offset, SEEK_SET);\n+      data = (char *)xmalloc (length);\n+      read (fd, data, length);\n+      fopts = data;\n+      do\n+\t{\n+\t  get_options_from_collect_gcc_options (collect_gcc,\n+\t\t\t\t\t\tfopts, CL_LANG_ALL,\n+\t\t\t\t\t\t&f2decoded_options,\n+\t\t\t\t\t\t&f2decoded_options_count);\n+\t  if (!fdecoded_options)\n+\t    {\n+\t      fdecoded_options = f2decoded_options;\n+\t      fdecoded_options_count = f2decoded_options_count;\n+\t    }\n+\t  else\n+\t    merge_and_complain (&fdecoded_options,\n+\t\t\t\t&fdecoded_options_count,\n+\t\t\t\tf2decoded_options, f2decoded_options_count);\n+\n+\t  fopts += strlen (fopts) + 1;\n+\t}\n+      while (fopts - data < length);\n+\n+      free (data);\n+      simple_object_release_read (sobj);\n+      close (fd);\n+    }\n+\n   /* Initalize the common arguments for the driver.  */\n   obstack_init (&argv_obstack);\n   obstack_ptr_grow (&argv_obstack, collect_gcc);\n   obstack_ptr_grow (&argv_obstack, \"-xlto\");\n   obstack_ptr_grow (&argv_obstack, \"-c\");\n+\n+  /* Append compiler driver arguments as far as they were merged.  */\n+  for (j = 1; j < fdecoded_options_count; ++j)\n+    {\n+      struct cl_decoded_option *option = &fdecoded_options[j];\n+\n+      /* File options have been properly filtered by lto-opts.c.  */\n+      switch (option->opt_index)\n+\t{\n+\t  /* Drop arguments that we want to take from the link line.  */\n+\t  case OPT_flto_:\n+\t  case OPT_flto:\n+\t  case OPT_flto_partition_none:\n+\t  case OPT_flto_partition_1to1:\n+\t  case OPT_flto_partition_balanced:\n+\t      continue;\n+\n+\t  default:\n+\t      break;\n+\t}\n+\n+      /* For now do what the original LTO option code was doing - pass\n+\t on any CL_TARGET flag and a few selected others.  */\n+      switch (option->opt_index)\n+\t{\n+\tcase OPT_fPIC:\n+\tcase OPT_fpic:\n+\tcase OPT_fpie:\n+\tcase OPT_fcommon:\n+\tcase OPT_fexceptions:\n+\t  break;\n+\n+\tdefault:\n+\t  if (!(cl_options[option->opt_index].flags & CL_TARGET))\n+\t    continue;\n+\t}\n+\n+      /* Pass the option on.  */\n+      for (i = 0; i < option->canonical_option_num_elements; ++i)\n+\tobstack_ptr_grow (&argv_obstack, option->canonical_option[i]);\n+    }\n+\n+  /* Append linker driver arguments.  Compiler options from the linker\n+     driver arguments will override / merge with those from the compiler.  */\n   for (j = 1; j < decoded_options_count; ++j)\n     {\n       struct cl_decoded_option *option = &decoded_options[j];"}, {"sha": "d8bbd9ca8ddd6075f64faa35cc8aa78d19b4b2a4", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -1,3 +1,10 @@\n+2011-11-03  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44965\n+\t* lto-lang.c (lto_post_options): Do not read file options.\n+\t* lto.c (lto_read_all_file_options): Remove.\n+\t(lto_init): Call lto_set_in_hooks here.\n+\n 2011-10-09  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (node_cmp, varpool_node_cmp): New functions."}, {"sha": "c702b9a2d24b5a6d10109a76c27c261bf451e7ed", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -692,8 +692,6 @@ lto_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n      support.  */\n   flag_excess_precision_cmdline = EXCESS_PRECISION_FAST;\n \n-  lto_read_all_file_options ();\n-\n   /* Initialize the compiler back end.  */\n   return false;\n }"}, {"sha": "3b35604af8d64a7ff0fa8878c822362a8c1650a9", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -2494,60 +2494,6 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n     }\n }\n \n-/* Read the options saved from each file in the command line.  Called\n-   from lang_hooks.post_options which is called by process_options\n-   right before all the options are used to initialize the compiler.\n-   This assumes that decode_options has already run, so the\n-   num_in_fnames and in_fnames are properly set.\n-\n-   Note that this assumes that all the files had been compiled with\n-   the same options, which is not a good assumption.  In general,\n-   options ought to be read from all the files in the set and merged.\n-   However, it is still unclear what the merge rules should be.  */\n-\n-void\n-lto_read_all_file_options (void)\n-{\n-  size_t i;\n-\n-  /* Clear any file options currently saved.  */\n-  lto_clear_file_options ();\n-\n-  /* Set the hooks to read ELF sections.  */\n-  lto_set_in_hooks (NULL, get_section_data, free_section_data);\n-  if (!quiet_flag)\n-    fprintf (stderr, \"Reading command line options:\");\n-\n-  for (i = 0; i < num_in_fnames; i++)\n-    {\n-      struct lto_file_decl_data *file_data;\n-      lto_file *file = lto_obj_file_open (in_fnames[i], false);\n-      if (!file)\n-\tbreak;\n-      if (!quiet_flag)\n-\t{\n-\t  fprintf (stderr, \" %s\", in_fnames[i]);\n-\t  fflush (stderr);\n-\t}\n-\n-      file_data = XCNEW (struct lto_file_decl_data);\n-      file_data->file_name = file->filename;\n-      file_data->section_hash_table = lto_obj_build_section_table (file, NULL);\n-\n-      lto_read_file_options (file_data);\n-\n-      lto_obj_file_close (file);\n-      htab_delete (file_data->section_hash_table);\n-      free (file_data);\n-    }\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\n\");\n-\n-  /* Apply globally the options read from all the files.  */\n-  lto_reissue_options ();\n-}\n-\n static GTY((length (\"lto_stats.num_input_files + 1\"))) struct lto_file_decl_data **all_file_decl_data;\n \n /* Turn file datas for sub files into a single array, so that they look\n@@ -2921,6 +2867,7 @@ lto_init (void)\n   lto_process_name ();\n   lto_streamer_hooks_init ();\n   lto_reader_init ();\n+  lto_set_in_hooks (NULL, get_section_data, free_section_data);\n   memset (&lto_stats, 0, sizeof (lto_stats));\n   bitmap_obstack_initialize (NULL);\n   gimple_register_cfg_hooks ();"}, {"sha": "00edbe6601c1da94d57198e969f7231e6d932804", "filename": "gcc/opts-common.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fopts-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fopts-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -878,9 +878,6 @@ handle_option (struct gcc_options *opts,\n \t\t\t\t\t    lang_mask, kind, loc,\n \t\t\t\t\t    handlers, dc))\n \t  return false;\n-\telse\n-\t  handlers->post_handling_callback (decoded,\n-\t\t\t\t\t    handlers->handlers[i].mask);\n       }\n   \n   return true;"}, {"sha": "b93d56fcd8d5b9540e1248e5a6a51a8e7de18843", "filename": "gcc/opts-global.c", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fopts-global.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fopts-global.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-global.c?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -160,19 +160,6 @@ unknown_option_callback (const struct cl_decoded_option *decoded)\n     return true;\n }\n \n-/* Note that an option DECODED has been successfully handled with a\n-   handler for mask MASK.  */\n-\n-static void\n-post_handling_callback (const struct cl_decoded_option *decoded ATTRIBUTE_UNUSED,\n-\t\t\tunsigned int mask ATTRIBUTE_UNUSED)\n-{\n-#ifdef ENABLE_LTO\n-  lto_register_user_option (decoded->opt_index, decoded->arg,\n-\t\t\t    decoded->value, mask);\n-#endif\n-}\n-\n /* Handle a front-end option; arguments and return value as for\n    handle_option.  */\n \n@@ -282,7 +269,6 @@ set_default_handlers (struct cl_option_handlers *handlers)\n {\n   handlers->unknown_option_callback = unknown_option_callback;\n   handlers->wrong_lang_callback = complain_wrong_lang;\n-  handlers->post_handling_callback = post_handling_callback;\n   handlers->num_handlers = 3;\n   handlers->handlers[0].handler = lang_handle_option;\n   handlers->handlers[0].mask = initial_lang_mask;\n@@ -314,11 +300,6 @@ decode_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t\t\t\tdecoded_options, decoded_options_count,\n \t\t\t\tloc, lang_mask, &handlers, dc);\n \n-#ifdef ENABLE_LTO\n-  /* Clear any options currently held for LTO.  */\n-  lto_clear_user_options ();\n-#endif\n-\n   read_cmdline_options (opts, opts_set,\n \t\t\tdecoded_options, decoded_options_count,\n \t\t\tloc, lang_mask,"}, {"sha": "dbefc6401d9288b277ca08e42f05a15376eb8887", "filename": "gcc/opts.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a35ef729f3eae64eb9ba8213fd840e4c71df84/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=52a35ef729f3eae64eb9ba8213fd840e4c71df84", "patch": "@@ -291,10 +291,6 @@ struct cl_option_handlers\n   void (*wrong_lang_callback) (const struct cl_decoded_option *decoded,\n \t\t\t       unsigned int lang_mask);\n \n-  /* Callback to call after the successful handling of any option.  */\n-  void (*post_handling_callback) (const struct cl_decoded_option *decoded,\n-\t\t\t\t  unsigned int mask);\n-\n   /* The number of individual handlers.  */\n   size_t num_handlers;\n "}]}