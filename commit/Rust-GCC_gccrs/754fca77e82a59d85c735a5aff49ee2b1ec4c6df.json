{"sha": "754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0ZmNhNzdlODJhNTlkODVjNzM1YTVhZmY0OWVlMmIxZWM0YzZkZg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-28T10:05:58Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-08-28T13:37:19Z"}, "message": "libstdc++: Fix std::allocator<void> for versioned namespace\n\nRemoving the allocator<void> specialization for the versioned namespace\nbreaks _Extptr_allocator<void> because the allocator<void>\nspecialization was still declared in <bits/memoryfwd.h>, making it an\nincomplete type.  It wrong to remove that specialization anyway, because\nit is still needed pre-C++20.\n\nThis removes the #if ! _GLIBCXX_INLINE_VERSION check, so that\nallocator<void> is still explicitly specialized for the versioned\nnamespace, consistent with the normal unversioned namespace mode.\n\nTo make _Extptr_allocator<void> usable as a ProtoAllocator, this change\nadds a default constructor and converting constructor. That is\nconsistent with std::allocator<void> since C++20 (and harmless to do for\nearlier standards).\n\nI'm also explicitly specializing allocator_traits<allocator<void>> so\nthat it doesn't need to use allocator<void>::construct and destroy.\nDoing that allows those members to be removed, further simplifying\nallocator<void>.  That new explicit specialization can delete the\nallocate, deallocate and max_size members, which are always ill-formed\nfor allocator<void>.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/alloc_traits.h (allocator_traits): Add explicit\n\tspecialization for allocator<void>. Improve doxygen comments.\n\t* include/bits/allocator.h (allocator<void>): Restore for the\n\tversioned namespace.\n\t(allocator<void>::construct, allocator<void>::destroy): Remove.\n\t* include/ext/extptr_allocator.h (_Extptr_allocator<void>):\n\tAdd default constructor and converting constructor.", "tree": {"sha": "0b66441f995e6bc728a2714c027be484b3f5dd22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b66441f995e6bc728a2714c027be484b3f5dd22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd3e5859fc16701acb73f59220c8c964af9f713b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd3e5859fc16701acb73f59220c8c964af9f713b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd3e5859fc16701acb73f59220c8c964af9f713b"}], "stats": {"total": 147, "additions": 120, "deletions": 27}, "files": [{"sha": "05b584f742f5e87365ea13c8e235c735d275993b", "filename": "libstdc++-v3/include/bits/alloc_traits.h", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Falloc_traits.h?ref=754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "patch": "@@ -559,6 +559,110 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return __rhs; }\n     };\n \n+  /// Explicit specialization for std::allocator<void>.\n+  template<>\n+    struct allocator_traits<allocator<void>>\n+    {\n+      /// The allocator type\n+      using allocator_type = allocator<void>;\n+\n+      /// The allocated type\n+      using value_type = void;\n+\n+      /// The allocator's pointer type.\n+      using pointer = void*;\n+\n+      /// The allocator's const pointer type.\n+      using const_pointer = const void*;\n+\n+      /// The allocator's void pointer type.\n+      using void_pointer = void*;\n+\n+      /// The allocator's const void pointer type.\n+      using const_void_pointer = const void*;\n+\n+      /// The allocator's difference type\n+      using difference_type = std::ptrdiff_t;\n+\n+      /// The allocator's size type\n+      using size_type = std::size_t;\n+\n+      /// How the allocator is propagated on copy assignment\n+      using propagate_on_container_copy_assignment = false_type;\n+\n+      /// How the allocator is propagated on move assignment\n+      using propagate_on_container_move_assignment = true_type;\n+\n+      /// How the allocator is propagated on swap\n+      using propagate_on_container_swap = false_type;\n+\n+      /// Whether all instances of the allocator type compare equal.\n+      using is_always_equal = true_type;\n+\n+      template<typename _Up>\n+\tusing rebind_alloc = allocator<_Up>;\n+\n+      template<typename _Up>\n+\tusing rebind_traits = allocator_traits<allocator<_Up>>;\n+\n+      /// allocate is ill-formed for allocator<void>\n+      static void*\n+      allocate(allocator_type&, size_type, const void* = nullptr) = delete;\n+\n+      /// deallocate is ill-formed for allocator<void>\n+      static void\n+      deallocate(allocator_type&, void*, size_type) = delete;\n+\n+      /**\n+       *  @brief  Construct an object of type `_Up`\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to memory of suitable size and alignment for\n+       *\t       an object of type `_Up`.\n+       *  @param  __args Constructor arguments.\n+       *\n+       *  Calls `__a.construct(__p, std::forward<_Args>(__args)...)`\n+       *  in C++11, C++14 and C++17. Changed in C++20 to call\n+       *  `std::construct_at(__p, std::forward<_Args>(__args)...)` instead.\n+      */\n+      template<typename _Up, typename... _Args>\n+\tstatic _GLIBCXX20_CONSTEXPR void\n+\tconstruct(allocator_type&, _Up* __p, _Args&&... __args)\n+\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n+\t{\n+#if __cplusplus <= 201703L\n+\t  ::new((void *)__p) _Up(std::forward<_Args>(__args)...);\n+#else\n+\t  std::construct_at(__p, std::forward<_Args>(__args)...);\n+#endif\n+\t}\n+\n+      /**\n+       *  @brief  Destroy an object of type `_Up`\n+       *  @param  __a  An allocator.\n+       *  @param  __p  Pointer to the object to destroy\n+       *\n+       *  Invokes the destructor for `*__p`.\n+      */\n+      template<typename _Up>\n+\tstatic _GLIBCXX20_CONSTEXPR void\n+\tdestroy(allocator_type&, _Up* __p)\n+\tnoexcept(is_nothrow_destructible<_Up>::value)\n+\t{ std::_Destroy(__p); }\n+\n+      /// max_size is ill-formed for allocator<void>\n+      static size_type\n+      max_size(const allocator_type&) = delete;\n+\n+      /**\n+       *  @brief  Obtain an allocator to use when copying a container.\n+       *  @param  __rhs  An allocator.\n+       *  @return `__rhs`\n+      */\n+      static _GLIBCXX20_CONSTEXPR allocator_type\n+      select_on_container_copy_construction(const allocator_type& __rhs)\n+      { return __rhs; }\n+    };\n+\n #if __cplusplus < 201703L\n   template<typename _Alloc>\n     inline void"}, {"sha": "a6883c6758a4ba9d5df557c5e833f7b21d3aa223", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "patch": "@@ -61,12 +61,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   // Since C++20 the primary template should be used for allocator<void>,\n-  // but then it would have a non-trivial default ctor and dtor, which\n-  // would be an ABI change. So C++20 still uses the allocator<void> explicit\n-  // specialization, with the historical ABI properties, but with the same\n-  // members that are present in the primary template.\n+  // but then it would have a non-trivial default ctor and dtor for C++20,\n+  // but trivial for C++98-17, which would be an ABI incompatibiliy between\n+  // different standard dialects. So C++20 still uses the allocator<void>\n+  // explicit specialization, with the historical ABI properties, but with\n+  // the same members that are present in the primary template.\n \n-#if ! _GLIBCXX_INLINE_VERSION\n   /// allocator<void> specialization.\n   template<>\n     class allocator<void>\n@@ -77,7 +77,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef ptrdiff_t   difference_type;\n \n #if __cplusplus <= 201703L\n-      // These were removed for C++20.\n+      // These were removed for C++20, allocator_traits does the right thing.\n       typedef void*       pointer;\n       typedef const void* const_pointer;\n \n@@ -96,7 +96,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t= true_type;\n \n #if __cplusplus >= 202002L\n+      // As noted above, these members are present for C++20 to provide the\n+      // same API as the primary template, but still trivial as in pre-C++20.\n       allocator() = default;\n+      ~allocator() = default;\n \n       template<typename _Up>\n \tconstexpr\n@@ -105,28 +108,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // No allocate member because it's ill-formed by LWG 3307.\n       // No deallocate member because it would be undefined to call it\n       // with any pointer which wasn't obtained from allocate.\n-\n-#else // ! C++20\n-    private:\n-      // This uses construct and destroy in C++11/14/17 modes.\n-      friend allocator_traits<allocator<void>>;\n-\n-      template<typename _Up, typename... _Args>\n-\tvoid\n-\tconstruct(_Up* __p, _Args&&... __args)\n-\tnoexcept(std::is_nothrow_constructible<_Up, _Args...>::value)\n-\t{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n-\n-      template<typename _Up>\n-\tvoid\n-\tdestroy(_Up* __p)\n-\tnoexcept(std::is_nothrow_destructible<_Up>::value)\n-\t{ __p->~_Up(); }\n-#endif // C++17\n+#endif // C++20\n #endif // C++11\n-\n     };\n-#endif // ! _GLIBCXX_INLINE_VERSION\n \n   /**\n    * @brief  The @a standard allocator, as per C++03 [20.4.1].\n@@ -212,7 +196,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return;\n \t  }\n #endif\n-\t  __allocator_base<_Tp>::deallocate(__p, __n);\n+\t__allocator_base<_Tp>::deallocate(__p, __n);\n       }\n #endif // C++20\n "}, {"sha": "2dfc73ec605c6ad7e335766b8552aa24e7b98b5c", "filename": "libstdc++-v3/include/ext/extptr_allocator.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/754fca77e82a59d85c735a5aff49ee2b1ec4c6df/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fextptr_allocator.h?ref=754fca77e82a59d85c735a5aff49ee2b1ec4c6df", "patch": "@@ -176,6 +176,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef _Pointer_adapter<_Relative_pointer_impl<const void> >\n                                                               const_pointer;\n \n+      _ExtPtr_allocator() { }\n+\n+      template<typename _Up>\n+\t_ExtPtr_allocator(const _ExtPtr_allocator<_Up>&) { }\n+\n       template<typename _Up>\n         struct rebind\n         { typedef _ExtPtr_allocator<_Up> other; };"}]}