{"sha": "3c8d8c0be95e99dc0cba7f6fad2429243582119f", "node_id": "C_kwDOANBUbNoAKDNjOGQ4YzBiZTk1ZTk5ZGMwY2JhN2Y2ZmFkMjQyOTI0MzU4MjExOWY", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-10-14T01:31:03Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-10-20T02:10:41Z"}, "message": "Adjust testcase for O2 vectorization.\n\nAs discussed in [1], this patch add xfail/target selector to those\ntestcases, also make a copy of them so that they can be tested w/o\nvectorization.\n\nNewly added xfail/target selectors are used to check the vectorization\ncapability of continuous byte/double bytes storage, these scenarios\nare exactly the part of the testcases that regressed after O2\nvectorization.\n\n[1] https://gcc.gnu.org/pipermail/gcc-patches/2021-October/581456.html.\n\n2021-10-19  Hongtao Liu  <hongtao.liu@intel.com>\n\t    Kewen Lin  <linkw@linux.ibm.com>\n\ngcc/ChangeLog\n\n\t* doc/sourcebuild.texi (Effective-Target Keywords): Document\n\tvect_slp_v2qi_store, vect_slp_v4qi_store, vect_slp_v8qi_store,\n\tvect_slp_v16qi_store, vect_slp_v2hi_store,\n\tvect_slp_v4hi_store, vect_slp_v2si_store, vect_slp_v4si_store.\n\ngcc/testsuite/ChangeLog\n\n\tPR middle-end/102722\n\tPR middle-end/102697\n\tPR middle-end/102462\n\tPR middle-end/102706\n\tPR middle-end/102744\n\t* c-c++-common/Wstringop-overflow-2.c: Adjust testcase with new\n\txfail/target selector.\n\t* gcc.dg/Warray-bounds-51.c: Ditto.\n\t* gcc.dg/Warray-parameter-3.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-14.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-21.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-68.c: Ditto.\n\t* gcc.dg/Wstringop-overflow-76.c: Ditto.\n\t* gcc.dg/Warray-bounds-48.c: Ditto.\n\t* gcc.dg/Wzero-length-array-bounds-2.c: Ditto.\n\t* lib/target-supports.exp (check_vect_slp_aligned_store_usage):\n\tNew function.\n\t(check_effective_target_vect_slp_v2qi_store): Ditto.\n\t(check_effective_target_vect_slp_v4qi_store): Ditto.\n\t(check_effective_target_vect_slp_v8qi_store): Ditto.\n\t(check_effective_target_vect_slp_v16qi_store): Ditto.\n\t(check_effective_target_vect_slp_v2hi_store): Ditto.\n\t(check_effective_target_vect_slp_v4hi_store): Ditto.\n\t(check_effective_target_vect_slp_v2si_store): Ditto.\n\t(check_effective_target_vect_slp_v4si_store): Ditto.\n\t* c-c++-common/Wstringop-overflow-2-novec.c: New test.\n\t* gcc.dg/Warray-bounds-51-novec.c: New test.\n\t* gcc.dg/Warray-bounds-48-novec.c: New test.\n\t* gcc.dg/Warray-parameter-3-novec.c: New test.\n\t* gcc.dg/Wstringop-overflow-14-novec.c: New test.\n\t* gcc.dg/Wstringop-overflow-21-novec.c: New test.\n\t* gcc.dg/Wstringop-overflow-76-novec.c: New test.\n\t* gcc.dg/Wzero-length-array-bounds-2-novec.c: New test.", "tree": {"sha": "24bbf79106b6f7acb568cb4ded3b1ab330662448", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24bbf79106b6f7acb568cb4ded3b1ab330662448"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c8d8c0be95e99dc0cba7f6fad2429243582119f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8d8c0be95e99dc0cba7f6fad2429243582119f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c8d8c0be95e99dc0cba7f6fad2429243582119f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c8d8c0be95e99dc0cba7f6fad2429243582119f/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19472fc3fc0cabcee5b8a5073e8128d21a1ed6f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19472fc3fc0cabcee5b8a5073e8128d21a1ed6f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19472fc3fc0cabcee5b8a5073e8128d21a1ed6f2"}], "stats": {"total": 1001, "additions": 967, "deletions": 34}, "files": [{"sha": "6a16576763006a13e946147ab1ea5b16b5bc219b", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -1845,6 +1845,38 @@ Target supports loop vectorization with partial vectors and\n @item vect_partial_vectors\n Target supports loop vectorization with partial vectors and\n @code{vect-partial-vector-usage} is nonzero.\n+\n+@item vect_slp_v2qi_store\n+Target supports vectorization of 2-byte char stores with 2-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v4qi_store\n+Target supports vectorization of 4-byte char stores with 4-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v8qi_store\n+Target supports vectorization of 8-byte char stores with 8-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v16qi_store\n+Target supports vectorization of 16-byte char stores with 16-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v2hi_store\n+Target supports vectorization of 4-byte short stores with 4-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v4hi_store\n+Target supports vectorization of 8-byte short stores with 8-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v2si_store\n+Target supports vectorization of 8-byte int stores with 8-byte aligned\n+address at plain @option{-O2}.\n+\n+@item vect_slp_v4si_store\n+Target supports vectorization of 16-byte int stores with 16-byte aligned\n+address at plain @option{-O2}.\n @end table\n \n @subsubsection Thread Local Storage attributes"}, {"sha": "3c34ad35a5df1cee3bd06b8d281c306d9185db40", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2-novec.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,126 @@\n+/* PR middle-end/91458 - inconsistent warning for writing past the end\n+   of an array member\n+   { dg-do compile }\n+   { dg-options \"-O2 -fno-tree-vectorize -Wall -Wno-array-bounds -fno-ipa-icf\" } */\n+\n+void sink (void*);\n+\n+// Exercise trailing one-element array members.\n+\n+struct A1\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object\" \"note\" }\n+};\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+struct A1 a1__ = { 0 };\n+\n+void ga1__ (void)\n+{\n+  a1__.a[0] = 0;\n+  a1__.a[1] = 1;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1__.a[2] = 2;                 // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 1 };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+struct A1 a1_0 = { 0, { } };\n+\n+void ga1_0_ (void)\n+{\n+  a1_0.a[0] = 0;\n+  a1_0.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_0.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 1, { } };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+struct A1 a1_1 = { 0, { 1 } };\n+\n+void ga1_1 (void)\n+{\n+  a1_1.a[0] = 0;\n+  a1_1.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1_1.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 0, { 1 } };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Exercise interior one-element array members (verify they're not\n+// treated as trailing.\n+\n+struct A1i\n+{\n+  char n;\n+  char a[1];                    // { dg-message \"destination object\" }\n+  char x;\n+};\n+\n+// Verify warning for access to a definition with an initializer that doesn't\n+// initialize the one-element array member.\n+struct A1i a1i__ = { 0 };\n+\n+void ga1i__ (void)\n+{\n+  a1i__.a[0] = 0;\n+  a1i__.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i__.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1i a = { 0 };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member to empty.\n+struct A1 a1i_0 = { 0, { } };\n+\n+void ga1i_0_ (void)\n+{\n+  a1i_0.a[0] = 0;\n+  a1i_0.a[1] = 1;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_0.a[2] = 2;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 0, { } };\n+  a.a[0] = 0;\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}\n+\n+// Verify warning for access to a definition with an initializer that\n+// initializes the one-element array member.\n+struct A1 a1i_1 = { 0, { 1 } };\n+\n+void ga1i_1 (void)\n+{\n+  a1i_1.a[0] = 0;\n+  a1i_1.a[1] = 1;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a1i_1.a[2] = 2;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+\n+  struct A1 a = { 0, { 1 } };\n+  a.a[0] = 1;\n+  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  sink (&a);\n+}"}, {"sha": "ca38bda73f53549ad0a55f17181c52ec2a67c111", "filename": "gcc/testsuite/c-c++-common/Wstringop-overflow-2.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-overflow-2.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -190,7 +190,7 @@ void ga1__ (void)\n   struct A1 a = { 1 };\n   a.a[0] = 0;\n   a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n   sink (&a);\n }\n \n@@ -207,7 +207,7 @@ void ga1_0_ (void)\n   struct A1 a = { 1, { } };\n   a.a[0] = 0;\n   a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n   sink (&a);\n }\n \n@@ -221,10 +221,10 @@ void ga1_1 (void)\n   a1_1.a[1] = 1;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a1_1.a[2] = 2;                // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n \n-  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n   a.a[0] = 0;\n-  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n-  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { vect_slp_v4qi_store } } }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { vect_slp_v4qi_store } } }\n   sink (&a);\n }\n \n@@ -289,7 +289,7 @@ void ga1i__ (void)\n   struct A1i a = { 0 };\n   a.a[0] = 0;\n   a.a[1] = 1;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  a.a[2] = 2;                    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n   sink (&a);\n }\n \n@@ -306,7 +306,7 @@ void ga1i_0_ (void)\n   struct A1 a = { 0, { } };\n   a.a[0] = 0;\n   a.a[1] = 1;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n-  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  a.a[2] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v2qi_store } } }\n   sink (&a);\n }\n \n@@ -320,10 +320,10 @@ void ga1i_1 (void)\n   a1i_1.a[1] = 1;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n   a1i_1.a[2] = 2;               // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n \n-  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  struct A1 a = { 0, { 1 } };   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { target { vect_slp_v4qi_store } } }\n   a.a[0] = 1;\n-  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n-  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  a.a[1] = 2;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v4qi_store } } }\n+  a.a[2] = 3;                   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102462\" { xfail { vect_slp_v4qi_store } } }\n   sink (&a);\n }\n "}, {"sha": "da179a2c0f59932b3e4d68d540a97551d94b2481", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-48-novec.c", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,364 @@\n+/* PR middle-end/91647 - missing -Warray-bounds accessing a zero-length array\n+   of a declared object\n+   { dg-do \"compile\" }\n+   { dg-options \"-O2 -Wall -fno-tree-vectorize\" }\n+   { dg-require-effective-target alloca } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+\n+void sink (void*);\n+\n+/* Exercise a true flexible member.  */\n+\n+struct AX\n+{\n+  int32_t n;\n+  int16_t ax[];     // { dg-message \"while referencing 'ax'\" \"member\" }\n+};\n+\n+static void warn_ax_local (struct AX *p)\n+{\n+  p->ax[0] = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_ax_extern (struct AX *p)\n+{\n+  p->ax[0] = 0; p->ax[99] = 99; p->ax[999] = 999; p->ax[9999] = 9999;\n+}\n+\n+static void warn_ax_local_buf (struct AX *p)\n+{\n+  p->ax[0] = 4; p->ax[1] = 5;\n+\n+  p->ax[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[4] = 8;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_ax_extern_buf (struct AX *p)\n+{\n+  p->ax[0] = 9; p->ax[1] = 10; p->ax[2] = 11;\n+\n+  p->ax[3] = 12;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[4] = 13;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->ax[5] = 14;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_ax_extern_bufx (struct AX *p)\n+{\n+  p->ax[0] = 0; p->ax[99] = 99; p->ax[999] = 999; p->ax[9999] = 9999;\n+}\n+\n+static void nowarn_ax_ref (struct AX *p)\n+{\n+  p->ax[0] = 0; p->ax[99] = 99; p->ax[999] = 999; p->ax[9999] = 9999;\n+}\n+\n+void test_ax (struct AX *p, unsigned n)\n+{\n+  {\n+    struct AX sax;  // { dg-message \"defined here\" \"struct definition\" }\n+    warn_ax_local (&sax);\n+    sink (&sax);\n+  }\n+\n+  {\n+    extern\n+      struct AX xsax;\n+    nowarn_ax_extern (&xsax);\n+    sink (&xsax);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the local BUF is diagnosed.  */\n+    char ax_buf_p2[sizeof (struct AX) + 2 * sizeof (int16_t)];\n+    warn_ax_local_buf ((struct AX*) ax_buf_p2);\n+    sink (ax_buf_p2);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the extern BUF with a known\n+       bound is diagnosed.  */\n+    extern char ax_buf_p3[sizeof (struct AX) + 3 * sizeof (int16_t)];\n+    warn_ax_extern_buf ((struct AX*) ax_buf_p3);\n+    sink (ax_buf_p3);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFX with an unknown bound are not\n+       diagnosed.  */\n+    extern char bufx[];\n+    nowarn_ax_extern_bufx ((struct AX*) bufx);\n+    sink (bufx);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFN with a runtime bound are not\n+       diagnosed.  */\n+    char bufn[n];\n+    nowarn_ax_extern_bufx ((struct AX*) bufn);\n+    sink (bufn);\n+  }\n+\n+  nowarn_ax_ref (p);\n+}\n+\n+\n+/* Exercise a zero-length trailing member array.  It's the same as above\n+   except that extern declarations with no definitions are considered to\n+   have zero elements (they can't be initialized to have any).  */\n+\n+struct A0\n+{\n+  int32_t n;\n+  int16_t a0[0];    // { dg-message \"while referencing 'a0'\" \"member\" }\n+};\n+\n+static void warn_a0_local (struct A0 *p)\n+{\n+  p->a0[0] = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a0_extern (struct A0 *p)\n+{\n+  p->a0[0] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[1] = 3;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a0_local_buf (struct A0 *p)\n+{\n+  p->a0[0] = 4; p->a0[1] = 5;\n+\n+  p->a0[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[4] = 8;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a0_extern_buf (struct A0 *p)\n+{\n+  p->a0[0] = 9; p->a0[1] = 10; p->a0[2] = 11;\n+\n+  p->a0[3] = 12;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[4] = 13;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a0[5] = 14;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_a0_extern_bufx (struct A0 *p)\n+{\n+  p->a0[0] = 0; p->a0[99] = 99; p->a0[999] = 999; p->a0[9999] = 9999;\n+}\n+\n+static void nowarn_a0_ref (struct A0 *p)\n+{\n+  p->a0[0] = 0; p->a0[99] = 99; p->a0[999] = 999; p->a0[9999] = 9999;\n+}\n+\n+void test_a0 (struct A0 *p, unsigned n)\n+{\n+  {\n+    struct A0 sa0;  // { dg-message \"defined here\" \"struct definition\" }\n+    warn_a0_local (&sa0);\n+    sink (&sa0);\n+  }\n+\n+  {\n+    extern\n+      struct A0 xsa0;  // { dg-message \"defined here\" \"struct definition\" }\n+    warn_a0_extern (&xsa0);\n+    sink (&xsa0);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the local BUF is diagnosed.  */\n+    char a0_buf_p2[sizeof (struct A0) + 2 * sizeof (int16_t)];\n+    warn_a0_local_buf ((struct A0*) a0_buf_p2);\n+    sink (a0_buf_p2);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the extern BUF with a known\n+       bound is diagnosed.  */\n+    extern char a0_buf_p3[sizeof (struct A0) + 3 * sizeof (int16_t)];\n+    warn_a0_extern_buf ((struct A0*) a0_buf_p3);\n+    sink (a0_buf_p3);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFX with an unknown bound are not\n+       diagnosed.  */\n+    extern char bufx[];\n+    nowarn_a0_extern_bufx ((struct A0*) bufx);\n+    sink (bufx);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFN with a runtime bound are not\n+       diagnosed.  */\n+    char bufn[n];\n+    nowarn_a0_extern_bufx ((struct A0*) bufn);\n+    sink (bufn);\n+  }\n+\n+  nowarn_a0_ref (p);\n+}\n+\n+\n+/* Exercise a one-element trailing member array.  It's the same as above\n+   except that it has exactly one element.  */\n+\n+struct A1\n+{\n+  int32_t n;\n+  int16_t a1[1];    // { dg-message \"while referencing 'a1'\" }\n+};\n+\n+static void warn_a1_local_noinit (struct A1 *p)\n+{\n+  p->a1[0] = 0;\n+  p->a1[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a1[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_extern (struct A1 *p)\n+{\n+  p->a1[0] = 0;\n+  p->a1[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a1[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_init (struct A1 *p)\n+{\n+  p->a1[0] = 0;\n+  p->a1[1] = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a1[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_local_buf (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[1] = 1; p->a1[2] = 2; p->a1[3] = 3;\n+\n+  p->a1[4] = 4;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a1_extern_buf (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[1] = 1; p->a1[2] = 2; p->a1[3] = 3; p->a1[4] = 4;\n+\n+  p->a1[5] = 5;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void nowarn_a1_extern_bufx (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[99] = 99; p->a1[999] = 999; p->a1[9999] = 9999;\n+}\n+\n+static void nowarn_a1_ref (struct A1 *p)\n+{\n+  p->a1[0] = 0; p->a1[99] = 99; p->a1[999] = 999; p->a1[9999] = 9999;\n+}\n+\n+void test_a1 (struct A1 *p, unsigned n)\n+{\n+  {\n+    struct A1 a1;\n+    warn_a1_local_noinit (&a1);\n+    sink (&a1);\n+  }\n+\n+  {\n+    extern struct A1 a1x;\n+    warn_a1_extern (&a1x);\n+    sink (&a1x);\n+}\n+  {\n+    struct A1 a1 = { 0, { 1 } };\n+    warn_a1_init (&a1);\n+    sink (&a1);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the local BUF is diagnosed.  */\n+    char buf_p2[sizeof (struct A1) + 2 * sizeof (int16_t)];\n+    warn_a1_local_buf ((struct A1*) buf_p2);\n+    sink (buf_p2);\n+  }\n+\n+  {\n+    /* Verify out-of-bounds access to the extern BUF with a known\n+       bound is diagnosed.  */\n+    extern char a1_buf_p3[sizeof (struct A1) + 3 * sizeof (int16_t)];\n+    warn_a1_extern_buf ((struct A1*) a1_buf_p3);\n+    sink (a1_buf_p3);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFX with an unknown bound are not\n+       diagnosed.  */\n+    extern char bufx[];\n+    nowarn_a1_extern_bufx ((struct A1*) bufx);\n+    sink (bufx);\n+  }\n+\n+  {\n+    /* Verify that accesses to BUFN with a runtime bound are not\n+       diagnosed.  */\n+    char bufn[n];\n+    nowarn_a1_extern_bufx ((struct A1*) bufn);\n+    sink (bufn);\n+  }\n+\n+  nowarn_a1_ref (p);\n+}\n+\n+\n+/* Exercise a two-element trailing member array.  It's treated\n+   the same as an interior array member.  */\n+\n+struct A2\n+{\n+  int32_t n;\n+  int16_t a2[2];    // { dg-message \"while referencing 'a2'\" }\n+};\n+\n+static void warn_a2_noinit (struct A2 *p)\n+{\n+  p->a2[0] = 0; p->a2[1] = 1;\n+\n+  p->a2[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a2_init (struct A2 *p)\n+{\n+  p->a2[0] = 0; p->a2[1] = 1;\n+\n+  p->a2[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a2[9] = 9;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+static void warn_a2_ref (struct A2 *p)\n+{\n+  p->a2[0] = 0; p->a2[1] = 1;\n+\n+  p->a2[2] = 2;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a2[9] = 9;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}\n+\n+void test_a2 (struct A2 *p)\n+{\n+  {\n+    struct A2 a2;\n+    warn_a2_noinit (&a2);\n+    sink (&a2);\n+  }\n+\n+  {\n+    struct A2 a2 = { 0, { 1, 2 } };\n+    warn_a2_init (&a2);\n+    sink (&a2);\n+  }\n+\n+  warn_a2_ref (p);\n+}"}, {"sha": "19b7634c0635687283990737cc0acc8298982dba", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-48.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-48.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -30,7 +30,7 @@ static void nowarn_ax_extern (struct AX *p)\n \n static void warn_ax_local_buf (struct AX *p)\n {\n-  p->ax[0] = 4; p->ax[1] = 5;\n+  p->ax[0] = 4; p->ax[1] = 5;  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2hi_store &&  { ! vect_slp_v4hi_store } } } }\n \n   p->ax[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   p->ax[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n@@ -130,7 +130,7 @@ static void warn_a0_extern (struct A0 *p)\n \n static void warn_a0_local_buf (struct A0 *p)\n {\n-  p->a0[0] = 4; p->a0[1] = 5;\n+  p->a0[0] = 4; p->a0[1] = 5;  // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2hi_store && { ! vect_slp_v4hi_store } } } }\n \n   p->a0[2] = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   p->a0[3] = 7;     // { dg-warning \"\\\\\\[-Warray-bounds\" }"}, {"sha": "ef8056d9b7f76702fd064a794ea51e903a888f43", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-51-novec.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,21 @@\n+/* PR middle-end/92333 - missing variable name referencing VLA in warnings\n+   PR middle-end/82608 - missing -Warray-bounds on an out-of-bounds VLA index\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fno-tree-vectorize\" }  */\n+\n+void sink (void*);\n+\n+void test_struct_char_vla_location (void)\n+{\n+  unsigned nelts = 7;\n+\n+  struct {\n+    char cvla[nelts]; // { dg-message \"declared here|while referencing\" }\n+  } s;\n+\n+  s.cvla[0] = __LINE__;\n+  s.cvla[nelts - 1] = 0;\n+  s.cvla[nelts] = 0;  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  sink (&s);\n+}"}, {"sha": "8b589f381915776fa317ef68a5704d8b5dcb8e4d", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-51.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-51.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -39,7 +39,7 @@ void test_struct_char_vla_location (void)\n   } s;\n \n   s.cvla[0] = __LINE__;\n-  s.cvla[nelts - 1] = 0; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  s.cvla[nelts - 1] = 0; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2qi_store } } }\n   s.cvla[nelts] = 0;  // { dg-warning \"\\\\\\[-Warray-bounds\" }\n \n   sink (&s);"}, {"sha": "5089d555392457258571980e757d5d402d62aad6", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-3-novec.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,16 @@\n+/* PR c/50584 - No warning for passing small array to C99 static array\n+   declarator\n+   { dg-do compile }\n+   { dg-options \"-Wall -Warray-parameter=1\" } */\n+\n+/* Also verify that -Warray-bounds doesn't trigger for ordinary array\n+   parameters...  */\n+#pragma GCC optimize (\"2,no-tree-vectorize\")\n+\n+/* ...but does for static arrays.  */\n+__attribute__ ((noipa)) void\n+gcas3 (char a[static 3])\n+{\n+  a[0] = 0; a[1] = 1; a[2] = 2;\n+  a[3] = 3;                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+}"}, {"sha": "b6ed8daf51cb092b7329ffe8d3a771293f5f241a", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-3.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -77,7 +77,7 @@ gia3 (int a[3])\n __attribute__ ((noipa)) void\n gcas3 (char a[static 3])\n {\n-  a[0] = 0; a[1] = 1; a[2] = 2; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  a[0] = 0; a[1] = 1; a[2] = 2; // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n   a[3] = 3;                   // { dg-warning \"\\\\\\[-Warray-bounds\" }\n }\n "}, {"sha": "de39eaaeb951d86e325ab0d5195faac94278134d", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-14-novec.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,16 @@\n+/* Test to verify that past-the-end multibyte writes via lvalues of wider\n+   types than char are diagnosed.\n+   { dg-do compile }\n+   { dg-require-effective-target int32plus }\n+   { dg-options \"-O2 -fno-tree-vectorize -Wall -Wno-array-bounds\" }  */\n+\n+typedef __INT16_TYPE__  int16_t;\n+\n+char a4[4], a8[8], a16[16];\n+\n+void test_int16 (void)\n+{\n+  char *p = a4 + 1;\n+  *(int16_t*)p = 0;\n+  *(int16_t*)(p + 2) = 0;   // { dg-warning \"writing 2 bytes into a region of size 1\" }\n+}"}, {"sha": "c4a3f05d8830702e2841950872909b3ed572555f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-14.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-14.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -36,8 +36,8 @@ void test_memcpy_cond (int i)\n void test_int16 (void)\n {\n   char *p = a4 + 1;\n-  *(int16_t*)p = 0;    // { dg-warning \"writing 4 bytes into a region of size 3\" \"\" { target { i?86-*-* x86_64-*-* } } }\n-  *(int16_t*)(p + 2) = 0;   // { dg-warning \"writing 2 bytes into a region of size 1\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  *(int16_t*)p = 0;    // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v2hi_store } } }\n+  *(int16_t*)(p + 2) = 0;   // { dg-warning \"writing 2 bytes into a region of size 1\" \"pr102706\" { xfail { vect_slp_v2hi_store } } }\n }\n \n "}, {"sha": "6f83548e902346ab77e1527363eb9da46d20fe6c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-21-novec.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,34 @@\n+/* PR middle-end/92312 - bogus -Wstringop-overflow storing into a trailing\n+   array backed by larger buffer\n+   { dg-do compile }\n+   { dg-options \"-O2 -fno-tree-vectorize -Wall -Wno-array-bounds\" } */\n+\n+struct S0 { char a, b[0]; };\n+\n+void sink (void*);\n+\n+void test_store_zero_length (int i)\n+{\n+  char a[3];\n+  struct S0 *p = (struct S0*)a;\n+  p->a = 0;\n+  p->b[0] = 0;\n+  p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[2] = 2;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[i] = 2;\n+  sink (p);\n+}\n+\n+struct Sx { char a, b[]; };\n+\n+void test_store_flexarray (int i)\n+{\n+  char a[3];\n+  struct Sx *p = (struct Sx*)a;\n+  p->a = 0;\n+  p->b[0] = 0;\n+  p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[2] = 1;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  p->b[i] = 2;\n+  sink (p);\n+}"}, {"sha": "3fccfc9a7985497f34aa632ef9aa64fdbbd2c488", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-21.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-21.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -23,10 +23,10 @@ void test_store_zero_length (int i)\n {\n   char a[3];\n   struct S0 *p = (struct S0*)a;\n-  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n   p->b[0] = 0;\n   p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n-  p->b[2] = 2;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  p->b[2] = 2;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n   p->b[i] = 2;\n   sink (p);\n }\n@@ -50,10 +50,10 @@ void test_store_flexarray (int i)\n {\n   char a[3];\n   struct Sx *p = (struct Sx*)a;\n-  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  p->a = 0;                         // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n   p->b[0] = 0;\n   p->b[1] = 1;                      // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n-  p->b[2] = 1;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  p->b[2] = 1;                      // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n   p->b[i] = 2;\n   sink (p);\n }"}, {"sha": "04e91afb8bcf2a23562535181bec060c50532ea1", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-68.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-68.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -58,11 +58,18 @@ void warn_comp_lit_zero (void)\n void warn_comp_lit (void)\n {\n   *(AC2*)a1 = Ac2;      // { dg-warning \"writing 2 bytes into a region of size 1\" \"pr101475\" { xfail *-*-* } }\n-  *(AC4*)a2 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" \"pr101475\" { xfail { ! { i?86-*-* x86_64-*-* } } } }\n-  *(AC4*)a3 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr101475\" { xfail { ! { i?86-*-* x86_64-*-* } } } }\n-  *(AC8*)a4 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" \"pr101475\" { xfail { ! { i?86-*-* x86_64-*-* } } } }\n-  *(AC8*)a7 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" \"pr101475\" { xfail { ! { i?86-*-* x86_64-*-* } } } }\n-  *(AC16*)a15 = Ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" \"pr101475\" { xfail { ! { i?86-*-* x86_64-*-* } } } }\n+  // After vectorization, below codes are optimized to\n+  // MEM <vector(4) char> [(char *)&a2] = { 0, 1, 2, 3 };\n+  // MEM <vector(4) char> [(char *)&a3] = { 0, 1, 2, 3 };\n+  // MEM <vector(8) char> [(char *)&a4] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  // MEM <vector(8) char> [(char *)&a7] = { 0, 1, 2, 3, 4, 5, 6, 7 };\n+  // MEM <vector(16) char> [(char *)&a15] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 };\n+  // and warning should be expected, refer to PR102722.\n+  *(AC4*)a2 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 2\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store } } } }\n+  *(AC4*)a3 = Ac4;      // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr101475\" { xfail { ! { vect_slp_v4qi_store } } } }\n+  *(AC8*)a4 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 4\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store } } } }\n+  *(AC8*)a7 = Ac8;      // { dg-warning \"writing 8 bytes into a region of size 7\" \"pr101475\" { xfail { ! { vect_slp_v8qi_store } } } }\n+  *(AC16*)a15 = Ac16;   // { dg-warning \"writing 16 bytes into a region of size 15\" \"pr101475\" { xfail { ! { vect_slp_v16qi_store } } } }\n }\n \n void warn_aggr_decl (void)"}, {"sha": "71c643b62fb42d476d5af5224b7eba3971d6f808", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-76-novec.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,88 @@\n+/* Verify warnings and notes for MAX_EXPRs involving either pointers\n+   to distinct objects or one to a known object and the other to\n+   an unknown one.  Unlike for the same object, for unrelated objects\n+   the expected warnings and notes are the same as for MIN_EXPR: when\n+   the order of the objects in the address space cannot be determined\n+   the larger of them is assumed to be used.  (This is different for\n+   distinct struct members where the order is given.)\n+   The relational expressions are strictly invalid but that should be\n+   diagnosed by a separate warning.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wno-array-bounds -fno-tree-vectorize\" } */\n+\n+#define MAX(p, q) ((p) > (q) ? (p) : (q))\n+\n+/* Verify that even for MAX_EXPR and like for MIN_EXPR, the note points\n+   to the larger of the two objects and mentions the offset into it\n+   (although the offset might be better included in the warning).  */\n+extern char a3[3];\n+extern char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" }\n+\n+void max_a3_a5 (int i)\n+{\n+  char *p = a3 + i;\n+  char *q = a5 + i;\n+\n+  /* The relational expression below is invalid and should be diagnosed\n+     by its own warning independently of -Wstringop-overflow.  */\n+  char *d = MAX (p, q);\n+\n+  d[2] = 0;\n+  d[3] = 0;\n+  d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+// Same as above but with the larger array as the first MAX_EXPR operand.\n+extern char b4[4];\n+extern char b6[6];  // { dg-message \"at offset 6 into destination object 'b6' of size 6\" \"note\" }\n+\n+void max_b6_b4 (int i)\n+{\n+  char *p = b6 + i;\n+  char *q = b4 + i;\n+  char *d = MAX (p, q);\n+\n+  d[3] = 0;\n+  d[4] = 0;\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+struct A3_5\n+{\n+  char a3[3];  // { dg-message \"at offset 3 into destination object 'a3' of size 3\" \"pr??????\" { xfail *-*-* } }\n+  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" }\n+};\n+\n+void max_A3_A5 (int i, struct A3_5 *pa3_5)\n+{\n+  char *p = pa3_5->a3 + i;\n+  char *q = pa3_5->a5 + i;\n+\n+  char *d = MAX (p, q);\n+  d[2] = 0;\n+  d[3] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr??????\" { xfail *-*-* } }\n+  d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct B4_B6\n+{\n+  char b4[4];\n+  char b6[6];       // { dg-message \"at offset 6 into destination object 'b6' of size 6\" \"note\" }\n+};\n+\n+void max_B6_B4 (int i, struct B4_B6 *pb4_b6)\n+{\n+  char *p = pb4_b6->b6 + i;\n+  char *q = pb4_b6->b4 + i;\n+  char *d = MAX (p, q);\n+\n+  d[3] = 0;\n+  d[4] = 0;\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}"}, {"sha": "52467267a0490de2490e1fabd8d3d3f3bdbd1294", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-76.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -27,10 +27,10 @@ void max_a3_a5 (int i)\n      by its own warning independently of -Wstringop-overflow.  */\n   char *d = MAX (p, q);\n \n-  d[2] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  d[2] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n   d[3] = 0;\n   d[4] = 0;\n-  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n }\n \n \n@@ -44,10 +44,10 @@ void max_b6_b4 (int i)\n   char *q = b4 + i;\n   char *d = MAX (p, q);\n \n-  d[3] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"\" { target { i?86-*-* x86_64-*-* } } }\n+  d[3] = 0;         // { dg-warning \"writing 4 bytes into a region of size 3\" \"pr102706\" { target { vect_slp_v4qi_store } } }\n   d[4] = 0;\n   d[5] = 0;\n-  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102706\" { xfail { vect_slp_v4qi_store } } }\n }\n \n \n@@ -82,7 +82,8 @@ void max_d8_p (char *q, int i)\n struct A3_5\n {\n   char a3[3];  // { dg-message \"at offset 3 into destination object 'a3' of size 3\" \"pr??????\" { xfail *-*-* } }\n-  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" { xfail { i?86-*-* x86_64-*-* } } }\n+  // refer to pr102697 for xfail\n+  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" { xfail { vect_slp_v4qi_store } } }\n };\n \n void max_A3_A5 (int i, struct A3_5 *pa3_5)\n@@ -95,14 +96,15 @@ void max_A3_A5 (int i, struct A3_5 *pa3_5)\n   d[2] = 0;\n   d[3] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr??????\" { xfail *-*-* } }\n   d[4] = 0;\n-  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102697\" { xfail { vect_slp_v4qi_store } } }\n }\n \n \n struct B4_B6\n {\n   char b4[4];\n-  char b6[6];       // { dg-message \"at offset \\[^a-zA-Z\\n\\r\\]*6\\[^a-zA-Z0-9\\]* into destination object 'b6' of size 6\" \"note\" { xfail { i?86-*-* x86_64-*-* } } }\n+  // refer to pr102697 for xfail\n+  char b6[6];       // { dg-message \"at offset \\[^a-zA-Z\\n\\r\\]*6\\[^a-zA-Z0-9\\]* into destination object 'b6' of size 6\" \"note\" { xfail { vect_slp_v4qi_store } } }\n };\n \n void max_B6_B4 (int i, struct B4_B6 *pb4_b6)\n@@ -114,7 +116,7 @@ void max_B6_B4 (int i, struct B4_B6 *pb4_b6)\n   d[3] = 0;\n   d[4] = 0;\n   d[5] = 0;\n-  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"\" { xfail { i?86-*-* x86_64-*-* } } }\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr102697\" { xfail { vect_slp_v4qi_store } } }\n }\n \n "}, {"sha": "8e023b7cfa7fbef11acb306d6e0962ea4c43a9aa", "filename": "gcc/testsuite/gcc.dg/Wzero-length-array-bounds-2-novec.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2-novec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2-novec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2-novec.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -0,0 +1,45 @@\n+/* Test to verify that -Wzero-length-bounds and not -Warray-bounds is\n+   issued for accesses to interior zero-length array members that are\n+   within the bounds of the enclosing struct.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fno-tree-vectorize\" } */\n+\n+void sink (void*);\n+\n+struct A { int i; };\n+struct B { int j; struct A a[0]; };\n+\n+struct C\n+{\n+  struct B b1;\n+  struct B b2;\n+};\n+\n+char cbuf1[1 * sizeof (struct C)];\n+char cbuf2[2 * sizeof (struct C)] = { };\n+\n+void test_C_global_buf (void)\n+{\n+  struct C *p = (struct C*)&cbuf1;\n+\n+  p->b1.a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  p->b2.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  p = (struct C*)&cbuf2;\n+  p->b1.a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (p);\n+\n+  p->b2.a[ 0].i = 0;\n+  p->b2.a[ 1].i = 0;\n+  p->b2.a[ 2].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 3].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+}"}, {"sha": "b2321495afcebf41dfa3e753a6299953b3d0b8fc", "filename": "gcc/testsuite/gcc.dg/Wzero-length-array-bounds-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -87,7 +87,7 @@ void test_C_global_buf (void)\n   p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n   sink (p);\n \n-  p->b2.a[ 0].i = 0;\n+  p->b2.a[ 0].i = 0;    // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr102706\" { target { vect_slp_v2si_store &&  { ! vect_slp_v4si_store } } } }\n   p->b2.a[ 1].i = 0;\n   p->b2.a[ 2].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n   p->b2.a[ 3].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }"}, {"sha": "1c8b1ebb86e8769e40fe88af3a4c651990dbb2a1", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c8d8c0be95e99dc0cba7f6fad2429243582119f/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=3c8d8c0be95e99dc0cba7f6fad2429243582119f", "patch": "@@ -7580,6 +7580,188 @@ proc check_effective_target_vect_element_align_preferred { } {\n \t\t   && [check_effective_target_vect_variable_length] }]\n }\n \n+# Return true if vectorization of v2qi/v4qi/v8qi/v16qi/v2hi store is enabed.\n+# Return zero if the desirable pattern isn't found.\n+# It's used by Warray-bounds/Wstringop-overflow testcases which are\n+# regressed by O2 vectorization, refer to PR102697/PR102462/PR102706\n+proc check_vect_slp_aligned_store_usage { pattern macro } {\n+    global tool\n+\n+    set result [check_compile slp_aligned_store_usage assembly {\n+\tchar a[16] __attribute__ ((aligned (16)));\n+\tshort b[4] __attribute__((aligned(8)));\n+\tint c[4] __attribute__((aligned(16)));\n+\t#ifdef TEST_V8QI\n+\tvoid\n+\tfoo ()\n+\t{\n+\t    a[0] = 0;\n+\t    a[1] = 1;\n+\t    a[2] = 2;\n+\t    a[3] = 3;\n+\t    a[4] = 4;\n+\t    a[5] = 5;\n+\t    a[6] = 6;\n+\t    a[7] = 7;\n+\t}\n+\t#elif TEST_V16QI\n+\tvoid\n+\tfoo1 ()\n+\t{\n+\t    a[0] = 0;\n+\t    a[1] = 1;\n+\t    a[2] = 2;\n+\t    a[3] = 3;\n+\t    a[4] = 4;\n+\t    a[5] = 5;\n+\t    a[6] = 6;\n+\t    a[7] = 7;\n+\t    a[8] = 8;\n+\t    a[9] = 9;\n+\t    a[10] = 10;\n+\t    a[11] = 11;\n+\t    a[12] = 12;\n+\t    a[13] = 13;\n+\t    a[14] = 14;\n+\t    a[15] = 15;\n+\t}\n+\t#elif TEST_V4QI\n+\tvoid\n+\tfoo2 ()\n+\t{\n+\t    a[0] = 0;\n+\t    a[1] = 1;\n+\t    a[2] = 2;\n+\t    a[3] = 3;\n+\t}\n+\t#elif TEST_V2QI\n+\tvoid\n+\tfoo3 ()\n+\t{\n+\t    a[0] = 0;\n+\t    a[1] = 1;\n+\t}\n+\t#elif TEST_V2HI\n+\tvoid\n+\tfoo4 ()\n+\t{\n+\t    b[0] = 0;\n+\t    b[1] = 1;\n+\t}\n+\t#elif TEST_V4HI\n+\tvoid\n+\tfoo5 ()\n+\t{\n+\t    b[0] = 0;\n+\t    b[1] = 1;\n+\t    b[2] = 2;\n+\t    b[3] = 3;\n+\t}\n+\t#elif TEST_V2SI\n+\tvoid\n+\tfoo6 ()\n+\t{\n+\t    c[0] = 0;\n+\t    c[1] = 1;\n+\t}\n+\t#elif TEST_V4SI\n+\tvoid\n+\tfoo7 ()\n+\t{\n+\t    c[0] = 0;\n+\t    c[1] = 1;\n+\t    c[2] = 2;\n+\t    c[3] = 3;\n+\t}\n+\t#endif\n+    } \"-O2 -fopt-info-all -D$macro\" ]\n+\n+      # Get compiler emitted messages and delete generated file.\n+      set lines [lindex $result 0]\n+      set output [lindex $result 1]\n+      remote_file build delete $output\n+\n+      # Check pattern exits in lines, set it to zero if not found.\n+      if { [regexp $pattern $lines] } then {\n+        return 1\n+      }\n+\n+    return 0\n+}\n+\n+# Return the true if target support vectorization of 2-byte char stores\n+# with 2-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v2qi_store { } {\n+    set pattern {add new stmt: MEM <vector\\(2\\) char>}\n+    set macro \"TEST_V2QI\"\n+    return [check_cached_effective_target vect_slp_v2qi_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro] }]\n+\n+}\n+\n+# Return the true if target support vectorization of 4-byte char stores\n+# with 4-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v4qi_store { } {\n+    set pattern {add new stmt: MEM <vector\\(4\\) char>}\n+    set macro \"TEST_V4QI\"\n+    return [check_cached_effective_target vect_slp_v4qi_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 8-byte char stores\n+# with 8-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v8qi_store { } {\n+    set pattern {add new stmt: MEM <vector\\(8\\) char>}\n+    set macro \"TEST_V8QI\"\n+    return [check_cached_effective_target vect_slp_v8qi_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 16-byte char stores\n+# with 16-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v16qi_store { } {\n+    set pattern {add new stmt: MEM <vector\\(16\\) char>}\n+    set macro \"TEST_V16QI\"\n+    return [check_cached_effective_target vect_slp_v16qi_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 4-byte short stores\n+# with 4-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v2hi_store { } {\n+    set pattern {add new stmt: MEM <vector\\(2\\) short int>}\n+    set macro \"TEST_V2HI\"\n+    return [check_cached_effective_target vect_slp_v2hi_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 8-byte short stores\n+# with 8-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v4hi_store { } {\n+    set pattern {add new stmt: MEM <vector\\(4\\) short int>}\n+    set macro \"TEST_V4HI\"\n+    return [check_cached_effective_target vect_slp_v4hi_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 8-byte int stores\n+# with 8-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v2si_store { } {\n+    set pattern {add new stmt: MEM <vector\\(2\\) int>}\n+    set macro \"TEST_V2SI\"\n+    return [check_cached_effective_target vect_slp_v2si_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n+# Return the true if target support vectorization of 16-byte int stores\n+# with 16-byte aligned address at plain O2.\n+proc check_effective_target_vect_slp_v4si_store { } {\n+    set pattern {add new stmt: MEM <vector\\(4\\) int>}\n+    set macro \"TEST_V4SI\"\n+    return [check_cached_effective_target vect_slp_v4si_store {\n+\texpr [check_vect_slp_aligned_store_usage $pattern $macro ] }]\n+}\n+\n # Return 1 if we can align stack data to the preferred vector alignment.\n \n proc check_effective_target_vect_align_stack_vars { } {"}]}