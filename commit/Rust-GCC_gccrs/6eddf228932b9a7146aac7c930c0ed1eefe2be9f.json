{"sha": "6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVkZGYyMjg5MzJiOWE3MTQ2YWFjN2M5MzBjMGVkMWVlZmUyYmU5Zg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-05-29T08:21:17Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-05-29T08:21:17Z"}, "message": "tree-vect-slp.c (vect_bb_slp_scalar_cost): New function computing scalar cost offsetted by stmts that are kept live by...\n\n2013-05-29  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_bb_slp_scalar_cost): New function\n\tcomputing scalar cost offsetted by stmts that are kept live\n\tby scalar uses.\n\t(vect_bb_vectorization_profitable_p): Use vect_bb_slp_scalar_cost\n\tfor computation of scalar cost.\n\n\t* gcc.dg/vect/bb-slp-32.c: New testcase.\n\nFrom-SVN: r199402", "tree": {"sha": "41ae1c0457832a11e435f1b4253c957229a17904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41ae1c0457832a11e435f1b4253c957229a17904"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d2510014de7affa7e74733c6300c2b5a8cc6d97f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2510014de7affa7e74733c6300c2b5a8cc6d97f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2510014de7affa7e74733c6300c2b5a8cc6d97f"}], "stats": {"total": 128, "additions": 105, "deletions": 23}, "files": [{"sha": "456a4cf87f2d60cda25bb6ead4c4c31c3f49753a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "patch": "@@ -1,3 +1,11 @@\n+2013-05-29  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_bb_slp_scalar_cost): New function\n+\tcomputing scalar cost offsetted by stmts that are kept live\n+\tby scalar uses.\n+\t(vect_bb_vectorization_profitable_p): Use vect_bb_slp_scalar_cost\n+\tfor computation of scalar cost.\n+\n 2013-05-28  Steve Ellcey  <sellcey@mips.com>\n \n \t* config/mips/mips-cpus.def (mips32r2): Change processor type."}, {"sha": "533abbb3be88d14c7998af05125bc402631aa826", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "patch": "@@ -1,3 +1,7 @@\n+2013-05-29  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/bb-slp-32.c: New testcase.\n+\n 2013-05-28  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-c++-common/cilk-plus/AN/array_test1.c: New test."}, {"sha": "df8008396a0fdcbdfe41bb8fa4216e565bbc09df", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-32.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-32.c?ref=6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-fvect-cost-model\" } */\n+\n+void bar (int *);\n+int foo (int *p)\n+{\n+  int x[4];\n+  int tem0, tem1, tem2, tem3;\n+  tem0 = p[0] + 1;\n+  x[0] = tem0;\n+  tem1 = p[1] + 2;\n+  x[1] = tem1;\n+  tem2 = p[2] + 3;\n+  x[2] = tem2;\n+  tem3 = p[3] + 4;\n+  x[3] = tem3;\n+  bar (x);\n+  return tem0 + tem1 + tem2 + tem3;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorization is not profitable\" \"slp\" } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */"}, {"sha": "5d8e85f16a62b5bae95adbd103a9027cf0148705", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 70, "deletions": 23, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eddf228932b9a7146aac7c930c0ed1eefe2be9f/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6eddf228932b9a7146aac7c930c0ed1eefe2be9f", "patch": "@@ -1898,6 +1898,69 @@ vect_slp_analyze_operations (bb_vec_info bb_vinfo)\n   return true;\n }\n \n+\n+/* Compute the scalar cost of the SLP node NODE and its children\n+   and return it.  Do not account defs that are marked in LIFE and\n+   update LIFE according to uses of NODE.  */\n+\n+static unsigned\n+vect_bb_slp_scalar_cost (slp_tree node, vec<bool, va_stack> life)\n+{\n+  unsigned scalar_cost = 0;\n+  unsigned i;\n+  gimple stmt;\n+  slp_tree child;\n+\n+  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt)\n+    {\n+      unsigned stmt_cost;\n+      ssa_op_iter op_iter;\n+      def_operand_p def_p;\n+      stmt_vec_info stmt_info;\n+\n+      if (life[i])\n+\tcontinue;\n+\n+      /* If there is a non-vectorized use of the defs then the scalar\n+         stmt is kept live in which case we do not account it or any\n+\t required defs in the SLP children in the scalar cost.  This\n+\t way we make the vectorization more costly when compared to\n+\t the scalar cost.  */\n+      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_DEF)\n+\t{\n+\t  imm_use_iterator use_iter;\n+\t  gimple use_stmt;\n+\t  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, DEF_FROM_PTR (def_p))\n+\t    if (!vinfo_for_stmt (use_stmt)\n+\t\t|| !STMT_VINFO_VECTORIZABLE (vinfo_for_stmt (use_stmt)))\n+\t      {\n+\t\tlife[i] = true;\n+\t\tBREAK_FROM_IMM_USE_STMT (use_iter);\n+\t      }\n+\t}\n+      if (life[i])\n+\tcontinue;\n+\n+      stmt_info = vinfo_for_stmt (stmt);\n+      if (STMT_VINFO_DATA_REF (stmt_info))\n+        {\n+          if (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n+            stmt_cost = vect_get_stmt_cost (scalar_load);\n+          else\n+            stmt_cost = vect_get_stmt_cost (scalar_store);\n+        }\n+      else\n+        stmt_cost = vect_get_stmt_cost (scalar_stmt);\n+\n+      scalar_cost += stmt_cost;\n+    }\n+\n+  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+    scalar_cost += vect_bb_slp_scalar_cost (child, life);\n+\n+  return scalar_cost;\n+}\n+\n /* Check if vectorization of the basic block is profitable.  */\n \n static bool\n@@ -1908,10 +1971,6 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n   int i, j;\n   unsigned int vec_inside_cost = 0, vec_outside_cost = 0, scalar_cost = 0;\n   unsigned int vec_prologue_cost = 0, vec_epilogue_cost = 0;\n-  unsigned int stmt_cost;\n-  gimple stmt;\n-  gimple_stmt_iterator si;\n-  basic_block bb = BB_VINFO_BB (bb_vinfo);\n   void *target_cost_data = BB_VINFO_TARGET_COST_DATA (bb_vinfo);\n   stmt_vec_info stmt_info = NULL;\n   stmt_vector_for_cost body_cost_vec;\n@@ -1931,26 +1990,14 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n     }\n \n   /* Calculate scalar cost.  */\n-  for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n-      stmt = gsi_stmt (si);\n-      stmt_info = vinfo_for_stmt (stmt);\n-\n-      if (!stmt_info || !STMT_VINFO_VECTORIZABLE (stmt_info)\n-          || !PURE_SLP_STMT (stmt_info))\n-        continue;\n-\n-      if (STMT_VINFO_DATA_REF (stmt_info))\n-        {\n-          if (DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n-            stmt_cost = vect_get_stmt_cost (scalar_load);\n-          else\n-            stmt_cost = vect_get_stmt_cost (scalar_store);\n-        }\n-      else\n-        stmt_cost = vect_get_stmt_cost (scalar_stmt);\n-\n-      scalar_cost += stmt_cost;\n+      vec<bool, va_stack> life;\n+      vec_stack_alloc (bool, life, SLP_INSTANCE_GROUP_SIZE (instance));\n+      life.quick_grow_cleared (SLP_INSTANCE_GROUP_SIZE (instance));\n+      scalar_cost += vect_bb_slp_scalar_cost (SLP_INSTANCE_TREE (instance),\n+\t\t\t\t\t      life);\n+      life.release ();\n     }\n \n   /* Complete the target-specific cost calculation.  */"}]}