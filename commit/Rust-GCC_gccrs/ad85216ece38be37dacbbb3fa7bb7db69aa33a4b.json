{"sha": "ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ4NTIxNmVjZTM4YmUzN2RhY2JiYjNmYTdiYjdkYjY5YWEzM2E0Yg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-09-07T02:36:41Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-09-07T02:36:41Z"}, "message": "c-aux-info.c (concat): Don't define.\n\n\t* c-aux-info.c (concat): Don't define.\n\n\t* cccp.c (my_strerror): Likewise.  All callers changed to use\n\txstrerror instead.\n\t(do_include): Call xstrdup, not xmalloc/strcpy.\n\t(grow_outbuf): Don't check if xrealloc returns NULL, it can't.\n\t(xmalloc, xrealloc, xcalloc, xstrdup): Don't define.\n\n\t* collect2.c (my_strsignal): Likewise.  All callers changed to use\n\tstrsignal instead.\n\t(locatelib): Call xstrdup, not xmalloc/strcpy.\n\n\t* 1750a.h (ASM_OUTPUT_INTERNAL_LABEL): Call xmalloc, not malloc.\n\n\t* dsp16xx.c (override_options): Call xstrdup, not xmalloc/strcpy.\n\n\t* i370.h (ASM_DECLARE_FUNCTION_NAME): Call xmalloc, not malloc.\n\n\t* mips.c (build_mips16_call_stub): Call xstrdup, not xmalloc/strcpy.\n\n\t* cppinit.c (cpp_options_init): Call xcalloc, not xmalloc/bzero.\n\n\t* dwarfout.c (dwarfout_init): Call concat, not xmalloc/strcpy/...\n\n\t* except.c (new_eh_region_entry): Call xmalloc/xrealloc, not\n\tmalloc/realloc.\n\t(find_all_handler_type_matches): Likewise.  Don't check return\n\tvalue.\n\t(get_new_handler, init_insn_eh_region, process_nestinfo): Call\n\txmalloc, not malloc.\n\t(init_eh_nesting_info): Likewise.  Call xcalloc, not xmalloc/bzero.\n\n\t* gcc.c (xstrerror, xmalloc, xrealloc): Don't define.\n\t(init_spec): Call xcalloc, not xmalloc/bzero.\n\t(set_spec): Call xstrdup, not save_string.\n\t(record_temp_file): Call xstrdup, not xmalloc/strcpy.\n\t(find_a_file): Call xstrdup, not xmalloc/strcpy.\n\t(process_command): Call xstrdup, not save_string.\n\t(main): Call xcalloc, not xmalloc/bzero.\n\n\t* gcov.c (xmalloc): Don't define.\n\t(create_program_flow_graph): Call xcalloc, not xmalloc/bzero.\n\t(scan_for_source_files): Call xstrdup, not xmalloc/strcpy.\n\t(output_data): Call xcalloc, not xmalloc/bzero.\n\n\t* haifa-sched.c (schedule_insns): Call xcalloc, not xmalloc/bzero.\n\n\t* mips-tdump.c (xmalloc): Don't define.\n\t(print_symbol): Call xmalloc, not malloc.\n\t(read_tfile): Call xcalloc, not calloc.\n\n\t* mips-tfile.c (xfree, my_strsignal, xmalloc, xcalloc, xrealloc):\n\tDon't define.  All callers of xfree/my_strsignal changed to use\n\tfree/strsignal instead.\n\t(allocate_cluster): Call xcalloc, not calloc.\n\n\t* objc/objc-act.c (lang_init): Call concat, not xmalloc/strcpy/...\n\tFix memory leak, free allocated memory.\n\n\t* prefix.c (translate_name): Call xstrdup, not save_string.\n\t(update_path): Likewise.\n\n\t* profile.c (branch_prob): Call xstrdup, not xmalloc/strcpy.\n\n\t* protoize.c (xstrerror, xmalloc, xrealloc, xfree, savestring2):\n\tDon't define.  Callers of xfree/savestring2 changed to use\n\tfree/concat instead.\n\n\t* reload1.c (reload): Call xcalloc, not xmalloc/bzero.\n\t(init_elim_table): Likewise.\n\n\t* resource.c (init_resource_info): Likewise.\n\n\t* stupid.c (stupid_life_analysis): Likewise.\n\n\t* toplev.c (xmalloc, xcalloc, xrealloc, xstrdup): Don't define.\n\t(open_dump_file): Call concat, not xmalloc/strcpy/...\n\t(clean_dump_file): Likewise.\n\t(compile_file): Call xstrdup, not xmalloc/strcpy.\n\nFrom-SVN: r29148", "tree": {"sha": "4078f3a9721ec2407abe016bdfff56e653a05da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4078f3a9721ec2407abe016bdfff56e653a05da4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/comments", "author": null, "committer": null, "parents": [{"sha": "d821b3ac44bd8fe0339c7293046c422109d1910c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d821b3ac44bd8fe0339c7293046c422109d1910c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d821b3ac44bd8fe0339c7293046c422109d1910c"}], "stats": {"total": 946, "additions": 200, "deletions": 746}, "files": [{"sha": "01e15cc0776fb28091ba5a45e13920f43a4f0903", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -1,3 +1,85 @@\n+Mon Sep  6 22:31:28 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-aux-info.c (concat): Don't define.\n+\n+\t* cccp.c (my_strerror): Likewise.  All callers changed to use\n+\txstrerror instead.\n+\t(do_include): Call xstrdup, not xmalloc/strcpy.\n+\t(grow_outbuf): Don't check if xrealloc returns NULL, it can't.\n+\t(xmalloc, xrealloc, xcalloc, xstrdup): Don't define.\n+\n+\t* collect2.c (my_strsignal): Likewise.  All callers changed to use\n+\tstrsignal instead.\n+\t(locatelib): Call xstrdup, not xmalloc/strcpy.\n+\n+\t* 1750a.h (ASM_OUTPUT_INTERNAL_LABEL): Call xmalloc, not malloc.\n+\n+\t* dsp16xx.c (override_options): Call xstrdup, not xmalloc/strcpy.\n+\n+\t* i370.h (ASM_DECLARE_FUNCTION_NAME): Call xmalloc, not malloc.\n+\n+\t* mips.c (build_mips16_call_stub): Call xstrdup, not xmalloc/strcpy.\n+\n+\t* cppinit.c (cpp_options_init): Call xcalloc, not xmalloc/bzero.\n+\n+\t* dwarfout.c (dwarfout_init): Call concat, not xmalloc/strcpy/...\n+\n+\t* except.c (new_eh_region_entry): Call xmalloc/xrealloc, not\n+\tmalloc/realloc.\n+\t(find_all_handler_type_matches): Likewise.  Don't check return\n+\tvalue.\n+\t(get_new_handler, init_insn_eh_region, process_nestinfo): Call\n+\txmalloc, not malloc.\n+\t(init_eh_nesting_info): Likewise.  Call xcalloc, not xmalloc/bzero.\n+\n+\t* gcc.c (xstrerror, xmalloc, xrealloc): Don't define.\n+\t(init_spec): Call xcalloc, not xmalloc/bzero.\n+\t(set_spec): Call xstrdup, not save_string.\n+\t(record_temp_file): Call xstrdup, not xmalloc/strcpy.\n+\t(find_a_file): Call xstrdup, not xmalloc/strcpy.\n+\t(process_command): Call xstrdup, not save_string.\n+\t(main): Call xcalloc, not xmalloc/bzero.\n+\n+\t* gcov.c (xmalloc): Don't define.\n+\t(create_program_flow_graph): Call xcalloc, not xmalloc/bzero.\n+\t(scan_for_source_files): Call xstrdup, not xmalloc/strcpy.\n+\t(output_data): Call xcalloc, not xmalloc/bzero.\n+\n+\t* haifa-sched.c (schedule_insns): Call xcalloc, not xmalloc/bzero.\n+\n+\t* mips-tdump.c (xmalloc): Don't define.\n+\t(print_symbol): Call xmalloc, not malloc.\n+\t(read_tfile): Call xcalloc, not calloc.\n+\n+\t* mips-tfile.c (xfree, my_strsignal, xmalloc, xcalloc, xrealloc):\n+\tDon't define.  All callers of xfree/my_strsignal changed to use\n+\tfree/strsignal instead.\n+\t(allocate_cluster): Call xcalloc, not calloc.\n+\n+\t* objc/objc-act.c (lang_init): Call concat, not xmalloc/strcpy/...\n+\tFix memory leak, free allocated memory.\n+\n+\t* prefix.c (translate_name): Call xstrdup, not save_string.\n+\t(update_path): Likewise.\n+\n+\t* profile.c (branch_prob): Call xstrdup, not xmalloc/strcpy.\n+\n+\t* protoize.c (xstrerror, xmalloc, xrealloc, xfree, savestring2):\n+\tDon't define.  Callers of xfree/savestring2 changed to use\n+\tfree/concat instead.\n+\n+\t* reload1.c (reload): Call xcalloc, not xmalloc/bzero.\n+\t(init_elim_table): Likewise.\n+\n+\t* resource.c (init_resource_info): Likewise.\n+\n+\t* stupid.c (stupid_life_analysis): Likewise.\n+\n+\t* toplev.c (xmalloc, xcalloc, xrealloc, xstrdup): Don't define.\n+\t(open_dump_file): Call concat, not xmalloc/strcpy/...\n+\t(clean_dump_file): Likewise.\n+\t(compile_file): Call xstrdup, not xmalloc/strcpy.\n+\n Mon Sep  6 15:04:55 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* v850.h (EXPAND_BUILTIN_VA_ARG): New."}, {"sha": "4131abf5e6833d8472c948571051ea03206e6928", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -45,67 +45,6 @@ static const char *gen_formal_list_for_func_def PROTO((tree, formals_style));\n static const char *gen_type\t\tPROTO((const char *, tree, formals_style));\n static const char *gen_decl\t\tPROTO((tree, int, formals_style));\n \f\n-/* Concatenate a sequence of strings, returning the result.\n-\n-   This function is based on the one in libiberty.  */\n-\n-/* This definition will conflict with the one from prefix.c in\n-   libcpp.a when linking cc1 and cc1obj.  So only provide it if we are\n-   not using libcpp.a */\n-#ifndef USE_CPPLIB\n-char *\n-concat VPROTO((const char *first, ...))\n-{\n-  register int length;\n-  register char *newstr;\n-  register char *end;\n-  register const char *arg;\n-  va_list args;\n-#ifndef ANSI_PROTOTYPES\n-  const char *first;\n-#endif\n-\n-  /* First compute the size of the result and get sufficient memory.  */\n-\n-  VA_START (args, first);\n-#ifndef ANSI_PROTOTYPES\n-  first = va_arg (args, const char *);\n-#endif\n-\n-  arg = first;\n-  length = 0;\n-\n-  while (arg != 0)\n-    {\n-      length += strlen (arg);\n-      arg = va_arg (args, const char *);\n-    }\n-\n-  newstr = (char *) malloc (length + 1);\n-  va_end (args);\n-\n-  /* Now copy the individual pieces to the result string.  */\n-\n-  VA_START (args, first);\n-#ifndef ANSI_PROTOTYPES\n-  first = va_arg (args, char *);\n-#endif\n-\n-  end = newstr;\n-  arg = first;\n-  while (arg != 0)\n-    {\n-      while (*arg)\n-\t*end++ = *arg++;\n-      arg = va_arg (args, const char *);\n-    }\n-  *end = '\\000';\n-  va_end (args);\n-\n-  return (newstr);\n-}\n-#endif /* ! USE_CPPLIB */\n-\n /* Given a string representing an entire type or an entire declaration\n    which only lacks the actual \"data-type\" specifier (at its left end),\n    affix the data-type specifier to the left end of the given type"}, {"sha": "d4d2a39fcf50233deb893455a66a3a8715842136", "filename": "gcc/cccp.c", "status": "modified", "additions": 4, "deletions": 86, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -964,7 +964,6 @@ static int discard_comments PROTO((U_CHAR *, int, int));\n \n static int change_newlines PROTO((U_CHAR *, int));\n \n-static char *my_strerror PROTO((int));\n static void notice PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n static void vnotice PROTO((const char *, va_list));\n void error PVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n@@ -4723,8 +4722,7 @@ when it is equipped with such a conditional.\\n\");\n     \n     /* Actually process the file */\n     if (pcfbuf) {\n-      pcfname = xmalloc (strlen (pcftry) + 1);\n-      strcpy (pcfname, pcftry);\n+      pcfname = xstrdup (pcftry);\n       pcfinclude ((U_CHAR *) pcfbuf, (U_CHAR *) fname, op);\n     }\n     else\n@@ -9230,38 +9228,6 @@ change_newlines (start, length)\n   return obp - start;\n }\n \f\n-/* my_strerror - return the descriptive text associated with an\n-   `errno' code.  */\n-\n-static char *\n-my_strerror (errnum)\n-     int errnum;\n-{\n-  char *result;\n-\n-#ifndef VMS\n-#ifndef HAVE_STRERROR\n-  result = (char *) ((errnum < sys_nerr) ? sys_errlist[errnum] : 0);\n-#else\n-  result = strerror (errnum);\n-#endif\n-#else\t/* VMS */\n-  /* VAXCRTL's strerror() takes an optional second argument, which only\n-     matters when the first argument is EVMSERR.  However, it's simplest\n-     just to pass it unconditionally.  `vaxc$errno' is declared in\n-     <errno.h>, and maintained by the library in parallel with `errno'.\n-     We assume that caller's `errnum' either matches the last setting of\n-     `errno' by the library or else does not have the value `EVMSERR'.  */\n-\n-  result = strerror (errnum, vaxc$errno);\n-#endif\n-\n-  if (!result)\n-    result = \"errno = ?\";\n-\n-  return result;\n-}\n-\n /* notice - output message to stderr */\n \n static void\n@@ -9358,7 +9324,7 @@ error_from_errno (name)\n     fprintf (stderr, \":%d: \", ip->lineno);\n   }\n \n-  fprintf (stderr, \"%s: %s\\n\", name, my_strerror (e));\n+  fprintf (stderr, \"%s: %s\\n\", name, xstrerror (e));\n \n   errors++;\n }\n@@ -9716,8 +9682,7 @@ grow_outbuf (obuf, needed)\n   if (minsize > obuf->length)\n     obuf->length = minsize;\n \n-  if ((p = (U_CHAR *) xrealloc (obuf->buf, obuf->length)) == NULL)\n-    memory_full ();\n+  p = (U_CHAR *) xrealloc (obuf->buf, obuf->length);\n \n   obuf->bufp = p + (obuf->bufp - obuf->buf);\n   obuf->buf = p;\n@@ -10638,7 +10603,7 @@ static void\n perror_with_name (name)\n      char *name;\n {\n-  fprintf (stderr, \"%s: %s: %s\\n\", progname, name, my_strerror (errno));\n+  fprintf (stderr, \"%s: %s: %s\\n\", progname, name, xstrerror (errno));\n   errors++;\n }\n \n@@ -10669,53 +10634,6 @@ memory_full ()\n {\n   fatal (\"Memory exhausted.\");\n }\n-\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR ptr = (PTR) malloc (size);\n-  if (!ptr)\n-    memory_full ();\n-  return ptr;\n-}\n-\n-PTR\n-xrealloc (old, size)\n-  PTR old;\n-  size_t size;\n-{\n-  register PTR ptr;\n-  if (old)\n-    ptr = (PTR) realloc (old, size);\n-  else\n-    ptr = (PTR) malloc (size);\n-  if (!ptr)\n-    memory_full ();\n-  return ptr;\n-}\n-\n-PTR\n-xcalloc (number, size)\n-  size_t number, size;\n-{\n-  register size_t total = number * size;\n-  register PTR ptr = (PTR) malloc (total);\n-  if (!ptr)\n-    memory_full ();\n-  bzero (ptr, total);\n-  return ptr;\n-}\n-\n-char *\n-xstrdup (input)\n-  const char *input;\n-{\n-  register size_t len = strlen (input) + 1;\n-  register char *output = xmalloc (len);\n-  memcpy (output, input, len);\n-  return output;\n-}\n \f\n #ifdef VMS\n "}, {"sha": "4e61a0d9b5138a0169e4fcb54cf323a51a709b17", "filename": "gcc/collect2.c", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -261,7 +261,6 @@ static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n static const char *libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n #endif\n \n-static const char *my_strsignal\tPROTO((int));\n static void handler\t\tPROTO((int));\n static int is_ctor_dtor\t\tPROTO((const char *));\n static char *find_a_file\tPROTO((struct path_prefix *, const char *));\n@@ -321,29 +320,6 @@ dup2 (oldfd, newfd)\n   return fd;\n }\n #endif\n-\n-static const char *\n-my_strsignal (s)\n-     int s;\n-{\n-#ifdef HAVE_STRSIGNAL\n-  return strsignal (s);\n-#else\n-  if (s >= 0 && s < NSIG)\n-    {\n-# ifdef NO_SYS_SIGLIST\n-      static char buffer[30];\n-\n-      sprintf (buffer, \"Unknown signal %d\", s);\n-      return buffer;\n-# else\n-      return sys_siglist[s];\n-# endif\n-    }\n-  else\n-    return NULL;\n-#endif /* HAVE_STRSIGNAL */\n-}\n \f\n /* Delete tempfiles and exit function.  */\n \n@@ -1577,7 +1553,7 @@ collect_wait (prog)\n \t\t  : \"%s terminated with signal %d [%s], core dumped\"),\n \t\t prog,\n \t\t sig,\n-\t\t my_strsignal(sig));\n+\t\t strsignal(sig));\n \t  collect_exit (FATAL_EXIT_CODE);\n \t}\n \n@@ -2418,8 +2394,7 @@ locatelib (name)\n \t    if (*ld_rules == ':')\n \t      cnt++;\n \t  ld_rules = (char *) (ld_2->ld_rules + code);\n-\t  ldr = (char *) xmalloc (strlen (ld_rules) + 1);\n-\t  strcpy (ldr, ld_rules);\n+\t  ldr = xstrdup (ld_rules);\n \t}\n       p = getenv (\"LD_LIBRARY_PATH\");\n       q = 0;\n@@ -2429,8 +2404,7 @@ locatelib (name)\n \t  for (q = p ; *q != 0; q++)\n \t    if (*q == ':')\n \t      cnt++;\n-\t  q = (char *) xmalloc (strlen (p) + 1);\n-\t  strcpy (q, p);\n+\t  q = xstrdup (p);\n \t}\n       l = (const char **) xmalloc ((cnt + 3) * sizeof (char *));\n       pp = l;"}, {"sha": "9ef503093567c83fe858ed669be77129ac823e98", "filename": "gcc/config/1750a/1750a.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2F1750a%2F1750a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2F1750a%2F1750a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.h?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -1116,7 +1116,7 @@ enum reg_class { NO_REGS, R2, R0_1, INDEX_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLA\n \tdo {\t\t\t\t\t\t\t\\\n \t  if (strcmp(PREFIX,\"LC\") == 0) {\t\t\t\\\n \t     label_pending = 1;\t\t\t\t\t\\\n-\t     datalbl[++datalbl_ndx].name = (char *) malloc (9); \\\n+\t     datalbl[++datalbl_ndx].name = (char *) xmalloc (9);\\\n \t     sprintf(datalbl[datalbl_ndx].name,\"LC%d\",NUM);\t\\\n \t     datalbl[datalbl_ndx].size = 0;\t\t\t\\\n \t     check_section(Konst);\t\t\t\t\\"}, {"sha": "b1a1a1c7b29f021873e43ef3d806c299612bacb1", "filename": "gcc/config/dsp16xx/dsp16xx.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -1505,8 +1505,7 @@ override_options ()\n   if (const_seg_name == (char *) 0)\n     const_seg_name = DEFAULT_CONST_SEG_NAME;\n   \n-  save_chip_name = (char *) xmalloc (strlen(chip_name) + 1);\n-  strcpy (save_chip_name, chip_name);\n+  save_chip_name = xstrdup (chip_name);\n \n   rsect_text = (char *) xmalloc (strlen(\".rsect \") + \n \t\t\t\t strlen(text_seg_name) + 3);"}, {"sha": "dcacc4202beac8b936ac717bba44501e66821bed", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -1569,12 +1569,7 @@ enum reg_class\n   if (!mvs_function_name)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       mvs_function_name_length = strlen (NAME) * 2;\t\t\t\\\n-      mvs_function_name = (char *) malloc (mvs_function_name_length);\t\\\n-      if (mvs_function_name == 0)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  fatal (\"virtual memory exceeded\");\t\t\t\t\\\n-\t  abort ();\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n+      mvs_function_name = (char *) xmalloc (mvs_function_name_length);\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n     strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\"}, {"sha": "a090a2e758e813f6effd93041d2e782edf505831", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -7973,8 +7973,7 @@ build_mips16_call_stub (retval, fnmem, arg_size, fp_code)\n \n       /* Record this stub.  */\n       l = (struct mips16_stub *) xmalloc (sizeof *l);\n-      l->name = (char *) xmalloc (strlen (fnname) + 1);\n-      strcpy (l->name, fnname);\n+      l->name = xstrdup (fnname);\n       l->fpret = fpret;\n       l->next = mips16_stubs;\n       mips16_stubs = l;"}, {"sha": "f0088e371805fa0cb96a40d3a8b3ac49c1f3ee63", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -525,8 +525,8 @@ cpp_options_init (opts)\n   opts->cplusplus_comments = 1;\n   opts->warn_import = 1;\n \n-  opts->pending = (struct cpp_pending *) xmalloc (sizeof (struct cpp_pending));\n-  bzero ((char *) opts->pending, sizeof (struct cpp_pending));\n+  opts->pending =\n+    (struct cpp_pending *) xcalloc (1, sizeof (struct cpp_pending));\n }\n \n /* Initialize a cpp_reader structure. */"}, {"sha": "90c15024217f1152560c65bbff61f805742e6f03", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -5814,18 +5814,12 @@ dwarfout_init (asm_out_file, main_input_filename)\n \t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, SFNAMES_SECTION);\n \t  ASM_OUTPUT_LABEL (asm_out_file, SFNAMES_BEGIN_LABEL);\n \t  {\n-\t    register char *pwd;\n-\t    register unsigned len;\n+\t    register char *pwd = getpwd ();\n \t    register char *dirname;\n \n-\t    pwd = getpwd ();\n \t    if (!pwd)\n \t      pfatal_with_name (\"getpwd\");\n-\t    len = strlen (pwd);\n-\t    dirname = (char *) xmalloc (len + 2);\n-    \n-\t    strcpy (dirname, pwd);\n-\t    strcpy (dirname + len, \"/\");\n+\t    dirname = concat (pwd, \"/\", NULL);\n \t    ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, dirname);\n \t    free (dirname);\n \t  }"}, {"sha": "aa9f19a00405942205210b7576dbf6775764912e", "filename": "gcc/except.c", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -711,14 +711,14 @@ new_eh_region_entry (note_eh_region, rethrow)\n       if (num_func_eh_entries == 0)\n         {\n           function_eh_regions = \n-                        (struct func_eh_entry *) malloc (SIZE_FUNC_EH (50));\n+                        (struct func_eh_entry *) xmalloc (SIZE_FUNC_EH (50));\n           num_func_eh_entries = 50;\n         }\n       else\n         {\n           num_func_eh_entries  = num_func_eh_entries * 3 / 2;\n           function_eh_regions = (struct func_eh_entry *) \n-            realloc (function_eh_regions, SIZE_FUNC_EH (num_func_eh_entries));\n+            xrealloc (function_eh_regions, SIZE_FUNC_EH (num_func_eh_entries));\n         }\n     }\n   function_eh_regions[current_func_eh_entry].range_number = note_eh_region;\n@@ -812,10 +812,7 @@ find_all_handler_type_matches (array)\n     return 0;\n \n   max_ptr = 100;\n-  ptr = (void **)malloc (max_ptr * sizeof (void *));\n-\n-  if (ptr == NULL)\n-    return 0;\n+  ptr = (void **) xmalloc (max_ptr * sizeof (void *));\n \n   for (x = 0 ; x < current_func_eh_entry; x++)\n     {\n@@ -839,9 +836,7 @@ find_all_handler_type_matches (array)\n               if (n_ptr >= max_ptr) \n                 {\n                   max_ptr += max_ptr / 2;\n-                  ptr = (void **)realloc (ptr, max_ptr * sizeof (void *));\n-                  if (ptr == NULL)\n-                    return 0;\n+                  ptr = (void **) xrealloc (ptr, max_ptr * sizeof (void *));\n                 }\n               ptr[n_ptr] = val;\n               n_ptr++;\n@@ -861,7 +856,7 @@ get_new_handler (handler, typeinfo)\n      void *typeinfo;\n {\n   struct handler_info* ptr;\n-  ptr = (struct handler_info *) malloc (sizeof (struct handler_info));\n+  ptr = (struct handler_info *) xmalloc (sizeof (struct handler_info));\n   ptr->handler_label = handler;\n   ptr->handler_number = CODE_LABEL_NUMBER (handler);\n   ptr->type_info = typeinfo;\n@@ -2952,7 +2947,7 @@ init_insn_eh_region (first, max_uid)\n         max_uid = INSN_UID (insn);\n \n   maximum_uid = max_uid;\n-  insn_eh_region = (int *) malloc ((max_uid + 1) * sizeof (int));\n+  insn_eh_region = (int *) xmalloc ((max_uid + 1) * sizeof (int));\n   insn = first;\n   set_insn_eh_region (&insn, 0);\n }\n@@ -3033,7 +3028,7 @@ process_nestinfo (block, info, nested_eh_region)\n     extra = 0;\n \n   info->num_handlers[index] = count + extra;\n-  info->handlers[index] = (handler_info **) malloc ((count + extra) \n+  info->handlers[index] = (handler_info **) xmalloc ((count + extra) \n   \t\t\t\t\t\t    * sizeof (handler_info **));\n \n   /* First put all our handlers into the list.  */\n@@ -3081,9 +3076,8 @@ init_eh_nesting_info ()\n   rtx insn;\n   int x;\n \n-  info = (eh_nesting_info *) malloc (sizeof (eh_nesting_info));\n-  info->region_index = (int *) malloc ((max_label_num () + 1) * sizeof (int));\n-  bzero ((char *) info->region_index, (max_label_num () + 1) * sizeof (int));\n+  info = (eh_nesting_info *) xmalloc (sizeof (eh_nesting_info));\n+  info->region_index = (int *) xcalloc ((max_label_num () + 1), sizeof (int));\n \n   nested_eh_region = (int *) alloca ((max_label_num () + 1) * sizeof (int));\n   bzero ((char *) nested_eh_region, (max_label_num () + 1) * sizeof (int));\n@@ -3122,14 +3116,10 @@ init_eh_nesting_info ()\n     }\n \n   region_count++;\n-  info->handlers = (handler_info ***) malloc (region_count \n-\t\t\t\t\t      * sizeof (handler_info ***));\n-  info->num_handlers = (int *) malloc (region_count * sizeof (int));\n-  info->outer_index = (int *) malloc (region_count * sizeof (int));\n-\n-  bzero ((char *) info->handlers, region_count * sizeof (rtx *));\n-  bzero ((char *) info->num_handlers, region_count * sizeof (int));\n-  bzero ((char *) info->outer_index, region_count * sizeof (int));\n+  info->handlers = (handler_info ***) xcalloc (region_count,\n+\t\t\t\t\t       sizeof (handler_info ***));\n+  info->num_handlers = (int *) xcalloc (region_count, sizeof (int));\n+  info->outer_index = (int *) xcalloc (region_count, sizeof (int));\n \n  /* Now initialize the handler lists for all exception blocks.  */\n   for (x = 0; x <= max_label_num (); x++)"}, {"sha": "e85b8a9a5cab8c18a5f0b339bd252b3033be0ddd", "filename": "gcc/gcc.c", "status": "modified", "additions": 12, "deletions": 73, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -1056,26 +1056,6 @@ translate_options (argcp, argvp)\n   *argcp = newindex;\n }\n \f\n-char *\n-xstrerror(e)\n-     int e;\n-{\n-#ifdef HAVE_STRERROR\n-\n-  return strerror(e);\n-\n-#else\n-\n-  if (!e)\n-    return \"errno = 0\";\n-\n-  if (e > 0 && e < sys_nerr)\n-    return sys_errlist[e];\n-\n-  return \"errno = ?\";\n-#endif\n-}\n-\f\n static char *\n skip_whitespace (p)\n      char *p;\n@@ -1181,10 +1161,8 @@ init_spec ()\n \n #ifdef EXTRA_SPECS\n   extra_specs = (struct spec_list *)\n-    xmalloc (sizeof(struct spec_list) *\n+    xcalloc (sizeof(struct spec_list),\n \t     (sizeof(extra_specs_1)/sizeof(extra_specs_1[0])));\n-  bzero ((PTR) extra_specs, sizeof(struct spec_list) *\n-\t (sizeof(extra_specs_1)/sizeof(extra_specs_1[0])));\n   \n   for (i = (sizeof(extra_specs_1) / sizeof(extra_specs_1[0])) - 1; i >= 0; i--)\n     {\n@@ -1246,7 +1224,7 @@ set_spec (name, spec)\n     {\n       /* Not found - make it */\n       sl = (struct spec_list *) xmalloc (sizeof (struct spec_list));\n-      sl->name = save_string (name, strlen (name));\n+      sl->name = xstrdup (name);\n       sl->name_len = name_len;\n       sl->ptr_spec = &sl->ptr;\n       sl->alloc_p = 0;\n@@ -1258,7 +1236,7 @@ set_spec (name, spec)\n   old_spec = *(sl->ptr_spec);\n   *(sl->ptr_spec) = ((spec[0] == '+' && ISSPACE ((unsigned char)spec[1]))\n \t\t     ? concat (old_spec, spec + 1, NULL_PTR)\n-\t\t     : save_string (spec, strlen (spec)));\n+\t\t     : xstrdup (spec));\n \n #ifdef DEBUG_SPECS\n   if (verbose_flag)\n@@ -1740,9 +1718,7 @@ record_temp_file (filename, always_delete, fail_delete)\n      int always_delete;\n      int fail_delete;\n {\n-  register char *name;\n-  name = xmalloc (strlen (filename) + 1);\n-  strcpy (name, filename);\n+  register char * const name = xstrdup (filename);\n \n   if (always_delete)\n     {\n@@ -1993,23 +1969,13 @@ find_a_file (pprefix, name, mode)\n   int len = pprefix->max_len + strlen (name) + strlen (file_suffix) + 1;\n \n #ifdef DEFAULT_ASSEMBLER\n-  if (! strcmp(name, \"as\") && access (DEFAULT_ASSEMBLER, mode) == 0) {\n-    name = DEFAULT_ASSEMBLER;\n-    len = strlen(name)+1;\n-    temp = xmalloc (len);\n-    strcpy (temp, name);\n-    return temp;\n-  }\n+  if (! strcmp(name, \"as\") && access (DEFAULT_ASSEMBLER, mode) == 0)\n+    return xstrdup (DEFAULT_ASSEMBLER);\n #endif\n \n #ifdef DEFAULT_LINKER\n-  if (! strcmp(name, \"ld\") && access (DEFAULT_LINKER, mode) == 0) {\n-    name = DEFAULT_LINKER;\n-    len = strlen(name)+1;\n-    temp = xmalloc (len);\n-    strcpy (temp, name);\n-    return temp;\n-  }\n+  if (! strcmp(name, \"ld\") && access (DEFAULT_LINKER, mode) == 0)\n+    return xstrdup (DEFAULT_LINKER);\n #endif\n \n   if (machine_suffix)\n@@ -2610,8 +2576,8 @@ process_command (argc, argv)\n \n   /* Figure compiler version from version string.  */\n \n-  compiler_version = temp1 =\n-    save_string (version_string, strlen (version_string));\n+  compiler_version = temp1 = xstrdup (version_string); \n+\n   for (; *temp1; ++temp1)\n     {\n       if (*temp1 == ' ')\n@@ -5026,13 +4992,11 @@ main (argc, argv)\n \n   i = n_infiles;\n   i += lang_specific_extra_outfiles;\n-  outfiles = (const char **) xmalloc (i * sizeof (char *));\n-  bzero ((char *) outfiles, i * sizeof (char *));\n+  outfiles = (const char **) xcalloc (i, sizeof (char *));\n \n   /* Record which files were specified explicitly as link input.  */\n \n-  explicit_link_files = xmalloc (n_infiles);\n-  bzero (explicit_link_files, n_infiles);\n+  explicit_link_files = xcalloc (1, n_infiles);\n \n   for (i = 0; (int)i < n_infiles; i++)\n     {\n@@ -5257,31 +5221,6 @@ lookup_compiler (name, length, language)\n   return 0;\n }\n \f\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR value = (PTR) malloc (size);\n-  if (value == 0)\n-    fatal (\"virtual memory exhausted\");\n-  return value;\n-}\n-\n-PTR\n-xrealloc (old, size)\n-  PTR old;\n-  size_t size;\n-{\n-  register PTR ptr;\n-  if (old)\n-    ptr = (PTR) realloc (old, size);\n-  else\n-    ptr = (PTR) malloc (size);\n-  if (ptr == 0)\n-    fatal (\"virtual memory exhausted\");\n-  return ptr;\n-}\n-\n static char *\n save_string (s, len)\n   const char *s;"}, {"sha": "7aff80920000b4a00d6c7247f8088d8287076854", "filename": "gcc/gcov.c", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -267,19 +267,6 @@ fnotice VPROTO ((FILE *file, const char *msgid, ...))\n }\n \n \n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR value = (PTR) malloc (size);\n-  if (value == 0)\n-    {\n-      fnotice (stderr, \"error: virtual memory exhausted\");\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  return value;\n-}\n-\n /* More 'friendly' abort that prints the line and file.\n    config.h can #define abort fancy_abort if you like that sort of thing.  */\n \n@@ -508,10 +495,8 @@ create_program_flow_graph (bptr)\n   /* Read the number of blocks.  */\n   __read_long (&num_blocks, bbg_file, 4);\n \n-  /* Create an array of size bb number of bb_info structs.  Bzero it.  */\n-  bb_graph = (struct bb_info *) xmalloc (num_blocks\n-\t\t\t\t\t * sizeof (struct bb_info));\n-  bzero ((char *) bb_graph, sizeof (struct bb_info) * num_blocks);\n+  /* Create an array of size bb number of bb_info structs.  */\n+  bb_graph = (struct bb_info *) xcalloc (num_blocks, sizeof (struct bb_info));\n \n   bptr->bb_graph = bb_graph;\n   bptr->num_blocks = num_blocks;\n@@ -802,8 +787,7 @@ scan_for_source_files ()\n \t      /* No sourcefile structure for this file name exists, create\n \t\t a new one, and append it to the front of the sources list.  */\n \t      s_ptr = (struct sourcefile *) xmalloc (sizeof(struct sourcefile));\n-\t      s_ptr->name = xmalloc (strlen ((char *) ptr) + 1);\n-\t      strcpy (s_ptr->name, (char *) ptr);\n+\t      s_ptr->name = xstrdup (ptr);\n \t      s_ptr->maxlineno = 0;\n \t      s_ptr->next = sources;\n \t      sources = s_ptr;\n@@ -1019,17 +1003,11 @@ output_data ()\n       else\n \tsource_file_name = s_ptr->name;\n \n-      line_counts = (long *) xmalloc (sizeof (long) * s_ptr->maxlineno);\n-      bzero ((char *) line_counts, sizeof (long) * s_ptr->maxlineno);\n-      line_exists = xmalloc (s_ptr->maxlineno);\n-      bzero (line_exists, s_ptr->maxlineno);\n+      line_counts = (long *) xcalloc (sizeof (long), s_ptr->maxlineno);\n+      line_exists = xcalloc (1, s_ptr->maxlineno);\n       if (output_branch_probs)\n-\t{\n-\t  branch_probs = (struct arcdata **) xmalloc (sizeof (struct arcdata *)\n-\t\t\t\t\t\t      * s_ptr->maxlineno);\n-\t  bzero ((char *) branch_probs, \n-\t\t sizeof (struct arcdata *) * s_ptr->maxlineno);\n-\t}\n+\tbranch_probs = (struct arcdata **)\n+\t  xcalloc (sizeof (struct arcdata *), s_ptr->maxlineno);\n       \n       /* There will be a zero at the beginning of the bb info, before the\n \t first list of line numbers, so must initialize block_num to 0.  */"}, {"sha": "5aa69b69e1e86fc4b6a45db4da0d1c409993222a", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -7767,14 +7767,9 @@ schedule_insns (dump_file)\n \n   max_uid = (get_max_uid () + 1);\n \n-  cant_move = (char *) xmalloc (max_uid * sizeof (char));\n-  bzero ((char *) cant_move, max_uid * sizeof (char));\n-\n-  fed_by_spec_load = (char *) xmalloc (max_uid * sizeof (char));\n-  bzero ((char *) fed_by_spec_load, max_uid * sizeof (char));\n-\n-  is_load_insn = (char *) xmalloc (max_uid * sizeof (char));\n-  bzero ((char *) is_load_insn, max_uid * sizeof (char));\n+  cant_move = xcalloc (max_uid, sizeof (char));\n+  fed_by_spec_load = xcalloc (max_uid, sizeof (char));\n+  is_load_insn = xcalloc (max_uid, sizeof (char));\n \n   insn_orig_block = (int *) xmalloc (max_uid * sizeof (int));\n   insn_luid = (int *) xmalloc (max_uid * sizeof (int));\n@@ -7903,17 +7898,17 @@ schedule_insns (dump_file)\n      We use xmalloc instead of alloca, because max_uid can be very large\n      when there is a lot of function inlining.  If we used alloca, we could\n      exceed stack limits on some hosts for some inputs.  */\n-  insn_priority = (int *) xmalloc (max_uid * sizeof (int));\n-  insn_reg_weight = (int *) xmalloc (max_uid * sizeof (int));\n-  insn_tick = (int *) xmalloc (max_uid * sizeof (int));\n-  insn_costs = (short *) xmalloc (max_uid * sizeof (short));\n-  insn_units = (short *) xmalloc (max_uid * sizeof (short));\n-  insn_blockage = (unsigned int *) xmalloc (max_uid * sizeof (unsigned int));\n-  insn_ref_count = (int *) xmalloc (max_uid * sizeof (int));\n+  insn_priority = (int *) xcalloc (max_uid, sizeof (int));\n+  insn_reg_weight = (int *) xcalloc (max_uid, sizeof (int));\n+  insn_tick = (int *) xcalloc (max_uid, sizeof (int));\n+  insn_costs = (short *) xcalloc (max_uid, sizeof (short));\n+  insn_units = (short *) xcalloc (max_uid, sizeof (short));\n+  insn_blockage = (unsigned int *) xcalloc (max_uid, sizeof (unsigned int));\n+  insn_ref_count = (int *) xcalloc (max_uid, sizeof (int));\n \n   /* Allocate for forward dependencies.  */\n-  insn_dep_count = (int *) xmalloc (max_uid * sizeof (int));\n-  insn_depend = (rtx *) xmalloc (max_uid * sizeof (rtx));\n+  insn_dep_count = (int *) xcalloc (max_uid, sizeof (int));\n+  insn_depend = (rtx *) xcalloc (max_uid, sizeof (rtx));\n \n   if (reload_completed == 0)\n     {\n@@ -7941,8 +7936,7 @@ schedule_insns (dump_file)\n     {\n       rtx line;\n \n-      line_note = (rtx *) xmalloc (max_uid * sizeof (rtx));\n-      bzero ((char *) line_note, max_uid * sizeof (rtx));\n+      line_note = (rtx *) xcalloc (max_uid, sizeof (rtx));\n       line_note_head = (rtx *) alloca (n_basic_blocks * sizeof (rtx));\n       bzero ((char *) line_note_head, n_basic_blocks * sizeof (rtx));\n \n@@ -7961,18 +7955,6 @@ schedule_insns (dump_file)\n \t    }\n     }\n \n-  bzero ((char *) insn_priority, max_uid * sizeof (int));\n-  bzero ((char *) insn_reg_weight, max_uid * sizeof (int));\n-  bzero ((char *) insn_tick, max_uid * sizeof (int));\n-  bzero ((char *) insn_costs, max_uid * sizeof (short));\n-  bzero ((char *) insn_units, max_uid * sizeof (short));\n-  bzero ((char *) insn_blockage, max_uid * sizeof (unsigned int));\n-  bzero ((char *) insn_ref_count, max_uid * sizeof (int));\n-\n-  /* Initialize for forward dependencies.  */\n-  bzero ((char *) insn_depend, max_uid * sizeof (rtx));\n-  bzero ((char *) insn_dep_count, max_uid * sizeof (int));\n-\n   /* Find units used in this fuction, for visualization.  */\n   if (sched_verbose)\n     init_target_units ();"}, {"sha": "d51a2eef0ec5cafb7e2a43ce97ddedbcf351f177", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -65,19 +65,6 @@ fatal(s)\n   exit(FATAL_EXIT_CODE);\n }\n \n-/* Same as `malloc' but report error if no memory available.  */\n-/* Do this before size_t is fiddled with so it matches the prototype\n-   in libiberty.h . */\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR value = (PTR) malloc (size);\n-  if (value == 0)\n-    fatal (\"Virtual memory exhausted.\");\n-  return value;\n-}\n-\n /* Due to size_t being defined in sys/types.h and different\n    in stddef.h, we have to do this by hand.....  Note, these\n    types are correct for MIPS based systems, and may not be\n@@ -928,7 +915,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \tif (want_scope)\n \t  {\n \t    if (free_scope == (scope_t *) 0)\n-\t      scope_ptr = (scope_t *) malloc (sizeof (scope_t));\n+\t      scope_ptr = (scope_t *) xmalloc (sizeof (scope_t));\n \t    else\n \t      {\n \t\tscope_ptr = free_scope;\n@@ -982,7 +969,7 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \tif (want_scope)\n \t  {\n \t    if (free_scope == (scope_t *) 0)\n-\t      scope_ptr = (scope_t *) malloc (sizeof (scope_t));\n+\t      scope_ptr = (scope_t *) xmalloc (sizeof (scope_t));\n \t    else\n \t      {\n \t\tscope_ptr = free_scope;\n@@ -1434,14 +1421,7 @@ read_tfile __proto((void))\n \t\t\t\t    \"Auxiliary symbols\");\n \n   if (sym_hdr.iauxMax > 0)\n-    {\n-      aux_used = calloc (sym_hdr.iauxMax, 1);\n-      if (aux_used == (char *) 0)\n-\t{\n-\t  perror (\"calloc\");\n-\t  exit (1);\n-\t}\n-    }\n+    aux_used = xcalloc (sym_hdr.iauxMax, 1);\n \n   l_strings = (char *) read_seek ((PTR_T) 0,\n \t\t\t\t  sym_hdr.issMax,"}, {"sha": "649d11fee9cc6c5831d3ee6ba8f3de0f910439ac", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 6, "deletions": 117, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -636,7 +636,6 @@ extern void\tpfatal_with_name\n \t\t\t\t__proto((const char *));\n extern void\tfancy_abort\t__proto((void));\n        void\tbotch\t\t__proto((const char *));\n-extern void\txfree\t\t__proto((PTR));\n \n extern void\tfatal\t\tPVPROTO((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n extern void\terror\t\tPVPROTO((const char *format, ...)) ATTRIBUTE_PRINTF_1;\n@@ -1693,7 +1692,6 @@ STATIC void\t  free_thead\t\t__proto((thead_t *));\n \n STATIC char\t *local_index\t\t__proto((const char *, int));\n STATIC char\t *local_rindex\t\t__proto((const char *, int));\n-STATIC const char\t *my_strsignal\t\t__proto((int));\n \n extern char  *mktemp\t\t\t__proto((char *));\n extern long   strtol\t\t\t__proto((const char *, char **, int));\n@@ -5022,37 +5020,14 @@ main (argc, argv)\n }\n \n \f\n-STATIC const char *\n-my_strsignal (s)\n-     int s;\n-{\n-#ifdef HAVE_STRSIGNAL\n-  return strsignal (s);\n-#else\n-  if (s >= 0 && s < NSIG)\n-    {\n-# ifdef NO_SYS_SIGLIST\n-      static char buffer[30];\n-\n-      sprintf (buffer, \"Unknown signal %d\", s);\n-      return buffer;\n-# else\n-      return sys_siglist[s];\n-# endif\n-    }\n-  else\n-    return NULL;\n-#endif /* HAVE_STRSIGNAL */\n-}\n-\n /* Catch a signal and exit without dumping core.  */\n \n STATIC void\n catch_signal (signum)\n      int signum;\n {\n   (void) signal (signum, SIG_DFL);\t/* just in case...  */\n-  fatal (my_strsignal(signum));\n+  fatal (strsignal(signum));\n }\n \n /* Print a fatal error message.  NAME is the text.\n@@ -5111,10 +5086,7 @@ STATIC page_t *\n allocate_cluster (npages)\n      Size_t npages;\n {\n-  register page_t *value = (page_t *) calloc (npages, PAGE_USIZE);\n-\n-  if (value == 0)\n-    fatal (\"Virtual memory exhausted.\");\n+  register page_t *value = (page_t *) xcalloc (npages, PAGE_USIZE);\n \n   if (debug > 3)\n     fprintf (stderr, \"\\talloc\\tnpages = %d, value = 0x%.8x\\n\", npages, value);\n@@ -5297,7 +5269,7 @@ free_scope (ptr)\n   alloc_counts[ (int)alloc_type_scope ].free_list.f_scope = ptr;\n \n #else\n-  xfree ((PTR_T) ptr);\n+  free ((PTR_T) ptr);\n #endif\n \n }\n@@ -5454,7 +5426,7 @@ free_tag (ptr)\n   alloc_counts[ (int)alloc_type_tag ].free_list.f_tag = ptr;\n \n #else\n-  xfree ((PTR_T) ptr);\n+  free ((PTR_T) ptr);\n #endif\n \n }\n@@ -5512,7 +5484,7 @@ free_forward (ptr)\n   alloc_counts[ (int)alloc_type_forward ].free_list.f_forward = ptr;\n \n #else\n-  xfree ((PTR_T) ptr);\n+  free ((PTR_T) ptr);\n #endif\n \n }\n@@ -5570,7 +5542,7 @@ free_thead (ptr)\n   alloc_counts[ (int)alloc_type_thead ].free_list.f_thead = ptr;\n \n #else\n-  xfree ((PTR_T) ptr);\n+  free ((PTR_T) ptr);\n #endif\n \n }\n@@ -5661,89 +5633,6 @@ botch (s)\n   fatal (s);\n }\n \n-/* Same as `malloc' but report error if no memory available.  */\n-\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR value = (PTR) malloc (size);\n-  if (value == 0)\n-    fatal (\"Virtual memory exhausted.\");\n-\n-  if (debug > 3)\n-    {\n-      fputs (\"\\tmalloc\\tptr = \", stderr);\n-      fprintf (stderr, HOST_PTR_PRINTF, value);\n-      fprintf (stderr, \", size = %10lu\\n\", (unsigned long) size);\n-    }\n-\n-  return value;\n-}\n-\n-/* Same as `calloc' but report error if no memory available.  */\n-\n-PTR\n-xcalloc (size1, size2)\n-  size_t size1, size2;\n-{\n-  register PTR value = (PTR) calloc (size1, size2);\n-  if (value == 0)\n-    fatal (\"Virtual memory exhausted.\");\n-\n-  if (debug > 3)\n-    {\n-      fputs (\"\\tcalloc\\tptr = \", stderr);\n-      fprintf (stderr, HOST_PTR_PRINTF, value);\n-      fprintf (stderr, \", size1 = %10lu, size2 = %10lu [%lu]\\n\",\n-\t       (unsigned long) size1, (unsigned long) size2,\n-\t       (unsigned long) size1*size2);\n-    }\n-\n-  return value;\n-}\n-\n-/* Same as `realloc' but report error if no memory available.  */\n-\n-PTR\n-xrealloc (ptr, size)\n-  PTR ptr;\n-  size_t size;\n-{\n-  register PTR result;\n-  if (ptr)\n-    result = (PTR) realloc (ptr, size);\n-  else\n-    result = (PTR) malloc (size);\n-  if (!result)\n-    fatal (\"Virtual memory exhausted.\");\n-\n-  if (debug > 3)\n-    {\n-      fputs (\"\\trealloc\\tptr = \", stderr);\n-      fprintf (stderr, HOST_PTR_PRINTF, result);\n-      fprintf (stderr, \", size = %10lu, orig = \", size);\n-      fprintf (stderr, HOST_PTR_PRINTF, ptr);\n-      fputs (\"\\n\", stderr);\n-    }\n-\n-  return result;\n-}\n-\n-void\n-xfree (ptr)\n-     PTR ptr;\n-{\n-  if (debug > 3)\n-    {\n-      fputs (\"\\tfree\\tptr = \", stderr);\n-      fprintf (stderr, HOST_PTR_PRINTF, ptr);\n-      fputs (\"\\n\", stderr);\n-    }\n-\n-  free (ptr);\n-}\n-\n \f\n /* Define our own index/rindex, since the local and global symbol\n    structures as defined by MIPS has an 'index' field.  */"}, {"sha": "9ea38ba48387b19cb846c5a2ce740a66db55e2e0", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -630,13 +630,11 @@ lang_init ()\n   /* If gen_declaration desired, open the output file.  */\n   if (flag_gen_declaration)\n     {\n-      int dump_base_name_length = strlen (dump_base_name);\n-      register char *dumpname = (char *) xmalloc (dump_base_name_length + 7);\n-      strcpy (dumpname, dump_base_name);\n-      strcat (dumpname, \".decl\");\n+      register char * const dumpname = concat (dumpname, \".decl\", NULL);\n       gen_declaration_file = fopen (dumpname, \"w\");\n       if (gen_declaration_file == 0)\n \tpfatal_with_name (dumpname);\n+      free (dumpname);\n     }\n \n   if (flag_next_runtime)"}, {"sha": "c659c28e7be0b57d89d4cd6cf66478af8716ae8f", "filename": "gcc/prefix.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -282,7 +282,7 @@ translate_name (name)\n   /* Remove any trailing directory separator from what we got.  */\n   if (IS_DIR_SEPARATOR (prefix[strlen (prefix) - 1]))\n     {\n-      char * temp = save_string (prefix, strlen (prefix));\n+      char * temp = xstrdup (prefix);\n       temp[strlen (temp) - 1] = 0;\n       prefix = temp;\n     }\n@@ -312,28 +312,24 @@ update_path (path, key)\n   /* Convert DIR_SEPARATOR_2 to DIR_SEPARATOR. */\n   if (DIR_SEPARATOR != DIR_SEPARATOR_2)\n     {\n-      int i;\n-      int len = strlen (path);\n-      char *new_path = save_string (path, len);\n-      for (i = 0; i < len; i++)\n-        if (new_path[i] == DIR_SEPARATOR_2)\n-          new_path[i] = DIR_SEPARATOR;\n+      char *new_path = xstrdup (path);\n       path = new_path;\n+      do {\n+\tif (*new_path == DIR_SEPARATOR_2)\n+\t  *new_path = DIR_SEPARATOR;\n+      } while (*new_path++);\n     }\n #endif\n       \n #if defined (DIR_SEPARATOR) && !defined (DIR_SEPARATOR_2)\n   if (DIR_SEPARATOR != '/')\n     {\n-      int i;\n-      int len = strlen (path);\n-      char *new_path = save_string (path, len);\n-\n-      for (i = 0; i < len; i++)\n-        if (new_path[i] == '/')\n-          new_path[i] = DIR_SEPARATOR;\n-\n+      char *new_path = xstrdup (path);\n       path = new_path;\n+      do {\n+\tif (*new_path == '/')\n+\t  *new_path = DIR_SEPARATOR;\n+      } while (*newpath++);\n     }\n #endif\n "}, {"sha": "6a473dbfed8522ef44529a5faf222fad59832fa4", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -563,9 +563,7 @@ branch_prob (f, dump_file)\n \t\t      {\n \t\t\tif (last_bb_file_name)\n \t\t\t  free (last_bb_file_name);\n-\t\t\tlast_bb_file_name\n-\t\t\t  = xmalloc (strlen (NOTE_SOURCE_FILE (insn)) + 1);\n-\t\t\tstrcpy (last_bb_file_name, NOTE_SOURCE_FILE (insn));\n+\t\t\tlast_bb_file_name = xstrdup (NOTE_SOURCE_FILE (insn));\n \t\t\toutput_gcov_string (NOTE_SOURCE_FILE (insn), (long)-1);\n \t\t      }\n "}, {"sha": "1c187fc2f1cf0f96033889acdb1e7ac9c5af5054", "filename": "gcc/protoize.c", "status": "modified", "additions": 9, "deletions": 94, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -600,73 +600,6 @@ notice VPARAMS ((const char *msgid, ...))\n }\n \n \f\n-char *\n-xstrerror(e)\n-     int e;\n-{\n-\n-#ifdef HAVE_STRERROR\n-  return strerror(e);\n-\n-#else\n-  if (!e)\n-    return \"\";\n-\n-  if (e > 0 && e < sys_nerr)\n-    return sys_errlist[e];\n-\n-  return \"errno = ?\";\n-#endif\n-}\n-\f\n-/* Allocate some space, but check that the allocation was successful.  */\n-/* alloca.c uses this, so don't make it static.  */\n-\n-pointer_type\n-xmalloc (byte_count)\n-     size_t byte_count;\n-{\n-  register pointer_type rv = (pointer_type) malloc (byte_count);\n-  if (rv == NULL)\n-    {\n-      notice (\"\\n%s: virtual memory exceeded\\n\", pname);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  return rv;\n-}\n-\n-/* Reallocate some space, but check that the reallocation was successful.  */\n-\n-pointer_type\n-xrealloc (old_space, byte_count)\n-     pointer_type old_space;\n-     size_t byte_count;\n-{\n-  register pointer_type rv;\n-  if (old_space)\n-    rv = (pointer_type) realloc (old_space, byte_count);\n-  else\n-    rv = (pointer_type) malloc (byte_count);\n-  if (rv == NULL)\n-    {\n-      notice (\"\\n%s: virtual memory exceeded\\n\", pname);\n-      exit (FATAL_EXIT_CODE);\n-    }\n-  return rv;\n-}\n-\n-/* Deallocate the area pointed to by an arbitrary pointer, but first, strip\n-   the `const' qualifier from it and also make sure that the pointer value\n-   is non-null.  */\n-\n-void\n-xfree (p)\n-     const_pointer_type p;\n-{\n-  if (p)\n-    free ((NONCONST pointer_type) p);\n-}\n-\n /* Make a copy of a string INPUT with size SIZE.  */\n \n static char *\n@@ -679,21 +612,6 @@ savestring (input, size)\n   return output;\n }\n \n-/* Make a copy of the concatenation of INPUT1 and INPUT2.  */\n-\n-static char *\n-savestring2 (input1, size1, input2, size2)\n-     const char *input1;\n-     unsigned int size1;\n-     const char *input2;\n-     unsigned int size2;\n-{\n-  char *output = (char *) xmalloc (size1 + size2 + 1);\n-  strcpy (output, input1);\n-  strcpy (&output[size1], input2);\n-  return output;\n-}\n-\n /* More 'friendly' abort that prints the line and file.\n    config.h can #define abort fancy_abort if you like that sort of thing.  */\n \n@@ -1109,7 +1027,7 @@ add_symbol (p, s)\n      const char *s;\n {\n   p->hash_next = NULL;\n-  p->symbol = savestring (s, strlen (s));\n+  p->symbol = xstrdup (s);\n   p->ddip = NULL;\n   p->fip = NULL;\n   return p;\n@@ -1157,7 +1075,7 @@ static void\n free_def_dec (p)\n      def_dec_info *p;\n {\n-  xfree (p->ansi_decl);\n+  free ((NONCONST pointer_type) p->ansi_decl);\n \n #ifndef UNPROTOIZE\n   {\n@@ -1167,12 +1085,12 @@ free_def_dec (p)\n     for (curr = p->f_list_chain; curr; curr = next)\n       {\n         next = curr->chain_next;\n-        xfree (curr);\n+        free ((NONCONST pointer_type) curr);\n       }\n   }\n #endif /* !defined (UNPROTOIZE) */\n \n-  xfree (p);\n+  free (p);\n }\n \n /* Unexpand as many macro symbol as we can find.\n@@ -2072,12 +1990,9 @@ gen_aux_info_file (base_filename)\n   /* Store the full source file name in the argument vector.  */\n   compile_params[input_file_name_index] = shortpath (NULL, base_filename);\n   /* Add .X to source file name to get aux-info file name.  */\n-  compile_params[aux_info_file_name_index]\n-    = savestring2 (compile_params[input_file_name_index],\n-\t           strlen (compile_params[input_file_name_index]),\n-\t\t   \".X\",\n-\t\t   2);\n-\n+  compile_params[aux_info_file_name_index] =\n+    concat (compile_params[input_file_name_index], \".X\", NULL);\n+  \n   if (!quiet_flag)\n     notice (\"%s: compiling `%s'\\n\",\n \t    pname, compile_params[input_file_name_index]);\n@@ -2382,7 +2297,7 @@ start_over: ;\n             if (referenced_file_is_newer (aux_info_p, aux_info_mtime))\n               {\n                 free (aux_info_base);\n-\t\txfree (aux_info_relocated_name);\n+\t\tfree (aux_info_relocated_name);\n                 if (keep_it && my_unlink (aux_info_filename) == -1)\n                   {\n \t\t    int errno_val = errno;\n@@ -2431,7 +2346,7 @@ start_over: ;\n   }\n \n   free (aux_info_base);\n-  xfree (aux_info_relocated_name);\n+  free (aux_info_relocated_name);\n }\n \f\n #ifndef UNPROTOIZE"}, {"sha": "a03e810694892e937b829859b184496327ea1dfb", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -655,27 +655,20 @@ reload (first, global, dumpfile)\n      Record memory equivalents in reg_mem_equiv so they can\n      be substituted eventually by altering the REG-rtx's.  */\n \n-  reg_equiv_constant = (rtx *) xmalloc (max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_constant, max_regno * sizeof (rtx));\n-  reg_equiv_memory_loc = (rtx *) xmalloc (max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_memory_loc, max_regno * sizeof (rtx));\n-  reg_equiv_mem = (rtx *) xmalloc (max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_mem, max_regno * sizeof (rtx));\n-  reg_equiv_init = (rtx *) xmalloc (max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_init, max_regno * sizeof (rtx));\n-  reg_equiv_address = (rtx *) xmalloc (max_regno * sizeof (rtx));\n-  bzero ((char *) reg_equiv_address, max_regno * sizeof (rtx));\n-  reg_max_ref_width = (int *) xmalloc (max_regno * sizeof (int));\n-  bzero ((char *) reg_max_ref_width, max_regno * sizeof (int));\n-  reg_old_renumber = (short *) xmalloc (max_regno * sizeof (short));\n+  reg_equiv_constant = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_mem = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_init = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_equiv_address = (rtx *) xcalloc (max_regno, sizeof (rtx));\n+  reg_max_ref_width = (int *) xcalloc (max_regno, sizeof (int));\n+  reg_old_renumber = (short *) xcalloc (max_regno, sizeof (short));\n   bcopy ((PTR) reg_renumber, (PTR) reg_old_renumber, max_regno * sizeof (short));\n   pseudo_forbidden_regs\n     = (HARD_REG_SET *) xmalloc (max_regno * sizeof (HARD_REG_SET));\n   pseudo_previous_regs\n-    = (HARD_REG_SET *) xmalloc (max_regno * sizeof (HARD_REG_SET));\n+    = (HARD_REG_SET *) xcalloc (max_regno, sizeof (HARD_REG_SET));\n \n   CLEAR_HARD_REG_SET (bad_spill_regs_global);\n-  bzero ((char *) pseudo_previous_regs, max_regno * sizeof (HARD_REG_SET));\n \n   /* Look for REG_EQUIV notes; record what each pseudo is equivalent to.\n      Also find all paradoxical subregs and find largest such for each pseudo.\n@@ -3731,12 +3724,8 @@ init_elim_table ()\n #endif\n \n   if (!reg_eliminate)\n-    {\n-      reg_eliminate = (struct elim_table *)\n-\txmalloc(sizeof(struct elim_table) * NUM_ELIMINABLE_REGS);\n-      bzero ((PTR) reg_eliminate,\n-\t     sizeof(struct elim_table) * NUM_ELIMINABLE_REGS);\n-    }\n+    reg_eliminate = (struct elim_table *)\n+      xcalloc(sizeof(struct elim_table), NUM_ELIMINABLE_REGS);\n \n   /* Does this function require a frame pointer?  */\n "}, {"sha": "4761515fc5aad23ba8e7cf330c3d91a279552fa5", "filename": "gcc/resource.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -1167,14 +1167,9 @@ init_resource_info (epilogue_insn)\n     mark_set_resources (epilogue_insn, &end_of_function_needs, 0, 1);\n \n   /* Allocate and initialize the tables used by mark_target_live_regs.  */\n-  target_hash_table\n-    = (struct target_info **) xmalloc ((TARGET_HASH_PRIME\n-\t\t\t\t       * sizeof (struct target_info *)));\n-  bzero ((char *) target_hash_table,\n-\t TARGET_HASH_PRIME * sizeof (struct target_info *));\n-\n-  bb_ticks = (int *) xmalloc (n_basic_blocks * sizeof (int));\n-  bzero ((char *) bb_ticks, n_basic_blocks * sizeof (int));\n+  target_hash_table = (struct target_info **)\n+    xcalloc (TARGET_HASH_PRIME, sizeof (struct target_info *));\n+  bb_ticks = (int *) xcalloc (n_basic_blocks, sizeof (int));\n }\n \f\n /* Free up the resources allcated to mark_target_live_regs ().  This"}, {"sha": "41ddcc8e22f04574f96726cff8c044f0582110ef", "filename": "gcc/stupid.c", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -220,36 +220,22 @@ stupid_life_analysis (f, nregs, file)\n \n   /* Allocate tables to record info about regs.  */\n \n-  reg_where_dead = (int *) xmalloc (nregs * sizeof (int));\n-  bzero ((char *) reg_where_dead, nregs * sizeof (int));\n-\n-  reg_where_born_exact = (int *) xmalloc (nregs * sizeof (int));\n-  bzero ((char *) reg_where_born_exact, nregs * sizeof (int));\n-\n-  reg_where_born_clobber = (int *) xmalloc (nregs * sizeof (int));\n-  bzero ((char *) reg_where_born_clobber, nregs * sizeof (int));\n-\n-  reg_where_dead_chain = (struct insn_chain **) xmalloc (nregs * sizeof (struct insn_chain *));\n-  bzero ((char *) reg_where_dead_chain, nregs * sizeof (struct insn_chain *));\n- \n-  reg_order = (int *) xmalloc (nregs * sizeof (int));\n-  bzero ((char *) reg_order, nregs * sizeof (int));\n-\n-  regs_change_size = (char *) xmalloc (nregs * sizeof (char));\n-  bzero ((char *) regs_change_size, nregs * sizeof (char));\n-\n-  regs_crosses_setjmp = (char *) xmalloc (nregs * sizeof (char));\n-  bzero ((char *) regs_crosses_setjmp, nregs * sizeof (char));\n+  reg_where_dead = (int *) xcalloc (nregs, sizeof (int));\n+  reg_where_born_exact = (int *) xcalloc (nregs, sizeof (int));\n+  reg_where_born_clobber = (int *) xcalloc (nregs, sizeof (int));\n+  reg_where_dead_chain = (struct insn_chain **)\n+    xcalloc (nregs, sizeof (struct insn_chain *));\n+  reg_order = (int *) xcalloc (nregs, sizeof (int));\n+  regs_change_size = (char *) xcalloc (nregs, sizeof (char));\n+  regs_crosses_setjmp = (char *) xcalloc (nregs, sizeof (char));\n \n   /* Allocate the reg_renumber array */\n   allocate_reg_info (max_regno, FALSE, TRUE);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     reg_renumber[i] = i;\n \n-  after_insn_hard_regs\n-    = (HARD_REG_SET *) xmalloc (max_suid * sizeof (HARD_REG_SET));\n-\n-  bzero ((char *) after_insn_hard_regs, max_suid * sizeof (HARD_REG_SET));\n+  after_insn_hard_regs =\n+    (HARD_REG_SET *) xcalloc (max_suid, sizeof (HARD_REG_SET));\n \n   /* Allocate and zero out many data structures\n      that will record the data from lifetime analysis.  */"}, {"sha": "89ed389168e2d42bc457994aba9131551d9c9ac3", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 84, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad85216ece38be37dacbbb3fa7bb7db69aa33a4b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ad85216ece38be37dacbbb3fa7bb7db69aa33a4b", "patch": "@@ -2280,76 +2280,6 @@ botch (s)\n {\n   abort ();\n }\n-\n-/* Same as `malloc' but report error if no memory available.  */\n-\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR value;\n-\n-  if (size == 0)\n-    size = 1;\n-\n-  value = (PTR) malloc (size);\n-  if (value == 0)\n-    fatal (\"virtual memory exhausted\");\n-  return value;\n-}\n-\n-/* Same as `calloc' but report error if no memory available.  */\n-\n-PTR\n-xcalloc (size1, size2)\n-  size_t size1, size2;\n-{\n-  register PTR value;\n-\n-  if (size1 == 0 || size2 == 0)\n-    size1 = size2 = 1;\n-\n-  value = (PTR) calloc (size1, size2);\n-  if (value == 0)\n-    fatal (\"virtual memory exhausted\");\n-  return value;\n-}\n-\n-\n-/* Same as `realloc' but report error if no memory available.  \n-   Also handle null PTR even if the vendor realloc gets it wrong.  */\n-\n-PTR\n-xrealloc (ptr, size)\n-  PTR ptr;\n-  size_t size;\n-{\n-  register PTR result;\n-\n-  if (size == 0)\n-    size = 1;\n-\n-  result = (ptr ? (PTR) realloc (ptr, size) : (PTR) malloc (size));\n-\n-  if (!result)\n-    fatal (\"virtual memory exhausted\");\n-\n-  return result;\n-}\n-\n-/* Same as `strdup' but report error if no memory available.  */\n-\n-char *\n-xstrdup (s)\n-  register const char *s;\n-{\n-  register char *result = (char *) malloc (strlen (s) + 1);\n-\n-  if (! result)\n-    fatal (\"virtual memory exhausted\");\n-  strcpy (result, s);\n-  return result;\n-}\n \f\n /* Return the logarithm of X, base 2, considering X unsigned,\n    if X is a power of 2.  Otherwise, returns -1.\n@@ -2596,14 +2526,11 @@ open_dump_file (suffix, function_name)\n   TIMEVAR\n     (dump_time,\n      {\n-       dumpname = (char *) xmalloc (strlen (dump_base_name) + strlen (suffix) + 1);\n+       dumpname = concat (dump_base_name, suffix, NULL);\n \n        if (rtl_dump_file != NULL)\n \t fclose (rtl_dump_file);\n   \n-       strcpy (dumpname, dump_base_name);\n-       strcat (dumpname, suffix);\n-       \n        rtl_dump_file = fopen (dumpname, \"a\");\n        \n        if (rtl_dump_file == NULL)\n@@ -2656,13 +2583,8 @@ static void\n clean_dump_file (suffix)\n   const char *suffix;\n {\n-  char *dumpname;\n+  char * const dumpname = concat (dump_base_name, suffix, NULL);\n \n-  dumpname = (char *) xmalloc (strlen (dump_base_name) + strlen (suffix) + 1);\n-\n-  strcpy (dumpname, dump_base_name);\n-  strcat (dumpname, suffix);\n-       \n   rtl_dump_file = fopen (dumpname, \"w\");\n \n   if (rtl_dump_file == NULL)\n@@ -3103,10 +3025,7 @@ compile_file (name)\n \t  strip_off_ending (dumpname, len);\n \t  strcat (dumpname, \".s\");\n \t  if (asm_file_name == 0)\n-\t    {\n-\t      asm_file_name = (char *) xmalloc (strlen (dumpname) + 1);\n-\t      strcpy (asm_file_name, dumpname);\n-\t    }\n+\t    asm_file_name = xstrdup (dumpname);\n \t  if (!strcmp (asm_file_name, \"-\"))\n \t    asm_out_file = stdout;\n \t  else"}]}