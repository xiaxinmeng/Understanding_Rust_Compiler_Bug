{"sha": "1160ec9a141faf1c4c0496c7412c8febeb623962", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE2MGVjOWExNDFmYWYxYzRjMDQ5NmM3NDEyYzhmZWJlYjYyMzk2Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-16T14:31:13Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-06-16T14:31:13Z"}, "message": "openmp: Initial part of OpenMP 5.0 non-rectangular loop support\n\nOpenMP 5.0 adds support for non-rectangular loop collapses, e.g.\ntriangular and more complex.\n\nThis patch deals just with the diagnostics so that they aren't rejected\nimmediately as before.  As the spec generally requires as before that the\niteration variable initializer and bound in the comparison as invariant\nvs. the outermost loop, and just add some exceptional forms that can violate\nthat, we need to avoid folding the expressions until we can detect them and\nin order to avoid folding it later on, I chose to use a TREE_VEC in those\nexpressions to hold the var_outer * expr1 + expr2 triplet, the patch adds\npretty-printing of that, gimplification etc. and just sorry_at during\nomp expansion for now.\n\nThe next step will be to implement the different cases of that one by one.\n\n2020-06-16  Jakub Jelinek  <jakub@redhat.com>\n\ngcc/\n\t* tree.h (OMP_FOR_NON_RECTANGULAR): Define.\n\t* gimplify.c (gimplify_omp_for): Diagnose schedule, ordered\n\tor dist_schedule clause on non-rectangular loops.  Handle\n\tgimplification of non-rectangular lb/b expressions.  When changing\n\titeration variable, adjust also non-rectangular lb/b expressions\n\treferencing that.\n\t* omp-general.h (struct omp_for_data_loop): Add m1, m2 and outer\n\tmembers.\n\t(struct omp_for_data): Add non_rect member.\n\t* omp-general.c (omp_extract_for_data): Handle non-rectangular\n\tloops.  Fill in non_rect, m1, m2 and outer.\n\t* omp-low.c (lower_omp_for): Handle non-rectangular lb/b expressions.\n\t* omp-expand.c (expand_omp_for): Emit sorry_at for unsupported\n\tnon-rectangular loop cases and assert for cases that can't be\n\tnon-rectangular.\n\t* tree-pretty-print.c (dump_mem_ref): Formatting fix.\n\t(dump_omp_loop_non_rect_expr): New function.\n\t(dump_generic_node): Handle non-rectangular OpenMP loops.\n\t* tree-pretty-print.h (dump_omp_loop_non_rect_expr): Declare.\n\t* gimple-pretty-print.c (dump_gimple_omp_for): Handle non-rectangular\n\tOpenMP loops.\ngcc/c-family/\n\t* c-common.h (c_omp_check_loop_iv_exprs): Add an int argument.\n\t* c-omp.c (struct c_omp_check_loop_iv_data): Add maybe_nonrect and\n\tidx members.\n\t(c_omp_is_loop_iterator): New function.\n\t(c_omp_check_loop_iv_r): Use it.  Add support for silent scanning\n\tif outer loop iterator is present.  Perform duplicate checking through\n\thash_set in the function rather than expecting caller to do that.\n\tPass NULL instead of d->ppset to walk_tree_1.\n\t(c_omp_check_nonrect_loop_iv): New function.\n\t(c_omp_check_loop_iv): Use it.  Fill in new members, allow\n\tnon-rectangular loop forms, diagnose multiple associated loops with\n\tthe same iterator.  Pass NULL instead of &pset to walk_tree_1.\n\t(c_omp_check_loop_iv_exprs): Likewise.\ngcc/c/\n\t* c-parser.c (c_parser_expr_no_commas): Save, clear and restore\n\tc_in_omp_for.\n\t(c_parser_omp_for_loop): Set c_in_omp_for around some calls to avoid\n\tpremature c_fully_fold.  Defer explicit c_fully_fold calls to after\n\tc_finish_omp_for.\n\t* c-tree.h (c_in_omp_for): Declare.\n\t* c-typeck.c (c_in_omp_for): Define.\n\t(build_modify_expr): Avoid c_fully_fold if c_in_omp_for.\n\t(digest_init): Likewise.\n\t(build_binary_op): Likewise.\ngcc/cp/\n\t* semantics.c (handle_omp_for_class_iterator): Adjust\n\tc_omp_check_loop_iv_exprs caller.\n\t(finish_omp_for): Likewise.  Don't call fold_build_cleanup_point_expr\n\tbefore calling c_finish_omp_for and c_omp_check_loop_iv, move it\n\tafter those calls.\n\t* pt.c (tsubst_omp_for_iterator): Handle non-rectangular loops.\ngcc/testsuite/\n\t* c-c++-common/gomp/loop-6.c: New test.\n\t* gcc.dg/gomp/loop-1.c: Don't expect diagnostics on valid\n\tnon-rectangular loops.\n\t* gcc.dg/gomp/loop-2.c: New test.\n\t* g++.dg/gomp/loop-1.C: Don't expect diagnostics on valid\n\tnon-rectangular loops.\n\t* g++.dg/gomp/loop-2.C: Likewise.\n\t* g++.dg/gomp/loop-5.C: New test.\n\t* g++.dg/gomp/loop-6.C: New test.", "tree": {"sha": "cccaae90eda1cbae323278675e2df1a186f32ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cccaae90eda1cbae323278675e2df1a186f32ac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1160ec9a141faf1c4c0496c7412c8febeb623962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1160ec9a141faf1c4c0496c7412c8febeb623962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1160ec9a141faf1c4c0496c7412c8febeb623962", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1160ec9a141faf1c4c0496c7412c8febeb623962/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fab46c5df7500f2ce640f98320d47a19d3de8a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab46c5df7500f2ce640f98320d47a19d3de8a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fab46c5df7500f2ce640f98320d47a19d3de8a2f"}], "stats": {"total": 1094, "additions": 948, "deletions": 146}, "files": [{"sha": "61627264e1ec273a25f2b3659c09087ea673c0a6", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -1196,7 +1196,7 @@ extern void c_finish_omp_taskyield (location_t);\n extern tree c_finish_omp_for (location_t, enum tree_code, tree, tree, tree,\n \t\t\t      tree, tree, tree, tree, bool);\n extern bool c_omp_check_loop_iv (tree, tree, walk_tree_lh);\n-extern bool c_omp_check_loop_iv_exprs (location_t, tree, tree, tree, tree,\n+extern bool c_omp_check_loop_iv_exprs (location_t, tree, int, tree, tree, tree,\n \t\t\t\t       walk_tree_lh);\n extern tree c_finish_oacc_wait (location_t, tree, tree);\n extern tree c_oacc_split_loop_clauses (tree, tree *, bool);"}, {"sha": "1ca2802c64ffbb0fa9fad487456e7f4b265099a5", "filename": "gcc/c-family/c-omp.c", "status": "modified", "additions": 297, "deletions": 43, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc-family%2Fc-omp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc-family%2Fc-omp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-omp.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"memmodel.h\"\n #include \"attribs.h\"\n #include \"gimplify.h\"\n+#include \"langhooks.h\"\n \n \n /* Complete a #pragma oacc wait construct.  LOC is the location of\n@@ -1041,13 +1042,37 @@ struct c_omp_check_loop_iv_data\n {\n   tree declv;\n   bool fail;\n+  bool maybe_nonrect;\n   location_t stmt_loc;\n   location_t expr_loc;\n   int kind;\n+  int idx;\n   walk_tree_lh lh;\n   hash_set<tree> *ppset;\n };\n \n+/* Return -1 if DECL is not a loop iterator in loop nest D, otherwise\n+   return the index of the loop in which it is an iterator.\n+   Return TREE_VEC_LENGTH (d->declv) if it is a C++ range for iterator.  */\n+\n+static int\n+c_omp_is_loop_iterator (tree decl, struct c_omp_check_loop_iv_data *d)\n+{\n+  for (int i = 0; i < TREE_VEC_LENGTH (d->declv); i++)\n+    if (decl == TREE_VEC_ELT (d->declv, i)\n+\t|| (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n+\t    && decl == TREE_PURPOSE (TREE_VEC_ELT (d->declv, i))))\n+      return i;\n+    else if (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n+\t     && TREE_CHAIN (TREE_VEC_ELT (d->declv, i))\n+\t     && (TREE_CODE (TREE_CHAIN (TREE_VEC_ELT (d->declv, i)))\n+\t\t == TREE_VEC)\n+\t     && decl == TREE_VEC_ELT (TREE_CHAIN (TREE_VEC_ELT (d->declv,\n+\t\t\t\t\t\t  i)), 2))\n+      return TREE_VEC_LENGTH (d->declv);\n+  return -1;\n+}\n+\n /* Helper function called via walk_tree, to diagnose uses\n    of associated loop IVs inside of lb, b and incr expressions\n    of OpenMP loops.  */\n@@ -1059,51 +1084,234 @@ c_omp_check_loop_iv_r (tree *tp, int *walk_subtrees, void *data)\n     = (struct c_omp_check_loop_iv_data *) data;\n   if (DECL_P (*tp))\n     {\n-      int i;\n-      for (i = 0; i < TREE_VEC_LENGTH (d->declv); i++)\n-\tif (*tp == TREE_VEC_ELT (d->declv, i)\n-\t    || (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n-\t\t&& *tp == TREE_PURPOSE (TREE_VEC_ELT (d->declv, i)))\n-\t    || (TREE_CODE (TREE_VEC_ELT (d->declv, i)) == TREE_LIST\n-\t\t&& TREE_CHAIN (TREE_VEC_ELT (d->declv, i))\n-\t\t&& (TREE_CODE (TREE_CHAIN (TREE_VEC_ELT (d->declv, i)))\n-\t\t    == TREE_VEC)\n-\t\t&& *tp == TREE_VEC_ELT (TREE_CHAIN (TREE_VEC_ELT (d->declv,\n-\t\t\t\t\t\t\t\t  i)), 2)))\n-\t  {\n-\t    location_t loc = d->expr_loc;\n-\t    if (loc == UNKNOWN_LOCATION)\n-\t      loc = d->stmt_loc;\n-\t    switch (d->kind)\n-\t      {\n-\t      case 0:\n-\t\terror_at (loc, \"initializer expression refers to \"\n-\t\t\t       \"iteration variable %qD\", *tp);\n-\t\tbreak;\n-\t      case 1:\n-\t\terror_at (loc, \"condition expression refers to \"\n-\t\t\t       \"iteration variable %qD\", *tp);\n-\t\tbreak;\n-\t      case 2:\n-\t\terror_at (loc, \"increment expression refers to \"\n-\t\t\t       \"iteration variable %qD\", *tp);\n-\t\tbreak;\n-\t      }\n-\t    d->fail = true;\n-\t  }\n+      int idx = c_omp_is_loop_iterator (*tp, d);\n+      if (idx == -1)\n+\treturn NULL_TREE;\n+\n+      if ((d->kind & 4) && idx < d->idx)\n+\t{\n+\t  d->maybe_nonrect = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (d->ppset->add (*tp))\n+\treturn NULL_TREE;\n+\n+      location_t loc = d->expr_loc;\n+      if (loc == UNKNOWN_LOCATION)\n+\tloc = d->stmt_loc;\n+\n+      switch (d->kind & 3)\n+\t{\n+\tcase 0:\n+\t  error_at (loc, \"initializer expression refers to \"\n+\t\t\t \"iteration variable %qD\", *tp);\n+\t  break;\n+\tcase 1:\n+\t  error_at (loc, \"condition expression refers to \"\n+\t\t\t \"iteration variable %qD\", *tp);\n+\t  break;\n+\tcase 2:\n+\t  error_at (loc, \"increment expression refers to \"\n+\t\t\t \"iteration variable %qD\", *tp);\n+\t  break;\n+\t}\n+      d->fail = true;\n     }\n+  else if (d->ppset->add (*tp))\n+    *walk_subtrees = 0;\n   /* Don't walk dtors added by C++ wrap_cleanups_r.  */\n   else if (TREE_CODE (*tp) == TRY_CATCH_EXPR\n \t   && TRY_CATCH_IS_CLEANUP (*tp))\n     {\n       *walk_subtrees = 0;\n       return walk_tree_1 (&TREE_OPERAND (*tp, 0), c_omp_check_loop_iv_r, data,\n-\t\t\t  d->ppset, d->lh);\n+\t\t\t  NULL, d->lh);\n     }\n \n   return NULL_TREE;\n }\n \n+/* Check the allowed expressions for non-rectangular loop nest lb and b\n+   expressions.  Return the outer var decl referenced in the expression.  */\n+\n+static tree\n+c_omp_check_nonrect_loop_iv (tree *tp, struct c_omp_check_loop_iv_data *d,\n+\t\t\t     walk_tree_lh lh)\n+{\n+  d->maybe_nonrect = false;\n+  if (d->fail)\n+    return NULL_TREE;\n+\n+  hash_set<tree> pset;\n+  hash_set<tree> *ppset = d->ppset;\n+  d->ppset = &pset;\n+\n+  tree t = *tp;\n+  if (TREE_CODE (t) == TREE_VEC\n+      && TREE_VEC_LENGTH (t) == 3\n+      && DECL_P (TREE_VEC_ELT (t, 0))\n+      && c_omp_is_loop_iterator (TREE_VEC_ELT (t, 0), d) >= 0)\n+    {\n+      d->kind &= 3;\n+      walk_tree_1 (&TREE_VEC_ELT (t, 1), c_omp_check_loop_iv_r, d, NULL, lh);\n+      walk_tree_1 (&TREE_VEC_ELT (t, 1), c_omp_check_loop_iv_r, d, NULL, lh);\n+      d->ppset = ppset;\n+      return d->fail ? NULL_TREE : TREE_VEC_ELT (t, 0);\n+    }\n+\n+  while (CONVERT_EXPR_P (t))\n+    t = TREE_OPERAND (t, 0);\n+\n+  tree a1 = t, a2 = integer_zero_node;\n+  bool neg_a1 = false, neg_a2 = false;\n+  switch (TREE_CODE (t))\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      a1 = TREE_OPERAND (t, 0);\n+      a2 = TREE_OPERAND (t, 1);\n+      while (CONVERT_EXPR_P (a1))\n+\ta1 = TREE_OPERAND (a1, 0);\n+      while (CONVERT_EXPR_P (a2))\n+\ta2 = TREE_OPERAND (a2, 0);\n+      if (DECL_P (a1) && c_omp_is_loop_iterator (a1, d) >= 0)\n+\t{\n+\t  a2 = TREE_OPERAND (t, 1);\n+\t  if (TREE_CODE (t) == MINUS_EXPR)\n+\t    neg_a2 = true;\n+\t  t = a1;\n+\t  break;\n+\t}\n+      if (DECL_P (a2) && c_omp_is_loop_iterator (a2, d) >= 0)\n+\t{\n+\t  a1 = TREE_OPERAND (t, 0);\n+\t  if (TREE_CODE (t) == MINUS_EXPR)\n+\t    neg_a1 = true;\n+\t  t = a2;\n+\t  a2 = a1;\n+\t  break;\n+\t}\n+      if (TREE_CODE (a1) == MULT_EXPR && TREE_CODE (a2) == MULT_EXPR)\n+\t{\n+\t  tree o1 = TREE_OPERAND (a1, 0);\n+\t  tree o2 = TREE_OPERAND (a1, 1);\n+\t  while (CONVERT_EXPR_P (o1))\n+\t    o1 = TREE_OPERAND (o1, 0);\n+\t  while (CONVERT_EXPR_P (o2))\n+\t    o2 = TREE_OPERAND (o2, 0);\n+\t  if ((DECL_P (o1) && c_omp_is_loop_iterator (o1, d) >= 0)\n+\t      || (DECL_P (o2) && c_omp_is_loop_iterator (o2, d) >= 0))\n+\t    {\n+\t      a2 = TREE_OPERAND (t, 1);\n+\t      if (TREE_CODE (t) == MINUS_EXPR)\n+\t\tneg_a2 = true;\n+\t      t = a1;\n+\t      break;\n+\t    }\n+\t}\n+      if (TREE_CODE (a2) == MULT_EXPR)\n+\t{\n+\t  a1 = TREE_OPERAND (t, 0);\n+\t  if (TREE_CODE (t) == MINUS_EXPR)\n+\t    neg_a1 = true;\n+\t  t = a2;\n+\t  a2 = a1;\n+\t  break;\n+\t}\n+      if (TREE_CODE (a1) == MULT_EXPR)\n+\t{\n+\t  a2 = TREE_OPERAND (t, 1);\n+\t  if (TREE_CODE (t) == MINUS_EXPR)\n+\t    neg_a2 = true;\n+\t  t = a1;\n+\t  break;\n+\t}\n+      a2 = integer_zero_node;\n+      break;\n+    default:\n+      break;\n+    }\n+\n+  a1 = integer_one_node;\n+  if (TREE_CODE (t) == MULT_EXPR)\n+    {\n+      tree o1 = TREE_OPERAND (t, 0);\n+      tree o2 = TREE_OPERAND (t, 1);\n+      while (CONVERT_EXPR_P (o1))\n+\to1 = TREE_OPERAND (o1, 0);\n+      while (CONVERT_EXPR_P (o2))\n+\to2 = TREE_OPERAND (o2, 0);\n+      if (DECL_P (o1) && c_omp_is_loop_iterator (o1, d) >= 0)\n+\t{\n+\t  a1 = TREE_OPERAND (t, 1);\n+\t  t = o1;\n+\t}\n+      else if (DECL_P (o2) && c_omp_is_loop_iterator (o2, d) >= 0)\n+\t{\n+\t  a1 = TREE_OPERAND (t, 0);\n+\t  t = o2;\n+\t}\n+    }\n+\n+  d->kind &= 3;\n+  tree ret = NULL_TREE;\n+  if (DECL_P (t) && c_omp_is_loop_iterator (t, d) >= 0)\n+    {\n+      location_t loc = d->expr_loc;\n+      if (loc == UNKNOWN_LOCATION)\n+\tloc = d->stmt_loc;\n+      if (!lang_hooks.types_compatible_p (TREE_TYPE (*tp), TREE_TYPE (t)))\n+\t{\n+\t  if (d->kind == 0)\n+\t    error_at (loc, \"outer iteration variable %qD used in initializer\"\n+\t\t\t   \" expression has type other than %qT\",\n+\t\t      t, TREE_TYPE (*tp));\n+\t  else\n+\t    error_at (loc, \"outer iteration variable %qD used in condition\"\n+\t\t\t   \" expression has type other than %qT\",\n+\t\t      t, TREE_TYPE (*tp));\n+\t  d->fail = true;\n+\t}\n+      else if (!INTEGRAL_TYPE_P (TREE_TYPE (a1)))\n+\t{\n+\t  error_at (loc, \"outer iteration variable %qD multiplier expression\"\n+\t\t\t \" %qE is not integral\", t, a1);\n+\t  d->fail = true;\n+\t}\n+      else if (!INTEGRAL_TYPE_P (TREE_TYPE (a2)))\n+\t{\n+\t  error_at (loc, \"outer iteration variable %qD addend expression\"\n+\t\t\t \" %qE is not integral\", t, a2);\n+\t  d->fail = true;\n+\t}\n+      else\n+\t{\n+\t  walk_tree_1 (&a1, c_omp_check_loop_iv_r, d, NULL, lh);\n+\t  walk_tree_1 (&a2, c_omp_check_loop_iv_r, d, NULL, lh);\n+        }\n+      if (!d->fail)\n+\t{\n+\t  a1 = fold_convert (TREE_TYPE (*tp), a1);\n+\t  a2 = fold_convert (TREE_TYPE (*tp), a2);\n+\t  if (neg_a1)\n+\t    a1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (a1), a1);\n+\t  if (neg_a2)\n+\t    a2 = fold_build1 (NEGATE_EXPR, TREE_TYPE (a2), a2);\n+\t  ret = t;\n+\t  *tp = make_tree_vec (3);\n+\t  TREE_VEC_ELT (*tp, 0) = t;\n+\t  TREE_VEC_ELT (*tp, 1) = a1;\n+\t  TREE_VEC_ELT (*tp, 2) = a2;\n+\t}\n+    }\n+  else\n+    walk_tree_1 (&t, c_omp_check_loop_iv_r, d, NULL, lh);\n+\n+  d->ppset = ppset;\n+  return ret;\n+}\n+\n /* Diagnose invalid references to loop iterators in lb, b and incr\n    expressions.  */\n \n@@ -1116,6 +1324,7 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n \n   data.declv = declv;\n   data.fail = false;\n+  data.maybe_nonrect = false;\n   data.stmt_loc = EXPR_LOCATION (stmt);\n   data.lh = lh;\n   data.ppset = &pset;\n@@ -1129,9 +1338,31 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n       gcc_assert (TREE_OPERAND (cond, 0) == decl);\n       tree incr = TREE_VEC_ELT (OMP_FOR_INCR (stmt), i);\n       data.expr_loc = EXPR_LOCATION (TREE_OPERAND (init, 1));\n-      data.kind = 0;\n+      tree vec_outer1 = NULL_TREE, vec_outer2 = NULL_TREE;\n+      int kind = 0;\n+      if (i > 0\n+\t  && (unsigned) c_omp_is_loop_iterator (decl, &data) < (unsigned) i)\n+\t{\n+\t  location_t loc = data.expr_loc;\n+\t  if (loc == UNKNOWN_LOCATION)\n+\t    loc = data.stmt_loc;\n+\t  error_at (loc, \"the same loop iteration variables %qD used in \"\n+\t\t\t \"multiple associated loops\", decl);\n+\t  data.fail = true;\n+\t}\n+      /* Handle non-rectangular loop nests.  */\n+      if (TREE_CODE (stmt) != OACC_LOOP\n+\t  && (TREE_CODE (TREE_OPERAND (init, 1)) == TREE_VEC\n+\t      || INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (init, 1))))\n+\t  && i > 0)\n+\tkind = 4;\n+      data.kind = kind;\n+      data.idx = i;\n       walk_tree_1 (&TREE_OPERAND (init, 1),\n-\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t   c_omp_check_loop_iv_r, &data, NULL, lh);\n+      if (data.maybe_nonrect)\n+\tvec_outer1 = c_omp_check_nonrect_loop_iv (&TREE_OPERAND (init, 1),\n+\t\t\t\t\t\t  &data, lh);\n       /* Don't warn for C++ random access iterators here, the\n \t expression then involves the subtraction and always refers\n \t to the original value.  The C++ FE needs to warn on those\n@@ -1141,10 +1372,24 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n \t      && decl == TREE_PURPOSE (TREE_VEC_ELT (declv, i))))\n \t{\n \t  data.expr_loc = EXPR_LOCATION (cond);\n-\t  data.kind = 1;\n+\t  data.kind = kind | 1;\n \t  walk_tree_1 (&TREE_OPERAND (cond, 1),\n-\t\t       c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t       c_omp_check_loop_iv_r, &data, NULL, lh);\n+\t  if (data.maybe_nonrect)\n+\t    vec_outer2 = c_omp_check_nonrect_loop_iv (&TREE_OPERAND (cond, 1),\n+\t\t\t\t\t\t      &data, lh);\n+\t}\n+      if (vec_outer1 && vec_outer2 && vec_outer1 != vec_outer2)\n+\t{\n+\t  location_t loc = data.expr_loc;\n+\t  if (loc == UNKNOWN_LOCATION)\n+\t    loc = data.stmt_loc;\n+\t  error_at (loc, \"two different outer iteration variables %qD and %qD\"\n+\t\t\t \" used in a single loop\", vec_outer1, vec_outer2);\n+\t  data.fail = true;\n \t}\n+      if (vec_outer1 || vec_outer2)\n+\tOMP_FOR_NON_RECTANGULAR (stmt) = 1;\n       if (TREE_CODE (incr) == MODIFY_EXPR)\n \t{\n \t  gcc_assert (TREE_OPERAND (incr, 0) == decl);\n@@ -1155,13 +1400,13 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n \t    {\n \t      data.expr_loc = EXPR_LOCATION (TREE_OPERAND (incr, 0));\n \t      walk_tree_1 (&TREE_OPERAND (incr, 0),\n-\t\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t\t   c_omp_check_loop_iv_r, &data, NULL, lh);\n \t    }\n \t  else\n \t    {\n \t      data.expr_loc = EXPR_LOCATION (TREE_OPERAND (incr, 1));\n \t      walk_tree_1 (&TREE_OPERAND (incr, 1),\n-\t\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t\t   c_omp_check_loop_iv_r, &data, NULL, lh);\n \t    }\n \t}\n     }\n@@ -1171,23 +1416,32 @@ c_omp_check_loop_iv (tree stmt, tree declv, walk_tree_lh lh)\n /* Similar, but allows to check the init or cond expressions individually.  */\n \n bool\n-c_omp_check_loop_iv_exprs (location_t stmt_loc, tree declv, tree decl,\n+c_omp_check_loop_iv_exprs (location_t stmt_loc, tree declv, int i, tree decl,\n \t\t\t   tree init, tree cond, walk_tree_lh lh)\n {\n   hash_set<tree> pset;\n   struct c_omp_check_loop_iv_data data;\n \n   data.declv = declv;\n   data.fail = false;\n+  data.maybe_nonrect = false;\n   data.stmt_loc = stmt_loc;\n   data.lh = lh;\n   data.ppset = &pset;\n+  data.idx = i;\n+  if (i > 0\n+      && (unsigned) c_omp_is_loop_iterator (decl, &data) < (unsigned) i)\n+    {\n+      error_at (stmt_loc, \"the same loop iteration variables %qD used in \"\n+      \t\t\t  \"multiple associated loops\", decl);\n+      data.fail = true;\n+    }\n   if (init)\n     {\n       data.expr_loc = EXPR_LOCATION (init);\n       data.kind = 0;\n       walk_tree_1 (&init,\n-\t\t   c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t   c_omp_check_loop_iv_r, &data, NULL, lh);\n     }\n   if (cond)\n     {\n@@ -1196,10 +1450,10 @@ c_omp_check_loop_iv_exprs (location_t stmt_loc, tree declv, tree decl,\n       data.kind = 1;\n       if (TREE_OPERAND (cond, 0) == decl)\n \twalk_tree_1 (&TREE_OPERAND (cond, 1),\n-\t\t     c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t     c_omp_check_loop_iv_r, &data, NULL, lh);\n       else\n \twalk_tree_1 (&TREE_OPERAND (cond, 0),\n-\t\t     c_omp_check_loop_iv_r, &data, &pset, lh);\n+\t\t     c_omp_check_loop_iv_r, &data, NULL, lh);\n     }\n   return !data.fail;\n }"}, {"sha": "7bf91ef91aad4d190053f9c3a9de35e0614bbf0a", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -7594,6 +7594,8 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after,\n   struct c_expr lhs, rhs, ret;\n   enum tree_code code;\n   location_t op_location, exp_location;\n+  bool save_in_omp_for = c_in_omp_for;\n+  c_in_omp_for = false;\n   gcc_assert (!after || c_dialect_objc ());\n   lhs = c_parser_conditional_expression (parser, after, omp_atomic_lhs);\n   op_location = c_parser_peek_token (parser)->location;\n@@ -7633,6 +7635,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after,\n       code = BIT_IOR_EXPR;\n       break;\n     default:\n+      c_in_omp_for = save_in_omp_for;\n       return lhs;\n     }\n   c_parser_consume_token (parser);\n@@ -7652,6 +7655,7 @@ c_parser_expr_no_commas (c_parser *parser, struct c_expr *after,\n       ret.original_code = ERROR_MARK;\n     }\n   ret.original_type = NULL;\n+  c_in_omp_for = save_in_omp_for;\n   return ret;\n }\n \n@@ -18119,8 +18123,10 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t  if (i > 0)\n \t    vec_safe_push (for_block, c_begin_compound_stmt (true));\n \t  this_pre_body = push_stmt_list ();\n+\t  c_in_omp_for = true;\n \t  c_parser_declaration_or_fndef (parser, true, true, true, true, true,\n \t\t\t\t\t NULL, vNULL);\n+\t  c_in_omp_for = false;\n \t  if (this_pre_body)\n \t    {\n \t      this_pre_body = pop_stmt_list (this_pre_body);\n@@ -18158,9 +18164,11 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t  init_exp = c_parser_expr_no_commas (parser, NULL);\n \t  init_exp = default_function_array_read_conversion (init_loc,\n \t\t\t\t\t\t\t     init_exp);\n+\t  c_in_omp_for = true;\n \t  init = build_modify_expr (init_loc, decl, decl_exp.original_type,\n \t\t\t\t    NOP_EXPR, init_loc, init_exp.value,\n \t\t\t\t    init_exp.original_type);\n+\t  c_in_omp_for = false;\n \t  init = c_process_expr_stmt (init_loc, init);\n \n \t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n@@ -18181,19 +18189,13 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n       if (c_parser_next_token_is_not (parser, CPP_SEMICOLON))\n \t{\n \t  location_t cond_loc = c_parser_peek_token (parser)->location;\n+\t  c_in_omp_for = true;\n \t  struct c_expr cond_expr\n \t    = c_parser_binary_expression (parser, NULL, NULL_TREE);\n+          c_in_omp_for = false;\n \n \t  cond = cond_expr.value;\n \t  cond = c_objc_common_truthvalue_conversion (cond_loc, cond);\n-\t  if (COMPARISON_CLASS_P (cond))\n-\t    {\n-\t      tree op0 = TREE_OPERAND (cond, 0), op1 = TREE_OPERAND (cond, 1);\n-\t      op0 = c_fully_fold (op0, false, NULL);\n-\t      op1 = c_fully_fold (op1, false, NULL);\n-\t      TREE_OPERAND (cond, 0) = op0;\n-\t      TREE_OPERAND (cond, 1) = op1;\n-\t    }\n \t  switch (cond_expr.original_code)\n \t    {\n \t    case GT_EXPR:\n@@ -18337,8 +18339,10 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n      an error from the initialization parsing.  */\n   if (!fail)\n     {\n+      c_in_omp_for = true;\n       stmt = c_finish_omp_for (loc, code, declv, NULL, initv, condv,\n \t\t\t       incrv, body, pre_body, true);\n+      c_in_omp_for = false;\n \n       /* Check for iterators appearing in lb, b or incr expressions.  */\n       if (stmt && !c_omp_check_loop_iv (stmt, declv, NULL))\n@@ -18348,6 +18352,40 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t{\n \t  add_stmt (stmt);\n \n+\t  for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (stmt)); i++)\n+\t    {\n+\t      tree init = TREE_VEC_ELT (OMP_FOR_INIT (stmt), i);\n+\t      gcc_assert (TREE_CODE (init) == MODIFY_EXPR);\n+\t      tree decl = TREE_OPERAND (init, 0);\n+\t      tree cond = TREE_VEC_ELT (OMP_FOR_COND (stmt), i);\n+\t      gcc_assert (COMPARISON_CLASS_P (cond));\n+\t      gcc_assert (TREE_OPERAND (cond, 0) == decl);\n+\n+\t      tree op0 = TREE_OPERAND (init, 1);\n+\t      if (!OMP_FOR_NON_RECTANGULAR (stmt)\n+\t\t  || TREE_CODE (op0) != TREE_VEC)\n+\t\tTREE_OPERAND (init, 1) = c_fully_fold (op0, false, NULL);\n+\t      else\n+\t\t{\n+\t\t  TREE_VEC_ELT (op0, 1)\n+\t\t    = c_fully_fold (TREE_VEC_ELT (op0, 1), false, NULL);\n+\t\t  TREE_VEC_ELT (op0, 2)\n+\t\t    = c_fully_fold (TREE_VEC_ELT (op0, 2), false, NULL);\n+\t\t}\n+\n+\t      tree op1 = TREE_OPERAND (cond, 1);\n+\t      if (!OMP_FOR_NON_RECTANGULAR (stmt)\n+\t\t  || TREE_CODE (op1) != TREE_VEC)\n+\t\tTREE_OPERAND (cond, 1) = c_fully_fold (op1, false, NULL);\n+\t      else\n+\t\t{\n+\t\t  TREE_VEC_ELT (op1, 1)\n+\t\t    = c_fully_fold (TREE_VEC_ELT (op1, 1), false, NULL);\n+\t\t  TREE_VEC_ELT (op1, 2)\n+\t\t    = c_fully_fold (TREE_VEC_ELT (op1, 2), false, NULL);\n+\t\t}\n+\t    }\n+\n \t  if (cclauses != NULL\n \t      && cclauses[C_OMP_CLAUSE_SPLIT_PARALLEL] != NULL)\n \t    {"}, {"sha": "10938cf08570137cb210838f3c90827032253b3b", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -657,6 +657,7 @@ extern alias_set_type c_get_alias_set (tree);\n extern int in_alignof;\n extern int in_sizeof;\n extern int in_typeof;\n+extern bool c_in_omp_for;\n \n extern tree c_last_sizeof_arg;\n extern location_t c_last_sizeof_loc;"}, {"sha": "3be3690c6e2265c208a5f53396deae9e66222061", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -71,6 +71,9 @@ int in_sizeof;\n /* The level of nesting inside \"typeof\".  */\n int in_typeof;\n \n+/* True when parsing OpenMP loop expressions.  */\n+bool c_in_omp_for;\n+\n /* The argument of last parsed sizeof expression, only to be tested\n    if expr.original_code == SIZEOF_EXPR.  */\n tree c_last_sizeof_arg;\n@@ -6209,15 +6212,20 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   if (!(is_atomic_op && modifycode != NOP_EXPR))\n     {\n       tree rhs_semantic_type = NULL_TREE;\n-      if (TREE_CODE (newrhs) == EXCESS_PRECISION_EXPR)\n+      if (!c_in_omp_for)\n \t{\n-\t  rhs_semantic_type = TREE_TYPE (newrhs);\n-\t  newrhs = TREE_OPERAND (newrhs, 0);\n+\t  if (TREE_CODE (newrhs) == EXCESS_PRECISION_EXPR)\n+\t    {\n+\t      rhs_semantic_type = TREE_TYPE (newrhs);\n+\t      newrhs = TREE_OPERAND (newrhs, 0);\n+\t    }\n+\t  npc = null_pointer_constant_p (newrhs);\n+\t  newrhs = c_fully_fold (newrhs, false, NULL);\n+\t  if (rhs_semantic_type)\n+\t    newrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n \t}\n-      npc = null_pointer_constant_p (newrhs);\n-      newrhs = c_fully_fold (newrhs, false, NULL);\n-      if (rhs_semantic_type)\n-\tnewrhs = build1 (EXCESS_PRECISION_EXPR, rhs_semantic_type, newrhs);\n+      else\n+\tnpc = null_pointer_constant_p (newrhs);\n       newrhs = convert_for_assignment (location, rhs_loc, lhstype, newrhs,\n \t\t\t\t       rhs_origtype, ic_assign, npc,\n \t\t\t\t       NULL_TREE, NULL_TREE, 0);\n@@ -7745,12 +7753,15 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \n   STRIP_TYPE_NOPS (inside_init);\n \n-  if (TREE_CODE (inside_init) == EXCESS_PRECISION_EXPR)\n+  if (!c_in_omp_for)\n     {\n-      semantic_type = TREE_TYPE (inside_init);\n-      inside_init = TREE_OPERAND (inside_init, 0);\n+      if (TREE_CODE (inside_init) == EXCESS_PRECISION_EXPR)\n+\t{\n+\t  semantic_type = TREE_TYPE (inside_init);\n+\t  inside_init = TREE_OPERAND (inside_init, 0);\n+\t}\n+      inside_init = c_fully_fold (inside_init, require_constant, &maybe_const);\n     }\n-  inside_init = c_fully_fold (inside_init, require_constant, &maybe_const);\n \n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n@@ -12475,7 +12486,7 @@ build_binary_op (location_t location, enum tree_code code,\n \t  converted = 1;\n \t  resultcode = xresultcode;\n \n-\t  if (c_inhibit_evaluation_warnings == 0)\n+\t  if (c_inhibit_evaluation_warnings == 0 && !c_in_omp_for)\n \t    {\n \t      bool op0_maybe_const = true;\n \t      bool op1_maybe_const = true;"}, {"sha": "07b9956c6b04a8a233b92917c66ec02f17541d90", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -17449,7 +17449,16 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n       else\n \tdecl = RECUR (decl);\n     }\n-  init = RECUR (init);\n+  if (init && TREE_CODE (init) == TREE_VEC)\n+    {\n+      init = copy_node (init);\n+      TREE_VEC_ELT (init, 0)\n+\t= tsubst_decl (TREE_VEC_ELT (init, 0), args, complain);\n+      TREE_VEC_ELT (init, 1) = RECUR (TREE_VEC_ELT (init, 1));\n+      TREE_VEC_ELT (init, 2) = RECUR (TREE_VEC_ELT (init, 2));\n+    }\n+  else\n+    init = RECUR (init);\n \n   if (orig_declv && OMP_FOR_ORIG_DECLS (t))\n     {\n@@ -17501,7 +17510,21 @@ tsubst_omp_for_iterator (tree t, int i, tree declv, tree &orig_declv,\n \n       if (!range_for)\n \t{\n-\t  cond = RECUR (TREE_VEC_ELT (OMP_FOR_COND (t), i));\n+\t  cond = TREE_VEC_ELT (OMP_FOR_COND (t), i);\n+\t  if (COMPARISON_CLASS_P (cond)\n+\t      && TREE_CODE (TREE_OPERAND (cond, 1)) == TREE_VEC)\n+\t    {\n+\t      tree lhs = RECUR (TREE_OPERAND (cond, 0));\n+\t      tree rhs = copy_node (TREE_OPERAND (cond, 1));\n+\t      TREE_VEC_ELT (rhs, 0)\n+\t\t= tsubst_decl (TREE_VEC_ELT (rhs, 0), args, complain);\n+\t      TREE_VEC_ELT (rhs, 1) = RECUR (TREE_VEC_ELT (rhs, 1));\n+\t      TREE_VEC_ELT (rhs, 2) = RECUR (TREE_VEC_ELT (rhs, 2));\n+\t      cond = build2 (TREE_CODE (cond), TREE_TYPE (cond),\n+\t\t\t     lhs, rhs);\t      \n+\t    }\n+\t  else\n+\t    cond = RECUR (cond);\n \t  incr = TREE_VEC_ELT (OMP_FOR_INCR (t), i);\n \t  if (TREE_CODE (incr) == MODIFY_EXPR)\n \t    {"}, {"sha": "d63cea96e239cb721c0a8f69d560e2f294689c7c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 43, "deletions": 31, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -8594,7 +8594,7 @@ handle_omp_for_class_iterator (int i, location_t locus, enum tree_code code,\n \t\tTREE_OPERAND (cond, 1), iter);\n       return true;\n     }\n-  if (!c_omp_check_loop_iv_exprs (locus, orig_declv,\n+  if (!c_omp_check_loop_iv_exprs (locus, orig_declv, i,\n \t\t\t\t  TREE_VEC_ELT (declv, i), NULL_TREE,\n \t\t\t\t  cond, cp_walk_subtrees))\n     return true;\n@@ -8980,8 +8980,8 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n       tree orig_init;\n       FOR_EACH_VEC_ELT (*orig_inits, i, orig_init)\n \tif (orig_init\n-\t    && !c_omp_check_loop_iv_exprs (locus, orig_declv\n-\t\t\t\t\t\t  ? orig_declv : declv,\n+\t    && !c_omp_check_loop_iv_exprs (locus,\n+\t\t\t\t\t   orig_declv ? orig_declv : declv, i,\n \t\t\t\t\t   TREE_VEC_ELT (declv, i), orig_init,\n \t\t\t\t\t   NULL_TREE, cp_walk_subtrees))\n \t  fail = true;\n@@ -9075,35 +9075,11 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \t  return NULL;\n \t}\n \n-      if (!processing_template_decl)\n-\t{\n-\t  init = fold_build_cleanup_point_expr (TREE_TYPE (init), init);\n-\t  init = cp_build_modify_expr (elocus, decl, NOP_EXPR, init,\n-\t\t\t\t       tf_warning_or_error);\n-\t}\n+      if (!processing_template_decl && TREE_CODE (init) != TREE_VEC)\n+\tinit = cp_build_modify_expr (elocus, decl, NOP_EXPR, init,\n+\t\t\t\t     tf_warning_or_error);\n       else\n \tinit = build2 (MODIFY_EXPR, void_type_node, decl, init);\n-      if (cond\n-\t  && TREE_SIDE_EFFECTS (cond)\n-\t  && COMPARISON_CLASS_P (cond)\n-\t  && !processing_template_decl)\n-\t{\n-\t  tree t = TREE_OPERAND (cond, 0);\n-\t  if (TREE_SIDE_EFFECTS (t)\n-\t      && t != decl\n-\t      && (TREE_CODE (t) != NOP_EXPR\n-\t\t  || TREE_OPERAND (t, 0) != decl))\n-\t    TREE_OPERAND (cond, 0)\n-\t      = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n-\n-\t  t = TREE_OPERAND (cond, 1);\n-\t  if (TREE_SIDE_EFFECTS (t)\n-\t      && t != decl\n-\t      && (TREE_CODE (t) != NOP_EXPR\n-\t\t  || TREE_OPERAND (t, 0) != decl))\n-\t    TREE_OPERAND (cond, 1)\n-\t      = fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n-\t}\n       if (decl == error_mark_node || init == error_mark_node)\n \treturn NULL;\n \n@@ -9132,9 +9108,45 @@ finish_omp_for (location_t locus, enum tree_code code, tree declv,\n \n   for (i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INCR (omp_for)); i++)\n     {\n-      decl = TREE_OPERAND (TREE_VEC_ELT (OMP_FOR_INIT (omp_for), i), 0);\n+      init = TREE_VEC_ELT (OMP_FOR_INIT (omp_for), i);\n+      decl = TREE_OPERAND (init, 0);\n+      cond = TREE_VEC_ELT (OMP_FOR_COND (omp_for), i);\n       incr = TREE_VEC_ELT (OMP_FOR_INCR (omp_for), i);\n \n+      if (!processing_template_decl)\n+\t{\n+\t  if (TREE_CODE (TREE_OPERAND (init, 1)) == TREE_VEC)\n+\t    {\n+\t      tree t = TREE_VEC_ELT (TREE_OPERAND (init, 1), 1);\n+\t      TREE_VEC_ELT (TREE_OPERAND (init, 1), 1)\n+\t\t= fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      t = TREE_VEC_ELT (TREE_OPERAND (init, 1), 2);\n+\t      TREE_VEC_ELT (TREE_OPERAND (init, 1), 2)\n+\t\t= fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree t = TREE_OPERAND (init, 1);\n+\t      TREE_OPERAND (init, 1)\n+\t\t= fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t    }\n+\t  if (TREE_CODE (TREE_OPERAND (cond, 1)) == TREE_VEC)\n+\t    {\n+\t      tree t = TREE_VEC_ELT (TREE_OPERAND (cond, 1), 1);\n+\t      TREE_VEC_ELT (TREE_OPERAND (cond, 1), 1)\n+\t\t= fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t      t = TREE_VEC_ELT (TREE_OPERAND (cond, 1), 2);\n+\t      TREE_VEC_ELT (TREE_OPERAND (cond, 1), 2)\n+\t\t= fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree t = TREE_OPERAND (cond, 1);\n+\t      TREE_OPERAND (cond, 1)\n+\t\t= fold_build_cleanup_point_expr (TREE_TYPE (t), t);\n+\t    }\n+\t}\n+\n       if (TREE_CODE (incr) != MODIFY_EXPR)\n \tcontinue;\n "}, {"sha": "0336d3e61c6e0d47ed757710647897af6d6fcd0c", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -1512,8 +1512,11 @@ dump_gimple_omp_for (pretty_printer *buffer, const gomp_for *gs, int spc,\n \t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n \t\t\t     flags, false);\n \t  pp_string (buffer, \" = \");\n-\t  dump_generic_node (buffer, gimple_omp_for_initial (gs, i), spc,\n-\t\t\t     flags, false);\n+\t  tree init = gimple_omp_for_initial (gs, i);\n+\t  if (TREE_CODE (init) != TREE_VEC)\n+\t    dump_generic_node (buffer, init, spc, flags, false);\n+\t  else\n+\t    dump_omp_loop_non_rect_expr (buffer, init, spc, flags);\n \t  pp_string (buffer, \"; \");\n \n \t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,\n@@ -1540,8 +1543,11 @@ dump_gimple_omp_for (pretty_printer *buffer, const gomp_for *gs, int spc,\n \t      gcc_unreachable ();\n \t    }\n \t  pp_space (buffer);\n-\t  dump_generic_node (buffer, gimple_omp_for_final (gs, i), spc,\n-\t\t\t     flags, false);\n+\t  tree cond = gimple_omp_for_final (gs, i);\n+\t  if (TREE_CODE (cond) != TREE_VEC)\n+\t    dump_generic_node (buffer, cond, spc, flags, false);\n+\t  else\n+\t    dump_omp_loop_non_rect_expr (buffer, cond, spc, flags);\n \t  pp_string (buffer, \"; \");\n \n \t  dump_generic_node (buffer, gimple_omp_for_index (gs, i), spc,"}, {"sha": "dd101197869f2b22bcbfb4eb778ef11b8329fab4", "filename": "gcc/gimplify.c", "status": "modified", "additions": 78, "deletions": 4, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -11182,7 +11182,26 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n   switch (TREE_CODE (for_stmt))\n     {\n     case OMP_FOR:\n+      if (OMP_FOR_NON_RECTANGULAR (inner_for_stmt ? inner_for_stmt : for_stmt))\n+\t{\n+\t  if (omp_find_clause (OMP_FOR_CLAUSES (for_stmt),\n+\t\t\t       OMP_CLAUSE_SCHEDULE))\n+\t    error_at (EXPR_LOCATION (for_stmt),\n+\t\t      \"%qs clause may not appear on non-rectangular %qs\",\n+\t\t      \"schedule\", \"for\");\n+\t  if (omp_find_clause (OMP_FOR_CLAUSES (for_stmt), OMP_CLAUSE_ORDERED))\n+\t    error_at (EXPR_LOCATION (for_stmt),\n+\t\t      \"%qs clause may not appear on non-rectangular %qs\",\n+\t\t      \"ordered\", \"for\");\n+\t}\n+      break;\n     case OMP_DISTRIBUTE:\n+      if (OMP_FOR_NON_RECTANGULAR (inner_for_stmt ? inner_for_stmt : for_stmt)\n+\t  && omp_find_clause (OMP_FOR_CLAUSES (for_stmt),\n+\t\t\t      OMP_CLAUSE_DIST_SCHEDULE))\n+\terror_at (EXPR_LOCATION (for_stmt),\n+\t\t  \"%qs clause may not appear on non-rectangular %qs\",\n+\t\t  \"dist_schedule\", \"distribute\");\n       break;\n     case OACC_LOOP:\n       ort = ORT_ACC;\n@@ -11757,8 +11776,18 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       else\n \tvar = decl;\n \n-      tret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n-\t\t\t    is_gimple_val, fb_rvalue, false);\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) == TREE_VEC)\n+\t{\n+\t  tree lb = TREE_OPERAND (t, 1);\n+\t  tret = gimplify_expr (&TREE_VEC_ELT (lb, 1), &for_pre_body, NULL,\n+\t\t\t\tis_gimple_val, fb_rvalue, false);\n+\t  ret = MIN (ret, tret);\n+\t  tret = gimplify_expr (&TREE_VEC_ELT (lb, 2), &for_pre_body, NULL,\n+\t\t\t\tis_gimple_val, fb_rvalue, false);\n+\t}\n+      else\n+\ttret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n+\t\t\t      is_gimple_val, fb_rvalue, false);\n       ret = MIN (ret, tret);\n       if (ret == GS_ERROR)\n \treturn ret;\n@@ -11768,8 +11797,18 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n       gcc_assert (COMPARISON_CLASS_P (t));\n       gcc_assert (TREE_OPERAND (t, 0) == decl);\n \n-      tret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n-\t\t\t    is_gimple_val, fb_rvalue, false);\n+      if (TREE_CODE (TREE_OPERAND (t, 1)) == TREE_VEC)\n+\t{\n+\t  tree ub = TREE_OPERAND (t, 1);\n+\t  tret = gimplify_expr (&TREE_VEC_ELT (ub, 1), &for_pre_body, NULL,\n+\t\t\t\tis_gimple_val, fb_rvalue, false);\n+\t  ret = MIN (ret, tret);\n+\t  tret = gimplify_expr (&TREE_VEC_ELT (ub, 2), &for_pre_body, NULL,\n+\t\t\t\tis_gimple_val, fb_rvalue, false);\n+\t}\n+      else\n+\ttret = gimplify_expr (&TREE_OPERAND (t, 1), &for_pre_body, NULL,\n+\t\t\t      is_gimple_val, fb_rvalue, false);\n       ret = MIN (ret, tret);\n \n       /* Handle OMP_FOR_INCR.  */\n@@ -11911,6 +11950,20 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \t\tpop_gimplify_context (bind);\n \t      }\n \t}\n+      if (OMP_FOR_NON_RECTANGULAR (for_stmt) && var != decl)\n+\tfor (int j = i + 1; j < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); j++)\n+\t  {\n+\t    t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), j);\n+\t    gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n+\t    if (TREE_CODE (TREE_OPERAND (t, 1)) == TREE_VEC\n+\t\t&& TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) == decl)\n+\t      TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) = var;\n+\t    t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), j);\n+\t    gcc_assert (COMPARISON_CLASS_P (t));\n+\t    if (TREE_CODE (TREE_OPERAND (t, 1)) == TREE_VEC\n+\t\t&& TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) == decl)\n+\t      TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) = var;\n+\t  }\n     }\n \n   BITMAP_FREE (has_decl_expr);\n@@ -11955,6 +12008,27 @@ gimplify_omp_for (tree *expr_p, gimple_seq *pre_p)\n \tt = TREE_VEC_ELT (OMP_FOR_INCR (for_stmt), i);\n \tTREE_OPERAND (t, 1) = copy_node (TREE_OPERAND (t, 1));\n \tTREE_OPERAND (TREE_OPERAND (t, 1), 0) = var;\n+\tif (OMP_FOR_NON_RECTANGULAR (for_stmt))\n+\t  for (int j = i + 1;\n+\t       j < TREE_VEC_LENGTH (OMP_FOR_INIT (for_stmt)); j++)\n+\t    {\n+\t      t = TREE_VEC_ELT (OMP_FOR_INIT (for_stmt), j);\n+\t      gcc_assert (TREE_CODE (t) == MODIFY_EXPR);\n+\t      if (TREE_CODE (TREE_OPERAND (t, 1)) == TREE_VEC\n+\t\t  && TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) == decl)\n+\t\t{\n+\t\t  TREE_OPERAND (t, 1) = copy_node (TREE_OPERAND (t, 1));\n+\t\t  TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) = var;\n+\t\t}\n+\t      t = TREE_VEC_ELT (OMP_FOR_COND (for_stmt), j);\n+\t      gcc_assert (COMPARISON_CLASS_P (t));\n+\t      if (TREE_CODE (TREE_OPERAND (t, 1)) == TREE_VEC\n+\t\t  && TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) == decl)\n+\t\t{\n+\t\t  TREE_OPERAND (t, 1) = copy_node (TREE_OPERAND (t, 1));\n+\t\t  TREE_VEC_ELT (TREE_OPERAND (t, 1), 0) = var;\n+\t\t}\n+\t  }\n       }\n \n   gimplify_adjust_omp_clauses (pre_p, for_body,"}, {"sha": "06caeb24c3a0d65691ecc9a473392e0dcd2f037e", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -6532,14 +6532,22 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n     loops_state_set (LOOPS_NEED_FIXUP);\n \n   if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_SIMD)\n-    expand_omp_simd (region, &fd);\n+    {\n+      if (fd.non_rect)\n+\tsorry_at (gimple_location (fd.for_stmt),\n+\t\t  \"non-rectangular %<simd%> not supported yet\");\n+      expand_omp_simd (region, &fd);\n+    }\n   else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_OACC_LOOP)\n     {\n-      gcc_assert (!inner_stmt);\n+      gcc_assert (!inner_stmt && !fd.non_rect);\n       expand_oacc_for (region, &fd);\n     }\n   else if (gimple_omp_for_kind (fd.for_stmt) == GF_OMP_FOR_KIND_TASKLOOP)\n     {\n+      if (fd.non_rect)\n+\tsorry_at (gimple_location (fd.for_stmt),\n+\t\t  \"non-rectangular %<taskloop%> not supported yet\");\n       if (gimple_omp_for_combined_into_p (fd.for_stmt))\n \texpand_omp_taskloop_for_inner (region, &fd, inner_stmt);\n       else\n@@ -6548,6 +6556,9 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n   else if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n \t   && !fd.have_ordered)\n     {\n+      if (fd.non_rect)\n+\tsorry_at (gimple_location (fd.for_stmt),\n+\t\t  \"non-rectangular OpenMP loops not supported yet\");\n       if (fd.chunk_size == NULL)\n \texpand_omp_for_static_nochunk (region, &fd, inner_stmt);\n       else\n@@ -6560,7 +6571,7 @@ expand_omp_for (struct omp_region *region, gimple *inner_stmt)\n       tree sched_arg = NULL_TREE;\n \n       gcc_assert (gimple_omp_for_kind (fd.for_stmt)\n-\t\t  == GF_OMP_FOR_KIND_FOR);\n+\t\t  == GF_OMP_FOR_KIND_FOR && !fd.non_rect);\n       if (fd.chunk_size == NULL\n \t  && fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC)\n \tfd.chunk_size = integer_zero_node;"}, {"sha": "fc889002a520c0e575689c74360033ce7721cf1b", "filename": "gcc/omp-general.c", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -201,6 +201,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->have_pointer_condtemp = false;\n   fd->have_scantemp = false;\n   fd->have_nonctrl_scantemp = false;\n+  fd->non_rect = false;\n   fd->lastprivate_conditional = 0;\n   fd->tiling = NULL_TREE;\n   fd->collapse = 1;\n@@ -330,12 +331,45 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\t  || TREE_CODE (TREE_TYPE (loop->v)) == POINTER_TYPE);\n       var = TREE_CODE (loop->v) == SSA_NAME ? SSA_NAME_VAR (loop->v) : loop->v;\n       loop->n1 = gimple_omp_for_initial (for_stmt, i);\n+      loop->m1 = NULL_TREE;\n+      loop->m2 = NULL_TREE;\n+      loop->outer = 0;\n+      if (TREE_CODE (loop->n1) == TREE_VEC)\n+\t{\n+\t  for (int j = i - 1; j >= 0; j--)\n+\t    if (TREE_VEC_ELT (loop->n1, 0) == gimple_omp_for_index (for_stmt, j))\n+\t      {\n+\t\tloop->outer = i - j;\n+\t\tbreak;\n+\t      }\n+\t  gcc_assert (loop->outer);\n+\t  loop->m1 = TREE_VEC_ELT (loop->n1, 1);\n+\t  loop->n1 = TREE_VEC_ELT (loop->n1, 2);\n+\t  fd->non_rect = true;\n+\t}\n \n       loop->cond_code = gimple_omp_for_cond (for_stmt, i);\n       loop->n2 = gimple_omp_for_final (for_stmt, i);\n       gcc_assert (loop->cond_code != NE_EXPR\n \t\t  || (gimple_omp_for_kind (for_stmt)\n \t\t      != GF_OMP_FOR_KIND_OACC_LOOP));\n+      if (TREE_CODE (loop->n2) == TREE_VEC)\n+\t{\n+\t  if (loop->outer)\n+\t    gcc_assert (TREE_VEC_ELT (loop->n2, 0)\n+\t\t\t== gimple_omp_for_index (for_stmt, i - loop->outer));\n+\t  else\n+\t    for (int j = i - 1; j >= 0; j--)\n+\t      if (TREE_VEC_ELT (loop->n2, 0) == gimple_omp_for_index (for_stmt, j))\n+\t\t{\n+\t\t  loop->outer = i - j;\n+\t\t  break;\n+\t\t}\n+\t  gcc_assert (loop->outer);\n+\t  loop->m2 = TREE_VEC_ELT (loop->n2, 1);\n+\t  loop->n2 = TREE_VEC_ELT (loop->n2, 2);\n+\t  fd->non_rect = true;\n+\t}\n \n       t = gimple_omp_for_incr (for_stmt, i);\n       gcc_assert (TREE_OPERAND (t, 0) == var);\n@@ -357,6 +391,10 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      = build_nonstandard_integer_type\n \t\t  (TYPE_PRECISION (TREE_TYPE (loop->v)), 1);\n \t}\n+      else if (loop->m1 || loop->m2)\n+\t/* Non-rectangular loops should use static schedule and no\n+\t   ordered clause.  */\n+\tgcc_unreachable ();\n       else if (iter_type != long_long_unsigned_type_node)\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (loop->v)))\n@@ -406,13 +444,18 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \n       if (collapse_count && *collapse_count == NULL)\n \t{\n-\t  t = fold_binary (loop->cond_code, boolean_type_node,\n-\t\t\t   fold_convert (TREE_TYPE (loop->v), loop->n1),\n-\t\t\t   fold_convert (TREE_TYPE (loop->v), loop->n2));\n+\t  if (loop->m1 || loop->m2)\n+\t    t = NULL_TREE;\n+\t  else\n+\t    t = fold_binary (loop->cond_code, boolean_type_node,\n+\t\t\t     fold_convert (TREE_TYPE (loop->v), loop->n1),\n+\t\t\t     fold_convert (TREE_TYPE (loop->v), loop->n2));\n \t  if (t && integer_zerop (t))\n \t    count = build_zero_cst (long_long_unsigned_type_node);\n \t  else if ((i == 0 || count != NULL_TREE)\n \t\t   && TREE_CODE (TREE_TYPE (loop->v)) == INTEGER_TYPE\n+\t\t   && loop->m1 == NULL_TREE\n+\t\t   && loop->m2 == NULL_TREE\n \t\t   && TREE_CONSTANT (loop->n1)\n \t\t   && TREE_CONSTANT (loop->n2)\n \t\t   && TREE_CODE (loop->step) == INTEGER_CST)\n@@ -486,6 +529,9 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n       fd->loop.n1 = build_int_cst (TREE_TYPE (fd->loop.v), 0);\n       fd->loop.n2 = *collapse_count;\n       fd->loop.step = build_int_cst (TREE_TYPE (fd->loop.v), 1);\n+      fd->loop.m1 = NULL_TREE;\n+      fd->loop.m2 = NULL_TREE;\n+      fd->loop.outer = 0;\n       fd->loop.cond_code = LT_EXPR;\n     }\n   else if (loops)"}, {"sha": "7c1122bb95fa26f20444006f78af7767771de8ba", "filename": "gcc/omp-general.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -43,11 +43,16 @@ enum oacc_loop_flags {\n };\n \n /* A structure holding the elements of:\n-   for (V = N1; V cond N2; V += STEP) [...] */\n+   for (V = N1; V cond N2; V += STEP) [...]\n+   or for non-rectangular loops:\n+   for (V = M1 * W + N1; V cond M2 * W + N2; V += STEP;\n+   where W is V of the OUTER-th loop (e.g. for OUTER 1 it is the\n+   the index of the immediately surrounding loop).  */\n \n struct omp_for_data_loop\n {\n-  tree v, n1, n2, step;\n+  tree v, n1, n2, step, m1, m2;\n+  int outer;\n   enum tree_code cond_code;\n };\n \n@@ -64,6 +69,7 @@ struct omp_for_data\n   int ordered;\n   bool have_nowait, have_ordered, simd_schedule, have_reductemp;\n   bool have_pointer_condtemp, have_scantemp, have_nonctrl_scantemp;\n+  bool non_rect;\n   int lastprivate_conditional;\n   unsigned char sched_modifiers;\n   enum omp_clause_schedule_kind sched_kind;"}, {"sha": "8bfdfbc4432ef4752b40224762e336e1350eae81", "filename": "gcc/omp-low.c", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -10573,13 +10573,31 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   for (i = 0; i < gimple_omp_for_collapse (stmt); i++)\n     {\n       rhs_p = gimple_omp_for_initial_ptr (stmt, i);\n-      if (!is_gimple_min_invariant (*rhs_p))\n+      if (TREE_CODE (*rhs_p) == TREE_VEC)\n+\t{\n+\t  if (!is_gimple_min_invariant (TREE_VEC_ELT (*rhs_p, 1)))\n+\t    TREE_VEC_ELT (*rhs_p, 1)\n+\t      = get_formal_tmp_var (TREE_VEC_ELT (*rhs_p, 1), &cnt_list);\n+\t  if (!is_gimple_min_invariant (TREE_VEC_ELT (*rhs_p, 2)))\n+\t    TREE_VEC_ELT (*rhs_p, 1)\n+\t      = get_formal_tmp_var (TREE_VEC_ELT (*rhs_p, 2), &cnt_list);\n+\t}\n+      else if (!is_gimple_min_invariant (*rhs_p))\n \t*rhs_p = get_formal_tmp_var (*rhs_p, &cnt_list);\n       else if (TREE_CODE (*rhs_p) == ADDR_EXPR)\n \trecompute_tree_invariant_for_addr_expr (*rhs_p);\n \n       rhs_p = gimple_omp_for_final_ptr (stmt, i);\n-      if (!is_gimple_min_invariant (*rhs_p))\n+      if (TREE_CODE (*rhs_p) == TREE_VEC)\n+\t{\n+\t  if (!is_gimple_min_invariant (TREE_VEC_ELT (*rhs_p, 1)))\n+\t    TREE_VEC_ELT (*rhs_p, 1)\n+\t      = get_formal_tmp_var (TREE_VEC_ELT (*rhs_p, 1), &cnt_list);\n+\t  if (!is_gimple_min_invariant (TREE_VEC_ELT (*rhs_p, 2)))\n+\t    TREE_VEC_ELT (*rhs_p, 1)\n+\t      = get_formal_tmp_var (TREE_VEC_ELT (*rhs_p, 2), &cnt_list);\n+\t}\n+      else if (!is_gimple_min_invariant (*rhs_p))\n \t*rhs_p = get_formal_tmp_var (*rhs_p, &cnt_list);\n       else if (TREE_CODE (*rhs_p) == ADDR_EXPR)\n \trecompute_tree_invariant_for_addr_expr (*rhs_p);"}, {"sha": "0d4474dbebb5ca282818902fa6fa0ed04a53002f", "filename": "gcc/testsuite/c-c++-common/gomp/loop-6.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Floop-6.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -0,0 +1,113 @@\n+int bar (int);\n+int baz (int *);\n+\n+void\n+f1 (int x)\n+{\n+  int i = 0, j = 0, k = 0;\n+  long long l = 0;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i * i; j < 16; j += 2)\t/* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i + 3; j < (i + 1) * 2; j += 2)\t/* { dg-error \"condition expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = (i + 1) * 2; j < i * 8; j += 2)\t/* { dg-error \"initializer expression refers to iteration variable\" } */\n+      ;\n+  #pragma omp for collapse(3)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = 0; j < 16; j++)\n+      for (k = i + j; k < 32; k++)\t/* { dg-error \"initializer expression refers to iteration variable\" } */\n+\t;\n+  #pragma omp for collapse(2)\n+  for (l = 0; l < 16; l++)\n+    for (j = 0; j < l; j++)\t\t/* { dg-error \"outer iteration variable 'l' used in condition expression has type other than 'int'\" } */\n+      ;\n+  #pragma omp for collapse(2)\t\t/* { dg-error \"outer iteration variable 'l' used in initializer expression has type other than 'int'\" \"\" { target c } } */\n+  for (l = 0; l < 16; l++)\t\t/* { dg-error \"outer iteration variable 'l' used in initializer expression has type other than 'int'\" \"\" { target c++ } } */\n+    for (j = 7LL * l; j < 32; j++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i + 3; j < i * 2 + 2; j += 2)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = i * 2 + 2; j < i * 6 + 2; j += 2)\n+      ;\n+  #pragma omp for collapse(3)\n+  for (i = 0; i < 16; i = i + 2)\n+    for (j = 0; j < 16; j++)\n+      for (k = 14 + 7 * i; k < 32 * j; k++)\t/* { dg-error \"two different outer iteration variables 'i' and 'j' used in a single loop\" } */\n+\t;\n+  #pragma omp for schedule(static, 2) collapse(2)\t/* { dg-error \"'schedule' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+  #pragma omp for schedule(static) collapse(2)\t\t/* { dg-error \"'schedule' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+  #pragma omp for schedule(dynamic, 5) collapse(2)\t/* { dg-error \"'schedule' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+  #pragma omp for ordered collapse(2)\t\t\t/* { dg-error \"'ordered' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+  #pragma omp for ordered collapse(2)\t\t\t/* { dg-error \"'ordered' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+  #pragma omp for ordered (3) collapse (2)\t\t/* { dg-error \"'ordered' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = 0; j < i; j++)\n+      for (k = 0; k < 64; k++)\n+        {\n+          #pragma omp ordered depend (sink: i - 1, j - 2, k - 3)\n+          #pragma omp ordered depend (source)\n+        }\n+  #pragma omp for ordered (3) collapse (2)\t\t/* { dg-error \"'ordered' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = 0; j < 64; j++)\n+      for (k = i; k < 64; k++)\n+        {\n+          #pragma omp ordered depend (sink: i - 1, j - 2, k - 3)\n+          #pragma omp ordered depend (source)\n+        }\n+  #pragma omp for simd schedule(simd: static) collapse(2)\t/* { dg-error \"'schedule' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+}\n+\n+void\n+f2 (void)\n+{\n+  int i = 0, j = 0;\n+  #pragma omp distribute dist_schedule(static, 4) collapse(2)\t/* { dg-error \"'dist_schedule' clause may not appear on non-rectangular 'distribute'\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = i; j < 64; j++)\n+      ;\n+  #pragma omp distribute collapse(2) dist_schedule(static)\t/* { dg-error \"'dist_schedule' clause may not appear on non-rectangular 'distribute'\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = i; j < 64; j++)\n+      ;\n+  #pragma omp distribute parallel for simd schedule(simd: static) collapse(2)\t/* { dg-error \"'schedule' clause may not appear on non-rectangular 'for'\" } */\n+  for (i = 0; i < 16; i++)\n+    for (j = 1; j < i; j++)\n+      ;\n+  #pragma omp distribute parallel for simd collapse(2) dist_schedule(static)\t/* { dg-error \"'dist_schedule' clause may not appear on non-rectangular 'distribute'\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = i; j < 64; j++)\n+      ;\n+  #pragma omp distribute simd collapse(2) dist_schedule(static)\t/* { dg-error \"'dist_schedule' clause may not appear on non-rectangular 'distribute'\" } */\n+  for (i = 0; i < 64; i++)\n+    for (j = i; j < 64; j++)\n+      ;\n+}"}, {"sha": "abfd1e30424159ec4398bf2d92c420ccc7ae2461", "filename": "gcc/testsuite/g++.dg/gomp/loop-1.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -74,12 +74,12 @@ f1 (int x)\n     for (j = 0; j < 16; j++)\n       ;\n   #pragma omp for collapse(2)\n-  for (i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i = i + 2)\n     for (j = i; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i = i + 2)\n-    for (j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = i + 3; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n@@ -91,11 +91,11 @@ f1 (int x)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n-    for (j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n-    for (j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i + 4; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n@@ -207,12 +207,12 @@ f2 (int x)\n     for (int j = 0; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n-  for (int i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (int i = 0; i < 16; i = i + 2)\n     for (int j = i; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i = i + 2)\n-    for (int j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (int j = i + 3; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n@@ -224,11 +224,11 @@ f2 (int x)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n-    for (int j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n-    for (int j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i + 4; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)"}, {"sha": "327fb0e10fe3ed0d7e8c459ed45a7f584eb37b45", "filename": "gcc/testsuite/g++.dg/gomp/loop-2.C", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-2.C?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -75,12 +75,12 @@ f1 (int x)\n     for (j = 0; j < 16; j++)\n       ;\n   #pragma omp for collapse(2)\n-  for (i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (i = 0; i < 16; i = i + 2)\n     for (j = i; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i = i + 2)\n-    for (j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = i + 3; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n@@ -92,11 +92,11 @@ f1 (int x)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n-    for (j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n-    for (j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i + 4; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n@@ -209,12 +209,12 @@ f2 (int x)\n     for (int j = 0; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n-  for (int i = 0; i < 16; i = i + 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  for (int i = 0; i < 16; i = i + 2)\n     for (int j = i; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i = i + 2)\n-    for (int j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (int j = i + 3; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n@@ -226,11 +226,11 @@ f2 (int x)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n-    for (int j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n-    for (int j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i + 4; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)"}, {"sha": "8601d031a1ddf9e41d00a84c04b27eb75c89b423", "filename": "gcc/testsuite/g++.dg/gomp/loop-5.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-5.C?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -0,0 +1,50 @@\n+void\n+foo ()\n+{\n+  int i = 0;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\t// { dg-error \"the same loop iteration variables 'i' used in multiple associated loops\" }\n+    for (i = 1; i < 32; i++)\n+      ;\n+  #pragma omp taskloop collapse(2)\n+  for (int j = 0; j < 16; j++)\t// { dg-error \"the same loop iteration variables 'j' used in multiple associated loops\" }\n+    for (j = 0; j < 16; j++)\n+      ;\n+}\n+\n+template <int N>\n+void\n+bar ()\n+{\n+  int i = 0;\n+  #pragma omp for collapse(2)\n+  for (i = 0; i < 16; i++)\t// { dg-error \"the same loop iteration variables 'i' used in multiple associated loops\" }\n+    for (i = 1; i < 32; i++)\n+      ;\n+  #pragma omp taskloop collapse(2)\n+  for (int j = 0; j < 16; j++)\t// { dg-error \"the same loop iteration variables 'j' used in multiple associated loops\" }\n+    for (j = 0; j < 16; j++)\n+      ;\n+}\n+\n+template <typename T>\n+void\n+baz ()\n+{\n+  T i = 0;\n+  #pragma omp for collapse(2)\t// { dg-error \"the same loop iteration variables 'i' used in multiple associated loops\" }\n+  for (i = 0; i < 16; i++)\n+    for (i = 1; i < 32; i++)\n+      ;\n+  #pragma omp taskloop collapse(2)\t// { dg-error \"the same loop iteration variables 'j' used in multiple associated loops\" }\n+  for (T j = 0; j < 16; j++)\n+    for (j = 0; j < 16; j++)\n+      ;\n+}\n+\n+void\n+test ()\n+{\n+  bar <0> ();\n+  baz <int> ();\n+}"}, {"sha": "902fef3c1be71938e937897159f24e99b935053d", "filename": "gcc/testsuite/g++.dg/gomp/loop-6.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-6.C?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -0,0 +1,69 @@\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+\n+template <typename T>\n+class I\n+{\n+public:\n+  typedef ptrdiff_t difference_type;\n+  I ();\n+  ~I ();\n+  I (T *);\n+  I (const I &);\n+  T &operator * ();\n+  T *operator -> ();\n+  T &operator [] (const difference_type &) const;\n+  I &operator = (const I &);\n+  I &operator ++ ();\n+  I operator ++ (int);\n+  I &operator -- ();\n+  I operator -- (int);\n+  I &operator += (const difference_type &);\n+  I &operator -= (const difference_type &);\n+  I operator + (const difference_type &) const;\n+  I operator - (const difference_type &) const;\n+  template <typename S> friend bool operator == (I<S> &, I<S> &);\n+  template <typename S> friend bool operator == (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator < (I<S> &, I<S> &);\n+  template <typename S> friend bool operator < (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator <= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator <= (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator > (I<S> &, I<S> &);\n+  template <typename S> friend bool operator > (const I<S> &, const I<S> &);\n+  template <typename S> friend bool operator >= (I<S> &, I<S> &);\n+  template <typename S> friend bool operator >= (const I<S> &, const I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (I<S> &, I<S> &);\n+  template <typename S> friend typename I<S>::difference_type operator - (const I<S> &, const I<S> &);\n+  template <typename S> friend I<S> operator + (typename I<S>::difference_type , const I<S> &);\n+private:\n+  T *p;\n+};\n+\n+template <typename T> bool operator == (I<T> &, I<T> &);\n+template <typename T> bool operator == (const I<T> &, const I<T> &);\n+template <typename T> bool operator != (I<T> &, I<T> &);\n+template <typename T> bool operator != (const I<T> &, const I<T> &);\n+template <typename T> bool operator < (I<T> &, I<T> &);\n+template <typename T> bool operator < (const I<T> &, const I<T> &);\n+template <typename T> bool operator <= (I<T> &, I<T> &);\n+template <typename T> bool operator <= (const I<T> &, const I<T> &);\n+template <typename T> bool operator > (I<T> &, I<T> &);\n+template <typename T> bool operator > (const I<T> &, const I<T> &);\n+template <typename T> bool operator >= (I<T> &, I<T> &);\n+template <typename T> bool operator >= (const I<T> &, const I<T> &);\n+template <typename T> typename I<T>::difference_type operator - (I<T> &, I<T> &);\n+template <typename T> typename I<T>::difference_type operator - (const I<T> &, const I<T> &);\n+template <typename T> I<T> operator + (typename I<T>::difference_type, const I<T> &);\n+\n+void\n+f1 (I<int> &x, I<int> &y)\n+{\n+  I<int> i;\n+  #pragma omp for collapse(2)\n+  for (i = x; i < y; i++)\t// { dg-error \"the same loop iteration variables 'i' used in multiple associated loops\" }\n+    for (i = x; i < y; i++)\n+      ;\n+  #pragma omp for collapse(2)\n+  for (I<int> j = x; j < y; j++)// { dg-error \"the same loop iteration variables 'j' used in multiple associated loops\" }\n+    for (j = y; j > x; j--)\n+      ;\n+}"}, {"sha": "7ec634664f49e95c629a5d4782262ac3baf1fb3c", "filename": "gcc/testsuite/gcc.dg/gomp/loop-1.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-1.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -73,13 +73,13 @@ f1 (int x)\n   for (i = j; i < 16; i = i + 2)\n     for (j = 0; j < 16; j++)\n       ;\n-  #pragma omp for collapse(2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  #pragma omp for collapse(2)\n   for (i = 0; i < 16; i = i + 2)\n     for (j = i; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i = i + 2)\n-    for (j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (j = i + 3; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n@@ -91,11 +91,11 @@ f1 (int x)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n-    for (j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i++)\n-    for (j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (j = 0; j < i + 4; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n@@ -206,13 +206,13 @@ f2 (int x)\n   for (int i = 0; i < 16; i = i + 2)\n     for (int j = 0; j < 16; j += 2)\n       ;\n-  #pragma omp for collapse(2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+  #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i = i + 2)\n     for (int j = i; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i = i + 2)\n-    for (int j = i + 3; j < 16; j += 2) /* { dg-error \"initializer expression refers to iteration variable\" } */\n+    for (int j = i + 3; j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n@@ -224,11 +224,11 @@ f2 (int x)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n-    for (int j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)\n-    for (int j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n+    for (int j = 0; j < i + 4; j++)\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++)"}, {"sha": "2917a4a519dba3ad1393dd27586887890316a207", "filename": "gcc/testsuite/gcc.dg/gomp/loop-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Floop-2.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -0,0 +1,13 @@\n+void\n+foo (void)\n+{\n+  int i = 0;\n+  #pragma omp for collapse(2)\t/* { dg-error \"the same loop iteration variables 'i' used in multiple associated loops\" } */\n+  for (i = 0; i < 16; i++)\n+    for (i = 1; i < 32; i++)\n+      ;\n+  #pragma omp taskloop collapse(2)\t/* { dg-error \"the same loop iteration variables 'j' used in multiple associated loops\" } */\n+  for (int j = 0; j < 16; j++)\n+    for (j = 0; j < 16; j++)\n+      ;\n+}"}, {"sha": "4f50f37b0da5aadb12bfc3219164acd391812d7f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -1568,7 +1568,36 @@ dump_mem_ref (pretty_printer *pp, tree node, int spc, dump_flags_t flags)\n \t}\n       pp_right_bracket (pp);\n     }\n- }\n+}\n+\n+/* Helper function for dump_generic_node.  Dump INIT or COND expression for\n+   OpenMP loop non-rectangular iterators.  */\n+\n+void\n+dump_omp_loop_non_rect_expr (pretty_printer *pp, tree node, int spc,\n+\t\t\t     dump_flags_t flags)\n+{\n+  gcc_assert (TREE_CODE (node) == TREE_VEC);\n+  dump_generic_node (pp, TREE_VEC_ELT (node, 0), spc, flags, false);\n+  pp_string (pp, \" * \");\n+  if (op_prio (TREE_VEC_ELT (node, 1)) <= op_code_prio (MULT_EXPR))\n+    {\n+      pp_left_paren (pp);\n+      dump_generic_node (pp, TREE_VEC_ELT (node, 1), spc, flags, false);\n+      pp_right_paren (pp);\n+    }\n+  else\n+    dump_generic_node (pp, TREE_VEC_ELT (node, 1), spc, flags, false);\n+  pp_string (pp, \" + \");\n+  if (op_prio (TREE_VEC_ELT (node, 1)) <= op_code_prio (PLUS_EXPR))\n+    {\n+      pp_left_paren (pp);\n+      dump_generic_node (pp, TREE_VEC_ELT (node, 2), spc, flags, false);\n+      pp_right_paren (pp);\n+    }\n+  else\n+    dump_generic_node (pp, TREE_VEC_ELT (node, 2), spc, flags, false);\n+}\n \n /* Dump the node NODE on the pretty_printer PP, SPC spaces of\n    indent.  FLAGS specifies details to show in the dump (see TDF_* in\n@@ -3418,13 +3447,34 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \t\t  spc += 2;\n \t\t  newline_and_indent (pp, spc);\n \t\t  pp_string (pp, \"for (\");\n-\t\t  dump_generic_node (pp,\n-\t\t\t\t     TREE_VEC_ELT (OMP_FOR_INIT (node), i),\n-\t\t\t\t     spc, flags, false);\n+\t\t  tree init = TREE_VEC_ELT (OMP_FOR_INIT (node), i);\n+\t\t  if (TREE_CODE (init) != MODIFY_EXPR\n+\t\t      || TREE_CODE (TREE_OPERAND (init, 1)) != TREE_VEC)\n+\t\t    dump_generic_node (pp, init, spc, flags, false);\n+\t\t  else\n+\t\t    {\n+\t\t      dump_generic_node (pp, TREE_OPERAND (init, 0),\n+\t\t\t\t\t spc, flags, false);\n+\t\t      pp_string (pp, \" = \");\n+\t\t      dump_omp_loop_non_rect_expr (pp, TREE_OPERAND (init, 1),\n+\t\t\t\t\t\t   spc, flags);\n+\t\t    }\n \t\t  pp_string (pp, \"; \");\n-\t\t  dump_generic_node (pp,\n-\t\t\t\t     TREE_VEC_ELT (OMP_FOR_COND (node), i),\n-\t\t\t\t     spc, flags, false);\n+\t\t  tree cond = TREE_VEC_ELT (OMP_FOR_COND (node), i);\n+\t\t  if (!COMPARISON_CLASS_P (cond)\n+\t\t      || TREE_CODE (TREE_OPERAND (cond, 1)) != TREE_VEC)\n+\t\t    dump_generic_node (pp, cond, spc, flags, false);\n+\t\t  else\n+\t\t    {\n+\t\t      dump_generic_node (pp, TREE_OPERAND (cond, 0),\n+\t\t\t\t\t spc, flags, false);\n+\t\t      const char *op = op_symbol (cond);\n+\t\t      pp_space (pp);\n+\t\t      pp_string (pp, op);\n+\t\t      pp_space (pp);\n+\t\t      dump_omp_loop_non_rect_expr (pp, TREE_OPERAND (cond, 1),\n+\t\t\t\t\t\t   spc, flags);\n+\t\t    }\n \t\t  pp_string (pp, \"; \");\n \t\t  dump_generic_node (pp,\n \t\t\t\t     TREE_VEC_ELT (OMP_FOR_INCR (node), i),"}, {"sha": "aca7679b49674ad61b0c0bf54593820a9226ef68", "filename": "gcc/tree-pretty-print.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftree-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftree-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.h?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -42,6 +42,8 @@ extern char *print_generic_expr_to_str (tree);\n extern void dump_omp_clauses (pretty_printer *, tree, int, dump_flags_t);\n extern void dump_omp_atomic_memory_order (pretty_printer *,\n \t\t\t\t\t  enum omp_memory_order);\n+extern void dump_omp_loop_non_rect_expr (pretty_printer *, tree, int,\n+\t\t\t\t\t dump_flags_t);\n extern int dump_generic_node (pretty_printer *, tree, int, dump_flags_t, bool);\n extern void print_declaration (pretty_printer *, tree, int, dump_flags_t);\n extern int op_code_prio (enum tree_code);"}, {"sha": "a74872f5f3e8fbe8df5460e373a97319d897cdc4", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1160ec9a141faf1c4c0496c7412c8febeb623962/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1160ec9a141faf1c4c0496c7412c8febeb623962", "patch": "@@ -1465,6 +1465,11 @@ class auto_suppress_location_wrappers\n   != UNKNOWN_LOCATION)\n #define OMP_CLAUSE_LOCATION(NODE)  (OMP_CLAUSE_CHECK (NODE))->omp_clause.locus\n \n+/* True on OMP_FOR and other OpenMP/OpenACC looping constructs if the loop nest\n+   is non-rectangular.  */\n+#define OMP_FOR_NON_RECTANGULAR(NODE) \\\n+  (OMP_LOOPING_CHECK (NODE)->base.private_flag)\n+\n /* True on an OMP_SECTION statement that was the last lexical member.\n    This status is meaningful in the implementation of lastprivate.  */\n #define OMP_SECTION_LAST(NODE) \\"}]}