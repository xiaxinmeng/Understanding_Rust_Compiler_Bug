{"sha": "bb1125df5370b6e29ddf9cb85b8c41a828796eee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmIxMTI1ZGY1MzcwYjZlMjlkZGY5Y2I4NWI4YzQxYTgyODc5NmVlZQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-10-14T17:12:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-10-14T17:12:40Z"}, "message": "[PATCH] Split ssa-dom-thread-2.c into separate files/tests\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2.c: Deleted.  The six functions\n\tcontained within have their own file/test now.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2a.c: New test extracted from\n\tssa-dom-thread-2.c.  Tighten expected output slightly and comment\n\texpectations a bit more.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2b.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2c.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2d.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2e.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2f.c: Likewise.\n\nFrom-SVN: r228821", "tree": {"sha": "868e460d297dff1b67349c10fe24300a8bbf8f16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/868e460d297dff1b67349c10fe24300a8bbf8f16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb1125df5370b6e29ddf9cb85b8c41a828796eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1125df5370b6e29ddf9cb85b8c41a828796eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb1125df5370b6e29ddf9cb85b8c41a828796eee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb1125df5370b6e29ddf9cb85b8c41a828796eee/comments", "author": null, "committer": null, "parents": [{"sha": "cb62081c07d971015fe6358f5c2b3b9dbcc34005", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb62081c07d971015fe6358f5c2b3b9dbcc34005", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb62081c07d971015fe6358f5c2b3b9dbcc34005"}], "stats": {"total": 302, "additions": 185, "deletions": 117}, "files": [{"sha": "f45ab81e5ca7a2e626125d9ed81e33a555e74a75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -1,5 +1,16 @@\n 2015-10-14  Jeff Law  <law@redhat.com>\n \n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2.c: Deleted.  The six functions\n+\tcontained within have their own file/test now.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2a.c: New test extracted from\n+\tssa-dom-thread-2.c.  Tighten expected output slightly and comment\n+\texpectations a bit more.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2b.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2c.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2d.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2e.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dom-thread-2f.c: Likewise.\n+\n         PR testsuite/67959\n \t* gcc.dg/tree-ssa/ssa-thread-13.c: Avoid bitfield assumptions.\n "}, {"sha": "bb697d16979ffa725040f0cce59d5edccc8d69d8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2.c", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb62081c07d971015fe6358f5c2b3b9dbcc34005/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb62081c07d971015fe6358f5c2b3b9dbcc34005/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2.c?ref=cb62081c07d971015fe6358f5c2b3b9dbcc34005", "patch": "@@ -1,117 +0,0 @@\n-/* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n-\n-void foo();\n-void bla();\n-void bar();\n-\n-/* In the following two cases, we should be able to thread edge through\n-   the loop header.  */\n-\n-void thread_entry_through_header (void)\n-{\n-  int i;\n-\n-  for (i = 0; i < 170; i++)\n-    bla ();\n-}\n-\n-void thread_latch_through_header (void)\n-{\n-  int i = 0;\n-  int first = 1;\n-\n-  do\n-    {\n-      if (first)\n-\tfoo ();\n-\n-      first = 0;\n-      bla ();\n-    } while (i++ < 100);\n-}\n-\n-/* This is a TODO -- it is correct to thread both entry and latch edge through\n-   the header, but we do not handle this case yet.  */\n-\n-void dont_thread_1 (void)\n-{\n-  int i = 0;\n-  int first = 1;\n-\n-  do\n-    {\n-      if (first)\n-\tfoo ();\n-      else\n-\tbar ();\n-\n-      first = 0;\n-      bla ();\n-    } while (i++ < 100);\n-}\n-\n-/* Avoid threading in the following two cases, to prevent creating subloops.  */\n-\n-void dont_thread_2 (int first)\n-{\n-  int i = 0;\n-\n-  do\n-    {\n-      if (first)\n-\tfoo ();\n-      else\n-\tbar ();\n-\n-      first = 0;\n-      bla ();\n-    } while (i++ < 100);\n-}\n-\n-void dont_thread_3 (int nfirst)\n-{\n-  int i = 0;\n-  int first = 0;\n-\n-  do\n-    {\n-      if (first)\n-\tfoo ();\n-      else\n-\tbar ();\n-\n-      first = nfirst;\n-      bla ();\n-    } while (i++ < 100);\n-}\n-\n-/* Avoid threading in this case, in order to avoid creating loop with\n-   multiple entries.  */\n-\n-void dont_thread_4 (int a, int nfirst)\n-{\n-  int i = 0;\n-  int first;\n-\n-  if (a)\n-    first = 0;\n-  else\n-    first = 1;\n-\n-  do\n-    {\n-      if (first)\n-\tfoo ();\n-      else\n-\tbar ();\n-\n-      first = nfirst;\n-      bla ();\n-    } while (i++ < 100);\n-}\n-\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 1 \"vrp1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 0 \"vrp1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 0 \"dom1\"} } */\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 1 \"dom1\"} } */"}, {"sha": "73d0ccf0cb4be0d6f3da917038b7b8c56c62f0ac", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2a.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2a.c?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void bla();\n+\n+/* In the following case, we should be able to thread edge through\n+   the loop header.  */\n+\n+void thread_entry_through_header (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 170; i++)\n+    bla ();\n+}\n+\n+/* There's a single jump thread that should be handled by the VRP\n+   jump threading pass.  */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 1 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 0 \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom1\"} } */"}, {"sha": "2f17517ea29975b55ce2da2e6efb7d695ee8c390", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2b.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void foo();\n+void bla();\n+\n+/* In the following case, we should be able to thread edge through\n+   the loop header.  */\n+\n+void thread_latch_through_header (void)\n+{\n+  int i = 0;\n+  int first = 1;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+\n+      first = 0;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* Threading the latch to a later point in the loop is safe in this\n+   case.  And we want to thread through the header as well.  These\n+   are both caught by threading in DOM.  */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 0 \"dom1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 2\" 1 \"dom1\"} } */"}, {"sha": "3a1f0d0ba6f3c0fb9230d9d6a4fe76c01512d894", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2c.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2c.c?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void foo();\n+void bla();\n+void bar();\n+\n+/* This is a TODO -- it is correct to thread both entry and latch edge through\n+   the header, but we do not handle this case yet.  */\n+\n+void dont_thread_1 (void)\n+{\n+  int i = 0;\n+  int first = 1;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = 0;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* In this case we can thread if and only if we thread through the\n+   header and around the latch.  If one is done without the other, then\n+   we create an irreducible CFG. */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom1\"} } */"}, {"sha": "5a4b7055884089d6111f8a74c30bc7a9fba1ea77", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2d.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2d.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2d.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2d.c?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void foo();\n+void bla();\n+void bar();\n+\n+/* Avoid threading in the following case, to prevent creating subloops.  */\n+\n+void dont_thread_2 (int first)\n+{\n+  int i = 0;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = 0;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* Peeling off the first iteration would make threading through\n+   the loop latch safe, but we don't do that currently.  */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom1\"} } */"}, {"sha": "e0c7738d057d18dab1ccd3d33c54cd083ea979dd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2e.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2e.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2e.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2e.c?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void foo();\n+void bla();\n+void bar();\n+\n+void dont_thread_3 (int nfirst)\n+{\n+  int i = 0;\n+  int first = 0;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = nfirst;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* Threading through the loop header is not safe here.  Peeling off\n+   the first iteration then unswitching the loop would be safe.  */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom1\"} } */"}, {"sha": "e278df01c0045958f380968ed2da6dfb7a6d7512", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2f.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2f.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb1125df5370b6e29ddf9cb85b8c41a828796eee/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2f.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2f.c?ref=bb1125df5370b6e29ddf9cb85b8c41a828796eee", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-vrp1-stats -fdump-tree-dom1-stats\" } */\n+\n+void foo();\n+void bla();\n+void bar();\n+\n+/* Avoid threading in this case, in order to avoid creating loop with\n+   multiple entries.  */\n+\n+void dont_thread_4 (int a, int nfirst)\n+{\n+  int i = 0;\n+  int first;\n+\n+  if (a)\n+    first = 0;\n+  else\n+    first = 1;\n+\n+  do\n+    {\n+      if (first)\n+\tfoo ();\n+      else\n+\tbar ();\n+\n+      first = nfirst;\n+      bla ();\n+    } while (i++ < 100);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"vrp1\"} } */\n+/* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom1\"} } */"}]}