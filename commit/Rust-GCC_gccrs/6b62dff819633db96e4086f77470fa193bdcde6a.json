{"sha": "6b62dff819633db96e4086f77470fa193bdcde6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI2MmRmZjgxOTYzM2RiOTZlNDA4NmY3NzQ3MGZhMTkzYmRjZGU2YQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2005-12-18T07:23:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2005-12-18T07:23:08Z"}, "message": "tree-ssa-dom.c (simplify_switch_and_lookup_avail_expr): Code to simplify SWITCH_EXPR_CODE moved from here to ...\n\n\n\t* tree-ssa-dom.c (simplify_switch_and_lookup_avail_expr): Code\n\tto simplify SWITCH_EXPR_CODE moved from here to ...\n\t* tree-ssa-forwprop.c (simplify_switch_expr): Here.\n\t(tree-ssa-forward_propagate_single_use_vars): Call\n\tsimplify_switch_expr when appropriate.\n\nFrom-SVN: r108738", "tree": {"sha": "5c3f58b68d6bf5311edde0b6c488a15485c73c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c3f58b68d6bf5311edde0b6c488a15485c73c46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b62dff819633db96e4086f77470fa193bdcde6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b62dff819633db96e4086f77470fa193bdcde6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b62dff819633db96e4086f77470fa193bdcde6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b62dff819633db96e4086f77470fa193bdcde6a/comments", "author": null, "committer": null, "parents": [{"sha": "a7ceba73e5af3733ab19ecf6cb3dec3c2c64a87a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7ceba73e5af3733ab19ecf6cb3dec3c2c64a87a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7ceba73e5af3733ab19ecf6cb3dec3c2c64a87a"}], "stats": {"total": 133, "additions": 68, "deletions": 65}, "files": [{"sha": "d30feed3cfdc8e89598fdfbb385b0a69da6d6833", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b62dff819633db96e4086f77470fa193bdcde6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b62dff819633db96e4086f77470fa193bdcde6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b62dff819633db96e4086f77470fa193bdcde6a", "patch": "@@ -1,3 +1,11 @@\n+2005-12-18  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (simplify_switch_and_lookup_avail_expr): Code\n+\tto simplify SWITCH_EXPR_CODE moved from here to ...\n+\t* tree-ssa-forwprop.c (simplify_switch_expr): Here.\n+\t(tree-ssa-forward_propagate_single_use_vars): Call\n+\tsimplify_switch_expr when appropriate.\n+\n 2005-12-17  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \t* doc/objc.texi (Type encoding): Add documentation about encoding"}, {"sha": "00659f3a6709ddd6f043ac14d5af0fc38df2084e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b62dff819633db96e4086f77470fa193bdcde6a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b62dff819633db96e4086f77470fa193bdcde6a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=6b62dff819633db96e4086f77470fa193bdcde6a", "patch": "@@ -274,7 +274,6 @@ static void record_cond (tree, tree);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n static tree simplify_cond_and_lookup_avail_expr (tree, stmt_ann_t, int);\n-static tree simplify_switch_and_lookup_avail_expr (tree, int);\n static tree find_equivalent_equality_comparison (tree);\n static void record_range (tree, basic_block);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n@@ -2120,67 +2119,6 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n   return 0;\n }\n \n-/* STMT is a SWITCH_EXPR for which we could not trivially determine its\n-   result.  This routine attempts to find equivalent forms of the\n-   condition which we may be able to optimize better.  */\n-\n-static tree\n-simplify_switch_and_lookup_avail_expr (tree stmt, int insert)\n-{\n-  tree cond = SWITCH_COND (stmt);\n-  tree def, to, ti;\n-\n-  /* The optimization that we really care about is removing unnecessary\n-     casts.  That will let us do much better in propagating the inferred\n-     constant at the switch target.  */\n-  if (TREE_CODE (cond) == SSA_NAME)\n-    {\n-      def = SSA_NAME_DEF_STMT (cond);\n-      if (TREE_CODE (def) == MODIFY_EXPR)\n-\t{\n-\t  def = TREE_OPERAND (def, 1);\n-\t  if (TREE_CODE (def) == NOP_EXPR)\n-\t    {\n-\t      int need_precision;\n-\t      bool fail;\n-\n-\t      def = TREE_OPERAND (def, 0);\n-\n-#ifdef ENABLE_CHECKING\n-\t      /* ??? Why was Jeff testing this?  We are gimple...  */\n-\t      gcc_assert (is_gimple_val (def));\n-#endif\n-\n-\t      to = TREE_TYPE (cond);\n-\t      ti = TREE_TYPE (def);\n-\n-\t      /* If we have an extension that preserves value, then we\n-\t\t can copy the source value into the switch.  */\n-\n-\t      need_precision = TYPE_PRECISION (ti);\n-\t      fail = false;\n-\t      if (TYPE_UNSIGNED (to) && !TYPE_UNSIGNED (ti))\n-\t\tfail = true;\n-\t      else if (!TYPE_UNSIGNED (to) && TYPE_UNSIGNED (ti))\n-\t\tneed_precision += 1;\n-\t      if (TYPE_PRECISION (to) < need_precision)\n-\t\tfail = true;\n-\n-\t      if (!fail)\n-\t\t{\n-\t\t  SWITCH_COND (stmt) = def;\n-\t\t  mark_stmt_modified (stmt);\n-\n-\t\t  return lookup_avail_expr (stmt, insert);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-\n /* CONST_AND_COPIES is a table which maps an SSA_NAME to the current\n    known value for that SSA_NAME (or NULL if no value is known).  \n \n@@ -2473,9 +2411,6 @@ eliminate_redundant_computations (tree stmt, stmt_ann_t ann)\n      the hash table, simplify the condition and try again.  */\n   if (! cached_lhs && TREE_CODE (stmt) == COND_EXPR)\n     cached_lhs = simplify_cond_and_lookup_avail_expr (stmt, ann, insert);\n-  /* Similarly for a SWITCH_EXPR.  */\n-  else if (!cached_lhs && TREE_CODE (stmt) == SWITCH_EXPR)\n-    cached_lhs = simplify_switch_and_lookup_avail_expr (stmt, insert);\n \n   opt_stats.num_exprs_considered++;\n "}, {"sha": "2d89494ca73906108da3160cfa41f81dea574b18", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b62dff819633db96e4086f77470fa193bdcde6a/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b62dff819633db96e4086f77470fa193bdcde6a/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=6b62dff819633db96e4086f77470fa193bdcde6a", "patch": "@@ -739,6 +739,61 @@ simplify_not_neg_expr (tree stmt)\n     }\n }\n \n+/* STMT is a SWITCH_EXPR for which we attempt to find equivalent forms of\n+   the condition which we may be able to optimize better.  */\n+\n+static void\n+simplify_switch_expr (tree stmt)\n+{\n+  tree cond = SWITCH_COND (stmt);\n+  tree def, to, ti;\n+\n+  /* The optimization that we really care about is removing unnecessary\n+     casts.  That will let us do much better in propagating the inferred\n+     constant at the switch target.  */\n+  if (TREE_CODE (cond) == SSA_NAME)\n+    {\n+      def = SSA_NAME_DEF_STMT (cond);\n+      if (TREE_CODE (def) == MODIFY_EXPR)\n+\t{\n+\t  def = TREE_OPERAND (def, 1);\n+\t  if (TREE_CODE (def) == NOP_EXPR)\n+\t    {\n+\t      int need_precision;\n+\t      bool fail;\n+\n+\t      def = TREE_OPERAND (def, 0);\n+\n+#ifdef ENABLE_CHECKING\n+\t      /* ??? Why was Jeff testing this?  We are gimple...  */\n+\t      gcc_assert (is_gimple_val (def));\n+#endif\n+\n+\t      to = TREE_TYPE (cond);\n+\t      ti = TREE_TYPE (def);\n+\n+\t      /* If we have an extension that preserves value, then we\n+\t\t can copy the source value into the switch.  */\n+\n+\t      need_precision = TYPE_PRECISION (ti);\n+\t      fail = false;\n+\t      if (TYPE_UNSIGNED (to) && !TYPE_UNSIGNED (ti))\n+\t\tfail = true;\n+\t      else if (!TYPE_UNSIGNED (to) && TYPE_UNSIGNED (ti))\n+\t\tneed_precision += 1;\n+\t      if (TYPE_PRECISION (to) < need_precision)\n+\t\tfail = true;\n+\n+\t      if (!fail)\n+\t\t{\n+\t\t  SWITCH_COND (stmt) = def;\n+\t\t  update_stmt (stmt);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Main entry point for the forward propagation optimizer.  */\n \n static void\n@@ -788,6 +843,11 @@ tree_ssa_forward_propagate_single_use_vars (void)\n \t      else\n \t\tbsi_next (&bsi);\n \t    }\n+\t  else if (TREE_CODE (stmt) == SWITCH_EXPR)\n+\t    {\n+\t      simplify_switch_expr (stmt);\n+\t      bsi_next (&bsi);\n+\t    }\n \t  else if (TREE_CODE (stmt) == COND_EXPR)\n \t    {\n \t      forward_propagate_into_cond (stmt);"}]}