{"sha": "15dc331ee63e6954f443a180978602c370a56af9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVkYzMzMWVlNjNlNjk1NGY0NDNhMTgwOTc4NjAyYzM3MGE1NmFmOQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-12T22:21:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-04-12T22:21:28Z"}, "message": "h8300.c (print_operand): Handle new 'R' case for accessing the 8-bit area.\n\n        * h8300/h8300.c (print_operand): Handle new 'R' case for accessing\n        the 8-bit area.  Make code for 'Y' fall into code for 'R' when\n        operand is not a register.  Update some comments.\n        (h8300_tiny_data_p): New function.\n        (h8300_valid_machine_decl_attribute): Handle \"tiny_data\" attribute.\n        * h8300/h8300.h (OK_FOR_U): Handle memory references into the\n        8-bit area.\n        (ENCODE_SECTION_INFO): Mark SYMBOL_REFs which refer to the 8-bit\n        area.\n        * h8300/h8300.md (many patterns): Use 'R' rather than 'X' for\n        operands that may be memory accesses into the 8-bit area.\n        (btst pattern): New pattern to set the cc0 (zbit) based on\n        data in the 8-bit area.\n\n        * h8300/h8300.md (one_cmplsi2): Fix length computation for h8300h.\n\nFrom-SVN: r11707", "tree": {"sha": "300ab9e653a1e8db416e4d3fb48fc4fa6c4cc2b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/300ab9e653a1e8db416e4d3fb48fc4fa6c4cc2b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15dc331ee63e6954f443a180978602c370a56af9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15dc331ee63e6954f443a180978602c370a56af9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15dc331ee63e6954f443a180978602c370a56af9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15dc331ee63e6954f443a180978602c370a56af9/comments", "author": null, "committer": null, "parents": [{"sha": "7f6ae52483134446bd577fa998a1438a1f339fbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f6ae52483134446bd577fa998a1438a1f339fbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f6ae52483134446bd577fa998a1438a1f339fbb"}], "stats": {"total": 162, "additions": 110, "deletions": 52}, "files": [{"sha": "062912b9f7ab0db48570306dee9a9c5fa2dc5c66", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dc331ee63e6954f443a180978602c370a56af9/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dc331ee63e6954f443a180978602c370a56af9/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=15dc331ee63e6954f443a180978602c370a56af9", "patch": "@@ -706,13 +706,16 @@ const_costs (r, c)\n    'L' fake label, changed after used twice.\n    'M' turn a 'M' constant into its negative mod 2.\n    'P' if operand is incing/decing sp, print .w, otherwise .b.\n+   'R' print operand as a byte:8 address if appropriate, else fall back to\n+       'X' handling.\n    'S' print operand as a long word\n    'T' print operand as a word\n    'U' if operand is incing/decing sp, print l, otherwise nothing.\n    'V' find the set bit, and print its number.\n    'W' find the clear bit, and print its number.\n    'X' print operand as a byte\n    'Y' print either l or h depending on whether last 'Z' operand < 8 or >= 8.\n+       If this operand isn't a register, fall back to 'R' handling.\n    'Z' print int & 7.\n    'b' print the bit opcode\n    'c' print the ibit opcode\n@@ -890,6 +893,7 @@ print_operand (file, x, code)\n \tabort ();\n       fprintf (file, \"#%d\", bitint & 7);\n       break;\n+    case 'R':\n     case 'X':\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s\", byte_reg (x, 0));\n@@ -902,7 +906,7 @@ print_operand (file, x, code)\n       if (GET_CODE (x) == REG)\n \tfprintf (file, \"%s%c\", names_big[REGNO (x)], bitint > 7 ? 'h' : 'l');\n       else\n-\tprint_operand (file, x, 0);\n+\tprint_operand (file, x, 'R');\n       bitint = -1;\n       break;\n     case 'Z':\n@@ -1081,6 +1085,13 @@ print_operand (file, x, code)\n \tcase MEM:\n \t  fprintf (file, \"@\");\n \t  output_address (XEXP (x, 0));\n+\n+\t  /* If this is an 'R' operand (reference into the 8-bit area),\n+\t     then specify a symbolic address as \"foo:8\".  */\n+ \t  if (code == 'R'\n+\t      && GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t      && SYMBOL_REF_FLAG (XEXP (x, 0)))\n+\t    fprintf (file, \":8\");\n \t  break;\n \n \tcase CONST_INT:\n@@ -2050,7 +2061,6 @@ fix_bit_operand (operands, what, type)\n   return 1;\n }\n \n-\n /* Return nonzero if FUNC is an interrupt function as specified\n    by the \"interrupt\" attribute.  */\n \n@@ -2083,6 +2093,22 @@ h8300_funcvec_function_p (func)\n   return a != NULL_TREE;\n }\n \n+/* Return nonzero if DECL is a variable that's in the tiny\n+   data area.  */\n+\n+int\n+h8300_tiny_data_p (decl)\n+     tree decl;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return 0;\n+\n+  a = lookup_attribute (\"tiny_data\", DECL_MACHINE_ATTRIBUTES (decl));\n+  return a != NULL_TREE;\n+}\n+\n /* Return nonzero if ATTR is a valid attribute for DECL.\n    ATTRIBUTES are any existing attributes and ARGS are the arguments\n    supplied with ATTR.\n@@ -2108,6 +2134,19 @@ h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n   if (is_attribute_p (\"interrupt_handler\", attr)\n       || is_attribute_p (\"function_vector\", attr))\n     return TREE_CODE (decl) == FUNCTION_DECL;\n+\n+  if (is_attribute_p (\"tiny_data\", attr)\n+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+    {\n+      if (DECL_INITIAL (decl) == NULL_TREE)\n+\t{\n+\t  warning (\"Only initialized variables can be placed into the 8-bit area.\");\n+\t  return 0;\n+\t}\n+      DECL_SECTION_NAME (decl) = build_string (8, \".eight\");\n+      return 1;\n+    }\n+      \n   return 0;\n }\n "}, {"sha": "c6d6b924fc12e58b1aab3a6d321803a1c4f1ae4c", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dc331ee63e6954f443a180978602c370a56af9/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dc331ee63e6954f443a180978602c370a56af9/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=15dc331ee63e6954f443a180978602c370a56af9", "patch": "@@ -790,11 +790,15 @@ struct rtx_def *function_arg();\n #endif\n \n /* Extra constraints - 'U' if for an operand valid for a bset\n-   destination; i.e. a register or register indirect target.  */\n+   destination; i.e. a register, register indirect, or the\n+   eightbit memory region (a SYMBOL_REF with the SYMBOL_REF_FLAG\n+   set.  */\n #define OK_FOR_U(OP) \\\n   ((GET_CODE (OP) == REG && REG_OK_FOR_BASE_P (OP)) \\\n    || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG \\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))) \n+       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))  \\\n+   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF \\\n+       && SYMBOL_REF_FLAG (XEXP (OP, 0))))\n  \n #define EXTRA_CONSTRAINT(OP, C) \\\n  ((C) == 'U' ? OK_FOR_U (OP) : 0)\n@@ -1085,8 +1089,11 @@ dtors_section() \t\t\t\t\t\t\\\n    through the function vector, the SYMBOL_REF_FLAG in the rtl\n    so the call patterns can generate the correct code.  */\n #define ENCODE_SECTION_INFO(DECL)  \\\n-  if (TREE_CODE (DECL) == FUNCTION_DECL \\\n-      && h8300_funcvec_function_p (DECL)) \\\n+  if ((TREE_CODE (DECL) == FUNCTION_DECL \\\n+       && h8300_funcvec_function_p (DECL)) \\\n+      || ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL)) \\\n+\t  && TREE_CODE (DECL) == VAR_DECL \\\n+\t  && h8300_tiny_data_p (DECL))) \\\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\n \n /* How to refer to registers in assembler output."}, {"sha": "ccd51b5db23d39001d9dca4a8e07c12b407fd644", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 58, "deletions": 46, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15dc331ee63e6954f443a180978602c370a56af9/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15dc331ee63e6954f443a180978602c370a56af9/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=15dc331ee63e6954f443a180978602c370a56af9", "patch": "@@ -38,7 +38,8 @@\n ;; Loading some 32bit integer constants could be done more\n ;; efficiently.  For example loading the value 4 as a 32bit\n ;; is normally done via mov.l #4,erX.  sub.l erX,erX, inc.l #4,erX \n-;; would be more efficient time and space-wise.\n+;; would be more efficient time and space-wise.  Similar sequences\n+;; can be found using bit-set insns dec, etc\n \n \n (define_attr \"type\" \"branch,return,call,arith,move,float,multi\"\n@@ -108,10 +109,10 @@\n    || register_operand (operands[1], QImode)\"\n   \"@\n    sub.b\t%X0,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\"\n+   mov.b\t%R1,%X0\n+   mov.b\t%X1,%R0\n+   mov.b\t%R1,%X0\n+   mov.b\t%X1,%R0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr_alternative \"length\"\n      [(const_int 2) (const_int 2) (const_int 2)\n@@ -140,7 +141,7 @@\n   \"@\n    sub.b\t%X0,%X0\n    mov.b\t%X1,%X0\n-   mov.b\t%X1,%X0\"\n+   mov.b\t%R1,%X0\"\n   [(set_attr \"type\" \"move\")\n    (set_attr_alternative \"length\"\n      [(const_int 2) (const_int 2)\n@@ -411,6 +412,15 @@\n ;; TEST INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+(define_insn \"\"\n+  [(set (cc0) (and:QI (match_operand:QI 0 \"bit_operand\" \"Ur\")\n+\t\t      (match_operand:QI 1 \"o_operand\" \"O\")))]\n+  \"\"\n+  \"btst %W1,%R0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set_zn_c0\")])\n+  \n (define_insn \"tstqi\"\n   [(set (cc0) (match_operand:QI 0 \"general_operand\" \"ra\"))]\n   \"\"\n@@ -778,7 +788,7 @@\n   \"register_operand (operands[0], QImode) || o_operand (operands[2], QImode)\"\n   \"@\n    and\t%X2,%X0\n-   bclr\t%W2,%X0\"\n+   bclr\t%W2,%R0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"set,none_0hit\")])\n@@ -843,7 +853,7 @@\n \t\t(match_operand:QI 2 \"nonmemory_operand\" \"P,rn\")))]\n   \"register_operand (operands[0], QImode) || p_operand (operands[2], QImode)\"\n   \"@\n-   bset\t%V2,%X0\n+   bset\t%V2,%R0\n    or\t%X2,%X0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"4,2\")\n@@ -936,7 +946,7 @@\n   \"register_operand (operands[0], QImode) || p_operand (operands[2], QImode)\"\n   \"@\n    xor\t%X2,%X0\n-   bnot\t%V2,%X0\"\n+   bnot\t%V2,%R0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"set,none_0hit\")])\n@@ -1099,9 +1109,12 @@\n     return \\\"not\t%S0\\\";\n }\"\n   [(set_attr \"type\" \"arith\")\n-;; ??? length is wrong for 300h\n-   (set_attr \"length\" \"8\")\n-   (set_attr \"cc\" \"clobber\")])\n+   (set_attr \"cc\" \"clobber\")\n+   (set (attr \"length\")\n+\t(if_then_else (eq (symbol_ref \"TARGET_H8300H\") (const_int 0))\n+\t\t      (const_int 8)\n+\t\t      (const_int 4)))])\n+\t\t\t\n \f\n ;; ----------------------------------------------------------------------\n ;; JUMP INSTRUCTIONS\n@@ -1230,7 +1243,6 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-;; ??? We don't take advantage of 16 bit relative jumps in the 300h.\n   \"*\n {\n   /* If we erroneously deleted a compare insn (which can happen if we need\n@@ -1389,14 +1401,14 @@\n     return \\\"mov.b\t#0,%t0\\\";\n \n   if (TARGET_H8300)\n-    return \\\"mov.b\t%X1,%s0\\;mov.b\t#0,%t0\\\";\n+    return \\\"mov.b\t%R1,%s0\\;mov.b\t#0,%t0\\\";\n   else\n     {\n       /* ??? See how often this gets optimized.  */\n       if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n \treturn \\\"extu.w\t%T0\\\";\n       else\n-\treturn \\\"mov.b\t%X1,%s0\\;extu.w\t%T0\\\";\n+\treturn \\\"mov.b\t%R1,%s0\\;extu.w\t%T0\\\";\n     }\n }\"\n   [(set_attr \"type\" \"multi\")\n@@ -1433,15 +1445,15 @@\n       if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n \treturn \\\"bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n       else\n-\treturn \\\"mov.b\t%X1,%s0\\;bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n+\treturn \\\"mov.b\t%R1,%s0\\;bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n     }\n   else\n     {\n       /* ??? See how often this gets optimized.  */\n       if (REG_P (operands[1]) && (REGNO (operands[1]) == REGNO (operands[0])))\n \treturn \\\"exts.w\t%T0\\\";\n       else\n-\treturn \\\"mov.b\t%X1,%s0\\;exts.w\t%T0\\\";\n+\treturn \\\"mov.b\t%R1,%s0\\;exts.w\t%T0\\\";\n     }\n }\"\n   [(set_attr \"type\" \"multi\")\n@@ -1690,11 +1702,11 @@\n {\n   output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n   if (get_attr_length (insn) == 2) \n-    return \\\"%d1\t%l0\\\";\n+    return \\\"b%d1\t%l0\\\";\n   else if (get_attr_length (insn) == 4) \n-    return \\\"%d1\t%l0:16\\\";\n+    return \\\"b%d1\t%l0:16\\\";\n   else\n-    return \\\"%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+    return \\\"b%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\" \n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -1714,11 +1726,11 @@\n {\n   output_asm_insn(\\\"bld\t%Z3,%Y2\\\", operands);\n   if (get_attr_length (insn) == 2) \n-    return \\\"%d1\t%l0\\\";\n+    return \\\"b%d1\t%l0\\\";\n   else if (get_attr_length (insn) == 4) \n-    return \\\"%d1\t%l0:16\\\";\n+    return \\\"b%d1\t%l0:16\\\";\n   else\n-    return \\\"%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+    return \\\"b%g1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n }\" \n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -1749,7 +1761,7 @@\n \t\t\t (const_int 1)\n \t\t\t (const_int 0)))]\n   \"\"\n-  \"bld\t#0,%X2\\;bst\t%Z1,%Y0 ; i1\")\n+  \"bld\t#0,%R2\\;bst\t%Z1,%Y0 ; i1\")\n \n ;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n ;; in combine.c, but there is no problem with writing it this way so we do.\n@@ -1772,7 +1784,7 @@\n \t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n \t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n   \"\"\n-  \"bld\t%Z2,%Y1\\;%b4\t#0,%X0\\;bst\t#0,%X0; bl1\")\n+  \"bld\t%Z2,%Y1\\;%b4\t#0,%R0\\;bst\t#0,%R0; bl1\")\n \n (define_insn \"bitlogical_1_hi\"\n   [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n@@ -1782,7 +1794,7 @@\n \t\t\t     (match_operand:HI 2 \"immediate_operand\" \"i\"))\n \t    (match_operand:HI 3 \"bit_operand\" \"0\")]))]\n   \"\"\n-  \"bld\t%Z2,%Y1\\;%b4\t#0,%X0\\;bst\t#0,%X0; bl2\")\n+  \"bld\t%Z2,%Y1\\;%b4\t#0,%R0\\;bst\t#0,%R0; bl2\")\n \n (define_insn \"bitlogical_2\"\n   [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n@@ -1794,7 +1806,7 @@\n \t\t\t     (const_int 1)\n \t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n   \"\"\n-  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%X0; bl3\")\n+  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\")\n \n (define_insn \"bitlogical_2_hi\"\n   [(set (match_operand:HI 0 \"bit_operand\" \"=Ur\")\n@@ -1806,7 +1818,7 @@\n \t\t\t     (const_int 1)\n \t\t\t     (match_operand:HI 4 \"immediate_operand\" \"i\"))]))]\n   \"\"\n-  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%X0; bl3\")\n+  \"bld\t%Z2,%Y1\\;%b5\t%Z4,%Y3\\;bst\t#0,%R0; bl3\")\n \n ;; This is how combine canonicalizes this pattern.  This is perhaps a bug\n ;; in combine.c, but there is no problem with writing it this way so we do.\n@@ -2091,7 +2103,7 @@\n \t\t\t    (subreg:QI (match_operand:HI 1 \"register_operand\" \"ri\") 0)) 0)\n \t\t(match_dup 0)))]\n   \"\"\n-  \"bset\t%X1,%X0\")\t\n+  \"bset\t%X1,%R0\")\t\n \n (define_insn \"fancybset\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n@@ -2100,7 +2112,7 @@\n \t\t\t    (match_operand:HI 1 \"nonmemory_operand\" \"ri\") ) 0)\n \t\t(match_operand:QI 2 \"general_operand\" \"Ur\")))]\n   \"\"\n-  \"mov.b\t%X2,%X0\\;bset\t%X1,%X0\")\t\n+  \"mov.b\t%R2,%R0\\;bset\t%X1,%R0\")\t\n \n (define_insn \"fancybclr4\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=Ur,Ur\")\n@@ -2112,8 +2124,8 @@\n    (clobber (match_scratch:HI 3 \"=X,&r\"))]\n   \"\"\n   \"@\n-   bclr\t%X2,%X0; l1\n-   mov.b\t%X1,%X3\\;mov.b\t%3,%0\\;bclr\t%X2,%X0; l3\")\n+   bclr\t%X2,%R0; l1\n+   mov.b\t%R1,%X3\\;mov.b\t%3,%0\\;bclr\t%X2,%R0; l3\")\n \n (define_insn \"fancybclr5\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=Ur,Ur\")\n@@ -2125,8 +2137,8 @@\n    (clobber (match_scratch:HI 3 \"=X,&r\"))]\n   \"\"\n   \"@\n-   bclr\t%X2,%X0; l1\n-   mov.b\t%X1,%X3\\;mov.b\t%3,%0\\;bclr\t%X2,%X0;l2\")\n+   bclr\t%X2,%R0; l1\n+   mov.b\t%R1,%X3\\;mov.b\t%3,%0\\;bclr\t%X2,%R0;l2\")\n \n (define_insn \"fancybclr2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=U,r\")\n@@ -2136,7 +2148,7 @@\n \t\t     (match_operand:HI 2 \"nonmemory_operand\" \"ri,ri\") ) 0)\n \t (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n   \"\"\n-  \"bclr\t%X2,%X0\")\n+  \"bclr\t%X2,%R0\")\n \n (define_insn \"fancybclr3\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=U,r\")\n@@ -2146,7 +2158,7 @@\n \t\t     (match_operand:QI 2 \"nonmemory_operand\" \"ri,ri\")) 0)\n \t (match_operand:QI 1 \"general_operand\" \"0,0\")))]\n   \"\"\n-  \"bclr\t%X2,%X0\")\n+  \"bclr\t%X2,%R0\")\n \n (define_insn \"fancybclr\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n@@ -2161,15 +2173,15 @@\n \t\t\t\t      (match_operand:QI 1 \"register_operand\" \"r\")) 0)\n \t\t(match_operand:QI 2 \"bit_operand\" \"0\")))]\n   \"\"\n-  \"bset\t%X1,%X0\")\n+  \"bset\t%X1,%R0\")\n \n (define_insn \"fancybsetp2\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=r,U\")\n \t(ior:QI (subreg:QI (ashift:HI (const_int 1)\n \t\t\t\t      (match_operand:QI 1 \"register_operand\" \"r,r\")) 0)\n \t\t(match_operand:QI 2 \"general_operand\" \"U,r\")))]\n   \"\"\n-  \"mov.b\t%X2,%X0\\;bset\t%X1,%X0\")\n+  \"mov.b\t%R2,%R0\\;bset\t%X1,%R0\")\n \t\n (define_insn \"fancybnot\"\n   [(set (match_operand:QI 0 \"bit_operand\" \"=Ur\")\n@@ -2178,7 +2190,7 @@\n \t\t(match_operand:QI 2 \"bit_operand\" \"0\")))]\n \n   \"\"\n-  \"bnot\t%X1,%X0\")\n+  \"bnot\t%X1,%R0\")\n \n (define_insn \"fancy_btst\"\n   [(set (pc)\n@@ -2192,11 +2204,11 @@\n   \"*\n {\n   if (get_attr_length (insn) == 2)\n-    return \\\"btst\t%X2,%X1\\;beq\t%l0\\\";\n+    return \\\"btst\t%X2,%R1\\;beq\t%l0\\\";\n   else if (get_attr_length (insn) == 4)\n-    return \\\"btst\t%X2,%X1\\;beq\t%l0:16\\\";\n+    return \\\"btst\t%X2,%R1\\;beq\t%l0:16\\\";\n   else\n-    return \\\"btst\t%X2,%X1\\;bne\t%L1\\;jmp\t@%l0\\;%L1:\\\";\n+    return \\\"btst\t%X2,%R1\\;bne\t%L1\\;jmp\t@%l0\\;%L1:\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -2213,11 +2225,11 @@\n   \"*\n {\n   if (get_attr_length (insn) == 2)\n-    return \\\"btst\t%X2,%X1\\;bne\t%l0\\\";\n+    return \\\"btst\t%X2,%R1\\;bne\t%l0\\\";\n   else if (get_attr_length (insn) == 4)\n-    return \\\"btst\t%X2,%X1\\;bne\t%l0:16\\\";\n+    return \\\"btst\t%X2,%R1\\;bne\t%l0:16\\\";\n   else\n-    return \\\"btst\t%X2,%X1\\;beq\t%L1\\;jmp\t@%l0\\;%L1:\\\";\n+    return \\\"btst\t%X2,%R1\\;beq\t%L1\\;jmp\t@%l0\\;%L1:\\\";\n }\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n@@ -2229,7 +2241,7 @@\n \t(and:QI (not:QI (match_operand:QI 2 \"bit_operand\" \"r,U\"))\n \t\t\t(const_int 1)))]\n   \"\"\n-  \"bld\t#0,%X2\\;bist\t%1,%0\"\n+  \"bld\t#0,%R2\\;bist\t%1,%0\"\n   [(set_attr \"type\" \"arith\")\n    (set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"clobber\")])"}]}