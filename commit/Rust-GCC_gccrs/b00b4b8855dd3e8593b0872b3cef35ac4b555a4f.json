{"sha": "b00b4b8855dd3e8593b0872b3cef35ac4b555a4f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAwYjRiODg1NWRkM2U4NTkzYjA4NzJiM2NlZjM1YWM0YjU1NWE0Zg==", "commit": {"author": {"name": "Peter Gerwinski", "email": "peter@gerwinski.de", "date": "2003-12-05T10:36:22Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-12-05T10:36:22Z"}, "message": "* tree.def (PLACEHOLDER_EXPR): Clarify commentary.\n\nFrom-SVN: r74322", "tree": {"sha": "c3e76ba10d860d83944fbe9eed9338233512b8c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3e76ba10d860d83944fbe9eed9338233512b8c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f/comments", "author": null, "committer": null, "parents": [{"sha": "5b4994bc7605b15cda980714cb4b9db3ad1f3771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b4994bc7605b15cda980714cb4b9db3ad1f3771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b4994bc7605b15cda980714cb4b9db3ad1f3771"}], "stats": {"total": 18, "additions": 16, "deletions": 2}, "files": [{"sha": "f78a8346d11b278c7daddab0badf16b1e0786be1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b00b4b8855dd3e8593b0872b3cef35ac4b555a4f", "patch": "@@ -1,3 +1,7 @@\n+2003-12-05  Peter Gerwinski <peter@gerwinski.de>\n+\n+        * tree.def (PLACEHOLDER_EXPR): Clarify commentary.\n+\n 2003-12-05  Steven Bosscher  <stevenb@suse.de>\n \n \t* config/d30v/d30v-protos.h , config/d30v/d30v.c,"}, {"sha": "79bb63e220a636641fac0ba9b12ed319668f493d", "filename": "gcc/tree.def", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b00b4b8855dd3e8593b0872b3cef35ac4b555a4f/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=b00b4b8855dd3e8593b0872b3cef35ac4b555a4f", "patch": "@@ -509,7 +509,8 @@ DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n    some field in an object of the type contains a value that is used in\n    the computation of another field's offset or size and/or the size of\n    the type.  The positions and/or sizes of fields can vary from object\n-   to object of the same type.\n+   to object of the same type or even for one and the same object within\n+   its scope.\n \n    Record types with discriminants in Ada or schema types in Pascal are\n    examples of such types.  This mechanism is also used to create \"fat\n@@ -533,7 +534,16 @@ DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n    For example, if your type FOO is a RECORD_TYPE with a field BAR,\n    and you need the value of <variable>.BAR to calculate TYPE_SIZE\n    (FOO), just substitute <variable> above with a PLACEHOLDER_EXPR\n-   what contains both the expression we wish to\n+   whose TREE_TYPE is FOO.  Then construct your COMPONENT_REF with\n+   the PLACEHOLDER_EXPR as the first operand (which has the correct\n+   type).  Later, when the size is needed in the program, the back-end\n+   will find this PLACEHOLDER_EXPR and generate code to calculate the\n+   actual size at run-time.  In the following, we describe how this\n+   calculation is done.\n+\n+   When we wish to evaluate a size or offset, we check whether it\n+   contains a PLACEHOLDER_EXPR.  If it does, we construct a\n+   WITH_RECORD_EXPR that contains both the expression we wish to\n    evaluate and an expression within which the object may be found.\n    The latter expression is the object itself in the simple case of an\n    Ada record with discriminant, but it can be the array in the case of"}]}