{"sha": "0e3f022139a75b2dc2fc537909ac7622f4fdbfcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUzZjAyMjEzOWE3NWIyZGMyZmM1Mzc5MDlhYzc2MjJmNGZkYmZjYg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-06-01T20:03:08Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2002-06-01T20:03:08Z"}, "message": "gcse.c (cprop_cc0_jump): Function deleted.\n\n\n\t* gcse.c (cprop_cc0_jump): Function deleted.\n\t(cprop_jump): Take an additional argument which is the possibly\n\tNULL cc setting insn immediately before the conditional jump.\n\tWhen a MODE_CC set is present, substitute it into the JUMP_INSN\n\tbefore attempting the constant propagation.\n\t(cprop_insn):  Recognize cc setters followed by conditional jumps\n\tas a special case.   Use cprop_jump instead of cprop_cc0_jump.\n\t(cprop_one_pass):  Call bypass_conditional_jumps if altering jumps.\n\t(find_bypass_set): New function based upon find_avail_set used by\n\tcprop, but finds constant expressions available at the end of\n\tbasic blocks.\n\t(bypass_block): New function.  Given a basic block that begins\n\twith a conditional jump and multiple incoming edges, perform\n\tthe jump bypass optimization.\n\t(bypass_conditional_jumps): New function.  Call bypass_block with\n\teach suitable basic block in the CFG using a simple single pass.\n\nFrom-SVN: r54152", "tree": {"sha": "236ae5725e2efc8064604b35e16d87ae4b091b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/236ae5725e2efc8064604b35e16d87ae4b091b29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb/comments", "author": null, "committer": null, "parents": [{"sha": "378393da613d7c182ce3370696ec47a5a5cb2aef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/378393da613d7c182ce3370696ec47a5a5cb2aef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/378393da613d7c182ce3370696ec47a5a5cb2aef"}], "stats": {"total": 352, "additions": 284, "deletions": 68}, "files": [{"sha": "9758865150717f82dcafb917519096d4fbded72a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e3f022139a75b2dc2fc537909ac7622f4fdbfcb", "patch": "@@ -1,3 +1,22 @@\n+2002-06-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcse.c (cprop_cc0_jump): Function deleted.\n+\t(cprop_jump): Take an additional argument which is the possibly\n+\tNULL cc setting insn immediately before the conditional jump.\n+\tWhen a MODE_CC set is present, substitute it into the JUMP_INSN\n+\tbefore attempting the constant propagation.\n+\t(cprop_insn):  Recognize cc setters followed by conditional jumps\n+\tas a special case.   Use cprop_jump instead of cprop_cc0_jump.\n+\t(cprop_one_pass):  Call bypass_conditional_jumps if altering jumps.\n+\t(find_bypass_set): New function based upon find_avail_set used by\n+\tcprop, but finds constant expressions available at the end of\n+\tbasic blocks.\n+\t(bypass_block): New function.  Given a basic block that begins\n+\twith a conditional jump and multiple incoming edges, perform\n+\tthe jump bypass optimization.\n+\t(bypass_conditional_jumps): New function.  Call bypass_block with\n+\teach suitable basic block in the CFG using a simple single pass.\n+\n 2002-06-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* tree.c (real_minus_onep): New function to test for -1.0."}, {"sha": "ae00a260ea5068c31456fda8408a015c857837a8", "filename": "gcc/gcse.c", "status": "modified", "additions": 265, "deletions": 68, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e3f022139a75b2dc2fc537909ac7622f4fdbfcb/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0e3f022139a75b2dc2fc537909ac7622f4fdbfcb", "patch": "@@ -609,16 +609,16 @@ static void compute_cprop_data\tPARAMS ((void));\n static void find_used_regs\tPARAMS ((rtx *, void *));\n static int try_replace_reg\tPARAMS ((rtx, rtx, rtx));\n static struct expr *find_avail_set PARAMS ((int, rtx));\n-static int cprop_jump\t\tPARAMS ((basic_block, rtx, rtx, rtx));\n-#ifdef HAVE_cc0\n-static int cprop_cc0_jump\tPARAMS ((basic_block, rtx, struct reg_use *, rtx));\n-#endif\n+static int cprop_jump\t\tPARAMS ((basic_block, rtx, rtx, rtx, rtx));\n static void mems_conflict_for_gcse_p PARAMS ((rtx, rtx, void *));\n static int load_killed_in_block_p    PARAMS ((basic_block, int, rtx, int));\n static void canon_list_insert        PARAMS ((rtx, rtx, void *));\n static int cprop_insn\t\tPARAMS ((basic_block, rtx, int));\n static int cprop\t\tPARAMS ((int));\n static int one_cprop_pass\tPARAMS ((int, int));\n+static struct expr *find_bypass_set PARAMS ((int, int));\n+static int bypass_block\t\t    PARAMS ((basic_block, rtx, rtx));\n+static int bypass_conditional_jumps PARAMS ((void));\n static void alloc_pre_mem\tPARAMS ((int, int));\n static void free_pre_mem\tPARAMS ((void));\n static void compute_pre_data\tPARAMS ((void));\n@@ -4077,48 +4077,68 @@ find_avail_set (regno, insn)\n }\n \n /* Subroutine of cprop_insn that tries to propagate constants into\n-   JUMP_INSNS.  INSN must be a conditional jump.  FROM is what we will try to\n-   replace, SRC is the constant we will try to substitute for it.  Returns\n-   nonzero if a change was made.  We know INSN has just a SET.  */\n+   JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL\n+   it is the instruction that immediately preceeds JUMP, and must be a\n+   single SET of a CC_MODE register.  FROM is what we will try to replace,\n+   SRC is the constant we will try to substitute for it.  Returns nonzero\n+   if a change was made. */\n \n static int\n-cprop_jump (bb, insn, from, src)\n-     rtx insn;\n+cprop_jump (bb, setcc, jump, from, src)\n+     basic_block bb;\n+     rtx setcc;\n+     rtx jump;\n      rtx from;\n      rtx src;\n-     basic_block bb;\n {\n-  rtx set = PATTERN (insn);\n-  rtx new = simplify_replace_rtx (SET_SRC (set), from, src);\n+  rtx new, new_set;\n+  rtx set = pc_set (jump);\n+\n+  /* First substitute in the INSN condition as the SET_SRC of the JUMP,\n+     then substitute that given values in this expanded JUMP.  */\n+  if (setcc != NULL)\n+    new_set = simplify_replace_rtx (SET_SRC (set),\n+\t\t\t\t    SET_DEST (PATTERN (setcc)),\n+\t\t\t\t    SET_SRC (PATTERN (setcc)));\n+  else\n+    new_set = set;\n+\n+  new = simplify_replace_rtx (new_set, from, src);\n \n   /* If no simplification can be made, then try the next\n      register.  */\n-  if (rtx_equal_p (new, SET_SRC (set)))\n+  if (rtx_equal_p (new, new_set))\n     return 0;\n  \n   /* If this is now a no-op delete it, otherwise this must be a valid insn.  */\n   if (new == pc_rtx)\n-    delete_insn (insn);\n+    delete_insn (jump);\n   else\n     {\n-      if (! validate_change (insn, &SET_SRC (set), new, 0))\n+      if (! validate_change (jump, &SET_SRC (set), new, 0))\n \treturn 0;\n \n       /* If this has turned into an unconditional jump,\n \t then put a barrier after it so that the unreachable\n \t code will be deleted.  */\n       if (GET_CODE (SET_SRC (set)) == LABEL_REF)\n-\temit_barrier_after (insn);\n+\temit_barrier_after (jump);\n      }\n \n+#ifdef HAVE_cc0\n+  /* Delete the cc0 setter.  */\n+  if (setcc != NULL && SET_DEST (PATTERN (setcc)) == cc0_rtx)\n+    delete_insn (setcc);\n+#endif\n+\n   run_jump_opt_after_gcse = 1;\n \n   const_prop_count++;\n   if (gcse_file != NULL)\n     {\n       fprintf (gcse_file,\n \t       \"CONST-PROP: Replacing reg %d in insn %d with constant \",\n-\t       REGNO (from), INSN_UID (insn));\n+\t       REGNO (from), INSN_UID (jump));\n       print_rtl (gcse_file, src);\n       fprintf (gcse_file, \"\\n\");\n     }\n@@ -4127,37 +4147,6 @@ cprop_jump (bb, insn, from, src)\n   return 1;\n }\n \n-#ifdef HAVE_cc0\n-\n-/* Subroutine of cprop_insn that tries to propagate constants into JUMP_INSNS\n-   for machines that have CC0.  INSN is a single set that stores into CC0;\n-   the insn following it is a conditional jump.  REG_USED is the use we will\n-   try to replace, SRC is the constant we will try to substitute for it.\n-   Returns nonzero if a change was made.  */\n-\n-static int\n-cprop_cc0_jump (bb, insn, reg_used, src)\n-     basic_block bb;\n-     rtx insn;\n-     struct reg_use *reg_used;\n-     rtx src;\n-{\n-  /* First substitute in the SET_SRC of INSN, then substitute that for\n-     CC0 in JUMP.  */\n-  rtx jump = NEXT_INSN (insn);\n-  rtx new_src = simplify_replace_rtx (SET_SRC (PATTERN (insn)),\n-\t\t\t\t      reg_used->reg_rtx, src);\n-\n-  if (! cprop_jump (bb, jump, cc0_rtx, new_src))\n-    return 0;\n-\n-  /* If we succeeded, delete the cc0 setter.  */\n-  delete_insn (insn);\n-\n-  return 1;\n-}\n-#endif\n- \n /* Perform constant and copy propagation on INSN.\n    The result is non-zero if a change was made.  */\n \n@@ -4216,7 +4205,27 @@ cprop_insn (bb, insn, alter_jumps)\n       /* Constant propagation.  */\n       if (CONSTANT_P (src))\n \t{\n-\t  /* Handle normal insns first.  */\n+\t  /* Check for MODE_CC setting instructions followed by\n+\t     conditional branch instructions first.  */\n+\t  if (alter_jumps\n+\t      && single_set (insn)\n+\t      && any_condjump_p (NEXT_INSN (insn))\n+              && onlyjump_p (NEXT_INSN (insn)))\n+\t    {\n+\t      rtx dest = SET_DEST (PATTERN (insn));\n+\t      if ((GET_MODE_CLASS (GET_MODE (dest)) == MODE_CC\n+#ifdef HAVE_cc0\n+\t\t   || dest == cc0_rtx\n+#endif\n+\t\t  ) && cprop_jump (bb, insn, NEXT_INSN (insn),\n+\t\t\t\t   reg_used->reg_rtx, src))\n+\t\t{\n+\t\t  changed = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  /* Handle normal insns next.  */\n \t  if (GET_CODE (insn) == INSN\n \t      && try_replace_reg (reg_used->reg_rtx, src, insn))\n \t    {\n@@ -4243,26 +4252,10 @@ cprop_insn (bb, insn, alter_jumps)\n \t     Right now the insn in question must look like\n \t     (set (pc) (if_then_else ...))  */\n \t  else if (alter_jumps\n-\t\t   && GET_CODE (insn) == JUMP_INSN\n-\t\t   && condjump_p (insn)\n-\t\t   && ! simplejump_p (insn))\n-\t    changed |= cprop_jump (bb, insn, reg_used->reg_rtx, src);\n+\t\t   && any_condjump_p (insn)\n+\t\t   && onlyjump_p (insn))\n+\t    changed |= cprop_jump (bb, NULL, insn, reg_used->reg_rtx, src);\n \n-#ifdef HAVE_cc0\n-\t  /* Similar code for machines that use a pair of CC0 setter and\n-\t     conditional jump insn.  */\n-\t  else if (alter_jumps\n-\t\t   && GET_CODE (PATTERN (insn)) == SET\n-\t\t   && SET_DEST (PATTERN (insn)) == cc0_rtx\n-\t\t   && GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t\t   && condjump_p (NEXT_INSN (insn))\n-\t\t   && ! simplejump_p (NEXT_INSN (insn))\n-\t\t   && cprop_cc0_jump (bb, insn, reg_used, src))\n-\t    {\n-\t      changed = 1;\n-\t      break;\n-\t    }\n-#endif\n \t}\n       else if (GET_CODE (src) == REG\n \t       && REGNO (src) >= FIRST_PSEUDO_REGISTER\n@@ -4362,6 +4355,8 @@ one_cprop_pass (pass, alter_jumps)\n       alloc_cprop_mem (last_basic_block, n_sets);\n       compute_cprop_data ();\n       changed = cprop (alter_jumps);\n+      if (alter_jumps)\n+\tchanged |= bypass_conditional_jumps ();\n       free_cprop_mem ();\n     }\n \n@@ -4378,6 +4373,208 @@ one_cprop_pass (pass, alter_jumps)\n   return changed;\n }\n \f\n+/* Bypass conditional jumps.  */\n+\n+/* Find a set of REGNO to a constant that is available at the end of basic\n+   block BB.  Returns NULL if no such set is found.  Based heavily upon\n+   find_avail_set.  */\n+\n+static struct expr *\n+find_bypass_set (regno, bb)\n+     int regno;\n+     int bb;\n+{\n+  struct expr *result = 0;\n+\n+  for (;;)\n+    {\n+      rtx src;\n+      struct expr *set = lookup_set (regno, NULL_RTX);\n+\n+      while (set)\n+\t{\n+\t  if (TEST_BIT (cprop_avout[bb], set->bitmap_index))\n+\t    break;\n+\t  set = next_set (regno, set);\n+\t}\n+\n+      if (set == 0)\n+\tbreak;\n+\n+      if (GET_CODE (set->expr) != SET)\n+\tabort ();\n+\n+      src = SET_SRC (set->expr);\n+      if (CONSTANT_P (src))\n+\tresult = set;\n+\n+      if (GET_CODE (src) != REG)\n+\tbreak;\n+\n+      regno = REGNO (src);\n+    }\n+  return result;\n+}\n+\n+\n+/* Subroutine of bypass_conditional_jumps that attempts to bypass the given\n+   basic block BB which has more than one predecessor.  If not NULL, SETCC\n+   is the first instruction of BB, which is immediately followed by JUMP_INSN\n+   JUMP.  Otherwise, SETCC is NULL, and JUMP is the first insn of BB.\n+   Returns nonzero if a change was made.  */\n+\n+static int\n+bypass_block (bb, setcc, jump)\n+     basic_block bb;\n+     rtx setcc, jump;\n+{\n+  rtx insn, note;\n+  edge e, enext;\n+  int i,change;\n+\n+  insn = (setcc != NULL) ? setcc : jump;\n+\n+  /* Determine set of register uses in INSN.  */\n+  reg_use_count = 0;\n+  note_uses (&PATTERN (insn), find_used_regs, NULL);\n+  note = find_reg_equal_equiv_note (insn);\n+  if (note)\n+    find_used_regs (&XEXP (note, 0), NULL);\n+\n+  change = 0;\n+  for (e = bb->pred; e; e = enext)\n+    {\n+      enext = e->pred_next;\n+      for (i = 0; i < reg_use_count; i++)\n+\t{\n+\t  struct reg_use *reg_used = &reg_use_table[i];\n+          unsigned int regno = REGNO (reg_used->reg_rtx);\n+\t  basic_block dest;\n+          struct expr *set;\n+          rtx src, new;\n+\n+          if (regno >= max_gcse_regno)\n+            continue;\n+\n+          set = find_bypass_set (regno, e->src->index);\n+\n+\t  if (! set)\n+\t    continue;\n+\n+          src = SET_SRC (pc_set (jump));\n+\n+\t  if (setcc != NULL)\n+\t      src = simplify_replace_rtx (src,\n+                                          SET_DEST (PATTERN (setcc)),\n+                                          SET_SRC (PATTERN (setcc)));\n+\n+\t  new = simplify_replace_rtx (src, reg_used->reg_rtx,\n+                                      SET_SRC (set->expr));\n+\n+          if (new == pc_rtx)\n+\t    dest = FALLTHRU_EDGE (bb)->dest;\n+\t  else if (GET_CODE (new) == LABEL_REF)\n+\t    dest = BRANCH_EDGE (bb)->dest;\n+\t  else\n+\t    dest = NULL;\n+\n+\t  /* Once basic block indices are stable, we should be able\n+\t     to use redirect_edge_and_branch_force instead.  */\n+\t  if ((dest != NULL) && (dest != e->dest)\n+\t      && redirect_edge_and_branch (e, dest))\n+\t    {\n+\t      /* Copy the MODE_CC setter to the redirected edge.\n+\t\t Don't copy CC0 setters, as CC0 is dead after jump.  */\n+\t      if (setcc)\n+\t\t{\n+\t\t  rtx pat = PATTERN (setcc);\n+\t\t  if (GET_MODE_CLASS (GET_MODE (SET_DEST (pat))) == MODE_CC)\n+\t\t    insert_insn_on_edge (copy_insn (pat), e);\n+\t\t}\n+\n+\t      if (gcse_file != NULL)\n+\t\t{\n+\t\t  fprintf (gcse_file, \"JUMP-BYPASS: Replacing reg %d in \",\n+\t\t\t   regno);\n+\t\t  fprintf (gcse_file, \"insn %d with constant \",\n+\t\t\t   INSN_UID (jump));\n+\t\t  print_rtl (gcse_file, SET_SRC (set->expr));\n+\t\t  fprintf (gcse_file, \"\\nBypass edge from %d->%d to %d\\n\",\n+\t\t\t   e->src->index, e->dest->index, dest->index);\n+\t\t}\n+\t      change = 1;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return change;\n+}\n+\n+/* Find basic blocks with more than one predecessor that only contain a\n+   single conditional jump.  If the result of the comparison is known at\n+   compile-time from any incoming edge, redirect that edge to the\n+   appropriate target.  Returns nonzero if a change was made.  */\n+\n+static int\n+bypass_conditional_jumps ()\n+{\n+  basic_block bb;\n+  int changed;\n+  rtx setcc;\n+  rtx insn;\n+  rtx dest;\n+\n+  /* Note we start at block 1.  */\n+  if (ENTRY_BLOCK_PTR->next_bb == EXIT_BLOCK_PTR)\n+    return 0;\n+\n+  changed = 0;\n+  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR->next_bb->next_bb,\n+                  EXIT_BLOCK_PTR, next_bb)\n+    {\n+      /* Check for more than one predecessor.  */\n+      if (bb->pred && bb->pred->pred_next)\n+\t{\n+\t  setcc = NULL_RTX;\n+\t  for (insn = bb->head;\n+\t       insn != NULL && insn != NEXT_INSN (bb->end);\n+\t       insn = NEXT_INSN (insn))\n+\t    if (GET_CODE (insn) == INSN)\n+\t      {\n+\t\tif (setcc)\n+\t\t  break;\n+\t\tif (!single_set (insn))\n+\t\t  break;\n+\n+\t\tdest = SET_DEST (PATTERN (insn));\n+\t\tif (GET_MODE_CLASS (GET_MODE (dest)) == MODE_CC)\n+\t\t  setcc = insn;\n+#ifdef HAVE_cc0\n+\t\telse if (dest == cc0_rtx)\n+\t\t  setcc = insn;\n+#endif\n+\t\telse\n+\t\t  break;\n+\t      }\n+\t    else if (GET_CODE (insn) == JUMP_INSN)\n+\t      {\n+\t\tif (any_condjump_p (insn) && onlyjump_p (insn))\n+\t\t  changed |= bypass_block (bb, setcc, insn);\n+\t\tbreak;\n+\t      }\n+\t    else if (INSN_P (insn))\n+\t      break;\n+\t}\n+    }\n+\n+  /* If we bypassed any MODE_CC setting insns, we inserted a\n+     copy on the redirected edge.  These need to be commited.  */\n+  if (changed)\n+    commit_edge_insertions();\n+\n+  return changed;\n+}\n+\f\n /* Compute PRE+LCM working variables.  */\n \n /* Local properties of expressions.  */"}]}