{"sha": "31de760604065cf4dae5de8828321c86b15bf3c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkZTc2MDYwNDA2NWNmNGRhZTVkZTg4MjgzMjFjODZiMTViZjNjOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-02-14T18:42:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-02-14T18:42:49Z"}, "message": "ipa-chkp.c: Use iterate_direct_aliases.\n\n\n\t* ipa-chkp.c: Use iterate_direct_aliases.\n\t* symtab.c (resolution_used_from_other_file_p): Move inline.\n\t(symtab_node::create_reference): Fix formating.\n\t(symtab_node::has_aliases_p): Move inline; use iterate_direct_aliases.\n\t(symtab_node::iterate_reference): Move inline.\n\t(symtab_node::iterate_referring): Move inline.\n\t(symtab_node::iterate_direct_aliases): Move inline.\n\t(symtab_node::used_from_object_file_p_worker): Inline into ...\n\t(symtab_node::used_from_object_file_p): ... this one; move inline.\n\t(symtab_node::call_for_symbol_and_aliases): Move inline;\n\tuse iterate_direct_aliases.\n\t(symtab_node::call_for_symbol_and_aliases_1): New method.\n\t(cgraph_node::call_for_symbol_and_aliases): Move inline;\n\tuse iterate_direct_aliases.\n\t(cgraph_node::call_for_symbol_and_aliases_1): New method.\n\t(varpool_node::call_for_node_and_aliases): Rename to ...\n\t(varpool_node::call_for_symbol_and_aliases): ... this one; Move inline;\n\tuse iterate_direct_aliases.\n\t(varpool_node::call_for_symbol_and_aliases_1): New method.\n\t* ipa.c (ipa_single_use): Use iterate_direct_aliases.\n\t(ipa_discover_readonly_nonaddressable_var): Update.\n\t* ipa-devirt.c: Fix formating.\n\t* cgraph.c (cgraph_node::can_remove_if_no_direct_calls_and_refs_p):\n\tMove inline.\n\t(cgraph_node::call_for_symbol_and_aliases): Move inline.\n\t(cgraph_node::call_for_symbol_and_aliases_1): New function..\n\t* cgraph.h (used_from_object_file_p_worker): Remove.\n\t(resolution_used_from_other_file_p): Move inline.\n\t(symtab_node::has_aliases_p): Move inline; use iterate_direct_aliases.\n\t(symtab_node::iterate_reference): Move inline.\n\t(symtab_node::iterate_referring): Move inline.\n\t(symtab_node::iterate_direct_aliases): Move inline.\n\t(symtab_node::used_from_object_file_p_worker): Inline into ...\n\t(symtab_node::used_from_object_file_p): Move inline.\n\t* tree-emutls.c (ipa_lower_emutls): Update.\n\t* varpool.c (varpool_node::call_for_symbol_and_aliases_1): New method.\n\t(varpool_node::call_for_node_and_aliases): Remove.\n\nFrom-SVN: r220709", "tree": {"sha": "400f48e176f588602e37c0b5ff58c528a2855b16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/400f48e176f588602e37c0b5ff58c528a2855b16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31de760604065cf4dae5de8828321c86b15bf3c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de760604065cf4dae5de8828321c86b15bf3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31de760604065cf4dae5de8828321c86b15bf3c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31de760604065cf4dae5de8828321c86b15bf3c9/comments", "author": null, "committer": null, "parents": [{"sha": "065d214ce4129853330cb0c992b981830c950909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/065d214ce4129853330cb0c992b981830c950909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/065d214ce4129853330cb0c992b981830c950909"}], "stats": {"total": 574, "additions": 338, "deletions": 236}, "files": [{"sha": "43c0e34877c84a708ac8c50a81451097c55b52b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -1,3 +1,43 @@\n+2015-02-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-chkp.c: Use iterate_direct_aliases.\n+\t* symtab.c (resolution_used_from_other_file_p): Move inline.\n+\t(symtab_node::create_reference): Fix formating.\n+\t(symtab_node::has_aliases_p): Move inline; use iterate_direct_aliases.\n+\t(symtab_node::iterate_reference): Move inline.\n+\t(symtab_node::iterate_referring): Move inline.\n+\t(symtab_node::iterate_direct_aliases): Move inline.\n+\t(symtab_node::used_from_object_file_p_worker): Inline into ...\n+\t(symtab_node::used_from_object_file_p): ... this one; move inline.\n+\t(symtab_node::call_for_symbol_and_aliases): Move inline;\n+\tuse iterate_direct_aliases.\n+\t(symtab_node::call_for_symbol_and_aliases_1): New method.\n+\t(cgraph_node::call_for_symbol_and_aliases): Move inline;\n+\tuse iterate_direct_aliases.\n+\t(cgraph_node::call_for_symbol_and_aliases_1): New method.\n+\t(varpool_node::call_for_node_and_aliases): Rename to ...\n+\t(varpool_node::call_for_symbol_and_aliases): ... this one; Move inline;\n+\tuse iterate_direct_aliases.\n+\t(varpool_node::call_for_symbol_and_aliases_1): New method.\n+\t* ipa.c (ipa_single_use): Use iterate_direct_aliases.\n+\t(ipa_discover_readonly_nonaddressable_var): Update.\n+\t* ipa-devirt.c: Fix formating.\n+\t* cgraph.c (cgraph_node::can_remove_if_no_direct_calls_and_refs_p):\n+\tMove inline.\n+\t(cgraph_node::call_for_symbol_and_aliases): Move inline.\n+\t(cgraph_node::call_for_symbol_and_aliases_1): New function..\n+\t* cgraph.h (used_from_object_file_p_worker): Remove.\n+\t(resolution_used_from_other_file_p): Move inline.\n+\t(symtab_node::has_aliases_p): Move inline; use iterate_direct_aliases.\n+\t(symtab_node::iterate_reference): Move inline.\n+\t(symtab_node::iterate_referring): Move inline.\n+\t(symtab_node::iterate_direct_aliases): Move inline.\n+\t(symtab_node::used_from_object_file_p_worker): Inline into ...\n+\t(symtab_node::used_from_object_file_p): Move inline.\n+\t* tree-emutls.c (ipa_lower_emutls): Update.\n+\t* varpool.c (varpool_node::call_for_symbol_and_aliases_1): New method.\n+\t(varpool_node::call_for_node_and_aliases): Remove.\n+\n 2015-02-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/62209"}, {"sha": "3548bd0757d1ffba24bf873d2333c1e6a5c13e58", "filename": "gcc/cgraph.c", "status": "modified", "additions": 20, "deletions": 58, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -2215,33 +2215,6 @@ cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n   return false;\n }\n \n-/* Call callback on function and aliases associated to the function.\n-   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n-   skipped.  */\n-\n-bool\n-cgraph_node::call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n-\t\t\t\t\t\t\t    void *),\n-\t\t\t\t\t  void *data,\n-\t\t\t\t\t  bool include_overwritable)\n-{\n-  ipa_ref *ref;\n-\n-  if (callback (this, data))\n-    return true;\n-\n-  FOR_EACH_ALIAS (this, ref)\n-    {\n-      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-      if (include_overwritable\n-\t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n-\tif (alias->call_for_symbol_and_aliases (callback, data,\n-\t\t\t\t\t\tinclude_overwritable))\n-\t  return true;\n-    }\n-  return false;\n-}\n-\n /* Worker to bring NODE local.  */\n \n bool\n@@ -2430,37 +2403,6 @@ cgraph_edge::maybe_hot_p (void)\n   return true;\n }\n \n-/* Return true when function can be removed from callgraph\n-   if all direct calls are eliminated.  */\n-\n-bool\n-cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n-{\n-  gcc_assert (!global.inlined_to);\n-  /* Instrumentation clones should not be removed before\n-     instrumentation happens.  New callers may appear after\n-     instrumentation.  */\n-  if (instrumentation_clone\n-      && !chkp_function_instrumented_p (decl))\n-    return false;\n-  /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (decl))\n-    return true;\n-  /* When function is needed, we can not remove it.  */\n-  if (force_output || used_from_other_partition)\n-    return false;\n-  if (DECL_STATIC_CONSTRUCTOR (decl)\n-      || DECL_STATIC_DESTRUCTOR (decl))\n-    return false;\n-  /* Only COMDAT functions can be removed if externally visible.  */\n-  if (externally_visible\n-      && (!DECL_COMDAT (decl)\n-\t  || forced_by_abi\n-\t  || used_from_object_file_p ()))\n-    return false;\n-  return true;\n-}\n-\n /* Worker for cgraph_can_remove_if_no_direct_calls_p.  */\n \n static bool\n@@ -3363,4 +3305,24 @@ cgraph_c_finalize (void)\n   version_info_node = NULL;\n }\n \n+/* A wroker for call_for_symbol_and_aliases.  */\n+\n+bool\n+cgraph_node::call_for_symbol_and_aliases_1 (bool (*callback) (cgraph_node *,\n+\t\t\t\t\t\t\t      void *),\n+\t\t\t\t\t    void *data,\n+\t\t\t\t\t    bool include_overwritable)\n+{\n+  ipa_ref *ref;\n+  FOR_EACH_ALIAS (this, ref)\n+    {\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      if (include_overwritable\n+\t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tif (alias->call_for_symbol_and_aliases (callback, data,\n+\t\t\t\t\t\tinclude_overwritable))\n+\t  return true;\n+    }\n+  return false;\n+}\n #include \"gt-cgraph.h\""}, {"sha": "6155804db6f0f4140c09587c42da486c486c7cfe", "filename": "gcc/cgraph.h", "status": "modified", "additions": 223, "deletions": 11, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -377,10 +377,6 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Verify symbol table for internal consistency.  */\n   static DEBUG_FUNCTION void verify_symtab_nodes (void);\n \n-  /* Return true when NODE is known to be used from other (non-LTO)\n-     object file. Known only when doing LTO via linker plugin.  */\n-  static bool used_from_object_file_p_worker (symtab_node *node);\n-\n   /* Type of the symbol.  */\n   ENUM_BITFIELD (symtab_type) type : 8;\n \n@@ -523,6 +519,10 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n      allocated structure is returned.  */\n   struct symbol_priority_map *priority_info (void);\n \n+  /* Worker for call_for_symbol_and_aliases_1.  */\n+  bool call_for_symbol_and_aliases_1 (bool (*callback) (symtab_node *, void *),\n+\t\t\t\t      void *data,\n+\t\t\t\t      bool include_overwrite);\n private:\n   /* Worker for set_section.  */\n   static bool set_section (symtab_node *n, void *s);\n@@ -532,6 +532,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n \n   /* Worker searching noninterposable alias.  */\n   static bool noninterposable_alias (symtab_node *node, void *data);\n+\n+  /* Worker for ultimate_alias_target.  */\n+  symtab_node *ultimate_alias_target_1 (enum availability *avail = NULL);\n };\n \n /* Walk all aliases for NODE.  */\n@@ -1291,6 +1294,12 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   unsigned nonfreeing_fn : 1;\n   /* True if there was multiple COMDAT bodies merged by lto-symtab.  */\n   unsigned merged : 1;\n+\n+private:\n+  /* Worker for call_for_symbol_and_aliases.  */\n+  bool call_for_symbol_and_aliases_1 (bool (*callback) (cgraph_node *,\n+\t\t\t\t\t\t        void *),\n+\t\t\t\t      void *data, bool include_overwritable);\n };\n \n /* A cgraph node set is a collection of cgraph nodes.  A cgraph node\n@@ -1670,9 +1679,9 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n   /* Call calback on varpool symbol and aliases associated to varpool symbol.\n      When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n      skipped. */\n-  bool call_for_node_and_aliases (bool (*callback) (varpool_node *, void *),\n-\t\t\t\t  void *data,\n-\t\t\t\t   bool include_overwritable);\n+  bool call_for_symbol_and_aliases (bool (*callback) (varpool_node *, void *),\n+\t\t\t\t    void *data,\n+\t\t\t\t    bool include_overwritable);\n \n   /* Return true when variable should be considered externally visible.  */\n   bool externally_visible_p (void);\n@@ -1747,6 +1756,11 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n private:\n   /* Assemble thunks and aliases associated to varpool node.  */\n   void assemble_aliases (void);\n+\n+  /* Worker for call_for_node_and_aliases.  */\n+  bool call_for_symbol_and_aliases_1 (bool (*callback) (varpool_node *, void *),\n+\t\t\t\t      void *data,\n+\t\t\t\t      bool include_overwritable);\n };\n \n /* Every top level asm statement is put into a asm_node.  */\n@@ -2181,7 +2195,6 @@ bool cgraph_function_possibly_inlined_p (tree);\n const char* cgraph_inline_failed_string (cgraph_inline_failed_t);\n cgraph_inline_failed_type_t cgraph_inline_failed_type (cgraph_inline_failed_t);\n \n-bool resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution);\n extern bool gimple_check_call_matching_types (gimple, tree, bool);\n \n /* In cgraphunit.c  */\n@@ -2209,6 +2222,9 @@ bool ipa_discover_readonly_nonaddressable_vars (void);\n /* In varpool.c  */\n tree ctor_for_folding (tree);\n \n+/* In tree-chkp.c  */\n+extern bool chkp_function_instrumented_p (tree fndecl);\n+\n /* Return true when the symbol is real symbol, i.e. it is not inline clone\n    or abstract function kept for debug info purposes only.  */\n inline bool\n@@ -2270,6 +2286,7 @@ symtab_node::get_alias_target (void)\n }\n \n /* Return next reachable static symbol with initializer after the node.  */\n+\n inline symtab_node *\n symtab_node::next_defined_symbol (void)\n {\n@@ -2282,6 +2299,78 @@ symtab_node::next_defined_symbol (void)\n   return NULL;\n }\n \n+/* Iterates I-th reference in the list, REF is also set.  */\n+\n+inline ipa_ref *\n+symtab_node::iterate_reference (unsigned i, ipa_ref *&ref)\n+{\n+  vec_safe_iterate (ref_list.references, i, &ref);\n+\n+  return ref;\n+}\n+\n+/* Iterates I-th referring item in the list, REF is also set.  */\n+\n+inline ipa_ref *\n+symtab_node::iterate_referring (unsigned i, ipa_ref *&ref)\n+{\n+  ref_list.referring.iterate (i, &ref);\n+\n+  return ref;\n+}\n+\n+/* Iterates I-th referring alias item in the list, REF is also set.  */\n+\n+inline ipa_ref *\n+symtab_node::iterate_direct_aliases (unsigned i, ipa_ref *&ref)\n+{\n+  ref_list.referring.iterate (i, &ref);\n+\n+  if (ref && ref->use != IPA_REF_ALIAS)\n+    return NULL;\n+\n+  return ref;\n+}\n+\n+/* Return true if list contains an alias.  */\n+\n+inline bool\n+symtab_node::has_aliases_p (void)\n+{\n+  ipa_ref *ref = NULL;\n+  int i;\n+\n+  for (i = 0; iterate_direct_aliases (i, ref); i++)\n+    if (ref->use == IPA_REF_ALIAS)\n+      return true;\n+  return false;\n+}\n+\n+/* Return true when RESOLUTION indicate that linker will use\n+   the symbol from non-LTO object files.  */\n+\n+inline bool\n+resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n+{\n+  return (resolution == LDPR_PREVAILING_DEF\n+\t  || resolution == LDPR_PREEMPTED_REG\n+\t  || resolution == LDPR_RESOLVED_EXEC\n+\t  || resolution == LDPR_RESOLVED_DYN);\n+}\n+\n+/* Return true when symtab_node is known to be used from other (non-LTO)\n+   object file. Known only when doing LTO via linker plugin.  */\n+\n+inline bool\n+symtab_node::used_from_object_file_p (void)\n+{\n+  if (!TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n+    return false;\n+  if (resolution_used_from_other_file_p (resolution))\n+    return true;\n+  return false;\n+}\n+\n /* Return varpool node for given symbol and check it is a function. */\n \n inline varpool_node *\n@@ -2644,6 +2733,37 @@ cgraph_node::only_called_directly_or_aliased_p (void)\n \t  && !externally_visible);\n }\n \n+/* Return true when function can be removed from callgraph\n+   if all direct calls are eliminated.  */\n+\n+inline bool\n+cgraph_node::can_remove_if_no_direct_calls_and_refs_p (void)\n+{\n+  gcc_checking_assert (!global.inlined_to);\n+  /* Instrumentation clones should not be removed before\n+     instrumentation happens.  New callers may appear after\n+     instrumentation.  */\n+  if (instrumentation_clone\n+      && !chkp_function_instrumented_p (decl))\n+    return false;\n+  /* Extern inlines can always go, we will use the external definition.  */\n+  if (DECL_EXTERNAL (decl))\n+    return true;\n+  /* When function is needed, we can not remove it.  */\n+  if (force_output || used_from_other_partition)\n+    return false;\n+  if (DECL_STATIC_CONSTRUCTOR (decl)\n+      || DECL_STATIC_DESTRUCTOR (decl))\n+    return false;\n+  /* Only COMDAT functions can be removed if externally visible.  */\n+  if (externally_visible\n+      && (!DECL_COMDAT (decl)\n+\t  || forced_by_abi\n+\t  || used_from_object_file_p ()))\n+    return false;\n+  return true;\n+}\n+\n /* Return true when variable can be removed from variable pool\n    if all direct calls are eliminated.  */\n \n@@ -2699,15 +2819,32 @@ varpool_node::get_alias_target (void)\n   return dyn_cast <varpool_node *> (symtab_node::get_alias_target ());\n }\n \n+/* Walk the alias chain to return the symbol NODE is alias of.\n+   If NODE is not an alias, return NODE.\n+   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+\n+inline symtab_node *\n+symtab_node::ultimate_alias_target (enum availability *availability)\n+{\n+  if (!alias)\n+    {\n+      if (availability)\n+\t*availability = get_availability ();\n+      return this;\n+    }\n+\n+  return ultimate_alias_target_1 (availability);\n+}\n+\n /* Given function symbol, walk the alias chain to return the function node\n    is alias of. Do not walk through thunks.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n \n inline cgraph_node *\n cgraph_node::ultimate_alias_target (enum availability *availability)\n {\n-  cgraph_node *n = dyn_cast <cgraph_node *> (symtab_node::ultimate_alias_target\n-    (availability));\n+  cgraph_node *n = dyn_cast <cgraph_node *>\n+    (symtab_node::ultimate_alias_target (availability));\n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n@@ -2756,6 +2893,7 @@ cgraph_edge::redirect_callee (cgraph_node *n)\n }\n \n /* Return true when the edge represents a direct recursion.  */\n+\n inline bool\n cgraph_edge::recursive_p (void)\n {\n@@ -2813,14 +2951,88 @@ cgraph_node::optimize_for_size_p (void)\n     return false;\n }\n \n-inline symtab_node * symtab_node::get_create (tree node)\n+/* Return symtab_node for NODE or create one if it is not present\n+   in symtab.  */\n+\n+inline symtab_node *\n+symtab_node::get_create (tree node)\n {\n   if (TREE_CODE (node) == VAR_DECL)\n     return varpool_node::get_create (node);\n   else\n     return cgraph_node::get_create (node);\n }\n \n+/* Return availability of NODE.  */\n+\n+inline enum availability\n+symtab_node::get_availability (void)\n+{\n+  if (is_a <cgraph_node *> (this))\n+    return dyn_cast <cgraph_node *> (this)->get_availability ();\n+  else\n+    return dyn_cast <varpool_node *> (this)->get_availability ();;\n+}\n+\n+/* Call calback on symtab node and aliases associated to this node.\n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped. */\n+\n+inline bool\n+symtab_node::call_for_symbol_and_aliases (bool (*callback) (symtab_node *,\n+\t\t\t\t\t\t\t    void *),\n+\t\t\t\t\t  void *data,\n+\t\t\t\t\t  bool include_overwritable)\n+{\n+  ipa_ref *ref;\n+\n+  if (callback (this, data))\n+    return true;\n+  if (iterate_direct_aliases (0, ref))\n+    return call_for_symbol_and_aliases_1 (callback, data, include_overwritable);\n+  return false;\n+}\n+\n+/* Call callback on function and aliases associated to the function.\n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped.  */\n+\n+inline bool\n+cgraph_node::call_for_symbol_and_aliases (bool (*callback) (cgraph_node *,\n+\t\t\t\t\t\t\t    void *),\n+\t\t\t\t\t  void *data,\n+\t\t\t\t\t  bool include_overwritable)\n+{\n+  ipa_ref *ref;\n+\n+  if (callback (this, data))\n+    return true;\n+  if (iterate_direct_aliases (0, ref))\n+    return call_for_symbol_and_aliases_1 (callback, data, include_overwritable);\n+\n+  return false;\n+}\n+\n+/* Call calback on varpool symbol and aliases associated to varpool symbol.\n+   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n+   skipped. */\n+\n+inline bool\n+varpool_node::call_for_symbol_and_aliases (bool (*callback) (varpool_node *,\n+\t\t\t\t\t\t\t     void *),\n+\t\t\t\t\t   void *data,\n+\t\t\t\t\t   bool include_overwritable)\n+{\n+  ipa_ref *ref;\n+\n+  if (callback (this, data))\n+    return true;\n+  if (iterate_direct_aliases (0, ref))\n+    return call_for_symbol_and_aliases_1 (callback, data, include_overwritable);\n+\n+  return false;\n+}\n+\n /* Build polymorphic call context for indirect call E.  */\n \n inline"}, {"sha": "0b857ffb8a05098f0a5b54329981fea96fcdff1b", "filename": "gcc/ipa-chkp.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -534,14 +534,13 @@ chkp_maybe_create_clone (tree fndecl)\n \tsymtab->call_cgraph_insertion_hooks (clone);\n \n       /* Clone all aliases.  */\n-      for (i = 0; node->iterate_referring (i, ref); i++)\n-\tif (ref->use == IPA_REF_ALIAS)\n-\t  {\n-\t    struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-\t    struct cgraph_node *chkp_alias\n-\t      = chkp_maybe_create_clone (alias->decl);\n-\t    chkp_alias->create_reference (clone, IPA_REF_ALIAS, NULL);\n-\t  }\n+      for (i = 0; node->iterate_direct_aliases (i, ref); i++)\n+\t{\n+\t  struct cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+\t  struct cgraph_node *chkp_alias\n+\t    = chkp_maybe_create_clone (alias->decl);\n+\t  chkp_alias->create_reference (clone, IPA_REF_ALIAS, NULL);\n+\t}\n \n       /* Clone all thunks.  */\n       for (e = node->callers; e; e = e->next_caller)"}, {"sha": "422d6a4155af85881fdd189fd1aa1e340b24af0f", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -1710,7 +1710,6 @@ referenced_from_vtable_p (struct cgraph_node *node)\n     return true;\n \n   for (i = 0; node->iterate_referring (i, ref); i++)\n-\t\n     if ((ref->use == IPA_REF_ALIAS\n \t && referenced_from_vtable_p (dyn_cast<cgraph_node *> (ref->referring)))\n \t|| (ref->use == IPA_REF_ADDR"}, {"sha": "c14f5992ae0577bd45b1115b406d820358268017", "filename": "gcc/ipa.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -808,8 +808,8 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t  {\n \t    if (TREE_ADDRESSABLE (vnode->decl) && dump_file)\n \t      fprintf (dump_file, \" %s (non-addressable)\", vnode->name ());\n-\t    vnode->call_for_node_and_aliases (clear_addressable_bit, NULL,\n-\t\t\t\t\t      true);\n+\t    vnode->call_for_symbol_and_aliases (clear_addressable_bit, NULL,\n+\t\t\t\t\t        true);\n \t  }\n \tif (!address_taken && !written\n \t    /* Making variable in explicit section readonly can cause section\n@@ -819,14 +819,14 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t  {\n \t    if (!TREE_READONLY (vnode->decl) && dump_file)\n \t      fprintf (dump_file, \" %s (read-only)\", vnode->name ());\n-\t    vnode->call_for_node_and_aliases (set_readonly_bit, NULL, true);\n+\t    vnode->call_for_symbol_and_aliases (set_readonly_bit, NULL, true);\n \t  }\n \tif (!vnode->writeonly && !read && !address_taken && written)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (write-only)\", vnode->name ());\n-\t    vnode->call_for_node_and_aliases (set_writeonly_bit, &remove_p, \n-\t\t\t\t\t     true);\n+\t    vnode->call_for_symbol_and_aliases (set_writeonly_bit, &remove_p, \n+\t\t\t\t\t        true);\n \t  }\n       }\n   if (dump_file)\n@@ -1343,9 +1343,8 @@ ipa_single_use (void)\n \t  single_user_map.put (var, user);\n \n \t  /* Enqueue all aliases for re-processing.  */\n-\t  for (i = 0; var->iterate_referring (i, ref); i++)\n-\t    if (ref->use == IPA_REF_ALIAS\n-\t\t&& !ref->referring->aux)\n+\t  for (i = 0; var->iterate_direct_aliases (i, ref); i++)\n+\t    if (!ref->referring->aux)\n \t      {\n \t\tref->referring->aux = first;\n \t\tfirst = dyn_cast <varpool_node *> (ref->referring);"}, {"sha": "ee47a738508ab1ba65b20ce84d5f1110cf74150d", "filename": "gcc/symtab.c", "status": "modified", "additions": 33, "deletions": 137, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -313,18 +313,6 @@ symbol_table::change_decl_assembler_name (tree decl, tree name)\n     }\n }\n \n-/* Return true when RESOLUTION indicate that linker will use\n-   the symbol from non-LTO object files.  */\n-\n-bool\n-resolution_used_from_other_file_p (enum ld_plugin_symbol_resolution resolution)\n-{\n-  return (resolution == LDPR_PREVAILING_DEF\n-\t  || resolution == LDPR_PREEMPTED_REG\n-\t  || resolution == LDPR_RESOLVED_EXEC\n-\t  || resolution == LDPR_RESOLVED_DYN);\n-}\n-\n /* Hash sections by their names.  */\n \n hashval_t\n@@ -527,18 +515,18 @@ symtab_node::create_reference (symtab_node *referred_node,\n \n   /* IPA_REF_ALIAS is always inserted at the beginning of the list.   */\n   if(use_type == IPA_REF_ALIAS)\n-  {\n-    list2->referring.safe_insert (0, ref);\n-    ref->referred_index = 0;\n+    {\n+      list2->referring.safe_insert (0, ref);\n+      ref->referred_index = 0;\n \n-    for (unsigned int i = 1; i < list2->referring.length (); i++)\n-      list2->referring[i]->referred_index = i;\n-  }\n+      for (unsigned int i = 1; i < list2->referring.length (); i++)\n+\tlist2->referring[i]->referred_index = i;\n+    }\n   else\n-  {\n-    list2->referring.safe_push (ref);\n-    ref->referred_index = list2->referring.length () - 1;\n-  }\n+    {\n+      list2->referring.safe_push (ref);\n+      ref->referred_index = list2->referring.length () - 1;\n+    }\n \n   ref->referring = this;\n   ref->referred = referred_node;\n@@ -743,52 +731,6 @@ symtab_node::dump_referring (FILE *file)\n   fprintf (file, \"\\n\");\n }\n \n-/* Return true if list contains an alias.  */\n-bool\n-symtab_node::has_aliases_p (void)\n-{\n-  ipa_ref *ref = NULL;\n-  int i;\n-\n-  for (i = 0; iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      return true;\n-  return false;\n-}\n-\n-/* Iterates I-th reference in the list, REF is also set.  */\n-\n-ipa_ref *\n-symtab_node::iterate_reference (unsigned i, ipa_ref *&ref)\n-{\n-  vec_safe_iterate (ref_list.references, i, &ref);\n-\n-  return ref;\n-}\n-\n-/* Iterates I-th referring item in the list, REF is also set.  */\n-\n-ipa_ref *\n-symtab_node::iterate_referring (unsigned i, ipa_ref *&ref)\n-{\n-  ref_list.referring.iterate (i, &ref);\n-\n-  return ref;\n-}\n-\n-/* Iterates I-th referring alias item in the list, REF is also set.  */\n-\n-ipa_ref *\n-symtab_node::iterate_direct_aliases (unsigned i, ipa_ref *&ref)\n-{\n-  ref_list.referring.iterate (i, &ref);\n-\n-  if (ref && ref->use != IPA_REF_ALIAS)\n-    return NULL;\n-\n-  return ref;\n-}\n-\n static const char * const symtab_type_names[] = {\"symbol\", \"function\", \"variable\"};\n \n /* Dump base fields of symtab nodes to F.  Not to be used directly.  */\n@@ -1196,29 +1138,6 @@ symtab_node::verify_symtab_nodes (void)\n     }\n }\n \n-/* Return true when NODE is known to be used from other (non-LTO)\n-   object file. Known only when doing LTO via linker plugin.  */\n-\n-bool\n-symtab_node::used_from_object_file_p_worker (symtab_node *node)\n-{\n-  if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n-    return false;\n-  if (resolution_used_from_other_file_p (node->resolution))\n-    return true;\n-  return false;\n-}\n-\n-\n-/* Return true when symtab_node is known to be used from other (non-LTO)\n-   object file. Known only when doing LTO via linker plugin.  */\n-\n-bool\n-symtab_node::used_from_object_file_p (void)\n-{\n-  return symtab_node::used_from_object_file_p_worker (this);\n-}\n-\n /* Make DECL local.  FIXME: We shouldn't need to mess with rtl this early,\n    but other code such as notice_global_symbol generates rtl.  */\n \n@@ -1260,20 +1179,13 @@ symtab_node::make_decl_local (void)\n \n /* Walk the alias chain to return the symbol NODE is alias of.\n    If NODE is not an alias, return NODE.\n-   When AVAILABILITY is non-NULL, get minimal availability in the chain.  */\n+   Assumes NODE is known to be alias.  */\n \n symtab_node *\n-symtab_node::ultimate_alias_target (enum availability *availability)\n+symtab_node::ultimate_alias_target_1 (enum availability *availability)\n {\n   bool weakref_p = false;\n \n-  if (!alias)\n-    {\n-      if (availability)\n-\t*availability = get_availability ();\n-      return this;\n-    }\n-\n   /* To determine visibility of the target, we follow ELF semantic of aliases.\n      Here alias is an alternative assembler name of a given definition. Its\n      availability prevails the availability of its target (i.e. static alias of\n@@ -1453,16 +1365,6 @@ symtab_node::get_init_priority ()\n   return h ? h->init : DEFAULT_INIT_PRIORITY;\n }\n \n-/* Return availability of NODE.  */\n-enum availability symtab_node::get_availability (void)\n-{\n-  if (is_a <cgraph_node *> (this))\n-    return dyn_cast <cgraph_node *> (this)->get_availability ();\n-  else\n-    return dyn_cast <varpool_node *> (this)->get_availability ();;\n-}\n-\n-\n /* Return the finalization priority.  */\n \n priority_type\n@@ -1608,33 +1510,6 @@ symtab_node::resolve_alias (symtab_node *target)\n   return true;\n }\n \n-/* Call calback on symtab node and aliases associated to this node.\n-   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n-   skipped. */\n-\n-bool\n-symtab_node::call_for_symbol_and_aliases (bool (*callback) (symtab_node *,\n-\t\t\t\t\t\t\t  void *),\n-\t\t\t\t\tvoid *data, bool include_overwritable)\n-{\n-  int i;\n-  ipa_ref *ref;\n-\n-  if (callback (this, data))\n-    return true;\n-  for (i = 0; iterate_referring (i, ref); i++)\n-    if (ref->use == IPA_REF_ALIAS)\n-      {\n-\tsymtab_node *alias = ref->referring;\n-\tif (include_overwritable\n-\t    || alias->get_availability () > AVAIL_INTERPOSABLE)\n-\t  if (alias->call_for_symbol_and_aliases (callback, data,\n-\t\t\t\t\t\tinclude_overwritable))\n-\t    return true;\n-      }\n-  return false;\n-}\n-\n /* Worker searching noninterposable alias.  */\n \n bool\n@@ -1961,3 +1836,24 @@ symtab_node::equal_address_to (symtab_node *s2)\n \n   return 2;\n }\n+\n+/* Worker for call_for_symbol_and_aliases.  */\n+\n+bool\n+symtab_node::call_for_symbol_and_aliases_1 (bool (*callback) (symtab_node *,\n+\t\t\t\t\t\t\t      void *),\n+\t\t\t\t\t    void *data,\n+\t\t\t\t\t    bool include_overwritable)\n+{\n+  ipa_ref *ref;\n+  FOR_EACH_ALIAS (this, ref)\n+    {\n+      symtab_node *alias = ref->referring;\n+      if (include_overwritable\n+\t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tif (alias->call_for_symbol_and_aliases (callback, data,\n+\t\t\t\t\t      include_overwritable))\n+\t  return true;\n+    }\n+  return false;\n+}"}, {"sha": "4d7b4e96a85e3417e3bc76a07f00c1d234ba402c", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -787,7 +787,7 @@ ipa_lower_emutls (void)\n       if (var->alias && !var->analyzed)\n \tany_aliases = true;\n       else if (!var->alias)\n-\tvar->call_for_node_and_aliases (create_emultls_var, &ctor_body, true);\n+\tvar->call_for_symbol_and_aliases (create_emultls_var, &ctor_body, true);\n     }\n \n   /* If there were any aliases, then frob the alias_pairs vector.  */"}, {"sha": "3135985740528a9c69a45efdd5aa5dc335d4e228", "filename": "gcc/varpool.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31de760604065cf4dae5de8828321c86b15bf3c9/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=31de760604065cf4dae5de8828321c86b15bf3c9", "patch": "@@ -817,28 +817,23 @@ varpool_node::create_extra_name_alias (tree alias, tree decl)\n   return alias_node;\n }\n \n-/* Call calback on varpool symbol and aliases associated to varpool symbol.\n-   When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are\n-   skipped. */\n+/* Worker for call_for_symbol_and_aliases.  */\n \n bool\n-varpool_node::call_for_node_and_aliases (bool (*callback) (varpool_node *,\n-\t\t\t\t\t\t\t   void *),\n-\t\t\t\t\t void *data,\n-\t\t\t\t\t bool include_overwritable)\n+varpool_node::call_for_symbol_and_aliases_1 (bool (*callback) (varpool_node *,\n+\t\t\t\t\t\t\t       void *),\n+\t\t\t\t\t     void *data,\n+\t\t\t\t\t     bool include_overwritable)\n {\n   ipa_ref *ref;\n \n-  if (callback (this, data))\n-    return true;\n-\n   FOR_EACH_ALIAS (this, ref)\n     {\n       varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n       if (include_overwritable\n \t  || alias->get_availability () > AVAIL_INTERPOSABLE)\n-\tif (alias->call_for_node_and_aliases (callback, data,\n-\t\t\t\t\t      include_overwritable))\n+\tif (alias->call_for_symbol_and_aliases (callback, data,\n+\t\t\t\t\t        include_overwritable))\n \t  return true;\n     }\n   return false;"}]}