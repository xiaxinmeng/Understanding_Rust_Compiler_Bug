{"sha": "cb0ca2844b8681305bcad7699657a7967cc9c634", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IwY2EyODQ0Yjg2ODEzMDViY2FkNzY5OTY1N2E3OTY3Y2M5YzYzNA==", "commit": {"author": {"name": "Michael Hayes", "email": "mph@elec.canterbury.ac.nz", "date": "1998-09-19T00:03:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-19T00:03:07Z"}, "message": "README.C4X: New file with information about the c4x ports.\n\n        * README.C4X: New file with information about the c4x ports.\n        * ginclude/va-c4x.h: New file for c4x varargs support.\n        * config/c4x: New directory with c4x port files.\n\nFrom-SVN: r22475", "tree": {"sha": "b0ebf2a8a557674219c6a8fe1c16245efbd77ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0ebf2a8a557674219c6a8fe1c16245efbd77ea3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb0ca2844b8681305bcad7699657a7967cc9c634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0ca2844b8681305bcad7699657a7967cc9c634", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb0ca2844b8681305bcad7699657a7967cc9c634", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb0ca2844b8681305bcad7699657a7967cc9c634/comments", "author": null, "committer": null, "parents": [{"sha": "289c9aa3c7c1c5f5522e3eee7fba071eafa0c21b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/289c9aa3c7c1c5f5522e3eee7fba071eafa0c21b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/289c9aa3c7c1c5f5522e3eee7fba071eafa0c21b"}], "stats": {"total": 15141, "additions": 15141, "deletions": 0}, "files": [{"sha": "6caede77f236d2e74219d38a53980036a3355f9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb0ca2844b8681305bcad7699657a7967cc9c634", "patch": "@@ -1,3 +1,9 @@\n+Sat Sep 19 01:00:32 1998  Michael Hayes  (mph@elec.canterbury.ac.nz)\n+\n+\t* README.C4X: New file with information about the c4x ports.\n+\t* ginclude/va-c4x.h: New file for c4x varargs support.\n+\t* config/c4x: New directory with c4x port files.\n+\n Fri Sep 18 22:52:05 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* reload.c (find_reloads): Do not replace a pseudo with "}, {"sha": "c8c5f22a8d4c1ddf309fd4f006eeceb05d017c41", "filename": "gcc/README.C4X", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2FREADME.C4X", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2FREADME.C4X", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.C4X?ref=cb0ca2844b8681305bcad7699657a7967cc9c634", "patch": "@@ -0,0 +1,48 @@\n+This file describes the implementation notes of the GNU C Compiler for\n+the Texas Instruments Floating Point Digital Signal Processor\n+families, TMS320C3x and TMS320C4x (including the C30, C31, C32, C40,\n+and C44 chips).\n+\n+\n+Currently, only two code variants are generated---those for the C3x\n+and C4x architectures.  Note that the new operand combinations for\n+parallel instructions, included in newer silicon revisions, are not\n+yet supported.  These should be trivial to add for someone with the\n+newer chips and the inclination.\n+\n+\n+While the generated assembly code is fairly similar to that recognised\n+by the TI assembler, there are a few differences (currently the machine\n+option -mti, designed to enfore compatibility, is not fully\n+implemented).  The major difference is the use of the ^ operator to\n+load the 16 MSBs of an address or constant for the C4x.\n+\n+\n+The generated assembly code requires the GNU assembler (GAS).  This is\n+not currently included as part of the binutils package, due to the\n+many hacks required to be compatible with TI's kludged COFF\n+implementation, and the binutils not being designed for 32-bit bytes.\n+Patches against binutils-2.7.2 can be obtained from\n+ftp://ongaonga.chch.cri.nz/pub/c4x.  This site also has patches for\n+the GNU debugger (GDB), incoporating a cycle accurate simulator that\n+can display profiles and histories of code execution, detailing\n+pipeline conflicts etc.\n+\n+\n+GCC can be configured as a cross compiler for both the C3x and C4x\n+architectures on the same system.  Use `configure --target=c4x' to\n+configure GCC for both the C3x and C4x.  Then use the -m30 option to\n+generate code for the C30 or -m40 (the default) for the C40.\n+\n+\n+Further installation notes and other optimization patches for GCC can\n+also be obtained from ftp://ongaonga.chch.cri.nz/pub/c4x.\n+\n+\n+A Majordomo mailing list, gcc_c40@atlantek.com.au, exists to discuss\n+related issues and suggestions for further optimizations.  To\n+subscribe send a message with `subscribe gcc_c40' in the body to\n+majordomo@atlantek.com.au.\n+\n+\n+Michael Hayes,  16 Sep 98"}, {"sha": "f6b75c13ec43064c4c60eada44e88170f7ea1847", "filename": "gcc/config/c4x/c4x.c", "status": "added", "additions": 5597, "deletions": 0, "changes": 5597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=cb0ca2844b8681305bcad7699657a7967cc9c634"}, {"sha": "cc92b2a12f9f70783852779b74cdf118e832bc15", "filename": "gcc/config/c4x/c4x.h", "status": "added", "additions": 2608, "deletions": 0, "changes": 2608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=cb0ca2844b8681305bcad7699657a7967cc9c634", "patch": "@@ -0,0 +1,2608 @@\n+/* Definitions of target machine for GNU compiler.  TMS320C[34]x\n+   Copyright (C) 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+\n+   Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n+              and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 1, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* Set the following so that some of the macros expand to function\n+   calls to simplify debugging.  */\n+#define C4X_DEBUG 1\n+\n+/* RUN-TIME TARGET SPECIFICATION */\n+\n+#define C4x   1\n+\n+/* Name of the c4x assembler */\n+\n+#define ASM_PROG \"c4x-as\"\n+\n+/* Name of the c4x linker */\n+\n+#define LD_PROG \"c4x-ld\"\n+\n+/* Define assembler options */\n+\n+#define ASM_SPEC \"\\\n+%{!mcpu=30:%{!mcpu=31:%{!mcpu=32:%{!mcpu=40:%{!mcpu=44:\\\n+%{!m30:%{!m40:-m40}}}}}}} \\\n+%{mcpu=30:-m30} \\\n+%{mcpu=31:-m31} \\\n+%{mcpu=32:-m32} \\\n+%{mcpu=40:-m40} \\\n+%{mcpu=44:-m44} \\\n+%{m30:-m30} \\\n+%{m31:-m31} \\\n+%{m32:-m32} \\\n+%{m40:-m40} \\\n+%{m44:-m44} \\\n+%{mmemparm:-p} %{mregparm:-r} \\\n+%{!mmemparm:%{!mregparm:-r}} \\\n+%{mbig:-b} %{msmall:-s} \\\n+%{!msmall:%{!mbig:-b}}\"\n+\n+/* Define linker options */\n+\n+#define LINK_SPEC \"\\\n+%{m30:--architecture c3x} \\\n+%{m31:--architecture c3x} \\\n+%{m32:--architecture c3x} \\\n+%{mcpu=30:--architecture c3x} \\\n+%{mcpu=31:--architecture c3x} \\\n+%{mcpu=32:--architecture c3x}\"\n+\n+/* Define C preprocessor options. */\n+\n+#define CPP_SPEC \"\\\n+%{!m30:%{!m31:%{!m32:%{!mcpu=30:%{!mcpu=31:%{!mcpu=32:%{!mcpu=40:%{!mcpu=44:\\\n+  %{!m40:%{!m44:-D_TMS320C4x -D_C4x -D_TMS320C40 -D_C40 }}}}}}}}}} \\\n+%{mcpu=30:-D_TMS320C3x -D_C3x -D_TMS320C30 -D_C30 } \\\n+%{m30:-D_TMS320C3x -D_C3x -D_TMS320C30 -D_C30 } \\\n+%{mcpu=31:-D_TMS320C3x -D_C3x -D_TMS320C31 -D_C31 } \\\n+%{m31:-D_TMS320C3x -D_C3x -D_TMS320C31 -D_C31 } \\\n+%{mcpu=32:-D_TMS320C3x -D_C3x -D_TMS320C32 -D_C32 } \\\n+%{m32:-D_TMS320C3x -D_C3x -D_TMS320C32 -D_C32 } \\\n+%{mcpu=40:-D_TMS320C4x -D_C4x -D_TMS320C40 -D_C40 } \\\n+%{m40:-D_TMS320C4x -D_C4x -D_TMS320C40 -D_C40 } \\\n+%{mcpu=44:-D_TMS320C4x -D_C4x -D_TMS320C44 -D_C44 } \\\n+%{m44:-D_TMS320C4x -D_C4x -D_TMS320C44 -D_C44 } \\\n+%{mmemparm:-U_REGPARM }%{mregparm:-D_REGPARM } \\\n+%{!mmemparm:%{!mregparm:-D_REGPARM }} \\\n+%{msmall:-U_BIGMODEL } %{mbig:-D_BIGMODEL } \\\n+%{!msmall:%{!mbig:-D_BIGMODEL }} \\\n+%{finline-functions:-D_INLINE }\"\n+\n+/* Specify the startup file to link with. */\n+\n+#define STARTFILE_SPEC \"\\\n+%{!mmemparm:%{m30:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n+%{mmemparm:%{m30:%{msmall:crt0_3sm%O%s} %{!msmall:crt0_3bm%O%s}}} \\\n+%{!mmemparm:%{m31:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n+%{mmemparm:%{m31:%{msmall:crt0_3sm%O%s} %{!msmall:crt0_3bm%O%s}}} \\\n+%{!mmemparm:%{m32:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n+%{mmemparm:%{m32:%{msmall:crt0_3sm%O%s} %{!msmall:crt0_3bm%O%s}}} \\\n+%{!mmemparm:%{mcpu=30:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n+%{mmemparm:%{mcpu=30:%{msmall:crt0_3sm%O%s} %{!msmall:crt0_3bm%O%s}}} \\\n+%{!mmemparm:%{mcpu=31:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n+%{mmemparm:%{mcpu=31:%{msmall:crt0_3sm%O%s} %{!msmall:crt0_3bm%O%s}}} \\\n+%{!mmemparm:%{mcpu=32:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n+%{mmemparm:%{mcpu=32:%{msmall:crt0_3sm%O%s} %{!msmall:crt0_3bm%O%s}}} \\\n+%{!mmemparm:%{m40:%{msmall:crt0_4sr%O%s} %{!msmall:crt0_4br%O%s}}} \\\n+%{mmemparm:%{m40:%{msmall:crt0_4sm%O%s} %{!msmall:crt0_4bm%O%s}}} \\\n+%{!mmemparm:%{m44:%{msmall:crt0_4sr%O%s} %{!msmall:crt0_4br%O%s}}} \\\n+%{mmemparm:%{m44:%{msmall:crt0_4sm%O%s} %{!msmall:crt0_4bm%O%s}}} \\\n+%{!mmemparm:%{mcpu=40:%{msmall:crt0_4sr%O%s} %{!msmall:crt0_4br%O%s}}} \\\n+%{mmemparm:%{mcpu=40:%{msmall:crt0_4sm%O%s} %{!msmall:crt0_4bm%O%s}}} \\\n+%{!mmemparm:%{mcpu=44:%{msmall:crt0_4sr%O%s} %{!msmall:crt0_4br%O%s}}} \\\n+%{mmemparm:%{mcpu=44:%{msmall:crt0_4sm%O%s} %{!msmall:crt0_4bm%O%s}}} \\\n+%{!mmemparm:%{!m30:%{!m31:%{!m32:%{!mcpu=30:%{!mcpu=31:%{!mcpu=32: \\\n+  %{!mcpu=40:%{!mcpu=44:%{!m40:%{!m44:%{msmall:crt0_4sr%O%s}}}}}}}}}}}} \\\n+%{mmemparm:%{!m30:%{!m31:%{!m32:%{!mcpu=30:%{!mcpu=31:%{!mcpu=32: \\\n+  %{!mcpu=40:%{!mcpu=44:%{!m40:%{!m44:%{msmall:crt0_4sm%O%s}}}}}}}}}}}} \\\n+%{!mmemparm:%{!m30:%{!m31:%{!m32:%{!mcpu=30:%{!mcpu=31:%{!mcpu=32: \\\n+  %{!mcpu=40:%{!mcpu=44:%{!m40:%{!m44:%{!msmall:crt0_4br%O%s}}}}}}}}}}}} \\\n+%{mmemparm:%{!m30:%{!m31:%{!m32:%{!mcpu=30:%{!mcpu=31:%{!mcpu=32: \\\n+  %{!mcpu=40:%{!mcpu=44:%{!m40:%{!m44:%{!msmall:crt0_4bm%O%s}}}}}}}}}}}}\"\n+\n+/* Specify the end file to link with */\n+\n+#define ENDFILE_SPEC \"\"\n+\n+/* Target compilation option flags */\n+\n+#define SMALL_MEMORY_FLAG   0x0000001 /* small memory model */\n+#define MPYI_FLAG           0x0000002 /* use 24-bit MPYI for C3x */\n+#define FAST_FIX_FLAG       0x0000004 /* fast fixing of floats */\n+#define RPTS_FLAG           0x0000008 /* allow use of RPTS */\n+#define C3X_FLAG            0x0000010 /* emit C3x code */\n+#define TI_FLAG             0x0000020 /* be compatible with TI assembler */\n+#define PARANOID_FLAG       0x0000040 /* be paranoid about DP reg. in ISRs */\n+#define MEMPARM_FLAG        0x0000080 /* pass arguments on stack */\n+#define DEVEL_FLAG          0x0000100 /* enable features under development */\n+#define RPTB_FLAG           0x0000200 /* enable repeat block */\n+#define BK_FLAG             0x0000400 /* use BK as general register */\n+#define DB_FLAG             0x0000800 /* use decrement and branch for C3x */\n+#define DEBUG_FLAG          0x0001000 /* enable debugging of GCC */\n+#define HOIST_FLAG          0x0002000 /* force constants into registers */\n+#define LOOP_UNSIGNED_FLAG  0x0004000 /* allow unsigned loop counters */\n+#define FORCE_FLAG          0x0008000 /* force op0 and op1 to be same */\n+#define PRESERVE_FLOAT_FLAG 0x0010000 /* save all 40 bits for floats */\n+#define PARALLEL_PACK_FLAG  0x0020000 /* allow parallel insn packing */\n+#define PARALLEL_MPY_FLAG   0x0040000 /* allow MPY||ADD, MPY||SUB insns */\n+#define ALIASES_FLAG\t    0x0080000 /* assume mem refs possibly aliased */\n+\n+#define C30_FLAG            0x0100000 /* emit C30 code */\n+#define C31_FLAG            0x0200000 /* emit C31 code */\n+#define C32_FLAG            0x0400000 /* emit C32 code */\n+#define C40_FLAG            0x1000000 /* emit C40 code */\n+#define C44_FLAG            0x2000000 /* emit C44 code */\n+\n+/* Run-time compilation parameters selecting different hardware subsets.\n+\n+   Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES \\\n+{ { \"small\", SMALL_MEMORY_FLAG }, \\\n+  { \"big\", -SMALL_MEMORY_FLAG }, \\\n+  { \"mpyi\", MPYI_FLAG}, \\\n+  { \"no-mpyi\", -MPYI_FLAG}, \\\n+  { \"fast-fix\", FAST_FIX_FLAG}, \\\n+  { \"no-fast-fix\", -FAST_FIX_FLAG}, \\\n+  { \"rpts\", RPTS_FLAG}, \\\n+  { \"no-rpts\", -RPTS_FLAG}, \\\n+  { \"rptb\", RPTB_FLAG}, \\\n+  { \"no-rptb\", -RPTB_FLAG}, \\\n+  { \"30\", C30_FLAG}, \\\n+  { \"31\", C31_FLAG}, \\\n+  { \"32\", C32_FLAG}, \\\n+  { \"40\", C40_FLAG}, \\\n+  { \"44\", C44_FLAG}, \\\n+  { \"ti\", TI_FLAG}, \\\n+  { \"no-ti\", -TI_FLAG}, \\\n+  { \"paranoid\", PARANOID_FLAG}, \\\n+  { \"no-paranoid\", -PARANOID_FLAG}, \\\n+  { \"isr-dp-reload\", PARANOID_FLAG}, \\\n+  { \"no-isr-dp-reload\", -PARANOID_FLAG}, \\\n+  { \"memparm\", MEMPARM_FLAG}, \\\n+  { \"regparm\", -MEMPARM_FLAG}, \\\n+  { \"devel\", DEVEL_FLAG}, \\\n+  { \"no-devel\", -DEVEL_FLAG}, \\\n+  { \"bk\", BK_FLAG}, \\\n+  { \"no-bk\", -BK_FLAG}, \\\n+  { \"db\", DB_FLAG}, \\\n+  { \"no-db\", -DB_FLAG}, \\\n+  { \"debug\", DEBUG_FLAG}, \\\n+  { \"no-debug\", -DEBUG_FLAG}, \\\n+  { \"hoist\", HOIST_FLAG}, \\\n+  { \"no-hoist\", -HOIST_FLAG}, \\\n+  { \"no-force\", -FORCE_FLAG}, \\\n+  { \"force\", FORCE_FLAG}, \\\n+  { \"loop-unsigned\", LOOP_UNSIGNED_FLAG}, \\\n+  { \"no-loop-unsigned\", -LOOP_UNSIGNED_FLAG}, \\\n+  { \"preserve-float\", PRESERVE_FLOAT_FLAG}, \\\n+  { \"no-preserve-float\", -PRESERVE_FLOAT_FLAG}, \\\n+  { \"parallel-insns\", PARALLEL_PACK_FLAG}, \\\n+  { \"no-parallel-mpy\", -PARALLEL_MPY_FLAG}, \\\n+  { \"parallel-mpy\", PARALLEL_MPY_FLAG}, \\\n+  { \"no-parallel-insns\", -PARALLEL_PACK_FLAG}, \\\n+  { \"aliases\", ALIASES_FLAG}, \\\n+  { \"no-aliases\", -ALIASES_FLAG}, \\\n+  { \"\", TARGET_DEFAULT} }\n+\n+/* Default target switches */\n+\n+/* Play safe, not the fastest code.  Note that setting PARALLEL_MPY\n+flag will set SMALL_REGISTER_CLASSES which can be a price to pay,\n+especially when MPY||ADD instructions are only generated very\n+infrequenctly. */\n+#define TARGET_DEFAULT\t\tALIASES_FLAG | RPTB_FLAG | PARALLEL_PACK_FLAG\n+\n+/* Caveats:\n+   Max iteration count for RPTB/RPTS is 2^31 + 1.\n+   Max iteration count for DB is 2^31 + 1 for C40, but 2^23 + 1 for C30.\n+   RPTS blocks interrupts.  */\n+\n+\n+extern int target_flags;\n+\n+#define TARGET_INLINE\t\t1 /* Inline MPYI */\n+#define TARGET_PARALLEL\t        1 /* Enable parallel insns in MD */\n+#define TARGET_SMALL_REG_CLASS\t1 \n+\n+#define TARGET_SMALL\t\t(target_flags & SMALL_MEMORY_FLAG)\n+#define TARGET_MPYI\t\t(!TARGET_C3X || (target_flags & MPYI_FLAG))\n+#define TARGET_FAST_FIX\t\t(target_flags & FAST_FIX_FLAG)\n+#define TARGET_RPTS\t\t(target_flags & RPTS_FLAG)\n+#define TARGET_TI\t\t(target_flags & TI_FLAG)\n+#define TARGET_PARANOID\t\t(target_flags & PARANOID_FLAG)\n+#define TARGET_MEMPARM\t\t(target_flags & MEMPARM_FLAG)\n+#define TARGET_DEVEL\t\t(target_flags & DEVEL_FLAG)\n+#define TARGET_RPTB\t\t(target_flags & RPTB_FLAG \\\n+\t\t\t\t && optimize >= 2)\n+#define TARGET_BK\t\t(target_flags & BK_FLAG)\n+#define TARGET_DB\t\t(!TARGET_C3X || (target_flags & DB_FLAG))\n+#define TARGET_DEBUG\t\t(target_flags & DEBUG_FLAG)\n+#define TARGET_HOIST\t\t(target_flags & HOIST_FLAG)\n+#define TARGET_LOOP_UNSIGNED\t(target_flags & LOOP_UNSIGNED_FLAG)\n+#define TARGET_FORCE\t\t(target_flags & FORCE_FLAG)\n+#define\tTARGET_PRESERVE_FLOAT\t(target_flags & PRESERVE_FLOAT_FLAG)\n+#define TARGET_PARALLEL_PACK\t(TARGET_RPTB \\\n+\t\t\t\t && (target_flags & PARALLEL_PACK_FLAG) \\\n+\t\t\t\t && optimize >= 2)\n+#define TARGET_PARALLEL_MPY\t(TARGET_PARALLEL_PACK \\\n+\t\t\t\t && (target_flags & PARALLEL_MPY_FLAG))\n+#define\tTARGET_ALIASES\t\t(target_flags & ALIASES_FLAG)\n+\n+#define TARGET_C3X\t\t(target_flags & C3X_FLAG)\n+#define TARGET_C30\t\t(target_flags & C30_FLAG)\n+#define TARGET_C31\t\t(target_flags & C31_FLAG)\n+#define TARGET_C32\t\t(target_flags & C32_FLAG)\n+#define TARGET_C40\t\t(target_flags & C40_FLAG)\n+#define TARGET_C44\t\t(target_flags & C44_FLAG)\n+\n+/* -mrpts            allows the use of the RPTS instruction irregardless.\n+   -mrpts=max-cycles will use RPTS if the number of cycles is constant\n+   and less than max-cycles. */\n+\n+#define TARGET_RPTS_CYCLES(CYCLES) (TARGET_RPTS || (CYCLES) < c4x_rpts_cycles)\n+\n+/* -mcpu=XX    with XX = target DSP version number */\n+\n+/* This macro is similar to `TARGET_SWITCHES' but defines names of\n+   command options that have values.  Its definition is an\n+   initializer with a subgrouping for each command option.\n+\n+   Each subgrouping contains a string constant, that defines the\n+   fixed part of the option name, and the address of a variable.\n+   The variable, type `char *', is set to the variable part of the\n+   given option if the fixed part matches.  The actual option name\n+   is made by appending `-m' to the specified name.\n+\n+   Here is an example which defines `-mshort-data-NUMBER'.  If the\n+   given option is `-mshort-data-512', the variable `m88k_short_data'\n+   will be set to the string `\"512\"'.\n+\n+   extern char *m88k_short_data;\n+   #define TARGET_OPTIONS { { \"short-data-\", &m88k_short_data } }  */\n+\n+extern char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n+\n+#define TARGET_OPTIONS\t\t\\\n+{ {\"rpts=\", &c4x_rpts_cycles_string},\\\n+  {\"cpu=\", &c4x_cpu_version_string} }\n+\n+/* Sometimes certain combinations of command options do not make sense\n+   on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed. */\n+\n+extern void c4x_override_options ();\n+#define OVERRIDE_OPTIONS c4x_override_options ()\n+\n+\n+/* Run Time Target Specification  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (TMS320C[34]x, TI syntax)\" );\n+\n+/* Storage Layout  */\n+\n+#define BITS_BIG_ENDIAN\t\t0\n+#define BYTES_BIG_ENDIAN\t0\n+#define WORDS_BIG_ENDIAN\t0\n+\n+/* Technically, we are little endian, but we put the floats out as\n+   whole longs and this makes GCC put them out in the right order. */\n+\n+#define FLOAT_WORDS_BIG_ENDIAN\t1\n+\n+/* Note the ANSI C standard requires sizeof(char) = 1.  On the C[34]x\n+   all integral and floating point data types are stored in memory as\n+   32-bits (floating point types can be stored as 40-bits in the\n+   extended precision registers), so sizeof(char) = sizeof(short) =\n+   sizeof(int) = sizeof(long) = sizeof(float) = sizeof(double) = 1. */\n+\n+#define BITS_PER_UNIT\t\t32\n+#define BITS_PER_WORD\t\t32\n+#define UNITS_PER_WORD\t\t1\n+#define POINTER_SIZE\t\t32\n+#define PARM_BOUNDARY\t        32\n+#define STACK_BOUNDARY\t\t32\n+#define FUNCTION_BOUNDARY\t32\n+#define BIGGEST_ALIGNMENT\t32\n+#define EMPTY_FIELD_BOUNDARY\t32\n+#define STRICT_ALIGNMENT\t0\n+#define TARGET_FLOAT_FORMAT\tC4X_FLOAT_FORMAT\n+#define MAX_FIXED_MODE_SIZE\t64 /* HImode */\n+\n+/* Use the internal floating point stuff in the compiler and not the\n+   host floating point stuff. */\n+\n+#define REAL_ARITHMETIC\n+\n+/* Define register numbers */\n+\n+/* Extended-precision registers */\n+\n+#define R0_REGNO   0\n+#define R1_REGNO   1\n+#define R2_REGNO   2\n+#define R3_REGNO   3\n+#define R4_REGNO   4\n+#define R5_REGNO   5\n+#define R6_REGNO   6\n+#define R7_REGNO   7\n+\n+/* Auxiliary (address) registers */\n+\n+#define AR0_REGNO  8\n+#define AR1_REGNO  9\n+#define AR2_REGNO 10\n+#define AR3_REGNO 11\n+#define AR4_REGNO 12\n+#define AR5_REGNO 13\n+#define AR6_REGNO 14\n+#define AR7_REGNO 15\n+\n+/* Data page register */\n+\n+#define DP_REGNO  16\n+\n+/* Index registers */\n+\n+#define IR0_REGNO 17\n+#define IR1_REGNO 18\n+\n+/* Block size register */\n+\n+#define BK_REGNO  19\n+\n+/* Stack pointer */\n+\n+#define SP_REGNO  20\n+\n+/* Status register */\n+\n+#define ST_REGNO  21\n+\n+/* Misc. interrupt registers */\n+\n+#define DIE_REGNO 22\t\t/* C4x only */\n+#define IE_REGNO  22\t\t/* C3x only */\n+#define IIE_REGNO 23\t\t/* C4x only */\n+#define IF_REGNO  23\t\t/* C3x only */\n+#define IIF_REGNO 24\t\t/* C4x only */\n+#define IOF_REGNO 24\t\t/* C3x only */\n+\n+/* Repeat block registers */\n+\n+#define RS_REGNO  25\n+#define RE_REGNO  26\n+#define RC_REGNO  27\n+\n+/* Additional extended-precision registers */\n+\n+#define R8_REGNO  28\t\t/* C4x only */\n+#define R9_REGNO  29\t\t/* C4x only */\n+#define R10_REGNO 30\t\t/* C4x only */\n+#define R11_REGNO 31\t\t/* C4x only */\n+\n+#define FIRST_PSEUDO_REGISTER\t32\n+\n+/* Extended precision registers (low set) */\n+\n+#define IS_R0R1_REG(r)             ((((r) >= R0_REGNO) && ((r) <= R1_REGNO)))\n+#define IS_R2R3_REG(r)             ((((r) >= R2_REGNO) && ((r) <= R3_REGNO)))\n+#define IS_EXT_LOW_REG(r)          ((((r) >= R0_REGNO) && ((r) <= R7_REGNO)))\n+\n+/* Extended precision registers (high set) */\n+\n+#define IS_EXT_HIGH_REG(r)         (!TARGET_C3X \\\n+\t\t\t            && ((r) >= R8_REGNO) && ((r) <= R11_REGNO))\n+/* Address registers */\n+\n+#define IS_AUX_REG(r)    (((r) >= AR0_REGNO) && ((r) <= AR7_REGNO))\n+#define IS_ADDR_REG(r)   IS_AUX_REG(r)\n+#define IS_DP_REG(r)     ((r) == DP_REGNO)\n+#define IS_INDEX_REG(r)  (((r) == IR0_REGNO) || ((r) == IR1_REGNO))\n+#define IS_SP_REG(r)     ((r) == SP_REGNO)\n+#define IS_BK_REG(r)     (TARGET_BK && (r) == BK_REGNO)\n+\n+/* Misc registers */\n+\n+#define IS_ST_REG(r)     ((r) == ST_REGNO)\n+#define IS_REPEAT_REG(r) (((r) >= RS_REGNO) && ((r) <= RC_REGNO))\n+\n+/* Composite register sets */\n+\n+#define IS_ADDR_OR_INDEX_REG(r) (IS_ADDR_REG(r) || IS_INDEX_REG(r))\n+#define IS_EXT_REG(r)           (IS_EXT_LOW_REG(r) || IS_EXT_HIGH_REG(r))\n+#define IS_STD_REG(r)           (IS_ADDR_OR_INDEX_REG(r) || IS_REPEAT_REG(r) \\\n+                                 || IS_SP_REG(r) || IS_BK_REG(r))\n+#define IS_INT_REG(r)           (IS_EXT_REG(r) || IS_STD_REG(r))\n+#define IS_GROUP1_REG(r)        (IS_ADDR_OR_INDEX_REG(r) || IS_BK_REG(r))\n+\n+\n+#define IS_PSEUDO_REG(r)            ((r) >= FIRST_PSEUDO_REGISTER)\n+#define IS_R0R1_OR_PSEUDO_REG(r)    (IS_R0R1_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_R2R3_OR_PSEUDO_REG(r)    (IS_R2R3_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_EXT_OR_PSEUDO_REG(r)     (IS_EXT_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_STD_OR_PSEUDO_REG(r)     (IS_STD_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_INT_OR_PSEUDO_REG(r)     (IS_INT_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_ADDR_OR_PSEUDO_REG(r)    (IS_ADDR_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_INDEX_OR_PSEUDO_REG(r)   (IS_INDEX_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_EXT_LOW_OR_PSEUDO_REG(r) (IS_EXT_LOW_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_DP_OR_PSEUDO_REG(r)      (IS_DP_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_SP_OR_PSEUDO_REG(r)      (IS_SP_REG(r) || IS_PSEUDO_REG(r))\n+#define IS_ST_OR_PSEUDO_REG(r)      (IS_ST_REG(r) || IS_PSEUDO_REG(r))\n+\n+#define IS_PSEUDO_REGNO(op)          (IS_PSEUDO_REG(REGNO(op)))\n+#define IS_ADDR_REGNO(op)            (IS_ADDR_REG(REGNO(op)))\n+#define IS_INDEX_REGNO(op)           (IS_INDEX_REG(REGNO(op)))\n+#define IS_GROUP1_REGNO(r)           (IS_GROUP1_REG(REGNO(op)))\n+\n+#define IS_R0R1_OR_PSEUDO_REGNO(op)  (IS_R0R1_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_R2R3_OR_PSEUDO_REGNO(op)  (IS_R2R3_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_EXT_OR_PSEUDO_REGNO(op)   (IS_EXT_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_STD_OR_PSEUDO_REGNO(op)   (IS_STD_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_EXT_LOW_OR_PSEUDO_REGNO(op) (IS_EXT_LOW_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_INT_OR_PSEUDO_REGNO(op)   (IS_INT_OR_PSEUDO_REG(REGNO(op)))\n+\n+#define IS_ADDR_OR_PSEUDO_REGNO(op)  (IS_ADDR_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_INDEX_OR_PSEUDO_REGNO(op) (IS_INDEX_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_DP_OR_PSEUDO_REGNO(op)    (IS_DP_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_SP_OR_PSEUDO_REGNO(op)    (IS_SP_OR_PSEUDO_REG(REGNO(op)))\n+#define IS_ST_OR_PSEUDO_REGNO(op)    (IS_ST_OR_PSEUDO_REG(REGNO(op)))\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator. */\n+\n+#define FIXED_REGISTERS \\\n+{\t\t\t\t\t\t\t\t\t\\\n+/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 */\t\\\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\t\\\n+/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11 */\t\\\n+    1,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0\t\\\n+}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  \n+   \n+   Note that the extended precision registers are only saved in some\n+   modes.  The macro HARD_REGNO_CALL_CLOBBERED specifies which modes\n+   get clobbered for a given regno.  */\n+\n+#define CALL_USED_REGISTERS \\\n+{\t\t\t\t\t\t\t\t\t\\\n+/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7 */\t\\\n+    1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,\t\\\n+/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11 */\t\\\n+    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1\t\\\n+}\n+\n+/* Macro to conditionally modify fixed_regs/call_used_regs. */\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (!TARGET_BK)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tfixed_regs[BK_REGNO] = 1;\t\t\t\\\n+        call_used_regs[BK_REGNO] = 1;\t\t\t\\\n+        c4x_regclass_map[BK_REGNO] = NO_REGS;\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    if (TARGET_C3X)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\t int i;                                          \\\n+\t\t\t\t\t\t\t \\\n+\t reg_names[DIE_REGNO] = \"ie\";  /* clobber die */ \\\n+\t reg_names[IF_REGNO] = \"if\";   /* clobber iie */ \\\n+\t reg_names[IOF_REGNO] = \"iof\"; /* clobber iif */ \\\n+\t \t\t\t\t\t\t\\\n+\t for (i = R8_REGNO; i <= R11_REGNO; i++)\t\\\n+\t {\t\t\t\t\t\t\\\n+\t     fixed_regs[i] = call_used_regs[i] = 1;\t\\\n+\t     c4x_regclass_map[i] = NO_REGS;\t\t\\\n+\t }\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+   }\n+\n+/* Order of Allocation of Registers  */\n+\n+/* List the order in which to allocate registers.  Each register must be\n+   listed once, even those in FIXED_REGISTERS.\n+\n+   First allocate registers that don't need preservation across calls,\n+   except index and address registers.  Then allocate data registers\n+   that require preservation across calls (even though this invokes an\n+   extra overhead of having to save/restore these registers).  Next\n+   allocate the address and index registers, since using these\n+   registers for arithmetic can cause pipeline stalls.  Finally\n+   allocated the fixed registers which won't be allocated anyhow.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\\\n+{R0_REGNO, R1_REGNO, R2_REGNO, R3_REGNO, \t\t\\\n+ R9_REGNO, R10_REGNO, R11_REGNO,\t\t\t\\\n+ RS_REGNO, RE_REGNO, RC_REGNO, BK_REGNO,\t\t\\\n+ R4_REGNO, R5_REGNO, R6_REGNO, R7_REGNO, R8_REGNO,\t\\\n+ AR0_REGNO, AR1_REGNO, AR2_REGNO, AR3_REGNO,\t\t\\\n+ AR4_REGNO, AR5_REGNO, AR6_REGNO, AR7_REGNO,\t\t\\\n+ IR0_REGNO, IR1_REGNO,\t\t\t\t\t\\\n+ SP_REGNO, DP_REGNO, ST_REGNO, IE_REGNO, IF_REGNO, IOF_REGNO}\n+\n+\n+/* Determine which register classes are very likely used by spill registers.\n+   local-alloc.c won't allocate pseudos that have these classes as their\n+   preferred class unless they are \"preferred or nothing\".  */\n+\n+#define CLASS_LIKELY_SPILLED_P(CLASS) \\\n+ ((CLASS) == INDEX_REGS)\n+\n+/* CCmode is wrongly defined in machmode.def  It should have a size\n+   of UNITS_PER_WORD. */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\\\n+(((MODE) == CCmode || (MODE) == CC_NOOVmode) ? 1 : ((MODE) == HFmode) ? 1 : \\\n+((GET_MODE_SIZE(MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+\n+/* A C expression that is nonzero if the hard register REGNO is preserved\n+   across a call in mode MODE.  This does not have to include the call used\n+   registers.  */\n+\n+#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t            \\\n+     (((REGNO) == R6_REGNO || (REGNO) == R7_REGNO)                          \\\n+      && (MODE) != QFmode                                                   \\\n+      || ((REGNO) == R4_REGNO || (REGNO) == R5_REGNO || (REGNO == R8_REGNO) \\\n+\t  && ((MODE) != QImode || (MODE) != HImode || (MODE) != Pmode)))\n+\n+/* Specify the modes required to caller save a given hard regno.  */\n+\n+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS) (c4x_caller_save_map[REGNO])\n+\n+int c4x_hard_regno_mode_ok ();\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)  c4x_hard_regno_mode_ok(REGNO, MODE)\n+\n+\n+/* A C expression that is nonzero if it is desirable to choose\n+   register allocation so as to avoid move instructions between a\n+   value of mode MODE1 and a value of mode MODE2.\n+\n+   Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t0\n+\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+enum reg_class\n+  {\n+    NO_REGS,\n+    R0R1_REGS,\t\t\t/* 't' */\n+    R2R3_REGS,\t\t\t/* 'u' */\n+    EXT_LOW_REGS,\t\t/* 'q' */\n+    EXT_REGS,\t\t\t/* 'f' */\n+    ADDR_REGS,\t\t\t/* 'a' */\n+    INDEX_REGS,\t\t\t/* 'x' */\n+    SP_REG,\t\t\t/* 'b' */\n+    BK_REG,\t\t\t/* 'k' */\n+    INT_REGS,\t\t\t/* 'c' */\n+    GENERAL_REGS,\t\t/* 'r' */\n+    DP_REG,\t\t\t/* 'z' */\n+    ST_REG,\t\t\t/* 'y' */\n+    ALL_REGS,\n+    LIM_REG_CLASSES\n+  };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES \\\n+{\t\t\t\\\n+   \"NO_REGS\",\t\t\\\n+   \"R0R1_REGS\",\t\t\\\n+   \"R2R3_REGS\",\t\t\\\n+   \"EXT_LOW_REGS\",\t\\\n+   \"EXT_REGS\",\t\t\\\n+   \"ADDR_REGS\",\t\t\\\n+   \"INDEX_REGS\",\t\\\n+   \"SP_REG\",\t\t\\\n+   \"BK_REG\",\t\t\\\n+   \"INT_REGS\",\t\t\\\n+   \"GENERAL_REGS\",\t\\\n+   \"DP_REG\",\t\t\\\n+   \"ST_REG\",\t\t\\\n+   \"ALL_REGS\"\t\t\\\n+};\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+\n+#define REG_CLASS_CONTENTS \\\n+{\t\t\t\t\t\t\\\n+ 0x00000000, /*     No registers */\t\t\\\n+ 0x00000003, /* 't' R0-R1\t */\t\t\\\n+ 0x0000000c, /* 'u' R2-R3\t */\t\t\\\n+ 0x000000ff, /* 'q' R0-R7\t */\t\t\\\n+ 0xf00000ff, /* 'f' R0-R11       */\t\t\\\n+ 0x0000ff00, /* 'a' AR0-AR7 */\t\t\t\\\n+ 0x00060000, /* 'x' IR0-IR1 */\t\t\t\\\n+ 0x00100000, /* 'b' SP */\t\t\t\\\n+ 0x00080000, /* 'k' BK */\t\t\t\\\n+ 0x0e1eff00, /* 'c' AR0-AR7, IR0-IR1, RC, RS, RE, BK, SP */\t\\\n+ 0xfe1effff, /* 'r' R0-R11, AR0-AR7, IR0-IR1, RC, RS, RE, BK, SP */\\\n+ 0x00010000, /* 'z' DP */\t\t\t\\\n+ 0x00200000, /* 'y' ST */\t\t\t\\\n+ 0xffffffff, /*     All registers */\t\t\\\n+}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) (c4x_regclass_map[REGNO])\n+\n+/* When SMALL_REGISTER_CLASSES is defined, the compiler allows\n+registers explicitly used in the rtl to be used as spill registers but\n+prevents the compiler from extending the lifetime of these registers.\n+Problems can occur if reload has to spill a register used explicitly\n+in the RTL if it has a long lifetime.   This is only likely to be a problem\n+with a function having many variables and thus lots of spilling.  \n+\n+We only need to define SMALL_REGISTER_CLASSES if TARGET_PARALLEL_MPY\n+is defined since the MPY|ADD insns require the classes R0R1_REGS and\n+R2R3_REGS which are used by the function return registers (R0,R1) and\n+the register arguments (R2,R3), respectively.  I'm reluctant to define\n+this macro since it stomps on many potential optimisations.  Ideally\n+it should have a register class argument so that not all the register\n+classes gets penalised for the sake of a naughty few...  For long\n+double arithmetic we need two additional registers that we can use as\n+spill registers.  */\n+\n+#define SMALL_REGISTER_CLASSES (TARGET_SMALL_REG_CLASS && TARGET_PARALLEL_MPY)\n+\n+#define BASE_REG_CLASS\tADDR_REGS\n+#define INDEX_REG_CLASS INDEX_REGS\n+\n+/*\n+  Constraints for the C4x\n+ \n+  a - address reg (ar0-ar7)\n+  b - stack reg (sp)\n+  c - other gp int-only reg\n+  d - data/int reg (equiv. to f)\n+  f - data/float reg\n+  h - data/long double reg (equiv. to f)\n+  k - block count (bk)\n+  q - r0-r7\n+  t - r0-r1\n+  u - r2-r3\n+  x - index register (ir0-ir1)\n+  y - status register (st)\n+  z - dp reg (dp) \n+\n+  G - short float 16-bit\n+  I - signed 16-bit constant (sign extended)\n+  J - signed 8-bit constant (sign extended)  (C4x only)\n+  K - signed 5-bit constant (sign extended)  (C4x only for stik)\n+  L - unsigned 16-bit constant\n+  M - unsigned 8-bit constant                (C4x only)\n+  N - ones complement of unsigned 16-bit constant\n+  Q - indirect arx + 9-bit signed displacement\n+      (a *-arx(n) or *+arx(n) is used to account for the sign bit)\n+  R - indirect arx + 5-bit unsigned displacement  (C4x only)\n+  S - indirect arx + 0, 1, or irn displacement\n+  T - direct symbol ref\n+  > - indirect with autoincrement\n+  < - indirect with autodecrement\n+  } - indirect with post-modify\n+  { - indirect with pre-modify\n+  */\n+\n+#define REG_CLASS_FROM_LETTER(CC)\t\t\t\t\\\n+     ( ((CC) == 'a') ? ADDR_REGS\t\t\t\t\\\n+     : ((CC) == 'b') ? SP_REG\t\t\t\t\t\\\n+     : ((CC) == 'c') ? INT_REGS\t\t\t\t\t\\\n+     : ((CC) == 'd') ? EXT_REGS\t\t\t\t\t\\\n+     : ((CC) == 'f') ? EXT_REGS\t\t\t\t\t\\\n+     : ((CC) == 'h') ? EXT_REGS\t\t\t\t\t\\\n+     : ((CC) == 'k') ? BK_REG\t\t\t\t\t\\\n+     : ((CC) == 'q') ? EXT_LOW_REGS\t\t\t\t\\\n+     : ((CC) == 't') ? R0R1_REGS\t\t\t\t\\\n+     : ((CC) == 'u') ? R2R3_REGS\t\t\t\t\\\n+     : ((CC) == 'x') ? INDEX_REGS\t\t\t\t\\\n+     : ((CC) == 'y') ? ST_REG\t\t\t\t\t\\\n+     : ((CC) == 'z') ? DP_REG\t\t\t\t\t\\\n+     : NO_REGS )\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n+     (IS_ADDR_REG(REGNO) || IS_ADDR_REG((unsigned)reg_renumber[REGNO]))\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+     (IS_INDEX_REG(REGNO) || IS_INDEX_REG((unsigned)reg_renumber[REGNO]))\n+\n+extern enum reg_class c4x_preferred_reload_class ();\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) c4x_preferred_reload_class(X, CLASS)\n+\n+extern enum reg_class c4x_limit_reload_class ();\n+#define LIMIT_RELOAD_CLASS(X, CLASS) c4x_limit_reload_class(X, CLASS)\n+\n+extern enum reg_class c4x_secondary_memory_needed ();\n+#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \t\\\n+c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\\\n+(((MODE) == CCmode || (MODE) == CC_NOOVmode) ? 1 : ((MODE) == HFmode) ? 1 : \\\n+((GET_MODE_SIZE(MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+#define IS_INT5_CONST(VAL) (((VAL) <= 15) && ((VAL) >= -16))\t/* 'K' */\n+\n+#define IS_UINT5_CONST(VAL) (((VAL) <= 31) && ((VAL) >= 0))\t/* 'R' */\n+\n+#define IS_INT8_CONST(VAL) (((VAL) <= 127) && ((VAL) >= -128))\t/* 'J' */\n+\n+#define IS_UINT8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= 0))\t/* 'M' */\n+\n+#define IS_INT16_CONST(VAL) (((VAL) <= 32767) && ((VAL) >= -32768)) /* 'I' */\n+\n+#define IS_UINT16_CONST(VAL) (((VAL) <= 65535) && ((VAL) >= 0))\t/* 'L' */\n+\n+#define IS_NOT_UINT16_CONST(VAL) IS_UINT16_CONST(~(VAL))\t/* 'N' */\n+\n+#define IS_HIGH_CONST(VAL) (!TARGET_C3X && (((VAL) & 0xffff) == 0)) /* 'O' */\n+\n+\n+#define IS_DISP1_CONST(VAL) (((VAL) <= 1) && ((VAL) >= -1)) /* 'S' */\n+\n+#define IS_DISP8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= -255))\t/* 'Q' */\n+\n+#define IS_DISP1_OFF_CONST(VAL) (IS_DISP1_CONST (VAL) \\\n+\t\t\t\t && IS_DISP1_CONST (VAL + 1))\n+\n+#define IS_DISP8_OFF_CONST(VAL) (IS_DISP8_CONST (VAL) \\\n+\t\t\t\t && IS_DISP8_CONST (VAL + 1))\n+\n+#define CONST_OK_FOR_LETTER_P(VAL, C)\t\t\t\t\t\\\n+        ( ((C) == 'I') ? (IS_INT16_CONST (VAL))\t\t\t\t\\\n+\t: ((C) == 'J') ? (!TARGET_C3X && IS_INT8_CONST (VAL))\t\t\\\n+\t: ((C) == 'K') ? (!TARGET_C3X && IS_INT5_CONST (VAL))\t\t\\\n+        : ((C) == 'L') ? (IS_UINT16_CONST (VAL))\t\t\t\\\n+\t: ((C) == 'M') ? (!TARGET_C3X && IS_UINT8_CONST (VAL))\t\t\\\n+\t: ((C) == 'N') ? (IS_NOT_UINT16_CONST (VAL))\t\t        \\\n+\t: ((C) == 'O') ? (IS_HIGH_CONST (VAL))\t\t\t        \\\n+        : 0 )\t\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VAL, C) \t\t\t\t\\\n+        ( ((C) == 'G') ? (fp_zero_operand (VAL))\t\t\t\\\n+\t: ((C) == 'H') ? (c4x_H_constant (VAL)) \t\t\t\\\n+\t: 0 )\n+\n+#define EXTRA_CONSTRAINT(VAL, C) \\\n+        ( ((C) == 'Q') ? (c4x_Q_constraint (VAL))\t\t\t\\\n+\t: ((C) == 'R') ? (c4x_R_constraint (VAL))\t\t\t\\\n+\t: ((C) == 'S') ? (c4x_S_constraint (VAL))\t\t\t\\\n+\t: ((C) == 'T') ? (c4x_T_constraint (VAL))\t\t\t\\\n+\t: 0 )\n+\n+#define SMALL_CONST(VAL, insn)\t\t\t\t\t\t\\\n+     (  ((insn == NULL_RTX) || (get_attr_data (insn) == DATA_INT16))\t\\\n+\t? IS_INT16_CONST (VAL)\t\t\t\t\t\t\\\n+\t: ( (get_attr_data (insn) == DATA_NOT_UINT16)\t\t\t\\\n+\t    ? IS_NOT_UINT16_CONST (VAL)\t\t\t\t\t\\\n+\t    :  ( (get_attr_data (insn) == DATA_HIGH_16)\t\t\t\\\n+\t       ? IS_HIGH_CONST (VAL)\t\t\t\t\t\\\n+\t       : IS_UINT16_CONST (VAL)\t\t\t\t\t\\\n+\t    )\t\t\t\t\t\t\t\t\\\n+\t  )\t\t\t\t\t\t\t\t\\\n+\t)\n+\n+/*\n+   I. Routine calling with arguments in registers\n+   ----------------------------------------------\n+\n+   The TI C3x compiler has a rather unusual register passing algorithm.\n+   Data is passed in the following registers (in order):\n+\n+   AR2, R2, R3, RC, RS, RE\n+\n+   However, the first and second floating point values are always in R2\n+   and R3 (and all other floats are on the stack).  Structs are always\n+   passed on the stack.  If the last argument is an ellipsis, the\n+   previous argument is passed on the stack so that its address can be\n+   taken for the stdargs macros.\n+\n+   Because of this, we have to pre-scan the list of arguments to figure\n+   out what goes where in the list.\n+\n+   II. Routine calling with arguments on stack\n+   -------------------------------------------\n+\n+   Let the subroutine declared as \"foo(arg0, arg1, arg2);\" have local\n+   variables loc0, loc1, and loc2.  After the function prologue has\n+   been executed, the stack frame will look like:\n+\n+   [stack grows towards increasing addresses]\n+       I-------------I\n+   5   I saved reg1  I  <= SP points here\n+       I-------------I\n+   4   I saved reg0  I  \n+       I-------------I\n+   3   I       loc2  I  \n+       I-------------I  \n+   2   I       loc1  I  \n+       I-------------I  \n+   1   I       loc0  I  \n+       I-------------I\n+   0   I     old FP  I <= FP (AR3) points here\n+       I-------------I\n+   -1  I  return PC  I\n+       I-------------I\n+   -2  I       arg0  I  \n+       I-------------I  \n+   -3  I       arg1  I\n+       I-------------I  \n+   -4  I       arg2  I \n+       I-------------I  \n+\n+   All local variables (locn) are accessible by means of +FP(n+1)\n+   addressing, where n is the local variable number.\n+\n+   All stack arguments (argn) are accessible by means of -FP(n-2).\n+\n+   The stack pointer (SP) points to the last register saved in the\n+   prologue (regn).\n+\n+   Note that a push instruction performs a preincrement of the stack\n+   pointer.  (STACK_PUSH_CODE == PRE_INC)\n+\n+   III. Registers used in function calling convention\n+   --------------------------------------------------\n+\n+   Preserved across calls: R4...R5 (only by PUSH,  i.e. lower 32 bits)\n+   R6...R7 (only by PUSHF, i.e. upper 32 bits)\n+   AR3...AR7\n+\n+   (Because of this model, we only assign FP values in R6, R7 and\n+   only assign integer values in R4, R5.)\n+\n+   These registers are saved at each function entry and restored at\n+   the exit. Also it is expected any of these not affected by any\n+   call to user-defined (not service) functions.\n+\n+   Not preserved across calls: R0...R3\n+   R4...R5 (upper 8 bits)\n+   R6...R7 (lower 8 bits)\n+   AR0...AR2, IR0, IR1, BK, ST, RS, RE, RC\n+\n+   These registers are used arbitrary in a function without being preserved.\n+   It is also expected that any of these can be clobbered by any call.\n+\n+   Not used by GCC (except for in user \"asm\" statements):\n+   IE (DIE), IF (IIE), IOF (IIF)\n+\n+   These registers are never used by GCC for any data, but can be used\n+   with \"asm\" statements.  */\n+\n+#define C4X_ARG0 -2\n+#define C4X_LOC0 1\n+\n+/* Basic Stack Layout  */\n+     \n+/* The stack grows upward, stack frame grows upward, and args grow\n+   downward. */\n+\n+#define STARTING_FRAME_OFFSET\t\tC4X_LOC0\n+#define FIRST_PARM_OFFSET(FNDECL)      (C4X_ARG0 + 1)\n+#define ARGS_GROW_DOWNWARD\n+#define STACK_POINTER_OFFSET 1\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+\n+/* #define STACK_GROWS_DOWNWARD */\n+/* Like the dsp16xx, i370, i960, and we32k ports */\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+\n+/* #define FRAME_GROWS_DOWNWARD */\n+\n+\n+/* Registers That Address the Stack Frame  */\n+\n+#define STACK_POINTER_REGNUM\tSP_REGNO\t/* SP */\n+#define FRAME_POINTER_REGNUM\tAR3_REGNO\t/* AR3 */\n+#define ARG_POINTER_REGNUM\tAR3_REGNO\t/* AR3 */\n+#define STATIC_CHAIN_REGNUM\tAR0_REGNO\t/* AR0 */\n+\n+/* Eliminating Frame Pointer and Arg Pointer  */\n+\n+#define FRAME_POINTER_REQUIRED\t0\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+ int regno;\t\t\t\t\t\t\t\\\n+ int offset = 0;\t\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+      offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n+\t\t&& ((regno == R6_REGNO) || (regno == R7_REGNO)) \\\n+\t\t? 2 : 1;\t\t\t\t\t\\\n+  (DEPTH) = -(offset + get_frame_size ());\t\t\t\\\n+}\n+\n+/* This is a hack... We need to specify a register.  */\n+#define\tELIMINABLE_REGS \t\t\t\t\t\\\n+  {{ FRAME_POINTER_REGNUM, FRAME_POINTER_REGNUM }}\n+\n+#define\tCAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+  (!(((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n+  || ((FROM) == FRAME_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)))\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t \t\\\n+{\t\t\t\t\t\t\t\t\\\n+ int regno;\t\t\t\t\t\t\t\\\n+ int offset = 0;\t\t\t\t\t\t\\\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n+      offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n+\t\t&& ((regno == R6_REGNO) || (regno == R7_REGNO)) \\\n+\t\t? 2 : 1;\t\t\t\t\t\\\n+  (OFFSET) = -(offset + get_frame_size ());\t\t\t\\\n+}\n+\n+\n+/* Passing Function Arguments on the Stack  */\n+\n+#if 0\n+#define PUSH_ROUNDING(BYTES) (BYTES)\n+#endif\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n+\n+/* The following structure is used by calls.c, function.c, c4x.c  */\n+\n+typedef struct c4x_args\n+{\n+  int floats;\n+  int ints;\n+  int maxfloats;\n+  int maxints;\n+  int init;\n+  int var;\n+  int prototype;\n+  int args;\n+}\n+CUMULATIVE_ARGS;\n+\n+extern void c4x_init_cumulative_args();\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+  (c4x_init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n+\n+extern void c4x_function_arg_advance();\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (c4x_function_arg_advance (&CUM, MODE, TYPE, NAMED))\n+\n+extern struct rtx_def *c4x_function_arg();\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  (c4x_function_arg(&CUM, MODE, TYPE, NAMED))\n+\n+/* Define the profitability of saving registers around calls.\n+   NOTE: For now we turn this off because caller-save assumes\n+   that a register with a QFmode quantity can be saved/restored\n+   using QImode.  */\n+\n+/* #define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0 */\n+\n+/* Never pass data by reference.  */\n+\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) 0\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n+\n+/* 1 if N is a possible register number for function argument passing. */\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO) \\\n+\t(  (   ((REGNO) == AR2_REGNO)\t/* AR2 */\t\\\n+\t    || ((REGNO) == R2_REGNO)\t/* R2 */\t\\\n+\t    || ((REGNO) == R3_REGNO)\t/* R3 */\t\\\n+\t    || ((REGNO) == RC_REGNO)\t/* RC */\t\\\n+\t    || ((REGNO) == RS_REGNO)\t/* RS */\t\\\n+\t    || ((REGNO) == RE_REGNO))\t/* RE */\t\\\n+\t ? 1\t\t\t\t\t\t\\\n+\t : 0)\n+\n+/* How Scalar Function Values Are Returned  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+\tgen_rtx(REG, TYPE_MODE(VALTYPE), R0_REGNO)\t/* Return in R0 */\n+\n+#define LIBCALL_VALUE(MODE) \\\n+\tgen_rtx(REG, MODE, R0_REGNO)\t/* Return in R0 */\n+\n+#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == R0_REGNO)\n+\n+/* How Large Values Are Returned  */\n+\n+#define DEFAULT_PCC_STRUCT_RETURN\t0\n+#define STRUCT_VALUE_REGNUM\t\tAR0_REGNO\t/* AR0 */\n+\n+\n+/* Function Entry and Exit  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)\tc4x_function_prologue(FILE, SIZE)\n+#define FUNCTION_EPILOGUE(FILE, SIZE)\tc4x_function_epilogue(FILE, SIZE)\n+\n+\n+/* Generating Code for Profiling  */\n+\n+/* Note that the generated assembly uses the ^ operator to load the 16\n+   MSBs of the address.  This is not supported by the TI assembler.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n+     if (!TARGET_C3X)\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldhi\\t^LP%d,ar2\\n\", (LABELNO));\t\\\n+\tfprintf (FILE, \"\\tor\\t#LP%d,ar2\\n\", (LABELNO));\t\t\\\n+\tfprintf (FILE, \"\\tcall\\tmcount\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\\\n+     else\t\t\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldiu\\t^LP%d,ar2\\n\", (LABELNO));\t\\\n+\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LP%d,ar2\\n\", (LABELNO));\t\t\\\n+\tfprintf (FILE, \"\\tcall\\tmcount\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+     }\n+\n+/* There are three profiling modes for basic blocks available.\n+   The modes are selected at compile time by using the options\n+   -a or -ax of the gnu compiler.\n+   The variable `profile_block_flag' will be set according to the\n+   selected option.\n+\n+   profile_block_flag == 0, no option used:\n+\n+      No profiling done.\n+\n+   profile_block_flag == 1, -a option used.\n+\n+      Count frequency of execution of every basic block.\n+\n+   profile_block_flag == 2, -ax option used.\n+\n+      Generate code to allow several different profiling modes at run time. \n+      Available modes are:\n+             Produce a trace of all basic blocks.\n+             Count frequency of jump instructions executed.\n+      In every mode it is possible to start profiling upon entering\n+      certain functions and to disable profiling of some other functions.\n+\n+    The result of basic-block profiling will be written to a file `bb.out'.\n+    If the -ax option is used parameters for the profiling will be read\n+    from file `bb.in'.\n+\n+*/\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, BLOCKNO) \t\t\t\\\n+  if (profile_block_flag == 2)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tr2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tldhi\\t^LPBX0,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n+\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldhi\\t%d,r2\\n\", (BLOCKNO) >> 16);\t\\\n+\t    fprintf (FILE, \"\\tor\\t%d,r2\\n\", (BLOCKNO));\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+ \telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldiu\\t%d,r2\\n\", (BLOCKNO));\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_init_trace_func\\n\");\t\\\n+\tfprintf (FILE, \"\\tpop\\tr2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tr2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tldiu\\t^LPBX0,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n+\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldi\\t%d,r2\\n\", (BLOCKNO) >> 16);\t\\\n+\t    fprintf (FILE, \"\\tlsh\\t16,r2\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tor\\t%d,r2\\n\", (BLOCKNO));\t\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+ \telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldiu\\t%d,r2\\n\", (BLOCKNO));\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_init_trace_func\\n\");\t\\\n+\tfprintf (FILE, \"\\tpop\\tr2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldhi\\t^LPBX0,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tcmpi\\t0,*ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tbne\\t$+2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_init_func\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tr2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tldiu\\t^LPBX0,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX0,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldi\\t*ar2,r2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tbne\\t$+2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_init_func\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tr2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    }\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO) \t\t\t\t\\\n+  if (profile_block_flag == 2)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldhi\\t^___bb,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#___bb,ar2\\n\");\t\t\t\\\n+\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldhi\\t%d,ar0\\n\", (BLOCKNO) >> 16);\\\n+\t    fprintf (FILE, \"\\tor\\t%d,ar0\\n\", (BLOCKNO));\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+ \telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldiu\\t%d,ar0\\n\", (BLOCKNO));\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldhi\\t^LPBX0,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX0,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tsti\\tar0,*+ar2(1)\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_trace_func\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n+        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldiu\\t^___bb,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#___bb,ar2\\n\");\t\t\t\\\n+\tif (BLOCKNO > 32767)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldi\\t%d,ar0\\n\", (BLOCKNO) >> 16);\t\\\n+\t    fprintf (FILE, \"\\tlsh\\t16,ar0\\n\");\t\t\t\\\n+\t    fprintf (FILE, \"\\tor\\t%d,ar0\\n\", (BLOCKNO));\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+ \telse\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"\\tldiu\\t%d,ar0\\n\", (BLOCKNO));\t\\\n+\t  }\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldiu\\t^LPBX0,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tlsh\\t16,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX0,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tsti\\tar0,*+ar2(1)\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_trace_func\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n+        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!TARGET_C3X)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldhi\\t^LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n+\tfprintf (FILE, \"\\taddi3\\t1,*ar2,ar0\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n+        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tldiu\\t^LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n+\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tor\\t#LPBX2+%d,ar2\\n\", (BLOCKNO));\t\\\n+\tfprintf (FILE, \"\\tldiu\\t*ar2,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\taddi\\t1,ar0\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tsti\\tar0,*ar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar0\\n\");\t\t\t\t\\\n+        fprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    }\n+\n+#define FUNCTION_BLOCK_PROFILER_EXIT(FILE)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tst\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n+\tfprintf (FILE, \"\\tcall\\t___bb_trace_ret\\n\");\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n+\tfprintf (FILE, \"\\tpop\\tst\\n\");\t\t\t\t\\\n+    }\n+\n+#define\tMACHINE_STATE_SAVE(ID)\t\t\\\n+\tasm(\"\tpush\tr0\");\t\t\\\n+\tasm(\"\tpushf\tr0\");\t\t\\\n+\tasm(\"\tpush\tr1\");\t\t\\\n+\tasm(\"\tpushf\tr1\");\t\t\\\n+\tasm(\"\tpush\tr2\");\t\t\\\n+\tasm(\"\tpushf\tr2\");\t\t\\\n+\tasm(\"\tpush\tr3\");\t\t\\\n+\tasm(\"\tpushf\tr3\");\t\t\\\n+\tasm(\"\tpush\tar0\");\t\t\\\n+\tasm(\"\tpush\tar1\");\t\t\\\n+\tasm(\"\t.if\t.BIGMODEL\");\t\\\n+\tasm(\"\tpush\tdp\");\t\t\\\n+\tasm(\"\t.endif\");\t\t\\\n+\tasm(\"\tpush\tir0\");\t\t\\\n+\tasm(\"\tpush\tir1\");\t\t\\\n+\tasm(\"\tpush\tbk\");\t\t\\\n+\tasm(\"\tpush\trs\");\t\t\\\n+\tasm(\"\tpush\tre\");\t\t\\\n+\tasm(\"\tpush\trc\");\t\t\\\n+\tasm(\"\t.if\t.tms320C40\");\t\\\n+\tasm(\"\tpush\tr9\");\t\t\\\n+\tasm(\"\tpushf\tr9\");\t\t\\\n+\tasm(\"\tpush\tr10\");\t\t\\\n+\tasm(\"\tpushf\tr10\");\t\t\\\n+\tasm(\"\tpush\tr11\");\t\t\\\n+\tasm(\"\tpushf\tr11\");\t\t\\\n+\tasm(\"\t.endif\");\n+\n+#define\tMACHINE_STATE_RESTORE(ID)\t\\\n+\tasm(\"\t.if\t.tms320C40\");\t\\\n+\tasm(\"\tpopf\tr11\");\t\t\\\n+\tasm(\"\tpop\tr11\");\t\t\\\n+\tasm(\"\tpopf\tr10\");\t\t\\\n+\tasm(\"\tpop\tr10\");\t\t\\\n+\tasm(\"\tpopf\tr9\");\t\t\\\n+\tasm(\"\tpop\tr9\");\t\t\\\n+\tasm(\"\t.endif\");\t\t\\\n+\tasm(\"\tpop\trc\");\t\t\\\n+\tasm(\"\tpop\tre\");\t\t\\\n+\tasm(\"\tpop\trs\");\t\t\\\n+\tasm(\"\tpop\tbk\");\t\t\\\n+\tasm(\"\tpop\tir1\");\t\t\\\n+\tasm(\"\tpop\tir0\");\t\t\\\n+\tasm(\"\t.if\t.BIGMODEL\");\t\\\n+\tasm(\"\tpop\tdp\");\t\t\\\n+\tasm(\"\t.endif\");\t\t\\\n+\tasm(\"\tpop\tar1\");\t\t\\\n+\tasm(\"\tpop\tar0\");\t\t\\\n+\tasm(\"\tpopf\tr3\");\t\t\\\n+\tasm(\"\tpop\tr3\");\t\t\\\n+\tasm(\"\tpopf\tr2\");\t\t\\\n+\tasm(\"\tpop\tr2\");\t\t\\\n+\tasm(\"\tpopf\tr1\");\t\t\\\n+\tasm(\"\tpop\tr1\");\t\t\\\n+\tasm(\"\tpopf\tr0\");\t\t\\\n+\tasm(\"\tpop\tr0\");\t\t\\\n+\n+/* Implicit Calls to Library Routines  */\n+\n+#define MULQI3_LIBCALL      \"__mulqi3\"\n+#define DIVQI3_LIBCALL      \"__divqi3\"\n+#define UDIVQI3_LIBCALL     \"__udivqi3\"\n+#define MODQI3_LIBCALL      \"__modqi3\"\n+#define UMODQI3_LIBCALL     \"__umodqi3\"\n+\n+#define DIVQF3_LIBCALL      \"__divqf3\"\n+\n+#define MULHF3_LIBCALL      \"__mulhf3\"\n+#define DIVHF3_LIBCALL      \"__divhf3\"\n+\n+#define MULHI3_LIBCALL      \"__mulhi3\"\n+#define SMULHI3_LIBCALL     \"__smulhi3_high\"\n+#define UMULHI3_LIBCALL     \"__umulhi3_high\"\n+#define DIVHI3_LIBCALL      \"__divhi3\"\n+#define UDIVHI3_LIBCALL     \"__udivhi3\"\n+#define MODHI3_LIBCALL      \"__modhi3\"\n+#define UMODHI3_LIBCALL     \"__umodhi3\"\n+\n+#define FLOATHIQF2_LIBCALL  \"__floathiqf2\"\n+#define FLOATUNSHIQF2_LIBCALL  \"__ufloathiqf2\"\n+#define FIX_TRUNCQFHI2_LIBCALL \"__fix_truncqfhi2\"\n+#define FIXUNS_TRUNCQFHI2_LIBCALL \"__ufix_truncqfhi2\"\n+\n+#define FLOATHIHF2_LIBCALL  \"__floathihf2\"\n+#define FLOATUNSHIHF2_LIBCALL  \"__ufloathihf2\"\n+#define FIX_TRUNCHFHI2_LIBCALL \"__fix_trunchfhi2\"\n+#define FIXUNS_TRUNCHFHI2_LIBCALL \"__ufix_trunchfhi2\"\n+\n+#define FFS_LIBCALL\t    \"__ffs\"\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* Add any extra modes needed to represent the condition code.\n+\n+   On the C4x, we have a \"no-overflow\" mode which is used when an ADD,\n+   SUB, NEG, or MPY insn is used to set the condition code.  This is\n+   to prevent the combiner from optimising away a following CMP of the\n+   result with zero when a signed conditional branch or load insn\n+   follows.\n+\n+   The problem is a subtle one and deals with the manner in which the\n+   negative condition (N) flag is used on the C4x.  This flag does not\n+   reflect the status of the actual result but of the ideal result had\n+   no overflow occured (when considering signed operands).\n+\n+   For example, 0x7fffffff + 1 => 0x80000000 Z=0 V=1 N=0 C=0.  Here\n+   the flags reflect the untruncated result, not the actual result.\n+   While the actual result is less than zero, the N flag is not set\n+   since the ideal result of the addition without truncation would\n+   have been positive.\n+   \n+   Note that the while the N flag is handled differently to most other\n+   architectures, the use of it is self consistent and is not the\n+   cause of the problem.\n+\n+   Logical operations set the N flag to the MSB of the result so if\n+   the result is negative, N is 1.  However, integer and floating\n+   point operations set the N flag to be the MSB of the result\n+   exclusive ored with the overflow (V) flag.  Thus if an overflow\n+   occurs and the result does not have the MSB set (i.e., the result\n+   looks like a positive number), the N flag is set.  Conversely, if\n+   an overflow occurs and the MSB of the result is set, N is set to 0.\n+   Thus the N flag represents the sign of the result if it could have\n+   been stored without overflow but does not represent the apparent\n+   sign of the result.  Note that most architectures set the N flag to\n+   be the MSB of the result.\n+\n+   The C4x approach to setting the N flag simplifies signed\n+   conditional branches and loads which only have to test the state of\n+   the N flag, whereas most architectures have to look at both the N\n+   and V flags.  The disadvantage is that there is no flag giving the\n+   status of the sign bit of the operation.  However, there are no\n+   conditional load or branch instructions that make use of this\n+   feature (e.g., BMI---branch minus) instruction.  Note that BN and\n+   BLT are identical in the C4x.\n+   \n+   To handle the problem where the N flag is set differently whenever\n+   there is an overflow we use a different CC mode, CC_NOOVmode which\n+   says that the CC reflects the comparison of the result against zero\n+   if no overflow occured.\n+\n+   For example, \n+\n+   [(set (reg:CC_NOOV 21)\n+         (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"\")\n+                                    (match_operand:QI 2 \"src_operand\" \"\"))\n+                          (const_int 0)))\n+    (set (match_operand:QI 0 \"ext_reg_operand\" \"\")\n+         (minus:QI (match_dup 1)\n+                   (match_dup 2)))]\n+\n+   Note that there is no problem for insns that don't return a result\n+   like CMP, since the CC reflects the effect of operation.\n+\n+   An example of a potential problem is when GCC\n+   converts   (LTU (MINUS (0x80000000) (0x7fffffff) (0x80000000)))\n+   to         (LEU (MINUS (0x80000000) (0x7fffffff) (0x7fffffff)))\n+   to         (GE  (MINUS (0x80000000) (0x7fffffff) (0x00000000)))\n+\n+   Now (MINUS (0x80000000) (0x7fffffff)) returns 0x00000001 but the\n+   C4x sets the N flag since the result without overflow would have\n+   been 0xffffffff when treating the operands as signed integers.\n+   Thus (GE (MINUS (0x80000000) (0x7fffffff) (0x00000000))) sets the N\n+   flag but (GE (0x00000001)) does not set the N flag.\n+\n+   The upshot is that we can not use signed branch and conditional\n+   load instructions after an add, subtract, neg, abs or multiply.\n+   We must emit a compare insn to check the result against 0.  */\n+\n+#define EXTRA_CC_MODES CC_NOOVmode\n+\n+/* Define the names for the modes specified above.  */\n+\n+#define EXTRA_CC_NAMES \"CC_NOOV\"\n+\n+/* CC_NOOVmode should be used when the first operand is a PLUS, MINUS, NEG\n+   or MULT.\n+   CCmode should be used when no special processing is needed. */\n+#define SELECT_CC_MODE(OP,X,Y) \\\n+  ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\\\n+    || GET_CODE (X) == NEG || GET_CODE (X) == MULT\t\t\\\n+    || GET_MODE (X) == ABS\t\t\t\t\t\\\n+    || GET_CODE (Y) == PLUS || GET_CODE (Y) == MINUS\t\t\\\n+    || GET_CODE (Y) == NEG || GET_CODE (Y) == MULT\t\t\\\n+    || GET_MODE (Y) == ABS)\t\t\t\t\t\\\n+    ? CC_NOOVmode : CCmode)\n+\n+extern struct rtx_def *c4x_gen_compare_reg ();\n+\n+/* Addressing Modes  */\n+\n+#define HAVE_POST_INCREMENT\n+#define HAVE_PRE_INCREMENT\n+#define HAVE_POST_DECREMENT\n+#define HAVE_PRE_DECREMENT\n+#define HAVE_PRE_MODIFY_REG\n+#define HAVE_POST_MODIFY_REG\n+#define HAVE_PRE_MODIFY_DISP\n+#define HAVE_POST_MODIFY_DISP\n+\n+/* What about LABEL_REF?  */\n+#define CONSTANT_ADDRESS_P(X) (GET_CODE (X) == SYMBOL_REF)\n+\n+#define MAX_REGS_PER_ADDRESS\t2\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+extern int c4x_check_legit_addr ();\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard or pseudo reg that can be used as an base.  */\n+\n+#define REG_OK_FOR_BASE_P(X) IS_ADDR_OR_PSEUDO_REG(REGNO(X))\n+\n+/* Nonzero if X is a hard or pseudo reg that can be used as an index.  */\n+\n+#define REG_OK_FOR_INDEX_P(X) IS_INDEX_OR_PSEUDO_REG(REGNO(X))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (c4x_check_legit_addr (MODE, X, 0))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+}\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (c4x_check_legit_addr (MODE, X, 1))\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+}\n+\n+#endif\n+\n+extern struct rtx_def *c4x_legitimize_address ();\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx new;\t\t\t\t\t\t\t\t\\\n+  new = c4x_legitimize_address (X, MODE);\t\t\t\t\\\n+  if (new != NULL_RTX)\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    (X) = new;\t\t\t\t\t\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+\n+/* No mode-dependent addresses on the C4x are autoincrements.  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n+  if (GET_CODE (ADDR) == PRE_DEC\t\\\n+      || GET_CODE (ADDR) == POST_DEC\t\\\n+      || GET_CODE (ADDR) == PRE_INC\t\\\n+      || GET_CODE (ADDR) == POST_INC\t\\\n+      || GET_CODE (ADDR) == POST_MODIFY\t\\\n+      || GET_CODE (ADDR) == PRE_MODIFY)\t\\\n+    goto LABEL\n+\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE. \n+\n+   The C4x can only load 16-bit immediate values, so we only allow\n+   a restricted subset of CONST_INT and CONST_DOUBLE and reject\n+   LABEL_REF, SYMBOL_REF, CONST, and HIGH codes.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n+  (GET_CODE (X) == CONST_DOUBLE && c4x_H_constant (X)\t\t\\\n+  || GET_CODE (X) == CONST_INT && c4x_I_constant (X))\n+\n+\n+#define LEGITIMATE_DISPLACEMENT_P(X) IS_DISP8_CONST (INTVAL (X))\n+\n+/* Descripting Relative Cost of Operations  */\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. \n+\n+   Note that we return, rather than break so that rtx_cost doesn't\n+   include CONST_COSTS otherwise expand_mult will think that it is\n+   cheaper to synthesise a multiply rather than to use a multiply\n+   instruction.  I think this is because the algorithm synth_mult\n+   doesn't take into account the loading of the operands, whereas the\n+   calculation of mult_cost does. \n+*/\n+\n+\n+#define RTX_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\t\\\n+    case MULT:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT \\\n+\t\t\t  || TARGET_MPYI ? 1 : 14);\t\t\t\\\n+    case DIV:  case UDIV: case MOD: case UMOD: \t\t\t\t\\\n+    return COSTS_N_INSNS (GET_MODE_CLASS (GET_MODE (RTX)) == MODE_FLOAT\t\\\n+\t\t\t  ? 15 : 50);\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.\n+\n+   An insn is assumed to cost 4 units.\n+   COSTS_N_INSNS (N) is defined as (N) * 4 - 2.\n+\n+   Some small integers are effectively free for the C40.  We should\n+   also consider if we are using the small memory model.  With\n+   the big memory model we require an extra insn for a constant\n+   loaded from memory.  */\n+\n+#define SHIFT_CODE_P(C) ((C) == ASHIFT || (C) == ASHIFTRT || (C) == LSHIFTRT)\n+\n+#define LOGICAL_CODE_P(C) ((C) == NOT || (C) == AND \\\n+                           || (C) == IOR || (C) == XOR)\n+\n+#define NON_COMMUTATIVE_CODE_P ((C) == MINUS || (C) == COMPARE)\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE)\t\t\t\\\n+\tcase CONST_INT:\t\t\t\t\t\t\\\n+           if (c4x_J_constant (RTX))\t\t\t\t\\\n+\t     return 0;\t\t\t\t\t\t\\\n+           if (TARGET_C3X && SHIFT_CODE_P (OUTER_CODE))\t\t\\\n+\t     return 3;\t\t\t\t\t\t\\\n+           if (LOGICAL_CODE_P (OUTER_CODE) \t\t\t\\\n+               ? c4x_L_constant (RTX) : c4x_I_constant (RTX))\t\\\n+\t     return 2;\t\t\t\t\t\t\\\n+\tcase CONST:\t\t\t\t\t\t\\\n+\tcase LABEL_REF:\t\t\t\t\t\t\\\n+\tcase SYMBOL_REF:\t\t\t\t\t\\\n+\t   return 4;\t\t\t\t\t\t\\\n+\tcase CONST_DOUBLE:\t\t\t\t\t\\\n+\t   if (c4x_H_constant (RTX))\t\t\t\t\\\n+\t     return 2;\t\t\t\t\t\t\\\n+           if (GET_MODE (RTX) == QFmode)\t\t\t\\\n+\t     return 4;\t\t\t\t\t\t\\\n+           else\t\t\t\t\t\t\t\\\n+\t     return 8;\n+\n+/* Compute the cost of an address.  This is meant to approximate the size\n+   and/or execution delay of an insn using that address.  If the cost is\n+   approximated by the RTL complexity, including CONST_COSTS above, as\n+   is usually the case for CISC machines, this macro should not be defined.\n+   For aggressively RISCy machines, only one insn format is allowed, so\n+   this macro should be a constant.  The value of this macro only matters\n+   for valid addresses.  We handle the most common address without \n+   a call to c4x_address_cost.  */\n+\n+extern int c4x_address_cost ();\n+\n+#define ADDRESS_COST(ADDR) (REG_P (ADDR) ? 1 : c4x_address_cost (ADDR))\n+\n+#define\tCANONICALIZE_COMPARISON(CODE, OP0, OP1)\t\t\\\n+if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  rtx tmp = OP0; OP0 = OP1 ; OP1 = tmp;\t\t\t\\\n+  CODE = swap_condition (CODE);\t\t\t\t\\\n+}\n+\n+#define EXT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, EXT_REGS))\n+#define ADDR_CLASS_P(CLASS) (reg_class_subset_p (CLASS, ADDR_REGS))\n+#define INDEX_CLASS_P(CLASS) (reg_class_subset_p (CLASS, INDEX_REGS))\n+#define EXPENSIVE_CLASS_P(CLASS) (ADDR_CLASS_P(CLASS) \\\n+                          || INDEX_CLASS_P(CLASS) || (CLASS) == SP_REG)\n+\n+/* Make the Rx register a little easier to use so they are used for\n+   calculations and the ARx registers are used for addressing. */\n+\n+#define REGISTER_MOVE_COST(FROM, TO) \\\n+(EXPENSIVE_CLASS_P(TO) ? 5 : EXPENSIVE_CLASS_P(FROM) ? 4 : 3)\n+\n+/* Memory move cost is same as fast register move.  Maybe this should\n+   be bumped up? */\n+\n+#define MEMORY_MOVE_COST(M,C,I)\t\t4\n+\n+/* Branches are kind of expensive (even with delayed branching) so\n+   make their cost higher.  */\n+\n+#define BRANCH_COST\t\t\t8\n+\n+/* Adjust the cost of dependencies.  */\n+\n+#define ADJUST_COST(INSN,LINK,DEP,COST) \\\n+  (COST) = c4x_adjust_cost (INSN, LINK, DEP, COST)\n+\n+#define\tWORD_REGISTER_OPERATIONS\n+\n+/* Dividing the Output into Sections  */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+#define USE_CONST_SECTION 1\n+\n+#define CONST_SECTION_ASM_OP \"\\t.sect\\t\\\".const\\\"\"\n+\n+/* Do not use .init section so __main will be called on startup. This will\n+   call __do_global_ctors and prepare for __do_global_dtors on exit. */\n+\n+#if 0\n+#define INIT_SECTION_ASM_OP  \"\\t.sect\\t\\\".init\\\"\"\n+#endif\n+\n+#define FINI_SECTION_ASM_OP  \"\\t.sect\\t\\\".fini\\\"\"\n+\n+/* Support const sections and the ctors and dtors sections for g++.\n+   Note that there appears to be two different ways to support const\n+   sections at the moment.  You can either #define the symbol\n+   READONLY_DATA_SECTION (giving it some code which switches to the\n+   readonly data section) or else you can #define the symbols\n+   EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side. */\n+\n+/* Define a few machine-specific details of the implementation of\n+   constructors.\n+\n+   The __CTORS_LIST__ goes in the .ctors section.  Define CTOR_LIST_BEGIN\n+   and CTOR_LIST_END to contribute to the .ctors section an instruction to\n+   push a word containing 0 (or some equivalent of that).\n+\n+   Define ASM_OUTPUT_CONSTRUCTOR to push the address of the constructor.  */\n+\n+#define CTORS_SECTION_ASM_OP\t\"\\t.sect\\t\\\".ctors\\\"\"\n+#define DTORS_SECTION_ASM_OP    \"\\t.sect\\t\\\".dtors\\\"\"\n+\n+/* Constructor list on stack is in reverse order.  Go to the end of the\n+   list and go backwards to call constructors in the right order.  */\n+\n+#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  extern func_ptr __CTOR_LIST__[];\t\t\t\t\\\n+  func_ptr *p, *beg = __CTOR_LIST__ + 1;\t\t\t\\\n+  for (p = beg; *p ; p++) ;\t\t\t\t\t\\\n+  while (p != beg)\t\t\t\t\t\t\\\n+    (*--p) ();\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* The TI tooling uses atexit. */\n+#define\tON_EXIT(FUNC,ARG)\tatexit (FUNC)\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS in_const, in_init, in_fini, in_ctors, in_dtors\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+  CONST_SECTION_FUNCTION\t\t\t\t\t\\\n+  INIT_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  FINI_SECTION_FUNCTION\t\t\t\t\t\t\\\n+  CTORS_SECTION_FUNCTION\t\t\t\t\t\\\n+  DTORS_SECTION_FUNCTION\n+\n+#define INIT_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+init_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_init)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \";\\t.init\\n\");\t\t\t\\\n+      in_section = in_init;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define FINI_SECTION_FUNCTION\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+fini_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_fini)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"\\t%s\\n\", FINI_SECTION_ASM_OP);\t\\\n+      in_section = in_fini;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define READONLY_DATA_SECTION() const_section ()\n+\n+#define CONST_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  extern void text_section();\t\t\t\t\t\t\\\n+  if (!USE_CONST_SECTION)\t\t\t\t\t\t\\\n+    text_section();\t\t\t\t\t\t\t\\\n+  else if (in_section != in_const)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP);\t\t\\\n+      in_section = in_const;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_STABS_OP \"\\t.stabs\"\n+\n+/* The ctors and dtors sections are not normally put into use \n+   by EXTRA_SECTIONS and EXTRA_SECTION_FUNCTIONS as defined in svr3.h,\n+   but it can't hurt to define these macros for whatever systems use them.  */\n+\n+#define CTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+ctors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_ctors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", CTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_ctors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define DTORS_SECTION_FUNCTION\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\t\\\n+dtors_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_dtors)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", DTORS_SECTION_ASM_OP);\t\t\\\n+      in_section = in_dtors;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_SECTION_NAME(FILE, DECL, NAME, RELOC) \\\n+   fprintf (FILE, \"\\t.sect\\t\\\"%s\\\"\\n\", NAME);\n+\n+/* This is machine-dependent because it needs to push something\n+   on the stack.  */\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global constructors.  */\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    ctors_section ();\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.word\\t \");\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement (sans semicolon) to output an element in the table of\n+   global destructors.  */\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    dtors_section ();                   \t\t\t\t\\\n+    fprintf (FILE, \"\\t.word\\t \");\t\t\t\t\t\\\n+    assemble_name (FILE, NAME);              \t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of DECL.  DECL is either a `VAR_DECL' node\n+   or a constant of some sort.  RELOC indicates whether forming\n+   the initial value of DECL requires link-time relocations.  */\n+\n+#define SELECT_SECTION(DECL, RELOC)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == STRING_CST)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! flag_writable_strings)\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((0 && RELOC)\t/* should be (flag_pic && RELOC) */\t\t\\\n+\t  || !TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL)\t\t\\\n+\t  || !DECL_INITIAL (DECL)\t\t\t\t\t\\\n+\t  || (DECL_INITIAL (DECL) != error_mark_node\t\t\t\\\n+\t      && !TREE_CONSTANT (DECL_INITIAL (DECL))))\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    const_section ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* A C statement or statements to switch to the appropriate\n+   section for output of RTX in mode MODE.  RTX is some kind\n+   of constant in RTL.  The argument MODE is redundant except\n+   in the case of a `const_int' rtx.  Currently, these always\n+   go into the const section.  */\n+\n+#define SELECT_RTX_SECTION(MODE, RTX) const_section()\n+\n+\n+/* Overall Framework of an Assembler File  */\n+\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+    int dspversion = 0;\t\t\t\t\t\t\\\n+    if (TARGET_C30) dspversion = 30;\t\t\t\t\\\n+    if (TARGET_C31) dspversion = 31;\t\t\t\t\\\n+    if (TARGET_C32) dspversion = 32;\t\t\t\t\\\n+    if (TARGET_C40) dspversion = 40;\t\t\t\t\\\n+    if (TARGET_C44) dspversion = 44;\t\t\t\t\\\n+    fprintf (FILE, \"\\t.version\\t%d\\n\", dspversion);\t\t\\\n+    fprintf (FILE, \"\\t.file\\t\");\t\t\t\t\\\n+    if (TARGET_TI)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+        char *p;\t\t\t\t\t\t\\\n+        char *after_dir = main_input_filename;\t\t\t\\\n+\tfor (p = main_input_filename; *p; p++)\t\t\t\\\n+\t  if (*p == '/')\t\t\t\t\t\\\n+\t    after_dir = p + 1;\t\t\t\t\t\\\n+\toutput_quoted_string (FILE, after_dir);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      output_quoted_string (FILE, main_input_filename);\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+}\n+\n+#define ASM_FILE_END(FILE)   fprintf (FILE, \"\\t.end\\n\")\n+\n+/* We need to have a data section we can identify so that we can set\n+   the DP register back to a data pointer in the small memory model.\n+   This is only required for ISRs if we are paranoid that someone\n+   may have quietly changed this register on the sly. */\n+\n+#define ASM_IDENTIFY_GCC(FILE) \\\n+    if (!TARGET_TI) fputs (\"gcc2_compiled.:\\n\", FILE);\t\\\n+      fputs (\"\\t.data\\ndata_sec:\\n\", FILE);\n+\n+#define ASM_COMMENT_START\t\";\"\n+\n+#define ASM_APP_ON \"\"\n+#define ASM_APP_OFF \"\"\n+\n+/* Output float/double constants  QFmode.  */\n+\n+#define ASM_OUTPUT_BYTE_FLOAT(FILE, VALUE)\t\t\\\n+{   long l;\t\t\t\t\t\t\\\n+    char str[30];\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+    REAL_VALUE_TO_DECIMAL (VALUE, \"%20f\", str);\t\t\\\n+    if (sizeof (int) == sizeof (long))\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t0%08xh\\t; %s\\n\", l, str);\\\n+    else\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t0%08lxh\\t; %s\\n\", l, str);\\\n+}\n+\n+/* Output long double constants  HFmode. \n+   The first word contains the exponent and first part of the mantissa\n+   in the same manner as QFmode.  The second word contains the full\n+   mantissa.  We should ensure that the two words are allocated within\n+   the same page for the large memory model since we only output a single\n+   LDP instruction.  FIXME.  The simplest solution probably is to output\n+   a LDP for each load.  */\n+\n+#define ASM_OUTPUT_SHORT_FLOAT(FILE, VALUE)\t\t\\\n+{   long l[2];\t\t\t\t\t\t\\\n+    char str[30];\t\t\t\t\t\\\n+    REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\\\n+    REAL_VALUE_TO_DECIMAL (VALUE, \"%20f\", str);\t\t\\\n+    l[1] = (l[0] << 8) | ((l[1] >> 24) & 0xff);\t\t\\\n+    if (sizeof (int) == sizeof (long))\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t0%08xh\\t; %s\\n\\t.word\\t0%08xh\\n\", \\\n+               l[0], str, l[1]);\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.word\\t0%08lxh\\t; %s\\n\\t.word\\t0%08lxh\\n\", \\\n+               l[0], str, l[1]);\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\t\\\n+{    fprintf (FILE, \"\\t.word\\t\");\t\t\t\\\n+     output_addr_const (FILE, VALUE);\t\t\t\\\n+     if (GET_CODE (VALUE) != SYMBOL_REF)\t\t\\\n+       fprintf (FILE, \" ; 0%08xh\\n\", INTVAL (VALUE));\t\\\n+     else\t\t\t\t\t\t\\\n+       fputc ('\\n', FILE);\t\t\t\t\\\n+}\n+\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word\\t0%xh\\n\", (VALUE))\n+\n+extern void c4x_output_ascii ();\n+#define ASM_OUTPUT_ASCII(FILE, PTR, LEN) c4x_output_ascii (FILE, PTR, LEN)\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+\n+/* Output and Generation of Labels  */\n+\n+#define NO_DOT_IN_LABEL\t\t/* Only required for TI format */\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\\\n+{ assemble_name (FILE, NAME); fputs (\":\\n\", FILE); }\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME) \\\n+{                                       \\\n+    fprintf (FILE, \"\\t.global\\t\");\t\\\n+    assemble_name (FILE, NAME);\t\t\\\n+    fputs (\"\\n\", FILE); \t        \\\n+}\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\\\n+{                                            \t\\\n+    fprintf (FILE, \"\\t.ref\\t\");\t\t\t\\\n+    assemble_name (FILE, NAME);\t             \t\\\n+    fputc ('\\n', FILE);  \t               \t\\\n+}\n+\n+/* A C statement to output on FILE an assembler pseudo-op to\n+   declare a library function named external.\n+   (Only needed to keep asm30 happy for ___divqf3 etc.) */\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)  \\\n+{\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t.ref\\t\");\t\t\t\\\n+    assemble_name (FILE, XSTR (FUN, 0));\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\\\n+}\n+\n+/* The prefix to add to user-visible assembler symbols.  */\n+\n+#define USER_LABEL_PREFIX \"_\"\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\\\n+asm_fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(BUFFER, PREFIX, NUM) \\\n+    sprintf (BUFFER, \"*%s%d\", PREFIX, NUM)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),    \\\n+  sprintf ((OUTPUT), \"%s%d\", (NAME), (LABELNO)))\n+\n+\n+/* Output of Dispatch Tables  */\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+    fprintf (FILE, \"\\t.long\\tL%d\\n\", VALUE);\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+    fprintf (FILE, \"\\t.long\\tL%d-L%d\\n\", VALUE, REL);\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+#define INT_TYPE_SIZE\t\t32\n+#define LONG_LONG_TYPE_SIZE\t64\n+#define FLOAT_TYPE_SIZE\t\t32\n+#define DOUBLE_TYPE_SIZE\t32\n+#define LONG_DOUBLE_TYPE_SIZE\t64 /* actually only 40 */\n+\n+/* Allow #sccs in preprocessor.  */\n+\n+#define SCCS_DIRECTIVE\n+\n+/* Output #ident as a .ident.  */\n+\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+#define CPP_PREDEFINES \"\"\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\"\\t.bss\\t\", FILE),\t\t\t\\\n+  assemble_name (FILE, (NAME)),\t\t\\\n+  fprintf (FILE, \",%u\\n\", (ROUNDED)))\n+\n+/* Output of Uninitialized Variables  */\n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+(  fputs (\"\\t.globl\\t\", FILE),\t\\\n+   assemble_name (FILE, (NAME)),\t\\\n+   fputs (\"\\n\\t.bss\\t\", FILE),\t\\\n+   assemble_name (FILE, (NAME)),\t\\\n+   fprintf (FILE, \",%u\\n\", (ROUNDED)))\n+\n+/* Macros Controlling Initialization Routines  */\n+\n+#define OBJECT_FORMAT_COFF\n+#define REAL_NM_FILE_NAME \"c4x-nm\"\n+\n+/* Output of Assembler Instructions  */\n+\n+/* Register names when used for integer modes.  */\n+\n+#define REGISTER_NAMES \\\n+{\t\t\t\t\t\t\t\t\\\n+ \"r0\",   \"r1\", \"r2\",   \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\\\n+ \"ar0\", \"ar1\", \"ar2\", \"ar3\", \"ar4\", \"ar5\", \"ar6\", \"ar7\",\t\\\n+ \"dp\",  \"ir0\", \"ir1\",  \"bk\",  \"sp\",  \"st\", \"die\", \"iie\",\t\\\n+ \"iif\",\t \"rs\",  \"re\",  \"rc\",  \"r8\",  \"r9\", \"r10\", \"r11\"\t\t\\\n+}\n+\n+/* Alternate register names when used for floating point modes.  */\n+\n+#define FLOAT_REGISTER_NAMES \\\n+{\t\t\t\t\t\t\t\t\\\n+ \"f0\",   \"f1\", \"f2\",   \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",\t\\\n+ \"ar0\", \"ar1\", \"ar2\", \"ar3\", \"ar4\", \"ar5\", \"ar6\", \"ar7\",\t\\\n+ \"dp\",  \"ir0\", \"ir1\",  \"bk\",  \"sp\",  \"st\", \"die\", \"iie\",\t\\\n+ \"iif\",\t \"rs\",  \"re\",  \"rc\",  \"f8\",  \"f9\", \"f10\", \"f11\"\t\t\\\n+}\n+\n+\n+extern void c4x_print_operand ();\n+#define PRINT_OPERAND(FILE, X, CODE) c4x_print_operand(FILE, X, CODE)\n+\n+/* Determine which codes are valid without a following integer.  These must\n+   not be alphabetic. */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n+\n+extern void c4x_print_operand_address ();\n+#define PRINT_OPERAND_ADDRESS(FILE, X) c4x_print_operand_address(FILE, X)\n+\n+/* Define this macro if you want to implement any pragmas.  If defined, it\n+   should be a C expression to be executed when #pragma is seen.  The\n+   argument STREAM is the stdio input stream from which the source\n+   text can be read.  CH is the first character after the #pragma.  The\n+   result of the expression is the terminating character found\n+   (newline or EOF).  */\n+extern int c4x_handle_pragma ();\n+#define HANDLE_PRAGMA(GETC, UNGETC, NAME) \\\n+  c4x_handle_pragma (GETC, UNGETC, NAME)\n+\n+extern void c4x_set_default_attributes ();\n+#define SET_DEFAULT_DECL_ATTRIBUTES(DECL, ATTRIBUTES) \\\n+  c4x_set_default_attributes (DECL, &ATTRIBUTES)\n+\n+extern int c4x_valid_type_attribute_p ();\n+#define VALID_MACHINE_TYPE_ATTRIBUTE(TYPE, ATTRIBUTES, NAME, ARGS) \\\n+  (c4x_valid_type_attribute_p (TYPE, ATTRIBUTES, NAME, ARGS))\n+\n+/* Assembler Commands for Alignment  */\n+\n+#define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n+{ int c = SIZE; \\\n+  for (; c > 0; --c) \\\n+   fprintf (FILE,\"\\t.word\\t0\\n\"); \\\n+}\n+\n+#define ASM_NO_SKIP_IN_TEXT 1\n+\n+/* I'm not sure about this one.  FIXME. */\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n+  if ((LOG) != 0)\t\t\t\\\n+    fprintf (FILE, \"\\t.align\\t%d\\n\", (1 << (LOG)))\n+\n+\n+/* Macros for SDB and DWARF Output  (use .sdef instead of .def\n+   to avoid conflict with TI's use of .def)  */\n+\n+#define SDB_DELIM \"\\n\"\n+#define SDB_DEBUGGING_INFO\n+\n+#define PUT_SDB_DEF(A)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, A); \t\\\n+     fprintf (asm_out_file, SDB_DELIM); } while (0)\n+\n+#define PUT_SDB_PLAIN_DEF(A)\t\t\t\\\n+  fprintf (asm_out_file,\"\\t.sdef\\t.%s%s\", A, SDB_DELIM)\n+\n+#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.sdef\\t.bb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.sdef\\t.eb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.sdef\\t.bf%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.sdef\\t.ef%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\t\t\\\n+do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, NAME);\t\t\\\n+     fprintf (asm_out_file,\t\t\t\t\\\n+\t      \"%s\\t.val\\t.%s\\t.scl\\t-1%s\\t.endef\\n\",\t\\\n+\t      SDB_DELIM, SDB_DELIM, SDB_DELIM); } while (0)\n+\n+\n+/* Define results of standard character escape sequences.  */\n+\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* A function address in a call instruction is a byte address (for\n+   indexing purposes) so give the MEM rtx a byte's mode.  */\n+\n+#define FUNCTION_MODE QImode\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Specify the machine mode that pointers have.  After generation of\n+   RTL, the compiler makes no further distinction between pointers and\n+   any other objects of this machine mode.  */\n+\n+#define Pmode QImode\n+\n+/* On the C4x we can write the following code. We have to clear the cache\n+   every time we execute it because the data in the stack could change.\n+\n+   laj   $+4\n+   addi3 4,r11,ar0\n+   lda   *ar0,ar1\n+   lda   *+ar0(1),ar0\n+   bud   ar1\n+   nop\n+   nop\n+   or   1000h,st\n+   .word FNADDR\n+   .word CXT\n+\n+   On the c3x this is a bit more difficult. We have to write self\n+   modifying code here. So we have to clear the cache every time\n+   we execute it because the data in the stack could change.\n+\n+   ldiu TOP_OF_FUNCTION,ar1\n+   lsh  16,ar1\n+   or   BOTTOM_OF_FUNCTION,ar1\n+   ldiu TOP_OF_STATIC,ar0\n+   bud  ar1\n+   lsh  16,ar0\n+   or   BOTTOM_OF_STATIC,ar0\n+   or   1000h,st\n+   \n+  */\n+\n+#define TRAMPOLINE_SIZE (TARGET_C3X ? 8 : 10)\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (TARGET_C3X)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\tldiu\\t0,ar1\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tlsh\\t16,ar1\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tor\\t0,ar1\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tldiu\\t0,ar0\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tbud\\tar1\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tlsh\\t16,ar0\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tor\\t0,ar0\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tor\\t1000h,st\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\tlaj\\t$+4\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\taddi3\\t4,r11,ar0\\n\");\t\t\\\n+      asm_fprintf (FILE, \"\\tlda\\t*ar0,ar1\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tlda\\t*+ar0(1),ar0\\n\");\t\t\\\n+      asm_fprintf (FILE, \"\\tbud\\tar1\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\\\n+      asm_fprintf (FILE, \"\\tor\\t1000h,st\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\t.word\\t0\\n\");\t\t\t\\\n+      asm_fprintf (FILE, \"\\t.word\\t0\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_C3X)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx tmp1, tmp2;\t\t\t\t\t\t\t\\\n+      tmp1 = expand_shift (RSHIFT_EXPR, QImode, FNADDR,\t\t\t\\\n+\t\t\t   size_int (16), 0, 1);\t\t\t\\\n+      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode, 0x5069),\t\\\n+\t\t\t   size_int (16), 0, 1);\t\t\t\\\n+      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+\t\t\t       plus_constant (tramp, 0)), tmp1);\t\\\n+      tmp1 = expand_and (FNADDR, gen_rtx (CONST_INT, VOIDmode,\t\t\\\n+\t\t\t\t\t  0xffff), 0);\t\t\t\\\n+      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode, 0x1069),\t\\\n+\t\t\t   size_int (16), 0, 1);\t\t\t\\\n+      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+\t\t\t       plus_constant (tramp, 2)), tmp1);\t\\\n+      tmp1 = expand_shift (RSHIFT_EXPR, QImode, CXT,\t\t\t\\\n+\t\t\t   size_int (16), 0, 1);\t\t\t\\\n+      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode, 0x5068),\t\\\n+\t\t\t   size_int (16), 0, 1);\t\t\t\\\n+      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+\t\t\t       plus_constant (tramp, 3)), tmp1);\t\\\n+      tmp1 = expand_and (CXT, gen_rtx (CONST_INT, VOIDmode,\t\t\\\n+\t\t\t\t       0xffff), 0);\t\t\t\\\n+      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode, 0x1068),\t\\\n+\t\t\t   size_int (16), 0, 1);\t\t\t\\\n+      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+\t\t\t       plus_constant (tramp, 6)), tmp1);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+\t\t\t       plus_constant (TRAMP, 8)), FNADDR); \t\\\n+      emit_move_insn (gen_rtx (MEM, QImode,\t\t\t\t\\\n+\t\t\t       plus_constant (TRAMP, 9)), CXT); \t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Specify the machine mode that this machine uses for the index in\n+   the tablejump instruction.  */\n+\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Max number of (32-bit) bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+\n+#define MOVE_MAX 1\n+\n+/* MOVE_RATIO is the number of move instructions that is better than a\n+   block move. */\n+\n+#define MOVE_RATIO 2\t\t/* Default value */\n+\n+#define BSS_SECTION_ASM_OP \".bss\"\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)  \\\n+  asm_fprintf (FILE, \"\\tpush\\t%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)  \\\n+  asm_fprintf (FILE, \"\\tpop\\t%s\\n\", reg_names[REGNO])\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* We need to use direct addressing for large constants and addresses\n+   that cannot fit within an instruction.  We must check for these\n+   after after the final jump optimisation pass, since this may\n+   introduce a local_move insn for a SYMBOL_REF.  This pass\n+   must come before delayed branch slot filling since it can generate\n+   additional instructions.  */\n+\n+#define MACHINE_DEPENDENT_REORG(INSNS) c4x_process_after_reload(INSNS)\n+\n+#define MACHINE_DEPENDENT_COMBINE(INSNS) c4x_combine_parallel(INSNS)\n+\n+#define DBR_OUTPUT_SEQEND(FILE)\t\t\\\n+if (final_sequence != NULL_RTX)\t\t\\\n+{\t\t\t\t\t\\\n+ int count;\t\t\t\t\\\n+ int laj = GET_CODE (XEXP (XEXP (final_sequence, 0), 0)) == CALL_INSN; \\\n+\t\t\t\t\t\\\n+ count = dbr_sequence_length();\t\t\\\n+ while (count < (laj ? 2 : 3))\t\t\\\n+ {\t\t\t\t\t\\\n+    fputs(\"\\tnop\\n\", FILE);\t\t\\\n+    count++;\t\t\t\t\\\n+ }\t\t\t\t\t\\\n+ if (laj)\t\t\t\t\\\n+    fputs(\"\\tpush\\tr11\\n\", FILE);\t\\\n+}\n+\n+#define NO_FUNCTION_CSE\n+\n+/* Repeat block stuff (hook into strength_reduce() in loop.c).  */\n+\n+extern void c4x_rptb_process ();\n+#define REPEAT_BLOCK_PROCESS(START, END) c4x_rptb_process(START, END)\n+\n+/* We don't want a leading tab.  */\n+\n+#define ASM_OUTPUT_ASM(FILE, STRING) fprintf (FILE, \"%s\\n\", STRING)\n+\n+/* Define the codes that are matched by predicates in c4x.c.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\\\n+  {\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\\\n+  {\"const_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n+  {\"stik_const_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"not_const_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"reg_or_const_operand\", {REG, SUBREG, CONST_INT, CONST_DOUBLE}},\\\n+  {\"r0r1_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"r2r3_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"ext_low_reg_operand\", {REG, SUBREG}},\t\t\t\\\n+  {\"ext_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"std_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"addr_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"index_reg_operand\", {REG, SUBREG}},\t\t\t\t\\\n+  {\"dp_reg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"sp_reg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"st_reg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"call_operand\", {REG, SYMBOL_REF}},\t\t\t\t\\\n+  {\"src_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n+  {\"src_hi_operand\", {SUBREG, REG, MEM, CONST_DOUBLE}}, \t\\\n+  {\"lsrc_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n+  {\"tsrc_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n+  {\"any_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE}}, \\\n+  {\"par_ind_operand\", {MEM}},\t\t\t\t\t\\\n+  {\"parallel_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n+  {\"mem_operand\", {MEM}},\t\t\t\t\t\\\n+\n+\n+/* Variables in c4x.c */\n+\n+extern enum reg_class c4x_regclass_map[];/* smallest class containing REGNO */\n+extern enum machine_mode c4x_caller_save_map[];\n+\n+extern struct rtx_def *c4x_compare_op0;\t/* operand 0 for comparisons */\n+extern struct rtx_def *c4x_compare_op1;\t/* operand 1 for comparisons */\n+\n+extern int c4x_rpts_cycles;\t        /* max cycles for RPTS */\n+extern int c4x_cpu_version;\t\t/* cpu version C30/31/32/40/44 */\n+\n+/* Functions in c4x.c */\n+\n+extern void c4x_function_prologue ();\n+\n+extern void c4x_function_epilogue ();\n+\n+extern struct rtx_def *c4x_operand_subword ();\n+\n+extern struct rtx_def *c4x_adj_offsettable_operand ();\n+\n+extern char *c4x_output_cbranch ();\n+\n+extern int c4x_null_epilogue_p ();\n+\n+extern int c4x_autoinc_operand ();\n+\n+extern int c4x_label_conflict ();\n+\n+extern int c4x_address_conflict ();\n+\n+extern int c4x_adjust_cost ();\n+\n+extern void c4x_process_after_reload ();\n+\n+extern void c4x_combine_parallel ();\n+\n+extern int c4x_rptb_nop_p ();\n+\n+extern int c4x_rptb_rpts_p ();\n+\n+extern int fp_zero_operand ();\n+\n+extern int const_operand ();\n+\n+extern int stik_const_operand ();\n+\n+extern int not_const_operand ();\n+\n+extern int reg_operand ();\n+\n+extern int reg_imm_operand ();\n+\n+extern int r0r1_reg_operand ();\n+\n+extern int r2r3_reg_operand ();\n+\n+extern int ext_low_reg_operand ();\n+\n+extern int ext_reg_operand ();\n+\n+extern int std_reg_operand ();\n+\n+extern int src_operand ();\n+\n+extern int lsrc_operand ();\n+\n+extern int tsrc_operand ();\n+\n+extern int addr_reg_operand ();\n+\n+extern int index_reg_operand ();\n+\n+extern int dp_reg_operand ();\n+\n+extern int sp_reg_operand ();\n+\n+extern int st_reg_operand ();\n+\n+extern int call_operand ();\n+\n+extern int par_ind_operand ();\n+\n+extern int c4x_H_constant ();\n+\n+extern int c4x_I_constant ();\n+\n+extern int c4x_J_constant ();\n+\n+extern int c4x_L_constant ();\n+\n+extern int c4x_Q_constraint ();\n+\n+extern int c4x_R_constraint ();\n+\n+extern int c4x_S_constraint ();\n+\n+extern int c4x_T_constraint ();\n+\n+extern void c4x_emit_libcall ();\n+\n+extern void c4x_emit_libcall3 ();\n+\n+extern void c4x_emit_libcall_mulhi ();\n+\n+extern int c4x_group1_reg_operand ();\n+\n+extern int c4x_group1_mem_operand ();\n+\n+extern int c4x_arx_reg_operand ();\n+\n+extern int legitimize_operands ();\n+\n+extern int valid_operands ();\n+\n+extern int valid_parallel_operands_4 ();\n+\n+extern int valid_parallel_operands_5 ();\n+\n+extern int valid_parallel_operands_6 ();"}, {"sha": "21e62eacc7defc5ee718cda3e993db1cd0a3082e", "filename": "gcc/config/c4x/c4x.md", "status": "added", "additions": 6798, "deletions": 0, "changes": 6798, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=cb0ca2844b8681305bcad7699657a7967cc9c634"}, {"sha": "e6964740c8d824f0fc3fc656cfc9feb375193953", "filename": "gcc/config/c4x/t-c4x", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Ft-c4x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Ft-c4x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Ft-c4x?ref=cb0ca2844b8681305bcad7699657a7967cc9c634", "patch": "@@ -0,0 +1,29 @@\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = c4x/libgcc.S\n+LIB1ASMFUNCS = _divqf3 _divqi3 _udivqi3 _umodqi3 _modqi3 _mulqi3 \\\n+\t_mulhf3 _divhf3 _unsfltconst _unsfltcompare \\\n+\t_mulhi3 _umulhi3_high _smulhi3_high _divhi3 _modhi3 _umodhi3 _udivhi3 \\\n+\t_fix_truncqfhi2 _ufix_truncqfhi2 _floathiqf2 _ufloathiqf2 \\\n+\t_floathihf2 _ufloathihf2 _fix_trunchfhi2 _ufix_trunchfhi2 _ffs\n+\n+# We do not have DF or DI types (or SF and SI for that matter),\n+# so fake out the libgcc2 compilation.\n+LIBGCC2_CFLAGS = -O2 -Dexit=unused_exit $(GCC_CFLAGS) $(LIBGCC2_INCLUDES) -DDF=HF -DDI=HI -DSF=QF -DSI=QI\n+\n+MULTILIB_OPTIONS = m30 msmall mmemparm\n+MULTILIB_DIRNAMES = c3x small mem\n+MULTILIB_MATCHES = m30=mcpu?30 m30=mcpu?31 m30=mcpu?32 m30=m31 m30=m32\n+MULTILIB_EXCEPTIONS =\n+MULTILIB_EXTRA_OPTS =\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+# Don't make libgcc1-test since require crt0.o\n+LIBGCC1_TEST =\n+\n+# Don't make objective C because we can't compile the libraries.\n+LANGUAGES = c proto  c++\n+\n+# C[34]x has its own float and limits.h\n+TARGET_FLOAT_H=config/c4x/c4x-float.h\n+TARGET_LIMITS_H=config/c4x/c4x-limits.h"}, {"sha": "dc329ebc9bad7a367b0fbaf46b8126604082a6d0", "filename": "gcc/config/c4x/xm-c4x.h", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fxm-c4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fconfig%2Fc4x%2Fxm-c4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fxm-c4x.h?ref=cb0ca2844b8681305bcad7699657a7967cc9c634", "patch": "@@ -0,0 +1,21 @@\n+/* #defines that need visibility everywhere.  */\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+#define HOST_BITS_PER_CHAR 32\n+#define HOST_BITS_PER_SHORT 32\n+#define HOST_BITS_PER_INT 32\n+#define HOST_BITS_PER_LONG 32\n+#define HOST_BITS_PER_LONGLONG 64\n+\n+#define HOST_WORDS_BIG_ENDIAN\n+\n+/* target machine dependencies.\n+   tm.h is a symbolic link to the actual target specific file.   */\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+#define SUCCESS_EXIT_CODE 0\n+#define FATAL_EXIT_CODE 33\n+"}, {"sha": "c73c6d592bdcff510ddc81f96db02ba3d4c0fc37", "filename": "gcc/ginclude/va-c4x.h", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fginclude%2Fva-c4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb0ca2844b8681305bcad7699657a7967cc9c634/gcc%2Fginclude%2Fva-c4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-c4x.h?ref=cb0ca2844b8681305bcad7699657a7967cc9c634", "patch": "@@ -0,0 +1,34 @@\n+/* GNU C varargs support for the TMS320C[34]x  */\n+\n+/* C[34]x arguments grow in weird ways (downwards) that the standard\n+   varargs stuff can't handle. */\n+\n+#ifndef __GNUC_VA_LIST\n+#define __GNUC_VA_LIST\n+\n+typedef void *__gnuc_va_list;\n+\n+#endif /* not __GNUC_VA_LIST */\n+\n+/* If this is for internal libc use, don't define anything but\n+   __gnuc_va_list.  */\n+#if defined (_STDARG_H) || defined (_VARARGS_H)\n+\n+#ifdef _STDARG_H /* stdarg.h support */\n+\n+#define va_start(AP,LASTARG) AP=(__gnuc_va_list) __builtin_next_arg (LASTARG)\n+\n+#else /* varargs.h support */\n+\n+#define\t__va_ellipsis\t...\n+#define\tva_alist\t__builtin_va_alist\n+#define\tva_dcl\t\tint __builtin_va_alist; __va_ellipsis\n+#define va_start(AP)\tAP=(__gnuc_va_list) ((int *)&__builtin_va_alist +  1)\n+\n+#endif /* _STDARG_H */\n+\n+#define va_end(AP)\t((void) 0)\n+#define va_arg(AP,TYPE)\t(AP = (__gnuc_va_list) ((char *) (AP) - sizeof(TYPE)), \\\n+\t\t\t *((TYPE *) ((char *) (AP))))\n+\n+#endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}