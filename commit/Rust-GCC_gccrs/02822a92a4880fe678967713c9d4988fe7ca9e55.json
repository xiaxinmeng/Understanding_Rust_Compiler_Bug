{"sha": "02822a92a4880fe678967713c9d4988fe7ca9e55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4MjJhOTJhNDg4MGZlNjc4OTY3NzEzYzlkNDk4OGZlN2NhOWU1NQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2006-10-31T17:55:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:55:05Z"}, "message": "exp_ch6.ads, [...]: Use new Validity_Check suppression capability.\n\n2006-10-31  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch6.ads, exp_ch6.adb: Use new Validity_Check suppression\n\tcapability.\n\t(Expand_Inlined_Call): Tagged types are by-reference types, and\n\ttherefore should be replaced by a renaming declaration in the expanded\n\tbody, as is done for limited types.\n\t(Expand_Call): If this is a call to a function with dispatching access\n\tresult, propagate tag from context.\n\t(Freeze_Subprogram): Enable full ABI compatibility for interfacing with\n\tCPP by default.\n\t(Make_Build_In_Place_Call_In_Assignment): New procedure to do\n\tbuild-in-place when the right-hand side of an assignment is a\n\tbuild-in-place function call.\n\t(Make_Build_In_Place_Call_In_Allocator): Apply an unchecked conversion\n\tof the explicit dereference of the allocator to the result subtype of\n\tthe build-in-place function. This is needed to satisfy type checking\n\tin cases where the caller's return object is created by an allocator for\n\ta class-wide access type and the type named in the allocator is a\n\tspecific type.\n\t(Make_Build_In_Place_Call_In_Object_Declaration): Apply an unchecked\n\tconversion of the reference to the declared object to the result subtype\n\tof the build-in-place function. This is needed to satisfy type checking\n\tin cases where the declared object has a class-wide type. Also, in the\n\tclass-wide case, change the type of the object entity to the specific\n\tresult subtype of the function, to avoid passing a class-wide object\n\twithout explicit initialization to the back end.\n\t(Register_Interface_DT_Entry): Moved outside the body of\n\tFreeze_Subprogram because this routine is now public; it is called from\n\tCheck_Dispatching_Overriding to handle late overriding of abstract\n\tinterface primitives.\n\t(Add_Access_Actual_To_Build_In_Place_Call): New utility procedure for\n\tadding an implicit access actual on a call to a build-in-place function.\n\t(Expand_Actuals): Test for an actual parameter that is a call to a\n\tbuild-in-place function and apply\n\tMake_Build_In_Place_Call_In_Anonymous_Context to the call.\n\t(Is_Build_In_Place_Function): New function to determine whether an\n\tentity is a function whose calls should be handled as build-in-place.\n\t(Is_Build_In_Place_Function_Call): New function to determine whether an\n\texpression is a function call that should handled as build-in-place.\n\t(Make_Build_In_Place_Call_In_Allocator): New procedure for handling\n\tcalls to build-in-place functions as the initialization of an allocator.\n\t(Make_Build_In_Place_Call_In_Anonymous_Context): New procedure for\n\thandling calls to build-in-place functions in contexts that do not\n\tinvolve init of a separate object (for example, actuals of subprogram\n\tcalls).\n\t(Make_Build_In_Place_Call_In_Object_Declaration): New procedure for\n\thandling calls to build-in-place functions as the initialization of an\n\tobject declaration.\n\t(Detect_Infinite_Recursion): Add explicit parameter Process to\n\tinstantiation of Traverse_Body to avoid unreferenced warning.\n\t(Check_Overriding_Inherited_Interfaces): Removed.\n\t(Register_Interface_DT_Entry): Code cleanup.\n\t(Register_Predefined_DT_Entry): Code cleanup.\n\t(Expand_Inlined_Call.Rewrite_Procedure_Call): Do not omit block around\n\tinlined statements if within a transient scope.\n\t(Expand_Inlined_Call.Process_Formals): When replacing occurrences of\n\tformal parameters with occurrences of actuals in inlined body, establish\n\tvisibility on the proper view of the actual's subtype for the body's\n\tcontext.\n\t(Freeze_Subprogram): Do nothing if we are compiling under full ABI\n\tcompatibility mode and we have an imported CPP subprogram because\n\tfor now we assume that imported CPP primitives correspond with\n\tobjects whose constructor is in the CPP side (and therefore we\n\tdon't need to generate code to register them in the dispatch table).\n\t(Expand_Actuals): Introduce copy of actual, only if it might be a bit-\n\taligned selected component.\n\t(Add_Call_By_Copy_Node): Add missing code to handle the case in which\n\tthe actual of an in-mode parameter is a type conversion.\n\t(Expand_Actuals): If the call does not come from source and the actual\n\tis potentially misaligned, let gigi handle it rather than rejecting the\n\t(Expand_N_Subprogram_Body, Freeze_Subprogram): set subprograms returning\n\tClass Wide types as returning by reference independantly of their\n\tcontrolled status since with HIE runtimes class wide types are not\n\tpotentially controlled anymore.\n\nFrom-SVN: r118260", "tree": {"sha": "e84a5d28ef7976d5b926e2e9576778e74f334291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e84a5d28ef7976d5b926e2e9576778e74f334291"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02822a92a4880fe678967713c9d4988fe7ca9e55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02822a92a4880fe678967713c9d4988fe7ca9e55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02822a92a4880fe678967713c9d4988fe7ca9e55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02822a92a4880fe678967713c9d4988fe7ca9e55/comments", "author": null, "committer": null, "parents": [{"sha": "efd6ef80ca7d6de864faeb5835712729da984b62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efd6ef80ca7d6de864faeb5835712729da984b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efd6ef80ca7d6de864faeb5835712729da984b62"}], "stats": {"total": 1132, "additions": 758, "deletions": 374}, "files": [{"sha": "90684120fcc0a43251d6cde1b11d34e7f944c063", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 696, "deletions": 373, "changes": 1069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02822a92a4880fe678967713c9d4988fe7ca9e55/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02822a92a4880fe678967713c9d4988fe7ca9e55/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=02822a92a4880fe678967713c9d4988fe7ca9e55", "patch": "@@ -57,10 +57,12 @@ with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n+with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n@@ -76,6 +78,15 @@ package body Exp_Ch6 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Add_Access_Actual_To_Build_In_Place_Call\n+     (Function_Call : Node_Id;\n+      Function_Id   : Entity_Id;\n+      Return_Object : Node_Id);\n+   --  Ada 2005 (AI-318-02): Apply the Unrestricted_Access attribute to the\n+   --  object name given by Return_Object and add the attribute to the end of\n+   --  the actual parameter list associated with the build-in-place function\n+   --  call denoted by Function_Call.\n+\n    procedure Check_Overriding_Operation (Subp : Entity_Id);\n    --  Subp is a dispatching operation. Check whether it may override an\n    --  inherited private operation, in which case its DT entry is that of\n@@ -143,8 +154,7 @@ package body Exp_Ch6 is\n \n    function Expand_Protected_Object_Reference\n      (N    : Node_Id;\n-      Scop : Entity_Id)\n-      return Node_Id;\n+      Scop : Entity_Id) return Node_Id;\n \n    procedure Expand_Protected_Subprogram_Call\n      (N    : Node_Id;\n@@ -155,6 +165,74 @@ package body Exp_Ch6 is\n    --  reference to the object itself, and the call becomes a call to the\n    --  corresponding protected subprogram.\n \n+   ----------------------------------------------\n+   -- Add_Access_Actual_To_Build_In_Place_Call --\n+   ----------------------------------------------\n+\n+   procedure Add_Access_Actual_To_Build_In_Place_Call\n+     (Function_Call : Node_Id;\n+      Function_Id   : Entity_Id;\n+      Return_Object : Node_Id)\n+   is\n+      Loc            : constant Source_Ptr := Sloc (Function_Call);\n+      Obj_Address    : Node_Id;\n+      Obj_Acc_Formal : Node_Id;\n+      Param_Assoc    : Node_Id;\n+\n+   begin\n+      --  Locate the implicit access parameter in the called function. Maybe\n+      --  we should be testing for the name of the access parameter (or perhaps\n+      --  better, each implicit formal for build-in-place could have an\n+      --  identifying flag, or a Uint attribute to identify it). ???\n+\n+      Obj_Acc_Formal := Extra_Formals (Function_Id);\n+\n+      while Present (Obj_Acc_Formal) loop\n+         exit when Ekind (Etype (Obj_Acc_Formal)) = E_Anonymous_Access_Type;\n+         Next_Formal_With_Extras (Obj_Acc_Formal);\n+      end loop;\n+\n+      pragma Assert (Present (Obj_Acc_Formal));\n+\n+      --  Apply Unrestricted_Access to caller's return object\n+\n+      Obj_Address :=\n+         Make_Attribute_Reference (Loc,\n+           Prefix         => Return_Object,\n+           Attribute_Name => Name_Unrestricted_Access);\n+\n+      Analyze_And_Resolve (Obj_Address, Etype (Obj_Acc_Formal));\n+\n+      --  Build the parameter association for the new actual and add it to the\n+      --  end of the function's actuals.\n+\n+      Param_Assoc :=\n+        Make_Parameter_Association (Loc,\n+          Selector_Name             => New_Occurrence_Of (Obj_Acc_Formal, Loc),\n+          Explicit_Actual_Parameter => Obj_Address);\n+\n+      Set_Parent (Param_Assoc, Function_Call);\n+      Set_Parent (Obj_Address, Param_Assoc);\n+\n+      if Present (Parameter_Associations (Function_Call)) then\n+         if Nkind (Last (Parameter_Associations (Function_Call))) =\n+              N_Parameter_Association\n+         then\n+            Set_Next_Named_Actual\n+              (Last (Parameter_Associations (Function_Call)),\n+               Obj_Address);\n+         else\n+            Set_First_Named_Actual (Function_Call, Obj_Address);\n+         end if;\n+\n+         Append (Param_Assoc, To => Parameter_Associations (Function_Call));\n+\n+      else\n+         Set_Parameter_Associations (Function_Call, New_List (Param_Assoc));\n+         Set_First_Named_Actual (Function_Call, Obj_Address);\n+      end if;\n+   end Add_Access_Actual_To_Build_In_Place_Call;\n+\n    --------------------------------\n    -- Check_Overriding_Operation --\n    --------------------------------\n@@ -354,7 +432,7 @@ package body Exp_Ch6 is\n          end if;\n       end Process;\n \n-      function Traverse_Body is new Traverse_Func;\n+      function Traverse_Body is new Traverse_Func (Process);\n \n    --  Start of processing for Detect_Infinite_Recursion\n \n@@ -554,7 +632,9 @@ package body Exp_Ch6 is\n             return;\n          end if;\n \n-         Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n+         Temp :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_Internal_Name ('T'));\n \n          --  Use formal type for temp, unless formal type is an unconstrained\n          --  array, in which case we don't have to worry about bounds checks,\n@@ -652,7 +732,18 @@ package body Exp_Ch6 is\n             end if;\n \n          elsif Ekind (Formal) = E_In_Parameter then\n-            Init := New_Occurrence_Of (Var, Loc);\n+\n+            --  Handle the case in which the actual is a type conversion\n+\n+            if Nkind (Actual) = N_Type_Conversion then\n+               if Conversion_OK (Actual) then\n+                  Init := OK_Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n+               else\n+                  Init := Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n+               end if;\n+            else\n+               Init := New_Occurrence_Of (Var, Loc);\n+            end if;\n \n          else\n             Init := Empty;\n@@ -760,7 +851,9 @@ package body Exp_Ch6 is\n \n          Reset_Packed_Prefix;\n \n-         Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n+         Temp :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_Internal_Name ('T'));\n          Incod  := Relocate_Node (Actual);\n          Outcod := New_Copy_Tree (Incod);\n \n@@ -925,7 +1018,9 @@ package body Exp_Ch6 is\n             return Entity (Actual);\n \n          else\n-            Var := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n+            Var :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('T'));\n \n             N_Node :=\n               Make_Object_Renaming_Declaration (Loc,\n@@ -990,6 +1085,20 @@ package body Exp_Ch6 is\n                  Expand_Protected_Object_Reference (N, Entity (Actual)));\n             end if;\n \n+            --  Ada 2005 (AI-318-02): If the actual parameter is a call to a\n+            --  build-in-place function, then a temporary return object needs\n+            --  to be created and access to it must be passed to the function.\n+            --  Currently we limit such functions to those with constrained\n+            --  inherently limited result subtypes, but eventually we plan to\n+            --  expand the allowed forms of funtions that are treated as\n+            --  build-in-place.\n+\n+            if Ada_Version >= Ada_05\n+              and then Is_Build_In_Place_Function_Call (Actual)\n+            then\n+               Make_Build_In_Place_Call_In_Anonymous_Context (Actual);\n+            end if;\n+\n             Apply_Constraint_Check (Actual, E_Formal);\n \n          --  Out parameter case. No constraint checks on access type\n@@ -1054,9 +1163,18 @@ package body Exp_Ch6 is\n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n                Add_Simple_Call_By_Copy_Code;\n \n-            --  If a non-scalar actual is possibly unaligned, we need a copy\n+            --  If a non-scalar actual is possibly bit-aligned, we need a copy\n+            --  because the back-end cannot cope with such objects. In other\n+            --  cases where alignment forces a copy, the back-end generates\n+            --  it properly. It should not be generated unconditionally in the\n+            --  front-end because it does not know precisely the alignment\n+            --  requirements of the target, and makes too conservative an\n+            --  estimate, leading to superfluous copies or spurious errors\n+            --  on by-reference parameters.\n \n-            elsif Is_Possibly_Unaligned_Object (Actual)\n+            elsif Nkind (Actual) = N_Selected_Component\n+              and then\n+                Component_May_Be_Bit_Aligned (Entity (Selector_Name (Actual)))\n               and then not Represented_As_Scalar (Etype (Formal))\n             then\n                Add_Simple_Call_By_Copy_Code;\n@@ -1920,15 +2038,33 @@ package body Exp_Ch6 is\n               and then Nkind (Parent (Parent (N))) = N_Assignment_Statement\n             then\n                Ass := Parent (Parent (N));\n+\n+            elsif Nkind (Parent (N)) = N_Explicit_Dereference\n+              and then Nkind (Parent (Parent (N))) = N_Assignment_Statement\n+            then\n+               Ass := Parent (Parent (N));\n             end if;\n \n             if Present (Ass)\n               and then Is_Class_Wide_Type (Etype (Name (Ass)))\n             then\n-               if Etype (N) /= Root_Type (Etype (Name (Ass))) then\n+               if Is_Access_Type (Etype (N)) then\n+                  if Designated_Type (Etype (N)) /=\n+                    Root_Type (Etype (Name (Ass)))\n+                  then\n+                     Error_Msg_NE\n+                       (\"tag-indeterminate expression \"\n+                         & \" must have designated type& ('R'M 5.2 (6))\",\n+                           N, Root_Type (Etype (Name (Ass))));\n+                  else\n+                     Propagate_Tag (Name (Ass), N);\n+                  end if;\n+\n+               elsif Etype (N) /= Root_Type (Etype (Name (Ass))) then\n                   Error_Msg_NE\n                     (\"tag-indeterminate expression must have type&\"\n-                      & \"('R'M 5.2 (6))\", N, Root_Type (Etype (Name (Ass))));\n+                     & \"('R'M 5.2 (6))\", N, Root_Type (Etype (Name (Ass))));\n+\n                else\n                   Propagate_Tag (Name (Ass), N);\n                end if;\n@@ -2053,6 +2189,9 @@ package body Exp_Ch6 is\n                if Etype (Formal) /= Etype (Parent_Formal)\n                  and then Is_Scalar_Type (Etype (Formal))\n                  and then Ekind (Formal) = E_In_Parameter\n+                 and then\n+                   not Subtypes_Statically_Match\n+                         (Etype (Parent_Formal), Etype (Actual))\n                  and then not Raises_Constraint_Error (Actual)\n                then\n                   Rewrite (Actual,\n@@ -2165,7 +2304,9 @@ package body Exp_Ch6 is\n                    Selector_Name =>\n                      New_Occurrence_Of (Next_Entity (First_Entity (T)), Loc));\n \n-               Nam := Make_Explicit_Dereference (Loc, Nam);\n+               Nam :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => Nam);\n \n                if Present (Parameter_Associations (N))  then\n                   Parm := Parameter_Associations (N);\n@@ -2176,13 +2317,15 @@ package body Exp_Ch6 is\n                Prepend (Obj, Parm);\n \n                if Etype (D_T) = Standard_Void_Type then\n-                  Call := Make_Procedure_Call_Statement (Loc,\n-                    Name => Nam,\n-                    Parameter_Associations => Parm);\n+                  Call :=\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name                   => Nam,\n+                      Parameter_Associations => Parm);\n                else\n-                  Call := Make_Function_Call (Loc,\n-                    Name => Nam,\n-                    Parameter_Associations => Parm);\n+                  Call :=\n+                    Make_Function_Call (Loc,\n+                      Name                   => Nam,\n+                      Parameter_Associations => Parm);\n                end if;\n \n                Set_First_Named_Actual (Call, First_Named_Actual (N));\n@@ -2364,7 +2507,7 @@ package body Exp_Ch6 is\n       --  Functions returning controlled objects need special attention\n \n       if Controlled_Type (Etype (Subp))\n-        and then not Is_Return_By_Reference_Type (Etype (Subp))\n+        and then not Is_Inherently_Limited_Type (Etype (Subp))\n       then\n          Expand_Ctrl_Function_Call (N);\n       end if;\n@@ -2574,13 +2717,6 @@ package body Exp_Ch6 is\n       --  If the type returned by the function is unconstrained and the\n       --  call can be inlined, special processing is required.\n \n-      procedure Find_Result;\n-      --  For a function that returns an unconstrained type, retrieve the\n-      --  name of the single variable that is the expression of a return\n-      --  statement in the body of the function. Build_Body_To_Inline has\n-      --  verified that this variable is unique, even in the presence of\n-      --  multiple return statements.\n-\n       procedure Make_Exit_Label;\n       --  Build declaration for exit label to be used in Return statements\n \n@@ -2602,55 +2738,11 @@ package body Exp_Ch6 is\n \n       procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id);\n       --  If procedure body has no local variables, inline body without\n-      --  creating block,  otherwise rewrite call with block.\n+      --  creating block, otherwise rewrite call with block.\n \n       function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n       --  Determine whether a formal parameter is used only once in Orig_Bod\n \n-      -----------------\n-      -- Find_Result --\n-      -----------------\n-\n-      procedure Find_Result is\n-         Decl : Node_Id;\n-         Id   : Node_Id;\n-\n-         function Get_Return (N : Node_Id) return Traverse_Result;\n-         --  Recursive function to locate return statements in body.\n-\n-         function Get_Return (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (N) = N_Return_Statement then\n-               Id := Expression (N);\n-               return Abandon;\n-            else\n-               return OK;\n-            end if;\n-         end Get_Return;\n-\n-         procedure Find_It is new Traverse_Proc (Get_Return);\n-\n-      --  Start of processing for Find_Result\n-\n-      begin\n-         Find_It (Handled_Statement_Sequence (Orig_Bod));\n-\n-         --  At this point the body is unanalyzed. Traverse the list of\n-         --  declarations to locate the defining_identifier for it.\n-\n-         Decl := First (Declarations (Blk));\n-\n-         while Present (Decl) loop\n-            if Chars (Defining_Identifier (Decl)) = Chars (Id) then\n-               Targ1 := Defining_Identifier (Decl);\n-               exit;\n-\n-            else\n-               Next (Decl);\n-            end if;\n-         end loop;\n-      end Find_Result;\n-\n       ---------------------\n       -- Make_Exit_Label --\n       ---------------------\n@@ -2660,7 +2752,9 @@ package body Exp_Ch6 is\n          --  Create exit label for subprogram if one does not exist yet\n \n          if No (Exit_Lab) then\n-            Lab_Id := Make_Identifier (Loc, New_Internal_Name ('L'));\n+            Lab_Id :=\n+              Make_Identifier (Loc,\n+                Chars => New_Internal_Name ('L'));\n             Set_Entity (Lab_Id,\n               Make_Defining_Identifier (Loc, Chars (Lab_Id)));\n             Exit_Lab := Make_Label (Loc, Lab_Id);\n@@ -2692,11 +2786,20 @@ package body Exp_Ch6 is\n             then\n                A := Renamed_Object (E);\n \n+               --  Rewrite the occurrence of the formal into an occurrence of\n+               --  the actual. Also establish visibility on the proper view of\n+               --  the actual's subtype for the body's context (if the actual's\n+               --  subtype is private at the call point but its full view is\n+               --  visible to the body, then the inlined tree here must be\n+               --  analyzed with the full view).\n+\n                if Is_Entity_Name (A) then\n                   Rewrite (N, New_Occurrence_Of (Entity (A), Loc));\n+                  Check_Private_View (N);\n \n                elsif Nkind (A) = N_Defining_Identifier then\n                   Rewrite (N, New_Occurrence_Of (A, Loc));\n+                  Check_Private_View (N);\n \n                else   --  numeric literal\n                   Rewrite (N, New_Copy (A));\n@@ -2881,7 +2984,20 @@ package body Exp_Ch6 is\n       procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id) is\n          HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n       begin\n-         if Is_Empty_List (Declarations (Blk)) then\n+         --  If there is a transient scope for N, this will be the scope of the\n+         --  actions for N, and the statements in Blk need to be within this\n+         --  scope. For example, they need to have visibility on the constant\n+         --  declarations created for the formals.\n+\n+         --  If N needs no transient scope, and if there are no declarations in\n+         --  the inlined body, we can do a little optimization and insert the\n+         --  statements for the body directly after N, and rewrite N to a\n+         --  null statement, instead of rewriting N into a full-blown block\n+         --  statement.\n+\n+         if not Scope_Is_Transient\n+           and then Is_Empty_List (Declarations (Blk))\n+         then\n             Insert_List_After (N, Statements (HSS));\n             Rewrite (N, Make_Null_Statement (Loc));\n          else\n@@ -2891,7 +3007,7 @@ package body Exp_Ch6 is\n \n       -------------------------\n       -- Formal_Is_Used_Once --\n-      ------------------------\n+      -------------------------\n \n       function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean is\n          Use_Counter : Int := 0;\n@@ -3009,10 +3125,14 @@ package body Exp_Ch6 is\n       end if;\n \n       --  For the unconstrained case, capture the name of the local\n-      --  variable that holds the result.\n+      --  variable that holds the result. This must be the first declaration\n+      --  in the block, because its bounds cannot depend on local variables.\n+      --  Otherwise there is no way to declare the result outside of the\n+      --  block. Needless to say, in general the bounds will depend on the\n+      --  actuals in the call.\n \n       if Is_Unc then\n-         Find_Result;\n+         Targ1 := Defining_Identifier (First (Declarations (Blk)));\n       end if;\n \n       --  If this is a derived function, establish the proper return type\n@@ -3099,9 +3219,10 @@ package body Exp_Ch6 is\n             if Nkind (A) = N_Type_Conversion\n               and then Ekind (F) /= E_In_Parameter\n             then\n-               New_A := Make_Unchecked_Type_Conversion (Loc,\n-                 Subtype_Mark => New_Occurrence_Of (Etype (F), Loc),\n-                 Expression   => Relocate_Node (Expression (A)));\n+               New_A :=\n+                 Make_Unchecked_Type_Conversion (Loc,\n+                   Subtype_Mark => New_Occurrence_Of (Etype (F), Loc),\n+                   Expression   => Relocate_Node (Expression (A)));\n \n             elsif Etype (F) /= Etype (A) then\n                New_A := Unchecked_Convert_To (Etype (F), Relocate_Node (A));\n@@ -3113,8 +3234,13 @@ package body Exp_Ch6 is\n \n             Set_Sloc (New_A, Sloc (N));\n \n+            --  If the actual has a by-reference type, it cannot be copied, so\n+            --  its value is captured in a renaming declaration. Otherwise\n+            --  declare a local constant initalized with the actual.\n+\n             if Ekind (F) = E_In_Parameter\n               and then not Is_Limited_Type (Etype (A))\n+              and then not Is_Tagged_Type  (Etype (A))\n             then\n                Decl :=\n                  Make_Object_Declaration (Loc,\n@@ -3289,8 +3415,10 @@ package body Exp_Ch6 is\n       Typ   : constant Entity_Id := Etype (N);\n \n       function Returned_By_Reference return Boolean;\n-      --  If the return type is returned through the secondary stack. that is\n+      --  If the return type is returned through the secondary stack; that is\n       --  by reference, we don't want to create a temp to force stack checking.\n+      --  ???\"sec stack\" is not right -- Ada 95 return-by-reference object are\n+      --  returned whereever they are.\n       --  Shouldn't this function be moved to exp_util???\n \n       function Rhs_Of_Assign_Or_Decl (N : Node_Id) return Boolean;\n@@ -3312,7 +3440,7 @@ package body Exp_Ch6 is\n          S : Entity_Id;\n \n       begin\n-         if Is_Return_By_Reference_Type (Typ) then\n+         if Is_Inherently_Limited_Type (Typ) then\n             return True;\n \n          elsif Nkind (Parent (N)) /= N_Return_Statement then\n@@ -3612,8 +3740,12 @@ package body Exp_Ch6 is\n \n          --  Build and set declarations for the wrapped thread body\n \n-         Ent_SS   := Make_Defining_Identifier (Loc, Name_uSecondary_Stack);\n-         Ent_ATSD := Make_Defining_Identifier (Loc, Name_uProcess_ATSD);\n+         Ent_SS   :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => Name_uSecondary_Stack);\n+         Ent_ATSD :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => Name_uProcess_ATSD);\n \n          Decl_SS :=\n            Make_Object_Declaration (Loc,\n@@ -3649,7 +3781,9 @@ package body Exp_Ch6 is\n          else\n             Check_Restriction (No_Exception_Handlers, N);\n \n-            Ent_EO := Make_Defining_Identifier (Loc, Name_uE);\n+            Ent_EO :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => Name_uE);\n \n             Excep_Handlers := New_List (\n               Make_Exception_Handler (Loc,\n@@ -3783,32 +3917,28 @@ package body Exp_Ch6 is\n       if Init_Or_Norm_Scalars and then Is_Subprogram (Spec_Id) then\n          declare\n             F : Entity_Id;\n-            V : constant Boolean := Validity_Checks_On;\n \n          begin\n-            --  We turn off validity checking, since we do not want any\n-            --  check on the initializing value itself (which we know\n-            --  may well be invalid!)\n-\n-            Validity_Checks_On := False;\n-\n             --  Loop through formals\n \n             F := First_Formal (Spec_Id);\n             while Present (F) loop\n                if Is_Scalar_Type (Etype (F))\n                  and then Ekind (F) = E_Out_Parameter\n                then\n+                  --  Insert the initialization. We turn off validity checks\n+                  --  for this assignment, since we do not want any check on\n+                  --  the initial value itself (which may well be invalid).\n+\n                   Insert_Before_And_Analyze (First (L),\n                     Make_Assignment_Statement (Loc,\n-                      Name => New_Occurrence_Of (F, Loc),\n-                      Expression => Get_Simple_Init_Val (Etype (F), Loc)));\n+                      Name       => New_Occurrence_Of (F, Loc),\n+                      Expression => Get_Simple_Init_Val (Etype (F), Loc)),\n+                    Suppress => Validity_Check);\n                end if;\n \n                Next_Formal (F);\n             end loop;\n-\n-            Validity_Checks_On := V;\n          end;\n       end if;\n \n@@ -3870,10 +4000,12 @@ package body Exp_Ch6 is\n          then\n             null;\n \n-         elsif Is_Return_By_Reference_Type (Typ) then\n+         elsif Is_Inherently_Limited_Type (Typ) then\n             Set_Returns_By_Ref (Spec_Id);\n \n-         elsif Present (Utyp) and then Controlled_Type (Utyp) then\n+         elsif Present (Utyp)\n+           and then (Is_Class_Wide_Type (Utyp) or else Controlled_Type (Utyp))\n+         then\n             Set_Returns_By_Ref (Spec_Id);\n          end if;\n       end;\n@@ -4067,6 +4199,8 @@ package body Exp_Ch6 is\n             Pop_Scope;\n          end if;\n \n+      --  Ada 2005 (AI-348): Generation of the null body\n+\n       elsif Nkind (Specification (N)) = N_Procedure_Specification\n         and then Null_Present (Specification (N))\n       then\n@@ -4104,8 +4238,7 @@ package body Exp_Ch6 is\n \n    function Expand_Protected_Object_Reference\n      (N    : Node_Id;\n-      Scop : Entity_Id)\n-     return Node_Id\n+      Scop : Entity_Id) return Node_Id\n    is\n       Loc   : constant Source_Ptr := Sloc (N);\n       Corr  : Entity_Id;\n@@ -4114,7 +4247,9 @@ package body Exp_Ch6 is\n       Proc  : Entity_Id;\n \n    begin\n-      Rec := Make_Identifier (Loc, Name_uObject);\n+      Rec :=\n+        Make_Identifier (Loc,\n+          Chars => Name_uObject);\n       Set_Etype (Rec, Corresponding_Record_Type (Scop));\n \n       --  Find enclosing protected operation, and retrieve its first parameter,\n@@ -4261,314 +4396,123 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Protected_Subprogram_Call;\n \n-   -----------------------\n-   -- Freeze_Subprogram --\n-   -----------------------\n-\n-   procedure Freeze_Subprogram (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-      E   : constant Entity_Id  := Entity (N);\n-\n-      procedure Check_Overriding_Inherited_Interfaces (E : Entity_Id);\n-      --  (Ada 2005): Check if the primitive E covers some interface already\n-      --  implemented by some ancestor of the tagged-type associated with E.\n-\n-      procedure Register_Interface_DT_Entry\n-        (Prim                : Entity_Id;\n-         Ancestor_Iface_Prim : Entity_Id := Empty);\n-      --  (Ada 2005): Register an interface primitive in a secondary dispatch\n-      --  table. If Prim overrides an ancestor primitive of its associated\n-      --  tagged-type then Ancestor_Iface_Prim indicates the entity of that\n-      --  immediate ancestor associated with the interface.\n-\n-      procedure Register_Predefined_DT_Entry (Prim : Entity_Id);\n-      --  (Ada 2005): Register a predefined primitive in all the secondary\n-      --  dispatch tables of its primitive type.\n-\n-      -------------------------------------------\n-      -- Check_Overriding_Inherited_Interfaces --\n-      -------------------------------------------\n-\n-      procedure Check_Overriding_Inherited_Interfaces (E : Entity_Id) is\n-         Typ          : Entity_Id;\n-         Elmt         : Elmt_Id;\n-         Prim_Op      : Entity_Id;\n-         Overriden_Op : Entity_Id := Empty;\n+   --------------------------------\n+   -- Is_Build_In_Place_Function --\n+   --------------------------------\n \n-      begin\n-         if Ada_Version < Ada_05\n-           or else not Is_Overriding_Operation (E)\n-           or else Is_Predefined_Dispatching_Operation (E)\n-           or else Present (Alias (E))\n+   function Is_Build_In_Place_Function (E : Entity_Id) return Boolean is\n+   begin\n+      --  For now we test whether E denotes a function or access-to-function\n+      --  type whose result subtype is constrained and inherently limited.\n+      --  Later this test will be revised to include unconstrained limited\n+      --  types and composite nonlimited types in general. Functions with\n+      --  a foreign convention or whose result type has a foreign convention\n+      --  never qualify.\n+\n+      if Ekind (E) = E_Function\n+        or else (Ekind (E) = E_Subprogram_Type\n+                  and then Etype (E) /= Standard_Void_Type)\n+      then\n+         if Has_Foreign_Convention (E)\n+           or else Has_Foreign_Convention (Etype (E))\n          then\n-            return;\n-         end if;\n-\n-         --  Get the entity associated with this primitive operation\n-\n-         Typ := Scope (DTC_Entity (E));\n-         loop\n-            exit when Etype (Typ) = Typ\n-              or else (Present (Full_View (Etype (Typ)))\n-                         and then Full_View (Etype (Typ)) = Typ);\n-\n-            --  Climb to the immediate ancestor handling private types\n-\n-            if Present (Full_View (Etype (Typ))) then\n-               Typ := Full_View (Etype (Typ));\n-            else\n-               Typ := Etype (Typ);\n-            end if;\n-\n-            if Present (Abstract_Interfaces (Typ)) then\n-\n-               --  Look for the overriden subprogram in the primary dispatch\n-               --  table of the ancestor.\n-\n-               Overriden_Op := Empty;\n-               Elmt         := First_Elmt (Primitive_Operations (Typ));\n-               while Present (Elmt) loop\n-                  Prim_Op := Node (Elmt);\n-\n-                  if Chars (Prim_Op) = Chars (E)\n-                    and then Type_Conformant\n-                               (New_Id => Prim_Op,\n-                                Old_Id => E,\n-                                Skip_Controlling_Formals => True)\n-                    and then DT_Position (Prim_Op) = DT_Position (E)\n-                    and then Etype (DTC_Entity (Prim_Op)) = RTE (RE_Tag)\n-                    and then No (Abstract_Interface_Alias (Prim_Op))\n-                  then\n-                     if Overriden_Op = Empty then\n-                        Overriden_Op := Prim_Op;\n-\n-                     --  Additional check to ensure that if two candidates have\n-                     --  been found then they refer to the same subprogram.\n-\n-                     else\n-                        declare\n-                           A1 : Entity_Id;\n-                           A2 : Entity_Id;\n-\n-                        begin\n-                           A1 := Overriden_Op;\n-                           while Present (Alias (A1)) loop\n-                              A1 := Alias (A1);\n-                           end loop;\n-\n-                           A2 := Prim_Op;\n-                           while Present (Alias (A2)) loop\n-                              A2 := Alias (A2);\n-                           end loop;\n-\n-                           if A1 /= A2 then\n-                              raise Program_Error;\n-                           end if;\n-                        end;\n-                     end if;\n-                  end if;\n-\n-                  Next_Elmt (Elmt);\n-               end loop;\n-\n-               --  If not found this is the first overriding of some abstract\n-               --  interface.\n-\n-               if Overriden_Op /= Empty then\n-\n-                  --  Find the entries associated with interfaces that are\n-                  --  alias of this primitive operation in the ancestor.\n-\n-                  Elmt := First_Elmt (Primitive_Operations (Typ));\n-                  while Present (Elmt) loop\n-                     Prim_Op := Node (Elmt);\n-\n-                     if Present (Abstract_Interface_Alias (Prim_Op))\n-                       and then Alias (Prim_Op) = Overriden_Op\n-                     then\n-                        Register_Interface_DT_Entry (E, Prim_Op);\n-                     end if;\n-\n-                     Next_Elmt (Elmt);\n-                  end loop;\n-               end if;\n-            end if;\n-         end loop;\n-      end Check_Overriding_Inherited_Interfaces;\n-\n-      ---------------------------------\n-      -- Register_Interface_DT_Entry --\n-      ---------------------------------\n-\n-      procedure Register_Interface_DT_Entry\n-        (Prim                : Entity_Id;\n-         Ancestor_Iface_Prim : Entity_Id := Empty)\n-      is\n-         E            : Entity_Id;\n-         Prim_Typ     : Entity_Id;\n-         Prim_Op      : Entity_Id;\n-         Iface_Typ    : Entity_Id;\n-         Iface_DT_Ptr : Entity_Id;\n-         Iface_Tag    : Entity_Id;\n-         New_Thunk    : Node_Id;\n-         Thunk_Id     : Entity_Id;\n-\n-      begin\n-         --  Nothing to do if the run-time does not give support to abstract\n-         --  interfaces.\n+            return False;\n \n-         if not (RTE_Available (RE_Interface_Tag)) then\n-            return;\n+         else\n+            return Is_Inherently_Limited_Type (Etype (E))\n+              and then Is_Constrained (Etype (E));\n          end if;\n \n-         if No (Ancestor_Iface_Prim) then\n-            Prim_Typ  := Scope (DTC_Entity (Alias (Prim)));\n-\n-            --  Look for the abstract interface subprogram\n-\n-            E := Abstract_Interface_Alias (Prim);\n-            while Present (E)\n-              and then Is_Abstract (E)\n-              and then not Is_Interface (Scope (DTC_Entity (E)))\n-            loop\n-               E := Alias (E);\n-            end loop;\n-\n-            Iface_Typ := Scope (DTC_Entity (E));\n-\n-            --  Generate the code of the thunk only when this primitive\n-            --  operation is associated with a secondary dispatch table.\n-\n-            if Is_Interface (Iface_Typ) then\n-               Iface_Tag := Find_Interface_Tag\n-                              (T     => Prim_Typ,\n-                               Iface => Iface_Typ);\n-\n-               if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n-                  Thunk_Id  :=\n-                    Make_Defining_Identifier (Loc,\n-                      Chars => New_Internal_Name ('T'));\n-\n-                  New_Thunk :=\n-                    Expand_Interface_Thunk\n-                      (N           => Prim,\n-                       Thunk_Alias => Alias (Prim),\n-                       Thunk_Id    => Thunk_Id);\n+      else\n+         return False;\n+      end if;\n+   end Is_Build_In_Place_Function;\n \n-                  Insert_After (N, New_Thunk);\n+   -------------------------------------\n+   -- Is_Build_In_Place_Function_Call --\n+   -------------------------------------\n \n-                  Iface_DT_Ptr :=\n-                    Find_Interface_ADT\n-                      (T     => Prim_Typ,\n-                       Iface => Iface_Typ);\n+   function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean is\n+      Exp_Node    : Node_Id := N;\n+      Function_Id : Entity_Id;\n \n-                  Insert_After (New_Thunk,\n-                    Fill_Secondary_DT_Entry (Sloc (Prim),\n-                      Prim         => Prim,\n-                      Iface_DT_Ptr => Iface_DT_Ptr,\n-                      Thunk_Id     => Thunk_Id));\n-               end if;\n-            end if;\n+   begin\n+      if Nkind (Exp_Node) = N_Qualified_Expression then\n+         Exp_Node := Expression (N);\n+      end if;\n \n-         else\n-            Iface_Typ :=\n-              Scope (DTC_Entity (Abstract_Interface_Alias\n-                                  (Ancestor_Iface_Prim)));\n+      if Nkind (Exp_Node) /= N_Function_Call then\n+         return False;\n \n-            Iface_Tag :=\n-              Find_Interface_Tag\n-                (T     => Scope (DTC_Entity (Alias (Ancestor_Iface_Prim))),\n-                 Iface => Iface_Typ);\n+      else\n+         if Is_Entity_Name (Name (Exp_Node)) then\n+            Function_Id := Entity (Name (Exp_Node));\n \n-            --  Generate the thunk only if the associated tag is an interface\n-            --  tag. The case in which the associated tag is the primary tag\n-            --  occurs when a tagged type is a direct derivation of an\n-            --  interface. For example:\n+         elsif Nkind (Name (Exp_Node)) = N_Explicit_Dereference then\n+            Function_Id := Etype (Name (Exp_Node));\n+         end if;\n \n-            --    type I is interface;\n-            --    ...\n-            --    type T is new I with ...\n+         return Is_Build_In_Place_Function (Function_Id);\n+      end if;\n+   end Is_Build_In_Place_Function_Call;\n \n-            if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n-               Thunk_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_Internal_Name ('T'));\n+   -----------------------\n+   -- Freeze_Subprogram --\n+   -----------------------\n \n-               if Present (Alias (Prim)) then\n-                  Prim_Op := Alias (Prim);\n-               else\n-                  Prim_Op := Prim;\n-               end if;\n+   procedure Freeze_Subprogram (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      E   : constant Entity_Id  := Entity (N);\n \n-               New_Thunk :=\n-                 Expand_Interface_Thunk\n-                   (N           => Ancestor_Iface_Prim,\n-                    Thunk_Alias => Prim_Op,\n-                    Thunk_Id    => Thunk_Id);\n-\n-               Insert_After (N, New_Thunk);\n-\n-               Iface_DT_Ptr :=\n-                 Find_Interface_ADT\n-                   (T     => Scope (DTC_Entity (Prim_Op)),\n-                    Iface => Iface_Typ);\n-\n-               Insert_After (New_Thunk,\n-                 Fill_Secondary_DT_Entry (Sloc (Prim),\n-                   Prim         => Ancestor_Iface_Prim,\n-                   Iface_DT_Ptr => Iface_DT_Ptr,\n-                   Thunk_Id     => Thunk_Id));\n-            end if;\n-         end if;\n-      end Register_Interface_DT_Entry;\n+      procedure Register_Predefined_DT_Entry (Prim : Entity_Id);\n+      --  (Ada 2005): Register a predefined primitive in all the secondary\n+      --  dispatch tables of its primitive type.\n \n       ----------------------------------\n       -- Register_Predefined_DT_Entry --\n       ----------------------------------\n \n       procedure Register_Predefined_DT_Entry (Prim : Entity_Id) is\n          Iface_DT_Ptr : Elmt_Id;\n-         Iface_Tag    : Entity_Id;\n-         Iface_Typ    : Elmt_Id;\n-         New_Thunk    : Entity_Id;\n-         Prim_Typ     : Entity_Id;\n+         Iface_Typ    : Entity_Id;\n+         Iface_Elmt   : Elmt_Id;\n+         Tagged_Typ   : Entity_Id;\n          Thunk_Id     : Entity_Id;\n \n       begin\n-         Prim_Typ := Scope (DTC_Entity (Prim));\n+         Tagged_Typ := Find_Dispatching_Type (Prim);\n \n-         if No (Access_Disp_Table (Prim_Typ))\n-           or else No (Abstract_Interfaces (Prim_Typ))\n+         if No (Access_Disp_Table (Tagged_Typ))\n+           or else No (Abstract_Interfaces (Tagged_Typ))\n            or else not RTE_Available (RE_Interface_Tag)\n          then\n             return;\n          end if;\n \n-         --  Skip the first acces-to-dispatch-table pointer since it leads\n+         --  Skip the first access-to-dispatch-table pointer since it leads\n          --  to the primary dispatch table. We are only concerned with the\n          --  secondary dispatch table pointers. Note that the access-to-\n          --  dispatch-table pointer corresponds to the first implemented\n          --  interface retrieved below.\n \n-         Iface_DT_Ptr := Next_Elmt (First_Elmt (Access_Disp_Table (Prim_Typ)));\n-         Iface_Typ := First_Elmt (Abstract_Interfaces (Prim_Typ));\n-         while Present (Iface_DT_Ptr) and then Present (Iface_Typ) loop\n-            Iface_Tag := Find_Interface_Tag (Prim_Typ, Node (Iface_Typ));\n-            pragma Assert (Present (Iface_Tag));\n+         Iface_DT_Ptr :=\n+           Next_Elmt (First_Elmt (Access_Disp_Table (Tagged_Typ)));\n+         Iface_Elmt := First_Elmt (Abstract_Interfaces (Tagged_Typ));\n+         while Present (Iface_DT_Ptr) and then Present (Iface_Elmt) loop\n+            Iface_Typ := Node (Iface_Elmt);\n \n-            if Etype (Iface_Tag) = RTE (RE_Interface_Tag) then\n-               Thunk_Id := Make_Defining_Identifier (Loc,\n-                             New_Internal_Name ('T'));\n+            if not Is_Ancestor (Iface_Typ, Tagged_Typ) then\n+               Thunk_Id :=\n+                 Make_Defining_Identifier (Loc,\n+                   Chars => New_Internal_Name ('T'));\n \n-               New_Thunk :=\n+               Insert_Actions (N, New_List (\n                  Expand_Interface_Thunk\n                   (N           => Prim,\n                    Thunk_Alias => Prim,\n-                   Thunk_Id    => Thunk_Id);\n+                   Thunk_Id    => Thunk_Id),\n \n-               Insert_After (N, New_Thunk);\n-               Insert_After (New_Thunk,\n-                 Make_DT_Access_Action (Node (Iface_Typ),\n+                 Make_DT_Access_Action (Iface_Typ,\n                    Action => Set_Predefined_Prim_Op_Address,\n                    Args   => New_List (\n                      Unchecked_Convert_To (RTE (RE_Tag),\n@@ -4578,17 +4522,28 @@ package body Exp_Ch6 is\n \n                      Make_Attribute_Reference (Loc,\n                        Prefix         => New_Reference_To (Thunk_Id, Loc),\n-                       Attribute_Name => Name_Address))));\n+                       Attribute_Name => Name_Address)))));\n             end if;\n \n             Next_Elmt (Iface_DT_Ptr);\n-            Next_Elmt (Iface_Typ);\n+            Next_Elmt (Iface_Elmt);\n          end loop;\n       end Register_Predefined_DT_Entry;\n \n    --  Start of processing for Freeze_Subprogram\n \n    begin\n+      --  We assume that imported CPP primitives correspond with objects\n+      --  whose constructor is in the CPP side (and therefore we don't need\n+      --  to generate code to register them in the dispatch table).\n+\n+      if not Debug_Flag_QQ\n+        and then Is_Imported (E)\n+        and then Convention (E) = Convention_CPP\n+      then\n+         return;\n+      end if;\n+\n       --  When a primitive is frozen, enter its name in the corresponding\n       --  dispatch table. If the DTC_Entity field is not set this is an\n       --  overridden primitive that can be ignored. We suppress the\n@@ -4634,7 +4589,7 @@ package body Exp_Ch6 is\n                   --  a subprogram that covers an abstract interface type.\n \n                   if Present (Abstract_Interface_Alias (E)) then\n-                     Register_Interface_DT_Entry (E);\n+                     Register_Interface_DT_Entry (N, E);\n \n                   --  Common case: Primitive subprogram\n \n@@ -4649,8 +4604,6 @@ package body Exp_Ch6 is\n                         Insert_After (N,\n                           Fill_DT_Entry (Sloc (N), Prim => E));\n                      end if;\n-\n-                     Check_Overriding_Inherited_Interfaces (E);\n                   end if;\n                end if;\n             end;\n@@ -4666,13 +4619,383 @@ package body Exp_Ch6 is\n          Utyp : constant Entity_Id := Underlying_Type (Typ);\n \n       begin\n-         if Is_Return_By_Reference_Type (Typ) then\n+         if Is_Inherently_Limited_Type (Typ) then\n             Set_Returns_By_Ref (E);\n \n-         elsif Present (Utyp) and then Controlled_Type (Utyp) then\n+         elsif Present (Utyp)\n+           and then (Is_Class_Wide_Type (Utyp) or else Controlled_Type (Utyp))\n+         then\n             Set_Returns_By_Ref (E);\n          end if;\n       end;\n    end Freeze_Subprogram;\n \n+   -------------------------------------------\n+   -- Make_Build_In_Place_Call_In_Allocator --\n+   -------------------------------------------\n+\n+   procedure Make_Build_In_Place_Call_In_Allocator\n+     (Allocator     : Node_Id;\n+      Function_Call : Node_Id)\n+   is\n+      Loc               : Source_Ptr;\n+      Func_Call         : Node_Id := Function_Call;\n+      Function_Id       : Entity_Id;\n+      Result_Subt       : Entity_Id;\n+      Acc_Type          : constant Entity_Id := Etype (Allocator);\n+      New_Allocator     : Node_Id;\n+      Return_Obj_Access : Entity_Id;\n+\n+   begin\n+      if Nkind (Func_Call) = N_Qualified_Expression then\n+         Func_Call := Expression (Func_Call);\n+      end if;\n+\n+      Loc := Sloc (Function_Call);\n+\n+      if Is_Entity_Name (Name (Func_Call)) then\n+         Function_Id := Entity (Name (Func_Call));\n+\n+      elsif Nkind (Name (Func_Call)) = N_Explicit_Dereference then\n+         Function_Id := Etype (Name (Func_Call));\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Result_Subt := Etype (Function_Id);\n+\n+      --  Replace the initialized allocator of form \"new T'(Func (...))\" with\n+      --  an uninitialized allocator of form \"new T\", where T is the result\n+      --  subtype of the called function. The call to the function is handled\n+      --  separately further below.\n+\n+      New_Allocator :=\n+        Make_Allocator (Loc, New_Reference_To (Result_Subt, Loc));\n+      Set_No_Initialization (New_Allocator);\n+\n+      Rewrite (Allocator, New_Allocator);\n+\n+      --  Create a new access object and initialize it to the result of the new\n+      --  uninitialized allocator.\n+\n+      Return_Obj_Access :=\n+        Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+      Set_Etype (Return_Obj_Access, Acc_Type);\n+\n+      Insert_Action (Allocator,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Return_Obj_Access,\n+          Object_Definition   => New_Reference_To (Acc_Type, Loc),\n+          Expression          => Relocate_Node (Allocator)));\n+\n+      --  Add an implicit actual to the function call that provides access to\n+      --  the allocated object. An unchecked conversion to the (specific)\n+      --  result subtype of the function is inserted to handle the case where\n+      --  the access type of the allocator has a class-wide designated type.\n+\n+      Add_Access_Actual_To_Build_In_Place_Call\n+        (Func_Call,\n+         Function_Id,\n+         Make_Unchecked_Type_Conversion (Loc,\n+           Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n+           Expression   =>\n+             Make_Explicit_Dereference (Loc,\n+               Prefix => New_Reference_To (Return_Obj_Access, Loc))));\n+\n+      --  Finally, replace the allocator node with a reference to the result\n+      --  of the function call itself (which will effectively be an access\n+      --  to the object created by the allocator).\n+\n+      Rewrite (Allocator, Make_Reference (Loc, Relocate_Node (Function_Call)));\n+      Analyze_And_Resolve (Allocator, Acc_Type);\n+   end Make_Build_In_Place_Call_In_Allocator;\n+\n+   ---------------------------------------------------\n+   -- Make_Build_In_Place_Call_In_Anonymous_Context --\n+   ---------------------------------------------------\n+\n+   procedure Make_Build_In_Place_Call_In_Anonymous_Context\n+     (Function_Call : Node_Id)\n+   is\n+      Loc             : Source_Ptr;\n+      Func_Call       : Node_Id := Function_Call;\n+      Function_Id     : Entity_Id;\n+      Result_Subt     : Entity_Id;\n+      Return_Obj_Id   : Entity_Id;\n+      Return_Obj_Decl : Entity_Id;\n+\n+   begin\n+      if Nkind (Func_Call) = N_Qualified_Expression then\n+         Func_Call := Expression (Func_Call);\n+      end if;\n+\n+      Loc := Sloc (Function_Call);\n+\n+      if Is_Entity_Name (Name (Func_Call)) then\n+         Function_Id := Entity (Name (Func_Call));\n+\n+      elsif Nkind (Name (Func_Call)) = N_Explicit_Dereference then\n+         Function_Id := Etype (Name (Func_Call));\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Result_Subt := Etype (Function_Id);\n+\n+      --  Create a temporary object to hold the function result\n+\n+      Return_Obj_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('R'));\n+      Set_Etype (Return_Obj_Id, Result_Subt);\n+\n+      Return_Obj_Decl :=\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Return_Obj_Id,\n+          Aliased_Present     => True,\n+          Object_Definition   => New_Reference_To (Result_Subt, Loc));\n+\n+      Set_No_Initialization (Return_Obj_Decl);\n+\n+      Insert_Action (Func_Call, Return_Obj_Decl);\n+\n+      --  Add an implicit actual to the function call that provides access to\n+      --  the caller's return object.\n+\n+      Add_Access_Actual_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, New_Reference_To (Return_Obj_Id, Loc));\n+   end Make_Build_In_Place_Call_In_Anonymous_Context;\n+\n+   ---------------------------------------------------\n+   -- Make_Build_In_Place_Call_In_Assignment --\n+   ---------------------------------------------------\n+\n+   procedure Make_Build_In_Place_Call_In_Assignment\n+     (Assign        : Node_Id;\n+      Function_Call : Node_Id)\n+   is\n+      Lhs             : constant Node_Id := Name (Assign);\n+      Loc             : Source_Ptr;\n+      Func_Call       : Node_Id := Function_Call;\n+      Function_Id     : Entity_Id;\n+      Result_Subt     : Entity_Id;\n+      Ref_Type        : Entity_Id;\n+      Ptr_Typ_Decl    : Node_Id;\n+      Def_Id          : Entity_Id;\n+      New_Expr        : Node_Id;\n+\n+   begin\n+      if Nkind (Func_Call) = N_Qualified_Expression then\n+         Func_Call := Expression (Func_Call);\n+      end if;\n+\n+      Loc := Sloc (Function_Call);\n+\n+      if Is_Entity_Name (Name (Func_Call)) then\n+         Function_Id := Entity (Name (Func_Call));\n+\n+      elsif Nkind (Name (Func_Call)) = N_Explicit_Dereference then\n+         Function_Id := Etype (Name (Func_Call));\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Result_Subt := Etype (Function_Id);\n+\n+      --  Add an implicit actual to the function call that provides access to\n+      --  the caller's return object.\n+\n+      Add_Access_Actual_To_Build_In_Place_Call\n+        (Func_Call,\n+         Function_Id,\n+         Make_Unchecked_Type_Conversion (Loc,\n+           Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n+           Expression   => Relocate_Node (Lhs)));\n+\n+      --  Create an access type designating the function's result subtype\n+\n+      Ref_Type :=\n+        Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+\n+      Ptr_Typ_Decl :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Ref_Type,\n+          Type_Definition =>\n+            Make_Access_To_Object_Definition (Loc,\n+              All_Present => True,\n+              Subtype_Indication =>\n+                New_Reference_To (Result_Subt, Loc)));\n+\n+      Insert_After_And_Analyze (Assign, Ptr_Typ_Decl);\n+\n+      --  Finally, create an access object initialized to a reference to the\n+      --  function call.\n+\n+      Def_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('R'));\n+      Set_Etype (Def_Id, Ref_Type);\n+\n+      New_Expr :=\n+        Make_Reference (Loc,\n+          Prefix => Relocate_Node (Func_Call));\n+\n+      Insert_After_And_Analyze (Ptr_Typ_Decl,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Def_Id,\n+          Object_Definition   => New_Reference_To (Ref_Type, Loc),\n+          Expression          => New_Expr));\n+\n+      Rewrite (Assign, Make_Null_Statement (Loc));\n+   end Make_Build_In_Place_Call_In_Assignment;\n+\n+   ----------------------------------------------------\n+   -- Make_Build_In_Place_Call_In_Object_Declaration --\n+   ----------------------------------------------------\n+\n+   procedure Make_Build_In_Place_Call_In_Object_Declaration\n+     (Object_Decl   : Node_Id;\n+      Function_Call : Node_Id)\n+   is\n+      Loc          : Source_Ptr;\n+      Func_Call    : Node_Id := Function_Call;\n+      Function_Id  : Entity_Id;\n+      Result_Subt  : Entity_Id;\n+      Ref_Type     : Entity_Id;\n+      Ptr_Typ_Decl : Node_Id;\n+      Def_Id       : Entity_Id;\n+      New_Expr     : Node_Id;\n+\n+   begin\n+      if Nkind (Func_Call) = N_Qualified_Expression then\n+         Func_Call := Expression (Func_Call);\n+      end if;\n+\n+      Loc := Sloc (Function_Call);\n+\n+      if Is_Entity_Name (Name (Func_Call)) then\n+         Function_Id := Entity (Name (Func_Call));\n+\n+      elsif Nkind (Name (Func_Call)) = N_Explicit_Dereference then\n+         Function_Id := Etype (Name (Func_Call));\n+\n+      else\n+         raise Program_Error;\n+      end if;\n+\n+      Result_Subt := Etype (Function_Id);\n+\n+      --  Add an implicit actual to the function call that provides access to\n+      --  the declared object. An unchecked conversion to the (specific) result\n+      --  type of the function is inserted to handle the case where the object\n+      --  is declared with a class-wide type.\n+\n+      Add_Access_Actual_To_Build_In_Place_Call\n+        (Func_Call,\n+         Function_Id,\n+         Make_Unchecked_Type_Conversion (Loc,\n+           Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n+           Expression   => New_Reference_To\n+                             (Defining_Identifier (Object_Decl), Loc)));\n+\n+      --  Create an access type designating the function's result subtype\n+\n+      Ref_Type :=\n+        Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+\n+      Ptr_Typ_Decl :=\n+        Make_Full_Type_Declaration (Loc,\n+          Defining_Identifier => Ref_Type,\n+          Type_Definition =>\n+            Make_Access_To_Object_Definition (Loc,\n+              All_Present => True,\n+              Subtype_Indication =>\n+                New_Reference_To (Result_Subt, Loc)));\n+\n+      Insert_After_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n+\n+      --  Finally, create an access object initialized to a reference to the\n+      --  function call.\n+\n+      Def_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_Internal_Name ('R'));\n+      Set_Etype (Def_Id, Ref_Type);\n+\n+      New_Expr :=\n+        Make_Reference (Loc,\n+          Prefix => Relocate_Node (Func_Call));\n+\n+      Insert_After_And_Analyze (Ptr_Typ_Decl,\n+        Make_Object_Declaration (Loc,\n+          Defining_Identifier => Def_Id,\n+          Object_Definition   => New_Reference_To (Ref_Type, Loc),\n+          Expression          => New_Expr));\n+\n+      Set_Expression (Object_Decl, Empty);\n+      Set_No_Initialization (Object_Decl);\n+\n+      --  If the object entity has a class-wide Etype, then we need to change\n+      --  it to the result subtype of the function call, because otherwise the\n+      --  object will be class-wide without an explicit intialization and won't\n+      --  be allocated properly by the back end. It seems unclean to make such\n+      --  a revision to the type at this point, and we should try to improve\n+      --  this treatment when build-in-place functions with class-wide results\n+      --  are implemented. ???\n+\n+      if Is_Class_Wide_Type (Etype (Defining_Identifier (Object_Decl))) then\n+         Set_Etype (Defining_Identifier (Object_Decl), Result_Subt);\n+      end if;\n+   end Make_Build_In_Place_Call_In_Object_Declaration;\n+\n+   ---------------------------------\n+   -- Register_Interface_DT_Entry --\n+   ---------------------------------\n+\n+   procedure Register_Interface_DT_Entry\n+     (Related_Nod : Node_Id;\n+      Prim        : Entity_Id)\n+   is\n+      Loc        : constant Source_Ptr := Sloc (Prim);\n+      Iface_Typ  : Entity_Id;\n+      Tagged_Typ : Entity_Id;\n+      Thunk_Id   : Entity_Id;\n+\n+   begin\n+      --  Nothing to do if the run-time does not support abstract interfaces\n+\n+      if not (RTE_Available (RE_Interface_Tag)) then\n+         return;\n+      end if;\n+\n+      Tagged_Typ := Find_Dispatching_Type (Alias (Prim));\n+      Iface_Typ  := Find_Dispatching_Type (Abstract_Interface_Alias (Prim));\n+\n+      --  Generate the code of the thunk only if the abstract interface type is\n+      --  not an immediate ancestor of Tagged_Type; otherwise the dispatch\n+      --  table associated with the interface is the primary dispatch table.\n+\n+      pragma Assert (Is_Interface (Iface_Typ));\n+\n+      if not Is_Ancestor (Iface_Typ, Tagged_Typ) then\n+         Thunk_Id  :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_Internal_Name ('T'));\n+\n+         Insert_Actions (Related_Nod, New_List (\n+           Expand_Interface_Thunk\n+             (N           => Prim,\n+              Thunk_Alias => Alias (Prim),\n+              Thunk_Id    => Thunk_Id),\n+\n+           Fill_Secondary_DT_Entry (Sloc (Prim),\n+             Prim         => Prim,\n+             Iface_DT_Ptr => Find_Interface_ADT (Tagged_Typ, Iface_Typ),\n+             Thunk_Id     => Thunk_Id)));\n+      end if;\n+   end Register_Interface_DT_Entry;\n+\n end Exp_Ch6;"}, {"sha": "219ce70abdb96a2e7b4c396c082445302251da42", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02822a92a4880fe678967713c9d4988fe7ca9e55/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02822a92a4880fe678967713c9d4988fe7ca9e55/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=02822a92a4880fe678967713c9d4988fe7ca9e55", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---     Copyright (C) 1992,1993,1994,1995 Free Software Foundation, Inc.     --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,9 +40,70 @@ package Exp_Ch6 is\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call.\n \n+   function Is_Build_In_Place_Function (E : Entity_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Returns True if E denotes a function or an\n+   --  access-to-function type whose result must be built in place; otherwise\n+   --  returns False. Currently this is restricted to the subset of functions\n+   --  whose result subtype is a constrained inherently limited type.\n+\n+   function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Returns True if N denotes a call to a function\n+   --  that requires handling as a build-in-place call or is a qualified\n+   --  expression applied to such a call; otherwise returns False.\n+\n    procedure Freeze_Subprogram (N : Node_Id);\n    --  generate the appropriate expansions related to Subprogram freeze\n    --  nodes (e. g. the filling of the corresponding Dispatch Table for\n    --  Primitive Operations)\n \n+   procedure Make_Build_In_Place_Call_In_Allocator\n+     (Allocator     : Node_Id;\n+      Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs as the expression initializing an allocator, by passing access\n+   --  to the allocated object as an additional parameter of the function call.\n+   --  A new access object is declared that is initialized to the result of the\n+   --  allocator, passed to the function, and the allocator is rewritten to\n+   --  refer to that access object. Function_Call must denote either an\n+   --  N_Function_Call node for which Is_Build_In_Place_Call is True, or else\n+   --  an N_Qualified_Expression node applied to such a function call.\n+\n+   procedure Make_Build_In_Place_Call_In_Anonymous_Context\n+     (Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs in a context that does not provide a separate object. A temporary\n+   --  object is created to act as the return object and an access to the\n+   --  temporary is passed as an additional parameter of the call. This occurs\n+   --  in contexts such as subprogram call actuals and object renamings.\n+   --  Function_Call must denote either an N_Function_Call node for which\n+   --  Is_Build_In_Place_Call is True, or else an N_Qualified_Expression node\n+   --  applied to such a function call.\n+\n+   procedure Make_Build_In_Place_Call_In_Assignment\n+     (Assign        : Node_Id;\n+      Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs as the right-hand side of an assignment statement by passing\n+   --  access to the left-hand sid as an additional parameter of the function\n+   --  call. Assign must denote a N_Assignment_Statement. Function_Call must\n+   --  denote either an N_Function_Call node for which Is_Build_In_Place_Call\n+   --  is True, or an N_Qualified_Expression node applied to such a function\n+   --  call.\n+\n+   procedure Make_Build_In_Place_Call_In_Object_Declaration\n+     (Object_Decl   : Node_Id;\n+      Function_Call : Node_Id);\n+   --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n+   --  occurs as the expression initializing an object declaration by\n+   --  passing access to the declared object as an additional parameter of the\n+   --  function call. Function_Call must denote either an N_Function_Call node\n+   --  for which Is_Build_In_Place_Call is True, or an N_Qualified_Expression\n+   --  node applied to such a function call.\n+\n+   procedure Register_Interface_DT_Entry\n+     (Related_Nod : Node_Id;\n+      Prim        : Entity_Id);\n+   --  Ada 2005 (AI-251): Register a primitive in a secondary dispatch table.\n+   --  Related_Nod is the node after which the expanded code will be inserted.\n+\n end Exp_Ch6;"}]}