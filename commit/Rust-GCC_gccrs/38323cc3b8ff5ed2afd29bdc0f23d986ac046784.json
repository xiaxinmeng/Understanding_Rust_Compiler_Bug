{"sha": "38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgzMjNjYzNiOGZmNWVkMmFmZDI5YmRjMGYyM2Q5ODZhYzA0Njc4NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-29T03:59:00Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-29T03:59:00Z"}, "message": "reload.c (push_secondary_reload): Revert 2000-08-16 change.\n\n        * reload.c (push_secondary_reload): Revert 2000-08-16 change.\n        (find_reloads): Likewise.\n        * config/alpha/alpha.md (reload_inqi): Revert 2000-08-11 change.\n        (reload_inhi): Likewise.\n\nFrom-SVN: r36028", "tree": {"sha": "ddcdb69aa72e50e7fe0f35dec6d89a3e77164430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddcdb69aa72e50e7fe0f35dec6d89a3e77164430"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/comments", "author": null, "committer": null, "parents": [{"sha": "2ed885df7663984e9e415b56fc242e58b7b1319f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ed885df7663984e9e415b56fc242e58b7b1319f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ed885df7663984e9e415b56fc242e58b7b1319f"}], "stats": {"total": 56, "additions": 35, "deletions": 21}, "files": [{"sha": "bec85cd990ad6511b82d1d2e045d835c0487aa80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "patch": "@@ -1,3 +1,10 @@\n+2000-08-28  Richard Henderson  <rth@cygnus.com>\n+\n+\t* reload.c (push_secondary_reload): Revert 2000-08-16 change.\n+\t(find_reloads): Likewise.\n+\t* config/alpha/alpha.md (reload_inqi): Revert 2000-08-11 change.\n+\t(reload_inhi): Likewise.\n+\n 2000-08-28  Richard Henderson  <rth@cygnus.com>\n \n \t* config/i386/i386.c: Don't error on EXTRA_CONSTRAINT defined."}, {"sha": "36d16c244c8ba9e22b8b84bddc653c8df66c507b", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "patch": "@@ -5343,11 +5343,11 @@\n (define_expand \"reload_inqi\"\n   [(parallel [(match_operand:QI 0 \"register_operand\" \"=r\")\n \t      (match_operand:QI 1 \"any_memory_operand\" \"m\")\n-\t      (match_operand:DI 2 \"register_operand\" \"=&r\")])]\n+\t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n {\n-  rtx seq;\n+  rtx scratch, seq;\n \n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n@@ -5361,8 +5361,16 @@\n     {\n       rtx addr;\n \n+      /* It is possible that one of the registers we got for operands[2]\n+\t might coincide with that of operands[0] (which is why we made\n+\t it TImode).  Pick the other one to use as our scratch.  */\n+      if (REGNO (operands[0]) == REGNO (operands[2]))\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n+      else\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n+\n       addr = get_unaligned_address (operands[1], 0);\n-      seq = gen_unaligned_loadqi (operands[0], addr, operands[2],\n+      seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n \t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n       alpha_set_memflags (seq, operands[1]);\n     }\n@@ -5373,11 +5381,11 @@\n (define_expand \"reload_inhi\"\n   [(parallel [(match_operand:HI 0 \"register_operand\" \"=r\")\n \t      (match_operand:HI 1 \"any_memory_operand\" \"m\")\n-\t      (match_operand:DI 2 \"register_operand\" \"=&r\")])]\n+\t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n {\n-  rtx seq;\n+  rtx scratch, seq;\n \n   if (GET_CODE (operands[1]) != MEM)\n     abort ();\n@@ -5391,8 +5399,16 @@\n     {\n       rtx addr;\n \n+      /* It is possible that one of the registers we got for operands[2]\n+\t might coincide with that of operands[0] (which is why we made\n+\t it TImode).  Pick the other one to use as our scratch.  */\n+      if (REGNO (operands[0]) == REGNO (operands[2]))\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n+      else\n+\tscratch = gen_rtx_REG (DImode, REGNO (operands[2]));\n+\n       addr = get_unaligned_address (operands[1], 0);\n-      seq = gen_unaligned_loadhi (operands[0], addr, operands[2],\n+      seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n \t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n       alpha_set_memflags (seq, operands[1]);\n     }"}, {"sha": "bf9c5ecf749f9e13def6ce755fb036186012f88f", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38323cc3b8ff5ed2afd29bdc0f23d986ac046784/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=38323cc3b8ff5ed2afd29bdc0f23d986ac046784", "patch": "@@ -400,8 +400,6 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \t  t_icode = icode;\n \t  icode = CODE_FOR_nothing;\n \t}\n-\n-      secondary_type = in_p ? RELOAD_FOR_INPUT : RELOAD_FOR_OUTPUT;\n     }\n \n   /* This case isn't valid, so fail.  Reload is allowed to use the same\n@@ -3930,11 +3928,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   for (i = 0; i < n_reloads; i++)\n     {\n       if (rld[i].secondary_p\n-\t  && rld[i].when_needed == operand_type[rld[i].opnum]\n-          && (operand_reloadnum[rld[i].opnum] < 0\n-\t      || (rld[operand_reloadnum[rld[i].opnum]].secondary_in_icode == -1\n-\t\t  && rld[operand_reloadnum[rld[i].opnum]].secondary_out_icode == -1)))\n-\t  rld[i].when_needed = address_type[rld[i].opnum];\n+\t  && rld[i].when_needed == operand_type[rld[i].opnum])\n+\trld[i].when_needed = address_type[rld[i].opnum];\n \n       if ((rld[i].when_needed == RELOAD_FOR_INPUT_ADDRESS\n \t   || rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n@@ -3953,15 +3948,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      int secondary_in_reload = rld[i].secondary_in_reload;\n \n \t      rld[secondary_in_reload].when_needed\n-\t\t= (rld[i].secondary_in_icode == -1\n-\t\t   ? RELOAD_FOR_OPADDR_ADDR\n-\t\t   : RELOAD_FOR_OPERAND_ADDRESS);\n+\t\t= RELOAD_FOR_OPADDR_ADDR;\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_in_reload > 0\n \t\t  && rld[secondary_in_reload].secondary_in_reload != -1)\n \t\trld[rld[secondary_in_reload].secondary_in_reload].when_needed\n-\t\t  = rld[secondary_in_reload].when_needed;\n+\t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n \t  if ((rld[i].when_needed == RELOAD_FOR_OUTPUT_ADDRESS\n@@ -3971,15 +3964,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      int secondary_out_reload = rld[i].secondary_out_reload;\n \n \t      rld[secondary_out_reload].when_needed\n-\t\t= (rld[i].secondary_out_icode == -1\n-\t\t   ? RELOAD_FOR_OPADDR_ADDR\n-\t\t   : RELOAD_FOR_OPERAND_ADDRESS);\n+\t\t= RELOAD_FOR_OPADDR_ADDR;\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_out_reload\n \t\t  && rld[secondary_out_reload].secondary_out_reload != -1)\n \t\trld[rld[secondary_out_reload].secondary_out_reload].when_needed\n-\t\t  = rld[secondary_out_reload].when_needed;\n+\t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n \t  if (rld[i].when_needed == RELOAD_FOR_INPADDR_ADDRESS"}]}