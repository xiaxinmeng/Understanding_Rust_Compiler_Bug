{"sha": "afee2a52da20b6062fcc367e9178395ee314e41f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZlZTJhNTJkYTIwYjYwNjJmY2MzNjdlOTE3ODM5NWVlMzE0ZTQxZg==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@linux.org.pl", "date": "2000-10-20T15:21:16Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2000-10-20T15:21:16Z"}, "message": "avr-protos.h (avr_output_bld): New.\n\n\t* config/avr/avr-protos.h (avr_output_bld): New.\n\t(out_shift_with_cnt): Add t_len argument.\n\t* config/avr/avr.c (avr_num_arg_regs): Remove -mpack-args.\n\t(output_movqi, output_movhi, output_movsisf): Optimize loading\n\tany constant with exactly one bit set to NO_LD_REGS.\n\t(out_shift_with_cnt): Optimize output code for size or speed,\n\tdepending on optimize_size.  Handle small shift counts as well\n\t(if not hand-optimized in ?sh??i3_out).  Shifts can be done\n\twith or without a scratch register, with help of __tmp_reg__\n\tor __zero_reg__ if necessary.  Add T_LEN argument to pass the\n\tlength of TEMPLATE in words, return total insn length in *LEN.\n\t(ashlqi3_out, ashrqi3_out, lshrqi3_out): Change all calls to\n\tout_shift_with_cnt to work with the above change.\n\t(ashlhi3_out, ashlsi3_out, ashrhi3_out, ashrsi3_out, lshrhi3_out,\n\tlshrsi3_out): Likewise.  Optimize more known shift count cases.\n\tRemove cases already well optimized in out_shift_with_cnt.\n\t(avr_output_bld): New function.\n\t* config/avr/avr.h (MASK_PACK_ARGS, TARGET_PACK_ARGS): Remove.\n\t(TARGET_SWITCHES): Remove -mpack-args backward compatibility.\n\t* config/avr/avr.md (*reload_inqi, *reload_inhi, *reload_insi):\n\tAdd reload_completed to insn condition - only for peepholes.\n\t(ashlqi3, ashrqi3, lshrqi3): Correct insn length for shift counts\n\tin a register or memory.\n\t(ashlhi3, ashlsi3, ashrhi3, ashrsi3, lshrhi3, lshrsi3): Likewise.\n\tDo not require a scratch register.\n\t(*ashlhi3_const, *ashlsi3_const, *ashrhi3_const, *ashrsi3_const,\n\t*lshrhi3_const, *lshrsi3_const): New insns and matching peepholes.\n\tOptimize shifts by known count using a scratch register, but only\n\tif one is still available after register allocation.\n\nFrom-SVN: r36963", "tree": {"sha": "56649df2c76f6c4e0999603720aa367e1746381d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56649df2c76f6c4e0999603720aa367e1746381d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afee2a52da20b6062fcc367e9178395ee314e41f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afee2a52da20b6062fcc367e9178395ee314e41f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afee2a52da20b6062fcc367e9178395ee314e41f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afee2a52da20b6062fcc367e9178395ee314e41f/comments", "author": null, "committer": null, "parents": [{"sha": "406b0a7cd686e97f5c9729c369cdcf3821ccf08e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406b0a7cd686e97f5c9729c369cdcf3821ccf08e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406b0a7cd686e97f5c9729c369cdcf3821ccf08e"}], "stats": {"total": 1146, "additions": 797, "deletions": 349}, "files": [{"sha": "b4ca68f3312c02e923edae4da9b161c57f8fa833", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afee2a52da20b6062fcc367e9178395ee314e41f", "patch": "@@ -1,3 +1,35 @@\n+2000-10-14  Marek Michalkiewicz  <marekm@linux.org.pl>\n+\n+\t* config/avr/avr-protos.h (avr_output_bld): New.\n+\t(out_shift_with_cnt): Add t_len argument.\n+\t* config/avr/avr.c (avr_num_arg_regs): Remove -mpack-args.\n+\t(output_movqi, output_movhi, output_movsisf): Optimize loading\n+\tany constant with exactly one bit set to NO_LD_REGS.\n+\t(out_shift_with_cnt): Optimize output code for size or speed,\n+\tdepending on optimize_size.  Handle small shift counts as well\n+\t(if not hand-optimized in ?sh??i3_out).  Shifts can be done\n+\twith or without a scratch register, with help of __tmp_reg__\n+\tor __zero_reg__ if necessary.  Add T_LEN argument to pass the\n+\tlength of TEMPLATE in words, return total insn length in *LEN.\n+\t(ashlqi3_out, ashrqi3_out, lshrqi3_out): Change all calls to\n+\tout_shift_with_cnt to work with the above change.\n+\t(ashlhi3_out, ashlsi3_out, ashrhi3_out, ashrsi3_out, lshrhi3_out,\n+\tlshrsi3_out): Likewise.  Optimize more known shift count cases.\n+\tRemove cases already well optimized in out_shift_with_cnt.\n+\t(avr_output_bld): New function.\n+\t* config/avr/avr.h (MASK_PACK_ARGS, TARGET_PACK_ARGS): Remove.\n+\t(TARGET_SWITCHES): Remove -mpack-args backward compatibility.\n+\t* config/avr/avr.md (*reload_inqi, *reload_inhi, *reload_insi):\n+\tAdd reload_completed to insn condition - only for peepholes.\n+\t(ashlqi3, ashrqi3, lshrqi3): Correct insn length for shift counts\n+\tin a register or memory.\n+\t(ashlhi3, ashlsi3, ashrhi3, ashrsi3, lshrhi3, lshrsi3): Likewise.\n+\tDo not require a scratch register.\n+\t(*ashlhi3_const, *ashlsi3_const, *ashrhi3_const, *ashrsi3_const,\n+\t*lshrhi3_const, *lshrsi3_const): New insns and matching peepholes.\n+\tOptimize shifts by known count using a scratch register, but only\n+\tif one is still available after register allocation.\n+\n 2000-10-20  J. David Anglin  <dave@hiauly1.hia.nrc.ca>\n  \n \t* t-vax: New file.  Don't build modules from libgcc1.c."}, {"sha": "14d34d18d61c12f69130592b0a62d10bf0d18c3b", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=afee2a52da20b6062fcc367e9178395ee314e41f", "patch": "@@ -109,6 +109,8 @@ extern const char * lshrqi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n extern const char * lshrhi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n extern const char * lshrsi3_out PARAMS ((rtx insn, rtx operands[], int *len));\n \n+extern void avr_output_bld PARAMS ((rtx operands[], int bit_nr));\n+\n extern enum reg_class preferred_reload_class PARAMS ((rtx x,\n \t\t\t\t\t\t     enum reg_class class));\n extern int    avr_address_cost       PARAMS ((rtx x));\n@@ -150,7 +152,8 @@ extern int    avr_simplify_comparision_p PARAMS ((enum machine_mode mode,\n extern RTX_CODE avr_normalize_condition  PARAMS ((RTX_CODE condition));\n extern int    compare_eq_p           PARAMS ((rtx insn));\n extern void   out_shift_with_cnt     PARAMS ((const char *template, rtx insn,\n-\t\t\t\t\t      rtx operands[], int *len));\n+\t\t\t\t\t      rtx operands[], int *len,\n+\t\t\t\t\t      int t_len));\n extern int    const_int_pow2_p       PARAMS ((rtx x));\n #endif /* RTX_CODE */\n "}, {"sha": "2854738d00f4d61f3e2363dde65c53271113556c", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 604, "deletions": 307, "changes": 911, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=afee2a52da20b6062fcc367e9178395ee314e41f", "patch": "@@ -1363,17 +1363,10 @@ avr_num_arg_regs (mode, type)\n   else\n     size = GET_MODE_SIZE (mode);\n \n-  /* Align all function arguments to start in even-numbered registers,\n-     for \"movw\" on the enhanced core (to keep call conventions the same\n-     on all devices, do it even if \"movw\" is not available).  Odd-sized\n-     arguments leave holes above them - registers still available for\n-     other uses.  Use -mpack-args for compatibility with old asm code\n-     (the new convention will still be used for libgcc calls).  */\n+  /* Align all function arguments to start in even-numbered registers.\n+     Odd-sized arguments leave holes above them.  */\n \n-  if (!(type && TARGET_PACK_ARGS))\n-    size += size & 1;\n-\n-  return size;\n+  return (size + 1) & ~1;\n }\n \n /* Controls whether a function argument is passed\n@@ -1464,20 +1457,6 @@ output_movqi (insn, operands, l)\n \t\t  return (AS1 (clr,%0) CR_TAB\n \t\t\t  AS1 (inc,%0));\n \t\t}\n-\t      else if (src == const2_rtx)\n-\t\t{\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      *l = 2;\n-\t\t      return (AS1 (inc,%0 ; reg_was_0) CR_TAB\n-\t\t\t      AS1 (inc,%0));\n-\t\t    }\n-\n-\t\t  *l = 3;\n-\t\t  return (AS1 (clr,%0) CR_TAB\n-\t\t\t  AS1 (inc,%0) CR_TAB\n-\t\t\t  AS1 (inc,%0));\n-\t\t}\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n@@ -1488,7 +1467,31 @@ output_movqi (insn, operands, l)\n \t\t  return (AS1 (clr,%0) CR_TAB\n \t\t\t  AS1 (dec,%0));\n \t\t}\n-\t      \n+\t      else\n+\t\t{\n+\t\t  int bit_nr = exact_log2 (INTVAL (src));\n+\n+\t\t  if (bit_nr >= 0)\n+\t\t    {\n+\t\t      if (reg_was_0 (insn, dest))\n+\t\t\t{\n+\t\t\t  *l = 2;\n+\t\t\t  if (!real_l)\n+\t\t\t    output_asm_insn (\"set ; reg_was_0\", operands);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  *l = 3;\n+\t\t\t  if (!real_l)\n+\t\t\t    output_asm_insn ((AS1 (clr,%0) CR_TAB\n+\t\t\t\t\t      \"set\"), operands);\n+\t\t\t}\n+\t\t      if (!real_l)\n+\t\t\tavr_output_bld (operands, bit_nr);\n+\n+\t\t      return \"\";\n+\t\t    }\n+\t\t}\n \t    }\n \t  \n \t  /* Last resort, larger than loading from memory.  */\n@@ -1621,21 +1624,6 @@ output_movhi (insn, operands, l)\n \t\t\t  AS1 (clr,%B0) CR_TAB\n \t\t\t  AS1 (inc,%A0));\n \t\t}\n-\t      else if (src == const2_rtx)\n-\t\t{\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      *l = 2;\n-\t\t      return (AS1 (inc,%0 ; reg_was_0) CR_TAB\n-\t\t\t      AS1 (inc,%0));\n-\t\t    }\n-\n-\t\t  *l = 4;\n-\t\t  return (AS1 (clr,%A0) CR_TAB\n-\t\t\t  AS1 (clr,%B0) CR_TAB\n-\t\t\t  AS1 (inc,%A0) CR_TAB\n-\t\t\t  AS1 (inc,%A0));\n-\t\t}\n \t      else if (src == constm1_rtx)\n \t\t{\n \t\t  /* Immediate constants -1 to any register */\n@@ -1651,6 +1639,33 @@ output_movhi (insn, operands, l)\n \t\t\t  AS1 (dec,%A0) CR_TAB\n \t\t\t  AS2 (mov,%B0,%A0));\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  int bit_nr = exact_log2 (INTVAL (src));\n+\n+\t\t  if (bit_nr >= 0)\n+\t\t    {\n+\t\t      if (reg_was_0 (insn, dest))\n+\t\t\t{\n+\t\t\t  *l = 2;\n+\t\t\t  if (!real_l)\n+\t\t\t    output_asm_insn (\"set ; reg_was_0\", operands);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  *l = 4;\n+\t\t\t  if (!real_l)\n+\t\t\t    output_asm_insn ((AS1 (clr,%A0) CR_TAB\n+\t\t\t\t\t      AS1 (clr,%B0) CR_TAB\n+\t\t\t\t\t      \"set\"), operands);\n+\t\t\t}\n+\t\t      if (!real_l)\n+\t\t\tavr_output_bld (operands, bit_nr);\n+\n+\t\t      return \"\";\n+\t\t    }\n+\t\t}\n+\n \t      if ((INTVAL (src) & 0xff) == 0)\n \t\t{\n \t\t  *l = 5;\n@@ -2260,20 +2275,19 @@ output_movsisf(insn, operands, l)\n \t  \n \t  if (GET_CODE (src) == CONST_INT)\n \t    {\n+\t      const char *clr_op0 =\n+\t\tAVR_ENHANCED ? (AS1 (clr,%A0) CR_TAB\n+\t\t\t\tAS1 (clr,%B0) CR_TAB\n+\t\t\t\tAS2 (movw,%C0,%A0))\n+\t\t\t     : (AS1 (clr,%A0) CR_TAB\n+\t\t\t\tAS1 (clr,%B0) CR_TAB\n+\t\t\t\tAS1 (clr,%C0) CR_TAB\n+\t\t\t\tAS1 (clr,%D0));\n+\n \t      if (src == const0_rtx) /* mov r,L */\n \t\t{\n-\t\t  if (AVR_ENHANCED)\n-\t\t    {\n-\t\t      *l = 3;\n-\t\t      return (AS1 (clr,%A0) CR_TAB\n-\t\t\t      AS1 (clr,%B0) CR_TAB\n-\t\t\t      AS2 (movw,%C0,%A0));\n-\t\t    }\n-\t\t  *l = 4;\n-\t\t  return (AS1 (clr,%A0) CR_TAB\n-\t\t\t  AS1 (clr,%B0) CR_TAB\n-\t\t\t  AS1 (clr,%C0) CR_TAB\n-\t\t\t  AS1 (clr,%D0));\n+\t\t  *l = AVR_ENHANCED ? 3 : 4;\n+\t\t  return clr_op0;\n \t\t}\n \t      else if (src == const1_rtx)\n \t\t{\n@@ -2282,46 +2296,10 @@ output_movsisf(insn, operands, l)\n \t\t      *l = 1;\n \t\t      return AS1 (inc,%A0 ; reg_was_0);\n \t\t    }\n-\t\t  if (AVR_ENHANCED)\n-\t\t    {\n-\t\t      *l = 4;\n-\t\t      return (AS1 (clr,%A0) CR_TAB\n-\t\t\t      AS1 (clr,%B0) CR_TAB\n-\t\t\t      AS2 (movw,%C0,%A0) CR_TAB\n-\t\t\t      AS1 (inc,%A0));\n-\t\t    }\n-\t\t  *l = 5;\n-\t\t  return (AS1 (clr,%A0) CR_TAB\n-\t\t\t  AS1 (clr,%B0) CR_TAB\n-\t\t\t  AS1 (clr,%C0) CR_TAB\n-\t\t\t  AS1 (clr,%D0) CR_TAB\n-\t\t\t  AS1 (inc,%A0));\n-\t\t}\n-\t      else if (src == const2_rtx)\n-\t\t{\n-\t\t  if (reg_was_0 (insn, dest))\n-\t\t    {\n-\t\t      *l = 2;\n-\t\t      return (AS1 (inc,%A0 ; reg_was_0) CR_TAB\n-\t\t\t      AS1 (inc,%A0));\n-\t\t    }\n-\n-\t\t  if (AVR_ENHANCED)\n-\t\t    {\n-\t\t      *l = 5;\n-\t\t      return (AS1 (clr,%D0)      CR_TAB\n-\t\t\t      AS1 (clr,%C0)      CR_TAB\n-\t\t\t      AS2 (movw,%A0,%C0) CR_TAB\n-\t\t\t      AS1 (inc,%A0)      CR_TAB\n-\t\t\t      AS1 (inc,%A0));\n-\t\t    }\n-\t\t  *l = 6;\n-\t\t  return (AS1 (clr,%D0) CR_TAB\n-\t\t\t  AS1 (clr,%B0) CR_TAB\n-\t\t\t  AS1 (clr,%C0) CR_TAB\n-\t\t\t  AS1 (clr,%A0) CR_TAB\n-\t\t\t  AS1 (inc,%A0) CR_TAB\n-\t\t\t  AS1 (inc,%A0));\n+\t\t  if (!real_l)\n+\t\t    output_asm_insn (clr_op0, operands);\n+\t\t  *l = AVR_ENHANCED ? 4 : 5;\n+\t\t  return AS1 (inc,%A0);\n \t\t}\n \t      else if (src == constm1_rtx)\n \t\t{\n@@ -2356,6 +2334,33 @@ output_movsisf(insn, operands, l)\n \t\t\t  AS2 (mov,%C0,%A0) CR_TAB\n \t\t\t  AS2 (mov,%D0,%A0));\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  int bit_nr = exact_log2 (INTVAL (src));\n+\n+\t\t  if (bit_nr >= 0)\n+\t\t    {\n+\t\t      if (reg_was_0 (insn, dest))\n+\t\t\t{\n+\t\t\t  *l = 2;\n+\t\t\t  if (!real_l)\n+\t\t\t    output_asm_insn (\"set ; reg_was_0\", operands);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  *l = AVR_ENHANCED ? 5 : 6;\n+\t\t\t  if (!real_l)\n+\t\t\t    {\n+\t\t\t      output_asm_insn (clr_op0, operands);\n+\t\t\t      output_asm_insn (\"set\", operands);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      if (!real_l)\n+\t\t\tavr_output_bld (operands, bit_nr);\n+\n+\t\t      return \"\";\n+\t\t    }\n+\t\t}\n \t    }\n \t  \n \t  /* Last resort, better than loading from memory.  */\n@@ -2684,52 +2689,107 @@ out_tstsi (insn, l)\n }\n \n \n-/* Generate asm equivalent for various shift's.\n-   Shift count are CONST_INT or REG.  */\n+/* Generate asm equivalent for various shifts.\n+   Shift count is a CONST_INT, MEM or REG.\n+   This only handles cases that are not already\n+   carefully hand-optimized in ?sh??i3_out.  */\n \n void\n-out_shift_with_cnt (template, insn, operands, len)\n+out_shift_with_cnt (template, insn, operands, len, t_len)\n      const char *template;\n      rtx insn;\n      rtx operands[];\n      int *len;\n+     int t_len;  /* Length of template.  */\n {\n   rtx op[10];\n-  char str[300];\n+  char str[500];\n   int second_label = 1;\n-  \n+  int saved_in_tmp = 0;\n+  int use_zero_reg = 0;\n+\n   op[0] = operands[0];\n   op[1] = operands[1];\n   op[2] = operands[2];\n   op[3] = operands[3];\n   str[0] = 0;\n-    \n-  if (CONSTANT_P (operands[2]))\n+\n+  if (len)\n+    *len = 1;\n+\n+  if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      if (len)\n-\t++*len;\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int count = INTVAL (operands[2]);\n+      int max_len = 10;  /* If larger than this, always use a loop.  */\n+\n+      if (count < 8 && !scratch)\n+\tuse_zero_reg = 1;\n+\n+      if (optimize_size)\n+\tmax_len = t_len + (scratch ? 3 : (use_zero_reg ? 4 : 5));\n+\n+      if (t_len * count <= max_len)\n+\t{\n+\t  /* Output shifts inline with no loop - faster.  */\n+\t  if (len)\n+\t    *len = t_len * count;\n+\t  else\n+\t    {\n+\t      while (count-- > 0)\n+\t\toutput_asm_insn (template, op);\n+\t    }\n+\n+\t  return;\n+\t}\n+\n+      if (scratch)\n+\t{\n+\t  if (!len)\n+\t    strcat (str, AS2 (ldi,%3,%2));\n+\t}\n+      else if (use_zero_reg)\n+\t{\n+\t  /* Hack to save one word: use __zero_reg__ as loop counter.\n+\t     Set one bit, then shift in a loop until it is 0 again.  */\n+\n+\t  op[3] = zero_reg_rtx;\n+\t  if (len)\n+\t    *len = 2;\n+\t  else\n+\t    strcat (str, (\"set\" CR_TAB\n+\t\t\t  AS2 (bld,%3,%2-1)));\n+\t}\n       else\n-\tstrcat (str, AS2 (ldi,%3,lo8((%2)-1)));\n+\t{\n+\t  /* No scratch register available, use one from LD_REGS (saved in\n+\t     __tmp_reg__) that doesn't overlap with registers to shift.  */\n+\n+\t  op[3] = gen_rtx (REG, QImode,\n+\t\t\t   ((true_regnum (operands[0]) - 1) & 15) + 16);\n+\t  op[4] = tmp_reg_rtx;\n+\t  saved_in_tmp = 1;\n+\n+\t  if (len)\n+\t    *len = 3;  /* Includes \"mov %3,%4\" after the loop.  */\n+\t  else\n+\t    strcat (str, (AS2 (mov,%4,%3) CR_TAB\n+\t\t\t  AS2 (ldi,%3,%2)));\n+\t}\n+\n       second_label = 0;\n     }\n   else if (GET_CODE (operands[2]) == MEM)\n     {\n-      int mov_len;\n       rtx op_mov[10];\n       \n       op[3] = op_mov[0] = tmp_reg_rtx;\n       op_mov[1] = op[2];\n-      \n-      if (!len)\n-\t{\n-\t  output_asm_insn (out_movqi_r_mr (insn, op_mov, NULL), op_mov);\n-\t  strcat (str, AS1 (rjmp,2f));\n-\t}\n+\n+      if (len)\n+\tout_movqi_r_mr (insn, op_mov, len);\n       else\n-\t{\n-\t  out_movqi_r_mr (insn, op_mov, &mov_len);\n-\t  *len += mov_len + 1;\n-\t}\n+\toutput_asm_insn (out_movqi_r_mr (insn, op_mov, NULL), op_mov);\n     }\n   else if (register_operand (operands[2], QImode))\n     {\n@@ -2738,26 +2798,33 @@ out_shift_with_cnt (template, insn, operands, len)\n       else\n \t{\n \t  op[3] = tmp_reg_rtx;\n-\t  if (len)\n-\t    ++*len;\n-\t  else\n-\t    strcat (str, AS2 (mov,%3,%2) CR_TAB);\n+\t  if (!len)\n+\t    strcat (str, (AS2 (mov,%3,%2) CR_TAB));\n \t}\n-      \n+    }\n+  else\n+    fatal_insn (\"Bad shift insn:\", insn);\n+\n+  if (second_label)\n+    {\n       if (len)\n \t++*len;\n       else\n \tstrcat (str, AS1 (rjmp,2f));\n-      \n     }\n-  if (!len)\n+\n+  if (len)\n+    *len += t_len + 2;  /* template + dec + brXX */\n+  else\n     {\n       strcat (str, \"\\n1:\\t\");\n       strcat (str, template);\n       strcat (str, second_label ? \"\\n2:\\t\" : \"\\n\\t\");\n-      strcat (str,\n-\t      AS1 (dec,%3) CR_TAB\n-\t      AS1 (brpl,1b));\n+      strcat (str, use_zero_reg ? AS1 (lsr,%3) : AS1 (dec,%3));\n+      strcat (str, CR_TAB);\n+      strcat (str, second_label ? AS1 (brpl,1b) : AS1 (brne,1b));\n+      if (saved_in_tmp)\n+\tstrcat (str, (CR_TAB AS2 (mov,%3,%4)));\n       output_asm_insn (str, op);\n     }\n }\n@@ -2854,10 +2921,8 @@ ashlqi3_out (insn, operands, len)\n   else if (CONSTANT_P (operands[2]))\n     fatal_insn (\"Internal compiler bug.\\nIncorrect shift:\", insn);\n \n-  if (len)\n-    *len = 3;\n   out_shift_with_cnt (AS1 (lsl,%0),\n-\t\t      insn, operands, len);\n+\t\t      insn, operands, len, 1);\n   return \"\";\n }\n \n@@ -2872,25 +2937,85 @@ ashlhi3_out (insn, operands, len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int ldi_ok = test_hard_reg_class (LD_REGS, operands[0]);\n       int k;\n-      int *t=len;\n+      int *t = len;\n \n       if (!len)\n \tlen = &k;\n       \n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 1:\n-\t  *len = 2;\n-\t  return (AS1 (lsl,%A0) CR_TAB\n-\t\t  AS1 (rol,%B0));\n+\tcase 4:\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  if (ldi_ok)\n+\t    {\n+\t      *len = 6;\n+\t      return (AS1 (swap,%A0)      CR_TAB\n+\t\t      AS1 (swap,%B0)      CR_TAB\n+\t\t      AS2 (andi,%B0,0xf0) CR_TAB\n+\t\t      AS2 (eor,%B0,%A0)   CR_TAB\n+\t\t      AS2 (andi,%A0,0xf0) CR_TAB\n+\t\t      AS2 (eor,%B0,%A0));\n+\t    }\n+\t  if (scratch)\n+\t    {\n+\t      *len = 7;\n+\t      return (AS1 (swap,%A0)    CR_TAB\n+\t\t      AS1 (swap,%B0)    CR_TAB\n+\t\t      AS2 (ldi,%3,0xf0) CR_TAB\n+\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      AS2 (eor,%B0,%A0) CR_TAB\n+\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      AS2 (eor,%B0,%A0));\n+\t    }\n+\t  break;  /* optimize_size ? 6 : 8 */\n \n-\tcase 2:\n-\t  *len = 4;\n-\t  return (AS1 (lsl,%A0) CR_TAB\n-\t\t  AS1 (rol,%B0) CR_TAB\n-\t\t  AS1 (lsl,%A0) CR_TAB\n-\t\t  AS1 (rol,%B0));\n+\tcase 5:\n+\t  if (optimize_size)\n+\t    break;  /* scratch ? 5 : 6 */\n+\t  if (ldi_ok)\n+\t    {\n+\t      *len = 8;\n+\t      return (AS1 (lsl,%A0)       CR_TAB\n+\t\t      AS1 (rol,%B0)       CR_TAB\n+\t\t      AS1 (swap,%A0)      CR_TAB\n+\t\t      AS1 (swap,%B0)      CR_TAB\n+\t\t      AS2 (andi,%B0,0xf0) CR_TAB\n+\t\t      AS2 (eor,%B0,%A0)   CR_TAB\n+\t\t      AS2 (andi,%A0,0xf0) CR_TAB\n+\t\t      AS2 (eor,%B0,%A0));\n+\t    }\n+\t  if (scratch)\n+\t    {\n+\t      *len = 9;\n+\t      return (AS1 (lsl,%A0)     CR_TAB\n+\t\t      AS1 (rol,%B0)     CR_TAB\n+\t\t      AS1 (swap,%A0)    CR_TAB\n+\t\t      AS1 (swap,%B0)    CR_TAB\n+\t\t      AS2 (ldi,%3,0xf0) CR_TAB\n+\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      AS2 (eor,%B0,%A0) CR_TAB\n+\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      AS2 (eor,%B0,%A0));\n+\t    }\n+\t  break;  /* 10 */\n+\n+\tcase 6:\n+\t  if (optimize_size)\n+\t    break;  /* scratch ? 5 : 6 */\n+\t  *len = 9;\n+\t  return (AS1 (clr,__tmp_reg__) CR_TAB\n+\t\t  AS1 (lsr,%B0)         CR_TAB\n+\t\t  AS1 (ror,%A0)         CR_TAB\n+\t\t  AS1 (ror,__tmp_reg__) CR_TAB\n+\t\t  AS1 (lsr,%B0)         CR_TAB\n+\t\t  AS1 (ror,%A0)         CR_TAB\n+\t\t  AS1 (ror,__tmp_reg__) CR_TAB\n+\t\t  AS2 (mov,%B0,%A0)     CR_TAB\n+\t\t  AS2 (mov,%A0,__tmp_reg__));\n \n \tcase 7:\n \t  *len = 5;\n@@ -2929,24 +3054,33 @@ ashlhi3_out (insn, operands, len)\n \t\t  AS1 (lsl,%B0));\n \n \tcase 12:\n-\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (ldi_ok)\n \t    {\n \t      *len = 4;\n \t      return (AS2 (mov,%B0,%A0) CR_TAB\n \t\t      AS1 (clr,%A0)     CR_TAB\n \t\t      AS1 (swap,%B0)    CR_TAB\n \t\t      AS2 (andi,%B0,0xf0));\n \t    }\n-\t  /* %3 is a scratch register from class LD_REGS */\n-\t  *len = 5;\n+\t  if (scratch)\n+\t    {\n+\t      *len = 5;\n+\t      return (AS2 (mov,%B0,%A0) CR_TAB\n+\t\t      AS1 (clr,%A0)     CR_TAB\n+\t\t      AS1 (swap,%B0)    CR_TAB\n+\t\t      AS2 (ldi,%3,0xf0) CR_TAB\n+\t\t      AS2 (and,%B0,%3));\n+\t    }\n+\t  *len = 6;\n \t  return (AS2 (mov,%B0,%A0) CR_TAB\n \t\t  AS1 (clr,%A0)     CR_TAB\n-\t\t  AS1 (swap,%B0)    CR_TAB\n-\t\t  AS2 (ldi,%3,0xf0) CR_TAB\n-\t\t  AS2 (and,%B0,%3));\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0));\n \n \tcase 13:\n-\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (ldi_ok)\n \t    {\n \t      *len = 5;\n \t      return (AS2 (mov,%B0,%A0) CR_TAB\n@@ -2955,7 +3089,7 @@ ashlhi3_out (insn, operands, len)\n \t\t      AS1 (lsl,%B0)     CR_TAB\n \t\t      AS2 (andi,%B0,0xe0));\n \t    }\n-\t  if (AVR_ENHANCED)\n+\t  if (AVR_ENHANCED && scratch)\n \t    {\n \t      *len = 5;\n \t      return (AS2 (ldi,%3,0x20) CR_TAB\n@@ -2964,10 +3098,48 @@ ashlhi3_out (insn, operands, len)\n \t\t      AS1 (clr,%A0)     CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  if (scratch)\n+\t    {\n+\t      *len = 6;\n+\t      return (AS2 (mov,%B0,%A0) CR_TAB\n+\t\t      AS1 (clr,%A0)     CR_TAB\n+\t\t      AS1 (swap,%B0)    CR_TAB\n+\t\t      AS1 (lsl,%B0)     CR_TAB\n+\t\t      AS2 (ldi,%3,0xe0) CR_TAB\n+\t\t      AS2 (and,%B0,%3));\n+\t    }\n+\t  if (AVR_ENHANCED)\n+\t    {\n+\t      *len = 6;\n+\t      return (\"set\"            CR_TAB\n+\t\t      AS2 (bld,r1,5)   CR_TAB\n+\t\t      AS2 (mul,%A0,r1) CR_TAB\n+\t\t      AS2 (mov,%B0,r0) CR_TAB\n+\t\t      AS1 (clr,%A0)    CR_TAB\n+\t\t      AS1 (clr,__zero_reg__));\n+\t    }\n+\t  *len = 7;\n+\t  return (AS2 (mov,%B0,%A0) CR_TAB\n+\t\t  AS1 (clr,%A0)     CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS1 (lsl,%B0));\n \n \tcase 14:\n-\t  if (AVR_ENHANCED)\n+\t  if (AVR_ENHANCED && ldi_ok)\n+\t    {\n+\t      *len = 5;\n+\t      return (AS2 (ldi,%B0,0x40) CR_TAB\n+\t\t      AS2 (mul,%A0,%B0)  CR_TAB\n+\t\t      AS2 (mov,%B0,r0)   CR_TAB\n+\t\t      AS1 (clr,%A0)      CR_TAB\n+\t\t      AS1 (clr,__zero_reg__));\n+\t    }\n+\t  if (AVR_ENHANCED && scratch)\n \t    {\n \t      *len = 5;\n \t      return (AS2 (ldi,%3,0x40) CR_TAB\n@@ -2976,7 +3148,24 @@ ashlhi3_out (insn, operands, len)\n \t\t      AS1 (clr,%A0)     CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size && ldi_ok)\n+\t    {\n+\t      *len = 5;\n+\t      return (AS2 (mov,%B0,%A0) CR_TAB\n+\t\t      AS2 (ldi,%A0,6) \"\\n1:\\t\"\n+\t\t      AS1 (lsl,%B0)     CR_TAB\n+\t\t      AS1 (dec,%A0)     CR_TAB\n+\t\t      AS1 (brne,1b));\n+\t    }\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  *len = 6;\n+\t  return (AS1 (clr,%B0) CR_TAB\n+\t\t  AS1 (lsr,%A0) CR_TAB\n+\t\t  AS1 (ror,%B0) CR_TAB\n+\t\t  AS1 (lsr,%A0) CR_TAB\n+\t\t  AS1 (ror,%B0) CR_TAB\n+\t\t  AS1 (clr,%A0));\n \n \tcase 15:\n \t  *len = 4;\n@@ -2987,11 +3176,9 @@ ashlhi3_out (insn, operands, len)\n \t}\n       len = t;\n     }\n-  if (len)\n-    *len = 4;\n-  out_shift_with_cnt (AS1 (lsl,%0)  CR_TAB\n-\t\t      AS1 (rol,%B0),\n-\t\t      insn, operands, len);\n+  out_shift_with_cnt ((AS1 (lsl,%A0) CR_TAB\n+\t\t       AS1 (rol,%B0)),\n+\t\t       insn, operands, len, 2);\n   return \"\";\n }\n \n@@ -3007,32 +3194,13 @@ ashlsi3_out (insn, operands, len)\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int k;\n-      int *t=len;\n+      int *t = len;\n       \n       if (!len)\n \tlen = &k;\n       \n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 1:\n-\t  *len = 4;\n-\t  return (AS1 (lsl,%A0) CR_TAB\n-\t\t  AS1 (rol,%B0) CR_TAB\n-\t\t  AS1 (rol,%C0) CR_TAB\n-\t\t  AS1 (rol,%D0));\n-\n-\tcase 2:\n-\t  /* Loop is one word smaller, but slower and needs a register.  */\n-\t  *len = 8;\n-\t  return (AS1 (lsl,%A0) CR_TAB\n-\t\t  AS1 (rol,%B0) CR_TAB\n-\t\t  AS1 (rol,%C0) CR_TAB\n-\t\t  AS1 (rol,%D0) CR_TAB\n-\t\t  AS1 (lsl,%A0) CR_TAB\n-\t\t  AS1 (rol,%B0) CR_TAB\n-\t\t  AS1 (rol,%C0) CR_TAB\n-\t\t  AS1 (rol,%D0));\n-\n \tcase 8:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n@@ -3111,13 +3279,11 @@ ashlsi3_out (insn, operands, len)\n \t}\n       len = t;\n     }\n-  if (len)\n-    *len = 6;\n-  out_shift_with_cnt (AS1 (lsl,%0)  CR_TAB\n-\t\t      AS1 (rol,%B0) CR_TAB\n-\t\t      AS1 (rol,%C0) CR_TAB\n-\t\t      AS1 (rol,%D0),\n-\t\t      insn, operands, len);\n+  out_shift_with_cnt ((AS1 (lsl,%A0) CR_TAB\n+\t\t       AS1 (rol,%B0) CR_TAB\n+\t\t       AS1 (rol,%C0) CR_TAB\n+\t\t       AS1 (rol,%D0)),\n+\t\t       insn, operands, len, 4);\n   return \"\";\n }\n \n@@ -3185,10 +3351,8 @@ ashrqi3_out (insn, operands, len)\n   else if (CONSTANT_P (operands[2]))\n     fatal_insn (\"Internal compiler bug.\\nIncorrect shift:\", insn);\n \n-  if (len)\n-    *len = 3;\n   out_shift_with_cnt (AS1 (asr,%0),\n-\t\t      insn, operands, len);\n+\t\t      insn, operands, len, 1);\n   return \"\";\n }\n \n@@ -3203,6 +3367,8 @@ ashrhi3_out (insn, operands, len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int ldi_ok = test_hard_reg_class (LD_REGS, operands[0]);\n       int k;\n       int *t = len;\n       \n@@ -3211,17 +3377,23 @@ ashrhi3_out (insn, operands, len)\n \n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 1:\n-\t  *len=2;\n-\t  return (AS1 (asr,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0));\n+\tcase 4:\n+\tcase 5:\n+\t  /* XXX try to optimize this too? */\n+\t  break;\n \n-\tcase 2:\n-\t  *len=4;\n-\t  return (AS1 (asr,%B0)  CR_TAB\n-\t\t  AS1 (ror,%A0) CR_TAB\n-\t\t  AS1 (asr,%B0)  CR_TAB\n-\t\t  AS1 (ror,%A0));\n+\tcase 6:\n+\t  if (optimize_size)\n+\t    break;  /* scratch ? 5 : 6 */\n+\t  *len = 8;\n+\t  return (AS2 (mov,__tmp_reg__,%A0) CR_TAB\n+\t\t  AS2 (mov,%A0,%B0)         CR_TAB\n+\t\t  AS1 (lsl,__tmp_reg__)     CR_TAB\n+\t\t  AS1 (rol,%A0)             CR_TAB\n+\t\t  AS2 (sbc,%B0,%B0)         CR_TAB\n+\t\t  AS1 (lsl,__tmp_reg__)     CR_TAB\n+\t\t  AS1 (rol,%A0)             CR_TAB\n+\t\t  AS1 (rol,%B0));\n \n \tcase 7:\n \t  *len = 4;\n@@ -3231,15 +3403,24 @@ ashrhi3_out (insn, operands, len)\n \t\t  AS2 (sbc,%B0,%B0));\n \n \tcase 8:\n-\t  if (true_regnum (operands[0]) != true_regnum (operands[1]) + 1)\n+\t  {\n+\t    int reg0 = true_regnum (operands[0]);\n+\t    int reg1 = true_regnum (operands[1]);\n+\n+\t    if (reg0 == reg1)\n+\t      return *len = 3, (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t\t\tAS1 (lsl,%B0)     CR_TAB\n+\t\t\t\tAS2 (sbc,%B0,%B0));\n+\t    else if (reg0 == reg1 + 1)\n+\t      return *len = 3, (AS1 (clr,%B0)    CR_TAB\n+\t\t\t\tAS2 (sbrc,%A0,7) CR_TAB\n+\t\t\t\tAS1 (dec,%B0));\n+\n \t    return *len = 4, (AS2 (mov,%A0,%B1) CR_TAB\n \t\t\t      AS1 (clr,%B0)     CR_TAB\n \t\t\t      AS2 (sbrc,%A0,7)  CR_TAB\n \t\t\t      AS1 (dec,%B0));\n-\t  else\n-\t    return *len = 3, (AS1 (clr,%B0)     CR_TAB\n-\t\t\t      AS2 (sbrc,%A0,7)  CR_TAB\n-\t\t\t      AS1 (dec,%B0));\n+\t  }\n \n \tcase 9:\n \t  *len = 4;\n@@ -3257,40 +3438,67 @@ ashrhi3_out (insn, operands, len)\n \t\t  AS1 (asr,%A0));\n \n \tcase 11:\n-\t  if (AVR_ENHANCED && test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (AVR_ENHANCED && ldi_ok)\n \t    {\n \t      *len = 5;\n-\t      return (AS2 (ldi,%3,0x20) CR_TAB\n-\t\t      AS2 (muls,%B0,%3) CR_TAB\n-\t\t      AS2 (mov,%A0,r1)  CR_TAB\n-\t\t      AS2 (sbc,%B0,%B0) CR_TAB\n+\t      return (AS2 (ldi,%A0,0x20) CR_TAB\n+\t\t      AS2 (muls,%B0,%A0) CR_TAB\n+\t\t      AS2 (mov,%A0,r1)   CR_TAB\n+\t\t      AS2 (sbc,%B0,%B0)  CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  *len = 6;\n+\t  return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS2 (sbc,%B0,%B0) CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0));\n \n \tcase 12:\n-\t  if (AVR_ENHANCED && test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (AVR_ENHANCED && ldi_ok)\n \t    {\n \t      *len = 5;\n-\t      return (AS2 (ldi,%3,0x10) CR_TAB\n-\t\t      AS2 (muls,%B0,%3) CR_TAB\n-\t\t      AS2 (mov,%A0,r1)  CR_TAB\n-\t\t      AS2 (sbc,%B0,%B0) CR_TAB\n+\t      return (AS2 (ldi,%A0,0x10) CR_TAB\n+\t\t      AS2 (muls,%B0,%A0) CR_TAB\n+\t\t      AS2 (mov,%A0,r1)   CR_TAB\n+\t\t      AS2 (sbc,%B0,%B0)  CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  *len = 7;\n+\t  return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS2 (sbc,%B0,%B0) CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0));\n \n \tcase 13:\n-\t  if (AVR_ENHANCED && test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (AVR_ENHANCED && ldi_ok)\n \t    {\n \t      *len = 5;\n-\t      return (AS2 (ldi,%3,0x08) CR_TAB\n-\t\t      AS2 (muls,%B0,%3) CR_TAB\n-\t\t      AS2 (mov,%A0,r1)  CR_TAB\n-\t\t      AS2 (sbc,%B0,%B0) CR_TAB\n+\t      return (AS2 (ldi,%A0,0x08) CR_TAB\n+\t\t      AS2 (muls,%B0,%A0) CR_TAB\n+\t\t      AS2 (mov,%A0,r1)   CR_TAB\n+\t\t      AS2 (sbc,%B0,%B0)  CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size)\n+\t    break;  /* scratch ? 5 : 7 */\n+\t  *len = 8;\n+\t  return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t  AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS2 (sbc,%B0,%B0) CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0)     CR_TAB\n+\t\t  AS1 (asr,%A0));\n \n \tcase 14:\n \t  *len = 5;\n@@ -3307,11 +3515,9 @@ ashrhi3_out (insn, operands, len)\n \t}\n       len = t;\n     }\n-  if (len)\n-    *len = 4;\n-  out_shift_with_cnt (AS1 (asr,%B0) CR_TAB\n-\t\t      AS1 (ror,%A0),\n-\t\t      insn, operands, len);\n+  out_shift_with_cnt ((AS1 (asr,%B0) CR_TAB\n+\t\t       AS1 (ror,%A0)),\n+\t\t       insn, operands, len, 2);\n   return \"\";\n }\n \n@@ -3334,25 +3540,6 @@ ashrsi3_out (insn, operands, len)\n       \n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 1:\n-\t  *len=4;\n-\t  return (AS1 (asr,%D0)  CR_TAB\n-\t\t  AS1 (ror,%C0)  CR_TAB\n-\t\t  AS1 (ror,%B0)  CR_TAB\n-\t\t  AS1 (ror,%A0));\n-\n-\tcase 2:\n-\t  /* Loop is one word smaller, but slower and needs a register.  */\n-\t  *len = 8;\n-\t  return (AS1 (asr,%D0) CR_TAB\n-\t\t  AS1 (ror,%C0) CR_TAB\n-\t\t  AS1 (ror,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0) CR_TAB\n-\t\t  AS1 (asr,%D0) CR_TAB\n-\t\t  AS1 (ror,%C0) CR_TAB\n-\t\t  AS1 (ror,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0));\n-\n \tcase 8:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n@@ -3446,13 +3633,11 @@ ashrsi3_out (insn, operands, len)\n \t}\n       len = t;\n     }\n-  if (len)\n-    *len = 6;\n-  out_shift_with_cnt (AS1 (asr,%D0) CR_TAB\n-\t\t      AS1 (ror,%C0) CR_TAB\n-\t\t      AS1 (ror,%B0) CR_TAB\n-\t\t      AS1 (ror,%A0),\n-\t\t      insn, operands, len);\n+  out_shift_with_cnt ((AS1 (asr,%D0) CR_TAB\n+\t\t       AS1 (ror,%C0) CR_TAB\n+\t\t       AS1 (ror,%B0) CR_TAB\n+\t\t       AS1 (ror,%A0)),\n+\t\t       insn, operands, len, 4);\n   return \"\";\n }\n \n@@ -3546,10 +3731,8 @@ lshrqi3_out (insn, operands, len)\n   else if (CONSTANT_P (operands[2]))\n     fatal_insn (\"Internal compiler bug.\\nIncorrect shift:\", insn);\n   \n-  if (len)\n-    *len = 3;\n   out_shift_with_cnt (AS1 (lsr,%0),\n-\t\t      insn, operands, len);\n+\t\t      insn, operands, len, 1);\n   return \"\";\n }\n \n@@ -3563,25 +3746,85 @@ lshrhi3_out (insn, operands, len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n+      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      int ldi_ok = test_hard_reg_class (LD_REGS, operands[0]);\n       int k;\n       int *t = len;\n-      \n+\n       if (!len)\n \tlen = &k;\n       \n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 1:\n-\t  *len = 2;\n-\t  return (AS1 (lsr,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0));\n-\t  \n-\tcase 2:\n-\t  *len = 4;\n-\t  return (AS1 (lsr,%B0)  CR_TAB\n-\t\t  AS1 (ror,%A0)  CR_TAB\n-\t\t  AS1 (lsr,%B0)  CR_TAB\n-\t\t  AS1 (ror,%A0));\n+\tcase 4:\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  if (ldi_ok)\n+\t    {\n+\t      *len = 6;\n+\t      return (AS1 (swap,%B0)      CR_TAB\n+\t\t      AS1 (swap,%A0)      CR_TAB\n+\t\t      AS2 (andi,%A0,0x0f) CR_TAB\n+\t\t      AS2 (eor,%A0,%B0)   CR_TAB\n+\t\t      AS2 (andi,%B0,0x0f) CR_TAB\n+\t\t      AS2 (eor,%A0,%B0));\n+\t    }\n+\t  if (scratch)\n+\t    {\n+\t      *len = 7;\n+\t      return (AS1 (swap,%B0)    CR_TAB\n+\t\t      AS1 (swap,%A0)    CR_TAB\n+\t\t      AS2 (ldi,%3,0x0f) CR_TAB\n+\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      AS2 (eor,%A0,%B0) CR_TAB\n+\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      AS2 (eor,%A0,%B0));\n+\t    }\n+\t  break;  /* optimize_size ? 6 : 8 */\n+\n+\tcase 5:\n+\t  if (optimize_size)\n+\t    break;  /* scratch ? 5 : 6 */\n+\t  if (ldi_ok)\n+\t    {\n+\t      *len = 8;\n+\t      return (AS1 (lsr,%B0)       CR_TAB\n+\t\t      AS1 (ror,%A0)       CR_TAB\n+\t\t      AS1 (swap,%B0)      CR_TAB\n+\t\t      AS1 (swap,%A0)      CR_TAB\n+\t\t      AS2 (andi,%A0,0x0f) CR_TAB\n+\t\t      AS2 (eor,%A0,%B0)   CR_TAB\n+\t\t      AS2 (andi,%B0,0x0f) CR_TAB\n+\t\t      AS2 (eor,%A0,%B0));\n+\t    }\n+\t  if (scratch)\n+\t    {\n+\t      *len = 9;\n+\t      return (AS1 (lsr,%B0)     CR_TAB\n+\t\t      AS1 (ror,%A0)     CR_TAB\n+\t\t      AS1 (swap,%B0)    CR_TAB\n+\t\t      AS1 (swap,%A0)    CR_TAB\n+\t\t      AS2 (ldi,%3,0x0f) CR_TAB\n+\t\t      AS2 (and,%A0,%3)  CR_TAB\n+\t\t      AS2 (eor,%A0,%B0) CR_TAB\n+\t\t      AS2 (and,%B0,%3)  CR_TAB\n+\t\t      AS2 (eor,%A0,%B0));\n+\t    }\n+\t  break;  /* 10 */\n+\n+\tcase 6:\n+\t  if (optimize_size)\n+\t    break;  /* scratch ? 5 : 6 */\n+\t  *len = 9;\n+\t  return (AS1 (clr,__tmp_reg__) CR_TAB\n+\t\t  AS1 (lsl,%A0)         CR_TAB\n+\t\t  AS1 (rol,%B0)         CR_TAB\n+\t\t  AS1 (rol,__tmp_reg__) CR_TAB\n+\t\t  AS1 (lsl,%A0)         CR_TAB\n+\t\t  AS1 (rol,%B0)         CR_TAB\n+\t\t  AS1 (rol,__tmp_reg__) CR_TAB\n+\t\t  AS2 (mov,%A0,%B0)     CR_TAB\n+\t\t  AS2 (mov,%B0,__tmp_reg__));\n \n \tcase 7:\n \t  *len = 5;\n@@ -3620,24 +3863,33 @@ lshrhi3_out (insn, operands, len)\n \t\t  AS1 (lsr,%A0));\n \n \tcase 12:\n-\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (ldi_ok)\n \t    {\n \t      *len = 4;\n \t      return (AS2 (mov,%A0,%B0) CR_TAB\n \t\t      AS1 (clr,%B0)     CR_TAB\n \t\t      AS1 (swap,%A0)    CR_TAB\n \t\t      AS2 (andi,%A0,0x0f));\n \t    }\n-\t  /* %3 is a scratch register from class LD_REGS */\n-\t  *len = 5;\n+\t  if (scratch)\n+\t    {\n+\t      *len = 5;\n+\t      return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t      AS1 (clr,%B0)     CR_TAB\n+\t\t      AS1 (swap,%A0)    CR_TAB\n+\t\t      AS2 (ldi,%3,0x0f) CR_TAB\n+\t\t      AS2 (and,%A0,%3));\n+\t    }\n+\t  *len = 6;\n \t  return (AS2 (mov,%A0,%B0) CR_TAB\n \t\t  AS1 (clr,%B0)     CR_TAB\n-\t\t  AS1 (swap,%A0)    CR_TAB\n-\t\t  AS2 (ldi,%3,0x0f) CR_TAB\n-\t\t  AS2 (and,%A0,%3));\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0));\n \n \tcase 13:\n-\t  if (test_hard_reg_class (LD_REGS, operands[0]))\n+\t  if (ldi_ok)\n \t    {\n \t      *len = 5;\n \t      return (AS2 (mov,%A0,%B0) CR_TAB\n@@ -3646,7 +3898,7 @@ lshrhi3_out (insn, operands, len)\n \t\t      AS1 (lsr,%A0)     CR_TAB\n \t\t      AS2 (andi,%A0,0x07));\n \t    }\n-\t  if (AVR_ENHANCED)\n+\t  if (AVR_ENHANCED && scratch)\n \t    {\n \t      *len = 5;\n \t      return (AS2 (ldi,%3,0x08) CR_TAB\n@@ -3655,10 +3907,48 @@ lshrhi3_out (insn, operands, len)\n \t\t      AS1 (clr,%B0)     CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  if (scratch)\n+\t    {\n+\t      *len = 6;\n+\t      return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t      AS1 (clr,%B0)     CR_TAB\n+\t\t      AS1 (swap,%A0)    CR_TAB\n+\t\t      AS1 (lsr,%A0)     CR_TAB\n+\t\t      AS2 (ldi,%3,0x07) CR_TAB\n+\t\t      AS2 (and,%A0,%3));\n+\t    }\n+\t  if (AVR_ENHANCED)\n+\t    {\n+\t      *len = 6;\n+\t      return (\"set\"            CR_TAB\n+\t\t      AS2 (bld,r1,3)   CR_TAB\n+\t\t      AS2 (mul,%B0,r1) CR_TAB\n+\t\t      AS2 (mov,%A0,r1) CR_TAB\n+\t\t      AS1 (clr,%B0)    CR_TAB\n+\t\t      AS1 (clr,__zero_reg__));\n+\t    }\n+\t  *len = 7;\n+\t  return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t  AS1 (clr,%B0)     CR_TAB\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0)     CR_TAB\n+\t\t  AS1 (lsr,%A0));\n \n \tcase 14:\n-\t  if (AVR_ENHANCED)\n+\t  if (AVR_ENHANCED && ldi_ok)\n+\t    {\n+\t      *len = 5;\n+\t      return (AS2 (ldi,%A0,0x04) CR_TAB\n+\t\t      AS2 (mul,%B0,%A0)  CR_TAB\n+\t\t      AS2 (mov,%A0,r1)   CR_TAB\n+\t\t      AS1 (clr,%B0)      CR_TAB\n+\t\t      AS1 (clr,__zero_reg__));\n+\t    }\n+\t  if (AVR_ENHANCED && scratch)\n \t    {\n \t      *len = 5;\n \t      return (AS2 (ldi,%3,0x04) CR_TAB\n@@ -3667,22 +3957,37 @@ lshrhi3_out (insn, operands, len)\n \t\t      AS1 (clr,%B0)     CR_TAB\n \t\t      AS1 (clr,__zero_reg__));\n \t    }\n-\t  break;\n+\t  if (optimize_size && ldi_ok)\n+\t    {\n+\t      *len = 5;\n+\t      return (AS2 (mov,%A0,%B0) CR_TAB\n+\t\t      AS2 (ldi,%B0,6) \"\\n1:\\t\"\n+\t\t      AS1 (lsr,%A0)     CR_TAB\n+\t\t      AS1 (dec,%B0)     CR_TAB\n+\t\t      AS1 (brne,1b));\n+\t    }\n+\t  if (optimize_size && scratch)\n+\t    break;  /* 5 */\n+\t  *len = 6;\n+\t  return (AS1 (clr,%A0) CR_TAB\n+\t\t  AS1 (lsl,%B0) CR_TAB\n+\t\t  AS1 (rol,%A0) CR_TAB\n+\t\t  AS1 (lsl,%B0) CR_TAB\n+\t\t  AS1 (rol,%A0) CR_TAB\n+\t\t  AS1 (clr,%B0));\n \n \tcase 15:\n \t  *len = 4;\n-\t  return (AS1 (lsl,%B0)     CR_TAB\n-\t\t  AS2 (sbc,%A0,%A0) CR_TAB\n-\t\t  AS1 (neg,%A0)     CR_TAB\n+\t  return (AS1 (clr,%A0) CR_TAB\n+\t\t  AS1 (lsl,%B0) CR_TAB\n+\t\t  AS1 (rol,%A0) CR_TAB\n \t\t  AS1 (clr,%B0));\n \t}\n       len = t;\n     }\n-  if (len)\n-    *len = 4;\n-  out_shift_with_cnt (AS1 (lsr,%B0) CR_TAB\n-\t\t      AS1 (ror,%A0),\n-\t\t      insn, operands, len);\n+  out_shift_with_cnt ((AS1 (lsr,%B0) CR_TAB\n+\t\t       AS1 (ror,%A0)),\n+\t\t       insn, operands, len, 2);\n   return \"\";\n }\n \n@@ -3704,25 +4009,6 @@ lshrsi3_out (insn, operands, len)\n       \n       switch (INTVAL (operands[2]))\n \t{\n-\tcase 1:\n-\t  *len = 4;\n-\t  return (AS1 (lsr,%D0) CR_TAB\n-\t\t  AS1 (ror,%C0) CR_TAB\n-\t\t  AS1 (ror,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0));\n-\n-\tcase 2:\n-\t  /* Loop is one word smaller, but slower and needs a register.  */\n-\t  *len = 8;\n-\t  return (AS1 (lsr,%D0) CR_TAB\n-\t\t  AS1 (ror,%C0) CR_TAB\n-\t\t  AS1 (ror,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0) CR_TAB\n-\t\t  AS1 (lsr,%D0) CR_TAB\n-\t\t  AS1 (ror,%C0) CR_TAB\n-\t\t  AS1 (ror,%B0) CR_TAB\n-\t\t  AS1 (ror,%A0));\n-\n \tcase 8:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n@@ -3791,13 +4077,11 @@ lshrsi3_out (insn, operands, len)\n \t}\n       len = t;\n     }\n-  if (len)\n-    *len = 6;\n-  out_shift_with_cnt (AS1 (lsr,%D0) CR_TAB\n-\t\t      AS1 (ror,%C0) CR_TAB\n-\t\t      AS1 (ror,%B0) CR_TAB\n-\t\t      AS1 (ror,%A0),\n-\t\t      insn, operands, len);\n+  out_shift_with_cnt ((AS1 (lsr,%D0) CR_TAB\n+\t\t       AS1 (ror,%C0) CR_TAB\n+\t\t       AS1 (ror,%B0) CR_TAB\n+\t\t       AS1 (ror,%A0)),\n+\t\t      insn, operands, len, 4);\n   return \"\";\n }\n \n@@ -4994,3 +5278,16 @@ output_reload_insisf (insn, operands, len)\n     }\n   return \"\";\n }\n+\n+void\n+avr_output_bld (operands, bit_nr)\n+     rtx operands[];\n+     int bit_nr;\n+{\n+  static char s[] = \"bld %A0,0\";\n+\n+  s[5] = 'A' + (bit_nr >> 3);\n+  s[8] = '0' + (bit_nr & 7);\n+  output_asm_insn (s, operands);\n+}\n+"}, {"sha": "2a130448b475ce3c85a9b9acb43fd1e7b4d7113c", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=afee2a52da20b6062fcc367e9178395ee314e41f", "patch": "@@ -55,7 +55,6 @@ extern int target_flags;\n #define MASK_NO_INTERRUPTS\t0x00020000\n #define MASK_CALL_PROLOGUES\t0x00040000\n #define MASK_TINY_STACK\t\t0x00080000\n-#define MASK_PACK_ARGS\t\t0x00100000\n \n #define TARGET_ORDER_1\t\t(target_flags & MASK_ORDER_1)\n #define TARGET_ORDER_2\t\t(target_flags & MASK_ORDER_2)\n@@ -64,7 +63,6 @@ extern int target_flags;\n #define TARGET_INSN_SIZE_DUMP\t(target_flags & MASK_INSN_SIZE_DUMP)\n #define TARGET_CALL_PROLOGUES\t(target_flags & MASK_CALL_PROLOGUES)\n #define TARGET_TINY_STACK\t(target_flags & MASK_TINY_STACK)\n-#define TARGET_PACK_ARGS\t(target_flags & MASK_PACK_ARGS)\n \n /* Dump each assembler insn's rtl into the output file.\n    This is for debugging the compiler itself.  */\n@@ -104,8 +102,6 @@ extern int target_flags;\n     N_(\"Use subroutines for function prologue/epilogue\") },\t\t\\\n   { \"tiny-stack\", MASK_TINY_STACK,\t\t\t\t\t\\\n     N_(\"Change only the low 8 bits of the stack pointer\") },\t\t\\\n-  { \"pack-args\", MASK_PACK_ARGS,\t\t\t\t\t\\\n-    N_(\"Do not align function arguments on even numbered registers\") },\t\\\n   { \"rtl\", MASK_RTL_DUMP, NULL },\t\t\t\t\t\\\n   { \"size\", MASK_INSN_SIZE_DUMP,\t\t\t\t\t\\\n     N_(\"Output instruction sizes to the asm file\") },\t\t\t\\"}, {"sha": "c774f735d007c3c8ce99985e894ad5598586abe9", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 157, "deletions": 37, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afee2a52da20b6062fcc367e9178395ee314e41f/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=afee2a52da20b6062fcc367e9178395ee314e41f", "patch": "@@ -182,7 +182,7 @@\n   [(set (match_operand:QI 0 \"register_operand\" \"=l\")\n \t(match_operand:QI 1 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n-  \"\"\n+  \"reload_completed\"\n   \"ldi %2,lo8(%1)\n \tmov %0,%2\"\n   [(set_attr \"length\" \"2\")\n@@ -231,7 +231,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n         (match_operand:HI 1 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n-  \"\"\n+  \"reload_completed\"\n   \"* return output_reload_inhi (insn, operands, NULL);\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"cc\" \"none\")])\n@@ -279,7 +279,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (match_operand:SI 1 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n-  \"\"\n+  \"reload_completed\"\n   \"* return output_reload_insisf (insn, operands, NULL);\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"cc\" \"none\")])\n@@ -889,34 +889,74 @@\n ;; arithmetic shift left\n \n (define_insn \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,!d,r,r\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"r,n,n,Qm\")))]\n+  [(set (match_operand:QI 0 \"register_operand\"           \"=r,r,r,!d,r,r\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,K,n,n,Qm\")))]\n   \"\"\n   \"* return ashlqi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"5,4,6,7\")\n-   (set_attr \"cc\" \"clobber,set_czn,set_czn,clobber\")])\n+  [(set_attr \"length\" \"5,1,2,4,6,9\")\n+   (set_attr \"cc\" \"clobber,set_czn,set_czn,set_czn,set_czn,clobber\")])\n \n (define_insn \"ashlhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"           \"=r,r,r,r,r,r\")\n \t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0,r,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,n,Qm\")))]\n   \"\"\n   \"* return ashlhi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"7,2,2,4,5,8\")\n+  [(set_attr \"length\" \"6,2,2,4,10,10\")\n    (set_attr \"cc\" \"clobber,set_n,clobber,set_n,clobber,clobber\")])\n \n (define_insn \"ashlsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"           \"=r,r,r,r,r,r\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0,r,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+\t\t   (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,n,Qm\")))]\n   \"\"\n   \"* return ashlsi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"9,4,4,8,7,10\")\n+  [(set_attr \"length\" \"8,4,4,8,10,12\")\n    (set_attr \"cc\" \"clobber,set_n,clobber,set_n,clobber,clobber\")])\n \n+;; Optimize if a scratch register from LD_REGS happens to be available.\n+\n+(define_peephole2\n+  [(match_scratch:QI 3 \"d\")\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (ashift:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 3))])]\n+  \"\")\n+\n+(define_insn \"*ashlhi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\"            \"=r,r,r,r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\"  \"0,r,0,0\")\n+\t\t   (match_operand:QI 2 \"const_int_operand\" \"P,O,K,n\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d\"))]\n+  \"reload_completed\"\n+  \"* return ashlhi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"2,2,4,10\")\n+   (set_attr \"cc\" \"set_n,clobber,set_n,clobber\")])\n+\n+(define_peephole2\n+  [(match_scratch:QI 3 \"d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t   (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (ashift:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 3))])]\n+  \"\")\n+\n+(define_insn \"*ashlsi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\"            \"=r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"0,r,0\")\n+\t\t   (match_operand:QI 2 \"const_int_operand\" \"P,O,n\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,&d\"))]\n+  \"reload_completed\"\n+  \"* return ashlsi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"4,4,10\")\n+   (set_attr \"cc\" \"set_n,clobber,clobber\")])\n+\n ;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>\n ;; arithmetic shift right\n \n@@ -926,61 +966,141 @@\n \t\t     (match_operand:QI 2 \"general_operand\" \"r,P,K,n,Qm\")))]\n   \"\"\n   \"* return ashrqi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"5,1,2,5,7\")\n-   (set_attr \"cc\" \"clobber,set_zn,set_zn,clobber,clobber\")])\n+  [(set_attr \"length\" \"5,1,2,5,9\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber\")])\n \n (define_insn \"ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,K,O,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,r,0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,n,Qm\")))]\n   \"\"\n   \"* return ashrhi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"7,2,4,4,5,8\")\n-   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n+  [(set_attr \"length\" \"6,2,4,4,10,10\")\n+   (set_attr \"cc\" \"clobber,clobber,set_n,clobber,clobber,clobber\")])\n \n (define_insn \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,r,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,n,Qm\")))]\n   \"\"\n   \"* return ashrsi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"9,4,6,8,7,10\")\n-   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n+  [(set_attr \"length\" \"8,4,6,8,10,12\")\n+   (set_attr \"cc\" \"clobber,clobber,set_n,clobber,clobber,clobber\")])\n+\n+;; Optimize if a scratch register from LD_REGS happens to be available.\n+\n+(define_peephole2\n+  [(match_scratch:QI 3 \"d\")\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (ashiftrt:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 3))])]\n+  \"\")\n+\n+(define_insn \"*ashrhi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\"              \"=r,r,r,r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0,r,0,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"P,O,K,n\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d\"))]\n+  \"reload_completed\"\n+  \"* return ashrhi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"2,4,4,10\")\n+   (set_attr \"cc\" \"clobber,set_n,clobber,clobber\")])\n+\n+(define_peephole2\n+  [(match_scratch:QI 3 \"d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (ashiftrt:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 3))])]\n+  \"\")\n+\n+(define_insn \"*ashrsi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,r,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"P,O,n\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,&d\"))]\n+  \"reload_completed\"\n+  \"* return ashrsi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"4,4,10\")\n+   (set_attr \"cc\" \"clobber,set_n,clobber\")])\n \n ;; >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>\n ;; logical shift right\n \n (define_insn \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,d,r,r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"r,n,n,Qm\")))]\n+  [(set (match_operand:QI 0 \"register_operand\"             \"=r,r,r,!d,r,r\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,K,n,n,Qm\")))]\n   \"\"\n   \"* return lshrqi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"6,4,6,7\")\n-   (set_attr \"cc\" \"clobber,set_czn,set_czn,clobber\")])\n+  [(set_attr \"length\" \"5,1,2,4,6,9\")\n+   (set_attr \"cc\" \"clobber,set_czn,set_czn,set_czn,set_czn,clobber\")])\n \n (define_insn \"lshrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,K,O,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,r,0,0,0\")\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,n,Qm\")))]\n   \"\"\n   \"* return lshrhi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"7,2,4,2,5,8\")\n+  [(set_attr \"length\" \"6,2,2,4,10,10\")\n    (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n \n (define_insn \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,r,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d,X\"))]\n+\t\t     (match_operand:QI 2 \"general_operand\"  \"r,P,O,K,n,Qm\")))]\n   \"\"\n   \"* return lshrsi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"9,4,4,8,7,10\")\n+  [(set_attr \"length\" \"8,4,4,8,10,12\")\n    (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber,clobber\")])\n \n+;; Optimize if a scratch register from LD_REGS happens to be available.\n+\n+(define_peephole2\n+  [(match_scratch:QI 3 \"d\")\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (lshiftrt:HI (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 3))])]\n+  \"\")\n+\n+(define_insn \"*lshrhi3_const\"\n+  [(set (match_operand:HI 0 \"register_operand\"              \"=r,r,r,r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0,r,0,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"P,O,K,n\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,X,&d\"))]\n+  \"reload_completed\"\n+  \"* return lshrhi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"2,2,4,10\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber,clobber\")])\n+\n+(define_peephole2\n+  [(match_scratch:QI 3 \"d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  [(parallel [(set (match_dup 0) (lshiftrt:SI (match_dup 1) (match_dup 2)))\n+\t      (clobber (match_dup 3))])]\n+  \"\")\n+\n+(define_insn \"*lshrsi3_const\"\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,r,0\")\n+\t\t     (match_operand:QI 2 \"const_int_operand\" \"P,O,n\")))\n+   (clobber (match_scratch:QI 3 \"=X,X,&d\"))]\n+  \"reload_completed\"\n+  \"* return lshrsi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"4,4,10\")\n+   (set_attr \"cc\" \"clobber,clobber,clobber\")])\n+\n ;; abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x) abs(x)\n ;; abs\n "}]}