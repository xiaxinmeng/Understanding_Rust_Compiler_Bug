{"sha": "5edc67b773372bf013f98a357912381d99de65f5", "node_id": "C_kwDOANBUbNoAKDVlZGM2N2I3NzMzNzJiZjAxM2Y5OGEzNTc5MTIzODFkOTlkZTY1ZjU", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-08-30T14:43:45Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-08-30T14:43:45Z"}, "message": "Split code out of vectorizable_slp_permutation\n\nA later patch needs to test whether the target supports a\nlane_permutation_t without having to construct a full SLP\nnode to test that.  This patch splits out most of the work\nof vectorizable_slp_permutation into a subroutine, so that\nproperties of the permutation can be passed explicitly without\ndisturbing the main interface.\n\nThe new subroutine still uses an slp_tree argument to get things\nlike the number of lanes and the vector type.  That's a bit clunky,\nbut it seemed like the least worst option.\n\ngcc/\n\t* tree-vect-slp.cc (vectorizable_slp_permutation_1): Split out from...\n\t(vectorizable_slp_permutation): ...here.", "tree": {"sha": "69d70df8d626c9a71924b475cd678346a7df31e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69d70df8d626c9a71924b475cd678346a7df31e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5edc67b773372bf013f98a357912381d99de65f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5edc67b773372bf013f98a357912381d99de65f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5edc67b773372bf013f98a357912381d99de65f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5edc67b773372bf013f98a357912381d99de65f5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25c2a50cc343eb7c2500b69a6556551d5221393f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25c2a50cc343eb7c2500b69a6556551d5221393f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25c2a50cc343eb7c2500b69a6556551d5221393f"}], "stats": {"total": 98, "additions": 66, "deletions": 32}, "files": [{"sha": "13c242e50128f701d55fb5664a07cca5089b07dd", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5edc67b773372bf013f98a357912381d99de65f5/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5edc67b773372bf013f98a357912381d99de65f5/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=5edc67b773372bf013f98a357912381d99de65f5", "patch": "@@ -6976,20 +6976,22 @@ vect_add_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   SLP_TREE_VEC_STMTS (node).quick_push (perm_stmt);\n }\n \n-/* Vectorize the SLP permutations in NODE as specified\n-   in SLP_TREE_LANE_PERMUTATION which is a vector of pairs of SLP\n-   child number and lane number.\n-   Interleaving of two two-lane two-child SLP subtrees (not supported):\n-     [ { 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 } ]\n-   A blend of two four-lane two-child SLP subtrees:\n-     [ { 0, 0 }, { 1, 1 }, { 0, 2 }, { 1, 3 } ]\n-   Highpart of a four-lane one-child SLP subtree (not supported):\n-     [ { 0, 2 }, { 0, 3 } ]\n-   Where currently only a subset is supported by code generating below.  */\n+/* Subroutine of vectorizable_slp_permutation.  Check whether the target\n+   can perform permutation PERM on the (1 or 2) input nodes in CHILDREN.\n+   If GSI is nonnull, emit the permutation there.\n \n-static bool\n-vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n-\t\t\t      slp_tree node, stmt_vector_for_cost *cost_vec)\n+   When GSI is null, the only purpose of NODE is to give properties\n+   of the result, such as the vector type and number of SLP lanes.\n+   The node does not need to be a VEC_PERM_EXPR.\n+\n+   If the target supports the operation, return the number of individual\n+   VEC_PERM_EXPRs needed, otherwise return -1.  Print information to the\n+   dump file if DUMP_P is true.  */\n+\n+static int\n+vectorizable_slp_permutation_1 (vec_info *vinfo, gimple_stmt_iterator *gsi,\n+\t\t\t\tslp_tree node, lane_permutation_t &perm,\n+\t\t\t\tvec<slp_tree> &children, bool dump_p)\n {\n   tree vectype = SLP_TREE_VECTYPE (node);\n \n@@ -7001,33 +7003,32 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   bool repeating_p = multiple_p (nunits, SLP_TREE_LANES (node));\n   tree op_vectype = NULL_TREE;\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+  FOR_EACH_VEC_ELT (children, i, child)\n     if (SLP_TREE_VECTYPE (child))\n       {\n \top_vectype = SLP_TREE_VECTYPE (child);\n \tbreak;\n       }\n   if (!op_vectype)\n     op_vectype = vectype;\n-  FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n+  FOR_EACH_VEC_ELT (children, i, child)\n     {\n       if ((SLP_TREE_DEF_TYPE (child) != vect_internal_def\n \t   && !vect_maybe_update_slp_op_vectype (child, op_vectype))\n \t  || !types_compatible_p (SLP_TREE_VECTYPE (child), op_vectype)\n \t  || !types_compatible_p (TREE_TYPE (vectype), TREE_TYPE (op_vectype)))\n \t{\n-\t  if (dump_enabled_p ())\n+\t  if (dump_p)\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"Unsupported vector types in lane permutation\\n\");\n-\t  return false;\n+\t  return -1;\n \t}\n       if (SLP_TREE_LANES (child) != SLP_TREE_LANES (node))\n \trepeating_p = false;\n     }\n \n-  vec<std::pair<unsigned, unsigned> > &perm = SLP_TREE_LANE_PERMUTATION (node);\n   gcc_assert (perm.length () == SLP_TREE_LANES (node));\n-  if (dump_enabled_p ())\n+  if (dump_p)\n     {\n       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t       \"vectorizing permutation\");\n@@ -7076,11 +7077,11 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n       /* Calculate every element of every permute mask vector explicitly,\n \t instead of relying on the pattern described above.  */\n       if (!nunits.is_constant (&npatterns))\n-\treturn false;\n+\treturn -1;\n       nelts_per_pattern = ncopies = 1;\n       if (loop_vec_info linfo = dyn_cast <loop_vec_info> (vinfo))\n \tif (!LOOP_VINFO_VECT_FACTOR (linfo).is_constant (&ncopies))\n-\t  return false;\n+\t  return -1;\n       noutputs_per_mask = 1;\n     }\n   unsigned olanes = ncopies * SLP_TREE_LANES (node);\n@@ -7093,13 +7094,13 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n   auto_vec<std::pair<std::pair<unsigned, unsigned>, unsigned> > vperm;\n   auto_vec<unsigned> active_lane;\n   vperm.create (olanes);\n-  active_lane.safe_grow_cleared (SLP_TREE_CHILDREN (node).length (), true);\n+  active_lane.safe_grow_cleared (children.length (), true);\n   for (unsigned i = 0; i < ncopies; ++i)\n     {\n       for (unsigned pi = 0; pi < perm.length (); ++pi)\n \t{\n \t  std::pair<unsigned, unsigned> p = perm[pi];\n-\t  tree vtype = SLP_TREE_VECTYPE (SLP_TREE_CHILDREN (node)[p.first]);\n+\t  tree vtype = SLP_TREE_VECTYPE (children[p.first]);\n \t  if (repeating_p)\n \t    vperm.quick_push ({{p.first, 0}, p.second + active_lane[p.first]});\n \t  else\n@@ -7112,12 +7113,19 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t    }\n \t}\n       /* Advance to the next group.  */\n-      for (unsigned j = 0; j < SLP_TREE_CHILDREN (node).length (); ++j)\n-\tactive_lane[j] += SLP_TREE_LANES (SLP_TREE_CHILDREN (node)[j]);\n+      for (unsigned j = 0; j < children.length (); ++j)\n+\tactive_lane[j] += SLP_TREE_LANES (children[j]);\n     }\n \n-  if (dump_enabled_p ())\n+  if (dump_p)\n     {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"vectorizing permutation\");\n+      for (unsigned i = 0; i < perm.length (); ++i)\n+\tdump_printf (MSG_NOTE, \" op%u[%u]\", perm[i].first, perm[i].second);\n+      if (repeating_p)\n+\tdump_printf (MSG_NOTE, \" (repeat %d)\\n\", SLP_TREE_LANES (node));\n+      dump_printf (MSG_NOTE, \"\\n\");\n       dump_printf_loc (MSG_NOTE, vect_location, \"as\");\n       for (unsigned i = 0; i < vperm.length (); ++i)\n \t{\n@@ -7163,12 +7171,12 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t}\n       else\n \t{\n-\t  if (dump_enabled_p ())\n+\t  if (dump_p)\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"permutation requires at \"\n \t\t\t     \"least three vectors\\n\");\n \t  gcc_assert (!gsi);\n-\t  return false;\n+\t  return -1;\n \t}\n \n       mask[index++] = mask_element;\n@@ -7190,7 +7198,7 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t\t\t\t\t    TYPE_VECTOR_SUBPARTS (op_vectype),\n \t\t\t\t\t    &c) || c != 2)))\n \t    {\n-\t      if (dump_enabled_p ())\n+\t      if (dump_p)\n \t\t{\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,\n \t\t\t\t   vect_location,\n@@ -7203,7 +7211,7 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"}\\n\");\n \t\t}\n \t      gcc_assert (!gsi);\n-\t      return false;\n+\t      return -1;\n \t    }\n \n \t  if (!identity_p)\n@@ -7214,8 +7222,8 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t\tsecond_vec = first_vec;\n \n \t      slp_tree\n-\t\tfirst_node = SLP_TREE_CHILDREN (node)[first_vec.first],\n-\t\tsecond_node = SLP_TREE_CHILDREN (node)[second_vec.first];\n+\t\tfirst_node = children[first_vec.first],\n+\t\tsecond_node = children[second_vec.first];\n \n \t      tree mask_vec = NULL_TREE;\n \t      if (!identity_p)\n@@ -7240,6 +7248,32 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n+  return nperms;\n+}\n+\n+/* Vectorize the SLP permutations in NODE as specified\n+   in SLP_TREE_LANE_PERMUTATION which is a vector of pairs of SLP\n+   child number and lane number.\n+   Interleaving of two two-lane two-child SLP subtrees (not supported):\n+     [ { 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 } ]\n+   A blend of two four-lane two-child SLP subtrees:\n+     [ { 0, 0 }, { 1, 1 }, { 0, 2 }, { 1, 3 } ]\n+   Highpart of a four-lane one-child SLP subtree (not supported):\n+     [ { 0, 2 }, { 0, 3 } ]\n+   Where currently only a subset is supported by code generating below.  */\n+\n+static bool\n+vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n+\t\t\t      slp_tree node, stmt_vector_for_cost *cost_vec)\n+{\n+  tree vectype = SLP_TREE_VECTYPE (node);\n+  lane_permutation_t &perm = SLP_TREE_LANE_PERMUTATION (node);\n+  int nperms = vectorizable_slp_permutation_1 (vinfo, gsi, node, perm,\n+\t\t\t\t\t       SLP_TREE_CHILDREN (node),\n+\t\t\t\t\t       dump_enabled_p ());\n+  if (nperms < 0)\n+    return false;\n+\n   if (!gsi)\n     record_stmt_cost (cost_vec, nperms, vec_perm, node, vectype, 0, vect_body);\n "}]}