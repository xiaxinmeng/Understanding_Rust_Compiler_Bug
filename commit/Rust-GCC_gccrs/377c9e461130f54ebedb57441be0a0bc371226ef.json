{"sha": "377c9e461130f54ebedb57441be0a0bc371226ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc3YzllNDYxMTMwZjU0ZWJlZGI1NzQ0MWJlMGEwYmMzNzEyMjZlZg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-04-12T22:37:12Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-04-12T22:37:12Z"}, "message": "Commit a change missed in r270326:\n\ngcc/c-family/ChangeLog:\n\n\tPR c/88383\n\tPR c/89288\n\tPR c/89798\n\tPR c/89797\n\t* c-attribs.c (type_valid_for_vector_size): Detect excessively\n\tlarge sizes.\n\t(validate_attribute): Handle DECLs and expressions.\n\t(has_attribute): Handle types referenced by expressions.\n\tAvoid considering array attributes in ARRAY_REF expressions .\n\nFrom-SVN: r270331", "tree": {"sha": "0298d543394f85b968d025629efef1c28bf7cd83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0298d543394f85b968d025629efef1c28bf7cd83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/377c9e461130f54ebedb57441be0a0bc371226ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/377c9e461130f54ebedb57441be0a0bc371226ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/377c9e461130f54ebedb57441be0a0bc371226ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/377c9e461130f54ebedb57441be0a0bc371226ef/comments", "author": null, "committer": null, "parents": [{"sha": "d7e418a1d8664c7b1516e16fae65efe4802cd050", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e418a1d8664c7b1516e16fae65efe4802cd050", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e418a1d8664c7b1516e16fae65efe4802cd050"}], "stats": {"total": 83, "additions": 63, "deletions": 20}, "files": [{"sha": "93b210eed9ca004a7f9b7fc3e24134bd5c04957a", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 63, "deletions": 20, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/377c9e461130f54ebedb57441be0a0bc371226ef/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/377c9e461130f54ebedb57441be0a0bc371226ef/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=377c9e461130f54ebedb57441be0a0bc371226ef", "patch": "@@ -3494,19 +3494,56 @@ type_valid_for_vector_size (tree type, tree atname, tree args,\n     return type;\n \n   tree size = TREE_VALUE (args);\n+  /* Erroneous arguments have already been diagnosed.  */\n+  if (size == error_mark_node)\n+    return NULL_TREE;\n+\n   if (size && TREE_CODE (size) != IDENTIFIER_NODE\n       && TREE_CODE (size) != FUNCTION_DECL)\n     size = default_conversion (size);\n \n-  if (!tree_fits_uhwi_p (size))\n+  if (TREE_CODE (size) != INTEGER_CST)\n+    {\n+      if (error_p)\n+\terror (\"%qE attribute argument value %qE is not an integer constant\",\n+\t       atname, size);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE is not an integer constant\",\n+\t\t atname, size);\n+      return NULL_TREE;\n+    }\n+\n+  if (!TYPE_UNSIGNED (TREE_TYPE (size))\n+      && tree_int_cst_sgn (size) < 0)\n     {\n-      /* FIXME: make the error message more informative.  */\n       if (error_p)\n-\twarning (OPT_Wattributes, \"%qE attribute ignored\", atname);\n+\terror (\"%qE attribute argument value %qE is negative\",\n+\t       atname, size);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE is negative\",\n+\t\t atname, size);\n+      return NULL_TREE;\n+    }\n+\n+  /* The attribute argument value is constrained by the maximum bit\n+     alignment representable in unsigned int on the host.  */\n+  unsigned HOST_WIDE_INT vecsize;\n+  unsigned HOST_WIDE_INT maxsize = tree_to_uhwi (max_object_size ());\n+  if (!tree_fits_uhwi_p (size)\n+      || (vecsize = tree_to_uhwi (size)) > maxsize)\n+    {\n+      if (error_p)\n+\terror (\"%qE attribute argument value %qE exceeds %wu\",\n+\t       atname, size, maxsize);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE exceeds %wu\",\n+\t\t atname, size, maxsize);\n       return NULL_TREE;\n     }\n \n-  unsigned HOST_WIDE_INT vecsize = tree_to_uhwi (size);\n   if (vecsize % tree_to_uhwi (TYPE_SIZE_UNIT (type)))\n     {\n       if (error_p)\n@@ -4068,8 +4105,12 @@ validate_attribute (location_t atloc, tree oper, tree attr)\n \n   if (TYPE_P (oper))\n     tmpdecl = build_decl (atloc, TYPE_DECL, tmpid, oper);\n-  else\n+  else if (DECL_P (oper))\n     tmpdecl = build_decl (atloc, TREE_CODE (oper), tmpid, TREE_TYPE (oper));\n+  else if (EXPR_P (oper))\n+    tmpdecl = build_decl (atloc, TYPE_DECL, tmpid, TREE_TYPE (oper));\n+  else\n+    return false;\n \n   /* Temporarily clear CURRENT_FUNCTION_DECL to make decl_attributes\n      believe the DECL declared above is at file scope.  (See bug 87526.)  */\n@@ -4078,7 +4119,7 @@ validate_attribute (location_t atloc, tree oper, tree attr)\n   if (DECL_P (tmpdecl))\n     {\n       if (DECL_P (oper))\n-\t/* An alias cannot be a defintion so declare the symbol extern.  */\n+\t/* An alias cannot be a definition so declare the symbol extern.  */\n \tDECL_EXTERNAL (tmpdecl) = true;\n       /* Attribute visibility only applies to symbols visible from other\n \t translation units so make it \"public.\"   */\n@@ -4114,11 +4155,17 @@ has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n       do\n \t{\n \t  /* Determine the array element/member declaration from\n-\t     an ARRAY/COMPONENT_REF.  */\n+\t     a COMPONENT_REF and an INDIRECT_REF involving a refeence.  */\n \t  STRIP_NOPS (t);\n \t  tree_code code = TREE_CODE (t);\n-\t  if (code == ARRAY_REF)\n-\t    t = TREE_OPERAND (t, 0);\n+\t  if (code == INDIRECT_REF)\n+\t    {\n+\t      tree op0 = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (TREE_TYPE (op0)) == REFERENCE_TYPE)\n+\t\tt = op0;\n+\t      else\n+\t\tbreak;\n+\t    }\n \t  else if (code == COMPONENT_REF)\n \t    t = TREE_OPERAND (t, 1);\n \t  else\n@@ -4169,7 +4216,8 @@ has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n \t}\n       else\n \t{\n-\t  atlist = TYPE_ATTRIBUTES (TREE_TYPE (expr));\n+\t  type = TREE_TYPE (expr);\n+\t  atlist = TYPE_ATTRIBUTES (type);\n \t  done = true;\n \t}\n \n@@ -4245,9 +4293,10 @@ has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n \t      if (tree arg = TREE_VALUE (attr))\n \t\t{\n \t\t  arg = convert (TREE_VALUE (arg));\n-\t\t  if (expr && DECL_P (expr)\n-\t\t      && DECL_USER_ALIGN (expr)\n-\t\t      && tree_fits_uhwi_p (arg))\n+\t\t  if (!tree_fits_uhwi_p (arg))\n+\t\t    /* Invalid argument.  */;\n+\t\t  else if (expr && DECL_P (expr)\n+\t\t\t   && DECL_USER_ALIGN (expr))\n \t\t    found_match = DECL_ALIGN_UNIT (expr) == tree_to_uhwi (arg);\n \t\t  else if (type && TYPE_USER_ALIGN (type))\n \t\t    found_match = TYPE_ALIGN_UNIT (type) == tree_to_uhwi (arg);\n@@ -4284,13 +4333,7 @@ has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n \t    }\n \t  else if (!strcmp (\"vector_size\", namestr))\n \t    {\n-\t      if (!type)\n-\t\tcontinue;\n-\n-\t      /* Determine the base type from arrays, pointers, and such.\n-\t\t Fail if the base type is not a vector.  */\n-\t      type = type_for_vector_size (type);\n-\t      if (!VECTOR_TYPE_P (type))\n+\t      if (!type || !VECTOR_TYPE_P (type))\n \t\treturn false;\n \n \t      if (tree arg = TREE_VALUE (attr))"}]}