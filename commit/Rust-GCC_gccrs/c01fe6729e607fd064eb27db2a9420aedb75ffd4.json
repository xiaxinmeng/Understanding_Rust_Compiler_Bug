{"sha": "c01fe6729e607fd064eb27db2a9420aedb75ffd4", "node_id": "C_kwDOANBUbNoAKGMwMWZlNjcyOWU2MDdmZDA2NGViMjdkYjJhOTQyMGFlZGI3NWZmZDQ", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-22T12:54:30Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-06-23T12:16:24Z"}, "message": "c++: Prune unneeded macro locations\n\nThis implements garbage collection on locations within macro\nexpansions, when streaming out a CMI.  When doing the reachability\nwalks, we now note which macro locations we need and then only write\nthose locations.  The complication here is that every macro expansion\nlocation has an independently calculated offset.  This complicates\nwriting, but reading remains the same -- the macro locations of a CMI\ncontinue to form a contiguous block.\n\nFor std headers this reduced the number of macro maps by 40% and the\nnumber of locations by 16%.  For a GMF including iostream, it reduced\nit by 80% and 60% respectively.\n\nOrdinary locations are still transformed en-mass.  They are somewhat\nmore complicated to apply a similar optimization to.\n\n\tgcc/cp/\n\t* module.cc (struct macro_info): New.\n\t(struct macro_traits): New.\n\t(macro_remap, macro_table): New globals.\n\t(depset::hash::find_dependencies): Note namespace location.\n\t(module_for_macro_loc): Adjust.\n\t(module_state::note_location): New.\n\t(module_state::Write_location): Note location when not\n\tstreaming. Adjust macro location streaming.\n\t(module_state::read_location): Adjust macro location\n\tstreaming.\n\t(module_state::write_init_maps): New.\n\t(module_state::write_prepare_maps): Reimplement macro map\n\tpreparation.\n\t(module_state::write_macro_maps): Reimplement.\n\t(module_state::read_macro_maps): Likewise.\n\t(module_state::write_begin): Adjust.\n\tgcc/testsuite/\n\t* g++.dg/modules/loc-prune-1.C: New.\n\t* g++.dg/modules/loc-prune-2.C: New.\n\t* g++.dg/modules/loc-prune-3.C: New.\n\t* g++.dg/modules/pr98718_a.C: Adjust.\n\t* g++.dg/modules/pr98718_b.C: Adjust.", "tree": {"sha": "daa6ef569dd5d8f3efb9bff77f98118a7a3b16e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daa6ef569dd5d8f3efb9bff77f98118a7a3b16e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01fe6729e607fd064eb27db2a9420aedb75ffd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01fe6729e607fd064eb27db2a9420aedb75ffd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01fe6729e607fd064eb27db2a9420aedb75ffd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01fe6729e607fd064eb27db2a9420aedb75ffd4/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "509cdb441614eab2a0fe90a970a927538b832bcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509cdb441614eab2a0fe90a970a927538b832bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509cdb441614eab2a0fe90a970a927538b832bcd"}], "stats": {"total": 410, "additions": 291, "deletions": 119}, "files": [{"sha": "7ee779d06b93598565256b7ec27f02efcafdc922", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 238, "deletions": 113, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=c01fe6729e607fd064eb27db2a9420aedb75ffd4", "patch": "@@ -3238,6 +3238,65 @@ class loc_spans {\n };\n \n static loc_spans spans;\n+\n+/* Information about macro locations we stream out.  */\n+struct macro_info\n+{\n+  const line_map_macro *src;    // original expansion\n+  unsigned remap;\t  // serialization\n+\n+  static int compare (const void *a_, const void *b_)\n+  {\n+    auto *a = static_cast<const macro_info *> (a_);\n+    auto *b = static_cast<const macro_info *> (b_);\n+\n+    gcc_checking_assert (MAP_START_LOCATION (a->src)\n+\t\t\t != MAP_START_LOCATION (b->src));\n+    if (MAP_START_LOCATION (a->src) < MAP_START_LOCATION (b->src))\n+      return -1;\n+    else\n+      return +1;\n+  }\n+};\n+struct macro_traits\n+{\n+  typedef macro_info value_type;\n+  typedef const line_map_macro *compare_type;\n+\n+  static const bool empty_zero_p = false;\n+\n+  static hashval_t hash (compare_type p)\n+  {\n+    return pointer_hash<const line_map_macro>::hash (p);\n+  }\n+  static hashval_t hash (const value_type &v)\n+  {\n+    return hash (v.src);\n+  }\n+  static bool equal (const value_type &v, const compare_type p)\n+  {\n+    return v.src == p;\n+  }\n+\n+  static void mark_empty (value_type &v)\n+  {\n+    v.src = nullptr;\n+  }\n+  static bool is_empty (value_type &v)\n+  {\n+    return !v.src;\n+  }\n+\n+  static bool is_deleted (value_type &) { return false; }\n+  static void mark_deleted (value_type &) { gcc_unreachable (); }\n+  \n+  static void remove (value_type &) {}\n+};\n+/* Table keyed by line_map_macro, used for noting.  */\n+static  hash_table<macro_traits> *macro_table;\n+/* Sorted vector, used for writing.  */\n+static vec<macro_info> *macro_remap;\n+\n /* Indirection to allow bsearching imports by ordinary location.  */\n static vec<module_state *> *ool;\n \n@@ -3398,7 +3457,7 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   /* Location ranges for this module.  adhoc-locs are decomposed, so\n      don't have a range.  */\n   loc_range_t GTY((skip)) ordinary_locs;\n-  loc_range_t GTY((skip)) macro_locs;\n+  loc_range_t GTY((skip)) macro_locs; // [lwm,num)\n \n   /* LOC is first set too the importing location.  When initially\n      loaded it refers to a module loc whose parent is the importing\n@@ -3591,6 +3650,7 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   bool read_entities (unsigned count, unsigned lwm, unsigned hwm);\n \n  private:\n+  void write_init_maps ();\n   location_map_info write_prepare_maps (module_state_config *);\n   bool read_prepare_maps (const module_state_config *);\n \n@@ -3599,7 +3659,7 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   bool read_ordinary_maps ();\n   void write_macro_maps (elf_out *to, location_map_info &,\n \t\t\t module_state_config *, unsigned *crc_ptr);\n-  bool read_macro_maps ();\n+  bool read_macro_maps (unsigned);\n \n  private:\n   void write_define (bytes_out &, const cpp_macro *, bool located = true);\n@@ -3616,6 +3676,7 @@ class GTY((chain_next (\"%h.parent\"), for_user)) module_state {\n   static cpp_macro *deferred_macro (cpp_reader *, location_t, cpp_hashnode *);\n \n  public:\n+  static void note_location (location_t);\n   static void write_location (bytes_out &, location_t);\n   location_t read_location (bytes_in &) const;\n \n@@ -13106,7 +13167,10 @@ depset::hash::find_dependencies (module_state *module)\n \t      else if (TREE_VISITED (decl))\n \t\t/* A global tree.  */;\n \t      else if (item->get_entity_kind () == EK_NAMESPACE)\n-\t\tadd_namespace_context (current, CP_DECL_CONTEXT (decl));\n+\t\t{\n+\t\t  module->note_location (DECL_SOURCE_LOCATION (decl));\n+\t\t  add_namespace_context (current, CP_DECL_CONTEXT (decl));\n+\t\t}\n \t      else\n \t\t{\n \t\t  walker.mark_declaration (decl, current->has_defn ());\n@@ -15518,15 +15582,15 @@ module_for_macro_loc (location_t loc)\n     {\n       unsigned half = len / 2;\n       module_state *probe = (*modules)[pos + half];\n-      if (loc >= probe->macro_locs.second)\n-\tlen = half;\n-      else if (loc >= probe->macro_locs.first)\n-\treturn probe;\n-      else\n+      if (loc < probe->macro_locs.first)\n \t{\n \t  pos += half + 1;\n \t  len = len - (half + 1);\n \t}\n+      else if (loc >= (probe->macro_locs.first + probe->macro_locs.second))\n+\tlen = half;\n+      else\n+\treturn probe;\n     }\n \n   return NULL;\n@@ -15545,16 +15609,73 @@ module_state::imported_from () const\n   return from;\n }\n \n+/* Note that LOC will need writing.  This allows us to prune locations\n+   that are not needed.  */\n+\n+void\n+module_state::note_location (location_t loc)\n+{\n+  if (!macro_table)\n+    ;\n+  else if (loc < RESERVED_LOCATION_COUNT)\n+    ;\n+  else if (IS_ADHOC_LOC (loc))\n+    {\n+      location_t locus = get_location_from_adhoc_loc (line_table, loc);\n+      note_location (locus);\n+      source_range range = get_range_from_loc (line_table, loc);\n+      if (range.m_start != locus)\n+\tnote_location (range.m_start);\n+      note_location (range.m_finish);\n+    }\n+  else if (loc >= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))\n+    {\n+      if (spans.macro (loc))\n+\t{\n+\t  const line_map *map = linemap_lookup (line_table, loc);\n+\t  const line_map_macro *mac_map = linemap_check_macro (map);\n+\t  hashval_t hv = macro_traits::hash (mac_map);\n+\t  macro_info *slot\n+\t    = macro_table->find_slot_with_hash (mac_map, hv, INSERT);\n+\t  if (!slot->src)\n+\t    {\n+\t      slot->src = mac_map;\n+\t      slot->remap = 0;\n+\t      // Expansion locations could themselves be from a\n+\t      // macro, we need to note them all.\n+\t      note_location (mac_map->expansion);\n+\t      gcc_checking_assert (mac_map->n_tokens);\n+\t      location_t tloc = UNKNOWN_LOCATION;\n+\t      for (unsigned ix = mac_map->n_tokens * 2; ix--;)\n+\t\tif (mac_map->macro_locations[ix] != tloc)\n+\t\t  {\n+\t\t    tloc = mac_map->macro_locations[ix];\n+\t\t    note_location (tloc);\n+\t\t  }\n+\t    }\n+\t}\t\t\t\t       \n+    }\n+  else if (IS_ORDINARY_LOC (loc))\n+    {\n+      /* This is where we should note we use this location.  See comment\n+\t about write_ordinary_maps.  */\n+    }\n+  else\n+    gcc_unreachable ();\n+  return;\n+}\n+\n /* If we're not streaming, record that we need location LOC.\n    Otherwise stream it.  */\n \n void\n module_state::write_location (bytes_out &sec, location_t loc)\n {\n   if (!sec.streaming_p ())\n-    /* This is where we should note we use this location.  See comment\n-       about write_ordinary_maps.  */\n-    return;\n+    {\n+      note_location (loc);\n+      return;\n+    }\n \n   if (loc < RESERVED_LOCATION_COUNT)\n     {\n@@ -15576,20 +15697,40 @@ module_state::write_location (bytes_out &sec, location_t loc)\n     }\n   else if (loc >= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))\n     {\n-      if (const loc_spans::span *span = spans.macro (loc))\n+      const macro_info *info = nullptr;\n+      unsigned offset = 0;\n+      if (unsigned hwm = macro_remap->length ())\n \t{\n-\t  unsigned off = MAX_LOCATION_T - loc;\n+\t  info = macro_remap->begin ();\n+\t  while (hwm != 1)\n+\t    {\n+\t      unsigned mid = hwm / 2;\n+\t      if (MAP_START_LOCATION (info[mid].src) <= loc)\n+\t\t{\n+\t\t  info += mid;\n+\t\t  hwm -= mid;\n+\t\t}\n+\t      else\n+\t\thwm = mid;\n+\t    }\n+\t  offset = loc - MAP_START_LOCATION (info->src);\n+\t  if (offset > info->src->n_tokens)\n+\t    info = nullptr;\n+\t}\n \n-\t  off -= span->macro_delta;\n+      gcc_checking_assert (bool (info) == bool (spans.macro (loc)));\n \n+      if (info)\n+\t{\n+\t  offset += info->remap;\n \t  sec.u (LK_MACRO);\n-\t  sec.u (off);\n+\t  sec.u (offset);\n \t  dump (dumper::LOCATION)\n-\t    && dump (\"Macro location %u output %u\", loc, off);\n+\t    && dump (\"Macro location %u output %u\", loc, offset);\n \t}\n       else if (const module_state *import = module_for_macro_loc (loc))\n \t{\n-\t  unsigned off = import->macro_locs.second - loc - 1;\n+\t  unsigned off = loc - import->macro_locs.first;\n \t  sec.u (LK_IMPORT_MACRO);\n \t  sec.u (import->remap);\n \t  sec.u (off);\n@@ -15668,12 +15809,8 @@ module_state::read_location (bytes_in &sec) const\n \n \tif (macro_locs.first)\n \t  {\n-\t    location_t adjusted = MAX_LOCATION_T - off;\n-\t    adjusted -= slurp->loc_deltas.second;\n-\t    if (adjusted < macro_locs.first)\n-\t      sec.set_overrun ();\n-\t    else if (adjusted < macro_locs.second)\n-\t      locus = adjusted;\n+\t    if (off < macro_locs.second)\n+\t      locus = off + macro_locs.first;\n \t    else\n \t      sec.set_overrun ();\n \t  }\n@@ -15733,8 +15870,8 @@ module_state::read_location (bytes_in &sec) const\n \t       {\n \t\t if (!import->macro_locs.first)\n \t\t   locus = import->loc;\n-\t\t else if (off < import->macro_locs.second - macro_locs.first)\n-\t\t   locus = import->macro_locs.second - off - 1;\n+\t\t else if (off < import->macro_locs.second)\n+\t\t   locus = off + import->macro_locs.first;\n \t\t else\n \t\t   sec.set_overrun ();\n \t       }\n@@ -15768,8 +15905,14 @@ module_state::read_location (bytes_in &sec) const\n // should decompose locations so that we can have a more graceful\n // degradation upon running out?\n \n+void\n+module_state::write_init_maps ()\n+{\n+  macro_table = new hash_table<macro_traits> (EXPERIMENT (1, 400));\n+}\n+\n location_map_info\n-module_state::write_prepare_maps (module_state_config *)\n+module_state::write_prepare_maps (module_state_config *cfg)\n {\n   dump () && dump (\"Preparing locations\");\n   dump.indent ();\n@@ -15840,7 +15983,6 @@ module_state::write_prepare_maps (module_state_config *)\n   /* Adjust the maps.  Ordinary ones ascend, and we must maintain\n      alignment.  Macro ones descend, but are unaligned.  */\n   location_t ord_off = spans[loc_spans::SPAN_FIRST].ordinary.first;\n-  location_t mac_off = spans[loc_spans::SPAN_FIRST].macro.second;\n   location_t range_mask = (1u << max_range) - 1;\n \n   dump () && dump (\"Ordinary maps range bits:%u, preserve:%x, zero:%u\",\n@@ -15850,16 +15992,9 @@ module_state::write_prepare_maps (module_state_config *)\n     {\n       loc_spans::span &span = spans[ix];\n \n-      span.macro_delta = mac_off - span.macro.second;\n-      mac_off -= span.macro.second - span.macro.first;\n-      dump () && dump (\"Macro span:%u [%u,%u):%u->%d(%u)\", ix,\n-\t\t       span.macro.first, span.macro.second,\n-\t\t       span.macro.second - span.macro.first,\n-\t\t       span.macro_delta, span.macro.first + span.macro_delta);\n-\n       line_map_ordinary const *omap\n \t= linemap_check_ordinary (linemap_lookup (line_table,\n-\t\t\t\t\t\t      span.ordinary.first));\n+\t\t\t\t\t\t  span.ordinary.first));\n       location_t base = MAP_START_LOCATION (omap);\n \n       /* Preserve the low MAX_RANGE bits of base by incrementing ORD_OFF.  */\n@@ -15888,14 +16023,33 @@ module_state::write_prepare_maps (module_state_config *)\n       ord_off = span.ordinary.second + span.ordinary_delta;\n     }\n \n-  dump () && dump (\"Ordinary:%u maps hwm:%u macro:%u maps lwm:%u \",\n+  vec_alloc (macro_remap, macro_table->size ());\n+  for (auto iter = macro_table->begin (), end = macro_table->end ();\n+       iter != end; ++iter)\n+    macro_remap->quick_push (*iter);\n+  delete macro_table;\n+  macro_table = nullptr;\n+\n+  macro_remap->qsort (&macro_info::compare);\n+  unsigned offset = 0;\n+  for (auto iter = macro_remap->begin (), end = macro_remap->end ();\n+       iter != end; ++iter)\n+    {\n+      auto mac = iter->src;\n+      iter->remap = offset;\n+      offset += mac->n_tokens;\n+    }\n+  info.num_maps.second = macro_remap->length ();\n+  cfg->macro_locs = offset;\n+\n+  dump () && dump (\"Ordinary:%u maps hwm:%u macro:%u maps %u locs\",\n \t\t   info.num_maps.first, ord_off,\n-\t\t   info.num_maps.second, mac_off);\n+\t\t   info.num_maps.second, cfg->macro_locs);\n \n   dump.outdent ();\n \n   info.max_range = max_range;\n-  \n+\n   return info;\n }\n \n@@ -16077,7 +16231,7 @@ module_state::write_ordinary_maps (elf_out *to, location_map_info &info,\n \n void\n module_state::write_macro_maps (elf_out *to, location_map_info &info,\n-\t\t\t\tmodule_state_config *cfg, unsigned *crc_p)\n+\t\t\t\tmodule_state_config *, unsigned *crc_p)\n {\n   dump () && dump (\"Writing macro location maps\");\n   dump.indent ();\n@@ -16088,74 +16242,46 @@ module_state::write_macro_maps (elf_out *to, location_map_info &info,\n   dump () && dump (\"Macro maps:%u\", info.num_maps.second);\n   sec.u (info.num_maps.second);\n \n-  location_t offset = spans[loc_spans::SPAN_FIRST].macro.second;\n-  sec.u (offset);\n-\n   unsigned macro_num = 0;\n-  for (unsigned ix = loc_spans::SPAN_FIRST; ix != spans.length (); ix++)\n-    {\n-      loc_spans::span &span = spans[ix];\n-      if (span.macro.first == span.macro.second)\n-\t/* Empty span.  */\n-\tcontinue;\n-\n-      for (unsigned macro\n-\t     = linemap_lookup_macro_index (line_table, span.macro.second - 1);\n-\t   macro < LINEMAPS_MACRO_USED (line_table);\n-\t   macro++)\n+  for (auto iter = macro_remap->end (), begin = macro_remap->begin ();\n+       iter-- != begin;)\n+    {\n+      auto mac = iter->src;\n+      sec.u (iter->remap);\n+      sec.u (mac->n_tokens);\n+      sec.cpp_node (mac->macro);\n+      write_location (sec, mac->expansion);\n+      const location_t *locs = mac->macro_locations;\n+      /* There are lots of identical runs.  */\n+      location_t prev = UNKNOWN_LOCATION;\n+      unsigned count = 0;\n+      unsigned runs = 0;\n+      for (unsigned jx = mac->n_tokens * 2; jx--;)\n \t{\n-\t  line_map_macro const *mmap\n-\t    = LINEMAPS_MACRO_MAP_AT (line_table, macro);\n-\t  location_t start_loc = MAP_START_LOCATION (mmap);\n-\t  if (start_loc < span.macro.first)\n-\t    /* Fallen out of the span.  */\n-\t    break;\n-\n-\t  if (!mmap->n_tokens)\n-\t    /* Empty expansion.  */\n-\t    continue;\n-\n-\t  sec.u (offset);\n-\t  sec.u (mmap->n_tokens);\n-\t  sec.cpp_node (mmap->macro);\n-\t  write_location (sec, mmap->expansion);\n-\t  const location_t *locs = mmap->macro_locations;\n-\t  /* There are lots of identical runs.  */\n-\t  location_t prev = UNKNOWN_LOCATION;\n-\t  unsigned count = 0;\n-\t  unsigned runs = 0;\n-\t  for (unsigned jx = mmap->n_tokens * 2; jx--;)\n+\t  location_t tok_loc = locs[jx];\n+\t  if (tok_loc == prev)\n \t    {\n-\t      location_t tok_loc = locs[jx];\n-\t      if (tok_loc == prev)\n-\t\t{\n-\t\t  count++;\n-\t\t  continue;\n-\t\t}\n-\t      runs++;\n-\t      sec.u (count);\n-\t      count = 1;\n-\t      prev = tok_loc;\n-\t      write_location (sec, tok_loc);\n+\t      count++;\n+\t      continue;\n \t    }\n+\t  runs++;\n \t  sec.u (count);\n-\t  dump (dumper::LOCATION)\n-\t    && dump (\"Span:%u macro:%u %I %u/%u*2 locations [%u,%u)->%u\",\n-\t\t     ix, macro_num, identifier (mmap->macro),\n-\t\t     runs, mmap->n_tokens,\n-\t\t     start_loc, start_loc + mmap->n_tokens,\n-\t\t     start_loc + span.macro_delta);\n-\t  macro_num++;\n-\t  offset -= mmap->n_tokens;\n-\t  gcc_checking_assert (offset == start_loc + span.macro_delta);\n+\t  count = 1;\n+\t  prev = tok_loc;\n+\t  write_location (sec, tok_loc);\n \t}\n+      sec.u (count);\n+      dump (dumper::LOCATION)\n+\t&& dump (\"Macro:%u %I %u/%u*2 locations [%u,%u)->%u\",\n+\t\t macro_num, identifier (mac->macro),\n+\t\t runs, mac->n_tokens,\n+\t\t MAP_START_LOCATION (mac),\n+\t\t MAP_START_LOCATION (mac) + mac->n_tokens,\n+\t\t iter->remap);\n+      macro_num++;\n     }\n-  dump () && dump (\"Macro location lwm:%u\", offset);\n-  sec.u (offset);\n   gcc_assert (macro_num == info.num_maps.second);\n \n-  cfg->macro_locs = MAX_LOCATION_T + 1 - offset;\n-\n   sec.end (to, to->name (MOD_SNAME_PFX \".mlm\"), crc_p);\n   dump.outdent ();\n }\n@@ -16265,7 +16391,7 @@ module_state::read_ordinary_maps ()\n }\n \n bool\n-module_state::read_macro_maps ()\n+module_state::read_macro_maps (unsigned num_macro_locs)\n {\n   bytes_in sec;\n \n@@ -16275,24 +16401,22 @@ module_state::read_macro_maps ()\n   dump.indent ();\n \n   unsigned num_macros = sec.u ();\n-  location_t zero = sec.u ();\n-  dump () && dump (\"Macro maps:%u zero:%u\", num_macros, zero);\n+  dump () && dump (\"Macro maps:%u locs:%u\", num_macros, num_macro_locs);\n \n   bool propagated = spans.maybe_propagate (this,\n \t\t\t\t\t   line_table->highest_location + 1);\n \n   location_t offset = LINEMAPS_MACRO_LOWEST_LOCATION (line_table);\n-  slurp->loc_deltas.second = zero - offset;\n-  macro_locs.second = zero - slurp->loc_deltas.second;\n-  dump () && dump (\"Macro loc delta %d\", slurp->loc_deltas.second);\n+  macro_locs.second = num_macro_locs;\n+  macro_locs.first = offset - num_macro_locs;\n+\n+  dump () && dump (\"Macro loc delta %d\", offset);\n+  dump () && dump (\"Macro locations [%u,%u)\",\n+\t\t   macro_locs.first, macro_locs.second);\n \n   for (unsigned ix = 0; ix != num_macros && !sec.get_overrun (); ix++)\n     {\n-      unsigned lwm = sec.u ();\n-      /* Record the current LWM so that the below read_location is\n-\t ok.  */\n-      macro_locs.first = lwm - slurp->loc_deltas.second;\n-\n+      unsigned offset = sec.u ();\n       unsigned n_tokens = sec.u ();\n       cpp_hashnode *node = sec.cpp_node ();\n       location_t exp_loc = read_location (sec);\n@@ -16303,6 +16427,8 @@ module_state::read_macro_maps ()\n \t/* We shouldn't run out of locations, as we checked that we\n \t   had enough before starting.  */\n \tbreak;\n+      gcc_checking_assert (MAP_START_LOCATION (macro)\n+\t\t\t   == offset + macro_locs.first);\n \n       location_t *locs = macro->macro_locations;\n       location_t tok_loc = UNKNOWN_LOCATION;\n@@ -16326,11 +16452,8 @@ module_state::read_macro_maps ()\n \t\t MAP_START_LOCATION (macro),\n \t\t MAP_START_LOCATION (macro) + n_tokens);\n     }\n-  location_t lwm = sec.u ();\n-  macro_locs.first = lwm - slurp->loc_deltas.second;\n \n   dump () && dump (\"Macro location lwm:%u\", macro_locs.first);\n-\n   if (propagated)\n     spans.close ();\n \n@@ -17604,6 +17727,8 @@ module_state::write_begin (elf_out *to, cpp_reader *reader,\n     /* No partitions present.  */\n     partitions = nullptr;\n \n+  write_init_maps ();\n+\n   /* Find the set of decls we must write out.  */\n   depset::hash table (DECL_NAMESPACE_BINDINGS (global_namespace)->size () * 8);\n   /* Add the specializations before the writables, so that we can\n@@ -17911,7 +18036,7 @@ module_state::read_initial (cpp_reader *reader)\n   gcc_assert (!from ()->is_frozen ());\n \n   /* Macro maps after the imports.  */\n-  if (ok && have_locs && !read_macro_maps ())\n+  if (ok && have_locs && !read_macro_maps (config.macro_locs))\n     ok = false;\n \n   /* Note whether there's an active initializer.  */"}, {"sha": "6978e496f1b89374b11a97f4a68546370afb4b76", "filename": "gcc/testsuite/g++.dg/modules/loc-prune-1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-1.C?ref=c01fe6729e607fd064eb27db2a9420aedb75ffd4", "patch": "@@ -0,0 +1,19 @@\n+//  { dg-additional-options {-fmodules-ts -fdump-lang-module-lineno} }\n+\n+export module foo;\n+// { dg-module-cmi foo }\n+#define NOT 1\n+#define YES 1\n+#define AGAIN_NO (1 + 2)\n+#if NOT\n+int foo (int = YES)\n+{\n+  return AGAIN_NO;\n+}\n+#endif\n+\n+// { dg-final { scan-lang-dump { Macro maps:1} module } }\n+// { dg-final { scan-lang-dump { Macro:0 YES 1/1.2 locations } module } }\n+// { dg-final { scan-lang-dump { Ordinary:[0-9]* maps hwm:[0-9]* macro:1 maps 1 locs} module } }\n+// { dg-final { scan-lang-dump-not {Macro:. NOT } module } }\n+// { dg-final { scan-lang-dump-not {Macro:. AGAIN_NO } module } }"}, {"sha": "fc4ed7825f3391f94af6dac0ad3805ef0518f1cc", "filename": "gcc/testsuite/g++.dg/modules/loc-prune-2.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-2.C?ref=c01fe6729e607fd064eb27db2a9420aedb75ffd4", "patch": "@@ -0,0 +1,14 @@\n+//  { dg-additional-options {-fmodules-ts -fdump-lang-module-lineno} }\n+\n+export module Eve;\n+// { dg-module-cmi Eve }\n+\n+#define BEGIN_NAMESPACE(X) inline namespace X {\n+#define END_NAMESPACE(X) }\n+\n+BEGIN_NAMESPACE (BOB)\n+void Alice ();\n+END_NAMESPACE (BOB)\n+\n+// { dg-final { scan-lang-dump { Macro maps:1} module } }\n+// { dg-final { scan-lang-dump { Macro:0 BEGIN_NAMESPACE 5/6.2 locations } module } }"}, {"sha": "40e8aa68e1dcc66712ac8d287f0b0419e36a405a", "filename": "gcc/testsuite/g++.dg/modules/loc-prune-3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Floc-prune-3.C?ref=c01fe6729e607fd064eb27db2a9420aedb75ffd4", "patch": "@@ -0,0 +1,16 @@\n+//  { dg-additional-options {-fmodules-ts -fdump-lang-module-lineno} }\n+\n+export module Eve;\n+// { dg-module-cmi Eve }\n+\n+#define BEGIN_NAMESPACE(X) inline namespace X {\n+#define END_NAMESPACE(X) }\n+\n+BEGIN_NAMESPACE (BOB)\n+namespace inner {\n+void Alice ();\n+}\n+END_NAMESPACE (BOB)\n+\n+// { dg-final { scan-lang-dump { Macro maps:1} module } }\n+// { dg-final { scan-lang-dump { Macro:0 BEGIN_NAMESPACE 5/6.2 locations } module } }"}, {"sha": "ebd95ea1f85318e3d07c2f609549718a0c6e181b", "filename": "gcc/testsuite/g++.dg/modules/pr98718_a.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_a.C?ref=c01fe6729e607fd064eb27db2a9420aedb75ffd4", "patch": "@@ -14,5 +14,5 @@ namespace std _GLIBCXX_VISIBILITY(default)\n export  module  hello:format;\n // { dg-module-cmi hello:format }\n \n-// { dg-final { scan-lang-dump { Ordinary:4 maps hwm:[0-9]* macro:1 maps lwm:214[0-9]*} module } }\n-// { dg-final { scan-lang-dump { Span:2 macro:0 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }\n+// { dg-final { scan-lang-dump { Ordinary:4 maps hwm:[0-9]* macro:0 maps 0 locs} module } }\n+// { dg-final { scan-lang-dump-not { Macro:. _GLIBCXX_VISIBILITY} module } }"}, {"sha": "6cb4698bad5aed0d80a8a338abc16408056685ff", "filename": "gcc/testsuite/g++.dg/modules/pr98718_b.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01fe6729e607fd064eb27db2a9420aedb75ffd4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fmodules%2Fpr98718_b.C?ref=c01fe6729e607fd064eb27db2a9420aedb75ffd4", "patch": "@@ -14,7 +14,5 @@ export  module  hello;\n export  import  :format;\n // { dg-module-cmi hello }\n \n-// { dg-final { scan-lang-dump {Macro:0 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }\n-// { dg-final { scan-lang-dump { Ordinary:8 maps hwm:[0-9]* macro:2 maps lwm:214[0-9]*} module } }\n-// { dg-final { scan-lang-dump { Span:2 macro:0 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }\n-// { dg-final { scan-lang-dump { Span:4 macro:1 _GLIBCXX_VISIBILITY 10/11\\*2 locations } module } }\n+// { dg-final { scan-lang-dump { Ordinary:8 maps hwm:[0-9]* macro:0 maps 0 locs} module } }\n+// { dg-final { scan-lang-dump-not { Macro:. _GLIBCXX_VISIBILITY} module } }"}]}