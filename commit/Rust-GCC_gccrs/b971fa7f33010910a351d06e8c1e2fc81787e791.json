{"sha": "b971fa7f33010910a351d06e8c1e2fc81787e791", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk3MWZhN2YzMzAxMDkxMGEzNTFkMDZlOGMxZTJmYzgxNzg3ZTc5MQ==", "commit": {"author": {"name": "Jim Wilson", "email": "jim.wilson@r3-a15.aus-colo", "date": "2017-06-26T21:40:47Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2017-06-26T21:40:47Z"}, "message": "Fix for SPEC CPU2017 621.wrf_s failure, add missing locking code.\n\n\tlibgfortran/\n\tPR libfortran/81195\n\t* io/unit.c (get_unit): Call __gthread_mutex_lock before newunit_stack\n\tand newunit_tos references.  Call __gthread_mutex_unlock afterward.\n\nFrom-SVN: r249667", "tree": {"sha": "b3b89b10b37626121cb9c6bd74ec09bc0d63a45e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3b89b10b37626121cb9c6bd74ec09bc0d63a45e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b971fa7f33010910a351d06e8c1e2fc81787e791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b971fa7f33010910a351d06e8c1e2fc81787e791", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b971fa7f33010910a351d06e8c1e2fc81787e791", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b971fa7f33010910a351d06e8c1e2fc81787e791/comments", "author": null, "committer": null, "parents": [{"sha": "b0d1023d5f5f52a21d00f6e7eb5d46898c052171", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d1023d5f5f52a21d00f6e7eb5d46898c052171", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d1023d5f5f52a21d00f6e7eb5d46898c052171"}], "stats": {"total": 12, "additions": 12, "deletions": 0}, "files": [{"sha": "778056ba29ee1096072c0a36d1342b1823fb3134", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b971fa7f33010910a351d06e8c1e2fc81787e791/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b971fa7f33010910a351d06e8c1e2fc81787e791/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b971fa7f33010910a351d06e8c1e2fc81787e791", "patch": "@@ -1,3 +1,9 @@\n+2017-06-26  Jim Wilson  <jim.wilson@r3-a15.aus-colo>\n+\n+\tPR libfortran/81195\n+\t* io/unit.c (get_unit): Call __gthread_mutex_lock before newunit_stack\n+\tand newunit_tos references.  Call __gthread_mutex_unlock afterward.\n+\n 2017-06-24  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n         PR fortran/52473"}, {"sha": "ef94294526a3628f5316d1e902a4b480c23ca986", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b971fa7f33010910a351d06e8c1e2fc81787e791/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b971fa7f33010910a351d06e8c1e2fc81787e791/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=b971fa7f33010910a351d06e8c1e2fc81787e791", "patch": "@@ -583,14 +583,17 @@ get_unit (st_parameter_dt *dtp, int do_create)\n \t}\n       else\n \t{\n+\t  __gthread_mutex_lock (&unit_lock);\n \t  if (newunit_tos)\n \t    {\n \t      dtp->common.unit = newunit_stack[newunit_tos].unit_number;\n \t      unit = newunit_stack[newunit_tos--].unit;\n+\t      __gthread_mutex_unlock (&unit_lock);\n \t      unit->fbuf->act = unit->fbuf->pos = 0;\n \t    }\n \t  else\n \t    {\n+\t      __gthread_mutex_unlock (&unit_lock);\n \t      dtp->common.unit = newunit_alloc ();\n \t      unit = xcalloc (1, sizeof (gfc_unit));\n \t      fbuf_init (unit, 128);\n@@ -603,12 +606,15 @@ get_unit (st_parameter_dt *dtp, int do_create)\n   /* If an internal unit number is passed from the parent to the child\n      it should have been stashed on the newunit_stack ready to be used.\n      Check for it now and return the internal unit if found.  */\n+  __gthread_mutex_lock (&unit_lock);\n   if (newunit_tos && (dtp->common.unit <= NEWUNIT_START)\n       && (dtp->common.unit == newunit_stack[newunit_tos].unit_number))\n     {\n       unit = newunit_stack[newunit_tos--].unit;\n+      __gthread_mutex_unlock (&unit_lock);\n       return unit;\n     }\n+  __gthread_mutex_unlock (&unit_lock);\n \n   /* Has to be an external unit.  */\n   dtp->u.p.unit_is_internal = 0;"}]}