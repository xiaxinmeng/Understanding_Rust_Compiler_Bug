{"sha": "aa803cc76ee6a0a4f951b20912def90880c996c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE4MDNjYzc2ZWU2YTBhNGY5NTFiMjA5MTJkZWY5MDg4MGM5OTZjMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-25T19:52:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-25T19:52:20Z"}, "message": "ipa-utils.h (subbinfo_with_vtable_at_offset, [...]): Declare.\n\n\n\t* ipa-utils.h (subbinfo_with_vtable_at_offset, type_all_derivations_known_p,\n\ttype_known_to_have_no_deriavations_p, types_must_be_same_for_odr,\n\ttypes_odr_comparable): Declare.\n\t(polymorphic_type_binfo_p): Move here from ipa-devirt.c\n\t* ipa-polymorphic-call.c: New file.\n\t(contains_polymorphic_type_p, possible_placement_new,\n\tipa_polymorphic_call_context::restrict_to_inner_class,\n\tcontains_type_p, decl_maybe_in_construction_p,\n\tipa_polymorphic_call_context::stream_out,\n\tipa_polymorphic_call_context::debug,\n\tipa_polymorphic_call_context::stream_in,\n\tipa_polymorphic_call_context::set_by_decl,\n\tipa_polymorphic_call_context::set_by_invariant,\n\twalk_ssa_copies,\n\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n\ttype_change_info, noncall_stmt_may_be_vtbl_ptr_store,\n\textr_type_from_vtbl_ptr_store, record_known_type\n\tcheck_stmt_for_type_change,\n\tipa_polymorphic_call_context::get_dynamic_type): Move here from\n\tipa-devirt.c\n\t* ipa-devirt.c: No longer include data-streamer.h, lto-streamer.h\n\tand streamer-hooks.h\n\t(contains_polymorphic_type_p, possible_placement_new,\n\tipa_polymorphic_call_context::restrict_to_inner_class,\n\tcontains_type_p, decl_maybe_in_construction_p,\n\tipa_polymorphic_call_context::stream_out,\n\tipa_polymorphic_call_context::debug,\n\tipa_polymorphic_call_context::stream_in,\n\tipa_polymorphic_call_context::set_by_decl,\n\tipa_polymorphic_call_context::set_by_invariant,\n\twalk_ssa_copies,\n\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n\ttype_change_info, noncall_stmt_may_be_vtbl_ptr_store,\n\textr_type_from_vtbl_ptr_store, record_known_type\n\tcheck_stmt_for_type_change,\n\tipa_polymorphic_call_context::get_dynamic_type): Move to\n\tipa-polymorphic-call.c\n\t(type_all_derivations_known_p, types_odr_comparable,\n\ttypes_must_be_same_for_odr): Export.\n\t(type_known_to_have_no_deriavations_p): New function.\n\t* Makefile.in: Add ipa-polymorphic-call.c\n\nFrom-SVN: r215615", "tree": {"sha": "737b851b74e90c187fd6b46491fa387a8085db27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/737b851b74e90c187fd6b46491fa387a8085db27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa803cc76ee6a0a4f951b20912def90880c996c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa803cc76ee6a0a4f951b20912def90880c996c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa803cc76ee6a0a4f951b20912def90880c996c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa803cc76ee6a0a4f951b20912def90880c996c1/comments", "author": null, "committer": null, "parents": [{"sha": "2f28755fbfdd89b016163e72fa92edb14a19e5e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f28755fbfdd89b016163e72fa92edb14a19e5e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f28755fbfdd89b016163e72fa92edb14a19e5e6"}], "stats": {"total": 3091, "additions": 1599, "deletions": 1492}, "files": [{"sha": "85dd75050eaff8b803f3c71bba93b0b5c7e65aee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aa803cc76ee6a0a4f951b20912def90880c996c1", "patch": "@@ -1,3 +1,47 @@\n+2014-09-25  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-utils.h (subbinfo_with_vtable_at_offset, type_all_derivations_known_p,\n+\ttype_known_to_have_no_deriavations_p, types_must_be_same_for_odr,\n+\ttypes_odr_comparable): Declare.\n+\t(polymorphic_type_binfo_p): Move here from ipa-devirt.c\n+\t* ipa-polymorphic-call.c: New file.\n+\t(contains_polymorphic_type_p, possible_placement_new,\n+\tipa_polymorphic_call_context::restrict_to_inner_class,\n+\tcontains_type_p, decl_maybe_in_construction_p,\n+\tipa_polymorphic_call_context::stream_out,\n+\tipa_polymorphic_call_context::debug,\n+\tipa_polymorphic_call_context::stream_in,\n+\tipa_polymorphic_call_context::set_by_decl,\n+\tipa_polymorphic_call_context::set_by_invariant,\n+\twalk_ssa_copies,\n+\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n+\ttype_change_info, noncall_stmt_may_be_vtbl_ptr_store,\n+\textr_type_from_vtbl_ptr_store, record_known_type\n+\tcheck_stmt_for_type_change,\n+\tipa_polymorphic_call_context::get_dynamic_type): Move here from\n+\tipa-devirt.c\n+\t* ipa-devirt.c: No longer include data-streamer.h, lto-streamer.h\n+\tand streamer-hooks.h\n+\t(contains_polymorphic_type_p, possible_placement_new,\n+\tipa_polymorphic_call_context::restrict_to_inner_class,\n+\tcontains_type_p, decl_maybe_in_construction_p,\n+\tipa_polymorphic_call_context::stream_out,\n+\tipa_polymorphic_call_context::debug,\n+\tipa_polymorphic_call_context::stream_in,\n+\tipa_polymorphic_call_context::set_by_decl,\n+\tipa_polymorphic_call_context::set_by_invariant,\n+\twalk_ssa_copies,\n+\tipa_polymorphic_call_context::ipa_polymorphic_call_context,\n+\ttype_change_info, noncall_stmt_may_be_vtbl_ptr_store,\n+\textr_type_from_vtbl_ptr_store, record_known_type\n+\tcheck_stmt_for_type_change,\n+\tipa_polymorphic_call_context::get_dynamic_type): Move to\n+\tipa-polymorphic-call.c\n+\t(type_all_derivations_known_p, types_odr_comparable,\n+\ttypes_must_be_same_for_odr): Export.\n+\t(type_known_to_have_no_deriavations_p): New function.\n+\t* Makefile.in: Add ipa-polymorphic-call.c\n+\n 2014-09-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-devirt.c (polymorphic_call_target_d): Add SPECULATIVE; reorder"}, {"sha": "3dd9d8f3393751cc455e7c5156139fc66689a078", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=aa803cc76ee6a0a4f951b20912def90880c996c1", "patch": "@@ -1255,6 +1255,7 @@ OBJS = \\\n \tinternal-fn.o \\\n \tipa-cp.o \\\n \tipa-devirt.o \\\n+\tipa-polymorphic-call.o \\\n \tipa-split.o \\\n \tipa-inline.o \\\n \tipa-comdats.o \\"}, {"sha": "cbc9dd589065a0c643023ba941f518e784add348", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 16, "deletions": 1492, "changes": 1508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=aa803cc76ee6a0a4f951b20912def90880c996c1", "patch": "@@ -135,9 +135,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"intl.h\"\n #include \"hash-map.h\"\n-#include \"data-streamer.h\"\n-#include \"lto-streamer.h\"\n-#include \"streamer-hooks.h\"\n \n /* Hash based set of pairs of types.  */\n typedef struct\n@@ -213,33 +210,15 @@ struct GTY(()) odr_type_d\n   bool odr_violated;\n };\n \n-static bool contains_type_p (tree, HOST_WIDE_INT, tree);\n-\n-\n-/* Return true if BINFO corresponds to a type with virtual methods. \n-\n-   Every type has several BINFOs.  One is the BINFO associated by the type\n-   while other represents bases of derived types.  The BINFOs representing\n-   bases do not have BINFO_VTABLE pointer set when this is the single\n-   inheritance (because vtables are shared).  Look up the BINFO of type\n-   and check presence of its vtable.  */\n-\n-static inline bool\n-polymorphic_type_binfo_p (tree binfo)\n-{\n-  /* See if BINFO's type has an virtual table associtated with it.  */\n-  return BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo)));\n-}\n-\n /* Return TRUE if all derived types of T are known and thus\n    we may consider the walk of derived type complete.\n \n    This is typically true only for final anonymous namespace types and types\n    defined within functions (that may be COMDAT and thus shared across units,\n    but with the same set of derived types).  */\n \n-static bool\n-type_all_derivations_known_p (tree t)\n+bool\n+type_all_derivations_known_p (const_tree t)\n {\n   if (TYPE_FINAL_P (t))\n     return true;\n@@ -460,7 +439,7 @@ types_same_for_odr (const_tree type1, const_tree type2)\n    In non-LTO it is always decide, in LTO however it depends in the type has\n    ODR info attached.  */\n \n-static bool\n+bool\n types_odr_comparable (tree t1, tree t2)\n {\n   return (!in_lto_p\n@@ -475,7 +454,7 @@ types_odr_comparable (tree t1, tree t2)\n /* Return true if T1 and T2 are ODR equivalent.  If ODR equivalency is not\n    known, be conservative and return false.  */\n \n-static bool\n+bool\n types_must_be_same_for_odr (tree t1, tree t2)\n {\n   if (types_odr_comparable (t1, t2))\n@@ -1438,6 +1417,17 @@ register_odr_type (tree type)\n     get_odr_type (type, true);\n }\n \n+/* Return true if type is known to have no derivations.  */\n+\n+bool\n+type_known_to_have_no_deriavations_p (tree t)\n+{\n+  return (type_all_derivations_known_p (t)\n+\t  && (TYPE_FINAL_P (t)\n+\t      || (odr_hash\n+\t\t  && !get_odr_type (t, true)->derived_types.length())));\n+}\n+\n /* Dump ODR type T and all its derrived type.  INDENT specify indentation for\n    recusive printing.  */\n \n@@ -1983,364 +1973,9 @@ devirt_node_removal_hook (struct cgraph_node *n, void *d ATTRIBUTE_UNUSED)\n     free_polymorphic_call_targets_hash ();\n }\n \n-/* Return true when TYPE contains an polymorphic type and thus is interesting\n-   for devirtualization machinery.  */\n-\n-bool\n-contains_polymorphic_type_p (const_tree type)\n-{\n-  type = TYPE_MAIN_VARIANT (type);\n-\n-  if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      if (TYPE_BINFO (type)\n-          && polymorphic_type_binfo_p (TYPE_BINFO (type)))\n-\treturn true;\n-      for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n-\tif (TREE_CODE (fld) == FIELD_DECL\n-\t    && !DECL_ARTIFICIAL (fld)\n-\t    && contains_polymorphic_type_p (TREE_TYPE (fld)))\n-\t  return true;\n-      return false;\n-    }\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return contains_polymorphic_type_p (TREE_TYPE (type));\n-  return false;\n-}\n-\n-/* Return true if it seems valid to use placement new to build EXPECTED_TYPE\n-   at possition CUR_OFFSET within TYPE.  \n-\n-   POD can be changed to an instance of a polymorphic type by\n-   placement new.  Here we play safe and assume that any\n-   non-polymorphic type is POD.  */\n-bool\n-possible_placement_new (tree type, tree expected_type,\n-\t\t\tHOST_WIDE_INT cur_offset)\n-{\n-  return ((TREE_CODE (type) != RECORD_TYPE\n-\t   || !TYPE_BINFO (type)\n-\t   || cur_offset >= BITS_PER_WORD\n-\t   || !polymorphic_type_binfo_p (TYPE_BINFO (type)))\n-\t  && (!TYPE_SIZE (type)\n-\t      || !tree_fits_shwi_p (TYPE_SIZE (type))\n-\t      || (cur_offset\n-\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n-\t\t     : 1)\n-\t\t  <= tree_to_uhwi (TYPE_SIZE (type)))));\n-}\n-\n-/* THIS->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n-   is contained at THIS->OFFSET.  Walk the memory representation of\n-   THIS->OUTER_TYPE and find the outermost class type that match\n-   EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update THIS\n-   to represent it.\n-\n-   If EXPECTED_TYPE is NULL, just find outermost polymorphic type with\n-   virtual table present at possition OFFSET.\n-\n-   For example when THIS represents type\n-   class A\n-     {\n-       int a;\n-       class B b;\n-     }\n-   and we look for type at offset sizeof(int), we end up with B and offset 0.\n-   If the same is produced by multiple inheritance, we end up with A and offset\n-   sizeof(int). \n-\n-   If we can not find corresponding class, give up by setting\n-   THIS->OUTER_TYPE to EXPECTED_TYPE and THIS->OFFSET to NULL. \n-   Return true when lookup was sucesful.  */\n-\n-bool\n-ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n-{\n-  tree type = outer_type;\n-  HOST_WIDE_INT cur_offset = offset;\n-  bool speculative = false;\n-  bool size_unknown = false;\n-\n-  /* Update OUTER_TYPE to match EXPECTED_TYPE if it is not set.  */\n-  if (!outer_type)\n-    {\n-      clear_outer_type (expected_type);\n-      type = expected_type;\n-      cur_offset = 0;\n-    }\n- /* See if OFFSET points inside OUTER_TYPE.  If it does not, we know\n-    that the context is either invalid, or the instance type must be\n-    derived from OUTER_TYPE.\n-\n-    Because the instance type may contain field whose type is of OUTER_TYPE,\n-    we can not derive any effective information about it.\n-\n-    TODO: In the case we know all derrived types, we can definitely do better\n-    here.  */\n-  else if (TYPE_SIZE (outer_type)\n-\t   && tree_fits_shwi_p (TYPE_SIZE (outer_type))\n-\t   && tree_to_shwi (TYPE_SIZE (outer_type)) >= 0\n-\t   && tree_to_shwi (TYPE_SIZE (outer_type)) <= offset)\n-   {\n-     clear_outer_type (expected_type);\n-     type = expected_type;\n-     cur_offset = 0;\n-\n-     /* If derived type is not allowed, we know that the context is invalid.  */\n-     if (!maybe_derived_type)\n-       {\n-\t clear_speculation ();\n-\t invalid = true;\n-\t return false;\n-       }\n-   }\n-\n-  if (speculative_outer_type)\n-    {\n-      /* Short cirucit the busy work bellow and give up on case when speculation\n-\t is obviously the same as outer_type.  */\n-      if ((!maybe_derived_type\n-\t   || speculative_maybe_derived_type)\n-\t  && types_must_be_same_for_odr (speculative_outer_type, outer_type))\n-\tclear_speculation ();\n-\n-      /* See if SPECULATIVE_OUTER_TYPE is contained in or derived from OUTER_TYPE.\n-\t In this case speculation is valid only if derived types are allowed. \n-\n-\t The test does not really look for derivate, but also accepts the case where\n-\t outer_type is a field of speculative_outer_type.  In this case eiter\n-\t MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n-\t the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n-\t and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n-      else if (speculative_offset < offset\n-\t       || !contains_type_p (speculative_outer_type,\n-\t\t\t\t    speculative_offset - offset,\n-\t\t\t\t    outer_type)\n-\t       || !maybe_derived_type)\n-\tclear_speculation ();\n-    }\n-  else\n-    /* Regularize things little bit and clear all the fields when no useful\n-       speculatin is known.  */\n-    clear_speculation ();\n-\n-  if (!type)\n-    goto no_useful_type_info;\n-\n-  /* Find the sub-object the constant actually refers to and mark whether it is\n-     an artificial one (as opposed to a user-defined one).\n-\n-     This loop is performed twice; first time for outer_type and second time\n-     for speculative_outer_type.  The second run has SPECULATIVE set.  */\n-  while (true)\n-    {\n-      HOST_WIDE_INT pos, size;\n-      tree fld;\n-\n-      /* If we do not know size of TYPE, we need to be more conservative\n-         about accepting cases where we can not find EXPECTED_TYPE.\n-\t Generally the types that do matter here are of constant size.\n-\t Size_unknown case should be very rare.  */\n-      if (TYPE_SIZE (type)\n-\t  && tree_fits_shwi_p (TYPE_SIZE (type))\n-\t  && tree_to_shwi (TYPE_SIZE (type)) >= 0)\n-\tsize_unknown = false;\n-      else\n-\tsize_unknown = true;\n-\n-      /* On a match, just return what we found.  */\n-      if ((types_odr_comparable (type, expected_type)\n-\t   && types_same_for_odr (type, expected_type))\n-\t  || (!expected_type\n-\t      && TREE_CODE (type) == RECORD_TYPE\n-\t      && TYPE_BINFO (type)\n-\t      && polymorphic_type_binfo_p (TYPE_BINFO (type))))\n-\t{\n-\t  if (speculative)\n-\t    {\n-\t      /* If we did not match the offset, just give up on speculation.  */\n-\t      if (cur_offset != 0\n-\t\t  /* Also check if speculation did not end up being same as\n-\t\t     non-speculation.  */\n-\t\t  || (types_must_be_same_for_odr (speculative_outer_type,\n-\t\t\t\t\t\t  outer_type)\n-\t\t      && (maybe_derived_type\n-\t\t\t  == speculative_maybe_derived_type)))\n-\t\tclear_speculation ();\n-\t      return true;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If type is known to be final, do not worry about derived\n-\t\t types.  Testing it here may help us to avoid speculation.  */\n-\t      if (type_all_derivations_known_p (outer_type)\n-\t\t  && (TYPE_FINAL_P (outer_type)\n-\t\t      || (odr_hash\n-\t\t\t  && !get_odr_type (outer_type, true)->derived_types.length())))\n-\t\tmaybe_derived_type = false;\n-\n-\t      /* Type can not contain itself on an non-zero offset.  In that case\n-\t\t just give up.  Still accept the case where size is now known.\n-\t\t Either the second copy may appear past the end of type or within\n-\t\t the non-POD buffer located inside the variably sized type\n-\t\t itself.  */\n-\t      if (cur_offset != 0)\n-\t\tgoto no_useful_type_info;\n-\t      /* If we determined type precisely or we have no clue on\n- \t\t speuclation, we are done.  */\n-\t      if (!maybe_derived_type || !speculative_outer_type)\n-\t\t{\n-\t\t  clear_speculation ();\n-\t          return true;\n-\t\t}\n-\t      /* Otherwise look into speculation now.  */\n-\t      else\n-\t\t{\n-\t\t  speculative = true;\n-\t\t  type = speculative_outer_type;\n-\t\t  cur_offset = speculative_offset;\n-\t\t  continue;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Walk fields and find corresponding on at OFFSET.  */\n-      if (TREE_CODE (type) == RECORD_TYPE)\n-\t{\n-\t  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n-\t    {\n-\t      if (TREE_CODE (fld) != FIELD_DECL)\n-\t\tcontinue;\n-\n-\t      pos = int_bit_position (fld);\n-\t      size = tree_to_uhwi (DECL_SIZE (fld));\n-\t      if (pos <= cur_offset && (pos + size) > cur_offset)\n-\t\tbreak;\n-\t    }\n-\n-\t  if (!fld)\n-\t    goto no_useful_type_info;\n-\n-\t  type = TYPE_MAIN_VARIANT (TREE_TYPE (fld));\n-\t  cur_offset -= pos;\n-\t  /* DECL_ARTIFICIAL represents a basetype.  */\n-\t  if (!DECL_ARTIFICIAL (fld))\n-\t    {\n-\t      if (!speculative)\n-\t\t{\n-\t\t  outer_type = type;\n-\t\t  offset = cur_offset;\n-\t\t  /* As soon as we se an field containing the type,\n-\t\t     we know we are not looking for derivations.  */\n-\t\t  maybe_derived_type = false;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  speculative_outer_type = type;\n-\t\t  speculative_offset = cur_offset;\n-\t\t  speculative_maybe_derived_type = false;\n-\t\t}\n-\t    }\n-\t}\n-      else if (TREE_CODE (type) == ARRAY_TYPE)\n-\t{\n-\t  tree subtype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n-\n-\t  /* Give up if we don't know array size.  */\n-\t  if (!TYPE_SIZE (subtype)\n-\t      || !tree_fits_shwi_p (TYPE_SIZE (subtype))\n-\t      || tree_to_shwi (TYPE_SIZE (subtype)) <= 0\n-\t      || !contains_polymorphic_type_p (subtype))\n-\t    goto no_useful_type_info;\n-\n-\t  HOST_WIDE_INT new_offset = cur_offset % tree_to_shwi (TYPE_SIZE (subtype));\n-\n-\t  /* We may see buffer for placement new.  In this case the expected type\n-\t     can be bigger than the subtype.  */\n-\t  if (TYPE_SIZE (subtype)\n-\t      && (cur_offset\n-\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n-\t\t     : 0)\n-\t\t  > tree_to_uhwi (TYPE_SIZE (type))))\n-\t    goto no_useful_type_info;\n-\n-\t  cur_offset = new_offset;\n-\t  type = subtype;\n-\t  if (!speculative)\n-\t    {\n-\t      outer_type = type;\n-\t      offset = cur_offset;\n-\t      maybe_derived_type = false;\n-\t    }\n-\t  else\n-\t    {\n-\t      speculative_outer_type = type;\n-\t      speculative_offset = cur_offset;\n-\t      speculative_maybe_derived_type = false;\n-\t    }\n-\t}\n-      /* Give up on anything else.  */\n-      else\n-\t{\n-no_useful_type_info:\n-\t  /* We found no way to embedd EXPECTED_TYPE in TYPE.\n-\t     We still permit two special cases - placement new and\n-\t     the case of variadic types containing themselves.  */\n-\t  if (!speculative\n-\t      && (size_unknown || !type\n-\t\t  || possible_placement_new (type, expected_type, cur_offset)))\n-\t    {\n-\t      /* In these weird cases we want to accept the context.\n-\t\t In non-speculative run we have no useful outer_type info\n-\t\t (TODO: we may eventually want to record upper bound on the\n-\t\t  type size that can be used to prune the walk),\n-\t\t but we still want to consider speculation that may\n-\t\t give useful info.  */\n-\t      if (!speculative)\n-\t\t{\n-\t\t  clear_outer_type (expected_type);\n-\t\t  if (speculative_outer_type)\n-\t\t    {\n-\t\t      speculative = true;\n-\t\t      type = speculative_outer_type;\n-\t\t      cur_offset = speculative_offset;\n-\t\t    }\n-\t\t  else\n-\t\t    return true;\n-\t\t}\n-\t      else\n-\t\tclear_speculation ();\n-\t      return true;\n-\t    }\n-\t  else\n-\t    {\n-\t      clear_speculation ();\n-\t      if (speculative)\n-\t\treturn true;\n-\t      clear_outer_type (expected_type);\n-\t      invalid = true; \n-\t      return false;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Return true if OUTER_TYPE contains OTR_TYPE at OFFSET.  */\n-\n-static bool\n-contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n-\t\t tree otr_type)\n-{\n-  ipa_polymorphic_call_context context;\n-  context.offset = offset;\n-  context.outer_type = TYPE_MAIN_VARIANT (outer_type);\n-  context.maybe_derived_type = false;\n-  return context.restrict_to_inner_class (otr_type);\n-}\n-\n /* Lookup base of BINFO that has virtual table VTABLE with OFFSET.  */\n \n-static tree\n+tree\n subbinfo_with_vtable_at_offset (tree binfo, unsigned HOST_WIDE_INT offset,\n \t\t\t\ttree vtable)\n {\n@@ -2438,1117 +2073,6 @@ vtable_pointer_value_to_binfo (const_tree t)\n \t\t\t\t\t offset, vtable);\n }\n \n-/* We know that the instance is stored in variable or parameter\n-   (not dynamically allocated) and we want to disprove the fact\n-   that it may be in construction at invocation of CALL.\n-\n-   For the variable to be in construction we actually need to\n-   be in constructor of corresponding global variable or\n-   the inline stack of CALL must contain the constructor.\n-   Check this condition.  This check works safely only before\n-   IPA passes, because inline stacks may become out of date\n-   later.  */\n-\n-bool\n-decl_maybe_in_construction_p (tree base, tree outer_type,\n-\t\t\t      gimple call, tree function)\n-{\n-  outer_type = TYPE_MAIN_VARIANT (outer_type);\n-  gcc_assert (DECL_P (base));\n-\n-  /* After inlining the code unification optimizations may invalidate\n-     inline stacks.  Also we need to give up on global variables after\n-     IPA, because addresses of these may have been propagated to their\n-     constructors.  */\n-  if (DECL_STRUCT_FUNCTION (function)->after_inlining)\n-    return true;\n-\n-  /* Pure functions can not do any changes on the dynamic type;\n-     that require writting to memory.  */\n-  if (!auto_var_in_fn_p (base, function)\n-      && flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n-    return false;\n-\n-  for (tree block = gimple_block (call); block && TREE_CODE (block) == BLOCK;\n-       block = BLOCK_SUPERCONTEXT (block))\n-    if (BLOCK_ABSTRACT_ORIGIN (block)\n-\t&& TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n-      {\n-\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n-\n-\tif (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n-\t    || (!DECL_CXX_CONSTRUCTOR_P (fn)\n-\t\t&& !DECL_CXX_DESTRUCTOR_P (fn)))\n-\t  {\n-\t    /* Watch for clones where we constant propagated the first\n-\t       argument (pointer to the instance).  */\n-\t    fn = DECL_ABSTRACT_ORIGIN (fn);\n-\t    if (!fn\n-\t\t|| !is_global_var (base)\n-\t        || TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n-\t\t|| (!DECL_CXX_CONSTRUCTOR_P (fn)\n-\t\t    && !DECL_CXX_DESTRUCTOR_P (fn)))\n-\t      continue;\n-\t  }\n-\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n-\t  continue;\n-\n-\t/* FIXME: this can go away once we have ODR types equivalency on\n-\t   LTO level.  */\n-\tif (in_lto_p && !polymorphic_type_binfo_p (TYPE_BINFO (outer_type)))\n-\t  return true;\n-\ttree type = TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (fn)));\n-\tif (types_same_for_odr (type, outer_type))\n-\t  return true;\n-      }\n-\n-  if (TREE_CODE (base) == VAR_DECL\n-      && is_global_var (base))\n-    {\n-      if (TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n-\t  || (!DECL_CXX_CONSTRUCTOR_P (function)\n-\t      && !DECL_CXX_DESTRUCTOR_P (function)))\n-\t{\n-\t  if (!DECL_ABSTRACT_ORIGIN (function))\n-\t    return false;\n-\t  /* Watch for clones where we constant propagated the first\n-\t     argument (pointer to the instance).  */\n-\t  function = DECL_ABSTRACT_ORIGIN (function);\n-\t  if (!function\n-\t      || TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n-\t      || (!DECL_CXX_CONSTRUCTOR_P (function)\n-\t\t  && !DECL_CXX_DESTRUCTOR_P (function)))\n-\t    return false;\n-\t}\n-      /* FIXME: this can go away once we have ODR types equivalency on\n-\t LTO level.  */\n-      if (in_lto_p && !polymorphic_type_binfo_p (TYPE_BINFO (outer_type)))\n-\treturn true;\n-      tree type = TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (function)));\n-      if (types_same_for_odr (type, outer_type))\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n-/* Dump human readable context to F.  */\n-\n-void\n-ipa_polymorphic_call_context::dump (FILE *f) const\n-{\n-  fprintf (f, \"    \");\n-  if (invalid)\n-    fprintf (f, \"Call is known to be undefined\\n\");\n-  else\n-    {\n-      if (!outer_type && !offset && !speculative_outer_type)\n-\tfprintf (f, \"Empty context\\n\");\n-      if (outer_type || offset)\n-\t{\n-\t  fprintf (f, \"Outer type:\");\n-\t  print_generic_expr (f, outer_type, TDF_SLIM);\n-\t  if (maybe_derived_type)\n-\t    fprintf (f, \" (or a derived type)\");\n-\t  if (maybe_in_construction)\n-\t    fprintf (f, \" (maybe in construction)\");\n-\t  fprintf (f, \" offset \"HOST_WIDE_INT_PRINT_DEC,\n-\t\t   offset);\n-\t}\n-      if (speculative_outer_type)\n-\t{\n-\t  fprintf (f, \" speculative outer type:\");\n-\t  print_generic_expr (f, speculative_outer_type, TDF_SLIM);\n-\t  if (speculative_maybe_derived_type)\n-\t    fprintf (f, \" (or a derived type)\");\n-\t  fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC,\n-\t\t   speculative_offset);\n-\t}\n-    }\n-  fprintf(f, \"\\n\");\n-}\n-\n-/* Print context to stderr.  */\n-\n-void\n-ipa_polymorphic_call_context::debug () const\n-{\n-  dump (stderr);\n-}\n-\n-/* Stream out the context to OB.  */\n-\n-void\n-ipa_polymorphic_call_context::stream_out (struct output_block *ob) const\n-{\n-  struct bitpack_d bp = bitpack_create (ob->main_stream);\n-\n-  bp_pack_value (&bp, invalid, 1);\n-  bp_pack_value (&bp, maybe_in_construction, 1);\n-  bp_pack_value (&bp, maybe_derived_type, 1);\n-  bp_pack_value (&bp, speculative_maybe_derived_type, 1);\n-  bp_pack_value (&bp, outer_type != NULL, 1);\n-  bp_pack_value (&bp, offset != 0, 1);\n-  bp_pack_value (&bp, speculative_outer_type != NULL, 1);\n-  streamer_write_bitpack (&bp);\n-\n-  if (outer_type != NULL)\n-    stream_write_tree (ob, outer_type, true);\n-  if (offset)\n-    streamer_write_hwi (ob, offset);\n-  if (speculative_outer_type != NULL)\n-    {\n-      stream_write_tree (ob, speculative_outer_type, true);\n-      streamer_write_hwi (ob, speculative_offset);\n-    }\n-  else\n-    gcc_assert (!speculative_offset);\n-}\n-\n-/* Stream in the context from IB and DATA_IN.  */\n-\n-void\n-ipa_polymorphic_call_context::stream_in (struct lto_input_block *ib,\n-\t\t\t\t\t struct data_in *data_in)\n-{\n-  struct bitpack_d bp = streamer_read_bitpack (ib);\n-\n-  invalid = bp_unpack_value (&bp, 1);\n-  maybe_in_construction = bp_unpack_value (&bp, 1);\n-  maybe_derived_type = bp_unpack_value (&bp, 1);\n-  speculative_maybe_derived_type = bp_unpack_value (&bp, 1);\n-  bool outer_type_p = bp_unpack_value (&bp, 1);\n-  bool offset_p = bp_unpack_value (&bp, 1);\n-  bool speculative_outer_type_p = bp_unpack_value (&bp, 1);\n-\n-  if (outer_type_p)\n-    outer_type = stream_read_tree (ib, data_in);\n-  else\n-    outer_type = NULL;\n-  if (offset_p)\n-    offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n-  else\n-    offset = 0;\n-  if (speculative_outer_type_p)\n-    {\n-      speculative_outer_type = stream_read_tree (ib, data_in);\n-      speculative_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n-    }\n-  else\n-    {\n-      speculative_outer_type = NULL;\n-      speculative_offset = 0;\n-    }\n-}\n-\n-/* Proudce polymorphic call context for call method of instance\n-   that is located within BASE (that is assumed to be a decl) at offset OFF. */\n-\n-void\n-ipa_polymorphic_call_context::set_by_decl (tree base, HOST_WIDE_INT off)\n-{\n-  gcc_assert (DECL_P (base));\n-\n-  outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n-  offset = off;\n-  clear_speculation ();\n-  /* Make very conservative assumption that all objects\n-     may be in construction. \n- \n-     It is up to caller to revisit this via\n-     get_dynamic_type or decl_maybe_in_construction_p.  */\n-  maybe_in_construction = true;\n-  maybe_derived_type = false;\n-}\n-\n-/* CST is an invariant (address of decl), try to get meaningful\n-   polymorphic call context for polymorphic call of method \n-   if instance of OTR_TYPE that is located at offset OFF of this invariant.\n-   Return FALSE if nothing meaningful can be found.  */\n-\n-bool\n-ipa_polymorphic_call_context::set_by_invariant (tree cst,\n-\t\t\t\t\t\ttree otr_type,\n-\t\t\t\t\t\tHOST_WIDE_INT off)\n-{\n-  HOST_WIDE_INT offset2, size, max_size;\n-  tree base;\n-\n-  invalid = false;\n-  off = 0;\n-  clear_outer_type (otr_type);\n-\n-  if (TREE_CODE (cst) != ADDR_EXPR)\n-    return false;\n-\n-  cst = TREE_OPERAND (cst, 0);\n-  base = get_ref_base_and_extent (cst, &offset2, &size, &max_size);\n-  if (!DECL_P (base) || max_size == -1 || max_size != size)\n-    return false;\n-\n-  /* Only type inconsistent programs can have otr_type that is\n-     not part of outer type.  */\n-  if (otr_type && !contains_type_p (TREE_TYPE (base), off, otr_type))\n-    return false;\n-\n-  set_by_decl (base, off);\n-  return true;\n-}\n-\n-/* See if OP is SSA name initialized as a copy or by single assignment.\n-   If so, walk the SSA graph up.  */\n-\n-static tree\n-walk_ssa_copies (tree op)\n-{\n-  STRIP_NOPS (op);\n-  while (TREE_CODE (op) == SSA_NAME\n-\t && !SSA_NAME_IS_DEFAULT_DEF (op)\n-\t && SSA_NAME_DEF_STMT (op)\n-\t && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n-    {\n-      if (gimple_assign_load_p (SSA_NAME_DEF_STMT (op)))\n-\treturn op;\n-      op = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op));\n-      STRIP_NOPS (op);\n-    }\n-  return op;\n-}\n-\n-/* Create polymorphic call context from IP invariant CST.\n-   This is typically &global_var.\n-   OTR_TYPE specify type of polymorphic call or NULL if unknown, OFF\n-   is offset of call.  */\n-\n-ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree cst,\n-\t\t\t\t\t\t\t    tree otr_type,\n-\t\t\t\t\t\t\t    HOST_WIDE_INT off)\n-{\n-  clear_speculation ();\n-  set_by_invariant (cst, otr_type, off);\n-}\n-\n-/* Build context for pointer REF contained in FNDECL at statement STMT.\n-   if INSTANCE is non-NULL, return pointer to the object described by\n-   the context or DECL where context is contained in.  */\n-\n-ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n-\t\t\t\t\t\t\t    tree ref,\n-\t\t\t\t\t\t\t    gimple stmt,\n-\t\t\t\t\t\t\t    tree *instance)\n-{\n-  tree otr_type = NULL;\n-  tree base_pointer;\n-\n-  if (TREE_CODE (ref) == OBJ_TYPE_REF)\n-    {\n-      otr_type = obj_type_ref_class (ref);\n-      base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n-    }\n-  else\n-    base_pointer = ref;\n-\n-  /* Set up basic info in case we find nothing interesting in the analysis.  */\n-  clear_speculation ();\n-  clear_outer_type (otr_type);\n-  invalid = false;\n-\n-  /* Walk SSA for outer object.  */\n-  do \n-    {\n-      base_pointer = walk_ssa_copies (base_pointer);\n-      if (TREE_CODE (base_pointer) == ADDR_EXPR)\n-\t{\n-\t  HOST_WIDE_INT size, max_size;\n-\t  HOST_WIDE_INT offset2;\n-\t  tree base = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n-\t\t\t\t\t       &offset2, &size, &max_size);\n-\n-\t  /* If this is a varying address, punt.  */\n-\t  if ((TREE_CODE (base) == MEM_REF || DECL_P (base))\n-\t      && max_size != -1\n-\t      && max_size == size)\n-\t    {\n-\t      /* We found dereference of a pointer.  Type of the pointer\n-\t\t and MEM_REF is meaningless, but we can look futher.  */\n-\t      if (TREE_CODE (base) == MEM_REF)\n-\t\t{\n-\t\t  base_pointer = TREE_OPERAND (base, 0);\n-\t\t  offset\n-\t\t    += offset2 + mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n-\t\t  outer_type = NULL;\n-\t\t}\n-\t      /* We found base object.  In this case the outer_type\n-\t\t is known.  */\n-\t      else if (DECL_P (base))\n-\t\t{\n-\t\t  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (base)));\n-\n-\t\t  /* Only type inconsistent programs can have otr_type that is\n-\t\t     not part of outer type.  */\n-\t\t  if (otr_type\n-\t\t      && !contains_type_p (TREE_TYPE (base),\n-\t\t\t\t\t   offset + offset2, otr_type))\n-\t\t    {\n-\t\t      invalid = true;\n-\t\t      if (instance)\n-\t\t\t*instance = base_pointer;\n-\t\t      return;\n-\t\t    }\n-\t\t  set_by_decl (base, offset + offset2);\n-\t\t  if (maybe_in_construction && stmt)\n-\t\t    maybe_in_construction\n-\t\t     = decl_maybe_in_construction_p (base,\n-\t\t\t\t\t\t     outer_type,\n-\t\t\t\t\t\t     stmt,\n-\t\t\t\t\t\t     fndecl);\n-\t\t  if (instance)\n-\t\t    *instance = base;\n-\t\t  return;\n-\t\t}\n-\t      else\n-\t\tbreak;\n-\t    }\n-\t  else\n-\t    break;\n-\t}\n-      else if (TREE_CODE (base_pointer) == POINTER_PLUS_EXPR\n-\t       && tree_fits_uhwi_p (TREE_OPERAND (base_pointer, 1)))\n-\t{\n-\t  offset += tree_to_shwi (TREE_OPERAND (base_pointer, 1))\n-\t\t    * BITS_PER_UNIT;\n-\t  base_pointer = TREE_OPERAND (base_pointer, 0);\n-\t}\n-      else\n-\tbreak;\n-    }\n-  while (true);\n-\n-  /* Try to determine type of the outer object.  */\n-  if (TREE_CODE (base_pointer) == SSA_NAME\n-      && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n-      && TREE_CODE (SSA_NAME_VAR (base_pointer)) == PARM_DECL)\n-    {\n-      /* See if parameter is THIS pointer of a method.  */\n-      if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE\n-\t  && SSA_NAME_VAR (base_pointer) == DECL_ARGUMENTS (fndecl))\n-\t{\n-\t  outer_type\n-\t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n-\t  gcc_assert (TREE_CODE (outer_type) == RECORD_TYPE);\n-\n-\t  /* Dynamic casting has possibly upcasted the type\n-\t     in the hiearchy.  In this case outer type is less\n-\t     informative than inner type and we should forget\n-\t     about it.  */\n-\t  if (otr_type\n-\t      && !contains_type_p (outer_type, offset,\n-\t\t\t\t   otr_type))\n-\t    {\n-\t      outer_type = NULL;\n-\t      if (instance)\n-\t\t*instance = base_pointer;\n-\t      return;\n-\t    }\n-\n-\t  /* If the function is constructor or destructor, then\n-\t     the type is possibly in construction, but we know\n-\t     it is not derived type.  */\n-\t  if (DECL_CXX_CONSTRUCTOR_P (fndecl)\n-\t      || DECL_CXX_DESTRUCTOR_P (fndecl))\n-\t    {\n-\t      maybe_in_construction = true;\n-\t      maybe_derived_type = false;\n-\t    }\n-\t  else\n-\t    {\n-\t      maybe_derived_type = true;\n-\t      maybe_in_construction = false;\n-\t    }\n-\t  if (instance)\n-\t    *instance = base_pointer;\n-\t  return;\n-\t}\n-      /* Non-PODs passed by value are really passed by invisible\n-\t reference.  In this case we also know the type of the\n-\t object.  */\n-      if (DECL_BY_REFERENCE (SSA_NAME_VAR (base_pointer)))\n-\t{\n-\t  outer_type\n-\t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n-\t  gcc_assert (!POINTER_TYPE_P (outer_type));\n-\t  /* Only type inconsistent programs can have otr_type that is\n-\t     not part of outer type.  */\n-\t  if (!contains_type_p (outer_type, offset,\n-\t\t\t        otr_type))\n-\t    { \n-\t      invalid = true;\n-\t      if (instance)\n-\t\t*instance = base_pointer;\n-\t      return;\n-\t    }\n-\t  maybe_derived_type = false;\n-\t  maybe_in_construction = false;\n-\t  if (instance)\n-\t    *instance = base_pointer;\n-\t  return;\n-\t}\n-    }\n-\n-  tree base_type = TREE_TYPE (base_pointer);\n-\n-  if (TREE_CODE (base_pointer) == SSA_NAME\n-      && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n-      && TREE_CODE (SSA_NAME_VAR (base_pointer)) != PARM_DECL)\n-    {\n-      invalid = true;\n-      if (instance)\n-\t*instance = base_pointer;\n-      return;\n-    }\n-  if (TREE_CODE (base_pointer) == SSA_NAME\n-      && SSA_NAME_DEF_STMT (base_pointer)\n-      && gimple_assign_single_p (SSA_NAME_DEF_STMT (base_pointer)))\n-    base_type = TREE_TYPE (gimple_assign_rhs1\n-\t\t\t    (SSA_NAME_DEF_STMT (base_pointer)));\n- \n-  if (POINTER_TYPE_P (base_type)\n-      && (otr_type\n-\t  || !contains_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n-\t\t\t       offset,\n-\t\t\t       otr_type)))\n-    {\n-      speculative_outer_type = TYPE_MAIN_VARIANT\n-\t\t\t\t\t  (TREE_TYPE (base_type));\n-      speculative_offset = offset;\n-      speculative_maybe_derived_type = true;\n-    }\n-  /* TODO: There are multiple ways to derive a type.  For instance\n-     if BASE_POINTER is passed to an constructor call prior our refernece.\n-     We do not make this type of flow sensitive analysis yet.  */\n-  if (instance)\n-    *instance = base_pointer;\n-  return;\n-}\n-\n-/* Structure to be passed in between detect_type_change and\n-   check_stmt_for_type_change.  */\n-\n-struct type_change_info\n-{\n-  /* Offset into the object where there is the virtual method pointer we are\n-     looking for.  */\n-  HOST_WIDE_INT offset;\n-  /* The declaration or SSA_NAME pointer of the base that we are checking for\n-     type change.  */\n-  tree instance;\n-  /* The reference to virtual table pointer used.  */\n-  tree vtbl_ptr_ref;\n-  tree otr_type;\n-  /* If we actually can tell the type that the object has changed to, it is\n-     stored in this field.  Otherwise it remains NULL_TREE.  */\n-  tree known_current_type;\n-  HOST_WIDE_INT known_current_offset;\n-\n-  /* Set to true if dynamic type change has been detected.  */\n-  bool type_maybe_changed;\n-  /* Set to true if multiple types have been encountered.  known_current_type\n-     must be disregarded in that case.  */\n-  bool multiple_types_encountered;\n-  /* Set to true if we possibly missed some dynamic type changes and we should\n-     consider the set to be speculative.  */\n-  bool speculative;\n-  bool seen_unanalyzed_store;\n-};\n-\n-/* Return true if STMT is not call and can modify a virtual method table pointer.\n-   We take advantage of fact that vtable stores must appear within constructor\n-   and destructor functions.  */\n-\n-static bool\n-noncall_stmt_may_be_vtbl_ptr_store (gimple stmt)\n-{\n-  if (is_gimple_assign (stmt))\n-    {\n-      tree lhs = gimple_assign_lhs (stmt);\n-\n-      if (gimple_clobber_p (stmt))\n-\treturn false;\n-      if (!AGGREGATE_TYPE_P (TREE_TYPE (lhs)))\n-\t{\n-\t  if (flag_strict_aliasing\n-\t      && !POINTER_TYPE_P (TREE_TYPE (lhs)))\n-\t    return false;\n-\n-\t  if (TREE_CODE (lhs) == COMPONENT_REF\n-\t      && !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n-\t    return false;\n-\t  /* In the future we might want to use get_base_ref_and_offset to find\n-\t     if there is a field corresponding to the offset and if so, proceed\n-\t     almost like if it was a component ref.  */\n-\t}\n-    }\n-\n-  /* Code unification may mess with inline stacks.  */\n-  if (cfun->after_inlining)\n-    return true;\n-\n-  /* Walk the inline stack and watch out for ctors/dtors.\n-     TODO: Maybe we can require the store to appear in toplevel\n-     block of CTOR/DTOR.  */\n-  for (tree block = gimple_block (stmt); block && TREE_CODE (block) == BLOCK;\n-       block = BLOCK_SUPERCONTEXT (block))\n-    if (BLOCK_ABSTRACT_ORIGIN (block)\n-\t&& TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n-      {\n-\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n-\n-\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n-\t  return false;\n-\treturn (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n-\t\t&& (DECL_CXX_CONSTRUCTOR_P (fn)\n-\t\t    || DECL_CXX_DESTRUCTOR_P (fn)));\n-      }\n-  return (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE\n-\t  && (DECL_CXX_CONSTRUCTOR_P (current_function_decl)\n-\t      || DECL_CXX_DESTRUCTOR_P (current_function_decl)));\n-}\n-\n-/* If STMT can be proved to be an assignment to the virtual method table\n-   pointer of ANALYZED_OBJ and the type associated with the new table\n-   identified, return the type.  Otherwise return NULL_TREE.  */\n-\n-static tree\n-extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n-\t\t\t       HOST_WIDE_INT *type_offset)\n-{\n-  HOST_WIDE_INT offset, size, max_size;\n-  tree lhs, rhs, base;\n-\n-  if (!gimple_assign_single_p (stmt))\n-    return NULL_TREE;\n-\n-  lhs = gimple_assign_lhs (stmt);\n-  rhs = gimple_assign_rhs1 (stmt);\n-  if (TREE_CODE (lhs) != COMPONENT_REF\n-      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n-     {\n-\tif (dump_file)\n-\t  fprintf (dump_file, \"  LHS is not virtual table.\\n\");\n-\treturn NULL_TREE;\n-     }\n-\n-  if (tci->vtbl_ptr_ref && operand_equal_p (lhs, tci->vtbl_ptr_ref, 0))\n-    ;\n-  else\n-    {\n-      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n-      if (offset != tci->offset\n-\t  || size != POINTER_SIZE\n-\t  || max_size != POINTER_SIZE)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    wrong offset %i!=%i or size %i\\n\",\n-\t\t     (int)offset, (int)tci->offset, (int)size);\n-\t  return NULL_TREE;\n-\t}\n-      if (DECL_P (tci->instance))\n-\t{\n-\t  if (base != tci->instance)\n-\t    {\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \"    base:\");\n-\t\t  print_generic_expr (dump_file, base, TDF_SLIM);\n-\t\t  fprintf (dump_file, \" does not match instance:\");\n-\t\t  print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n-      else if (TREE_CODE (base) == MEM_REF)\n-\t{\n-\t  if (!operand_equal_p (tci->instance, TREE_OPERAND (base, 0), 0)\n-\t      || !integer_zerop (TREE_OPERAND (base, 1)))\n-\t    {\n-\t      if (dump_file)\n-\t\t{\n-\t\t  fprintf (dump_file, \"    base mem ref:\");\n-\t\t  print_generic_expr (dump_file, base, TDF_SLIM);\n-\t\t  fprintf (dump_file, \" has nonzero offset or does not match instance:\");\n-\t\t  print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\t      return NULL_TREE;\n-\t    }\n-\t}\n-      else if (!operand_equal_p (tci->instance, base, 0)\n-\t       || tci->offset)\n-\t{\n-\t  if (dump_file)\n-\t    {\n-\t      fprintf (dump_file, \"    base:\");\n-\t      print_generic_expr (dump_file, base, TDF_SLIM);\n-\t      fprintf (dump_file, \" does not match instance:\");\n-\t      print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n-\t      fprintf (dump_file, \" with offset %i\\n\", (int)tci->offset);\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n-    }\n-\n-  tree vtable;\n-  unsigned HOST_WIDE_INT offset2;\n-\n-  if (!vtable_pointer_value_to_vtable (rhs, &vtable, &offset2))\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"    Failed to lookup binfo\\n\");\n-      return NULL;\n-    }\n-\n-  tree binfo = subbinfo_with_vtable_at_offset (TYPE_BINFO (DECL_CONTEXT (vtable)),\n-\t\t\t\t\t       offset2, vtable);\n-  if (!binfo)\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \"    Construction vtable used\\n\");\n-      /* FIXME: We should suport construction contextes.  */\n-      return NULL;\n-    }\n- \n-  *type_offset = tree_to_shwi (BINFO_OFFSET (binfo)) * BITS_PER_UNIT;\n-  return DECL_CONTEXT (vtable);\n-}\n-\n-/* Record dynamic type change of TCI to TYPE.  */\n-\n-void\n-record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset)\n-{\n-  if (dump_file)\n-    {\n-      if (type)\n-\t{\n-          fprintf (dump_file, \"  Recording type: \");\n-\t  print_generic_expr (dump_file, type, TDF_SLIM);\n-          fprintf (dump_file, \" at offset %i\\n\", (int)offset);\n-\t}\n-     else\n-       fprintf (dump_file, \"  Recording unknown type\\n\");\n-    }\n-\n-  /* If we found a constructor of type that is not polymorphic or\n-     that may contain the type in question as a field (not as base),\n-     restrict to the inner class first to make type matching bellow\n-     happier.  */\n-  if (type\n-      && (offset\n-          || (TREE_CODE (type) != RECORD_TYPE\n-\t      || !polymorphic_type_binfo_p (TYPE_BINFO (type)))))\n-    {\n-      ipa_polymorphic_call_context context;\n-\n-      context.offset = offset;\n-      context.outer_type = type;\n-      context.maybe_in_construction = false;\n-      context.maybe_derived_type = false;\n-      /* If we failed to find the inner type, we know that the call\n-\t would be undefined for type produced here.  */\n-      if (!context.restrict_to_inner_class (tci->otr_type))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  Ignoring; does not contain otr_type\\n\");\n-\t  return;\n-\t}\n-      /* Watch for case we reached an POD type and anticipate placement\n-\t new.  */\n-      if (!context.maybe_derived_type)\n-\t{\n-          type = context.outer_type;\n-          offset = context.offset;\n-\t}\n-    }\n-  if (tci->type_maybe_changed\n-      && (!types_same_for_odr (type, tci->known_current_type)\n-\t  || offset != tci->known_current_offset))\n-    tci->multiple_types_encountered = true;\n-  tci->known_current_type = TYPE_MAIN_VARIANT (type);\n-  tci->known_current_offset = offset;\n-  tci->type_maybe_changed = true;\n-}\n-\n-/* Callback of walk_aliased_vdefs and a helper function for\n-   detect_type_change to check whether a particular statement may modify\n-   the virtual table pointer, and if possible also determine the new type of\n-   the (sub-)object.  It stores its result into DATA, which points to a\n-   type_change_info structure.  */\n-\n-static bool\n-check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n-{\n-  gimple stmt = SSA_NAME_DEF_STMT (vdef);\n-  struct type_change_info *tci = (struct type_change_info *) data;\n-  tree fn;\n-\n-  /* If we already gave up, just terminate the rest of walk.  */\n-  if (tci->multiple_types_encountered)\n-    return true;\n-\n-  if (is_gimple_call (stmt))\n-    {\n-      if (gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE))\n-\treturn false;\n-\n-      /* Check for a constructor call.  */\n-      if ((fn = gimple_call_fndecl (stmt)) != NULL_TREE\n-\t  && DECL_CXX_CONSTRUCTOR_P (fn)\n-\t  && TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n-\t  && gimple_call_num_args (stmt))\n-      {\n-\ttree op = walk_ssa_copies (gimple_call_arg (stmt, 0));\n-\ttree type = method_class_type (TREE_TYPE (fn));\n-\tHOST_WIDE_INT offset = 0, size, max_size;\n-\n-\tif (dump_file)\n-\t  {\n-\t    fprintf (dump_file, \"  Checking constructor call: \");\n-\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t  }\n-\n-\t/* See if THIS parameter seems like instance pointer.  */\n-\tif (TREE_CODE (op) == ADDR_EXPR)\n-\t  {\n-\t    op = get_ref_base_and_extent (TREE_OPERAND (op, 0),\n-\t\t\t\t\t  &offset, &size, &max_size);\n-\t    if (size != max_size || max_size == -1)\n-\t      {\n-                tci->speculative = true;\n-\t        return false;\n-\t      }\n-\t    if (op && TREE_CODE (op) == MEM_REF)\n-\t      {\n-\t\tif (!tree_fits_shwi_p (TREE_OPERAND (op, 1)))\n-\t\t  {\n-                    tci->speculative = true;\n-\t\t    return false;\n-\t\t  }\n-\t\toffset += tree_to_shwi (TREE_OPERAND (op, 1))\n-\t\t\t  * BITS_PER_UNIT;\n-\t\top = TREE_OPERAND (op, 0);\n-\t      }\n-\t    else if (DECL_P (op))\n-\t      ;\n-\t    else\n-\t      {\n-                tci->speculative = true;\n-\t        return false;\n-\t      }\n-\t    op = walk_ssa_copies (op);\n-\t  }\n-\tif (operand_equal_p (op, tci->instance, 0)\n-\t    && TYPE_SIZE (type)\n-\t    && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t    && tree_fits_shwi_p (TYPE_SIZE (type))\n-\t    && tree_to_shwi (TYPE_SIZE (type)) + offset > tci->offset)\n-\t  {\n-\t    record_known_type (tci, type, tci->offset - offset);\n-\t    return true;\n-\t  }\n-      }\n-     /* Calls may possibly change dynamic type by placement new. Assume\n-        it will not happen, but make result speculative only.  */\n-     if (dump_file)\n-\t{\n-          fprintf (dump_file, \"  Function call may change dynamic type:\");\n-\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t}\n-     tci->speculative = true;\n-     return false;\n-   }\n-  /* Check for inlined virtual table store.  */\n-  else if (noncall_stmt_may_be_vtbl_ptr_store (stmt))\n-    {\n-      tree type;\n-      HOST_WIDE_INT offset = 0;\n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \"  Checking vtbl store: \");\n-\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n-\t}\n-\n-      type = extr_type_from_vtbl_ptr_store (stmt, tci, &offset);\n-      gcc_assert (!type || TYPE_MAIN_VARIANT (type) == type);\n-      if (!type)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  Unanalyzed store may change type.\\n\");\n-\t  tci->seen_unanalyzed_store = true;\n-\t  tci->speculative = true;\n-\t}\n-      else\n-        record_known_type (tci, type, offset);\n-      return true;\n-    }\n-  else\n-    return false;\n-}\n-\n-/* THIS is polymorphic call context obtained from get_polymorphic_context.\n-   OTR_OBJECT is pointer to the instance returned by OBJ_TYPE_REF_OBJECT.\n-   INSTANCE is pointer to the outer instance as returned by\n-   get_polymorphic_context.  To avoid creation of temporary expressions,\n-   INSTANCE may also be an declaration of get_polymorphic_context found the\n-   value to be in static storage.\n-\n-   If the type of instance is not fully determined\n-   (either OUTER_TYPE is unknown or MAYBE_IN_CONSTRUCTION/INCLUDE_DERIVED_TYPES\n-   is set), try to walk memory writes and find the actual construction of the\n-   instance.\n-\n-   We do not include this analysis in the context analysis itself, because\n-   it needs memory SSA to be fully built and the walk may be expensive.\n-   So it is not suitable for use withing fold_stmt and similar uses.  */\n-\n-bool\n-ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n-\t\t\t\t\t\ttree otr_object,\n-\t\t\t\t\t\ttree otr_type,\n-\t\t\t\t\t\tgimple call)\n-{\n-  struct type_change_info tci;\n-  ao_ref ao;\n-  bool function_entry_reached = false;\n-  tree instance_ref = NULL;\n-  gimple stmt = call;\n-  /* Remember OFFSET before it is modified by restrict_to_inner_class.\n-     This is because we do not update INSTANCE when walking inwards.  */\n-  HOST_WIDE_INT instance_offset = offset;\n-\n-  otr_type = TYPE_MAIN_VARIANT (otr_type);\n-\n-  /* Walk into inner type. This may clear maybe_derived_type and save us\n-     from useless work.  It also makes later comparsions with static type\n-     easier.  */\n-  if (outer_type)\n-    {\n-      if (!restrict_to_inner_class (otr_type))\n-        return false;\n-    }\n-\n-  if (!maybe_in_construction && !maybe_derived_type)\n-    return false;\n-\n-  /* We need to obtain refernce to virtual table pointer.  It is better\n-     to look it up in the code rather than build our own.  This require bit\n-     of pattern matching, but we end up verifying that what we found is\n-     correct. \n-\n-     What we pattern match is:\n-\n-       tmp = instance->_vptr.A;   // vtbl ptr load\n-       tmp2 = tmp[otr_token];\t  // vtable lookup\n-       OBJ_TYPE_REF(tmp2;instance->0) (instance);\n- \n-     We want to start alias oracle walk from vtbl pointer load,\n-     but we may not be able to identify it, for example, when PRE moved the\n-     load around.  */\n-\n-  if (gimple_code (call) == GIMPLE_CALL)\n-    {\n-      tree ref = gimple_call_fn (call);\n-      HOST_WIDE_INT offset2, size, max_size;\n-\n-      if (TREE_CODE (ref) == OBJ_TYPE_REF)\n-\t{\n-\t  ref = OBJ_TYPE_REF_EXPR (ref);\n-\t  ref = walk_ssa_copies (ref);\n-\n-\t  /* Check if definition looks like vtable lookup.  */\n-\t  if (TREE_CODE (ref) == SSA_NAME\n-\t      && !SSA_NAME_IS_DEFAULT_DEF (ref)\n-\t      && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref))\n-\t      && TREE_CODE (gimple_assign_rhs1\n-\t\t\t     (SSA_NAME_DEF_STMT (ref))) == MEM_REF)\n-\t    {\n-\t      ref = get_base_address\n-\t\t     (TREE_OPERAND (gimple_assign_rhs1\n-\t\t\t\t     (SSA_NAME_DEF_STMT (ref)), 0));\n-\t      ref = walk_ssa_copies (ref);\n-\t      /* Find base address of the lookup and see if it looks like\n-\t\t vptr load.  */\n-\t      if (TREE_CODE (ref) == SSA_NAME\n-\t\t  && !SSA_NAME_IS_DEFAULT_DEF (ref)\n-\t\t  && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref)))\n-\t\t{\n-\t\t  tree ref_exp = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ref));\n-\t\t  tree base_ref = get_ref_base_and_extent\n-\t\t\t\t   (ref_exp, &offset2, &size, &max_size);\n-\n-\t\t  /* Finally verify that what we found looks like read from OTR_OBJECT\n-\t\t     or from INSTANCE with offset OFFSET.  */\n-\t\t  if (base_ref\n-\t\t      && ((TREE_CODE (base_ref) == MEM_REF\n-\t\t           && ((offset2 == instance_offset\n-\t\t                && TREE_OPERAND (base_ref, 0) == instance)\n-\t\t\t       || (!offset2 && TREE_OPERAND (base_ref, 0) == otr_object)))\n-\t\t\t  || (DECL_P (instance) && base_ref == instance\n-\t\t\t      && offset2 == instance_offset)))\n-\t\t    {\n-\t\t      stmt = SSA_NAME_DEF_STMT (ref);\n-\t\t      instance_ref = ref_exp;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-    }\n- \n-  /* If we failed to look up the refernece in code, build our own.  */\n-  if (!instance_ref)\n-    {\n-      /* If the statement in question does not use memory, we can't tell\n-\t anything.  */\n-      if (!gimple_vuse (stmt))\n-\treturn false;\n-      ao_ref_init_from_ptr_and_size (&ao, otr_object, NULL);\n-    }\n-  else\n-  /* Otherwise use the real reference.  */\n-    ao_ref_init (&ao, instance_ref);\n-\n-  /* We look for vtbl pointer read.  */\n-  ao.size = POINTER_SIZE;\n-  ao.max_size = ao.size;\n-  ao.ref_alias_set\n-    = get_deref_alias_set (TREE_TYPE (BINFO_VTABLE (TYPE_BINFO (otr_type))));\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Determining dynamic type for call: \");\n-      print_gimple_stmt (dump_file, call, 0, 0);\n-      fprintf (dump_file, \"  Starting walk at: \");\n-      print_gimple_stmt (dump_file, stmt, 0, 0);\n-      fprintf (dump_file, \"  instance pointer: \");\n-      print_generic_expr (dump_file, otr_object, TDF_SLIM);\n-      fprintf (dump_file, \"  Outer instance pointer: \");\n-      print_generic_expr (dump_file, instance, TDF_SLIM);\n-      fprintf (dump_file, \" offset: %i (bits)\", (int)offset);\n-      fprintf (dump_file, \" vtbl reference: \");\n-      print_generic_expr (dump_file, instance_ref, TDF_SLIM);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  tci.offset = offset;\n-  tci.instance = instance;\n-  tci.vtbl_ptr_ref = instance_ref;\n-  gcc_assert (TREE_CODE (instance) != MEM_REF);\n-  tci.known_current_type = NULL_TREE;\n-  tci.known_current_offset = 0;\n-  tci.otr_type = otr_type;\n-  tci.type_maybe_changed = false;\n-  tci.multiple_types_encountered = false;\n-  tci.speculative = false;\n-  tci.seen_unanalyzed_store = false;\n-\n-  walk_aliased_vdefs (&ao, gimple_vuse (stmt), check_stmt_for_type_change,\n-\t\t      &tci, NULL, &function_entry_reached);\n-\n-  /* If we did not find any type changing statements, we may still drop\n-     maybe_in_construction flag if the context already have outer type. \n-\n-     Here we make special assumptions about both constructors and\n-     destructors which are all the functions that are allowed to alter the\n-     VMT pointers.  It assumes that destructors begin with assignment into\n-     all VMT pointers and that constructors essentially look in the\n-     following way:\n-\n-     1) The very first thing they do is that they call constructors of\n-     ancestor sub-objects that have them.\n-\n-     2) Then VMT pointers of this and all its ancestors is set to new\n-     values corresponding to the type corresponding to the constructor.\n-\n-     3) Only afterwards, other stuff such as constructor of member\n-     sub-objects and the code written by the user is run.  Only this may\n-     include calling virtual functions, directly or indirectly.\n-\n-     4) placement new can not be used to change type of non-POD statically\n-     allocated variables.\n-\n-     There is no way to call a constructor of an ancestor sub-object in any\n-     other way.\n-\n-     This means that we do not have to care whether constructors get the\n-     correct type information because they will always change it (in fact,\n-     if we define the type to be given by the VMT pointer, it is undefined).\n-\n-     The most important fact to derive from the above is that if, for some\n-     statement in the section 3, we try to detect whether the dynamic type\n-     has changed, we can safely ignore all calls as we examine the function\n-     body backwards until we reach statements in section 2 because these\n-     calls cannot be ancestor constructors or destructors (if the input is\n-     not bogus) and so do not change the dynamic type (this holds true only\n-     for automatically allocated objects but at the moment we devirtualize\n-     only these).  We then must detect that statements in section 2 change\n-     the dynamic type and can try to derive the new type.  That is enough\n-     and we can stop, we will never see the calls into constructors of\n-     sub-objects in this code. \n-\n-     Therefore if the static outer type was found (outer_type)\n-     we can safely ignore tci.speculative that is set on calls and give up\n-     only if there was dyanmic type store that may affect given variable\n-     (seen_unanalyzed_store)  */\n-\n-  if (!tci.type_maybe_changed\n-      || (outer_type\n-\t  && !tci.seen_unanalyzed_store\n-\t  && !tci.multiple_types_encountered\n-\t  && offset == tci.offset\n-\t  && types_same_for_odr (tci.known_current_type,\n-\t\t\t\t outer_type)))\n-    {\n-      if (!outer_type || tci.seen_unanalyzed_store)\n-\treturn false;\n-      if (maybe_in_construction)\n-        maybe_in_construction = false;\n-      if (dump_file)\n-\tfprintf (dump_file, \"  No dynamic type change found.\\n\");\n-      return true;\n-    }\n-\n-  if (tci.known_current_type\n-      && !function_entry_reached\n-      && !tci.multiple_types_encountered)\n-    {\n-      if (!tci.speculative)\n-\t{\n-\t  outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n-\t  offset = tci.known_current_offset;\n-\t  maybe_in_construction = false;\n-\t  maybe_derived_type = false;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  Determined dynamic type.\\n\");\n-\t}\n-      else if (!speculative_outer_type\n-\t       || speculative_maybe_derived_type)\n-\t{\n-\t  speculative_outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n-\t  speculative_offset = tci.known_current_offset;\n-\t  speculative_maybe_derived_type = false;\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"  Determined speculative dynamic type.\\n\");\n-\t}\n-    }\n-  else if (dump_file)\n-    {\n-      fprintf (dump_file, \"  Found multiple types%s%s\\n\",\n-\t       function_entry_reached ? \" (function entry reached)\" : \"\",\n-\t       function_entry_reached ? \" (multiple types encountered)\" : \"\");\n-    }\n-\n-  return true;\n-}\n-\n /* Walk bases of OUTER_TYPE that contain OTR_TYPE at OFFSET.\n    Lookup their respecitve virtual methods for OTR_TOKEN and OTR_TYPE\n    and insert them to NODES."}, {"sha": "23f14ac60e38d54b86015f4288832d0a46702570", "filename": "gcc/ipa-polymorphic-call.c", "status": "added", "additions": 1518, "deletions": 0, "changes": 1518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=aa803cc76ee6a0a4f951b20912def90880c996c1", "patch": "@@ -0,0 +1,1518 @@\n+/* Analysis of polymorphic call context.\n+   Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"print-tree.h\"\n+#include \"calls.h\"\n+#include \"expr.h\"\n+#include \"tree-pass.h\"\n+#include \"hash-set.h\"\n+#include \"target.h\"\n+#include \"hash-table.h\"\n+#include \"inchash.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"ipa-utils.h\"\n+#include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n+#include \"gimple-fold.h\"\n+#include \"gimple-expr.h\"\n+#include \"gimple.h\"\n+#include \"ipa-inline.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-dfa.h\"\n+#include \"demangle.h\"\n+#include \"dbgcnt.h\"\n+#include \"gimple-pretty-print.h\"\n+#include \"stor-layout.h\"\n+#include \"intl.h\"\n+#include \"data-streamer.h\"\n+#include \"lto-streamer.h\"\n+#include \"streamer-hooks.h\"\n+\n+/* Return true when TYPE contains an polymorphic type and thus is interesting\n+   for devirtualization machinery.  */\n+\n+static bool contains_type_p (tree, HOST_WIDE_INT, tree);\n+\n+bool\n+contains_polymorphic_type_p (const_tree type)\n+{\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      if (TYPE_BINFO (type)\n+          && polymorphic_type_binfo_p (TYPE_BINFO (type)))\n+\treturn true;\n+      for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+\tif (TREE_CODE (fld) == FIELD_DECL\n+\t    && !DECL_ARTIFICIAL (fld)\n+\t    && contains_polymorphic_type_p (TREE_TYPE (fld)))\n+\t  return true;\n+      return false;\n+    }\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return contains_polymorphic_type_p (TREE_TYPE (type));\n+  return false;\n+}\n+\n+/* Return true if it seems valid to use placement new to build EXPECTED_TYPE\n+   at possition CUR_OFFSET within TYPE.  \n+\n+   POD can be changed to an instance of a polymorphic type by\n+   placement new.  Here we play safe and assume that any\n+   non-polymorphic type is POD.  */\n+bool\n+possible_placement_new (tree type, tree expected_type,\n+\t\t\tHOST_WIDE_INT cur_offset)\n+{\n+  return ((TREE_CODE (type) != RECORD_TYPE\n+\t   || !TYPE_BINFO (type)\n+\t   || cur_offset >= BITS_PER_WORD\n+\t   || !polymorphic_type_binfo_p (TYPE_BINFO (type)))\n+\t  && (!TYPE_SIZE (type)\n+\t      || !tree_fits_shwi_p (TYPE_SIZE (type))\n+\t      || (cur_offset\n+\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n+\t\t     : 1)\n+\t\t  <= tree_to_uhwi (TYPE_SIZE (type)))));\n+}\n+\n+/* THIS->OUTER_TYPE is a type of memory object where object of EXPECTED_TYPE\n+   is contained at THIS->OFFSET.  Walk the memory representation of\n+   THIS->OUTER_TYPE and find the outermost class type that match\n+   EXPECTED_TYPE or contain EXPECTED_TYPE as a base.  Update THIS\n+   to represent it.\n+\n+   If EXPECTED_TYPE is NULL, just find outermost polymorphic type with\n+   virtual table present at possition OFFSET.\n+\n+   For example when THIS represents type\n+   class A\n+     {\n+       int a;\n+       class B b;\n+     }\n+   and we look for type at offset sizeof(int), we end up with B and offset 0.\n+   If the same is produced by multiple inheritance, we end up with A and offset\n+   sizeof(int). \n+\n+   If we can not find corresponding class, give up by setting\n+   THIS->OUTER_TYPE to EXPECTED_TYPE and THIS->OFFSET to NULL. \n+   Return true when lookup was sucesful.  */\n+\n+bool\n+ipa_polymorphic_call_context::restrict_to_inner_class (tree expected_type)\n+{\n+  tree type = outer_type;\n+  HOST_WIDE_INT cur_offset = offset;\n+  bool speculative = false;\n+  bool size_unknown = false;\n+\n+  /* Update OUTER_TYPE to match EXPECTED_TYPE if it is not set.  */\n+  if (!outer_type)\n+    {\n+      clear_outer_type (expected_type);\n+      type = expected_type;\n+      cur_offset = 0;\n+    }\n+ /* See if OFFSET points inside OUTER_TYPE.  If it does not, we know\n+    that the context is either invalid, or the instance type must be\n+    derived from OUTER_TYPE.\n+\n+    Because the instance type may contain field whose type is of OUTER_TYPE,\n+    we can not derive any effective information about it.\n+\n+    TODO: In the case we know all derrived types, we can definitely do better\n+    here.  */\n+  else if (TYPE_SIZE (outer_type)\n+\t   && tree_fits_shwi_p (TYPE_SIZE (outer_type))\n+\t   && tree_to_shwi (TYPE_SIZE (outer_type)) >= 0\n+\t   && tree_to_shwi (TYPE_SIZE (outer_type)) <= offset)\n+   {\n+     clear_outer_type (expected_type);\n+     type = expected_type;\n+     cur_offset = 0;\n+\n+     /* If derived type is not allowed, we know that the context is invalid.  */\n+     if (!maybe_derived_type)\n+       {\n+\t clear_speculation ();\n+\t invalid = true;\n+\t return false;\n+       }\n+   }\n+\n+  if (speculative_outer_type)\n+    {\n+      /* Short cirucit the busy work bellow and give up on case when speculation\n+\t is obviously the same as outer_type.  */\n+      if ((!maybe_derived_type\n+\t   || speculative_maybe_derived_type)\n+\t  && types_must_be_same_for_odr (speculative_outer_type, outer_type))\n+\tclear_speculation ();\n+\n+      /* See if SPECULATIVE_OUTER_TYPE is contained in or derived from OUTER_TYPE.\n+\t In this case speculation is valid only if derived types are allowed. \n+\n+\t The test does not really look for derivate, but also accepts the case where\n+\t outer_type is a field of speculative_outer_type.  In this case eiter\n+\t MAYBE_DERIVED_TYPE is false and we have full non-speculative information or\n+\t the loop bellow will correctly update SPECULATIVE_OUTER_TYPE\n+\t and SPECULATIVE_MAYBE_DERIVED_TYPE.  */\n+      else if (speculative_offset < offset\n+\t       || !contains_type_p (speculative_outer_type,\n+\t\t\t\t    speculative_offset - offset,\n+\t\t\t\t    outer_type)\n+\t       || !maybe_derived_type)\n+\tclear_speculation ();\n+    }\n+  else\n+    /* Regularize things little bit and clear all the fields when no useful\n+       speculatin is known.  */\n+    clear_speculation ();\n+\n+  if (!type)\n+    goto no_useful_type_info;\n+\n+  /* Find the sub-object the constant actually refers to and mark whether it is\n+     an artificial one (as opposed to a user-defined one).\n+\n+     This loop is performed twice; first time for outer_type and second time\n+     for speculative_outer_type.  The second run has SPECULATIVE set.  */\n+  while (true)\n+    {\n+      HOST_WIDE_INT pos, size;\n+      tree fld;\n+\n+      /* If we do not know size of TYPE, we need to be more conservative\n+         about accepting cases where we can not find EXPECTED_TYPE.\n+\t Generally the types that do matter here are of constant size.\n+\t Size_unknown case should be very rare.  */\n+      if (TYPE_SIZE (type)\n+\t  && tree_fits_shwi_p (TYPE_SIZE (type))\n+\t  && tree_to_shwi (TYPE_SIZE (type)) >= 0)\n+\tsize_unknown = false;\n+      else\n+\tsize_unknown = true;\n+\n+      /* On a match, just return what we found.  */\n+      if ((types_odr_comparable (type, expected_type)\n+\t   && types_same_for_odr (type, expected_type))\n+\t  || (!expected_type\n+\t      && TREE_CODE (type) == RECORD_TYPE\n+\t      && TYPE_BINFO (type)\n+\t      && polymorphic_type_binfo_p (TYPE_BINFO (type))))\n+\t{\n+\t  if (speculative)\n+\t    {\n+\t      /* If we did not match the offset, just give up on speculation.  */\n+\t      if (cur_offset != 0\n+\t\t  /* Also check if speculation did not end up being same as\n+\t\t     non-speculation.  */\n+\t\t  || (types_must_be_same_for_odr (speculative_outer_type,\n+\t\t\t\t\t\t  outer_type)\n+\t\t      && (maybe_derived_type\n+\t\t\t  == speculative_maybe_derived_type)))\n+\t\tclear_speculation ();\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If type is known to be final, do not worry about derived\n+\t\t types.  Testing it here may help us to avoid speculation.  */\n+\t      if (type_known_to_have_no_deriavations_p (outer_type))\n+\t\tmaybe_derived_type = false;\n+\n+\t      /* Type can not contain itself on an non-zero offset.  In that case\n+\t\t just give up.  Still accept the case where size is now known.\n+\t\t Either the second copy may appear past the end of type or within\n+\t\t the non-POD buffer located inside the variably sized type\n+\t\t itself.  */\n+\t      if (cur_offset != 0)\n+\t\tgoto no_useful_type_info;\n+\t      /* If we determined type precisely or we have no clue on\n+ \t\t speuclation, we are done.  */\n+\t      if (!maybe_derived_type || !speculative_outer_type)\n+\t\t{\n+\t\t  clear_speculation ();\n+\t          return true;\n+\t\t}\n+\t      /* Otherwise look into speculation now.  */\n+\t      else\n+\t\t{\n+\t\t  speculative = true;\n+\t\t  type = speculative_outer_type;\n+\t\t  cur_offset = speculative_offset;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Walk fields and find corresponding on at OFFSET.  */\n+      if (TREE_CODE (type) == RECORD_TYPE)\n+\t{\n+\t  for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+\t    {\n+\t      if (TREE_CODE (fld) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      pos = int_bit_position (fld);\n+\t      size = tree_to_uhwi (DECL_SIZE (fld));\n+\t      if (pos <= cur_offset && (pos + size) > cur_offset)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (!fld)\n+\t    goto no_useful_type_info;\n+\n+\t  type = TYPE_MAIN_VARIANT (TREE_TYPE (fld));\n+\t  cur_offset -= pos;\n+\t  /* DECL_ARTIFICIAL represents a basetype.  */\n+\t  if (!DECL_ARTIFICIAL (fld))\n+\t    {\n+\t      if (!speculative)\n+\t\t{\n+\t\t  outer_type = type;\n+\t\t  offset = cur_offset;\n+\t\t  /* As soon as we se an field containing the type,\n+\t\t     we know we are not looking for derivations.  */\n+\t\t  maybe_derived_type = false;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  speculative_outer_type = type;\n+\t\t  speculative_offset = cur_offset;\n+\t\t  speculative_maybe_derived_type = false;\n+\t\t}\n+\t    }\n+\t}\n+      else if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  tree subtype = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+\n+\t  /* Give up if we don't know array size.  */\n+\t  if (!TYPE_SIZE (subtype)\n+\t      || !tree_fits_shwi_p (TYPE_SIZE (subtype))\n+\t      || tree_to_shwi (TYPE_SIZE (subtype)) <= 0\n+\t      || !contains_polymorphic_type_p (subtype))\n+\t    goto no_useful_type_info;\n+\n+\t  HOST_WIDE_INT new_offset = cur_offset % tree_to_shwi (TYPE_SIZE (subtype));\n+\n+\t  /* We may see buffer for placement new.  In this case the expected type\n+\t     can be bigger than the subtype.  */\n+\t  if (TYPE_SIZE (subtype)\n+\t      && (cur_offset\n+\t\t  + (expected_type ? tree_to_uhwi (TYPE_SIZE (expected_type))\n+\t\t     : 0)\n+\t\t  > tree_to_uhwi (TYPE_SIZE (type))))\n+\t    goto no_useful_type_info;\n+\n+\t  cur_offset = new_offset;\n+\t  type = subtype;\n+\t  if (!speculative)\n+\t    {\n+\t      outer_type = type;\n+\t      offset = cur_offset;\n+\t      maybe_derived_type = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      speculative_outer_type = type;\n+\t      speculative_offset = cur_offset;\n+\t      speculative_maybe_derived_type = false;\n+\t    }\n+\t}\n+      /* Give up on anything else.  */\n+      else\n+\t{\n+no_useful_type_info:\n+\t  /* We found no way to embedd EXPECTED_TYPE in TYPE.\n+\t     We still permit two special cases - placement new and\n+\t     the case of variadic types containing themselves.  */\n+\t  if (!speculative\n+\t      && (size_unknown || !type\n+\t\t  || possible_placement_new (type, expected_type, cur_offset)))\n+\t    {\n+\t      /* In these weird cases we want to accept the context.\n+\t\t In non-speculative run we have no useful outer_type info\n+\t\t (TODO: we may eventually want to record upper bound on the\n+\t\t  type size that can be used to prune the walk),\n+\t\t but we still want to consider speculation that may\n+\t\t give useful info.  */\n+\t      if (!speculative)\n+\t\t{\n+\t\t  clear_outer_type (expected_type);\n+\t\t  if (speculative_outer_type)\n+\t\t    {\n+\t\t      speculative = true;\n+\t\t      type = speculative_outer_type;\n+\t\t      cur_offset = speculative_offset;\n+\t\t    }\n+\t\t  else\n+\t\t    return true;\n+\t\t}\n+\t      else\n+\t\tclear_speculation ();\n+\t      return true;\n+\t    }\n+\t  else\n+\t    {\n+\t      clear_speculation ();\n+\t      if (speculative)\n+\t\treturn true;\n+\t      clear_outer_type (expected_type);\n+\t      invalid = true; \n+\t      return false;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Return true if OUTER_TYPE contains OTR_TYPE at OFFSET.  */\n+\n+static bool\n+contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n+\t\t tree otr_type)\n+{\n+  ipa_polymorphic_call_context context;\n+  context.offset = offset;\n+  context.outer_type = TYPE_MAIN_VARIANT (outer_type);\n+  context.maybe_derived_type = false;\n+  return context.restrict_to_inner_class (otr_type);\n+}\n+\n+\n+/* We know that the instance is stored in variable or parameter\n+   (not dynamically allocated) and we want to disprove the fact\n+   that it may be in construction at invocation of CALL.\n+\n+   For the variable to be in construction we actually need to\n+   be in constructor of corresponding global variable or\n+   the inline stack of CALL must contain the constructor.\n+   Check this condition.  This check works safely only before\n+   IPA passes, because inline stacks may become out of date\n+   later.  */\n+\n+bool\n+decl_maybe_in_construction_p (tree base, tree outer_type,\n+\t\t\t      gimple call, tree function)\n+{\n+  outer_type = TYPE_MAIN_VARIANT (outer_type);\n+  gcc_assert (DECL_P (base));\n+\n+  /* After inlining the code unification optimizations may invalidate\n+     inline stacks.  Also we need to give up on global variables after\n+     IPA, because addresses of these may have been propagated to their\n+     constructors.  */\n+  if (DECL_STRUCT_FUNCTION (function)->after_inlining)\n+    return true;\n+\n+  /* Pure functions can not do any changes on the dynamic type;\n+     that require writting to memory.  */\n+  if (!auto_var_in_fn_p (base, function)\n+      && flags_from_decl_or_type (function) & (ECF_PURE | ECF_CONST))\n+    return false;\n+\n+  for (tree block = gimple_block (call); block && TREE_CODE (block) == BLOCK;\n+       block = BLOCK_SUPERCONTEXT (block))\n+    if (BLOCK_ABSTRACT_ORIGIN (block)\n+\t&& TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n+      {\n+\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+\tif (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n+\t    || (!DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t&& !DECL_CXX_DESTRUCTOR_P (fn)))\n+\t  {\n+\t    /* Watch for clones where we constant propagated the first\n+\t       argument (pointer to the instance).  */\n+\t    fn = DECL_ABSTRACT_ORIGIN (fn);\n+\t    if (!fn\n+\t\t|| !is_global_var (base)\n+\t        || TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE\n+\t\t|| (!DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t    && !DECL_CXX_DESTRUCTOR_P (fn)))\n+\t      continue;\n+\t  }\n+\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n+\t  continue;\n+\n+\t/* FIXME: this can go away once we have ODR types equivalency on\n+\t   LTO level.  */\n+\tif (in_lto_p && !polymorphic_type_binfo_p (TYPE_BINFO (outer_type)))\n+\t  return true;\n+\ttree type = TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (fn)));\n+\tif (types_same_for_odr (type, outer_type))\n+\t  return true;\n+      }\n+\n+  if (TREE_CODE (base) == VAR_DECL\n+      && is_global_var (base))\n+    {\n+      if (TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n+\t  || (!DECL_CXX_CONSTRUCTOR_P (function)\n+\t      && !DECL_CXX_DESTRUCTOR_P (function)))\n+\t{\n+\t  if (!DECL_ABSTRACT_ORIGIN (function))\n+\t    return false;\n+\t  /* Watch for clones where we constant propagated the first\n+\t     argument (pointer to the instance).  */\n+\t  function = DECL_ABSTRACT_ORIGIN (function);\n+\t  if (!function\n+\t      || TREE_CODE (TREE_TYPE (function)) != METHOD_TYPE\n+\t      || (!DECL_CXX_CONSTRUCTOR_P (function)\n+\t\t  && !DECL_CXX_DESTRUCTOR_P (function)))\n+\t    return false;\n+\t}\n+      /* FIXME: this can go away once we have ODR types equivalency on\n+\t LTO level.  */\n+      if (in_lto_p && !polymorphic_type_binfo_p (TYPE_BINFO (outer_type)))\n+\treturn true;\n+      tree type = TYPE_MAIN_VARIANT (method_class_type (TREE_TYPE (function)));\n+      if (types_same_for_odr (type, outer_type))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Dump human readable context to F.  */\n+\n+void\n+ipa_polymorphic_call_context::dump (FILE *f) const\n+{\n+  fprintf (f, \"    \");\n+  if (invalid)\n+    fprintf (f, \"Call is known to be undefined\\n\");\n+  else\n+    {\n+      if (!outer_type && !offset && !speculative_outer_type)\n+\tfprintf (f, \"Empty context\\n\");\n+      if (outer_type || offset)\n+\t{\n+\t  fprintf (f, \"Outer type:\");\n+\t  print_generic_expr (f, outer_type, TDF_SLIM);\n+\t  if (maybe_derived_type)\n+\t    fprintf (f, \" (or a derived type)\");\n+\t  if (maybe_in_construction)\n+\t    fprintf (f, \" (maybe in construction)\");\n+\t  fprintf (f, \" offset \"HOST_WIDE_INT_PRINT_DEC,\n+\t\t   offset);\n+\t}\n+      if (speculative_outer_type)\n+\t{\n+\t  fprintf (f, \" speculative outer type:\");\n+\t  print_generic_expr (f, speculative_outer_type, TDF_SLIM);\n+\t  if (speculative_maybe_derived_type)\n+\t    fprintf (f, \" (or a derived type)\");\n+\t  fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC,\n+\t\t   speculative_offset);\n+\t}\n+    }\n+  fprintf(f, \"\\n\");\n+}\n+\n+/* Print context to stderr.  */\n+\n+void\n+ipa_polymorphic_call_context::debug () const\n+{\n+  dump (stderr);\n+}\n+\n+/* Stream out the context to OB.  */\n+\n+void\n+ipa_polymorphic_call_context::stream_out (struct output_block *ob) const\n+{\n+  struct bitpack_d bp = bitpack_create (ob->main_stream);\n+\n+  bp_pack_value (&bp, invalid, 1);\n+  bp_pack_value (&bp, maybe_in_construction, 1);\n+  bp_pack_value (&bp, maybe_derived_type, 1);\n+  bp_pack_value (&bp, speculative_maybe_derived_type, 1);\n+  bp_pack_value (&bp, outer_type != NULL, 1);\n+  bp_pack_value (&bp, offset != 0, 1);\n+  bp_pack_value (&bp, speculative_outer_type != NULL, 1);\n+  streamer_write_bitpack (&bp);\n+\n+  if (outer_type != NULL)\n+    stream_write_tree (ob, outer_type, true);\n+  if (offset)\n+    streamer_write_hwi (ob, offset);\n+  if (speculative_outer_type != NULL)\n+    {\n+      stream_write_tree (ob, speculative_outer_type, true);\n+      streamer_write_hwi (ob, speculative_offset);\n+    }\n+  else\n+    gcc_assert (!speculative_offset);\n+}\n+\n+/* Stream in the context from IB and DATA_IN.  */\n+\n+void\n+ipa_polymorphic_call_context::stream_in (struct lto_input_block *ib,\n+\t\t\t\t\t struct data_in *data_in)\n+{\n+  struct bitpack_d bp = streamer_read_bitpack (ib);\n+\n+  invalid = bp_unpack_value (&bp, 1);\n+  maybe_in_construction = bp_unpack_value (&bp, 1);\n+  maybe_derived_type = bp_unpack_value (&bp, 1);\n+  speculative_maybe_derived_type = bp_unpack_value (&bp, 1);\n+  bool outer_type_p = bp_unpack_value (&bp, 1);\n+  bool offset_p = bp_unpack_value (&bp, 1);\n+  bool speculative_outer_type_p = bp_unpack_value (&bp, 1);\n+\n+  if (outer_type_p)\n+    outer_type = stream_read_tree (ib, data_in);\n+  else\n+    outer_type = NULL;\n+  if (offset_p)\n+    offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+  else\n+    offset = 0;\n+  if (speculative_outer_type_p)\n+    {\n+      speculative_outer_type = stream_read_tree (ib, data_in);\n+      speculative_offset = (HOST_WIDE_INT) streamer_read_hwi (ib);\n+    }\n+  else\n+    {\n+      speculative_outer_type = NULL;\n+      speculative_offset = 0;\n+    }\n+}\n+\n+/* Proudce polymorphic call context for call method of instance\n+   that is located within BASE (that is assumed to be a decl) at offset OFF. */\n+\n+void\n+ipa_polymorphic_call_context::set_by_decl (tree base, HOST_WIDE_INT off)\n+{\n+  gcc_assert (DECL_P (base));\n+\n+  outer_type = TYPE_MAIN_VARIANT (TREE_TYPE (base));\n+  offset = off;\n+  clear_speculation ();\n+  /* Make very conservative assumption that all objects\n+     may be in construction. \n+ \n+     It is up to caller to revisit this via\n+     get_dynamic_type or decl_maybe_in_construction_p.  */\n+  maybe_in_construction = true;\n+  maybe_derived_type = false;\n+}\n+\n+/* CST is an invariant (address of decl), try to get meaningful\n+   polymorphic call context for polymorphic call of method \n+   if instance of OTR_TYPE that is located at offset OFF of this invariant.\n+   Return FALSE if nothing meaningful can be found.  */\n+\n+bool\n+ipa_polymorphic_call_context::set_by_invariant (tree cst,\n+\t\t\t\t\t\ttree otr_type,\n+\t\t\t\t\t\tHOST_WIDE_INT off)\n+{\n+  HOST_WIDE_INT offset2, size, max_size;\n+  tree base;\n+\n+  invalid = false;\n+  off = 0;\n+  clear_outer_type (otr_type);\n+\n+  if (TREE_CODE (cst) != ADDR_EXPR)\n+    return false;\n+\n+  cst = TREE_OPERAND (cst, 0);\n+  base = get_ref_base_and_extent (cst, &offset2, &size, &max_size);\n+  if (!DECL_P (base) || max_size == -1 || max_size != size)\n+    return false;\n+\n+  /* Only type inconsistent programs can have otr_type that is\n+     not part of outer type.  */\n+  if (otr_type && !contains_type_p (TREE_TYPE (base), off, otr_type))\n+    return false;\n+\n+  set_by_decl (base, off);\n+  return true;\n+}\n+\n+/* See if OP is SSA name initialized as a copy or by single assignment.\n+   If so, walk the SSA graph up.  */\n+\n+static tree\n+walk_ssa_copies (tree op)\n+{\n+  STRIP_NOPS (op);\n+  while (TREE_CODE (op) == SSA_NAME\n+\t && !SSA_NAME_IS_DEFAULT_DEF (op)\n+\t && SSA_NAME_DEF_STMT (op)\n+\t && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n+    {\n+      if (gimple_assign_load_p (SSA_NAME_DEF_STMT (op)))\n+\treturn op;\n+      op = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op));\n+      STRIP_NOPS (op);\n+    }\n+  return op;\n+}\n+\n+/* Create polymorphic call context from IP invariant CST.\n+   This is typically &global_var.\n+   OTR_TYPE specify type of polymorphic call or NULL if unknown, OFF\n+   is offset of call.  */\n+\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree cst,\n+\t\t\t\t\t\t\t    tree otr_type,\n+\t\t\t\t\t\t\t    HOST_WIDE_INT off)\n+{\n+  clear_speculation ();\n+  set_by_invariant (cst, otr_type, off);\n+}\n+\n+/* Build context for pointer REF contained in FNDECL at statement STMT.\n+   if INSTANCE is non-NULL, return pointer to the object described by\n+   the context or DECL where context is contained in.  */\n+\n+ipa_polymorphic_call_context::ipa_polymorphic_call_context (tree fndecl,\n+\t\t\t\t\t\t\t    tree ref,\n+\t\t\t\t\t\t\t    gimple stmt,\n+\t\t\t\t\t\t\t    tree *instance)\n+{\n+  tree otr_type = NULL;\n+  tree base_pointer;\n+\n+  if (TREE_CODE (ref) == OBJ_TYPE_REF)\n+    {\n+      otr_type = obj_type_ref_class (ref);\n+      base_pointer = OBJ_TYPE_REF_OBJECT (ref);\n+    }\n+  else\n+    base_pointer = ref;\n+\n+  /* Set up basic info in case we find nothing interesting in the analysis.  */\n+  clear_speculation ();\n+  clear_outer_type (otr_type);\n+  invalid = false;\n+\n+  /* Walk SSA for outer object.  */\n+  do \n+    {\n+      base_pointer = walk_ssa_copies (base_pointer);\n+      if (TREE_CODE (base_pointer) == ADDR_EXPR)\n+\t{\n+\t  HOST_WIDE_INT size, max_size;\n+\t  HOST_WIDE_INT offset2;\n+\t  tree base = get_ref_base_and_extent (TREE_OPERAND (base_pointer, 0),\n+\t\t\t\t\t       &offset2, &size, &max_size);\n+\n+\t  /* If this is a varying address, punt.  */\n+\t  if ((TREE_CODE (base) == MEM_REF || DECL_P (base))\n+\t      && max_size != -1\n+\t      && max_size == size)\n+\t    {\n+\t      /* We found dereference of a pointer.  Type of the pointer\n+\t\t and MEM_REF is meaningless, but we can look futher.  */\n+\t      if (TREE_CODE (base) == MEM_REF)\n+\t\t{\n+\t\t  base_pointer = TREE_OPERAND (base, 0);\n+\t\t  offset\n+\t\t    += offset2 + mem_ref_offset (base).to_short_addr () * BITS_PER_UNIT;\n+\t\t  outer_type = NULL;\n+\t\t}\n+\t      /* We found base object.  In this case the outer_type\n+\t\t is known.  */\n+\t      else if (DECL_P (base))\n+\t\t{\n+\t\t  gcc_assert (!POINTER_TYPE_P (TREE_TYPE (base)));\n+\n+\t\t  /* Only type inconsistent programs can have otr_type that is\n+\t\t     not part of outer type.  */\n+\t\t  if (otr_type\n+\t\t      && !contains_type_p (TREE_TYPE (base),\n+\t\t\t\t\t   offset + offset2, otr_type))\n+\t\t    {\n+\t\t      invalid = true;\n+\t\t      if (instance)\n+\t\t\t*instance = base_pointer;\n+\t\t      return;\n+\t\t    }\n+\t\t  set_by_decl (base, offset + offset2);\n+\t\t  if (maybe_in_construction && stmt)\n+\t\t    maybe_in_construction\n+\t\t     = decl_maybe_in_construction_p (base,\n+\t\t\t\t\t\t     outer_type,\n+\t\t\t\t\t\t     stmt,\n+\t\t\t\t\t\t     fndecl);\n+\t\t  if (instance)\n+\t\t    *instance = base;\n+\t\t  return;\n+\t\t}\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+      else if (TREE_CODE (base_pointer) == POINTER_PLUS_EXPR\n+\t       && tree_fits_uhwi_p (TREE_OPERAND (base_pointer, 1)))\n+\t{\n+\t  offset += tree_to_shwi (TREE_OPERAND (base_pointer, 1))\n+\t\t    * BITS_PER_UNIT;\n+\t  base_pointer = TREE_OPERAND (base_pointer, 0);\n+\t}\n+      else\n+\tbreak;\n+    }\n+  while (true);\n+\n+  /* Try to determine type of the outer object.  */\n+  if (TREE_CODE (base_pointer) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n+      && TREE_CODE (SSA_NAME_VAR (base_pointer)) == PARM_DECL)\n+    {\n+      /* See if parameter is THIS pointer of a method.  */\n+      if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE\n+\t  && SSA_NAME_VAR (base_pointer) == DECL_ARGUMENTS (fndecl))\n+\t{\n+\t  outer_type\n+\t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n+\t  gcc_assert (TREE_CODE (outer_type) == RECORD_TYPE);\n+\n+\t  /* Dynamic casting has possibly upcasted the type\n+\t     in the hiearchy.  In this case outer type is less\n+\t     informative than inner type and we should forget\n+\t     about it.  */\n+\t  if (otr_type\n+\t      && !contains_type_p (outer_type, offset,\n+\t\t\t\t   otr_type))\n+\t    {\n+\t      outer_type = NULL;\n+\t      if (instance)\n+\t\t*instance = base_pointer;\n+\t      return;\n+\t    }\n+\n+\t  /* If the function is constructor or destructor, then\n+\t     the type is possibly in construction, but we know\n+\t     it is not derived type.  */\n+\t  if (DECL_CXX_CONSTRUCTOR_P (fndecl)\n+\t      || DECL_CXX_DESTRUCTOR_P (fndecl))\n+\t    {\n+\t      maybe_in_construction = true;\n+\t      maybe_derived_type = false;\n+\t    }\n+\t  else\n+\t    {\n+\t      maybe_derived_type = true;\n+\t      maybe_in_construction = false;\n+\t    }\n+\t  if (instance)\n+\t    *instance = base_pointer;\n+\t  return;\n+\t}\n+      /* Non-PODs passed by value are really passed by invisible\n+\t reference.  In this case we also know the type of the\n+\t object.  */\n+      if (DECL_BY_REFERENCE (SSA_NAME_VAR (base_pointer)))\n+\t{\n+\t  outer_type\n+\t     = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (base_pointer)));\n+\t  gcc_assert (!POINTER_TYPE_P (outer_type));\n+\t  /* Only type inconsistent programs can have otr_type that is\n+\t     not part of outer type.  */\n+\t  if (!contains_type_p (outer_type, offset,\n+\t\t\t        otr_type))\n+\t    { \n+\t      invalid = true;\n+\t      if (instance)\n+\t\t*instance = base_pointer;\n+\t      return;\n+\t    }\n+\t  maybe_derived_type = false;\n+\t  maybe_in_construction = false;\n+\t  if (instance)\n+\t    *instance = base_pointer;\n+\t  return;\n+\t}\n+    }\n+\n+  tree base_type = TREE_TYPE (base_pointer);\n+\n+  if (TREE_CODE (base_pointer) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (base_pointer)\n+      && TREE_CODE (SSA_NAME_VAR (base_pointer)) != PARM_DECL)\n+    {\n+      invalid = true;\n+      if (instance)\n+\t*instance = base_pointer;\n+      return;\n+    }\n+  if (TREE_CODE (base_pointer) == SSA_NAME\n+      && SSA_NAME_DEF_STMT (base_pointer)\n+      && gimple_assign_single_p (SSA_NAME_DEF_STMT (base_pointer)))\n+    base_type = TREE_TYPE (gimple_assign_rhs1\n+\t\t\t    (SSA_NAME_DEF_STMT (base_pointer)));\n+ \n+  if (POINTER_TYPE_P (base_type)\n+      && (otr_type\n+\t  || !contains_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (base_type)),\n+\t\t\t       offset,\n+\t\t\t       otr_type)))\n+    {\n+      speculative_outer_type = TYPE_MAIN_VARIANT\n+\t\t\t\t\t  (TREE_TYPE (base_type));\n+      speculative_offset = offset;\n+      speculative_maybe_derived_type = true;\n+    }\n+  /* TODO: There are multiple ways to derive a type.  For instance\n+     if BASE_POINTER is passed to an constructor call prior our refernece.\n+     We do not make this type of flow sensitive analysis yet.  */\n+  if (instance)\n+    *instance = base_pointer;\n+  return;\n+}\n+\n+/* Structure to be passed in between detect_type_change and\n+   check_stmt_for_type_change.  */\n+\n+struct type_change_info\n+{\n+  /* Offset into the object where there is the virtual method pointer we are\n+     looking for.  */\n+  HOST_WIDE_INT offset;\n+  /* The declaration or SSA_NAME pointer of the base that we are checking for\n+     type change.  */\n+  tree instance;\n+  /* The reference to virtual table pointer used.  */\n+  tree vtbl_ptr_ref;\n+  tree otr_type;\n+  /* If we actually can tell the type that the object has changed to, it is\n+     stored in this field.  Otherwise it remains NULL_TREE.  */\n+  tree known_current_type;\n+  HOST_WIDE_INT known_current_offset;\n+\n+  /* Set to true if dynamic type change has been detected.  */\n+  bool type_maybe_changed;\n+  /* Set to true if multiple types have been encountered.  known_current_type\n+     must be disregarded in that case.  */\n+  bool multiple_types_encountered;\n+  /* Set to true if we possibly missed some dynamic type changes and we should\n+     consider the set to be speculative.  */\n+  bool speculative;\n+  bool seen_unanalyzed_store;\n+};\n+\n+/* Return true if STMT is not call and can modify a virtual method table pointer.\n+   We take advantage of fact that vtable stores must appear within constructor\n+   and destructor functions.  */\n+\n+static bool\n+noncall_stmt_may_be_vtbl_ptr_store (gimple stmt)\n+{\n+  if (is_gimple_assign (stmt))\n+    {\n+      tree lhs = gimple_assign_lhs (stmt);\n+\n+      if (gimple_clobber_p (stmt))\n+\treturn false;\n+      if (!AGGREGATE_TYPE_P (TREE_TYPE (lhs)))\n+\t{\n+\t  if (flag_strict_aliasing\n+\t      && !POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t    return false;\n+\n+\t  if (TREE_CODE (lhs) == COMPONENT_REF\n+\t      && !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n+\t    return false;\n+\t  /* In the future we might want to use get_base_ref_and_offset to find\n+\t     if there is a field corresponding to the offset and if so, proceed\n+\t     almost like if it was a component ref.  */\n+\t}\n+    }\n+\n+  /* Code unification may mess with inline stacks.  */\n+  if (cfun->after_inlining)\n+    return true;\n+\n+  /* Walk the inline stack and watch out for ctors/dtors.\n+     TODO: Maybe we can require the store to appear in toplevel\n+     block of CTOR/DTOR.  */\n+  for (tree block = gimple_block (stmt); block && TREE_CODE (block) == BLOCK;\n+       block = BLOCK_SUPERCONTEXT (block))\n+    if (BLOCK_ABSTRACT_ORIGIN (block)\n+\t&& TREE_CODE (BLOCK_ABSTRACT_ORIGIN (block)) == FUNCTION_DECL)\n+      {\n+\ttree fn = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+\tif (flags_from_decl_or_type (fn) & (ECF_PURE | ECF_CONST))\n+\t  return false;\n+\treturn (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+\t\t&& (DECL_CXX_CONSTRUCTOR_P (fn)\n+\t\t    || DECL_CXX_DESTRUCTOR_P (fn)));\n+      }\n+  return (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE\n+\t  && (DECL_CXX_CONSTRUCTOR_P (current_function_decl)\n+\t      || DECL_CXX_DESTRUCTOR_P (current_function_decl)));\n+}\n+\n+/* If STMT can be proved to be an assignment to the virtual method table\n+   pointer of ANALYZED_OBJ and the type associated with the new table\n+   identified, return the type.  Otherwise return NULL_TREE.  */\n+\n+static tree\n+extr_type_from_vtbl_ptr_store (gimple stmt, struct type_change_info *tci,\n+\t\t\t       HOST_WIDE_INT *type_offset)\n+{\n+  HOST_WIDE_INT offset, size, max_size;\n+  tree lhs, rhs, base;\n+\n+  if (!gimple_assign_single_p (stmt))\n+    return NULL_TREE;\n+\n+  lhs = gimple_assign_lhs (stmt);\n+  rhs = gimple_assign_rhs1 (stmt);\n+  if (TREE_CODE (lhs) != COMPONENT_REF\n+      || !DECL_VIRTUAL_P (TREE_OPERAND (lhs, 1)))\n+     {\n+\tif (dump_file)\n+\t  fprintf (dump_file, \"  LHS is not virtual table.\\n\");\n+\treturn NULL_TREE;\n+     }\n+\n+  if (tci->vtbl_ptr_ref && operand_equal_p (lhs, tci->vtbl_ptr_ref, 0))\n+    ;\n+  else\n+    {\n+      base = get_ref_base_and_extent (lhs, &offset, &size, &max_size);\n+      if (offset != tci->offset\n+\t  || size != POINTER_SIZE\n+\t  || max_size != POINTER_SIZE)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"    wrong offset %i!=%i or size %i\\n\",\n+\t\t     (int)offset, (int)tci->offset, (int)size);\n+\t  return NULL_TREE;\n+\t}\n+      if (DECL_P (tci->instance))\n+\t{\n+\t  if (base != tci->instance)\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"    base:\");\n+\t\t  print_generic_expr (dump_file, base, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" does not match instance:\");\n+\t\t  print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+      else if (TREE_CODE (base) == MEM_REF)\n+\t{\n+\t  if (!operand_equal_p (tci->instance, TREE_OPERAND (base, 0), 0)\n+\t      || !integer_zerop (TREE_OPERAND (base, 1)))\n+\t    {\n+\t      if (dump_file)\n+\t\t{\n+\t\t  fprintf (dump_file, \"    base mem ref:\");\n+\t\t  print_generic_expr (dump_file, base, TDF_SLIM);\n+\t\t  fprintf (dump_file, \" has nonzero offset or does not match instance:\");\n+\t\t  print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+      else if (!operand_equal_p (tci->instance, base, 0)\n+\t       || tci->offset)\n+\t{\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"    base:\");\n+\t      print_generic_expr (dump_file, base, TDF_SLIM);\n+\t      fprintf (dump_file, \" does not match instance:\");\n+\t      print_generic_expr (dump_file, tci->instance, TDF_SLIM);\n+\t      fprintf (dump_file, \" with offset %i\\n\", (int)tci->offset);\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  tree vtable;\n+  unsigned HOST_WIDE_INT offset2;\n+\n+  if (!vtable_pointer_value_to_vtable (rhs, &vtable, &offset2))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Failed to lookup binfo\\n\");\n+      return NULL;\n+    }\n+\n+  tree binfo = subbinfo_with_vtable_at_offset (TYPE_BINFO (DECL_CONTEXT (vtable)),\n+\t\t\t\t\t       offset2, vtable);\n+  if (!binfo)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"    Construction vtable used\\n\");\n+      /* FIXME: We should suport construction contextes.  */\n+      return NULL;\n+    }\n+ \n+  *type_offset = tree_to_shwi (BINFO_OFFSET (binfo)) * BITS_PER_UNIT;\n+  return DECL_CONTEXT (vtable);\n+}\n+\n+/* Record dynamic type change of TCI to TYPE.  */\n+\n+static void\n+record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset)\n+{\n+  if (dump_file)\n+    {\n+      if (type)\n+\t{\n+          fprintf (dump_file, \"  Recording type: \");\n+\t  print_generic_expr (dump_file, type, TDF_SLIM);\n+          fprintf (dump_file, \" at offset %i\\n\", (int)offset);\n+\t}\n+     else\n+       fprintf (dump_file, \"  Recording unknown type\\n\");\n+    }\n+\n+  /* If we found a constructor of type that is not polymorphic or\n+     that may contain the type in question as a field (not as base),\n+     restrict to the inner class first to make type matching bellow\n+     happier.  */\n+  if (type\n+      && (offset\n+          || (TREE_CODE (type) != RECORD_TYPE\n+\t      || !polymorphic_type_binfo_p (TYPE_BINFO (type)))))\n+    {\n+      ipa_polymorphic_call_context context;\n+\n+      context.offset = offset;\n+      context.outer_type = type;\n+      context.maybe_in_construction = false;\n+      context.maybe_derived_type = false;\n+      /* If we failed to find the inner type, we know that the call\n+\t would be undefined for type produced here.  */\n+      if (!context.restrict_to_inner_class (tci->otr_type))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Ignoring; does not contain otr_type\\n\");\n+\t  return;\n+\t}\n+      /* Watch for case we reached an POD type and anticipate placement\n+\t new.  */\n+      if (!context.maybe_derived_type)\n+\t{\n+          type = context.outer_type;\n+          offset = context.offset;\n+\t}\n+    }\n+  if (tci->type_maybe_changed\n+      && (!types_same_for_odr (type, tci->known_current_type)\n+\t  || offset != tci->known_current_offset))\n+    tci->multiple_types_encountered = true;\n+  tci->known_current_type = TYPE_MAIN_VARIANT (type);\n+  tci->known_current_offset = offset;\n+  tci->type_maybe_changed = true;\n+}\n+\n+/* Callback of walk_aliased_vdefs and a helper function for\n+   detect_type_change to check whether a particular statement may modify\n+   the virtual table pointer, and if possible also determine the new type of\n+   the (sub-)object.  It stores its result into DATA, which points to a\n+   type_change_info structure.  */\n+\n+static bool\n+check_stmt_for_type_change (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef, void *data)\n+{\n+  gimple stmt = SSA_NAME_DEF_STMT (vdef);\n+  struct type_change_info *tci = (struct type_change_info *) data;\n+  tree fn;\n+\n+  /* If we already gave up, just terminate the rest of walk.  */\n+  if (tci->multiple_types_encountered)\n+    return true;\n+\n+  if (is_gimple_call (stmt))\n+    {\n+      if (gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE))\n+\treturn false;\n+\n+      /* Check for a constructor call.  */\n+      if ((fn = gimple_call_fndecl (stmt)) != NULL_TREE\n+\t  && DECL_CXX_CONSTRUCTOR_P (fn)\n+\t  && TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n+\t  && gimple_call_num_args (stmt))\n+      {\n+\ttree op = walk_ssa_copies (gimple_call_arg (stmt, 0));\n+\ttree type = method_class_type (TREE_TYPE (fn));\n+\tHOST_WIDE_INT offset = 0, size, max_size;\n+\n+\tif (dump_file)\n+\t  {\n+\t    fprintf (dump_file, \"  Checking constructor call: \");\n+\t    print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  }\n+\n+\t/* See if THIS parameter seems like instance pointer.  */\n+\tif (TREE_CODE (op) == ADDR_EXPR)\n+\t  {\n+\t    op = get_ref_base_and_extent (TREE_OPERAND (op, 0),\n+\t\t\t\t\t  &offset, &size, &max_size);\n+\t    if (size != max_size || max_size == -1)\n+\t      {\n+                tci->speculative = true;\n+\t        return false;\n+\t      }\n+\t    if (op && TREE_CODE (op) == MEM_REF)\n+\t      {\n+\t\tif (!tree_fits_shwi_p (TREE_OPERAND (op, 1)))\n+\t\t  {\n+                    tci->speculative = true;\n+\t\t    return false;\n+\t\t  }\n+\t\toffset += tree_to_shwi (TREE_OPERAND (op, 1))\n+\t\t\t  * BITS_PER_UNIT;\n+\t\top = TREE_OPERAND (op, 0);\n+\t      }\n+\t    else if (DECL_P (op))\n+\t      ;\n+\t    else\n+\t      {\n+                tci->speculative = true;\n+\t        return false;\n+\t      }\n+\t    op = walk_ssa_copies (op);\n+\t  }\n+\tif (operand_equal_p (op, tci->instance, 0)\n+\t    && TYPE_SIZE (type)\n+\t    && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t    && tree_fits_shwi_p (TYPE_SIZE (type))\n+\t    && tree_to_shwi (TYPE_SIZE (type)) + offset > tci->offset)\n+\t  {\n+\t    record_known_type (tci, type, tci->offset - offset);\n+\t    return true;\n+\t  }\n+      }\n+     /* Calls may possibly change dynamic type by placement new. Assume\n+        it will not happen, but make result speculative only.  */\n+     if (dump_file)\n+\t{\n+          fprintf (dump_file, \"  Function call may change dynamic type:\");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+     tci->speculative = true;\n+     return false;\n+   }\n+  /* Check for inlined virtual table store.  */\n+  else if (noncall_stmt_may_be_vtbl_ptr_store (stmt))\n+    {\n+      tree type;\n+      HOST_WIDE_INT offset = 0;\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"  Checking vtbl store: \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+\n+      type = extr_type_from_vtbl_ptr_store (stmt, tci, &offset);\n+      gcc_assert (!type || TYPE_MAIN_VARIANT (type) == type);\n+      if (!type)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Unanalyzed store may change type.\\n\");\n+\t  tci->seen_unanalyzed_store = true;\n+\t  tci->speculative = true;\n+\t}\n+      else\n+        record_known_type (tci, type, offset);\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* THIS is polymorphic call context obtained from get_polymorphic_context.\n+   OTR_OBJECT is pointer to the instance returned by OBJ_TYPE_REF_OBJECT.\n+   INSTANCE is pointer to the outer instance as returned by\n+   get_polymorphic_context.  To avoid creation of temporary expressions,\n+   INSTANCE may also be an declaration of get_polymorphic_context found the\n+   value to be in static storage.\n+\n+   If the type of instance is not fully determined\n+   (either OUTER_TYPE is unknown or MAYBE_IN_CONSTRUCTION/INCLUDE_DERIVED_TYPES\n+   is set), try to walk memory writes and find the actual construction of the\n+   instance.\n+\n+   We do not include this analysis in the context analysis itself, because\n+   it needs memory SSA to be fully built and the walk may be expensive.\n+   So it is not suitable for use withing fold_stmt and similar uses.  */\n+\n+bool\n+ipa_polymorphic_call_context::get_dynamic_type (tree instance,\n+\t\t\t\t\t\ttree otr_object,\n+\t\t\t\t\t\ttree otr_type,\n+\t\t\t\t\t\tgimple call)\n+{\n+  struct type_change_info tci;\n+  ao_ref ao;\n+  bool function_entry_reached = false;\n+  tree instance_ref = NULL;\n+  gimple stmt = call;\n+  /* Remember OFFSET before it is modified by restrict_to_inner_class.\n+     This is because we do not update INSTANCE when walking inwards.  */\n+  HOST_WIDE_INT instance_offset = offset;\n+\n+  otr_type = TYPE_MAIN_VARIANT (otr_type);\n+\n+  /* Walk into inner type. This may clear maybe_derived_type and save us\n+     from useless work.  It also makes later comparsions with static type\n+     easier.  */\n+  if (outer_type)\n+    {\n+      if (!restrict_to_inner_class (otr_type))\n+        return false;\n+    }\n+\n+  if (!maybe_in_construction && !maybe_derived_type)\n+    return false;\n+\n+  /* We need to obtain refernce to virtual table pointer.  It is better\n+     to look it up in the code rather than build our own.  This require bit\n+     of pattern matching, but we end up verifying that what we found is\n+     correct. \n+\n+     What we pattern match is:\n+\n+       tmp = instance->_vptr.A;   // vtbl ptr load\n+       tmp2 = tmp[otr_token];\t  // vtable lookup\n+       OBJ_TYPE_REF(tmp2;instance->0) (instance);\n+ \n+     We want to start alias oracle walk from vtbl pointer load,\n+     but we may not be able to identify it, for example, when PRE moved the\n+     load around.  */\n+\n+  if (gimple_code (call) == GIMPLE_CALL)\n+    {\n+      tree ref = gimple_call_fn (call);\n+      HOST_WIDE_INT offset2, size, max_size;\n+\n+      if (TREE_CODE (ref) == OBJ_TYPE_REF)\n+\t{\n+\t  ref = OBJ_TYPE_REF_EXPR (ref);\n+\t  ref = walk_ssa_copies (ref);\n+\n+\t  /* Check if definition looks like vtable lookup.  */\n+\t  if (TREE_CODE (ref) == SSA_NAME\n+\t      && !SSA_NAME_IS_DEFAULT_DEF (ref)\n+\t      && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref))\n+\t      && TREE_CODE (gimple_assign_rhs1\n+\t\t\t     (SSA_NAME_DEF_STMT (ref))) == MEM_REF)\n+\t    {\n+\t      ref = get_base_address\n+\t\t     (TREE_OPERAND (gimple_assign_rhs1\n+\t\t\t\t     (SSA_NAME_DEF_STMT (ref)), 0));\n+\t      ref = walk_ssa_copies (ref);\n+\t      /* Find base address of the lookup and see if it looks like\n+\t\t vptr load.  */\n+\t      if (TREE_CODE (ref) == SSA_NAME\n+\t\t  && !SSA_NAME_IS_DEFAULT_DEF (ref)\n+\t\t  && gimple_assign_load_p (SSA_NAME_DEF_STMT (ref)))\n+\t\t{\n+\t\t  tree ref_exp = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (ref));\n+\t\t  tree base_ref = get_ref_base_and_extent\n+\t\t\t\t   (ref_exp, &offset2, &size, &max_size);\n+\n+\t\t  /* Finally verify that what we found looks like read from OTR_OBJECT\n+\t\t     or from INSTANCE with offset OFFSET.  */\n+\t\t  if (base_ref\n+\t\t      && ((TREE_CODE (base_ref) == MEM_REF\n+\t\t           && ((offset2 == instance_offset\n+\t\t                && TREE_OPERAND (base_ref, 0) == instance)\n+\t\t\t       || (!offset2 && TREE_OPERAND (base_ref, 0) == otr_object)))\n+\t\t\t  || (DECL_P (instance) && base_ref == instance\n+\t\t\t      && offset2 == instance_offset)))\n+\t\t    {\n+\t\t      stmt = SSA_NAME_DEF_STMT (ref);\n+\t\t      instance_ref = ref_exp;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+ \n+  /* If we failed to look up the refernece in code, build our own.  */\n+  if (!instance_ref)\n+    {\n+      /* If the statement in question does not use memory, we can't tell\n+\t anything.  */\n+      if (!gimple_vuse (stmt))\n+\treturn false;\n+      ao_ref_init_from_ptr_and_size (&ao, otr_object, NULL);\n+    }\n+  else\n+  /* Otherwise use the real reference.  */\n+    ao_ref_init (&ao, instance_ref);\n+\n+  /* We look for vtbl pointer read.  */\n+  ao.size = POINTER_SIZE;\n+  ao.max_size = ao.size;\n+  ao.ref_alias_set\n+    = get_deref_alias_set (TREE_TYPE (BINFO_VTABLE (TYPE_BINFO (otr_type))));\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Determining dynamic type for call: \");\n+      print_gimple_stmt (dump_file, call, 0, 0);\n+      fprintf (dump_file, \"  Starting walk at: \");\n+      print_gimple_stmt (dump_file, stmt, 0, 0);\n+      fprintf (dump_file, \"  instance pointer: \");\n+      print_generic_expr (dump_file, otr_object, TDF_SLIM);\n+      fprintf (dump_file, \"  Outer instance pointer: \");\n+      print_generic_expr (dump_file, instance, TDF_SLIM);\n+      fprintf (dump_file, \" offset: %i (bits)\", (int)offset);\n+      fprintf (dump_file, \" vtbl reference: \");\n+      print_generic_expr (dump_file, instance_ref, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  tci.offset = offset;\n+  tci.instance = instance;\n+  tci.vtbl_ptr_ref = instance_ref;\n+  gcc_assert (TREE_CODE (instance) != MEM_REF);\n+  tci.known_current_type = NULL_TREE;\n+  tci.known_current_offset = 0;\n+  tci.otr_type = otr_type;\n+  tci.type_maybe_changed = false;\n+  tci.multiple_types_encountered = false;\n+  tci.speculative = false;\n+  tci.seen_unanalyzed_store = false;\n+\n+  walk_aliased_vdefs (&ao, gimple_vuse (stmt), check_stmt_for_type_change,\n+\t\t      &tci, NULL, &function_entry_reached);\n+\n+  /* If we did not find any type changing statements, we may still drop\n+     maybe_in_construction flag if the context already have outer type. \n+\n+     Here we make special assumptions about both constructors and\n+     destructors which are all the functions that are allowed to alter the\n+     VMT pointers.  It assumes that destructors begin with assignment into\n+     all VMT pointers and that constructors essentially look in the\n+     following way:\n+\n+     1) The very first thing they do is that they call constructors of\n+     ancestor sub-objects that have them.\n+\n+     2) Then VMT pointers of this and all its ancestors is set to new\n+     values corresponding to the type corresponding to the constructor.\n+\n+     3) Only afterwards, other stuff such as constructor of member\n+     sub-objects and the code written by the user is run.  Only this may\n+     include calling virtual functions, directly or indirectly.\n+\n+     4) placement new can not be used to change type of non-POD statically\n+     allocated variables.\n+\n+     There is no way to call a constructor of an ancestor sub-object in any\n+     other way.\n+\n+     This means that we do not have to care whether constructors get the\n+     correct type information because they will always change it (in fact,\n+     if we define the type to be given by the VMT pointer, it is undefined).\n+\n+     The most important fact to derive from the above is that if, for some\n+     statement in the section 3, we try to detect whether the dynamic type\n+     has changed, we can safely ignore all calls as we examine the function\n+     body backwards until we reach statements in section 2 because these\n+     calls cannot be ancestor constructors or destructors (if the input is\n+     not bogus) and so do not change the dynamic type (this holds true only\n+     for automatically allocated objects but at the moment we devirtualize\n+     only these).  We then must detect that statements in section 2 change\n+     the dynamic type and can try to derive the new type.  That is enough\n+     and we can stop, we will never see the calls into constructors of\n+     sub-objects in this code. \n+\n+     Therefore if the static outer type was found (outer_type)\n+     we can safely ignore tci.speculative that is set on calls and give up\n+     only if there was dyanmic type store that may affect given variable\n+     (seen_unanalyzed_store)  */\n+\n+  if (!tci.type_maybe_changed\n+      || (outer_type\n+\t  && !tci.seen_unanalyzed_store\n+\t  && !tci.multiple_types_encountered\n+\t  && offset == tci.offset\n+\t  && types_same_for_odr (tci.known_current_type,\n+\t\t\t\t outer_type)))\n+    {\n+      if (!outer_type || tci.seen_unanalyzed_store)\n+\treturn false;\n+      if (maybe_in_construction)\n+        maybe_in_construction = false;\n+      if (dump_file)\n+\tfprintf (dump_file, \"  No dynamic type change found.\\n\");\n+      return true;\n+    }\n+\n+  if (tci.known_current_type\n+      && !function_entry_reached\n+      && !tci.multiple_types_encountered)\n+    {\n+      if (!tci.speculative)\n+\t{\n+\t  outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n+\t  offset = tci.known_current_offset;\n+\t  maybe_in_construction = false;\n+\t  maybe_derived_type = false;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Determined dynamic type.\\n\");\n+\t}\n+      else if (!speculative_outer_type\n+\t       || speculative_maybe_derived_type)\n+\t{\n+\t  speculative_outer_type = TYPE_MAIN_VARIANT (tci.known_current_type);\n+\t  speculative_offset = tci.known_current_offset;\n+\t  speculative_maybe_derived_type = false;\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"  Determined speculative dynamic type.\\n\");\n+\t}\n+    }\n+  else if (dump_file)\n+    {\n+      fprintf (dump_file, \"  Found multiple types%s%s\\n\",\n+\t       function_entry_reached ? \" (function entry reached)\" : \"\",\n+\t       function_entry_reached ? \" (multiple types encountered)\" : \"\");\n+    }\n+\n+  return true;\n+}\n+"}, {"sha": "029f39a0462ea49ea53ed62ecd5082c0ad1ac488", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa803cc76ee6a0a4f951b20912def90880c996c1/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=aa803cc76ee6a0a4f951b20912def90880c996c1", "patch": "@@ -74,9 +74,14 @@ tree method_class_type (const_tree);\n bool decl_maybe_in_construction_p (tree, tree, gimple, tree);\n tree vtable_pointer_value_to_binfo (const_tree);\n bool vtable_pointer_value_to_vtable (const_tree, tree *, unsigned HOST_WIDE_INT *);\n+tree subbinfo_with_vtable_at_offset (tree, unsigned HOST_WIDE_INT, tree);\n void compare_virtual_tables (varpool_node *, varpool_node *);\n+bool type_all_derivations_known_p (const_tree);\n+bool type_known_to_have_no_deriavations_p (tree);\n bool contains_polymorphic_type_p (const_tree);\n void register_odr_type (tree);\n+bool types_must_be_same_for_odr (tree, tree);\n+bool types_odr_comparable (tree, tree);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If COMPLETEP is non-NULL, store true if the list is complette. \n@@ -162,6 +167,21 @@ odr_type_p (const_tree t)\n   return (TYPE_NAME (t)\n           && (DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t))));\n }\n+\n+/* Return true if BINFO corresponds to a type with virtual methods. \n+\n+   Every type has several BINFOs.  One is the BINFO associated by the type\n+   while other represents bases of derived types.  The BINFOs representing\n+   bases do not have BINFO_VTABLE pointer set when this is the single\n+   inheritance (because vtables are shared).  Look up the BINFO of type\n+   and check presence of its vtable.  */\n+\n+inline bool\n+polymorphic_type_binfo_p (const_tree binfo)\n+{\n+  /* See if BINFO's type has an virtual table associtated with it.  */\n+  return BINFO_VTABLE (TYPE_BINFO (BINFO_TYPE (binfo)));\n+}\n #endif  /* GCC_IPA_UTILS_H  */\n \n "}]}