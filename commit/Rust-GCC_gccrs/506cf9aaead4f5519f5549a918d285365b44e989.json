{"sha": "506cf9aaead4f5519f5549a918d285365b44e989", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2Y2Y5YWFlYWQ0ZjU1MTlmNTU0OWE5MThkMjg1MzY1YjQ0ZTk4OQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-02T19:34:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-02T19:34:41Z"}, "message": "libgo: Update to weekly.2011-11-01.\n\nFrom-SVN: r181938", "tree": {"sha": "fe0344f264049738dca876a6dd2f69e96621ca17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe0344f264049738dca876a6dd2f69e96621ca17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/506cf9aaead4f5519f5549a918d285365b44e989", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506cf9aaead4f5519f5549a918d285365b44e989", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506cf9aaead4f5519f5549a918d285365b44e989", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506cf9aaead4f5519f5549a918d285365b44e989/comments", "author": null, "committer": null, "parents": [{"sha": "bfa9b58039ceacb1bae803fbbfb049b93540f2a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa9b58039ceacb1bae803fbbfb049b93540f2a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa9b58039ceacb1bae803fbbfb049b93540f2a7"}], "stats": {"total": 3851, "additions": 2243, "deletions": 1608}, "files": [{"sha": "f63d1694922efd89d03002b5d22372cb390e5514", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5876,13 +5876,13 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n   ret->append(\"interface {\");\n   if (this->methods_ != NULL)\n     {\n+      ret->push_back(' ');\n       for (Typed_identifier_list::const_iterator p = this->methods_->begin();\n \t   p != this->methods_->end();\n \t   ++p)\n \t{\n \t  if (p != this->methods_->begin())\n-\t    ret->append(\";\");\n-\t  ret->push_back(' ');\n+\t    ret->append(\"; \");\n \t  if (!Gogo::is_hidden_name(p->name()))\n \t    ret->append(p->name());\n \t  else\n@@ -5898,8 +5898,9 @@ Interface_type::do_reflection(Gogo* gogo, std::string* ret) const\n \t  sub = sub.substr(4);\n \t  ret->append(sub);\n \t}\n+      ret->push_back(' ');\n     }\n-  ret->append(\" }\");\n+  ret->append(\"}\");\n }\n \n // Mangled name."}, {"sha": "f30af59816811f9f6e577b5c982e57e1b018f222", "filename": "libgo/config.h.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -33,18 +33,12 @@\n /* Define to 1 if the system has the type `off64_t'. */\n #undef HAVE_OFF64_T\n \n-/* Define to 1 if you have the `random' function. */\n-#undef HAVE_RANDOM\n-\n /* Define to 1 if you have the `sem_timedwait' function. */\n #undef HAVE_SEM_TIMEDWAIT\n \n /* Define to 1 if you have the `setenv' function. */\n #undef HAVE_SETENV\n \n-/* Define to 1 if you have the `srandom' function. */\n-#undef HAVE_SRANDOM\n-\n /* Define to 1 if you have the <stdint.h> header file. */\n #undef HAVE_STDINT_H\n "}, {"sha": "2e99887e62dfb40f6a7d61f3f76072e343100788", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -14529,7 +14529,7 @@ else\n fi\n \n \n-for ac_func in srandom random strerror_r strsignal wait4 mincore setenv\n+for ac_func in strerror_r strsignal wait4 mincore setenv\n do :\n   as_ac_var=`$as_echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n ac_fn_c_check_func \"$LINENO\" \"$ac_func\" \"$as_ac_var\""}, {"sha": "62d4c9599915f5589ef7d6da9dc875fae86ddc6d", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -452,7 +452,7 @@ AC_CHECK_HEADERS([linux/filter.h linux/netlink.h linux/rtnetlink.h], [], [],\n \n AM_CONDITIONAL(HAVE_SYS_MMAN_H, test \"$ac_cv_header_sys_mman_h\" = yes)\n \n-AC_CHECK_FUNCS(srandom random strerror_r strsignal wait4 mincore setenv)\n+AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv)\n AM_CONDITIONAL(HAVE_STRERROR_R, test \"$ac_cv_func_strerror_r\" = yes)\n AM_CONDITIONAL(HAVE_WAIT4, test \"$ac_cv_func_wait4\" = yes)\n "}, {"sha": "4f9f599a1484d507f696f79158d2f5129d963a85", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -60,10 +60,10 @@ type directoryEnd struct {\n \tcomment            string\n }\n \n-func recoverError(err *os.Error) {\n+func recoverError(errp *os.Error) {\n \tif e := recover(); e != nil {\n-\t\tif osErr, ok := e.(os.Error); ok {\n-\t\t\t*err = osErr\n+\t\tif err, ok := e.(os.Error); ok {\n+\t\t\t*errp = err\n \t\t\treturn\n \t\t}\n \t\tpanic(e)"}, {"sha": "db13d20f71c3875c21b1c4a27d8ff151d23011a6", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -302,7 +302,7 @@ func (x *Int) String() string {\n \treturn x.abs.decimalString()\n }\n \n-func charset(ch int) string {\n+func charset(ch rune) string {\n \tswitch ch {\n \tcase 'b':\n \t\treturn lowercaseDigits[0:2]\n@@ -339,7 +339,7 @@ func writeMultiple(s fmt.State, text string, count int) {\n // output field width, space or zero padding, and left or\n // right justification.\n //\n-func (x *Int) Format(s fmt.State, ch int) {\n+func (x *Int) Format(s fmt.State, ch rune) {\n \tcs := charset(ch)\n \n \t// special cases\n@@ -460,7 +460,7 @@ func (z *Int) scan(r io.RuneScanner, base int) (*Int, int, os.Error) {\n // Scan is a support routine for fmt.Scanner; it sets z to the value of\n // the scanned number. It accepts the formats 'b' (binary), 'o' (octal),\n // 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).\n-func (z *Int) Scan(s fmt.ScanState, ch int) os.Error {\n+func (z *Int) Scan(s fmt.ScanState, ch rune) os.Error {\n \ts.SkipSpace() // skip leading space characters\n \tbase := 0\n \tswitch ch {"}, {"sha": "d66bb5fa0530c877139a50f744213b79c3d3855f", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -536,7 +536,7 @@ func TestScan(t *testing.T) {\n \t\tbuf.Reset()\n \t\tbuf.WriteString(test.input)\n \t\tif _, err := fmt.Fscanf(&buf, test.format, x); err != nil {\n-\t\t\tt.Errorf(\"#%d error: %s\", i, err.String())\n+\t\t\tt.Errorf(\"#%d error: %s\", i, err)\n \t\t}\n \t\tif x.String() != test.output {\n \t\t\tt.Errorf(\"#%d got %s; want %s\", i, x.String(), test.output)"}, {"sha": "fa0d7e72277c482fd5c10b779266488213cf6640", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -589,15 +589,15 @@ func (x nat) bitLen() int {\n // MaxBase is the largest number base accepted for string conversions.\n const MaxBase = 'z' - 'a' + 10 + 1 // = hexValue('z') + 1\n \n-func hexValue(ch int) Word {\n+func hexValue(ch rune) Word {\n \td := MaxBase + 1 // illegal base\n \tswitch {\n \tcase '0' <= ch && ch <= '9':\n-\t\td = ch - '0'\n+\t\td = int(ch - '0')\n \tcase 'a' <= ch && ch <= 'z':\n-\t\td = ch - 'a' + 10\n+\t\td = int(ch - 'a' + 10)\n \tcase 'A' <= ch && ch <= 'Z':\n-\t\td = ch - 'A' + 10\n+\t\td = int(ch - 'A' + 10)\n \t}\n \treturn Word(d)\n }"}, {"sha": "ab34c6ec189fd47c154066adfb6661670db5f94b", "filename": "libgo/go/big/nat_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -231,7 +231,7 @@ var natScanTests = []struct {\n \tx    nat    // expected nat\n \tb    int    // expected base\n \tok   bool   // expected success\n-\tnext int    // next character (or 0, if at EOF)\n+\tnext rune   // next character (or 0, if at EOF)\n }{\n \t// error: illegal base\n \t{base: -1},"}, {"sha": "1940a05494da0454211c031add8129fdc6c11e97", "filename": "libgo/go/big/rat.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -249,13 +249,13 @@ func (z *Rat) Quo(x, y *Rat) *Rat {\n \treturn z.norm()\n }\n \n-func ratTok(ch int) bool {\n+func ratTok(ch rune) bool {\n \treturn strings.IndexRune(\"+-/0123456789.eE\", ch) >= 0\n }\n \n // Scan is a support routine for fmt.Scanner. It accepts the formats\n // 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.\n-func (z *Rat) Scan(s fmt.ScanState, ch int) os.Error {\n+func (z *Rat) Scan(s fmt.ScanState, ch rune) os.Error {\n \ttok, err := s.Token(true, ratTok)\n \tif err != nil {\n \t\treturn err"}, {"sha": "2443450411323d49e0672d99c92a16b341675b77", "filename": "libgo/go/big/rat_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Frat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbig%2Frat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Frat_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -112,7 +112,7 @@ func TestRatScan(t *testing.T) {\n \t\t_, err := fmt.Fscanf(&buf, \"%v\", x)\n \t\tif err == nil != test.ok {\n \t\t\tif test.ok {\n-\t\t\t\tt.Errorf(\"#%d error: %s\", i, err.String())\n+\t\t\t\tt.Errorf(\"#%d error: %s\", i, err)\n \t\t\t} else {\n \t\t\t\tt.Errorf(\"#%d expected error\", i)\n \t\t\t}"}, {"sha": "3a4e0ed8b02bdf82c8b38b1a08269ce926f7dd4a", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -208,22 +208,22 @@ func (b *Reader) UnreadByte() os.Error {\n \n // ReadRune reads a single UTF-8 encoded Unicode character and returns the\n // rune and its size in bytes.\n-func (b *Reader) ReadRune() (rune int, size int, err os.Error) {\n+func (b *Reader) ReadRune() (r rune, size int, err os.Error) {\n \tfor b.r+utf8.UTFMax > b.w && !utf8.FullRune(b.buf[b.r:b.w]) && b.err == nil {\n \t\tb.fill()\n \t}\n \tb.lastRuneSize = -1\n \tif b.r == b.w {\n \t\treturn 0, 0, b.readErr()\n \t}\n-\trune, size = int(b.buf[b.r]), 1\n-\tif rune >= 0x80 {\n-\t\trune, size = utf8.DecodeRune(b.buf[b.r:b.w])\n+\tr, size = rune(b.buf[b.r]), 1\n+\tif r >= 0x80 {\n+\t\tr, size = utf8.DecodeRune(b.buf[b.r:b.w])\n \t}\n \tb.r += size\n \tb.lastByte = int(b.buf[b.r-1])\n \tb.lastRuneSize = size\n-\treturn rune, size, nil\n+\treturn r, size, nil\n }\n \n // UnreadRune unreads the last rune.  If the most recent read operation on\n@@ -497,9 +497,9 @@ func (b *Writer) WriteByte(c byte) os.Error {\n \n // WriteRune writes a single Unicode code point, returning\n // the number of bytes written and any error.\n-func (b *Writer) WriteRune(rune int) (size int, err os.Error) {\n-\tif rune < utf8.RuneSelf {\n-\t\terr = b.WriteByte(byte(rune))\n+func (b *Writer) WriteRune(r rune) (size int, err os.Error) {\n+\tif r < utf8.RuneSelf {\n+\t\terr = b.WriteByte(byte(r))\n \t\tif err != nil {\n \t\t\treturn 0, err\n \t\t}\n@@ -516,10 +516,10 @@ func (b *Writer) WriteRune(rune int) (size int, err os.Error) {\n \t\tn = b.Available()\n \t\tif n < utf8.UTFMax {\n \t\t\t// Can only happen if buffer is silly small.\n-\t\t\treturn b.WriteString(string(rune))\n+\t\t\treturn b.WriteString(string(r))\n \t\t}\n \t}\n-\tsize = utf8.EncodeRune(b.buf[b.n:], rune)\n+\tsize = utf8.EncodeRune(b.buf[b.n:], r)\n \tb.n += size\n \treturn size, nil\n }"}, {"sha": "4fd5f90b8eecee7991c10a1f17f9a0ddc58938f6", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -195,14 +195,14 @@ func readRuneSegments(t *testing.T, segments []string) {\n \twant := strings.Join(segments, \"\")\n \tr := NewReader(&StringReader{data: segments})\n \tfor {\n-\t\trune, _, err := r.ReadRune()\n+\t\tr, _, err := r.ReadRune()\n \t\tif err != nil {\n \t\t\tif err != os.EOF {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tbreak\n \t\t}\n-\t\tgot += string(rune)\n+\t\tgot += string(r)\n \t}\n \tif got != want {\n \t\tt.Errorf(\"segments=%v got=%s want=%s\", segments, got, want)\n@@ -233,24 +233,24 @@ func TestUnreadRune(t *testing.T) {\n \tr := NewReader(&StringReader{data: segments})\n \t// Normal execution.\n \tfor {\n-\t\trune, _, err := r.ReadRune()\n+\t\tr1, _, err := r.ReadRune()\n \t\tif err != nil {\n \t\t\tif err != os.EOF {\n \t\t\t\tt.Error(\"unexpected EOF\")\n \t\t\t}\n \t\t\tbreak\n \t\t}\n-\t\tgot += string(rune)\n+\t\tgot += string(r1)\n \t\t// Put it back and read it again\n \t\tif err = r.UnreadRune(); err != nil {\n \t\t\tt.Error(\"unexpected error on UnreadRune:\", err)\n \t\t}\n-\t\trune1, _, err := r.ReadRune()\n+\t\tr2, _, err := r.ReadRune()\n \t\tif err != nil {\n \t\t\tt.Error(\"unexpected error reading after unreading:\", err)\n \t\t}\n-\t\tif rune != rune1 {\n-\t\t\tt.Errorf(\"incorrect rune after unread: got %c wanted %c\", rune1, rune)\n+\t\tif r1 != r2 {\n+\t\t\tt.Errorf(\"incorrect rune after unread: got %c wanted %c\", r1, r2)\n \t\t}\n \t}\n \tif got != data {\n@@ -339,25 +339,25 @@ func TestReadWriteRune(t *testing.T) {\n \tw := NewWriter(byteBuf)\n \t// Write the runes out using WriteRune\n \tbuf := make([]byte, utf8.UTFMax)\n-\tfor rune := 0; rune < NRune; rune++ {\n-\t\tsize := utf8.EncodeRune(buf, rune)\n-\t\tnbytes, err := w.WriteRune(rune)\n+\tfor r := rune(0); r < NRune; r++ {\n+\t\tsize := utf8.EncodeRune(buf, r)\n+\t\tnbytes, err := w.WriteRune(r)\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"WriteRune(0x%x) error: %s\", rune, err)\n+\t\t\tt.Fatalf(\"WriteRune(0x%x) error: %s\", r, err)\n \t\t}\n \t\tif nbytes != size {\n-\t\t\tt.Fatalf(\"WriteRune(0x%x) expected %d, got %d\", rune, size, nbytes)\n+\t\t\tt.Fatalf(\"WriteRune(0x%x) expected %d, got %d\", r, size, nbytes)\n \t\t}\n \t}\n \tw.Flush()\n \n \tr := NewReader(byteBuf)\n \t// Read them back with ReadRune\n-\tfor rune := 0; rune < NRune; rune++ {\n-\t\tsize := utf8.EncodeRune(buf, rune)\n+\tfor r1 := rune(0); r1 < NRune; r1++ {\n+\t\tsize := utf8.EncodeRune(buf, r1)\n \t\tnr, nbytes, err := r.ReadRune()\n-\t\tif nr != rune || nbytes != size || err != nil {\n-\t\t\tt.Fatalf(\"ReadRune(0x%x) got 0x%x,%d not 0x%x,%d (err=%s)\", r, nr, nbytes, r, size, err)\n+\t\tif nr != r1 || nbytes != size || err != nil {\n+\t\t\tt.Fatalf(\"ReadRune(0x%x) got 0x%x,%d not 0x%x,%d (err=%s)\", r1, nr, nbytes, r1, size, err)\n \t\t}\n \t}\n }"}, {"sha": "c2a8c9fe59a1dac78881ffb646bd512ec834fac7", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -188,7 +188,7 @@ func (b *Buffer) WriteByte(c byte) os.Error {\n // code point r to the buffer, returning its length and\n // an error, which is always nil but is included\n // to match bufio.Writer's WriteRune.\n-func (b *Buffer) WriteRune(r int) (n int, err os.Error) {\n+func (b *Buffer) WriteRune(r rune) (n int, err os.Error) {\n \tif r < utf8.RuneSelf {\n \t\tb.WriteByte(byte(r))\n \t\treturn 1, nil\n@@ -255,7 +255,7 @@ func (b *Buffer) ReadByte() (c byte, err os.Error) {\n // If no bytes are available, the error returned is os.EOF.\n // If the bytes are an erroneous UTF-8 encoding, it\n // consumes one byte and returns U+FFFD, 1.\n-func (b *Buffer) ReadRune() (r int, size int, err os.Error) {\n+func (b *Buffer) ReadRune() (r rune, size int, err os.Error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n@@ -266,7 +266,7 @@ func (b *Buffer) ReadRune() (r int, size int, err os.Error) {\n \tc := b.buf[b.off]\n \tif c < utf8.RuneSelf {\n \t\tb.off++\n-\t\treturn int(c), 1, nil\n+\t\treturn rune(c), 1, nil\n \t}\n \tr, n := utf8.DecodeRune(b.buf[b.off:])\n \tb.off += n"}, {"sha": "ee38e084a5ce70e714029342d19cc32cbaee54c9", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -264,7 +264,7 @@ func TestRuneIO(t *testing.T) {\n \tb := make([]byte, utf8.UTFMax*NRune)\n \tvar buf Buffer\n \tn := 0\n-\tfor r := 0; r < NRune; r++ {\n+\tfor r := rune(0); r < NRune; r++ {\n \t\tsize := utf8.EncodeRune(b[n:], r)\n \t\tnbytes, err := buf.WriteRune(r)\n \t\tif err != nil {\n@@ -284,7 +284,7 @@ func TestRuneIO(t *testing.T) {\n \n \tp := make([]byte, utf8.UTFMax)\n \t// Read it back with ReadRune\n-\tfor r := 0; r < NRune; r++ {\n+\tfor r := rune(0); r < NRune; r++ {\n \t\tsize := utf8.EncodeRune(p, r)\n \t\tnr, nbytes, err := buf.ReadRune()\n \t\tif nr != r || nbytes != size || err != nil {\n@@ -295,7 +295,7 @@ func TestRuneIO(t *testing.T) {\n \t// Check that UnreadRune works\n \tbuf.Reset()\n \tbuf.Write(b)\n-\tfor r := 0; r < NRune; r++ {\n+\tfor r := rune(0); r < NRune; r++ {\n \t\tr1, size, _ := buf.ReadRune()\n \t\tif err := buf.UnreadRune(); err != nil {\n \t\t\tt.Fatalf(\"UnreadRune(%U) got error %q\", r, err)"}, {"sha": "ac8320fe6b4f5514a5922e8c2c18fa8feccc3693", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -130,10 +130,10 @@ func LastIndex(s, sep []byte) int {\n // IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It returns the byte index of the first occurrence in s of the given rune.\n // It returns -1 if rune is not present in s.\n-func IndexRune(s []byte, rune int) int {\n+func IndexRune(s []byte, r rune) int {\n \tfor i := 0; i < len(s); {\n-\t\tr, size := utf8.DecodeRune(s[i:])\n-\t\tif r == rune {\n+\t\tr1, size := utf8.DecodeRune(s[i:])\n+\t\tif r == r1 {\n \t\t\treturn i\n \t\t}\n \t\ti += size\n@@ -147,16 +147,17 @@ func IndexRune(s []byte, rune int) int {\n // point in common.\n func IndexAny(s []byte, chars string) int {\n \tif len(chars) > 0 {\n-\t\tvar rune, width int\n+\t\tvar r rune\n+\t\tvar width int\n \t\tfor i := 0; i < len(s); i += width {\n-\t\t\trune = int(s[i])\n-\t\t\tif rune < utf8.RuneSelf {\n+\t\t\tr = rune(s[i])\n+\t\t\tif r < utf8.RuneSelf {\n \t\t\t\twidth = 1\n \t\t\t} else {\n-\t\t\t\trune, width = utf8.DecodeRune(s[i:])\n+\t\t\t\tr, width = utf8.DecodeRune(s[i:])\n \t\t\t}\n-\t\t\tfor _, r := range chars {\n-\t\t\t\tif rune == r {\n+\t\t\tfor _, ch := range chars {\n+\t\t\t\tif r == ch {\n \t\t\t\t\treturn i\n \t\t\t\t}\n \t\t\t}\n@@ -172,10 +173,10 @@ func IndexAny(s []byte, chars string) int {\n func LastIndexAny(s []byte, chars string) int {\n \tif len(chars) > 0 {\n \t\tfor i := len(s); i > 0; {\n-\t\t\trune, size := utf8.DecodeLastRune(s[0:i])\n+\t\t\tr, size := utf8.DecodeLastRune(s[0:i])\n \t\t\ti -= size\n-\t\t\tfor _, m := range chars {\n-\t\t\t\tif rune == m {\n+\t\t\tfor _, ch := range chars {\n+\t\t\t\tif r == ch {\n \t\t\t\t\treturn i\n \t\t\t\t}\n \t\t\t}\n@@ -256,13 +257,13 @@ func Fields(s []byte) [][]byte {\n // It splits the array s at each run of code points c satisfying f(c) and\n // returns a slice of subarrays of s.  If no code points in s satisfy f(c), an\n // empty slice is returned.\n-func FieldsFunc(s []byte, f func(int) bool) [][]byte {\n+func FieldsFunc(s []byte, f func(rune) bool) [][]byte {\n \tn := 0\n \tinField := false\n \tfor i := 0; i < len(s); {\n-\t\trune, size := utf8.DecodeRune(s[i:])\n+\t\tr, size := utf8.DecodeRune(s[i:])\n \t\twasInField := inField\n-\t\tinField = !f(rune)\n+\t\tinField = !f(r)\n \t\tif inField && !wasInField {\n \t\t\tn++\n \t\t}\n@@ -273,13 +274,13 @@ func FieldsFunc(s []byte, f func(int) bool) [][]byte {\n \tna := 0\n \tfieldStart := -1\n \tfor i := 0; i <= len(s) && na < n; {\n-\t\trune, size := utf8.DecodeRune(s[i:])\n-\t\tif fieldStart < 0 && size > 0 && !f(rune) {\n+\t\tr, size := utf8.DecodeRune(s[i:])\n+\t\tif fieldStart < 0 && size > 0 && !f(r) {\n \t\t\tfieldStart = i\n \t\t\ti += size\n \t\t\tcontinue\n \t\t}\n-\t\tif fieldStart >= 0 && (size == 0 || f(rune)) {\n+\t\tif fieldStart >= 0 && (size == 0 || f(r)) {\n \t\t\ta[na] = s[fieldStart:i]\n \t\t\tna++\n \t\t\tfieldStart = -1\n@@ -329,7 +330,7 @@ func HasSuffix(s, suffix []byte) bool {\n // according to the mapping function. If mapping returns a negative value, the character is\n // dropped from the string with no replacement.  The characters in s and the\n // output are interpreted as UTF-8-encoded Unicode code points.\n-func Map(mapping func(rune int) int, s []byte) []byte {\n+func Map(mapping func(r rune) rune, s []byte) []byte {\n \t// In the worst case, the array can grow when mapped, making\n \t// things unpleasant.  But it's so rare we barge in assuming it's\n \t// fine.  It could also shrink but that falls out naturally.\n@@ -338,20 +339,20 @@ func Map(mapping func(rune int) int, s []byte) []byte {\n \tb := make([]byte, maxbytes)\n \tfor i := 0; i < len(s); {\n \t\twid := 1\n-\t\trune := int(s[i])\n-\t\tif rune >= utf8.RuneSelf {\n-\t\t\trune, wid = utf8.DecodeRune(s[i:])\n+\t\tr := rune(s[i])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, wid = utf8.DecodeRune(s[i:])\n \t\t}\n-\t\trune = mapping(rune)\n-\t\tif rune >= 0 {\n-\t\t\tif nbytes+utf8.RuneLen(rune) > maxbytes {\n+\t\tr = mapping(r)\n+\t\tif r >= 0 {\n+\t\t\tif nbytes+utf8.RuneLen(r) > maxbytes {\n \t\t\t\t// Grow the buffer.\n \t\t\t\tmaxbytes = maxbytes*2 + utf8.UTFMax\n \t\t\t\tnb := make([]byte, maxbytes)\n \t\t\t\tcopy(nb, b[0:nbytes])\n \t\t\t\tb = nb\n \t\t\t}\n-\t\t\tnbytes += utf8.EncodeRune(b[nbytes:maxbytes], rune)\n+\t\t\tnbytes += utf8.EncodeRune(b[nbytes:maxbytes], r)\n \t\t}\n \t\ti += wid\n \t}\n@@ -383,44 +384,44 @@ func ToTitle(s []byte) []byte { return Map(unicode.ToTitle, s) }\n // ToUpperSpecial returns a copy of the byte array s with all Unicode letters mapped to their\n // upper case, giving priority to the special casing rules.\n func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r int) int { return _case.ToUpper(r) }, s)\n+\treturn Map(func(r rune) rune { return _case.ToUpper(r) }, s)\n }\n \n // ToLowerSpecial returns a copy of the byte array s with all Unicode letters mapped to their\n // lower case, giving priority to the special casing rules.\n func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r int) int { return _case.ToLower(r) }, s)\n+\treturn Map(func(r rune) rune { return _case.ToLower(r) }, s)\n }\n \n // ToTitleSpecial returns a copy of the byte array s with all Unicode letters mapped to their\n // title case, giving priority to the special casing rules.\n func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte {\n-\treturn Map(func(r int) int { return _case.ToTitle(r) }, s)\n+\treturn Map(func(r rune) rune { return _case.ToTitle(r) }, s)\n }\n \n // isSeparator reports whether the rune could mark a word boundary.\n // TODO: update when package unicode captures more of the properties.\n-func isSeparator(rune int) bool {\n+func isSeparator(r rune) bool {\n \t// ASCII alphanumerics and underscore are not separators\n-\tif rune <= 0x7F {\n+\tif r <= 0x7F {\n \t\tswitch {\n-\t\tcase '0' <= rune && rune <= '9':\n+\t\tcase '0' <= r && r <= '9':\n \t\t\treturn false\n-\t\tcase 'a' <= rune && rune <= 'z':\n+\t\tcase 'a' <= r && r <= 'z':\n \t\t\treturn false\n-\t\tcase 'A' <= rune && rune <= 'Z':\n+\t\tcase 'A' <= r && r <= 'Z':\n \t\t\treturn false\n-\t\tcase rune == '_':\n+\t\tcase r == '_':\n \t\t\treturn false\n \t\t}\n \t\treturn true\n \t}\n \t// Letters and digits are not separators\n-\tif unicode.IsLetter(rune) || unicode.IsDigit(rune) {\n+\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\n \t\treturn false\n \t}\n \t// Otherwise, all we can do for now is treat spaces as separators.\n-\treturn unicode.IsSpace(rune)\n+\treturn unicode.IsSpace(r)\n }\n \n // BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n@@ -431,9 +432,9 @@ func Title(s []byte) []byte {\n \t// Use a closure here to remember state.\n \t// Hackish but effective. Depends on Map scanning in order and calling\n \t// the closure once per rune.\n-\tprev := ' '\n+\tprev := rune(' ')\n \treturn Map(\n-\t\tfunc(r int) int {\n+\t\tfunc(r rune) rune {\n \t\t\tif isSeparator(prev) {\n \t\t\t\tprev = r\n \t\t\t\treturn unicode.ToTitle(r)\n@@ -446,7 +447,7 @@ func Title(s []byte) []byte {\n \n // TrimLeftFunc returns a subslice of s by slicing off all leading UTF-8-encoded\n // Unicode code points c that satisfy f(c).\n-func TrimLeftFunc(s []byte, f func(r int) bool) []byte {\n+func TrimLeftFunc(s []byte, f func(r rune) bool) []byte {\n \ti := indexFunc(s, f, false)\n \tif i == -1 {\n \t\treturn nil\n@@ -456,7 +457,7 @@ func TrimLeftFunc(s []byte, f func(r int) bool) []byte {\n \n // TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8\n // encoded Unicode code points c that satisfy f(c).\n-func TrimRightFunc(s []byte, f func(r int) bool) []byte {\n+func TrimRightFunc(s []byte, f func(r rune) bool) []byte {\n \ti := lastIndexFunc(s, f, false)\n \tif i >= 0 && s[i] >= utf8.RuneSelf {\n \t\t_, wid := utf8.DecodeRune(s[i:])\n@@ -469,36 +470,36 @@ func TrimRightFunc(s []byte, f func(r int) bool) []byte {\n \n // TrimFunc returns a subslice of s by slicing off all leading and trailing\n // UTF-8-encoded Unicode code points c that satisfy f(c).\n-func TrimFunc(s []byte, f func(r int) bool) []byte {\n+func TrimFunc(s []byte, f func(r rune) bool) []byte {\n \treturn TrimRightFunc(TrimLeftFunc(s, f), f)\n }\n \n // IndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It returns the byte index in s of the first Unicode\n // code point satisfying f(c), or -1 if none do.\n-func IndexFunc(s []byte, f func(r int) bool) int {\n+func IndexFunc(s []byte, f func(r rune) bool) int {\n \treturn indexFunc(s, f, true)\n }\n \n // LastIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\n // It returns the byte index in s of the last Unicode\n // code point satisfying f(c), or -1 if none do.\n-func LastIndexFunc(s []byte, f func(r int) bool) int {\n+func LastIndexFunc(s []byte, f func(r rune) bool) int {\n \treturn lastIndexFunc(s, f, true)\n }\n \n // indexFunc is the same as IndexFunc except that if\n // truth==false, the sense of the predicate function is\n // inverted.\n-func indexFunc(s []byte, f func(r int) bool, truth bool) int {\n+func indexFunc(s []byte, f func(r rune) bool, truth bool) int {\n \tstart := 0\n \tfor start < len(s) {\n \t\twid := 1\n-\t\trune := int(s[start])\n-\t\tif rune >= utf8.RuneSelf {\n-\t\t\trune, wid = utf8.DecodeRune(s[start:])\n+\t\tr := rune(s[start])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, wid = utf8.DecodeRune(s[start:])\n \t\t}\n-\t\tif f(rune) == truth {\n+\t\tif f(r) == truth {\n \t\t\treturn start\n \t\t}\n \t\tstart += wid\n@@ -509,21 +510,21 @@ func indexFunc(s []byte, f func(r int) bool, truth bool) int {\n // lastIndexFunc is the same as LastIndexFunc except that if\n // truth==false, the sense of the predicate function is\n // inverted.\n-func lastIndexFunc(s []byte, f func(r int) bool, truth bool) int {\n+func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int {\n \tfor i := len(s); i > 0; {\n-\t\trune, size := utf8.DecodeLastRune(s[0:i])\n+\t\tr, size := utf8.DecodeLastRune(s[0:i])\n \t\ti -= size\n-\t\tif f(rune) == truth {\n+\t\tif f(r) == truth {\n \t\t\treturn i\n \t\t}\n \t}\n \treturn -1\n }\n \n-func makeCutsetFunc(cutset string) func(rune int) bool {\n-\treturn func(rune int) bool {\n+func makeCutsetFunc(cutset string) func(r rune) bool {\n+\treturn func(r rune) bool {\n \t\tfor _, c := range cutset {\n-\t\t\tif c == rune {\n+\t\t\tif c == r {\n \t\t\t\treturn true\n \t\t\t}\n \t\t}\n@@ -556,8 +557,8 @@ func TrimSpace(s []byte) []byte {\n }\n \n // Runes returns a slice of runes (Unicode code points) equivalent to s.\n-func Runes(s []byte) []int {\n-\tt := make([]int, utf8.RuneCount(s))\n+func Runes(s []byte) []rune {\n+\tt := make([]rune, utf8.RuneCount(s))\n \ti := 0\n \tfor len(s) > 0 {\n \t\tr, l := utf8.DecodeRune(s)\n@@ -614,15 +615,15 @@ func Replace(s, old, new []byte, n int) []byte {\n func EqualFold(s, t []byte) bool {\n \tfor len(s) != 0 && len(t) != 0 {\n \t\t// Extract first rune from each.\n-\t\tvar sr, tr int\n+\t\tvar sr, tr rune\n \t\tif s[0] < utf8.RuneSelf {\n-\t\t\tsr, s = int(s[0]), s[1:]\n+\t\t\tsr, s = rune(s[0]), s[1:]\n \t\t} else {\n \t\t\tr, size := utf8.DecodeRune(s)\n \t\t\tsr, s = r, s[size:]\n \t\t}\n \t\tif t[0] < utf8.RuneSelf {\n-\t\t\ttr, t = int(t[0]), t[1:]\n+\t\t\ttr, t = rune(t[0]), t[1:]\n \t\t} else {\n \t\t\tr, size := utf8.DecodeRune(t)\n \t\t\ttr, t = r, t[size:]"}, {"sha": "62f258de8ac32978437c516848f54191e20d006f", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -444,7 +444,7 @@ func TestFields(t *testing.T) {\n }\n \n func TestFieldsFunc(t *testing.T) {\n-\tpred := func(c int) bool { return c == 'X' }\n+\tpred := func(c rune) bool { return c == 'X' }\n \tvar fieldsFuncTests = []FieldsTest{\n \t\t{\"\", []string{}},\n \t\t{\"XX\", []string{}},\n@@ -514,40 +514,40 @@ func runStringTests(t *testing.T, f func([]byte) []byte, funcName string, testCa\n \t}\n }\n \n-func tenRunes(rune int) string {\n-\tr := make([]int, 10)\n-\tfor i := range r {\n-\t\tr[i] = rune\n+func tenRunes(r rune) string {\n+\trunes := make([]rune, 10)\n+\tfor i := range runes {\n+\t\trunes[i] = r\n \t}\n-\treturn string(r)\n+\treturn string(runes)\n }\n \n // User-defined self-inverse mapping function\n-func rot13(rune int) int {\n-\tstep := 13\n-\tif rune >= 'a' && rune <= 'z' {\n-\t\treturn ((rune - 'a' + step) % 26) + 'a'\n+func rot13(r rune) rune {\n+\tconst step = 13\n+\tif r >= 'a' && r <= 'z' {\n+\t\treturn ((r - 'a' + step) % 26) + 'a'\n \t}\n-\tif rune >= 'A' && rune <= 'Z' {\n-\t\treturn ((rune - 'A' + step) % 26) + 'A'\n+\tif r >= 'A' && r <= 'Z' {\n+\t\treturn ((r - 'A' + step) % 26) + 'A'\n \t}\n-\treturn rune\n+\treturn r\n }\n \n func TestMap(t *testing.T) {\n \t// Run a couple of awful growth/shrinkage tests\n \ta := tenRunes('a')\n \n \t// 1.  Grow.  This triggers two reallocations in Map.\n-\tmaxRune := func(rune int) int { return unicode.MaxRune }\n+\tmaxRune := func(r rune) rune { return unicode.MaxRune }\n \tm := Map(maxRune, []byte(a))\n \texpect := tenRunes(unicode.MaxRune)\n \tif string(m) != expect {\n \t\tt.Errorf(\"growing: expected %q got %q\", expect, m)\n \t}\n \n \t// 2. Shrink\n-\tminRune := func(rune int) int { return 'a' }\n+\tminRune := func(r rune) rune { return 'a' }\n \tm = Map(minRune, []byte(tenRunes(unicode.MaxRune)))\n \texpect = a\n \tif string(m) != expect {\n@@ -569,9 +569,9 @@ func TestMap(t *testing.T) {\n \t}\n \n \t// 5. Drop\n-\tdropNotLatin := func(rune int) int {\n-\t\tif unicode.Is(unicode.Latin, rune) {\n-\t\t\treturn rune\n+\tdropNotLatin := func(r rune) rune {\n+\t\tif unicode.Is(unicode.Latin, r) {\n+\t\t\treturn r\n \t\t}\n \t\treturn -1\n \t}\n@@ -615,7 +615,7 @@ func TestRepeat(t *testing.T) {\n \t}\n }\n \n-func runesEqual(a, b []int) bool {\n+func runesEqual(a, b []rune) bool {\n \tif len(a) != len(b) {\n \t\treturn false\n \t}\n@@ -629,18 +629,18 @@ func runesEqual(a, b []int) bool {\n \n type RunesTest struct {\n \tin    string\n-\tout   []int\n+\tout   []rune\n \tlossy bool\n }\n \n var RunesTests = []RunesTest{\n-\t{\"\", []int{}, false},\n-\t{\" \", []int{32}, false},\n-\t{\"ABC\", []int{65, 66, 67}, false},\n-\t{\"abc\", []int{97, 98, 99}, false},\n-\t{\"\\u65e5\\u672c\\u8a9e\", []int{26085, 26412, 35486}, false},\n-\t{\"ab\\x80c\", []int{97, 98, 0xFFFD, 99}, true},\n-\t{\"ab\\xc0c\", []int{97, 98, 0xFFFD, 99}, true},\n+\t{\"\", []rune{}, false},\n+\t{\" \", []rune{32}, false},\n+\t{\"ABC\", []rune{65, 66, 67}, false},\n+\t{\"abc\", []rune{97, 98, 99}, false},\n+\t{\"\\u65e5\\u672c\\u8a9e\", []rune{26085, 26412, 35486}, false},\n+\t{\"ab\\x80c\", []rune{97, 98, 0xFFFD, 99}, true},\n+\t{\"ab\\xc0c\", []rune{97, 98, 0xFFFD, 99}, true},\n }\n \n func TestRunes(t *testing.T) {\n@@ -711,15 +711,15 @@ func TestTrim(t *testing.T) {\n }\n \n type predicate struct {\n-\tf    func(r int) bool\n+\tf    func(r rune) bool\n \tname string\n }\n \n var isSpace = predicate{unicode.IsSpace, \"IsSpace\"}\n var isDigit = predicate{unicode.IsDigit, \"IsDigit\"}\n var isUpper = predicate{unicode.IsUpper, \"IsUpper\"}\n var isValidRune = predicate{\n-\tfunc(r int) bool {\n+\tfunc(r rune) bool {\n \t\treturn r != utf8.RuneError\n \t},\n \t\"IsValidRune\",\n@@ -732,7 +732,7 @@ type TrimFuncTest struct {\n \n func not(p predicate) predicate {\n \treturn predicate{\n-\t\tfunc(r int) bool {\n+\t\tfunc(r rune) bool {\n \t\t\treturn !p.f(r)\n \t\t},\n \t\t\"not \" + p.name,"}, {"sha": "3efbc1c46f2a7758c3915996294c6e398cd66b3e", "filename": "libgo/go/crypto/bcrypt/bcrypt_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fbcrypt%2Fbcrypt_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -86,7 +86,7 @@ func TestInvalidHashErrors(t *testing.T) {\n \t\t\tt.Errorf(\"%s: Should have returned an error\", name)\n \t\t}\n \t\tif err != nil && err != expected {\n-\t\t\tt.Errorf(\"%s gave err %v but should have given %v\", name, err.String(), expected.String())\n+\t\t\tt.Errorf(\"%s gave err %v but should have given %v\", name, err, expected)\n \t\t}\n \t}\n \tfor _, iht := range invalidTests {"}, {"sha": "9cc21f1f8f67a43fcfb2cf6ea55566c1c8ff4080", "filename": "libgo/go/crypto/openpgp/error/error.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferror%2Ferror.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -41,21 +41,21 @@ func (b SignatureError) String() string {\n \treturn \"OpenPGP signature invalid: \" + string(b)\n }\n \n-type keyIncorrect int\n+type keyIncorrectError int\n \n-func (ki keyIncorrect) String() string {\n+func (ki keyIncorrectError) String() string {\n \treturn \"the given key was incorrect\"\n }\n \n-var KeyIncorrectError = keyIncorrect(0)\n+var KeyIncorrectError = keyIncorrectError(0)\n \n-type unknownIssuer int\n+type unknownIssuerError int\n \n-func (unknownIssuer) String() string {\n+func (unknownIssuerError) String() string {\n \treturn \"signature make by unknown entity\"\n }\n \n-var UnknownIssuerError = unknownIssuer(0)\n+var UnknownIssuerError = unknownIssuerError(0)\n \n type UnknownPacketTypeError uint8\n "}, {"sha": "3df88e06915a849c70c16e03c3d126566cefd1a5", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -116,15 +116,7 @@ func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n // [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (priv *PrivateKey, err os.Error) {\n \tpriv = new(PrivateKey)\n-\t// Smaller public exponents lead to faster public key\n-\t// operations. Since the exponent must be coprime to\n-\t// (p-1)(q-1), the smallest possible value is 3. Some have\n-\t// suggested that a larger exponent (often 2**16+1) be used\n-\t// since previous implementation bugs[1] were avoided when this\n-\t// was the case. However, there are no current reasons not to use\n-\t// small exponents.\n-\t// [1] http://marc.info/?l=cryptography&m=115694833312008&w=2\n-\tpriv.E = 3\n+\tpriv.E = 65537\n \n \tif nprimes < 2 {\n \t\treturn nil, os.NewError(\"rsa.GenerateMultiPrimeKey: nprimes must be >= 2\")"}, {"sha": "0856311e4cba288461c0f83ba9d5c18ba99610fa", "filename": "libgo/go/crypto/tls/alert.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Falert.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -71,3 +71,7 @@ func (e alert) String() string {\n \t}\n \treturn \"alert(\" + strconv.Itoa(int(e)) + \")\"\n }\n+\n+func (e alert) Error() string {\n+\treturn e.String()\n+}"}, {"sha": "a06b97894de6ee203639a596c1981b4faa752d9b", "filename": "libgo/go/csv/reader.go", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcsv%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcsv%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -101,8 +101,8 @@ var (\n //\n // If TrimLeadingSpace is true, leading white space in a field is ignored.\n type Reader struct {\n-\tComma            int  // Field delimiter (set to ',' by NewReader)\n-\tComment          int  // Comment character for start of line\n+\tComma            rune // Field delimiter (set to ',' by NewReader)\n+\tComment          rune // Comment character for start of line\n \tFieldsPerRecord  int  // Number of expected fields per record\n \tLazyQuotes       bool // Allow lazy quotes\n \tTrailingComma    bool // Allow trailing comma\n@@ -173,23 +173,23 @@ func (r *Reader) ReadAll() (records [][]string, err os.Error) {\n // readRune reads one rune from r, folding \\r\\n to \\n and keeping track\n // of how far into the line we have read.  r.column will point to the start\n // of this rune, not the end of this rune.\n-func (r *Reader) readRune() (int, os.Error) {\n-\trune, _, err := r.r.ReadRune()\n+func (r *Reader) readRune() (rune, os.Error) {\n+\tr1, _, err := r.r.ReadRune()\n \n \t// Handle \\r\\n here.  We make the simplifying assumption that\n \t// anytime \\r is followed by \\n that it can be folded to \\n.\n \t// We will not detect files which contain both \\r\\n and bare \\n.\n-\tif rune == '\\r' {\n-\t\trune, _, err = r.r.ReadRune()\n+\tif r1 == '\\r' {\n+\t\tr1, _, err = r.r.ReadRune()\n \t\tif err == nil {\n-\t\t\tif rune != '\\n' {\n+\t\t\tif r1 != '\\n' {\n \t\t\t\tr.r.UnreadRune()\n-\t\t\t\trune = '\\r'\n+\t\t\t\tr1 = '\\r'\n \t\t\t}\n \t\t}\n \t}\n \tr.column++\n-\treturn rune, err\n+\treturn r1, err\n }\n \n // unreadRune puts the last rune read from r back.\n@@ -199,13 +199,13 @@ func (r *Reader) unreadRune() {\n }\n \n // skip reads runes up to and including the rune delim or until error.\n-func (r *Reader) skip(delim int) os.Error {\n+func (r *Reader) skip(delim rune) os.Error {\n \tfor {\n-\t\trune, err := r.readRune()\n+\t\tr1, err := r.readRune()\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n-\t\tif rune == delim {\n+\t\tif r1 == delim {\n \t\t\treturn nil\n \t\t}\n \t}\n@@ -224,12 +224,12 @@ func (r *Reader) parseRecord() (fields []string, err os.Error) {\n \t// If we are support comments and it is the comment character\n \t// then skip to the end of line.\n \n-\trune, _, err := r.r.ReadRune()\n+\tr1, _, err := r.r.ReadRune()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tif r.Comment != 0 && rune == r.Comment {\n+\tif r.Comment != 0 && r1 == r.Comment {\n \t\treturn nil, r.skip('\\n')\n \t}\n \tr.r.UnreadRune()\n@@ -252,10 +252,10 @@ func (r *Reader) parseRecord() (fields []string, err os.Error) {\n // parseField parses the next field in the record.  The read field is\n // located in r.field.  Delim is the first character not part of the field\n // (r.Comma or '\\n').\n-func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n+func (r *Reader) parseField() (haveField bool, delim rune, err os.Error) {\n \tr.field.Reset()\n \n-\trune, err := r.readRune()\n+\tr1, err := r.readRune()\n \tif err != nil {\n \t\t// If we have EOF and are not at the start of a line\n \t\t// then we return the empty field.  We have already\n@@ -267,30 +267,30 @@ func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n \t}\n \n \tif r.TrimLeadingSpace {\n-\t\tfor rune != '\\n' && unicode.IsSpace(rune) {\n-\t\t\trune, err = r.readRune()\n+\t\tfor r1 != '\\n' && unicode.IsSpace(r1) {\n+\t\t\tr1, err = r.readRune()\n \t\t\tif err != nil {\n \t\t\t\treturn false, 0, err\n \t\t\t}\n \t\t}\n \t}\n \n-\tswitch rune {\n+\tswitch r1 {\n \tcase r.Comma:\n \t\t// will check below\n \n \tcase '\\n':\n \t\t// We are a trailing empty field or a blank line\n \t\tif r.column == 0 {\n-\t\t\treturn false, rune, nil\n+\t\t\treturn false, r1, nil\n \t\t}\n-\t\treturn true, rune, nil\n+\t\treturn true, r1, nil\n \n \tcase '\"':\n \t\t// quoted field\n \tQuoted:\n \t\tfor {\n-\t\t\trune, err = r.readRune()\n+\t\t\tr1, err = r.readRune()\n \t\t\tif err != nil {\n \t\t\t\tif err == os.EOF {\n \t\t\t\t\tif r.LazyQuotes {\n@@ -300,16 +300,16 @@ func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n \t\t\t\t}\n \t\t\t\treturn false, 0, err\n \t\t\t}\n-\t\t\tswitch rune {\n+\t\t\tswitch r1 {\n \t\t\tcase '\"':\n-\t\t\t\trune, err = r.readRune()\n-\t\t\t\tif err != nil || rune == r.Comma {\n+\t\t\t\tr1, err = r.readRune()\n+\t\t\t\tif err != nil || r1 == r.Comma {\n \t\t\t\t\tbreak Quoted\n \t\t\t\t}\n-\t\t\t\tif rune == '\\n' {\n-\t\t\t\t\treturn true, rune, nil\n+\t\t\t\tif r1 == '\\n' {\n+\t\t\t\t\treturn true, r1, nil\n \t\t\t\t}\n-\t\t\t\tif rune != '\"' {\n+\t\t\t\tif r1 != '\"' {\n \t\t\t\t\tif !r.LazyQuotes {\n \t\t\t\t\t\tr.column--\n \t\t\t\t\t\treturn false, 0, r.error(ErrQuote)\n@@ -321,21 +321,21 @@ func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n \t\t\t\tr.line++\n \t\t\t\tr.column = -1\n \t\t\t}\n-\t\t\tr.field.WriteRune(rune)\n+\t\t\tr.field.WriteRune(r1)\n \t\t}\n \n \tdefault:\n \t\t// unquoted field\n \t\tfor {\n-\t\t\tr.field.WriteRune(rune)\n-\t\t\trune, err = r.readRune()\n-\t\t\tif err != nil || rune == r.Comma {\n+\t\t\tr.field.WriteRune(r1)\n+\t\t\tr1, err = r.readRune()\n+\t\t\tif err != nil || r1 == r.Comma {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif rune == '\\n' {\n-\t\t\t\treturn true, rune, nil\n+\t\t\tif r1 == '\\n' {\n+\t\t\t\treturn true, r1, nil\n \t\t\t}\n-\t\t\tif !r.LazyQuotes && rune == '\"' {\n+\t\t\tif !r.LazyQuotes && r1 == '\"' {\n \t\t\t\treturn false, 0, r.error(ErrBareQuote)\n \t\t\t}\n \t\t}\n@@ -353,20 +353,20 @@ func (r *Reader) parseField() (haveField bool, delim int, err os.Error) {\n \t\t// are at the end of the line (being mindful\n \t\t// of trimming spaces).\n \t\tc := r.column\n-\t\trune, err = r.readRune()\n+\t\tr1, err = r.readRune()\n \t\tif r.TrimLeadingSpace {\n-\t\t\tfor rune != '\\n' && unicode.IsSpace(rune) {\n-\t\t\t\trune, err = r.readRune()\n+\t\t\tfor r1 != '\\n' && unicode.IsSpace(r1) {\n+\t\t\t\tr1, err = r.readRune()\n \t\t\t\tif err != nil {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err == os.EOF || rune == '\\n' {\n+\t\tif err == os.EOF || r1 == '\\n' {\n \t\t\tr.column = c // report the comma\n \t\t\treturn false, 0, r.error(ErrTrailingComma)\n \t\t}\n \t\tr.unreadRune()\n \t}\n-\treturn true, rune, nil\n+\treturn true, r1, nil\n }"}, {"sha": "1b2360593549c6b5ad9b3d95debc5160d9143399", "filename": "libgo/go/csv/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcsv%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcsv%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Freader_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -17,8 +17,8 @@ var readTests = []struct {\n \tUseFieldsPerRecord bool // false (default) means FieldsPerRecord is -1\n \n \t// These fields are copied into the Reader\n-\tComma            int\n-\tComment          int\n+\tComma            rune\n+\tComment          rune\n \tFieldsPerRecord  int\n \tLazyQuotes       bool\n \tTrailingComma    bool"}, {"sha": "98573c29fbea76ddb8423e6869b8ea6f6c3c872a", "filename": "libgo/go/csv/writer.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcsv%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fcsv%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcsv%2Fwriter.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -23,7 +23,7 @@ import (\n //\n // If UseCRLF is true, the Writer ends each record with \\r\\n instead of \\n.\n type Writer struct {\n-\tComma   int  // Field delimiter (set to to ',' by NewWriter)\n+\tComma   rune // Field delimiter (set to to ',' by NewWriter)\n \tUseCRLF bool // True to use \\r\\n as the line terminator\n \tw       *bufio.Writer\n }\n@@ -58,8 +58,8 @@ func (w *Writer) Write(record []string) (err os.Error) {\n \t\t\treturn\n \t\t}\n \n-\t\tfor _, rune := range field {\n-\t\t\tswitch rune {\n+\t\tfor _, r1 := range field {\n+\t\t\tswitch r1 {\n \t\t\tcase '\"':\n \t\t\t\t_, err = w.w.WriteString(`\"\"`)\n \t\t\tcase '\\r':\n@@ -73,7 +73,7 @@ func (w *Writer) Write(record []string) (err os.Error) {\n \t\t\t\t\terr = w.w.WriteByte('\\n')\n \t\t\t\t}\n \t\t\tdefault:\n-\t\t\t\t_, err = w.w.WriteRune(rune)\n+\t\t\t\t_, err = w.w.WriteRune(r1)\n \t\t\t}\n \t\t\tif err != nil {\n \t\t\t\treturn\n@@ -117,6 +117,6 @@ func (w *Writer) fieldNeedsQuotes(field string) bool {\n \t\treturn true\n \t}\n \n-\trune, _ := utf8.DecodeRuneInString(field)\n-\treturn unicode.IsSpace(rune)\n+\tr1, _ := utf8.DecodeRuneInString(field)\n+\treturn unicode.IsSpace(r1)\n }"}, {"sha": "ef20605a172adc4fc975d84f6e2be0266b6b293e", "filename": "libgo/go/encoding/binary/binary_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fbinary%2Fbinary_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5,10 +5,10 @@\n package binary\n \n import (\n-\t\"io\"\n-\t\"os\"\n \t\"bytes\"\n+\t\"io\"\n \t\"math\"\n+\t\"os\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -99,7 +99,7 @@ var little = []byte{\n var src = []byte{1, 2, 3, 4, 5, 6, 7, 8}\n var res = []int32{0x01020304, 0x05060708}\n \n-func checkResult(t *testing.T, dir string, order, err os.Error, have, want interface{}) {\n+func checkResult(t *testing.T, dir string, order ByteOrder, err os.Error, have, want interface{}) {\n \tif err != nil {\n \t\tt.Errorf(\"%v %v: %v\", dir, order, err)\n \t\treturn"}, {"sha": "7070cc79fdea971138e3b1261c55d447303d5534", "filename": "libgo/go/exp/ebnf/ebnf.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Febnf.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -163,7 +163,7 @@ func (v *verifier) push(prod *Production) {\n \t}\n }\n \n-func (v *verifier) verifyChar(x *Token) int {\n+func (v *verifier) verifyChar(x *Token) rune {\n \ts := x.String\n \tif utf8.RuneCountInString(s) != 1 {\n \t\tv.error(x.Pos(), \"single char expected, found \"+s)"}, {"sha": "dac5dd8339f4f5e0971fc18bca45d790d2c9192f", "filename": "libgo/go/exp/ebnf/parser.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Febnf%2Fparser.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -15,7 +15,7 @@ type parser struct {\n \terrors  errorList\n \tscanner scanner.Scanner\n \tpos     scanner.Position // token position\n-\ttok     int              // one token look-ahead\n+\ttok     rune             // one token look-ahead\n \tlit     string           // token literal\n }\n \n@@ -42,7 +42,7 @@ func (p *parser) errorExpected(pos scanner.Position, msg string) {\n \tp.error(pos, msg)\n }\n \n-func (p *parser) expect(tok int) scanner.Position {\n+func (p *parser) expect(tok rune) scanner.Position {\n \tpos := p.pos\n \tif p.tok != tok {\n \t\tp.errorExpected(pos, scanner.TokenString(tok))"}, {"sha": "f4a453ede4d6365d6925adbdccfac514fa7cedf7", "filename": "libgo/go/exp/gui/x11/conn.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fgui%2Fx11%2Fconn.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -87,7 +87,7 @@ func (c *conn) writeSocket() {\n \t\t\tsetU32LE(c.flushBuf0[16:20], uint32(y<<16))\n \t\t\tif _, err := c.w.Write(c.flushBuf0[:24]); err != nil {\n \t\t\t\tif err != os.EOF {\n-\t\t\t\t\tlog.Println(\"x11:\", err.String())\n+\t\t\t\t\tlog.Println(\"x11:\", err)\n \t\t\t\t}\n \t\t\t\treturn\n \t\t\t}\n@@ -106,15 +106,15 @@ func (c *conn) writeSocket() {\n \t\t\t\tx += nx\n \t\t\t\tif _, err := c.w.Write(c.flushBuf1[:nx]); err != nil {\n \t\t\t\t\tif err != os.EOF {\n-\t\t\t\t\t\tlog.Println(\"x11:\", err.String())\n+\t\t\t\t\t\tlog.Println(\"x11:\", err)\n \t\t\t\t\t}\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\tif err := c.w.Flush(); err != nil {\n \t\t\tif err != os.EOF {\n-\t\t\t\tlog.Println(\"x11:\", err.String())\n+\t\t\t\tlog.Println(\"x11:\", err)\n \t\t\t}\n \t\t\treturn\n \t\t}"}, {"sha": "7965ffc5742dbc11d9516a83089f62152201f97b", "filename": "libgo/go/exp/norm/composition.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -126,26 +126,26 @@ func (rb *reorderBuffer) insert(src input, i int, info runeInfo) bool {\n }\n \n // appendRune inserts a rune at the end of the buffer. It is used for Hangul.\n-func (rb *reorderBuffer) appendRune(rune uint32) {\n+func (rb *reorderBuffer) appendRune(r uint32) {\n \tbn := rb.nbyte\n-\tsz := utf8.EncodeRune(rb.byte[bn:], int(rune))\n+\tsz := utf8.EncodeRune(rb.byte[bn:], rune(r))\n \trb.nbyte += utf8.UTFMax\n \trb.rune[rb.nrune] = runeInfo{bn, uint8(sz), 0, 0}\n \trb.nrune++\n }\n \n // assignRune sets a rune at position pos. It is used for Hangul and recomposition.\n-func (rb *reorderBuffer) assignRune(pos int, rune uint32) {\n+func (rb *reorderBuffer) assignRune(pos int, r uint32) {\n \tbn := rb.rune[pos].pos\n-\tsz := utf8.EncodeRune(rb.byte[bn:], int(rune))\n+\tsz := utf8.EncodeRune(rb.byte[bn:], rune(r))\n \trb.rune[pos] = runeInfo{bn, uint8(sz), 0, 0}\n }\n \n // runeAt returns the rune at position n. It is used for Hangul and recomposition.\n func (rb *reorderBuffer) runeAt(n int) uint32 {\n \tinf := rb.rune[n]\n-\trune, _ := utf8.DecodeRune(rb.byte[inf.pos : inf.pos+inf.size])\n-\treturn uint32(rune)\n+\tr, _ := utf8.DecodeRune(rb.byte[inf.pos : inf.pos+inf.size])\n+\treturn uint32(r)\n }\n \n // bytesAt returns the UTF-8 encoding of the rune at position n.\n@@ -237,17 +237,17 @@ func isHangulWithoutJamoT(b []byte) bool {\n // decomposeHangul algorithmically decomposes a Hangul rune into\n // its Jamo components.\n // See http://unicode.org/reports/tr15/#Hangul for details on decomposing Hangul.\n-func (rb *reorderBuffer) decomposeHangul(rune uint32) bool {\n+func (rb *reorderBuffer) decomposeHangul(r uint32) bool {\n \tb := rb.rune[:]\n \tn := rb.nrune\n \tif n+3 > len(b) {\n \t\treturn false\n \t}\n-\trune -= hangulBase\n-\tx := rune % jamoTCount\n-\trune /= jamoTCount\n-\trb.appendRune(jamoLBase + rune/jamoVCount)\n-\trb.appendRune(jamoVBase + rune%jamoVCount)\n+\tr -= hangulBase\n+\tx := r % jamoTCount\n+\tr /= jamoTCount\n+\trb.appendRune(jamoLBase + r/jamoVCount)\n+\trb.appendRune(jamoVBase + r%jamoVCount)\n \tif x != 0 {\n \t\trb.appendRune(jamoTBase + x)\n \t}"}, {"sha": "e32380d7afac6f822bcccfd4e12f4a3fc167da03", "filename": "libgo/go/exp/norm/composition_test.go", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fcomposition_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -8,14 +8,14 @@ import \"testing\"\n \n // TestCase is used for most tests.\n type TestCase struct {\n-\tin  []int\n-\tout []int\n+\tin  []rune\n+\tout []rune\n }\n \n-type insertFunc func(rb *reorderBuffer, rune int) bool\n+type insertFunc func(rb *reorderBuffer, r rune) bool\n \n-func insert(rb *reorderBuffer, rune int) bool {\n-\tsrc := inputString(string(rune))\n+func insert(rb *reorderBuffer, r rune) bool {\n+\tsrc := inputString(string(r))\n \treturn rb.insert(src, 0, rb.f.info(src, 0))\n }\n \n@@ -39,7 +39,7 @@ func runTests(t *testing.T, name string, fm Form, f insertFunc, tests []TestCase\n \t\t\tcontinue\n \t\t}\n \t\tfor j, want := range test.out {\n-\t\t\tfound := int(rb.runeAt(j))\n+\t\t\tfound := rune(rb.runeAt(j))\n \t\t\tif found != want {\n \t\t\t\tt.Errorf(\"%s:%d: runeAt(%d) = %U; want %U\", name, i, j, found, want)\n \t\t\t}\n@@ -57,7 +57,7 @@ func TestFlush(t *testing.T) {\n \t\tt.Errorf(\"wrote bytes on flush of empty buffer. (len(out) = %d)\", len(out))\n \t}\n \n-\tfor _, r := range []int(\"world!\") {\n+\tfor _, r := range []rune(\"world!\") {\n \t\tinsert(&rb, r)\n \t}\n \n@@ -76,33 +76,33 @@ func TestFlush(t *testing.T) {\n }\n \n var insertTests = []TestCase{\n-\t{[]int{'a'}, []int{'a'}},\n-\t{[]int{0x300}, []int{0x300}},\n-\t{[]int{0x300, 0x316}, []int{0x316, 0x300}}, // CCC(0x300)==230; CCC(0x316)==220\n-\t{[]int{0x316, 0x300}, []int{0x316, 0x300}},\n-\t{[]int{0x41, 0x316, 0x300}, []int{0x41, 0x316, 0x300}},\n-\t{[]int{0x41, 0x300, 0x316}, []int{0x41, 0x316, 0x300}},\n-\t{[]int{0x300, 0x316, 0x41}, []int{0x316, 0x300, 0x41}},\n-\t{[]int{0x41, 0x300, 0x40, 0x316}, []int{0x41, 0x300, 0x40, 0x316}},\n+\t{[]rune{'a'}, []rune{'a'}},\n+\t{[]rune{0x300}, []rune{0x300}},\n+\t{[]rune{0x300, 0x316}, []rune{0x316, 0x300}}, // CCC(0x300)==230; CCC(0x316)==220\n+\t{[]rune{0x316, 0x300}, []rune{0x316, 0x300}},\n+\t{[]rune{0x41, 0x316, 0x300}, []rune{0x41, 0x316, 0x300}},\n+\t{[]rune{0x41, 0x300, 0x316}, []rune{0x41, 0x316, 0x300}},\n+\t{[]rune{0x300, 0x316, 0x41}, []rune{0x316, 0x300, 0x41}},\n+\t{[]rune{0x41, 0x300, 0x40, 0x316}, []rune{0x41, 0x300, 0x40, 0x316}},\n }\n \n func TestInsert(t *testing.T) {\n \trunTests(t, \"TestInsert\", NFD, insert, insertTests)\n }\n \n var decompositionNFDTest = []TestCase{\n-\t{[]int{0xC0}, []int{0x41, 0x300}},\n-\t{[]int{0xAC00}, []int{0x1100, 0x1161}},\n-\t{[]int{0x01C4}, []int{0x01C4}},\n-\t{[]int{0x320E}, []int{0x320E}},\n-\t{[]int(\"\uc74c\u1ebb\uacfc\"), []int{0x110B, 0x1173, 0x11B7, 0x65, 0x309, 0x1100, 0x116A}},\n+\t{[]rune{0xC0}, []rune{0x41, 0x300}},\n+\t{[]rune{0xAC00}, []rune{0x1100, 0x1161}},\n+\t{[]rune{0x01C4}, []rune{0x01C4}},\n+\t{[]rune{0x320E}, []rune{0x320E}},\n+\t{[]rune(\"\uc74c\u1ebb\uacfc\"), []rune{0x110B, 0x1173, 0x11B7, 0x65, 0x309, 0x1100, 0x116A}},\n }\n \n var decompositionNFKDTest = []TestCase{\n-\t{[]int{0xC0}, []int{0x41, 0x300}},\n-\t{[]int{0xAC00}, []int{0x1100, 0x1161}},\n-\t{[]int{0x01C4}, []int{0x44, 0x5A, 0x030C}},\n-\t{[]int{0x320E}, []int{0x28, 0x1100, 0x1161, 0x29}},\n+\t{[]rune{0xC0}, []rune{0x41, 0x300}},\n+\t{[]rune{0xAC00}, []rune{0x1100, 0x1161}},\n+\t{[]rune{0x01C4}, []rune{0x44, 0x5A, 0x030C}},\n+\t{[]rune{0x320E}, []rune{0x28, 0x1100, 0x1161, 0x29}},\n }\n \n func TestDecomposition(t *testing.T) {\n@@ -111,15 +111,15 @@ func TestDecomposition(t *testing.T) {\n }\n \n var compositionTest = []TestCase{\n-\t{[]int{0x41, 0x300}, []int{0xC0}},\n-\t{[]int{0x41, 0x316}, []int{0x41, 0x316}},\n-\t{[]int{0x41, 0x300, 0x35D}, []int{0xC0, 0x35D}},\n-\t{[]int{0x41, 0x316, 0x300}, []int{0xC0, 0x316}},\n+\t{[]rune{0x41, 0x300}, []rune{0xC0}},\n+\t{[]rune{0x41, 0x316}, []rune{0x41, 0x316}},\n+\t{[]rune{0x41, 0x300, 0x35D}, []rune{0xC0, 0x35D}},\n+\t{[]rune{0x41, 0x316, 0x300}, []rune{0xC0, 0x316}},\n \t// blocking starter\n-\t{[]int{0x41, 0x316, 0x40, 0x300}, []int{0x41, 0x316, 0x40, 0x300}},\n-\t{[]int{0x1100, 0x1161}, []int{0xAC00}},\n+\t{[]rune{0x41, 0x316, 0x40, 0x300}, []rune{0x41, 0x316, 0x40, 0x300}},\n+\t{[]rune{0x1100, 0x1161}, []rune{0xAC00}},\n \t// parenthesized Hangul, alternate between ASCII and Hangul.\n-\t{[]int{0x28, 0x1100, 0x1161, 0x29}, []int{0x28, 0xAC00, 0x29}},\n+\t{[]rune{0x28, 0x1100, 0x1161, 0x29}, []rune{0x28, 0xAC00, 0x29}},\n }\n \n func TestComposition(t *testing.T) {"}, {"sha": "93edf221ef8371c4b2f9a945ba515f836d6a8601", "filename": "libgo/go/exp/norm/maketables.go", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketables.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -119,7 +119,7 @@ const (\n // This contains only the properties we're interested in.\n type Char struct {\n \tname          string\n-\tcodePoint     int   // if zero, this index is not a valid code point.\n+\tcodePoint     rune  // if zero, this index is not a valid code point.\n \tccc           uint8 // canonical combining class\n \texcludeInComp bool  // from CompositionExclusions.txt\n \tcompatDecomp  bool  // it has a compatibility expansion\n@@ -160,7 +160,7 @@ const (\n \tSMissing\n )\n \n-var lastChar int = 0\n+var lastChar = rune('\\u0000')\n \n func (c Char) isValid() bool {\n \treturn c.codePoint != 0 && c.state != SMissing\n@@ -193,7 +193,7 @@ func (f FormInfo) String() string {\n \treturn buf.String()\n }\n \n-type Decomposition []int\n+type Decomposition []rune\n \n func (d Decomposition) String() string {\n \treturn fmt.Sprintf(\"%.4X\", d)\n@@ -220,7 +220,7 @@ func openReader(file string) (input io.ReadCloser) {\n \treturn\n }\n \n-func parseDecomposition(s string, skipfirst bool) (a []int, e os.Error) {\n+func parseDecomposition(s string, skipfirst bool) (a []rune, e os.Error) {\n \tdecomp := strings.Split(s, \" \")\n \tif len(decomp) > 0 && skipfirst {\n \t\tdecomp = decomp[1:]\n@@ -230,7 +230,7 @@ func parseDecomposition(s string, skipfirst bool) (a []int, e os.Error) {\n \t\tif err != nil {\n \t\t\treturn a, err\n \t\t}\n-\t\ta = append(a, int(point))\n+\t\ta = append(a, rune(point))\n \t}\n \treturn a, nil\n }\n@@ -260,7 +260,7 @@ func parseCharacter(line string) {\n \t\tstate = SLast\n \t}\n \tfirstChar := lastChar + 1\n-\tlastChar = int(point)\n+\tlastChar = rune(point)\n \tif state != SLast {\n \t\tfirstChar = lastChar\n \t}\n@@ -370,8 +370,8 @@ func loadCompositionExclusions() {\n // hasCompatDecomp returns true if any of the recursive\n // decompositions contains a compatibility expansion.\n // In this case, the character may not occur in NFK*.\n-func hasCompatDecomp(rune int) bool {\n-\tc := &chars[rune]\n+func hasCompatDecomp(r rune) bool {\n+\tc := &chars[r]\n \tif c.compatDecomp {\n \t\treturn true\n \t}\n@@ -396,19 +396,19 @@ const (\n \tJamoTEnd  = 0x11C3\n )\n \n-func isHangul(rune int) bool {\n-\treturn HangulBase <= rune && rune < HangulEnd\n+func isHangul(r rune) bool {\n+\treturn HangulBase <= r && r < HangulEnd\n }\n \n-func ccc(rune int) uint8 {\n-\treturn chars[rune].ccc\n+func ccc(r rune) uint8 {\n+\treturn chars[r].ccc\n }\n \n // Insert a rune in a buffer, ordered by Canonical Combining Class.\n-func insertOrdered(b Decomposition, rune int) Decomposition {\n+func insertOrdered(b Decomposition, r rune) Decomposition {\n \tn := len(b)\n \tb = append(b, 0)\n-\tcc := ccc(rune)\n+\tcc := ccc(r)\n \tif cc > 0 {\n \t\t// Use bubble sort.\n \t\tfor ; n > 0; n-- {\n@@ -418,18 +418,18 @@ func insertOrdered(b Decomposition, rune int) Decomposition {\n \t\t\tb[n] = b[n-1]\n \t\t}\n \t}\n-\tb[n] = rune\n+\tb[n] = r\n \treturn b\n }\n \n // Recursively decompose.\n-func decomposeRecursive(form int, rune int, d Decomposition) Decomposition {\n-\tif isHangul(rune) {\n+func decomposeRecursive(form int, r rune, d Decomposition) Decomposition {\n+\tif isHangul(r) {\n \t\treturn d\n \t}\n-\tdcomp := chars[rune].forms[form].decomp\n+\tdcomp := chars[r].forms[form].decomp\n \tif len(dcomp) == 0 {\n-\t\treturn insertOrdered(d, rune)\n+\t\treturn insertOrdered(d, r)\n \t}\n \tfor _, c := range dcomp {\n \t\td = decomposeRecursive(form, c, d)\n@@ -475,8 +475,8 @@ func completeCharFields(form int) {\n \t\t\tf.isOneWay = f.isOneWay || hasCompatDecomp(c.codePoint)\n \t\t}\n \n-\t\tfor _, rune := range f.decomp {\n-\t\t\tchars[rune].forms[form].inDecomp = true\n+\t\tfor _, r := range f.decomp {\n+\t\t\tchars[r].forms[form].inDecomp = true\n \t\t}\n \t}\n \n@@ -505,7 +505,7 @@ func completeCharFields(form int) {\n \t\tswitch {\n \t\tcase len(f.decomp) > 0:\n \t\t\tf.quickCheck[MDecomposed] = QCNo\n-\t\tcase isHangul(i):\n+\t\tcase isHangul(rune(i)):\n \t\t\tf.quickCheck[MDecomposed] = QCNo\n \t\tdefault:\n \t\t\tf.quickCheck[MDecomposed] = QCYes\n@@ -588,7 +588,7 @@ func printCharInfoTables() int {\n \tfor i, char := range chars {\n \t\tv := makeCharInfo(char)\n \t\tif v != 0 {\n-\t\t\tt.insert(i, v)\n+\t\t\tt.insert(rune(i), v)\n \t\t}\n \t}\n \treturn t.printTables(\"charInfo\")\n@@ -606,7 +606,7 @@ func printDecompositionTables() int {\n \tfor _, c := range chars {\n \t\tfor f := 0; f < 2; f++ {\n \t\t\td := c.forms[f].expandedDecomp\n-\t\t\ts := string([]int(d))\n+\t\t\ts := string([]rune(d))\n \t\t\tif _, ok := positionMap[s]; !ok {\n \t\t\t\tp := decompositions.Len()\n \t\t\t\tdecompositions.WriteByte(uint8(len(s)))\n@@ -624,7 +624,7 @@ func printDecompositionTables() int {\n \tfor i, c := range chars {\n \t\td := c.forms[FCanonical].expandedDecomp\n \t\tif len(d) != 0 {\n-\t\t\tnfcT.insert(i, positionMap[string([]int(d))])\n+\t\t\tnfcT.insert(rune(i), positionMap[string([]rune(d))])\n \t\t\tif ccc(c.codePoint) != ccc(d[0]) {\n \t\t\t\t// We assume the lead ccc of a decomposition is !=0 in this case.\n \t\t\t\tif ccc(d[0]) == 0 {\n@@ -634,7 +634,7 @@ func printDecompositionTables() int {\n \t\t}\n \t\td = c.forms[FCompatibility].expandedDecomp\n \t\tif len(d) != 0 {\n-\t\t\tnfkcT.insert(i, positionMap[string([]int(d))])\n+\t\t\tnfkcT.insert(rune(i), positionMap[string([]rune(d))])\n \t\t\tif ccc(c.codePoint) != ccc(d[0]) {\n \t\t\t\t// We assume the lead ccc of a decomposition is !=0 in this case.\n \t\t\t\tif ccc(d[0]) == 0 {\n@@ -752,7 +752,7 @@ func verifyComputed() {\n \tfor i, c := range chars {\n \t\tfor _, f := range c.forms {\n \t\t\tisNo := (f.quickCheck[MDecomposed] == QCNo)\n-\t\t\tif (len(f.decomp) > 0) != isNo && !isHangul(i) {\n+\t\t\tif (len(f.decomp) > 0) != isNo && !isHangul(rune(i)) {\n \t\t\t\tlog.Fatalf(\"%U: NF*D must be no if rune decomposes\", i)\n \t\t\t}\n \n@@ -764,7 +764,7 @@ func verifyComputed() {\n \t}\n }\n \n-var qcRe = regexp.MustCompile(`^([0-9A-F\\.]+) *; (NF.*_QC); ([YNM]) #.*$`)\n+var qcRe = regexp.MustCompile(`([0-9A-F\\.]+) *; (NF.*_QC); ([YNM]) #.*`)\n \n // Use values in DerivedNormalizationProps.txt to compare against the\n // values we computed."}, {"sha": "20eb889ddef63cbdc41ccccc08c561b5d5bfd147", "filename": "libgo/go/exp/norm/maketesttables.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fmaketesttables.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -16,7 +16,7 @@ func main() {\n \n // We take the smallest, largest and an arbitrary value for each \n // of the UTF-8 sequence lengths.\n-var testRunes = []int{\n+var testRunes = []rune{\n \t0x01, 0x0C, 0x7F, // 1-byte sequences\n \t0x80, 0x100, 0x7FF, // 2-byte sequences\n \t0x800, 0x999, 0xFFFF, // 3-byte sequences"}, {"sha": "6bd5292d3fb81820d1b24e191ac954bd6bbe80ee", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -28,13 +28,13 @@ func runPosTests(t *testing.T, name string, f Form, fn positionFunc, tests []Pos\n \t\tif pos != test.pos {\n \t\t\tt.Errorf(\"%s:%d: position is %d; want %d\", name, i, pos, test.pos)\n \t\t}\n-\t\trunes := []int(test.buffer)\n+\t\trunes := []rune(test.buffer)\n \t\tif rb.nrune != len(runes) {\n \t\t\tt.Errorf(\"%s:%d: reorder buffer lenght is %d; want %d\", name, i, rb.nrune, len(runes))\n \t\t\tcontinue\n \t\t}\n \t\tfor j, want := range runes {\n-\t\t\tfound := int(rb.runeAt(j))\n+\t\t\tfound := rune(rb.runeAt(j))\n \t\t\tif found != want {\n \t\t\t\tt.Errorf(\"%s:%d: rune at %d is %U; want %U\", name, i, j, found, want)\n \t\t\t}\n@@ -385,8 +385,8 @@ func runAppendTests(t *testing.T, name string, f Form, fn appendFunc, tests []Ap\n \t\t}\n \t\tif outs != test.out {\n \t\t\t// Find first rune that differs and show context.\n-\t\t\tir := []int(outs)\n-\t\t\tig := []int(test.out)\n+\t\t\tir := []rune(outs)\n+\t\t\tig := []rune(test.out)\n \t\t\tfor j := 0; j < len(ir) && j < len(ig); j++ {\n \t\t\t\tif ir[j] == ig[j] {\n \t\t\t\t\tcontinue"}, {"sha": "e747ddef763f5600b1982842c49a04cc36cac288", "filename": "libgo/go/exp/norm/normregtest.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormregtest.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -16,8 +16,8 @@ import (\n \t\"path\"\n \t\"regexp\"\n \t\"runtime\"\n-\t\"strings\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"time\"\n \t\"utf8\"\n )\n@@ -103,7 +103,7 @@ type Test struct {\n \tname   string\n \tpartnr int\n \tnumber int\n-\trune   int                 // used for character by character test\n+\tr      rune                // used for character by character test\n \tcols   [cMaxColumns]string // Each has 5 entries, see below.\n }\n \n@@ -174,12 +174,12 @@ func loadTestData() {\n \t\t\t\tif err != nil {\n \t\t\t\t\tlogger.Fatal(err)\n \t\t\t\t}\n-\t\t\t\tif test.rune == 0 {\n+\t\t\t\tif test.r == 0 {\n \t\t\t\t\t// save for CharacterByCharacterTests\n-\t\t\t\t\ttest.rune = int(r)\n+\t\t\t\t\ttest.r = int(r)\n \t\t\t\t}\n \t\t\t\tvar buf [utf8.UTFMax]byte\n-\t\t\t\tsz := utf8.EncodeRune(buf[:], int(r))\n+\t\t\t\tsz := utf8.EncodeRune(buf[:], rune(r))\n \t\t\t\ttest.cols[j-1] += string(buf[:sz])\n \t\t\t}\n \t\t}\n@@ -198,7 +198,7 @@ func cmpResult(t *Test, name string, f norm.Form, gold, test, result string) {\n \t\tif errorCount > 20 {\n \t\t\treturn\n \t\t}\n-\t\tst, sr, sg := []int(test), []int(result), []int(gold)\n+\t\tst, sr, sg := []rune(test), []rune(result), []rune(gold)\n \t\tlogger.Printf(\"%s:%s: %s(%X)=%X; want:%X: %s\",\n \t\t\tt.Name(), name, fstr[f], st, sr, sg, t.name)\n \t}\n@@ -210,7 +210,7 @@ func cmpIsNormal(t *Test, name string, f norm.Form, test string, result, want bo\n \t\tif errorCount > 20 {\n \t\t\treturn\n \t\t}\n-\t\tlogger.Printf(\"%s:%s: %s(%X)=%v; want: %v\", t.Name(), name, fstr[f], []int(test), result, want)\n+\t\tlogger.Printf(\"%s:%s: %s(%X)=%v; want: %v\", t.Name(), name, fstr[f], []rune(test), result, want)\n \t}\n }\n \n@@ -243,13 +243,13 @@ func CharacterByCharacterTests() {\n \ttests := part[1].tests\n \tlast := 0\n \tfor i := 0; i <= len(tests); i++ { // last one is special case\n-\t\tvar rune int\n+\t\tvar r int\n \t\tif i == len(tests) {\n-\t\t\trune = 0x2FA1E // Don't have to go to 0x10FFFF\n+\t\t\tr = 0x2FA1E // Don't have to go to 0x10FFFF\n \t\t} else {\n-\t\t\trune = tests[i].rune\n+\t\t\tr = tests[i].r\n \t\t}\n-\t\tfor last++; last < rune; last++ {\n+\t\tfor last++; last < r; last++ {\n \t\t\t// Check all characters that were not explicitly listed in the test.\n \t\t\tt := &Test{partnr: 1, number: -1}\n \t\t\tchar := string(last)"}, {"sha": "bbd5c03e7b3a1af5b833a93a46a88a8837d5e9e6", "filename": "libgo/go/exp/norm/trie_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftrie_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -73,15 +73,15 @@ var tests = []trietest{\n \t{1, []byte{t6, tx, tx, tx, tx, tx}},\n }\n \n-func mkUtf8(rune int) ([]byte, int) {\n+func mkUTF8(r rune) ([]byte, int) {\n \tvar b [utf8.UTFMax]byte\n-\tsz := utf8.EncodeRune(b[:], rune)\n+\tsz := utf8.EncodeRune(b[:], r)\n \treturn b[:sz], sz\n }\n \n func TestLookup(t *testing.T) {\n \tfor i, tt := range testRunes {\n-\t\tb, szg := mkUtf8(tt)\n+\t\tb, szg := mkUTF8(tt)\n \t\tv, szt := testdata.lookup(b)\n \t\tif int(v) != i {\n \t\t\tt.Errorf(\"lookup(%U): found value %#x, expected %#x\", tt, v, i)\n@@ -103,7 +103,7 @@ func TestLookup(t *testing.T) {\n \n func TestLookupUnsafe(t *testing.T) {\n \tfor i, tt := range testRunes {\n-\t\tb, _ := mkUtf8(tt)\n+\t\tb, _ := mkUTF8(tt)\n \t\tv := testdata.lookupUnsafe(b)\n \t\tif int(v) != i {\n \t\t\tt.Errorf(\"lookupUnsafe(%U): found value %#x, expected %#x\", i, v, i)\n@@ -113,7 +113,7 @@ func TestLookupUnsafe(t *testing.T) {\n \n func TestLookupString(t *testing.T) {\n \tfor i, tt := range testRunes {\n-\t\tb, szg := mkUtf8(tt)\n+\t\tb, szg := mkUTF8(tt)\n \t\tv, szt := testdata.lookupString(string(b))\n \t\tif int(v) != i {\n \t\t\tt.Errorf(\"lookup(%U): found value %#x, expected %#x\", i, v, i)\n@@ -135,7 +135,7 @@ func TestLookupString(t *testing.T) {\n \n func TestLookupStringUnsafe(t *testing.T) {\n \tfor i, tt := range testRunes {\n-\t\tb, _ := mkUtf8(tt)\n+\t\tb, _ := mkUTF8(tt)\n \t\tv := testdata.lookupStringUnsafe(string(b))\n \t\tif int(v) != i {\n \t\t\tt.Errorf(\"lookupUnsafe(%U): found value %#x, expected %#x\", i, v, i)"}, {"sha": "7f6276096c56e0ed6b97ab900db4bc97c4279edd", "filename": "libgo/go/exp/norm/triedata_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriedata_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -4,7 +4,7 @@\n \n package norm\n \n-var testRunes = []int{1, 12, 127, 128, 256, 2047, 2048, 2457, 65535, 65536, 65793, 1114111, 512, 513, 514, 528, 533}\n+var testRunes = []rune{1, 12, 127, 128, 256, 2047, 2048, 2457, 65535, 65536, 65793, 1114111, 512, 513, 514, 528, 533}\n \n // testdataValues: 192 entries, 384 bytes\n // Block 2 is the null block."}, {"sha": "56cba3219668c510b39649708507d8eeb4c56067", "filename": "libgo/go/exp/norm/triegen.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Ftriegen.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -94,9 +94,9 @@ func (n trieNode) countSparseEntries() int {\n \treturn count\n }\n \n-func (n *trieNode) insert(rune int, value uint16) {\n+func (n *trieNode) insert(r rune, value uint16) {\n \tvar p [utf8.UTFMax]byte\n-\tsz := utf8.EncodeRune(p[:], rune)\n+\tsz := utf8.EncodeRune(p[:], r)\n \n \tfor i := 0; i < sz; i++ {\n \t\tif n.leaf {"}, {"sha": "849991868e12b93b27ac826ef20a539418146b0d", "filename": "libgo/go/exp/sql/convert_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -52,7 +52,7 @@ var conversionTests = []conversionTest{\n \t{s: \"256\", d: &scanuint8, wanterr: `string \"256\" overflows uint8`},\n \t{s: \"256\", d: &scanuint16, wantuint: 256},\n \t{s: \"-1\", d: &scanint, wantint: -1},\n-\t{s: \"foo\", d: &scanint, wanterr: `converting string \"foo\" to a int: parsing \"foo\": Invalid argument`},\n+\t{s: \"foo\", d: &scanint, wanterr: `converting string \"foo\" to a int: parsing \"foo\": invalid syntax`},\n }\n \n func intValue(intptr interface{}) int64 {"}, {"sha": "9eed3157ee70deaba06b4a4a2a3cb8c1f8199ccd", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -258,51 +258,71 @@ func (c *ClientConn) openChan(typ string) (*clientChan, os.Error) {\n // mainloop reads incoming messages and routes channel messages\n // to their respective ClientChans.\n func (c *ClientConn) mainLoop() {\n+\t// TODO(dfc) signal the underlying close to all channels\n+\tdefer c.Close()\n \tfor {\n \t\tpacket, err := c.readPacket()\n \t\tif err != nil {\n-\t\t\t// TODO(dfc) signal the underlying close to all channels\n-\t\t\tc.Close()\n-\t\t\treturn\n+\t\t\tbreak\n \t\t}\n \t\t// TODO(dfc) A note on blocking channel use. \n \t\t// The msg, win, data and dataExt channels of a clientChan can \n \t\t// cause this loop to block indefinately if the consumer does \n \t\t// not service them. \n-\t\tswitch msg := decode(packet).(type) {\n-\t\tcase *channelOpenMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *channelOpenConfirmMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *channelOpenFailureMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *channelCloseMsg:\n-\t\t\tch := c.getChan(msg.PeersId)\n-\t\t\tclose(ch.win)\n-\t\t\tclose(ch.data)\n-\t\t\tclose(ch.dataExt)\n-\t\t\tc.chanlist.remove(msg.PeersId)\n-\t\tcase *channelEOFMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *channelRequestSuccessMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *channelRequestFailureMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *channelRequestMsg:\n-\t\t\tc.getChan(msg.PeersId).msg <- msg\n-\t\tcase *windowAdjustMsg:\n-\t\t\tc.getChan(msg.PeersId).win <- int(msg.AdditionalBytes)\n-\t\tcase *channelData:\n-\t\t\tc.getChan(msg.PeersId).data <- msg.Payload\n-\t\tcase *channelExtendedData:\n-\t\t\t// RFC 4254 5.2 defines data_type_code 1 to be data destined \n-\t\t\t// for stderr on interactive sessions. Other data types are\n-\t\t\t// silently discarded.\n-\t\t\tif msg.Datatype == 1 {\n-\t\t\t\tc.getChan(msg.PeersId).dataExt <- msg.Payload\n+\t\tswitch packet[0] {\n+\t\tcase msgChannelData:\n+\t\t\tif len(packet) < 9 {\n+\t\t\t\t// malformed data packet\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tpeersId := uint32(packet[1])<<24 | uint32(packet[2])<<16 | uint32(packet[3])<<8 | uint32(packet[4])\n+\t\t\tif length := int(packet[5])<<24 | int(packet[6])<<16 | int(packet[7])<<8 | int(packet[8]); length > 0 {\n+\t\t\t\tpacket = packet[9:]\n+\t\t\t\tc.getChan(peersId).data <- packet[:length]\n+\t\t\t}\n+\t\tcase msgChannelExtendedData:\n+\t\t\tif len(packet) < 13 {\n+\t\t\t\t// malformed data packet\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tpeersId := uint32(packet[1])<<24 | uint32(packet[2])<<16 | uint32(packet[3])<<8 | uint32(packet[4])\n+\t\t\tdatatype := uint32(packet[5])<<24 | uint32(packet[6])<<16 | uint32(packet[7])<<8 | uint32(packet[8])\n+\t\t\tif length := int(packet[9])<<24 | int(packet[10])<<16 | int(packet[11])<<8 | int(packet[12]); length > 0 {\n+\t\t\t\tpacket = packet[13:]\n+\t\t\t\t// RFC 4254 5.2 defines data_type_code 1 to be data destined \n+\t\t\t\t// for stderr on interactive sessions. Other data types are\n+\t\t\t\t// silently discarded.\n+\t\t\t\tif datatype == 1 {\n+\t\t\t\t\tc.getChan(peersId).dataExt <- packet[:length]\n+\t\t\t\t}\n \t\t\t}\n \t\tdefault:\n-\t\t\tfmt.Printf(\"mainLoop: unhandled %#v\\n\", msg)\n+\t\t\tswitch msg := decode(packet).(type) {\n+\t\t\tcase *channelOpenMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *channelOpenConfirmMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *channelOpenFailureMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *channelCloseMsg:\n+\t\t\t\tch := c.getChan(msg.PeersId)\n+\t\t\t\tclose(ch.win)\n+\t\t\t\tclose(ch.data)\n+\t\t\t\tclose(ch.dataExt)\n+\t\t\t\tc.chanlist.remove(msg.PeersId)\n+\t\t\tcase *channelEOFMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *channelRequestSuccessMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *channelRequestFailureMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *channelRequestMsg:\n+\t\t\t\tc.getChan(msg.PeersId).msg <- msg\n+\t\t\tcase *windowAdjustMsg:\n+\t\t\t\tc.getChan(msg.PeersId).win <- int(msg.AdditionalBytes)\n+\t\t\tdefault:\n+\t\t\t\tfmt.Printf(\"mainLoop: unhandled %#v\\n\", msg)\n+\t\t\t}\n \t\t}\n \t}\n }"}, {"sha": "5f2c447142adb328e6da7358539180b0cc3579ff", "filename": "libgo/go/exp/ssh/messages.go", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -144,19 +144,6 @@ type channelOpenFailureMsg struct {\n \tLanguage string\n }\n \n-// See RFC 4254, section 5.2.\n-type channelData struct {\n-\tPeersId uint32\n-\tPayload []byte `ssh:\"rest\"`\n-}\n-\n-// See RFC 4254, section 5.2.\n-type channelExtendedData struct {\n-\tPeersId  uint32\n-\tDatatype uint32\n-\tPayload  []byte `ssh:\"rest\"`\n-}\n-\n type channelRequestMsg struct {\n \tPeersId             uint32\n \tRequest             string\n@@ -612,10 +599,6 @@ func decode(packet []byte) interface{} {\n \t\tmsg = new(channelOpenFailureMsg)\n \tcase msgChannelWindowAdjust:\n \t\tmsg = new(windowAdjustMsg)\n-\tcase msgChannelData:\n-\t\tmsg = new(channelData)\n-\tcase msgChannelExtendedData:\n-\t\tmsg = new(channelExtendedData)\n \tcase msgChannelEOF:\n \t\tmsg = new(channelEOFMsg)\n \tcase msgChannelClose:"}, {"sha": "0dd24ecd6ee7d4512e5a4a79af0250322a63c7c1", "filename": "libgo/go/exp/ssh/server.go", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -581,75 +581,89 @@ func (s *ServerConn) Accept() (Channel, os.Error) {\n \t\t\treturn nil, err\n \t\t}\n \n-\t\tswitch msg := decode(packet).(type) {\n-\t\tcase *channelOpenMsg:\n-\t\t\tc := new(channel)\n-\t\t\tc.chanType = msg.ChanType\n-\t\t\tc.theirId = msg.PeersId\n-\t\t\tc.theirWindow = msg.PeersWindow\n-\t\t\tc.maxPacketSize = msg.MaxPacketSize\n-\t\t\tc.extraData = msg.TypeSpecificData\n-\t\t\tc.myWindow = defaultWindowSize\n-\t\t\tc.serverConn = s\n-\t\t\tc.cond = sync.NewCond(&c.lock)\n-\t\t\tc.pendingData = make([]byte, c.myWindow)\n-\n-\t\t\ts.lock.Lock()\n-\t\t\tc.myId = s.nextChanId\n-\t\t\ts.nextChanId++\n-\t\t\ts.channels[c.myId] = c\n-\t\t\ts.lock.Unlock()\n-\t\t\treturn c, nil\n-\n-\t\tcase *channelRequestMsg:\n-\t\t\ts.lock.Lock()\n-\t\t\tc, ok := s.channels[msg.PeersId]\n-\t\t\tif !ok {\n-\t\t\t\tcontinue\n+\t\tswitch packet[0] {\n+\t\tcase msgChannelData:\n+\t\t\tif len(packet) < 9 {\n+\t\t\t\t// malformed data packet\n+\t\t\t\treturn nil, ParseError{msgChannelData}\n \t\t\t}\n-\t\t\tc.handlePacket(msg)\n-\t\t\ts.lock.Unlock()\n-\n-\t\tcase *channelData:\n+\t\t\tpeersId := uint32(packet[1])<<24 | uint32(packet[2])<<16 | uint32(packet[3])<<8 | uint32(packet[4])\n \t\t\ts.lock.Lock()\n-\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\tc, ok := s.channels[peersId]\n \t\t\tif !ok {\n+\t\t\t\ts.lock.Unlock()\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tc.handleData(msg.Payload)\n-\t\t\ts.lock.Unlock()\n-\n-\t\tcase *channelEOFMsg:\n-\t\t\ts.lock.Lock()\n-\t\t\tc, ok := s.channels[msg.PeersId]\n-\t\t\tif !ok {\n-\t\t\t\tcontinue\n+\t\t\tif length := int(packet[5])<<24 | int(packet[6])<<16 | int(packet[7])<<8 | int(packet[8]); length > 0 {\n+\t\t\t\tpacket = packet[9:]\n+\t\t\t\tc.handleData(packet[:length])\n \t\t\t}\n-\t\t\tc.handlePacket(msg)\n \t\t\ts.lock.Unlock()\n+\t\tdefault:\n+\t\t\tswitch msg := decode(packet).(type) {\n+\t\t\tcase *channelOpenMsg:\n+\t\t\t\tc := new(channel)\n+\t\t\t\tc.chanType = msg.ChanType\n+\t\t\t\tc.theirId = msg.PeersId\n+\t\t\t\tc.theirWindow = msg.PeersWindow\n+\t\t\t\tc.maxPacketSize = msg.MaxPacketSize\n+\t\t\t\tc.extraData = msg.TypeSpecificData\n+\t\t\t\tc.myWindow = defaultWindowSize\n+\t\t\t\tc.serverConn = s\n+\t\t\t\tc.cond = sync.NewCond(&c.lock)\n+\t\t\t\tc.pendingData = make([]byte, c.myWindow)\n+\n+\t\t\t\ts.lock.Lock()\n+\t\t\t\tc.myId = s.nextChanId\n+\t\t\t\ts.nextChanId++\n+\t\t\t\ts.channels[c.myId] = c\n+\t\t\t\ts.lock.Unlock()\n+\t\t\t\treturn c, nil\n+\n+\t\t\tcase *channelRequestMsg:\n+\t\t\t\ts.lock.Lock()\n+\t\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\t\tif !ok {\n+\t\t\t\t\ts.lock.Unlock()\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tc.handlePacket(msg)\n+\t\t\t\ts.lock.Unlock()\n \n-\t\tcase *channelCloseMsg:\n-\t\t\ts.lock.Lock()\n-\t\t\tc, ok := s.channels[msg.PeersId]\n-\t\t\tif !ok {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tc.handlePacket(msg)\n-\t\t\ts.lock.Unlock()\n+\t\t\tcase *channelEOFMsg:\n+\t\t\t\ts.lock.Lock()\n+\t\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\t\tif !ok {\n+\t\t\t\t\ts.lock.Unlock()\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tc.handlePacket(msg)\n+\t\t\t\ts.lock.Unlock()\n \n-\t\tcase *globalRequestMsg:\n-\t\t\tif msg.WantReply {\n-\t\t\t\tif err := s.writePacket([]byte{msgRequestFailure}); err != nil {\n-\t\t\t\t\treturn nil, err\n+\t\t\tcase *channelCloseMsg:\n+\t\t\t\ts.lock.Lock()\n+\t\t\t\tc, ok := s.channels[msg.PeersId]\n+\t\t\t\tif !ok {\n+\t\t\t\t\ts.lock.Unlock()\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t}\n+\t\t\t\tc.handlePacket(msg)\n+\t\t\t\ts.lock.Unlock()\n \n-\t\tcase UnexpectedMessageError:\n-\t\t\treturn nil, msg\n-\t\tcase *disconnectMsg:\n-\t\t\treturn nil, os.EOF\n-\t\tdefault:\n-\t\t\t// Unknown message. Ignore.\n+\t\t\tcase *globalRequestMsg:\n+\t\t\t\tif msg.WantReply {\n+\t\t\t\t\tif err := s.writePacket([]byte{msgRequestFailure}); err != nil {\n+\t\t\t\t\t\treturn nil, err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\tcase UnexpectedMessageError:\n+\t\t\t\treturn nil, msg\n+\t\t\tcase *disconnectMsg:\n+\t\t\t\treturn nil, os.EOF\n+\t\t\tdefault:\n+\t\t\t\t// Unknown message. Ignore.\n+\t\t\t}\n \t\t}\n \t}\n "}, {"sha": "c26ae78d17fb45f25fe3633f6960f3a8ab8adc6f", "filename": "libgo/go/exp/template/html/css.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -35,19 +35,19 @@ func endsWithCSSKeyword(b []byte, kw string) bool {\n }\n \n // isCSSNmchar returns whether rune is allowed anywhere in a CSS identifier.\n-func isCSSNmchar(rune int) bool {\n+func isCSSNmchar(r rune) bool {\n \t// Based on the CSS3 nmchar production but ignores multi-rune escape\n \t// sequences.\n \t// http://www.w3.org/TR/css3-syntax/#SUBTOK-nmchar\n-\treturn 'a' <= rune && rune <= 'z' ||\n-\t\t'A' <= rune && rune <= 'Z' ||\n-\t\t'0' <= rune && rune <= '9' ||\n-\t\t'-' == rune ||\n-\t\t'_' == rune ||\n+\treturn 'a' <= r && r <= 'z' ||\n+\t\t'A' <= r && r <= 'Z' ||\n+\t\t'0' <= r && r <= '9' ||\n+\t\tr == '-' ||\n+\t\tr == '_' ||\n \t\t// Non-ASCII cases below.\n-\t\t0x80 <= rune && rune <= 0xd7ff ||\n-\t\t0xe000 <= rune && rune <= 0xfffd ||\n-\t\t0x10000 <= rune && rune <= 0x10ffff\n+\t\t0x80 <= r && r <= 0xd7ff ||\n+\t\t0xe000 <= r && r <= 0xfffd ||\n+\t\t0x10000 <= r && r <= 0x10ffff\n }\n \n // decodeCSS decodes CSS3 escapes given a sequence of stringchars.\n@@ -81,11 +81,11 @@ func decodeCSS(s []byte) []byte {\n \t\t\tfor j < len(s) && j < 7 && isHex(s[j]) {\n \t\t\t\tj++\n \t\t\t}\n-\t\t\trune := hexDecode(s[1:j])\n-\t\t\tif rune > unicode.MaxRune {\n-\t\t\t\trune, j = rune/16, j-1\n+\t\t\tr := hexDecode(s[1:j])\n+\t\t\tif r > unicode.MaxRune {\n+\t\t\t\tr, j = r/16, j-1\n \t\t\t}\n-\t\t\tn := utf8.EncodeRune(b[len(b):cap(b)], rune)\n+\t\t\tn := utf8.EncodeRune(b[len(b):cap(b)], r)\n \t\t\t// The optional space at the end allows a hex\n \t\t\t// sequence to be followed by a literal hex.\n \t\t\t// string(decodeCSS([]byte(`\\A B`))) == \"\\nB\"\n@@ -105,17 +105,17 @@ func isHex(c byte) bool {\n }\n \n // hexDecode decodes a short hex digit sequence: \"10\" -> 16.\n-func hexDecode(s []byte) int {\n-\tn := 0\n+func hexDecode(s []byte) rune {\n+\tn := rune(0)\n \tfor _, c := range s {\n \t\tn <<= 4\n \t\tswitch {\n \t\tcase '0' <= c && c <= '9':\n-\t\t\tn |= int(c - '0')\n+\t\t\tn |= rune(c - '0')\n \t\tcase 'a' <= c && c <= 'f':\n-\t\t\tn |= int(c-'a') + 10\n+\t\t\tn |= rune(c-'a') + 10\n \t\tcase 'A' <= c && c <= 'F':\n-\t\t\tn |= int(c-'A') + 10\n+\t\t\tn |= rune(c-'A') + 10\n \t\tdefault:\n \t\t\tpanic(fmt.Sprintf(\"Bad hex digit in %q\", s))\n \t\t}\n@@ -251,11 +251,11 @@ func cssValueFilter(args ...interface{}) string {\n \t\tcase '-':\n \t\t\t// Disallow <!-- or -->.\n \t\t\t// -- should not appear in valid identifiers.\n-\t\t\tif i != 0 && '-' == b[i-1] {\n+\t\t\tif i != 0 && b[i-1] == '-' {\n \t\t\t\treturn filterFailsafe\n \t\t\t}\n \t\tdefault:\n-\t\t\tif c < 0x80 && isCSSNmchar(int(c)) {\n+\t\t\tif c < 0x80 && isCSSNmchar(rune(c)) {\n \t\t\t\tid = append(id, c)\n \t\t\t}\n \t\t}"}, {"sha": "b3b83e855d3b47a66834b66196722eeca7295758", "filename": "libgo/go/exp/template/html/css_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fcss_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -35,7 +35,7 @@ func TestEndsWithCSSKeyword(t *testing.T) {\n \n func TestIsCSSNmchar(t *testing.T) {\n \ttests := []struct {\n-\t\trune int\n+\t\trune rune\n \t\twant bool\n \t}{\n \t\t{0, false},\n@@ -114,11 +114,11 @@ func TestDecodeCSS(t *testing.T) {\n func TestHexDecode(t *testing.T) {\n \tfor i := 0; i < 0x200000; i += 101 /* coprime with 16 */ {\n \t\ts := strconv.Itob(i, 16)\n-\t\tif got := hexDecode([]byte(s)); got != i {\n+\t\tif got := int(hexDecode([]byte(s))); got != i {\n \t\t\tt.Errorf(\"%s: want %d but got %d\", s, i, got)\n \t\t}\n \t\ts = strings.ToUpper(s)\n-\t\tif got := hexDecode([]byte(s)); got != i {\n+\t\tif got := int(hexDecode([]byte(s))); got != i {\n \t\t\tt.Errorf(\"%s: want %d but got %d\", s, i, got)\n \t\t}\n \t}"}, {"sha": "1b3b2567335b8860163f09571fdd849d5b32b74e", "filename": "libgo/go/exp/template/html/escape_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fescape_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -1549,8 +1549,8 @@ func TestEnsurePipelineContains(t *testing.T) {\n \t}\n }\n \n-func expectExecuteFailure(t *testing.T, b *bytes.Buffer) {\n-\tif x := recover(); x != nil {\n+func expectExecuteFailure(t *testing.T, b *bytes.Buffer, err os.Error) {\n+\tif err != nil {\n \t\tif b.Len() != 0 {\n \t\t\tt.Errorf(\"output on buffer: %q\", b.String())\n \t\t}\n@@ -1563,8 +1563,8 @@ func TestEscapeErrorsNotIgnorable(t *testing.T) {\n \tvar b bytes.Buffer\n \ttmpl := template.Must(template.New(\"dangerous\").Parse(\"<a\"))\n \tEscape(tmpl)\n-\tdefer expectExecuteFailure(t, &b)\n-\ttmpl.Execute(&b, nil)\n+\terr := tmpl.Execute(&b, nil)\n+\texpectExecuteFailure(t, &b, err)\n }\n \n func TestEscapeSetErrorsNotIgnorable(t *testing.T) {\n@@ -1574,8 +1574,8 @@ func TestEscapeSetErrorsNotIgnorable(t *testing.T) {\n \t}\n \tEscapeSet(s, \"t\")\n \tvar b bytes.Buffer\n-\tdefer expectExecuteFailure(t, &b)\n-\ts.Execute(&b, \"t\", nil)\n+\terr = s.Execute(&b, \"t\", nil)\n+\texpectExecuteFailure(t, &b, err)\n }\n \n func TestRedundantFuncs(t *testing.T) {"}, {"sha": "92d8f419946477747b406466217be8a005c59daa", "filename": "libgo/go/exp/template/html/html.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fhtml.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -139,7 +139,7 @@ var htmlNospaceNormReplacementTable = []string{\n func htmlReplacer(s string, replacementTable []string, badRunes bool) string {\n \twritten, b := 0, new(bytes.Buffer)\n \tfor i, r := range s {\n-\t\tif r < len(replacementTable) {\n+\t\tif int(r) < len(replacementTable) {\n \t\t\tif repl := replacementTable[r]; len(repl) != 0 {\n \t\t\t\tb.WriteString(s[written:i])\n \t\t\t\tb.WriteString(repl)"}, {"sha": "5646f8a4fd8075914b5213661cfac3f3a24ec0f9", "filename": "libgo/go/exp/template/html/js.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftemplate%2Fhtml%2Fjs.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -85,7 +85,7 @@ func nextJSCtx(s []byte, preceding jsCtx) jsCtx {\n \t\t// Look for an IdentifierName and see if it is a keyword that\n \t\t// can precede a regular expression.\n \t\tj := n\n-\t\tfor j > 0 && isJSIdentPart(int(s[j-1])) {\n+\t\tfor j > 0 && isJSIdentPart(rune(s[j-1])) {\n \t\t\tj--\n \t\t}\n \t\tif regexpPrecederKeywords[string(s[j:])] {\n@@ -234,7 +234,7 @@ func replace(s string, replacementTable []string) string {\n \tfor i, r := range s {\n \t\tvar repl string\n \t\tswitch {\n-\t\tcase r < len(replacementTable) && replacementTable[r] != \"\":\n+\t\tcase int(r) < len(replacementTable) && replacementTable[r] != \"\":\n \t\t\trepl = replacementTable[r]\n \t\tcase r == '\\u2028':\n \t\t\trepl = `\\u2028`\n@@ -329,17 +329,17 @@ var jsRegexpReplacementTable = []string{\n // It does not handle all the non-Latin letters, joiners, and combining marks,\n // but it does handle every codepoint that can occur in a numeric literal or\n // a keyword.\n-func isJSIdentPart(rune int) bool {\n+func isJSIdentPart(r rune) bool {\n \tswitch {\n-\tcase '$' == rune:\n+\tcase r == '$':\n \t\treturn true\n-\tcase '0' <= rune && rune <= '9':\n+\tcase '0' <= r && r <= '9':\n \t\treturn true\n-\tcase 'A' <= rune && rune <= 'Z':\n+\tcase 'A' <= r && r <= 'Z':\n \t\treturn true\n-\tcase '_' == rune:\n+\tcase r == '_':\n \t\treturn true\n-\tcase 'a' <= rune && rune <= 'z':\n+\tcase 'a' <= r && r <= 'z':\n \t\treturn true\n \t}\n \treturn false"}, {"sha": "784ffff01a37785d813578a0cd43f96799ca2bc0", "filename": "libgo/go/exp/types/exportdata.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fexportdata.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -17,21 +17,21 @@ import (\n \n func readGopackHeader(buf *bufio.Reader) (name string, size int, err os.Error) {\n \t// See $GOROOT/include/ar.h.\n-\thdr := make([]byte, 64+12+6+6+8+10+2)\n+\thdr := make([]byte, 16+12+6+6+8+10+2)\n \t_, err = io.ReadFull(buf, hdr)\n \tif err != nil {\n \t\treturn\n \t}\n \tif trace {\n \t\tfmt.Printf(\"header: %s\", hdr)\n \t}\n-\ts := strings.TrimSpace(string(hdr[64+12+6+6+8:][:10]))\n+\ts := strings.TrimSpace(string(hdr[16+12+6+6+8:][:10]))\n \tsize, err = strconv.Atoi(s)\n \tif err != nil || hdr[len(hdr)-2] != '`' || hdr[len(hdr)-1] != '\\n' {\n \t\terr = os.NewError(\"invalid archive header\")\n \t\treturn\n \t}\n-\tname = strings.TrimSpace(string(hdr[:64]))\n+\tname = strings.TrimSpace(string(hdr[:16]))\n \treturn\n }\n "}, {"sha": "4e5172a3d22e1f4c633d9184d2e8f93b85d11dbb", "filename": "libgo/go/exp/types/gcimporter.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fgcimporter.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -71,7 +71,7 @@ func findPkg(path string) (filename, id string) {\n // object/archive file and populates its scope with the results.\n type gcParser struct {\n \tscanner scanner.Scanner\n-\ttok     int                    // current token\n+\ttok     rune                   // current token\n \tlit     string                 // literal string; only valid for Ident, Int, String tokens\n \tid      string                 // package id of imported package\n \timports map[string]*ast.Object // package id -> package object\n@@ -195,7 +195,7 @@ func (p *gcParser) errorf(format string, args ...interface{}) {\n \tp.error(fmt.Sprintf(format, args...))\n }\n \n-func (p *gcParser) expect(tok int) string {\n+func (p *gcParser) expect(tok rune) string {\n \tlit := p.lit\n \tif p.tok != tok {\n \t\tp.errorf(\"expected %q, got %q (%q)\", scanner.TokenString(tok), scanner.TokenString(p.tok), lit)\n@@ -205,9 +205,9 @@ func (p *gcParser) expect(tok int) string {\n }\n \n func (p *gcParser) expectSpecial(tok string) {\n-\tsep := 'x' // not white space\n+\tsep := rune('x') // not white space\n \ti := 0\n-\tfor i < len(tok) && p.tok == int(tok[i]) && sep > ' ' {\n+\tfor i < len(tok) && p.tok == rune(tok[i]) && sep > ' ' {\n \t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token\n \t\tp.next()\n \t\ti++\n@@ -260,7 +260,7 @@ func (p *gcParser) parsePkgId() *ast.Object {\n func (p *gcParser) parseDotIdent() string {\n \tident := \"\"\n \tif p.tok != scanner.Int {\n-\t\tsep := 'x' // not white space\n+\t\tsep := rune('x') // not white space\n \t\tfor (p.tok == scanner.Ident || p.tok == scanner.Int || p.tok == '\u00b7') && sep > ' ' {\n \t\t\tident += p.lit\n \t\t\tsep = p.scanner.Peek() // if sep <= ' ', there is white space before the next token"}, {"sha": "84a1abe27013251a6826f8ca0524486bc9453601", "filename": "libgo/go/exp/types/testdata/test0.src", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Ftestdata%2Ftest0.src?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// type declarations\n+\n+package test0\n+\n+import \"unsafe\"\n+\n+const pi = 3.1415\n+\n+type (\n+\tN undeclared /* ERROR \"undeclared\" */\n+\tB bool\n+\tI int32\n+\tA [10]P\n+\tT struct {\n+\t\tx, y P\n+\t}\n+\tP *T\n+\tR (*R)\n+\tF func(A) I\n+\tY interface {\n+\t\tf(A) I\n+\t}\n+\tS [](((P)))\n+\tM map[I]F\n+\tC chan<- I\n+)\n+\n+\n+type (\n+\tp1 pi /* ERROR \"not a package\" */ .foo\n+\tp2 unsafe.Pointer\n+)\n+\n+\n+type (\n+\tPi pi /* ERROR \"not a type\" */\n+\n+\ta /* DISABLED \"illegal cycle\" */ a\n+\ta /* ERROR \"redeclared\" */ int\n+\n+\t// where the cycle error appears depends on the\n+\t// order in which declarations are processed\n+\t// (which depends on the order in which a map\n+\t// is iterated through)\n+\tb c\n+\tc /* DISABLED \"illegal cycle\" */ d\n+\td e\n+\te b\n+\n+\tt *t\n+\n+\tU V\n+\tV *W\n+\tW U\n+\n+\tP1 *S2\n+\tP2 P1\n+\n+\tS0 struct {\n+\t}\n+\tS1 struct {\n+\t\ta, b, c int\n+\t\tu, v, a /* ERROR \"redeclared\" */ float32\n+\t}\n+\tS2 struct {\n+\t\tU // anonymous field\n+\t\t// TODO(gri) recognize double-declaration below\n+\t\t// U /* ERROR \"redeclared\" */ int\n+\t}\n+\tS3 struct {\n+\t\tx S2\n+\t}\n+\tS4/* DISABLED \"illegal cycle\" */ struct {\n+\t\tS4\n+\t}\n+\tS5 struct {\n+\t\tS6\n+\t}\n+\tS6 /* DISABLED \"illegal cycle\" */ struct {\n+\t\tfield S7\n+\t}\n+\tS7 struct {\n+\t\tS5\n+\t}\n+\n+\tL1 []L1\n+\tL2 []int\n+\n+\tA1 [10]int\n+\tA2 /* DISABLED \"illegal cycle\" */ [10]A2\n+\tA3 /* DISABLED \"illegal cycle\" */ [10]struct {\n+\t\tx A4\n+\t}\n+\tA4 [10]A3\n+\n+\tF1 func()\n+\tF2 func(x, y, z float32)\n+\tF3 func(x, y, x /* ERROR \"redeclared\" */ float32)\n+\tF4 func() (x, y, x /* ERROR \"redeclared\" */ float32)\n+\tF5 func(x int) (x /* ERROR \"redeclared\" */ float32)\n+\tF6 func(x ...int)\n+\n+\tI1 interface{}\n+\tI2 interface {\n+\t\tm1()\n+\t}\n+\tI3 interface {\n+\t\tm1()\n+\t\tm1 /* ERROR \"redeclared\" */ ()\n+\t}\n+\tI4 interface {\n+\t\tm1(x, y, x /* ERROR \"redeclared\" */ float32)\n+\t\tm2() (x, y, x /* ERROR \"redeclared\" */ float32)\n+\t\tm3(x int) (x /* ERROR \"redeclared\" */ float32)\n+\t}\n+\tI5 interface {\n+\t\tm1(I5)\n+\t}\n+\tI6 interface {\n+\t\tS0 /* ERROR \"non-interface\" */\n+\t}\n+\tI7 interface {\n+\t\tI1\n+\t\tI1\n+\t}\n+\tI8 /* DISABLED \"illegal cycle\" */ interface {\n+\t\tI8\n+\t}\n+\tI9 /* DISABLED \"illegal cycle\" */ interface {\n+\t\tI10\n+\t}\n+\tI10 interface {\n+\t\tI11\n+\t}\n+\tI11 interface {\n+\t\tI9\n+\t}\n+\n+\tC1 chan int\n+\tC2 <-chan int\n+\tC3 chan<- C3\n+\tC4 chan C5\n+\tC5 chan C6\n+\tC6 chan C4\n+\n+\tM1 map[Last]string\n+\tM2 map[string]M2\n+\n+\tLast int\n+)"}, {"sha": "f0435966d11e9618f6bc5a19a6fffad5ddd1b4e3", "filename": "libgo/go/exp/types/universe.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -54,6 +54,7 @@ func init() {\n \n \tBool = defType(\"bool\")\n \tdefType(\"byte\") // TODO(gri) should be an alias for uint8\n+\tdefType(\"rune\") // TODO(gri) should be an alias for int\n \tdefType(\"complex64\")\n \tComplex128 = defType(\"complex128\")\n \tdefType(\"float32\")"}, {"sha": "fb2b825e68e3fac258a72a46db6f4d4235183645", "filename": "libgo/go/exp/winfsnotify/winfsnotify_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fwinfsnotify%2Fwinfsnotify_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -40,7 +40,7 @@ func TestNotifyEvents(t *testing.T) {\n \t// Add a watch for testDir\n \tos.RemoveAll(testDir)\n \tif err = os.Mkdir(testDir, 0777); err != nil {\n-\t\tt.Fatalf(\"Failed to create test directory\", err)\n+\t\tt.Fatalf(\"Failed to create test directory: %s\", err)\n \t}\n \tdefer os.RemoveAll(testDir)\n \terr = watcher.AddWatch(testDir, mask)"}, {"sha": "f5d6ed586c87276ef5dcbd62009309a19465ece9", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -102,7 +102,7 @@ func (v *Map) String() string {\n \t\tif !first {\n \t\t\tfmt.Fprintf(b, \", \")\n \t\t}\n-\t\tfmt.Fprintf(b, \"\\\"%s\\\": %v\", key, val.String())\n+\t\tfmt.Fprintf(b, \"\\\"%s\\\": %v\", key, val)\n \t\tfirst = false\n \t}\n \tfmt.Fprintf(b, \"}\")"}, {"sha": "6713f0a16ed27c8e0495263d1797230068ff36fa", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -89,10 +89,14 @@\n \tIf an operand implements interface Formatter, that interface\n \tcan be used for fine control of formatting.\n \n-\tIf an operand implements method String() string that method\n+\tNext, if an operand implements the error interface, the Error method\n \twill be used to convert the object to a string, which will then\n-\tbe formatted as required by the verb (if any). To avoid\n-\trecursion in cases such as\n+\tbe formatted as required by the verb (if any).\n+\n+\tFinally, if an operand implements method String() string that method\n+\twill be used to convert the object to a string, which will then\n+\tbe formatted as required by the verb (if any).\n+\tTo avoid recursion in cases such as\n \t\ttype X int\n \t\tfunc (x X) String() string { return Sprintf(\"%d\", x) }\n \tcast the value before recurring:"}, {"sha": "db83f85f9570c55ee269003b437306647c643336", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -73,7 +73,7 @@ type C struct {\n \n type F int\n \n-func (f F) Format(s State, c int) {\n+func (f F) Format(s State, c rune) {\n \tFprintf(s, \"<%c=F(%d)>\", c, int(f))\n }\n \n@@ -356,7 +356,7 @@ var fmttests = []struct {\n \t{\"%#v\", map[string]int{\"a\": 1}, `map[string] int{\"a\":1}`},\n \t{\"%#v\", map[string]B{\"a\": {1, 2}}, `map[string] fmt_test.B{\"a\":fmt_test.B{I:1, j:2}}`},\n \t{\"%#v\", []string{\"a\", \"b\"}, `[]string{\"a\", \"b\"}`},\n-\t{\"%#v\", SI{}, `fmt_test.SI{I:interface { }(nil)}`},\n+\t{\"%#v\", SI{}, `fmt_test.SI{I:interface {}(nil)}`},\n \n \t// slices with other formats\n \t{\"%#x\", []int{1, 2, 15}, `[0x1 0x2 0xf]`},\n@@ -546,7 +546,7 @@ func TestCountMallocs(t *testing.T) {\n \n type flagPrinter struct{}\n \n-func (*flagPrinter) Format(f State, c int) {\n+func (*flagPrinter) Format(f State, c rune) {\n \ts := \"%\"\n \tfor i := 0; i < 128; i++ {\n \t\tif f.Flag(i) {\n@@ -746,7 +746,7 @@ type PanicF struct {\n }\n \n // Value receiver.\n-func (p PanicF) Format(f State, c int) {\n+func (p PanicF) Format(f State, c rune) {\n \tpanic(p.message)\n }\n "}, {"sha": "80eb9863353c73e7b793f11d9a8923244eadf229", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -242,8 +242,8 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t}\n \n \t// If we want a quoted char for %#U, move the data up to make room.\n-\tif f.unicode && f.uniQuote && a >= 0 && a <= unicode.MaxRune && unicode.IsPrint(int(a)) {\n-\t\truneWidth := utf8.RuneLen(int(a))\n+\tif f.unicode && f.uniQuote && a >= 0 && a <= unicode.MaxRune && unicode.IsPrint(rune(a)) {\n+\t\truneWidth := utf8.RuneLen(rune(a))\n \t\twidth := 1 + 1 + runeWidth + 1 // space, quote, rune, quote\n \t\tcopy(buf[i-width:], buf[i:])   // guaranteed to have enough room.\n \t\ti -= width\n@@ -253,7 +253,7 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \t\tj++\n \t\tbuf[j] = '\\''\n \t\tj++\n-\t\tutf8.EncodeRune(buf[j:], int(a))\n+\t\tutf8.EncodeRune(buf[j:], rune(a))\n \t\tj += runeWidth\n \t\tbuf[j] = '\\''\n \t}\n@@ -400,7 +400,7 @@ func (f *fmt) fmt_G32(v float32) { f.plusSpace(strconv.Ftoa32(v, 'G', doPrec(f,\n func (f *fmt) fmt_fb32(v float32) { f.padString(strconv.Ftoa32(v, 'b', 0)) }\n \n // fmt_c64 formats a complex64 according to the verb.\n-func (f *fmt) fmt_c64(v complex64, verb int) {\n+func (f *fmt) fmt_c64(v complex64, verb rune) {\n \tf.buf.WriteByte('(')\n \tr := real(v)\n \tfor i := 0; ; i++ {\n@@ -426,7 +426,7 @@ func (f *fmt) fmt_c64(v complex64, verb int) {\n }\n \n // fmt_c128 formats a complex128 according to the verb.\n-func (f *fmt) fmt_c128(v complex128, verb int) {\n+func (f *fmt) fmt_c128(v complex128, verb rune) {\n \tf.buf.WriteByte('(')\n \tr := real(v)\n \tfor i := 0; ; i++ {"}, {"sha": "5e0237f4544e903add42486656082007e7538e9b", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -51,7 +51,7 @@ type State interface {\n // The implementation of Format may call Sprintf or Fprintf(f) etc.\n // to generate its output.\n type Formatter interface {\n-\tFormat(f State, c int)\n+\tFormat(f State, c rune)\n }\n \n // Stringer is implemented by any value that has a String method,\n@@ -159,7 +159,7 @@ func (p *pp) Flag(b int) bool {\n \treturn false\n }\n \n-func (p *pp) add(c int) {\n+func (p *pp) add(c rune) {\n \tp.buf.WriteRune(c)\n }\n \n@@ -297,7 +297,7 @@ func (p *pp) unknownType(v interface{}) {\n \tp.buf.WriteByte('?')\n }\n \n-func (p *pp) badVerb(verb int) {\n+func (p *pp) badVerb(verb rune) {\n \tp.add('%')\n \tp.add('!')\n \tp.add(verb)\n@@ -317,7 +317,7 @@ func (p *pp) badVerb(verb int) {\n \tp.add(')')\n }\n \n-func (p *pp) fmtBool(v bool, verb int) {\n+func (p *pp) fmtBool(v bool, verb rune) {\n \tswitch verb {\n \tcase 't', 'v':\n \t\tp.fmt.fmt_boolean(v)\n@@ -328,15 +328,15 @@ func (p *pp) fmtBool(v bool, verb int) {\n \n // fmtC formats a rune for the 'c' format.\n func (p *pp) fmtC(c int64) {\n-\trune := int(c) // Check for overflow.\n-\tif int64(rune) != c {\n-\t\trune = utf8.RuneError\n+\tr := rune(c) // Check for overflow.\n+\tif int64(r) != c {\n+\t\tr = utf8.RuneError\n \t}\n-\tw := utf8.EncodeRune(p.runeBuf[0:utf8.UTFMax], rune)\n+\tw := utf8.EncodeRune(p.runeBuf[0:utf8.UTFMax], r)\n \tp.fmt.pad(p.runeBuf[0:w])\n }\n \n-func (p *pp) fmtInt64(v int64, verb int) {\n+func (p *pp) fmtInt64(v int64, verb rune) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(v, 2, signed, ldigits)\n@@ -394,7 +394,7 @@ func (p *pp) fmtUnicode(v int64) {\n \tp.fmt.sharp = sharp\n }\n \n-func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool) {\n+func (p *pp) fmtUint64(v uint64, verb rune, goSyntax bool) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.integer(int64(v), 2, unsigned, ldigits)\n@@ -427,7 +427,7 @@ func (p *pp) fmtUint64(v uint64, verb int, goSyntax bool) {\n \t}\n }\n \n-func (p *pp) fmtFloat32(v float32, verb int) {\n+func (p *pp) fmtFloat32(v float32, verb rune) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.fmt_fb32(v)\n@@ -446,7 +446,7 @@ func (p *pp) fmtFloat32(v float32, verb int) {\n \t}\n }\n \n-func (p *pp) fmtFloat64(v float64, verb int) {\n+func (p *pp) fmtFloat64(v float64, verb rune) {\n \tswitch verb {\n \tcase 'b':\n \t\tp.fmt.fmt_fb64(v)\n@@ -465,7 +465,7 @@ func (p *pp) fmtFloat64(v float64, verb int) {\n \t}\n }\n \n-func (p *pp) fmtComplex64(v complex64, verb int) {\n+func (p *pp) fmtComplex64(v complex64, verb rune) {\n \tswitch verb {\n \tcase 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c64(v, verb)\n@@ -476,7 +476,7 @@ func (p *pp) fmtComplex64(v complex64, verb int) {\n \t}\n }\n \n-func (p *pp) fmtComplex128(v complex128, verb int) {\n+func (p *pp) fmtComplex128(v complex128, verb rune) {\n \tswitch verb {\n \tcase 'e', 'E', 'f', 'F', 'g', 'G':\n \t\tp.fmt.fmt_c128(v, verb)\n@@ -487,7 +487,7 @@ func (p *pp) fmtComplex128(v complex128, verb int) {\n \t}\n }\n \n-func (p *pp) fmtString(v string, verb int, goSyntax bool) {\n+func (p *pp) fmtString(v string, verb rune, goSyntax bool) {\n \tswitch verb {\n \tcase 'v':\n \t\tif goSyntax {\n@@ -508,7 +508,7 @@ func (p *pp) fmtString(v string, verb int, goSyntax bool) {\n \t}\n }\n \n-func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int) {\n+func (p *pp) fmtBytes(v []byte, verb rune, goSyntax bool, depth int) {\n \tif verb == 'v' || verb == 'd' {\n \t\tif goSyntax {\n \t\t\tp.buf.Write(bytesBytes)\n@@ -547,7 +547,7 @@ func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int) {\n \t}\n }\n \n-func (p *pp) fmtPointer(value reflect.Value, verb int, goSyntax bool) {\n+func (p *pp) fmtPointer(value reflect.Value, verb rune, goSyntax bool) {\n \tvar u uintptr\n \tswitch value.Kind() {\n \tcase reflect.Chan, reflect.Func, reflect.Map, reflect.Ptr, reflect.Slice, reflect.UnsafePointer:\n@@ -579,7 +579,7 @@ var (\n \tuintptrBits = reflect.TypeOf(uintptr(0)).Bits()\n )\n \n-func (p *pp) catchPanic(field interface{}, verb int) {\n+func (p *pp) catchPanic(field interface{}, verb rune) {\n \tif err := recover(); err != nil {\n \t\t// If it's a nil pointer, just say \"<nil>\". The likeliest causes are a\n \t\t// Stringer that fails to guard against nil or a nil pointer for a\n@@ -604,7 +604,7 @@ func (p *pp) catchPanic(field interface{}, verb int) {\n \t}\n }\n \n-func (p *pp) handleMethods(verb int, plus, goSyntax bool, depth int) (wasString, handled bool) {\n+func (p *pp) handleMethods(verb rune, plus, goSyntax bool, depth int) (wasString, handled bool) {\n \t// Is it a Formatter?\n \tif formatter, ok := p.field.(Formatter); ok {\n \t\thandled = true\n@@ -630,20 +630,31 @@ func (p *pp) handleMethods(verb int, plus, goSyntax bool, depth int) (wasString,\n \t\t\treturn\n \t\t}\n \t} else {\n-\t\t// Is it a Stringer?\n-\t\tif stringer, ok := p.field.(Stringer); ok {\n+\t\t// Is it an error or Stringer?\n+\t\t// The duplication in the bodies is necessary:\n+\t\t// setting wasString and handled and deferring catchPanic\n+\t\t// must happen before calling the method.\n+\t\tswitch v := p.field.(type) {\n+\t\tcase os.Error:\n \t\t\twasString = false\n \t\t\thandled = true\n \t\t\tdefer p.catchPanic(p.field, verb)\n-\t\t\tp.printField(stringer.String(), verb, plus, false, depth)\n+\t\t\tp.printField(v.String(), verb, plus, false, depth)\n+\t\t\treturn\n+\n+\t\tcase Stringer:\n+\t\t\twasString = false\n+\t\t\thandled = true\n+\t\t\tdefer p.catchPanic(p.field, verb)\n+\t\t\tp.printField(v.String(), verb, plus, false, depth)\n \t\t\treturn\n \t\t}\n \t}\n \thandled = false\n \treturn\n }\n \n-func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n+func (p *pp) printField(field interface{}, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n \tif field == nil {\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.buf.Write(nilAngleBytes)\n@@ -719,7 +730,7 @@ func (p *pp) printField(field interface{}, verb int, plus, goSyntax bool, depth\n }\n \n // printValue is like printField but starts with a reflect value, not an interface{} value.\n-func (p *pp) printValue(value reflect.Value, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n+func (p *pp) printValue(value reflect.Value, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n \tif !value.IsValid() {\n \t\tif verb == 'T' || verb == 'v' {\n \t\t\tp.buf.Write(nilAngleBytes)\n@@ -755,7 +766,7 @@ func (p *pp) printValue(value reflect.Value, verb int, plus, goSyntax bool, dept\n \n // printReflectValue is the fallback for both printField and printValue.\n // It uses reflect to print the value.\n-func (p *pp) printReflectValue(value reflect.Value, verb int, plus, goSyntax bool, depth int) (wasString bool) {\n+func (p *pp) printReflectValue(value reflect.Value, verb rune, plus, goSyntax bool, depth int) (wasString bool) {\n \toldValue := p.value\n \tp.value = value\n BigSwitch:"}, {"sha": "eae952c9fff895dd0b7420cb33e79d95877b1e54", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 66, "deletions": 65, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -32,7 +32,7 @@ type ScanState interface {\n \t// If invoked during Scanln, Fscanln, or Sscanln, ReadRune() will\n \t// return EOF after returning the first '\\n' or when reading beyond\n \t// the specified width.\n-\tReadRune() (rune int, size int, err os.Error)\n+\tReadRune() (r rune, size int, err os.Error)\n \t// UnreadRune causes the next call to ReadRune to return the same rune.\n \tUnreadRune() os.Error\n \t// SkipSpace skips space in the input. Newlines are treated as space \n@@ -47,7 +47,7 @@ type ScanState interface {\n \t// EOF.  The returned slice points to shared data that may be overwritten\n \t// by the next call to Token, a call to a Scan function using the ScanState\n \t// as input, or when the calling Scan method returns.\n-\tToken(skipSpace bool, f func(int) bool) (token []byte, err os.Error)\n+\tToken(skipSpace bool, f func(rune) bool) (token []byte, err os.Error)\n \t// Width returns the value of the width option and whether it has been set.\n \t// The unit is Unicode code points.\n \tWidth() (wid int, ok bool)\n@@ -62,7 +62,7 @@ type ScanState interface {\n // receiver, which must be a pointer to be useful.  The Scan method is called\n // for any argument to Scan, Scanf, or Scanln that implements it.\n type Scanner interface {\n-\tScan(state ScanState, verb int) os.Error\n+\tScan(state ScanState, verb rune) os.Error\n }\n \n // Scan scans text read from standard input, storing successive\n@@ -149,8 +149,8 @@ const eof = -1\n type ss struct {\n \trr       io.RuneReader // where to read input\n \tbuf      bytes.Buffer  // token accumulator\n-\tpeekRune int           // one-rune lookahead\n-\tprevRune int           // last rune returned by ReadRune\n+\tpeekRune rune          // one-rune lookahead\n+\tprevRune rune          // last rune returned by ReadRune\n \tcount    int           // runes consumed so far.\n \tatEOF    bool          // already read EOF\n \tssave\n@@ -174,12 +174,12 @@ func (s *ss) Read(buf []byte) (n int, err os.Error) {\n \treturn 0, os.NewError(\"ScanState's Read should not be called. Use ReadRune\")\n }\n \n-func (s *ss) ReadRune() (rune int, size int, err os.Error) {\n+func (s *ss) ReadRune() (r rune, size int, err os.Error) {\n \tif s.peekRune >= 0 {\n \t\ts.count++\n-\t\trune = s.peekRune\n-\t\tsize = utf8.RuneLen(rune)\n-\t\ts.prevRune = rune\n+\t\tr = s.peekRune\n+\t\tsize = utf8.RuneLen(r)\n+\t\ts.prevRune = r\n \t\ts.peekRune = -1\n \t\treturn\n \t}\n@@ -188,10 +188,10 @@ func (s *ss) ReadRune() (rune int, size int, err os.Error) {\n \t\treturn\n \t}\n \n-\trune, size, err = s.rr.ReadRune()\n+\tr, size, err = s.rr.ReadRune()\n \tif err == nil {\n \t\ts.count++\n-\t\ts.prevRune = rune\n+\t\ts.prevRune = r\n \t} else if err == os.EOF {\n \t\ts.atEOF = true\n \t}\n@@ -207,8 +207,8 @@ func (s *ss) Width() (wid int, ok bool) {\n \n // The public method returns an error; this private one panics.\n // If getRune reaches EOF, the return value is EOF (-1).\n-func (s *ss) getRune() (rune int) {\n-\trune, _, err := s.ReadRune()\n+func (s *ss) getRune() (r rune) {\n+\tr, _, err := s.ReadRune()\n \tif err != nil {\n \t\tif err == os.EOF {\n \t\t\treturn eof\n@@ -221,9 +221,9 @@ func (s *ss) getRune() (rune int) {\n // mustReadRune turns os.EOF into a panic(io.ErrUnexpectedEOF).\n // It is called in cases such as string scanning where an EOF is a\n // syntax error.\n-func (s *ss) mustReadRune() (rune int) {\n-\trune = s.getRune()\n-\tif rune == eof {\n+func (s *ss) mustReadRune() (r rune) {\n+\tr = s.getRune()\n+\tif r == eof {\n \t\ts.error(io.ErrUnexpectedEOF)\n \t}\n \treturn\n@@ -248,7 +248,7 @@ func (s *ss) errorString(err string) {\n \tpanic(scanError{os.NewError(err)})\n }\n \n-func (s *ss) Token(skipSpace bool, f func(int) bool) (tok []byte, err os.Error) {\n+func (s *ss) Token(skipSpace bool, f func(rune) bool) (tok []byte, err os.Error) {\n \tdefer func() {\n \t\tif e := recover(); e != nil {\n \t\t\tif se, ok := e.(scanError); ok {\n@@ -267,7 +267,7 @@ func (s *ss) Token(skipSpace bool, f func(int) bool) (tok []byte, err os.Error)\n }\n \n // notSpace is the default scanning function used in Token.\n-func notSpace(r int) bool {\n+func notSpace(r rune) bool {\n \treturn !unicode.IsSpace(r)\n }\n \n@@ -308,13 +308,13 @@ func (r *readRune) unread(buf []byte) {\n \n // ReadRune returns the next UTF-8 encoded code point from the\n // io.Reader inside r.\n-func (r *readRune) ReadRune() (rune int, size int, err os.Error) {\n+func (r *readRune) ReadRune() (rr rune, size int, err os.Error) {\n \tr.buf[0], err = r.readByte()\n \tif err != nil {\n \t\treturn 0, 0, err\n \t}\n \tif r.buf[0] < utf8.RuneSelf { // fast check for common ASCII case\n-\t\trune = int(r.buf[0])\n+\t\trr = rune(r.buf[0])\n \t\treturn\n \t}\n \tvar n int\n@@ -328,7 +328,7 @@ func (r *readRune) ReadRune() (rune int, size int, err os.Error) {\n \t\t\treturn\n \t\t}\n \t}\n-\trune, size = utf8.DecodeRune(r.buf[0:n])\n+\trr, size = utf8.DecodeRune(r.buf[0:n])\n \tif size < n { // an error\n \t\tr.unread(r.buf[size:n])\n \t}\n@@ -387,11 +387,11 @@ func (s *ss) free(old ssave) {\n // skipSpace skips spaces and maybe newlines.\n func (s *ss) skipSpace(stopAtNewline bool) {\n \tfor {\n-\t\trune := s.getRune()\n-\t\tif rune == eof {\n+\t\tr := s.getRune()\n+\t\tif r == eof {\n \t\t\treturn\n \t\t}\n-\t\tif rune == '\\n' {\n+\t\tif r == '\\n' {\n \t\t\tif stopAtNewline {\n \t\t\t\tbreak\n \t\t\t}\n@@ -401,7 +401,7 @@ func (s *ss) skipSpace(stopAtNewline bool) {\n \t\t\ts.errorString(\"unexpected newline\")\n \t\t\treturn\n \t\t}\n-\t\tif !unicode.IsSpace(rune) {\n+\t\tif !unicode.IsSpace(r) {\n \t\t\ts.UnreadRune()\n \t\t\tbreak\n \t\t}\n@@ -411,21 +411,21 @@ func (s *ss) skipSpace(stopAtNewline bool) {\n // token returns the next space-delimited string from the input.  It\n // skips white space.  For Scanln, it stops at newlines.  For Scan,\n // newlines are treated as spaces.\n-func (s *ss) token(skipSpace bool, f func(int) bool) []byte {\n+func (s *ss) token(skipSpace bool, f func(rune) bool) []byte {\n \tif skipSpace {\n \t\ts.skipSpace(false)\n \t}\n \t// read until white space or newline\n \tfor {\n-\t\trune := s.getRune()\n-\t\tif rune == eof {\n+\t\tr := s.getRune()\n+\t\tif r == eof {\n \t\t\tbreak\n \t\t}\n-\t\tif !f(rune) {\n+\t\tif !f(r) {\n \t\t\ts.UnreadRune()\n \t\t\tbreak\n \t\t}\n-\t\ts.buf.WriteRune(rune)\n+\t\ts.buf.WriteRune(r)\n \t}\n \treturn s.buf.Bytes()\n }\n@@ -441,34 +441,34 @@ var boolError = os.NewError(\"syntax error scanning boolean\")\n // consume reads the next rune in the input and reports whether it is in the ok string.\n // If accept is true, it puts the character into the input token.\n func (s *ss) consume(ok string, accept bool) bool {\n-\trune := s.getRune()\n-\tif rune == eof {\n+\tr := s.getRune()\n+\tif r == eof {\n \t\treturn false\n \t}\n-\tif strings.IndexRune(ok, rune) >= 0 {\n+\tif strings.IndexRune(ok, r) >= 0 {\n \t\tif accept {\n-\t\t\ts.buf.WriteRune(rune)\n+\t\t\ts.buf.WriteRune(r)\n \t\t}\n \t\treturn true\n \t}\n-\tif rune != eof && accept {\n+\tif r != eof && accept {\n \t\ts.UnreadRune()\n \t}\n \treturn false\n }\n \n // peek reports whether the next character is in the ok string, without consuming it.\n func (s *ss) peek(ok string) bool {\n-\trune := s.getRune()\n-\tif rune != eof {\n+\tr := s.getRune()\n+\tif r != eof {\n \t\ts.UnreadRune()\n \t}\n-\treturn strings.IndexRune(ok, rune) >= 0\n+\treturn strings.IndexRune(ok, r) >= 0\n }\n \n func (s *ss) notEOF() {\n \t// Guarantee there is data to be read.\n-\tif rune := s.getRune(); rune == eof {\n+\tif r := s.getRune(); r == eof {\n \t\tpanic(os.EOF)\n \t}\n \ts.UnreadRune()\n@@ -481,7 +481,7 @@ func (s *ss) accept(ok string) bool {\n }\n \n // okVerb verifies that the verb is present in the list, setting s.err appropriately if not.\n-func (s *ss) okVerb(verb int, okVerbs, typ string) bool {\n+func (s *ss) okVerb(verb rune, okVerbs, typ string) bool {\n \tfor _, v := range okVerbs {\n \t\tif v == verb {\n \t\t\treturn true\n@@ -492,7 +492,7 @@ func (s *ss) okVerb(verb int, okVerbs, typ string) bool {\n }\n \n // scanBool returns the value of the boolean represented by the next token.\n-func (s *ss) scanBool(verb int) bool {\n+func (s *ss) scanBool(verb rune) bool {\n \ts.skipSpace(false)\n \ts.notEOF()\n \tif !s.okVerb(verb, \"tv\", \"boolean\") {\n@@ -530,7 +530,7 @@ const (\n )\n \n // getBase returns the numeric base represented by the verb and its digit string.\n-func (s *ss) getBase(verb int) (base int, digits string) {\n+func (s *ss) getBase(verb rune) (base int, digits string) {\n \ts.okVerb(verb, \"bdoUxXv\", \"integer\") // sets s.err\n \tbase = 10\n \tdigits = decimalDigits\n@@ -564,13 +564,13 @@ func (s *ss) scanNumber(digits string, haveDigits bool) string {\n // scanRune returns the next rune value in the input.\n func (s *ss) scanRune(bitSize int) int64 {\n \ts.notEOF()\n-\trune := int64(s.getRune())\n+\tr := int64(s.getRune())\n \tn := uint(bitSize)\n-\tx := (rune << (64 - n)) >> (64 - n)\n-\tif x != rune {\n-\t\ts.errorString(\"overflow on character value \" + string(rune))\n+\tx := (r << (64 - n)) >> (64 - n)\n+\tif x != r {\n+\t\ts.errorString(\"overflow on character value \" + string(r))\n \t}\n-\treturn rune\n+\treturn r\n }\n \n // scanBasePrefix reports whether the integer begins with a 0 or 0x,\n@@ -593,7 +593,7 @@ func (s *ss) scanBasePrefix() (base int, digits string, found bool) {\n \n // scanInt returns the value of the integer represented by the next\n // token, checking for overflow.  Any error is stored in s.err.\n-func (s *ss) scanInt(verb int, bitSize int) int64 {\n+func (s *ss) scanInt(verb rune, bitSize int) int64 {\n \tif verb == 'c' {\n \t\treturn s.scanRune(bitSize)\n \t}\n@@ -626,7 +626,7 @@ func (s *ss) scanInt(verb int, bitSize int) int64 {\n \n // scanUint returns the value of the unsigned integer represented\n // by the next token, checking for overflow.  Any error is stored in s.err.\n-func (s *ss) scanUint(verb int, bitSize int) uint64 {\n+func (s *ss) scanUint(verb rune, bitSize int) uint64 {\n \tif verb == 'c' {\n \t\treturn uint64(s.scanRune(bitSize))\n \t}\n@@ -747,7 +747,7 @@ func (s *ss) convertFloat(str string, n int) float64 {\n // The atof argument is a type-specific reader for the underlying type.\n // If we're reading complex64, atof will parse float32s and convert them\n // to float64's to avoid reproducing this code for each complex type.\n-func (s *ss) scanComplex(verb int, n int) complex128 {\n+func (s *ss) scanComplex(verb rune, n int) complex128 {\n \tif !s.okVerb(verb, floatVerbs, \"complex\") {\n \t\treturn 0\n \t}\n@@ -761,7 +761,7 @@ func (s *ss) scanComplex(verb int, n int) complex128 {\n \n // convertString returns the string represented by the next input characters.\n // The format of the input is determined by the verb.\n-func (s *ss) convertString(verb int) (str string) {\n+func (s *ss) convertString(verb rune) (str string) {\n \tif !s.okVerb(verb, \"svqx\", \"string\") {\n \t\treturn \"\"\n \t}\n@@ -786,26 +786,26 @@ func (s *ss) quotedString() string {\n \tcase '`':\n \t\t// Back-quoted: Anything goes until EOF or back quote.\n \t\tfor {\n-\t\t\trune := s.mustReadRune()\n-\t\t\tif rune == quote {\n+\t\t\tr := s.mustReadRune()\n+\t\t\tif r == quote {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\ts.buf.WriteRune(rune)\n+\t\t\ts.buf.WriteRune(r)\n \t\t}\n \t\treturn s.buf.String()\n \tcase '\"':\n \t\t// Double-quoted: Include the quotes and let strconv.Unquote do the backslash escapes.\n \t\ts.buf.WriteRune(quote)\n \t\tfor {\n-\t\t\trune := s.mustReadRune()\n-\t\t\ts.buf.WriteRune(rune)\n-\t\t\tif rune == '\\\\' {\n+\t\t\tr := s.mustReadRune()\n+\t\t\ts.buf.WriteRune(r)\n+\t\t\tif r == '\\\\' {\n \t\t\t\t// In a legal backslash escape, no matter how long, only the character\n \t\t\t\t// immediately after the escape can itself be a backslash or quote.\n \t\t\t\t// Thus we only need to protect the first character after the backslash.\n-\t\t\t\trune := s.mustReadRune()\n-\t\t\t\ts.buf.WriteRune(rune)\n-\t\t\t} else if rune == '\"' {\n+\t\t\t\tr := s.mustReadRune()\n+\t\t\t\ts.buf.WriteRune(r)\n+\t\t\t} else if r == '\"' {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n@@ -821,7 +821,8 @@ func (s *ss) quotedString() string {\n }\n \n // hexDigit returns the value of the hexadecimal digit\n-func (s *ss) hexDigit(digit int) int {\n+func (s *ss) hexDigit(d rune) int {\n+\tdigit := int(d)\n \tswitch digit {\n \tcase '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':\n \t\treturn digit - '0'\n@@ -871,7 +872,7 @@ const floatVerbs = \"beEfFgGv\"\n const hugeWid = 1 << 30\n \n // scanOne scans a single value, deriving the scanner from the type of the argument.\n-func (s *ss) scanOne(verb int, field interface{}) {\n+func (s *ss) scanOne(verb rune, field interface{}) {\n \ts.buf.Reset()\n \tvar err os.Error\n \t// If the parameter has its own Scan method, use that.\n@@ -997,11 +998,11 @@ func (s *ss) doScan(a []interface{}) (numProcessed int, err os.Error) {\n \t// Check for newline if required.\n \tif !s.nlIsSpace {\n \t\tfor {\n-\t\t\trune := s.getRune()\n-\t\t\tif rune == '\\n' || rune == eof {\n+\t\t\tr := s.getRune()\n+\t\t\tif r == '\\n' || r == eof {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif !unicode.IsSpace(rune) {\n+\t\t\tif !unicode.IsSpace(r) {\n \t\t\t\ts.errorString(\"Scan: expected newline\")\n \t\t\t\tbreak\n \t\t\t}"}, {"sha": "fbc28c1b2bb9886cb832699f34820a4e2b7d053c", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -87,8 +87,8 @@ type FloatTest struct {\n // Xs accepts any non-empty run of the verb character\n type Xs string\n \n-func (x *Xs) Scan(state ScanState, verb int) os.Error {\n-\ttok, err := state.Token(true, func(r int) bool { return r == verb })\n+func (x *Xs) Scan(state ScanState, verb rune) os.Error {\n+\ttok, err := state.Token(true, func(r rune) bool { return r == verb })\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -109,7 +109,7 @@ type IntString struct {\n \ts string\n }\n \n-func (s *IntString) Scan(state ScanState, verb int) os.Error {\n+func (s *IntString) Scan(state ScanState, verb rune) os.Error {\n \tif _, err := Fscan(state, &s.i); err != nil {\n \t\treturn err\n \t}\n@@ -749,8 +749,8 @@ type TwoLines string\n \n // Attempt to read two lines into the object.  Scanln should prevent this\n // because it stops at newline; Scan and Scanf should be fine.\n-func (t *TwoLines) Scan(state ScanState, verb int) os.Error {\n-\tchars := make([]int, 0, 100)\n+func (t *TwoLines) Scan(state ScanState, verb rune) os.Error {\n+\tchars := make([]rune, 0, 100)\n \tfor nlCount := 0; nlCount < 2; {\n \t\tc, _, err := state.ReadRune()\n \t\tif err != nil {\n@@ -812,7 +812,7 @@ type RecursiveInt struct {\n \tnext *RecursiveInt\n }\n \n-func (r *RecursiveInt) Scan(state ScanState, verb int) (err os.Error) {\n+func (r *RecursiveInt) Scan(state ScanState, verb rune) (err os.Error) {\n \t_, err = Fscan(state, &r.i)\n \tif err != nil {\n \t\treturn\n@@ -838,8 +838,7 @@ func scanInts(r *RecursiveInt, b *bytes.Buffer) (err os.Error) {\n \tif err != nil {\n \t\treturn\n \t}\n-\tvar c int\n-\tc, _, err = b.ReadRune()\n+\tc, _, err := b.ReadRune()\n \tif err != nil {\n \t\tif err == os.EOF {\n \t\t\terr = nil"}, {"sha": "f8caafc179a62ec7ece999d9f6737a1c91fd9ab0", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -752,6 +752,7 @@ type (\n \t\tName    *Ident        // local package name (including \".\"); or nil\n \t\tPath    *BasicLit     // import path\n \t\tComment *CommentGroup // line comments; or nil\n+\t\tEndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)\n \t}\n \n \t// A ValueSpec node represents a constant or variable declaration\n@@ -785,7 +786,13 @@ func (s *ImportSpec) Pos() token.Pos {\n func (s *ValueSpec) Pos() token.Pos { return s.Names[0].Pos() }\n func (s *TypeSpec) Pos() token.Pos  { return s.Name.Pos() }\n \n-func (s *ImportSpec) End() token.Pos { return s.Path.End() }\n+func (s *ImportSpec) End() token.Pos {\n+\tif s.EndPos != 0 {\n+\t\treturn s.EndPos\n+\t}\n+\treturn s.Path.End()\n+}\n+\n func (s *ValueSpec) End() token.Pos {\n \tif n := len(s.Values); n > 0 {\n \t\treturn s.Values[n-1].End()"}, {"sha": "e36f99fdf020957f21303115faeabf3fe2073b1a", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -149,7 +149,7 @@ func (p *printer) print(x reflect.Value) {\n \t\tp.print(x.Elem())\n \n \tcase reflect.Map:\n-\t\tp.printf(\"%s (len = %d) {\\n\", x.Type().String(), x.Len())\n+\t\tp.printf(\"%s (len = %d) {\\n\", x.Type(), x.Len())\n \t\tp.indent++\n \t\tfor _, key := range x.MapKeys() {\n \t\t\tp.print(key)\n@@ -178,7 +178,7 @@ func (p *printer) print(x reflect.Value) {\n \t\t\tp.printf(\"%#q\", s)\n \t\t\treturn\n \t\t}\n-\t\tp.printf(\"%s (len = %d) {\\n\", x.Type().String(), x.Len())\n+\t\tp.printf(\"%s (len = %d) {\\n\", x.Type(), x.Len())\n \t\tp.indent++\n \t\tfor i, n := 0, x.Len(); i < n; i++ {\n \t\t\tp.printf(\"%d: \", i)\n@@ -189,7 +189,7 @@ func (p *printer) print(x reflect.Value) {\n \t\tp.printf(\"}\")\n \n \tcase reflect.Struct:\n-\t\tp.printf(\"%s {\\n\", x.Type().String())\n+\t\tp.printf(\"%s {\\n\", x.Type())\n \t\tp.indent++\n \t\tt := x.Type()\n \t\tfor i, n := 0, t.NumField(); i < n; i++ {"}, {"sha": "398e31ce26f7864f20a6c379b3663da80d522821", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -28,7 +28,7 @@ var buildPkgs = []struct {\n \t\t\tGoFiles:      []string{\"pkgtest.go\"},\n \t\t\tSFiles:       []string{\"sqrt_\" + runtime.GOARCH + \".s\"},\n \t\t\tPackage:      \"pkgtest\",\n-\t\t\tImports:      []string{\"os\"},\n+\t\t\tImports:      []string{\"bytes\"},\n \t\t\tTestImports:  []string{\"fmt\", \"pkgtest\"},\n \t\t\tTestGoFiles:  sortstr([]string{\"sqrt_test.go\", \"sqrt_\" + runtime.GOARCH + \"_test.go\"}),\n \t\t\tXTestGoFiles: []string{\"xsqrt_test.go\"},"}, {"sha": "b67f999b7662cf7370c2cac219e08e55aaa3ced0", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -461,10 +461,10 @@ func safeName(s string) bool {\n //\n func splitQuoted(s string) (r []string, err os.Error) {\n \tvar args []string\n-\targ := make([]int, len(s))\n+\targ := make([]rune, len(s))\n \tescaped := false\n \tquoted := false\n-\tquote := 0\n+\tquote := rune(0)\n \ti := 0\n \tfor _, rune := range s {\n \t\tswitch {"}, {"sha": "08eea1e2bc37899fc1b78bcc78c777a28386669f", "filename": "libgo/go/go/build/pkgtest/pkgtest.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpkgtest%2Fpkgtest.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -4,9 +4,9 @@\n \n package pkgtest\n \n-import \"os\"\n+import \"bytes\"\n \n-func Foo() os.Error {\n+func Foo() *bytes.Buffer {\n \treturn nil\n }\n "}, {"sha": "9174864339117c7f7c46823ea09bec51da4a09bf", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -175,8 +175,6 @@ func setFunc(table map[string]*ast.FuncDecl, f *ast.FuncDecl) {\n }\n \n func (doc *docReader) addFunc(fun *ast.FuncDecl) {\n-\tname := fun.Name.Name\n-\n \t// determine if it should be associated with a type\n \tif fun.Recv != nil {\n \t\t// method\n@@ -205,19 +203,6 @@ func (doc *docReader) addFunc(fun *ast.FuncDecl) {\n \t\t\ttyp := doc.lookupTypeDoc(tname)\n \t\t\tif typ != nil {\n \t\t\t\t// named and exported result type\n-\n-\t\t\t\t// Work-around for failure of heuristic: In package os\n-\t\t\t\t// too many functions are considered factory functions\n-\t\t\t\t// for the Error type. Eliminate manually for now as\n-\t\t\t\t// this appears to be the only important case in the\n-\t\t\t\t// current library where the heuristic fails.\n-\t\t\t\tif doc.pkgName == \"os\" && tname == \"Error\" &&\n-\t\t\t\t\tname != \"NewError\" && name != \"NewSyscallError\" {\n-\t\t\t\t\t// not a factory function for os.Error\n-\t\t\t\t\tsetFunc(doc.funcs, fun) // treat as ordinary function\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\n \t\t\t\tsetFunc(typ.factories, fun)\n \t\t\t\treturn\n \t\t\t}"}, {"sha": "e2c944137217893adac3fe64d5b14f7d639c7e88", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -434,7 +434,9 @@ func (p *parser) parseLhsList() []ast.Expr {\n \tswitch p.tok {\n \tcase token.DEFINE:\n \t\t// lhs of a short variable declaration\n-\t\tp.shortVarDecl(p.makeIdentList(list))\n+\t\t// but doesn't enter scope until later:\n+\t\t// caller must call p.shortVarDecl(p.makeIdentList(list))\n+\t\t// at appropriate time.\n \tcase token.COLON:\n \t\t// lhs of a label declaration or a communication clause of a select\n \t\t// statement (parseLhsList is not called when parsing the case clause\n@@ -1398,6 +1400,9 @@ func (p *parser) parseSimpleStmt(mode int) (ast.Stmt, bool) {\n \t\t} else {\n \t\t\ty = p.parseRhsList()\n \t\t}\n+\t\tif tok == token.DEFINE {\n+\t\t\tp.shortVarDecl(p.makeIdentList(x))\n+\t\t}\n \t\treturn &ast.AssignStmt{x, pos, tok, y}, isRange\n \t}\n \n@@ -1722,6 +1727,9 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t\t}\n \t\t\t\tp.next()\n \t\t\t\trhs = p.parseRhs()\n+\t\t\t\tif tok == token.DEFINE && lhs != nil {\n+\t\t\t\t\tp.shortVarDecl(p.makeIdentList(lhs))\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// rhs must be single receive operation\n \t\t\t\tif len(lhs) > 1 {\n@@ -1909,7 +1917,7 @@ func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tp.expectSemi() // call before accessing p.linecomment\n \n \t// collect imports\n-\tspec := &ast.ImportSpec{doc, ident, path, p.lineComment}\n+\tspec := &ast.ImportSpec{doc, ident, path, p.lineComment, token.NoPos}\n \tp.imports = append(p.imports, spec)\n \n \treturn spec"}, {"sha": "dee90fbcf4c4a37adfa99e15ed170357413ce8d7", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5,6 +5,7 @@\n package parser\n \n import (\n+\t\"go/ast\"\n \t\"go/token\"\n \t\"os\"\n \t\"testing\"\n@@ -134,3 +135,46 @@ func TestParse4(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestColonEqualsScope(t *testing.T) {\n+\tf, err := ParseFile(fset, \"\", `package p; func f() { x, y, z := x, y, z }`, 0)\n+\tif err != nil {\n+\t\tt.Errorf(\"parse: %s\", err)\n+\t}\n+\n+\t// RHS refers to undefined globals; LHS does not.\n+\tas := f.Decls[0].(*ast.FuncDecl).Body.List[0].(*ast.AssignStmt)\n+\tfor _, v := range as.Rhs {\n+\t\tid := v.(*ast.Ident)\n+\t\tif id.Obj != nil {\n+\t\t\tt.Errorf(\"rhs %s has Obj, should not\", id.Name)\n+\t\t}\n+\t}\n+\tfor _, v := range as.Lhs {\n+\t\tid := v.(*ast.Ident)\n+\t\tif id.Obj == nil {\n+\t\t\tt.Errorf(\"lhs %s does not have Obj, should\", id.Name)\n+\t\t}\n+\t}\n+}\n+\n+func TestVarScope(t *testing.T) {\n+\tf, err := ParseFile(fset, \"\", `package p; func f() { var x, y, z = x, y, z }`, 0)\n+\tif err != nil {\n+\t\tt.Errorf(\"parse: %s\", err)\n+\t}\n+\n+\t// RHS refers to undefined globals; LHS does not.\n+\tas := f.Decls[0].(*ast.FuncDecl).Body.List[0].(*ast.DeclStmt).Decl.(*ast.GenDecl).Specs[0].(*ast.ValueSpec)\n+\tfor _, v := range as.Values {\n+\t\tid := v.(*ast.Ident)\n+\t\tif id.Obj != nil {\n+\t\t\tt.Errorf(\"rhs %s has Obj, should not\", id.Name)\n+\t\t}\n+\t}\n+\tfor _, id := range as.Names {\n+\t\tif id.Obj == nil {\n+\t\t\tt.Errorf(\"lhs %s does not have Obj, should\", id.Name)\n+\t\t}\n+\t}\n+}"}, {"sha": "248e43d4e72993e93c4f1db9ac5321d395d242ce", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -1278,6 +1278,7 @@ func (p *printer) spec(spec ast.Spec, n int, doIndent bool, multiLine *bool) {\n \t\t}\n \t\tp.expr(s.Path, multiLine)\n \t\tp.setComment(s.Comment)\n+\t\tp.print(s.EndPos)\n \n \tcase *ast.ValueSpec:\n \t\tif n != 1 {"}, {"sha": "df2a46bc22687f79a3f9aa835d8069ad9ead546d", "filename": "libgo/go/go/scanner/errors.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Ferrors.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -92,7 +92,7 @@ func (p ErrorList) String() string {\n \tcase 1:\n \t\treturn p[0].String()\n \t}\n-\treturn fmt.Sprintf(\"%s (and %d more errors)\", p[0].String(), len(p)-1)\n+\treturn fmt.Sprintf(\"%s (and %d more errors)\", p[0], len(p)-1)\n }\n \n // These constants control the construction of the ErrorList"}, {"sha": "dfbdaa3a125dce4b9aa32a4d7ab3c27eca7c6423", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -43,7 +43,7 @@ type Scanner struct {\n \tmode uint         // scanning mode\n \n \t// scanning state\n-\tch         int  // current character\n+\tch         rune // current character\n \toffset     int  // character offset\n \trdOffset   int  // reading offset (position after current character)\n \tlineOffset int  // current line offset\n@@ -63,7 +63,7 @@ func (S *Scanner) next() {\n \t\t\tS.lineOffset = S.offset\n \t\t\tS.file.AddLine(S.offset)\n \t\t}\n-\t\tr, w := int(S.src[S.rdOffset]), 1\n+\t\tr, w := rune(S.src[S.rdOffset]), 1\n \t\tswitch {\n \t\tcase r == 0:\n \t\t\tS.error(S.offset, \"illegal character NUL\")\n@@ -232,11 +232,11 @@ func (S *Scanner) findLineEnd() bool {\n \treturn false\n }\n \n-func isLetter(ch int) bool {\n+func isLetter(ch rune) bool {\n \treturn 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)\n }\n \n-func isDigit(ch int) bool {\n+func isDigit(ch rune) bool {\n \treturn '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)\n }\n \n@@ -248,14 +248,14 @@ func (S *Scanner) scanIdentifier() token.Token {\n \treturn token.Lookup(S.src[offs:S.offset])\n }\n \n-func digitVal(ch int) int {\n+func digitVal(ch rune) int {\n \tswitch {\n \tcase '0' <= ch && ch <= '9':\n-\t\treturn ch - '0'\n+\t\treturn int(ch - '0')\n \tcase 'a' <= ch && ch <= 'f':\n-\t\treturn ch - 'a' + 10\n+\t\treturn int(ch - 'a' + 10)\n \tcase 'A' <= ch && ch <= 'F':\n-\t\treturn ch - 'A' + 10\n+\t\treturn int(ch - 'A' + 10)\n \t}\n \treturn 16 // larger than any legal digit val\n }\n@@ -337,7 +337,7 @@ exit:\n \treturn tok\n }\n \n-func (S *Scanner) scanEscape(quote int) {\n+func (S *Scanner) scanEscape(quote rune) {\n \toffs := S.offset\n \n \tvar i, base, max uint32\n@@ -462,7 +462,7 @@ func (S *Scanner) switch2(tok0, tok1 token.Token) token.Token {\n \treturn tok0\n }\n \n-func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 int, tok2 token.Token) token.Token {\n+func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 rune, tok2 token.Token) token.Token {\n \tif S.ch == '=' {\n \t\tS.next()\n \t\treturn tok1\n@@ -474,7 +474,7 @@ func (S *Scanner) switch3(tok0, tok1 token.Token, ch2 int, tok2 token.Token) tok\n \treturn tok0\n }\n \n-func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 int, tok2, tok3 token.Token) token.Token {\n+func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Token) token.Token {\n \tif S.ch == '=' {\n \t\tS.next()\n \t\treturn tok1"}, {"sha": "7ed927a49fa976e605ee600d8877397186f4881b", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -237,7 +237,7 @@ func TestScan(t *testing.T) {\n \t\t}\n \t\tcheckPos(t, lit, pos, epos)\n \t\tif tok != e.tok {\n-\t\t\tt.Errorf(\"bad token for %q: got %s, expected %s\", lit, tok.String(), e.tok.String())\n+\t\t\tt.Errorf(\"bad token for %q: got %s, expected %s\", lit, tok, e.tok)\n \t\t}\n \t\tif e.tok.IsLiteral() && lit != e.lit {\n \t\t\tt.Errorf(\"bad literal for %q: got %q, expected %q\", lit, lit, e.lit)\n@@ -286,7 +286,7 @@ func checkSemi(t *testing.T, line string, mode uint) {\n \t\t\t\t}\n \t\t\t\tcheckPos(t, line, pos, semiPos)\n \t\t\t} else {\n-\t\t\t\tt.Errorf(\"bad token for %q: got %s, expected ;\", line, tok.String())\n+\t\t\t\tt.Errorf(\"bad token for %q: got %s, expected ;\", line, tok)\n \t\t\t}\n \t\t} else if tok == token.SEMICOLON {\n \t\t\tt.Errorf(\"bad token for %q: got ;, expected no ;\", line)\n@@ -509,7 +509,7 @@ func TestInit(t *testing.T) {\n \ts.Scan()              // true\n \t_, tok, _ := s.Scan() // {\n \tif tok != token.LBRACE {\n-\t\tt.Errorf(\"bad token: got %s, expected %s\", tok.String(), token.LBRACE)\n+\t\tt.Errorf(\"bad token: got %s, expected %s\", tok, token.LBRACE)\n \t}\n \n \t// 2nd init\n@@ -521,7 +521,7 @@ func TestInit(t *testing.T) {\n \t}\n \t_, tok, _ = s.Scan() // go\n \tif tok != token.GO {\n-\t\tt.Errorf(\"bad token: got %s, expected %s\", tok.String(), token.GO)\n+\t\tt.Errorf(\"bad token: got %s, expected %s\", tok, token.GO)\n \t}\n \n \tif s.ErrorCount != 0 {"}, {"sha": "5306354bf2a1c91b6d405161aa2250b1c5883e43", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -41,7 +41,7 @@ var encodeT = []EncodeT{\n // plain test.Error call.\n func testError(t *testing.T) {\n \tif e := recover(); e != nil {\n-\t\tt.Error(e.(gobError).Error) // Will re-panic if not one of our errors, such as a runtime error.\n+\t\tt.Error(e.(gobError).err) // Will re-panic if not one of our errors, such as a runtime error.\n \t}\n \treturn\n }"}, {"sha": "d027d3f1a4bdcbd12a50674cab90dd31bd5d8f2b", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -881,7 +881,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t}\n \t}\n \tif op == nil {\n-\t\terrorf(\"decode can't handle type %s\", rt.String())\n+\t\terrorf(\"decode can't handle type %s\", rt)\n \t}\n \treturn &op, indir\n }\n@@ -1110,7 +1110,7 @@ func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEn\n \t\twireStruct = wire.StructT\n \t}\n \tif wireStruct == nil {\n-\t\terrorf(\"type mismatch in decoder: want struct type %s; got non-struct\", rt.String())\n+\t\terrorf(\"type mismatch in decoder: want struct type %s; got non-struct\", rt)\n \t}\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, len(wireStruct.Field))"}, {"sha": "1d526e35c0f918baad25a6df52758cc548b63ffe", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -64,7 +64,7 @@ func (dec *Decoder) recvType(id typeId) {\n \tdec.wireType[id] = wire\n }\n \n-var errBadCount = gobError{os.NewError(\"invalid message length\")}\n+var errBadCount = os.NewError(\"invalid message length\")\n \n // recvMessage reads the next count-delimited item from the input. It is the converse\n // of Encoder.writeMessage. It returns false on EOF or other error reading the message."}, {"sha": "c16443553cee640afdcf8bc0cc925c157d5dbd2c", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -610,7 +610,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t}\n \t}\n \tif op == nil {\n-\t\terrorf(\"can't happen: encode type %s\", rt.String())\n+\t\terrorf(\"can't happen: encode type %s\", rt)\n \t}\n \treturn &op, indir\n }"}, {"sha": "98c0c97757879daec5ce07473a3ca755f08f8c64", "filename": "libgo/go/gob/encoder_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -606,14 +606,14 @@ func TestSliceReusesMemory(t *testing.T) {\n \t}\n \t// general slice\n \t{\n-\t\tx := []int(\"abcd\")\n+\t\tx := []rune(\"abcd\")\n \t\tenc := NewEncoder(buf)\n \t\terr := enc.Encode(x)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"ints: encode: %s\", err)\n \t\t}\n \t\t// Decode into y, which is big enough.\n-\t\ty := []int(\"ABCDE\")\n+\t\ty := []rune(\"ABCDE\")\n \t\taddr := &y[0]\n \t\tdec := NewDecoder(buf)\n \t\terr = dec.Decode(&y)"}, {"sha": "106543d736031a4a5bf5c6846dde4834bdfca198", "filename": "libgo/go/gob/error.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fgob%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ferror.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -18,7 +18,7 @@ import (\n \n // A gobError wraps an os.Error and is used to distinguish errors (panics) generated in this package.\n type gobError struct {\n-\tos.Error\n+\terr os.Error\n }\n \n // errorf is like error but takes Printf-style arguments to construct an os.Error.\n@@ -29,14 +29,14 @@ func errorf(format string, args ...interface{}) {\n \n // error wraps the argument error and uses it as the argument to panic.\n func error(err os.Error) {\n-\tpanic(gobError{Error: err})\n+\tpanic(gobError{err})\n }\n \n // catchError is meant to be used as a deferred function to turn a panic(gobError) into a\n // plain os.Error.  It overwrites the error return of the function that deferred its call.\n func catchError(err *os.Error) {\n \tif e := recover(); e != nil {\n-\t\t*err = e.(gobError).Error // Will re-panic if not one of our errors, such as a runtime error.\n+\t\t*err = e.(gobError).err // Will re-panic if not one of our errors, such as a runtime error.\n \t}\n \treturn\n }"}, {"sha": "bd83075235999368865ad74c31314ef16c1ed6d7", "filename": "libgo/go/html/entity.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fentity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fentity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fentity.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -13,7 +13,7 @@ const longestEntityWithoutSemicolon = 6\n //\n // Note that the HTML5 list is larger than the HTML4 list at\n // http://www.w3.org/TR/html4/sgml/entities.html\n-var entity = map[string]int{\n+var entity = map[string]rune{\n \t\"AElig;\":                           '\\U000000C6',\n \t\"AMP;\":                             '\\U00000026',\n \t\"Aacute;\":                          '\\U000000C1',\n@@ -2155,7 +2155,7 @@ var entity = map[string]int{\n }\n \n // HTML entities that are two unicode codepoints.\n-var entity2 = map[string][2]int{\n+var entity2 = map[string][2]rune{\n \t// TODO(nigeltao): Handle replacements that are wider than their names.\n \t// \"nLt;\":                     {'\\u226A', '\\u20D2'},\n \t// \"nGt;\":                     {'\\u226B', '\\u20D2'},"}, {"sha": "69e0028e445bdd40c66917ea7841963133806356", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -14,7 +14,7 @@ import (\n // These replacements permit compatibility with old numeric entities that \n // assumed Windows-1252 encoding.\n // http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference\n-var replacementTable = [...]int{\n+var replacementTable = [...]rune{\n \t'\\u20AC', // First entry is what 0x80 should be replaced with.\n \t'\\u0081',\n \t'\\u201A',\n@@ -79,23 +79,23 @@ func unescapeEntity(b []byte, dst, src int, attribute bool) (dst1, src1 int) {\n \t\t\ti++\n \t\t}\n \n-\t\tx := 0\n+\t\tx := rune(0)\n \t\tfor i < len(s) {\n \t\t\tc = s[i]\n \t\t\ti++\n \t\t\tif hex {\n \t\t\t\tif '0' <= c && c <= '9' {\n-\t\t\t\t\tx = 16*x + int(c) - '0'\n+\t\t\t\t\tx = 16*x + rune(c) - '0'\n \t\t\t\t\tcontinue\n \t\t\t\t} else if 'a' <= c && c <= 'f' {\n-\t\t\t\t\tx = 16*x + int(c) - 'a' + 10\n+\t\t\t\t\tx = 16*x + rune(c) - 'a' + 10\n \t\t\t\t\tcontinue\n \t\t\t\t} else if 'A' <= c && c <= 'F' {\n-\t\t\t\t\tx = 16*x + int(c) - 'A' + 10\n+\t\t\t\t\tx = 16*x + rune(c) - 'A' + 10\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t} else if '0' <= c && c <= '9' {\n-\t\t\t\tx = 10*x + int(c) - '0'\n+\t\t\t\tx = 10*x + rune(c) - '0'\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif c != ';' {"}, {"sha": "5ca6035c118aac8051a8baf8dd34926d39106d6d", "filename": "libgo/go/html/node.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fnode.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -135,6 +135,8 @@ func (s *nodeStack) remove(n *Node) {\n \t*s = (*s)[:j]\n }\n \n+// TODO(nigeltao): forTag no longer used. Should it be deleted?\n+\n // forTag returns the top-most element node with the given tag.\n func (s *nodeStack) forTag(tag string) *Node {\n \tfor i := len(*s) - 1; i >= 0; i-- {"}, {"sha": "54f7e2e8a55debaae9df9046aa2436c6271b46c0", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -7,6 +7,7 @@ package html\n import (\n \t\"io\"\n \t\"os\"\n+\t\"strings\"\n )\n \n // A parser implements the HTML5 parsing algorithm:\n@@ -125,6 +126,7 @@ func (p *parser) addChild(n *Node) {\n // fosterParent adds a child node according to the foster parenting rules.\n // Section 11.2.5.3, \"foster parenting\".\n func (p *parser) fosterParent(n *Node) {\n+\tp.fosterParenting = false\n \tvar table, parent *Node\n \tvar i int\n \tfor i = len(p.oe) - 1; i >= 0; i-- {\n@@ -430,20 +432,33 @@ func beforeHeadIM(p *parser) (insertionMode, bool) {\n \treturn inHeadIM, !implied\n }\n \n+const whitespace = \" \\t\\r\\n\\f\"\n+\n // Section 11.2.5.4.4.\n func inHeadIM(p *parser) (insertionMode, bool) {\n \tvar (\n \t\tpop     bool\n \t\timplied bool\n \t)\n \tswitch p.tok.Type {\n-\tcase ErrorToken, TextToken:\n+\tcase ErrorToken:\n+\t\timplied = true\n+\tcase TextToken:\n+\t\ts := strings.TrimLeft(p.tok.Data, whitespace)\n+\t\tif len(s) < len(p.tok.Data) {\n+\t\t\t// Add the initial whitespace to the current node.\n+\t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n+\t\t\tif s == \"\" {\n+\t\t\t\treturn inHeadIM, true\n+\t\t\t}\n+\t\t\tp.tok.Data = s\n+\t\t}\n \t\timplied = true\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"meta\":\n \t\t\t// TODO.\n-\t\tcase \"script\", \"title\":\n+\t\tcase \"script\", \"title\", \"noscript\", \"noframes\", \"style\":\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.setOriginalIM(inHeadIM)\n \t\t\treturn textIM, true\n@@ -469,7 +484,7 @@ func inHeadIM(p *parser) (insertionMode, bool) {\n \t\t}\n \t\treturn afterHeadIM, !implied\n \t}\n-\treturn inHeadIM, !implied\n+\treturn inHeadIM, true\n }\n \n // Section 11.2.5.4.6.\n@@ -538,10 +553,13 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\t}\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"a\":\n-\t\t\tif n := p.afe.forTag(\"a\"); n != nil {\n-\t\t\t\tp.inBodyEndTagFormatting(\"a\")\n-\t\t\t\tp.oe.remove(n)\n-\t\t\t\tp.afe.remove(n)\n+\t\t\tfor i := len(p.afe) - 1; i >= 0 && p.afe[i].Type != scopeMarkerNode; i-- {\n+\t\t\t\tif n := p.afe[i]; n.Type == ElementNode && n.Data == \"a\" {\n+\t\t\t\t\tp.inBodyEndTagFormatting(\"a\")\n+\t\t\t\t\tp.oe.remove(n)\n+\t\t\t\t\tp.afe.remove(n)\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n@@ -594,6 +612,12 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\t}\n \t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n \t\t\tp.addElement(\"li\", p.tok.Attr)\n+\t\tcase \"optgroup\", \"option\":\n+\t\t\tif p.top().Data == \"option\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tdefault:\n \t\t\t// TODO.\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -655,6 +679,10 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t\tp.afe.remove(formattingElement)\n \t\t\treturn\n \t\t}\n+\t\tif !p.elementInScope(defaultScopeStopTags, tag) {\n+\t\t\t// Ignore the tag.\n+\t\t\treturn\n+\t\t}\n \n \t\t// Steps 5-6. Find the furthest block.\n \t\tvar furthestBlock *Node\n@@ -732,6 +760,10 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\tfurthestBlock.Add(clone)\n \n \t\t// Step 14. Fix up the list of active formatting elements.\n+\t\tif oldLoc := p.afe.index(formattingElement); oldLoc != -1 && oldLoc < bookmark {\n+\t\t\t// Move the bookmark with the rest of the list.\n+\t\t\tbookmark--\n+\t\t}\n \t\tp.afe.remove(formattingElement)\n \t\tp.afe.insert(bookmark, clone)\n \n@@ -757,6 +789,8 @@ func (p *parser) inBodyEndTagOther(tag string) {\n // Section 11.2.5.4.8.\n func textIM(p *parser) (insertionMode, bool) {\n \tswitch p.tok.Type {\n+\tcase ErrorToken:\n+\t\tp.oe.pop()\n \tcase TextToken:\n \t\tp.addText(p.tok.Data)\n \t\treturn textIM, true\n@@ -956,7 +990,12 @@ func inCellIM(p *parser) (insertionMode, bool) {\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"td\", \"th\":\n-\t\t\t// TODO.\n+\t\t\tif !p.popUntil(tableScopeStopTags, p.tok.Data) {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn inCellIM, true\n+\t\t\t}\n+\t\t\tp.clearActiveFormattingElements()\n+\t\t\treturn inRowIM, true\n \t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\":\n \t\t\t// TODO.\n \t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":"}, {"sha": "b9572fa12344607658ba2bbd8a74bea3e9b117a8", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -132,7 +132,7 @@ func TestParser(t *testing.T) {\n \t\trc := make(chan io.Reader)\n \t\tgo readDat(filename, rc)\n \t\t// TODO(nigeltao): Process all test cases, not just a subset.\n-\t\tfor i := 0; i < 34; i++ {\n+\t\tfor i := 0; i < 80; i++ {\n \t\t\t// Parse the #data section.\n \t\t\tb, err := ioutil.ReadAll(<-rc)\n \t\t\tif err != nil {\n@@ -160,14 +160,10 @@ func TestParser(t *testing.T) {\n \t\t\t\tt.Errorf(\"%s test #%d %q, got vs want:\\n----\\n%s----\\n%s----\", filename, i, text, got, want)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\t// Check that rendering and re-parsing results in an identical tree.\n-\t\t\tif filename == \"tests1.dat\" && i == 30 {\n-\t\t\t\t// Test 30 in tests1.dat is such messed-up markup that a correct parse\n-\t\t\t\t// results in a non-conforming tree (one <a> element nested inside another).\n-\t\t\t\t// Therefore when it is rendered and re-parsed, it isn't the same.\n-\t\t\t\t// So we skip rendering on that test.\n+\t\t\tif renderTestBlacklist[text] {\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\t// Check that rendering and re-parsing results in an identical tree.\n \t\t\tpr, pw := io.Pipe()\n \t\t\tgo func() {\n \t\t\t\tpw.CloseWithError(Render(pw, doc))\n@@ -187,3 +183,15 @@ func TestParser(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Some test input result in parse trees are not 'well-formed' despite\n+// following the HTML5 recovery algorithms. Rendering and re-parsing such a\n+// tree will not result in an exact clone of that tree. We blacklist such\n+// inputs from the render test.\n+var renderTestBlacklist = map[string]bool{\n+\t// The second <a> will be reparented to the first <table>'s parent. This\n+\t// results in an <a> whose parent is an <a>, which is not 'well-formed'.\n+\t`<a><table><td><a><table></table><a></tr><a></table><b>X</b>C<a>Y`: true,\n+\t// The second <a> will be reparented, similar to the case above.\n+\t`<a href=\"blah\">aba<table><a href=\"foo\">br<tr><td></td></tr>x</table>aoe`: true,\n+}"}, {"sha": "0522b6ef92ae193c1452b7a975998b833aff5f3b", "filename": "libgo/go/html/render.go", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -19,17 +19,28 @@ type writer interface {\n \n // Render renders the parse tree n to the given writer.\n //\n-// For 'well-formed' parse trees, calling Parse on the output of Render will\n-// result in a clone of the original tree.\n+// Rendering is done on a 'best effort' basis: calling Parse on the output of\n+// Render will always result in something similar to the original tree, but it\n+// is not necessarily an exact clone unless the original tree was 'well-formed'.\n+// 'Well-formed' is not easily specified; the HTML5 specification is\n+// complicated.\n //\n-// 'Well-formed' is not formally specified, but calling Parse on arbitrary\n-// input results in a 'well-formed' parse tree if Parse does not return an\n-// error. Programmatically constructed trees are typically also 'well-formed',\n-// but it is possible to construct a tree that, when rendered and re-parsed,\n-// results in a different tree. A simple example is that a solitary text node\n-// would become a tree containing <html>, <head> and <body> elements. Another\n-// example is that the programmatic equivalent of \"a<head>b</head>c\" becomes\n-// \"<html><head><head/><body>abc</body></html>\".\n+// Calling Parse on arbitrary input typically results in a 'well-formed' parse\n+// tree. However, it is possible for Parse to yield a 'badly-formed' parse tree.\n+// For example, in a 'well-formed' parse tree, no <a> element is a child of\n+// another <a> element: parsing \"<a><a>\" results in two sibling elements.\n+// Similarly, in a 'well-formed' parse tree, no <a> element is a child of a\n+// <table> element: parsing \"<p><table><a>\" results in a <p> with two sibling\n+// children; the <a> is reparented to the <table>'s parent. However, calling\n+// Parse on \"<a><table><a>\" does not return an error, but the result has an <a>\n+// element with an <a> child, and is therefore not 'well-formed'.\n+// \n+// Programmatically constructed trees are typically also 'well-formed', but it\n+// is possible to construct a tree that looks innocuous but, when rendered and\n+// re-parsed, results in a different tree. A simple example is that a solitary\n+// text node would become a tree containing <html>, <head> and <body> elements.\n+// Another example is that the programmatic equivalent of \"a<head>b</head>c\"\n+// becomes \"<html><head><head/><body>abc</body></html>\".\n func Render(w io.Writer, n *Node) os.Error {\n \tif x, ok := w.(writer); ok {\n \t\treturn render(x, n)"}, {"sha": "a5efdf2d498c9049ff642ca3b78b485ba6084bbb", "filename": "libgo/go/html/token_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhtml%2Ftoken_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -439,7 +439,7 @@ loop:\n \t\t}\n \t\tz.Next()\n \t\tif z.Error() != os.EOF {\n-\t\t\tt.Errorf(\"%s: want EOF got %q\", tt.desc, z.Token().String())\n+\t\t\tt.Errorf(\"%s: want EOF got %q\", tt.desc, z.Error())\n \t\t}\n \t}\n }"}, {"sha": "365a712dfa85b2bb57512b4a80a6940da5d92405", "filename": "libgo/go/http/cgi/host.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -333,18 +333,18 @@ func (h *Handler) handleInternalRedirect(rw http.ResponseWriter, req *http.Reque\n \th.PathLocationHandler.ServeHTTP(rw, newReq)\n }\n \n-func upperCaseAndUnderscore(rune int) int {\n+func upperCaseAndUnderscore(r rune) rune {\n \tswitch {\n-\tcase rune >= 'a' && rune <= 'z':\n-\t\treturn rune - ('a' - 'A')\n-\tcase rune == '-':\n+\tcase r >= 'a' && r <= 'z':\n+\t\treturn r - ('a' - 'A')\n+\tcase r == '-':\n \t\treturn '_'\n-\tcase rune == '=':\n+\tcase r == '=':\n \t\t// Maybe not part of the CGI 'spec' but would mess up\n \t\t// the environment in any case, as Go represents the\n \t\t// environment as a slice of \"key=value\" strings.\n \t\treturn '_'\n \t}\n \t// TODO: other transformations in spec or practice?\n-\treturn rune\n+\treturn r\n }"}, {"sha": "3a63db009fc2c1eb7fe8bcaee5ce2e6129670f3c", "filename": "libgo/go/http/reverseproxy.go", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhttp%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhttp%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freverseproxy.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -69,6 +69,14 @@ func NewSingleHostReverseProxy(target *url.URL) *ReverseProxy {\n \treturn &ReverseProxy{Director: director}\n }\n \n+func copyHeader(dst, src Header) {\n+\tfor k, vv := range src {\n+\t\tfor _, v := range vv {\n+\t\t\tdst.Add(k, v)\n+\t\t}\n+\t}\n+}\n+\n func (p *ReverseProxy) ServeHTTP(rw ResponseWriter, req *Request) {\n \ttransport := p.Transport\n \tif transport == nil {\n@@ -84,6 +92,16 @@ func (p *ReverseProxy) ServeHTTP(rw ResponseWriter, req *Request) {\n \toutreq.ProtoMinor = 1\n \toutreq.Close = false\n \n+\t// Remove the connection header to the backend.  We want a\n+\t// persistent connection, regardless of what the client sent\n+\t// to us.  This is modifying the same underlying map from req\n+\t// (shallow copied above) so we only copy it if necessary.\n+\tif outreq.Header.Get(\"Connection\") != \"\" {\n+\t\toutreq.Header = make(Header)\n+\t\tcopyHeader(outreq.Header, req.Header)\n+\t\toutreq.Header.Del(\"Connection\")\n+\t}\n+\n \tif clientIp, _, err := net.SplitHostPort(req.RemoteAddr); err == nil {\n \t\toutreq.Header.Set(\"X-Forwarded-For\", clientIp)\n \t}\n@@ -95,12 +113,7 @@ func (p *ReverseProxy) ServeHTTP(rw ResponseWriter, req *Request) {\n \t\treturn\n \t}\n \n-\thdr := rw.Header()\n-\tfor k, vv := range res.Header {\n-\t\tfor _, v := range vv {\n-\t\t\thdr.Add(k, v)\n-\t\t}\n-\t}\n+\tcopyHeader(rw.Header(), res.Header)\n \n \trw.WriteHeader(res.StatusCode)\n "}, {"sha": "663218d61b9950d10d95310176ce970ca656e7fe", "filename": "libgo/go/http/reverseproxy_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhttp%2Freverseproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fhttp%2Freverseproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freverseproxy_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -24,6 +24,9 @@ func TestReverseProxy(t *testing.T) {\n \t\tif r.Header.Get(\"X-Forwarded-For\") == \"\" {\n \t\t\tt.Errorf(\"didn't get X-Forwarded-For header\")\n \t\t}\n+\t\tif c := r.Header.Get(\"Connection\"); c != \"\" {\n+\t\t\tt.Errorf(\"handler got Connection header value %q\", c)\n+\t\t}\n \t\tif g, e := r.Host, \"some-name\"; g != e {\n \t\t\tt.Errorf(\"backend got Host header %q, want %q\", g, e)\n \t\t}\n@@ -43,6 +46,8 @@ func TestReverseProxy(t *testing.T) {\n \n \tgetReq, _ := NewRequest(\"GET\", frontend.URL, nil)\n \tgetReq.Host = \"some-name\"\n+\tgetReq.Header.Set(\"Connection\", \"close\")\n+\tgetReq.Close = true\n \tres, err := DefaultClient.Do(getReq)\n \tif err != nil {\n \t\tt.Fatalf(\"Get: %v\", err)"}, {"sha": "07e2bce76a617249afc84315c489198a64d9e121", "filename": "libgo/go/io/io.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fio%2Fio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fio%2Fio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fio.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -194,7 +194,7 @@ type ByteScanner interface {\n // and returns the rune and its size in bytes. If no character is\n // available, err will be set.\n type RuneReader interface {\n-\tReadRune() (rune int, size int, err os.Error)\n+\tReadRune() (r rune, size int, err os.Error)\n }\n \n // RuneScanner is the interface that adds the UnreadRune method to the"}, {"sha": "800df985abc9212c78ab44b617b697a4f7883d30", "filename": "libgo/go/json/decode.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -588,7 +588,7 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value) {\n \t\tswitch v.Kind() {\n \t\tdefault:\n \t\t\td.saveError(&UnmarshalTypeError{\"null\", v.Type()})\n-\t\tcase reflect.Interface, reflect.Ptr, reflect.Map:\n+\t\tcase reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:\n \t\t\tv.Set(reflect.Zero(v.Type()))\n \t\t}\n \n@@ -805,15 +805,15 @@ func (d *decodeState) literalInterface() interface{} {\n \n // getu4 decodes \\uXXXX from the beginning of s, returning the hex value,\n // or it returns -1.\n-func getu4(s []byte) int {\n+func getu4(s []byte) rune {\n \tif len(s) < 6 || s[0] != '\\\\' || s[1] != 'u' {\n \t\treturn -1\n \t}\n-\trune, err := strconv.Btoui64(string(s[2:6]), 16)\n+\tr, err := strconv.Btoui64(string(s[2:6]), 16)\n \tif err != nil {\n \t\treturn -1\n \t}\n-\treturn int(rune)\n+\treturn rune(r)\n }\n \n // unquote converts a quoted JSON string literal s into an actual string t.\n@@ -843,8 +843,8 @@ func unquoteBytes(s []byte) (t []byte, ok bool) {\n \t\t\tr++\n \t\t\tcontinue\n \t\t}\n-\t\trune, size := utf8.DecodeRune(s[r:])\n-\t\tif rune == utf8.RuneError && size == 1 {\n+\t\trr, size := utf8.DecodeRune(s[r:])\n+\t\tif rr == utf8.RuneError && size == 1 {\n \t\t\tbreak\n \t\t}\n \t\tr += size\n@@ -899,23 +899,23 @@ func unquoteBytes(s []byte) (t []byte, ok bool) {\n \t\t\t\tw++\n \t\t\tcase 'u':\n \t\t\t\tr--\n-\t\t\t\trune := getu4(s[r:])\n-\t\t\t\tif rune < 0 {\n+\t\t\t\trr := getu4(s[r:])\n+\t\t\t\tif rr < 0 {\n \t\t\t\t\treturn\n \t\t\t\t}\n \t\t\t\tr += 6\n-\t\t\t\tif utf16.IsSurrogate(rune) {\n-\t\t\t\t\trune1 := getu4(s[r:])\n-\t\t\t\t\tif dec := utf16.DecodeRune(rune, rune1); dec != unicode.ReplacementChar {\n+\t\t\t\tif utf16.IsSurrogate(rr) {\n+\t\t\t\t\trr1 := getu4(s[r:])\n+\t\t\t\t\tif dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {\n \t\t\t\t\t\t// A valid pair; consume.\n \t\t\t\t\t\tr += 6\n \t\t\t\t\t\tw += utf8.EncodeRune(b[w:], dec)\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t\t// Invalid surrogate; fall back to replacement rune.\n-\t\t\t\t\trune = unicode.ReplacementChar\n+\t\t\t\t\trr = unicode.ReplacementChar\n \t\t\t\t}\n-\t\t\t\tw += utf8.EncodeRune(b[w:], rune)\n+\t\t\t\tw += utf8.EncodeRune(b[w:], rr)\n \t\t\t}\n \n \t\t// Quote, control characters are invalid.\n@@ -930,9 +930,9 @@ func unquoteBytes(s []byte) (t []byte, ok bool) {\n \n \t\t// Coerce to well-formed UTF-8.\n \t\tdefault:\n-\t\t\trune, size := utf8.DecodeRune(s[r:])\n+\t\t\trr, size := utf8.DecodeRune(s[r:])\n \t\t\tr += size\n-\t\t\tw += utf8.EncodeRune(b[w:], rune)\n+\t\t\tw += utf8.EncodeRune(b[w:], rr)\n \t\t}\n \t}\n \treturn b[0:w], true"}, {"sha": "d745e8dd26f864bbfcff9275e8dd39f626f16df9", "filename": "libgo/go/json/decode_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fdecode_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -243,7 +243,7 @@ func TestHTMLEscape(t *testing.T) {\n \t}\n }\n \n-func noSpace(c int) int {\n+func noSpace(c rune) rune {\n \tif isSpace(c) {\n \t\treturn -1\n \t}\n@@ -456,7 +456,7 @@ var allValueIndent = `{\n \t\"PSlice\": null,\n \t\"PSliceP\": null,\n \t\"EmptySlice\": [],\n-\t\"NilSlice\": [],\n+\t\"NilSlice\": null,\n \t\"StringSlice\": [\n \t\t\"str24\",\n \t\t\"str25\",\n@@ -528,8 +528,8 @@ var pallValueIndent = `{\n \t},\n \t\"EmptyMap\": null,\n \t\"NilMap\": null,\n-\t\"Slice\": [],\n-\t\"SliceP\": [],\n+\t\"Slice\": null,\n+\t\"SliceP\": null,\n \t\"PSlice\": [\n \t\t{\n \t\t\t\"Tag\": \"tag20\"\n@@ -547,10 +547,10 @@ var pallValueIndent = `{\n \t\t\t\"Tag\": \"tag23\"\n \t\t}\n \t],\n-\t\"EmptySlice\": [],\n-\t\"NilSlice\": [],\n-\t\"StringSlice\": [],\n-\t\"ByteSlice\": \"\",\n+\t\"EmptySlice\": null,\n+\t\"NilSlice\": null,\n+\t\"StringSlice\": null,\n+\t\"ByteSlice\": null,\n \t\"Small\": {\n \t\t\"Tag\": \"\"\n \t},"}, {"sha": "ba5c15cc4969e5279edb9fe35e2d83f2ef089da3", "filename": "libgo/go/json/encode.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -352,7 +352,15 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\t}\n \t\te.WriteByte('}')\n \n-\tcase reflect.Array, reflect.Slice:\n+\tcase reflect.Slice:\n+\t\tif v.IsNil() {\n+\t\t\te.WriteString(\"null\")\n+\t\t\tbreak\n+\t\t}\n+\t\t// Slices can be marshalled as nil, but otherwise are handled\n+\t\t// as arrays.\n+\t\tfallthrough\n+\tcase reflect.Array:\n \t\tif v.Type() == byteSliceType {\n \t\t\te.WriteByte('\"')\n \t\t\ts := v.Interface().([]byte)"}, {"sha": "92f266aba63819bf87dcb26be26b436f7e9515d0", "filename": "libgo/go/json/encode_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fencode_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -28,7 +28,7 @@ type Optionals struct {\n var optionalsExpected = `{\n  \"sr\": \"\",\n  \"omitempty\": 0,\n- \"slr\": [],\n+ \"slr\": null,\n  \"mr\": {}\n }`\n "}, {"sha": "1a39b4cb34d0cdca0d65716d5777c570fe30536d", "filename": "libgo/go/json/scanner.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -176,7 +176,7 @@ func (s *scanner) popParseState() {\n \t}\n }\n \n-func isSpace(c int) bool {\n+func isSpace(c rune) bool {\n \treturn c == ' ' || c == '\\t' || c == '\\r' || c == '\\n'\n }\n "}, {"sha": "40bf2951778ec91457f4c7232f1d37b4f3370d67", "filename": "libgo/go/json/scanner_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fscanner_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -261,13 +261,13 @@ func genValue(n int) interface{} {\n \n func genString(stddev float64) string {\n \tn := int(math.Abs(rand.NormFloat64()*stddev + stddev/2))\n-\tc := make([]int, n)\n+\tc := make([]rune, n)\n \tfor i := range c {\n \t\tf := math.Abs(rand.NormFloat64()*64 + 32)\n \t\tif f > 0x10ffff {\n \t\t\tf = 0x10ffff\n \t\t}\n-\t\tc[i] = int(f)\n+\t\tc[i] = rune(f)\n \t}\n \treturn string(c)\n }"}, {"sha": "98cb7935df11dd8e18ebf0710b56f114562eee8b", "filename": "libgo/go/json/stream.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fstream.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fjson%2Fstream.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fjson%2Fstream.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -115,7 +115,7 @@ Input:\n \n func nonSpace(b []byte) bool {\n \tfor _, c := range b {\n-\t\tif !isSpace(int(c)) {\n+\t\tif !isSpace(rune(c)) {\n \t\t\treturn true\n \t\t}\n \t}"}, {"sha": "29249fbde177c855ba7e64a2b2a92929ef1e2d07", "filename": "libgo/go/mail/message.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmail%2Fmessage.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmail%2Fmessage.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmail%2Fmessage.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -454,7 +454,7 @@ func decodeRFC2047Word(s string) (string, os.Error) {\n \tcase \"iso-8859-1\":\n \t\tb := new(bytes.Buffer)\n \t\tfor _, c := range dec {\n-\t\t\tb.WriteRune(int(c))\n+\t\t\tb.WriteRune(rune(c))\n \t\t}\n \t\treturn b.String(), nil\n \tcase \"utf-8\":"}, {"sha": "b540b179323d67851ddb02a455c32ac663376d79", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -1709,7 +1709,7 @@ func TestCopysign(t *testing.T) {\n \n func TestCos(t *testing.T) {\n \tfor i := 0; i < len(vf); i++ {\n-\t\tif f := Cos(vf[i]); !close(cos[i], f) {\n+\t\tif f := Cos(vf[i]); !veryclose(cos[i], f) {\n \t\t\tt.Errorf(\"Cos(%g) = %g, want %g\", vf[i], f, cos[i])\n \t\t}\n \t}\n@@ -2192,7 +2192,7 @@ func TestSignbit(t *testing.T) {\n }\n func TestSin(t *testing.T) {\n \tfor i := 0; i < len(vf); i++ {\n-\t\tif f := Sin(vf[i]); !close(sin[i], f) {\n+\t\tif f := Sin(vf[i]); !veryclose(sin[i], f) {\n \t\t\tt.Errorf(\"Sin(%g) = %g, want %g\", vf[i], f, sin[i])\n \t\t}\n \t}\n@@ -2205,7 +2205,7 @@ func TestSin(t *testing.T) {\n \n func TestSincos(t *testing.T) {\n \tfor i := 0; i < len(vf); i++ {\n-\t\tif s, c := Sincos(vf[i]); !close(sin[i], s) || !close(cos[i], c) {\n+\t\tif s, c := Sincos(vf[i]); !veryclose(sin[i], s) || !veryclose(cos[i], c) {\n \t\t\tt.Errorf(\"Sincos(%g) = %g, %g want %g, %g\", vf[i], s, c, sin[i], cos[i])\n \t\t}\n \t}"}, {"sha": "9e553a268bddcec52c3f77ced2832aa5183d22b8", "filename": "libgo/go/math/sin.go", "status": "modified", "additions": 198, "deletions": 40, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmath%2Fsin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmath%2Fsin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fsin.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -1,65 +1,223 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n+// Copyright 2011 The Go Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n package math\n \n /*\n \tFloating-point sine and cosine.\n-\n-\tCoefficients are #5077 from Hart & Cheney. (18.80D)\n */\n \n-func sinus(x float64, quad int) float64 {\n+// The original C code, the long comment, and the constants\n+// below were from http://netlib.sandia.gov/cephes/cmath/sin.c,\n+// available from http://www.netlib.org/cephes/cmath.tgz.\n+// The go code is a simplified version of the original C.\n+//\n+//      sin.c\n+//\n+//      Circular sine\n+//\n+// SYNOPSIS:\n+//\n+// double x, y, sin();\n+// y = sin( x );\n+//\n+// DESCRIPTION:\n+//\n+// Range reduction is into intervals of pi/4.  The reduction error is nearly\n+// eliminated by contriving an extended precision modular arithmetic.\n+//\n+// Two polynomial approximating functions are employed.\n+// Between 0 and pi/4 the sine is approximated by\n+//      x  +  x**3 P(x**2).\n+// Between pi/4 and pi/2 the cosine is represented as\n+//      1  -  x**2 Q(x**2).\n+//\n+// ACCURACY:\n+//\n+//                      Relative error:\n+// arithmetic   domain      # trials      peak         rms\n+//    DEC       0, 10       150000       3.0e-17     7.8e-18\n+//    IEEE -1.07e9,+1.07e9  130000       2.1e-16     5.4e-17\n+//\n+// Partial loss of accuracy begins to occur at x = 2**30 = 1.074e9.  The loss\n+// is not gradual, but jumps suddenly to about 1 part in 10e7.  Results may\n+// be meaningless for x > 2**49 = 5.6e14.\n+//\n+//      cos.c\n+//\n+//      Circular cosine\n+//\n+// SYNOPSIS:\n+//\n+// double x, y, cos();\n+// y = cos( x );\n+//\n+// DESCRIPTION:\n+//\n+// Range reduction is into intervals of pi/4.  The reduction error is nearly\n+// eliminated by contriving an extended precision modular arithmetic.\n+//\n+// Two polynomial approximating functions are employed.\n+// Between 0 and pi/4 the cosine is approximated by\n+//      1  -  x**2 Q(x**2).\n+// Between pi/4 and pi/2 the sine is represented as\n+//      x  +  x**3 P(x**2).\n+//\n+// ACCURACY:\n+//\n+//                      Relative error:\n+// arithmetic   domain      # trials      peak         rms\n+//    IEEE -1.07e9,+1.07e9  130000       2.1e-16     5.4e-17\n+//    DEC        0,+1.07e9   17000       3.0e-17     7.2e-18\n+//\n+// Cephes Math Library Release 2.8:  June, 2000\n+// Copyright 1984, 1987, 1989, 1992, 2000 by Stephen L. Moshier\n+//\n+// The readme file at http://netlib.sandia.gov/cephes/ says:\n+//    Some software in this archive may be from the book _Methods and\n+// Programs for Mathematical Functions_ (Prentice-Hall or Simon & Schuster\n+// International, 1989) or from the Cephes Mathematical Library, a\n+// commercial product. In either event, it is copyrighted by the author.\n+// What you see here may be used freely but it comes with no support or\n+// guarantee.\n+//\n+//   The two known misprints in the book are repaired here in the\n+// source listings for the gamma function and the incomplete beta\n+// integral.\n+//\n+//   Stephen L. Moshier\n+//   moshier@na-net.ornl.gov\n+\n+// sin coefficients\n+var _sin = [...]float64{\n+\t1.58962301576546568060E-10, // 0x3de5d8fd1fd19ccd\n+\t-2.50507477628578072866E-8, // 0xbe5ae5e5a9291f5d\n+\t2.75573136213857245213E-6,  // 0x3ec71de3567d48a1\n+\t-1.98412698295895385996E-4, // 0xbf2a01a019bfdf03\n+\t8.33333333332211858878E-3,  // 0x3f8111111110f7d0\n+\t-1.66666666666666307295E-1, // 0xbfc5555555555548\n+}\n+// cos coefficients\n+var _cos = [...]float64{\n+\t-1.13585365213876817300E-11, // 0xbda8fa49a0861a9b\n+\t2.08757008419747316778E-9,   // 0x3e21ee9d7b4e3f05\n+\t-2.75573141792967388112E-7,  // 0xbe927e4f7eac4bc6\n+\t2.48015872888517045348E-5,   // 0x3efa01a019c844f5\n+\t-1.38888888888730564116E-3,  // 0xbf56c16c16c14f91\n+\t4.16666666666665929218E-2,   // 0x3fa555555555554b\n+}\n+\n+// Cos returns the cosine of x.\n+//\n+// Special conditions are:\n+//\tCos(\u00b1Inf) = NaN\n+//\tCos(NaN) = NaN\n+func Cos(x float64) float64 {\n \tconst (\n-\t\tP0 = .1357884097877375669092680e8\n-\t\tP1 = -.4942908100902844161158627e7\n-\t\tP2 = .4401030535375266501944918e6\n-\t\tP3 = -.1384727249982452873054457e5\n-\t\tP4 = .1459688406665768722226959e3\n-\t\tQ0 = .8644558652922534429915149e7\n-\t\tQ1 = .4081792252343299749395779e6\n-\t\tQ2 = .9463096101538208180571257e4\n-\t\tQ3 = .1326534908786136358911494e3\n+\t\tPI4A = 7.85398125648498535156E-1                             // 0x3fe921fb40000000, Pi/4 split into three parts\n+\t\tPI4B = 3.77489470793079817668E-8                             // 0x3e64442d00000000,\n+\t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n+\t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n \t)\n+\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n+\t// when compiler does it for us\n+\t// special cases\n+\tswitch {\n+\tcase x != x || x < -MaxFloat64 || x > MaxFloat64: // IsNaN(x) || IsInf(x, 0):\n+\t\treturn NaN()\n+\t}\n+\n+\t// make argument positive\n+\tsign := false\n \tif x < 0 {\n \t\tx = -x\n-\t\tquad = quad + 2\n \t}\n-\tx = x * (2 / Pi) /* underflow? */\n-\tvar y float64\n-\tif x > 32764 {\n-\t\tvar e float64\n-\t\te, y = Modf(x)\n-\t\te = e + float64(quad)\n-\t\tf, _ := Modf(0.25 * e)\n-\t\tquad = int(e - 4*f)\n-\t} else {\n-\t\tk := int32(x)\n-\t\ty = x - float64(k)\n-\t\tquad = (quad + int(k)) & 3\n+\n+\tj := int64(x * M4PI) // integer part of x/(Pi/4), as integer for tests on the phase angle\n+\ty := float64(j)      // integer part of x/(Pi/4), as float\n+\n+\t// map zeros to origin\n+\tif j&1 == 1 {\n+\t\tj += 1\n+\t\ty += 1\n+\t}\n+\tj &= 7 // octant modulo 2Pi radians (360 degrees)\n+\tif j > 3 {\n+\t\tj -= 4\n+\t\tsign = !sign\n+\t}\n+\tif j > 1 {\n+\t\tsign = !sign\n \t}\n \n-\tif quad&1 != 0 {\n-\t\ty = 1 - y\n+\tz := ((x - y*PI4A) - y*PI4B) - y*PI4C // Extended precision modular arithmetic\n+\tzz := z * z\n+\tif j == 1 || j == 2 {\n+\t\ty = z + z*zz*((((((_sin[0]*zz)+_sin[1])*zz+_sin[2])*zz+_sin[3])*zz+_sin[4])*zz+_sin[5])\n+\t} else {\n+\t\ty = 1.0 - 0.5*zz + zz*zz*((((((_cos[0]*zz)+_cos[1])*zz+_cos[2])*zz+_cos[3])*zz+_cos[4])*zz+_cos[5])\n \t}\n-\tif quad > 1 {\n+\tif sign {\n \t\ty = -y\n \t}\n-\n-\tyy := y * y\n-\ttemp1 := ((((P4*yy+P3)*yy+P2)*yy+P1)*yy + P0) * y\n-\ttemp2 := ((((yy+Q3)*yy+Q2)*yy+Q1)*yy + Q0)\n-\treturn temp1 / temp2\n+\treturn y\n }\n \n-// Cos returns the cosine of x.\n-func Cos(x float64) float64 {\n+// Sin returns the sine of x.\n+//\n+// Special conditions are:\n+//\tSin(\u00b10) = \u00b10\n+//\tSin(\u00b1Inf) = NaN\n+//\tSin(NaN) = NaN\n+func Sin(x float64) float64 {\n+\tconst (\n+\t\tPI4A = 7.85398125648498535156E-1                             // 0x3fe921fb40000000, Pi/4 split into three parts\n+\t\tPI4B = 3.77489470793079817668E-8                             // 0x3e64442d00000000,\n+\t\tPI4C = 2.69515142907905952645E-15                            // 0x3ce8469898cc5170,\n+\t\tM4PI = 1.273239544735162542821171882678754627704620361328125 // 4/pi\n+\t)\n+\t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n+\t// when compiler does it for us\n+\t// special cases\n+\tswitch {\n+\tcase x == 0 || x != x: // x == 0 || IsNaN():\n+\t\treturn x // return \u00b10 || NaN()\n+\tcase x < -MaxFloat64 || x > MaxFloat64: // IsInf(x, 0):\n+\t\treturn NaN()\n+\t}\n+\n+\t// make argument positive but save the sign\n+\tsign := false\n \tif x < 0 {\n \t\tx = -x\n+\t\tsign = true\n \t}\n-\treturn sinus(x, 1)\n-}\n \n-// Sin returns the sine of x.\n-func Sin(x float64) float64 { return sinus(x, 0) }\n+\tj := int64(x * M4PI) // integer part of x/(Pi/4), as integer for tests on the phase angle\n+\ty := float64(j)      // integer part of x/(Pi/4), as float\n+\n+\t// map zeros to origin\n+\tif j&1 == 1 {\n+\t\tj += 1\n+\t\ty += 1\n+\t}\n+\tj &= 7 // octant modulo 2Pi radians (360 degrees)\n+\t// reflect in x axis\n+\tif j > 3 {\n+\t\tsign = !sign\n+\t\tj -= 4\n+\t}\n+\n+\tz := ((x - y*PI4A) - y*PI4B) - y*PI4C // Extended precision modular arithmetic\n+\tzz := z * z\n+\tif j == 1 || j == 2 {\n+\t\ty = 1.0 - 0.5*zz + zz*zz*((((((_cos[0]*zz)+_cos[1])*zz+_cos[2])*zz+_cos[3])*zz+_cos[4])*zz+_cos[5])\n+\t} else {\n+\t\ty = z + z*zz*((((((_sin[0]*zz)+_sin[1])*zz+_sin[2])*zz+_sin[3])*zz+_sin[4])*zz+_sin[5])\n+\t}\n+\tif sign {\n+\t\ty = -y\n+\t}\n+\treturn y\n+}"}, {"sha": "e16a06c86be899429b808ade356192a550451bae", "filename": "libgo/go/mime/grammar.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmime%2Fgrammar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmime%2Fgrammar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fgrammar.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -10,16 +10,16 @@ import (\n \n // isTSpecial returns true if rune is in 'tspecials' as defined by RFC\n // 1521 and RFC 2045.\n-func isTSpecial(rune int) bool {\n-\treturn strings.IndexRune(`()<>@,;:\\\"/[]?=`, rune) != -1\n+func isTSpecial(r rune) bool {\n+\treturn strings.IndexRune(`()<>@,;:\\\"/[]?=`, r) != -1\n }\n \n // IsTokenChar returns true if rune is in 'token' as defined by RFC\n // 1521 and RFC 2045.\n-func IsTokenChar(rune int) bool {\n+func IsTokenChar(r rune) bool {\n \t// token := 1*<any (US-ASCII) CHAR except SPACE, CTLs,\n \t//             or tspecials>\n-\treturn rune > 0x20 && rune < 0x7f && !isTSpecial(rune)\n+\treturn r > 0x20 && r < 0x7f && !isTSpecial(r)\n }\n \n // IsToken returns true if s is a 'token' as as defined by RFC 1521\n@@ -32,14 +32,14 @@ func IsToken(s string) bool {\n }\n \n // IsQText returns true if rune is in 'qtext' as defined by RFC 822.\n-func IsQText(rune int) bool {\n+func IsQText(r int) bool {\n \t// CHAR        =  <any ASCII character>        ; (  0-177,  0.-127.)\n \t// qtext       =  <any CHAR excepting <\">,     ; => may be folded\n \t//                \"\\\" & CR, and including\n \t//                linear-white-space>\n-\tswitch rune {\n+\tswitch r {\n \tcase '\"', '\\\\', '\\r':\n \t\treturn false\n \t}\n-\treturn rune < 0x80\n+\treturn r < 0x80\n }"}, {"sha": "8ad800443507c163aa80fd26bc2ed92cc9c46e79", "filename": "libgo/go/mime/mediatype.go", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmime%2Fmediatype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fmime%2Fmediatype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmediatype.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -199,8 +199,8 @@ func decode2231Enc(v string) string {\n \treturn encv\n }\n \n-func isNotTokenChar(rune int) bool {\n-\treturn !IsTokenChar(rune)\n+func isNotTokenChar(r rune) bool {\n+\treturn !IsTokenChar(r)\n }\n \n // consumeToken consumes a token from the beginning of provided\n@@ -228,24 +228,25 @@ func consumeValue(v string) (value, rest string) {\n \t\treturn consumeToken(v)\n \t}\n \n-\tleadQuote := int(v[0])\n+\tleadQuote := rune(v[0])\n \n \t// parse a quoted-string\n \trest = v[1:] // consume the leading quote\n \tbuffer := new(bytes.Buffer)\n-\tvar idx, rune int\n+\tvar idx int\n+\tvar r rune\n \tvar nextIsLiteral bool\n-\tfor idx, rune = range rest {\n+\tfor idx, r = range rest {\n \t\tswitch {\n \t\tcase nextIsLiteral:\n-\t\t\tbuffer.WriteRune(rune)\n+\t\t\tbuffer.WriteRune(r)\n \t\t\tnextIsLiteral = false\n-\t\tcase rune == leadQuote:\n+\t\tcase r == leadQuote:\n \t\t\treturn buffer.String(), rest[idx+1:]\n-\t\tcase rune == '\\\\':\n+\t\tcase r == '\\\\':\n \t\t\tnextIsLiteral = true\n-\t\tcase rune != '\\r' && rune != '\\n':\n-\t\t\tbuffer.WriteRune(rune)\n+\t\tcase r != '\\r' && r != '\\n':\n+\t\t\tbuffer.WriteRune(r)\n \t\tdefault:\n \t\t\treturn \"\", v\n \t\t}"}, {"sha": "a14c592e8f63fa75902560d6aaa7f8d736816e69", "filename": "libgo/go/net/lookup_plan9.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Flookup_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_plan9.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -49,7 +49,7 @@ func queryCS(net, host, service string) (res []string, err os.Error) {\n \n func queryCS1(net string, ip IP, port int) (clone, dest string, err os.Error) {\n \tips := \"*\"\n-\tif !ip.IsUnspecified() {\n+\tif len(ip) != 0 && !ip.IsUnspecified() {\n \t\tips = ip.String()\n \t}\n \tlines, err := queryCS(net, ips, itoa(port))\n@@ -215,7 +215,16 @@ func LookupMX(name string) (mx []*MX, err os.Error) {\n \n // LookupTXT returns the DNS TXT records for the given domain name.\n func LookupTXT(name string) (txt []string, err os.Error) {\n-\treturn nil, os.NewError(\"net.LookupTXT is not implemented on Plan 9\")\n+\tlines, err := queryDNS(name, \"txt\")\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfor _, line := range lines {\n+\t\tif i := byteIndex(line, '\\t'); i >= 0 {\n+\t\t\ttxt = append(txt, line[i+1:])\n+\t\t}\n+\t}\n+\treturn\n }\n \n // LookupAddr performs a reverse lookup for the given address, returning a list"}, {"sha": "6b7e53d0c6cbf42242e8d8af419628bce1d1f5b5", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -52,8 +52,8 @@ func TestGmailMX(t *testing.T) {\n }\n \n func TestGmailTXT(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n-\t\tt.Logf(\"LookupTXT is not implemented on Windows or Plan 9\")\n+\tif runtime.GOOS == \"windows\" {\n+\t\tt.Logf(\"LookupTXT is not implemented on Windows\")\n \t\treturn\n \t}\n \tif testing.Short() || avoidMacFirewall {"}, {"sha": "51cdac91bef5840415266c140db3ee986cc12257", "filename": "libgo/go/net/net_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Fnet_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Fnet_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"flag\"\n \t\"os\"\n \t\"regexp\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -128,6 +129,9 @@ func TestReverseAddress(t *testing.T) {\n }\n \n func TestShutdown(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\treturn\n+\t}\n \tl, err := Listen(\"tcp\", \"127.0.0.1:0\")\n \tif err != nil {\n \t\tif l, err = Listen(\"tcp6\", \"[::1]:0\"); err != nil {"}, {"sha": "9b9cd9e368bf5dc3dd3d897d1433c81e082ee949", "filename": "libgo/go/net/sock_windows.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -11,6 +11,13 @@ import (\n )\n \n func setKernelSpecificSockopt(s syscall.Handle, f int) {\n+\t// Windows will reuse recently-used addresses by default.\n+\t// SO_REUSEADDR should not be used here, as it allows\n+\t// a socket to forcibly bind to a port in use by another socket.\n+\t// This could lead to a non-deterministic behavior, where\n+\t// connection requests over the port cannot be guaranteed\n+\t// to be handled by the correct socket.\n+\n \t// Allow broadcast.\n \tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n "}, {"sha": "3319e57c3384d9208b9895ad192e1be1c5f103a8", "filename": "libgo/go/net/tcpsock_plan9.go", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_plan9.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -16,6 +16,24 @@ type TCPConn struct {\n \tplan9Conn\n }\n \n+// CloseRead shuts down the reading side of the TCP connection.\n+// Most callers should just use Close.\n+func (c *TCPConn) CloseRead() os.Error {\n+\tif !c.ok() {\n+\t\treturn os.EINVAL\n+\t}\n+\treturn os.EPLAN9\n+}\n+\n+// CloseWrite shuts down the writing side of the TCP connection.\n+// Most callers should just use Close.\n+func (c *TCPConn) CloseWrite() os.Error {\n+\tif !c.ok() {\n+\t\treturn os.EINVAL\n+\t}\n+\treturn os.EPLAN9\n+}\n+\n // DialTCP connects to the remote address raddr on the network net,\n // which must be \"tcp\", \"tcp4\", or \"tcp6\".  If laddr is not nil, it is used\n // as the local address for the connection."}, {"sha": "98b39276b8a9ef0ea45e979c1aad780ed6b14c19", "filename": "libgo/go/net/textproto/reader.go", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -50,8 +50,22 @@ func (r *Reader) ReadLineBytes() ([]byte, os.Error) {\n \n func (r *Reader) readLineSlice() ([]byte, os.Error) {\n \tr.closeDot()\n-\tline, _, err := r.R.ReadLine()\n-\treturn line, err\n+\tvar line []byte\n+\tfor {\n+\t\tl, more, err := r.R.ReadLine()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\t// Avoid the copy if the first call produced a full line.\n+\t\tif line == nil && !more {\n+\t\t\treturn l, nil\n+\t\t}\n+\t\tline = append(line, l...)\n+\t\tif !more {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\treturn line, nil\n }\n \n // ReadContinuedLine reads a possibly continued line from r,"}, {"sha": "a087e29d914515db776f36b753ef91a3630d5c45", "filename": "libgo/go/net/textproto/reader_test.go", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -139,6 +139,23 @@ func TestReadMIMEHeader(t *testing.T) {\n \t}\n }\n \n+func TestLargeReadMIMEHeader(t *testing.T) {\n+\tdata := make([]byte, 16*1024)\n+\tfor i := 0; i < len(data); i++ {\n+\t\tdata[i] = 'x'\n+\t}\n+\tsdata := string(data)\n+\tr := reader(\"Cookie: \" + sdata + \"\\r\\n\\n\")\n+\tm, err := r.ReadMIMEHeader()\n+\tif err != nil {\n+\t\tt.Fatalf(\"ReadMIMEHeader: %v\", err)\n+\t}\n+\tcookie := m.Get(\"Cookie\")\n+\tif cookie != sdata {\n+\t\tt.Fatalf(\"ReadMIMEHeader: %v bytes, want %v bytes\", len(cookie), len(sdata))\n+\t}\n+}\n+\n type readResponseTest struct {\n \tin       string\n \tinCode   int"}, {"sha": "2c2c36fff5e772095f3f305e7275852b4356845d", "filename": "libgo/go/net/timeout_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fnet%2Ftimeout_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftimeout_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -6,6 +6,7 @@ package net\n \n import (\n \t\"os\"\n+\t\"runtime\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -41,11 +42,17 @@ func testTimeout(t *testing.T, network, addr string, readFrom bool) {\n }\n \n func TestTimeoutUDP(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\treturn\n+\t}\n \ttestTimeout(t, \"udp\", \"127.0.0.1:53\", false)\n \ttestTimeout(t, \"udp\", \"127.0.0.1:53\", true)\n }\n \n func TestTimeoutTCP(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\treturn\n+\t}\n \t// set up a listener that won't talk back\n \tlistening := make(chan string)\n \tdone := make(chan int)"}, {"sha": "f18d9c8f59256f00b1d337e37b5878e7d85f976b", "filename": "libgo/go/old/regexp/regexp.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Fregexp%2Fregexp.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -119,7 +119,7 @@ type instr struct {\n \tindex int    // used only in debugging; could be eliminated\n \tnext  *instr // the instruction to execute after this one\n \t// Special fields valid only for some items.\n-\tchar   int        // iChar\n+\tchar   rune       // iChar\n \tbraNum int        // iBra, iEbra\n \tcclass *charClass // iCharClass\n \tleft   *instr     // iAlt, other branch\n@@ -172,8 +172,8 @@ type Regexp struct {\n type charClass struct {\n \tnegate bool // is character class negated? ([^a-z])\n \t// slice of int, stored pairwise: [a-z] is (a,z); x is (x,x):\n-\tranges     []int\n-\tcmin, cmax int\n+\tranges     []rune\n+\tcmin, cmax rune\n }\n \n func (cclass *charClass) print() {\n@@ -192,7 +192,7 @@ func (cclass *charClass) print() {\n \t}\n }\n \n-func (cclass *charClass) addRange(a, b int) {\n+func (cclass *charClass) addRange(a, b rune) {\n \t// range is a through b inclusive\n \tcclass.ranges = append(cclass.ranges, a, b)\n \tif a < cclass.cmin {\n@@ -203,7 +203,7 @@ func (cclass *charClass) addRange(a, b int) {\n \t}\n }\n \n-func (cclass *charClass) matches(c int) bool {\n+func (cclass *charClass) matches(c rune) bool {\n \tif c < cclass.cmin || c > cclass.cmax {\n \t\treturn cclass.negate\n \t}\n@@ -219,7 +219,7 @@ func (cclass *charClass) matches(c int) bool {\n func newCharClass() *instr {\n \ti := &instr{kind: iCharClass}\n \ti.cclass = new(charClass)\n-\ti.cclass.ranges = make([]int, 0, 4)\n+\ti.cclass.ranges = make([]rune, 0, 4)\n \ti.cclass.cmin = 0x10FFFF + 1 // MaxRune + 1\n \ti.cclass.cmax = -1\n \treturn i\n@@ -235,7 +235,7 @@ type parser struct {\n \tre    *Regexp\n \tnlpar int // number of unclosed lpars\n \tpos   int\n-\tch    int\n+\tch    rune\n }\n \n func (p *parser) error(err Error) {\n@@ -244,9 +244,9 @@ func (p *parser) error(err Error) {\n \n const endOfText = -1\n \n-func (p *parser) c() int { return p.ch }\n+func (p *parser) c() rune { return p.ch }\n \n-func (p *parser) nextc() int {\n+func (p *parser) nextc() rune {\n \tif p.pos >= len(p.re.expr) {\n \t\tp.ch = endOfText\n \t} else {\n@@ -264,7 +264,7 @@ func newParser(re *Regexp) *parser {\n \treturn p\n }\n \n-func special(c int) bool {\n+func special(c rune) bool {\n \tfor _, r := range `\\.+*?()|[]^$` {\n \t\tif c == r {\n \t\t\treturn true\n@@ -273,7 +273,7 @@ func special(c int) bool {\n \treturn false\n }\n \n-func ispunct(c int) bool {\n+func ispunct(c rune) bool {\n \tfor _, r := range \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\" {\n \t\tif c == r {\n \t\t\treturn true\n@@ -285,16 +285,16 @@ func ispunct(c int) bool {\n var escapes = []byte(\"abfnrtv\")\n var escaped = []byte(\"\\a\\b\\f\\n\\r\\t\\v\")\n \n-func escape(c int) int {\n+func escape(c rune) int {\n \tfor i, b := range escapes {\n-\t\tif int(b) == c {\n+\t\tif rune(b) == c {\n \t\t\treturn i\n \t\t}\n \t}\n \treturn -1\n }\n \n-func (p *parser) checkBackslash() int {\n+func (p *parser) checkBackslash() rune {\n \tc := p.c()\n \tif c == '\\\\' {\n \t\tc = p.nextc()\n@@ -304,7 +304,7 @@ func (p *parser) checkBackslash() int {\n \t\tcase ispunct(c):\n \t\t\t// c is as delivered\n \t\tcase escape(c) >= 0:\n-\t\t\tc = int(escaped[escape(c)])\n+\t\t\tc = rune(escaped[escape(c)])\n \t\tdefault:\n \t\t\tp.error(ErrBadBackslash)\n \t\t}\n@@ -319,7 +319,7 @@ func (p *parser) charClass() *instr {\n \t\tcc.negate = true\n \t\tp.nextc()\n \t}\n-\tleft := -1\n+\tleft := rune(-1)\n \tfor {\n \t\tswitch c := p.c(); c {\n \t\tcase ']', endOfText:\n@@ -751,8 +751,8 @@ func (a *matchArena) addState(s []state, inst *instr, prefixed bool, match *matc\n // input abstracts different representations of the input text. It provides\n // one-character lookahead.\n type input interface {\n-\tstep(pos int) (rune int, width int) // advance one rune\n-\tcanCheckPrefix() bool               // can we look ahead without losing info?\n+\tstep(pos int) (r rune, width int) // advance one rune\n+\tcanCheckPrefix() bool             // can we look ahead without losing info?\n \thasPrefix(re *Regexp) bool\n \tindex(re *Regexp, pos int) int\n }\n@@ -766,7 +766,7 @@ func newInputString(str string) *inputString {\n \treturn &inputString{str: str}\n }\n \n-func (i *inputString) step(pos int) (int, int) {\n+func (i *inputString) step(pos int) (rune, int) {\n \tif pos < len(i.str) {\n \t\treturn utf8.DecodeRuneInString(i.str[pos:len(i.str)])\n \t}\n@@ -794,7 +794,7 @@ func newInputBytes(str []byte) *inputBytes {\n \treturn &inputBytes{str: str}\n }\n \n-func (i *inputBytes) step(pos int) (int, int) {\n+func (i *inputBytes) step(pos int) (rune, int) {\n \tif pos < len(i.str) {\n \t\treturn utf8.DecodeRune(i.str[pos:len(i.str)])\n \t}\n@@ -824,7 +824,7 @@ func newInputReader(r io.RuneReader) *inputReader {\n \treturn &inputReader{r: r}\n }\n \n-func (i *inputReader) step(pos int) (int, int) {\n+func (i *inputReader) step(pos int) (rune, int) {\n \tif !i.atEOT && pos != i.pos {\n \t\treturn endOfText, 0\n \n@@ -886,7 +886,7 @@ func (re *Regexp) doExecute(i input, pos int) []int {\n \t\tatBOT: pos == 0,\n \t\tatEOT: nextChar == endOfText,\n \t}\n-\tfor c, startPos := 0, pos; c != endOfText; {\n+\tfor c, startPos := rune(0), pos; c != endOfText; {\n \t\tif !found && (pos == startPos || !anchored) {\n \t\t\t// prime the pump if we haven't seen a match yet\n \t\t\tmatch := arena.noMatch()\n@@ -966,7 +966,7 @@ func (re *Regexp) doExecute(i input, pos int) []int {\n // of the regular expression re.  It returns the boolean true if the\n // literal string comprises the entire regular expression.\n func (re *Regexp) LiteralPrefix() (prefix string, complete bool) {\n-\tc := make([]int, len(re.inst)-2) // minus start and end.\n+\tc := make([]rune, len(re.inst)-2) // minus start and end.\n \t// First instruction is start; skip that.\n \ti := 0\n \tfor inst := re.inst[0].next; inst.kind != iEnd; inst = inst.next {\n@@ -1141,7 +1141,7 @@ func QuoteMeta(s string) string {\n \t// A byte loop is correct because all metacharacters are ASCII.\n \tj := 0\n \tfor i := 0; i < len(s); i++ {\n-\t\tif special(int(s[i])) {\n+\t\tif special(rune(s[i])) {\n \t\t\tb[j] = '\\\\'\n \t\t\tj++\n \t\t}"}, {"sha": "9f8d1eba338a3ecffaf7c2b133f6d3159c9b5c46", "filename": "libgo/go/old/template/parse.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fold%2Ftemplate%2Fparse.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -146,8 +146,8 @@ func (t *Template) parseError(err string, args ...interface{}) {\n \n // Is this an exported - upper case - name?\n func isExported(name string) bool {\n-\trune, _ := utf8.DecodeRuneInString(name)\n-\treturn unicode.IsUpper(rune)\n+\tr, _ := utf8.DecodeRuneInString(name)\n+\treturn unicode.IsUpper(r)\n }\n \n // -- Lexical analysis\n@@ -419,7 +419,7 @@ func (t *Template) newVariable(words []string) *variableElement {\n \t\tcase '\"', '`', '\\'':\n \t\t\tv, err := strconv.Unquote(word)\n \t\t\tif err == nil && word[0] == '\\'' {\n-\t\t\t\targs[i] = []int(v)[0]\n+\t\t\t\targs[i], _ = utf8.DecodeRuneInString(v)\n \t\t\t} else {\n \t\t\t\targs[i], lerr = v, err\n \t\t\t}"}, {"sha": "9f982e183a2676262ba6a816a210c5fde453f7eb", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -69,7 +69,7 @@ func (file *File) Read(b []byte) (n int, err Error) {\n \tif n < 0 {\n \t\tn = 0\n \t}\n-\tif n == 0 && !iserror(e) {\n+\tif n == 0 && len(b) > 0 && !iserror(e) {\n \t\treturn 0, EOF\n \t}\n \tif iserror(e) {"}, {"sha": "b8c4967b12d36020d942e36d7a37abec3ff55b99", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -163,6 +163,27 @@ func TestLstat(t *testing.T) {\n \t}\n }\n \n+// Read with length 0 should not return EOF.\n+func TestRead0(t *testing.T) {\n+\tpath := sfdir + \"/\" + sfname\n+\tf, err := Open(path)\n+\tif err != nil {\n+\t\tt.Fatal(\"open failed:\", err)\n+\t}\n+\tdefer f.Close()\n+\n+\tb := make([]byte, 0)\n+\tn, err := f.Read(b)\n+\tif n != 0 || err != nil {\n+\t\tt.Errorf(\"Read(0) = %d, %v, want 0, nil\", n, err)\n+\t}\n+\tb = make([]byte, 100)\n+\tn, err = f.Read(b)\n+\tif n <= 0 || err != nil {\n+\t\tt.Errorf(\"Read(100) = %d, %v, want >0, nil\", n, err)\n+\t}\n+}\n+\n func testReaddirnames(dir string, contents []string, t *testing.T) {\n \tfile, err := Open(dir)\n \tdefer file.Close()"}, {"sha": "15c84a7e9850ad3bf991455485debe90796f81c7", "filename": "libgo/go/path/filepath/match.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -136,7 +136,7 @@ func matchChunk(chunk, s string) (rest string, ok bool, err os.Error) {\n \t\t\t\t\tchunk = chunk[1:]\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tvar lo, hi int\n+\t\t\t\tvar lo, hi rune\n \t\t\t\tif lo, chunk, err = getEsc(chunk); err != nil {\n \t\t\t\t\treturn\n \t\t\t\t}\n@@ -183,7 +183,7 @@ func matchChunk(chunk, s string) (rest string, ok bool, err os.Error) {\n }\n \n // getEsc gets a possibly-escaped character from chunk, for a character class.\n-func getEsc(chunk string) (r int, nchunk string, err os.Error) {\n+func getEsc(chunk string) (r rune, nchunk string, err os.Error) {\n \tif len(chunk) == 0 || chunk[0] == '-' || chunk[0] == ']' {\n \t\terr = ErrBadPattern\n \t\treturn"}, {"sha": "e9d032799fe7a8ca5676a1e06b6c7add193c982c", "filename": "libgo/go/path/match.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fpath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fpath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fmatch.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -136,7 +136,7 @@ func matchChunk(chunk, s string) (rest string, ok bool, err os.Error) {\n \t\t\t\t\tchunk = chunk[1:]\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tvar lo, hi int\n+\t\t\t\tvar lo, hi rune\n \t\t\t\tif lo, chunk, err = getEsc(chunk); err != nil {\n \t\t\t\t\treturn\n \t\t\t\t}\n@@ -183,7 +183,7 @@ func matchChunk(chunk, s string) (rest string, ok bool, err os.Error) {\n }\n \n // getEsc gets a possibly-escaped character from chunk, for a character class.\n-func getEsc(chunk string) (r int, nchunk string, err os.Error) {\n+func getEsc(chunk string) (r rune, nchunk string, err os.Error) {\n \tif len(chunk) == 0 || chunk[0] == '-' || chunk[0] == ']' {\n \t\terr = ErrBadPattern\n \t\treturn"}, {"sha": "98b6e23c1d0492683f29289a40488bab1ea295f6", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -11,7 +11,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t. \"reflect\"\n-/*\t\"runtime\" */\n+\t/*\t\"runtime\" */\n \t\"testing\"\n \t\"unsafe\"\n )\n@@ -434,7 +434,7 @@ func TestInterfaceGet(t *testing.T) {\n \tinter.E = 123.456\n \tv1 := ValueOf(&inter)\n \tv2 := v1.Elem().Field(0)\n-\tassert(t, v2.Type().String(), \"interface { }\")\n+\tassert(t, v2.Type().String(), \"interface {}\")\n \ti2 := v2.Interface()\n \tv3 := ValueOf(i2)\n \tassert(t, v3.Type().String(), \"float64\")\n@@ -447,7 +447,7 @@ func TestInterfaceValue(t *testing.T) {\n \tinter.E = 123.456\n \tv1 := ValueOf(&inter)\n \tv2 := v1.Elem().Field(0)\n-\tassert(t, v2.Type().String(), \"interface { }\")\n+\tassert(t, v2.Type().String(), \"interface {}\")\n \tv3 := v2.Elem()\n \tassert(t, v3.Type().String(), \"float64\")\n "}, {"sha": "d7057a191b773719a178aef5eaba2001f9a6ab01", "filename": "libgo/go/regexp/exec.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fexec.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -90,15 +90,15 @@ func (m *machine) match(i input, pos int) bool {\n \t\tm.matchcap[i] = -1\n \t}\n \trunq, nextq := &m.q0, &m.q1\n-\trune, rune1 := endOfText, endOfText\n+\tr, r1 := endOfText, endOfText\n \twidth, width1 := 0, 0\n-\trune, width = i.step(pos)\n-\tif rune != endOfText {\n-\t\trune1, width1 = i.step(pos + width)\n+\tr, width = i.step(pos)\n+\tif r != endOfText {\n+\t\tr1, width1 = i.step(pos + width)\n \t}\n \tvar flag syntax.EmptyOp\n \tif pos == 0 {\n-\t\tflag = syntax.EmptyOpContext(-1, rune)\n+\t\tflag = syntax.EmptyOpContext(-1, r)\n \t} else {\n \t\tflag = i.context(pos)\n \t}\n@@ -112,15 +112,15 @@ func (m *machine) match(i input, pos int) bool {\n \t\t\t\t// Have match; finished exploring alternatives.\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tif len(m.re.prefix) > 0 && rune1 != m.re.prefixRune && i.canCheckPrefix() {\n+\t\t\tif len(m.re.prefix) > 0 && r1 != m.re.prefixRune && i.canCheckPrefix() {\n \t\t\t\t// Match requires literal prefix; fast search for it.\n \t\t\t\tadvance := i.index(m.re, pos)\n \t\t\t\tif advance < 0 {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\tpos += advance\n-\t\t\t\trune, width = i.step(pos)\n-\t\t\t\trune1, width1 = i.step(pos + width)\n+\t\t\t\tr, width = i.step(pos)\n+\t\t\t\tr1, width1 = i.step(pos + width)\n \t\t\t}\n \t\t}\n \t\tif !m.matched {\n@@ -129,8 +129,8 @@ func (m *machine) match(i input, pos int) bool {\n \t\t\t}\n \t\t\tm.add(runq, uint32(m.p.Start), pos, m.matchcap, flag, nil)\n \t\t}\n-\t\tflag = syntax.EmptyOpContext(rune, rune1)\n-\t\tm.step(runq, nextq, pos, pos+width, rune, flag)\n+\t\tflag = syntax.EmptyOpContext(r, r1)\n+\t\tm.step(runq, nextq, pos, pos+width, r, flag)\n \t\tif width == 0 {\n \t\t\tbreak\n \t\t}\n@@ -140,9 +140,9 @@ func (m *machine) match(i input, pos int) bool {\n \t\t\tbreak\n \t\t}\n \t\tpos += width\n-\t\trune, width = rune1, width1\n-\t\tif rune != endOfText {\n-\t\t\trune1, width1 = i.step(pos + width)\n+\t\tr, width = r1, width1\n+\t\tif r != endOfText {\n+\t\t\tr1, width1 = i.step(pos + width)\n \t\t}\n \t\trunq, nextq = nextq, runq\n \t}\n@@ -166,7 +166,7 @@ func (m *machine) clear(q *queue) {\n // The step processes the rune c (which may be endOfText),\n // which starts at position pos and ends at nextPos.\n // nextCond gives the setting for the empty-width flags after c.\n-func (m *machine) step(runq, nextq *queue, pos, nextPos, c int, nextCond syntax.EmptyOp) {\n+func (m *machine) step(runq, nextq *queue, pos, nextPos int, c rune, nextCond syntax.EmptyOp) {\n \tlongest := m.re.longest\n \tfor j := 0; j < len(runq.dense); j++ {\n \t\td := &runq.dense[j]"}, {"sha": "a1b7951bfe8e1be908c59f65852d9b3528487073", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -83,7 +83,7 @@ type Regexp struct {\n \tprefix         string         // required prefix in unanchored matches\n \tprefixBytes    []byte         // prefix, as a []byte\n \tprefixComplete bool           // prefix is the entire regexp\n-\tprefixRune     int            // first rune in prefix\n+\tprefixRune     rune           // first rune in prefix\n \tcond           syntax.EmptyOp // empty-width conditions required at start of match\n \tnumSubexp      int\n \tlongest        bool\n@@ -224,13 +224,13 @@ func (re *Regexp) NumSubexp() int {\n \treturn re.numSubexp\n }\n \n-const endOfText = -1\n+const endOfText rune = -1\n \n // input abstracts different representations of the input text. It provides\n // one-character lookahead.\n type input interface {\n-\tstep(pos int) (rune int, width int) // advance one rune\n-\tcanCheckPrefix() bool               // can we look ahead without losing info?\n+\tstep(pos int) (r rune, width int) // advance one rune\n+\tcanCheckPrefix() bool             // can we look ahead without losing info?\n \thasPrefix(re *Regexp) bool\n \tindex(re *Regexp, pos int) int\n \tcontext(pos int) syntax.EmptyOp\n@@ -245,11 +245,11 @@ func newInputString(str string) *inputString {\n \treturn &inputString{str: str}\n }\n \n-func (i *inputString) step(pos int) (int, int) {\n+func (i *inputString) step(pos int) (rune, int) {\n \tif pos < len(i.str) {\n \t\tc := i.str[pos]\n \t\tif c < utf8.RuneSelf {\n-\t\t\treturn int(c), 1\n+\t\t\treturn rune(c), 1\n \t\t}\n \t\treturn utf8.DecodeRuneInString(i.str[pos:])\n \t}\n@@ -269,7 +269,7 @@ func (i *inputString) index(re *Regexp, pos int) int {\n }\n \n func (i *inputString) context(pos int) syntax.EmptyOp {\n-\tr1, r2 := -1, -1\n+\tr1, r2 := endOfText, endOfText\n \tif pos > 0 && pos <= len(i.str) {\n \t\tr1, _ = utf8.DecodeLastRuneInString(i.str[:pos])\n \t}\n@@ -288,11 +288,11 @@ func newInputBytes(str []byte) *inputBytes {\n \treturn &inputBytes{str: str}\n }\n \n-func (i *inputBytes) step(pos int) (int, int) {\n+func (i *inputBytes) step(pos int) (rune, int) {\n \tif pos < len(i.str) {\n \t\tc := i.str[pos]\n \t\tif c < utf8.RuneSelf {\n-\t\t\treturn int(c), 1\n+\t\t\treturn rune(c), 1\n \t\t}\n \t\treturn utf8.DecodeRune(i.str[pos:])\n \t}\n@@ -312,7 +312,7 @@ func (i *inputBytes) index(re *Regexp, pos int) int {\n }\n \n func (i *inputBytes) context(pos int) syntax.EmptyOp {\n-\tr1, r2 := -1, -1\n+\tr1, r2 := endOfText, endOfText\n \tif pos > 0 && pos <= len(i.str) {\n \t\tr1, _ = utf8.DecodeLastRune(i.str[:pos])\n \t}\n@@ -333,7 +333,7 @@ func newInputReader(r io.RuneReader) *inputReader {\n \treturn &inputReader{r: r}\n }\n \n-func (i *inputReader) step(pos int) (int, int) {\n+func (i *inputReader) step(pos int) (rune, int) {\n \tif !i.atEOT && pos != i.pos {\n \t\treturn endOfText, 0\n "}, {"sha": "c90de3fe99d7e0fba989ce7da68c19379dcb1a4b", "filename": "libgo/go/regexp/syntax/compile.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fcompile.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -91,8 +91,8 @@ func (c *compiler) init() {\n \tc.inst(InstFail)\n }\n \n-var anyRuneNotNL = []int{0, '\\n' - 1, '\\n' + 1, unicode.MaxRune}\n-var anyRune = []int{0, unicode.MaxRune}\n+var anyRuneNotNL = []rune{0, '\\n' - 1, '\\n' + 1, unicode.MaxRune}\n+var anyRune = []rune{0, unicode.MaxRune}\n \n func (c *compiler) compile(re *Regexp) frag {\n \tswitch re.Op {\n@@ -262,12 +262,12 @@ func (c *compiler) empty(op EmptyOp) frag {\n \treturn f\n }\n \n-func (c *compiler) rune(rune []int, flags Flags) frag {\n+func (c *compiler) rune(r []rune, flags Flags) frag {\n \tf := c.inst(InstRune)\n \ti := &c.p.Inst[f.i]\n-\ti.Rune = rune\n+\ti.Rune = r\n \tflags &= FoldCase // only relevant flag is FoldCase\n-\tif len(rune) != 1 || unicode.SimpleFold(rune[0]) == rune[0] {\n+\tif len(r) != 1 || unicode.SimpleFold(r[0]) == r[0] {\n \t\t// and sometimes not even that\n \t\tflags &^= FoldCase\n \t}\n@@ -276,11 +276,11 @@ func (c *compiler) rune(rune []int, flags Flags) frag {\n \n \t// Special cases for exec machine.\n \tswitch {\n-\tcase flags&FoldCase == 0 && (len(rune) == 1 || len(rune) == 2 && rune[0] == rune[1]):\n+\tcase flags&FoldCase == 0 && (len(r) == 1 || len(r) == 2 && r[0] == r[1]):\n \t\ti.Op = InstRune1\n-\tcase len(rune) == 2 && rune[0] == 0 && rune[1] == unicode.MaxRune:\n+\tcase len(r) == 2 && r[0] == 0 && r[1] == unicode.MaxRune:\n \t\ti.Op = InstRuneAny\n-\tcase len(rune) == 4 && rune[0] == 0 && rune[1] == '\\n'-1 && rune[2] == '\\n'+1 && rune[3] == unicode.MaxRune:\n+\tcase len(r) == 4 && r[0] == 0 && r[1] == '\\n'-1 && r[2] == '\\n'+1 && r[3] == unicode.MaxRune:\n \t\ti.Op = InstRuneAnyNotNL\n \t}\n "}, {"sha": "bb19c5ad55cf96166c0dd35c3d2b2bedfdac0cf2", "filename": "libgo/go/regexp/syntax/parse.go", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -82,7 +82,7 @@ type parser struct {\n \tfree        *Regexp\n \tnumCap      int // number of capturing groups seen\n \twholeRegexp string\n-\ttmpClass    []int // temporary char class work space\n+\ttmpClass    []rune // temporary char class work space\n }\n \n func (p *parser) newRegexp(op Op) *Regexp {\n@@ -149,7 +149,7 @@ func (p *parser) push(re *Regexp) *Regexp {\n // If r >= 0 and there's a node left over, maybeConcat uses it\n // to push r with the given flags.\n // maybeConcat reports whether r was pushed.\n-func (p *parser) maybeConcat(r int, flags Flags) bool {\n+func (p *parser) maybeConcat(r rune, flags Flags) bool {\n \tn := len(p.stack)\n \tif n < 2 {\n \t\treturn false\n@@ -178,7 +178,7 @@ func (p *parser) maybeConcat(r int, flags Flags) bool {\n }\n \n // newLiteral returns a new OpLiteral Regexp with the given flags\n-func (p *parser) newLiteral(r int, flags Flags) *Regexp {\n+func (p *parser) newLiteral(r rune, flags Flags) *Regexp {\n \tre := p.newRegexp(OpLiteral)\n \tre.Flags = flags\n \tif flags&FoldCase != 0 {\n@@ -190,7 +190,7 @@ func (p *parser) newLiteral(r int, flags Flags) *Regexp {\n }\n \n // minFoldRune returns the minimum rune fold-equivalent to r.\n-func minFoldRune(r int) int {\n+func minFoldRune(r rune) rune {\n \tif r < MinFold || r > MaxFold {\n \t\treturn r\n \t}\n@@ -206,7 +206,7 @@ func minFoldRune(r int) int {\n \n // literal pushes a literal regexp for the rune r on the stack\n // and returns that regexp.\n-func (p *parser) literal(r int) {\n+func (p *parser) literal(r rune) {\n \tp.push(p.newLiteral(r, p.flags))\n }\n \n@@ -369,7 +369,7 @@ func (p *parser) factor(sub []*Regexp, flags Flags) []*Regexp {\n \t}\n \n \t// Round 1: Factor out common literal prefixes.\n-\tvar str []int\n+\tvar str []rune\n \tvar strflags Flags\n \tstart := 0\n \tout := sub[:0]\n@@ -380,7 +380,7 @@ func (p *parser) factor(sub []*Regexp, flags Flags) []*Regexp {\n \t\t//\n \t\t// Invariant: sub[start:i] consists of regexps that all begin\n \t\t// with str as modified by strflags.\n-\t\tvar istr []int\n+\t\tvar istr []rune\n \t\tvar iflags Flags\n \t\tif i < len(sub) {\n \t\t\tistr, iflags = p.leadingString(sub[i])\n@@ -543,7 +543,7 @@ func (p *parser) factor(sub []*Regexp, flags Flags) []*Regexp {\n \n // leadingString returns the leading literal string that re begins with.\n // The string refers to storage in re or its children.\n-func (p *parser) leadingString(re *Regexp) ([]int, Flags) {\n+func (p *parser) leadingString(re *Regexp) ([]rune, Flags) {\n \tif re.Op == OpConcat && len(re.Sub) > 0 {\n \t\tre = re.Sub[0]\n \t}\n@@ -639,7 +639,7 @@ func literalRegexp(s string, flags Flags) *Regexp {\n \tfor _, c := range s {\n \t\tif len(re.Rune) >= cap(re.Rune) {\n \t\t\t// string is too long to fit in Rune0.  let Go handle it\n-\t\t\tre.Rune = []int(s)\n+\t\t\tre.Rune = []rune(s)\n \t\t\tbreak\n \t\t}\n \t\tre.Rune = append(re.Rune, c)\n@@ -662,7 +662,7 @@ func Parse(s string, flags Flags) (*Regexp, os.Error) {\n \tvar (\n \t\tp          parser\n \t\terr        os.Error\n-\t\tc          int\n+\t\tc          rune\n \t\top         Op\n \t\tlastRepeat string\n \t\tmin, max   int\n@@ -935,7 +935,7 @@ func (p *parser) parsePerlFlags(s string) (rest string, err os.Error) {\n \t}\n \n \t// Non-capturing group.  Might also twiddle Perl flags.\n-\tvar c int\n+\tvar c rune\n \tt = t[2:] // skip (?\n \tflags := p.flags\n \tsign := +1\n@@ -1049,7 +1049,7 @@ func isCharClass(re *Regexp) bool {\n }\n \n // does re match r?\n-func matchRune(re *Regexp, r int) bool {\n+func matchRune(re *Regexp, r rune) bool {\n \tswitch re.Op {\n \tcase OpLiteral:\n \t\treturn len(re.Rune) == 1 && re.Rune[0] == r\n@@ -1186,7 +1186,7 @@ func (p *parser) parseRightParen() os.Error {\n \n // parseEscape parses an escape sequence at the beginning of s\n // and returns the rune.\n-func (p *parser) parseEscape(s string) (r int, rest string, err os.Error) {\n+func (p *parser) parseEscape(s string) (r rune, rest string, err os.Error) {\n \tt := s[1:]\n \tif t == \"\" {\n \t\treturn 0, \"\", &Error{ErrTrailingBackslash, \"\"}\n@@ -1221,7 +1221,7 @@ Switch:\n \t\t\tif t == \"\" || t[0] < '0' || t[0] > '7' {\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tr = r*8 + int(t[0]) - '0'\n+\t\t\tr = r*8 + rune(t[0]) - '0'\n \t\t\tt = t[1:]\n \t\t}\n \t\treturn r, t, nil\n@@ -1302,7 +1302,7 @@ Switch:\n \n // parseClassChar parses a character class character at the beginning of s\n // and returns it.\n-func (p *parser) parseClassChar(s, wholeClass string) (r int, rest string, err os.Error) {\n+func (p *parser) parseClassChar(s, wholeClass string) (r rune, rest string, err os.Error) {\n \tif s == \"\" {\n \t\treturn 0, \"\", &Error{Code: ErrMissingBracket, Expr: wholeClass}\n \t}\n@@ -1318,13 +1318,13 @@ func (p *parser) parseClassChar(s, wholeClass string) (r int, rest string, err o\n \n type charGroup struct {\n \tsign  int\n-\tclass []int\n+\tclass []rune\n }\n \n // parsePerlClassEscape parses a leading Perl character class escape like \\d\n // from the beginning of s.  If one is present, it appends the characters to r\n // and returns the new slice r and the remainder of the string.\n-func (p *parser) parsePerlClassEscape(s string, r []int) (out []int, rest string) {\n+func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string) {\n \tif p.flags&PerlX == 0 || len(s) < 2 || s[0] != '\\\\' {\n \t\treturn\n \t}\n@@ -1338,7 +1338,7 @@ func (p *parser) parsePerlClassEscape(s string, r []int) (out []int, rest string\n // parseNamedClass parses a leading POSIX named character class like [:alnum:]\n // from the beginning of s.  If one is present, it appends the characters to r\n // and returns the new slice r and the remainder of the string.\n-func (p *parser) parseNamedClass(s string, r []int) (out []int, rest string, err os.Error) {\n+func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err os.Error) {\n \tif len(s) < 2 || s[0] != '[' || s[1] != ':' {\n \t\treturn\n \t}\n@@ -1356,7 +1356,7 @@ func (p *parser) parseNamedClass(s string, r []int) (out []int, rest string, err\n \treturn p.appendGroup(r, g), s, nil\n }\n \n-func (p *parser) appendGroup(r []int, g charGroup) []int {\n+func (p *parser) appendGroup(r []rune, g charGroup) []rune {\n \tif p.flags&FoldCase == 0 {\n \t\tif g.sign < 0 {\n \t\t\tr = appendNegatedClass(r, g.class)\n@@ -1401,7 +1401,7 @@ func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable) {\n // parseUnicodeClass parses a leading Unicode character class like \\p{Han}\n // from the beginning of s.  If one is present, it appends the characters to r\n // and returns the new slice r and the remainder of the string.\n-func (p *parser) parseUnicodeClass(s string, r []int) (out []int, rest string, err os.Error) {\n+func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err os.Error) {\n \tif p.flags&UnicodeGroups == 0 || len(s) < 2 || s[0] != '\\\\' || s[1] != 'p' && s[1] != 'P' {\n \t\treturn\n \t}\n@@ -1533,7 +1533,7 @@ func (p *parser) parseClass(s string) (rest string, err os.Error) {\n \n \t\t// Single character or simple range.\n \t\trng := t\n-\t\tvar lo, hi int\n+\t\tvar lo, hi rune\n \t\tif lo, t, err = p.parseClassChar(t, s); err != nil {\n \t\t\treturn \"\", err\n \t\t}\n@@ -1570,7 +1570,7 @@ func (p *parser) parseClass(s string) (rest string, err os.Error) {\n \n // cleanClass sorts the ranges (pairs of elements of r),\n // merges them, and eliminates duplicates.\n-func cleanClass(rp *[]int) []int {\n+func cleanClass(rp *[]rune) []rune {\n \n \t// Sort by lo increasing, hi decreasing to break ties.\n \tsort.Sort(ranges{rp})\n@@ -1601,15 +1601,15 @@ func cleanClass(rp *[]int) []int {\n }\n \n // appendLiteral returns the result of appending the literal x to the class r.\n-func appendLiteral(r []int, x int, flags Flags) []int {\n+func appendLiteral(r []rune, x rune, flags Flags) []rune {\n \tif flags&FoldCase != 0 {\n \t\treturn appendFoldedRange(r, x, x)\n \t}\n \treturn AppendRange(r, x, x)\n }\n \n-// AppendRange returns the result of appending the range lo-hi to the class r.\n-func AppendRange(r []int, lo, hi int) []int {\n+// appendRange returns the result of appending the range lo-hi to the class r.\n+func AppendRange(r []rune, lo, hi rune) []rune {\n \t// Expand last range or next to last range if it overlaps or abuts.\n \t// Checking two ranges helps when appending case-folded\n \t// alphabets, so that one range can be expanding A-Z and the\n@@ -1642,7 +1642,7 @@ const (\n \n // appendFoldedRange returns the result of appending the range lo-hi\n // and its case folding-equivalent runes to the class r.\n-func appendFoldedRange(r []int, lo, hi int) []int {\n+func appendFoldedRange(r []rune, lo, hi rune) []rune {\n \t// Optimizations.\n \tif lo <= MinFold && hi >= MaxFold {\n \t\t// Range is full: folding can't add more.\n@@ -1677,15 +1677,15 @@ func appendFoldedRange(r []int, lo, hi int) []int {\n \n // appendClass returns the result of appending the class x to the class r.\n // It assume x is clean.\n-func appendClass(r []int, x []int) []int {\n+func appendClass(r []rune, x []rune) []rune {\n \tfor i := 0; i < len(x); i += 2 {\n \t\tr = AppendRange(r, x[i], x[i+1])\n \t}\n \treturn r\n }\n \n // appendFolded returns the result of appending the case folding of the class x to the class r.\n-func appendFoldedClass(r []int, x []int) []int {\n+func appendFoldedClass(r []rune, x []rune) []rune {\n \tfor i := 0; i < len(x); i += 2 {\n \t\tr = appendFoldedRange(r, x[i], x[i+1])\n \t}\n@@ -1694,8 +1694,8 @@ func appendFoldedClass(r []int, x []int) []int {\n \n // appendNegatedClass returns the result of appending the negation of the class x to the class r.\n // It assumes x is clean.\n-func appendNegatedClass(r []int, x []int) []int {\n-\tnextLo := 0\n+func appendNegatedClass(r []rune, x []rune) []rune {\n+\tnextLo := rune('\\u0000')\n \tfor i := 0; i < len(x); i += 2 {\n \t\tlo, hi := x[i], x[i+1]\n \t\tif nextLo <= lo-1 {\n@@ -1710,9 +1710,9 @@ func appendNegatedClass(r []int, x []int) []int {\n }\n \n // appendTable returns the result of appending x to the class r.\n-func appendTable(r []int, x *unicode.RangeTable) []int {\n+func appendTable(r []rune, x *unicode.RangeTable) []rune {\n \tfor _, xr := range x.R16 {\n-\t\tlo, hi, stride := int(xr.Lo), int(xr.Hi), int(xr.Stride)\n+\t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n \t\t\tr = AppendRange(r, lo, hi)\n \t\t\tcontinue\n@@ -1722,7 +1722,7 @@ func appendTable(r []int, x *unicode.RangeTable) []int {\n \t\t}\n \t}\n \tfor _, xr := range x.R32 {\n-\t\tlo, hi, stride := int(xr.Lo), int(xr.Hi), int(xr.Stride)\n+\t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n \t\t\tr = AppendRange(r, lo, hi)\n \t\t\tcontinue\n@@ -1735,10 +1735,10 @@ func appendTable(r []int, x *unicode.RangeTable) []int {\n }\n \n // appendNegatedTable returns the result of appending the negation of x to the class r.\n-func appendNegatedTable(r []int, x *unicode.RangeTable) []int {\n-\tnextLo := 0 // lo end of next class to add\n+func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune {\n+\tnextLo := rune('\\u0000') // lo end of next class to add\n \tfor _, xr := range x.R16 {\n-\t\tlo, hi, stride := int(xr.Lo), int(xr.Hi), int(xr.Stride)\n+\t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n \t\t\tif nextLo <= lo-1 {\n \t\t\t\tr = AppendRange(r, nextLo, lo-1)\n@@ -1754,7 +1754,7 @@ func appendNegatedTable(r []int, x *unicode.RangeTable) []int {\n \t\t}\n \t}\n \tfor _, xr := range x.R32 {\n-\t\tlo, hi, stride := int(xr.Lo), int(xr.Hi), int(xr.Stride)\n+\t\tlo, hi, stride := rune(xr.Lo), rune(xr.Hi), rune(xr.Stride)\n \t\tif stride == 1 {\n \t\t\tif nextLo <= lo-1 {\n \t\t\t\tr = AppendRange(r, nextLo, lo-1)\n@@ -1777,9 +1777,9 @@ func appendNegatedTable(r []int, x *unicode.RangeTable) []int {\n \n // negateClass overwrites r and returns r's negation.\n // It assumes the class r is already clean.\n-func negateClass(r []int) []int {\n-\tnextLo := 0 // lo end of next class to add\n-\tw := 0      // write index\n+func negateClass(r []rune) []rune {\n+\tnextLo := rune('\\u0000') // lo end of next class to add\n+\tw := 0                   // write index\n \tfor i := 0; i < len(r); i += 2 {\n \t\tlo, hi := r[i], r[i+1]\n \t\tif nextLo <= lo-1 {\n@@ -1801,9 +1801,9 @@ func negateClass(r []int) []int {\n // ranges implements sort.Interface on a []rune.\n // The choice of receiver type definition is strange\n // but avoids an allocation since we already have\n-// a *[]int.\n+// a *[]rune.\n type ranges struct {\n-\tp *[]int\n+\tp *[]rune\n }\n \n func (ra ranges) Less(i, j int) bool {\n@@ -1835,19 +1835,19 @@ func checkUTF8(s string) os.Error {\n \treturn nil\n }\n \n-func nextRune(s string) (c int, t string, err os.Error) {\n+func nextRune(s string) (c rune, t string, err os.Error) {\n \tc, size := utf8.DecodeRuneInString(s)\n \tif c == utf8.RuneError && size == 1 {\n \t\treturn 0, \"\", &Error{Code: ErrInvalidUTF8, Expr: s}\n \t}\n \treturn c, s[size:], nil\n }\n \n-func isalnum(c int) bool {\n+func isalnum(c rune) bool {\n \treturn '0' <= c && c <= '9' || 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z'\n }\n \n-func unhex(c int) int {\n+func unhex(c rune) rune {\n \tif '0' <= c && c <= '9' {\n \t\treturn c - '0'\n \t}"}, {"sha": "88f65ecfc9bddc5e58d1ca0e85a80ead6e1e56d6", "filename": "libgo/go/regexp/syntax/parse_test.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fparse_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5,9 +5,9 @@\n package syntax_test\n \n import (\n-\t. \"regexp/syntax\"\n \t\"bytes\"\n \t\"fmt\"\n+\t. \"regexp/syntax\"\n \t\"testing\"\n \t\"unicode\"\n )\n@@ -372,10 +372,10 @@ func dumpRegexp(b *bytes.Buffer, re *Regexp) {\n \tb.WriteByte('}')\n }\n \n-func mkCharClass(f func(int) bool) string {\n+func mkCharClass(f func(rune) bool) string {\n \tre := &Regexp{Op: OpCharClass}\n-\tlo := -1\n-\tfor i := 0; i <= unicode.MaxRune; i++ {\n+\tlo := rune(-1)\n+\tfor i := rune(0); i <= unicode.MaxRune; i++ {\n \t\tif f(i) {\n \t\t\tif lo < 0 {\n \t\t\t\tlo = i\n@@ -393,12 +393,12 @@ func mkCharClass(f func(int) bool) string {\n \treturn dump(re)\n }\n \n-func isUpperFold(rune int) bool {\n-\tif unicode.IsUpper(rune) {\n+func isUpperFold(r rune) bool {\n+\tif unicode.IsUpper(r) {\n \t\treturn true\n \t}\n-\tc := unicode.SimpleFold(rune)\n-\tfor c != rune {\n+\tc := unicode.SimpleFold(r)\n+\tfor c != r {\n \t\tif unicode.IsUpper(c) {\n \t\t\treturn true\n \t\t}\n@@ -408,8 +408,8 @@ func isUpperFold(rune int) bool {\n }\n \n func TestFoldConstants(t *testing.T) {\n-\tlast := -1\n-\tfor i := 0; i <= unicode.MaxRune; i++ {\n+\tlast := rune(-1)\n+\tfor i := rune(0); i <= unicode.MaxRune; i++ {\n \t\tif unicode.SimpleFold(i) == i {\n \t\t\tcontinue\n \t\t}\n@@ -428,8 +428,8 @@ func TestAppendRangeCollapse(t *testing.T) {\n \t// into the earlier ones (it looks back two ranges), so that\n \t// the slice never grows very large.\n \t// Note that we are not calling cleanClass.\n-\tvar r []int\n-\tfor i := 'A'; i <= 'Z'; i++ {\n+\tvar r []rune\n+\tfor i := rune('A'); i <= 'Z'; i++ {\n \t\tr = AppendRange(r, i, i)\n \t\tr = AppendRange(r, i+'a'-'A', i+'a'-'A')\n \t}"}, {"sha": "1a11ca62f0c0de7d7748110dd0a76482798597c7", "filename": "libgo/go/regexp/syntax/perl_groups.go", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fperl_groups.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fperl_groups.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fperl_groups.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -3,17 +3,17 @@\n \n package syntax\n \n-var code1 = []int{ /* \\d */\n+var code1 = []rune{ /* \\d */\n \t0x30, 0x39,\n }\n \n-var code2 = []int{ /* \\s */\n+var code2 = []rune{ /* \\s */\n \t0x9, 0xa,\n \t0xc, 0xd,\n \t0x20, 0x20,\n }\n \n-var code3 = []int{ /* \\w */\n+var code3 = []rune{ /* \\w */\n \t0x30, 0x39,\n \t0x41, 0x5a,\n \t0x5f, 0x5f,\n@@ -28,71 +28,71 @@ var perlGroup = map[string]charGroup{\n \t`\\w`: {+1, code3},\n \t`\\W`: {-1, code3},\n }\n-var code4 = []int{ /* [:alnum:] */\n+var code4 = []rune{ /* [:alnum:] */\n \t0x30, 0x39,\n \t0x41, 0x5a,\n \t0x61, 0x7a,\n }\n \n-var code5 = []int{ /* [:alpha:] */\n+var code5 = []rune{ /* [:alpha:] */\n \t0x41, 0x5a,\n \t0x61, 0x7a,\n }\n \n-var code6 = []int{ /* [:ascii:] */\n+var code6 = []rune{ /* [:ascii:] */\n \t0x0, 0x7f,\n }\n \n-var code7 = []int{ /* [:blank:] */\n+var code7 = []rune{ /* [:blank:] */\n \t0x9, 0x9,\n \t0x20, 0x20,\n }\n \n-var code8 = []int{ /* [:cntrl:] */\n+var code8 = []rune{ /* [:cntrl:] */\n \t0x0, 0x1f,\n \t0x7f, 0x7f,\n }\n \n-var code9 = []int{ /* [:digit:] */\n+var code9 = []rune{ /* [:digit:] */\n \t0x30, 0x39,\n }\n \n-var code10 = []int{ /* [:graph:] */\n+var code10 = []rune{ /* [:graph:] */\n \t0x21, 0x7e,\n }\n \n-var code11 = []int{ /* [:lower:] */\n+var code11 = []rune{ /* [:lower:] */\n \t0x61, 0x7a,\n }\n \n-var code12 = []int{ /* [:print:] */\n+var code12 = []rune{ /* [:print:] */\n \t0x20, 0x7e,\n }\n \n-var code13 = []int{ /* [:punct:] */\n+var code13 = []rune{ /* [:punct:] */\n \t0x21, 0x2f,\n \t0x3a, 0x40,\n \t0x5b, 0x60,\n \t0x7b, 0x7e,\n }\n \n-var code14 = []int{ /* [:space:] */\n+var code14 = []rune{ /* [:space:] */\n \t0x9, 0xd,\n \t0x20, 0x20,\n }\n \n-var code15 = []int{ /* [:upper:] */\n+var code15 = []rune{ /* [:upper:] */\n \t0x41, 0x5a,\n }\n \n-var code16 = []int{ /* [:word:] */\n+var code16 = []rune{ /* [:word:] */\n \t0x30, 0x39,\n \t0x41, 0x5a,\n \t0x5f, 0x5f,\n \t0x61, 0x7a,\n }\n \n-var code17 = []int{ /* [:xdigit:] */\n+var code17 = []rune{ /* [:xdigit:] */\n \t0x30, 0x39,\n \t0x41, 0x46,\n \t0x61, 0x66,"}, {"sha": "f5b697a59ae02693a8c30e02c10e5cf814e1d59c", "filename": "libgo/go/regexp/syntax/prog.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fprog.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -51,7 +51,7 @@ const (\n // at the beginning of the text.\n // Passing r2 == -1 indicates that the position is\n // at the end of the text.\n-func EmptyOpContext(r1, r2 int) EmptyOp {\n+func EmptyOpContext(r1, r2 rune) EmptyOp {\n \tvar op EmptyOp\n \tif r1 < 0 {\n \t\top |= EmptyBeginText | EmptyBeginLine\n@@ -76,7 +76,7 @@ func EmptyOpContext(r1, r2 int) EmptyOp {\n // IsWordChar reports whether r is consider a ``word character''\n // during the evaluation of the \\b and \\B zero-width assertions.\n // These assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n-func IsWordChar(r int) bool {\n+func IsWordChar(r rune) bool {\n \treturn 'A' <= r && r <= 'Z' || 'a' <= r && r <= 'z' || '0' <= r && r <= '9' || r == '_'\n }\n \n@@ -85,7 +85,7 @@ type Inst struct {\n \tOp   InstOp\n \tOut  uint32 // all but InstMatch, InstFail\n \tArg  uint32 // InstAlt, InstAltMatch, InstCapture, InstEmptyWidth\n-\tRune []int\n+\tRune []rune\n }\n \n func (p *Prog) String() string {\n@@ -161,7 +161,7 @@ Loop:\n \n // MatchRune returns true if the instruction matches (and consumes) r.\n // It should only be called when i.Op == InstRune.\n-func (i *Inst) MatchRune(r int) bool {\n+func (i *Inst) MatchRune(r rune) bool {\n \trune := i.Rune\n \n \t// Special case: single-rune slice is from literal string, not char class.\n@@ -210,17 +210,17 @@ func (i *Inst) MatchRune(r int) bool {\n \n // As per re2's Prog::IsWordChar. Determines whether rune is an ASCII word char.\n // Since we act on runes, it would be easy to support Unicode here.\n-func wordRune(rune int) bool {\n-\treturn rune == '_' ||\n-\t\t('A' <= rune && rune <= 'Z') ||\n-\t\t('a' <= rune && rune <= 'z') ||\n-\t\t('0' <= rune && rune <= '9')\n+func wordRune(r rune) bool {\n+\treturn r == '_' ||\n+\t\t('A' <= r && r <= 'Z') ||\n+\t\t('a' <= r && r <= 'z') ||\n+\t\t('0' <= r && r <= '9')\n }\n \n // MatchEmptyWidth returns true if the instruction matches\n // an empty string between the runes before and after.\n // It should only be called when i.Op == InstEmptyWidth.\n-func (i *Inst) MatchEmptyWidth(before int, after int) bool {\n+func (i *Inst) MatchEmptyWidth(before rune, after rune) bool {\n \tswitch EmptyOp(i.Arg) {\n \tcase EmptyBeginLine:\n \t\treturn before == '\\n' || before == -1"}, {"sha": "b5ddab1d16bbe5258765ea8453c49447c008b4dd", "filename": "libgo/go/regexp/syntax/regexp.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fsyntax%2Fregexp.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -22,8 +22,8 @@ type Regexp struct {\n \tFlags    Flags\n \tSub      []*Regexp  // subexpressions, if any\n \tSub0     [1]*Regexp // storage for short Sub\n-\tRune     []int      // matched runes, for OpLiteral, OpCharClass\n-\tRune0    [2]int     // storage for short Rune\n+\tRune     []rune     // matched runes, for OpLiteral, OpCharClass\n+\tRune0    [2]rune    // storage for short Rune\n \tMin, Max int        // min, max for OpRepeat\n \tCap      int        // capturing index, for OpCapture\n \tName     string     // capturing name, for OpCapture\n@@ -252,7 +252,7 @@ func (re *Regexp) String() string {\n \n const meta = `\\.+*?()|[]{}^$`\n \n-func escape(b *bytes.Buffer, r int, force bool) {\n+func escape(b *bytes.Buffer, r rune, force bool) {\n \tif unicode.IsPrint(r) {\n \t\tif strings.IndexRune(meta, r) >= 0 || force {\n \t\t\tb.WriteRune('\\\\')\n@@ -277,15 +277,15 @@ func escape(b *bytes.Buffer, r int, force bool) {\n \tdefault:\n \t\tif r < 0x100 {\n \t\t\tb.WriteString(`\\x`)\n-\t\t\ts := strconv.Itob(r, 16)\n+\t\t\ts := strconv.Itob(int(r), 16)\n \t\t\tif len(s) == 1 {\n \t\t\t\tb.WriteRune('0')\n \t\t\t}\n \t\t\tb.WriteString(s)\n \t\t\tbreak\n \t\t}\n \t\tb.WriteString(`\\x{`)\n-\t\tb.WriteString(strconv.Itob(r, 16))\n+\t\tb.WriteString(strconv.Itob(int(r), 16))\n \t\tb.WriteString(`}`)\n \t}\n }"}, {"sha": "99253baf3cb7d571ec05d357a3f8b743e103d65b", "filename": "libgo/go/rpc/jsonrpc/all_test.go", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fjsonrpc%2Fall_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -6,6 +6,7 @@ package jsonrpc\n \n import (\n \t\"fmt\"\n+\t\"io\"\n \t\"json\"\n \t\"net\"\n \t\"os\"\n@@ -154,3 +155,67 @@ func TestClient(t *testing.T) {\n \t\tt.Error(\"Div: expected divide by zero error; got\", err)\n \t}\n }\n+\n+func TestMalformedInput(t *testing.T) {\n+\tcli, srv := net.Pipe()\n+\tgo cli.Write([]byte(`{id:1}`)) // invalid json\n+\tServeConn(srv)                 // must return, not loop\n+}\n+\n+func TestUnexpectedError(t *testing.T) {\n+\tcli, srv := myPipe()\n+\tgo cli.PipeWriter.CloseWithError(os.NewError(\"unexpected error!\")) // reader will get this error\n+\tServeConn(srv)                                                     // must return, not loop\n+}\n+\n+// Copied from package net.\n+func myPipe() (*pipe, *pipe) {\n+\tr1, w1 := io.Pipe()\n+\tr2, w2 := io.Pipe()\n+\n+\treturn &pipe{r1, w2}, &pipe{r2, w1}\n+}\n+\n+type pipe struct {\n+\t*io.PipeReader\n+\t*io.PipeWriter\n+}\n+\n+type pipeAddr int\n+\n+func (pipeAddr) Network() string {\n+\treturn \"pipe\"\n+}\n+\n+func (pipeAddr) String() string {\n+\treturn \"pipe\"\n+}\n+\n+func (p *pipe) Close() os.Error {\n+\terr := p.PipeReader.Close()\n+\terr1 := p.PipeWriter.Close()\n+\tif err == nil {\n+\t\terr = err1\n+\t}\n+\treturn err\n+}\n+\n+func (p *pipe) LocalAddr() net.Addr {\n+\treturn pipeAddr(0)\n+}\n+\n+func (p *pipe) RemoteAddr() net.Addr {\n+\treturn pipeAddr(0)\n+}\n+\n+func (p *pipe) SetTimeout(nsec int64) os.Error {\n+\treturn os.NewError(\"net.Pipe does not support timeouts\")\n+}\n+\n+func (p *pipe) SetReadTimeout(nsec int64) os.Error {\n+\treturn os.NewError(\"net.Pipe does not support timeouts\")\n+}\n+\n+func (p *pipe) SetWriteTimeout(nsec int64) os.Error {\n+\treturn os.NewError(\"net.Pipe does not support timeouts\")\n+}"}, {"sha": "71797e2e5a9f678c8ee28dde207acc888eb43cca", "filename": "libgo/go/rpc/server.go", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -116,8 +116,8 @@ import (\n \t\"bufio\"\n \t\"gob\"\n \t\"http\"\n-\t\"log\"\n \t\"io\"\n+\t\"log\"\n \t\"net\"\n \t\"os\"\n \t\"reflect\"\n@@ -394,12 +394,12 @@ func (server *Server) ServeConn(conn io.ReadWriteCloser) {\n func (server *Server) ServeCodec(codec ServerCodec) {\n \tsending := new(sync.Mutex)\n \tfor {\n-\t\tservice, mtype, req, argv, replyv, err := server.readRequest(codec)\n+\t\tservice, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)\n \t\tif err != nil {\n \t\t\tif err != os.EOF {\n \t\t\t\tlog.Println(\"rpc:\", err)\n \t\t\t}\n-\t\t\tif err == os.EOF || err == io.ErrUnexpectedEOF {\n+\t\t\tif !keepReading {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\t// send a response if we actually managed to read a header.\n@@ -418,9 +418,9 @@ func (server *Server) ServeCodec(codec ServerCodec) {\n // It does not close the codec upon completion.\n func (server *Server) ServeRequest(codec ServerCodec) os.Error {\n \tsending := new(sync.Mutex)\n-\tservice, mtype, req, argv, replyv, err := server.readRequest(codec)\n+\tservice, mtype, req, argv, replyv, keepReading, err := server.readRequest(codec)\n \tif err != nil {\n-\t\tif err == os.EOF || err == io.ErrUnexpectedEOF {\n+\t\tif !keepReading {\n \t\t\treturn err\n \t\t}\n \t\t// send a response if we actually managed to read a header.\n@@ -474,10 +474,10 @@ func (server *Server) freeResponse(resp *Response) {\n \tserver.respLock.Unlock()\n }\n \n-func (server *Server) readRequest(codec ServerCodec) (service *service, mtype *methodType, req *Request, argv, replyv reflect.Value, err os.Error) {\n-\tservice, mtype, req, err = server.readRequestHeader(codec)\n+func (server *Server) readRequest(codec ServerCodec) (service *service, mtype *methodType, req *Request, argv, replyv reflect.Value, keepReading bool, err os.Error) {\n+\tservice, mtype, req, keepReading, err = server.readRequestHeader(codec)\n \tif err != nil {\n-\t\tif err == os.EOF || err == io.ErrUnexpectedEOF {\n+\t\tif !keepReading {\n \t\t\treturn\n \t\t}\n \t\t// discard body\n@@ -505,7 +505,7 @@ func (server *Server) readRequest(codec ServerCodec) (service *service, mtype *m\n \treturn\n }\n \n-func (server *Server) readRequestHeader(codec ServerCodec) (service *service, mtype *methodType, req *Request, err os.Error) {\n+func (server *Server) readRequestHeader(codec ServerCodec) (service *service, mtype *methodType, req *Request, keepReading bool, err os.Error) {\n \t// Grab the request header.\n \treq = server.getRequest()\n \terr = codec.ReadRequestHeader(req)\n@@ -518,6 +518,10 @@ func (server *Server) readRequestHeader(codec ServerCodec) (service *service, mt\n \t\treturn\n \t}\n \n+\t// We read the header successfully.  If we see an error now,\n+\t// we can still recover and move on to the next request.\n+\tkeepReading = true\n+\n \tserviceMethod := strings.Split(req.ServiceMethod, \".\")\n \tif len(serviceMethod) != 2 {\n \t\terr = os.NewError(\"rpc: service/method request ill-formed: \" + req.ServiceMethod)"}, {"sha": "3e9fe297d4502cf148d5f208455a6d48db2595f4", "filename": "libgo/go/rpc/server_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -311,8 +311,9 @@ func (codec *CodecEmulator) ReadRequestBody(argv interface{}) os.Error {\n func (codec *CodecEmulator) WriteResponse(resp *Response, reply interface{}) os.Error {\n \tif resp.Error != \"\" {\n \t\tcodec.err = os.NewError(resp.Error)\n+\t} else {\n+\t\t*codec.reply = *(reply.(*Reply))\n \t}\n-\t*codec.reply = *(reply.(*Reply))\n \treturn nil\n }\n "}, {"sha": "124370384c095ebfc46f5059ef89a50913021b01", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -10,7 +10,6 @@ func Breakpoint()\n // LockOSThread wires the calling goroutine to its current operating system thread.\n // Until the calling goroutine exits or calls UnlockOSThread, it will always\n // execute in that thread, and no other goroutine can.\n-// LockOSThread cannot be used during init functions.\n func LockOSThread()\n \n // UnlockOSThread unwires the calling goroutine from its fixed operating system thread."}, {"sha": "702289645450d512c5d14804e88c0f962270abfb", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -17,6 +17,9 @@ import (\n \t\"sync\"\n )\n \n+// BUG(rsc): CPU profiling is broken on OS X, due to an Apple kernel bug.\n+// For details, see http://code.google.com/p/go/source/detail?r=35b716c94225.\n+\n // WriteHeapProfile writes a pprof-formatted heap profile to w.\n // If a write to w returns an error, WriteHeapProfile returns that error.\n // Otherwise, WriteHeapProfile returns nil."}, {"sha": "3594db997dd8c1e0beedfaf77f97d2118c686182", "filename": "libgo/go/scanner/scanner.go", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fscanner%2Fscanner.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -93,7 +93,7 @@ const (\n \tskipComment\n )\n \n-var tokenString = map[int]string{\n+var tokenString = map[rune]string{\n \tEOF:       \"EOF\",\n \tIdent:     \"Ident\",\n \tInt:       \"Int\",\n@@ -105,7 +105,7 @@ var tokenString = map[int]string{\n }\n \n // TokenString returns a (visible) string for a token or Unicode character.\n-func TokenString(tok int) string {\n+func TokenString(tok rune) string {\n \tif s, found := tokenString[tok]; found {\n \t\treturn s\n \t}\n@@ -144,7 +144,7 @@ type Scanner struct {\n \ttokEnd int          // token text tail end (srcBuf index)\n \n \t// One character look-ahead\n-\tch int // character before current srcPos\n+\tch rune // character before current srcPos\n \n \t// Error is called for each error encountered. If no Error\n \t// function is set, the error is reported to os.Stderr.\n@@ -218,8 +218,8 @@ func (s *Scanner) Init(src io.Reader) *Scanner {\n // that only a minimal amount of work needs to be done in the common ASCII\n // case (one test to check for both ASCII and end-of-buffer, and one test\n // to check for newlines).\n-func (s *Scanner) next() int {\n-\tch, width := int(s.srcBuf[s.srcPos]), 1\n+func (s *Scanner) next() rune {\n+\tch, width := rune(s.srcBuf[s.srcPos]), 1\n \n \tif ch >= utf8.RuneSelf {\n \t\t// uncommon case: not ASCII or not enough bytes\n@@ -264,7 +264,7 @@ func (s *Scanner) next() int {\n \t\t\t}\n \t\t}\n \t\t// at least one byte\n-\t\tch = int(s.srcBuf[s.srcPos])\n+\t\tch = rune(s.srcBuf[s.srcPos])\n \t\tif ch >= utf8.RuneSelf {\n \t\t\t// uncommon case: not ASCII\n \t\t\tch, width = utf8.DecodeRune(s.srcBuf[s.srcPos:s.srcEnd])\n@@ -304,7 +304,7 @@ func (s *Scanner) next() int {\n // it prints an error message to os.Stderr. Next does not\n // update the Scanner's Position field; use Pos() to\n // get the current position.\n-func (s *Scanner) Next() int {\n+func (s *Scanner) Next() rune {\n \ts.tokPos = -1 // don't collect token text\n \ts.Line = 0    // invalidate token position\n \tch := s.Peek()\n@@ -315,7 +315,7 @@ func (s *Scanner) Next() int {\n // Peek returns the next Unicode character in the source without advancing\n // the scanner. It returns EOF if the scanner's position is at the last\n // character of the source.\n-func (s *Scanner) Peek() int {\n+func (s *Scanner) Peek() rune {\n \tif s.ch < 0 {\n \t\ts.ch = s.next()\n \t}\n@@ -335,43 +335,43 @@ func (s *Scanner) error(msg string) {\n \tfmt.Fprintf(os.Stderr, \"%s: %s\\n\", pos, msg)\n }\n \n-func (s *Scanner) scanIdentifier() int {\n+func (s *Scanner) scanIdentifier() rune {\n \tch := s.next() // read character after first '_' or letter\n \tfor ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch) {\n \t\tch = s.next()\n \t}\n \treturn ch\n }\n \n-func digitVal(ch int) int {\n+func digitVal(ch rune) int {\n \tswitch {\n \tcase '0' <= ch && ch <= '9':\n-\t\treturn ch - '0'\n+\t\treturn int(ch - '0')\n \tcase 'a' <= ch && ch <= 'f':\n-\t\treturn ch - 'a' + 10\n+\t\treturn int(ch - 'a' + 10)\n \tcase 'A' <= ch && ch <= 'F':\n-\t\treturn ch - 'A' + 10\n+\t\treturn int(ch - 'A' + 10)\n \t}\n \treturn 16 // larger than any legal digit val\n }\n \n-func isDecimal(ch int) bool { return '0' <= ch && ch <= '9' }\n+func isDecimal(ch rune) bool { return '0' <= ch && ch <= '9' }\n \n-func (s *Scanner) scanMantissa(ch int) int {\n+func (s *Scanner) scanMantissa(ch rune) rune {\n \tfor isDecimal(ch) {\n \t\tch = s.next()\n \t}\n \treturn ch\n }\n \n-func (s *Scanner) scanFraction(ch int) int {\n+func (s *Scanner) scanFraction(ch rune) rune {\n \tif ch == '.' {\n \t\tch = s.scanMantissa(s.next())\n \t}\n \treturn ch\n }\n \n-func (s *Scanner) scanExponent(ch int) int {\n+func (s *Scanner) scanExponent(ch rune) rune {\n \tif ch == 'e' || ch == 'E' {\n \t\tch = s.next()\n \t\tif ch == '-' || ch == '+' {\n@@ -382,7 +382,7 @@ func (s *Scanner) scanExponent(ch int) int {\n \treturn ch\n }\n \n-func (s *Scanner) scanNumber(ch int) (int, int) {\n+func (s *Scanner) scanNumber(ch rune) (rune, rune) {\n \t// isDecimal(ch)\n \tif ch == '0' {\n \t\t// int or float\n@@ -426,7 +426,7 @@ func (s *Scanner) scanNumber(ch int) (int, int) {\n \treturn Int, ch\n }\n \n-func (s *Scanner) scanDigits(ch, base, n int) int {\n+func (s *Scanner) scanDigits(ch rune, base, n int) rune {\n \tfor n > 0 && digitVal(ch) < base {\n \t\tch = s.next()\n \t\tn--\n@@ -437,7 +437,7 @@ func (s *Scanner) scanDigits(ch, base, n int) int {\n \treturn ch\n }\n \n-func (s *Scanner) scanEscape(quote int) int {\n+func (s *Scanner) scanEscape(quote rune) rune {\n \tch := s.next() // read character after '/'\n \tswitch ch {\n \tcase 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\\\', quote:\n@@ -457,7 +457,7 @@ func (s *Scanner) scanEscape(quote int) int {\n \treturn ch\n }\n \n-func (s *Scanner) scanString(quote int) (n int) {\n+func (s *Scanner) scanString(quote rune) (n int) {\n \tch := s.next() // read character after quote\n \tfor ch != quote {\n \t\tif ch == '\\n' || ch < 0 {\n@@ -491,7 +491,7 @@ func (s *Scanner) scanChar() {\n \t}\n }\n \n-func (s *Scanner) scanComment(ch int) int {\n+func (s *Scanner) scanComment(ch rune) rune {\n \t// ch == '/' || ch == '*'\n \tif ch == '/' {\n \t\t// line comment\n@@ -524,7 +524,7 @@ func (s *Scanner) scanComment(ch int) int {\n // It returns EOF at the end of the source. It reports scanner errors (read and\n // token errors) by calling s.Error, if not nil; otherwise it prints an error\n // message to os.Stderr.\n-func (s *Scanner) Scan() int {\n+func (s *Scanner) Scan() rune {\n \tch := s.Peek()\n \n \t// reset token text position"}, {"sha": "fb398831e10f0e2dd121f7b70816da5486ff7dc1", "filename": "libgo/go/scanner/scanner_test.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -64,7 +64,7 @@ func TestNext(t *testing.T) {\n }\n \n type token struct {\n-\ttok  int\n+\ttok  rune\n \ttext string\n }\n \n@@ -233,7 +233,7 @@ func makeSource(pattern string) *bytes.Buffer {\n \treturn &buf\n }\n \n-func checkTok(t *testing.T, s *Scanner, line, got, want int, text string) {\n+func checkTok(t *testing.T, s *Scanner, line int, got, want rune, text string) {\n \tif got != want {\n \t\tt.Fatalf(\"tok = %s, want %s for %q\", TokenString(got), TokenString(want), text)\n \t}\n@@ -329,7 +329,7 @@ func TestScanZeroMode(t *testing.T) {\n \t}\n }\n \n-func testScanSelectedMode(t *testing.T, mode uint, class int) {\n+func testScanSelectedMode(t *testing.T, mode uint, class rune) {\n \tsrc := makeSource(\"%s\\n\")\n \ts := new(Scanner).Init(src)\n \ts.Mode = mode\n@@ -398,7 +398,7 @@ func TestScanWhitespace(t *testing.T) {\n \t}\n }\n \n-func testError(t *testing.T, src, pos, msg string, tok int) {\n+func testError(t *testing.T, src, pos, msg string, tok rune) {\n \ts := new(Scanner).Init(bytes.NewBufferString(src))\n \terrorCalled := false\n \ts.Error = func(s *Scanner, m string) {\n@@ -463,15 +463,15 @@ func checkPos(t *testing.T, got, want Position) {\n \t}\n }\n \n-func checkNextPos(t *testing.T, s *Scanner, offset, line, column, char int) {\n+func checkNextPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n \tif ch := s.Next(); ch != char {\n \t\tt.Errorf(\"ch = %s, want %s\", TokenString(ch), TokenString(char))\n \t}\n \twant := Position{Offset: offset, Line: line, Column: column}\n \tcheckPos(t, s.Pos(), want)\n }\n \n-func checkScanPos(t *testing.T, s *Scanner, offset, line, column, char int) {\n+func checkScanPos(t *testing.T, s *Scanner, offset, line, column int, char rune) {\n \twant := Position{Offset: offset, Line: line, Column: column}\n \tcheckPos(t, s.Pos(), want)\n \tif ch := s.Scan(); ch != char {"}, {"sha": "553d3ae0991985c765f126d76610ec55f0413691", "filename": "libgo/go/smtp/smtp_test.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fsmtp%2Fsmtp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fsmtp%2Fsmtp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsmtp%2Fsmtp_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -37,14 +37,14 @@ testLoop:\n \t\t\tt.Errorf(\"#%d got response %s, expected %s\", i, resp, test.responses[0])\n \t\t}\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"#%d error: %s\", i, err.String())\n+\t\t\tt.Errorf(\"#%d error: %s\", i, err)\n \t\t}\n \t\tfor j := range test.challenges {\n \t\t\tchallenge := []byte(test.challenges[j])\n \t\t\texpected := []byte(test.responses[j+1])\n \t\t\tresp, err := test.auth.Next(challenge, true)\n \t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"#%d error: %s\", i, err.String())\n+\t\t\t\tt.Errorf(\"#%d error: %s\", i, err)\n \t\t\t\tcontinue testLoop\n \t\t\t}\n \t\t\tif !bytes.Equal(resp, expected) {\n@@ -74,13 +74,13 @@ func TestBasic(t *testing.T) {\n \tc := &Client{Text: textproto.NewConn(fake)}\n \n \tif err := c.helo(); err != nil {\n-\t\tt.Fatalf(\"HELO failed: %s\", err.String())\n+\t\tt.Fatalf(\"HELO failed: %s\", err)\n \t}\n \tif err := c.ehlo(); err == nil {\n \t\tt.Fatalf(\"Expected first EHLO to fail\")\n \t}\n \tif err := c.ehlo(); err != nil {\n-\t\tt.Fatalf(\"Second EHLO failed: %s\", err.String())\n+\t\tt.Fatalf(\"Second EHLO failed: %s\", err)\n \t}\n \n \tif ok, args := c.Extension(\"aUtH\"); !ok || args != \"LOGIN PLAIN\" {\n@@ -105,14 +105,14 @@ func TestBasic(t *testing.T) {\n \tc.tls = true\n \tc.serverName = \"smtp.google.com\"\n \tif err := c.Auth(PlainAuth(\"\", \"user\", \"pass\", \"smtp.google.com\")); err != nil {\n-\t\tt.Fatalf(\"AUTH failed: %s\", err.String())\n+\t\tt.Fatalf(\"AUTH failed: %s\", err)\n \t}\n \n \tif err := c.Mail(\"user@gmail.com\"); err != nil {\n-\t\tt.Fatalf(\"MAIL failed: %s\", err.String())\n+\t\tt.Fatalf(\"MAIL failed: %s\", err)\n \t}\n \tif err := c.Rcpt(\"golang-nuts@googlegroups.com\"); err != nil {\n-\t\tt.Fatalf(\"RCPT failed: %s\", err.String())\n+\t\tt.Fatalf(\"RCPT failed: %s\", err)\n \t}\n \tmsg := `From: user@gmail.com\n To: golang-nuts@googlegroups.com\n@@ -123,17 +123,17 @@ Line 1\n Goodbye.`\n \tw, err := c.Data()\n \tif err != nil {\n-\t\tt.Fatalf(\"DATA failed: %s\", err.String())\n+\t\tt.Fatalf(\"DATA failed: %s\", err)\n \t}\n \tif _, err := w.Write([]byte(msg)); err != nil {\n-\t\tt.Fatalf(\"Data write failed: %s\", err.String())\n+\t\tt.Fatalf(\"Data write failed: %s\", err)\n \t}\n \tif err := w.Close(); err != nil {\n-\t\tt.Fatalf(\"Bad data response: %s\", err.String())\n+\t\tt.Fatalf(\"Bad data response: %s\", err)\n \t}\n \n \tif err := c.Quit(); err != nil {\n-\t\tt.Fatalf(\"QUIT failed: %s\", err.String())\n+\t\tt.Fatalf(\"QUIT failed: %s\", err)\n \t}\n \n \tbcmdbuf.Flush()"}, {"sha": "720819490cb1742f4d50b31c08c9f866fb83909c", "filename": "libgo/go/strconv/atob.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatob.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatob.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatob.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -16,7 +16,7 @@ func Atob(str string) (value bool, err os.Error) {\n \tcase \"0\", \"f\", \"F\", \"false\", \"FALSE\", \"False\":\n \t\treturn false, nil\n \t}\n-\treturn false, &NumError{str, os.EINVAL}\n+\treturn false, &NumError{str, ErrSyntax}\n }\n \n // Btoa returns \"true\" or \"false\" according to the value of the boolean argument"}, {"sha": "d9db6c7c0afc81cfb94a9580355cec6a858c3fd3", "filename": "libgo/go/strconv/atob_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatob_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatob_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatob_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -17,8 +17,8 @@ type atobTest struct {\n }\n \n var atobtests = []atobTest{\n-\t{\"\", false, os.EINVAL},\n-\t{\"asdf\", false, os.EINVAL},\n+\t{\"\", false, ErrSyntax},\n+\t{\"asdf\", false, ErrSyntax},\n \t{\"0\", false, nil},\n \t{\"f\", false, nil},\n \t{\"F\", false, nil},"}, {"sha": "4a4b1b43ce25656593dbc011e8840ba25d068208", "filename": "libgo/go/strconv/atof.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -350,19 +350,19 @@ func (d *decimal) atof32() (f float32, ok bool) {\n // The errors that Atof32 returns have concrete type *NumError\n // and include err.Num = s.\n //\n-// If s is not syntactically well-formed, Atof32 returns err.Error = os.EINVAL.\n+// If s is not syntactically well-formed, Atof32 returns err.Error = ErrSyntax.\n //\n // If s is syntactically well-formed but is more than 1/2 ULP\n // away from the largest floating point number of the given size,\n-// Atof32 returns f = \u00b1Inf, err.Error = os.ERANGE.\n+// Atof32 returns f = \u00b1Inf, err.Error = ErrRange.\n func Atof32(s string) (f float32, err os.Error) {\n \tif val, ok := special(s); ok {\n \t\treturn float32(val), nil\n \t}\n \n \tvar d decimal\n \tif !d.set(s) {\n-\t\treturn 0, &NumError{s, os.EINVAL}\n+\t\treturn 0, &NumError{s, ErrSyntax}\n \t}\n \tif optimize {\n \t\tif f, ok := d.atof32(); ok {\n@@ -372,7 +372,7 @@ func Atof32(s string) (f float32, err os.Error) {\n \tb, ovf := d.floatBits(&float32info)\n \tf = math.Float32frombits(uint32(b))\n \tif ovf {\n-\t\terr = &NumError{s, os.ERANGE}\n+\t\terr = &NumError{s, ErrRange}\n \t}\n \treturn f, err\n }\n@@ -387,7 +387,7 @@ func Atof64(s string) (f float64, err os.Error) {\n \n \tvar d decimal\n \tif !d.set(s) {\n-\t\treturn 0, &NumError{s, os.EINVAL}\n+\t\treturn 0, &NumError{s, ErrSyntax}\n \t}\n \tif optimize {\n \t\tif f, ok := d.atof64(); ok {\n@@ -397,7 +397,7 @@ func Atof64(s string) (f float64, err os.Error) {\n \tb, ovf := d.floatBits(&float64info)\n \tf = math.Float64frombits(b)\n \tif ovf {\n-\t\terr = &NumError{s, os.ERANGE}\n+\t\terr = &NumError{s, ErrRange}\n \t}\n \treturn f, err\n }"}, {"sha": "33f881c7fd6f23b3d1072a26230e3881a098d298", "filename": "libgo/go/strconv/atof_test.go", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatof_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -18,11 +18,11 @@ type atofTest struct {\n }\n \n var atoftests = []atofTest{\n-\t{\"\", \"0\", os.EINVAL},\n+\t{\"\", \"0\", ErrSyntax},\n \t{\"1\", \"1\", nil},\n \t{\"+1\", \"1\", nil},\n-\t{\"1x\", \"0\", os.EINVAL},\n-\t{\"1.1.\", \"0\", os.EINVAL},\n+\t{\"1x\", \"0\", ErrSyntax},\n+\t{\"1.1.\", \"0\", ErrSyntax},\n \t{\"1e23\", \"1e+23\", nil},\n \t{\"1E23\", \"1e+23\", nil},\n \t{\"100000000000000000000000\", \"1e+23\", nil},\n@@ -56,28 +56,28 @@ var atoftests = []atofTest{\n \t{\"1.7976931348623157e308\", \"1.7976931348623157e+308\", nil},\n \t{\"-1.7976931348623157e308\", \"-1.7976931348623157e+308\", nil},\n \t// next float64 - too large\n-\t{\"1.7976931348623159e308\", \"+Inf\", os.ERANGE},\n-\t{\"-1.7976931348623159e308\", \"-Inf\", os.ERANGE},\n+\t{\"1.7976931348623159e308\", \"+Inf\", ErrRange},\n+\t{\"-1.7976931348623159e308\", \"-Inf\", ErrRange},\n \t// the border is ...158079\n \t// borderline - okay\n \t{\"1.7976931348623158e308\", \"1.7976931348623157e+308\", nil},\n \t{\"-1.7976931348623158e308\", \"-1.7976931348623157e+308\", nil},\n \t// borderline - too large\n-\t{\"1.797693134862315808e308\", \"+Inf\", os.ERANGE},\n-\t{\"-1.797693134862315808e308\", \"-Inf\", os.ERANGE},\n+\t{\"1.797693134862315808e308\", \"+Inf\", ErrRange},\n+\t{\"-1.797693134862315808e308\", \"-Inf\", ErrRange},\n \n \t// a little too large\n \t{\"1e308\", \"1e+308\", nil},\n-\t{\"2e308\", \"+Inf\", os.ERANGE},\n-\t{\"1e309\", \"+Inf\", os.ERANGE},\n+\t{\"2e308\", \"+Inf\", ErrRange},\n+\t{\"1e309\", \"+Inf\", ErrRange},\n \n \t// way too large\n-\t{\"1e310\", \"+Inf\", os.ERANGE},\n-\t{\"-1e310\", \"-Inf\", os.ERANGE},\n-\t{\"1e400\", \"+Inf\", os.ERANGE},\n-\t{\"-1e400\", \"-Inf\", os.ERANGE},\n-\t{\"1e400000\", \"+Inf\", os.ERANGE},\n-\t{\"-1e400000\", \"-Inf\", os.ERANGE},\n+\t{\"1e310\", \"+Inf\", ErrRange},\n+\t{\"-1e310\", \"-Inf\", ErrRange},\n+\t{\"1e400\", \"+Inf\", ErrRange},\n+\t{\"-1e400\", \"-Inf\", ErrRange},\n+\t{\"1e400000\", \"+Inf\", ErrRange},\n+\t{\"-1e400000\", \"-Inf\", ErrRange},\n \n \t// denormalized\n \t{\"1e-305\", \"1e-305\", nil},\n@@ -99,14 +99,14 @@ var atoftests = []atofTest{\n \n \t// try to overflow exponent\n \t{\"1e-4294967296\", \"0\", nil},\n-\t{\"1e+4294967296\", \"+Inf\", os.ERANGE},\n+\t{\"1e+4294967296\", \"+Inf\", ErrRange},\n \t{\"1e-18446744073709551616\", \"0\", nil},\n-\t{\"1e+18446744073709551616\", \"+Inf\", os.ERANGE},\n+\t{\"1e+18446744073709551616\", \"+Inf\", ErrRange},\n \n \t// Parse errors\n-\t{\"1e\", \"0\", os.EINVAL},\n-\t{\"1e-\", \"0\", os.EINVAL},\n-\t{\".e-1\", \"0\", os.EINVAL},\n+\t{\"1e\", \"0\", ErrSyntax},\n+\t{\"1e-\", \"0\", ErrSyntax},\n+\t{\".e-1\", \"0\", ErrSyntax},\n \n \t// http://www.exploringbinary.com/java-hangs-when-converting-2-2250738585072012e-308/\n \t{\"2.2250738585072012e-308\", \"2.2250738585072014e-308\", nil},"}, {"sha": "92ba89daea4586e19c8b7beebf15f6dd94316fbd", "filename": "libgo/go/strconv/atoi.go", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatoi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatoi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatoi.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -6,9 +6,16 @@ package strconv\n \n import \"os\"\n \n+// ErrRange indicates that a value is out of range for the target type.\n+var ErrRange = os.NewError(\"value out of range\")\n+\n+// ErrSyntax indicates that a value does not have the right syntax for the target type.\n+var ErrSyntax = os.NewError(\"invalid syntax\")\n+\n+// A NumError records a failed conversion.\n type NumError struct {\n-\tNum   string\n-\tError os.Error\n+\tNum   string   // the input\n+\tError os.Error // the reason the conversion failed (ErrRange, ErrSyntax)\n }\n \n func (e *NumError) String() string { return `parsing \"` + e.Num + `\": ` + e.Error.String() }\n@@ -38,15 +45,15 @@ func cutoff64(base int) uint64 {\n //\n // The errors that Btoui64 returns have concrete type *NumError\n // and include err.Num = s.  If s is empty or contains invalid\n-// digits, err.Error = os.EINVAL; if the value corresponding\n-// to s cannot be represented by a uint64, err.Error = os.ERANGE.\n+// digits, err.Error = ErrSyntax; if the value corresponding\n+// to s cannot be represented by a uint64, err.Error = ErrRange.\n func Btoui64(s string, b int) (n uint64, err os.Error) {\n \tvar cutoff uint64\n \n \ts0 := s\n \tswitch {\n \tcase len(s) < 1:\n-\t\terr = os.EINVAL\n+\t\terr = ErrSyntax\n \t\tgoto Error\n \n \tcase 2 <= b && b <= 36:\n@@ -59,7 +66,7 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {\n \t\t\tb = 16\n \t\t\ts = s[2:]\n \t\t\tif len(s) < 1 {\n-\t\t\t\terr = os.EINVAL\n+\t\t\t\terr = ErrSyntax\n \t\t\t\tgoto Error\n \t\t\t}\n \t\tcase s[0] == '0':\n@@ -88,19 +95,19 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {\n \t\t\tv = d - 'A' + 10\n \t\tdefault:\n \t\t\tn = 0\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\tgoto Error\n \t\t}\n \t\tif int(v) >= b {\n \t\t\tn = 0\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\tgoto Error\n \t\t}\n \n \t\tif n >= cutoff {\n \t\t\t// n*b overflows\n \t\t\tn = 1<<64 - 1\n-\t\t\terr = os.ERANGE\n+\t\t\terr = ErrRange\n \t\t\tgoto Error\n \t\t}\n \t\tn *= uint64(b)\n@@ -109,7 +116,7 @@ func Btoui64(s string, b int) (n uint64, err os.Error) {\n \t\tif n1 < n {\n \t\t\t// n+v overflows\n \t\t\tn = 1<<64 - 1\n-\t\t\terr = os.ERANGE\n+\t\t\terr = ErrRange\n \t\t\tgoto Error\n \t\t}\n \t\tn = n1\n@@ -124,8 +131,8 @@ Error:\n // Atoui64 interprets a string s as a decimal number and\n // returns the corresponding value n.\n //\n-// Atoui64 returns err == os.EINVAL if s is empty or contains invalid digits.\n-// It returns err == os.ERANGE if s cannot be represented by a uint64.\n+// Atoui64 returns err.Error = ErrSyntax if s is empty or contains invalid digits.\n+// It returns err.Error = ErrRange if s cannot be represented by a uint64.\n func Atoui64(s string) (n uint64, err os.Error) {\n \treturn Btoui64(s, 10)\n }\n@@ -135,7 +142,7 @@ func Atoui64(s string) (n uint64, err os.Error) {\n func Btoi64(s string, base int) (i int64, err os.Error) {\n \t// Empty string bad.\n \tif len(s) == 0 {\n-\t\treturn 0, &NumError{s, os.EINVAL}\n+\t\treturn 0, &NumError{s, ErrSyntax}\n \t}\n \n \t// Pick off leading sign.\n@@ -151,15 +158,15 @@ func Btoi64(s string, base int) (i int64, err os.Error) {\n \t// Convert unsigned and check range.\n \tvar un uint64\n \tun, err = Btoui64(s, base)\n-\tif err != nil && err.(*NumError).Error != os.ERANGE {\n+\tif err != nil && err.(*NumError).Error != ErrRange {\n \t\terr.(*NumError).Num = s0\n \t\treturn 0, err\n \t}\n \tif !neg && un >= 1<<63 {\n-\t\treturn 1<<63 - 1, &NumError{s0, os.ERANGE}\n+\t\treturn 1<<63 - 1, &NumError{s0, ErrRange}\n \t}\n \tif neg && un > 1<<63 {\n-\t\treturn -1 << 63, &NumError{s0, os.ERANGE}\n+\t\treturn -1 << 63, &NumError{s0, ErrRange}\n \t}\n \tn := int64(un)\n \tif neg {\n@@ -175,28 +182,28 @@ func Atoi64(s string) (i int64, err os.Error) { return Btoi64(s, 10) }\n // Atoui is like Atoui64 but returns its result as a uint.\n func Atoui(s string) (i uint, err os.Error) {\n \ti1, e1 := Atoui64(s)\n-\tif e1 != nil && e1.(*NumError).Error != os.ERANGE {\n+\tif e1 != nil && e1.(*NumError).Error != ErrRange {\n \t\treturn 0, e1\n \t}\n \ti = uint(i1)\n \tif uint64(i) != i1 {\n-\t\treturn ^uint(0), &NumError{s, os.ERANGE}\n+\t\treturn ^uint(0), &NumError{s, ErrRange}\n \t}\n \treturn i, nil\n }\n \n // Atoi is like Atoi64 but returns its result as an int.\n func Atoi(s string) (i int, err os.Error) {\n \ti1, e1 := Atoi64(s)\n-\tif e1 != nil && e1.(*NumError).Error != os.ERANGE {\n+\tif e1 != nil && e1.(*NumError).Error != ErrRange {\n \t\treturn 0, e1\n \t}\n \ti = int(i1)\n \tif int64(i) != i1 {\n \t\tif i1 < 0 {\n-\t\t\treturn -1 << (IntSize - 1), &NumError{s, os.ERANGE}\n+\t\t\treturn -1 << (IntSize - 1), &NumError{s, ErrRange}\n \t\t}\n-\t\treturn 1<<(IntSize-1) - 1, &NumError{s, os.ERANGE}\n+\t\treturn 1<<(IntSize-1) - 1, &NumError{s, ErrRange}\n \t}\n \treturn i, nil\n }"}, {"sha": "0d2e38117a367baffe3492fec801c394b90726df", "filename": "libgo/go/strconv/atoi_test.go", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatoi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fatoi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fatoi_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -18,36 +18,36 @@ type atoui64Test struct {\n }\n \n var atoui64tests = []atoui64Test{\n-\t{\"\", 0, os.EINVAL},\n+\t{\"\", 0, ErrSyntax},\n \t{\"0\", 0, nil},\n \t{\"1\", 1, nil},\n \t{\"12345\", 12345, nil},\n \t{\"012345\", 12345, nil},\n-\t{\"12345x\", 0, os.EINVAL},\n+\t{\"12345x\", 0, ErrSyntax},\n \t{\"98765432100\", 98765432100, nil},\n \t{\"18446744073709551615\", 1<<64 - 1, nil},\n-\t{\"18446744073709551616\", 1<<64 - 1, os.ERANGE},\n-\t{\"18446744073709551620\", 1<<64 - 1, os.ERANGE},\n+\t{\"18446744073709551616\", 1<<64 - 1, ErrRange},\n+\t{\"18446744073709551620\", 1<<64 - 1, ErrRange},\n }\n \n var btoui64tests = []atoui64Test{\n-\t{\"\", 0, os.EINVAL},\n+\t{\"\", 0, ErrSyntax},\n \t{\"0\", 0, nil},\n \t{\"1\", 1, nil},\n \t{\"12345\", 12345, nil},\n \t{\"012345\", 012345, nil},\n \t{\"0x12345\", 0x12345, nil},\n \t{\"0X12345\", 0x12345, nil},\n-\t{\"12345x\", 0, os.EINVAL},\n+\t{\"12345x\", 0, ErrSyntax},\n \t{\"98765432100\", 98765432100, nil},\n \t{\"18446744073709551615\", 1<<64 - 1, nil},\n-\t{\"18446744073709551616\", 1<<64 - 1, os.ERANGE},\n-\t{\"18446744073709551620\", 1<<64 - 1, os.ERANGE},\n+\t{\"18446744073709551616\", 1<<64 - 1, ErrRange},\n+\t{\"18446744073709551620\", 1<<64 - 1, ErrRange},\n \t{\"0xFFFFFFFFFFFFFFFF\", 1<<64 - 1, nil},\n-\t{\"0x10000000000000000\", 1<<64 - 1, os.ERANGE},\n+\t{\"0x10000000000000000\", 1<<64 - 1, ErrRange},\n \t{\"01777777777777777777777\", 1<<64 - 1, nil},\n-\t{\"01777777777777777777778\", 0, os.EINVAL},\n-\t{\"02000000000000000000000\", 1<<64 - 1, os.ERANGE},\n+\t{\"01777777777777777777778\", 0, ErrSyntax},\n+\t{\"02000000000000000000000\", 1<<64 - 1, ErrRange},\n \t{\"0200000000000000000000\", 1 << 61, nil},\n }\n \n@@ -58,7 +58,7 @@ type atoi64Test struct {\n }\n \n var atoi64tests = []atoi64Test{\n-\t{\"\", 0, os.EINVAL},\n+\t{\"\", 0, ErrSyntax},\n \t{\"0\", 0, nil},\n \t{\"-0\", 0, nil},\n \t{\"1\", 1, nil},\n@@ -71,14 +71,14 @@ var atoi64tests = []atoi64Test{\n \t{\"-98765432100\", -98765432100, nil},\n \t{\"9223372036854775807\", 1<<63 - 1, nil},\n \t{\"-9223372036854775807\", -(1<<63 - 1), nil},\n-\t{\"9223372036854775808\", 1<<63 - 1, os.ERANGE},\n+\t{\"9223372036854775808\", 1<<63 - 1, ErrRange},\n \t{\"-9223372036854775808\", -1 << 63, nil},\n-\t{\"9223372036854775809\", 1<<63 - 1, os.ERANGE},\n-\t{\"-9223372036854775809\", -1 << 63, os.ERANGE},\n+\t{\"9223372036854775809\", 1<<63 - 1, ErrRange},\n+\t{\"-9223372036854775809\", -1 << 63, ErrRange},\n }\n \n var btoi64tests = []atoi64Test{\n-\t{\"\", 0, os.EINVAL},\n+\t{\"\", 0, ErrSyntax},\n \t{\"0\", 0, nil},\n \t{\"-0\", 0, nil},\n \t{\"1\", 1, nil},\n@@ -89,16 +89,16 @@ var btoi64tests = []atoi64Test{\n \t{\"-012345\", -012345, nil},\n \t{\"0x12345\", 0x12345, nil},\n \t{\"-0X12345\", -0x12345, nil},\n-\t{\"12345x\", 0, os.EINVAL},\n-\t{\"-12345x\", 0, os.EINVAL},\n+\t{\"12345x\", 0, ErrSyntax},\n+\t{\"-12345x\", 0, ErrSyntax},\n \t{\"98765432100\", 98765432100, nil},\n \t{\"-98765432100\", -98765432100, nil},\n \t{\"9223372036854775807\", 1<<63 - 1, nil},\n \t{\"-9223372036854775807\", -(1<<63 - 1), nil},\n-\t{\"9223372036854775808\", 1<<63 - 1, os.ERANGE},\n+\t{\"9223372036854775808\", 1<<63 - 1, ErrRange},\n \t{\"-9223372036854775808\", -1 << 63, nil},\n-\t{\"9223372036854775809\", 1<<63 - 1, os.ERANGE},\n-\t{\"-9223372036854775809\", -1 << 63, os.ERANGE},\n+\t{\"9223372036854775809\", 1<<63 - 1, ErrRange},\n+\t{\"-9223372036854775809\", -1 << 63, ErrRange},\n }\n \n type atoui32Test struct {\n@@ -108,15 +108,15 @@ type atoui32Test struct {\n }\n \n var atoui32tests = []atoui32Test{\n-\t{\"\", 0, os.EINVAL},\n+\t{\"\", 0, ErrSyntax},\n \t{\"0\", 0, nil},\n \t{\"1\", 1, nil},\n \t{\"12345\", 12345, nil},\n \t{\"012345\", 12345, nil},\n-\t{\"12345x\", 0, os.EINVAL},\n+\t{\"12345x\", 0, ErrSyntax},\n \t{\"987654321\", 987654321, nil},\n \t{\"4294967295\", 1<<32 - 1, nil},\n-\t{\"4294967296\", 1<<32 - 1, os.ERANGE},\n+\t{\"4294967296\", 1<<32 - 1, ErrRange},\n }\n \n type atoi32Test struct {\n@@ -126,7 +126,7 @@ type atoi32Test struct {\n }\n \n var atoi32tests = []atoi32Test{\n-\t{\"\", 0, os.EINVAL},\n+\t{\"\", 0, ErrSyntax},\n \t{\"0\", 0, nil},\n \t{\"-0\", 0, nil},\n \t{\"1\", 1, nil},\n@@ -135,16 +135,16 @@ var atoi32tests = []atoi32Test{\n \t{\"-12345\", -12345, nil},\n \t{\"012345\", 12345, nil},\n \t{\"-012345\", -12345, nil},\n-\t{\"12345x\", 0, os.EINVAL},\n-\t{\"-12345x\", 0, os.EINVAL},\n+\t{\"12345x\", 0, ErrSyntax},\n+\t{\"-12345x\", 0, ErrSyntax},\n \t{\"987654321\", 987654321, nil},\n \t{\"-987654321\", -987654321, nil},\n \t{\"2147483647\", 1<<31 - 1, nil},\n \t{\"-2147483647\", -(1<<31 - 1), nil},\n-\t{\"2147483648\", 1<<31 - 1, os.ERANGE},\n+\t{\"2147483648\", 1<<31 - 1, ErrRange},\n \t{\"-2147483648\", -1 << 31, nil},\n-\t{\"2147483649\", 1<<31 - 1, os.ERANGE},\n-\t{\"-2147483649\", -1 << 31, os.ERANGE},\n+\t{\"2147483649\", 1<<31 - 1, ErrRange},\n+\t{\"-2147483649\", -1 << 31, ErrRange},\n }\n \n func init() {"}, {"sha": "991d3ac1e435d14767c7f27cc3162b7d3f31c1ba", "filename": "libgo/go/strconv/fp_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Ffp_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -96,7 +96,7 @@ func myatof32(s string) (f float32, ok bool) {\n func TestFp(t *testing.T) {\n \tf, err := os.Open(\"testfp.txt\")\n \tif err != nil {\n-\t\tt.Fatal(\"testfp: open testfp.txt:\", err.String())\n+\t\tt.Fatal(\"testfp: open testfp.txt:\", err)\n \t}\n \tdefer f.Close()\n "}, {"sha": "7efdcfedb22231a015516b6a44635ff03bb2ccc4", "filename": "libgo/go/strconv/quote.go", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fquote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fquote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -18,32 +18,32 @@ func quoteWith(s string, quote byte, ASCIIonly bool) string {\n \tvar buf bytes.Buffer\n \tbuf.WriteByte(quote)\n \tfor width := 0; len(s) > 0; s = s[width:] {\n-\t\trune := int(s[0])\n+\t\tr := rune(s[0])\n \t\twidth = 1\n-\t\tif rune >= utf8.RuneSelf {\n-\t\t\trune, width = utf8.DecodeRuneInString(s)\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, width = utf8.DecodeRuneInString(s)\n \t\t}\n-\t\tif width == 1 && rune == utf8.RuneError {\n+\t\tif width == 1 && r == utf8.RuneError {\n \t\t\tbuf.WriteString(`\\x`)\n \t\t\tbuf.WriteByte(lowerhex[s[0]>>4])\n \t\t\tbuf.WriteByte(lowerhex[s[0]&0xF])\n \t\t\tcontinue\n \t\t}\n-\t\tif rune == int(quote) || rune == '\\\\' { // always backslashed\n+\t\tif r == rune(quote) || r == '\\\\' { // always backslashed\n \t\t\tbuf.WriteByte('\\\\')\n-\t\t\tbuf.WriteByte(byte(rune))\n+\t\t\tbuf.WriteByte(byte(r))\n \t\t\tcontinue\n \t\t}\n \t\tif ASCIIonly {\n-\t\t\tif rune <= unicode.MaxASCII && unicode.IsPrint(rune) {\n-\t\t\t\tbuf.WriteRune(rune)\n+\t\t\tif r <= unicode.MaxASCII && unicode.IsPrint(r) {\n+\t\t\t\tbuf.WriteRune(r)\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t} else if unicode.IsPrint(rune) {\n-\t\t\tbuf.WriteRune(rune)\n+\t\t} else if unicode.IsPrint(r) {\n+\t\t\tbuf.WriteRune(r)\n \t\t\tcontinue\n \t\t}\n-\t\tswitch rune {\n+\t\tswitch r {\n \t\tcase '\\a':\n \t\t\tbuf.WriteString(`\\a`)\n \t\tcase '\\b':\n@@ -60,22 +60,22 @@ func quoteWith(s string, quote byte, ASCIIonly bool) string {\n \t\t\tbuf.WriteString(`\\v`)\n \t\tdefault:\n \t\t\tswitch {\n-\t\t\tcase rune < ' ':\n+\t\t\tcase r < ' ':\n \t\t\t\tbuf.WriteString(`\\x`)\n \t\t\t\tbuf.WriteByte(lowerhex[s[0]>>4])\n \t\t\t\tbuf.WriteByte(lowerhex[s[0]&0xF])\n-\t\t\tcase rune > unicode.MaxRune:\n-\t\t\t\trune = 0xFFFD\n+\t\t\tcase r > unicode.MaxRune:\n+\t\t\t\tr = 0xFFFD\n \t\t\t\tfallthrough\n-\t\t\tcase rune < 0x10000:\n+\t\t\tcase r < 0x10000:\n \t\t\t\tbuf.WriteString(`\\u`)\n \t\t\t\tfor s := 12; s >= 0; s -= 4 {\n-\t\t\t\t\tbuf.WriteByte(lowerhex[rune>>uint(s)&0xF])\n+\t\t\t\t\tbuf.WriteByte(lowerhex[r>>uint(s)&0xF])\n \t\t\t\t}\n \t\t\tdefault:\n \t\t\t\tbuf.WriteString(`\\U`)\n \t\t\t\tfor s := 28; s >= 0; s -= 4 {\n-\t\t\t\t\tbuf.WriteByte(lowerhex[rune>>uint(s)&0xF])\n+\t\t\t\t\tbuf.WriteByte(lowerhex[r>>uint(s)&0xF])\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -130,8 +130,8 @@ func CanBackquote(s string) bool {\n \treturn true\n }\n \n-func unhex(b byte) (v int, ok bool) {\n-\tc := int(b)\n+func unhex(b byte) (v rune, ok bool) {\n+\tc := rune(b)\n \tswitch {\n \tcase '0' <= c && c <= '9':\n \t\treturn c - '0', true\n@@ -157,22 +157,22 @@ func unhex(b byte) (v int, ok bool) {\n // If set to a single quote, it permits the sequence \\' and disallows unescaped '.\n // If set to a double quote, it permits \\\" and disallows unescaped \".\n // If set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n-func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string, err os.Error) {\n+func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err os.Error) {\n \t// easy cases\n \tswitch c := s[0]; {\n \tcase c == quote && (quote == '\\'' || quote == '\"'):\n-\t\terr = os.EINVAL\n+\t\terr = ErrSyntax\n \t\treturn\n \tcase c >= utf8.RuneSelf:\n \t\tr, size := utf8.DecodeRuneInString(s)\n \t\treturn r, true, s[size:], nil\n \tcase c != '\\\\':\n-\t\treturn int(s[0]), false, s[1:], nil\n+\t\treturn rune(s[0]), false, s[1:], nil\n \t}\n \n \t// hard case: c is backslash\n \tif len(s) <= 1 {\n-\t\terr = os.EINVAL\n+\t\terr = ErrSyntax\n \t\treturn\n \t}\n \tc := s[1]\n@@ -203,15 +203,15 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,\n \t\tcase 'U':\n \t\t\tn = 8\n \t\t}\n-\t\tv := 0\n+\t\tvar v rune\n \t\tif len(s) < n {\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\treturn\n \t\t}\n \t\tfor j := 0; j < n; j++ {\n \t\t\tx, ok := unhex(s[j])\n \t\t\tif !ok {\n-\t\t\t\terr = os.EINVAL\n+\t\t\t\terr = ErrSyntax\n \t\t\t\treturn\n \t\t\t}\n \t\t\tv = v<<4 | x\n@@ -223,40 +223,40 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,\n \t\t\tbreak\n \t\t}\n \t\tif v > unicode.MaxRune {\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\treturn\n \t\t}\n \t\tvalue = v\n \t\tmultibyte = true\n \tcase '0', '1', '2', '3', '4', '5', '6', '7':\n-\t\tv := int(c) - '0'\n+\t\tv := rune(c) - '0'\n \t\tif len(s) < 2 {\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\treturn\n \t\t}\n \t\tfor j := 0; j < 2; j++ { // one digit already; two more\n-\t\t\tx := int(s[j]) - '0'\n+\t\t\tx := rune(s[j]) - '0'\n \t\t\tif x < 0 || x > 7 {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tv = (v << 3) | x\n \t\t}\n \t\ts = s[2:]\n \t\tif v > 255 {\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\treturn\n \t\t}\n \t\tvalue = v\n \tcase '\\\\':\n \t\tvalue = '\\\\'\n \tcase '\\'', '\"':\n \t\tif c != quote {\n-\t\t\terr = os.EINVAL\n+\t\t\terr = ErrSyntax\n \t\t\treturn\n \t\t}\n-\t\tvalue = int(c)\n+\t\tvalue = rune(c)\n \tdefault:\n-\t\terr = os.EINVAL\n+\t\terr = ErrSyntax\n \t\treturn\n \t}\n \ttail = s\n@@ -271,29 +271,29 @@ func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string,\n func Unquote(s string) (t string, err os.Error) {\n \tn := len(s)\n \tif n < 2 {\n-\t\treturn \"\", os.EINVAL\n+\t\treturn \"\", ErrSyntax\n \t}\n \tquote := s[0]\n \tif quote != s[n-1] {\n-\t\treturn \"\", os.EINVAL\n+\t\treturn \"\", ErrSyntax\n \t}\n \ts = s[1 : n-1]\n \n \tif quote == '`' {\n \t\tif strings.Contains(s, \"`\") {\n-\t\t\treturn \"\", os.EINVAL\n+\t\t\treturn \"\", ErrSyntax\n \t\t}\n \t\treturn s, nil\n \t}\n \tif quote != '\"' && quote != '\\'' {\n-\t\treturn \"\", os.EINVAL\n+\t\treturn \"\", ErrSyntax\n \t}\n \tif strings.Index(s, \"\\n\") >= 0 {\n-\t\treturn \"\", os.EINVAL\n+\t\treturn \"\", ErrSyntax\n \t}\n \n \t// Is it trivial?  Avoid allocation.\n-\tif strings.Index(s, `\\`) < 0 && strings.IndexRune(s, int(quote)) < 0 {\n+\tif strings.Index(s, `\\`) < 0 && strings.IndexRune(s, rune(quote)) < 0 {\n \t\tswitch quote {\n \t\tcase '\"':\n \t\t\treturn s, nil\n@@ -319,7 +319,7 @@ func Unquote(s string) (t string, err os.Error) {\n \t\t}\n \t\tif quote == '\\'' && len(s) != 0 {\n \t\t\t// single-quoted must be single character\n-\t\t\treturn \"\", os.EINVAL\n+\t\t\treturn \"\", ErrSyntax\n \t\t}\n \t}\n \treturn buf.String(), nil"}, {"sha": "9a597700d27a7d69dcbeb61cfcc9e88745e5596b", "filename": "libgo/go/strconv/quote_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5,7 +5,6 @@\n package strconv_test\n \n import (\n-\t\"os\"\n \t. \"strconv\"\n \t\"testing\"\n )\n@@ -210,8 +209,8 @@ func TestUnquote(t *testing.T) {\n \t}\n \n \tfor _, s := range misquoted {\n-\t\tif out, err := Unquote(s); out != \"\" || err != os.EINVAL {\n-\t\t\tt.Errorf(\"Unquote(%#q) = %q, %v want %q, %v\", s, out, err, \"\", os.EINVAL)\n+\t\tif out, err := Unquote(s); out != \"\" || err != ErrSyntax {\n+\t\t\tt.Errorf(\"Unquote(%#q) = %q, %v want %q, %v\", s, out, err, \"\", ErrSyntax)\n \t\t}\n \t}\n }"}, {"sha": "f4385a437ab6108f947789e8092ea1075efd7ed9", "filename": "libgo/go/strings/reader.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freader.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -60,16 +60,16 @@ func (r *Reader) UnreadByte() os.Error {\n // If no bytes are available, the error returned is os.EOF.\n // If the bytes are an erroneous UTF-8 encoding, it\n // consumes one byte and returns U+FFFD, 1.\n-func (r *Reader) ReadRune() (rune int, size int, err os.Error) {\n+func (r *Reader) ReadRune() (ch rune, size int, err os.Error) {\n \tif r.i >= len(r.s) {\n \t\treturn 0, 0, os.EOF\n \t}\n \tr.prevRune = r.i\n \tif c := r.s[r.i]; c < utf8.RuneSelf {\n \t\tr.i++\n-\t\treturn int(c), 1, nil\n+\t\treturn rune(c), 1, nil\n \t}\n-\trune, size = utf8.DecodeRuneInString(r.s[r.i:])\n+\tch, size = utf8.DecodeRuneInString(r.s[r.i:])\n \tr.i += size\n \treturn\n }"}, {"sha": "23c7e2e53347672dab6a44759cb68bdcb28ce885", "filename": "libgo/go/strings/replace_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Freplace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Freplace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Freplace_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -159,12 +159,12 @@ func BenchmarkByteByteReplaces(b *testing.B) {\n // BenchmarkByteByteMap compares byteByteImpl against Map.\n func BenchmarkByteByteMap(b *testing.B) {\n \tstr := Repeat(\"a\", 100) + Repeat(\"b\", 100)\n-\tfn := func(r int) int {\n+\tfn := func(r rune) rune {\n \t\tswitch r {\n \t\tcase 'a':\n-\t\t\treturn int('A')\n+\t\t\treturn 'A'\n \t\tcase 'b':\n-\t\t\treturn int('B')\n+\t\t\treturn 'B'\n \t\t}\n \t\treturn r\n \t}"}, {"sha": "4f6e8a6fe3e3e2f7c09957aedc8b7a7988391157", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -21,11 +21,12 @@ func explode(s string, n int) []string {\n \t\tn = l\n \t}\n \ta := make([]string, n)\n-\tvar size, rune int\n+\tvar size int\n+\tvar ch rune\n \ti, cur := 0, 0\n \tfor ; i+1 < n; i++ {\n-\t\trune, size = utf8.DecodeRuneInString(s[cur:])\n-\t\ta[i] = string(rune)\n+\t\tch, size = utf8.DecodeRuneInString(s[cur:])\n+\t\ta[i] = string(ch)\n \t\tcur += size\n \t}\n \t// add the rest, if there is any\n@@ -117,19 +118,19 @@ func LastIndex(s, sep string) int {\n }\n \n // IndexRune returns the index of the first instance of the Unicode code point\n-// rune, or -1 if rune is not present in s.\n-func IndexRune(s string, rune int) int {\n+// r, or -1 if rune is not present in s.\n+func IndexRune(s string, r rune) int {\n \tswitch {\n-\tcase rune < 0x80:\n-\t\tb := byte(rune)\n+\tcase r < 0x80:\n+\t\tb := byte(r)\n \t\tfor i := 0; i < len(s); i++ {\n \t\t\tif s[i] == b {\n \t\t\t\treturn i\n \t\t\t}\n \t\t}\n \tdefault:\n \t\tfor i, c := range s {\n-\t\t\tif c == rune {\n+\t\t\tif c == r {\n \t\t\t\treturn i\n \t\t\t}\n \t\t}\n@@ -241,7 +242,7 @@ func Fields(s string) []string {\n // FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\n // and returns an array of slices of s. If all code points in s satisfy f(c) or the\n // string is empty, an empty slice is returned.\n-func FieldsFunc(s string, f func(int) bool) []string {\n+func FieldsFunc(s string, f func(rune) bool) []string {\n \t// First count the fields.\n \tn := 0\n \tinField := false\n@@ -310,7 +311,7 @@ func HasSuffix(s, suffix string) bool {\n // Map returns a copy of the string s with all its characters modified\n // according to the mapping function. If mapping returns a negative value, the character is\n // dropped from the string with no replacement.\n-func Map(mapping func(rune int) int, s string) string {\n+func Map(mapping func(rune) rune, s string) string {\n \t// In the worst case, the string can grow when mapped, making\n \t// things unpleasant.  But it's so rare we barge in assuming it's\n \t// fine.  It could also shrink but that falls out naturally.\n@@ -321,18 +322,18 @@ func Map(mapping func(rune int) int, s string) string {\n \tvar b []byte\n \n \tfor i, c := range s {\n-\t\trune := mapping(c)\n+\t\tr := mapping(c)\n \t\tif b == nil {\n-\t\t\tif rune == c {\n+\t\t\tif r == c {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tb = make([]byte, maxbytes)\n \t\t\tnbytes = copy(b, s[:i])\n \t\t}\n-\t\tif rune >= 0 {\n+\t\tif r >= 0 {\n \t\t\twid := 1\n-\t\t\tif rune >= utf8.RuneSelf {\n-\t\t\t\twid = utf8.RuneLen(rune)\n+\t\t\tif r >= utf8.RuneSelf {\n+\t\t\t\twid = utf8.RuneLen(r)\n \t\t\t}\n \t\t\tif nbytes+wid > maxbytes {\n \t\t\t\t// Grow the buffer.\n@@ -341,7 +342,7 @@ func Map(mapping func(rune int) int, s string) string {\n \t\t\t\tcopy(nb, b[0:nbytes])\n \t\t\t\tb = nb\n \t\t\t}\n-\t\t\tnbytes += utf8.EncodeRune(b[nbytes:maxbytes], rune)\n+\t\t\tnbytes += utf8.EncodeRune(b[nbytes:maxbytes], r)\n \t\t}\n \t}\n \tif b == nil {\n@@ -375,44 +376,44 @@ func ToTitle(s string) string { return Map(unicode.ToTitle, s) }\n // ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\n // upper case, giving priority to the special casing rules.\n func ToUpperSpecial(_case unicode.SpecialCase, s string) string {\n-\treturn Map(func(r int) int { return _case.ToUpper(r) }, s)\n+\treturn Map(func(r rune) rune { return _case.ToUpper(r) }, s)\n }\n \n // ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\n // lower case, giving priority to the special casing rules.\n func ToLowerSpecial(_case unicode.SpecialCase, s string) string {\n-\treturn Map(func(r int) int { return _case.ToLower(r) }, s)\n+\treturn Map(func(r rune) rune { return _case.ToLower(r) }, s)\n }\n \n // ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\n // title case, giving priority to the special casing rules.\n func ToTitleSpecial(_case unicode.SpecialCase, s string) string {\n-\treturn Map(func(r int) int { return _case.ToTitle(r) }, s)\n+\treturn Map(func(r rune) rune { return _case.ToTitle(r) }, s)\n }\n \n // isSeparator reports whether the rune could mark a word boundary.\n // TODO: update when package unicode captures more of the properties.\n-func isSeparator(rune int) bool {\n+func isSeparator(r rune) bool {\n \t// ASCII alphanumerics and underscore are not separators\n-\tif rune <= 0x7F {\n+\tif r <= 0x7F {\n \t\tswitch {\n-\t\tcase '0' <= rune && rune <= '9':\n+\t\tcase '0' <= r && r <= '9':\n \t\t\treturn false\n-\t\tcase 'a' <= rune && rune <= 'z':\n+\t\tcase 'a' <= r && r <= 'z':\n \t\t\treturn false\n-\t\tcase 'A' <= rune && rune <= 'Z':\n+\t\tcase 'A' <= r && r <= 'Z':\n \t\t\treturn false\n-\t\tcase rune == '_':\n+\t\tcase r == '_':\n \t\t\treturn false\n \t\t}\n \t\treturn true\n \t}\n \t// Letters and digits are not separators\n-\tif unicode.IsLetter(rune) || unicode.IsDigit(rune) {\n+\tif unicode.IsLetter(r) || unicode.IsDigit(r) {\n \t\treturn false\n \t}\n \t// Otherwise, all we can do for now is treat spaces as separators.\n-\treturn unicode.IsSpace(rune)\n+\treturn unicode.IsSpace(r)\n }\n \n // BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n@@ -423,9 +424,9 @@ func Title(s string) string {\n \t// Use a closure here to remember state.\n \t// Hackish but effective. Depends on Map scanning in order and calling\n \t// the closure once per rune.\n-\tprev := ' '\n+\tprev := rune(' ')\n \treturn Map(\n-\t\tfunc(r int) int {\n+\t\tfunc(r rune) rune {\n \t\t\tif isSeparator(prev) {\n \t\t\t\tprev = r\n \t\t\t\treturn unicode.ToTitle(r)\n@@ -438,7 +439,7 @@ func Title(s string) string {\n \n // TrimLeftFunc returns a slice of the string s with all leading\n // Unicode code points c satisfying f(c) removed.\n-func TrimLeftFunc(s string, f func(r int) bool) string {\n+func TrimLeftFunc(s string, f func(rune) bool) string {\n \ti := indexFunc(s, f, false)\n \tif i == -1 {\n \t\treturn \"\"\n@@ -448,7 +449,7 @@ func TrimLeftFunc(s string, f func(r int) bool) string {\n \n // TrimRightFunc returns a slice of the string s with all trailing\n // Unicode code points c satisfying f(c) removed.\n-func TrimRightFunc(s string, f func(r int) bool) string {\n+func TrimRightFunc(s string, f func(rune) bool) string {\n \ti := lastIndexFunc(s, f, false)\n \tif i >= 0 && s[i] >= utf8.RuneSelf {\n \t\t_, wid := utf8.DecodeRuneInString(s[i:])\n@@ -461,34 +462,34 @@ func TrimRightFunc(s string, f func(r int) bool) string {\n \n // TrimFunc returns a slice of the string s with all leading\n // and trailing Unicode code points c satisfying f(c) removed.\n-func TrimFunc(s string, f func(r int) bool) string {\n+func TrimFunc(s string, f func(rune) bool) string {\n \treturn TrimRightFunc(TrimLeftFunc(s, f), f)\n }\n \n // IndexFunc returns the index into s of the first Unicode\n // code point satisfying f(c), or -1 if none do.\n-func IndexFunc(s string, f func(r int) bool) int {\n+func IndexFunc(s string, f func(rune) bool) int {\n \treturn indexFunc(s, f, true)\n }\n \n // LastIndexFunc returns the index into s of the last\n // Unicode code point satisfying f(c), or -1 if none do.\n-func LastIndexFunc(s string, f func(r int) bool) int {\n+func LastIndexFunc(s string, f func(rune) bool) int {\n \treturn lastIndexFunc(s, f, true)\n }\n \n // indexFunc is the same as IndexFunc except that if\n // truth==false, the sense of the predicate function is\n // inverted.\n-func indexFunc(s string, f func(r int) bool, truth bool) int {\n+func indexFunc(s string, f func(rune) bool, truth bool) int {\n \tstart := 0\n \tfor start < len(s) {\n \t\twid := 1\n-\t\trune := int(s[start])\n-\t\tif rune >= utf8.RuneSelf {\n-\t\t\trune, wid = utf8.DecodeRuneInString(s[start:])\n+\t\tr := rune(s[start])\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\tr, wid = utf8.DecodeRuneInString(s[start:])\n \t\t}\n-\t\tif f(rune) == truth {\n+\t\tif f(r) == truth {\n \t\t\treturn start\n \t\t}\n \t\tstart += wid\n@@ -499,19 +500,19 @@ func indexFunc(s string, f func(r int) bool, truth bool) int {\n // lastIndexFunc is the same as LastIndexFunc except that if\n // truth==false, the sense of the predicate function is\n // inverted.\n-func lastIndexFunc(s string, f func(r int) bool, truth bool) int {\n+func lastIndexFunc(s string, f func(rune) bool, truth bool) int {\n \tfor i := len(s); i > 0; {\n-\t\trune, size := utf8.DecodeLastRuneInString(s[0:i])\n+\t\tr, size := utf8.DecodeLastRuneInString(s[0:i])\n \t\ti -= size\n-\t\tif f(rune) == truth {\n+\t\tif f(r) == truth {\n \t\t\treturn i\n \t\t}\n \t}\n \treturn -1\n }\n \n-func makeCutsetFunc(cutset string) func(rune int) bool {\n-\treturn func(rune int) bool { return IndexRune(cutset, rune) != -1 }\n+func makeCutsetFunc(cutset string) func(rune) bool {\n+\treturn func(r rune) bool { return IndexRune(cutset, r) != -1 }\n }\n \n // Trim returns a slice of the string s with all leading and\n@@ -589,15 +590,15 @@ func Replace(s, old, new string, n int) string {\n func EqualFold(s, t string) bool {\n \tfor s != \"\" && t != \"\" {\n \t\t// Extract first rune from each string.\n-\t\tvar sr, tr int\n+\t\tvar sr, tr rune\n \t\tif s[0] < utf8.RuneSelf {\n-\t\t\tsr, s = int(s[0]), s[1:]\n+\t\t\tsr, s = rune(s[0]), s[1:]\n \t\t} else {\n \t\t\tr, size := utf8.DecodeRuneInString(s)\n \t\t\tsr, s = r, s[size:]\n \t\t}\n \t\tif t[0] < utf8.RuneSelf {\n-\t\t\ttr, t = int(t[0]), t[1:]\n+\t\t\ttr, t = rune(t[0]), t[1:]\n \t\t} else {\n \t\t\tr, size := utf8.DecodeRuneInString(t)\n \t\t\ttr, t = r, t[size:]"}, {"sha": "4132996c192d0b957af7ae7a8998b217f20decd6", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -122,7 +122,7 @@ func TestLastIndexAny(t *testing.T) { runIndexTests(t, LastIndexAny, \"LastIndexA\n \n var indexRuneTests = []struct {\n \ts    string\n-\trune int\n+\trune rune\n \tout  int\n }{\n \t{\"a A x\", 'A', 2},\n@@ -312,7 +312,7 @@ var FieldsFuncTests = []FieldsTest{\n }\n \n func TestFieldsFunc(t *testing.T) {\n-\tpred := func(c int) bool { return c == 'X' }\n+\tpred := func(c rune) bool { return c == 'X' }\n \tfor _, tt := range FieldsFuncTests {\n \t\ta := FieldsFunc(tt.s, pred)\n \t\tif !eq(a, tt.a) {\n@@ -374,39 +374,39 @@ var trimSpaceTests = []StringTest{\n \t{\"x \u263a \", \"x \u263a\"},\n }\n \n-func tenRunes(rune int) string {\n-\tr := make([]int, 10)\n+func tenRunes(ch rune) string {\n+\tr := make([]rune, 10)\n \tfor i := range r {\n-\t\tr[i] = rune\n+\t\tr[i] = ch\n \t}\n \treturn string(r)\n }\n \n // User-defined self-inverse mapping function\n-func rot13(rune int) int {\n-\tstep := 13\n-\tif rune >= 'a' && rune <= 'z' {\n-\t\treturn ((rune - 'a' + step) % 26) + 'a'\n+func rot13(r rune) rune {\n+\tstep := rune(13)\n+\tif r >= 'a' && r <= 'z' {\n+\t\treturn ((r - 'a' + step) % 26) + 'a'\n \t}\n-\tif rune >= 'A' && rune <= 'Z' {\n-\t\treturn ((rune - 'A' + step) % 26) + 'A'\n+\tif r >= 'A' && r <= 'Z' {\n+\t\treturn ((r - 'A' + step) % 26) + 'A'\n \t}\n-\treturn rune\n+\treturn r\n }\n \n func TestMap(t *testing.T) {\n \t// Run a couple of awful growth/shrinkage tests\n \ta := tenRunes('a')\n \t// 1.  Grow.  This triggers two reallocations in Map.\n-\tmaxRune := func(rune int) int { return unicode.MaxRune }\n+\tmaxRune := func(rune) rune { return unicode.MaxRune }\n \tm := Map(maxRune, a)\n \texpect := tenRunes(unicode.MaxRune)\n \tif m != expect {\n \t\tt.Errorf(\"growing: expected %q got %q\", expect, m)\n \t}\n \n \t// 2. Shrink\n-\tminRune := func(rune int) int { return 'a' }\n+\tminRune := func(rune) rune { return 'a' }\n \tm = Map(minRune, tenRunes(unicode.MaxRune))\n \texpect = a\n \tif m != expect {\n@@ -428,9 +428,9 @@ func TestMap(t *testing.T) {\n \t}\n \n \t// 5. Drop\n-\tdropNotLatin := func(rune int) int {\n-\t\tif unicode.Is(unicode.Latin, rune) {\n-\t\t\treturn rune\n+\tdropNotLatin := func(r rune) rune {\n+\t\tif unicode.Is(unicode.Latin, r) {\n+\t\t\treturn r\n \t\t}\n \t\treturn -1\n \t}\n@@ -441,8 +441,8 @@ func TestMap(t *testing.T) {\n \t}\n \n \t// 6. Identity\n-\tidentity := func(rune int) int {\n-\t\treturn rune\n+\tidentity := func(r rune) rune {\n+\t\treturn r\n \t}\n \torig := \"Input string that we expect not to be copied.\"\n \tm = Map(identity, orig)\n@@ -457,8 +457,8 @@ func TestToUpper(t *testing.T) { runStringTests(t, ToUpper, \"ToUpper\", upperTest\n func TestToLower(t *testing.T) { runStringTests(t, ToLower, \"ToLower\", lowerTests) }\n \n func BenchmarkMapNoChanges(b *testing.B) {\n-\tidentity := func(rune int) int {\n-\t\treturn rune\n+\tidentity := func(r rune) rune {\n+\t\treturn r\n \t}\n \tfor i := 0; i < b.N; i++ {\n \t\tMap(identity, \"Some string that won't be modified.\")\n@@ -536,23 +536,23 @@ func TestTrim(t *testing.T) {\n }\n \n type predicate struct {\n-\tf    func(r int) bool\n+\tf    func(rune) bool\n \tname string\n }\n \n var isSpace = predicate{unicode.IsSpace, \"IsSpace\"}\n var isDigit = predicate{unicode.IsDigit, \"IsDigit\"}\n var isUpper = predicate{unicode.IsUpper, \"IsUpper\"}\n var isValidRune = predicate{\n-\tfunc(r int) bool {\n+\tfunc(r rune) bool {\n \t\treturn r != utf8.RuneError\n \t},\n \t\"IsValidRune\",\n }\n \n func not(p predicate) predicate {\n \treturn predicate{\n-\t\tfunc(r int) bool {\n+\t\tfunc(r rune) bool {\n \t\t\treturn !p.f(r)\n \t\t},\n \t\t\"not \" + p.name,\n@@ -645,9 +645,9 @@ func TestCaseConsistency(t *testing.T) {\n \tif testing.Short() {\n \t\tnumRunes = 1000\n \t}\n-\ta := make([]int, numRunes)\n+\ta := make([]rune, numRunes)\n \tfor i := range a {\n-\t\ta[i] = i\n+\t\ta[i] = rune(i)\n \t}\n \ts := string(a)\n \t// convert the cases.\n@@ -706,7 +706,7 @@ func TestRepeat(t *testing.T) {\n \t}\n }\n \n-func runesEqual(a, b []int) bool {\n+func runesEqual(a, b []rune) bool {\n \tif len(a) != len(b) {\n \t\treturn false\n \t}\n@@ -720,30 +720,30 @@ func runesEqual(a, b []int) bool {\n \n var RunesTests = []struct {\n \tin    string\n-\tout   []int\n+\tout   []rune\n \tlossy bool\n }{\n-\t{\"\", []int{}, false},\n-\t{\" \", []int{32}, false},\n-\t{\"ABC\", []int{65, 66, 67}, false},\n-\t{\"abc\", []int{97, 98, 99}, false},\n-\t{\"\\u65e5\\u672c\\u8a9e\", []int{26085, 26412, 35486}, false},\n-\t{\"ab\\x80c\", []int{97, 98, 0xFFFD, 99}, true},\n-\t{\"ab\\xc0c\", []int{97, 98, 0xFFFD, 99}, true},\n+\t{\"\", []rune{}, false},\n+\t{\" \", []rune{32}, false},\n+\t{\"ABC\", []rune{65, 66, 67}, false},\n+\t{\"abc\", []rune{97, 98, 99}, false},\n+\t{\"\\u65e5\\u672c\\u8a9e\", []rune{26085, 26412, 35486}, false},\n+\t{\"ab\\x80c\", []rune{97, 98, 0xFFFD, 99}, true},\n+\t{\"ab\\xc0c\", []rune{97, 98, 0xFFFD, 99}, true},\n }\n \n func TestRunes(t *testing.T) {\n \tfor _, tt := range RunesTests {\n-\t\ta := []int(tt.in)\n+\t\ta := []rune(tt.in)\n \t\tif !runesEqual(a, tt.out) {\n-\t\t\tt.Errorf(\"[]int(%q) = %v; want %v\", tt.in, a, tt.out)\n+\t\t\tt.Errorf(\"[]rune(%q) = %v; want %v\", tt.in, a, tt.out)\n \t\t\tcontinue\n \t\t}\n \t\tif !tt.lossy {\n \t\t\t// can only test reassembly if we didn't lose information\n \t\t\ts := string(a)\n \t\t\tif s != tt.in {\n-\t\t\t\tt.Errorf(\"string([]int(%q)) = %x; want %x\", tt.in, s, tt.in)\n+\t\t\t\tt.Errorf(\"string([]rune(%q)) = %x; want %x\", tt.in, s, tt.in)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "34c6633232ffaa864d5571e4172e5d24128661c9", "filename": "libgo/go/template/exec.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Fexec.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -97,7 +97,7 @@ func (t *Template) Execute(wr io.Writer, data interface{}) (err os.Error) {\n \t\tline: 1,\n \t\tvars: []variable{{\"$\", value}},\n \t}\n-\tif t.Root == nil {\n+\tif t.Tree == nil || t.Root == nil {\n \t\tstate.errorf(\"must be parsed before execution\")\n \t}\n \tstate.walk(value, t.Root)"}, {"sha": "2d2b4029423d4a09762146bb08bb1f81ae28cc59", "filename": "libgo/go/template/exec_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Fexec_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -98,7 +98,7 @@ var tVal = &T{\n \tEmpty3:            []int{7, 8},\n \tEmpty4:            &U{\"UinEmpty\"},\n \tNonEmptyInterface: new(T),\n-\tStr:               os.NewError(\"foozle\"),\n+\tStr:               bytes.NewBuffer([]byte(\"foozle\")),\n \tPI:                newInt(23),\n \tPSI:               newIntSlice(21, 22, 23),\n \tTmpl:              Must(New(\"x\").Parse(\"test template\")), // \"x\" is the value of .X\n@@ -644,7 +644,7 @@ func TestTree(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(\"exec error:\", err)\n \t}\n-\tstripSpace := func(r int) int {\n+\tstripSpace := func(r rune) rune {\n \t\tif r == '\\t' || r == '\\n' {\n \t\t\treturn -1\n \t\t}"}, {"sha": "938559eec96213e4122d7de352b02d81dad4f2dd", "filename": "libgo/go/template/funcs.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Ffuncs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Ffuncs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Ffuncs.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -279,7 +279,7 @@ func JSEscape(w io.Writer, b []byte) {\n \tfor i := 0; i < len(b); i++ {\n \t\tc := b[i]\n \n-\t\tif !jsIsSpecial(int(c)) {\n+\t\tif !jsIsSpecial(rune(c)) {\n \t\t\t// fast path: nothing to do\n \t\t\tcontinue\n \t\t}\n@@ -307,12 +307,12 @@ func JSEscape(w io.Writer, b []byte) {\n \t\t\t}\n \t\t} else {\n \t\t\t// Unicode rune.\n-\t\t\trune, size := utf8.DecodeRune(b[i:])\n-\t\t\tif unicode.IsPrint(rune) {\n+\t\t\tr, size := utf8.DecodeRune(b[i:])\n+\t\t\tif unicode.IsPrint(r) {\n \t\t\t\tw.Write(b[i : i+size])\n \t\t\t} else {\n \t\t\t\t// TODO(dsymonds): Do this without fmt?\n-\t\t\t\tfmt.Fprintf(w, \"\\\\u%04X\", rune)\n+\t\t\t\tfmt.Fprintf(w, \"\\\\u%04X\", r)\n \t\t\t}\n \t\t\ti += size - 1\n \t\t}\n@@ -332,12 +332,12 @@ func JSEscapeString(s string) string {\n \treturn b.String()\n }\n \n-func jsIsSpecial(rune int) bool {\n-\tswitch rune {\n+func jsIsSpecial(r rune) bool {\n+\tswitch r {\n \tcase '\\\\', '\\'', '\"', '<', '>':\n \t\treturn true\n \t}\n-\treturn rune < ' ' || utf8.RuneSelf <= rune\n+\treturn r < ' ' || utf8.RuneSelf <= r\n }\n \n // JSEscaper returns the escaped JavaScript equivalent of the textual"}, {"sha": "04c105d16104ecc5b5e15fbfb7681c665c23831e", "filename": "libgo/go/template/parse/lex.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Fparse%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftemplate%2Fparse%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Fparse%2Flex.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -131,21 +131,21 @@ type lexer struct {\n }\n \n // next returns the next rune in the input.\n-func (l *lexer) next() (rune int) {\n+func (l *lexer) next() (r rune) {\n \tif l.pos >= len(l.input) {\n \t\tl.width = 0\n \t\treturn eof\n \t}\n-\trune, l.width = utf8.DecodeRuneInString(l.input[l.pos:])\n+\tr, l.width = utf8.DecodeRuneInString(l.input[l.pos:])\n \tl.pos += l.width\n-\treturn rune\n+\treturn r\n }\n \n // peek returns but does not consume the next rune in the input.\n-func (l *lexer) peek() int {\n-\trune := l.next()\n+func (l *lexer) peek() rune {\n+\tr := l.next()\n \tl.backup()\n-\treturn rune\n+\treturn r\n }\n \n // backup steps back one rune. Can only be called once per call of next.\n@@ -468,7 +468,7 @@ Loop:\n }\n \n // isSpace reports whether r is a space character.\n-func isSpace(r int) bool {\n+func isSpace(r rune) bool {\n \tswitch r {\n \tcase ' ', '\\t', '\\n', '\\r':\n \t\treturn true\n@@ -477,6 +477,6 @@ func isSpace(r int) bool {\n }\n \n // isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.\n-func isAlphaNumeric(r int) bool {\n+func isAlphaNumeric(r rune) bool {\n \treturn r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)\n }"}, {"sha": "9ec1925de3d36739c5eb70fcca010d2c7a41038c", "filename": "libgo/go/testing/quick/quick.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftesting%2Fquick%2Fquick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftesting%2Fquick%2Fquick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fquick%2Fquick.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -123,9 +123,9 @@ func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool) {\n \t\treturn s, true\n \tcase reflect.String:\n \t\tnumChars := rand.Intn(complexSize)\n-\t\tcodePoints := make([]int, numChars)\n+\t\tcodePoints := make([]rune, numChars)\n \t\tfor i := 0; i < numChars; i++ {\n-\t\t\tcodePoints[i] = rand.Intn(0x10ffff)\n+\t\t\tcodePoints[i] = rune(rand.Intn(0x10ffff))\n \t\t}\n \t\treturn reflect.ValueOf(string(codePoints)), true\n \tcase reflect.Struct:"}, {"sha": "1a629c918853ca5d2e2e27c6f666e9aab4558efc", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -45,12 +45,12 @@ const (\n \tUnixDate = \"Mon Jan _2 15:04:05 MST 2006\"\n \tRubyDate = \"Mon Jan 02 15:04:05 -0700 2006\"\n \tRFC822   = \"02 Jan 06 1504 MST\"\n-\t// RFC822 with Zulu time.\n-\tRFC822Z = \"02 Jan 06 1504 -0700\"\n-\tRFC850  = \"Monday, 02-Jan-06 15:04:05 MST\"\n-\tRFC1123 = \"Mon, 02 Jan 2006 15:04:05 MST\"\n-\tRFC3339 = \"2006-01-02T15:04:05Z07:00\"\n-\tKitchen = \"3:04PM\"\n+\tRFC822Z  = \"02 Jan 06 1504 -0700\" // RFC822 with numeric zone\n+\tRFC850   = \"Monday, 02-Jan-06 15:04:05 MST\"\n+\tRFC1123  = \"Mon, 02 Jan 2006 15:04:05 MST\"\n+\tRFC1123Z = \"Mon, 02 Jan 2006 15:04:05 -0700\" // RFC1123 with numeric zone\n+\tRFC3339  = \"2006-01-02T15:04:05Z07:00\"\n+\tKitchen  = \"3:04PM\"\n \t// Handy time stamps.\n \tStamp      = \"Jan _2 15:04:05\"\n \tStampMilli = \"Jan _2 15:04:05.000\""}, {"sha": "e4cf51374cb877b60c96500db9313c058924c57a", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -201,6 +201,7 @@ var formatTests = []FormatTest{\n \t{\"RFC822\", RFC822, \"04 Feb 09 2100 PST\"},\n \t{\"RFC850\", RFC850, \"Wednesday, 04-Feb-09 21:00:57 PST\"},\n \t{\"RFC1123\", RFC1123, \"Wed, 04 Feb 2009 21:00:57 PST\"},\n+\t{\"RFC1123Z\", RFC1123Z, \"Wed, 04 Feb 2009 21:00:57 -0800\"},\n \t{\"RFC3339\", RFC3339, \"2009-02-04T21:00:57-08:00\"},\n \t{\"Kitchen\", Kitchen, \"9:00PM\"},\n \t{\"am/pm\", \"3pm\", \"9pm\"},\n@@ -240,6 +241,7 @@ var parseTests = []ParseTest{\n \t{\"RubyDate\", RubyDate, \"Thu Feb 04 21:00:57 -0800 2010\", true, true, 1, 0},\n \t{\"RFC850\", RFC850, \"Thursday, 04-Feb-10 21:00:57 PST\", true, true, 1, 0},\n \t{\"RFC1123\", RFC1123, \"Thu, 04 Feb 2010 21:00:57 PST\", true, true, 1, 0},\n+\t{\"RFC1123Z\", RFC1123Z, \"Thu, 04 Feb 2010 21:00:57 -0800\", true, true, 1, 0},\n \t{\"RFC3339\", RFC3339, \"2010-02-04T21:00:57-08:00\", true, false, 1, 0},\n \t{\"custom: \\\"2006-01-02 15:04:05-07\\\"\", \"2006-01-02 15:04:05-07\", \"2010-02-04 21:00:57-08\", true, false, 1, 0},\n \t// Optional fractional seconds.\n@@ -248,6 +250,7 @@ var parseTests = []ParseTest{\n \t{\"RubyDate\", RubyDate, \"Thu Feb 04 21:00:57.012 -0800 2010\", true, true, 1, 3},\n \t{\"RFC850\", RFC850, \"Thursday, 04-Feb-10 21:00:57.0123 PST\", true, true, 1, 4},\n \t{\"RFC1123\", RFC1123, \"Thu, 04 Feb 2010 21:00:57.01234 PST\", true, true, 1, 5},\n+\t{\"RFC1123Z\", RFC1123Z, \"Thu, 04 Feb 2010 21:00:57.01234 -0800\", true, true, 1, 5},\n \t{\"RFC3339\", RFC3339, \"2010-02-04T21:00:57.012345678-08:00\", true, false, 1, 9},\n \t// Amount of white space should not matter.\n \t{\"ANSIC\", ANSIC, \"Thu Feb 4 21:00:57 2010\", false, true, 1, 0},"}, {"sha": "4800bd6ea8eaff79fdf019b72754eee6e33306aa", "filename": "libgo/go/unicode/digit.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fdigit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fdigit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fdigit.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5,9 +5,9 @@\n package unicode\n \n // IsDigit reports whether the rune is a decimal digit.\n-func IsDigit(rune int) bool {\n-\tif rune <= MaxLatin1 {\n-\t\treturn '0' <= rune && rune <= '9'\n+func IsDigit(r rune) bool {\n+\tif r <= MaxLatin1 {\n+\t\treturn '0' <= r && r <= '9'\n \t}\n-\treturn Is(Digit, rune)\n+\treturn Is(Digit, r)\n }"}, {"sha": "551c42a24eec82eebacc3f4e2cc0868ad588b266", "filename": "libgo/go/unicode/digit_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fdigit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fdigit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fdigit_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -9,7 +9,7 @@ import (\n \t. \"unicode\"\n )\n \n-var testDigit = []int{\n+var testDigit = []rune{\n \t0x0030,\n \t0x0039,\n \t0x0661,\n@@ -68,7 +68,7 @@ var testDigit = []int{\n \t0x1D7CE,\n }\n \n-var testLetter = []int{\n+var testLetter = []rune{\n \t0x0041,\n \t0x0061,\n \t0x00AA,\n@@ -118,7 +118,7 @@ func TestDigit(t *testing.T) {\n \n // Test that the special case in IsDigit agrees with the table\n func TestDigitOptimization(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tif Is(Digit, i) != IsDigit(i) {\n \t\t\tt.Errorf(\"IsDigit(U+%04X) disagrees with Is(Digit)\", i)\n \t\t}"}, {"sha": "9343bc9b0a9b7951740fe1efd402dac126b5e6b9", "filename": "libgo/go/unicode/graphic.go", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fgraphic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fgraphic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fgraphic.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -31,32 +31,32 @@ var PrintRanges = []*RangeTable{\n // IsGraphic reports whether the rune is defined as a Graphic by Unicode.\n // Such characters include letters, marks, numbers, punctuation, symbols, and\n // spaces, from categories L, M, N, P, S, Zs.\n-func IsGraphic(rune int) bool {\n+func IsGraphic(r rune) bool {\n \t// We cast to uint32 to avoid the extra test for negative,\n \t// and in the index we cast to uint8 to avoid the range check.\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pg != 0\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pg != 0\n \t}\n-\treturn IsOneOf(GraphicRanges, rune)\n+\treturn IsOneOf(GraphicRanges, r)\n }\n \n // IsPrint reports whether the rune is defined as printable by Go. Such\n // characters include letters, marks, numbers, punctuation, symbols, and the\n // ASCII space character, from categories L, M, N, P, S and the ASCII space\n // character.  This categorization is the same as IsGraphic except that the\n // only spacing character is ASCII space, U+0020.\n-func IsPrint(rune int) bool {\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pp != 0\n+func IsPrint(r rune) bool {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pp != 0\n \t}\n-\treturn IsOneOf(PrintRanges, rune)\n+\treturn IsOneOf(PrintRanges, r)\n }\n \n // IsOneOf reports whether the rune is a member of one of the ranges.\n // The rune is known to be above Latin-1.\n-func IsOneOf(set []*RangeTable, rune int) bool {\n+func IsOneOf(set []*RangeTable, r rune) bool {\n \tfor _, inside := range set {\n-\t\tif Is(inside, rune) {\n+\t\tif Is(inside, r) {\n \t\t\treturn true\n \t\t}\n \t}\n@@ -66,43 +66,43 @@ func IsOneOf(set []*RangeTable, rune int) bool {\n // IsControl reports whether the rune is a control character.\n // The C (Other) Unicode category includes more code points\n // such as surrogates; use Is(C, rune) to test for them.\n-func IsControl(rune int) bool {\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pC != 0\n+func IsControl(r rune) bool {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pC != 0\n \t}\n \t// All control characters are < Latin1Max.\n \treturn false\n }\n \n // IsLetter reports whether the rune is a letter (category L).\n-func IsLetter(rune int) bool {\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&(pLu|pLl) != 0\n+func IsLetter(r rune) bool {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&(pLu|pLl) != 0\n \t}\n-\treturn Is(Letter, rune)\n+\treturn Is(Letter, r)\n }\n \n // IsMark reports whether the rune is a mark character (category M).\n-func IsMark(rune int) bool {\n+func IsMark(r rune) bool {\n \t// There are no mark characters in Latin-1.\n-\treturn Is(Mark, rune)\n+\treturn Is(Mark, r)\n }\n \n // IsNumber reports whether the rune is a number (category N).\n-func IsNumber(rune int) bool {\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pN != 0\n+func IsNumber(r rune) bool {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pN != 0\n \t}\n-\treturn Is(Number, rune)\n+\treturn Is(Number, r)\n }\n \n // IsPunct reports whether the rune is a Unicode punctuation character\n // (category P).\n-func IsPunct(rune int) bool {\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pP != 0\n+func IsPunct(r rune) bool {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pP != 0\n \t}\n-\treturn Is(Punct, rune)\n+\treturn Is(Punct, r)\n }\n \n // IsSpace reports whether the rune is a space character as defined\n@@ -111,22 +111,22 @@ func IsPunct(rune int) bool {\n //\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\n // Other definitions of spacing characters are set by category\n // Z and property Pattern_White_Space.\n-func IsSpace(rune int) bool {\n+func IsSpace(r rune) bool {\n \t// This property isn't the same as Z; special-case it.\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\tswitch rune {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\tswitch r {\n \t\tcase '\\t', '\\n', '\\v', '\\f', '\\r', ' ', 0x85, 0xA0:\n \t\t\treturn true\n \t\t}\n \t\treturn false\n \t}\n-\treturn Is(White_Space, rune)\n+\treturn Is(White_Space, r)\n }\n \n // IsSymbol reports whether the rune is a symbolic character.\n-func IsSymbol(rune int) bool {\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pS != 0\n+func IsSymbol(r rune) bool {\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pS != 0\n \t}\n-\treturn Is(Symbol, rune)\n+\treturn Is(Symbol, r)\n }"}, {"sha": "7b1f6209e806dda28840620f79152b6d17f31c54", "filename": "libgo/go/unicode/graphic_test.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fgraphic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fgraphic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fgraphic_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -13,7 +13,7 @@ import (\n // in the Latin-1 range through the property table.\n \n func TestIsControlLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsControl(i)\n \t\twant := false\n \t\tswitch {\n@@ -29,7 +29,7 @@ func TestIsControlLatin1(t *testing.T) {\n }\n \n func TestIsLetterLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsLetter(i)\n \t\twant := Is(Letter, i)\n \t\tif got != want {\n@@ -39,7 +39,7 @@ func TestIsLetterLatin1(t *testing.T) {\n }\n \n func TestIsUpperLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsUpper(i)\n \t\twant := Is(Upper, i)\n \t\tif got != want {\n@@ -49,7 +49,7 @@ func TestIsUpperLatin1(t *testing.T) {\n }\n \n func TestIsLowerLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsLower(i)\n \t\twant := Is(Lower, i)\n \t\tif got != want {\n@@ -59,7 +59,7 @@ func TestIsLowerLatin1(t *testing.T) {\n }\n \n func TestNumberLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsNumber(i)\n \t\twant := Is(Number, i)\n \t\tif got != want {\n@@ -69,7 +69,7 @@ func TestNumberLatin1(t *testing.T) {\n }\n \n func TestIsPrintLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsPrint(i)\n \t\twant := IsOneOf(PrintRanges, i)\n \t\tif i == ' ' {\n@@ -82,7 +82,7 @@ func TestIsPrintLatin1(t *testing.T) {\n }\n \n func TestIsGraphicLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsGraphic(i)\n \t\twant := IsOneOf(GraphicRanges, i)\n \t\tif got != want {\n@@ -92,7 +92,7 @@ func TestIsGraphicLatin1(t *testing.T) {\n }\n \n func TestIsPunctLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsPunct(i)\n \t\twant := Is(Punct, i)\n \t\tif got != want {\n@@ -102,7 +102,7 @@ func TestIsPunctLatin1(t *testing.T) {\n }\n \n func TestIsSpaceLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsSpace(i)\n \t\twant := Is(White_Space, i)\n \t\tif got != want {\n@@ -112,7 +112,7 @@ func TestIsSpaceLatin1(t *testing.T) {\n }\n \n func TestIsSymbolLatin1(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tgot := IsSymbol(i)\n \t\twant := Is(Symbol, i)\n \t\tif got != want {"}, {"sha": "01c485b6931ad700a43618a7698ea8cc506a20c9", "filename": "libgo/go/unicode/letter.go", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fletter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fletter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fletter.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -71,7 +71,7 @@ const (\n \tMaxCase\n )\n \n-type d [MaxCase]int32 // to make the CaseRanges text shorter\n+type d [MaxCase]rune // to make the CaseRanges text shorter\n \n // If the Delta field of a CaseRange is UpperLower or LowerUpper, it means\n // this CaseRange represents a sequence of the form (say)\n@@ -81,17 +81,17 @@ const (\n )\n \n // is16 uses binary search to test whether rune is in the specified slice of 16-bit ranges.\n-func is16(ranges []Range16, rune uint16) bool {\n+func is16(ranges []Range16, r uint16) bool {\n \t// binary search over ranges\n \tlo := 0\n \thi := len(ranges)\n \tfor lo < hi {\n \t\tm := lo + (hi-lo)/2\n-\t\tr := ranges[m]\n-\t\tif r.Lo <= rune && rune <= r.Hi {\n-\t\t\treturn (rune-r.Lo)%r.Stride == 0\n+\t\trange_ := ranges[m]\n+\t\tif range_.Lo <= r && r <= range_.Hi {\n+\t\t\treturn (r-range_.Lo)%range_.Stride == 0\n \t\t}\n-\t\tif rune < r.Lo {\n+\t\tif r < range_.Lo {\n \t\t\thi = m\n \t\t} else {\n \t\t\tlo = m + 1\n@@ -101,17 +101,17 @@ func is16(ranges []Range16, rune uint16) bool {\n }\n \n // is32 uses binary search to test whether rune is in the specified slice of 32-bit ranges.\n-func is32(ranges []Range32, rune uint32) bool {\n+func is32(ranges []Range32, r uint32) bool {\n \t// binary search over ranges\n \tlo := 0\n \thi := len(ranges)\n \tfor lo < hi {\n \t\tm := lo + (hi-lo)/2\n-\t\tr := ranges[m]\n-\t\tif r.Lo <= rune && rune <= r.Hi {\n-\t\t\treturn (rune-r.Lo)%r.Stride == 0\n+\t\trange_ := ranges[m]\n+\t\tif range_.Lo <= r && r <= range_.Hi {\n+\t\t\treturn (r-range_.Lo)%range_.Stride == 0\n \t\t}\n-\t\tif rune < r.Lo {\n+\t\tif r < range_.Lo {\n \t\t\thi = m\n \t\t} else {\n \t\t\tlo = m + 1\n@@ -121,11 +121,11 @@ func is32(ranges []Range32, rune uint32) bool {\n }\n \n // Is tests whether rune is in the specified table of ranges.\n-func Is(rangeTab *RangeTable, rune int) bool {\n+func Is(rangeTab *RangeTable, r rune) bool {\n \t// common case: rune is ASCII or Latin-1.\n-\tif uint32(rune) <= MaxLatin1 {\n+\tif uint32(r) <= MaxLatin1 {\n \t\t// Only need to check R16, since R32 is always >= 1<<16.\n-\t\tr16 := uint16(rune)\n+\t\tr16 := uint16(r)\n \t\tfor _, r := range rangeTab.R16 {\n \t\t\tif r16 > r.Hi {\n \t\t\t\tcontinue\n@@ -138,44 +138,44 @@ func Is(rangeTab *RangeTable, rune int) bool {\n \t\treturn false\n \t}\n \tr16 := rangeTab.R16\n-\tif len(r16) > 0 && rune <= int(r16[len(r16)-1].Hi) {\n-\t\treturn is16(r16, uint16(rune))\n+\tif len(r16) > 0 && r <= rune(r16[len(r16)-1].Hi) {\n+\t\treturn is16(r16, uint16(r))\n \t}\n \tr32 := rangeTab.R32\n-\tif len(r32) > 0 && rune >= int(r32[0].Lo) {\n-\t\treturn is32(r32, uint32(rune))\n+\tif len(r32) > 0 && r >= rune(r32[0].Lo) {\n+\t\treturn is32(r32, uint32(r))\n \t}\n \treturn false\n }\n \n // IsUpper reports whether the rune is an upper case letter.\n-func IsUpper(rune int) bool {\n+func IsUpper(r rune) bool {\n \t// See comment in IsGraphic.\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pLu != 0\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pLu != 0\n \t}\n-\treturn Is(Upper, rune)\n+\treturn Is(Upper, r)\n }\n \n // IsLower reports whether the rune is a lower case letter.\n-func IsLower(rune int) bool {\n+func IsLower(r rune) bool {\n \t// See comment in IsGraphic.\n-\tif uint32(rune) <= MaxLatin1 {\n-\t\treturn properties[uint8(rune)]&pLl != 0\n+\tif uint32(r) <= MaxLatin1 {\n+\t\treturn properties[uint8(r)]&pLl != 0\n \t}\n-\treturn Is(Lower, rune)\n+\treturn Is(Lower, r)\n }\n \n // IsTitle reports whether the rune is a title case letter.\n-func IsTitle(rune int) bool {\n-\tif rune <= MaxLatin1 {\n+func IsTitle(r rune) bool {\n+\tif r <= MaxLatin1 {\n \t\treturn false\n \t}\n-\treturn Is(Title, rune)\n+\treturn Is(Title, r)\n }\n \n // to maps the rune using the specified case mapping.\n-func to(_case int, rune int, caseRange []CaseRange) int {\n+func to(_case int, r rune, caseRange []CaseRange) rune {\n \tif _case < 0 || MaxCase <= _case {\n \t\treturn ReplacementChar // as reasonable an error as any\n \t}\n@@ -184,9 +184,9 @@ func to(_case int, rune int, caseRange []CaseRange) int {\n \thi := len(caseRange)\n \tfor lo < hi {\n \t\tm := lo + (hi-lo)/2\n-\t\tr := caseRange[m]\n-\t\tif int(r.Lo) <= rune && rune <= int(r.Hi) {\n-\t\t\tdelta := int(r.Delta[_case])\n+\t\tcr := caseRange[m]\n+\t\tif rune(cr.Lo) <= r && r <= rune(cr.Hi) {\n+\t\t\tdelta := rune(cr.Delta[_case])\n \t\t\tif delta > MaxRune {\n \t\t\t\t// In an Upper-Lower sequence, which always starts with\n \t\t\t\t// an UpperCase letter, the real deltas always look like:\n@@ -198,82 +198,82 @@ func to(_case int, rune int, caseRange []CaseRange) int {\n \t\t\t\t// bit in the sequence offset.\n \t\t\t\t// The constants UpperCase and TitleCase are even while LowerCase\n \t\t\t\t// is odd so we take the low bit from _case.\n-\t\t\t\treturn int(r.Lo) + ((rune-int(r.Lo))&^1 | _case&1)\n+\t\t\t\treturn rune(cr.Lo) + ((r-rune(cr.Lo))&^1 | rune(_case&1))\n \t\t\t}\n-\t\t\treturn rune + delta\n+\t\t\treturn r + delta\n \t\t}\n-\t\tif rune < int(r.Lo) {\n+\t\tif r < rune(cr.Lo) {\n \t\t\thi = m\n \t\t} else {\n \t\t\tlo = m + 1\n \t\t}\n \t}\n-\treturn rune\n+\treturn r\n }\n \n // To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n-func To(_case int, rune int) int {\n-\treturn to(_case, rune, CaseRanges)\n+func To(_case int, r rune) rune {\n+\treturn to(_case, r, CaseRanges)\n }\n \n // ToUpper maps the rune to upper case.\n-func ToUpper(rune int) int {\n-\tif rune <= MaxASCII {\n-\t\tif 'a' <= rune && rune <= 'z' {\n-\t\t\trune -= 'a' - 'A'\n+func ToUpper(r rune) rune {\n+\tif r <= MaxASCII {\n+\t\tif 'a' <= r && r <= 'z' {\n+\t\t\tr -= 'a' - 'A'\n \t\t}\n-\t\treturn rune\n+\t\treturn r\n \t}\n-\treturn To(UpperCase, rune)\n+\treturn To(UpperCase, r)\n }\n \n // ToLower maps the rune to lower case.\n-func ToLower(rune int) int {\n-\tif rune <= MaxASCII {\n-\t\tif 'A' <= rune && rune <= 'Z' {\n-\t\t\trune += 'a' - 'A'\n+func ToLower(r rune) rune {\n+\tif r <= MaxASCII {\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\tr += 'a' - 'A'\n \t\t}\n-\t\treturn rune\n+\t\treturn r\n \t}\n-\treturn To(LowerCase, rune)\n+\treturn To(LowerCase, r)\n }\n \n // ToTitle maps the rune to title case.\n-func ToTitle(rune int) int {\n-\tif rune <= MaxASCII {\n-\t\tif 'a' <= rune && rune <= 'z' { // title case is upper case for ASCII\n-\t\t\trune -= 'a' - 'A'\n+func ToTitle(r rune) rune {\n+\tif r <= MaxASCII {\n+\t\tif 'a' <= r && r <= 'z' { // title case is upper case for ASCII\n+\t\t\tr -= 'a' - 'A'\n \t\t}\n-\t\treturn rune\n+\t\treturn r\n \t}\n-\treturn To(TitleCase, rune)\n+\treturn To(TitleCase, r)\n }\n \n // ToUpper maps the rune to upper case giving priority to the special mapping.\n-func (special SpecialCase) ToUpper(rune int) int {\n-\tr := to(UpperCase, rune, []CaseRange(special))\n-\tif r == rune {\n-\t\tr = ToUpper(rune)\n+func (special SpecialCase) ToUpper(r rune) rune {\n+\tr1 := to(UpperCase, r, []CaseRange(special))\n+\tif r1 == r {\n+\t\tr1 = ToUpper(r)\n \t}\n-\treturn r\n+\treturn r1\n }\n \n // ToTitle maps the rune to title case giving priority to the special mapping.\n-func (special SpecialCase) ToTitle(rune int) int {\n-\tr := to(TitleCase, rune, []CaseRange(special))\n-\tif r == rune {\n-\t\tr = ToTitle(rune)\n+func (special SpecialCase) ToTitle(r rune) rune {\n+\tr1 := to(TitleCase, r, []CaseRange(special))\n+\tif r1 == r {\n+\t\tr1 = ToTitle(r)\n \t}\n-\treturn r\n+\treturn r1\n }\n \n // ToLower maps the rune to lower case giving priority to the special mapping.\n-func (special SpecialCase) ToLower(rune int) int {\n-\tr := to(LowerCase, rune, []CaseRange(special))\n-\tif r == rune {\n-\t\tr = ToLower(rune)\n+func (special SpecialCase) ToLower(r rune) rune {\n+\tr1 := to(LowerCase, r, []CaseRange(special))\n+\tif r1 == r {\n+\t\tr1 = ToLower(r)\n \t}\n-\treturn r\n+\treturn r1\n }\n \n // caseOrbit is defined in tables.go as []foldPair.  Right now all the\n@@ -300,27 +300,27 @@ type foldPair struct {\n //\n //\tSimpleFold('1') = '1'\n //\n-func SimpleFold(rune int) int {\n+func SimpleFold(r rune) rune {\n \t// Consult caseOrbit table for special cases.\n \tlo := 0\n \thi := len(caseOrbit)\n \tfor lo < hi {\n \t\tm := lo + (hi-lo)/2\n-\t\tif int(caseOrbit[m].From) < rune {\n+\t\tif rune(caseOrbit[m].From) < r {\n \t\t\tlo = m + 1\n \t\t} else {\n \t\t\thi = m\n \t\t}\n \t}\n-\tif lo < len(caseOrbit) && int(caseOrbit[lo].From) == rune {\n-\t\treturn int(caseOrbit[lo].To)\n+\tif lo < len(caseOrbit) && rune(caseOrbit[lo].From) == r {\n+\t\treturn rune(caseOrbit[lo].To)\n \t}\n \n \t// No folding specified.  This is a one- or two-element\n \t// equivalence class containing rune and ToLower(rune)\n \t// and ToUpper(rune) if they are different from rune.\n-\tif l := ToLower(rune); l != rune {\n+\tif l := ToLower(r); l != r {\n \t\treturn l\n \t}\n-\treturn ToUpper(rune)\n+\treturn ToUpper(r)\n }"}, {"sha": "2d80562182cc3498caa23a1e1ad70d5450375351", "filename": "libgo/go/unicode/letter_test.go", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fletter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fletter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fletter_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -9,7 +9,7 @@ import (\n \t. \"unicode\"\n )\n \n-var upperTest = []int{\n+var upperTest = []rune{\n \t0x41,\n \t0xc0,\n \t0xd8,\n@@ -33,7 +33,7 @@ var upperTest = []int{\n \t0x1d7ca,\n }\n \n-var notupperTest = []int{\n+var notupperTest = []rune{\n \t0x40,\n \t0x5b,\n \t0x61,\n@@ -46,7 +46,7 @@ var notupperTest = []int{\n \t0x10000,\n }\n \n-var letterTest = []int{\n+var letterTest = []rune{\n \t0x41,\n \t0x61,\n \t0xaa,\n@@ -82,7 +82,7 @@ var letterTest = []int{\n \t0x2fa1d,\n }\n \n-var notletterTest = []int{\n+var notletterTest = []rune{\n \t0x20,\n \t0x35,\n \t0x375,\n@@ -94,7 +94,7 @@ var notletterTest = []int{\n }\n \n // Contains all the special cased Latin-1 chars.\n-var spaceTest = []int{\n+var spaceTest = []rune{\n \t0x09,\n \t0x0a,\n \t0x0b,\n@@ -108,7 +108,8 @@ var spaceTest = []int{\n }\n \n type caseT struct {\n-\tcas, in, out int\n+\tcas     int\n+\tin, out rune\n }\n \n var caseTest = []caseT{\n@@ -327,7 +328,7 @@ func TestIsSpace(t *testing.T) {\n // Check that the optimizations for IsLetter etc. agree with the tables.\n // We only need to check the Latin-1 range.\n func TestLetterOptimizations(t *testing.T) {\n-\tfor i := 0; i <= MaxLatin1; i++ {\n+\tfor i := rune(0); i <= MaxLatin1; i++ {\n \t\tif Is(Letter, i) != IsLetter(i) {\n \t\t\tt.Errorf(\"IsLetter(U+%04X) disagrees with Is(Letter)\", i)\n \t\t}\n@@ -356,8 +357,8 @@ func TestLetterOptimizations(t *testing.T) {\n }\n \n func TestTurkishCase(t *testing.T) {\n-\tlower := []int(\"abc\u00e7defg\u011fh\u0131ijklmno\u00f6prs\u015ftu\u00fcvyz\")\n-\tupper := []int(\"ABC\u00c7DEFG\u011eHI\u0130JKLMNO\u00d6PRS\u015eTU\u00dcVYZ\")\n+\tlower := []rune(\"abc\u00e7defg\u011fh\u0131ijklmno\u00f6prs\u015ftu\u00fcvyz\")\n+\tupper := []rune(\"ABC\u00c7DEFG\u011eHI\u0130JKLMNO\u00d6PRS\u015eTU\u00dcVYZ\")\n \tfor i, l := range lower {\n \t\tu := upper[i]\n \t\tif TurkishCase.ToLower(l) != l {\n@@ -416,13 +417,13 @@ var simpleFoldTests = []string{\n \n func TestSimpleFold(t *testing.T) {\n \tfor _, tt := range simpleFoldTests {\n-\t\tcycle := []int(tt)\n-\t\trune := cycle[len(cycle)-1]\n+\t\tcycle := []rune(tt)\n+\t\tr := cycle[len(cycle)-1]\n \t\tfor _, out := range cycle {\n-\t\t\tif r := SimpleFold(rune); r != out {\n-\t\t\t\tt.Errorf(\"SimpleFold(%#U) = %#U, want %#U\", rune, r, out)\n+\t\t\tif r := SimpleFold(r); r != out {\n+\t\t\t\tt.Errorf(\"SimpleFold(%#U) = %#U, want %#U\", r, r, out)\n \t\t\t}\n-\t\t\trune = out\n+\t\t\tr = out\n \t\t}\n \t}\n }"}, {"sha": "1c5b801426fa2f6770db9c601c4e507bc6a98acc", "filename": "libgo/go/unicode/script_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Funicode%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Fscript_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -10,7 +10,7 @@ import (\n )\n \n type T struct {\n-\trune   int\n+\trune   rune\n \tscript string\n }\n "}, {"sha": "2b2eb28f2df658709d3ad218c9c128bbf722ab76", "filename": "libgo/go/utf16/utf16.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf16%2Futf16.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf16%2Futf16.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf16%2Futf16.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -20,33 +20,33 @@ const (\n \n // IsSurrogate returns true if the specified Unicode code point\n // can appear in a surrogate pair.\n-func IsSurrogate(rune int) bool {\n-\treturn surr1 <= rune && rune < surr3\n+func IsSurrogate(r rune) bool {\n+\treturn surr1 <= r && r < surr3\n }\n \n // DecodeRune returns the UTF-16 decoding of a surrogate pair.\n // If the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\n // the Unicode replacement code point U+FFFD.\n-func DecodeRune(r1, r2 int) int {\n+func DecodeRune(r1, r2 rune) rune {\n \tif surr1 <= r1 && r1 < surr2 && surr2 <= r2 && r2 < surr3 {\n-\t\treturn (int(r1)-surr1)<<10 | (int(r2) - surr2) + 0x10000\n+\t\treturn (rune(r1)-surr1)<<10 | (rune(r2) - surr2) + 0x10000\n \t}\n \treturn unicode.ReplacementChar\n }\n \n // EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\n // If the rune is not a valid Unicode code point or does not need encoding,\n // EncodeRune returns U+FFFD, U+FFFD.\n-func EncodeRune(rune int) (r1, r2 int) {\n-\tif rune < surrSelf || rune > unicode.MaxRune || IsSurrogate(rune) {\n+func EncodeRune(r rune) (r1, r2 rune) {\n+\tif r < surrSelf || r > unicode.MaxRune || IsSurrogate(r) {\n \t\treturn unicode.ReplacementChar, unicode.ReplacementChar\n \t}\n-\trune -= surrSelf\n-\treturn surr1 + (rune>>10)&0x3ff, surr2 + rune&0x3ff\n+\tr -= surrSelf\n+\treturn surr1 + (r>>10)&0x3ff, surr2 + r&0x3ff\n }\n \n // Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n-func Encode(s []int) []uint16 {\n+func Encode(s []rune) []uint16 {\n \tn := len(s)\n \tfor _, v := range s {\n \t\tif v >= surrSelf {\n@@ -76,15 +76,15 @@ func Encode(s []int) []uint16 {\n \n // Decode returns the Unicode code point sequence represented\n // by the UTF-16 encoding s.\n-func Decode(s []uint16) []int {\n-\ta := make([]int, len(s))\n+func Decode(s []uint16) []rune {\n+\ta := make([]rune, len(s))\n \tn := 0\n \tfor i := 0; i < len(s); i++ {\n \t\tswitch r := s[i]; {\n \t\tcase surr1 <= r && r < surr2 && i+1 < len(s) &&\n \t\t\tsurr2 <= s[i+1] && s[i+1] < surr3:\n \t\t\t// valid surrogate sequence\n-\t\t\ta[n] = DecodeRune(int(r), int(s[i+1]))\n+\t\t\ta[n] = DecodeRune(rune(r), rune(s[i+1]))\n \t\t\ti++\n \t\t\tn++\n \t\tcase surr1 <= r && r < surr3:\n@@ -93,7 +93,7 @@ func Decode(s []uint16) []int {\n \t\t\tn++\n \t\tdefault:\n \t\t\t// normal rune\n-\t\t\ta[n] = int(r)\n+\t\t\ta[n] = rune(r)\n \t\t\tn++\n \t\t}\n \t}"}, {"sha": "7ea290a52999ebfd23792a28efa82e84b9339586", "filename": "libgo/go/utf16/utf16_test.go", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf16%2Futf16_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf16%2Futf16_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf16%2Futf16_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -5,31 +5,30 @@\n package utf16_test\n \n import (\n-\t\"fmt\"\n \t\"reflect\"\n \t\"testing\"\n \t\"unicode\"\n \t. \"utf16\"\n )\n \n type encodeTest struct {\n-\tin  []int\n+\tin  []rune\n \tout []uint16\n }\n \n var encodeTests = []encodeTest{\n-\t{[]int{1, 2, 3, 4}, []uint16{1, 2, 3, 4}},\n-\t{[]int{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff},\n+\t{[]rune{1, 2, 3, 4}, []uint16{1, 2, 3, 4}},\n+\t{[]rune{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff},\n \t\t[]uint16{0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff}},\n-\t{[]int{'a', 'b', 0xd7ff, 0xd800, 0xdfff, 0xe000, 0x110000, -1},\n+\t{[]rune{'a', 'b', 0xd7ff, 0xd800, 0xdfff, 0xe000, 0x110000, -1},\n \t\t[]uint16{'a', 'b', 0xd7ff, 0xfffd, 0xfffd, 0xe000, 0xfffd, 0xfffd}},\n }\n \n func TestEncode(t *testing.T) {\n \tfor _, tt := range encodeTests {\n \t\tout := Encode(tt.in)\n \t\tif !reflect.DeepEqual(out, tt.out) {\n-\t\t\tt.Errorf(\"Encode(%v) = %v; want %v\", hex(tt.in), hex16(out), hex16(tt.out))\n+\t\t\tt.Errorf(\"Encode(%x) = %x; want %x\", tt.in, out, tt.out)\n \t\t}\n \t}\n }\n@@ -53,7 +52,7 @@ func TestEncodeRune(t *testing.T) {\n \t\t\t\t\tt.Errorf(\"#%d: ran out of tt.out\", i)\n \t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tif r1 != int(tt.out[j]) || r2 != int(tt.out[j+1]) {\n+\t\t\t\tif r1 != rune(tt.out[j]) || r2 != rune(tt.out[j+1]) {\n \t\t\t\t\tt.Errorf(\"EncodeRune(%#x) = %#x, %#x; want %#x, %#x\", r, r1, r2, tt.out[j], tt.out[j+1])\n \t\t\t\t}\n \t\t\t\tj += 2\n@@ -71,48 +70,22 @@ func TestEncodeRune(t *testing.T) {\n \n type decodeTest struct {\n \tin  []uint16\n-\tout []int\n+\tout []rune\n }\n \n var decodeTests = []decodeTest{\n-\t{[]uint16{1, 2, 3, 4}, []int{1, 2, 3, 4}},\n+\t{[]uint16{1, 2, 3, 4}, []rune{1, 2, 3, 4}},\n \t{[]uint16{0xffff, 0xd800, 0xdc00, 0xd800, 0xdc01, 0xd808, 0xdf45, 0xdbff, 0xdfff},\n-\t\t[]int{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff}},\n-\t{[]uint16{0xd800, 'a'}, []int{0xfffd, 'a'}},\n-\t{[]uint16{0xdfff}, []int{0xfffd}},\n+\t\t[]rune{0xffff, 0x10000, 0x10001, 0x12345, 0x10ffff}},\n+\t{[]uint16{0xd800, 'a'}, []rune{0xfffd, 'a'}},\n+\t{[]uint16{0xdfff}, []rune{0xfffd}},\n }\n \n func TestDecode(t *testing.T) {\n \tfor _, tt := range decodeTests {\n \t\tout := Decode(tt.in)\n \t\tif !reflect.DeepEqual(out, tt.out) {\n-\t\t\tt.Errorf(\"Decode(%v) = %v; want %v\", hex16(tt.in), hex(out), hex(tt.out))\n+\t\t\tt.Errorf(\"Decode(%x) = %x; want %x\", tt.in, out, tt.out)\n \t\t}\n \t}\n }\n-\n-type hex []int\n-\n-func (h hex) Format(f fmt.State, c int) {\n-\tfmt.Fprint(f, \"[\")\n-\tfor i, v := range h {\n-\t\tif i > 0 {\n-\t\t\tfmt.Fprint(f, \" \")\n-\t\t}\n-\t\tfmt.Fprintf(f, \"%x\", v)\n-\t}\n-\tfmt.Fprint(f, \"]\")\n-}\n-\n-type hex16 []uint16\n-\n-func (h hex16) Format(f fmt.State, c int) {\n-\tfmt.Fprint(f, \"[\")\n-\tfor i, v := range h {\n-\t\tif i > 0 {\n-\t\t\tfmt.Fprint(f, \" \")\n-\t\t}\n-\t\tfmt.Fprintf(f, \"%x\", v)\n-\t}\n-\tfmt.Fprint(f, \"]\")\n-}"}, {"sha": "b33347950fc1d3453fcac77e6cce455e71ab8c6d", "filename": "libgo/go/utf8/string.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Fstring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Fstring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf8%2Fstring.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -101,46 +101,46 @@ func (s *String) Slice(i, j int) string {\n \n // At returns the rune with index i in the String.  The sequence of runes is the same\n // as iterating over the contents with a \"for range\" clause.\n-func (s *String) At(i int) int {\n+func (s *String) At(i int) rune {\n \t// ASCII is easy.  Let the compiler catch the indexing error if there is one.\n \tif i < s.nonASCII {\n-\t\treturn int(s.str[i])\n+\t\treturn rune(s.str[i])\n \t}\n \n \t// Now we do need to know the index is valid.\n \tif i < 0 || i >= s.numRunes {\n \t\tpanic(outOfRange)\n \t}\n \n-\tvar rune int\n+\tvar r rune\n \n \t// Five easy common cases: within 1 spot of bytePos/runePos, or the beginning, or the end.\n \t// With these cases, all scans from beginning or end work in O(1) time per rune.\n \tswitch {\n \n \tcase i == s.runePos-1: // backing up one rune\n-\t\trune, s.width = DecodeLastRuneInString(s.str[0:s.bytePos])\n+\t\tr, s.width = DecodeLastRuneInString(s.str[0:s.bytePos])\n \t\ts.runePos = i\n \t\ts.bytePos -= s.width\n-\t\treturn rune\n+\t\treturn r\n \tcase i == s.runePos+1: // moving ahead one rune\n \t\ts.runePos = i\n \t\ts.bytePos += s.width\n \t\tfallthrough\n \tcase i == s.runePos:\n-\t\trune, s.width = DecodeRuneInString(s.str[s.bytePos:])\n-\t\treturn rune\n+\t\tr, s.width = DecodeRuneInString(s.str[s.bytePos:])\n+\t\treturn r\n \tcase i == 0: // start of string\n-\t\trune, s.width = DecodeRuneInString(s.str)\n+\t\tr, s.width = DecodeRuneInString(s.str)\n \t\ts.runePos = 0\n \t\ts.bytePos = 0\n-\t\treturn rune\n+\t\treturn r\n \n \tcase i == s.numRunes-1: // last rune in string\n-\t\trune, s.width = DecodeLastRuneInString(s.str)\n+\t\tr, s.width = DecodeLastRuneInString(s.str)\n \t\ts.runePos = i\n \t\ts.bytePos = len(s.str) - s.width\n-\t\treturn rune\n+\t\treturn r\n \t}\n \n \t// We need to do a linear scan.  There are three places to start from:\n@@ -173,7 +173,7 @@ func (s *String) At(i int) int {\n \tif forward {\n \t\t// TODO: Is it much faster to use a range loop for this scan?\n \t\tfor {\n-\t\t\trune, s.width = DecodeRuneInString(s.str[s.bytePos:])\n+\t\t\tr, s.width = DecodeRuneInString(s.str[s.bytePos:])\n \t\t\tif s.runePos == i {\n \t\t\t\tbreak\n \t\t\t}\n@@ -182,15 +182,15 @@ func (s *String) At(i int) int {\n \t\t}\n \t} else {\n \t\tfor {\n-\t\t\trune, s.width = DecodeLastRuneInString(s.str[0:s.bytePos])\n+\t\t\tr, s.width = DecodeLastRuneInString(s.str[0:s.bytePos])\n \t\t\ts.runePos--\n \t\t\ts.bytePos -= s.width\n \t\t\tif s.runePos == i {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n-\treturn rune\n+\treturn r\n }\n \n // We want the panic in At(i) to satisfy os.Error, because that's what"}, {"sha": "920d2a0ea31c5f13e5be0bb84d21e602eff7d612", "filename": "libgo/go/utf8/string_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Fstring_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Fstring_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf8%2Fstring_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -12,7 +12,7 @@ import (\n \n func TestScanForwards(t *testing.T) {\n \tfor _, s := range testStrings {\n-\t\trunes := []int(s)\n+\t\trunes := []rune(s)\n \t\tstr := NewString(s)\n \t\tif str.RuneCount() != len(runes) {\n \t\t\tt.Errorf(\"%s: expected %d runes; got %d\", s, len(runes), str.RuneCount())\n@@ -29,7 +29,7 @@ func TestScanForwards(t *testing.T) {\n \n func TestScanBackwards(t *testing.T) {\n \tfor _, s := range testStrings {\n-\t\trunes := []int(s)\n+\t\trunes := []rune(s)\n \t\tstr := NewString(s)\n \t\tif str.RuneCount() != len(runes) {\n \t\t\tt.Errorf(\"%s: expected %d runes; got %d\", s, len(runes), str.RuneCount())\n@@ -57,7 +57,7 @@ func TestRandomAccess(t *testing.T) {\n \t\tif len(s) == 0 {\n \t\t\tcontinue\n \t\t}\n-\t\trunes := []int(s)\n+\t\trunes := []rune(s)\n \t\tstr := NewString(s)\n \t\tif str.RuneCount() != len(runes) {\n \t\t\tt.Errorf(\"%s: expected %d runes; got %d\", s, len(runes), str.RuneCount())\n@@ -79,7 +79,7 @@ func TestRandomSliceAccess(t *testing.T) {\n \t\tif len(s) == 0 || s[0] == '\\x80' { // the bad-UTF-8 string fools this simple test\n \t\t\tcontinue\n \t\t}\n-\t\trunes := []int(s)\n+\t\trunes := []rune(s)\n \t\tstr := NewString(s)\n \t\tif str.RuneCount() != len(runes) {\n \t\t\tt.Errorf(\"%s: expected %d runes; got %d\", s, len(runes), str.RuneCount())"}, {"sha": "a5f9983b332e7448f9c5182f6bb17e336b79af42", "filename": "libgo/go/utf8/utf8.go", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Futf8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Futf8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf8%2Futf8.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -34,7 +34,7 @@ const (\n \trune4Max = 1<<21 - 1\n )\n \n-func decodeRuneInternal(p []byte) (rune, size int, short bool) {\n+func decodeRuneInternal(p []byte) (r rune, size int, short bool) {\n \tn := len(p)\n \tif n < 1 {\n \t\treturn RuneError, 0, true\n@@ -43,7 +43,7 @@ func decodeRuneInternal(p []byte) (rune, size int, short bool) {\n \n \t// 1-byte, 7-bit sequence?\n \tif c0 < tx {\n-\t\treturn int(c0), 1, false\n+\t\treturn rune(c0), 1, false\n \t}\n \n \t// unexpected continuation byte?\n@@ -62,11 +62,11 @@ func decodeRuneInternal(p []byte) (rune, size int, short bool) {\n \n \t// 2-byte, 11-bit sequence?\n \tif c0 < t3 {\n-\t\trune = int(c0&mask2)<<6 | int(c1&maskx)\n-\t\tif rune <= rune1Max {\n+\t\tr = rune(c0&mask2)<<6 | rune(c1&maskx)\n+\t\tif r <= rune1Max {\n \t\t\treturn RuneError, 1, false\n \t\t}\n-\t\treturn rune, 2, false\n+\t\treturn r, 2, false\n \t}\n \n \t// need second continuation byte\n@@ -80,11 +80,11 @@ func decodeRuneInternal(p []byte) (rune, size int, short bool) {\n \n \t// 3-byte, 16-bit sequence?\n \tif c0 < t4 {\n-\t\trune = int(c0&mask3)<<12 | int(c1&maskx)<<6 | int(c2&maskx)\n-\t\tif rune <= rune2Max {\n+\t\tr = rune(c0&mask3)<<12 | rune(c1&maskx)<<6 | rune(c2&maskx)\n+\t\tif r <= rune2Max {\n \t\t\treturn RuneError, 1, false\n \t\t}\n-\t\treturn rune, 3, false\n+\t\treturn r, 3, false\n \t}\n \n \t// need third continuation byte\n@@ -98,18 +98,18 @@ func decodeRuneInternal(p []byte) (rune, size int, short bool) {\n \n \t// 4-byte, 21-bit sequence?\n \tif c0 < t5 {\n-\t\trune = int(c0&mask4)<<18 | int(c1&maskx)<<12 | int(c2&maskx)<<6 | int(c3&maskx)\n-\t\tif rune <= rune3Max {\n+\t\tr = rune(c0&mask4)<<18 | rune(c1&maskx)<<12 | rune(c2&maskx)<<6 | rune(c3&maskx)\n+\t\tif r <= rune3Max {\n \t\t\treturn RuneError, 1, false\n \t\t}\n-\t\treturn rune, 4, false\n+\t\treturn r, 4, false\n \t}\n \n \t// error\n \treturn RuneError, 1, false\n }\n \n-func decodeRuneInStringInternal(s string) (rune, size int, short bool) {\n+func decodeRuneInStringInternal(s string) (r rune, size int, short bool) {\n \tn := len(s)\n \tif n < 1 {\n \t\treturn RuneError, 0, true\n@@ -118,7 +118,7 @@ func decodeRuneInStringInternal(s string) (rune, size int, short bool) {\n \n \t// 1-byte, 7-bit sequence?\n \tif c0 < tx {\n-\t\treturn int(c0), 1, false\n+\t\treturn rune(c0), 1, false\n \t}\n \n \t// unexpected continuation byte?\n@@ -137,11 +137,11 @@ func decodeRuneInStringInternal(s string) (rune, size int, short bool) {\n \n \t// 2-byte, 11-bit sequence?\n \tif c0 < t3 {\n-\t\trune = int(c0&mask2)<<6 | int(c1&maskx)\n-\t\tif rune <= rune1Max {\n+\t\tr = rune(c0&mask2)<<6 | rune(c1&maskx)\n+\t\tif r <= rune1Max {\n \t\t\treturn RuneError, 1, false\n \t\t}\n-\t\treturn rune, 2, false\n+\t\treturn r, 2, false\n \t}\n \n \t// need second continuation byte\n@@ -155,11 +155,11 @@ func decodeRuneInStringInternal(s string) (rune, size int, short bool) {\n \n \t// 3-byte, 16-bit sequence?\n \tif c0 < t4 {\n-\t\trune = int(c0&mask3)<<12 | int(c1&maskx)<<6 | int(c2&maskx)\n-\t\tif rune <= rune2Max {\n+\t\tr = rune(c0&mask3)<<12 | rune(c1&maskx)<<6 | rune(c2&maskx)\n+\t\tif r <= rune2Max {\n \t\t\treturn RuneError, 1, false\n \t\t}\n-\t\treturn rune, 3, false\n+\t\treturn r, 3, false\n \t}\n \n \t// need third continuation byte\n@@ -173,11 +173,11 @@ func decodeRuneInStringInternal(s string) (rune, size int, short bool) {\n \n \t// 4-byte, 21-bit sequence?\n \tif c0 < t5 {\n-\t\trune = int(c0&mask4)<<18 | int(c1&maskx)<<12 | int(c2&maskx)<<6 | int(c3&maskx)\n-\t\tif rune <= rune3Max {\n+\t\tr = rune(c0&mask4)<<18 | rune(c1&maskx)<<12 | rune(c2&maskx)<<6 | rune(c3&maskx)\n+\t\tif r <= rune3Max {\n \t\t\treturn RuneError, 1, false\n \t\t}\n-\t\treturn rune, 4, false\n+\t\treturn r, 4, false\n \t}\n \n \t// error\n@@ -198,28 +198,28 @@ func FullRuneInString(s string) bool {\n }\n \n // DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes.\n-func DecodeRune(p []byte) (rune, size int) {\n-\trune, size, _ = decodeRuneInternal(p)\n+func DecodeRune(p []byte) (r rune, size int) {\n+\tr, size, _ = decodeRuneInternal(p)\n \treturn\n }\n \n // DecodeRuneInString is like DecodeRune but its input is a string.\n-func DecodeRuneInString(s string) (rune, size int) {\n-\trune, size, _ = decodeRuneInStringInternal(s)\n+func DecodeRuneInString(s string) (r rune, size int) {\n+\tr, size, _ = decodeRuneInStringInternal(s)\n \treturn\n }\n \n // DecodeLastRune unpacks the last UTF-8 encoding in p\n // and returns the rune and its width in bytes.\n-func DecodeLastRune(p []byte) (rune, size int) {\n+func DecodeLastRune(p []byte) (r rune, size int) {\n \tend := len(p)\n \tif end == 0 {\n \t\treturn RuneError, 0\n \t}\n \tstart := end - 1\n-\trune = int(p[start])\n-\tif rune < RuneSelf {\n-\t\treturn rune, 1\n+\tr = rune(p[start])\n+\tif r < RuneSelf {\n+\t\treturn r, 1\n \t}\n \t// guard against O(n^2) behavior when traversing\n \t// backwards through strings with long sequences of\n@@ -236,23 +236,23 @@ func DecodeLastRune(p []byte) (rune, size int) {\n \tif start < 0 {\n \t\tstart = 0\n \t}\n-\trune, size = DecodeRune(p[start:end])\n+\tr, size = DecodeRune(p[start:end])\n \tif start+size != end {\n \t\treturn RuneError, 1\n \t}\n-\treturn rune, size\n+\treturn r, size\n }\n \n // DecodeLastRuneInString is like DecodeLastRune but its input is a string.\n-func DecodeLastRuneInString(s string) (rune, size int) {\n+func DecodeLastRuneInString(s string) (r rune, size int) {\n \tend := len(s)\n \tif end == 0 {\n \t\treturn RuneError, 0\n \t}\n \tstart := end - 1\n-\trune = int(s[start])\n-\tif rune < RuneSelf {\n-\t\treturn rune, 1\n+\tr = rune(s[start])\n+\tif r < RuneSelf {\n+\t\treturn r, 1\n \t}\n \t// guard against O(n^2) behavior when traversing\n \t// backwards through strings with long sequences of\n@@ -269,50 +269,48 @@ func DecodeLastRuneInString(s string) (rune, size int) {\n \tif start < 0 {\n \t\tstart = 0\n \t}\n-\trune, size = DecodeRuneInString(s[start:end])\n+\tr, size = DecodeRuneInString(s[start:end])\n \tif start+size != end {\n \t\treturn RuneError, 1\n \t}\n-\treturn rune, size\n+\treturn r, size\n }\n \n // RuneLen returns the number of bytes required to encode the rune.\n-func RuneLen(rune int) int {\n+func RuneLen(r rune) int {\n \tswitch {\n-\tcase rune <= rune1Max:\n+\tcase r <= rune1Max:\n \t\treturn 1\n-\tcase rune <= rune2Max:\n+\tcase r <= rune2Max:\n \t\treturn 2\n-\tcase rune <= rune3Max:\n+\tcase r <= rune3Max:\n \t\treturn 3\n-\tcase rune <= rune4Max:\n+\tcase r <= rune4Max:\n \t\treturn 4\n \t}\n \treturn -1\n }\n \n // EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\n // It returns the number of bytes written.\n-func EncodeRune(p []byte, rune int) int {\n+func EncodeRune(p []byte, r rune) int {\n \t// Negative values are erroneous.  Making it unsigned addresses the problem.\n-\tr := uint(rune)\n-\n-\tif r <= rune1Max {\n+\tif uint32(r) <= rune1Max {\n \t\tp[0] = byte(r)\n \t\treturn 1\n \t}\n \n-\tif r <= rune2Max {\n+\tif uint32(r) <= rune2Max {\n \t\tp[0] = t2 | byte(r>>6)\n \t\tp[1] = tx | byte(r)&maskx\n \t\treturn 2\n \t}\n \n-\tif r > unicode.MaxRune {\n+\tif uint32(r) > unicode.MaxRune {\n \t\tr = RuneError\n \t}\n \n-\tif r <= rune3Max {\n+\tif uint32(r) <= rune3Max {\n \t\tp[0] = t3 | byte(r>>12)\n \t\tp[1] = tx | byte(r>>6)&maskx\n \t\tp[2] = tx | byte(r)&maskx"}, {"sha": "857bcf6e1a67c1b8b9dd95e1d52d0eac54af7dcb", "filename": "libgo/go/utf8/utf8_test.go", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Futf8_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Futf8%2Futf8_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Futf8%2Futf8_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -11,8 +11,8 @@ import (\n )\n \n type Utf8Map struct {\n-\trune int\n-\tstr  string\n+\tr   rune\n+\tstr string\n }\n \n var utf8map = []Utf8Map{\n@@ -58,11 +58,11 @@ func TestFullRune(t *testing.T) {\n \t\tm := utf8map[i]\n \t\tb := []byte(m.str)\n \t\tif !FullRune(b) {\n-\t\t\tt.Errorf(\"FullRune(%q) (%U) = false, want true\", b, m.rune)\n+\t\t\tt.Errorf(\"FullRune(%q) (%U) = false, want true\", b, m.r)\n \t\t}\n \t\ts := m.str\n \t\tif !FullRuneInString(s) {\n-\t\t\tt.Errorf(\"FullRuneInString(%q) (%U) = false, want true\", s, m.rune)\n+\t\t\tt.Errorf(\"FullRuneInString(%q) (%U) = false, want true\", s, m.r)\n \t\t}\n \t\tb1 := b[0 : len(b)-1]\n \t\tif FullRune(b1) {\n@@ -80,10 +80,10 @@ func TestEncodeRune(t *testing.T) {\n \t\tm := utf8map[i]\n \t\tb := []byte(m.str)\n \t\tvar buf [10]byte\n-\t\tn := EncodeRune(buf[0:], m.rune)\n+\t\tn := EncodeRune(buf[0:], m.r)\n \t\tb1 := buf[0:n]\n \t\tif !bytes.Equal(b, b1) {\n-\t\t\tt.Errorf(\"EncodeRune(%#04x) = %q want %q\", m.rune, b1, b)\n+\t\t\tt.Errorf(\"EncodeRune(%#04x) = %q want %q\", m.r, b1, b)\n \t\t}\n \t}\n }\n@@ -92,40 +92,40 @@ func TestDecodeRune(t *testing.T) {\n \tfor i := 0; i < len(utf8map); i++ {\n \t\tm := utf8map[i]\n \t\tb := []byte(m.str)\n-\t\trune, size := DecodeRune(b)\n-\t\tif rune != m.rune || size != len(b) {\n-\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b, rune, size, m.rune, len(b))\n+\t\tr, size := DecodeRune(b)\n+\t\tif r != m.r || size != len(b) {\n+\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b, r, size, m.r, len(b))\n \t\t}\n \t\ts := m.str\n-\t\trune, size = DecodeRuneInString(s)\n-\t\tif rune != m.rune || size != len(b) {\n-\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", s, rune, size, m.rune, len(b))\n+\t\tr, size = DecodeRuneInString(s)\n+\t\tif r != m.r || size != len(b) {\n+\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", s, r, size, m.r, len(b))\n \t\t}\n \n \t\t// there's an extra byte that bytes left behind - make sure trailing byte works\n-\t\trune, size = DecodeRune(b[0:cap(b)])\n-\t\tif rune != m.rune || size != len(b) {\n-\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b, rune, size, m.rune, len(b))\n+\t\tr, size = DecodeRune(b[0:cap(b)])\n+\t\tif r != m.r || size != len(b) {\n+\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b, r, size, m.r, len(b))\n \t\t}\n \t\ts = m.str + \"\\x00\"\n-\t\trune, size = DecodeRuneInString(s)\n-\t\tif rune != m.rune || size != len(b) {\n-\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, %d want %#04x, %d\", s, rune, size, m.rune, len(b))\n+\t\tr, size = DecodeRuneInString(s)\n+\t\tif r != m.r || size != len(b) {\n+\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, %d want %#04x, %d\", s, r, size, m.r, len(b))\n \t\t}\n \n \t\t// make sure missing bytes fail\n \t\twantsize := 1\n \t\tif wantsize >= len(b) {\n \t\t\twantsize = 0\n \t\t}\n-\t\trune, size = DecodeRune(b[0 : len(b)-1])\n-\t\tif rune != RuneError || size != wantsize {\n-\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b[0:len(b)-1], rune, size, RuneError, wantsize)\n+\t\tr, size = DecodeRune(b[0 : len(b)-1])\n+\t\tif r != RuneError || size != wantsize {\n+\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b[0:len(b)-1], r, size, RuneError, wantsize)\n \t\t}\n \t\ts = m.str[0 : len(m.str)-1]\n-\t\trune, size = DecodeRuneInString(s)\n-\t\tif rune != RuneError || size != wantsize {\n-\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, %d want %#04x, %d\", s, rune, size, RuneError, wantsize)\n+\t\tr, size = DecodeRuneInString(s)\n+\t\tif r != RuneError || size != wantsize {\n+\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, %d want %#04x, %d\", s, r, size, RuneError, wantsize)\n \t\t}\n \n \t\t// make sure bad sequences fail\n@@ -134,14 +134,14 @@ func TestDecodeRune(t *testing.T) {\n \t\t} else {\n \t\t\tb[len(b)-1] = 0x7F\n \t\t}\n-\t\trune, size = DecodeRune(b)\n-\t\tif rune != RuneError || size != 1 {\n-\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b, rune, size, RuneError, 1)\n+\t\tr, size = DecodeRune(b)\n+\t\tif r != RuneError || size != 1 {\n+\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, %d want %#04x, %d\", b, r, size, RuneError, 1)\n \t\t}\n \t\ts = string(b)\n-\t\trune, size = DecodeRune(b)\n-\t\tif rune != RuneError || size != 1 {\n-\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, %d want %#04x, %d\", s, rune, size, RuneError, 1)\n+\t\tr, size = DecodeRune(b)\n+\t\tif r != RuneError || size != 1 {\n+\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, %d want %#04x, %d\", s, r, size, RuneError, 1)\n \t\t}\n \n \t}\n@@ -164,7 +164,7 @@ func TestSequencing(t *testing.T) {\n // it's good to verify\n func TestIntConversion(t *testing.T) {\n \tfor _, ts := range testStrings {\n-\t\trunes := []int(ts)\n+\t\trunes := []rune(ts)\n \t\tif RuneCountInString(ts) != len(runes) {\n \t\t\tt.Errorf(\"%q: expected %d runes; got %d\", ts, len(runes), RuneCountInString(ts))\n \t\t\tbreak\n@@ -182,7 +182,7 @@ func TestIntConversion(t *testing.T) {\n func testSequence(t *testing.T, s string) {\n \ttype info struct {\n \t\tindex int\n-\t\trune  int\n+\t\tr     rune\n \t}\n \tindex := make([]info, len(s))\n \tb := []byte(s)\n@@ -195,14 +195,14 @@ func testSequence(t *testing.T, s string) {\n \t\t}\n \t\tindex[j] = info{i, r}\n \t\tj++\n-\t\trune1, size1 := DecodeRune(b[i:])\n-\t\tif r != rune1 {\n-\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, want %#04x\", s[i:], rune1, r)\n+\t\tr1, size1 := DecodeRune(b[i:])\n+\t\tif r != r1 {\n+\t\t\tt.Errorf(\"DecodeRune(%q) = %#04x, want %#04x\", s[i:], r1, r)\n \t\t\treturn\n \t\t}\n-\t\trune2, size2 := DecodeRuneInString(s[i:])\n-\t\tif r != rune2 {\n-\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, want %#04x\", s[i:], rune2, r)\n+\t\tr2, size2 := DecodeRuneInString(s[i:])\n+\t\tif r != r2 {\n+\t\t\tt.Errorf(\"DecodeRuneInString(%q) = %#04x, want %#04x\", s[i:], r2, r)\n \t\t\treturn\n \t\t}\n \t\tif size1 != size2 {\n@@ -213,18 +213,18 @@ func testSequence(t *testing.T, s string) {\n \t}\n \tj--\n \tfor si = len(s); si > 0; {\n-\t\trune1, size1 := DecodeLastRune(b[0:si])\n-\t\trune2, size2 := DecodeLastRuneInString(s[0:si])\n+\t\tr1, size1 := DecodeLastRune(b[0:si])\n+\t\tr2, size2 := DecodeLastRuneInString(s[0:si])\n \t\tif size1 != size2 {\n \t\t\tt.Errorf(\"DecodeLastRune/DecodeLastRuneInString(%q, %d) size mismatch %d/%d\", s, si, size1, size2)\n \t\t\treturn\n \t\t}\n-\t\tif rune1 != index[j].rune {\n-\t\t\tt.Errorf(\"DecodeLastRune(%q, %d) = %#04x, want %#04x\", s, si, rune1, index[j].rune)\n+\t\tif r1 != index[j].r {\n+\t\t\tt.Errorf(\"DecodeLastRune(%q, %d) = %#04x, want %#04x\", s, si, r1, index[j].r)\n \t\t\treturn\n \t\t}\n-\t\tif rune2 != index[j].rune {\n-\t\t\tt.Errorf(\"DecodeLastRuneInString(%q, %d) = %#04x, want %#04x\", s, si, rune2, index[j].rune)\n+\t\tif r2 != index[j].r {\n+\t\t\tt.Errorf(\"DecodeLastRuneInString(%q, %d) = %#04x, want %#04x\", s, si, r2, index[j].r)\n \t\t\treturn\n \t\t}\n \t\tsi -= size1"}, {"sha": "eb358d5dcceb01d2c439b7e78c2de74e359d0063", "filename": "libgo/go/xml/marshal_test.go", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fmarshal_test.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -8,10 +8,10 @@ import (\n \t\"reflect\"\n \t\"testing\"\n \n-\t\"os\"\n \t\"bytes\"\n-\t\"strings\"\n+\t\"os\"\n \t\"strconv\"\n+\t\"strings\"\n )\n \n type DriveType int\n@@ -314,42 +314,39 @@ func TestMarshal(t *testing.T) {\n }\n \n var marshalErrorTests = []struct {\n-\tValue      interface{}\n-\tExpectErr  string\n-\tExpectKind reflect.Kind\n+\tValue interface{}\n+\tErr   string\n+\tKind  reflect.Kind\n }{\n \t{\n-\t\tValue:      make(chan bool),\n-\t\tExpectErr:  \"xml: unsupported type: chan bool\",\n-\t\tExpectKind: reflect.Chan,\n+\t\tValue: make(chan bool),\n+\t\tErr:   \"xml: unsupported type: chan bool\",\n+\t\tKind:  reflect.Chan,\n \t},\n \t{\n \t\tValue: map[string]string{\n \t\t\t\"question\": \"What do you get when you multiply six by nine?\",\n \t\t\t\"answer\":   \"42\",\n \t\t},\n-\t\tExpectErr:  \"xml: unsupported type: map[string] string\",\n-\t\tExpectKind: reflect.Map,\n+\t\tErr:  \"xml: unsupported type: map[string] string\",\n+\t\tKind: reflect.Map,\n \t},\n \t{\n-\t\tValue:      map[*Ship]bool{nil: false},\n-\t\tExpectErr:  \"xml: unsupported type: map[*xml.Ship] bool\",\n-\t\tExpectKind: reflect.Map,\n+\t\tValue: map[*Ship]bool{nil: false},\n+\t\tErr:   \"xml: unsupported type: map[*xml.Ship] bool\",\n+\t\tKind:  reflect.Map,\n \t},\n }\n \n func TestMarshalErrors(t *testing.T) {\n \tfor idx, test := range marshalErrorTests {\n \t\tbuf := bytes.NewBuffer(nil)\n \t\terr := Marshal(buf, test.Value)\n-\t\tif got, want := err, test.ExpectErr; got == nil {\n-\t\t\tt.Errorf(\"#%d: want error %s\", idx, want)\n-\t\t\tcontinue\n-\t\t} else if got.String() != want {\n-\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error] %q, want %q\", idx, test.Value, got, want)\n+\t\tif err == nil || err.String() != test.Err {\n+\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error] %q, want %q\", idx, test.Value, err, test.Err)\n \t\t}\n-\t\tif got, want := err.(*UnsupportedTypeError).Type.Kind(), test.ExpectKind; got != want {\n-\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error kind] %s, want %s\", idx, test.Value, got, want)\n+\t\tif kind := err.(*UnsupportedTypeError).Type.Kind(); kind != test.Kind {\n+\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error kind] %s, want %s\", idx, test.Value, kind, test.Kind)\n \t\t}\n \t}\n }"}, {"sha": "1fe20ac614779e84a94933f672351db98b6c6531", "filename": "libgo/go/xml/read.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fread.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -206,7 +206,7 @@ func fieldName(original string) string {\n \t}\n \n \treturn strings.Map(\n-\t\tfunc(x int) int {\n+\t\tfunc(x rune) rune {\n \t\t\tif x == '_' || unicode.IsDigit(x) || unicode.IsLetter(x) {\n \t\t\t\treturn unicode.ToLower(x)\n \t\t\t}"}, {"sha": "bc03c8e0d49ab5b34025c2f0179729720109161a", "filename": "libgo/go/xml/xml.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fgo%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fxml.go?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -960,13 +960,13 @@ Input:\n // Decide whether the given rune is in the XML Character Range, per\n // the Char production of http://www.xml.com/axml/testaxml.htm,\n // Section 2.2 Characters.\n-func isInCharacterRange(rune int) (inrange bool) {\n-\treturn rune == 0x09 ||\n-\t\trune == 0x0A ||\n-\t\trune == 0x0D ||\n-\t\trune >= 0x20 && rune <= 0xDF77 ||\n-\t\trune >= 0xE000 && rune <= 0xFFFD ||\n-\t\trune >= 0x10000 && rune <= 0x10FFFF\n+func isInCharacterRange(r rune) (inrange bool) {\n+\treturn r == 0x09 ||\n+\t\tr == 0x0A ||\n+\t\tr == 0x0D ||\n+\t\tr >= 0x20 && r <= 0xDF77 ||\n+\t\tr >= 0xE000 && r <= 0xFFFD ||\n+\t\tr >= 0x10000 && r <= 0x10FFFF\n }\n \n // Get name space name: name with a : stuck in the middle.\n@@ -1690,7 +1690,7 @@ func procInstEncoding(s string) string {\n \tif v[0] != '\\'' && v[0] != '\"' {\n \t\treturn \"\"\n \t}\n-\tidx = strings.IndexRune(v[1:], int(v[0]))\n+\tidx = strings.IndexRune(v[1:], rune(v[0]))\n \tif idx == -1 {\n \t\treturn \"\"\n \t}"}, {"sha": "45467ed06c0c381f6592b223a16ec855a89c8094", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -32,10 +32,7 @@\n \n extern char **environ;\n \n-/* These functions are created for the main package.  */\n-extern void __go_init_main (void);\n-extern void real_main (void) asm (\"main.main\");\n-\n+extern void runtime_main (void);\n static void mainstart (void *);\n \n /* The main function.  */\n@@ -47,13 +44,6 @@ main (int argc, char **argv)\n   runtime_args (argc, (byte **) argv);\n   runtime_osinit ();\n   runtime_schedinit ();\n-\n-#if defined(HAVE_SRANDOM)\n-  srandom ((unsigned int) time (NULL));\n-#else\n-  srand ((unsigned int) time (NULL));\n-#endif\n-\n   __go_go (mainstart, NULL);\n   runtime_mstart (runtime_m ());\n   abort ();\n@@ -62,13 +52,5 @@ main (int argc, char **argv)\n static void\n mainstart (void *arg __attribute__ ((unused)))\n {\n-  __go_init_main ();\n-\n-  mstats.enablegc = 1;\n-\n-  real_main ();\n-\n-  runtime_exit (0);\n-\n-  abort ();\n+  runtime_main ();\n }"}, {"sha": "e5c01f550e6d17b439bea4d1ce3c979a091871b7", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -128,6 +128,9 @@ struct Sched {\n \tvolatile uint32 atomic;\t// atomic scheduling word (see below)\n \n \tint32 profilehz;\t// cpu profiling rate\n+\t\n+\tbool init;  // running initialization\n+\tbool lockmain;  // init called runtime.LockOSThread\n \n \tNote\tstopped;\t// one g can set waitstop and wait here for m's to stop\n };\n@@ -292,11 +295,7 @@ runtime_mcall(void (*pfn)(G*))\n //\tmake & queue new G\n //\tcall runtime_mstart\n //\n-// The new G does:\n-//\n-//\tcall main_init_function\n-//\tcall initdone\n-//\tcall main_main\n+// The new G calls runtime_main.\n void\n runtime_schedinit(void)\n {\n@@ -340,6 +339,37 @@ runtime_schedinit(void)\n \tm->nomemprof--;\n }\n \n+extern void main_init(void) __asm__ (\"__go_init_main\");\n+extern void main_main(void) __asm__ (\"main.main\");\n+\n+// The main goroutine.\n+void\n+runtime_main(void)\n+{\n+\t// Lock the main goroutine onto this, the main OS thread,\n+\t// during initialization.  Most programs won't care, but a few\n+\t// do require certain calls to be made by the main thread.\n+\t// Those can arrange for main.main to run in the main thread\n+\t// by calling runtime.LockOSThread during initialization\n+\t// to preserve the lock.\n+\truntime_LockOSThread();\n+\truntime_sched.init = true;\n+\tmain_init();\n+\truntime_sched.init = false;\n+\tif(!runtime_sched.lockmain)\n+\t\truntime_UnlockOSThread();\n+\n+\t// For gccgo we have to wait until after main is initialized\n+\t// to enable GC, because initializing main registers the GC\n+\t// roots.\n+\tmstats.enablegc = 1;\n+\n+\tmain_main();\n+\truntime_exit(0);\n+\tfor(;;)\n+\t\t*(int32*)0 = 0;\n+}\n+\n // Lock the scheduler.\n static void\n schedlock(void)\n@@ -1233,16 +1263,6 @@ runtime_Gosched(void)\n \truntime_gosched();\n }\n \n-void runtime_LockOSThread (void)\n-  __asm__ (\"libgo_runtime.runtime.LockOSThread\");\n-\n-void\n-runtime_LockOSThread(void)\n-{\n-\tm->lockedg = g;\n-\tg->lockedm = m;\n-}\n-\n // delete when scheduler is stronger\n int32\n runtime_gomaxprocsfunc(int32 n)\n@@ -1282,12 +1302,24 @@ runtime_gomaxprocsfunc(int32 n)\n \treturn ret;\n }\n \n-void runtime_UnlockOSThread (void)\n-  __asm__ (\"libgo_runtime.runtime.UnlockOSThread\");\n+void\n+runtime_LockOSThread(void)\n+{\n+\tif(m == &runtime_m0 && runtime_sched.init) {\n+\t\truntime_sched.lockmain = true;\n+\t\treturn;\n+\t}\n+\tm->lockedg = g;\n+\tg->lockedm = m;\n+}\n \n void\n runtime_UnlockOSThread(void)\n {\n+\tif(m == &runtime_m0 && runtime_sched.init) {\n+\t\truntime_sched.lockmain = false;\n+\t\treturn;\n+\t}\n \tm->lockedg = nil;\n \tg->lockedm = nil;\n }"}, {"sha": "0044319709549df46308c8f6d08a8815bf516824", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506cf9aaead4f5519f5549a918d285365b44e989/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=506cf9aaead4f5519f5549a918d285365b44e989", "patch": "@@ -318,16 +318,20 @@ void\truntime_startpanic(void);\n void\truntime_ready(G*);\n const byte*\truntime_getenv(const char*);\n int32\truntime_atoi(const byte*);\n+uint32\truntime_fastrand1(void);\n+\n void\truntime_sigprof(uint8 *pc, uint8 *sp, uint8 *lr, G *gp);\n void\truntime_resetcpuprofiler(int32);\n void\truntime_setcpuprofilerate(void(*)(uintptr*, int32), int32);\n-uint32\truntime_fastrand1(void);\n+void\truntime_usleep(uint32);\n+\n void\truntime_semacquire(uint32 volatile *);\n void\truntime_semrelease(uint32 volatile *);\n int32\truntime_gomaxprocsfunc(int32 n);\n void\truntime_procyield(uint32);\n void\truntime_osyield(void);\n-void\truntime_usleep(uint32);\n+void\truntime_LockOSThread(void) __asm__(\"libgo_runtime.runtime.LockOSThread\");\n+void\truntime_UnlockOSThread(void) __asm__(\"libgo_runtime.runtime.UnlockOSThread\");\n \n struct __go_func_type;\n void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,"}]}