{"sha": "9ca872365c5b30dfb5eb04dbb5e88a68057bdd10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhODcyMzY1YzViMzBkZmI1ZWIwNGRiYjVlODhhNjgwNTdiZGQxMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-03-04T13:25:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-03-04T13:25:27Z"}, "message": "re PR rtl-optimization/40761 (IRA memory hog for insanely nested loops)\n\n2010-03-04  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/40761\n\t* tree-ssa-pre.c (compute_antic): Walk reverse postorder\n\tin reverse order.\n\t(my_rev_post_order_compute): New function.\n\t(init_pre): Call it.\n\nFrom-SVN: r157225", "tree": {"sha": "4edbd6125abaa31622622467b569aeed8922553a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4edbd6125abaa31622622467b569aeed8922553a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10/comments", "author": null, "committer": null, "parents": [{"sha": "c09a001455b78691473a4f2edb18532463f4370a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c09a001455b78691473a4f2edb18532463f4370a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c09a001455b78691473a4f2edb18532463f4370a"}], "stats": {"total": 97, "additions": 92, "deletions": 5}, "files": [{"sha": "4706306172cb1d26df696fe0bcf76756f18a48ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9ca872365c5b30dfb5eb04dbb5e88a68057bdd10", "patch": "@@ -1,8 +1,16 @@\n+2010-03-04  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/40761\n+\t* tree-ssa-pre.c (compute_antic): Walk reverse postorder\n+\tin reverse order.\n+\t(my_rev_post_order_compute): New function.\n+\t(init_pre): Call it.\n+\n 2010-03-04  Changpeng Fang  <changpeng.fang@amd.com>\n \n \tPR middle-end/43209\n-\t* tree-ssa-loop-ivopts.c (determine_use_iv_cost_condition): Do not decrease\n-\tthe cost of an IV candidate when the cost is infinite.\n+\t* tree-ssa-loop-ivopts.c (determine_use_iv_cost_condition): Do not\n+\tdecrease the cost of an IV candidate when the cost is infinite.\n \n 2010-03-04  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n "}, {"sha": "684484fb0caaccd030832080ff7ea7cc7b878657", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ca872365c5b30dfb5eb04dbb5e88a68057bdd10/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=9ca872365c5b30dfb5eb04dbb5e88a68057bdd10", "patch": "@@ -2542,7 +2542,7 @@ compute_antic (void)\n \tfprintf (dump_file, \"Starting iteration %d\\n\", num_iterations);\n       num_iterations++;\n       changed = false;\n-      for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n+      for (i = n_basic_blocks - NUM_FIXED_BLOCKS - 1; i >= 0; i--)\n \t{\n \t  if (TEST_BIT (changed_blocks, postorder[i]))\n \t    {\n@@ -2573,7 +2573,7 @@ compute_antic (void)\n \t    fprintf (dump_file, \"Starting iteration %d\\n\", num_iterations);\n \t  num_iterations++;\n \t  changed = false;\n-\t  for (i = 0; i < n_basic_blocks - NUM_FIXED_BLOCKS; i++)\n+\t  for (i = n_basic_blocks - NUM_FIXED_BLOCKS - 1 ; i >= 0; i--)\n \t    {\n \t      if (TEST_BIT (changed_blocks, postorder[i]))\n \t\t{\n@@ -4507,6 +4507,85 @@ remove_dead_inserted_code (void)\n   VEC_free (gimple, heap, worklist);\n }\n \n+/* Compute a reverse post-order in *POST_ORDER.  If INCLUDE_ENTRY_EXIT is\n+   true, then then ENTRY_BLOCK and EXIT_BLOCK are included.  Returns\n+   the number of visited blocks.  */\n+\n+static int\n+my_rev_post_order_compute (int *post_order, bool include_entry_exit)\n+{\n+  edge_iterator *stack;\n+  int sp;\n+  int post_order_num = 0;\n+  sbitmap visited;\n+  int count;\n+\n+  if (include_entry_exit)\n+    post_order[post_order_num++] = EXIT_BLOCK;\n+\n+  /* Allocate stack for back-tracking up CFG.  */\n+  stack = XNEWVEC (edge_iterator, n_basic_blocks + 1);\n+  sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  visited = sbitmap_alloc (last_basic_block);\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (visited);\n+\n+  /* Push the last edge on to the stack.  */\n+  stack[sp++] = ei_start (EXIT_BLOCK_PTR->preds);\n+\n+  while (sp)\n+    {\n+      edge_iterator ei;\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      ei = stack[sp - 1];\n+      src = ei_edge (ei)->src;\n+      dest = ei_edge (ei)->dest;\n+\n+      /* Check if the edge destination has been visited yet.  */\n+      if (src != ENTRY_BLOCK_PTR && ! TEST_BIT (visited, src->index))\n+        {\n+          /* Mark that we have visited the destination.  */\n+          SET_BIT (visited, src->index);\n+\n+          if (EDGE_COUNT (src->preds) > 0)\n+            /* Since the DEST node has been visited for the first\n+               time, check its successors.  */\n+            stack[sp++] = ei_start (src->preds);\n+          else\n+            post_order[post_order_num++] = src->index;\n+        }\n+      else\n+        {\n+          if (ei_one_before_end_p (ei) && dest != EXIT_BLOCK_PTR)\n+            post_order[post_order_num++] = dest->index;\n+\n+          if (!ei_one_before_end_p (ei))\n+            ei_next (&stack[sp - 1]);\n+          else\n+            sp--;\n+        }\n+    }\n+\n+  if (include_entry_exit)\n+    {\n+      post_order[post_order_num++] = ENTRY_BLOCK;\n+      count = post_order_num;\n+    }\n+  else\n+    count = post_order_num + 2;\n+\n+  free (stack);\n+  sbitmap_free (visited);\n+  return post_order_num;\n+}\n+\n+\n /* Initialize data structures used by PRE.  */\n \n static void\n@@ -4535,7 +4614,7 @@ init_pre (bool do_fre)\n \n \n   postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n-  post_order_compute (postorder, false, false);\n+  my_rev_post_order_compute (postorder, false);\n \n   FOR_ALL_BB (bb)\n     bb->aux = XCNEWVEC (struct bb_bitmap_sets, 1);"}]}