{"sha": "a4dec0d6de97348e71932f7080fe4a3bb8730096", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRkZWMwZDZkZTk3MzQ4ZTcxOTMyZjcwODBmZTRhM2JiODczMDA5Ng==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-12-07T21:12:49Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-12-07T21:12:49Z"}, "message": "stl_map.h (map(const map&)): Make default.\n\n2016-12-07  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/stl_map.h (map(const map&)): Make default.\n\t(map(map&&)): Likewise.\n\t(~map()): Likewise.\n\t(operator=(const map&)): Likewise.\n\t* include/bits/stl_multimap.h (multimap(const multimap&)): Make default.\n\t(multimap(multimap&&)): Likewise.\n\t(~multimap()): Likewise.\n\t(operator=(const multimap&)): Likewise.\n\t* include/bits/stl_set.h (set(const set&)): Make default.\n\t(set(set&&)): Likewise.\n\t(~set()): Likewise.\n\t(operator=(const set&)): Likewise.\n\t* include/bits/stl_multiset.h (multiset(const multiset&)): Make default.\n\t(multiset(multiset&&)): Likewise.\n\t(~multiset()): Likewise.\n\t(operator=(const multiset&)): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree_key_compare<>): New.\n\t(_Rb_tree_header): New.\n\t(_Rb_tree_impl): Inherit from latters.\n\t(_Rb_tree_impl()): Make default.\n\t(_Rb_tree_impl(const _Rb_tree_impl&)): New.\n\t(_Rb_tree<>(const _Rb_tree&): Use latter.\n\t(_Rb_tree_impl(_Rb_tree_impl&&)): New, default.\n\t(_Rb_tree_impl(const _Key_compare&, const _Node_allocator&)): Delete.\n\t(_Rb_tree_impl::_M_reset): Move...\n\t(_Rb_tree_header::_M_reset): ...here.\n\t(_Rb_tree_impl::_M_initialize): Delete.\n\t(_Rb_tree(_Rb_tree&&)): Make default.\n\t(_Rb_tree_header::_M_move_data(_Rb_tree_header&)): New.\n\t(_Rb_tree<>::_M_move_data(_Rb_tree&, true_type)): Use latter.\n\t(_Rb_tree<>(_Rb_tree&&)): Make default.\n\nFrom-SVN: r243379", "tree": {"sha": "ba53d566ffab0ecf6615b97afd77862e9b9d9f82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba53d566ffab0ecf6615b97afd77862e9b9d9f82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4dec0d6de97348e71932f7080fe4a3bb8730096", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dec0d6de97348e71932f7080fe4a3bb8730096", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4dec0d6de97348e71932f7080fe4a3bb8730096", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4dec0d6de97348e71932f7080fe4a3bb8730096/comments", "author": null, "committer": null, "parents": [{"sha": "c89529306c91eafa81c762e9050d51c747c14af0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c89529306c91eafa81c762e9050d51c747c14af0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c89529306c91eafa81c762e9050d51c747c14af0"}], "stats": {"total": 348, "additions": 200, "deletions": 148}, "files": [{"sha": "3feef857c009875c0c389ae9e4e9c65390aed88d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a4dec0d6de97348e71932f7080fe4a3bb8730096", "patch": "@@ -1,3 +1,37 @@\n+2016-12-07  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/stl_map.h (map(const map&)): Make default.\n+\t(map(map&&)): Likewise.\n+\t(~map()): Likewise.\n+\t(operator=(const map&)): Likewise.\n+\t* include/bits/stl_multimap.h (multimap(const multimap&)): Make default.\n+\t(multimap(multimap&&)): Likewise.\n+\t(~multimap()): Likewise.\n+\t(operator=(const multimap&)): Likewise.\n+\t* include/bits/stl_set.h (set(const set&)): Make default.\n+\t(set(set&&)): Likewise.\n+\t(~set()): Likewise.\n+\t(operator=(const set&)): Likewise.\n+\t* include/bits/stl_multiset.h (multiset(const multiset&)): Make default.\n+\t(multiset(multiset&&)): Likewise.\n+\t(~multiset()): Likewise.\n+\t(operator=(const multiset&)): Likewise.\n+\t* include/bits/stl_tree.h (_Rb_tree_key_compare<>): New.\n+\t(_Rb_tree_header): New.\n+\t(_Rb_tree_impl): Inherit from latters.\n+\t(_Rb_tree_impl()): Make default.\n+\t(_Rb_tree_impl(const _Rb_tree_impl&)): New.\n+\t(_Rb_tree<>(const _Rb_tree&): Use latter.\n+\t(_Rb_tree_impl(_Rb_tree_impl&&)): New, default.\n+\t(_Rb_tree_impl(const _Key_compare&, const _Node_allocator&)): Delete.\n+\t(_Rb_tree_impl::_M_reset): Move...\n+\t(_Rb_tree_header::_M_reset): ...here.\n+\t(_Rb_tree_impl::_M_initialize): Delete.\n+\t(_Rb_tree(_Rb_tree&&)): Make default.\n+\t(_Rb_tree_header::_M_move_data(_Rb_tree_header&)): New.\n+\t(_Rb_tree<>::_M_move_data(_Rb_tree&, true_type)): Use latter.\n+\t(_Rb_tree<>(_Rb_tree&&)): Make default.\n+\n 2016-12-07  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/experimental/bits/fs_path.h (path::_S_convert): Replace"}, {"sha": "bbd0a97f24359cf0c0370c54140c28d1151f91c8", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=a4dec0d6de97348e71932f7080fe4a3bb8730096", "patch": "@@ -185,25 +185,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /**\n        *  @brief  %Map copy constructor.\n-       *  @param  __x  A %map of identical element and allocator types.\n        *\n-       *  The newly-created %map uses a copy of the allocator object used\n-       *  by @a __x (unless the allocator traits dictate a different object).\n+       *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       map(const map& __x)\n       : _M_t(__x._M_t) { }\n+#else\n+      map(const map&) = default;\n \n-#if __cplusplus >= 201103L\n       /**\n        *  @brief  %Map move constructor.\n-       *  @param  __x  A %map of identical element and allocator types.\n        *\n-       *  The newly-created %map contains the exact contents of @a __x.\n-       *  The contents of @a __x are a valid, but unspecified %map.\n+       *  The newly-created %map contains the exact contents of the moved\n+       *  instance. The moved instance is a valid, but unspecified, %map.\n        */\n-      map(map&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _M_t(std::move(__x._M_t)) { }\n+      map(map&&) = default;\n \n       /**\n        *  @brief  Builds a %map from an initializer_list.\n@@ -284,31 +281,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t: _M_t(__comp, _Pair_alloc_type(__a))\n         { _M_t._M_insert_unique(__first, __last); }\n \n-      // FIXME There is no dtor declared, but we should have something\n-      // generated by Doxygen.  I don't know what tags to add to this\n-      // paragraph to make that happen:\n+#if __cplusplus >= 201103L\n       /**\n        *  The dtor only erases the elements, and note that if the elements\n        *  themselves are pointers, the pointed-to memory is not touched in any\n        *  way.  Managing the pointer is the user's responsibility.\n        */\n+      ~map() = default;\n+#endif\n \n       /**\n        *  @brief  %Map assignment operator.\n-       *  @param  __x  A %map of identical element and allocator types.\n-       *\n-       *  All the elements of @a __x are copied.\n        *\n        *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       map&\n       operator=(const map& __x)\n       {\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n+#else\n+      map&\n+      operator=(const map&) = default;\n \n-#if __cplusplus >= 201103L\n       /// Move assignment operator.\n       map&\n       operator=(map&&) = default;"}, {"sha": "a5f775b468f053e58fada8a4704d0057302f45db", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=a4dec0d6de97348e71932f7080fe4a3bb8730096", "patch": "@@ -182,25 +182,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /**\n        *  @brief  %Multimap copy constructor.\n-       *  @param  __x  A %multimap of identical element and allocator types.\n        *\n-       *  The newly-created %multimap uses a copy of the allocator object used\n-       *  by @a __x (unless the allocator traits dictate a different object).\n+       *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       multimap(const multimap& __x)\n       : _M_t(__x._M_t) { }\n+#else\n+      multimap(const multimap&) = default;\n \n-#if __cplusplus >= 201103L\n       /**\n        *  @brief  %Multimap move constructor.\n-       *  @param   __x  A %multimap of identical element and allocator types.\n        *\n-       *  The newly-created %multimap contains the exact contents of @a __x.\n-       *  The contents of @a __x are a valid, but unspecified %multimap.\n+       *  The newly-created %multimap contains the exact contents of the\n+       *  moved instance. The moved instance is a valid, but unspecified\n+       *  %multimap.\n        */\n-      multimap(multimap&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _M_t(std::move(__x._M_t)) { }\n+      multimap(multimap&&) = default;\n \n       /**\n        *  @brief  Builds a %multimap from an initializer_list.\n@@ -278,31 +276,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t: _M_t(__comp, _Pair_alloc_type(__a))\n         { _M_t._M_insert_equal(__first, __last); }\n \n-      // FIXME There is no dtor declared, but we should have something generated\n-      // by Doxygen.  I don't know what tags to add to this paragraph to make\n-      // that happen:\n+#if __cplusplus >= 201103L\n       /**\n        *  The dtor only erases the elements, and note that if the elements\n        *  themselves are pointers, the pointed-to memory is not touched in any\n-       *  way.  Managing the pointer is the user's responsibility.\n+       *  way. Managing the pointer is the user's responsibility.\n        */\n+      ~multimap() = default;\n+#endif\n \n       /**\n        *  @brief  %Multimap assignment operator.\n-       *  @param  __x  A %multimap of identical element and allocator types.\n-       *\n-       *  All the elements of @a __x are copied.\n        *\n        *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       multimap&\n       operator=(const multimap& __x)\n       {\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n+#else\n+      multimap&\n+      operator=(const multimap&) = default;\n \n-#if __cplusplus >= 201103L\n       /// Move assignment operator.\n       multimap&\n       operator=(multimap&&) = default;"}, {"sha": "8a83b177ac9e48b74b8b714cb13e37aed531d6e5", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=a4dec0d6de97348e71932f7080fe4a3bb8730096", "patch": "@@ -194,25 +194,23 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /**\n        *  @brief  %Multiset copy constructor.\n-       *  @param  __x  A %multiset of identical element and allocator types.\n        *\n-       *  The newly-created %multiset uses a copy of the allocator object used\n-       *  by @a __x (unless the allocator traits dictate a different object).\n+       *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       multiset(const multiset& __x)\n       : _M_t(__x._M_t) { }\n+#else\n+      multiset(const multiset&) = default;\n \n-#if __cplusplus >= 201103L\n      /**\n        *  @brief  %Multiset move constructor.\n-       *  @param  __x  A %multiset of identical element and allocator types.\n        *\n-       *  The newly-created %multiset contains the exact contents of @a __x.\n-       *  The contents of @a __x are a valid, but unspecified %multiset.\n+       *  The newly-created %multiset contains the exact contents of the\n+       *  moved instance. The moved instance is a valid, but unspecified\n+       *  %multiset.\n        */\n-      multiset(multiset&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _M_t(std::move(__x._M_t)) { }\n+      multiset(multiset&&) = default;\n \n       /**\n        *  @brief  Builds a %multiset from an initializer_list.\n@@ -256,24 +254,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t\t const allocator_type& __a)\n \t: _M_t(_Compare(), _Key_alloc_type(__a))\n         { _M_t._M_insert_equal(__first, __last); }\n+\n+      /**\n+       *  The dtor only erases the elements, and note that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way. Managing the pointer is the user's responsibility.\n+       */\n+      ~multiset() = default;\n #endif\n \n       /**\n        *  @brief  %Multiset assignment operator.\n-       *  @param  __x  A %multiset of identical element and allocator types.\n-       *\n-       *  All the elements of @a __x are copied.\n        *\n        *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       multiset&\n       operator=(const multiset& __x)\n       {\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n+#else\n+      multiset&\n+      operator=(const multiset&) = default;\n \n-#if __cplusplus >= 201103L\n       /// Move assignment operator.\n       multiset&\n       operator=(multiset&&) = default;"}, {"sha": "db1e031dc3621d860189e0de140a210632b2dd38", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=a4dec0d6de97348e71932f7080fe4a3bb8730096", "patch": "@@ -199,25 +199,22 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \n       /**\n        *  @brief  %Set copy constructor.\n-       *  @param  __x  A %set of identical element and allocator types.\n        *\n-       *  The newly-created %set uses a copy of the allocator object used\n-       *  by @a __x (unless the allocator traits dictate a different object).\n+       *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       set(const set& __x)\n       : _M_t(__x._M_t) { }\n+#else\n+      set(const set&) = default;\n \n-#if __cplusplus >= 201103L\n      /**\n        *  @brief %Set move constructor\n-       *  @param __x  A %set of identical element and allocator types.\n        *\n-       *  The newly-created %set contains the exact contents of @a x.\n-       *  The contents of @a x are a valid, but unspecified %set.\n+       *  The newly-created %set contains the exact contents of the moved\n+       *  instance. The moved instance is a valid, but unspecified, %set.\n        */\n-      set(set&& __x)\n-      noexcept(is_nothrow_copy_constructible<_Compare>::value)\n-      : _M_t(std::move(__x._M_t)) { }\n+      set(set&&) = default;\n \n       /**\n        *  @brief  Builds a %set from an initializer_list.\n@@ -261,24 +258,31 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t    const allocator_type& __a)\n \t: _M_t(_Compare(), _Key_alloc_type(__a))\n         { _M_t._M_insert_unique(__first, __last); }\n+\n+      /**\n+       *  The dtor only erases the elements, and note that if the elements\n+       *  themselves are pointers, the pointed-to memory is not touched in any\n+       *  way. Managing the pointer is the user's responsibility.\n+       */\n+      ~set() = default;\n #endif\n \n       /**\n        *  @brief  %Set assignment operator.\n-       *  @param  __x  A %set of identical element and allocator types.\n-       *\n-       *  All the elements of @a __x are copied.\n        *\n        *  Whether the allocator is copied depends on the allocator traits.\n        */\n+#if __cplusplus < 201103L\n       set&\n       operator=(const set& __x)\n       {\n \t_M_t = __x._M_t;\n \treturn *this;\n       }\n+#else\n+      set&\n+      operator=(const set&) = default;\n \n-#if __cplusplus >= 201103L\n       /// Move assignment operator.\n       set&\n       operator=(set&&) = default;"}, {"sha": "f5bb5f78946452720d9b4b69f35026052aeaaf81", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 99, "deletions": 85, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4dec0d6de97348e71932f7080fe4a3bb8730096/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=a4dec0d6de97348e71932f7080fe4a3bb8730096", "patch": "@@ -137,6 +137,80 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n   };\n \n+  // Helper type offering value initialization guarantee on the compare functor.\n+  template<typename _Key_compare>\n+    struct _Rb_tree_key_compare\n+    {\n+      _Key_compare\t\t_M_key_compare;\n+\n+      _Rb_tree_key_compare()\n+      _GLIBCXX_NOEXCEPT_IF(\n+\tis_nothrow_default_constructible<_Key_compare>::value)\n+      : _M_key_compare()\n+      { }\n+\n+      _Rb_tree_key_compare(const _Key_compare& __comp)\n+      : _M_key_compare(__comp)\n+      { }\n+\n+#if __cplusplus >= 201103L\n+      // Copy constructor added for consistency with C++98 mode.\n+      _Rb_tree_key_compare(const _Rb_tree_key_compare&) = default;\n+\n+      _Rb_tree_key_compare(_Rb_tree_key_compare&& __x)\n+\tnoexcept(is_nothrow_copy_constructible<_Key_compare>::value)\n+      : _M_key_compare(__x._M_key_compare)\n+      { }\n+#endif\n+    };\n+\n+  // Helper type to manage default initialization of node count and header.\n+  struct _Rb_tree_header\n+  {\n+    _Rb_tree_node_base\t_M_header;\n+    size_t\t\t_M_node_count; // Keeps track of size of tree.\n+\n+    _Rb_tree_header() _GLIBCXX_NOEXCEPT\n+    {\n+      _M_header._M_color = _S_red;\n+      _M_reset();\n+    }\n+\n+#if __cplusplus >= 201103L\n+    _Rb_tree_header(_Rb_tree_header&& __x) noexcept\n+    {\n+      if (__x._M_header._M_parent != nullptr)\n+\t_M_move_data(__x);\n+      else\n+\t{\n+\t  _M_header._M_color = _S_red;\n+\t  _M_reset();\n+\t}\n+    }\n+#endif\n+\n+    void\n+    _M_move_data(_Rb_tree_header& __from)\n+    {\n+      _M_header._M_parent = __from._M_header._M_parent;\n+      _M_header._M_left = __from._M_header._M_left;\n+      _M_header._M_right = __from._M_header._M_right;\n+      _M_header._M_parent->_M_parent = &_M_header;\n+      _M_node_count = __from._M_node_count;\n+\n+      __from._M_reset();\n+    }\n+\n+    void\n+    _M_reset()\n+    {\n+      _M_header._M_parent = 0;\n+      _M_header._M_left = &_M_header;\n+      _M_header._M_right = &_M_header;\n+      _M_node_count = 0;\n+    }\n+  };\n+\n   template<typename _Val>\n     struct _Rb_tree_node : public _Rb_tree_node_base\n     {\n@@ -599,50 +673,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Unused _Is_pod_comparator is kept as it is part of mangled name.\n       template<typename _Key_compare,\n \t       bool /* _Is_pod_comparator */ = __is_pod(_Key_compare)>\n-        struct _Rb_tree_impl : public _Node_allocator\n+        struct _Rb_tree_impl\n+\t: public _Node_allocator\n+\t, public _Rb_tree_key_compare<_Key_compare>\n+\t, public _Rb_tree_header\n         {\n-\t  _Key_compare\t\t_M_key_compare;\n-\t  _Rb_tree_node_base\t_M_header;\n-\t  size_type\t\t_M_node_count; // Keeps track of size of tree.\n+\t  typedef _Rb_tree_key_compare<_Key_compare> _Base_key_compare;\n \n+#if __cplusplus < 201103L\n \t  _Rb_tree_impl()\n-\t  _GLIBCXX_NOEXCEPT_IF(\n-\t    is_nothrow_default_constructible<_Node_allocator>::value\n-\t    && is_nothrow_default_constructible<_Key_compare>::value)\n-\t  : _Node_allocator(), _M_key_compare(), _M_header(),\n-\t    _M_node_count(0)\n-\t  { _M_initialize(); }\n-\n-\t  _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)\n-\t  : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),\n-\t    _M_node_count(0)\n-\t  { _M_initialize(); }\n+\t  { }\n+#else\n+\t  _Rb_tree_impl() = default;\n+#endif\n+\n+\t  _Rb_tree_impl(const _Rb_tree_impl& __x)\n+\t  : _Node_allocator(_Alloc_traits::_S_select_on_copy(__x))\n+\t  , _Base_key_compare(__x._M_key_compare)\n+\t  { }\n \n #if __cplusplus >= 201103L\n+\t  _Rb_tree_impl(_Rb_tree_impl&&) = default;\n \t  _Rb_tree_impl(const _Key_compare& __comp, _Node_allocator&& __a)\n-\t  : _Node_allocator(std::move(__a)), _M_key_compare(__comp),\n-\t    _M_header(), _M_node_count(0)\n-\t  { _M_initialize(); }\n+\t  : _Node_allocator(std::move(__a)), _Base_key_compare(__comp)\n+\t  { }\n #endif\n-\n-\t  void\n-\t  _M_reset()\n-\t  {\n-\t    this->_M_header._M_parent = 0;\n-\t    this->_M_header._M_left = &this->_M_header;\n-\t    this->_M_header._M_right = &this->_M_header;\n-\t    this->_M_node_count = 0;\n-\t  }\n-\n-\tprivate:\n-\t  void\n-\t  _M_initialize()\n-\t  {\n-\t    this->_M_header._M_color = _S_red;\n-\t    this->_M_header._M_parent = 0;\n-\t    this->_M_header._M_left = &this->_M_header;\n-\t    this->_M_header._M_right = &this->_M_header;\n-\t  }\n \t};\n \n       _Rb_tree_impl<_Compare> _M_impl;\n@@ -845,8 +900,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       : _M_impl(__comp, _Node_allocator(__a)) { }\n \n       _Rb_tree(const _Rb_tree& __x)\n-      : _M_impl(__x._M_impl._M_key_compare,\n-\t        _Alloc_traits::_S_select_on_copy(__x._M_get_Node_allocator()))\n+      : _M_impl(__x._M_impl)\n       {\n \tif (__x._M_root() != 0)\n \t  {\n@@ -874,13 +928,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n       }\n \n-      _Rb_tree(_Rb_tree&& __x)\n-      : _M_impl(__x._M_impl._M_key_compare,\n-\t\tstd::move(__x._M_get_Node_allocator()))\n-      {\n-\tif (__x._M_root() != 0)\n-\t  _M_move_data(__x, std::true_type());\n-      }\n+      _Rb_tree(_Rb_tree&&) = default;\n \n       _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)\n       : _Rb_tree(std::move(__x), _Node_allocator(__a))\n@@ -1278,7 +1326,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       // Move elements from container with equal allocator.\n       void\n-      _M_move_data(_Rb_tree&, std::true_type);\n+      _M_move_data(_Rb_tree& __x, std::true_type)\n+      { _M_impl._M_move_data(__x._M_impl); }\n \n       // Move elements from container with possibly non-equal allocator,\n       // which might result in a copy not a move.\n@@ -1529,33 +1578,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_move_data(__x, __eq());\n     }\n \n-  template<typename _Key, typename _Val, typename _KeyOfValue,\n-           typename _Compare, typename _Alloc>\n-    void\n-    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n-    _M_move_data(_Rb_tree& __x, std::true_type)\n-    {\n-      _M_root() = __x._M_root();\n-      _M_leftmost() = __x._M_leftmost();\n-      _M_rightmost() = __x._M_rightmost();\n-      _M_root()->_M_parent = _M_end();\n-\n-      __x._M_root() = 0;\n-      __x._M_leftmost() = __x._M_end();\n-      __x._M_rightmost() = __x._M_end();\n-\n-      this->_M_impl._M_node_count = __x._M_impl._M_node_count;\n-      __x._M_impl._M_node_count = 0;\n-    }\n-\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     _M_move_data(_Rb_tree& __x, std::false_type)\n     {\n       if (_M_get_Node_allocator() == __x._M_get_Node_allocator())\n-\t  _M_move_data(__x, std::true_type());\n+\t_M_move_data(__x, std::true_type());\n       else\n \t{\n \t  _Alloc_node __an(*this);\n@@ -1966,26 +1996,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (_M_root() == 0)\n \t{\n \t  if (__t._M_root() != 0)\n-\t    {\n-\t      _M_root() = __t._M_root();\n-\t      _M_leftmost() = __t._M_leftmost();\n-\t      _M_rightmost() = __t._M_rightmost();\n-\t      _M_root()->_M_parent = _M_end();\n-\t      _M_impl._M_node_count = __t._M_impl._M_node_count;\n-\t      \n-\t      __t._M_impl._M_reset();\n-\t    }\n+\t    _M_impl._M_move_data(__t._M_impl);\n \t}\n       else if (__t._M_root() == 0)\n-\t{\n-\t  __t._M_root() = _M_root();\n-\t  __t._M_leftmost() = _M_leftmost();\n-\t  __t._M_rightmost() = _M_rightmost();\n-\t  __t._M_root()->_M_parent = __t._M_end();\n-\t  __t._M_impl._M_node_count = _M_impl._M_node_count;\n-\t  \n-\t  _M_impl._M_reset();\n-\t}\n+\t__t._M_impl._M_move_data(_M_impl);\n       else\n \t{\n \t  std::swap(_M_root(),__t._M_root());"}]}