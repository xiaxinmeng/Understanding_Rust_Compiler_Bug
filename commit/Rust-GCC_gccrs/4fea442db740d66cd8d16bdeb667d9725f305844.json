{"sha": "4fea442db740d66cd8d16bdeb667d9725f305844", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlYTQ0MmRiNzQwZDY2Y2Q4ZDE2YmRlYjY2N2Q5NzI1ZjMwNTg0NA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-10-31T16:20:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-10-31T16:20:05Z"}, "message": "Implement multiple 'auto' feature from Concepts TS.\n\n\t* parser.c (cp_parser_type_id_1): Allow 'auto' if -fconcepts.\n\t(cp_parser_template_type_arg): Likewise.\n\t(get_concept_from_constraint): Split out most logic to...\n\t* constraint.cc (placeholder_extract_concept_and_args): ...here.\n\t(equivalent_placeholder_constraints, hash_placeholder_constraint): New.\n\t* cxx-pretty-print.c (pp_cxx_constrained_type_spec): New.\n\t* cxx-pretty-print.h: Declare it.\n\t* error.c (dump_type) [TEMPLATE_TYPE_PARM]: Call it.\n\t* pt.c (is_auto_r, extract_autos_r, extract_autos, auto_hash): New.\n\t(type_uses_auto): Use is_auto_r.\n\t(do_auto_deduction): Handle multiple 'auto's if -fconcepts.\n\t* typeck.c (structural_comptypes) [TEMPLATE_TYPE_PARM]: Compare\n\tconstraints.\n\nFrom-SVN: r229629", "tree": {"sha": "58ced5bf7feb8ee0c6ac2b1c7d216ad00966909d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58ced5bf7feb8ee0c6ac2b1c7d216ad00966909d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fea442db740d66cd8d16bdeb667d9725f305844", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fea442db740d66cd8d16bdeb667d9725f305844", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fea442db740d66cd8d16bdeb667d9725f305844", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fea442db740d66cd8d16bdeb667d9725f305844/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a459b07fa440fcb449e9b65cf0cc649905b6ba9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a459b07fa440fcb449e9b65cf0cc649905b6ba9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a459b07fa440fcb449e9b65cf0cc649905b6ba9e"}], "stats": {"total": 326, "additions": 295, "deletions": 31}, "files": [{"sha": "d283cbe5f3acc1665842abf0b7ae0aa514a30c28", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -1,5 +1,20 @@\n 2015-10-31  Jason Merrill  <jason@redhat.com>\n \n+\tImplement multiple 'auto' feature from Concepts TS.\n+\t* parser.c (cp_parser_type_id_1): Allow 'auto' if -fconcepts.\n+\t(cp_parser_template_type_arg): Likewise.\n+\t(get_concept_from_constraint): Split out most logic to...\n+\t* constraint.cc (placeholder_extract_concept_and_args): ...here.\n+\t(equivalent_placeholder_constraints, hash_placeholder_constraint): New.\n+\t* cxx-pretty-print.c (pp_cxx_constrained_type_spec): New.\n+\t* cxx-pretty-print.h: Declare it.\n+\t* error.c (dump_type) [TEMPLATE_TYPE_PARM]: Call it.\n+\t* pt.c (is_auto_r, extract_autos_r, extract_autos, auto_hash): New.\n+\t(type_uses_auto): Use is_auto_r.\n+\t(do_auto_deduction): Handle multiple 'auto's if -fconcepts.\n+\t* typeck.c (structural_comptypes) [TEMPLATE_TYPE_PARM]: Compare\n+\tconstraints.\n+\n \t* pt.c (for_each_template_parm_r): Use WALK_SUBTREE.\n \tReturn a meaningful value rather than error_mark_node.\n \t(for_each_template_parm): Return a tree."}, {"sha": "a1fbf174ee85cfee8e4326323bf54ae4f68c6f2b", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -1379,6 +1379,89 @@ make_constrained_auto (tree con, tree args)\n   return decl;\n }\n \n+/* Given the predicate constraint T from a placeholder type, extract its\n+   TMPL and ARGS.  */\n+\n+void\n+placeholder_extract_concept_and_args (tree t, tree &tmpl, tree &args)\n+{\n+  gcc_assert (TREE_CODE (t) == PRED_CONSTR);\n+  t = PRED_CONSTR_EXPR (t);\n+  gcc_assert (TREE_CODE (t) == CALL_EXPR\n+              || TREE_CODE (t) == TEMPLATE_ID_EXPR\n+              || VAR_P (t));\n+\n+  if (TREE_CODE (t) == CALL_EXPR)\n+    t = CALL_EXPR_FN (t);\n+  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)\n+    {\n+      tmpl = TREE_OPERAND (t, 0);\n+      if (TREE_CODE (tmpl) == OVERLOAD)\n+\t{\n+\t  gcc_assert (OVL_CHAIN (tmpl) == NULL_TREE);\n+\t  tmpl = OVL_FUNCTION (tmpl);\n+\t}\n+      args = TREE_OPERAND (t, 1);\n+    }\n+  else if (DECL_P (t))\n+    {\n+      tmpl = DECL_TI_TEMPLATE (t);\n+      args = DECL_TI_ARGS (t);\n+    }\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Returns true iff the placeholders C1 and C2 are equivalent.  C1\n+   and C2 can be either PRED_CONSTR_EXPR or TEMPLATE_TYPE_PARM.  */\n+\n+bool\n+equivalent_placeholder_constraints (tree c1, tree c2)\n+{\n+  if (TREE_CODE (c1) == TEMPLATE_TYPE_PARM)\n+    c1 = PLACEHOLDER_TYPE_CONSTRAINTS (c1);\n+  if (TREE_CODE (c2) == TEMPLATE_TYPE_PARM)\n+    c2 = PLACEHOLDER_TYPE_CONSTRAINTS (c2);\n+\n+  if (c1 == c2)\n+    return true;\n+  if (!c1 || !c2)\n+    return false;\n+\n+  tree t1, t2, a1, a2;\n+  placeholder_extract_concept_and_args (c1, t1, a1);\n+  placeholder_extract_concept_and_args (c2, t2, a2);\n+\n+  if (t1 != t2)\n+    return false;\n+  int len = TREE_VEC_LENGTH (a1);\n+  if (len != TREE_VEC_LENGTH (a2))\n+    return false;\n+  /* Skip the first argument to avoid infinite recursion on the\n+     placeholder auto itself.  */\n+  for (int i = len-1; i > 0; --i)\n+    if (!cp_tree_equal (TREE_VEC_ELT (a1, i),\n+\t\t\tTREE_VEC_ELT (a2, i)))\n+      return false;\n+  return true;\n+}\n+\n+/* Return a hash value for the placeholder PRED_CONSTR C.  */\n+\n+hashval_t\n+hash_placeholder_constraint (tree c)\n+{\n+  tree t, a;\n+  placeholder_extract_concept_and_args (c, t, a);\n+\n+  /* Like hash_tmpl_and_args, but skip the first argument.  */\n+  hashval_t val = iterative_hash_object (DECL_UID (t), 0);\n+\n+  for (int i = TREE_VEC_LENGTH (a)-1; i > 0; --i)\n+    val = iterative_hash_template_arg (TREE_VEC_ELT (a, i), val);\n+\n+  return val;\n+}\n \n /*---------------------------------------------------------------------------\n                         Constraint substitution"}, {"sha": "adb4bae0a22b52095d965286ec8a4088a806c5a3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -6729,6 +6729,9 @@ extern tree get_shorthand_constraints           (tree);\n extern tree build_concept_check                 (tree, tree, tree = NULL_TREE);\n extern tree build_constrained_parameter         (tree, tree, tree = NULL_TREE);\n extern tree make_constrained_auto               (tree, tree);\n+extern void placeholder_extract_concept_and_args (tree, tree&, tree&);\n+extern bool equivalent_placeholder_constraints  (tree, tree);\n+extern hashval_t hash_placeholder_constraint\t(tree);\n extern bool deduce_constrained_parameter        (tree, tree&, tree&);\n extern tree resolve_constraint_check            (tree);\n extern tree check_function_concept              (tree);"}, {"sha": "72bbfc5c318392d6150c6b3736e25d4e1ccc5efa", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -2195,6 +2195,26 @@ pp_cxx_canonical_template_parameter (cxx_pretty_printer *pp, tree parm)\n   pp_cxx_end_template_argument_list (pp);\n }\n \n+/* Print a constrained-type-specifier.  */\n+\n+void\n+pp_cxx_constrained_type_spec (cxx_pretty_printer *pp, tree c)\n+{\n+  tree t, a;\n+  placeholder_extract_concept_and_args (c, t, a);\n+  pp->id_expression (t);\n+  if (TREE_VEC_LENGTH (a) > 1)\n+    {\n+      pp_cxx_begin_template_argument_list (pp);\n+      tree args = make_tree_vec (TREE_VEC_LENGTH (a) - 1);\n+      for (int i = TREE_VEC_LENGTH (a) - 1; i > 0; --i)\n+\tTREE_VEC_ELT (args, i-1) = TREE_VEC_ELT (a, i);\n+      pp_cxx_template_argument_list (pp, args);\n+      ggc_free (args);\n+      pp_cxx_end_template_argument_list (pp);\n+    }\n+}\n+\n /*\n   template-declaration:\n      export(opt) template < template-parameter-list > declaration"}, {"sha": "9bb9ccf6e66192c8bc23898d074fe516ecb43cc9", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -107,5 +107,6 @@ void pp_cxx_parameterized_constraint (cxx_pretty_printer *, tree);\n void pp_cxx_conjunction (cxx_pretty_printer *, tree);\n void pp_cxx_disjunction (cxx_pretty_printer *, tree);\n void pp_cxx_constraint (cxx_pretty_printer *, tree);\n+void pp_cxx_constrained_type_spec (cxx_pretty_printer *, tree);\n \n #endif /* GCC_CXX_PRETTY_PRINT_H */"}, {"sha": "75f6abb415f90e5f11d198c6393b624f801619a5", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -494,7 +494,9 @@ dump_type (cxx_pretty_printer *pp, tree t, int flags)\n \n     case TEMPLATE_TYPE_PARM:\n       pp_cxx_cv_qualifier_seq (pp, t);\n-      if (TYPE_IDENTIFIER (t))\n+      if (tree c = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n+\tpp_cxx_constrained_type_spec (pp, c);\n+      else if (TYPE_IDENTIFIER (t))\n \tpp_cxx_tree_identifier (pp, TYPE_IDENTIFIER (t));\n       else\n \tpp_cxx_canonical_template_parameter"}, {"sha": "19e306df4ba029bcb740aec1d0f48d95c2134606", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -19442,6 +19442,8 @@ cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,\n     abstract_declarator = NULL;\n \n   if (type_specifier_seq.type\n+      /* The concepts TS allows 'auto' as a type-id.  */\n+      && !flag_concepts\n       /* None of the valid uses of 'auto' in C++14 involve the type-id\n \t nonterminal, but it is valid in a trailing-return-type.  */\n       && !(cxx_dialect >= cxx14 && is_trailing_return)\n@@ -19484,7 +19486,7 @@ cp_parser_template_type_arg (cp_parser *parser)\n     = G_(\"types may not be defined in template arguments\");\n   r = cp_parser_type_id_1 (parser, true, false);\n   parser->type_definition_forbidden_message = saved_message;\n-  if (cxx_dialect >= cxx14 && type_uses_auto (r))\n+  if (cxx_dialect >= cxx14 && !flag_concepts && type_uses_auto (r))\n     {\n       error (\"invalid use of %<auto%> in template argument\");\n       r = error_mark_node;\n@@ -36557,23 +36559,9 @@ tree_type_is_auto_or_concept (const_tree t)\n static tree\n get_concept_from_constraint (tree t)\n {\n-  gcc_assert (TREE_CODE (t) == PRED_CONSTR);\n-  t = PRED_CONSTR_EXPR (t);\n-  gcc_assert (TREE_CODE (t) == CALL_EXPR\n-              || TREE_CODE (t) == TEMPLATE_ID_EXPR\n-              || VAR_P (t));\n-\n-  if (TREE_CODE (t) == TEMPLATE_ID_EXPR)\n-    return DECL_TEMPLATE_RESULT (TREE_OPERAND (t, 0));\n-  if (VAR_P (t))\n-    return DECL_TEMPLATE_RESULT (DECL_TI_TEMPLATE (t));\n-  else\n-    {\n-      tree fn = CALL_EXPR_FN (t);\n-      tree ovl = TREE_OPERAND (fn, 0);\n-      tree tmpl = OVL_FUNCTION (ovl);\n-      return DECL_TEMPLATE_RESULT (tmpl);\n-    }\n+  tree tmpl, args;\n+  placeholder_extract_concept_and_args (t, tmpl, args);\n+  return DECL_TEMPLATE_RESULT (tmpl);\n }\n \n /* Add an implicit template type parameter to the CURRENT_TEMPLATE_PARMS"}, {"sha": "e836ec747d03a4393b0efb9ba13e1de86ed25e6a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 133, "deletions": 12, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -23394,6 +23394,100 @@ listify_autos (tree type, tree auto_node)\n   return tsubst (type, argvec, tf_warning_or_error, NULL_TREE);\n }\n \n+/* Hash traits for hashing possibly constrained 'auto'\n+   TEMPLATE_TYPE_PARMs for use by do_auto_deduction.  */\n+\n+struct auto_hash : default_hash_traits<tree>\n+{\n+  static inline hashval_t hash (tree);\n+  static inline bool equal (tree, tree);\n+};\n+\n+/* Hash the 'auto' T.  */\n+\n+inline hashval_t\n+auto_hash::hash (tree t)\n+{\n+  if (tree c = PLACEHOLDER_TYPE_CONSTRAINTS (t))\n+    /* Matching constrained-type-specifiers denote the same template\n+       parameter, so hash the constraint.  */\n+    return hash_placeholder_constraint (c);\n+  else\n+    /* But unconstrained autos are all separate, so just hash the pointer.  */\n+    return iterative_hash_object (t, 0);\n+}\n+\n+/* Compare two 'auto's.  */\n+\n+inline bool\n+auto_hash::equal (tree t1, tree t2)\n+{\n+  if (t1 == t2)\n+    return true;\n+\n+  tree c1 = PLACEHOLDER_TYPE_CONSTRAINTS (t1);\n+  tree c2 = PLACEHOLDER_TYPE_CONSTRAINTS (t2);\n+\n+  /* Two unconstrained autos are distinct.  */\n+  if (!c1 || !c2)\n+    return false;\n+\n+  return equivalent_placeholder_constraints (c1, c2);\n+}\n+\n+/* for_each_template_parm callback for extract_autos: if t is a (possibly\n+   constrained) auto, add it to the vector.  */\n+\n+static int\n+extract_autos_r (tree t, void *data)\n+{\n+  hash_table<auto_hash> &hash = *(hash_table<auto_hash>*)data;\n+  if (is_auto_or_concept (t))\n+    {\n+      /* All the autos were built with index 0; fix that up now.  */\n+      tree *p = hash.find_slot (t, INSERT);\n+      unsigned idx;\n+      if (*p)\n+\t/* If this is a repeated constrained-type-specifier, use the index we\n+\t   chose before.  */\n+\tidx = TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (*p));\n+      else\n+\t{\n+\t  /* Otherwise this is new, so use the current count.  */\n+\t  *p = t;\n+\t  idx = hash.elements () - 1;\n+\t}\n+      TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (t)) = idx;\n+    }\n+\n+  /* Always keep walking.  */\n+  return 0;\n+}\n+\n+/* Return a TREE_VEC of the 'auto's used in type under the Concepts TS, which\n+   says they can appear anywhere in the type.  */\n+\n+static tree\n+extract_autos (tree type)\n+{\n+  hash_set<tree> visited;\n+  hash_table<auto_hash> hash (2);\n+\n+  for_each_template_parm (type, extract_autos_r, &hash, &visited, true);\n+\n+  tree tree_vec = make_tree_vec (hash.elements());\n+  for (hash_table<auto_hash>::iterator iter = hash.begin();\n+       iter != hash.end(); ++iter)\n+    {\n+      tree elt = *iter;\n+      unsigned i = TEMPLATE_PARM_IDX (TEMPLATE_TYPE_PARM_INDEX (elt));\n+      TREE_VEC_ELT (tree_vec, i)\n+\t= build_tree_list (NULL_TREE, TYPE_NAME (elt));\n+    }\n+\n+  return tree_vec;\n+}\n+\n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.  */\n \n@@ -23450,11 +23544,11 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \n   init = resolve_nondeduced_context (init);\n \n-  targs = make_tree_vec (1);\n   if (AUTO_IS_DECLTYPE (auto_node))\n     {\n       bool id = (DECL_P (init) || (TREE_CODE (init) == COMPONENT_REF\n \t\t\t\t   && !REF_PARENTHESIZED_P (init)));\n+      targs = make_tree_vec (1);\n       TREE_VEC_ELT (targs, 0)\n \t= finish_decltype_type (init, id, tf_warning_or_error);\n       if (type != auto_node)\n@@ -23467,14 +23561,21 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n   else\n     {\n       tree parms = build_tree_list (NULL_TREE, type);\n-      tree tparms = make_tree_vec (1);\n-      int val;\n-\n-      TREE_VEC_ELT (tparms, 0)\n-\t= build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n-      val = type_unification_real (tparms, targs, parms, &init, 1, 0,\n-\t\t\t\t   DEDUCE_CALL, LOOKUP_NORMAL,\n-\t\t\t\t   NULL, /*explain_p=*/false);\n+      tree tparms;\n+\n+      if (flag_concepts)\n+\ttparms = extract_autos (type);\n+      else\n+\t{\n+\t  tparms = make_tree_vec (1);\n+\t  TREE_VEC_ELT (tparms, 0)\n+\t    = build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n+\t}\n+\n+      targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n+      int val = type_unification_real (tparms, targs, parms, &init, 1, 0,\n+\t\t\t\t       DEDUCE_CALL, LOOKUP_NORMAL,\n+\t\t\t\t       NULL, /*explain_p=*/false);\n       if (val > 0)\n \t{\n \t  if (processing_template_decl)\n@@ -23503,7 +23604,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n      of each declared variable is determined as described above. If the\n      type deduced for the template parameter U is not the same in each\n      deduction, the program is ill-formed.  */\n-  if (TREE_TYPE (auto_node)\n+  if (!flag_concepts && TREE_TYPE (auto_node)\n       && !same_type_p (TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0)))\n     {\n       if (cfun && auto_node == current_function_auto_return_pattern\n@@ -23516,7 +23617,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \t       auto_node, TREE_TYPE (auto_node), TREE_VEC_ELT (targs, 0));\n       return error_mark_node;\n     }\n-  if (context != adc_requirement)\n+  if (!flag_concepts)\n     TREE_TYPE (auto_node) = TREE_VEC_ELT (targs, 0);\n \n   /* Check any placeholder constraints against the deduced type. */\n@@ -23592,13 +23693,33 @@ is_auto (const_tree type)\n     return false;\n }\n \n+/* for_each_template_parm callback for type_uses_auto.  */\n+\n+int\n+is_auto_r (tree tp, void */*data*/)\n+{\n+  return is_auto_or_concept (tp);\n+}\n+\n /* Returns the TEMPLATE_TYPE_PARM in TYPE representing `auto' iff TYPE contains\n    a use of `auto'.  Returns NULL_TREE otherwise.  */\n \n tree\n type_uses_auto (tree type)\n {\n-  return find_type_usage (type, is_auto);\n+  if (flag_concepts)\n+    {\n+      /* The Concepts TS allows multiple autos in one type-specifier; just\n+\t return the first one we find, do_auto_deduction will collect all of\n+\t them.  */\n+      if (uses_template_parms (type))\n+\treturn for_each_template_parm (type, is_auto_r, /*data*/NULL,\n+\t\t\t\t       /*visited*/NULL, /*nondeduced*/true);\n+      else\n+\treturn NULL_TREE;\n+    }\n+  else\n+    return find_type_usage (type, is_auto);\n }\n \n /* Returns true iff TYPE is a TEMPLATE_TYPE_PARM representing 'auto',"}, {"sha": "e68e9df02a4bac70e02dd0b72eed45b366d6a647", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -1333,6 +1333,10 @@ structural_comptypes (tree t1, tree t2, int strict)\n \t template parameters set, they can't be equal.  */\n       if (!comp_template_parms_position (t1, t2))\n \treturn false;\n+      /* Constrained 'auto's are distinct from parms that don't have the same\n+\t constraints.  */\n+      if (!equivalent_placeholder_constraints (t1, t2))\n+\treturn false;\n       break;\n \n     case TYPENAME_TYPE:"}, {"sha": "6068e4cc4862517511a61a79fd524edc1c68d24f", "filename": "gcc/testsuite/g++.dg/concepts/auto1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fea442db740d66cd8d16bdeb667d9725f305844/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconcepts%2Fauto1.C?ref=4fea442db740d66cd8d16bdeb667d9725f305844", "patch": "@@ -0,0 +1,27 @@\n+// { dg-options \"-std=c++1z\" }\n+\n+template <class T1, class T2> class A { };\n+\n+A<int, int> a;\n+A<double, float> a2;\n+A<double, double> a22;\n+\n+A<auto, auto> b = a;\n+A<auto, auto> b1 = a2;\n+\n+template <class T> concept bool C = __is_same_as (T, int);\n+\n+A<C,C> b2 = a;\n+A<C,C> b3 = a2;\t\t\t// { dg-error \"\" }\n+A<C,C> b32 = a22;\t\t// { dg-error \"\" }\n+\n+template <class T> concept bool C2() { return __is_enum (T); }\n+\n+enum E1 { };\n+enum E2 { };\n+\n+A<E1,E1> a3;\n+A<C2,C2> b4 = a3;\n+\n+A<E1,E2> a4;\n+A<C2,C2> b5 = a4;\t\t// { dg-error \"\" }"}]}