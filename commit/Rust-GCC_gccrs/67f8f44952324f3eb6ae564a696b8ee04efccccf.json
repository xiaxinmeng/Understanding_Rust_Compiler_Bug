{"sha": "67f8f44952324f3eb6ae564a696b8ee04efccccf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdmOGY0NDk1MjMyNGYzZWI2YWU1NjRhNjk2YjhlZTA0ZWZjY2NjZg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-06-05T17:42:55Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-06-05T17:42:55Z"}, "message": "2011-06-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tMerge trunk into branch, part one.\n\n[[Split portion of a mixed commit.]]\n\nFrom-SVN: r174658.2", "tree": {"sha": "ca7498f76c8ecfb88405f61c4a8ce7bb32761ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca7498f76c8ecfb88405f61c4a8ce7bb32761ea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67f8f44952324f3eb6ae564a696b8ee04efccccf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f8f44952324f3eb6ae564a696b8ee04efccccf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f8f44952324f3eb6ae564a696b8ee04efccccf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f8f44952324f3eb6ae564a696b8ee04efccccf/comments", "author": null, "committer": null, "parents": [{"sha": "419b55d0f9076bfa47c93b5899a83e953cee2d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/419b55d0f9076bfa47c93b5899a83e953cee2d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/419b55d0f9076bfa47c93b5899a83e953cee2d96"}], "stats": {"total": 129968, "additions": 129968, "deletions": 0}, "files": [{"sha": "f35b3639aafec7c56e25ea8a6dafd164e60fa328", "filename": "gcc/go/gofrontend/expressions.cc.merge-left.r167407", "status": "added", "additions": 12264, "deletions": 0, "changes": 12264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "2c330ef2e4622c4e631a31e1c640750d61b7f6c9", "filename": "gcc/go/gofrontend/expressions.cc.merge-right.r172891", "status": "added", "additions": 12843, "deletions": 0, "changes": 12843, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "861d5c0ca9914291a20da8821faf42a24b4702d8", "filename": "gcc/go/gofrontend/expressions.cc.working", "status": "added", "additions": 12663, "deletions": 0, "changes": 12663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "c756084a1dc999aca6f02f362d12dec523087993", "filename": "gcc/go/gofrontend/go.cc.merge-left.r167407", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgo.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgo.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,153 @@\n+// go.cc -- Go frontend main file for gcc.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+\n+#include \"lex.h\"\n+#include \"parse.h\"\n+#include \"gogo.h\"\n+\n+// The unique prefix to use for exported symbols.  This is set during\n+// option processing.\n+\n+static std::string unique_prefix;\n+\n+// The data structures we build to represent the file.\n+static Gogo* gogo;\n+\n+// Create the main IR data structure.\n+\n+GO_EXTERN_C\n+void\n+go_create_gogo(int int_type_size, int float_type_size, int pointer_size)\n+{\n+  gcc_assert(::gogo == NULL);\n+  ::gogo = new Gogo(int_type_size, float_type_size, pointer_size);\n+  if (!unique_prefix.empty())\n+    ::gogo->set_unique_prefix(unique_prefix);\n+}\n+\n+// Set the unique prefix we use for exported symbols.\n+\n+GO_EXTERN_C\n+void\n+go_set_prefix(const char* arg)\n+{\n+  unique_prefix = arg;\n+  for (size_t i = 0; i < unique_prefix.length(); ++i)\n+    {\n+      char c = unique_prefix[i];\n+      if ((c >= 'a' && c <= 'z')\n+\t  || (c >= 'A' && c <= 'Z')\n+\t  || (c >= '0' && c <= '9')\n+\t  || c == '_')\n+\t;\n+      else\n+\tunique_prefix[i] = '_';\n+    }\n+}\n+\n+// Parse the input files.\n+\n+GO_EXTERN_C\n+void\n+go_parse_input_files(const char** filenames, unsigned int filename_count,\n+\t\t     bool only_check_syntax, bool require_return_statement)\n+{\n+  gcc_assert(filename_count > 0);\n+  for (unsigned int i = 0; i < filename_count; ++i)\n+    {\n+      if (i > 0)\n+\t::gogo->clear_file_scope();\n+\n+      const char* filename = filenames[i];\n+      FILE* file;\n+      if (strcmp(filename, \"-\") == 0)\n+\tfile = stdin;\n+      else\n+\t{\n+\t  file = fopen(filename, \"r\");\n+\t  if (file == NULL)\n+\t    fatal_error(\"cannot open %s: %m\", filename);\n+\t}\n+\n+      Lex lexer(filename, file);\n+\n+      Parse parse(&lexer, ::gogo);\n+      parse.program();\n+\n+      if (strcmp(filename, \"-\") != 0)\n+\tfclose(file);\n+    }\n+\n+  ::gogo->clear_file_scope();\n+\n+  // If the global predeclared names are referenced but not defined,\n+  // define them now.\n+  ::gogo->define_global_names();\n+\n+  // Finalize method lists and build stub methods for named types.\n+  ::gogo->finalize_methods();\n+\n+  // Now that we have seen all the names, lower the parse tree into a\n+  // form which is easier to use.\n+  ::gogo->lower_parse_tree();\n+\n+  // Now that we have seen all the names, verify that types are\n+  // correct.\n+  ::gogo->verify_types();\n+\n+  // Work out types of unspecified constants and variables.\n+  ::gogo->determine_types();\n+\n+  // Check types and issue errors as appropriate.\n+  ::gogo->check_types();\n+\n+  if (only_check_syntax)\n+    return;\n+\n+  // Check that functions have return statements.\n+  if (require_return_statement)\n+    ::gogo->check_return_statements();\n+\n+  // Export global identifiers as appropriate.\n+  ::gogo->do_exports();\n+\n+  // Build required interface method tables.\n+  ::gogo->build_interface_method_tables();\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  ::gogo->remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  ::gogo->order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  ::gogo->build_recover_thunks();\n+\n+  // Convert complicated go and defer statements into simpler ones.\n+  ::gogo->simplify_thunk_statements();\n+}\n+\n+// Write out globals.\n+\n+GO_EXTERN_C\n+void\n+go_write_globals()\n+{\n+  return ::gogo->write_globals();\n+}\n+\n+// Return the global IR structure.  This is used by some of the\n+// langhooks to pass to other code.\n+\n+Gogo*\n+go_get_gogo()\n+{\n+  return ::gogo;\n+}"}, {"sha": "3da1404129bed55d9a38f1513d1c094e09f4473f", "filename": "gcc/go/gofrontend/go.cc.merge-right.r172891", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgo.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgo.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,151 @@\n+// go.cc -- Go frontend main file for gcc.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+\n+#include \"lex.h\"\n+#include \"parse.h\"\n+#include \"backend.h\"\n+#include \"gogo.h\"\n+\n+// The unique prefix to use for exported symbols.  This is set during\n+// option processing.\n+\n+static std::string unique_prefix;\n+\n+// The data structures we build to represent the file.\n+static Gogo* gogo;\n+\n+// Create the main IR data structure.\n+\n+GO_EXTERN_C\n+void\n+go_create_gogo(int int_type_size, int pointer_size)\n+{\n+  go_assert(::gogo == NULL);\n+  ::gogo = new Gogo(go_get_backend(), int_type_size, pointer_size);\n+  if (!unique_prefix.empty())\n+    ::gogo->set_unique_prefix(unique_prefix);\n+}\n+\n+// Set the unique prefix we use for exported symbols.\n+\n+GO_EXTERN_C\n+void\n+go_set_prefix(const char* arg)\n+{\n+  unique_prefix = arg;\n+  for (size_t i = 0; i < unique_prefix.length(); ++i)\n+    {\n+      char c = unique_prefix[i];\n+      if ((c >= 'a' && c <= 'z')\n+\t  || (c >= 'A' && c <= 'Z')\n+\t  || (c >= '0' && c <= '9')\n+\t  || c == '_')\n+\t;\n+      else\n+\tunique_prefix[i] = '_';\n+    }\n+}\n+\n+// Parse the input files.\n+\n+GO_EXTERN_C\n+void\n+go_parse_input_files(const char** filenames, unsigned int filename_count,\n+\t\t     bool only_check_syntax, bool require_return_statement)\n+{\n+  go_assert(filename_count > 0);\n+  for (unsigned int i = 0; i < filename_count; ++i)\n+    {\n+      if (i > 0)\n+\t::gogo->clear_file_scope();\n+\n+      const char* filename = filenames[i];\n+      FILE* file;\n+      if (strcmp(filename, \"-\") == 0)\n+\tfile = stdin;\n+      else\n+\t{\n+\t  file = fopen(filename, \"r\");\n+\t  if (file == NULL)\n+\t    fatal_error(\"cannot open %s: %m\", filename);\n+\t}\n+\n+      Lex lexer(filename, file);\n+\n+      Parse parse(&lexer, ::gogo);\n+      parse.program();\n+\n+      if (strcmp(filename, \"-\") != 0)\n+\tfclose(file);\n+    }\n+\n+  ::gogo->clear_file_scope();\n+\n+  // If the global predeclared names are referenced but not defined,\n+  // define them now.\n+  ::gogo->define_global_names();\n+\n+  // Finalize method lists and build stub methods for named types.\n+  ::gogo->finalize_methods();\n+\n+  // Now that we have seen all the names, lower the parse tree into a\n+  // form which is easier to use.\n+  ::gogo->lower_parse_tree();\n+\n+  // Now that we have seen all the names, verify that types are\n+  // correct.\n+  ::gogo->verify_types();\n+\n+  // Work out types of unspecified constants and variables.\n+  ::gogo->determine_types();\n+\n+  // Check types and issue errors as appropriate.\n+  ::gogo->check_types();\n+\n+  if (only_check_syntax)\n+    return;\n+\n+  // Check that functions have return statements.\n+  if (require_return_statement)\n+    ::gogo->check_return_statements();\n+\n+  // Export global identifiers as appropriate.\n+  ::gogo->do_exports();\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  ::gogo->remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  ::gogo->order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  ::gogo->build_recover_thunks();\n+\n+  // Convert complicated go and defer statements into simpler ones.\n+  ::gogo->simplify_thunk_statements();\n+}\n+\n+// Write out globals.\n+\n+GO_EXTERN_C\n+void\n+go_write_globals()\n+{\n+  return ::gogo->write_globals();\n+}\n+\n+// Return the global IR structure.  This is used by some of the\n+// langhooks to pass to other code.\n+\n+Gogo*\n+go_get_gogo()\n+{\n+  return ::gogo;\n+}"}, {"sha": "7b1fd7eccbb4b8d7c1e279497b6e048e5fcd9810", "filename": "gcc/go/gofrontend/go.cc.working", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgo.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgo.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,150 @@\n+// go.cc -- Go frontend main file for gcc.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+\n+#include \"lex.h\"\n+#include \"parse.h\"\n+#include \"gogo.h\"\n+\n+// The unique prefix to use for exported symbols.  This is set during\n+// option processing.\n+\n+static std::string unique_prefix;\n+\n+// The data structures we build to represent the file.\n+static Gogo* gogo;\n+\n+// Create the main IR data structure.\n+\n+GO_EXTERN_C\n+void\n+go_create_gogo(int int_type_size, int pointer_size)\n+{\n+  gcc_assert(::gogo == NULL);\n+  ::gogo = new Gogo(int_type_size, pointer_size);\n+  if (!unique_prefix.empty())\n+    ::gogo->set_unique_prefix(unique_prefix);\n+}\n+\n+// Set the unique prefix we use for exported symbols.\n+\n+GO_EXTERN_C\n+void\n+go_set_prefix(const char* arg)\n+{\n+  unique_prefix = arg;\n+  for (size_t i = 0; i < unique_prefix.length(); ++i)\n+    {\n+      char c = unique_prefix[i];\n+      if ((c >= 'a' && c <= 'z')\n+\t  || (c >= 'A' && c <= 'Z')\n+\t  || (c >= '0' && c <= '9')\n+\t  || c == '_')\n+\t;\n+      else\n+\tunique_prefix[i] = '_';\n+    }\n+}\n+\n+// Parse the input files.\n+\n+GO_EXTERN_C\n+void\n+go_parse_input_files(const char** filenames, unsigned int filename_count,\n+\t\t     bool only_check_syntax, bool require_return_statement)\n+{\n+  gcc_assert(filename_count > 0);\n+  for (unsigned int i = 0; i < filename_count; ++i)\n+    {\n+      if (i > 0)\n+\t::gogo->clear_file_scope();\n+\n+      const char* filename = filenames[i];\n+      FILE* file;\n+      if (strcmp(filename, \"-\") == 0)\n+\tfile = stdin;\n+      else\n+\t{\n+\t  file = fopen(filename, \"r\");\n+\t  if (file == NULL)\n+\t    fatal_error(\"cannot open %s: %m\", filename);\n+\t}\n+\n+      Lex lexer(filename, file);\n+\n+      Parse parse(&lexer, ::gogo);\n+      parse.program();\n+\n+      if (strcmp(filename, \"-\") != 0)\n+\tfclose(file);\n+    }\n+\n+  ::gogo->clear_file_scope();\n+\n+  // If the global predeclared names are referenced but not defined,\n+  // define them now.\n+  ::gogo->define_global_names();\n+\n+  // Finalize method lists and build stub methods for named types.\n+  ::gogo->finalize_methods();\n+\n+  // Now that we have seen all the names, lower the parse tree into a\n+  // form which is easier to use.\n+  ::gogo->lower_parse_tree();\n+\n+  // Now that we have seen all the names, verify that types are\n+  // correct.\n+  ::gogo->verify_types();\n+\n+  // Work out types of unspecified constants and variables.\n+  ::gogo->determine_types();\n+\n+  // Check types and issue errors as appropriate.\n+  ::gogo->check_types();\n+\n+  if (only_check_syntax)\n+    return;\n+\n+  // Check that functions have return statements.\n+  if (require_return_statement)\n+    ::gogo->check_return_statements();\n+\n+  // Export global identifiers as appropriate.\n+  ::gogo->do_exports();\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  ::gogo->remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  ::gogo->order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  ::gogo->build_recover_thunks();\n+\n+  // Convert complicated go and defer statements into simpler ones.\n+  ::gogo->simplify_thunk_statements();\n+}\n+\n+// Write out globals.\n+\n+GO_EXTERN_C\n+void\n+go_write_globals()\n+{\n+  return ::gogo->write_globals();\n+}\n+\n+// Return the global IR structure.  This is used by some of the\n+// langhooks to pass to other code.\n+\n+Gogo*\n+go_get_gogo()\n+{\n+  return ::gogo;\n+}"}, {"sha": "755a0e9c78467951dc7ebc3014b19e7af32f0ecf", "filename": "gcc/go/gofrontend/gogo-tree.cc.merge-left.r167407", "status": "added", "additions": 3105, "deletions": 0, "changes": 3105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "c24ff98fbd423e470bf0ac462d592d6dd8af596f", "filename": "gcc/go/gofrontend/gogo-tree.cc.merge-right.r172891", "status": "added", "additions": 2697, "deletions": 0, "changes": 2697, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,2697 @@\n+// gogo-tree.cc -- convert Go frontend Gogo IR to gcc trees.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include <gmp.h>\n+\n+#ifndef ENABLE_BUILD_WITH_CXX\n+extern \"C\"\n+{\n+#endif\n+\n+#include \"toplev.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"cgraph.h\"\n+#include \"langhooks.h\"\n+#include \"convert.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+\n+#ifndef ENABLE_BUILD_WITH_CXX\n+}\n+#endif\n+\n+#include \"go-c.h\"\n+#include \"types.h\"\n+#include \"expressions.h\"\n+#include \"statements.h\"\n+#include \"runtime.h\"\n+#include \"backend.h\"\n+#include \"gogo.h\"\n+\n+// Whether we have seen any errors.\n+\n+bool\n+saw_errors()\n+{\n+  return errorcount != 0 || sorrycount != 0;\n+}\n+\n+// A helper function.\n+\n+static inline tree\n+get_identifier_from_string(const std::string& str)\n+{\n+  return get_identifier_with_length(str.data(), str.length());\n+}\n+\n+// Builtin functions.\n+\n+static std::map<std::string, tree> builtin_functions;\n+\n+// Define a builtin function.  BCODE is the builtin function code\n+// defined by builtins.def.  NAME is the name of the builtin function.\n+// LIBNAME is the name of the corresponding library function, and is\n+// NULL if there isn't one.  FNTYPE is the type of the function.\n+// CONST_P is true if the function has the const attribute.\n+\n+static void\n+define_builtin(built_in_function bcode, const char* name, const char* libname,\n+\t       tree fntype, bool const_p)\n+{\n+  tree decl = add_builtin_function(name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t   libname, NULL_TREE);\n+  if (const_p)\n+    TREE_READONLY(decl) = 1;\n+  built_in_decls[bcode] = decl;\n+  implicit_built_in_decls[bcode] = decl;\n+  builtin_functions[name] = decl;\n+  if (libname != NULL)\n+    {\n+      decl = add_builtin_function(libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t  NULL, NULL_TREE);\n+      if (const_p)\n+\tTREE_READONLY(decl) = 1;\n+      builtin_functions[libname] = decl;\n+    }\n+}\n+\n+// Create trees for implicit builtin functions.\n+\n+void\n+Gogo::define_builtin_function_trees()\n+{\n+  /* We need to define the fetch_and_add functions, since we use them\n+     for ++ and --.  */\n+  tree t = go_type_for_size(BITS_PER_UNIT, 1);\n+  tree p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  define_builtin(BUILT_IN_ADD_AND_FETCH_1, \"__sync_fetch_and_add_1\", NULL,\n+\t\t build_function_type_list(t, p, t, NULL_TREE), false);\n+\n+  t = go_type_for_size(BITS_PER_UNIT * 2, 1);\n+  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  define_builtin (BUILT_IN_ADD_AND_FETCH_2, \"__sync_fetch_and_add_2\", NULL,\n+\t\t  build_function_type_list(t, p, t, NULL_TREE), false);\n+\n+  t = go_type_for_size(BITS_PER_UNIT * 4, 1);\n+  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  define_builtin(BUILT_IN_ADD_AND_FETCH_4, \"__sync_fetch_and_add_4\", NULL,\n+\t\t build_function_type_list(t, p, t, NULL_TREE), false);\n+\n+  t = go_type_for_size(BITS_PER_UNIT * 8, 1);\n+  p = build_pointer_type(build_qualified_type(t, TYPE_QUAL_VOLATILE));\n+  define_builtin(BUILT_IN_ADD_AND_FETCH_8, \"__sync_fetch_and_add_8\", NULL,\n+\t\t build_function_type_list(t, p, t, NULL_TREE), false);\n+\n+  // We use __builtin_expect for magic import functions.\n+  define_builtin(BUILT_IN_EXPECT, \"__builtin_expect\", NULL,\n+\t\t build_function_type_list(long_integer_type_node,\n+\t\t\t\t\t  long_integer_type_node,\n+\t\t\t\t\t  long_integer_type_node,\n+\t\t\t\t\t  NULL_TREE),\n+\t\t true);\n+\n+  // We use __builtin_memmove for the predeclared copy function.\n+  define_builtin(BUILT_IN_MEMMOVE, \"__builtin_memmove\", \"memmove\",\n+\t\t build_function_type_list(ptr_type_node,\n+\t\t\t\t\t  ptr_type_node,\n+\t\t\t\t\t  const_ptr_type_node,\n+\t\t\t\t\t  size_type_node,\n+\t\t\t\t\t  NULL_TREE),\n+\t\t false);\n+\n+  // We provide sqrt for the math library.\n+  define_builtin(BUILT_IN_SQRT, \"__builtin_sqrt\", \"sqrt\",\n+\t\t build_function_type_list(double_type_node,\n+\t\t\t\t\t  double_type_node,\n+\t\t\t\t\t  NULL_TREE),\n+\t\t true);\n+  define_builtin(BUILT_IN_SQRTL, \"__builtin_sqrtl\", \"sqrtl\",\n+\t\t build_function_type_list(long_double_type_node,\n+\t\t\t\t\t  long_double_type_node,\n+\t\t\t\t\t  NULL_TREE),\n+\t\t true);\n+\n+  // We use __builtin_return_address in the thunk we build for\n+  // functions which call recover.\n+  define_builtin(BUILT_IN_RETURN_ADDRESS, \"__builtin_return_address\", NULL,\n+\t\t build_function_type_list(ptr_type_node,\n+\t\t\t\t\t  unsigned_type_node,\n+\t\t\t\t\t  NULL_TREE),\n+\t\t false);\n+\n+  // The compiler uses __builtin_trap for some exception handling\n+  // cases.\n+  define_builtin(BUILT_IN_TRAP, \"__builtin_trap\", NULL,\n+\t\t build_function_type(void_type_node, void_list_node),\n+\t\t false);\n+}\n+\n+// Get the name to use for the import control function.  If there is a\n+// global function or variable, then we know that that name must be\n+// unique in the link, and we use it as the basis for our name.\n+\n+const std::string&\n+Gogo::get_init_fn_name()\n+{\n+  if (this->init_fn_name_.empty())\n+    {\n+      go_assert(this->package_ != NULL);\n+      if (this->is_main_package())\n+\t{\n+\t  // Use a name which the runtime knows.\n+\t  this->init_fn_name_ = \"__go_init_main\";\n+\t}\n+      else\n+\t{\n+\t  std::string s = this->unique_prefix();\n+\t  s.append(1, '.');\n+\t  s.append(this->package_name());\n+\t  s.append(\"..import\");\n+\t  this->init_fn_name_ = s;\n+\t}\n+    }\n+\n+  return this->init_fn_name_;\n+}\n+\n+// Add statements to INIT_STMT_LIST which run the initialization\n+// functions for imported packages.  This is only used for the \"main\"\n+// package.\n+\n+void\n+Gogo::init_imports(tree* init_stmt_list)\n+{\n+  go_assert(this->is_main_package());\n+\n+  if (this->imported_init_fns_.empty())\n+    return;\n+\n+  tree fntype = build_function_type(void_type_node, void_list_node);\n+\n+  // We must call them in increasing priority order.\n+  std::vector<Import_init> v;\n+  for (std::set<Import_init>::const_iterator p =\n+\t this->imported_init_fns_.begin();\n+       p != this->imported_init_fns_.end();\n+       ++p)\n+    v.push_back(*p);\n+  std::sort(v.begin(), v.end());\n+\n+  for (std::vector<Import_init>::const_iterator p = v.begin();\n+       p != v.end();\n+       ++p)\n+    {\n+      std::string user_name = p->package_name() + \".init\";\n+      tree decl = build_decl(UNKNOWN_LOCATION, FUNCTION_DECL,\n+\t\t\t     get_identifier_from_string(user_name),\n+\t\t\t     fntype);\n+      const std::string& init_name(p->init_name());\n+      SET_DECL_ASSEMBLER_NAME(decl, get_identifier_from_string(init_name));\n+      TREE_PUBLIC(decl) = 1;\n+      DECL_EXTERNAL(decl) = 1;\n+      append_to_statement_list(build_call_expr(decl, 0), init_stmt_list);\n+    }\n+}\n+\n+// Register global variables with the garbage collector.  We need to\n+// register all variables which can hold a pointer value.  They become\n+// roots during the mark phase.  We build a struct that is easy to\n+// hook into a list of roots.\n+\n+// struct __go_gc_root_list\n+// {\n+//   struct __go_gc_root_list* __next;\n+//   struct __go_gc_root\n+//   {\n+//     void* __decl;\n+//     size_t __size;\n+//   } __roots[];\n+// };\n+\n+// The last entry in the roots array has a NULL decl field.\n+\n+void\n+Gogo::register_gc_vars(const std::vector<Named_object*>& var_gc,\n+\t\t       tree* init_stmt_list)\n+{\n+  if (var_gc.empty())\n+    return;\n+\n+  size_t count = var_gc.size();\n+\n+  tree root_type = Gogo::builtin_struct(NULL, \"__go_gc_root\", NULL_TREE, 2,\n+\t\t\t\t\t\"__next\",\n+\t\t\t\t\tptr_type_node,\n+\t\t\t\t\t\"__size\",\n+\t\t\t\t\tsizetype);\n+\n+  tree index_type = build_index_type(size_int(count));\n+  tree array_type = build_array_type(root_type, index_type);\n+\n+  tree root_list_type = make_node(RECORD_TYPE);\n+  root_list_type = Gogo::builtin_struct(NULL, \"__go_gc_root_list\",\n+\t\t\t\t\troot_list_type, 2,\n+\t\t\t\t\t\"__next\",\n+\t\t\t\t\tbuild_pointer_type(root_list_type),\n+\t\t\t\t\t\"__roots\",\n+\t\t\t\t\tarray_type);\n+\n+  // Build an initialier for the __roots array.\n+\n+  VEC(constructor_elt,gc)* roots_init = VEC_alloc(constructor_elt, gc,\n+\t\t\t\t\t\t  count + 1);\n+\n+  size_t i = 0;\n+  for (std::vector<Named_object*>::const_iterator p = var_gc.begin();\n+       p != var_gc.end();\n+       ++p, ++i)\n+    {\n+      VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+\n+      constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+      tree field = TYPE_FIELDS(root_type);\n+      elt->index = field;\n+      Bvariable* bvar = (*p)->get_backend_variable(this, NULL);\n+      tree decl = var_to_tree(bvar);\n+      go_assert(TREE_CODE(decl) == VAR_DECL);\n+      elt->value = build_fold_addr_expr(decl);\n+\n+      elt = VEC_quick_push(constructor_elt, init, NULL);\n+      field = DECL_CHAIN(field);\n+      elt->index = field;\n+      elt->value = DECL_SIZE_UNIT(decl);\n+\n+      elt = VEC_quick_push(constructor_elt, roots_init, NULL);\n+      elt->index = size_int(i);\n+      elt->value = build_constructor(root_type, init);\n+    }\n+\n+  // The list ends with a NULL entry.\n+\n+  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  tree field = TYPE_FIELDS(root_type);\n+  elt->index = field;\n+  elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n+\n+  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  field = DECL_CHAIN(field);\n+  elt->index = field;\n+  elt->value = size_zero_node;\n+\n+  elt = VEC_quick_push(constructor_elt, roots_init, NULL);\n+  elt->index = size_int(i);\n+  elt->value = build_constructor(root_type, init);\n+\n+  // Build a constructor for the struct.\n+\n+  VEC(constructor_elt,gc*) root_list_init = VEC_alloc(constructor_elt, gc, 2);\n+\n+  elt = VEC_quick_push(constructor_elt, root_list_init, NULL);\n+  field = TYPE_FIELDS(root_list_type);\n+  elt->index = field;\n+  elt->value = fold_convert(TREE_TYPE(field), null_pointer_node);\n+\n+  elt = VEC_quick_push(constructor_elt, root_list_init, NULL);\n+  field = DECL_CHAIN(field);\n+  elt->index = field;\n+  elt->value = build_constructor(array_type, roots_init);\n+\n+  // Build a decl to register.\n+\n+  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL,\n+\t\t\t create_tmp_var_name(\"gc\"), root_list_type);\n+  DECL_EXTERNAL(decl) = 0;\n+  TREE_PUBLIC(decl) = 0;\n+  TREE_STATIC(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+  DECL_INITIAL(decl) = build_constructor(root_list_type, root_list_init);\n+  rest_of_decl_compilation(decl, 1, 0);\n+\n+  static tree register_gc_fndecl;\n+  tree call = Gogo::call_builtin(&register_gc_fndecl, BUILTINS_LOCATION,\n+\t\t\t\t \"__go_register_gc_roots\",\n+\t\t\t\t 1,\n+\t\t\t\t void_type_node,\n+\t\t\t\t build_pointer_type(root_list_type),\n+\t\t\t\t build_fold_addr_expr(decl));\n+  if (call != error_mark_node)\n+    append_to_statement_list(call, init_stmt_list);\n+}\n+\n+// Build the decl for the initialization function.\n+\n+tree\n+Gogo::initialization_function_decl()\n+{\n+  // The tedious details of building your own function.  There doesn't\n+  // seem to be a helper function for this.\n+  std::string name = this->package_name() + \".init\";\n+  tree fndecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL,\n+\t\t\t   get_identifier_from_string(name),\n+\t\t\t   build_function_type(void_type_node,\n+\t\t\t\t\t       void_list_node));\n+  const std::string& asm_name(this->get_init_fn_name());\n+  SET_DECL_ASSEMBLER_NAME(fndecl, get_identifier_from_string(asm_name));\n+\n+  tree resdecl = build_decl(BUILTINS_LOCATION, RESULT_DECL, NULL_TREE,\n+\t\t\t    void_type_node);\n+  DECL_ARTIFICIAL(resdecl) = 1;\n+  DECL_CONTEXT(resdecl) = fndecl;\n+  DECL_RESULT(fndecl) = resdecl;\n+\n+  TREE_STATIC(fndecl) = 1;\n+  TREE_USED(fndecl) = 1;\n+  DECL_ARTIFICIAL(fndecl) = 1;\n+  TREE_PUBLIC(fndecl) = 1;\n+\n+  DECL_INITIAL(fndecl) = make_node(BLOCK);\n+  TREE_USED(DECL_INITIAL(fndecl)) = 1;\n+\n+  return fndecl;\n+}\n+\n+// Create the magic initialization function.  INIT_STMT_LIST is the\n+// code that it needs to run.\n+\n+void\n+Gogo::write_initialization_function(tree fndecl, tree init_stmt_list)\n+{\n+  // Make sure that we thought we needed an initialization function,\n+  // as otherwise we will not have reported it in the export data.\n+  go_assert(this->is_main_package() || this->need_init_fn_);\n+\n+  if (fndecl == NULL_TREE)\n+    fndecl = this->initialization_function_decl();\n+\n+  DECL_SAVED_TREE(fndecl) = init_stmt_list;\n+\n+  current_function_decl = fndecl;\n+  if (DECL_STRUCT_FUNCTION(fndecl) == NULL)\n+    push_struct_function(fndecl);\n+  else\n+    push_cfun(DECL_STRUCT_FUNCTION(fndecl));\n+  cfun->function_end_locus = BUILTINS_LOCATION;\n+\n+  gimplify_function_tree(fndecl);\n+\n+  cgraph_add_new_function(fndecl, false);\n+  cgraph_mark_needed_node(cgraph_get_node(fndecl));\n+\n+  current_function_decl = NULL_TREE;\n+  pop_cfun();\n+}\n+\n+// Search for references to VAR in any statements or called functions.\n+\n+class Find_var : public Traverse\n+{\n+ public:\n+  // A hash table we use to avoid looping.  The index is the name of a\n+  // named object.  We only look through objects defined in this\n+  // package.\n+  typedef Unordered_set(std::string) Seen_objects;\n+\n+  Find_var(Named_object* var, Seen_objects* seen_objects)\n+    : Traverse(traverse_expressions),\n+      var_(var), seen_objects_(seen_objects), found_(false)\n+  { }\n+\n+  // Whether the variable was found.\n+  bool\n+  found() const\n+  { return this->found_; }\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The variable we are looking for.\n+  Named_object* var_;\n+  // Names of objects we have already seen.\n+  Seen_objects* seen_objects_;\n+  // True if the variable was found.\n+  bool found_;\n+};\n+\n+// See if EXPR refers to VAR, looking through function calls and\n+// variable initializations.\n+\n+int\n+Find_var::expression(Expression** pexpr)\n+{\n+  Expression* e = *pexpr;\n+\n+  Var_expression* ve = e->var_expression();\n+  if (ve != NULL)\n+    {\n+      Named_object* v = ve->named_object();\n+      if (v == this->var_)\n+\t{\n+\t  this->found_ = true;\n+\t  return TRAVERSE_EXIT;\n+\t}\n+\n+      if (v->is_variable() && v->package() == NULL)\n+\t{\n+\t  Expression* init = v->var_value()->init();\n+\t  if (init != NULL)\n+\t    {\n+\t      std::pair<Seen_objects::iterator, bool> ins =\n+\t\tthis->seen_objects_->insert(v->name());\n+\t      if (ins.second)\n+\t\t{\n+\t\t  // This is the first time we have seen this name.\n+\t\t  if (Expression::traverse(&init, this) == TRAVERSE_EXIT)\n+\t\t    return TRAVERSE_EXIT;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // We traverse the code of any function we see.  Note that this\n+  // means that we will traverse the code of a function whose address\n+  // is taken even if it is not called.\n+  Func_expression* fe = e->func_expression();\n+  if (fe != NULL)\n+    {\n+      const Named_object* f = fe->named_object();\n+      if (f->is_function() && f->package() == NULL)\n+\t{\n+\t  std::pair<Seen_objects::iterator, bool> ins =\n+\t    this->seen_objects_->insert(f->name());\n+\t  if (ins.second)\n+\t    {\n+\t      // This is the first time we have seen this name.\n+\t      if (f->func_value()->block()->traverse(this) == TRAVERSE_EXIT)\n+\t\treturn TRAVERSE_EXIT;\n+\t    }\n+\t}\n+    }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Return true if EXPR refers to VAR.\n+\n+static bool\n+expression_requires(Expression* expr, Block* preinit, Named_object* var)\n+{\n+  Find_var::Seen_objects seen_objects;\n+  Find_var find_var(var, &seen_objects);\n+  if (expr != NULL)\n+    Expression::traverse(&expr, &find_var);\n+  if (preinit != NULL)\n+    preinit->traverse(&find_var);\n+  \n+  return find_var.found();\n+}\n+\n+// Sort variable initializations.  If the initialization expression\n+// for variable A refers directly or indirectly to the initialization\n+// expression for variable B, then we must initialize B before A.\n+\n+class Var_init\n+{\n+ public:\n+  Var_init()\n+    : var_(NULL), init_(NULL_TREE), waiting_(0)\n+  { }\n+\n+  Var_init(Named_object* var, tree init)\n+    : var_(var), init_(init), waiting_(0)\n+  { }\n+\n+  // Return the variable.\n+  Named_object*\n+  var() const\n+  { return this->var_; }\n+\n+  // Return the initialization expression.\n+  tree\n+  init() const\n+  { return this->init_; }\n+\n+  // Return the number of variables waiting for this one to be\n+  // initialized.\n+  size_t\n+  waiting() const\n+  { return this->waiting_; }\n+\n+  // Increment the number waiting.\n+  void\n+  increment_waiting()\n+  { ++this->waiting_; }\n+\n+ private:\n+  // The variable being initialized.\n+  Named_object* var_;\n+  // The initialization expression to run.\n+  tree init_;\n+  // The number of variables which are waiting for this one.\n+  size_t waiting_;\n+};\n+\n+typedef std::list<Var_init> Var_inits;\n+\n+// Sort the variable initializations.  The rule we follow is that we\n+// emit them in the order they appear in the array, except that if the\n+// initialization expression for a variable V1 depends upon another\n+// variable V2 then we initialize V1 after V2.\n+\n+static void\n+sort_var_inits(Var_inits* var_inits)\n+{\n+  Var_inits ready;\n+  while (!var_inits->empty())\n+    {\n+      Var_inits::iterator p1 = var_inits->begin();\n+      Named_object* var = p1->var();\n+      Expression* init = var->var_value()->init();\n+      Block* preinit = var->var_value()->preinit();\n+\n+      // Start walking through the list to see which variables VAR\n+      // needs to wait for.  We can skip P1->WAITING variables--that\n+      // is the number we've already checked.\n+      Var_inits::iterator p2 = p1;\n+      ++p2;\n+      for (size_t i = p1->waiting(); i > 0; --i)\n+\t++p2;\n+\n+      for (; p2 != var_inits->end(); ++p2)\n+\t{\n+\t  if (expression_requires(init, preinit, p2->var()))\n+\t    {\n+\t      // Check for cycles.\n+\t      if (expression_requires(p2->var()->var_value()->init(),\n+\t\t\t\t      p2->var()->var_value()->preinit(),\n+\t\t\t\t      var))\n+\t\t{\n+\t\t  error_at(var->location(),\n+\t\t\t   (\"initialization expressions for %qs and \"\n+\t\t\t    \"%qs depend upon each other\"),\n+\t\t\t   var->message_name().c_str(),\n+\t\t\t   p2->var()->message_name().c_str());\n+\t\t  inform(p2->var()->location(), \"%qs defined here\",\n+\t\t\t p2->var()->message_name().c_str());\n+\t\t  p2 = var_inits->end();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // We can't emit P1 until P2 is emitted.  Move P1.\n+\t\t  // Note that the WAITING loop always executes at\n+\t\t  // least once, which is what we want.\n+\t\t  p2->increment_waiting();\n+\t\t  Var_inits::iterator p3 = p2;\n+\t\t  for (size_t i = p2->waiting(); i > 0; --i)\n+\t\t    ++p3;\n+\t\t  var_inits->splice(p3, *var_inits, p1);\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (p2 == var_inits->end())\n+\t{\n+\t  // VAR does not depends upon any other initialization expressions.\n+\n+\t  // Check for a loop of VAR on itself.  We only do this if\n+\t  // INIT is not NULL; when INIT is NULL, it means that\n+\t  // PREINIT sets VAR, which we will interpret as a loop.\n+\t  if (init != NULL && expression_requires(init, preinit, var))\n+\t    error_at(var->location(),\n+\t\t     \"initialization expression for %qs depends upon itself\",\n+\t\t     var->message_name().c_str());\n+\t  ready.splice(ready.end(), *var_inits, p1);\n+\t}\n+    }\n+\n+  // Now READY is the list in the desired initialization order.\n+  var_inits->swap(ready);\n+}\n+\n+// Write out the global definitions.\n+\n+void\n+Gogo::write_globals()\n+{\n+  this->convert_named_types();\n+  this->build_interface_method_tables();\n+\n+  Bindings* bindings = this->current_bindings();\n+  size_t count = bindings->size_definitions();\n+\n+  tree* vec = new tree[count];\n+\n+  tree init_fndecl = NULL_TREE;\n+  tree init_stmt_list = NULL_TREE;\n+\n+  if (this->is_main_package())\n+    this->init_imports(&init_stmt_list);\n+\n+  // A list of variable initializations.\n+  Var_inits var_inits;\n+\n+  // A list of variables which need to be registered with the garbage\n+  // collector.\n+  std::vector<Named_object*> var_gc;\n+  var_gc.reserve(count);\n+\n+  tree var_init_stmt_list = NULL_TREE;\n+  size_t i = 0;\n+  for (Bindings::const_definitions_iterator p = bindings->begin_definitions();\n+       p != bindings->end_definitions();\n+       ++p, ++i)\n+    {\n+      Named_object* no = *p;\n+\n+      go_assert(!no->is_type_declaration() && !no->is_function_declaration());\n+      // There is nothing to do for a package.\n+      if (no->is_package())\n+\t{\n+\t  --i;\n+\t  --count;\n+\t  continue;\n+\t}\n+\n+      // There is nothing to do for an object which was imported from\n+      // a different package into the global scope.\n+      if (no->package() != NULL)\n+\t{\n+\t  --i;\n+\t  --count;\n+\t  continue;\n+\t}\n+\n+      // There is nothing useful we can output for constants which\n+      // have ideal or non-integeral type.\n+      if (no->is_const())\n+\t{\n+\t  Type* type = no->const_value()->type();\n+\t  if (type == NULL)\n+\t    type = no->const_value()->expr()->type();\n+\t  if (type->is_abstract() || type->integer_type() == NULL)\n+\t    {\n+\t      --i;\n+\t      --count;\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (!no->is_variable())\n+\t{\n+\t  vec[i] = no->get_tree(this, NULL);\n+\t  if (vec[i] == error_mark_node)\n+\t    {\n+\t      go_assert(saw_errors());\n+\t      --i;\n+\t      --count;\n+\t      continue;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  Bvariable* var = no->get_backend_variable(this, NULL);\n+\t  vec[i] = var_to_tree(var);\n+\t  if (vec[i] == error_mark_node)\n+\t    {\n+\t      go_assert(saw_errors());\n+\t      --i;\n+\t      --count;\n+\t      continue;\n+\t    }\n+\n+\t  // Check for a sink variable, which may be used to run an\n+\t  // initializer purely for its side effects.\n+\t  bool is_sink = no->name()[0] == '_' && no->name()[1] == '.';\n+\n+\t  tree var_init_tree = NULL_TREE;\n+\t  if (!no->var_value()->has_pre_init())\n+\t    {\n+\t      tree init = no->var_value()->get_init_tree(this, NULL);\n+\t      if (init == error_mark_node)\n+\t\tgo_assert(saw_errors());\n+\t      else if (init == NULL_TREE)\n+\t\t;\n+\t      else if (TREE_CONSTANT(init))\n+\t\tthis->backend()->global_variable_set_init(var,\n+\t\t\t\t\t\t\t  tree_to_expr(init));\n+\t      else if (is_sink)\n+\t\tvar_init_tree = init;\n+\t      else\n+\t\tvar_init_tree = fold_build2_loc(no->location(), MODIFY_EXPR,\n+\t\t\t\t\t\tvoid_type_node, vec[i], init);\n+\t    }\n+\t  else\n+\t    {\n+\t      // We are going to create temporary variables which\n+\t      // means that we need an fndecl.\n+\t      if (init_fndecl == NULL_TREE)\n+\t\tinit_fndecl = this->initialization_function_decl();\n+\t      current_function_decl = init_fndecl;\n+\t      if (DECL_STRUCT_FUNCTION(init_fndecl) == NULL)\n+\t\tpush_struct_function(init_fndecl);\n+\t      else\n+\t\tpush_cfun(DECL_STRUCT_FUNCTION(init_fndecl));\n+\n+\t      tree var_decl = is_sink ? NULL_TREE : vec[i];\n+\t      var_init_tree = no->var_value()->get_init_block(this, NULL,\n+\t\t\t\t\t\t\t      var_decl);\n+\n+\t      current_function_decl = NULL_TREE;\n+\t      pop_cfun();\n+\t    }\n+\n+\t  if (var_init_tree != NULL_TREE && var_init_tree != error_mark_node)\n+\t    {\n+\t      if (no->var_value()->init() == NULL\n+\t\t  && !no->var_value()->has_pre_init())\n+\t\tappend_to_statement_list(var_init_tree, &var_init_stmt_list);\n+\t      else\n+\t\tvar_inits.push_back(Var_init(no, var_init_tree));\n+\t    }\n+\n+\t  if (!is_sink && no->var_value()->type()->has_pointer())\n+\t    var_gc.push_back(no);\n+\t}\n+    }\n+\n+  // Register global variables with the garbage collector.\n+  this->register_gc_vars(var_gc, &init_stmt_list);\n+\n+  // Simple variable initializations, after all variables are\n+  // registered.\n+  append_to_statement_list(var_init_stmt_list, &init_stmt_list);\n+\n+  // Complex variable initializations, first sorting them into a\n+  // workable order.\n+  if (!var_inits.empty())\n+    {\n+      sort_var_inits(&var_inits);\n+      for (Var_inits::const_iterator p = var_inits.begin();\n+\t   p != var_inits.end();\n+\t   ++p)\n+\tappend_to_statement_list(p->init(), &init_stmt_list);\n+    }\n+\n+  // After all the variables are initialized, call the \"init\"\n+  // functions if there are any.\n+  for (std::vector<Named_object*>::const_iterator p =\n+\t this->init_functions_.begin();\n+       p != this->init_functions_.end();\n+       ++p)\n+    {\n+      tree decl = (*p)->get_tree(this, NULL);\n+      tree call = build_call_expr(decl, 0);\n+      append_to_statement_list(call, &init_stmt_list);\n+    }\n+\n+  // Set up a magic function to do all the initialization actions.\n+  // This will be called if this package is imported.\n+  if (init_stmt_list != NULL_TREE\n+      || this->need_init_fn_\n+      || this->is_main_package())\n+    this->write_initialization_function(init_fndecl, init_stmt_list);\n+\n+  // Pass everything back to the middle-end.\n+\n+  wrapup_global_declarations(vec, count);\n+\n+  cgraph_finalize_compilation_unit();\n+\n+  check_global_declarations(vec, count);\n+  emit_debug_global_declarations(vec, count);\n+\n+  delete[] vec;\n+}\n+\n+// Get a tree for the identifier for a named object.\n+\n+tree\n+Named_object::get_id(Gogo* gogo)\n+{\n+  go_assert(!this->is_variable() && !this->is_result_variable());\n+  std::string decl_name;\n+  if (this->is_function_declaration()\n+      && !this->func_declaration_value()->asm_name().empty())\n+    decl_name = this->func_declaration_value()->asm_name();\n+  else if (this->is_type()\n+\t   && this->type_value()->location() == BUILTINS_LOCATION)\n+    {\n+      // We don't need the package name for builtin types.\n+      decl_name = Gogo::unpack_hidden_name(this->name_);\n+    }\n+  else\n+    {\n+      std::string package_name;\n+      if (this->package_ == NULL)\n+\tpackage_name = gogo->package_name();\n+      else\n+\tpackage_name = this->package_->name();\n+\n+      decl_name = package_name + '.' + Gogo::unpack_hidden_name(this->name_);\n+\n+      Function_type* fntype;\n+      if (this->is_function())\n+\tfntype = this->func_value()->type();\n+      else if (this->is_function_declaration())\n+\tfntype = this->func_declaration_value()->type();\n+      else\n+\tfntype = NULL;\n+      if (fntype != NULL && fntype->is_method())\n+\t{\n+\t  decl_name.push_back('.');\n+\t  decl_name.append(fntype->receiver()->type()->mangled_name(gogo));\n+\t}\n+    }\n+  if (this->is_type())\n+    {\n+      const Named_object* in_function = this->type_value()->in_function();\n+      if (in_function != NULL)\n+\tdecl_name += '$' + in_function->name();\n+    }\n+  return get_identifier_from_string(decl_name);\n+}\n+\n+// Get a tree for a named object.\n+\n+tree\n+Named_object::get_tree(Gogo* gogo, Named_object* function)\n+{\n+  if (this->tree_ != NULL_TREE)\n+    return this->tree_;\n+\n+  tree name;\n+  if (this->classification_ == NAMED_OBJECT_TYPE)\n+    name = NULL_TREE;\n+  else\n+    name = this->get_id(gogo);\n+  tree decl;\n+  switch (this->classification_)\n+    {\n+    case NAMED_OBJECT_CONST:\n+      {\n+\tNamed_constant* named_constant = this->u_.const_value;\n+\tTranslate_context subcontext(gogo, function, NULL, NULL);\n+\ttree expr_tree = named_constant->expr()->get_tree(&subcontext);\n+\tif (expr_tree == error_mark_node)\n+\t  decl = error_mark_node;\n+\telse\n+\t  {\n+\t    Type* type = named_constant->type();\n+\t    if (type != NULL && !type->is_abstract())\n+\t      {\n+\t\tif (!type->is_error())\n+\t\t  expr_tree = fold_convert(type->get_tree(gogo), expr_tree);\n+\t\telse\n+\t\t  expr_tree = error_mark_node;\n+\t      }\n+\t    if (expr_tree == error_mark_node)\n+\t      decl = error_mark_node;\n+\t    else if (INTEGRAL_TYPE_P(TREE_TYPE(expr_tree)))\n+\t      {\n+\t\tdecl = build_decl(named_constant->location(), CONST_DECL,\n+\t\t\t\t  name, TREE_TYPE(expr_tree));\n+\t\tDECL_INITIAL(decl) = expr_tree;\n+\t\tTREE_CONSTANT(decl) = 1;\n+\t\tTREE_READONLY(decl) = 1;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// A CONST_DECL is only for an enum constant, so we\n+\t\t// shouldn't use for non-integral types.  Instead we\n+\t\t// just return the constant itself, rather than a\n+\t\t// decl.\n+\t\tdecl = expr_tree;\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case NAMED_OBJECT_TYPE:\n+      {\n+\tNamed_type* named_type = this->u_.type_value;\n+\ttree type_tree = named_type->get_tree(gogo);\n+\tif (type_tree == error_mark_node)\n+\t  decl = error_mark_node;\n+\telse\n+\t  {\n+\t    decl = TYPE_NAME(type_tree);\n+\t    go_assert(decl != NULL_TREE);\n+\n+\t    // We need to produce a type descriptor for every named\n+\t    // type, and for a pointer to every named type, since\n+\t    // other files or packages might refer to them.  We need\n+\t    // to do this even for hidden types, because they might\n+\t    // still be returned by some function.  Simply calling the\n+\t    // type_descriptor method is enough to create the type\n+\t    // descriptor, even though we don't do anything with it.\n+\t    if (this->package_ == NULL)\n+\t      {\n+\t\tnamed_type->type_descriptor_pointer(gogo);\n+\t\tType* pn = Type::make_pointer_type(named_type);\n+\t\tpn->type_descriptor_pointer(gogo);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case NAMED_OBJECT_TYPE_DECLARATION:\n+      error(\"reference to undefined type %qs\",\n+\t    this->message_name().c_str());\n+      return error_mark_node;\n+\n+    case NAMED_OBJECT_VAR:\n+    case NAMED_OBJECT_RESULT_VAR:\n+    case NAMED_OBJECT_SINK:\n+      go_unreachable();\n+\n+    case NAMED_OBJECT_FUNC:\n+      {\n+\tFunction* func = this->u_.func_value;\n+\tdecl = func->get_or_make_decl(gogo, this, name);\n+\tif (decl != error_mark_node)\n+\t  {\n+\t    if (func->block() != NULL)\n+\t      {\n+\t\tif (DECL_STRUCT_FUNCTION(decl) == NULL)\n+\t\t  push_struct_function(decl);\n+\t\telse\n+\t\t  push_cfun(DECL_STRUCT_FUNCTION(decl));\n+\n+\t\tcfun->function_end_locus = func->block()->end_location();\n+\n+\t\tcurrent_function_decl = decl;\n+\n+\t\tfunc->build_tree(gogo, this);\n+\n+\t\tgimplify_function_tree(decl);\n+\n+\t\tcgraph_finalize_function(decl, true);\n+\n+\t\tcurrent_function_decl = NULL_TREE;\n+\t\tpop_cfun();\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      go_unreachable();\n+    }\n+\n+  if (TREE_TYPE(decl) == error_mark_node)\n+    decl = error_mark_node;\n+\n+  tree ret = decl;\n+\n+  this->tree_ = ret;\n+\n+  if (ret != error_mark_node)\n+    go_preserve_from_gc(ret);\n+\n+  return ret;\n+}\n+\n+// Get the initial value of a variable as a tree.  This does not\n+// consider whether the variable is in the heap--it returns the\n+// initial value as though it were always stored in the stack.\n+\n+tree\n+Variable::get_init_tree(Gogo* gogo, Named_object* function)\n+{\n+  go_assert(this->preinit_ == NULL);\n+  if (this->init_ == NULL)\n+    {\n+      go_assert(!this->is_parameter_);\n+      return this->type_->get_init_tree(gogo,\n+\t\t\t\t\t(this->is_global_\n+\t\t\t\t\t || this->is_in_heap()));\n+    }\n+  else\n+    {\n+      Translate_context context(gogo, function, NULL, NULL);\n+      tree rhs_tree = this->init_->get_tree(&context);\n+      return Expression::convert_for_assignment(&context, this->type(),\n+\t\t\t\t\t\tthis->init_->type(),\n+\t\t\t\t\t\trhs_tree, this->location());\n+    }\n+}\n+\n+// Get the initial value of a variable when a block is required.\n+// VAR_DECL is the decl to set; it may be NULL for a sink variable.\n+\n+tree\n+Variable::get_init_block(Gogo* gogo, Named_object* function, tree var_decl)\n+{\n+  go_assert(this->preinit_ != NULL);\n+\n+  // We want to add the variable assignment to the end of the preinit\n+  // block.  The preinit block may have a TRY_FINALLY_EXPR and a\n+  // TRY_CATCH_EXPR; if it does, we want to add to the end of the\n+  // regular statements.\n+\n+  Translate_context context(gogo, function, NULL, NULL);\n+  Bblock* bblock = this->preinit_->get_backend(&context);\n+  tree block_tree = block_to_tree(bblock);\n+  if (block_tree == error_mark_node)\n+    return error_mark_node;\n+  go_assert(TREE_CODE(block_tree) == BIND_EXPR);\n+  tree statements = BIND_EXPR_BODY(block_tree);\n+  while (statements != NULL_TREE\n+\t && (TREE_CODE(statements) == TRY_FINALLY_EXPR\n+\t     || TREE_CODE(statements) == TRY_CATCH_EXPR))\n+    statements = TREE_OPERAND(statements, 0);\n+\n+  // It's possible to have pre-init statements without an initializer\n+  // if the pre-init statements set the variable.\n+  if (this->init_ != NULL)\n+    {\n+      tree rhs_tree = this->init_->get_tree(&context);\n+      if (rhs_tree == error_mark_node)\n+\treturn error_mark_node;\n+      if (var_decl == NULL_TREE)\n+\tappend_to_statement_list(rhs_tree, &statements);\n+      else\n+\t{\n+\t  tree val = Expression::convert_for_assignment(&context, this->type(),\n+\t\t\t\t\t\t\tthis->init_->type(),\n+\t\t\t\t\t\t\trhs_tree,\n+\t\t\t\t\t\t\tthis->location());\n+\t  if (val == error_mark_node)\n+\t    return error_mark_node;\n+\t  tree set = fold_build2_loc(this->location(), MODIFY_EXPR,\n+\t\t\t\t     void_type_node, var_decl, val);\n+\t  append_to_statement_list(set, &statements);\n+\t}\n+    }\n+\n+  return block_tree;\n+}\n+\n+// Get a tree for a function decl.\n+\n+tree\n+Function::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n+{\n+  if (this->fndecl_ == NULL_TREE)\n+    {\n+      tree functype = this->type_->get_tree(gogo);\n+      if (functype == error_mark_node)\n+\tthis->fndecl_ = error_mark_node;\n+      else\n+\t{\n+\t  // The type of a function comes back as a pointer, but we\n+\t  // want the real function type for a function declaration.\n+\t  go_assert(POINTER_TYPE_P(functype));\n+\t  functype = TREE_TYPE(functype);\n+\t  tree decl = build_decl(this->location(), FUNCTION_DECL, id, functype);\n+\n+\t  this->fndecl_ = decl;\n+\n+\t  if (no->package() != NULL)\n+\t    ;\n+\t  else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n+\t    ;\n+\t  else if (Gogo::unpack_hidden_name(no->name()) == \"init\"\n+\t\t   && !this->type_->is_method())\n+\t    ;\n+\t  else if (Gogo::unpack_hidden_name(no->name()) == \"main\"\n+\t\t   && gogo->is_main_package())\n+\t    TREE_PUBLIC(decl) = 1;\n+\t  // Methods have to be public even if they are hidden because\n+\t  // they can be pulled into type descriptors when using\n+\t  // anonymous fields.\n+\t  else if (!Gogo::is_hidden_name(no->name())\n+\t\t   || this->type_->is_method())\n+\t    {\n+\t      TREE_PUBLIC(decl) = 1;\n+\t      std::string asm_name = gogo->unique_prefix();\n+\t      asm_name.append(1, '.');\n+\t      asm_name.append(IDENTIFIER_POINTER(id), IDENTIFIER_LENGTH(id));\n+\t      SET_DECL_ASSEMBLER_NAME(decl,\n+\t\t\t\t      get_identifier_from_string(asm_name));\n+\t    }\n+\n+\t  // Why do we have to do this in the frontend?\n+\t  tree restype = TREE_TYPE(functype);\n+\t  tree resdecl = build_decl(this->location(), RESULT_DECL, NULL_TREE,\n+\t\t\t\t    restype);\n+\t  DECL_ARTIFICIAL(resdecl) = 1;\n+\t  DECL_IGNORED_P(resdecl) = 1;\n+\t  DECL_CONTEXT(resdecl) = decl;\n+\t  DECL_RESULT(decl) = resdecl;\n+\n+\t  if (this->enclosing_ != NULL)\n+\t    DECL_STATIC_CHAIN(decl) = 1;\n+\n+\t  // If a function calls the predeclared recover function, we\n+\t  // can't inline it, because recover behaves differently in a\n+\t  // function passed directly to defer.\n+\t  if (this->calls_recover_ && !this->is_recover_thunk_)\n+\t    DECL_UNINLINABLE(decl) = 1;\n+\n+\t  // If this is a thunk created to call a function which calls\n+\t  // the predeclared recover function, we need to disable\n+\t  // stack splitting for the thunk.\n+\t  if (this->is_recover_thunk_)\n+\t    {\n+\t      tree attr = get_identifier(\"__no_split_stack__\");\n+\t      DECL_ATTRIBUTES(decl) = tree_cons(attr, NULL_TREE, NULL_TREE);\n+\t    }\n+\n+\t  go_preserve_from_gc(decl);\n+\n+\t  if (this->closure_var_ != NULL)\n+\t    {\n+\t      push_struct_function(decl);\n+\n+\t      Bvariable* bvar = this->closure_var_->get_backend_variable(gogo,\n+\t\t\t\t\t\t\t\t\t no);\n+\t      tree closure_decl = var_to_tree(bvar);\n+\t      if (closure_decl == error_mark_node)\n+\t\tthis->fndecl_ = error_mark_node;\n+\t      else\n+\t\t{\n+\t\t  DECL_ARTIFICIAL(closure_decl) = 1;\n+\t\t  DECL_IGNORED_P(closure_decl) = 1;\n+\t\t  TREE_USED(closure_decl) = 1;\n+\t\t  DECL_ARG_TYPE(closure_decl) = TREE_TYPE(closure_decl);\n+\t\t  TREE_READONLY(closure_decl) = 1;\n+\n+\t\t  DECL_STRUCT_FUNCTION(decl)->static_chain_decl = closure_decl;\n+\t\t}\n+\n+\t      pop_cfun();\n+\t    }\n+\t}\n+    }\n+  return this->fndecl_;\n+}\n+\n+// Get a tree for a function declaration.\n+\n+tree\n+Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no, tree id)\n+{\n+  if (this->fndecl_ == NULL_TREE)\n+    {\n+      // Let Go code use an asm declaration to pick up a builtin\n+      // function.\n+      if (!this->asm_name_.empty())\n+\t{\n+\t  std::map<std::string, tree>::const_iterator p =\n+\t    builtin_functions.find(this->asm_name_);\n+\t  if (p != builtin_functions.end())\n+\t    {\n+\t      this->fndecl_ = p->second;\n+\t      return this->fndecl_;\n+\t    }\n+\t}\n+\n+      tree functype = this->fntype_->get_tree(gogo);\n+      tree decl;\n+      if (functype == error_mark_node)\n+\tdecl = error_mark_node;\n+      else\n+\t{\n+\t  // The type of a function comes back as a pointer, but we\n+\t  // want the real function type for a function declaration.\n+\t  go_assert(POINTER_TYPE_P(functype));\n+\t  functype = TREE_TYPE(functype);\n+\t  decl = build_decl(this->location(), FUNCTION_DECL, id, functype);\n+\t  TREE_PUBLIC(decl) = 1;\n+\t  DECL_EXTERNAL(decl) = 1;\n+\n+\t  if (this->asm_name_.empty())\n+\t    {\n+\t      std::string asm_name = (no->package() == NULL\n+\t\t\t\t      ? gogo->unique_prefix()\n+\t\t\t\t      : no->package()->unique_prefix());\n+\t      asm_name.append(1, '.');\n+\t      asm_name.append(IDENTIFIER_POINTER(id), IDENTIFIER_LENGTH(id));\n+\t      SET_DECL_ASSEMBLER_NAME(decl,\n+\t\t\t\t      get_identifier_from_string(asm_name));\n+\t    }\n+\t}\n+      this->fndecl_ = decl;\n+      go_preserve_from_gc(decl);\n+    }\n+  return this->fndecl_;\n+}\n+\n+// We always pass the receiver to a method as a pointer.  If the\n+// receiver is actually declared as a non-pointer type, then we copy\n+// the value into a local variable, so that it has the right type.  In\n+// this function we create the real PARM_DECL to use, and set\n+// DEC_INITIAL of the var_decl to be the value passed in.\n+\n+tree\n+Function::make_receiver_parm_decl(Gogo* gogo, Named_object* no, tree var_decl)\n+{\n+  if (var_decl == error_mark_node)\n+    return error_mark_node;\n+  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n+  tree val_type = TREE_TYPE(var_decl);\n+  bool is_in_heap = no->var_value()->is_in_heap();\n+  if (is_in_heap)\n+    {\n+      go_assert(POINTER_TYPE_P(val_type));\n+      val_type = TREE_TYPE(val_type);\n+    }\n+\n+  source_location loc = DECL_SOURCE_LOCATION(var_decl);\n+  std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n+  name += \".pointer\";\n+  tree id = get_identifier_from_string(name);\n+  tree parm_decl = build_decl(loc, PARM_DECL, id, build_pointer_type(val_type));\n+  DECL_CONTEXT(parm_decl) = current_function_decl;\n+  DECL_ARG_TYPE(parm_decl) = TREE_TYPE(parm_decl);\n+\n+  go_assert(DECL_INITIAL(var_decl) == NULL_TREE);\n+  // The receiver might be passed as a null pointer.\n+  tree check = fold_build2_loc(loc, NE_EXPR, boolean_type_node, parm_decl,\n+\t\t\t       fold_convert_loc(loc, TREE_TYPE(parm_decl),\n+\t\t\t\t\t\tnull_pointer_node));\n+  tree ind = build_fold_indirect_ref_loc(loc, parm_decl);\n+  TREE_THIS_NOTRAP(ind) = 1;\n+  tree zero_init = no->var_value()->type()->get_init_tree(gogo, false);\n+  tree init = fold_build3_loc(loc, COND_EXPR, TREE_TYPE(ind),\n+\t\t\t      check, ind, zero_init);\n+\n+  if (is_in_heap)\n+    {\n+      tree size = TYPE_SIZE_UNIT(val_type);\n+      tree space = gogo->allocate_memory(no->var_value()->type(), size,\n+\t\t\t\t\t no->location());\n+      space = save_expr(space);\n+      space = fold_convert(build_pointer_type(val_type), space);\n+      tree spaceref = build_fold_indirect_ref_loc(no->location(), space);\n+      TREE_THIS_NOTRAP(spaceref) = 1;\n+      tree check = fold_build2_loc(loc, NE_EXPR, boolean_type_node,\n+\t\t\t\t   parm_decl,\n+\t\t\t\t   fold_convert_loc(loc, TREE_TYPE(parm_decl),\n+\t\t\t\t\t\t    null_pointer_node));\n+      tree parmref = build_fold_indirect_ref_loc(no->location(), parm_decl);\n+      TREE_THIS_NOTRAP(parmref) = 1;\n+      tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n+\t\t\t\t spaceref, parmref);\n+      init = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(space),\n+\t\t\t     build3(COND_EXPR, void_type_node,\n+\t\t\t\t    check, set, NULL_TREE),\n+\t\t\t     space);\n+    }\n+\n+  DECL_INITIAL(var_decl) = init;\n+\n+  return parm_decl;\n+}\n+\n+// If we take the address of a parameter, then we need to copy it into\n+// the heap.  We will access it as a local variable via an\n+// indirection.\n+\n+tree\n+Function::copy_parm_to_heap(Gogo* gogo, Named_object* no, tree var_decl)\n+{\n+  if (var_decl == error_mark_node)\n+    return error_mark_node;\n+  go_assert(TREE_CODE(var_decl) == VAR_DECL);\n+  source_location loc = DECL_SOURCE_LOCATION(var_decl);\n+\n+  std::string name = IDENTIFIER_POINTER(DECL_NAME(var_decl));\n+  name += \".param\";\n+  tree id = get_identifier_from_string(name);\n+\n+  tree type = TREE_TYPE(var_decl);\n+  go_assert(POINTER_TYPE_P(type));\n+  type = TREE_TYPE(type);\n+\n+  tree parm_decl = build_decl(loc, PARM_DECL, id, type);\n+  DECL_CONTEXT(parm_decl) = current_function_decl;\n+  DECL_ARG_TYPE(parm_decl) = type;\n+\n+  tree size = TYPE_SIZE_UNIT(type);\n+  tree space = gogo->allocate_memory(no->var_value()->type(), size, loc);\n+  space = save_expr(space);\n+  space = fold_convert(TREE_TYPE(var_decl), space);\n+  tree spaceref = build_fold_indirect_ref_loc(loc, space);\n+  TREE_THIS_NOTRAP(spaceref) = 1;\n+  tree init = build2(COMPOUND_EXPR, TREE_TYPE(space),\n+\t\t     build2(MODIFY_EXPR, void_type_node, spaceref, parm_decl),\n+\t\t     space);\n+  DECL_INITIAL(var_decl) = init;\n+\n+  return parm_decl;\n+}\n+\n+// Get a tree for function code.\n+\n+void\n+Function::build_tree(Gogo* gogo, Named_object* named_function)\n+{\n+  tree fndecl = this->fndecl_;\n+  go_assert(fndecl != NULL_TREE);\n+\n+  tree params = NULL_TREE;\n+  tree* pp = &params;\n+\n+  tree declare_vars = NULL_TREE;\n+  for (Bindings::const_definitions_iterator p =\n+\t this->block_->bindings()->begin_definitions();\n+       p != this->block_->bindings()->end_definitions();\n+       ++p)\n+    {\n+      if ((*p)->is_variable() && (*p)->var_value()->is_parameter())\n+\t{\n+\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n+\t  *pp = var_to_tree(bvar);\n+\n+\t  // We always pass the receiver to a method as a pointer.  If\n+\t  // the receiver is declared as a non-pointer type, then we\n+\t  // copy the value into a local variable.\n+\t  if ((*p)->var_value()->is_receiver()\n+\t      && (*p)->var_value()->type()->points_to() == NULL)\n+\t    {\n+\t      tree parm_decl = this->make_receiver_parm_decl(gogo, *p, *pp);\n+\t      tree var = *pp;\n+\t      if (var != error_mark_node)\n+\t\t{\n+\t\t  go_assert(TREE_CODE(var) == VAR_DECL);\n+\t\t  DECL_CHAIN(var) = declare_vars;\n+\t\t  declare_vars = var;\n+\t\t}\n+\t      *pp = parm_decl;\n+\t    }\n+\t  else if ((*p)->var_value()->is_in_heap())\n+\t    {\n+\t      // If we take the address of a parameter, then we need\n+\t      // to copy it into the heap.\n+\t      tree parm_decl = this->copy_parm_to_heap(gogo, *p, *pp);\n+\t      tree var = *pp;\n+\t      if (var != error_mark_node)\n+\t\t{\n+\t\t  go_assert(TREE_CODE(var) == VAR_DECL);\n+\t\t  DECL_CHAIN(var) = declare_vars;\n+\t\t  declare_vars = var;\n+\t\t}\n+\t      *pp = parm_decl;\n+\t    }\n+\n+\t  if (*pp != error_mark_node)\n+\t    {\n+\t      go_assert(TREE_CODE(*pp) == PARM_DECL);\n+\t      pp = &DECL_CHAIN(*pp);\n+\t    }\n+\t}\n+      else if ((*p)->is_result_variable())\n+\t{\n+\t  Bvariable* bvar = (*p)->get_backend_variable(gogo, named_function);\n+\t  tree var_decl = var_to_tree(bvar);\n+\n+\t  Type* type = (*p)->result_var_value()->type();\n+\t  tree init;\n+\t  if (!(*p)->result_var_value()->is_in_heap())\n+\t    init = type->get_init_tree(gogo, false);\n+\t  else\n+\t    {\n+\t      source_location loc = (*p)->location();\n+\t      tree type_tree = type->get_tree(gogo);\n+\t      tree space = gogo->allocate_memory(type,\n+\t\t\t\t\t\t TYPE_SIZE_UNIT(type_tree),\n+\t\t\t\t\t\t loc);\n+\t      tree ptr_type_tree = build_pointer_type(type_tree);\n+\t      tree subinit = type->get_init_tree(gogo, true);\n+\t      if (subinit == NULL_TREE)\n+\t\tinit = fold_convert_loc(loc, ptr_type_tree, space);\n+\t      else\n+\t\t{\n+\t\t  space = save_expr(space);\n+\t\t  space = fold_convert_loc(loc, ptr_type_tree, space);\n+\t\t  tree spaceref = build_fold_indirect_ref_loc(loc, space);\n+\t\t  TREE_THIS_NOTRAP(spaceref) = 1;\n+\t\t  tree set = fold_build2_loc(loc, MODIFY_EXPR, void_type_node,\n+\t\t\t\t\t     spaceref, subinit);\n+\t\t  init = fold_build2_loc(loc, COMPOUND_EXPR, TREE_TYPE(space),\n+\t\t\t\t\t set, space);\n+\t\t}\n+\t    }\n+\n+\t  if (var_decl != error_mark_node)\n+\t    {\n+\t      go_assert(TREE_CODE(var_decl) == VAR_DECL);\n+\t      DECL_INITIAL(var_decl) = init;\n+\t      DECL_CHAIN(var_decl) = declare_vars;\n+\t      declare_vars = var_decl;\n+\t    }\n+\t}\n+    }\n+  *pp = NULL_TREE;\n+\n+  DECL_ARGUMENTS(fndecl) = params;\n+\n+  if (this->block_ != NULL)\n+    {\n+      go_assert(DECL_INITIAL(fndecl) == NULL_TREE);\n+\n+      // Declare variables if necessary.\n+      tree bind = NULL_TREE;\n+      tree defer_init = NULL_TREE;\n+      if (declare_vars != NULL_TREE || this->defer_stack_ != NULL)\n+\t{\n+\t  tree block = make_node(BLOCK);\n+\t  BLOCK_SUPERCONTEXT(block) = fndecl;\n+\t  DECL_INITIAL(fndecl) = block;\n+\t  BLOCK_VARS(block) = declare_vars;\n+\t  TREE_USED(block) = 1;\n+\n+\t  bind = build3(BIND_EXPR, void_type_node, BLOCK_VARS(block),\n+\t\t\tNULL_TREE, block);\n+\t  TREE_SIDE_EFFECTS(bind) = 1;\n+\n+\t  if (this->defer_stack_ != NULL)\n+\t    {\n+\t      Translate_context dcontext(gogo, named_function, this->block_,\n+\t\t\t\t\t tree_to_block(bind));\n+\t      Bstatement* bdi = this->defer_stack_->get_backend(&dcontext);\n+\t      defer_init = stat_to_tree(bdi);\n+\t    }\n+\t}\n+\n+      // Build the trees for all the statements in the function.\n+      Translate_context context(gogo, named_function, NULL, NULL);\n+      Bblock* bblock = this->block_->get_backend(&context);\n+      tree code = block_to_tree(bblock);\n+\n+      tree init = NULL_TREE;\n+      tree except = NULL_TREE;\n+      tree fini = NULL_TREE;\n+\n+      // Initialize variables if necessary.\n+      for (tree v = declare_vars; v != NULL_TREE; v = DECL_CHAIN(v))\n+\t{\n+\t  tree dv = build1(DECL_EXPR, void_type_node, v);\n+\t  SET_EXPR_LOCATION(dv, DECL_SOURCE_LOCATION(v));\n+\t  append_to_statement_list(dv, &init);\n+\t}\n+\n+      // If we have a defer stack, initialize it at the start of a\n+      // function.\n+      if (defer_init != NULL_TREE && defer_init != error_mark_node)\n+\t{\n+\t  SET_EXPR_LOCATION(defer_init, this->block_->start_location());\n+\t  append_to_statement_list(defer_init, &init);\n+\n+\t  // Clean up the defer stack when we leave the function.\n+\t  this->build_defer_wrapper(gogo, named_function, &except, &fini);\n+\t}\n+\n+      if (code != NULL_TREE && code != error_mark_node)\n+\t{\n+\t  if (init != NULL_TREE)\n+\t    code = build2(COMPOUND_EXPR, void_type_node, init, code);\n+\t  if (except != NULL_TREE)\n+\t    code = build2(TRY_CATCH_EXPR, void_type_node, code,\n+\t\t\t  build2(CATCH_EXPR, void_type_node, NULL, except));\n+\t  if (fini != NULL_TREE)\n+\t    code = build2(TRY_FINALLY_EXPR, void_type_node, code, fini);\n+\t}\n+\n+      // Stick the code into the block we built for the receiver, if\n+      // we built on.\n+      if (bind != NULL_TREE && code != NULL_TREE && code != error_mark_node)\n+\t{\n+\t  BIND_EXPR_BODY(bind) = code;\n+\t  code = bind;\n+\t}\n+\n+      DECL_SAVED_TREE(fndecl) = code;\n+    }\n+}\n+\n+// Build the wrappers around function code needed if the function has\n+// any defer statements.  This sets *EXCEPT to an exception handler\n+// and *FINI to a finally handler.\n+\n+void\n+Function::build_defer_wrapper(Gogo* gogo, Named_object* named_function,\n+\t\t\t      tree *except, tree *fini)\n+{\n+  source_location end_loc = this->block_->end_location();\n+\n+  // Add an exception handler.  This is used if a panic occurs.  Its\n+  // purpose is to stop the stack unwinding if a deferred function\n+  // calls recover.  There are more details in\n+  // libgo/runtime/go-unwind.c.\n+\n+  tree stmt_list = NULL_TREE;\n+\n+  Expression* call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n+\t\t\t\t\tthis->defer_stack(end_loc));\n+  Translate_context context(gogo, named_function, NULL, NULL);\n+  tree call_tree = call->get_tree(&context);\n+  if (call_tree != error_mark_node)\n+    append_to_statement_list(call_tree, &stmt_list);\n+\n+  tree retval = this->return_value(gogo, named_function, end_loc, &stmt_list);\n+  tree set;\n+  if (retval == NULL_TREE)\n+    set = NULL_TREE;\n+  else\n+    set = fold_build2_loc(end_loc, MODIFY_EXPR, void_type_node,\n+\t\t\t  DECL_RESULT(this->fndecl_), retval);\n+  tree ret_stmt = fold_build1_loc(end_loc, RETURN_EXPR, void_type_node, set);\n+  append_to_statement_list(ret_stmt, &stmt_list);\n+\n+  go_assert(*except == NULL_TREE);\n+  *except = stmt_list;\n+\n+  // Add some finally code to run the defer functions.  This is used\n+  // both in the normal case, when no panic occurs, and also if a\n+  // panic occurs to run any further defer functions.  Of course, it\n+  // is possible for a defer function to call panic which should be\n+  // caught by another defer function.  To handle that we use a loop.\n+  //  finish:\n+  //   try { __go_undefer(); } catch { __go_check_defer(); goto finish; }\n+  //   if (return values are named) return named_vals;\n+\n+  stmt_list = NULL;\n+\n+  tree label = create_artificial_label(end_loc);\n+  tree define_label = fold_build1_loc(end_loc, LABEL_EXPR, void_type_node,\n+\t\t\t\t      label);\n+  append_to_statement_list(define_label, &stmt_list);\n+\n+  call = Runtime::make_call(Runtime::UNDEFER, end_loc, 1,\n+\t\t\t    this->defer_stack(end_loc));\n+  tree undefer = call->get_tree(&context);\n+\n+  call = Runtime::make_call(Runtime::CHECK_DEFER, end_loc, 1,\n+\t\t\t    this->defer_stack(end_loc));\n+  tree defer = call->get_tree(&context);\n+\n+  if (undefer == error_mark_node || defer == error_mark_node)\n+    return;\n+\n+  tree jump = fold_build1_loc(end_loc, GOTO_EXPR, void_type_node, label);\n+  tree catch_body = build2(COMPOUND_EXPR, void_type_node, defer, jump);\n+  catch_body = build2(CATCH_EXPR, void_type_node, NULL, catch_body);\n+  tree try_catch = build2(TRY_CATCH_EXPR, void_type_node, undefer, catch_body);\n+\n+  append_to_statement_list(try_catch, &stmt_list);\n+\n+  if (this->type_->results() != NULL\n+      && !this->type_->results()->empty()\n+      && !this->type_->results()->front().name().empty())\n+    {\n+      // If the result variables are named, we need to return them\n+      // again, because they might have been changed by a defer\n+      // function.\n+      retval = this->return_value(gogo, named_function, end_loc,\n+\t\t\t\t  &stmt_list);\n+      set = fold_build2_loc(end_loc, MODIFY_EXPR, void_type_node,\n+\t\t\t    DECL_RESULT(this->fndecl_), retval);\n+      ret_stmt = fold_build1_loc(end_loc, RETURN_EXPR, void_type_node, set);\n+      append_to_statement_list(ret_stmt, &stmt_list);\n+    }\n+  \n+  go_assert(*fini == NULL_TREE);\n+  *fini = stmt_list;\n+}\n+\n+// Return the value to assign to DECL_RESULT(this->fndecl_).  This may\n+// also add statements to STMT_LIST, which need to be executed before\n+// the assignment.  This is used for a return statement with no\n+// explicit values.\n+\n+tree\n+Function::return_value(Gogo* gogo, Named_object* named_function,\n+\t\t       source_location location, tree* stmt_list) const\n+{\n+  const Typed_identifier_list* results = this->type_->results();\n+  if (results == NULL || results->empty())\n+    return NULL_TREE;\n+\n+  go_assert(this->results_ != NULL);\n+  if (this->results_->size() != results->size())\n+    {\n+      go_assert(saw_errors());\n+      return error_mark_node;\n+    }\n+\n+  tree retval;\n+  if (results->size() == 1)\n+    {\n+      Bvariable* bvar =\n+\tthis->results_->front()->get_backend_variable(gogo,\n+\t\t\t\t\t\t      named_function);\n+      tree ret = var_to_tree(bvar);\n+      if (this->results_->front()->result_var_value()->is_in_heap())\n+\tret = build_fold_indirect_ref_loc(location, ret);\n+      return ret;\n+    }\n+  else\n+    {\n+      tree rettype = TREE_TYPE(DECL_RESULT(this->fndecl_));\n+      retval = create_tmp_var(rettype, \"RESULT\");\n+      tree field = TYPE_FIELDS(rettype);\n+      int index = 0;\n+      for (Typed_identifier_list::const_iterator pr = results->begin();\n+\t   pr != results->end();\n+\t   ++pr, ++index, field = DECL_CHAIN(field))\n+\t{\n+\t  go_assert(field != NULL);\n+\t  Named_object* no = (*this->results_)[index];\n+\t  Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n+\t  tree val = var_to_tree(bvar);\n+\t  if (no->result_var_value()->is_in_heap())\n+\t    val = build_fold_indirect_ref_loc(location, val);\n+\t  tree set = fold_build2_loc(location, MODIFY_EXPR, void_type_node,\n+\t\t\t\t     build3(COMPONENT_REF, TREE_TYPE(field),\n+\t\t\t\t\t    retval, field, NULL_TREE),\n+\t\t\t\t     val);\n+\t  append_to_statement_list(set, stmt_list);\n+\t}\n+      return retval;\n+    }\n+}\n+\n+// Return the integer type to use for a size.\n+\n+GO_EXTERN_C\n+tree\n+go_type_for_size(unsigned int bits, int unsignedp)\n+{\n+  const char* name;\n+  switch (bits)\n+    {\n+    case 8:\n+      name = unsignedp ? \"uint8\" : \"int8\";\n+      break;\n+    case 16:\n+      name = unsignedp ? \"uint16\" : \"int16\";\n+      break;\n+    case 32:\n+      name = unsignedp ? \"uint32\" : \"int32\";\n+      break;\n+    case 64:\n+      name = unsignedp ? \"uint64\" : \"int64\";\n+      break;\n+    default:\n+      if (bits == POINTER_SIZE && unsignedp)\n+\tname = \"uintptr\";\n+      else\n+\treturn NULL_TREE;\n+    }\n+  Type* type = Type::lookup_integer_type(name);\n+  return type->get_tree(go_get_gogo());\n+}\n+\n+// Return the type to use for a mode.\n+\n+GO_EXTERN_C\n+tree\n+go_type_for_mode(enum machine_mode mode, int unsignedp)\n+{\n+  // FIXME: This static_cast should be in machmode.h.\n+  enum mode_class mc = static_cast<enum mode_class>(GET_MODE_CLASS(mode));\n+  if (mc == MODE_INT)\n+    return go_type_for_size(GET_MODE_BITSIZE(mode), unsignedp);\n+  else if (mc == MODE_FLOAT)\n+    {\n+      Type* type;\n+      switch (GET_MODE_BITSIZE (mode))\n+\t{\n+\tcase 32:\n+\t  type = Type::lookup_float_type(\"float32\");\n+\t  break;\n+\tcase 64:\n+\t  type = Type::lookup_float_type(\"float64\");\n+\t  break;\n+\tdefault:\n+\t  // We have to check for long double in order to support\n+\t  // i386 excess precision.\n+\t  if (mode == TYPE_MODE(long_double_type_node))\n+\t    return long_double_type_node;\n+\t  return NULL_TREE;\n+\t}\n+      return type->float_type()->type_tree();\n+    }\n+  else if (mc == MODE_COMPLEX_FLOAT)\n+    {\n+      Type *type;\n+      switch (GET_MODE_BITSIZE (mode))\n+\t{\n+\tcase 64:\n+\t  type = Type::lookup_complex_type(\"complex64\");\n+\t  break;\n+\tcase 128:\n+\t  type = Type::lookup_complex_type(\"complex128\");\n+\t  break;\n+\tdefault:\n+\t  // We have to check for long double in order to support\n+\t  // i386 excess precision.\n+\t  if (mode == TYPE_MODE(complex_long_double_type_node))\n+\t    return complex_long_double_type_node;\n+\t  return NULL_TREE;\n+\t}\n+      return type->complex_type()->type_tree();\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n+// Return a tree which allocates SIZE bytes which will holds value of\n+// type TYPE.\n+\n+tree\n+Gogo::allocate_memory(Type* type, tree size, source_location location)\n+{\n+  // If the package imports unsafe, then it may play games with\n+  // pointers that look like integers.\n+  if (this->imported_unsafe_ || type->has_pointer())\n+    {\n+      static tree new_fndecl;\n+      return Gogo::call_builtin(&new_fndecl,\n+\t\t\t\tlocation,\n+\t\t\t\t\"__go_new\",\n+\t\t\t\t1,\n+\t\t\t\tptr_type_node,\n+\t\t\t\tsizetype,\n+\t\t\t\tsize);\n+    }\n+  else\n+    {\n+      static tree new_nopointers_fndecl;\n+      return Gogo::call_builtin(&new_nopointers_fndecl,\n+\t\t\t\tlocation,\n+\t\t\t\t\"__go_new_nopointers\",\n+\t\t\t\t1,\n+\t\t\t\tptr_type_node,\n+\t\t\t\tsizetype,\n+\t\t\t\tsize);\n+    }\n+}\n+\n+// Build a builtin struct with a list of fields.  The name is\n+// STRUCT_NAME.  STRUCT_TYPE is NULL_TREE or an empty RECORD_TYPE\n+// node; this exists so that the struct can have fields which point to\n+// itself.  If PTYPE is not NULL, store the result in *PTYPE.  There\n+// are NFIELDS fields.  Each field is a name (a const char*) followed\n+// by a type (a tree).\n+\n+tree\n+Gogo::builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n+\t\t     int nfields, ...)\n+{\n+  if (ptype != NULL && *ptype != NULL_TREE)\n+    return *ptype;\n+\n+  va_list ap;\n+  va_start(ap, nfields);\n+\n+  tree fields = NULL_TREE;\n+  for (int i = 0; i < nfields; ++i)\n+    {\n+      const char* field_name = va_arg(ap, const char*);\n+      tree type = va_arg(ap, tree);\n+      if (type == error_mark_node)\n+\t{\n+\t  if (ptype != NULL)\n+\t    *ptype = error_mark_node;\n+\t  return error_mark_node;\n+\t}\n+      tree field = build_decl(BUILTINS_LOCATION, FIELD_DECL,\n+\t\t\t      get_identifier(field_name), type);\n+      DECL_CHAIN(field) = fields;\n+      fields = field;\n+    }\n+\n+  va_end(ap);\n+\n+  if (struct_type == NULL_TREE)\n+    struct_type = make_node(RECORD_TYPE);\n+  finish_builtin_struct(struct_type, struct_name, fields, NULL_TREE);\n+\n+  if (ptype != NULL)\n+    {\n+      go_preserve_from_gc(struct_type);\n+      *ptype = struct_type;\n+    }\n+\n+  return struct_type;\n+}\n+\n+// Return a type to use for pointer to const char for a string.\n+\n+tree\n+Gogo::const_char_pointer_type_tree()\n+{\n+  static tree type;\n+  if (type == NULL_TREE)\n+    {\n+      tree const_char_type = build_qualified_type(unsigned_char_type_node,\n+\t\t\t\t\t\t  TYPE_QUAL_CONST);\n+      type = build_pointer_type(const_char_type);\n+      go_preserve_from_gc(type);\n+    }\n+  return type;\n+}\n+\n+// Return a tree for a string constant.\n+\n+tree\n+Gogo::string_constant_tree(const std::string& val)\n+{\n+  tree index_type = build_index_type(size_int(val.length()));\n+  tree const_char_type = build_qualified_type(unsigned_char_type_node,\n+\t\t\t\t\t      TYPE_QUAL_CONST);\n+  tree string_type = build_array_type(const_char_type, index_type);\n+  string_type = build_variant_type_copy(string_type);\n+  TYPE_STRING_FLAG(string_type) = 1;\n+  tree string_val = build_string(val.length(), val.data());\n+  TREE_TYPE(string_val) = string_type;\n+  return string_val;\n+}\n+\n+// Return a tree for a Go string constant.\n+\n+tree\n+Gogo::go_string_constant_tree(const std::string& val)\n+{\n+  tree string_type = Type::make_string_type()->get_tree(this);\n+\n+  VEC(constructor_elt, gc)* init = VEC_alloc(constructor_elt, gc, 2);\n+\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  tree field = TYPE_FIELDS(string_type);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__data\") == 0);\n+  elt->index = field;\n+  tree str = Gogo::string_constant_tree(val);\n+  elt->value = fold_convert(TREE_TYPE(field),\n+\t\t\t    build_fold_addr_expr(str));\n+\n+  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  field = DECL_CHAIN(field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__length\") == 0);\n+  elt->index = field;\n+  elt->value = build_int_cst_type(TREE_TYPE(field), val.length());\n+\n+  tree constructor = build_constructor(string_type, init);\n+  TREE_READONLY(constructor) = 1;\n+  TREE_CONSTANT(constructor) = 1;\n+\n+  return constructor;\n+}\n+\n+// Return a tree for a pointer to a Go string constant.  This is only\n+// used for type descriptors, so we return a pointer to a constant\n+// decl.\n+\n+tree\n+Gogo::ptr_go_string_constant_tree(const std::string& val)\n+{\n+  tree pval = this->go_string_constant_tree(val);\n+\n+  tree decl = build_decl(UNKNOWN_LOCATION, VAR_DECL,\n+\t\t\t create_tmp_var_name(\"SP\"), TREE_TYPE(pval));\n+  DECL_EXTERNAL(decl) = 0;\n+  TREE_PUBLIC(decl) = 0;\n+  TREE_USED(decl) = 1;\n+  TREE_READONLY(decl) = 1;\n+  TREE_CONSTANT(decl) = 1;\n+  TREE_STATIC(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+  DECL_INITIAL(decl) = pval;\n+  rest_of_decl_compilation(decl, 1, 0);\n+\n+  return build_fold_addr_expr(decl);\n+}\n+\n+// Build the type of the struct that holds a slice for the given\n+// element type.\n+\n+tree\n+Gogo::slice_type_tree(tree element_type_tree)\n+{\n+  // We use int for the count and capacity fields in a slice header.\n+  // This matches 6g.  The language definition guarantees that we\n+  // can't allocate space of a size which does not fit in int\n+  // anyhow. FIXME: integer_type_node is the the C type \"int\" but is\n+  // not necessarily the Go type \"int\".  They will differ when the C\n+  // type \"int\" has fewer than 32 bits.\n+  return Gogo::builtin_struct(NULL, \"__go_slice\", NULL_TREE, 3,\n+\t\t\t      \"__values\",\n+\t\t\t      build_pointer_type(element_type_tree),\n+\t\t\t      \"__count\",\n+\t\t\t      integer_type_node,\n+\t\t\t      \"__capacity\",\n+\t\t\t      integer_type_node);\n+}\n+\n+// Given the tree for a slice type, return the tree for the type of\n+// the elements of the slice.\n+\n+tree\n+Gogo::slice_element_type_tree(tree slice_type_tree)\n+{\n+  go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE\n+\t     && POINTER_TYPE_P(TREE_TYPE(TYPE_FIELDS(slice_type_tree))));\n+  return TREE_TYPE(TREE_TYPE(TYPE_FIELDS(slice_type_tree)));\n+}\n+\n+// Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n+// the slice.  VALUES is the value pointer and COUNT is the number of\n+// entries.  If CAPACITY is not NULL, it is the capacity; otherwise\n+// the capacity and the count are the same.\n+\n+tree\n+Gogo::slice_constructor(tree slice_type_tree, tree values, tree count,\n+\t\t\ttree capacity)\n+{\n+  go_assert(TREE_CODE(slice_type_tree) == RECORD_TYPE);\n+\n+  VEC(constructor_elt,gc)* init = VEC_alloc(constructor_elt, gc, 3);\n+\n+  tree field = TYPE_FIELDS(slice_type_tree);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__values\") == 0);\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt->index = field;\n+  go_assert(TYPE_MAIN_VARIANT(TREE_TYPE(field))\n+\t     == TYPE_MAIN_VARIANT(TREE_TYPE(values)));\n+  elt->value = values;\n+\n+  count = fold_convert(sizetype, count);\n+  if (capacity == NULL_TREE)\n+    {\n+      count = save_expr(count);\n+      capacity = count;\n+    }\n+\n+  field = DECL_CHAIN(field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__count\") == 0);\n+  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt->index = field;\n+  elt->value = fold_convert(TREE_TYPE(field), count);\n+\n+  field = DECL_CHAIN(field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__capacity\") == 0);\n+  elt = VEC_quick_push(constructor_elt, init, NULL);\n+  elt->index = field;\n+  elt->value = fold_convert(TREE_TYPE(field), capacity);\n+\n+  return build_constructor(slice_type_tree, init);\n+}\n+\n+// Build a constructor for an empty slice.\n+\n+tree\n+Gogo::empty_slice_constructor(tree slice_type_tree)\n+{\n+  tree element_field = TYPE_FIELDS(slice_type_tree);\n+  tree ret = Gogo::slice_constructor(slice_type_tree,\n+\t\t\t\t     fold_convert(TREE_TYPE(element_field),\n+\t\t\t\t\t\t  null_pointer_node),\n+\t\t\t\t     size_zero_node,\n+\t\t\t\t     size_zero_node);\n+  TREE_CONSTANT(ret) = 1;\n+  return ret;\n+}\n+\n+// Build a map descriptor for a map of type MAPTYPE.\n+\n+tree\n+Gogo::map_descriptor(Map_type* maptype)\n+{\n+  if (this->map_descriptors_ == NULL)\n+    this->map_descriptors_ = new Map_descriptors(10);\n+\n+  std::pair<const Map_type*, tree> val(maptype, NULL);\n+  std::pair<Map_descriptors::iterator, bool> ins =\n+    this->map_descriptors_->insert(val);\n+  Map_descriptors::iterator p = ins.first;\n+  if (!ins.second)\n+    {\n+      if (p->second == error_mark_node)\n+\treturn error_mark_node;\n+      go_assert(p->second != NULL_TREE && DECL_P(p->second));\n+      return build_fold_addr_expr(p->second);\n+    }\n+\n+  Type* keytype = maptype->key_type();\n+  Type* valtype = maptype->val_type();\n+\n+  std::string mangled_name = (\"__go_map_\" + maptype->mangled_name(this));\n+\n+  tree id = get_identifier_from_string(mangled_name);\n+\n+  // Get the type of the map descriptor.  This is __go_map_descriptor\n+  // in libgo/map.h.\n+\n+  tree struct_type = this->map_descriptor_type();\n+\n+  // The map entry type is a struct with three fields.  This struct is\n+  // specific to MAPTYPE.  Build it.\n+\n+  tree map_entry_type = make_node(RECORD_TYPE);\n+\n+  map_entry_type = Gogo::builtin_struct(NULL, \"__map\", map_entry_type, 3,\n+\t\t\t\t\t\"__next\",\n+\t\t\t\t\tbuild_pointer_type(map_entry_type),\n+\t\t\t\t\t\"__key\",\n+\t\t\t\t\tkeytype->get_tree(this),\n+\t\t\t\t\t\"__val\",\n+\t\t\t\t\tvaltype->get_tree(this));\n+  if (map_entry_type == error_mark_node)\n+    {\n+      p->second = error_mark_node;\n+      return error_mark_node;\n+    }\n+\n+  tree map_entry_key_field = DECL_CHAIN(TYPE_FIELDS(map_entry_type));\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_entry_key_field)),\n+\t\t    \"__key\") == 0);\n+\n+  tree map_entry_val_field = DECL_CHAIN(map_entry_key_field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_entry_val_field)),\n+\t\t    \"__val\") == 0);\n+\n+  // Initialize the entries.\n+\n+  tree map_descriptor_field = TYPE_FIELDS(struct_type);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(map_descriptor_field)),\n+\t\t    \"__map_descriptor\") == 0);\n+  tree entry_size_field = DECL_CHAIN(map_descriptor_field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(entry_size_field)),\n+\t\t    \"__entry_size\") == 0);\n+  tree key_offset_field = DECL_CHAIN(entry_size_field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(key_offset_field)),\n+\t\t    \"__key_offset\") == 0);\n+  tree val_offset_field = DECL_CHAIN(key_offset_field);\n+  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(val_offset_field)),\n+\t\t    \"__val_offset\") == 0);\n+\n+  VEC(constructor_elt, gc)* descriptor = VEC_alloc(constructor_elt, gc, 6);\n+\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, descriptor, NULL);\n+  elt->index = map_descriptor_field;\n+  elt->value = maptype->type_descriptor_pointer(this);\n+\n+  elt = VEC_quick_push(constructor_elt, descriptor, NULL);\n+  elt->index = entry_size_field;\n+  elt->value = TYPE_SIZE_UNIT(map_entry_type);\n+\n+  elt = VEC_quick_push(constructor_elt, descriptor, NULL);\n+  elt->index = key_offset_field;\n+  elt->value = byte_position(map_entry_key_field);\n+\n+  elt = VEC_quick_push(constructor_elt, descriptor, NULL);\n+  elt->index = val_offset_field;\n+  elt->value = byte_position(map_entry_val_field);\n+\n+  tree constructor = build_constructor(struct_type, descriptor);\n+\n+  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL, id, struct_type);\n+  TREE_STATIC(decl) = 1;\n+  TREE_USED(decl) = 1;\n+  TREE_READONLY(decl) = 1;\n+  TREE_CONSTANT(decl) = 1;\n+  DECL_INITIAL(decl) = constructor;\n+  make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n+  resolve_unique_section(decl, 1, 0);\n+\n+  rest_of_decl_compilation(decl, 1, 0);\n+\n+  go_preserve_from_gc(decl);\n+  p->second = decl;\n+\n+  return build_fold_addr_expr(decl);\n+}\n+\n+// Return a tree for the type of a map descriptor.  This is struct\n+// __go_map_descriptor in libgo/runtime/map.h.  This is the same for\n+// all map types.\n+\n+tree\n+Gogo::map_descriptor_type()\n+{\n+  static tree struct_type;\n+  tree dtype = Type::make_type_descriptor_type()->get_tree(this);\n+  dtype = build_qualified_type(dtype, TYPE_QUAL_CONST);\n+  return Gogo::builtin_struct(&struct_type, \"__go_map_descriptor\", NULL_TREE,\n+\t\t\t      4,\n+\t\t\t      \"__map_descriptor\",\n+\t\t\t      build_pointer_type(dtype),\n+\t\t\t      \"__entry_size\",\n+\t\t\t      sizetype,\n+\t\t\t      \"__key_offset\",\n+\t\t\t      sizetype,\n+\t\t\t      \"__val_offset\",\n+\t\t\t      sizetype);\n+}\n+\n+// Return the name to use for a type descriptor decl for TYPE.  This\n+// is used when TYPE does not have a name.\n+\n+std::string\n+Gogo::unnamed_type_descriptor_decl_name(const Type* type)\n+{\n+  return \"__go_td_\" + type->mangled_name(this);\n+}\n+\n+// Return the name to use for a type descriptor decl for a type named\n+// NAME, defined in the function IN_FUNCTION.  IN_FUNCTION will\n+// normally be NULL.\n+\n+std::string\n+Gogo::type_descriptor_decl_name(const Named_object* no,\n+\t\t\t\tconst Named_object* in_function)\n+{\n+  std::string ret = \"__go_tdn_\";\n+  if (no->type_value()->is_builtin())\n+    go_assert(in_function == NULL);\n+  else\n+    {\n+      const std::string& unique_prefix(no->package() == NULL\n+\t\t\t\t       ? this->unique_prefix()\n+\t\t\t\t       : no->package()->unique_prefix());\n+      const std::string& package_name(no->package() == NULL\n+\t\t\t\t      ? this->package_name()\n+\t\t\t\t      : no->package()->name());\n+      ret.append(unique_prefix);\n+      ret.append(1, '.');\n+      ret.append(package_name);\n+      ret.append(1, '.');\n+      if (in_function != NULL)\n+\t{\n+\t  ret.append(Gogo::unpack_hidden_name(in_function->name()));\n+\t  ret.append(1, '.');\n+\t}\n+    }\n+  ret.append(no->name());\n+  return ret;\n+}\n+\n+// Where a type descriptor decl should be defined.\n+\n+Gogo::Type_descriptor_location\n+Gogo::type_descriptor_location(const Type* type)\n+{\n+  const Named_type* name = type->named_type();\n+  if (name != NULL)\n+    {\n+      if (name->named_object()->package() != NULL)\n+\t{\n+\t  // This is a named type defined in a different package.  The\n+\t  // descriptor should be defined in that package.\n+\t  return TYPE_DESCRIPTOR_UNDEFINED;\n+\t}\n+      else if (name->is_builtin())\n+\t{\n+\t  // We create the descriptor for a builtin type whenever we\n+\t  // need it.\n+\t  return TYPE_DESCRIPTOR_COMMON;\n+\t}\n+      else\n+\t{\n+\t  // This is a named type defined in this package.  The\n+\t  // descriptor should be defined here.\n+\t  return TYPE_DESCRIPTOR_DEFINED;\n+\t}\n+    }\n+  else\n+    {\n+      if (type->points_to() != NULL\n+\t  && type->points_to()->named_type() != NULL\n+\t  && type->points_to()->named_type()->named_object()->package() != NULL)\n+\t{\n+\t  // This is an unnamed pointer to a named type defined in a\n+\t  // different package.  The descriptor should be defined in\n+\t  // that package.\n+\t  return TYPE_DESCRIPTOR_UNDEFINED;\n+\t}\n+      else\n+\t{\n+\t  // This is an unnamed type.  The descriptor could be defined\n+\t  // in any package where it is needed, and the linker will\n+\t  // pick one descriptor to keep.\n+\t  return TYPE_DESCRIPTOR_COMMON;\n+\t}\n+    }\n+}\n+\n+// Build a type descriptor decl for TYPE.  INITIALIZER is a struct\n+// composite literal which initializers the type descriptor.\n+\n+void\n+Gogo::build_type_descriptor_decl(const Type* type, Expression* initializer,\n+\t\t\t\t tree* pdecl)\n+{\n+  const Named_type* name = type->named_type();\n+\n+  // We can have multiple instances of unnamed types, but we only want\n+  // to emit the type descriptor once.  We use a hash table to handle\n+  // this.  This is not necessary for named types, as they are unique,\n+  // and we store the type descriptor decl in the type itself.\n+  tree* phash = NULL;\n+  if (name == NULL)\n+    {\n+      if (this->type_descriptor_decls_ == NULL)\n+\tthis->type_descriptor_decls_ = new Type_descriptor_decls(10);\n+\n+      std::pair<Type_descriptor_decls::iterator, bool> ins =\n+\tthis->type_descriptor_decls_->insert(std::make_pair(type, NULL_TREE));\n+      if (!ins.second)\n+\t{\n+\t  // We've already built a type descriptor for this type.\n+\t  *pdecl = ins.first->second;\n+\t  return;\n+\t}\n+      phash = &ins.first->second;\n+    }\n+\n+  std::string decl_name;\n+  if (name == NULL)\n+    decl_name = this->unnamed_type_descriptor_decl_name(type);\n+  else\n+    decl_name = this->type_descriptor_decl_name(name->named_object(),\n+\t\t\t\t\t\tname->in_function());\n+  tree id = get_identifier_from_string(decl_name);\n+  tree descriptor_type_tree = initializer->type()->get_tree(this);\n+  if (descriptor_type_tree == error_mark_node)\n+    {\n+      *pdecl = error_mark_node;\n+      return;\n+    }\n+  tree decl = build_decl(name == NULL ? BUILTINS_LOCATION : name->location(),\n+\t\t\t VAR_DECL, id,\n+\t\t\t build_qualified_type(descriptor_type_tree,\n+\t\t\t\t\t      TYPE_QUAL_CONST));\n+  TREE_READONLY(decl) = 1;\n+  TREE_CONSTANT(decl) = 1;\n+  DECL_ARTIFICIAL(decl) = 1;\n+\n+  go_preserve_from_gc(decl);\n+  if (phash != NULL)\n+    *phash = decl;\n+\n+  // We store the new DECL now because we may need to refer to it when\n+  // expanding INITIALIZER.\n+  *pdecl = decl;\n+\n+  // If appropriate, just refer to the exported type identifier.\n+  Gogo::Type_descriptor_location type_descriptor_location =\n+    this->type_descriptor_location(type);\n+  if (type_descriptor_location == TYPE_DESCRIPTOR_UNDEFINED)\n+    {\n+      TREE_PUBLIC(decl) = 1;\n+      DECL_EXTERNAL(decl) = 1;\n+      return;\n+    }\n+\n+  TREE_STATIC(decl) = 1;\n+  TREE_USED(decl) = 1;\n+\n+  Translate_context context(this, NULL, NULL, NULL);\n+  context.set_is_const();\n+  tree constructor = initializer->get_tree(&context);\n+\n+  if (constructor == error_mark_node)\n+    go_assert(saw_errors());\n+\n+  DECL_INITIAL(decl) = constructor;\n+\n+  if (type_descriptor_location == TYPE_DESCRIPTOR_DEFINED)\n+    TREE_PUBLIC(decl) = 1;\n+  else\n+    {\n+      go_assert(type_descriptor_location == TYPE_DESCRIPTOR_COMMON);\n+      make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n+      resolve_unique_section(decl, 1, 0);\n+    }\n+\n+  rest_of_decl_compilation(decl, 1, 0);\n+}\n+\n+// Build an interface method table for a type: a list of function\n+// pointers, one for each interface method.  This is used for\n+// interfaces.\n+\n+tree\n+Gogo::interface_method_table_for_type(const Interface_type* interface,\n+\t\t\t\t      Named_type* type,\n+\t\t\t\t      bool is_pointer)\n+{\n+  const Typed_identifier_list* interface_methods = interface->methods();\n+  go_assert(!interface_methods->empty());\n+\n+  std::string mangled_name = ((is_pointer ? \"__go_pimt__\" : \"__go_imt_\")\n+\t\t\t      + interface->mangled_name(this)\n+\t\t\t      + \"__\"\n+\t\t\t      + type->mangled_name(this));\n+\n+  tree id = get_identifier_from_string(mangled_name);\n+\n+  // See whether this interface has any hidden methods.\n+  bool has_hidden_methods = false;\n+  for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n+       p != interface_methods->end();\n+       ++p)\n+    {\n+      if (Gogo::is_hidden_name(p->name()))\n+\t{\n+\t  has_hidden_methods = true;\n+\t  break;\n+\t}\n+    }\n+\n+  // We already know that the named type is convertible to the\n+  // interface.  If the interface has hidden methods, and the named\n+  // type is defined in a different package, then the interface\n+  // conversion table will be defined by that other package.\n+  if (has_hidden_methods && type->named_object()->package() != NULL)\n+    {\n+      tree array_type = build_array_type(const_ptr_type_node, NULL);\n+      tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL, id, array_type);\n+      TREE_READONLY(decl) = 1;\n+      TREE_CONSTANT(decl) = 1;\n+      TREE_PUBLIC(decl) = 1;\n+      DECL_EXTERNAL(decl) = 1;\n+      go_preserve_from_gc(decl);\n+      return decl;\n+    }\n+\n+  size_t count = interface_methods->size();\n+  VEC(constructor_elt, gc)* pointers = VEC_alloc(constructor_elt, gc,\n+\t\t\t\t\t\t count + 1);\n+\n+  // The first element is the type descriptor.\n+  constructor_elt* elt = VEC_quick_push(constructor_elt, pointers, NULL);\n+  elt->index = size_zero_node;\n+  Type* td_type;\n+  if (!is_pointer)\n+    td_type = type;\n+  else\n+    td_type = Type::make_pointer_type(type);\n+  elt->value = fold_convert(const_ptr_type_node,\n+\t\t\t    td_type->type_descriptor_pointer(this));\n+\n+  size_t i = 1;\n+  for (Typed_identifier_list::const_iterator p = interface_methods->begin();\n+       p != interface_methods->end();\n+       ++p, ++i)\n+    {\n+      bool is_ambiguous;\n+      Method* m = type->method_function(p->name(), &is_ambiguous);\n+      go_assert(m != NULL);\n+\n+      Named_object* no = m->named_object();\n+\n+      tree fnid = no->get_id(this);\n+\n+      tree fndecl;\n+      if (no->is_function())\n+\tfndecl = no->func_value()->get_or_make_decl(this, no, fnid);\n+      else if (no->is_function_declaration())\n+\tfndecl = no->func_declaration_value()->get_or_make_decl(this, no,\n+\t\t\t\t\t\t\t\tfnid);\n+      else\n+\tgo_unreachable();\n+      fndecl = build_fold_addr_expr(fndecl);\n+\n+      elt = VEC_quick_push(constructor_elt, pointers, NULL);\n+      elt->index = size_int(i);\n+      elt->value = fold_convert(const_ptr_type_node, fndecl);\n+    }\n+  go_assert(i == count + 1);\n+\n+  tree array_type = build_array_type(const_ptr_type_node,\n+\t\t\t\t     build_index_type(size_int(count)));\n+  tree constructor = build_constructor(array_type, pointers);\n+\n+  tree decl = build_decl(BUILTINS_LOCATION, VAR_DECL, id, array_type);\n+  TREE_STATIC(decl) = 1;\n+  TREE_USED(decl) = 1;\n+  TREE_READONLY(decl) = 1;\n+  TREE_CONSTANT(decl) = 1;\n+  DECL_INITIAL(decl) = constructor;\n+\n+  // If the interface type has hidden methods, then this is the only\n+  // definition of the table.  Otherwise it is a comdat table which\n+  // may be defined in multiple packages.\n+  if (has_hidden_methods)\n+    TREE_PUBLIC(decl) = 1;\n+  else\n+    {\n+      make_decl_one_only(decl, DECL_ASSEMBLER_NAME(decl));\n+      resolve_unique_section(decl, 1, 0);\n+    }\n+\n+  rest_of_decl_compilation(decl, 1, 0);\n+\n+  go_preserve_from_gc(decl);\n+\n+  return decl;\n+}\n+\n+// Mark a function as a builtin library function.\n+\n+void\n+Gogo::mark_fndecl_as_builtin_library(tree fndecl)\n+{\n+  DECL_EXTERNAL(fndecl) = 1;\n+  TREE_PUBLIC(fndecl) = 1;\n+  DECL_ARTIFICIAL(fndecl) = 1;\n+  TREE_NOTHROW(fndecl) = 1;\n+  DECL_VISIBILITY(fndecl) = VISIBILITY_DEFAULT;\n+  DECL_VISIBILITY_SPECIFIED(fndecl) = 1;\n+}\n+\n+// Build a call to a builtin function.\n+\n+tree\n+Gogo::call_builtin(tree* pdecl, source_location location, const char* name,\n+\t\t   int nargs, tree rettype, ...)\n+{\n+  if (rettype == error_mark_node)\n+    return error_mark_node;\n+\n+  tree* types = new tree[nargs];\n+  tree* args = new tree[nargs];\n+\n+  va_list ap;\n+  va_start(ap, rettype);\n+  for (int i = 0; i < nargs; ++i)\n+    {\n+      types[i] = va_arg(ap, tree);\n+      args[i] = va_arg(ap, tree);\n+      if (types[i] == error_mark_node || args[i] == error_mark_node)\n+\t{\n+\t  delete[] types;\n+\t  delete[] args;\n+\t  return error_mark_node;\n+\t}\n+    }\n+  va_end(ap);\n+\n+  if (*pdecl == NULL_TREE)\n+    {\n+      tree fnid = get_identifier(name);\n+\n+      tree argtypes = NULL_TREE;\n+      tree* pp = &argtypes;\n+      for (int i = 0; i < nargs; ++i)\n+\t{\n+\t  *pp = tree_cons(NULL_TREE, types[i], NULL_TREE);\n+\t  pp = &TREE_CHAIN(*pp);\n+\t}\n+      *pp = void_list_node;\n+\n+      tree fntype = build_function_type(rettype, argtypes);\n+\n+      *pdecl = build_decl(BUILTINS_LOCATION, FUNCTION_DECL, fnid, fntype);\n+      Gogo::mark_fndecl_as_builtin_library(*pdecl);\n+      go_preserve_from_gc(*pdecl);\n+    }\n+\n+  tree fnptr = build_fold_addr_expr(*pdecl);\n+  if (CAN_HAVE_LOCATION_P(fnptr))\n+    SET_EXPR_LOCATION(fnptr, location);\n+\n+  tree ret = build_call_array(rettype, fnptr, nargs, args);\n+  SET_EXPR_LOCATION(ret, location);\n+\n+  delete[] types;\n+  delete[] args;\n+\n+  return ret;\n+}\n+\n+// Build a call to the runtime error function.\n+\n+tree\n+Gogo::runtime_error(int code, source_location location)\n+{\n+  static tree runtime_error_fndecl;\n+  tree ret = Gogo::call_builtin(&runtime_error_fndecl,\n+\t\t\t\tlocation,\n+\t\t\t\t\"__go_runtime_error\",\n+\t\t\t\t1,\n+\t\t\t\tvoid_type_node,\n+\t\t\t\tinteger_type_node,\n+\t\t\t\tbuild_int_cst(integer_type_node, code));\n+  if (ret == error_mark_node)\n+    return error_mark_node;\n+  // The runtime error function panics and does not return.\n+  TREE_NOTHROW(runtime_error_fndecl) = 0;\n+  TREE_THIS_VOLATILE(runtime_error_fndecl) = 1;\n+  return ret;\n+}\n+\n+// Return a tree for receiving a value of type TYPE_TREE on CHANNEL.\n+// This does a blocking receive and returns the value read from the\n+// channel.  If FOR_SELECT is true, this is being done because it was\n+// chosen in a select statement.\n+\n+tree\n+Gogo::receive_from_channel(tree type_tree, tree channel, bool for_select,\n+\t\t\t   source_location location)\n+{\n+  if (type_tree == error_mark_node || channel == error_mark_node)\n+    return error_mark_node;\n+\n+  if (int_size_in_bytes(type_tree) <= 8\n+      && !AGGREGATE_TYPE_P(type_tree)\n+      && !FLOAT_TYPE_P(type_tree))\n+    {\n+      static tree receive_small_fndecl;\n+      tree call = Gogo::call_builtin(&receive_small_fndecl,\n+\t\t\t\t     location,\n+\t\t\t\t     \"__go_receive_small\",\n+\t\t\t\t     2,\n+\t\t\t\t     uint64_type_node,\n+\t\t\t\t     ptr_type_node,\n+\t\t\t\t     channel,\n+\t\t\t\t     boolean_type_node,\n+\t\t\t\t     (for_select\n+\t\t\t\t      ? boolean_true_node\n+\t\t\t\t      : boolean_false_node));\n+      if (call == error_mark_node)\n+\treturn error_mark_node;\n+      // This can panic if there are too many operations on a closed\n+      // channel.\n+      TREE_NOTHROW(receive_small_fndecl) = 0;\n+      int bitsize = GET_MODE_BITSIZE(TYPE_MODE(type_tree));\n+      tree int_type_tree = go_type_for_size(bitsize, 1);\n+      return fold_convert_loc(location, type_tree,\n+\t\t\t      fold_convert_loc(location, int_type_tree,\n+\t\t\t\t\t       call));\n+    }\n+  else\n+    {\n+      tree tmp = create_tmp_var(type_tree, get_name(type_tree));\n+      DECL_IGNORED_P(tmp) = 0;\n+      TREE_ADDRESSABLE(tmp) = 1;\n+      tree make_tmp = build1(DECL_EXPR, void_type_node, tmp);\n+      SET_EXPR_LOCATION(make_tmp, location);\n+      tree tmpaddr = build_fold_addr_expr(tmp);\n+      tmpaddr = fold_convert(ptr_type_node, tmpaddr);\n+      static tree receive_big_fndecl;\n+      tree call = Gogo::call_builtin(&receive_big_fndecl,\n+\t\t\t\t     location,\n+\t\t\t\t     \"__go_receive_big\",\n+\t\t\t\t     3,\n+\t\t\t\t     boolean_type_node,\n+\t\t\t\t     ptr_type_node,\n+\t\t\t\t     channel,\n+\t\t\t\t     ptr_type_node,\n+\t\t\t\t     tmpaddr,\n+\t\t\t\t     boolean_type_node,\n+\t\t\t\t     (for_select\n+\t\t\t\t      ? boolean_true_node\n+\t\t\t\t      : boolean_false_node));\n+      if (call == error_mark_node)\n+\treturn error_mark_node;\n+      // This can panic if there are too many operations on a closed\n+      // channel.\n+      TREE_NOTHROW(receive_big_fndecl) = 0;\n+      return build2(COMPOUND_EXPR, type_tree, make_tmp,\n+\t\t    build2(COMPOUND_EXPR, type_tree, call, tmp));\n+    }\n+}\n+\n+// Return the type of a function trampoline.  This is like\n+// get_trampoline_type in tree-nested.c.\n+\n+tree\n+Gogo::trampoline_type_tree()\n+{\n+  static tree type_tree;\n+  if (type_tree == NULL_TREE)\n+    {\n+      unsigned int size;\n+      unsigned int align;\n+      go_trampoline_info(&size, &align);\n+      tree t = build_index_type(build_int_cst(integer_type_node, size - 1));\n+      t = build_array_type(char_type_node, t);\n+\n+      type_tree = Gogo::builtin_struct(NULL, \"__go_trampoline\", NULL_TREE, 1,\n+\t\t\t\t       \"__data\", t);\n+      t = TYPE_FIELDS(type_tree);\n+      DECL_ALIGN(t) = align;\n+      DECL_USER_ALIGN(t) = 1;\n+\n+      go_preserve_from_gc(type_tree);\n+    }\n+  return type_tree;\n+}\n+\n+// Make a trampoline which calls FNADDR passing CLOSURE.\n+\n+tree\n+Gogo::make_trampoline(tree fnaddr, tree closure, source_location location)\n+{\n+  tree trampoline_type = Gogo::trampoline_type_tree();\n+  tree trampoline_size = TYPE_SIZE_UNIT(trampoline_type);\n+\n+  closure = save_expr(closure);\n+\n+  // We allocate the trampoline using a special function which will\n+  // mark it as executable.\n+  static tree trampoline_fndecl;\n+  tree x = Gogo::call_builtin(&trampoline_fndecl,\n+\t\t\t      location,\n+\t\t\t      \"__go_allocate_trampoline\",\n+\t\t\t      2,\n+\t\t\t      ptr_type_node,\n+\t\t\t      size_type_node,\n+\t\t\t      trampoline_size,\n+\t\t\t      ptr_type_node,\n+\t\t\t      fold_convert_loc(location, ptr_type_node,\n+\t\t\t\t\t       closure));\n+  if (x == error_mark_node)\n+    return error_mark_node;\n+\n+  x = save_expr(x);\n+\n+  // Initialize the trampoline.\n+  tree ini = build_call_expr(implicit_built_in_decls[BUILT_IN_INIT_TRAMPOLINE],\n+\t\t\t     3, x, fnaddr, closure);\n+\n+  // On some targets the trampoline address needs to be adjusted.  For\n+  // example, when compiling in Thumb mode on the ARM, the address\n+  // needs to have the low bit set.\n+  x = build_call_expr(implicit_built_in_decls[BUILT_IN_ADJUST_TRAMPOLINE],\n+\t\t      1, x);\n+  x = fold_convert(TREE_TYPE(fnaddr), x);\n+\n+  return build2(COMPOUND_EXPR, TREE_TYPE(x), ini, x);\n+}"}, {"sha": "238a0d72487c36919a3d39ca2debda90c318e026", "filename": "gcc/go/gofrontend/gogo-tree.cc.working", "status": "added", "additions": 3145, "deletions": 0, "changes": 3145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo-tree.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "0216d6c6b098bd68794c5d0b2e9c698cbf7d877b", "filename": "gcc/go/gofrontend/gogo.cc.merge-left.r167407", "status": "added", "additions": 4274, "deletions": 0, "changes": 4274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "d9f604a5f229a89f787d158cf8680e0e1a3b4040", "filename": "gcc/go/gofrontend/gogo.cc.merge-right.r172891", "status": "added", "additions": 4796, "deletions": 0, "changes": 4796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "a6411d362c484a1a21c2f54479be72eb6f8aa7ba", "filename": "gcc/go/gofrontend/gogo.cc.working", "status": "added", "additions": 4514, "deletions": 0, "changes": 4514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "d0cfa1e90e08f23d11452bb2c938504e8f69eaa5", "filename": "gcc/go/gofrontend/gogo.h.merge-left.r167407", "status": "added", "additions": 2484, "deletions": 0, "changes": 2484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.h.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.h.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,2484 @@\n+// gogo.h -- Go frontend parsed representation.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_GOGO_H\n+#define GO_GOGO_H\n+\n+class Traverse;\n+class Type;\n+class Type_hash_identical;\n+class Type_equal;\n+class Type_identical;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Expression;\n+class Statement;\n+class Block;\n+class Function;\n+class Bindings;\n+class Package;\n+class Variable;\n+class Pointer_type;\n+class Struct_type;\n+class Struct_field;\n+class Struct_field_list;\n+class Array_type;\n+class Map_type;\n+class Channel_type;\n+class Interface_type;\n+class Named_type;\n+class Forward_declaration_type;\n+class Method;\n+class Methods;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Export;\n+class Import;\n+\n+// This file declares the basic classes used to hold the internal\n+// representation of Go which is built by the parser.\n+\n+// An initialization function for an imported package.  This is a\n+// magic function which initializes variables and runs the \"init\"\n+// function.\n+\n+class Import_init\n+{\n+ public:\n+  Import_init(const std::string& package_name, const std::string& init_name,\n+\t      int priority)\n+    : package_name_(package_name), init_name_(init_name), priority_(priority)\n+  { }\n+\n+  // The name of the package being imported.\n+  const std::string&\n+  package_name() const\n+  { return this->package_name_; }\n+\n+  // The name of the package's init function.\n+  const std::string&\n+  init_name() const\n+  { return this->init_name_; }\n+\n+  // The priority of the initialization function.  Functions with a\n+  // lower priority number must be run first.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+ private:\n+  // The name of the package being imported.\n+  std::string package_name_;\n+  // The name of the package's init function.\n+  std::string init_name_;\n+  // The priority.\n+  int priority_;\n+};\n+\n+// For sorting purposes.\n+\n+inline bool\n+operator<(const Import_init& i1, const Import_init& i2)\n+{\n+  if (i1.priority() < i2.priority())\n+    return true;\n+  if (i1.priority() > i2.priority())\n+    return false;\n+  if (i1.package_name() != i2.package_name())\n+    return i1.package_name() < i2.package_name();\n+  return i1.init_name() < i2.init_name();\n+}\n+\n+// The holder for the internal representation of the entire\n+// compilation unit.\n+\n+class Gogo\n+{\n+ public:\n+  // Create the IR, passing in the sizes of the types \"int\", \"float\",\n+  // and \"uintptr\" in bits.\n+  Gogo(int int_type_size, int float_type_size, int pointer_size);\n+\n+  // Get the package name.\n+  const std::string&\n+  package_name() const;\n+\n+  // Set the package name.\n+  void\n+  set_package_name(const std::string&, source_location);\n+\n+  // If necessary, adjust the name to use for a hidden symbol.  We add\n+  // a prefix of the package name, so that hidden symbols in different\n+  // packages do not collide.\n+  std::string\n+  pack_hidden_name(const std::string& name, bool is_exported) const\n+  {\n+    return (is_exported\n+\t    ? name\n+\t    : ('.' + this->unique_prefix()\n+\t       + '.' + this->package_name()\n+\t       + '.' + name));\n+  }\n+\n+  // Unpack a name which may have been hidden.  Returns the\n+  // user-visible name of the object.\n+  static std::string\n+  unpack_hidden_name(const std::string& name)\n+  { return name[0] != '.' ? name : name.substr(name.rfind('.') + 1); }\n+\n+  // Return whether a possibly packed name is hidden.\n+  static bool\n+  is_hidden_name(const std::string& name)\n+  { return name[0] == '.'; }\n+\n+  // Return the package prefix of a hidden name.\n+  static std::string\n+  hidden_name_prefix(const std::string& name)\n+  {\n+    gcc_assert(Gogo::is_hidden_name(name));\n+    return name.substr(1, name.rfind('.') - 1);\n+  }\n+\n+  // Given a name which may or may not have been hidden, return the\n+  // name to use in an error message.\n+  static std::string\n+  message_name(const std::string& name);\n+\n+  // Return whether a name is the blank identifier _.\n+  static bool\n+  is_sink_name(const std::string& name)\n+  {\n+    return (name[0] == '.'\n+\t    && name[name.length() - 1] == '_'\n+\t    && name[name.length() - 2] == '.');\n+  }\n+\n+  // Return the unique prefix to use for all exported symbols.\n+  const std::string&\n+  unique_prefix() const;\n+\n+  // Set the unique prefix.\n+  void\n+  set_unique_prefix(const std::string&);\n+\n+  // Return the priority to use for the package we are compiling.\n+  // This is two more than the largest priority of any package we\n+  // import.\n+  int\n+  package_priority() const;\n+\n+  // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n+  // is the local name to give to the package.  If LOCAL_NAME is empty\n+  // the declarations are added to the global scope.\n+  void\n+  import_package(const std::string& filename, const std::string& local_name,\n+\t\t bool is_local_name_exported, source_location);\n+\n+  // Whether we are the global binding level.\n+  bool\n+  in_global_scope() const;\n+\n+  // Look up a name in the current binding contours.\n+  Named_object*\n+  lookup(const std::string&, Named_object** pfunction) const;\n+\n+  // Look up a name in the current block.\n+  Named_object*\n+  lookup_in_block(const std::string&) const;\n+\n+  // Look up a name in the global namespace--the universal scope.\n+  Named_object*\n+  lookup_global(const char*) const;\n+\n+  // Add a new imported package.  REAL_NAME is the real name of the\n+  // package.  ALIAS is the alias of the package; this may be the same\n+  // as REAL_NAME.  This sets *PADD_TO_GLOBALS if symbols added to\n+  // this package should be added to the global namespace; this is\n+  // true if the alias is \".\".  LOCATION is the location of the import\n+  // statement.  This returns the new package, or NULL on error.\n+  Package*\n+  add_imported_package(const std::string& real_name, const std::string& alias,\n+\t\t       bool is_alias_exported,\n+\t\t       const std::string& unique_prefix,\n+\t\t       source_location location,\n+\t\t       bool* padd_to_globals);\n+\n+  // Register a package.  This package may or may not be imported.\n+  // This returns the Package structure for the package, creating if\n+  // it necessary.\n+  Package*\n+  register_package(const std::string& name, const std::string& unique_prefix,\n+\t\t   source_location);\n+\n+  // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n+  // method function should be added to the type of its receiver.\n+  Named_object*\n+  start_function(const std::string& name, Function_type* type,\n+\t\t bool add_method_to_type, source_location);\n+\n+  // Finish compiling a function.\n+  void\n+  finish_function(source_location);\n+\n+  // Return the current function.\n+  Named_object*\n+  current_function() const;\n+\n+  // Start a new block.  This is not initially associated with a\n+  // function.\n+  void\n+  start_block(source_location);\n+\n+  // Finish the current block and return it.\n+  Block*\n+  finish_block(source_location);\n+\n+  // Declare an unknown name.  This is used while parsing.  The name\n+  // must be resolved by the end of the parse.  Unknown names are\n+  // always added at the package level.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location);\n+\n+  // Declare a function.\n+  Named_object*\n+  declare_function(const std::string&, Function_type*, source_location);\n+\n+  // Add a label.\n+  Label*\n+  add_label_definition(const std::string&, source_location);\n+\n+  // Add a label reference.\n+  Label*\n+  add_label_reference(const std::string&);\n+\n+  // Add a statement to the current block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a block to the current block.\n+  void\n+  add_block(Block*, source_location);\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier&, Expression*, int iota_value);\n+\n+  // Add a type.\n+  void\n+  add_type(const std::string&, Type*, source_location);\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  void\n+  add_named_type(Named_type*);\n+\n+  // Declare a type.\n+  Named_object*\n+  declare_type(const std::string&, source_location);\n+\n+  // Declare a type at the package level.  This is used when the\n+  // parser sees an unknown name where a type name is required.\n+  Named_object*\n+  declare_package_type(const std::string&, source_location);\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string&, Variable*);\n+\n+  // Add a sink--a reference to the blank identifier _.\n+  Named_object*\n+  add_sink();\n+\n+  // Add a named object to the current namespace.  This is used for\n+  // import . \"package\".\n+  void\n+  add_named_object(Named_object*);\n+\n+  // Return a name to use for a thunk function.  A thunk function is\n+  // one we create during the compilation, for a go statement or a\n+  // defer statement or a method expression.\n+  static std::string\n+  thunk_name();\n+\n+  // Return whether an object is a thunk.\n+  static bool\n+  is_thunk(const Named_object*);\n+\n+  // Note that we've seen an interface type.  This is used to build\n+  // all required interface method tables.\n+  void\n+  record_interface_type(Interface_type*);\n+\n+  // Clear out all names in file scope.  This is called when we start\n+  // parsing a new file.\n+  void\n+  clear_file_scope();\n+\n+  // Traverse the tree.  See the Traverse class.\n+  void\n+  traverse(Traverse*);\n+\n+  // Define the predeclared global names.\n+  void\n+  define_global_names();\n+\n+  // Verify and complete all types.\n+  void\n+  verify_types();\n+\n+  // Lower the parse tree.\n+  void\n+  lower_parse_tree();\n+\n+  // Lower an expression.\n+  void\n+  lower_expression(Named_object* function, Expression**);\n+\n+  // Lower a constant.\n+  void\n+  lower_constant(Named_object*);\n+\n+  // Finalize the method lists and build stub methods for named types.\n+  void\n+  finalize_methods();\n+\n+  // Work out the types to use for unspecified variables and\n+  // constants.\n+  void\n+  determine_types();\n+\n+  // Type check the program.\n+  void\n+  check_types();\n+\n+  // Check the types in a single block.  This is used for complicated\n+  // go statements.\n+  void\n+  check_types_in_block(Block*);\n+\n+  // Check for return statements.\n+  void\n+  check_return_statements();\n+\n+  // Do all exports.\n+  void\n+  do_exports();\n+\n+  // Add an import control function for an imported package to the\n+  // list.\n+  void\n+  add_import_init_fn(const std::string& package_name,\n+\t\t     const std::string& init_name, int prio);\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  void\n+  remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  void\n+  order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  void\n+  build_recover_thunks();\n+\n+  // Simplify statements which might use thunks: go and defer\n+  // statements.\n+  void\n+  simplify_thunk_statements();\n+\n+  // Write out the global values.\n+  void\n+  write_globals();\n+\n+  // Build a call to a builtin function.  PDECL should point to a NULL\n+  // initialized static pointer which will hold the fndecl.  NAME is\n+  // the name of the function.  NARGS is the number of arguments.\n+  // RETTYPE is the return type.  It is followed by NARGS pairs of\n+  // type and argument (both trees).\n+  static tree\n+  call_builtin(tree* pdecl, source_location, const char* name, int nargs,\n+\t       tree rettype, ...);\n+\n+  // Build a call to the runtime error function.\n+  static tree\n+  runtime_error(int code, source_location);\n+\n+  // Build a builtin struct with a list of fields.\n+  static tree\n+  builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n+\t\t int nfields, ...);\n+\n+  // Mark a function declaration as a builtin library function.\n+  static void\n+  mark_fndecl_as_builtin_library(tree fndecl);\n+\n+  // Build the type of the struct that holds a slice for the given\n+  // element type.\n+  tree\n+  slice_type_tree(tree element_type_tree);\n+\n+  // Given a tree for a slice type, return the tree for the element\n+  // type.\n+  static tree\n+  slice_element_type_tree(tree slice_type_tree);\n+\n+  // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n+  // the slice.  VALUES points to the values.  COUNT is the size,\n+  // CAPACITY is the capacity.  If CAPACITY is NULL, it is set to\n+  // COUNT.\n+  static tree\n+  slice_constructor(tree slice_type_tree, tree values, tree count,\n+\t\t    tree capacity);\n+\n+  // Build a constructor for an empty slice.  SLICE_TYPE_TREE is the\n+  // type of the slice.\n+  static tree\n+  empty_slice_constructor(tree slice_type_tree);\n+\n+  // Build a map descriptor.\n+  tree\n+  map_descriptor(Map_type*);\n+\n+  // Return a tree for the type of a map descriptor.  This is struct\n+  // __go_map_descriptor in libgo/runtime/map.h.  This is the same for\n+  // all map types.\n+  tree\n+  map_descriptor_type();\n+\n+  // Build a type descriptor for TYPE using INITIALIZER as the type\n+  // descriptor.  This builds a new decl stored in *PDECL.\n+  void\n+  build_type_descriptor_decl(const Type*, Expression* initializer,\n+\t\t\t     tree* pdecl);\n+\n+  // Build required interface method tables.\n+  void\n+  build_interface_method_tables();\n+\n+  // Build an interface method table for a type: a list of function\n+  // pointers, one for each interface method.  This returns a decl.\n+  tree\n+  interface_method_table_for_type(const Interface_type*, Named_type*,\n+\t\t\t\t  bool is_pointer);\n+\n+  // Return a tree which allocate SIZE bytes to hold values of type\n+  // TYPE.\n+  tree\n+  allocate_memory(Type *type, tree size, source_location);\n+\n+  // Return a type to use for pointer to const char.\n+  static tree\n+  const_char_pointer_type_tree();\n+\n+  // Build a string constant with the right type.\n+  static tree\n+  string_constant_tree(const std::string&);\n+\n+  // Build a Go string constant.  This returns a pointer to the\n+  // constant.\n+  tree\n+  go_string_constant_tree(const std::string&);\n+\n+  // Send a value on a channel.\n+  static tree\n+  send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n+\t\t  source_location);\n+\n+  // Receive a value from a channel.\n+  static tree\n+  receive_from_channel(tree type_tree, tree channel, bool for_select,\n+\t\t       source_location);\n+\n+  // Return a tree for receiving an integer on a channel.\n+  static tree\n+  receive_as_64bit_integer(tree type, tree channel, bool blocking,\n+\t\t\t   bool for_select);\n+\n+\n+  // Make a trampoline which calls FNADDR passing CLOSURE.\n+  tree\n+  make_trampoline(tree fnaddr, tree closure, source_location);\n+\n+ private:\n+  // During parsing, we keep a stack of functions.  Each function on\n+  // the stack is one that we are currently parsing.  For each\n+  // function, we keep track of the current stack of blocks.\n+  struct Open_function\n+  {\n+    // The function.\n+    Named_object* function;\n+    // The stack of active blocks in the function.\n+    std::vector<Block*> blocks;\n+  };\n+\n+  // The stack of functions.\n+  typedef std::vector<Open_function> Open_functions;\n+\n+  // Create trees for implicit builtin functions.\n+  void\n+  define_builtin_function_trees();\n+\n+  // Set up the built-in unsafe package.\n+  void\n+  import_unsafe(const std::string&, bool is_exported, source_location);\n+\n+  // Add a new imported package.\n+  Named_object*\n+  add_package(const std::string& real_name, const std::string& alias,\n+\t      const std::string& unique_prefix, source_location location);\n+\n+  // Return the current binding contour.\n+  Bindings*\n+  current_bindings();\n+\n+  const Bindings*\n+  current_bindings() const;\n+\n+  // Return the current block.\n+  Block*\n+  current_block();\n+\n+  // Get the name of the magic initialization function.\n+  const std::string&\n+  get_init_fn_name();\n+\n+  // Get the decl for the magic initialization function.\n+  tree\n+  initialization_function_decl();\n+\n+  // Write the magic initialization function.\n+  void\n+  write_initialization_function(tree fndecl, tree init_stmt_list);\n+\n+  // Initialize imported packages.\n+  void\n+  init_imports(tree*);\n+\n+  // Register variables with the garbage collector.\n+  void\n+  register_gc_vars(const std::vector<Named_object*>&, tree*);\n+\n+  // Build a pointer to a Go string constant.  This returns a pointer\n+  // to the pointer.\n+  tree\n+  ptr_go_string_constant_tree(const std::string&);\n+\n+  // Return the name to use for a type descriptor decl for an unnamed\n+  // type.\n+  std::string\n+  unnamed_type_descriptor_decl_name(const Type* type);\n+\n+  // Return the name to use for a type descriptor decl for a type\n+  // named NO, defined in IN_FUNCTION.\n+  std::string\n+  type_descriptor_decl_name(const Named_object* no,\n+\t\t\t    const Named_object* in_function);\n+\n+  // Where a type descriptor should be defined.\n+  enum Type_descriptor_location\n+    {\n+      // Defined in this file.\n+      TYPE_DESCRIPTOR_DEFINED,\n+      // Defined in some other file.\n+      TYPE_DESCRIPTOR_UNDEFINED,\n+      // Common definition which may occur in multiple files.\n+      TYPE_DESCRIPTOR_COMMON\n+    };\n+\n+  // Return where the decl for TYPE should be defined.\n+  Type_descriptor_location\n+  type_descriptor_location(const Type* type);\n+\n+  // Return the type of a trampoline.\n+  static tree\n+  trampoline_type_tree();\n+\n+  // Type used to map import names to packages.\n+  typedef std::map<std::string, Package*> Imports;\n+\n+  // Type used to map package names to packages.\n+  typedef std::map<std::string, Package*> Packages;\n+\n+  // Type used to map special names in the sys package.\n+  typedef std::map<std::string, std::string> Sys_names;\n+\n+  // Hash table mapping map types to map descriptor decls.\n+  typedef Unordered_map_hash(const Map_type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Map_descriptors;\n+\n+  // Map unnamed types to type descriptor decls.\n+  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Type_descriptor_decls;\n+\n+  // The package we are compiling.\n+  Package* package_;\n+  // The list of currently open functions during parsing.\n+  Open_functions functions_;\n+  // The global binding contour.  This includes the builtin functions\n+  // and the package we are compiling.\n+  Bindings* globals_;\n+  // Mapping from import file names to packages.\n+  Imports imports_;\n+  // Whether the magic unsafe package was imported.\n+  bool imported_unsafe_;\n+  // Mapping from package names we have seen to packages.  This does\n+  // not include the package we are compiling.\n+  Packages packages_;\n+  // Mapping from map types to map descriptors.\n+  Map_descriptors* map_descriptors_;\n+  // Mapping from unnamed types to type descriptor decls.\n+  Type_descriptor_decls* type_descriptor_decls_;\n+  // The functions named \"init\", if there are any.\n+  std::vector<Named_object*> init_functions_;\n+  // Whether we need a magic initialization function.\n+  bool need_init_fn_;\n+  // The name of the magic initialization function.\n+  std::string init_fn_name_;\n+  // A list of import control variables for packages that we import.\n+  std::set<Import_init> imported_init_fns_;\n+  // The unique prefix used for all global symbols.\n+  std::string unique_prefix_;\n+  // A list of interface types defined while parsing.\n+  std::vector<Interface_type*> interface_types_;\n+};\n+\n+// A block of statements.\n+\n+class Block\n+{\n+ public:\n+  Block(Block* enclosing, source_location);\n+\n+  // Return the enclosing block.\n+  const Block*\n+  enclosing() const\n+  { return this->enclosing_; }\n+\n+  // Return the bindings of the block.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  const Bindings*\n+  bindings() const\n+  { return this->bindings_; }\n+\n+  // Look at the block's statements.\n+  const std::vector<Statement*>*\n+  statements() const\n+  { return &this->statements_; }\n+\n+  // Return the start location.  This is normally the location of the\n+  // left curly brace which starts the block.\n+  source_location\n+  start_location() const\n+  { return this->start_location_; }\n+\n+  // Return the end location.  This is normally the location of the\n+  // right curly brace which ends the block.\n+  source_location\n+  end_location() const\n+  { return this->end_location_; }\n+\n+  // Add a statement to the block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a statement to the front of the block.\n+  void\n+  add_statement_at_front(Statement*);\n+\n+  // Replace a statement in a block.\n+  void\n+  replace_statement(size_t index, Statement*);\n+\n+  // Add a Statement before statement number INDEX.\n+  void\n+  insert_statement_before(size_t index, Statement*);\n+\n+  // Add a Statement after statement number INDEX.\n+  void\n+  insert_statement_after(size_t index, Statement*);\n+\n+  // Set the end location of the block.\n+  void\n+  set_end_location(source_location location)\n+  { this->end_location_ = location; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Set final types for unspecified variables and constants.\n+  void\n+  determine_types();\n+\n+  // Return true if execution of this block may fall through to the\n+  // next block.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return a tree of the code in this block.\n+  tree\n+  get_tree(Translate_context*);\n+\n+  // Iterate over statements.\n+\n+  typedef std::vector<Statement*>::iterator iterator;\n+\n+  iterator\n+  begin()\n+  { return this->statements_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->statements_.end(); }\n+\n+ private:\n+  // Enclosing block.\n+  Block* enclosing_;\n+  // Statements in the block.\n+  std::vector<Statement*> statements_;\n+  // Binding contour.\n+  Bindings* bindings_;\n+  // Location of start of block.\n+  source_location start_location_;\n+  // Location of end of block.\n+  source_location end_location_;\n+};\n+\n+// A function.\n+\n+class Function\n+{\n+ public:\n+  Function(Function_type* type, Function*, Block*, source_location);\n+\n+  // Return the function's type.\n+  Function_type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Return the enclosing function if there is one.\n+  Function*\n+  enclosing()\n+  { return this->enclosing_; }\n+\n+  // Set the enclosing function.  This is used when building thunks\n+  // for functions which call recover.\n+  void\n+  set_enclosing(Function* enclosing)\n+  {\n+    gcc_assert(this->enclosing_ == NULL);\n+    this->enclosing_ = enclosing;\n+  }\n+\n+  // Create the named result variables in the outer block.\n+  void\n+  create_named_result_variables();\n+\n+  // Add a new field to the closure variable.\n+  void\n+  add_closure_field(Named_object* var, source_location loc)\n+  { this->closure_fields_.push_back(std::make_pair(var, loc)); }\n+\n+  // Whether this function needs a closure.\n+  bool\n+  needs_closure() const\n+  { return !this->closure_fields_.empty(); }\n+\n+  // Return the closure variable, creating it if necessary.  This is\n+  // passed to the function as a static chain parameter.\n+  Named_object*\n+  closure_var();\n+\n+  // Set the closure variable.  This is used when building thunks for\n+  // functions which call recover.\n+  void\n+  set_closure_var(Named_object* v)\n+  {\n+    gcc_assert(this->closure_var_ == NULL);\n+    this->closure_var_ = v;\n+  }\n+\n+  // Return the variable for a reference to field INDEX in the closure\n+  // variable.\n+  Named_object*\n+  enclosing_var(unsigned int index)\n+  {\n+    gcc_assert(index < this->closure_fields_.size());\n+    return closure_fields_[index].first;\n+  }\n+\n+  // Set the type of the closure variable if there is one.\n+  void\n+  set_closure_type();\n+\n+  // Get the block of statements associated with the function.\n+  Block*\n+  block() const\n+  { return this->block_; }\n+\n+  // Get the location of the start of the function.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this function is actually a method.\n+  bool\n+  is_method() const;\n+\n+  // Add a label definition to the function.\n+  Label*\n+  add_label_definition(const std::string& label_name, source_location);\n+\n+  // Add a label reference to a function.\n+  Label*\n+  add_label_reference(const std::string& label_name);\n+\n+  // Whether this function calls the predeclared recover function.\n+  bool\n+  calls_recover() const\n+  { return this->calls_recover_; }\n+\n+  // Record that this function calls the predeclared recover function.\n+  // This is set during the lowering pass.\n+  void\n+  set_calls_recover()\n+  { this->calls_recover_ = true; }\n+\n+  // Whether this is a recover thunk function.\n+  bool\n+  is_recover_thunk() const\n+  { return this->is_recover_thunk_; }\n+\n+  // Record that this is a thunk built for a function which calls\n+  // recover.\n+  void\n+  set_is_recover_thunk()\n+  { this->is_recover_thunk_ = true; }\n+\n+  // Whether this function already has a recover thunk.\n+  bool\n+  has_recover_thunk() const\n+  { return this->has_recover_thunk_; }\n+\n+  // Record that this function already has a recover thunk.\n+  void\n+  set_has_recover_thunk()\n+  { this->has_recover_thunk_ = true; }\n+\n+  // Swap with another function.  Used only for the thunk which calls\n+  // recover.\n+  void\n+  swap_for_recover(Function *);\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Determine types in the function.\n+  void\n+  determine_types();\n+\n+  // Return the function's decl given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Return the function's decl after it has been built.\n+  tree\n+  get_decl() const\n+  {\n+    gcc_assert(this->fndecl_ != NULL);\n+    return this->fndecl_;\n+  }\n+\n+  // Set the function decl to hold a tree of the function code.\n+  void\n+  build_tree(Gogo*, Named_object*);\n+\n+  // Get the value to return when not explicitly specified.  May also\n+  // add statements to execute first to STMT_LIST.\n+  tree\n+  return_value(Gogo*, Named_object*, source_location, tree* stmt_list) const;\n+\n+  // Get a tree for the variable holding the defer stack.\n+  tree\n+  defer_stack(source_location);\n+\n+  // Export the function.\n+  void\n+  export_func(Export*, const std::string& name) const;\n+\n+  // Export a function with a type.\n+  static void\n+  export_func_with_type(Export*, const std::string& name,\n+\t\t\tconst Function_type*);\n+\n+  // Import a function.\n+  static void\n+  import_func(Import*, std::string* pname, Typed_identifier** receiver,\n+\t      Typed_identifier_list** pparameters,\n+\t      Typed_identifier_list** presults, bool* is_varargs);\n+\n+ private:\n+  // Type for mapping from label names to Label objects.\n+  typedef Unordered_map(std::string, Label*) Labels;\n+\n+  tree\n+  make_receiver_parm_decl(Gogo*, Named_object*, tree);\n+\n+  tree\n+  copy_parm_to_heap(Gogo*, Named_object*, tree);\n+\n+  void\n+  build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n+\n+  typedef std::vector<Named_object*> Named_results;\n+\n+  typedef std::vector<std::pair<Named_object*,\n+\t\t\t\tsource_location> > Closure_fields;\n+\n+  // The function's type.\n+  Function_type* type_;\n+  // The enclosing function.  This is NULL when there isn't one, which\n+  // is the normal case.\n+  Function* enclosing_;\n+  // The named result variables, if any.\n+  Named_results* named_results_;\n+  // If there is a closure, this is the list of variables which appear\n+  // in the closure.  This is created by the parser, and then resolved\n+  // to a real type when we lower parse trees.\n+  Closure_fields closure_fields_;\n+  // The closure variable, passed as a parameter using the static\n+  // chain parameter.  Normally NULL.\n+  Named_object* closure_var_;\n+  // The outer block of statements in the function.\n+  Block* block_;\n+  // The source location of the start of the function.\n+  source_location location_;\n+  // Labels defined or referenced in the function.\n+  Labels labels_;\n+  // The function decl.\n+  tree fndecl_;\n+  // A variable holding the defer stack variable.  This is NULL unless\n+  // we actually need a defer stack.\n+  tree defer_stack_;\n+  // True if this function calls the predeclared recover function.\n+  bool calls_recover_;\n+  // True if this a thunk built for a function which calls recover.\n+  bool is_recover_thunk_;\n+  // True if this function already has a recover thunk.\n+  bool has_recover_thunk_;\n+};\n+\n+// A function declaration.\n+\n+class Function_declaration\n+{\n+ public:\n+  Function_declaration(Function_type* fntype, source_location location)\n+    : fntype_(fntype), location_(location), asm_name_(), fndecl_(NULL)\n+  { }\n+\n+  Function_type*\n+  type() const\n+  { return this->fntype_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  const std::string&\n+  asm_name() const\n+  { return this->asm_name_; }\n+\n+  // Set the assembler name.\n+  void\n+  set_asm_name(const std::string& asm_name)\n+  { this->asm_name_ = asm_name; }\n+\n+  // Return a decl for the function given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Export a function declaration.\n+  void\n+  export_func(Export* exp, const std::string& name) const\n+  { Function::export_func_with_type(exp, name, this->fntype_); }\n+\n+ private:\n+  // The type of the function.\n+  Function_type* fntype_;\n+  // The location of the declaration.\n+  source_location location_;\n+  // The assembler name: this is the name to use in references to the\n+  // function.  This is normally empty.\n+  std::string asm_name_;\n+  // The function decl if needed.\n+  tree fndecl_;\n+};\n+\n+// A variable.\n+\n+class Variable\n+{\n+ public:\n+  Variable(Type*, Expression*, bool is_global, bool is_parameter,\n+\t   bool is_receiver, source_location);\n+\n+  // Get the type of the variable.\n+  Type*\n+  type() const;\n+\n+  // Return whether the type is defined yet.\n+  bool\n+  has_type() const\n+  { return this->type_ != NULL; }\n+\n+  // Get the initial value.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Return whether there are any preinit statements.\n+  bool\n+  has_pre_init() const\n+  { return this->preinit_ != NULL; }\n+\n+  // Return the preinit statements if any.\n+  Block*\n+  preinit() const\n+  { return this->preinit_; }\n+\n+  // Return whether this is a global variable.\n+  bool\n+  is_global() const\n+  { return this->is_global_; }\n+\n+  // Return whether this is a function parameter.\n+  bool\n+  is_parameter() const\n+  { return this->is_parameter_; }\n+\n+  // Return whether this is the receiver parameter of a method.\n+  bool\n+  is_receiver() const\n+  { return this->is_receiver_; }\n+\n+  // Change this parameter to be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_receiver()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_receiver_ = true;\n+  }\n+\n+  // Change this parameter to not be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_not_receiver()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_receiver_ = false;\n+  }\n+\n+  // Return whether this is the varargs parameter of a function.\n+  bool\n+  is_varargs_parameter() const\n+  { return this->is_varargs_parameter_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_ && !this->is_global_; }\n+\n+  // Get the source location of the variable's declaration.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Record that this is the varargs parameter of a function.\n+  void\n+  set_is_varargs_parameter()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_varargs_parameter_ = true;\n+  }\n+\n+  // Clear the initial value; used for error handling.\n+  void\n+  clear_init()\n+  { this->init_ = NULL; }\n+\n+  // Set the initial value; used for converting shortcuts.\n+  void\n+  set_init(Expression* init)\n+  { this->init_ = init; }\n+\n+  // Get the preinit block, a block of statements to be run before the\n+  // initialization expression.\n+  Block*\n+  preinit_block();\n+\n+  // Add a statement to be run before the initialization expression.\n+  // This is only used for global variables.\n+  void\n+  add_preinit_statement(Statement*);\n+\n+  // Lower the initialization expression after parsing is complete.\n+  void\n+  lower_init_expression(Gogo*, Named_object*);\n+\n+  // A special case: the init value is used only to determine the\n+  // type.  This is used if the variable is defined using := with the\n+  // comma-ok form of a map index or a receive expression.  The init\n+  // value is actually the map index expression or receive expression.\n+  // We use this because we may not know the right type at parse time.\n+  void\n+  set_type_from_init_tuple()\n+  { this->type_from_init_tuple_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a range clause.  The init value is the range expression.  The\n+  // type of the variable is the index type of the range expression\n+  // (i.e., the first value returned by a range).\n+  void\n+  set_type_from_range_index()\n+  { this->type_from_range_index_ = true; }\n+\n+  // Another special case: like set_type_from_range_index, but the\n+  // type is the value type of the range expression (i.e., the second\n+  // value returned by a range).\n+  void\n+  set_type_from_range_value()\n+  { this->type_from_range_value_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a case in a select statement.  The init value is the channel.\n+  // The type of the variable is the channel's element type.\n+  void\n+  set_type_from_chan_element()\n+  { this->type_from_chan_element_ = true; }\n+\n+  // After we lower the select statement, we once again set the type\n+  // from the initialization expression.\n+  void\n+  clear_type_from_chan_element()\n+  {\n+    gcc_assert(this->type_from_chan_element_);\n+    this->type_from_chan_element_ = false;\n+  }\n+\n+  // Note that this variable was created for a type switch clause.\n+  void\n+  set_is_type_switch_var()\n+  { this->is_type_switch_var_ = true; }\n+\n+  // Traverse the initializer expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the variable if necessary.\n+  void\n+  determine_type();\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Get the initial value of the variable as a tree.  This may only\n+  // be called if has_pre_init() returns false.\n+  tree\n+  get_init_tree(Gogo*, Named_object* function);\n+\n+  // Return a series of statements which sets the value of the\n+  // variable in DECL.  This should only be called is has_pre_init()\n+  // returns true.  DECL may be NULL for a sink variable.\n+  tree\n+  get_init_block(Gogo*, Named_object* function, tree decl);\n+\n+  // Export the variable.\n+  void\n+  export_var(Export*, const std::string& name) const;\n+\n+  // Import a variable.\n+  static void\n+  import_var(Import*, std::string* pname, Type** ptype);\n+\n+ private:\n+  // The type of a tuple.\n+  Type*\n+  type_from_tuple(Expression*, bool) const;\n+\n+  // The type of a range.\n+  Type*\n+  type_from_range(Expression*, bool, bool) const;\n+\n+  // The element type of a channel.\n+  Type*\n+  type_from_chan_element(Expression*, bool) const;\n+\n+  // The variable's type.  This may be NULL if the type is set from\n+  // the expression.\n+  Type* type_;\n+  // The initial value.  This may be NULL if the variable should be\n+  // initialized to the default value for the type.\n+  Expression* init_;\n+  // Statements to run before the init statement.\n+  Block* preinit_;\n+  // Location of variable definition.\n+  source_location location_;\n+  // Whether this is a global variable.\n+  bool is_global_ : 1;\n+  // Whether this is a function parameter.\n+  bool is_parameter_ : 1;\n+  // Whether this is the receiver parameter of a method.\n+  bool is_receiver_ : 1;\n+  // Whether this is the varargs parameter of a function.\n+  bool is_varargs_parameter_ : 1;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_ : 1;\n+  // True if we have lowered the initialization expression.\n+  bool init_is_lowered_ : 1;\n+  // True if init is a tuple used to set the type.\n+  bool type_from_init_tuple_ : 1;\n+  // True if init is a range clause and the type is the index type.\n+  bool type_from_range_index_ : 1;\n+  // True if init is a range clause and the type is the value type.\n+  bool type_from_range_value_ : 1;\n+  // True if init is a channel and the type is the channel's element type.\n+  bool type_from_chan_element_ : 1;\n+  // True if this is a variable created for a type switch case.\n+  bool is_type_switch_var_ : 1;\n+};\n+\n+// A variable which is really the name for a function return value, or\n+// part of one.\n+\n+class Result_variable\n+{\n+ public:\n+  Result_variable(Type* type, Function* function, int index)\n+    : type_(type), function_(function), index_(index),\n+      is_address_taken_(false)\n+  { }\n+\n+  // Get the type of the result variable.\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Get the function that this is associated with.\n+  Function*\n+  function() const\n+  { return this->function_; }\n+\n+  // Index in the list of function results.\n+  int\n+  index() const\n+  { return this->index_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_; }\n+\n+ private:\n+  // Type of result variable.\n+  Type* type_;\n+  // Function with which this is associated.\n+  Function* function_;\n+  // Index in list of results.\n+  int index_;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_;\n+};\n+\n+// The value we keep for a named constant.  This lets us hold a type\n+// and an expression.\n+\n+class Named_constant\n+{\n+ public:\n+  Named_constant(Type* type, Expression* expr, int iota_value,\n+\t\t source_location location)\n+    : type_(type), expr_(expr), iota_value_(iota_value), location_(location),\n+      lowering_(false)\n+  { }\n+\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+  int\n+  iota_value() const\n+  { return this->iota_value_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Whether we are lowering.\n+  bool\n+  lowering() const\n+  { return this->lowering_; }\n+\n+  // Set that we are lowering.\n+  void\n+  set_lowering()\n+  { this->lowering_ = true; }\n+\n+  // We are no longer lowering.\n+  void\n+  clear_lowering()\n+  { this->lowering_ = false; }\n+\n+  // Traverse the expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the constant if necessary.\n+  void\n+  determine_type();\n+\n+  // Indicate that we found and reported an error for this constant.\n+  void\n+  set_error();\n+\n+  // Export the constant.\n+  void\n+  export_const(Export*, const std::string& name) const;\n+\n+  // Import a constant.\n+  static void\n+  import_const(Import*, std::string*, Type**, Expression**);\n+\n+ private:\n+  // The type of the constant.\n+  Type* type_;\n+  // The expression for the constant.\n+  Expression* expr_;\n+  // If the predeclared constant iota is used in EXPR_, this is the\n+  // value it will have.  We do this because at parse time we don't\n+  // know whether the name \"iota\" will refer to the predeclared\n+  // constant or to something else.  We put in the right value in when\n+  // we lower.\n+  int iota_value_;\n+  // The location of the definition.\n+  source_location location_;\n+  // Whether we are currently lowering this constant.\n+  bool lowering_;\n+};\n+\n+// A type declaration.\n+\n+class Type_declaration\n+{\n+ public:\n+  Type_declaration(source_location location)\n+    : location_(location), in_function_(NULL), methods_(),\n+      issued_warning_(false)\n+  { }\n+\n+  // Return the location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the function in which this type is declared.  This will\n+  // return NULL for a type declared in global scope.\n+  Named_object*\n+  in_function()\n+  { return this->in_function_; }\n+\n+  // Set the function in which this type is declared.\n+  void\n+  set_in_function(Named_object* f)\n+  { this->in_function_ = f; }\n+\n+  // Add a method to this type.  This is used when methods are defined\n+  // before the type.\n+  Named_object*\n+  add_method(const std::string& name, Function* function);\n+\n+  // Add a method declaration to this type.\n+  Named_object*\n+  add_method_declaration(const std::string& name, Function_type* type,\n+\t\t\t source_location location);\n+\n+  // Return whether any methods were defined.\n+  bool\n+  has_methods() const;\n+\n+  // Define methods when the real type is known.\n+  void\n+  define_methods(Named_type*);\n+\n+  // This is called if we are trying to use this type.  It returns\n+  // true if we should issue a warning.\n+  bool\n+  using_type();\n+\n+ private:\n+  typedef std::vector<Named_object*> Methods;\n+\n+  // The location of the type declaration.\n+  source_location location_;\n+  // If this type is declared in a function, a pointer back to the\n+  // function in which it is defined.\n+  Named_object* in_function_;\n+  // Methods defined before the type is defined.\n+  Methods methods_;\n+  // True if we have issued a warning about a use of this type\n+  // declaration when it is undefined.\n+  bool issued_warning_;\n+};\n+\n+// An unknown object.  These are created by the parser for forward\n+// references to names which have not been seen before.  In a correct\n+// program, these will always point to a real definition by the end of\n+// the parse.  Because they point to another Named_object, these may\n+// only be referenced by Unknown_expression objects.\n+\n+class Unknown_name\n+{\n+ public:\n+  Unknown_name(source_location location)\n+    : location_(location), real_named_object_(NULL)\n+  { }\n+\n+  // Return the location where this name was first seen.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the real named object that this points to, or NULL if it\n+  // was never resolved.\n+  Named_object*\n+  real_named_object() const\n+  { return this->real_named_object_; }\n+\n+  // Set the real named object that this points to.\n+  void\n+  set_real_named_object(Named_object* no);\n+\n+ private:\n+  // The location where this name was first seen.\n+  source_location location_;\n+  // The real named object when it is known.\n+  Named_object*\n+  real_named_object_;\n+};\n+\n+// A named object named.  This is the result of a declaration.  We\n+// don't use a superclass because they all have to be handled\n+// differently.\n+\n+class Named_object\n+{\n+ public:\n+  enum Classification\n+  {\n+    // An uninitialized Named_object.  We should never see this.\n+    NAMED_OBJECT_UNINITIALIZED,\n+    // An unknown name.  This is used for forward references.  In a\n+    // correct program, these will all be resolved by the end of the\n+    // parse.\n+    NAMED_OBJECT_UNKNOWN,\n+    // A const.\n+    NAMED_OBJECT_CONST,\n+    // A type.\n+    NAMED_OBJECT_TYPE,\n+    // A forward type declaration.\n+    NAMED_OBJECT_TYPE_DECLARATION,\n+    // A var.\n+    NAMED_OBJECT_VAR,\n+    // A result variable in a function.\n+    NAMED_OBJECT_RESULT_VAR,\n+    // The blank identifier--the special variable named _.\n+    NAMED_OBJECT_SINK,\n+    // A func.\n+    NAMED_OBJECT_FUNC,\n+    // A forward func declaration.\n+    NAMED_OBJECT_FUNC_DECLARATION,\n+    // A package.\n+    NAMED_OBJECT_PACKAGE\n+  };\n+\n+  // Return the classification.\n+  Classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Classifiers.\n+\n+  bool\n+  is_unknown() const\n+  { return this->classification_ == NAMED_OBJECT_UNKNOWN; }\n+\n+  bool\n+  is_const() const\n+  { return this->classification_ == NAMED_OBJECT_CONST; }\n+\n+  bool\n+  is_type() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE; }\n+\n+  bool\n+  is_type_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE_DECLARATION; }\n+\n+  bool\n+  is_variable() const\n+  { return this->classification_ == NAMED_OBJECT_VAR; }\n+\n+  bool\n+  is_result_variable() const\n+  { return this->classification_ == NAMED_OBJECT_RESULT_VAR; }\n+\n+  bool\n+  is_sink() const\n+  { return this->classification_ == NAMED_OBJECT_SINK; }\n+\n+  bool\n+  is_function() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC; }\n+\n+  bool\n+  is_function_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC_DECLARATION; }\n+\n+  bool\n+  is_package() const\n+  { return this->classification_ == NAMED_OBJECT_PACKAGE; }\n+\n+  // Creators.\n+\n+  static Named_object*\n+  make_unknown_name(const std::string& name, source_location);\n+\n+  static Named_object*\n+  make_constant(const Typed_identifier&, const Package*, Expression*,\n+\t\tint iota_value);\n+\n+  static Named_object*\n+  make_type(const std::string&, const Package*, Type*, source_location);\n+\n+  static Named_object*\n+  make_type_declaration(const std::string&, const Package*, source_location);\n+\n+  static Named_object*\n+  make_variable(const std::string&, const Package*, Variable*);\n+\n+  static Named_object*\n+  make_result_variable(const std::string&, Result_variable*);\n+\n+  static Named_object*\n+  make_sink();\n+\n+  static Named_object*\n+  make_function(const std::string&, const Package*, Function*);\n+\n+  static Named_object*\n+  make_function_declaration(const std::string&, const Package*, Function_type*,\n+\t\t\t    source_location);\n+\n+  static Named_object*\n+  make_package(const std::string& alias, Package* package);\n+\n+  // Getters.\n+\n+  Unknown_name*\n+  unknown_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  const Unknown_name*\n+  unknown_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  Named_constant*\n+  const_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  const Named_constant*\n+  const_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  Named_type*\n+  type_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  const Named_type*\n+  type_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  Type_declaration*\n+  type_declaration_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  const Type_declaration*\n+  type_declaration_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  Variable*\n+  var_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  const Variable*\n+  var_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  Result_variable*\n+  result_var_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  const Result_variable*\n+  result_var_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  Function*\n+  func_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  const Function*\n+  func_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  Function_declaration*\n+  func_declaration_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  const Function_declaration*\n+  func_declaration_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  Package*\n+  package_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const Package*\n+  package_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the name to use in an error message.  The difference is\n+  // that if this Named_object is defined in a different package, this\n+  // will return PACKAGE.NAME.\n+  std::string\n+  message_name() const;\n+\n+  const Package*\n+  package() const\n+  { return this->package_; }\n+\n+  // Resolve an unknown value if possible.  This returns the same\n+  // Named_object or a new one.\n+  Named_object*\n+  resolve()\n+  {\n+    Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tNamed_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  const Named_object*\n+  resolve() const\n+  {\n+    const Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tconst Named_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  // The location where this object was defined or referenced.\n+  source_location\n+  location() const;\n+\n+  // Return a tree for the external identifier for this object.\n+  tree\n+  get_id(Gogo*);\n+\n+  // Return a tree representing this object.\n+  tree\n+  get_tree(Gogo*, Named_object* function);\n+\n+  // Define a type declaration.\n+  void\n+  set_type_value(Named_type*);\n+\n+  // Define a function declaration.\n+  void\n+  set_function_value(Function*);\n+\n+  // Export this object.\n+  void\n+  export_named_object(Export*) const;\n+\n+ private:\n+  Named_object(const std::string&, const Package*, Classification);\n+\n+  // The name of the object.\n+  std::string name_;\n+  // The package that this object is in.  This is NULL if it is in the\n+  // file we are compiling.\n+  const Package* package_;\n+  // The type of object this is.\n+  Classification classification_;\n+  // The real data.\n+  union\n+  {\n+    Unknown_name* unknown_value;\n+    Named_constant* const_value;\n+    Named_type* type_value;\n+    Type_declaration* type_declaration;\n+    Variable* var_value;\n+    Result_variable* result_var_value;\n+    Function* func_value;\n+    Function_declaration* func_declaration_value;\n+    Package* package_value;\n+  } u_;\n+  // The DECL tree for this object if we have already converted it.\n+  tree tree_;\n+};\n+\n+// A binding contour.  This binds names to objects.\n+\n+class Bindings\n+{\n+ public:\n+  // Type for mapping from names to objects.\n+  typedef Unordered_map(std::string, Named_object*) Contour;\n+\n+  Bindings(Bindings* enclosing);\n+\n+  // Add an unknown name.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_unknown_name(name,\n+\t\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, const Package* package,\n+\t       Expression* expr, int iota_value)\n+  {\n+    return this->add_named_object(Named_object::make_constant(tid, package,\n+\t\t\t\t\t\t\t      expr,\n+\t\t\t\t\t\t\t      iota_value));\n+  }\n+\n+  // Add a type.\n+  Named_object*\n+  add_type(const std::string& name, const Package* package, Type* type,\n+\t   source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_type(name, package, type,\n+\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  Named_object*\n+  add_named_type(Named_type* named_type);\n+\n+  // Add a type declaration.\n+  Named_object*\n+  add_type_declaration(const std::string& name, const Package* package,\n+\t\t       source_location location)\n+  {\n+    Named_object* no = Named_object::make_type_declaration(name, package,\n+\t\t\t\t\t\t\t   location);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string& name, const Package* package,\n+\t       Variable* variable)\n+  {\n+    return this->add_named_object(Named_object::make_variable(name, package,\n+\t\t\t\t\t\t\t      variable));\n+  }\n+\n+  // Add a result variable.\n+  Named_object*\n+  add_result_variable(const std::string& name, Result_variable* result)\n+  {\n+    return this->add_named_object(Named_object::make_result_variable(name,\n+\t\t\t\t\t\t\t\t     result));\n+  }\n+\n+  // Add a function.\n+  Named_object*\n+  add_function(const std::string& name, const Package*, Function* function);\n+\n+  // Add a function declaration.\n+  Named_object*\n+  add_function_declaration(const std::string& name, const Package* package,\n+\t\t\t   Function_type* type, source_location location);\n+\n+  // Add a package.  The location is the location of the import\n+  // statement.\n+  Named_object*\n+  add_package(const std::string& alias, Package* package)\n+  {\n+    Named_object* no = Named_object::make_package(alias, package);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a method to the list of objects.  This is not added to the\n+  // lookup table.\n+  void\n+  add_method(Named_object*);\n+\n+  // Add a named object to this binding.\n+  Named_object*\n+  add_named_object(Named_object* no)\n+  { return this->add_named_object_to_contour(&this->bindings_, no); }\n+\n+  // Clear all names in file scope from the bindings.\n+  void\n+  clear_file_scope();\n+\n+  // Look up a name in this binding contour and in any enclosing\n+  // binding contours.  This returns NULL if the name is not found.\n+  Named_object*\n+  lookup(const std::string&) const;\n+\n+  // Look up a name in this binding contour without looking in any\n+  // enclosing binding contours.  Returns NULL if the name is not found.\n+  Named_object*\n+  lookup_local(const std::string&) const;\n+\n+  // Remove a name.\n+  void\n+  remove_binding(Named_object*);\n+\n+  // Traverse the tree.  See the Traverse class.\n+  int\n+  traverse(Traverse*, bool is_global);\n+\n+  // Iterate over definitions.  This does not include things which\n+  // were only declared.\n+\n+  typedef std::vector<Named_object*>::const_iterator\n+    const_definitions_iterator;\n+\n+  const_definitions_iterator\n+  begin_definitions() const\n+  { return this->named_objects_.begin(); }\n+\n+  const_definitions_iterator\n+  end_definitions() const\n+  { return this->named_objects_.end(); }\n+\n+  // Return the number of definitions.\n+  size_t\n+  size_definitions() const\n+  { return this->named_objects_.size(); }\n+\n+  // Return whether there are no definitions.\n+  bool\n+  empty_definitions() const\n+  { return this->named_objects_.empty(); }\n+\n+  // Iterate over declarations.  This is everything that has been\n+  // declared, which includes everything which has been defined.\n+\n+  typedef Contour::const_iterator const_declarations_iterator;\n+\n+  const_declarations_iterator\n+  begin_declarations() const\n+  { return this->bindings_.begin(); }\n+\n+  const_declarations_iterator\n+  end_declarations() const\n+  { return this->bindings_.end(); }\n+\n+  // Return the number of declarations.\n+  size_t\n+  size_declarations() const\n+  { return this->bindings_.size(); }\n+\n+  // Return whether there are no declarations.\n+  bool\n+  empty_declarations() const\n+  { return this->bindings_.empty(); }\n+\n+  // Return the first declaration.\n+  Named_object*\n+  first_declaration()\n+  { return this->bindings_.empty() ? NULL : this->bindings_.begin()->second; }\n+\n+ private:\n+  Named_object*\n+  add_named_object_to_contour(Contour*, Named_object*);\n+\n+  Named_object*\n+  new_definition(Named_object*, Named_object*);\n+\n+  // Enclosing bindings.\n+  Bindings* enclosing_;\n+  // The list of objects.\n+  std::vector<Named_object*> named_objects_;\n+  // The mapping from names to objects.\n+  Contour bindings_;\n+};\n+\n+// A label.\n+\n+class Label\n+{\n+ public:\n+  Label(const std::string& name)\n+    : name_(name), location_(0), decl_(NULL)\n+  { }\n+\n+  // Return the label's name.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return whether the label has been defined.\n+  bool\n+  is_defined() const\n+  { return this->location_ != 0; }\n+\n+  // Return the location of the definition.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Define the label at LOCATION.\n+  void\n+  define(source_location location)\n+  {\n+    gcc_assert(this->location_ == 0);\n+    this->location_ = location;\n+  }\n+\n+  // Return the LABEL_DECL for this decl.\n+  tree\n+  get_decl();\n+\n+  // Return an expression for the address of this label.\n+  tree\n+  get_addr(source_location location);\n+\n+ private:\n+  // The name of the label.\n+  std::string name_;\n+  // The location of the definition.  This is 0 if the label has not\n+  // yet been defined.\n+  source_location location_;\n+  // The LABEL_DECL.\n+  tree decl_;\n+};\n+\n+// An unnamed label.  These are used when lowering loops.\n+\n+class Unnamed_label\n+{\n+ public:\n+  Unnamed_label(source_location location)\n+    : location_(location), decl_(NULL)\n+  { }\n+\n+  // Get the location where the label is defined.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Set the location where the label is defined.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Return a statement which defines this label.\n+  tree\n+  get_definition();\n+\n+  // Return a goto to this label from LOCATION.\n+  tree\n+  get_goto(source_location location);\n+\n+ private:\n+  // Return the LABEL_DECL to use with GOTO_EXPR.\n+  tree\n+  get_decl();\n+\n+  // The location where the label is defined.\n+  source_location location_;\n+  // The LABEL_DECL.\n+  tree decl_;\n+};\n+\n+// An imported package.\n+\n+class Package\n+{\n+ public:\n+  Package(const std::string& name, const std::string& unique_prefix,\n+\t  source_location location);\n+\n+  // The real name of this package.  This may be different from the\n+  // name in the associated Named_object if the import statement used\n+  // an alias.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the location of the import statement.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Get the unique prefix used for all symbols exported from this\n+  // package.\n+  const std::string&\n+  unique_prefix() const\n+  {\n+    gcc_assert(!this->unique_prefix_.empty());\n+    return this->unique_prefix_;\n+  }\n+\n+  // The priority of this package.  The init function of packages with\n+  // lower priority must be run before the init function of packages\n+  // with higher priority.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+  // Set the priority.\n+  void\n+  set_priority(int priority);\n+\n+  // Return the bindings.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  // Whether some symbol from the package was used.\n+  bool\n+  used() const\n+  { return this->used_; }\n+\n+  // Note that some symbol from this package was used.\n+  void\n+  set_used() const\n+  { this->used_ = true; }\n+\n+  // Clear the used field for the next file.\n+  void\n+  clear_used()\n+  { this->used_ = false; }\n+\n+  // Whether this package was imported in the current file.\n+  bool\n+  is_imported() const\n+  { return this->is_imported_; }\n+\n+  // Note that this package was imported in the current file.\n+  void\n+  set_is_imported()\n+  { this->is_imported_ = true; }\n+\n+  // Clear the imported field for the next file.\n+  void\n+  clear_is_imported()\n+  { this->is_imported_ = false; }\n+\n+  // Whether this package was imported with a name of \"_\".\n+  bool\n+  uses_sink_alias() const\n+  { return this->uses_sink_alias_; }\n+\n+  // Note that this package was imported with a name of \"_\".\n+  void\n+  set_uses_sink_alias()\n+  { this->uses_sink_alias_ = true; }\n+\n+  // Clear the sink alias field for the next file.\n+  void\n+  clear_uses_sink_alias()\n+  { this->uses_sink_alias_ = false; }\n+\n+  // Look up a name in the package.  Returns NULL if the name is not\n+  // found.\n+  Named_object*\n+  lookup(const std::string& name) const\n+  { return this->bindings_->lookup(name); }\n+\n+  // Set the location of the package.  This is used if it is seen in a\n+  // different import before it is really imported.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Add a constant to the package.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, Expression* expr)\n+  { return this->bindings_->add_constant(tid, this, expr, 0); }\n+\n+  // Add a type to the package.\n+  Named_object*\n+  add_type(const std::string& name, Type* type, source_location location)\n+  { return this->bindings_->add_type(name, this, type, location); }\n+\n+  // Add a type declaration to the package.\n+  Named_object*\n+  add_type_declaration(const std::string& name, source_location location)\n+  { return this->bindings_->add_type_declaration(name, this, location); }\n+\n+  // Add a variable to the package.\n+  Named_object*\n+  add_variable(const std::string& name, Variable* variable)\n+  { return this->bindings_->add_variable(name, this, variable); }\n+\n+  // Add a function declaration to the package.\n+  Named_object*\n+  add_function_declaration(const std::string& name, Function_type* type,\n+\t\t\t   source_location loc)\n+  { return this->bindings_->add_function_declaration(name, this, type, loc); }\n+\n+  // Determine types of constants.\n+  void\n+  determine_types();\n+\n+ private:\n+  // The real name of this package.\n+  std::string name_;\n+  // The unique prefix for all exported global symbols.\n+  std::string unique_prefix_;\n+  // The names in this package.\n+  Bindings* bindings_;\n+  // The priority of this package.  A package has a priority higher\n+  // than the priority of all of the packages that it imports.  This\n+  // is used to run init functions in the right order.\n+  int priority_;\n+  // The location of the import statement.\n+  source_location location_;\n+  // True if some name from this package was used.  This is mutable\n+  // because we can use a package even if we have a const pointer to\n+  // it.\n+  mutable bool used_;\n+  // True if this package was imported in the current file.\n+  bool is_imported_;\n+  // True if this package was imported with a name of \"_\".\n+  bool uses_sink_alias_;\n+};\n+\n+// Return codes for the traversal functions.  This is not an enum\n+// because we want to be able to declare traversal functions in other\n+// header files without including this one.\n+\n+// Continue traversal as usual.\n+const int TRAVERSE_CONTINUE = -1;\n+\n+// Exit traversal.\n+const int TRAVERSE_EXIT = 0;\n+\n+// Continue traversal, but skip components of the current object.\n+// E.g., if this is returned by Traverse::statement, we do not\n+// traverse the expressions in the statement even if\n+// traverse_expressions is set in the traverse_mask.\n+const int TRAVERSE_SKIP_COMPONENTS = 1;\n+\n+// This class is used when traversing the parse tree.  The caller uses\n+// a subclass which overrides functions as desired.\n+\n+class Traverse\n+{\n+ public:\n+  // These bitmasks say what to traverse.\n+  static const unsigned int traverse_variables =    0x1;\n+  static const unsigned int traverse_constants =    0x2;\n+  static const unsigned int traverse_functions =    0x4;\n+  static const unsigned int traverse_blocks =       0x8;\n+  static const unsigned int traverse_statements =  0x10;\n+  static const unsigned int traverse_expressions = 0x20;\n+  static const unsigned int traverse_types =       0x40;\n+\n+  Traverse(unsigned int traverse_mask)\n+    : traverse_mask_(traverse_mask), types_seen_(NULL), expressions_seen_(NULL)\n+  { }\n+\n+  virtual ~Traverse();\n+\n+  // The bitmask of what to traverse.\n+  unsigned int\n+  traverse_mask() const\n+  { return this->traverse_mask_; }\n+\n+  // Record that we are going to traverse a type.  This returns true\n+  // if the type has already been seen in this traversal.  This is\n+  // required because types, unlike expressions, can form a circular\n+  // graph.\n+  bool\n+  remember_type(const Type*);\n+\n+  // Record that we are going to see an expression.  This returns true\n+  // if the expression has already been seen in this traversal.  This\n+  // is only needed for cases where multiple expressions can point to\n+  // a single one.\n+  bool\n+  remember_expression(const Expression*);\n+\n+  // These functions return one of the TRAVERSE codes defined above.\n+\n+  // If traverse_variables is set in the mask, this is called for\n+  // every variable in the tree.\n+  virtual int\n+  variable(Named_object*);\n+\n+  // If traverse_constants is set in the mask, this is called for\n+  // every named constant in the tree.  The bool parameter is true for\n+  // a global constant.\n+  virtual int\n+  constant(Named_object*, bool);\n+\n+  // If traverse_functions is set in the mask, this is called for\n+  // every function in the tree.\n+  virtual int\n+  function(Named_object*);\n+\n+  // If traverse_blocks is set in the mask, this is called for every\n+  // block in the tree.\n+  virtual int\n+  block(Block*);\n+\n+  // If traverse_statements is set in the mask, this is called for\n+  // every statement in the tree.\n+  virtual int\n+  statement(Block*, size_t* index, Statement*);\n+\n+  // If traverse_expressions is set in the mask, this is called for\n+  // every expression in the tree.\n+  virtual int\n+  expression(Expression**);\n+\n+  // If traverse_types is set in the mask, this is called for every\n+  // type in the tree.\n+  virtual int\n+  type(Type*);\n+\n+ private:\n+  typedef Unordered_set_hash(const Type*, Type_hash_identical,\n+\t\t\t     Type_identical) Types_seen;\n+\n+  typedef Unordered_set(const Expression*) Expressions_seen;\n+\n+  // Bitmask of what sort of objects to traverse.\n+  unsigned int traverse_mask_;\n+  // Types which have been seen in this traversal.\n+  Types_seen* types_seen_;\n+  // Expressions which have been seen in this traversal.\n+  Expressions_seen* expressions_seen_;\n+};\n+\n+// When translating the gogo IR into trees, this is the context we\n+// pass down the blocks and statements.\n+\n+class Translate_context\n+{\n+ public:\n+  Translate_context(Gogo* gogo, Named_object* function, Block* block,\n+\t\t    tree block_tree)\n+    : gogo_(gogo), function_(function), block_(block), block_tree_(block_tree),\n+      is_const_(false)\n+  { }\n+\n+  // Accessors.\n+\n+  Gogo*\n+  gogo()\n+  { return this->gogo_; }\n+\n+  Named_object*\n+  function()\n+  { return this->function_; }\n+\n+  Block*\n+  block()\n+  { return this->block_; }\n+\n+  tree\n+  block_tree()\n+  { return this->block_tree_; }\n+\n+  bool\n+  is_const()\n+  { return this->is_const_; }\n+\n+  // Make a constant context.\n+  void\n+  set_is_const()\n+  { this->is_const_ = true; }\n+\n+ private:\n+  // The IR for the entire compilation unit.\n+  Gogo* gogo_;\n+  // The function we are currently translating.\n+  Named_object* function_;\n+  // The block we are currently translating.\n+  Block *block_;\n+  // The BLOCK node for the current block.\n+  tree block_tree_;\n+  // Whether this is being evaluated in a constant context.  This is\n+  // used for type descriptor initializers.\n+  bool is_const_;\n+};\n+\n+// Runtime error codes.  These must match the values in\n+// libgo/runtime/go-runtime-error.c.\n+\n+// Slice index out of bounds: negative or larger than the length of\n+// the slice.\n+static const int RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS = 0;\n+\n+// Array index out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS = 1;\n+\n+// String index out of bounds.\n+static const int RUNTIME_ERROR_STRING_INDEX_OUT_OF_BOUNDS = 2;\n+\n+// Slice slice out of bounds: negative or larger than the length of\n+// the slice or high bound less than low bound.\n+static const int RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS = 3;\n+\n+// Array slice out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS = 4;\n+\n+// String slice out of bounds.\n+static const int RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS = 5;\n+\n+// Dereference of nil pointer.  This is used when there is a\n+// dereference of a pointer to a very large struct or array, to ensure\n+// that a gigantic array is not used a proxy to access random memory\n+// locations.\n+static const int RUNTIME_ERROR_NIL_DEREFERENCE = 6;\n+\n+// Slice length or capacity out of bounds in make: negative or\n+// overflow or length greater than capacity.\n+static const int RUNTIME_ERROR_MAKE_SLICE_OUT_OF_BOUNDS = 7;\n+\n+// Map capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 8;\n+\n+// Channel capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 9;\n+\n+// This is used by some of the langhooks.\n+extern Gogo* go_get_gogo();\n+\n+// Whether we have seen any errors.  FIXME: Replace with a backend\n+// interface.\n+extern bool saw_errors();\n+\n+#endif // !defined(GO_GOGO_H)"}, {"sha": "788c80a454d218bce14da9edcd437cc29d3974c6", "filename": "gcc/go/gofrontend/gogo.h.merge-right.r172891", "status": "added", "additions": 2612, "deletions": 0, "changes": 2612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.h.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.h.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,2612 @@\n+// gogo.h -- Go frontend parsed representation.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_GOGO_H\n+#define GO_GOGO_H\n+\n+class Traverse;\n+class Type;\n+class Type_hash_identical;\n+class Type_equal;\n+class Type_identical;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Expression;\n+class Statement;\n+class Temporary_statement;\n+class Block;\n+class Function;\n+class Bindings;\n+class Package;\n+class Variable;\n+class Pointer_type;\n+class Struct_type;\n+class Struct_field;\n+class Struct_field_list;\n+class Array_type;\n+class Map_type;\n+class Channel_type;\n+class Interface_type;\n+class Named_type;\n+class Forward_declaration_type;\n+class Method;\n+class Methods;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Backend;\n+class Export;\n+class Import;\n+class Bexpression;\n+class Bstatement;\n+class Bblock;\n+class Bvariable;\n+class Blabel;\n+\n+// This file declares the basic classes used to hold the internal\n+// representation of Go which is built by the parser.\n+\n+// An initialization function for an imported package.  This is a\n+// magic function which initializes variables and runs the \"init\"\n+// function.\n+\n+class Import_init\n+{\n+ public:\n+  Import_init(const std::string& package_name, const std::string& init_name,\n+\t      int priority)\n+    : package_name_(package_name), init_name_(init_name), priority_(priority)\n+  { }\n+\n+  // The name of the package being imported.\n+  const std::string&\n+  package_name() const\n+  { return this->package_name_; }\n+\n+  // The name of the package's init function.\n+  const std::string&\n+  init_name() const\n+  { return this->init_name_; }\n+\n+  // The priority of the initialization function.  Functions with a\n+  // lower priority number must be run first.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+ private:\n+  // The name of the package being imported.\n+  std::string package_name_;\n+  // The name of the package's init function.\n+  std::string init_name_;\n+  // The priority.\n+  int priority_;\n+};\n+\n+// For sorting purposes.\n+\n+inline bool\n+operator<(const Import_init& i1, const Import_init& i2)\n+{\n+  if (i1.priority() < i2.priority())\n+    return true;\n+  if (i1.priority() > i2.priority())\n+    return false;\n+  if (i1.package_name() != i2.package_name())\n+    return i1.package_name() < i2.package_name();\n+  return i1.init_name() < i2.init_name();\n+}\n+\n+// The holder for the internal representation of the entire\n+// compilation unit.\n+\n+class Gogo\n+{\n+ public:\n+  // Create the IR, passing in the sizes of the types \"int\" and\n+  // \"uintptr\" in bits.\n+  Gogo(Backend* backend, int int_type_size, int pointer_size);\n+\n+  // Get the backend generator.\n+  Backend*\n+  backend()\n+  { return this->backend_; }\n+\n+  // Get the package name.\n+  const std::string&\n+  package_name() const;\n+\n+  // Set the package name.\n+  void\n+  set_package_name(const std::string&, source_location);\n+\n+  // Return whether this is the \"main\" package.\n+  bool\n+  is_main_package() const;\n+\n+  // If necessary, adjust the name to use for a hidden symbol.  We add\n+  // a prefix of the package name, so that hidden symbols in different\n+  // packages do not collide.\n+  std::string\n+  pack_hidden_name(const std::string& name, bool is_exported) const\n+  {\n+    return (is_exported\n+\t    ? name\n+\t    : ('.' + this->unique_prefix()\n+\t       + '.' + this->package_name()\n+\t       + '.' + name));\n+  }\n+\n+  // Unpack a name which may have been hidden.  Returns the\n+  // user-visible name of the object.\n+  static std::string\n+  unpack_hidden_name(const std::string& name)\n+  { return name[0] != '.' ? name : name.substr(name.rfind('.') + 1); }\n+\n+  // Return whether a possibly packed name is hidden.\n+  static bool\n+  is_hidden_name(const std::string& name)\n+  { return name[0] == '.'; }\n+\n+  // Return the package prefix of a hidden name.\n+  static std::string\n+  hidden_name_prefix(const std::string& name)\n+  {\n+    go_assert(Gogo::is_hidden_name(name));\n+    return name.substr(1, name.rfind('.') - 1);\n+  }\n+\n+  // Given a name which may or may not have been hidden, return the\n+  // name to use in an error message.\n+  static std::string\n+  message_name(const std::string& name);\n+\n+  // Return whether a name is the blank identifier _.\n+  static bool\n+  is_sink_name(const std::string& name)\n+  {\n+    return (name[0] == '.'\n+\t    && name[name.length() - 1] == '_'\n+\t    && name[name.length() - 2] == '.');\n+  }\n+\n+  // Return the unique prefix to use for all exported symbols.\n+  const std::string&\n+  unique_prefix() const;\n+\n+  // Set the unique prefix.\n+  void\n+  set_unique_prefix(const std::string&);\n+\n+  // Return the priority to use for the package we are compiling.\n+  // This is two more than the largest priority of any package we\n+  // import.\n+  int\n+  package_priority() const;\n+\n+  // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n+  // is the local name to give to the package.  If LOCAL_NAME is empty\n+  // the declarations are added to the global scope.\n+  void\n+  import_package(const std::string& filename, const std::string& local_name,\n+\t\t bool is_local_name_exported, source_location);\n+\n+  // Whether we are the global binding level.\n+  bool\n+  in_global_scope() const;\n+\n+  // Look up a name in the current binding contours.\n+  Named_object*\n+  lookup(const std::string&, Named_object** pfunction) const;\n+\n+  // Look up a name in the current block.\n+  Named_object*\n+  lookup_in_block(const std::string&) const;\n+\n+  // Look up a name in the global namespace--the universal scope.\n+  Named_object*\n+  lookup_global(const char*) const;\n+\n+  // Add a new imported package.  REAL_NAME is the real name of the\n+  // package.  ALIAS is the alias of the package; this may be the same\n+  // as REAL_NAME.  This sets *PADD_TO_GLOBALS if symbols added to\n+  // this package should be added to the global namespace; this is\n+  // true if the alias is \".\".  LOCATION is the location of the import\n+  // statement.  This returns the new package, or NULL on error.\n+  Package*\n+  add_imported_package(const std::string& real_name, const std::string& alias,\n+\t\t       bool is_alias_exported,\n+\t\t       const std::string& unique_prefix,\n+\t\t       source_location location,\n+\t\t       bool* padd_to_globals);\n+\n+  // Register a package.  This package may or may not be imported.\n+  // This returns the Package structure for the package, creating if\n+  // it necessary.\n+  Package*\n+  register_package(const std::string& name, const std::string& unique_prefix,\n+\t\t   source_location);\n+\n+  // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n+  // method function should be added to the type of its receiver.\n+  Named_object*\n+  start_function(const std::string& name, Function_type* type,\n+\t\t bool add_method_to_type, source_location);\n+\n+  // Finish compiling a function.\n+  void\n+  finish_function(source_location);\n+\n+  // Return the current function.\n+  Named_object*\n+  current_function() const;\n+\n+  // Start a new block.  This is not initially associated with a\n+  // function.\n+  void\n+  start_block(source_location);\n+\n+  // Finish the current block and return it.\n+  Block*\n+  finish_block(source_location);\n+\n+  // Declare an unknown name.  This is used while parsing.  The name\n+  // must be resolved by the end of the parse.  Unknown names are\n+  // always added at the package level.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location);\n+\n+  // Declare a function.\n+  Named_object*\n+  declare_function(const std::string&, Function_type*, source_location);\n+\n+  // Add a label.\n+  Label*\n+  add_label_definition(const std::string&, source_location);\n+\n+  // Add a label reference.\n+  Label*\n+  add_label_reference(const std::string&);\n+\n+  // Add a statement to the current block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a block to the current block.\n+  void\n+  add_block(Block*, source_location);\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier&, Expression*, int iota_value);\n+\n+  // Add a type.\n+  void\n+  add_type(const std::string&, Type*, source_location);\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  void\n+  add_named_type(Named_type*);\n+\n+  // Declare a type.\n+  Named_object*\n+  declare_type(const std::string&, source_location);\n+\n+  // Declare a type at the package level.  This is used when the\n+  // parser sees an unknown name where a type name is required.\n+  Named_object*\n+  declare_package_type(const std::string&, source_location);\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string&, Variable*);\n+\n+  // Add a sink--a reference to the blank identifier _.\n+  Named_object*\n+  add_sink();\n+\n+  // Add a named object to the current namespace.  This is used for\n+  // import . \"package\".\n+  void\n+  add_named_object(Named_object*);\n+\n+  // Return a name to use for a thunk function.  A thunk function is\n+  // one we create during the compilation, for a go statement or a\n+  // defer statement or a method expression.\n+  static std::string\n+  thunk_name();\n+\n+  // Return whether an object is a thunk.\n+  static bool\n+  is_thunk(const Named_object*);\n+\n+  // Note that we've seen an interface type.  This is used to build\n+  // all required interface method tables.\n+  void\n+  record_interface_type(Interface_type*);\n+\n+  // Note that we need an initialization function.\n+  void\n+  set_need_init_fn()\n+  { this->need_init_fn_ = true; }\n+\n+  // Clear out all names in file scope.  This is called when we start\n+  // parsing a new file.\n+  void\n+  clear_file_scope();\n+\n+  // Traverse the tree.  See the Traverse class.\n+  void\n+  traverse(Traverse*);\n+\n+  // Define the predeclared global names.\n+  void\n+  define_global_names();\n+\n+  // Verify and complete all types.\n+  void\n+  verify_types();\n+\n+  // Lower the parse tree.\n+  void\n+  lower_parse_tree();\n+\n+  // Lower all the statements in a block.\n+  void\n+  lower_block(Named_object* function, Block*);\n+\n+  // Lower an expression.\n+  void\n+  lower_expression(Named_object* function, Expression**);\n+\n+  // Lower a constant.\n+  void\n+  lower_constant(Named_object*);\n+\n+  // Finalize the method lists and build stub methods for named types.\n+  void\n+  finalize_methods();\n+\n+  // Work out the types to use for unspecified variables and\n+  // constants.\n+  void\n+  determine_types();\n+\n+  // Type check the program.\n+  void\n+  check_types();\n+\n+  // Check the types in a single block.  This is used for complicated\n+  // go statements.\n+  void\n+  check_types_in_block(Block*);\n+\n+  // Check for return statements.\n+  void\n+  check_return_statements();\n+\n+  // Do all exports.\n+  void\n+  do_exports();\n+\n+  // Add an import control function for an imported package to the\n+  // list.\n+  void\n+  add_import_init_fn(const std::string& package_name,\n+\t\t     const std::string& init_name, int prio);\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  void\n+  remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  void\n+  order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  void\n+  build_recover_thunks();\n+\n+  // Simplify statements which might use thunks: go and defer\n+  // statements.\n+  void\n+  simplify_thunk_statements();\n+\n+  // Convert named types to the backend representation.\n+  void\n+  convert_named_types();\n+\n+  // Convert named types in a list of bindings.\n+  void\n+  convert_named_types_in_bindings(Bindings*);\n+\n+  // True if named types have been converted to the backend\n+  // representation.\n+  bool\n+  named_types_are_converted() const\n+  { return this->named_types_are_converted_; }\n+\n+  // Write out the global values.\n+  void\n+  write_globals();\n+\n+  // Build a call to a builtin function.  PDECL should point to a NULL\n+  // initialized static pointer which will hold the fndecl.  NAME is\n+  // the name of the function.  NARGS is the number of arguments.\n+  // RETTYPE is the return type.  It is followed by NARGS pairs of\n+  // type and argument (both trees).\n+  static tree\n+  call_builtin(tree* pdecl, source_location, const char* name, int nargs,\n+\t       tree rettype, ...);\n+\n+  // Build a call to the runtime error function.\n+  static tree\n+  runtime_error(int code, source_location);\n+\n+  // Build a builtin struct with a list of fields.\n+  static tree\n+  builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n+\t\t int nfields, ...);\n+\n+  // Mark a function declaration as a builtin library function.\n+  static void\n+  mark_fndecl_as_builtin_library(tree fndecl);\n+\n+  // Build the type of the struct that holds a slice for the given\n+  // element type.\n+  tree\n+  slice_type_tree(tree element_type_tree);\n+\n+  // Given a tree for a slice type, return the tree for the element\n+  // type.\n+  static tree\n+  slice_element_type_tree(tree slice_type_tree);\n+\n+  // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n+  // the slice.  VALUES points to the values.  COUNT is the size,\n+  // CAPACITY is the capacity.  If CAPACITY is NULL, it is set to\n+  // COUNT.\n+  static tree\n+  slice_constructor(tree slice_type_tree, tree values, tree count,\n+\t\t    tree capacity);\n+\n+  // Build a constructor for an empty slice.  SLICE_TYPE_TREE is the\n+  // type of the slice.\n+  static tree\n+  empty_slice_constructor(tree slice_type_tree);\n+\n+  // Build a map descriptor.\n+  tree\n+  map_descriptor(Map_type*);\n+\n+  // Return a tree for the type of a map descriptor.  This is struct\n+  // __go_map_descriptor in libgo/runtime/map.h.  This is the same for\n+  // all map types.\n+  tree\n+  map_descriptor_type();\n+\n+  // Build a type descriptor for TYPE using INITIALIZER as the type\n+  // descriptor.  This builds a new decl stored in *PDECL.\n+  void\n+  build_type_descriptor_decl(const Type*, Expression* initializer,\n+\t\t\t     tree* pdecl);\n+\n+  // Build required interface method tables.\n+  void\n+  build_interface_method_tables();\n+\n+  // Build an interface method table for a type: a list of function\n+  // pointers, one for each interface method.  This returns a decl.\n+  tree\n+  interface_method_table_for_type(const Interface_type*, Named_type*,\n+\t\t\t\t  bool is_pointer);\n+\n+  // Return a tree which allocate SIZE bytes to hold values of type\n+  // TYPE.\n+  tree\n+  allocate_memory(Type *type, tree size, source_location);\n+\n+  // Return a type to use for pointer to const char.\n+  static tree\n+  const_char_pointer_type_tree();\n+\n+  // Build a string constant with the right type.\n+  static tree\n+  string_constant_tree(const std::string&);\n+\n+  // Build a Go string constant.  This returns a pointer to the\n+  // constant.\n+  tree\n+  go_string_constant_tree(const std::string&);\n+\n+  // Receive a value from a channel.\n+  static tree\n+  receive_from_channel(tree type_tree, tree channel, bool for_select,\n+\t\t       source_location);\n+\n+  // Return a tree for receiving an integer on a channel.\n+  static tree\n+  receive_as_64bit_integer(tree type, tree channel, bool blocking,\n+\t\t\t   bool for_select);\n+\n+\n+  // Make a trampoline which calls FNADDR passing CLOSURE.\n+  tree\n+  make_trampoline(tree fnaddr, tree closure, source_location);\n+\n+ private:\n+  // During parsing, we keep a stack of functions.  Each function on\n+  // the stack is one that we are currently parsing.  For each\n+  // function, we keep track of the current stack of blocks.\n+  struct Open_function\n+  {\n+    // The function.\n+    Named_object* function;\n+    // The stack of active blocks in the function.\n+    std::vector<Block*> blocks;\n+  };\n+\n+  // The stack of functions.\n+  typedef std::vector<Open_function> Open_functions;\n+\n+  // Create trees for implicit builtin functions.\n+  void\n+  define_builtin_function_trees();\n+\n+  // Set up the built-in unsafe package.\n+  void\n+  import_unsafe(const std::string&, bool is_exported, source_location);\n+\n+  // Add a new imported package.\n+  Named_object*\n+  add_package(const std::string& real_name, const std::string& alias,\n+\t      const std::string& unique_prefix, source_location location);\n+\n+  // Return the current binding contour.\n+  Bindings*\n+  current_bindings();\n+\n+  const Bindings*\n+  current_bindings() const;\n+\n+  // Return the current block.\n+  Block*\n+  current_block();\n+\n+  // Get the name of the magic initialization function.\n+  const std::string&\n+  get_init_fn_name();\n+\n+  // Get the decl for the magic initialization function.\n+  tree\n+  initialization_function_decl();\n+\n+  // Write the magic initialization function.\n+  void\n+  write_initialization_function(tree fndecl, tree init_stmt_list);\n+\n+  // Initialize imported packages.\n+  void\n+  init_imports(tree*);\n+\n+  // Register variables with the garbage collector.\n+  void\n+  register_gc_vars(const std::vector<Named_object*>&, tree*);\n+\n+  // Build a pointer to a Go string constant.  This returns a pointer\n+  // to the pointer.\n+  tree\n+  ptr_go_string_constant_tree(const std::string&);\n+\n+  // Return the name to use for a type descriptor decl for an unnamed\n+  // type.\n+  std::string\n+  unnamed_type_descriptor_decl_name(const Type* type);\n+\n+  // Return the name to use for a type descriptor decl for a type\n+  // named NO, defined in IN_FUNCTION.\n+  std::string\n+  type_descriptor_decl_name(const Named_object* no,\n+\t\t\t    const Named_object* in_function);\n+\n+  // Where a type descriptor should be defined.\n+  enum Type_descriptor_location\n+    {\n+      // Defined in this file.\n+      TYPE_DESCRIPTOR_DEFINED,\n+      // Defined in some other file.\n+      TYPE_DESCRIPTOR_UNDEFINED,\n+      // Common definition which may occur in multiple files.\n+      TYPE_DESCRIPTOR_COMMON\n+    };\n+\n+  // Return where the decl for TYPE should be defined.\n+  Type_descriptor_location\n+  type_descriptor_location(const Type* type);\n+\n+  // Return the type of a trampoline.\n+  static tree\n+  trampoline_type_tree();\n+\n+  // Type used to map import names to packages.\n+  typedef std::map<std::string, Package*> Imports;\n+\n+  // Type used to map package names to packages.\n+  typedef std::map<std::string, Package*> Packages;\n+\n+  // Type used to map special names in the sys package.\n+  typedef std::map<std::string, std::string> Sys_names;\n+\n+  // Hash table mapping map types to map descriptor decls.\n+  typedef Unordered_map_hash(const Map_type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Map_descriptors;\n+\n+  // Map unnamed types to type descriptor decls.\n+  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Type_descriptor_decls;\n+\n+  // The backend generator.\n+  Backend* backend_;\n+  // The package we are compiling.\n+  Package* package_;\n+  // The list of currently open functions during parsing.\n+  Open_functions functions_;\n+  // The global binding contour.  This includes the builtin functions\n+  // and the package we are compiling.\n+  Bindings* globals_;\n+  // Mapping from import file names to packages.\n+  Imports imports_;\n+  // Whether the magic unsafe package was imported.\n+  bool imported_unsafe_;\n+  // Mapping from package names we have seen to packages.  This does\n+  // not include the package we are compiling.\n+  Packages packages_;\n+  // Mapping from map types to map descriptors.\n+  Map_descriptors* map_descriptors_;\n+  // Mapping from unnamed types to type descriptor decls.\n+  Type_descriptor_decls* type_descriptor_decls_;\n+  // The functions named \"init\", if there are any.\n+  std::vector<Named_object*> init_functions_;\n+  // Whether we need a magic initialization function.\n+  bool need_init_fn_;\n+  // The name of the magic initialization function.\n+  std::string init_fn_name_;\n+  // A list of import control variables for packages that we import.\n+  std::set<Import_init> imported_init_fns_;\n+  // The unique prefix used for all global symbols.\n+  std::string unique_prefix_;\n+  // Whether an explicit unique prefix was set by -fgo-prefix.\n+  bool unique_prefix_specified_;\n+  // A list of interface types defined while parsing.\n+  std::vector<Interface_type*> interface_types_;\n+  // Whether named types have been converted.\n+  bool named_types_are_converted_;\n+};\n+\n+// A block of statements.\n+\n+class Block\n+{\n+ public:\n+  Block(Block* enclosing, source_location);\n+\n+  // Return the enclosing block.\n+  const Block*\n+  enclosing() const\n+  { return this->enclosing_; }\n+\n+  // Return the bindings of the block.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  const Bindings*\n+  bindings() const\n+  { return this->bindings_; }\n+\n+  // Look at the block's statements.\n+  const std::vector<Statement*>*\n+  statements() const\n+  { return &this->statements_; }\n+\n+  // Return the start location.  This is normally the location of the\n+  // left curly brace which starts the block.\n+  source_location\n+  start_location() const\n+  { return this->start_location_; }\n+\n+  // Return the end location.  This is normally the location of the\n+  // right curly brace which ends the block.\n+  source_location\n+  end_location() const\n+  { return this->end_location_; }\n+\n+  // Add a statement to the block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a statement to the front of the block.\n+  void\n+  add_statement_at_front(Statement*);\n+\n+  // Replace a statement in a block.\n+  void\n+  replace_statement(size_t index, Statement*);\n+\n+  // Add a Statement before statement number INDEX.\n+  void\n+  insert_statement_before(size_t index, Statement*);\n+\n+  // Add a Statement after statement number INDEX.\n+  void\n+  insert_statement_after(size_t index, Statement*);\n+\n+  // Set the end location of the block.\n+  void\n+  set_end_location(source_location location)\n+  { this->end_location_ = location; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Set final types for unspecified variables and constants.\n+  void\n+  determine_types();\n+\n+  // Return true if execution of this block may fall through to the\n+  // next block.\n+  bool\n+  may_fall_through() const;\n+\n+  // Convert the block to the backend representation.\n+  Bblock*\n+  get_backend(Translate_context*);\n+\n+  // Iterate over statements.\n+\n+  typedef std::vector<Statement*>::iterator iterator;\n+\n+  iterator\n+  begin()\n+  { return this->statements_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->statements_.end(); }\n+\n+ private:\n+  // Enclosing block.\n+  Block* enclosing_;\n+  // Statements in the block.\n+  std::vector<Statement*> statements_;\n+  // Binding contour.\n+  Bindings* bindings_;\n+  // Location of start of block.\n+  source_location start_location_;\n+  // Location of end of block.\n+  source_location end_location_;\n+};\n+\n+// A function.\n+\n+class Function\n+{\n+ public:\n+  Function(Function_type* type, Function*, Block*, source_location);\n+\n+  // Return the function's type.\n+  Function_type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Return the enclosing function if there is one.\n+  Function*\n+  enclosing()\n+  { return this->enclosing_; }\n+\n+  // Set the enclosing function.  This is used when building thunks\n+  // for functions which call recover.\n+  void\n+  set_enclosing(Function* enclosing)\n+  {\n+    go_assert(this->enclosing_ == NULL);\n+    this->enclosing_ = enclosing;\n+  }\n+\n+  // The result variables.\n+  typedef std::vector<Named_object*> Results;\n+\n+  // Create the result variables in the outer block.\n+  void\n+  create_result_variables(Gogo*);\n+\n+  // Update the named result variables when cloning a function which\n+  // calls recover.\n+  void\n+  update_result_variables();\n+\n+  // Return the result variables.\n+  Results*\n+  result_variables()\n+  { return this->results_; }\n+\n+  // Whether the result variables have names.\n+  bool\n+  results_are_named() const\n+  { return this->results_are_named_; }\n+\n+  // Add a new field to the closure variable.\n+  void\n+  add_closure_field(Named_object* var, source_location loc)\n+  { this->closure_fields_.push_back(std::make_pair(var, loc)); }\n+\n+  // Whether this function needs a closure.\n+  bool\n+  needs_closure() const\n+  { return !this->closure_fields_.empty(); }\n+\n+  // Return the closure variable, creating it if necessary.  This is\n+  // passed to the function as a static chain parameter.\n+  Named_object*\n+  closure_var();\n+\n+  // Set the closure variable.  This is used when building thunks for\n+  // functions which call recover.\n+  void\n+  set_closure_var(Named_object* v)\n+  {\n+    go_assert(this->closure_var_ == NULL);\n+    this->closure_var_ = v;\n+  }\n+\n+  // Return the variable for a reference to field INDEX in the closure\n+  // variable.\n+  Named_object*\n+  enclosing_var(unsigned int index)\n+  {\n+    go_assert(index < this->closure_fields_.size());\n+    return closure_fields_[index].first;\n+  }\n+\n+  // Set the type of the closure variable if there is one.\n+  void\n+  set_closure_type();\n+\n+  // Get the block of statements associated with the function.\n+  Block*\n+  block() const\n+  { return this->block_; }\n+\n+  // Get the location of the start of the function.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this function is actually a method.\n+  bool\n+  is_method() const;\n+\n+  // Add a label definition to the function.\n+  Label*\n+  add_label_definition(const std::string& label_name, source_location);\n+\n+  // Add a label reference to a function.\n+  Label*\n+  add_label_reference(const std::string& label_name);\n+\n+  // Warn about labels that are defined but not used.\n+  void\n+  check_labels() const;\n+\n+  // Whether this function calls the predeclared recover function.\n+  bool\n+  calls_recover() const\n+  { return this->calls_recover_; }\n+\n+  // Record that this function calls the predeclared recover function.\n+  // This is set during the lowering pass.\n+  void\n+  set_calls_recover()\n+  { this->calls_recover_ = true; }\n+\n+  // Whether this is a recover thunk function.\n+  bool\n+  is_recover_thunk() const\n+  { return this->is_recover_thunk_; }\n+\n+  // Record that this is a thunk built for a function which calls\n+  // recover.\n+  void\n+  set_is_recover_thunk()\n+  { this->is_recover_thunk_ = true; }\n+\n+  // Whether this function already has a recover thunk.\n+  bool\n+  has_recover_thunk() const\n+  { return this->has_recover_thunk_; }\n+\n+  // Record that this function already has a recover thunk.\n+  void\n+  set_has_recover_thunk()\n+  { this->has_recover_thunk_ = true; }\n+\n+  // Swap with another function.  Used only for the thunk which calls\n+  // recover.\n+  void\n+  swap_for_recover(Function *);\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Determine types in the function.\n+  void\n+  determine_types();\n+\n+  // Return the function's decl given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Return the function's decl after it has been built.\n+  tree\n+  get_decl() const\n+  {\n+    go_assert(this->fndecl_ != NULL);\n+    return this->fndecl_;\n+  }\n+\n+  // Set the function decl to hold a tree of the function code.\n+  void\n+  build_tree(Gogo*, Named_object*);\n+\n+  // Get the value to return when not explicitly specified.  May also\n+  // add statements to execute first to STMT_LIST.\n+  tree\n+  return_value(Gogo*, Named_object*, source_location, tree* stmt_list) const;\n+\n+  // Get a tree for the variable holding the defer stack.\n+  Expression*\n+  defer_stack(source_location);\n+\n+  // Export the function.\n+  void\n+  export_func(Export*, const std::string& name) const;\n+\n+  // Export a function with a type.\n+  static void\n+  export_func_with_type(Export*, const std::string& name,\n+\t\t\tconst Function_type*);\n+\n+  // Import a function.\n+  static void\n+  import_func(Import*, std::string* pname, Typed_identifier** receiver,\n+\t      Typed_identifier_list** pparameters,\n+\t      Typed_identifier_list** presults, bool* is_varargs);\n+\n+ private:\n+  // Type for mapping from label names to Label objects.\n+  typedef Unordered_map(std::string, Label*) Labels;\n+\n+  tree\n+  make_receiver_parm_decl(Gogo*, Named_object*, tree);\n+\n+  tree\n+  copy_parm_to_heap(Gogo*, Named_object*, tree);\n+\n+  void\n+  build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n+\n+  typedef std::vector<std::pair<Named_object*,\n+\t\t\t\tsource_location> > Closure_fields;\n+\n+  // The function's type.\n+  Function_type* type_;\n+  // The enclosing function.  This is NULL when there isn't one, which\n+  // is the normal case.\n+  Function* enclosing_;\n+  // The result variables, if any.\n+  Results* results_;\n+  // If there is a closure, this is the list of variables which appear\n+  // in the closure.  This is created by the parser, and then resolved\n+  // to a real type when we lower parse trees.\n+  Closure_fields closure_fields_;\n+  // The closure variable, passed as a parameter using the static\n+  // chain parameter.  Normally NULL.\n+  Named_object* closure_var_;\n+  // The outer block of statements in the function.\n+  Block* block_;\n+  // The source location of the start of the function.\n+  source_location location_;\n+  // Labels defined or referenced in the function.\n+  Labels labels_;\n+  // The function decl.\n+  tree fndecl_;\n+  // The defer stack variable.  A pointer to this variable is used to\n+  // distinguish the defer stack for one function from another.  This\n+  // is NULL unless we actually need a defer stack.\n+  Temporary_statement* defer_stack_;\n+  // True if the result variables are named.\n+  bool results_are_named_;\n+  // True if this function calls the predeclared recover function.\n+  bool calls_recover_;\n+  // True if this a thunk built for a function which calls recover.\n+  bool is_recover_thunk_;\n+  // True if this function already has a recover thunk.\n+  bool has_recover_thunk_;\n+};\n+\n+// A function declaration.\n+\n+class Function_declaration\n+{\n+ public:\n+  Function_declaration(Function_type* fntype, source_location location)\n+    : fntype_(fntype), location_(location), asm_name_(), fndecl_(NULL)\n+  { }\n+\n+  Function_type*\n+  type() const\n+  { return this->fntype_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  const std::string&\n+  asm_name() const\n+  { return this->asm_name_; }\n+\n+  // Set the assembler name.\n+  void\n+  set_asm_name(const std::string& asm_name)\n+  { this->asm_name_ = asm_name; }\n+\n+  // Return a decl for the function given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Export a function declaration.\n+  void\n+  export_func(Export* exp, const std::string& name) const\n+  { Function::export_func_with_type(exp, name, this->fntype_); }\n+\n+ private:\n+  // The type of the function.\n+  Function_type* fntype_;\n+  // The location of the declaration.\n+  source_location location_;\n+  // The assembler name: this is the name to use in references to the\n+  // function.  This is normally empty.\n+  std::string asm_name_;\n+  // The function decl if needed.\n+  tree fndecl_;\n+};\n+\n+// A variable.\n+\n+class Variable\n+{\n+ public:\n+  Variable(Type*, Expression*, bool is_global, bool is_parameter,\n+\t   bool is_receiver, source_location);\n+\n+  // Get the type of the variable.\n+  Type*\n+  type();\n+\n+  Type*\n+  type() const;\n+\n+  // Return whether the type is defined yet.\n+  bool\n+  has_type() const\n+  { return this->type_ != NULL; }\n+\n+  // Get the initial value.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Return whether there are any preinit statements.\n+  bool\n+  has_pre_init() const\n+  { return this->preinit_ != NULL; }\n+\n+  // Return the preinit statements if any.\n+  Block*\n+  preinit() const\n+  { return this->preinit_; }\n+\n+  // Return whether this is a global variable.\n+  bool\n+  is_global() const\n+  { return this->is_global_; }\n+\n+  // Return whether this is a function parameter.\n+  bool\n+  is_parameter() const\n+  { return this->is_parameter_; }\n+\n+  // Return whether this is the receiver parameter of a method.\n+  bool\n+  is_receiver() const\n+  { return this->is_receiver_; }\n+\n+  // Change this parameter to be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_receiver()\n+  {\n+    go_assert(this->is_parameter_);\n+    this->is_receiver_ = true;\n+  }\n+\n+  // Change this parameter to not be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_not_receiver()\n+  {\n+    go_assert(this->is_parameter_);\n+    this->is_receiver_ = false;\n+  }\n+\n+  // Return whether this is the varargs parameter of a function.\n+  bool\n+  is_varargs_parameter() const\n+  { return this->is_varargs_parameter_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_ && !this->is_global_; }\n+\n+  // Get the source location of the variable's declaration.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Record that this is the varargs parameter of a function.\n+  void\n+  set_is_varargs_parameter()\n+  {\n+    go_assert(this->is_parameter_);\n+    this->is_varargs_parameter_ = true;\n+  }\n+\n+  // Clear the initial value; used for error handling.\n+  void\n+  clear_init()\n+  { this->init_ = NULL; }\n+\n+  // Set the initial value; used for converting shortcuts.\n+  void\n+  set_init(Expression* init)\n+  { this->init_ = init; }\n+\n+  // Get the preinit block, a block of statements to be run before the\n+  // initialization expression.\n+  Block*\n+  preinit_block(Gogo*);\n+\n+  // Add a statement to be run before the initialization expression.\n+  // This is only used for global variables.\n+  void\n+  add_preinit_statement(Gogo*, Statement*);\n+\n+  // Lower the initialization expression after parsing is complete.\n+  void\n+  lower_init_expression(Gogo*, Named_object*);\n+\n+  // A special case: the init value is used only to determine the\n+  // type.  This is used if the variable is defined using := with the\n+  // comma-ok form of a map index or a receive expression.  The init\n+  // value is actually the map index expression or receive expression.\n+  // We use this because we may not know the right type at parse time.\n+  void\n+  set_type_from_init_tuple()\n+  { this->type_from_init_tuple_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a range clause.  The init value is the range expression.  The\n+  // type of the variable is the index type of the range expression\n+  // (i.e., the first value returned by a range).\n+  void\n+  set_type_from_range_index()\n+  { this->type_from_range_index_ = true; }\n+\n+  // Another special case: like set_type_from_range_index, but the\n+  // type is the value type of the range expression (i.e., the second\n+  // value returned by a range).\n+  void\n+  set_type_from_range_value()\n+  { this->type_from_range_value_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a case in a select statement.  The init value is the channel.\n+  // The type of the variable is the channel's element type.\n+  void\n+  set_type_from_chan_element()\n+  { this->type_from_chan_element_ = true; }\n+\n+  // After we lower the select statement, we once again set the type\n+  // from the initialization expression.\n+  void\n+  clear_type_from_chan_element()\n+  {\n+    go_assert(this->type_from_chan_element_);\n+    this->type_from_chan_element_ = false;\n+  }\n+\n+  // Note that this variable was created for a type switch clause.\n+  void\n+  set_is_type_switch_var()\n+  { this->is_type_switch_var_ = true; }\n+\n+  // Traverse the initializer expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the variable if necessary.\n+  void\n+  determine_type();\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Get the backend representation of the variable.\n+  Bvariable*\n+  get_backend_variable(Gogo*, Named_object*, const Package*,\n+\t\t       const std::string&);\n+\n+  // Get the initial value of the variable as a tree.  This may only\n+  // be called if has_pre_init() returns false.\n+  tree\n+  get_init_tree(Gogo*, Named_object* function);\n+\n+  // Return a series of statements which sets the value of the\n+  // variable in DECL.  This should only be called is has_pre_init()\n+  // returns true.  DECL may be NULL for a sink variable.\n+  tree\n+  get_init_block(Gogo*, Named_object* function, tree decl);\n+\n+  // Export the variable.\n+  void\n+  export_var(Export*, const std::string& name) const;\n+\n+  // Import a variable.\n+  static void\n+  import_var(Import*, std::string* pname, Type** ptype);\n+\n+ private:\n+  // The type of a tuple.\n+  Type*\n+  type_from_tuple(Expression*, bool) const;\n+\n+  // The type of a range.\n+  Type*\n+  type_from_range(Expression*, bool, bool) const;\n+\n+  // The element type of a channel.\n+  Type*\n+  type_from_chan_element(Expression*, bool) const;\n+\n+  // The variable's type.  This may be NULL if the type is set from\n+  // the expression.\n+  Type* type_;\n+  // The initial value.  This may be NULL if the variable should be\n+  // initialized to the default value for the type.\n+  Expression* init_;\n+  // Statements to run before the init statement.\n+  Block* preinit_;\n+  // Location of variable definition.\n+  source_location location_;\n+  // Backend representation.\n+  Bvariable* backend_;\n+  // Whether this is a global variable.\n+  bool is_global_ : 1;\n+  // Whether this is a function parameter.\n+  bool is_parameter_ : 1;\n+  // Whether this is the receiver parameter of a method.\n+  bool is_receiver_ : 1;\n+  // Whether this is the varargs parameter of a function.\n+  bool is_varargs_parameter_ : 1;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_ : 1;\n+  // True if we have seen this variable in a traversal.\n+  bool seen_ : 1;\n+  // True if we have lowered the initialization expression.\n+  bool init_is_lowered_ : 1;\n+  // True if init is a tuple used to set the type.\n+  bool type_from_init_tuple_ : 1;\n+  // True if init is a range clause and the type is the index type.\n+  bool type_from_range_index_ : 1;\n+  // True if init is a range clause and the type is the value type.\n+  bool type_from_range_value_ : 1;\n+  // True if init is a channel and the type is the channel's element type.\n+  bool type_from_chan_element_ : 1;\n+  // True if this is a variable created for a type switch case.\n+  bool is_type_switch_var_ : 1;\n+  // True if we have determined types.\n+  bool determined_type_ : 1;\n+};\n+\n+// A variable which is really the name for a function return value, or\n+// part of one.\n+\n+class Result_variable\n+{\n+ public:\n+  Result_variable(Type* type, Function* function, int index,\n+\t\t  source_location location)\n+    : type_(type), function_(function), index_(index), location_(location),\n+      backend_(NULL), is_address_taken_(false)\n+  { }\n+\n+  // Get the type of the result variable.\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Get the function that this is associated with.\n+  Function*\n+  function() const\n+  { return this->function_; }\n+\n+  // Index in the list of function results.\n+  int\n+  index() const\n+  { return this->index_; }\n+\n+  // The location of the variable definition.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_; }\n+\n+  // Set the function.  This is used when cloning functions which call\n+  // recover.\n+  void\n+  set_function(Function* function)\n+  { this->function_ = function; }\n+\n+  // Get the backend representation of the variable.\n+  Bvariable*\n+  get_backend_variable(Gogo*, Named_object*, const std::string&);\n+\n+ private:\n+  // Type of result variable.\n+  Type* type_;\n+  // Function with which this is associated.\n+  Function* function_;\n+  // Index in list of results.\n+  int index_;\n+  // Where the result variable is defined.\n+  source_location location_;\n+  // Backend representation.\n+  Bvariable* backend_;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_;\n+};\n+\n+// The value we keep for a named constant.  This lets us hold a type\n+// and an expression.\n+\n+class Named_constant\n+{\n+ public:\n+  Named_constant(Type* type, Expression* expr, int iota_value,\n+\t\t source_location location)\n+    : type_(type), expr_(expr), iota_value_(iota_value), location_(location),\n+      lowering_(false)\n+  { }\n+\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+  int\n+  iota_value() const\n+  { return this->iota_value_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Whether we are lowering.\n+  bool\n+  lowering() const\n+  { return this->lowering_; }\n+\n+  // Set that we are lowering.\n+  void\n+  set_lowering()\n+  { this->lowering_ = true; }\n+\n+  // We are no longer lowering.\n+  void\n+  clear_lowering()\n+  { this->lowering_ = false; }\n+\n+  // Traverse the expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the constant if necessary.\n+  void\n+  determine_type();\n+\n+  // Indicate that we found and reported an error for this constant.\n+  void\n+  set_error();\n+\n+  // Export the constant.\n+  void\n+  export_const(Export*, const std::string& name) const;\n+\n+  // Import a constant.\n+  static void\n+  import_const(Import*, std::string*, Type**, Expression**);\n+\n+ private:\n+  // The type of the constant.\n+  Type* type_;\n+  // The expression for the constant.\n+  Expression* expr_;\n+  // If the predeclared constant iota is used in EXPR_, this is the\n+  // value it will have.  We do this because at parse time we don't\n+  // know whether the name \"iota\" will refer to the predeclared\n+  // constant or to something else.  We put in the right value in when\n+  // we lower.\n+  int iota_value_;\n+  // The location of the definition.\n+  source_location location_;\n+  // Whether we are currently lowering this constant.\n+  bool lowering_;\n+};\n+\n+// A type declaration.\n+\n+class Type_declaration\n+{\n+ public:\n+  Type_declaration(source_location location)\n+    : location_(location), in_function_(NULL), methods_(),\n+      issued_warning_(false)\n+  { }\n+\n+  // Return the location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the function in which this type is declared.  This will\n+  // return NULL for a type declared in global scope.\n+  Named_object*\n+  in_function()\n+  { return this->in_function_; }\n+\n+  // Set the function in which this type is declared.\n+  void\n+  set_in_function(Named_object* f)\n+  { this->in_function_ = f; }\n+\n+  // Add a method to this type.  This is used when methods are defined\n+  // before the type.\n+  Named_object*\n+  add_method(const std::string& name, Function* function);\n+\n+  // Add a method declaration to this type.\n+  Named_object*\n+  add_method_declaration(const std::string& name, Function_type* type,\n+\t\t\t source_location location);\n+\n+  // Return whether any methods were defined.\n+  bool\n+  has_methods() const;\n+\n+  // Define methods when the real type is known.\n+  void\n+  define_methods(Named_type*);\n+\n+  // This is called if we are trying to use this type.  It returns\n+  // true if we should issue a warning.\n+  bool\n+  using_type();\n+\n+ private:\n+  typedef std::vector<Named_object*> Methods;\n+\n+  // The location of the type declaration.\n+  source_location location_;\n+  // If this type is declared in a function, a pointer back to the\n+  // function in which it is defined.\n+  Named_object* in_function_;\n+  // Methods defined before the type is defined.\n+  Methods methods_;\n+  // True if we have issued a warning about a use of this type\n+  // declaration when it is undefined.\n+  bool issued_warning_;\n+};\n+\n+// An unknown object.  These are created by the parser for forward\n+// references to names which have not been seen before.  In a correct\n+// program, these will always point to a real definition by the end of\n+// the parse.  Because they point to another Named_object, these may\n+// only be referenced by Unknown_expression objects.\n+\n+class Unknown_name\n+{\n+ public:\n+  Unknown_name(source_location location)\n+    : location_(location), real_named_object_(NULL)\n+  { }\n+\n+  // Return the location where this name was first seen.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the real named object that this points to, or NULL if it\n+  // was never resolved.\n+  Named_object*\n+  real_named_object() const\n+  { return this->real_named_object_; }\n+\n+  // Set the real named object that this points to.\n+  void\n+  set_real_named_object(Named_object* no);\n+\n+ private:\n+  // The location where this name was first seen.\n+  source_location location_;\n+  // The real named object when it is known.\n+  Named_object*\n+  real_named_object_;\n+};\n+\n+// A named object named.  This is the result of a declaration.  We\n+// don't use a superclass because they all have to be handled\n+// differently.\n+\n+class Named_object\n+{\n+ public:\n+  enum Classification\n+  {\n+    // An uninitialized Named_object.  We should never see this.\n+    NAMED_OBJECT_UNINITIALIZED,\n+    // An unknown name.  This is used for forward references.  In a\n+    // correct program, these will all be resolved by the end of the\n+    // parse.\n+    NAMED_OBJECT_UNKNOWN,\n+    // A const.\n+    NAMED_OBJECT_CONST,\n+    // A type.\n+    NAMED_OBJECT_TYPE,\n+    // A forward type declaration.\n+    NAMED_OBJECT_TYPE_DECLARATION,\n+    // A var.\n+    NAMED_OBJECT_VAR,\n+    // A result variable in a function.\n+    NAMED_OBJECT_RESULT_VAR,\n+    // The blank identifier--the special variable named _.\n+    NAMED_OBJECT_SINK,\n+    // A func.\n+    NAMED_OBJECT_FUNC,\n+    // A forward func declaration.\n+    NAMED_OBJECT_FUNC_DECLARATION,\n+    // A package.\n+    NAMED_OBJECT_PACKAGE\n+  };\n+\n+  // Return the classification.\n+  Classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Classifiers.\n+\n+  bool\n+  is_unknown() const\n+  { return this->classification_ == NAMED_OBJECT_UNKNOWN; }\n+\n+  bool\n+  is_const() const\n+  { return this->classification_ == NAMED_OBJECT_CONST; }\n+\n+  bool\n+  is_type() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE; }\n+\n+  bool\n+  is_type_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE_DECLARATION; }\n+\n+  bool\n+  is_variable() const\n+  { return this->classification_ == NAMED_OBJECT_VAR; }\n+\n+  bool\n+  is_result_variable() const\n+  { return this->classification_ == NAMED_OBJECT_RESULT_VAR; }\n+\n+  bool\n+  is_sink() const\n+  { return this->classification_ == NAMED_OBJECT_SINK; }\n+\n+  bool\n+  is_function() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC; }\n+\n+  bool\n+  is_function_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC_DECLARATION; }\n+\n+  bool\n+  is_package() const\n+  { return this->classification_ == NAMED_OBJECT_PACKAGE; }\n+\n+  // Creators.\n+\n+  static Named_object*\n+  make_unknown_name(const std::string& name, source_location);\n+\n+  static Named_object*\n+  make_constant(const Typed_identifier&, const Package*, Expression*,\n+\t\tint iota_value);\n+\n+  static Named_object*\n+  make_type(const std::string&, const Package*, Type*, source_location);\n+\n+  static Named_object*\n+  make_type_declaration(const std::string&, const Package*, source_location);\n+\n+  static Named_object*\n+  make_variable(const std::string&, const Package*, Variable*);\n+\n+  static Named_object*\n+  make_result_variable(const std::string&, Result_variable*);\n+\n+  static Named_object*\n+  make_sink();\n+\n+  static Named_object*\n+  make_function(const std::string&, const Package*, Function*);\n+\n+  static Named_object*\n+  make_function_declaration(const std::string&, const Package*, Function_type*,\n+\t\t\t    source_location);\n+\n+  static Named_object*\n+  make_package(const std::string& alias, Package* package);\n+\n+  // Getters.\n+\n+  Unknown_name*\n+  unknown_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  const Unknown_name*\n+  unknown_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  Named_constant*\n+  const_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  const Named_constant*\n+  const_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  Named_type*\n+  type_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  const Named_type*\n+  type_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  Type_declaration*\n+  type_declaration_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  const Type_declaration*\n+  type_declaration_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  Variable*\n+  var_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  const Variable*\n+  var_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  Result_variable*\n+  result_var_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  const Result_variable*\n+  result_var_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  Function*\n+  func_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  const Function*\n+  func_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  Function_declaration*\n+  func_declaration_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  const Function_declaration*\n+  func_declaration_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  Package*\n+  package_value()\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const Package*\n+  package_value() const\n+  {\n+    go_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the name to use in an error message.  The difference is\n+  // that if this Named_object is defined in a different package, this\n+  // will return PACKAGE.NAME.\n+  std::string\n+  message_name() const;\n+\n+  const Package*\n+  package() const\n+  { return this->package_; }\n+\n+  // Resolve an unknown value if possible.  This returns the same\n+  // Named_object or a new one.\n+  Named_object*\n+  resolve()\n+  {\n+    Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tNamed_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  const Named_object*\n+  resolve() const\n+  {\n+    const Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tconst Named_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  // The location where this object was defined or referenced.\n+  source_location\n+  location() const;\n+\n+  // Convert a variable to the backend representation.\n+  Bvariable*\n+  get_backend_variable(Gogo*, Named_object* function);\n+\n+  // Return a tree for the external identifier for this object.\n+  tree\n+  get_id(Gogo*);\n+\n+  // Return a tree representing this object.\n+  tree\n+  get_tree(Gogo*, Named_object* function);\n+\n+  // Define a type declaration.\n+  void\n+  set_type_value(Named_type*);\n+\n+  // Define a function declaration.\n+  void\n+  set_function_value(Function*);\n+\n+  // Declare an unknown name as a type declaration.\n+  void\n+  declare_as_type();\n+\n+  // Export this object.\n+  void\n+  export_named_object(Export*) const;\n+\n+ private:\n+  Named_object(const std::string&, const Package*, Classification);\n+\n+  // The name of the object.\n+  std::string name_;\n+  // The package that this object is in.  This is NULL if it is in the\n+  // file we are compiling.\n+  const Package* package_;\n+  // The type of object this is.\n+  Classification classification_;\n+  // The real data.\n+  union\n+  {\n+    Unknown_name* unknown_value;\n+    Named_constant* const_value;\n+    Named_type* type_value;\n+    Type_declaration* type_declaration;\n+    Variable* var_value;\n+    Result_variable* result_var_value;\n+    Function* func_value;\n+    Function_declaration* func_declaration_value;\n+    Package* package_value;\n+  } u_;\n+  // The DECL tree for this object if we have already converted it.\n+  tree tree_;\n+};\n+\n+// A binding contour.  This binds names to objects.\n+\n+class Bindings\n+{\n+ public:\n+  // Type for mapping from names to objects.\n+  typedef Unordered_map(std::string, Named_object*) Contour;\n+\n+  Bindings(Bindings* enclosing);\n+\n+  // Add an unknown name.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_unknown_name(name,\n+\t\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, const Package* package,\n+\t       Expression* expr, int iota_value)\n+  {\n+    return this->add_named_object(Named_object::make_constant(tid, package,\n+\t\t\t\t\t\t\t      expr,\n+\t\t\t\t\t\t\t      iota_value));\n+  }\n+\n+  // Add a type.\n+  Named_object*\n+  add_type(const std::string& name, const Package* package, Type* type,\n+\t   source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_type(name, package, type,\n+\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  Named_object*\n+  add_named_type(Named_type* named_type);\n+\n+  // Add a type declaration.\n+  Named_object*\n+  add_type_declaration(const std::string& name, const Package* package,\n+\t\t       source_location location)\n+  {\n+    Named_object* no = Named_object::make_type_declaration(name, package,\n+\t\t\t\t\t\t\t   location);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string& name, const Package* package,\n+\t       Variable* variable)\n+  {\n+    return this->add_named_object(Named_object::make_variable(name, package,\n+\t\t\t\t\t\t\t      variable));\n+  }\n+\n+  // Add a result variable.\n+  Named_object*\n+  add_result_variable(const std::string& name, Result_variable* result)\n+  {\n+    return this->add_named_object(Named_object::make_result_variable(name,\n+\t\t\t\t\t\t\t\t     result));\n+  }\n+\n+  // Add a function.\n+  Named_object*\n+  add_function(const std::string& name, const Package*, Function* function);\n+\n+  // Add a function declaration.\n+  Named_object*\n+  add_function_declaration(const std::string& name, const Package* package,\n+\t\t\t   Function_type* type, source_location location);\n+\n+  // Add a package.  The location is the location of the import\n+  // statement.\n+  Named_object*\n+  add_package(const std::string& alias, Package* package)\n+  {\n+    Named_object* no = Named_object::make_package(alias, package);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a method to the list of objects.  This is not added to the\n+  // lookup table.\n+  void\n+  add_method(Named_object*);\n+\n+  // Add a named object to this binding.\n+  Named_object*\n+  add_named_object(Named_object* no)\n+  { return this->add_named_object_to_contour(&this->bindings_, no); }\n+\n+  // Clear all names in file scope from the bindings.\n+  void\n+  clear_file_scope();\n+\n+  // Look up a name in this binding contour and in any enclosing\n+  // binding contours.  This returns NULL if the name is not found.\n+  Named_object*\n+  lookup(const std::string&) const;\n+\n+  // Look up a name in this binding contour without looking in any\n+  // enclosing binding contours.  Returns NULL if the name is not found.\n+  Named_object*\n+  lookup_local(const std::string&) const;\n+\n+  // Remove a name.\n+  void\n+  remove_binding(Named_object*);\n+\n+  // Traverse the tree.  See the Traverse class.\n+  int\n+  traverse(Traverse*, bool is_global);\n+\n+  // Iterate over definitions.  This does not include things which\n+  // were only declared.\n+\n+  typedef std::vector<Named_object*>::const_iterator\n+    const_definitions_iterator;\n+\n+  const_definitions_iterator\n+  begin_definitions() const\n+  { return this->named_objects_.begin(); }\n+\n+  const_definitions_iterator\n+  end_definitions() const\n+  { return this->named_objects_.end(); }\n+\n+  // Return the number of definitions.\n+  size_t\n+  size_definitions() const\n+  { return this->named_objects_.size(); }\n+\n+  // Return whether there are no definitions.\n+  bool\n+  empty_definitions() const\n+  { return this->named_objects_.empty(); }\n+\n+  // Iterate over declarations.  This is everything that has been\n+  // declared, which includes everything which has been defined.\n+\n+  typedef Contour::const_iterator const_declarations_iterator;\n+\n+  const_declarations_iterator\n+  begin_declarations() const\n+  { return this->bindings_.begin(); }\n+\n+  const_declarations_iterator\n+  end_declarations() const\n+  { return this->bindings_.end(); }\n+\n+  // Return the number of declarations.\n+  size_t\n+  size_declarations() const\n+  { return this->bindings_.size(); }\n+\n+  // Return whether there are no declarations.\n+  bool\n+  empty_declarations() const\n+  { return this->bindings_.empty(); }\n+\n+  // Return the first declaration.\n+  Named_object*\n+  first_declaration()\n+  { return this->bindings_.empty() ? NULL : this->bindings_.begin()->second; }\n+\n+ private:\n+  Named_object*\n+  add_named_object_to_contour(Contour*, Named_object*);\n+\n+  Named_object*\n+  new_definition(Named_object*, Named_object*);\n+\n+  // Enclosing bindings.\n+  Bindings* enclosing_;\n+  // The list of objects.\n+  std::vector<Named_object*> named_objects_;\n+  // The mapping from names to objects.\n+  Contour bindings_;\n+};\n+\n+// A label.\n+\n+class Label\n+{\n+ public:\n+  Label(const std::string& name)\n+    : name_(name), location_(0), is_used_(false), blabel_(NULL)\n+  { }\n+\n+  // Return the label's name.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return whether the label has been defined.\n+  bool\n+  is_defined() const\n+  { return this->location_ != 0; }\n+\n+  // Return whether the label has been used.\n+  bool\n+  is_used() const\n+  { return this->is_used_; }\n+\n+  // Record that the label is used.\n+  void\n+  set_is_used()\n+  { this->is_used_ = true; }\n+\n+  // Return the location of the definition.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Define the label at LOCATION.\n+  void\n+  define(source_location location)\n+  {\n+    go_assert(this->location_ == 0);\n+    this->location_ = location;\n+  }\n+\n+  // Return the backend representation for this label.\n+  Blabel*\n+  get_backend_label(Translate_context*);\n+\n+  // Return an expression for the address of this label.  This is used\n+  // to get the return address of a deferred function to see whether\n+  // the function may call recover.\n+  Bexpression*\n+  get_addr(Translate_context*, source_location location);\n+\n+ private:\n+  // The name of the label.\n+  std::string name_;\n+  // The location of the definition.  This is 0 if the label has not\n+  // yet been defined.\n+  source_location location_;\n+  // Whether the label has been used.\n+  bool is_used_;\n+  // The backend representation.\n+  Blabel* blabel_;\n+};\n+\n+// An unnamed label.  These are used when lowering loops.\n+\n+class Unnamed_label\n+{\n+ public:\n+  Unnamed_label(source_location location)\n+    : location_(location), blabel_(NULL)\n+  { }\n+\n+  // Get the location where the label is defined.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Set the location where the label is defined.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Return a statement which defines this label.\n+  Bstatement*\n+  get_definition(Translate_context*);\n+\n+  // Return a goto to this label from LOCATION.\n+  Bstatement*\n+  get_goto(Translate_context*, source_location location);\n+\n+ private:\n+  // Return the backend representation.\n+  Blabel*\n+  get_blabel(Translate_context*);\n+\n+  // The location where the label is defined.\n+  source_location location_;\n+  // The backend representation of this label.\n+  Blabel* blabel_;\n+};\n+\n+// An imported package.\n+\n+class Package\n+{\n+ public:\n+  Package(const std::string& name, const std::string& unique_prefix,\n+\t  source_location location);\n+\n+  // The real name of this package.  This may be different from the\n+  // name in the associated Named_object if the import statement used\n+  // an alias.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the location of the import statement.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Get the unique prefix used for all symbols exported from this\n+  // package.\n+  const std::string&\n+  unique_prefix() const\n+  {\n+    go_assert(!this->unique_prefix_.empty());\n+    return this->unique_prefix_;\n+  }\n+\n+  // The priority of this package.  The init function of packages with\n+  // lower priority must be run before the init function of packages\n+  // with higher priority.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+  // Set the priority.\n+  void\n+  set_priority(int priority);\n+\n+  // Return the bindings.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  // Whether some symbol from the package was used.\n+  bool\n+  used() const\n+  { return this->used_; }\n+\n+  // Note that some symbol from this package was used.\n+  void\n+  set_used() const\n+  { this->used_ = true; }\n+\n+  // Clear the used field for the next file.\n+  void\n+  clear_used()\n+  { this->used_ = false; }\n+\n+  // Whether this package was imported in the current file.\n+  bool\n+  is_imported() const\n+  { return this->is_imported_; }\n+\n+  // Note that this package was imported in the current file.\n+  void\n+  set_is_imported()\n+  { this->is_imported_ = true; }\n+\n+  // Clear the imported field for the next file.\n+  void\n+  clear_is_imported()\n+  { this->is_imported_ = false; }\n+\n+  // Whether this package was imported with a name of \"_\".\n+  bool\n+  uses_sink_alias() const\n+  { return this->uses_sink_alias_; }\n+\n+  // Note that this package was imported with a name of \"_\".\n+  void\n+  set_uses_sink_alias()\n+  { this->uses_sink_alias_ = true; }\n+\n+  // Clear the sink alias field for the next file.\n+  void\n+  clear_uses_sink_alias()\n+  { this->uses_sink_alias_ = false; }\n+\n+  // Look up a name in the package.  Returns NULL if the name is not\n+  // found.\n+  Named_object*\n+  lookup(const std::string& name) const\n+  { return this->bindings_->lookup(name); }\n+\n+  // Set the location of the package.  This is used if it is seen in a\n+  // different import before it is really imported.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Add a constant to the package.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, Expression* expr)\n+  { return this->bindings_->add_constant(tid, this, expr, 0); }\n+\n+  // Add a type to the package.\n+  Named_object*\n+  add_type(const std::string& name, Type* type, source_location location)\n+  { return this->bindings_->add_type(name, this, type, location); }\n+\n+  // Add a type declaration to the package.\n+  Named_object*\n+  add_type_declaration(const std::string& name, source_location location)\n+  { return this->bindings_->add_type_declaration(name, this, location); }\n+\n+  // Add a variable to the package.\n+  Named_object*\n+  add_variable(const std::string& name, Variable* variable)\n+  { return this->bindings_->add_variable(name, this, variable); }\n+\n+  // Add a function declaration to the package.\n+  Named_object*\n+  add_function_declaration(const std::string& name, Function_type* type,\n+\t\t\t   source_location loc)\n+  { return this->bindings_->add_function_declaration(name, this, type, loc); }\n+\n+  // Determine types of constants.\n+  void\n+  determine_types();\n+\n+ private:\n+  // The real name of this package.\n+  std::string name_;\n+  // The unique prefix for all exported global symbols.\n+  std::string unique_prefix_;\n+  // The names in this package.\n+  Bindings* bindings_;\n+  // The priority of this package.  A package has a priority higher\n+  // than the priority of all of the packages that it imports.  This\n+  // is used to run init functions in the right order.\n+  int priority_;\n+  // The location of the import statement.\n+  source_location location_;\n+  // True if some name from this package was used.  This is mutable\n+  // because we can use a package even if we have a const pointer to\n+  // it.\n+  mutable bool used_;\n+  // True if this package was imported in the current file.\n+  bool is_imported_;\n+  // True if this package was imported with a name of \"_\".\n+  bool uses_sink_alias_;\n+};\n+\n+// Return codes for the traversal functions.  This is not an enum\n+// because we want to be able to declare traversal functions in other\n+// header files without including this one.\n+\n+// Continue traversal as usual.\n+const int TRAVERSE_CONTINUE = -1;\n+\n+// Exit traversal.\n+const int TRAVERSE_EXIT = 0;\n+\n+// Continue traversal, but skip components of the current object.\n+// E.g., if this is returned by Traverse::statement, we do not\n+// traverse the expressions in the statement even if\n+// traverse_expressions is set in the traverse_mask.\n+const int TRAVERSE_SKIP_COMPONENTS = 1;\n+\n+// This class is used when traversing the parse tree.  The caller uses\n+// a subclass which overrides functions as desired.\n+\n+class Traverse\n+{\n+ public:\n+  // These bitmasks say what to traverse.\n+  static const unsigned int traverse_variables =    0x1;\n+  static const unsigned int traverse_constants =    0x2;\n+  static const unsigned int traverse_functions =    0x4;\n+  static const unsigned int traverse_blocks =       0x8;\n+  static const unsigned int traverse_statements =  0x10;\n+  static const unsigned int traverse_expressions = 0x20;\n+  static const unsigned int traverse_types =       0x40;\n+\n+  Traverse(unsigned int traverse_mask)\n+    : traverse_mask_(traverse_mask), types_seen_(NULL), expressions_seen_(NULL)\n+  { }\n+\n+  virtual ~Traverse();\n+\n+  // The bitmask of what to traverse.\n+  unsigned int\n+  traverse_mask() const\n+  { return this->traverse_mask_; }\n+\n+  // Record that we are going to traverse a type.  This returns true\n+  // if the type has already been seen in this traversal.  This is\n+  // required because types, unlike expressions, can form a circular\n+  // graph.\n+  bool\n+  remember_type(const Type*);\n+\n+  // Record that we are going to see an expression.  This returns true\n+  // if the expression has already been seen in this traversal.  This\n+  // is only needed for cases where multiple expressions can point to\n+  // a single one.\n+  bool\n+  remember_expression(const Expression*);\n+\n+  // These functions return one of the TRAVERSE codes defined above.\n+\n+  // If traverse_variables is set in the mask, this is called for\n+  // every variable in the tree.\n+  virtual int\n+  variable(Named_object*);\n+\n+  // If traverse_constants is set in the mask, this is called for\n+  // every named constant in the tree.  The bool parameter is true for\n+  // a global constant.\n+  virtual int\n+  constant(Named_object*, bool);\n+\n+  // If traverse_functions is set in the mask, this is called for\n+  // every function in the tree.\n+  virtual int\n+  function(Named_object*);\n+\n+  // If traverse_blocks is set in the mask, this is called for every\n+  // block in the tree.\n+  virtual int\n+  block(Block*);\n+\n+  // If traverse_statements is set in the mask, this is called for\n+  // every statement in the tree.\n+  virtual int\n+  statement(Block*, size_t* index, Statement*);\n+\n+  // If traverse_expressions is set in the mask, this is called for\n+  // every expression in the tree.\n+  virtual int\n+  expression(Expression**);\n+\n+  // If traverse_types is set in the mask, this is called for every\n+  // type in the tree.\n+  virtual int\n+  type(Type*);\n+\n+ private:\n+  typedef Unordered_set_hash(const Type*, Type_hash_identical,\n+\t\t\t     Type_identical) Types_seen;\n+\n+  typedef Unordered_set(const Expression*) Expressions_seen;\n+\n+  // Bitmask of what sort of objects to traverse.\n+  unsigned int traverse_mask_;\n+  // Types which have been seen in this traversal.\n+  Types_seen* types_seen_;\n+  // Expressions which have been seen in this traversal.\n+  Expressions_seen* expressions_seen_;\n+};\n+\n+// When translating the gogo IR into the backend data structure, this\n+// is the context we pass down the blocks and statements.\n+\n+class Translate_context\n+{\n+ public:\n+  Translate_context(Gogo* gogo, Named_object* function, Block* block,\n+\t\t    Bblock* bblock)\n+    : gogo_(gogo), backend_(gogo->backend()), function_(function),\n+      block_(block), bblock_(bblock), is_const_(false)\n+  { }\n+\n+  // Accessors.\n+\n+  Gogo*\n+  gogo()\n+  { return this->gogo_; }\n+\n+  Backend*\n+  backend()\n+  { return this->backend_; }\n+\n+  Named_object*\n+  function()\n+  { return this->function_; }\n+\n+  Block*\n+  block()\n+  { return this->block_; }\n+\n+  Bblock*\n+  bblock()\n+  { return this->bblock_; }\n+\n+  bool\n+  is_const()\n+  { return this->is_const_; }\n+\n+  // Make a constant context.\n+  void\n+  set_is_const()\n+  { this->is_const_ = true; }\n+\n+ private:\n+  // The IR for the entire compilation unit.\n+  Gogo* gogo_;\n+  // The generator for the backend data structures.\n+  Backend* backend_;\n+  // The function we are currently translating.  NULL if not in a\n+  // function, e.g., the initializer of a global variable.\n+  Named_object* function_;\n+  // The block we are currently translating.  NULL if not in a\n+  // function.\n+  Block *block_;\n+  // The backend representation of the current block.  NULL if block_\n+  // is NULL.\n+  Bblock* bblock_;\n+  // Whether this is being evaluated in a constant context.  This is\n+  // used for type descriptor initializers.\n+  bool is_const_;\n+};\n+\n+// Runtime error codes.  These must match the values in\n+// libgo/runtime/go-runtime-error.c.\n+\n+// Slice index out of bounds: negative or larger than the length of\n+// the slice.\n+static const int RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS = 0;\n+\n+// Array index out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS = 1;\n+\n+// String index out of bounds.\n+static const int RUNTIME_ERROR_STRING_INDEX_OUT_OF_BOUNDS = 2;\n+\n+// Slice slice out of bounds: negative or larger than the length of\n+// the slice or high bound less than low bound.\n+static const int RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS = 3;\n+\n+// Array slice out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS = 4;\n+\n+// String slice out of bounds.\n+static const int RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS = 5;\n+\n+// Dereference of nil pointer.  This is used when there is a\n+// dereference of a pointer to a very large struct or array, to ensure\n+// that a gigantic array is not used a proxy to access random memory\n+// locations.\n+static const int RUNTIME_ERROR_NIL_DEREFERENCE = 6;\n+\n+// Slice length or capacity out of bounds in make: negative or\n+// overflow or length greater than capacity.\n+static const int RUNTIME_ERROR_MAKE_SLICE_OUT_OF_BOUNDS = 7;\n+\n+// Map capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 8;\n+\n+// Channel capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 9;\n+\n+// This is used by some of the langhooks.\n+extern Gogo* go_get_gogo();\n+\n+// Whether we have seen any errors.  FIXME: Replace with a backend\n+// interface.\n+extern bool saw_errors();\n+\n+#endif // !defined(GO_GOGO_H)"}, {"sha": "7a887a54296db8e9d548eee6f337f135f34ced1c", "filename": "gcc/go/gofrontend/gogo.h.working", "status": "added", "additions": 2537, "deletions": 0, "changes": 2537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.h.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fgogo.h.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,2537 @@\n+// gogo.h -- Go frontend parsed representation.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_GOGO_H\n+#define GO_GOGO_H\n+\n+class Traverse;\n+class Type;\n+class Type_hash_identical;\n+class Type_equal;\n+class Type_identical;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Expression;\n+class Statement;\n+class Block;\n+class Function;\n+class Bindings;\n+class Package;\n+class Variable;\n+class Pointer_type;\n+class Struct_type;\n+class Struct_field;\n+class Struct_field_list;\n+class Array_type;\n+class Map_type;\n+class Channel_type;\n+class Interface_type;\n+class Named_type;\n+class Forward_declaration_type;\n+class Method;\n+class Methods;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Export;\n+class Import;\n+\n+// This file declares the basic classes used to hold the internal\n+// representation of Go which is built by the parser.\n+\n+// An initialization function for an imported package.  This is a\n+// magic function which initializes variables and runs the \"init\"\n+// function.\n+\n+class Import_init\n+{\n+ public:\n+  Import_init(const std::string& package_name, const std::string& init_name,\n+\t      int priority)\n+    : package_name_(package_name), init_name_(init_name), priority_(priority)\n+  { }\n+\n+  // The name of the package being imported.\n+  const std::string&\n+  package_name() const\n+  { return this->package_name_; }\n+\n+  // The name of the package's init function.\n+  const std::string&\n+  init_name() const\n+  { return this->init_name_; }\n+\n+  // The priority of the initialization function.  Functions with a\n+  // lower priority number must be run first.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+ private:\n+  // The name of the package being imported.\n+  std::string package_name_;\n+  // The name of the package's init function.\n+  std::string init_name_;\n+  // The priority.\n+  int priority_;\n+};\n+\n+// For sorting purposes.\n+\n+inline bool\n+operator<(const Import_init& i1, const Import_init& i2)\n+{\n+  if (i1.priority() < i2.priority())\n+    return true;\n+  if (i1.priority() > i2.priority())\n+    return false;\n+  if (i1.package_name() != i2.package_name())\n+    return i1.package_name() < i2.package_name();\n+  return i1.init_name() < i2.init_name();\n+}\n+\n+// The holder for the internal representation of the entire\n+// compilation unit.\n+\n+class Gogo\n+{\n+ public:\n+  // Create the IR, passing in the sizes of the types \"int\" and\n+  // \"uintptr\" in bits.\n+  Gogo(int int_type_size, int pointer_size);\n+\n+  // Get the package name.\n+  const std::string&\n+  package_name() const;\n+\n+  // Set the package name.\n+  void\n+  set_package_name(const std::string&, source_location);\n+\n+  // Return whether this is the \"main\" package.\n+  bool\n+  is_main_package() const;\n+\n+  // If necessary, adjust the name to use for a hidden symbol.  We add\n+  // a prefix of the package name, so that hidden symbols in different\n+  // packages do not collide.\n+  std::string\n+  pack_hidden_name(const std::string& name, bool is_exported) const\n+  {\n+    return (is_exported\n+\t    ? name\n+\t    : ('.' + this->unique_prefix()\n+\t       + '.' + this->package_name()\n+\t       + '.' + name));\n+  }\n+\n+  // Unpack a name which may have been hidden.  Returns the\n+  // user-visible name of the object.\n+  static std::string\n+  unpack_hidden_name(const std::string& name)\n+  { return name[0] != '.' ? name : name.substr(name.rfind('.') + 1); }\n+\n+  // Return whether a possibly packed name is hidden.\n+  static bool\n+  is_hidden_name(const std::string& name)\n+  { return name[0] == '.'; }\n+\n+  // Return the package prefix of a hidden name.\n+  static std::string\n+  hidden_name_prefix(const std::string& name)\n+  {\n+    gcc_assert(Gogo::is_hidden_name(name));\n+    return name.substr(1, name.rfind('.') - 1);\n+  }\n+\n+  // Given a name which may or may not have been hidden, return the\n+  // name to use in an error message.\n+  static std::string\n+  message_name(const std::string& name);\n+\n+  // Return whether a name is the blank identifier _.\n+  static bool\n+  is_sink_name(const std::string& name)\n+  {\n+    return (name[0] == '.'\n+\t    && name[name.length() - 1] == '_'\n+\t    && name[name.length() - 2] == '.');\n+  }\n+\n+  // Return the unique prefix to use for all exported symbols.\n+  const std::string&\n+  unique_prefix() const;\n+\n+  // Set the unique prefix.\n+  void\n+  set_unique_prefix(const std::string&);\n+\n+  // Return the priority to use for the package we are compiling.\n+  // This is two more than the largest priority of any package we\n+  // import.\n+  int\n+  package_priority() const;\n+\n+  // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n+  // is the local name to give to the package.  If LOCAL_NAME is empty\n+  // the declarations are added to the global scope.\n+  void\n+  import_package(const std::string& filename, const std::string& local_name,\n+\t\t bool is_local_name_exported, source_location);\n+\n+  // Whether we are the global binding level.\n+  bool\n+  in_global_scope() const;\n+\n+  // Look up a name in the current binding contours.\n+  Named_object*\n+  lookup(const std::string&, Named_object** pfunction) const;\n+\n+  // Look up a name in the current block.\n+  Named_object*\n+  lookup_in_block(const std::string&) const;\n+\n+  // Look up a name in the global namespace--the universal scope.\n+  Named_object*\n+  lookup_global(const char*) const;\n+\n+  // Add a new imported package.  REAL_NAME is the real name of the\n+  // package.  ALIAS is the alias of the package; this may be the same\n+  // as REAL_NAME.  This sets *PADD_TO_GLOBALS if symbols added to\n+  // this package should be added to the global namespace; this is\n+  // true if the alias is \".\".  LOCATION is the location of the import\n+  // statement.  This returns the new package, or NULL on error.\n+  Package*\n+  add_imported_package(const std::string& real_name, const std::string& alias,\n+\t\t       bool is_alias_exported,\n+\t\t       const std::string& unique_prefix,\n+\t\t       source_location location,\n+\t\t       bool* padd_to_globals);\n+\n+  // Register a package.  This package may or may not be imported.\n+  // This returns the Package structure for the package, creating if\n+  // it necessary.\n+  Package*\n+  register_package(const std::string& name, const std::string& unique_prefix,\n+\t\t   source_location);\n+\n+  // Start compiling a function.  ADD_METHOD_TO_TYPE is true if a\n+  // method function should be added to the type of its receiver.\n+  Named_object*\n+  start_function(const std::string& name, Function_type* type,\n+\t\t bool add_method_to_type, source_location);\n+\n+  // Finish compiling a function.\n+  void\n+  finish_function(source_location);\n+\n+  // Return the current function.\n+  Named_object*\n+  current_function() const;\n+\n+  // Start a new block.  This is not initially associated with a\n+  // function.\n+  void\n+  start_block(source_location);\n+\n+  // Finish the current block and return it.\n+  Block*\n+  finish_block(source_location);\n+\n+  // Declare an unknown name.  This is used while parsing.  The name\n+  // must be resolved by the end of the parse.  Unknown names are\n+  // always added at the package level.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location);\n+\n+  // Declare a function.\n+  Named_object*\n+  declare_function(const std::string&, Function_type*, source_location);\n+\n+  // Add a label.\n+  Label*\n+  add_label_definition(const std::string&, source_location);\n+\n+  // Add a label reference.\n+  Label*\n+  add_label_reference(const std::string&);\n+\n+  // Add a statement to the current block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a block to the current block.\n+  void\n+  add_block(Block*, source_location);\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier&, Expression*, int iota_value);\n+\n+  // Add a type.\n+  void\n+  add_type(const std::string&, Type*, source_location);\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  void\n+  add_named_type(Named_type*);\n+\n+  // Declare a type.\n+  Named_object*\n+  declare_type(const std::string&, source_location);\n+\n+  // Declare a type at the package level.  This is used when the\n+  // parser sees an unknown name where a type name is required.\n+  Named_object*\n+  declare_package_type(const std::string&, source_location);\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string&, Variable*);\n+\n+  // Add a sink--a reference to the blank identifier _.\n+  Named_object*\n+  add_sink();\n+\n+  // Add a named object to the current namespace.  This is used for\n+  // import . \"package\".\n+  void\n+  add_named_object(Named_object*);\n+\n+  // Return a name to use for a thunk function.  A thunk function is\n+  // one we create during the compilation, for a go statement or a\n+  // defer statement or a method expression.\n+  static std::string\n+  thunk_name();\n+\n+  // Return whether an object is a thunk.\n+  static bool\n+  is_thunk(const Named_object*);\n+\n+  // Note that we've seen an interface type.  This is used to build\n+  // all required interface method tables.\n+  void\n+  record_interface_type(Interface_type*);\n+\n+  // Note that we need an initialization function.\n+  void\n+  set_need_init_fn()\n+  { this->need_init_fn_ = true; }\n+\n+  // Clear out all names in file scope.  This is called when we start\n+  // parsing a new file.\n+  void\n+  clear_file_scope();\n+\n+  // Traverse the tree.  See the Traverse class.\n+  void\n+  traverse(Traverse*);\n+\n+  // Define the predeclared global names.\n+  void\n+  define_global_names();\n+\n+  // Verify and complete all types.\n+  void\n+  verify_types();\n+\n+  // Lower the parse tree.\n+  void\n+  lower_parse_tree();\n+\n+  // Lower all the statements in a block.\n+  void\n+  lower_block(Named_object* function, Block*);\n+\n+  // Lower an expression.\n+  void\n+  lower_expression(Named_object* function, Expression**);\n+\n+  // Lower a constant.\n+  void\n+  lower_constant(Named_object*);\n+\n+  // Finalize the method lists and build stub methods for named types.\n+  void\n+  finalize_methods();\n+\n+  // Work out the types to use for unspecified variables and\n+  // constants.\n+  void\n+  determine_types();\n+\n+  // Type check the program.\n+  void\n+  check_types();\n+\n+  // Check the types in a single block.  This is used for complicated\n+  // go statements.\n+  void\n+  check_types_in_block(Block*);\n+\n+  // Check for return statements.\n+  void\n+  check_return_statements();\n+\n+  // Do all exports.\n+  void\n+  do_exports();\n+\n+  // Add an import control function for an imported package to the\n+  // list.\n+  void\n+  add_import_init_fn(const std::string& package_name,\n+\t\t     const std::string& init_name, int prio);\n+\n+  // Turn short-cut operators (&&, ||) into explicit if statements.\n+  void\n+  remove_shortcuts();\n+\n+  // Use temporary variables to force order of evaluation.\n+  void\n+  order_evaluations();\n+\n+  // Build thunks for functions which call recover.\n+  void\n+  build_recover_thunks();\n+\n+  // Simplify statements which might use thunks: go and defer\n+  // statements.\n+  void\n+  simplify_thunk_statements();\n+\n+  // Convert named types to the backend representation.\n+  void\n+  convert_named_types();\n+\n+  // Convert named types in a list of bindings.\n+  void\n+  convert_named_types_in_bindings(Bindings*);\n+\n+  // True if named types have been converted to the backend\n+  // representation.\n+  bool\n+  named_types_are_converted() const\n+  { return this->named_types_are_converted_; }\n+\n+  // Write out the global values.\n+  void\n+  write_globals();\n+\n+  // Build a call to a builtin function.  PDECL should point to a NULL\n+  // initialized static pointer which will hold the fndecl.  NAME is\n+  // the name of the function.  NARGS is the number of arguments.\n+  // RETTYPE is the return type.  It is followed by NARGS pairs of\n+  // type and argument (both trees).\n+  static tree\n+  call_builtin(tree* pdecl, source_location, const char* name, int nargs,\n+\t       tree rettype, ...);\n+\n+  // Build a call to the runtime error function.\n+  static tree\n+  runtime_error(int code, source_location);\n+\n+  // Build a builtin struct with a list of fields.\n+  static tree\n+  builtin_struct(tree* ptype, const char* struct_name, tree struct_type,\n+\t\t int nfields, ...);\n+\n+  // Mark a function declaration as a builtin library function.\n+  static void\n+  mark_fndecl_as_builtin_library(tree fndecl);\n+\n+  // Build the type of the struct that holds a slice for the given\n+  // element type.\n+  tree\n+  slice_type_tree(tree element_type_tree);\n+\n+  // Given a tree for a slice type, return the tree for the element\n+  // type.\n+  static tree\n+  slice_element_type_tree(tree slice_type_tree);\n+\n+  // Build a constructor for a slice.  SLICE_TYPE_TREE is the type of\n+  // the slice.  VALUES points to the values.  COUNT is the size,\n+  // CAPACITY is the capacity.  If CAPACITY is NULL, it is set to\n+  // COUNT.\n+  static tree\n+  slice_constructor(tree slice_type_tree, tree values, tree count,\n+\t\t    tree capacity);\n+\n+  // Build a constructor for an empty slice.  SLICE_TYPE_TREE is the\n+  // type of the slice.\n+  static tree\n+  empty_slice_constructor(tree slice_type_tree);\n+\n+  // Build a map descriptor.\n+  tree\n+  map_descriptor(Map_type*);\n+\n+  // Return a tree for the type of a map descriptor.  This is struct\n+  // __go_map_descriptor in libgo/runtime/map.h.  This is the same for\n+  // all map types.\n+  tree\n+  map_descriptor_type();\n+\n+  // Build a type descriptor for TYPE using INITIALIZER as the type\n+  // descriptor.  This builds a new decl stored in *PDECL.\n+  void\n+  build_type_descriptor_decl(const Type*, Expression* initializer,\n+\t\t\t     tree* pdecl);\n+\n+  // Build required interface method tables.\n+  void\n+  build_interface_method_tables();\n+\n+  // Build an interface method table for a type: a list of function\n+  // pointers, one for each interface method.  This returns a decl.\n+  tree\n+  interface_method_table_for_type(const Interface_type*, Named_type*,\n+\t\t\t\t  bool is_pointer);\n+\n+  // Return a tree which allocate SIZE bytes to hold values of type\n+  // TYPE.\n+  tree\n+  allocate_memory(Type *type, tree size, source_location);\n+\n+  // Return a type to use for pointer to const char.\n+  static tree\n+  const_char_pointer_type_tree();\n+\n+  // Build a string constant with the right type.\n+  static tree\n+  string_constant_tree(const std::string&);\n+\n+  // Build a Go string constant.  This returns a pointer to the\n+  // constant.\n+  tree\n+  go_string_constant_tree(const std::string&);\n+\n+  // Send a value on a channel.\n+  static tree\n+  send_on_channel(tree channel, tree val, bool blocking, bool for_select,\n+\t\t  source_location);\n+\n+  // Receive a value from a channel.\n+  static tree\n+  receive_from_channel(tree type_tree, tree channel, bool for_select,\n+\t\t       source_location);\n+\n+  // Return a tree for receiving an integer on a channel.\n+  static tree\n+  receive_as_64bit_integer(tree type, tree channel, bool blocking,\n+\t\t\t   bool for_select);\n+\n+\n+  // Make a trampoline which calls FNADDR passing CLOSURE.\n+  tree\n+  make_trampoline(tree fnaddr, tree closure, source_location);\n+\n+ private:\n+  // During parsing, we keep a stack of functions.  Each function on\n+  // the stack is one that we are currently parsing.  For each\n+  // function, we keep track of the current stack of blocks.\n+  struct Open_function\n+  {\n+    // The function.\n+    Named_object* function;\n+    // The stack of active blocks in the function.\n+    std::vector<Block*> blocks;\n+  };\n+\n+  // The stack of functions.\n+  typedef std::vector<Open_function> Open_functions;\n+\n+  // Create trees for implicit builtin functions.\n+  void\n+  define_builtin_function_trees();\n+\n+  // Set up the built-in unsafe package.\n+  void\n+  import_unsafe(const std::string&, bool is_exported, source_location);\n+\n+  // Add a new imported package.\n+  Named_object*\n+  add_package(const std::string& real_name, const std::string& alias,\n+\t      const std::string& unique_prefix, source_location location);\n+\n+  // Return the current binding contour.\n+  Bindings*\n+  current_bindings();\n+\n+  const Bindings*\n+  current_bindings() const;\n+\n+  // Return the current block.\n+  Block*\n+  current_block();\n+\n+  // Get the name of the magic initialization function.\n+  const std::string&\n+  get_init_fn_name();\n+\n+  // Get the decl for the magic initialization function.\n+  tree\n+  initialization_function_decl();\n+\n+  // Write the magic initialization function.\n+  void\n+  write_initialization_function(tree fndecl, tree init_stmt_list);\n+\n+  // Initialize imported packages.\n+  void\n+  init_imports(tree*);\n+\n+  // Register variables with the garbage collector.\n+  void\n+  register_gc_vars(const std::vector<Named_object*>&, tree*);\n+\n+  // Build a pointer to a Go string constant.  This returns a pointer\n+  // to the pointer.\n+  tree\n+  ptr_go_string_constant_tree(const std::string&);\n+\n+  // Return the name to use for a type descriptor decl for an unnamed\n+  // type.\n+  std::string\n+  unnamed_type_descriptor_decl_name(const Type* type);\n+\n+  // Return the name to use for a type descriptor decl for a type\n+  // named NO, defined in IN_FUNCTION.\n+  std::string\n+  type_descriptor_decl_name(const Named_object* no,\n+\t\t\t    const Named_object* in_function);\n+\n+  // Where a type descriptor should be defined.\n+  enum Type_descriptor_location\n+    {\n+      // Defined in this file.\n+      TYPE_DESCRIPTOR_DEFINED,\n+      // Defined in some other file.\n+      TYPE_DESCRIPTOR_UNDEFINED,\n+      // Common definition which may occur in multiple files.\n+      TYPE_DESCRIPTOR_COMMON\n+    };\n+\n+  // Return where the decl for TYPE should be defined.\n+  Type_descriptor_location\n+  type_descriptor_location(const Type* type);\n+\n+  // Return the type of a trampoline.\n+  static tree\n+  trampoline_type_tree();\n+\n+  // Type used to map import names to packages.\n+  typedef std::map<std::string, Package*> Imports;\n+\n+  // Type used to map package names to packages.\n+  typedef std::map<std::string, Package*> Packages;\n+\n+  // Type used to map special names in the sys package.\n+  typedef std::map<std::string, std::string> Sys_names;\n+\n+  // Hash table mapping map types to map descriptor decls.\n+  typedef Unordered_map_hash(const Map_type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Map_descriptors;\n+\n+  // Map unnamed types to type descriptor decls.\n+  typedef Unordered_map_hash(const Type*, tree, Type_hash_identical,\n+\t\t\t     Type_identical) Type_descriptor_decls;\n+\n+  // The package we are compiling.\n+  Package* package_;\n+  // The list of currently open functions during parsing.\n+  Open_functions functions_;\n+  // The global binding contour.  This includes the builtin functions\n+  // and the package we are compiling.\n+  Bindings* globals_;\n+  // Mapping from import file names to packages.\n+  Imports imports_;\n+  // Whether the magic unsafe package was imported.\n+  bool imported_unsafe_;\n+  // Mapping from package names we have seen to packages.  This does\n+  // not include the package we are compiling.\n+  Packages packages_;\n+  // Mapping from map types to map descriptors.\n+  Map_descriptors* map_descriptors_;\n+  // Mapping from unnamed types to type descriptor decls.\n+  Type_descriptor_decls* type_descriptor_decls_;\n+  // The functions named \"init\", if there are any.\n+  std::vector<Named_object*> init_functions_;\n+  // Whether we need a magic initialization function.\n+  bool need_init_fn_;\n+  // The name of the magic initialization function.\n+  std::string init_fn_name_;\n+  // A list of import control variables for packages that we import.\n+  std::set<Import_init> imported_init_fns_;\n+  // The unique prefix used for all global symbols.\n+  std::string unique_prefix_;\n+  // Whether an explicit unique prefix was set by -fgo-prefix.\n+  bool unique_prefix_specified_;\n+  // A list of interface types defined while parsing.\n+  std::vector<Interface_type*> interface_types_;\n+  // Whether named types have been converted.\n+  bool named_types_are_converted_;\n+};\n+\n+// A block of statements.\n+\n+class Block\n+{\n+ public:\n+  Block(Block* enclosing, source_location);\n+\n+  // Return the enclosing block.\n+  const Block*\n+  enclosing() const\n+  { return this->enclosing_; }\n+\n+  // Return the bindings of the block.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  const Bindings*\n+  bindings() const\n+  { return this->bindings_; }\n+\n+  // Look at the block's statements.\n+  const std::vector<Statement*>*\n+  statements() const\n+  { return &this->statements_; }\n+\n+  // Return the start location.  This is normally the location of the\n+  // left curly brace which starts the block.\n+  source_location\n+  start_location() const\n+  { return this->start_location_; }\n+\n+  // Return the end location.  This is normally the location of the\n+  // right curly brace which ends the block.\n+  source_location\n+  end_location() const\n+  { return this->end_location_; }\n+\n+  // Add a statement to the block.\n+  void\n+  add_statement(Statement*);\n+\n+  // Add a statement to the front of the block.\n+  void\n+  add_statement_at_front(Statement*);\n+\n+  // Replace a statement in a block.\n+  void\n+  replace_statement(size_t index, Statement*);\n+\n+  // Add a Statement before statement number INDEX.\n+  void\n+  insert_statement_before(size_t index, Statement*);\n+\n+  // Add a Statement after statement number INDEX.\n+  void\n+  insert_statement_after(size_t index, Statement*);\n+\n+  // Set the end location of the block.\n+  void\n+  set_end_location(source_location location)\n+  { this->end_location_ = location; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Set final types for unspecified variables and constants.\n+  void\n+  determine_types();\n+\n+  // Return true if execution of this block may fall through to the\n+  // next block.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return a tree of the code in this block.\n+  tree\n+  get_tree(Translate_context*);\n+\n+  // Iterate over statements.\n+\n+  typedef std::vector<Statement*>::iterator iterator;\n+\n+  iterator\n+  begin()\n+  { return this->statements_.begin(); }\n+\n+  iterator\n+  end()\n+  { return this->statements_.end(); }\n+\n+ private:\n+  // Enclosing block.\n+  Block* enclosing_;\n+  // Statements in the block.\n+  std::vector<Statement*> statements_;\n+  // Binding contour.\n+  Bindings* bindings_;\n+  // Location of start of block.\n+  source_location start_location_;\n+  // Location of end of block.\n+  source_location end_location_;\n+};\n+\n+// A function.\n+\n+class Function\n+{\n+ public:\n+  Function(Function_type* type, Function*, Block*, source_location);\n+\n+  // Return the function's type.\n+  Function_type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Return the enclosing function if there is one.\n+  Function*\n+  enclosing()\n+  { return this->enclosing_; }\n+\n+  // Set the enclosing function.  This is used when building thunks\n+  // for functions which call recover.\n+  void\n+  set_enclosing(Function* enclosing)\n+  {\n+    gcc_assert(this->enclosing_ == NULL);\n+    this->enclosing_ = enclosing;\n+  }\n+\n+  // Create the named result variables in the outer block.\n+  void\n+  create_named_result_variables(Gogo*);\n+\n+  // Update the named result variables when cloning a function which\n+  // calls recover.\n+  void\n+  update_named_result_variables();\n+\n+  // Add a new field to the closure variable.\n+  void\n+  add_closure_field(Named_object* var, source_location loc)\n+  { this->closure_fields_.push_back(std::make_pair(var, loc)); }\n+\n+  // Whether this function needs a closure.\n+  bool\n+  needs_closure() const\n+  { return !this->closure_fields_.empty(); }\n+\n+  // Return the closure variable, creating it if necessary.  This is\n+  // passed to the function as a static chain parameter.\n+  Named_object*\n+  closure_var();\n+\n+  // Set the closure variable.  This is used when building thunks for\n+  // functions which call recover.\n+  void\n+  set_closure_var(Named_object* v)\n+  {\n+    gcc_assert(this->closure_var_ == NULL);\n+    this->closure_var_ = v;\n+  }\n+\n+  // Return the variable for a reference to field INDEX in the closure\n+  // variable.\n+  Named_object*\n+  enclosing_var(unsigned int index)\n+  {\n+    gcc_assert(index < this->closure_fields_.size());\n+    return closure_fields_[index].first;\n+  }\n+\n+  // Set the type of the closure variable if there is one.\n+  void\n+  set_closure_type();\n+\n+  // Get the block of statements associated with the function.\n+  Block*\n+  block() const\n+  { return this->block_; }\n+\n+  // Get the location of the start of the function.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return whether this function is actually a method.\n+  bool\n+  is_method() const;\n+\n+  // Add a label definition to the function.\n+  Label*\n+  add_label_definition(const std::string& label_name, source_location);\n+\n+  // Add a label reference to a function.\n+  Label*\n+  add_label_reference(const std::string& label_name);\n+\n+  // Whether this function calls the predeclared recover function.\n+  bool\n+  calls_recover() const\n+  { return this->calls_recover_; }\n+\n+  // Record that this function calls the predeclared recover function.\n+  // This is set during the lowering pass.\n+  void\n+  set_calls_recover()\n+  { this->calls_recover_ = true; }\n+\n+  // Whether this is a recover thunk function.\n+  bool\n+  is_recover_thunk() const\n+  { return this->is_recover_thunk_; }\n+\n+  // Record that this is a thunk built for a function which calls\n+  // recover.\n+  void\n+  set_is_recover_thunk()\n+  { this->is_recover_thunk_ = true; }\n+\n+  // Whether this function already has a recover thunk.\n+  bool\n+  has_recover_thunk() const\n+  { return this->has_recover_thunk_; }\n+\n+  // Record that this function already has a recover thunk.\n+  void\n+  set_has_recover_thunk()\n+  { this->has_recover_thunk_ = true; }\n+\n+  // Swap with another function.  Used only for the thunk which calls\n+  // recover.\n+  void\n+  swap_for_recover(Function *);\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Traverse*);\n+\n+  // Determine types in the function.\n+  void\n+  determine_types();\n+\n+  // Return the function's decl given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Return the function's decl after it has been built.\n+  tree\n+  get_decl() const\n+  {\n+    gcc_assert(this->fndecl_ != NULL);\n+    return this->fndecl_;\n+  }\n+\n+  // Set the function decl to hold a tree of the function code.\n+  void\n+  build_tree(Gogo*, Named_object*);\n+\n+  // Get the value to return when not explicitly specified.  May also\n+  // add statements to execute first to STMT_LIST.\n+  tree\n+  return_value(Gogo*, Named_object*, source_location, tree* stmt_list) const;\n+\n+  // Get a tree for the variable holding the defer stack.\n+  tree\n+  defer_stack(source_location);\n+\n+  // Export the function.\n+  void\n+  export_func(Export*, const std::string& name) const;\n+\n+  // Export a function with a type.\n+  static void\n+  export_func_with_type(Export*, const std::string& name,\n+\t\t\tconst Function_type*);\n+\n+  // Import a function.\n+  static void\n+  import_func(Import*, std::string* pname, Typed_identifier** receiver,\n+\t      Typed_identifier_list** pparameters,\n+\t      Typed_identifier_list** presults, bool* is_varargs);\n+\n+ private:\n+  // Type for mapping from label names to Label objects.\n+  typedef Unordered_map(std::string, Label*) Labels;\n+\n+  tree\n+  make_receiver_parm_decl(Gogo*, Named_object*, tree);\n+\n+  tree\n+  copy_parm_to_heap(Gogo*, Named_object*, tree);\n+\n+  void\n+  build_defer_wrapper(Gogo*, Named_object*, tree*, tree*);\n+\n+  typedef std::vector<Named_object*> Named_results;\n+\n+  typedef std::vector<std::pair<Named_object*,\n+\t\t\t\tsource_location> > Closure_fields;\n+\n+  // The function's type.\n+  Function_type* type_;\n+  // The enclosing function.  This is NULL when there isn't one, which\n+  // is the normal case.\n+  Function* enclosing_;\n+  // The named result variables, if any.\n+  Named_results* named_results_;\n+  // If there is a closure, this is the list of variables which appear\n+  // in the closure.  This is created by the parser, and then resolved\n+  // to a real type when we lower parse trees.\n+  Closure_fields closure_fields_;\n+  // The closure variable, passed as a parameter using the static\n+  // chain parameter.  Normally NULL.\n+  Named_object* closure_var_;\n+  // The outer block of statements in the function.\n+  Block* block_;\n+  // The source location of the start of the function.\n+  source_location location_;\n+  // Labels defined or referenced in the function.\n+  Labels labels_;\n+  // The function decl.\n+  tree fndecl_;\n+  // A variable holding the defer stack variable.  This is NULL unless\n+  // we actually need a defer stack.\n+  tree defer_stack_;\n+  // True if this function calls the predeclared recover function.\n+  bool calls_recover_;\n+  // True if this a thunk built for a function which calls recover.\n+  bool is_recover_thunk_;\n+  // True if this function already has a recover thunk.\n+  bool has_recover_thunk_;\n+};\n+\n+// A function declaration.\n+\n+class Function_declaration\n+{\n+ public:\n+  Function_declaration(Function_type* fntype, source_location location)\n+    : fntype_(fntype), location_(location), asm_name_(), fndecl_(NULL)\n+  { }\n+\n+  Function_type*\n+  type() const\n+  { return this->fntype_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  const std::string&\n+  asm_name() const\n+  { return this->asm_name_; }\n+\n+  // Set the assembler name.\n+  void\n+  set_asm_name(const std::string& asm_name)\n+  { this->asm_name_ = asm_name; }\n+\n+  // Return a decl for the function given an identifier.\n+  tree\n+  get_or_make_decl(Gogo*, Named_object*, tree id);\n+\n+  // Export a function declaration.\n+  void\n+  export_func(Export* exp, const std::string& name) const\n+  { Function::export_func_with_type(exp, name, this->fntype_); }\n+\n+ private:\n+  // The type of the function.\n+  Function_type* fntype_;\n+  // The location of the declaration.\n+  source_location location_;\n+  // The assembler name: this is the name to use in references to the\n+  // function.  This is normally empty.\n+  std::string asm_name_;\n+  // The function decl if needed.\n+  tree fndecl_;\n+};\n+\n+// A variable.\n+\n+class Variable\n+{\n+ public:\n+  Variable(Type*, Expression*, bool is_global, bool is_parameter,\n+\t   bool is_receiver, source_location);\n+\n+  // Get the type of the variable.\n+  Type*\n+  type();\n+\n+  Type*\n+  type() const;\n+\n+  // Return whether the type is defined yet.\n+  bool\n+  has_type() const\n+  { return this->type_ != NULL; }\n+\n+  // Get the initial value.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Return whether there are any preinit statements.\n+  bool\n+  has_pre_init() const\n+  { return this->preinit_ != NULL; }\n+\n+  // Return the preinit statements if any.\n+  Block*\n+  preinit() const\n+  { return this->preinit_; }\n+\n+  // Return whether this is a global variable.\n+  bool\n+  is_global() const\n+  { return this->is_global_; }\n+\n+  // Return whether this is a function parameter.\n+  bool\n+  is_parameter() const\n+  { return this->is_parameter_; }\n+\n+  // Return whether this is the receiver parameter of a method.\n+  bool\n+  is_receiver() const\n+  { return this->is_receiver_; }\n+\n+  // Change this parameter to be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_receiver()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_receiver_ = true;\n+  }\n+\n+  // Change this parameter to not be a receiver.  This is used when\n+  // creating the thunks created for functions which call recover.\n+  void\n+  set_is_not_receiver()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_receiver_ = false;\n+  }\n+\n+  // Return whether this is the varargs parameter of a function.\n+  bool\n+  is_varargs_parameter() const\n+  { return this->is_varargs_parameter_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_ && !this->is_global_; }\n+\n+  // Get the source location of the variable's declaration.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Record that this is the varargs parameter of a function.\n+  void\n+  set_is_varargs_parameter()\n+  {\n+    gcc_assert(this->is_parameter_);\n+    this->is_varargs_parameter_ = true;\n+  }\n+\n+  // Clear the initial value; used for error handling.\n+  void\n+  clear_init()\n+  { this->init_ = NULL; }\n+\n+  // Set the initial value; used for converting shortcuts.\n+  void\n+  set_init(Expression* init)\n+  { this->init_ = init; }\n+\n+  // Get the preinit block, a block of statements to be run before the\n+  // initialization expression.\n+  Block*\n+  preinit_block(Gogo*);\n+\n+  // Add a statement to be run before the initialization expression.\n+  // This is only used for global variables.\n+  void\n+  add_preinit_statement(Gogo*, Statement*);\n+\n+  // Lower the initialization expression after parsing is complete.\n+  void\n+  lower_init_expression(Gogo*, Named_object*);\n+\n+  // A special case: the init value is used only to determine the\n+  // type.  This is used if the variable is defined using := with the\n+  // comma-ok form of a map index or a receive expression.  The init\n+  // value is actually the map index expression or receive expression.\n+  // We use this because we may not know the right type at parse time.\n+  void\n+  set_type_from_init_tuple()\n+  { this->type_from_init_tuple_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a range clause.  The init value is the range expression.  The\n+  // type of the variable is the index type of the range expression\n+  // (i.e., the first value returned by a range).\n+  void\n+  set_type_from_range_index()\n+  { this->type_from_range_index_ = true; }\n+\n+  // Another special case: like set_type_from_range_index, but the\n+  // type is the value type of the range expression (i.e., the second\n+  // value returned by a range).\n+  void\n+  set_type_from_range_value()\n+  { this->type_from_range_value_ = true; }\n+\n+  // Another special case: the init value is used only to determine\n+  // the type.  This is used if the variable is defined using := with\n+  // a case in a select statement.  The init value is the channel.\n+  // The type of the variable is the channel's element type.\n+  void\n+  set_type_from_chan_element()\n+  { this->type_from_chan_element_ = true; }\n+\n+  // After we lower the select statement, we once again set the type\n+  // from the initialization expression.\n+  void\n+  clear_type_from_chan_element()\n+  {\n+    gcc_assert(this->type_from_chan_element_);\n+    this->type_from_chan_element_ = false;\n+  }\n+\n+  // Note that this variable was created for a type switch clause.\n+  void\n+  set_is_type_switch_var()\n+  { this->is_type_switch_var_ = true; }\n+\n+  // Traverse the initializer expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the variable if necessary.\n+  void\n+  determine_type();\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Get the initial value of the variable as a tree.  This may only\n+  // be called if has_pre_init() returns false.\n+  tree\n+  get_init_tree(Gogo*, Named_object* function);\n+\n+  // Return a series of statements which sets the value of the\n+  // variable in DECL.  This should only be called is has_pre_init()\n+  // returns true.  DECL may be NULL for a sink variable.\n+  tree\n+  get_init_block(Gogo*, Named_object* function, tree decl);\n+\n+  // Export the variable.\n+  void\n+  export_var(Export*, const std::string& name) const;\n+\n+  // Import a variable.\n+  static void\n+  import_var(Import*, std::string* pname, Type** ptype);\n+\n+ private:\n+  // The type of a tuple.\n+  Type*\n+  type_from_tuple(Expression*, bool) const;\n+\n+  // The type of a range.\n+  Type*\n+  type_from_range(Expression*, bool, bool) const;\n+\n+  // The element type of a channel.\n+  Type*\n+  type_from_chan_element(Expression*, bool) const;\n+\n+  // The variable's type.  This may be NULL if the type is set from\n+  // the expression.\n+  Type* type_;\n+  // The initial value.  This may be NULL if the variable should be\n+  // initialized to the default value for the type.\n+  Expression* init_;\n+  // Statements to run before the init statement.\n+  Block* preinit_;\n+  // Location of variable definition.\n+  source_location location_;\n+  // Whether this is a global variable.\n+  bool is_global_ : 1;\n+  // Whether this is a function parameter.\n+  bool is_parameter_ : 1;\n+  // Whether this is the receiver parameter of a method.\n+  bool is_receiver_ : 1;\n+  // Whether this is the varargs parameter of a function.\n+  bool is_varargs_parameter_ : 1;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_ : 1;\n+  // True if we have seen this variable in a traversal.\n+  bool seen_ : 1;\n+  // True if we have lowered the initialization expression.\n+  bool init_is_lowered_ : 1;\n+  // True if init is a tuple used to set the type.\n+  bool type_from_init_tuple_ : 1;\n+  // True if init is a range clause and the type is the index type.\n+  bool type_from_range_index_ : 1;\n+  // True if init is a range clause and the type is the value type.\n+  bool type_from_range_value_ : 1;\n+  // True if init is a channel and the type is the channel's element type.\n+  bool type_from_chan_element_ : 1;\n+  // True if this is a variable created for a type switch case.\n+  bool is_type_switch_var_ : 1;\n+  // True if we have determined types.\n+  bool determined_type_ : 1;\n+};\n+\n+// A variable which is really the name for a function return value, or\n+// part of one.\n+\n+class Result_variable\n+{\n+ public:\n+  Result_variable(Type* type, Function* function, int index)\n+    : type_(type), function_(function), index_(index),\n+      is_address_taken_(false)\n+  { }\n+\n+  // Get the type of the result variable.\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  // Get the function that this is associated with.\n+  Function*\n+  function() const\n+  { return this->function_; }\n+\n+  // Index in the list of function results.\n+  int\n+  index() const\n+  { return this->index_; }\n+\n+  // Whether this variable's address is taken.\n+  bool\n+  is_address_taken() const\n+  { return this->is_address_taken_; }\n+\n+  // Note that something takes the address of this variable.\n+  void\n+  set_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Whether this variable should live in the heap.\n+  bool\n+  is_in_heap() const\n+  { return this->is_address_taken_; }\n+\n+  // Set the function.  This is used when cloning functions which call\n+  // recover.\n+  void\n+  set_function(Function* function)\n+  { this->function_ = function; }\n+\n+ private:\n+  // Type of result variable.\n+  Type* type_;\n+  // Function with which this is associated.\n+  Function* function_;\n+  // Index in list of results.\n+  int index_;\n+  // Whether something takes the address of this variable.\n+  bool is_address_taken_;\n+};\n+\n+// The value we keep for a named constant.  This lets us hold a type\n+// and an expression.\n+\n+class Named_constant\n+{\n+ public:\n+  Named_constant(Type* type, Expression* expr, int iota_value,\n+\t\t source_location location)\n+    : type_(type), expr_(expr), iota_value_(iota_value), location_(location),\n+      lowering_(false)\n+  { }\n+\n+  Type*\n+  type() const\n+  { return this->type_; }\n+\n+  Expression*\n+  expr() const\n+  { return this->expr_; }\n+\n+  int\n+  iota_value() const\n+  { return this->iota_value_; }\n+\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Whether we are lowering.\n+  bool\n+  lowering() const\n+  { return this->lowering_; }\n+\n+  // Set that we are lowering.\n+  void\n+  set_lowering()\n+  { this->lowering_ = true; }\n+\n+  // We are no longer lowering.\n+  void\n+  clear_lowering()\n+  { this->lowering_ = false; }\n+\n+  // Traverse the expression.\n+  int\n+  traverse_expression(Traverse*);\n+\n+  // Determine the type of the constant if necessary.\n+  void\n+  determine_type();\n+\n+  // Indicate that we found and reported an error for this constant.\n+  void\n+  set_error();\n+\n+  // Export the constant.\n+  void\n+  export_const(Export*, const std::string& name) const;\n+\n+  // Import a constant.\n+  static void\n+  import_const(Import*, std::string*, Type**, Expression**);\n+\n+ private:\n+  // The type of the constant.\n+  Type* type_;\n+  // The expression for the constant.\n+  Expression* expr_;\n+  // If the predeclared constant iota is used in EXPR_, this is the\n+  // value it will have.  We do this because at parse time we don't\n+  // know whether the name \"iota\" will refer to the predeclared\n+  // constant or to something else.  We put in the right value in when\n+  // we lower.\n+  int iota_value_;\n+  // The location of the definition.\n+  source_location location_;\n+  // Whether we are currently lowering this constant.\n+  bool lowering_;\n+};\n+\n+// A type declaration.\n+\n+class Type_declaration\n+{\n+ public:\n+  Type_declaration(source_location location)\n+    : location_(location), in_function_(NULL), methods_(),\n+      issued_warning_(false)\n+  { }\n+\n+  // Return the location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the function in which this type is declared.  This will\n+  // return NULL for a type declared in global scope.\n+  Named_object*\n+  in_function()\n+  { return this->in_function_; }\n+\n+  // Set the function in which this type is declared.\n+  void\n+  set_in_function(Named_object* f)\n+  { this->in_function_ = f; }\n+\n+  // Add a method to this type.  This is used when methods are defined\n+  // before the type.\n+  Named_object*\n+  add_method(const std::string& name, Function* function);\n+\n+  // Add a method declaration to this type.\n+  Named_object*\n+  add_method_declaration(const std::string& name, Function_type* type,\n+\t\t\t source_location location);\n+\n+  // Return whether any methods were defined.\n+  bool\n+  has_methods() const;\n+\n+  // Define methods when the real type is known.\n+  void\n+  define_methods(Named_type*);\n+\n+  // This is called if we are trying to use this type.  It returns\n+  // true if we should issue a warning.\n+  bool\n+  using_type();\n+\n+ private:\n+  typedef std::vector<Named_object*> Methods;\n+\n+  // The location of the type declaration.\n+  source_location location_;\n+  // If this type is declared in a function, a pointer back to the\n+  // function in which it is defined.\n+  Named_object* in_function_;\n+  // Methods defined before the type is defined.\n+  Methods methods_;\n+  // True if we have issued a warning about a use of this type\n+  // declaration when it is undefined.\n+  bool issued_warning_;\n+};\n+\n+// An unknown object.  These are created by the parser for forward\n+// references to names which have not been seen before.  In a correct\n+// program, these will always point to a real definition by the end of\n+// the parse.  Because they point to another Named_object, these may\n+// only be referenced by Unknown_expression objects.\n+\n+class Unknown_name\n+{\n+ public:\n+  Unknown_name(source_location location)\n+    : location_(location), real_named_object_(NULL)\n+  { }\n+\n+  // Return the location where this name was first seen.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Return the real named object that this points to, or NULL if it\n+  // was never resolved.\n+  Named_object*\n+  real_named_object() const\n+  { return this->real_named_object_; }\n+\n+  // Set the real named object that this points to.\n+  void\n+  set_real_named_object(Named_object* no);\n+\n+ private:\n+  // The location where this name was first seen.\n+  source_location location_;\n+  // The real named object when it is known.\n+  Named_object*\n+  real_named_object_;\n+};\n+\n+// A named object named.  This is the result of a declaration.  We\n+// don't use a superclass because they all have to be handled\n+// differently.\n+\n+class Named_object\n+{\n+ public:\n+  enum Classification\n+  {\n+    // An uninitialized Named_object.  We should never see this.\n+    NAMED_OBJECT_UNINITIALIZED,\n+    // An unknown name.  This is used for forward references.  In a\n+    // correct program, these will all be resolved by the end of the\n+    // parse.\n+    NAMED_OBJECT_UNKNOWN,\n+    // A const.\n+    NAMED_OBJECT_CONST,\n+    // A type.\n+    NAMED_OBJECT_TYPE,\n+    // A forward type declaration.\n+    NAMED_OBJECT_TYPE_DECLARATION,\n+    // A var.\n+    NAMED_OBJECT_VAR,\n+    // A result variable in a function.\n+    NAMED_OBJECT_RESULT_VAR,\n+    // The blank identifier--the special variable named _.\n+    NAMED_OBJECT_SINK,\n+    // A func.\n+    NAMED_OBJECT_FUNC,\n+    // A forward func declaration.\n+    NAMED_OBJECT_FUNC_DECLARATION,\n+    // A package.\n+    NAMED_OBJECT_PACKAGE\n+  };\n+\n+  // Return the classification.\n+  Classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Classifiers.\n+\n+  bool\n+  is_unknown() const\n+  { return this->classification_ == NAMED_OBJECT_UNKNOWN; }\n+\n+  bool\n+  is_const() const\n+  { return this->classification_ == NAMED_OBJECT_CONST; }\n+\n+  bool\n+  is_type() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE; }\n+\n+  bool\n+  is_type_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_TYPE_DECLARATION; }\n+\n+  bool\n+  is_variable() const\n+  { return this->classification_ == NAMED_OBJECT_VAR; }\n+\n+  bool\n+  is_result_variable() const\n+  { return this->classification_ == NAMED_OBJECT_RESULT_VAR; }\n+\n+  bool\n+  is_sink() const\n+  { return this->classification_ == NAMED_OBJECT_SINK; }\n+\n+  bool\n+  is_function() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC; }\n+\n+  bool\n+  is_function_declaration() const\n+  { return this->classification_ == NAMED_OBJECT_FUNC_DECLARATION; }\n+\n+  bool\n+  is_package() const\n+  { return this->classification_ == NAMED_OBJECT_PACKAGE; }\n+\n+  // Creators.\n+\n+  static Named_object*\n+  make_unknown_name(const std::string& name, source_location);\n+\n+  static Named_object*\n+  make_constant(const Typed_identifier&, const Package*, Expression*,\n+\t\tint iota_value);\n+\n+  static Named_object*\n+  make_type(const std::string&, const Package*, Type*, source_location);\n+\n+  static Named_object*\n+  make_type_declaration(const std::string&, const Package*, source_location);\n+\n+  static Named_object*\n+  make_variable(const std::string&, const Package*, Variable*);\n+\n+  static Named_object*\n+  make_result_variable(const std::string&, Result_variable*);\n+\n+  static Named_object*\n+  make_sink();\n+\n+  static Named_object*\n+  make_function(const std::string&, const Package*, Function*);\n+\n+  static Named_object*\n+  make_function_declaration(const std::string&, const Package*, Function_type*,\n+\t\t\t    source_location);\n+\n+  static Named_object*\n+  make_package(const std::string& alias, Package* package);\n+\n+  // Getters.\n+\n+  Unknown_name*\n+  unknown_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  const Unknown_name*\n+  unknown_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_UNKNOWN);\n+    return this->u_.unknown_value;\n+  }\n+\n+  Named_constant*\n+  const_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  const Named_constant*\n+  const_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_CONST);\n+    return this->u_.const_value;\n+  }\n+\n+  Named_type*\n+  type_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  const Named_type*\n+  type_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE);\n+    return this->u_.type_value;\n+  }\n+\n+  Type_declaration*\n+  type_declaration_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  const Type_declaration*\n+  type_declaration_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_TYPE_DECLARATION);\n+    return this->u_.type_declaration;\n+  }\n+\n+  Variable*\n+  var_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  const Variable*\n+  var_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_VAR);\n+    return this->u_.var_value;\n+  }\n+\n+  Result_variable*\n+  result_var_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  const Result_variable*\n+  result_var_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_RESULT_VAR);\n+    return this->u_.result_var_value;\n+  }\n+\n+  Function*\n+  func_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  const Function*\n+  func_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC);\n+    return this->u_.func_value;\n+  }\n+\n+  Function_declaration*\n+  func_declaration_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  const Function_declaration*\n+  func_declaration_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_FUNC_DECLARATION);\n+    return this->u_.func_declaration_value;\n+  }\n+\n+  Package*\n+  package_value()\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const Package*\n+  package_value() const\n+  {\n+    gcc_assert(this->classification_ == NAMED_OBJECT_PACKAGE);\n+    return this->u_.package_value;\n+  }\n+\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the name to use in an error message.  The difference is\n+  // that if this Named_object is defined in a different package, this\n+  // will return PACKAGE.NAME.\n+  std::string\n+  message_name() const;\n+\n+  const Package*\n+  package() const\n+  { return this->package_; }\n+\n+  // Resolve an unknown value if possible.  This returns the same\n+  // Named_object or a new one.\n+  Named_object*\n+  resolve()\n+  {\n+    Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tNamed_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  const Named_object*\n+  resolve() const\n+  {\n+    const Named_object* ret = this;\n+    if (this->is_unknown())\n+      {\n+\tconst Named_object* r = this->unknown_value()->real_named_object();\n+\tif (r != NULL)\n+\t  ret = r;\n+      }\n+    return ret;\n+  }\n+\n+  // The location where this object was defined or referenced.\n+  source_location\n+  location() const;\n+\n+  // Return a tree for the external identifier for this object.\n+  tree\n+  get_id(Gogo*);\n+\n+  // Return a tree representing this object.\n+  tree\n+  get_tree(Gogo*, Named_object* function);\n+\n+  // Define a type declaration.\n+  void\n+  set_type_value(Named_type*);\n+\n+  // Define a function declaration.\n+  void\n+  set_function_value(Function*);\n+\n+  // Declare an unknown name as a type declaration.\n+  void\n+  declare_as_type();\n+\n+  // Export this object.\n+  void\n+  export_named_object(Export*) const;\n+\n+ private:\n+  Named_object(const std::string&, const Package*, Classification);\n+\n+  // The name of the object.\n+  std::string name_;\n+  // The package that this object is in.  This is NULL if it is in the\n+  // file we are compiling.\n+  const Package* package_;\n+  // The type of object this is.\n+  Classification classification_;\n+  // The real data.\n+  union\n+  {\n+    Unknown_name* unknown_value;\n+    Named_constant* const_value;\n+    Named_type* type_value;\n+    Type_declaration* type_declaration;\n+    Variable* var_value;\n+    Result_variable* result_var_value;\n+    Function* func_value;\n+    Function_declaration* func_declaration_value;\n+    Package* package_value;\n+  } u_;\n+  // The DECL tree for this object if we have already converted it.\n+  tree tree_;\n+};\n+\n+// A binding contour.  This binds names to objects.\n+\n+class Bindings\n+{\n+ public:\n+  // Type for mapping from names to objects.\n+  typedef Unordered_map(std::string, Named_object*) Contour;\n+\n+  Bindings(Bindings* enclosing);\n+\n+  // Add an unknown name.\n+  Named_object*\n+  add_unknown_name(const std::string& name, source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_unknown_name(name,\n+\t\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a constant.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, const Package* package,\n+\t       Expression* expr, int iota_value)\n+  {\n+    return this->add_named_object(Named_object::make_constant(tid, package,\n+\t\t\t\t\t\t\t      expr,\n+\t\t\t\t\t\t\t      iota_value));\n+  }\n+\n+  // Add a type.\n+  Named_object*\n+  add_type(const std::string& name, const Package* package, Type* type,\n+\t   source_location location)\n+  {\n+    return this->add_named_object(Named_object::make_type(name, package, type,\n+\t\t\t\t\t\t\t  location));\n+  }\n+\n+  // Add a named type.  This is used for builtin types, and to add an\n+  // imported type to the global scope.\n+  Named_object*\n+  add_named_type(Named_type* named_type);\n+\n+  // Add a type declaration.\n+  Named_object*\n+  add_type_declaration(const std::string& name, const Package* package,\n+\t\t       source_location location)\n+  {\n+    Named_object* no = Named_object::make_type_declaration(name, package,\n+\t\t\t\t\t\t\t   location);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Add a variable.\n+  Named_object*\n+  add_variable(const std::string& name, const Package* package,\n+\t       Variable* variable)\n+  {\n+    return this->add_named_object(Named_object::make_variable(name, package,\n+\t\t\t\t\t\t\t      variable));\n+  }\n+\n+  // Add a result variable.\n+  Named_object*\n+  add_result_variable(const std::string& name, Result_variable* result)\n+  {\n+    return this->add_named_object(Named_object::make_result_variable(name,\n+\t\t\t\t\t\t\t\t     result));\n+  }\n+\n+  // Add a function.\n+  Named_object*\n+  add_function(const std::string& name, const Package*, Function* function);\n+\n+  // Add a function declaration.\n+  Named_object*\n+  add_function_declaration(const std::string& name, const Package* package,\n+\t\t\t   Function_type* type, source_location location);\n+\n+  // Add a package.  The location is the location of the import\n+  // statement.\n+  Named_object*\n+  add_package(const std::string& alias, Package* package)\n+  {\n+    Named_object* no = Named_object::make_package(alias, package);\n+    return this->add_named_object(no);\n+  }\n+\n+  // Define a type which was already declared.\n+  void\n+  define_type(Named_object*, Named_type*);\n+\n+  // Add a method to the list of objects.  This is not added to the\n+  // lookup table.\n+  void\n+  add_method(Named_object*);\n+\n+  // Add a named object to this binding.\n+  Named_object*\n+  add_named_object(Named_object* no)\n+  { return this->add_named_object_to_contour(&this->bindings_, no); }\n+\n+  // Clear all names in file scope from the bindings.\n+  void\n+  clear_file_scope();\n+\n+  // Look up a name in this binding contour and in any enclosing\n+  // binding contours.  This returns NULL if the name is not found.\n+  Named_object*\n+  lookup(const std::string&) const;\n+\n+  // Look up a name in this binding contour without looking in any\n+  // enclosing binding contours.  Returns NULL if the name is not found.\n+  Named_object*\n+  lookup_local(const std::string&) const;\n+\n+  // Remove a name.\n+  void\n+  remove_binding(Named_object*);\n+\n+  // Traverse the tree.  See the Traverse class.\n+  int\n+  traverse(Traverse*, bool is_global);\n+\n+  // Iterate over definitions.  This does not include things which\n+  // were only declared.\n+\n+  typedef std::vector<Named_object*>::const_iterator\n+    const_definitions_iterator;\n+\n+  const_definitions_iterator\n+  begin_definitions() const\n+  { return this->named_objects_.begin(); }\n+\n+  const_definitions_iterator\n+  end_definitions() const\n+  { return this->named_objects_.end(); }\n+\n+  // Return the number of definitions.\n+  size_t\n+  size_definitions() const\n+  { return this->named_objects_.size(); }\n+\n+  // Return whether there are no definitions.\n+  bool\n+  empty_definitions() const\n+  { return this->named_objects_.empty(); }\n+\n+  // Iterate over declarations.  This is everything that has been\n+  // declared, which includes everything which has been defined.\n+\n+  typedef Contour::const_iterator const_declarations_iterator;\n+\n+  const_declarations_iterator\n+  begin_declarations() const\n+  { return this->bindings_.begin(); }\n+\n+  const_declarations_iterator\n+  end_declarations() const\n+  { return this->bindings_.end(); }\n+\n+  // Return the number of declarations.\n+  size_t\n+  size_declarations() const\n+  { return this->bindings_.size(); }\n+\n+  // Return whether there are no declarations.\n+  bool\n+  empty_declarations() const\n+  { return this->bindings_.empty(); }\n+\n+  // Return the first declaration.\n+  Named_object*\n+  first_declaration()\n+  { return this->bindings_.empty() ? NULL : this->bindings_.begin()->second; }\n+\n+ private:\n+  Named_object*\n+  add_named_object_to_contour(Contour*, Named_object*);\n+\n+  Named_object*\n+  new_definition(Named_object*, Named_object*);\n+\n+  // Enclosing bindings.\n+  Bindings* enclosing_;\n+  // The list of objects.\n+  std::vector<Named_object*> named_objects_;\n+  // The mapping from names to objects.\n+  Contour bindings_;\n+};\n+\n+// A label.\n+\n+class Label\n+{\n+ public:\n+  Label(const std::string& name)\n+    : name_(name), location_(0), decl_(NULL)\n+  { }\n+\n+  // Return the label's name.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return whether the label has been defined.\n+  bool\n+  is_defined() const\n+  { return this->location_ != 0; }\n+\n+  // Return the location of the definition.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Define the label at LOCATION.\n+  void\n+  define(source_location location)\n+  {\n+    gcc_assert(this->location_ == 0);\n+    this->location_ = location;\n+  }\n+\n+  // Return the LABEL_DECL for this decl.\n+  tree\n+  get_decl();\n+\n+  // Return an expression for the address of this label.\n+  tree\n+  get_addr(source_location location);\n+\n+ private:\n+  // The name of the label.\n+  std::string name_;\n+  // The location of the definition.  This is 0 if the label has not\n+  // yet been defined.\n+  source_location location_;\n+  // The LABEL_DECL.\n+  tree decl_;\n+};\n+\n+// An unnamed label.  These are used when lowering loops.\n+\n+class Unnamed_label\n+{\n+ public:\n+  Unnamed_label(source_location location)\n+    : location_(location), decl_(NULL)\n+  { }\n+\n+  // Get the location where the label is defined.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Set the location where the label is defined.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Return a statement which defines this label.\n+  tree\n+  get_definition();\n+\n+  // Return a goto to this label from LOCATION.\n+  tree\n+  get_goto(source_location location);\n+\n+ private:\n+  // Return the LABEL_DECL to use with GOTO_EXPR.\n+  tree\n+  get_decl();\n+\n+  // The location where the label is defined.\n+  source_location location_;\n+  // The LABEL_DECL.\n+  tree decl_;\n+};\n+\n+// An imported package.\n+\n+class Package\n+{\n+ public:\n+  Package(const std::string& name, const std::string& unique_prefix,\n+\t  source_location location);\n+\n+  // The real name of this package.  This may be different from the\n+  // name in the associated Named_object if the import statement used\n+  // an alias.\n+  const std::string&\n+  name() const\n+  { return this->name_; }\n+\n+  // Return the location of the import statement.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Get the unique prefix used for all symbols exported from this\n+  // package.\n+  const std::string&\n+  unique_prefix() const\n+  {\n+    gcc_assert(!this->unique_prefix_.empty());\n+    return this->unique_prefix_;\n+  }\n+\n+  // The priority of this package.  The init function of packages with\n+  // lower priority must be run before the init function of packages\n+  // with higher priority.\n+  int\n+  priority() const\n+  { return this->priority_; }\n+\n+  // Set the priority.\n+  void\n+  set_priority(int priority);\n+\n+  // Return the bindings.\n+  Bindings*\n+  bindings()\n+  { return this->bindings_; }\n+\n+  // Whether some symbol from the package was used.\n+  bool\n+  used() const\n+  { return this->used_; }\n+\n+  // Note that some symbol from this package was used.\n+  void\n+  set_used() const\n+  { this->used_ = true; }\n+\n+  // Clear the used field for the next file.\n+  void\n+  clear_used()\n+  { this->used_ = false; }\n+\n+  // Whether this package was imported in the current file.\n+  bool\n+  is_imported() const\n+  { return this->is_imported_; }\n+\n+  // Note that this package was imported in the current file.\n+  void\n+  set_is_imported()\n+  { this->is_imported_ = true; }\n+\n+  // Clear the imported field for the next file.\n+  void\n+  clear_is_imported()\n+  { this->is_imported_ = false; }\n+\n+  // Whether this package was imported with a name of \"_\".\n+  bool\n+  uses_sink_alias() const\n+  { return this->uses_sink_alias_; }\n+\n+  // Note that this package was imported with a name of \"_\".\n+  void\n+  set_uses_sink_alias()\n+  { this->uses_sink_alias_ = true; }\n+\n+  // Clear the sink alias field for the next file.\n+  void\n+  clear_uses_sink_alias()\n+  { this->uses_sink_alias_ = false; }\n+\n+  // Look up a name in the package.  Returns NULL if the name is not\n+  // found.\n+  Named_object*\n+  lookup(const std::string& name) const\n+  { return this->bindings_->lookup(name); }\n+\n+  // Set the location of the package.  This is used if it is seen in a\n+  // different import before it is really imported.\n+  void\n+  set_location(source_location location)\n+  { this->location_ = location; }\n+\n+  // Add a constant to the package.\n+  Named_object*\n+  add_constant(const Typed_identifier& tid, Expression* expr)\n+  { return this->bindings_->add_constant(tid, this, expr, 0); }\n+\n+  // Add a type to the package.\n+  Named_object*\n+  add_type(const std::string& name, Type* type, source_location location)\n+  { return this->bindings_->add_type(name, this, type, location); }\n+\n+  // Add a type declaration to the package.\n+  Named_object*\n+  add_type_declaration(const std::string& name, source_location location)\n+  { return this->bindings_->add_type_declaration(name, this, location); }\n+\n+  // Add a variable to the package.\n+  Named_object*\n+  add_variable(const std::string& name, Variable* variable)\n+  { return this->bindings_->add_variable(name, this, variable); }\n+\n+  // Add a function declaration to the package.\n+  Named_object*\n+  add_function_declaration(const std::string& name, Function_type* type,\n+\t\t\t   source_location loc)\n+  { return this->bindings_->add_function_declaration(name, this, type, loc); }\n+\n+  // Determine types of constants.\n+  void\n+  determine_types();\n+\n+ private:\n+  // The real name of this package.\n+  std::string name_;\n+  // The unique prefix for all exported global symbols.\n+  std::string unique_prefix_;\n+  // The names in this package.\n+  Bindings* bindings_;\n+  // The priority of this package.  A package has a priority higher\n+  // than the priority of all of the packages that it imports.  This\n+  // is used to run init functions in the right order.\n+  int priority_;\n+  // The location of the import statement.\n+  source_location location_;\n+  // True if some name from this package was used.  This is mutable\n+  // because we can use a package even if we have a const pointer to\n+  // it.\n+  mutable bool used_;\n+  // True if this package was imported in the current file.\n+  bool is_imported_;\n+  // True if this package was imported with a name of \"_\".\n+  bool uses_sink_alias_;\n+};\n+\n+// Return codes for the traversal functions.  This is not an enum\n+// because we want to be able to declare traversal functions in other\n+// header files without including this one.\n+\n+// Continue traversal as usual.\n+const int TRAVERSE_CONTINUE = -1;\n+\n+// Exit traversal.\n+const int TRAVERSE_EXIT = 0;\n+\n+// Continue traversal, but skip components of the current object.\n+// E.g., if this is returned by Traverse::statement, we do not\n+// traverse the expressions in the statement even if\n+// traverse_expressions is set in the traverse_mask.\n+const int TRAVERSE_SKIP_COMPONENTS = 1;\n+\n+// This class is used when traversing the parse tree.  The caller uses\n+// a subclass which overrides functions as desired.\n+\n+class Traverse\n+{\n+ public:\n+  // These bitmasks say what to traverse.\n+  static const unsigned int traverse_variables =    0x1;\n+  static const unsigned int traverse_constants =    0x2;\n+  static const unsigned int traverse_functions =    0x4;\n+  static const unsigned int traverse_blocks =       0x8;\n+  static const unsigned int traverse_statements =  0x10;\n+  static const unsigned int traverse_expressions = 0x20;\n+  static const unsigned int traverse_types =       0x40;\n+\n+  Traverse(unsigned int traverse_mask)\n+    : traverse_mask_(traverse_mask), types_seen_(NULL), expressions_seen_(NULL)\n+  { }\n+\n+  virtual ~Traverse();\n+\n+  // The bitmask of what to traverse.\n+  unsigned int\n+  traverse_mask() const\n+  { return this->traverse_mask_; }\n+\n+  // Record that we are going to traverse a type.  This returns true\n+  // if the type has already been seen in this traversal.  This is\n+  // required because types, unlike expressions, can form a circular\n+  // graph.\n+  bool\n+  remember_type(const Type*);\n+\n+  // Record that we are going to see an expression.  This returns true\n+  // if the expression has already been seen in this traversal.  This\n+  // is only needed for cases where multiple expressions can point to\n+  // a single one.\n+  bool\n+  remember_expression(const Expression*);\n+\n+  // These functions return one of the TRAVERSE codes defined above.\n+\n+  // If traverse_variables is set in the mask, this is called for\n+  // every variable in the tree.\n+  virtual int\n+  variable(Named_object*);\n+\n+  // If traverse_constants is set in the mask, this is called for\n+  // every named constant in the tree.  The bool parameter is true for\n+  // a global constant.\n+  virtual int\n+  constant(Named_object*, bool);\n+\n+  // If traverse_functions is set in the mask, this is called for\n+  // every function in the tree.\n+  virtual int\n+  function(Named_object*);\n+\n+  // If traverse_blocks is set in the mask, this is called for every\n+  // block in the tree.\n+  virtual int\n+  block(Block*);\n+\n+  // If traverse_statements is set in the mask, this is called for\n+  // every statement in the tree.\n+  virtual int\n+  statement(Block*, size_t* index, Statement*);\n+\n+  // If traverse_expressions is set in the mask, this is called for\n+  // every expression in the tree.\n+  virtual int\n+  expression(Expression**);\n+\n+  // If traverse_types is set in the mask, this is called for every\n+  // type in the tree.\n+  virtual int\n+  type(Type*);\n+\n+ private:\n+  typedef Unordered_set_hash(const Type*, Type_hash_identical,\n+\t\t\t     Type_identical) Types_seen;\n+\n+  typedef Unordered_set(const Expression*) Expressions_seen;\n+\n+  // Bitmask of what sort of objects to traverse.\n+  unsigned int traverse_mask_;\n+  // Types which have been seen in this traversal.\n+  Types_seen* types_seen_;\n+  // Expressions which have been seen in this traversal.\n+  Expressions_seen* expressions_seen_;\n+};\n+\n+// When translating the gogo IR into trees, this is the context we\n+// pass down the blocks and statements.\n+\n+class Translate_context\n+{\n+ public:\n+  Translate_context(Gogo* gogo, Named_object* function, Block* block,\n+\t\t    tree block_tree)\n+    : gogo_(gogo), function_(function), block_(block), block_tree_(block_tree),\n+      is_const_(false)\n+  { }\n+\n+  // Accessors.\n+\n+  Gogo*\n+  gogo()\n+  { return this->gogo_; }\n+\n+  Named_object*\n+  function()\n+  { return this->function_; }\n+\n+  Block*\n+  block()\n+  { return this->block_; }\n+\n+  tree\n+  block_tree()\n+  { return this->block_tree_; }\n+\n+  bool\n+  is_const()\n+  { return this->is_const_; }\n+\n+  // Make a constant context.\n+  void\n+  set_is_const()\n+  { this->is_const_ = true; }\n+\n+ private:\n+  // The IR for the entire compilation unit.\n+  Gogo* gogo_;\n+  // The function we are currently translating.\n+  Named_object* function_;\n+  // The block we are currently translating.\n+  Block *block_;\n+  // The BLOCK node for the current block.\n+  tree block_tree_;\n+  // Whether this is being evaluated in a constant context.  This is\n+  // used for type descriptor initializers.\n+  bool is_const_;\n+};\n+\n+// Runtime error codes.  These must match the values in\n+// libgo/runtime/go-runtime-error.c.\n+\n+// Slice index out of bounds: negative or larger than the length of\n+// the slice.\n+static const int RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS = 0;\n+\n+// Array index out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS = 1;\n+\n+// String index out of bounds.\n+static const int RUNTIME_ERROR_STRING_INDEX_OUT_OF_BOUNDS = 2;\n+\n+// Slice slice out of bounds: negative or larger than the length of\n+// the slice or high bound less than low bound.\n+static const int RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS = 3;\n+\n+// Array slice out of bounds.\n+static const int RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS = 4;\n+\n+// String slice out of bounds.\n+static const int RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS = 5;\n+\n+// Dereference of nil pointer.  This is used when there is a\n+// dereference of a pointer to a very large struct or array, to ensure\n+// that a gigantic array is not used a proxy to access random memory\n+// locations.\n+static const int RUNTIME_ERROR_NIL_DEREFERENCE = 6;\n+\n+// Slice length or capacity out of bounds in make: negative or\n+// overflow or length greater than capacity.\n+static const int RUNTIME_ERROR_MAKE_SLICE_OUT_OF_BOUNDS = 7;\n+\n+// Map capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS = 8;\n+\n+// Channel capacity out of bounds in make: negative or overflow.\n+static const int RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS = 9;\n+\n+// This is used by some of the langhooks.\n+extern Gogo* go_get_gogo();\n+\n+// Whether we have seen any errors.  FIXME: Replace with a backend\n+// interface.\n+extern bool saw_errors();\n+\n+#endif // !defined(GO_GOGO_H)"}, {"sha": "c8b55c56214b9dbb999f5c4b27c444105fbee8de", "filename": "gcc/go/gofrontend/parse.cc.merge-left.r167407", "status": "added", "additions": 4730, "deletions": 0, "changes": 4730, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "eeb4f5da34721383dde52efe712322df21a86b4d", "filename": "gcc/go/gofrontend/parse.cc.merge-right.r172891", "status": "added", "additions": 5131, "deletions": 0, "changes": 5131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "f1b93429ff20c921e27b1d78ec264f4603263c71", "filename": "gcc/go/gofrontend/parse.cc.working", "status": "added", "additions": 5015, "deletions": 0, "changes": 5015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "fc2eb12b6d5081ae232ee4e09eb5d4007b526fb9", "filename": "gcc/go/gofrontend/parse.h.merge-left.r167407", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.h.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.h.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,307 @@\n+// parse.h -- Go frontend parser.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_PARSE_H\n+#define GO_PARSE_H\n+\n+class Set_iota_traverse;\n+class Lex;\n+class Gogo;\n+class Named_object;\n+class Type;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Block;\n+class Expression;\n+class Expression_list;\n+class Struct_field_list;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Statement;\n+class Label;\n+\n+// Parse the program.\n+\n+class Parse\n+{\n+ public:\n+  Parse(Lex*, Gogo*);\n+\n+  // Parse a program.\n+  void\n+  program();\n+\n+ private:\n+  // Precedence values.\n+  enum Precedence\n+  {\n+    PRECEDENCE_INVALID = -1,\n+    PRECEDENCE_NORMAL = 0,\n+    PRECEDENCE_OROR,\n+    PRECEDENCE_ANDAND,\n+    PRECEDENCE_CHANOP,\n+    PRECEDENCE_RELOP,\n+    PRECEDENCE_ADDOP,\n+    PRECEDENCE_MULOP\n+  };\n+\n+  // We use this when parsing the range clause of a for statement.\n+  struct Range_clause\n+  {\n+    // Set to true if we found a range clause.\n+    bool found;\n+    // The index expression.\n+    Expression* index;\n+    // The value expression.\n+    Expression* value;\n+    // The range expression.\n+    Expression* range;\n+\n+    Range_clause()\n+      : found(false), index(NULL), value(NULL), range(NULL)\n+    { }\n+  };\n+\n+  // We use this when parsing the statement at the start of a switch,\n+  // in order to recognize type switches.\n+  struct Type_switch\n+  {\n+    // Set to true if we find a type switch.\n+    bool found;\n+    // The variable name.\n+    std::string name;\n+    // The location of the variable.\n+    source_location location;\n+    // The expression.\n+    Expression* expr;\n+\n+    Type_switch()\n+      : found(false), name(), location(UNKNOWN_LOCATION), expr(NULL)\n+    { }\n+  };\n+\n+  // A variable defined in an enclosing function referenced by the\n+  // current function.\n+  class Enclosing_var\n+  {\n+   public:\n+    Enclosing_var(Named_object* var, Named_object* in_function,\n+\t\t  unsigned int index)\n+      : var_(var), in_function_(in_function), index_(index)\n+    { }\n+\n+    // We put these in a vector, so we need a default constructor.\n+    Enclosing_var()\n+      : var_(NULL), in_function_(NULL), index_(-1U)\n+    { }\n+\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    Named_object*\n+    in_function() const\n+    { return this->in_function_; }\n+\n+    unsigned int\n+    index() const\n+    { return this->index_; }\n+\n+   private:\n+    // The variable which is being referred to.\n+    Named_object* var_;\n+    // The function where the variable is defined.\n+    Named_object* in_function_;\n+    // The index of the field in this function's closure struct for\n+    // this variable.\n+    unsigned int index_;\n+  };\n+\n+  // We store Enclosing_var entries in a set, so we need a comparator.\n+  struct Enclosing_var_comparison\n+  {\n+    bool\n+    operator()(const Enclosing_var&, const Enclosing_var&);\n+  };\n+\n+  // A set of Enclosing_var entries.\n+  typedef std::set<Enclosing_var, Enclosing_var_comparison> Enclosing_vars;\n+\n+  // Peek at the current token from the lexer.\n+  const Token*\n+  peek_token();\n+\n+  // Consume the current token, return the next one.\n+  const Token*\n+  advance_token();\n+\n+  // Push a token back on the input stream.\n+  void\n+  unget_token(const Token&);\n+\n+  // The location of the current token.\n+  source_location\n+  location();\n+\n+  // For break and continue we keep a stack of statements with\n+  // associated labels (if any).  The top of the stack is used for a\n+  // break or continue statement with no label.\n+  typedef std::vector<std::pair<Statement*, const Label*> > Bc_stack;\n+\n+  // Parser nonterminals.\n+  void identifier_list(Typed_identifier_list*);\n+  Expression_list* expression_list(Expression*, bool may_be_sink);\n+  bool qualified_ident(std::string*, Named_object**);\n+  Type* type();\n+  bool type_may_start_here();\n+  Type* type_name(bool issue_error);\n+  Type* array_type(bool may_use_ellipsis);\n+  Type* map_type();\n+  Type* struct_type();\n+  void field_decl(Struct_field_list*);\n+  Type* pointer_type();\n+  Type* channel_type();\n+  Function_type* signature(Typed_identifier*, source_location);\n+  Typed_identifier_list* parameters(bool* is_varargs);\n+  Typed_identifier_list* parameter_list(bool* is_varargs);\n+  void parameter_decl(bool, Typed_identifier_list*, bool*, bool*);\n+  Typed_identifier_list* result();\n+  source_location block();\n+  Type* interface_type();\n+  bool method_spec(Typed_identifier_list*);\n+  void declaration();\n+  bool declaration_may_start_here();\n+  void decl(void (Parse::*)(void*), void*);\n+  void list(void (Parse::*)(void*), void*, bool);\n+  void const_decl();\n+  void const_spec(Type**, Expression_list**);\n+  void type_decl();\n+  void type_spec(void*);\n+  void var_decl();\n+  void var_spec(void*);\n+  void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n+\t\t bool is_coloneq, source_location);\n+  bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t   bool is_coloneq, source_location);\n+  bool init_vars_from_map(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t  bool is_coloneq, source_location);\n+  bool init_vars_from_receive(const Typed_identifier_list*, Type*,\n+\t\t\t      Expression*, bool is_coloneq, source_location);\n+  bool init_vars_from_type_guard(const Typed_identifier_list*, Type*,\n+\t\t\t\t Expression*, bool is_coloneq,\n+\t\t\t\t source_location);\n+  Named_object* init_var(const Typed_identifier&, Type*, Expression*,\n+\t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n+  void simple_var_decl_or_assignment(const std::string&, source_location,\n+\t\t\t\t     Range_clause*, Type_switch*);\n+  void function_decl();\n+  Typed_identifier* receiver();\n+  Expression* operand(bool may_be_sink);\n+  Expression* enclosing_var_reference(Named_object*, Named_object*,\n+\t\t\t\t      source_location);\n+  Expression* composite_lit(Type*, int depth, source_location);\n+  Expression* function_lit();\n+  Expression* create_closure(Named_object* function, Enclosing_vars*,\n+\t\t\t     source_location);\n+  Expression* primary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t   bool* is_type_switch);\n+  Expression* selector(Expression*, bool* is_type_switch);\n+  Expression* index(Expression*);\n+  Expression* call(Expression*);\n+  Expression* expression(Precedence, bool may_be_sink,\n+\t\t\t bool may_be_composite_lit, bool* is_type_switch);\n+  bool expression_may_start_here();\n+  Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t bool* is_type_switch);\n+  Expression* qualified_expr(Expression*, source_location);\n+  Expression* id_to_expression(const std::string&, source_location);\n+  void statement(const Label*);\n+  bool statement_may_start_here();\n+  void labeled_stmt(const std::string&, source_location);\n+  Expression* simple_stat(bool, bool, Range_clause*, Type_switch*);\n+  bool simple_stat_may_start_here();\n+  void statement_list();\n+  bool statement_list_may_start_here();\n+  void expression_stat(Expression*);\n+  void inc_dec_stat(Expression*);\n+  void assignment(Expression*, Range_clause*);\n+  void tuple_assignment(Expression_list*, Range_clause*);\n+  void send();\n+  void go_or_defer_stat();\n+  void return_stat();\n+  void if_stat();\n+  void switch_stat(const Label*);\n+  Statement* expr_switch_body(const Label*, Expression*, source_location);\n+  void expr_case_clause(Case_clauses*);\n+  Expression_list* expr_switch_case(bool*);\n+  Statement* type_switch_body(const Label*, const Type_switch&,\n+\t\t\t      source_location);\n+  void type_case_clause(Named_object*, Type_case_clauses*);\n+  void type_switch_case(std::vector<Type*>*, bool*);\n+  void select_stat(const Label*);\n+  void comm_clause(Select_clauses*);\n+  bool comm_case(bool*, Expression**, Expression**, std::string*, bool*);\n+  bool send_or_recv_expr(bool*, Expression**, Expression**, std::string*);\n+  void for_stat(const Label*);\n+  void for_clause(Expression**, Block**);\n+  void range_clause_decl(const Typed_identifier_list*, Range_clause*);\n+  void range_clause_expr(const Expression_list*, Range_clause*);\n+  void push_break_statement(Statement*, const Label*);\n+  void push_continue_statement(Statement*, const Label*);\n+  void pop_break_statement();\n+  void pop_continue_statement();\n+  Statement* find_bc_statement(const Bc_stack*, const std::string&);\n+  void break_stat();\n+  void continue_stat();\n+  void goto_stat();\n+  void package_clause();\n+  void import_decl();\n+  void import_spec(void*);\n+\n+  void reset_iota();\n+  int iota_value();\n+  void increment_iota();\n+\n+  // Skip past an error looking for a semicolon or OP.  Return true if\n+  // all is well, false if we found EOF.\n+  bool\n+  skip_past_error(Operator op);\n+\n+  // Verify that an expression is not a sink, and return either the\n+  // expression or an error.\n+  Expression*\n+  verify_not_sink(Expression*);\n+\n+  // Return the statement associated with a label in a Bc_stack, or\n+  // NULL.\n+  Statement*\n+  find_bc_statement(const Bc_stack*, const std::string&) const;\n+\n+  // The lexer output we are parsing.\n+  Lex* lex_;\n+  // The current token.\n+  Token token_;\n+  // A token pushed back on the input stream.\n+  Token unget_token_;\n+  // Whether unget_token_ is valid.\n+  bool unget_token_valid_;\n+  // The code we are generating.\n+  Gogo* gogo_;\n+  // A stack of statements for which break may be used.\n+  Bc_stack break_stack_;\n+  // A stack of statements for which continue may be used.\n+  Bc_stack continue_stack_;\n+  // The current iota value.\n+  int iota_;\n+  // References from the local function to variables defined in\n+  // enclosing functions.\n+  Enclosing_vars enclosing_vars_;\n+};\n+\n+\n+#endif // !defined(GO_PARSE_H)"}, {"sha": "f072fd35932dee6cd6d05111a459bb2d9b5fbf10", "filename": "gcc/go/gofrontend/parse.h.merge-right.r172891", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.h.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.h.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,309 @@\n+// parse.h -- Go frontend parser.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_PARSE_H\n+#define GO_PARSE_H\n+\n+class Set_iota_traverse;\n+class Lex;\n+class Gogo;\n+class Named_object;\n+class Type;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Block;\n+class Expression;\n+class Expression_list;\n+class Struct_field_list;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Statement;\n+class Label;\n+\n+// Parse the program.\n+\n+class Parse\n+{\n+ public:\n+  Parse(Lex*, Gogo*);\n+\n+  // Parse a program.\n+  void\n+  program();\n+\n+ private:\n+  // Precedence values.\n+  enum Precedence\n+  {\n+    PRECEDENCE_INVALID = -1,\n+    PRECEDENCE_NORMAL = 0,\n+    PRECEDENCE_OROR,\n+    PRECEDENCE_ANDAND,\n+    PRECEDENCE_RELOP,\n+    PRECEDENCE_ADDOP,\n+    PRECEDENCE_MULOP\n+  };\n+\n+  // We use this when parsing the range clause of a for statement.\n+  struct Range_clause\n+  {\n+    // Set to true if we found a range clause.\n+    bool found;\n+    // The index expression.\n+    Expression* index;\n+    // The value expression.\n+    Expression* value;\n+    // The range expression.\n+    Expression* range;\n+\n+    Range_clause()\n+      : found(false), index(NULL), value(NULL), range(NULL)\n+    { }\n+  };\n+\n+  // We use this when parsing the statement at the start of a switch,\n+  // in order to recognize type switches.\n+  struct Type_switch\n+  {\n+    // Set to true if we find a type switch.\n+    bool found;\n+    // The variable name.\n+    std::string name;\n+    // The location of the variable.\n+    source_location location;\n+    // The expression.\n+    Expression* expr;\n+\n+    Type_switch()\n+      : found(false), name(), location(UNKNOWN_LOCATION), expr(NULL)\n+    { }\n+  };\n+\n+  // A variable defined in an enclosing function referenced by the\n+  // current function.\n+  class Enclosing_var\n+  {\n+   public:\n+    Enclosing_var(Named_object* var, Named_object* in_function,\n+\t\t  unsigned int index)\n+      : var_(var), in_function_(in_function), index_(index)\n+    { }\n+\n+    // We put these in a vector, so we need a default constructor.\n+    Enclosing_var()\n+      : var_(NULL), in_function_(NULL), index_(-1U)\n+    { }\n+\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    Named_object*\n+    in_function() const\n+    { return this->in_function_; }\n+\n+    unsigned int\n+    index() const\n+    { return this->index_; }\n+\n+   private:\n+    // The variable which is being referred to.\n+    Named_object* var_;\n+    // The function where the variable is defined.\n+    Named_object* in_function_;\n+    // The index of the field in this function's closure struct for\n+    // this variable.\n+    unsigned int index_;\n+  };\n+\n+  // We store Enclosing_var entries in a set, so we need a comparator.\n+  struct Enclosing_var_comparison\n+  {\n+    bool\n+    operator()(const Enclosing_var&, const Enclosing_var&);\n+  };\n+\n+  // A set of Enclosing_var entries.\n+  typedef std::set<Enclosing_var, Enclosing_var_comparison> Enclosing_vars;\n+\n+  // Peek at the current token from the lexer.\n+  const Token*\n+  peek_token();\n+\n+  // Consume the current token, return the next one.\n+  const Token*\n+  advance_token();\n+\n+  // Push a token back on the input stream.\n+  void\n+  unget_token(const Token&);\n+\n+  // The location of the current token.\n+  source_location\n+  location();\n+\n+  // For break and continue we keep a stack of statements with\n+  // associated labels (if any).  The top of the stack is used for a\n+  // break or continue statement with no label.\n+  typedef std::vector<std::pair<Statement*, Label*> > Bc_stack;\n+\n+  // Parser nonterminals.\n+  void identifier_list(Typed_identifier_list*);\n+  Expression_list* expression_list(Expression*, bool may_be_sink);\n+  bool qualified_ident(std::string*, Named_object**);\n+  Type* type();\n+  bool type_may_start_here();\n+  Type* type_name(bool issue_error);\n+  Type* array_type(bool may_use_ellipsis);\n+  Type* map_type();\n+  Type* struct_type();\n+  void field_decl(Struct_field_list*);\n+  Type* pointer_type();\n+  Type* channel_type();\n+  Function_type* signature(Typed_identifier*, source_location);\n+  bool parameters(Typed_identifier_list**, bool* is_varargs);\n+  Typed_identifier_list* parameter_list(bool* is_varargs);\n+  void parameter_decl(bool, Typed_identifier_list*, bool*, bool*);\n+  bool result(Typed_identifier_list**);\n+  source_location block();\n+  Type* interface_type();\n+  void method_spec(Typed_identifier_list*);\n+  void declaration();\n+  bool declaration_may_start_here();\n+  void decl(void (Parse::*)(void*), void*);\n+  void list(void (Parse::*)(void*), void*, bool);\n+  void const_decl();\n+  void const_spec(Type**, Expression_list**);\n+  void type_decl();\n+  void type_spec(void*);\n+  void var_decl();\n+  void var_spec(void*);\n+  void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n+\t\t bool is_coloneq, source_location);\n+  bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t   bool is_coloneq, source_location);\n+  bool init_vars_from_map(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t  bool is_coloneq, source_location);\n+  bool init_vars_from_receive(const Typed_identifier_list*, Type*,\n+\t\t\t      Expression*, bool is_coloneq, source_location);\n+  bool init_vars_from_type_guard(const Typed_identifier_list*, Type*,\n+\t\t\t\t Expression*, bool is_coloneq,\n+\t\t\t\t source_location);\n+  Named_object* init_var(const Typed_identifier&, Type*, Expression*,\n+\t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n+  Named_object* create_dummy_global(Type*, Expression*, source_location);\n+  void simple_var_decl_or_assignment(const std::string&, source_location,\n+\t\t\t\t     Range_clause*, Type_switch*);\n+  void function_decl();\n+  Typed_identifier* receiver();\n+  Expression* operand(bool may_be_sink);\n+  Expression* enclosing_var_reference(Named_object*, Named_object*,\n+\t\t\t\t      source_location);\n+  Expression* composite_lit(Type*, int depth, source_location);\n+  Expression* function_lit();\n+  Expression* create_closure(Named_object* function, Enclosing_vars*,\n+\t\t\t     source_location);\n+  Expression* primary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t   bool* is_type_switch);\n+  Expression* selector(Expression*, bool* is_type_switch);\n+  Expression* index(Expression*);\n+  Expression* call(Expression*);\n+  Expression* expression(Precedence, bool may_be_sink,\n+\t\t\t bool may_be_composite_lit, bool* is_type_switch);\n+  bool expression_may_start_here();\n+  Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t bool* is_type_switch);\n+  Expression* qualified_expr(Expression*, source_location);\n+  Expression* id_to_expression(const std::string&, source_location);\n+  void statement(Label*);\n+  bool statement_may_start_here();\n+  void labeled_stmt(const std::string&, source_location);\n+  Expression* simple_stat(bool, bool*, Range_clause*, Type_switch*);\n+  bool simple_stat_may_start_here();\n+  void statement_list();\n+  bool statement_list_may_start_here();\n+  void expression_stat(Expression*);\n+  void send_stmt(Expression*);\n+  void inc_dec_stat(Expression*);\n+  void assignment(Expression*, Range_clause*);\n+  void tuple_assignment(Expression_list*, Range_clause*);\n+  void send();\n+  void go_or_defer_stat();\n+  void return_stat();\n+  void if_stat();\n+  void switch_stat(Label*);\n+  Statement* expr_switch_body(Label*, Expression*, source_location);\n+  void expr_case_clause(Case_clauses*, bool* saw_default);\n+  Expression_list* expr_switch_case(bool*);\n+  Statement* type_switch_body(Label*, const Type_switch&, source_location);\n+  void type_case_clause(Named_object*, Type_case_clauses*, bool* saw_default);\n+  void type_switch_case(std::vector<Type*>*, bool*);\n+  void select_stat(Label*);\n+  void comm_clause(Select_clauses*, bool* saw_default);\n+  bool comm_case(bool*, Expression**, Expression**, Expression**,\n+\t\t std::string*, std::string*, bool*);\n+  bool send_or_recv_stmt(bool*, Expression**, Expression**, Expression**,\n+\t\t\t std::string*, std::string*);\n+  void for_stat(Label*);\n+  void for_clause(Expression**, Block**);\n+  void range_clause_decl(const Typed_identifier_list*, Range_clause*);\n+  void range_clause_expr(const Expression_list*, Range_clause*);\n+  void push_break_statement(Statement*, Label*);\n+  void push_continue_statement(Statement*, Label*);\n+  void pop_break_statement();\n+  void pop_continue_statement();\n+  Statement* find_bc_statement(const Bc_stack*, const std::string&);\n+  void break_stat();\n+  void continue_stat();\n+  void goto_stat();\n+  void package_clause();\n+  void import_decl();\n+  void import_spec(void*);\n+\n+  void reset_iota();\n+  int iota_value();\n+  void increment_iota();\n+\n+  // Skip past an error looking for a semicolon or OP.  Return true if\n+  // all is well, false if we found EOF.\n+  bool\n+  skip_past_error(Operator op);\n+\n+  // Verify that an expression is not a sink, and return either the\n+  // expression or an error.\n+  Expression*\n+  verify_not_sink(Expression*);\n+\n+  // Return the statement associated with a label in a Bc_stack, or\n+  // NULL.\n+  Statement*\n+  find_bc_statement(const Bc_stack*, const std::string&) const;\n+\n+  // The lexer output we are parsing.\n+  Lex* lex_;\n+  // The current token.\n+  Token token_;\n+  // A token pushed back on the input stream.\n+  Token unget_token_;\n+  // Whether unget_token_ is valid.\n+  bool unget_token_valid_;\n+  // The code we are generating.\n+  Gogo* gogo_;\n+  // A stack of statements for which break may be used.\n+  Bc_stack* break_stack_;\n+  // A stack of statements for which continue may be used.\n+  Bc_stack* continue_stack_;\n+  // The current iota value.\n+  int iota_;\n+  // References from the local function to variables defined in\n+  // enclosing functions.\n+  Enclosing_vars enclosing_vars_;\n+};\n+\n+\n+#endif // !defined(GO_PARSE_H)"}, {"sha": "d164414df7b8edd1d94502d30fae11a997d1ae63", "filename": "gcc/go/gofrontend/parse.h.working", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.h.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fparse.h.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.h.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,310 @@\n+// parse.h -- Go frontend parser.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_PARSE_H\n+#define GO_PARSE_H\n+\n+class Set_iota_traverse;\n+class Lex;\n+class Gogo;\n+class Named_object;\n+class Type;\n+class Typed_identifier;\n+class Typed_identifier_list;\n+class Function_type;\n+class Block;\n+class Expression;\n+class Expression_list;\n+class Struct_field_list;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Statement;\n+class Label;\n+\n+// Parse the program.\n+\n+class Parse\n+{\n+ public:\n+  Parse(Lex*, Gogo*);\n+\n+  // Parse a program.\n+  void\n+  program();\n+\n+ private:\n+  // Precedence values.\n+  enum Precedence\n+  {\n+    PRECEDENCE_INVALID = -1,\n+    PRECEDENCE_NORMAL = 0,\n+    PRECEDENCE_OROR,\n+    PRECEDENCE_ANDAND,\n+    PRECEDENCE_RELOP,\n+    PRECEDENCE_ADDOP,\n+    PRECEDENCE_MULOP\n+  };\n+\n+  // We use this when parsing the range clause of a for statement.\n+  struct Range_clause\n+  {\n+    // Set to true if we found a range clause.\n+    bool found;\n+    // The index expression.\n+    Expression* index;\n+    // The value expression.\n+    Expression* value;\n+    // The range expression.\n+    Expression* range;\n+\n+    Range_clause()\n+      : found(false), index(NULL), value(NULL), range(NULL)\n+    { }\n+  };\n+\n+  // We use this when parsing the statement at the start of a switch,\n+  // in order to recognize type switches.\n+  struct Type_switch\n+  {\n+    // Set to true if we find a type switch.\n+    bool found;\n+    // The variable name.\n+    std::string name;\n+    // The location of the variable.\n+    source_location location;\n+    // The expression.\n+    Expression* expr;\n+\n+    Type_switch()\n+      : found(false), name(), location(UNKNOWN_LOCATION), expr(NULL)\n+    { }\n+  };\n+\n+  // A variable defined in an enclosing function referenced by the\n+  // current function.\n+  class Enclosing_var\n+  {\n+   public:\n+    Enclosing_var(Named_object* var, Named_object* in_function,\n+\t\t  unsigned int index)\n+      : var_(var), in_function_(in_function), index_(index)\n+    { }\n+\n+    // We put these in a vector, so we need a default constructor.\n+    Enclosing_var()\n+      : var_(NULL), in_function_(NULL), index_(-1U)\n+    { }\n+\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    Named_object*\n+    in_function() const\n+    { return this->in_function_; }\n+\n+    unsigned int\n+    index() const\n+    { return this->index_; }\n+\n+   private:\n+    // The variable which is being referred to.\n+    Named_object* var_;\n+    // The function where the variable is defined.\n+    Named_object* in_function_;\n+    // The index of the field in this function's closure struct for\n+    // this variable.\n+    unsigned int index_;\n+  };\n+\n+  // We store Enclosing_var entries in a set, so we need a comparator.\n+  struct Enclosing_var_comparison\n+  {\n+    bool\n+    operator()(const Enclosing_var&, const Enclosing_var&);\n+  };\n+\n+  // A set of Enclosing_var entries.\n+  typedef std::set<Enclosing_var, Enclosing_var_comparison> Enclosing_vars;\n+\n+  // Peek at the current token from the lexer.\n+  const Token*\n+  peek_token();\n+\n+  // Consume the current token, return the next one.\n+  const Token*\n+  advance_token();\n+\n+  // Push a token back on the input stream.\n+  void\n+  unget_token(const Token&);\n+\n+  // The location of the current token.\n+  source_location\n+  location();\n+\n+  // For break and continue we keep a stack of statements with\n+  // associated labels (if any).  The top of the stack is used for a\n+  // break or continue statement with no label.\n+  typedef std::vector<std::pair<Statement*, const Label*> > Bc_stack;\n+\n+  // Parser nonterminals.\n+  void identifier_list(Typed_identifier_list*);\n+  Expression_list* expression_list(Expression*, bool may_be_sink);\n+  bool qualified_ident(std::string*, Named_object**);\n+  Type* type();\n+  bool type_may_start_here();\n+  Type* type_name(bool issue_error);\n+  Type* array_type(bool may_use_ellipsis);\n+  Type* map_type();\n+  Type* struct_type();\n+  void field_decl(Struct_field_list*);\n+  Type* pointer_type();\n+  Type* channel_type();\n+  Function_type* signature(Typed_identifier*, source_location);\n+  bool parameters(Typed_identifier_list**, bool* is_varargs);\n+  Typed_identifier_list* parameter_list(bool* is_varargs);\n+  void parameter_decl(bool, Typed_identifier_list*, bool*, bool*);\n+  bool result(Typed_identifier_list**);\n+  source_location block();\n+  Type* interface_type();\n+  void method_spec(Typed_identifier_list*);\n+  void declaration();\n+  bool declaration_may_start_here();\n+  void decl(void (Parse::*)(void*), void*);\n+  void list(void (Parse::*)(void*), void*, bool);\n+  void const_decl();\n+  void const_spec(Type**, Expression_list**);\n+  void type_decl();\n+  void type_spec(void*);\n+  void var_decl();\n+  void var_spec(void*);\n+  void init_vars(const Typed_identifier_list*, Type*, Expression_list*,\n+\t\t bool is_coloneq, source_location);\n+  bool init_vars_from_call(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t   bool is_coloneq, source_location);\n+  bool init_vars_from_map(const Typed_identifier_list*, Type*, Expression*,\n+\t\t\t  bool is_coloneq, source_location);\n+  bool init_vars_from_receive(const Typed_identifier_list*, Type*,\n+\t\t\t      Expression*, bool is_coloneq, source_location);\n+  bool init_vars_from_type_guard(const Typed_identifier_list*, Type*,\n+\t\t\t\t Expression*, bool is_coloneq,\n+\t\t\t\t source_location);\n+  Named_object* init_var(const Typed_identifier&, Type*, Expression*,\n+\t\t\t bool is_coloneq, bool type_from_init, bool* is_new);\n+  Named_object* create_dummy_global(Type*, Expression*, source_location);\n+  void simple_var_decl_or_assignment(const std::string&, source_location,\n+\t\t\t\t     Range_clause*, Type_switch*);\n+  void function_decl();\n+  Typed_identifier* receiver();\n+  Expression* operand(bool may_be_sink);\n+  Expression* enclosing_var_reference(Named_object*, Named_object*,\n+\t\t\t\t      source_location);\n+  Expression* composite_lit(Type*, int depth, source_location);\n+  Expression* function_lit();\n+  Expression* create_closure(Named_object* function, Enclosing_vars*,\n+\t\t\t     source_location);\n+  Expression* primary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t   bool* is_type_switch);\n+  Expression* selector(Expression*, bool* is_type_switch);\n+  Expression* index(Expression*);\n+  Expression* call(Expression*);\n+  Expression* expression(Precedence, bool may_be_sink,\n+\t\t\t bool may_be_composite_lit, bool* is_type_switch);\n+  bool expression_may_start_here();\n+  Expression* unary_expr(bool may_be_sink, bool may_be_composite_lit,\n+\t\t\t bool* is_type_switch);\n+  Expression* qualified_expr(Expression*, source_location);\n+  Expression* id_to_expression(const std::string&, source_location);\n+  void statement(const Label*);\n+  bool statement_may_start_here();\n+  void labeled_stmt(const std::string&, source_location);\n+  Expression* simple_stat(bool, bool, Range_clause*, Type_switch*);\n+  bool simple_stat_may_start_here();\n+  void statement_list();\n+  bool statement_list_may_start_here();\n+  void expression_stat(Expression*);\n+  void send_stmt(Expression*);\n+  void inc_dec_stat(Expression*);\n+  void assignment(Expression*, Range_clause*);\n+  void tuple_assignment(Expression_list*, Range_clause*);\n+  void send();\n+  void go_or_defer_stat();\n+  void return_stat();\n+  void if_stat();\n+  void switch_stat(const Label*);\n+  Statement* expr_switch_body(const Label*, Expression*, source_location);\n+  void expr_case_clause(Case_clauses*, bool* saw_default);\n+  Expression_list* expr_switch_case(bool*);\n+  Statement* type_switch_body(const Label*, const Type_switch&,\n+\t\t\t      source_location);\n+  void type_case_clause(Named_object*, Type_case_clauses*, bool* saw_default);\n+  void type_switch_case(std::vector<Type*>*, bool*);\n+  void select_stat(const Label*);\n+  void comm_clause(Select_clauses*, bool* saw_default);\n+  bool comm_case(bool*, Expression**, Expression**, Expression**,\n+\t\t std::string*, std::string*, bool*);\n+  bool send_or_recv_stmt(bool*, Expression**, Expression**, Expression**,\n+\t\t\t std::string*, std::string*);\n+  void for_stat(const Label*);\n+  void for_clause(Expression**, Block**);\n+  void range_clause_decl(const Typed_identifier_list*, Range_clause*);\n+  void range_clause_expr(const Expression_list*, Range_clause*);\n+  void push_break_statement(Statement*, const Label*);\n+  void push_continue_statement(Statement*, const Label*);\n+  void pop_break_statement();\n+  void pop_continue_statement();\n+  Statement* find_bc_statement(const Bc_stack*, const std::string&);\n+  void break_stat();\n+  void continue_stat();\n+  void goto_stat();\n+  void package_clause();\n+  void import_decl();\n+  void import_spec(void*);\n+\n+  void reset_iota();\n+  int iota_value();\n+  void increment_iota();\n+\n+  // Skip past an error looking for a semicolon or OP.  Return true if\n+  // all is well, false if we found EOF.\n+  bool\n+  skip_past_error(Operator op);\n+\n+  // Verify that an expression is not a sink, and return either the\n+  // expression or an error.\n+  Expression*\n+  verify_not_sink(Expression*);\n+\n+  // Return the statement associated with a label in a Bc_stack, or\n+  // NULL.\n+  Statement*\n+  find_bc_statement(const Bc_stack*, const std::string&) const;\n+\n+  // The lexer output we are parsing.\n+  Lex* lex_;\n+  // The current token.\n+  Token token_;\n+  // A token pushed back on the input stream.\n+  Token unget_token_;\n+  // Whether unget_token_ is valid.\n+  bool unget_token_valid_;\n+  // The code we are generating.\n+  Gogo* gogo_;\n+  // A stack of statements for which break may be used.\n+  Bc_stack* break_stack_;\n+  // A stack of statements for which continue may be used.\n+  Bc_stack* continue_stack_;\n+  // The current iota value.\n+  int iota_;\n+  // References from the local function to variables defined in\n+  // enclosing functions.\n+  Enclosing_vars enclosing_vars_;\n+};\n+\n+\n+#endif // !defined(GO_PARSE_H)"}, {"sha": "10fe7e41c564d74c52ff9b536991c69a55cb5cc4", "filename": "gcc/go/gofrontend/statements.cc.merge-left.r167407", "status": "added", "additions": 5146, "deletions": 0, "changes": 5146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "7e422fc94b7169a2b2aa195af83d1c72f1309450", "filename": "gcc/go/gofrontend/statements.cc.merge-right.r172891", "status": "added", "additions": 5073, "deletions": 0, "changes": 5073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "d24d98f4f88e28f4ea5c59e130b1176bfd17e4be", "filename": "gcc/go/gofrontend/statements.cc.working", "status": "added", "additions": 5396, "deletions": 0, "changes": 5396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "6ca586f10a9cf9c9ae0a405f0dd2a698337ee7af", "filename": "gcc/go/gofrontend/statements.h.merge-left.r167407", "status": "added", "additions": 1420, "deletions": 0, "changes": 1420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.h.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.h.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,1420 @@\n+// statements.h -- Go frontend statements.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_STATEMENTS_H\n+#define GO_STATEMENTS_H\n+\n+#include \"operator.h\"\n+\n+class Gogo;\n+class Traverse;\n+class Block;\n+class Function;\n+class Unnamed_label;\n+class Temporary_statement;\n+class Variable_declaration_statement;\n+class Return_statement;\n+class Thunk_statement;\n+class Label_statement;\n+class For_statement;\n+class For_range_statement;\n+class Switch_statement;\n+class Type_switch_statement;\n+class Select_statement;\n+class Variable;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Expression;\n+class Expression_list;\n+class Struct_type;\n+class Call_expression;\n+class Map_index_expression;\n+class Receive_expression;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Typed_identifier_list;\n+\n+// This class is used to traverse assignments made by a statement\n+// which makes assignments.\n+\n+class Traverse_assignments\n+{\n+ public:\n+  Traverse_assignments()\n+  { }\n+\n+  virtual ~Traverse_assignments()\n+  { }\n+\n+  // This is called for a variable initialization.\n+  virtual void\n+  initialize_variable(Named_object*) = 0;\n+\n+  // This is called for each assignment made by the statement.  PLHS\n+  // points to the left hand side, and PRHS points to the right hand\n+  // side.  PRHS may be NULL if there is no associated expression, as\n+  // in the bool set by a non-blocking receive.\n+  virtual void\n+  assignment(Expression** plhs, Expression** prhs) = 0;\n+\n+  // This is called for each expression which is not passed to the\n+  // assignment function.  This is used for some of the statements\n+  // which assign two values, for which there is no expression which\n+  // describes the value.  For ++ and -- the value is passed to both\n+  // the assignment method and the rhs method.  IS_STORED is true if\n+  // this value is being stored directly.  It is false if the value is\n+  // computed but not stored.  IS_LOCAL is true if the value is being\n+  // stored in a local variable or this is being called by a return\n+  // statement.\n+  virtual void\n+  value(Expression**, bool is_stored, bool is_local) = 0;\n+};\n+\n+// A single statement.\n+\n+class Statement\n+{\n+ public:\n+  // The types of statements.\n+  enum Statement_classification\n+  {\n+    STATEMENT_ERROR,\n+    STATEMENT_VARIABLE_DECLARATION,\n+    STATEMENT_TEMPORARY,\n+    STATEMENT_ASSIGNMENT,\n+    STATEMENT_EXPRESSION,\n+    STATEMENT_BLOCK,\n+    STATEMENT_GO,\n+    STATEMENT_DEFER,\n+    STATEMENT_RETURN,\n+    STATEMENT_BREAK_OR_CONTINUE,\n+    STATEMENT_GOTO,\n+    STATEMENT_GOTO_UNNAMED,\n+    STATEMENT_LABEL,\n+    STATEMENT_UNNAMED_LABEL,\n+    STATEMENT_IF,\n+    STATEMENT_CONSTANT_SWITCH,\n+    STATEMENT_SELECT,\n+\n+    // These statements types are created by the parser, but they\n+    // disappear during the lowering pass.\n+    STATEMENT_ASSIGNMENT_OPERATION,\n+    STATEMENT_TUPLE_ASSIGNMENT,\n+    STATEMENT_TUPLE_MAP_ASSIGNMENT,\n+    STATEMENT_MAP_ASSIGNMENT,\n+    STATEMENT_TUPLE_RECEIVE_ASSIGNMENT,\n+    STATEMENT_TUPLE_TYPE_GUARD_ASSIGNMENT,\n+    STATEMENT_INCDEC,\n+    STATEMENT_FOR,\n+    STATEMENT_FOR_RANGE,\n+    STATEMENT_SWITCH,\n+    STATEMENT_TYPE_SWITCH\n+  };\n+\n+  Statement(Statement_classification, source_location);\n+\n+  virtual ~Statement();\n+\n+  // Make a variable declaration.\n+  static Statement*\n+  make_variable_declaration(Named_object*);\n+\n+  // Make a statement which creates a temporary variable and\n+  // initializes it to an expression.  The block is used if the\n+  // temporary variable has to be explicitly destroyed; the variable\n+  // must still be added to the block.  References to the temporary\n+  // variable may be constructed using make_temporary_reference.\n+  // Either the type or the initialization expression may be NULL, but\n+  // not both.\n+  static Temporary_statement*\n+  make_temporary(Type*, Expression*, source_location);\n+\n+  // Make an assignment statement.\n+  static Statement*\n+  make_assignment(Expression*, Expression*, source_location);\n+\n+  // Make an assignment operation (+=, etc.).\n+  static Statement*\n+  make_assignment_operation(Operator, Expression*, Expression*,\n+\t\t\t    source_location);\n+\n+  // Make a tuple assignment statement.\n+  static Statement*\n+  make_tuple_assignment(Expression_list*, Expression_list*, source_location);\n+\n+  // Make an assignment from a map index to a pair of variables.\n+  static Statement*\n+  make_tuple_map_assignment(Expression* val, Expression* present,\n+\t\t\t    Expression*, source_location);\n+\n+  // Make a statement which assigns a pair of values to a map.\n+  static Statement*\n+  make_map_assignment(Expression*, Expression* val,\n+\t\t      Expression* should_set, source_location);\n+\n+  // Make an assignment from a nonblocking receive to a pair of\n+  // variables.\n+  static Statement*\n+  make_tuple_receive_assignment(Expression* val, Expression* success,\n+\t\t\t\tExpression* channel, source_location);\n+\n+  // Make an assignment from a type guard to a pair of variables.\n+  static Statement*\n+  make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n+\t\t\t\t   Expression* expr, Type* type,\n+\t\t\t\t   source_location);\n+\n+  // Make an expression statement from an Expression.\n+  static Statement*\n+  make_statement(Expression*);\n+\n+  // Make a block statement from a Block.  This is an embedded list of\n+  // statements which may also include variable definitions.\n+  static Statement*\n+  make_block_statement(Block*, source_location);\n+\n+  // Make an increment statement.\n+  static Statement*\n+  make_inc_statement(Expression*);\n+\n+  // Make a decrement statement.\n+  static Statement*\n+  make_dec_statement(Expression*);\n+\n+  // Make a go statement.\n+  static Statement*\n+  make_go_statement(Call_expression* call, source_location);\n+\n+  // Make a defer statement.\n+  static Statement*\n+  make_defer_statement(Call_expression* call, source_location);\n+\n+  // Make a return statement.\n+  static Statement*\n+  make_return_statement(const Typed_identifier_list*, Expression_list*,\n+\t\t\tsource_location);\n+\n+  // Make a break statement.\n+  static Statement*\n+  make_break_statement(Unnamed_label* label, source_location);\n+\n+  // Make a continue statement.\n+  static Statement*\n+  make_continue_statement(Unnamed_label* label, source_location);\n+\n+  // Make a goto statement.\n+  static Statement*\n+  make_goto_statement(Label* label, source_location);\n+\n+  // Make a goto statement to an unnamed label.\n+  static Statement*\n+  make_goto_unnamed_statement(Unnamed_label* label, source_location);\n+\n+  // Make a label statement--where the label is defined.\n+  static Statement*\n+  make_label_statement(Label* label, source_location);\n+\n+  // Make an unnamed label statement--where the label is defined.\n+  static Statement*\n+  make_unnamed_label_statement(Unnamed_label* label);\n+\n+  // Make an if statement.\n+  static Statement*\n+  make_if_statement(Expression* cond, Block* then_block, Block* else_block,\n+\t\t    source_location);\n+\n+  // Make a switch statement.\n+  static Switch_statement*\n+  make_switch_statement(Expression* switch_val, source_location);\n+\n+  // Make a type switch statement.\n+  static Type_switch_statement*\n+  make_type_switch_statement(Named_object* var, Expression*, source_location);\n+\n+  // Make a select statement.\n+  static Select_statement*\n+  make_select_statement(source_location);\n+\n+  // Make a for statement.\n+  static For_statement*\n+  make_for_statement(Block* init, Expression* cond, Block* post,\n+\t\t     source_location location);\n+\n+  // Make a for statement with a range clause.\n+  static For_range_statement*\n+  make_for_range_statement(Expression* index_var, Expression* value_var,\n+\t\t\t   Expression* range, source_location);\n+\n+  // Return the statement classification.\n+  Statement_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Get the statement location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Block*, size_t* index, Traverse*);\n+\n+  // Traverse the contents of this statement--the expressions and\n+  // statements which it contains.\n+  int\n+  traverse_contents(Traverse*);\n+\n+  // If this statement assigns some values, it calls a function for\n+  // each value to which this statement assigns a value, and returns\n+  // true.  If this statement does not assign any values, it returns\n+  // false.\n+  bool\n+  traverse_assignments(Traverse_assignments* tassign);\n+\n+  // Lower a statement.  This is called immediately after parsing to\n+  // simplify statements for further processing.  It returns the same\n+  // Statement or a new one.  BLOCK is the block containing this\n+  // statement.\n+  Statement*\n+  lower(Gogo* gogo, Block* block)\n+  { return this->do_lower(gogo, block); }\n+\n+  // Set type information for unnamed constants.\n+  void\n+  determine_types();\n+\n+  // Check types in a statement.  This simply checks that any\n+  // expressions used by the statement have the right type.\n+  void\n+  check_types(Gogo* gogo)\n+  { this->do_check_types(gogo); }\n+\n+  // Return whether this is a block statement.\n+  bool\n+  is_block_statement() const\n+  { return this->classification_ == STATEMENT_BLOCK; }\n+\n+  // If this is a variable declaration statement, return it.\n+  // Otherwise return NULL.\n+  Variable_declaration_statement*\n+  variable_declaration_statement()\n+  {\n+    return this->convert<Variable_declaration_statement,\n+\t\t\t STATEMENT_VARIABLE_DECLARATION>();\n+  }\n+\n+  // If this is a return statement, return it.  Otherwise return NULL.\n+  Return_statement*\n+  return_statement()\n+  { return this->convert<Return_statement, STATEMENT_RETURN>(); }\n+\n+  // If this is a thunk statement (a go or defer statement), return\n+  // it.  Otherwise return NULL.\n+  Thunk_statement*\n+  thunk_statement();\n+\n+  // If this is a label statement, return it.  Otherwise return NULL.\n+  Label_statement*\n+  label_statement()\n+  { return this->convert<Label_statement, STATEMENT_LABEL>(); }\n+\n+  // If this is a for statement, return it.  Otherwise return NULL.\n+  For_statement*\n+  for_statement()\n+  { return this->convert<For_statement, STATEMENT_FOR>(); }\n+\n+  // If this is a for statement over a range clause, return it.\n+  // Otherwise return NULL.\n+  For_range_statement*\n+  for_range_statement()\n+  { return this->convert<For_range_statement, STATEMENT_FOR_RANGE>(); }\n+\n+  // If this is a switch statement, return it.  Otherwise return NULL.\n+  Switch_statement*\n+  switch_statement()\n+  { return this->convert<Switch_statement, STATEMENT_SWITCH>(); }\n+\n+  // If this is a type switch statement, return it.  Otherwise return\n+  // NULL.\n+  Type_switch_statement*\n+  type_switch_statement()\n+  { return this->convert<Type_switch_statement, STATEMENT_TYPE_SWITCH>(); }\n+\n+  // If this is a select statement, return it.  Otherwise return NULL.\n+  Select_statement*\n+  select_statement()\n+  { return this->convert<Select_statement, STATEMENT_SELECT>(); }\n+\n+  // Return true if this statement may fall through--if after\n+  // executing this statement we may go on to execute the following\n+  // statement, if any.\n+  bool\n+  may_fall_through() const\n+  { return this->do_may_fall_through(); }\n+\n+  // Return the tree for a statement.  BLOCK is the enclosing block.\n+  tree\n+  get_tree(Translate_context*);\n+\n+ protected:\n+  // Implemented by child class: traverse the tree.\n+  virtual int\n+  do_traverse(Traverse*) = 0;\n+\n+  // Implemented by child class: traverse assignments.  Any statement\n+  // which includes an assignment should implement this.\n+  virtual bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { return false; }\n+\n+  // Implemented by the child class: lower this statement to a simpler\n+  // one.\n+  virtual Statement*\n+  do_lower(Gogo*, Block*)\n+  { return this; }\n+\n+  // Implemented by child class: set type information for unnamed\n+  // constants.  Any statement which includes an expression needs to\n+  // implement this.\n+  virtual void\n+  do_determine_types()\n+  { }\n+\n+  // Implemented by child class: check types of expressions used in a\n+  // statement.\n+  virtual void\n+  do_check_types(Gogo*)\n+  { }\n+\n+  // Implemented by child class: return true if this statement may\n+  // fall through.\n+  virtual bool\n+  do_may_fall_through() const\n+  { return true; }\n+\n+  // Implemented by child class: return a tree.\n+  virtual tree\n+  do_get_tree(Translate_context*) = 0;\n+\n+  // Traverse an expression in a statement.\n+  int\n+  traverse_expression(Traverse*, Expression**);\n+\n+  // Traverse an expression list in a statement.  The Expression_list\n+  // may be NULL.\n+  int\n+  traverse_expression_list(Traverse*, Expression_list*);\n+\n+  // Traverse a type in a statement.\n+  int\n+  traverse_type(Traverse*, Type*);\n+\n+  // Build a tree node with one operand, setting the location.  The\n+  // first operand really has type \"enum tree_code\", but that enum is\n+  // not defined here.\n+  tree\n+  build_stmt_1(int tree_code_value, tree);\n+\n+  // For children to call when they detect that they are in error.\n+  void\n+  set_is_error();\n+\n+  // For children to call to report an error conveniently.\n+  void\n+  report_error(const char*);\n+\n+  // For children to return an error statement from lower().\n+  static Statement*\n+  make_error_statement(source_location);\n+\n+ private:\n+  // Convert to the desired statement classification, or return NULL.\n+  // This is a controlled dynamic cast.\n+  template<typename Statement_class, Statement_classification sc>\n+  Statement_class*\n+  convert()\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Statement_class, Statement_classification sc>\n+  const Statement_class*\n+  convert() const\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<const Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  // The statement classification.\n+  Statement_classification classification_;\n+  // The location in the input file of the start of this statement.\n+  source_location location_;\n+};\n+\n+// A statement which creates and initializes a temporary variable.\n+\n+class Temporary_statement : public Statement\n+{\n+ public:\n+  Temporary_statement(Type* type, Expression* init, source_location location)\n+    : Statement(STATEMENT_TEMPORARY, location),\n+      type_(type), init_(init), decl_(NULL), is_address_taken_(false)\n+  { }\n+\n+  // Return the type of the temporary variable.\n+  Type*\n+  type() const;\n+\n+  // Return the initialization expression.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Record that something takes the address of this temporary\n+  // variable.\n+  void\n+  set_is_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Return the tree for the temporary variable itself.  This should\n+  // not be called until after the statement itself has been expanded.\n+  tree\n+  get_decl() const\n+  {\n+    gcc_assert(this->decl_ != NULL);\n+    return this->decl_;\n+  }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The type of the temporary variable.\n+  Type* type_;\n+  // The initial value of the temporary variable.  This may be NULL.\n+  Expression* init_;\n+  // The DECL for the temporary variable.\n+  tree decl_;\n+  // True if something takes the address of this temporary variable.\n+  bool is_address_taken_;\n+};\n+\n+// A variable declaration.  This marks the point in the code where a\n+// variable is declared.  The Variable is also attached to a Block.\n+\n+class Variable_declaration_statement : public Statement\n+{\n+ public:\n+  Variable_declaration_statement(Named_object* var);\n+\n+  // The variable being declared.\n+  Named_object*\n+  var()\n+  { return this->var_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  Named_object* var_;\n+};\n+\n+// A return statement.\n+\n+class Return_statement : public Statement\n+{\n+ public:\n+  Return_statement(const Typed_identifier_list* results, Expression_list* vals,\n+\t\t   source_location location)\n+    : Statement(STATEMENT_RETURN, location),\n+      results_(results), vals_(vals)\n+  { }\n+\n+  // The list of values being returned.  This may be NULL.\n+  const Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->traverse_expression_list(traverse, this->vals_); }\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  bool\n+  do_may_fall_through() const\n+  { return false; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The result types of the function we are returning from.  This is\n+  // here because in some of the traversals it is inconvenient to get\n+  // it.\n+  const Typed_identifier_list* results_;\n+  // Return values.  This may be NULL.\n+  Expression_list* vals_;\n+};\n+\n+// Select_clauses holds the clauses of a select statement.  This is\n+// built by the parser.\n+\n+class Select_clauses\n+{\n+ public:\n+  Select_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  IS_SEND is true if this is a send clause,\n+  // false for a receive clause.  For a send clause CHANNEL is the\n+  // channel and VAL is the value to send.  For a receive clause\n+  // CHANNEL is the channel and VAL is either NULL or a Var_expression\n+  // for the variable to set; if VAL is NULL, VAR may be a variable\n+  // which is initialized with the received value.  IS_DEFAULT is true\n+  // if this is the default clause.  STATEMENTS is the list of\n+  // statements to execute.\n+  void\n+  add(bool is_send, Expression* channel, Expression* val, Named_object* var,\n+      bool is_default, Block* statements, source_location location)\n+  {\n+    this->clauses_.push_back(Select_clause(is_send, channel, val, var,\n+\t\t\t\t\t   is_default, statements, location));\n+  }\n+\n+  // Traverse the select clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower statements.\n+  void\n+  lower(Block*);\n+\n+  // Determine types.\n+  void\n+  determine_types();\n+\n+  // Whether the select clauses may fall through to the statement\n+  // which follows the overall select statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return a tree implementing the select statement.\n+  tree\n+  get_tree(Translate_context*, Unnamed_label* break_label, source_location);\n+\n+ private:\n+  // A single clause.\n+  class Select_clause\n+  {\n+   public:\n+    Select_clause()\n+      : channel_(NULL), val_(NULL), var_(NULL), statements_(NULL),\n+\tis_send_(false), is_default_(false)\n+    { }\n+\n+    Select_clause(bool is_send, Expression* channel, Expression* val,\n+\t\t  Named_object* var, bool is_default, Block* statements,\n+\t\t  source_location location)\n+      : channel_(channel), val_(val), var_(var), statements_(statements),\n+\tlocation_(location), is_send_(is_send), is_default_(is_default),\n+\tis_lowered_(false)\n+    { gcc_assert(is_default ? channel == NULL : channel != NULL); }\n+\n+    // Traverse the select clause.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower statements.\n+    void\n+    lower(Block*);\n+\n+    // Determine types.\n+    void\n+    determine_types();\n+\n+    // Return true if this is the default clause.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // Return the channel.  This will return NULL for the default\n+    // clause.\n+    Expression*\n+    channel() const\n+    { return this->channel_; }\n+\n+    // Return the value.  This will return NULL for the default\n+    // clause, or for a receive clause for which no value was given.\n+    Expression*\n+    val() const\n+    { return this->val_; }\n+\n+    // Return the variable to set when a receive clause is also a\n+    // variable definition (v := <- ch).  This will return NULL for\n+    // the default case, or for a send clause, or for a receive clause\n+    // which does not define a variable.\n+    Named_object*\n+    var() const\n+    { return this->var_; }\n+\n+    // Return true for a send, false for a receive.\n+    bool\n+    is_send() const\n+    {\n+      gcc_assert(!this->is_default_);\n+      return this->is_send_;\n+    }\n+\n+    // Return the statements.\n+    const Block*\n+    statements() const\n+    { return this->statements_; }\n+\n+    // Return the location.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Whether this clause may fall through to the statement which\n+    // follows the overall select statement.\n+    bool\n+    may_fall_through() const;\n+\n+    // Return a tree for the statements to execute.\n+    tree\n+    get_statements_tree(Translate_context*);\n+\n+   private:\n+    // The channel.\n+    Expression* channel_;\n+    // The value to send or the variable to set.\n+    Expression* val_;\n+    // The variable to initialize, for \"case a := <- ch\".\n+    Named_object* var_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // The location of this clause.\n+    source_location location_;\n+    // Whether this is a send or a receive.\n+    bool is_send_;\n+    // Whether this is the default.\n+    bool is_default_;\n+    // Whether this has been lowered.\n+    bool is_lowered_;\n+  };\n+\n+  void\n+  add_clause_tree(Translate_context*, int, Select_clause*, Unnamed_label*,\n+\t\t  tree*);\n+\n+  typedef std::vector<Select_clause> Clauses;\n+\n+  Clauses clauses_;\n+};\n+\n+// A select statement.\n+\n+class Select_statement : public Statement\n+{\n+ public:\n+  Select_statement(source_location location)\n+    : Statement(STATEMENT_SELECT, location),\n+      clauses_(NULL), break_label_(NULL), is_lowered_(false)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Select_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this select statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->clauses_->traverse(traverse); }\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  void\n+  do_determine_types()\n+  { this->clauses_->determine_types(); }\n+\n+  bool\n+  do_may_fall_through() const\n+  { return this->clauses_->may_fall_through(); }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The select clauses.\n+  Select_clauses* clauses_;\n+  // The break label.\n+  Unnamed_label* break_label_;\n+  // Whether this statement has been lowered.\n+  bool is_lowered_;\n+};\n+\n+// A statement which requires a thunk: go or defer.\n+\n+class Thunk_statement : public Statement\n+{\n+ public:\n+  Thunk_statement(Statement_classification, Call_expression*,\n+\t\t  source_location);\n+\n+  // Return the call expression.\n+  Expression*\n+  call()\n+  { return this->call_; }\n+\n+  // Simplify a go or defer statement so that it only uses a single\n+  // parameter.\n+  bool\n+  simplify_statement(Gogo*, Block*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  // Return the function and argument trees for the call.\n+  void\n+  get_fn_and_arg(Translate_context*, tree* pfn, tree* parg);\n+\n+ private:\n+  // Return whether this is a simple go statement.\n+  bool\n+  is_simple(Function_type*) const;\n+\n+  // Build the struct to use for a complex case.\n+  Struct_type*\n+  build_struct(Function_type* fntype);\n+\n+  // Build the thunk.\n+  void\n+  build_thunk(Gogo*, const std::string&, Function_type* fntype);\n+\n+  // The field name used in the thunk structure for the function\n+  // pointer.\n+  static const char* const thunk_field_fn;\n+\n+  // The field name used in the thunk structure for the receiver, if\n+  // there is one.\n+  static const char* const thunk_field_receiver;\n+\n+  // Set the name to use for thunk field N.\n+  void\n+  thunk_field_param(int n, char* buf, size_t buflen);\n+\n+  // The function call to be executed in a separate thread (go) or\n+  // later (defer).\n+  Expression* call_;\n+  // The type used for a struct to pass to a thunk, if this is not a\n+  // simple call.\n+  Struct_type* struct_type_;\n+};\n+\n+// A go statement.\n+\n+class Go_statement : public Thunk_statement\n+{\n+ public:\n+  Go_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_GO, call, location)\n+  { }\n+\n+ protected:\n+  tree\n+  do_get_tree(Translate_context*);\n+};\n+\n+// A defer statement.\n+\n+class Defer_statement : public Thunk_statement\n+{\n+ public:\n+  Defer_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_DEFER, call, location)\n+  { }\n+\n+ protected:\n+  tree\n+  do_get_tree(Translate_context*);\n+};\n+\n+// A label statement.\n+\n+class Label_statement : public Statement\n+{\n+ public:\n+  Label_statement(Label* label, source_location location)\n+    : Statement(STATEMENT_LABEL, location),\n+      label_(label)\n+  { }\n+\n+  // Return the label itself.\n+  const Label*\n+  label() const\n+  { return this->label_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The label.\n+  Label* label_;\n+};\n+\n+// A for statement.\n+\n+class For_statement : public Statement\n+{\n+ public:\n+  For_statement(Block* init, Expression* cond, Block* post,\n+\t\tsource_location location)\n+    : Statement(STATEMENT_FOR, location),\n+      init_(init), cond_(cond), post_(post), statements_(NULL),\n+      break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    gcc_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+  // Set the break and continue labels for this statement.\n+  void\n+  set_break_continue_labels(Unnamed_label* break_label,\n+\t\t\t    Unnamed_label* continue_label);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { gcc_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // The initialization statements.  This may be NULL.\n+  Block* init_;\n+  // The condition.  This may be NULL.\n+  Expression* cond_;\n+  // The statements to run after each iteration.  This may be NULL.\n+  Block* post_;\n+  // The statements in the loop itself.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// A for statement over a range clause.\n+\n+class For_range_statement : public Statement\n+{\n+ public:\n+  For_range_statement(Expression* index_var, Expression* value_var,\n+\t\t      Expression* range, source_location location)\n+    : Statement(STATEMENT_FOR_RANGE, location),\n+      index_var_(index_var), value_var_(value_var), range_(range),\n+      statements_(NULL), break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    gcc_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { gcc_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  Expression*\n+  make_range_ref(Named_object*, Temporary_statement*, source_location);\n+\n+  Expression*\n+  call_builtin(Gogo*, const char* funcname, Expression* arg, source_location);\n+\n+  void\n+  lower_range_array(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t    Temporary_statement*, Temporary_statement*,\n+\t\t    Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_string(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t     Temporary_statement*, Temporary_statement*,\n+\t\t     Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_map(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t  Temporary_statement*, Temporary_statement*,\n+\t\t  Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_channel(Gogo*, Block*, Block*, Named_object*,\n+\t\t      Temporary_statement*, Temporary_statement*,\n+\t\t      Temporary_statement*, Block**, Expression**, Block**,\n+\t\t      Block**);\n+\n+  // The variable which is set to the index value.\n+  Expression* index_var_;\n+  // The variable which is set to the element value.  This may be\n+  // NULL.\n+  Expression* value_var_;\n+  // The expression we are ranging over.\n+  Expression* range_;\n+  // The statements in the block.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// Class Case_clauses holds the clauses of a switch statement.  This\n+// is built by the parser.\n+\n+class Case_clauses\n+{\n+ public:\n+  Case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  CASES is a list of case expressions; it may be\n+  // NULL.  IS_DEFAULT is true if this is the default case.\n+  // STATEMENTS is a block of statements.  IS_FALLTHROUGH is true if\n+  // after the statements the case clause should fall through to the\n+  // next clause.\n+  void\n+  add(Expression_list* cases, bool is_default, Block* statements,\n+      bool is_fallthrough, source_location location)\n+  {\n+    this->clauses_.push_back(Case_clause(cases, is_default, statements,\n+\t\t\t\t\t is_fallthrough, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower for a nonconstant switch.\n+  void\n+  lower(Block*, Temporary_statement*, Unnamed_label*) const;\n+\n+  // Determine types of expressions.  The Type parameter is the type\n+  // of the switch value.\n+  void\n+  determine_types(Type*);\n+\n+  // Check types.  The Type parameter is the type of the switch value.\n+  bool\n+  check_types(Type*);\n+\n+  // Return true if all the clauses are constant values.\n+  bool\n+  is_constant() const;\n+\n+  // Return true if these clauses may fall through to the statements\n+  // following the switch statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return the body of a SWITCH_EXPR when all the clauses are\n+  // constants.\n+  tree\n+  get_constant_tree(Translate_context*, Unnamed_label* break_label) const;\n+\n+ private:\n+  // For a constant tree we need to keep a record of constants we have\n+  // already seen.  Note that INTEGER_CST trees are interned.\n+  typedef Unordered_set(tree) Case_constants;\n+\n+  // One case clause.\n+  class Case_clause\n+  {\n+   public:\n+    Case_clause()\n+      : cases_(NULL), statements_(NULL), is_default_(false),\n+\tis_fallthrough_(false), location_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Case_clause(Expression_list* cases, bool is_default, Block* statements,\n+\t\tbool is_fallthrough, source_location location)\n+      : cases_(cases), statements_(statements), is_default_(is_default),\n+\tis_fallthrough_(is_fallthrough), location_(location)\n+    { }\n+\n+    // Whether this clause falls through to the next clause.\n+    bool\n+    is_fallthrough() const\n+    { return this->is_fallthrough_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower for a nonconstant switch.\n+    void\n+    lower(Block*, Temporary_statement*, Unnamed_label*, Unnamed_label*) const;\n+\n+    // Determine types.\n+    void\n+    determine_types(Type*);\n+\n+    // Check types.\n+    bool\n+    check_types(Type*);\n+\n+    // Return true if all the case expressions are constant.\n+    bool\n+    is_constant() const;\n+\n+    // Return true if this clause may fall through to execute the\n+    // statements following the switch statement.  This is not the\n+    // same as whether this clause falls through to the next clause.\n+    bool\n+    may_fall_through() const;\n+\n+    // Build up the body of a SWITCH_EXPR when the case expressions\n+    // are constant.\n+    void\n+    get_constant_tree(Translate_context*, Unnamed_label* break_label,\n+\t\t      Case_constants* case_constants, tree* stmt_list) const;\n+\n+   private:\n+    // The list of case expressions.\n+    Expression_list* cases_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // Whether this falls through after the statements.\n+    bool is_fallthrough_;\n+    // The location of this case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Case_clause;\n+\n+  // The type of the list of clauses.\n+  typedef std::vector<Case_clause> Clauses;\n+\n+  // All the case clauses.\n+  Clauses clauses_;\n+};\n+\n+// A switch statement.\n+\n+class Switch_statement : public Statement\n+{\n+ public:\n+  Switch_statement(Expression* val, source_location location)\n+    : Statement(STATEMENT_SWITCH, location),\n+      val_(val), clauses_(NULL), break_label_(NULL)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Case_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // The value to switch on.  This may be NULL.\n+  Expression* val_;\n+  // The case clauses.\n+  Case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+// Class Type_case_clauses holds the clauses of a type switch\n+// statement.  This is built by the parser.\n+\n+class Type_case_clauses\n+{\n+ public:\n+  Type_case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  TYPE is the type for this clause; it may be\n+  // NULL.  IS_FALLTHROUGH is true if this falls through to the next\n+  // clause; in this case STATEMENTS will be NULL.  IS_DEFAULT is true\n+  // if this is the default case.  STATEMENTS is a block of\n+  // statements; it may be NULL.\n+  void\n+  add(Type* type, bool is_fallthrough, bool is_default, Block* statements,\n+      source_location location)\n+  {\n+    this->clauses_.push_back(Type_case_clause(type, is_fallthrough, is_default,\n+\t\t\t\t\t      statements, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the type case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Check for duplicates.\n+  void\n+  check_duplicates() const;\n+\n+  // Lower to if and goto statements.\n+  void\n+  lower(Block*, Temporary_statement* descriptor_temp,\n+\tUnnamed_label* break_label) const;\n+\n+ private:\n+  // One type case clause.\n+  class Type_case_clause\n+  {\n+   public:\n+    Type_case_clause()\n+      : type_(NULL), statements_(NULL), is_default_(false),\n+\tlocation_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Type_case_clause(Type* type, bool is_fallthrough, bool is_default,\n+\t\t     Block* statements, source_location location)\n+      : type_(type), statements_(statements), is_fallthrough_(is_fallthrough),\n+\tis_default_(is_default), location_(location)\n+    { }\n+\n+    // The type.\n+    Type*\n+    type() const\n+    { return this->type_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this type clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower to if and goto statements.\n+    void\n+    lower(Block*, Temporary_statement* descriptor_temp,\n+\t  Unnamed_label* break_label, Unnamed_label** stmts_label) const;\n+\n+   private:\n+    // The type for this type clause.\n+    Type* type_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this falls through--this is true for \"case T1, T2\".\n+    bool is_fallthrough_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // The location of this type case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Type_case_clause;\n+\n+  // The type of the list of type clauses.\n+  typedef std::vector<Type_case_clause> Type_clauses;\n+\n+  // All the type case clauses.\n+  Type_clauses clauses_;\n+};\n+\n+// A type switch statement.\n+\n+class Type_switch_statement : public Statement\n+{\n+ public:\n+  Type_switch_statement(Named_object* var, Expression* expr,\n+\t\t\tsource_location location)\n+    : Statement(STATEMENT_TYPE_SWITCH, location),\n+      var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n+  { gcc_assert(var == NULL || expr == NULL); }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Type_case_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this type switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // Get the type descriptor.\n+  tree\n+  get_type_descriptor(Translate_context*, Type*, tree);\n+\n+  // The variable holding the value we are switching on.\n+  Named_object* var_;\n+  // The expression we are switching on if there is no variable.\n+  Expression* expr_;\n+  // The type case clauses.\n+  Type_case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+#endif // !defined(GO_STATEMENTS_H)"}, {"sha": "5c27c11796767d5f3f7bfbbbd8c1c87b63abbd73", "filename": "gcc/go/gofrontend/statements.h.merge-right.r172891", "status": "added", "additions": 1446, "deletions": 0, "changes": 1446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.h.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.h.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,1446 @@\n+// statements.h -- Go frontend statements.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_STATEMENTS_H\n+#define GO_STATEMENTS_H\n+\n+#include \"operator.h\"\n+\n+class Gogo;\n+class Traverse;\n+class Block;\n+class Function;\n+class Unnamed_label;\n+class Temporary_statement;\n+class Variable_declaration_statement;\n+class Return_statement;\n+class Thunk_statement;\n+class Label_statement;\n+class For_statement;\n+class For_range_statement;\n+class Switch_statement;\n+class Type_switch_statement;\n+class Send_statement;\n+class Select_statement;\n+class Variable;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Expression;\n+class Expression_list;\n+class Struct_type;\n+class Call_expression;\n+class Map_index_expression;\n+class Receive_expression;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Typed_identifier_list;\n+class Bexpression;\n+class Bstatement;\n+class Bvariable;\n+\n+// This class is used to traverse assignments made by a statement\n+// which makes assignments.\n+\n+class Traverse_assignments\n+{\n+ public:\n+  Traverse_assignments()\n+  { }\n+\n+  virtual ~Traverse_assignments()\n+  { }\n+\n+  // This is called for a variable initialization.\n+  virtual void\n+  initialize_variable(Named_object*) = 0;\n+\n+  // This is called for each assignment made by the statement.  PLHS\n+  // points to the left hand side, and PRHS points to the right hand\n+  // side.  PRHS may be NULL if there is no associated expression, as\n+  // in the bool set by a non-blocking receive.\n+  virtual void\n+  assignment(Expression** plhs, Expression** prhs) = 0;\n+\n+  // This is called for each expression which is not passed to the\n+  // assignment function.  This is used for some of the statements\n+  // which assign two values, for which there is no expression which\n+  // describes the value.  For ++ and -- the value is passed to both\n+  // the assignment method and the rhs method.  IS_STORED is true if\n+  // this value is being stored directly.  It is false if the value is\n+  // computed but not stored.  IS_LOCAL is true if the value is being\n+  // stored in a local variable or this is being called by a return\n+  // statement.\n+  virtual void\n+  value(Expression**, bool is_stored, bool is_local) = 0;\n+};\n+\n+// A single statement.\n+\n+class Statement\n+{\n+ public:\n+  // The types of statements.\n+  enum Statement_classification\n+  {\n+    STATEMENT_ERROR,\n+    STATEMENT_VARIABLE_DECLARATION,\n+    STATEMENT_TEMPORARY,\n+    STATEMENT_ASSIGNMENT,\n+    STATEMENT_EXPRESSION,\n+    STATEMENT_BLOCK,\n+    STATEMENT_GO,\n+    STATEMENT_DEFER,\n+    STATEMENT_RETURN,\n+    STATEMENT_BREAK_OR_CONTINUE,\n+    STATEMENT_GOTO,\n+    STATEMENT_GOTO_UNNAMED,\n+    STATEMENT_LABEL,\n+    STATEMENT_UNNAMED_LABEL,\n+    STATEMENT_IF,\n+    STATEMENT_CONSTANT_SWITCH,\n+    STATEMENT_SEND,\n+    STATEMENT_SELECT,\n+\n+    // These statements types are created by the parser, but they\n+    // disappear during the lowering pass.\n+    STATEMENT_ASSIGNMENT_OPERATION,\n+    STATEMENT_TUPLE_ASSIGNMENT,\n+    STATEMENT_TUPLE_MAP_ASSIGNMENT,\n+    STATEMENT_MAP_ASSIGNMENT,\n+    STATEMENT_TUPLE_RECEIVE_ASSIGNMENT,\n+    STATEMENT_TUPLE_TYPE_GUARD_ASSIGNMENT,\n+    STATEMENT_INCDEC,\n+    STATEMENT_FOR,\n+    STATEMENT_FOR_RANGE,\n+    STATEMENT_SWITCH,\n+    STATEMENT_TYPE_SWITCH\n+  };\n+\n+  Statement(Statement_classification, source_location);\n+\n+  virtual ~Statement();\n+\n+  // Make a variable declaration.\n+  static Statement*\n+  make_variable_declaration(Named_object*);\n+\n+  // Make a statement which creates a temporary variable and\n+  // initializes it to an expression.  The block is used if the\n+  // temporary variable has to be explicitly destroyed; the variable\n+  // must still be added to the block.  References to the temporary\n+  // variable may be constructed using make_temporary_reference.\n+  // Either the type or the initialization expression may be NULL, but\n+  // not both.\n+  static Temporary_statement*\n+  make_temporary(Type*, Expression*, source_location);\n+\n+  // Make an assignment statement.\n+  static Statement*\n+  make_assignment(Expression*, Expression*, source_location);\n+\n+  // Make an assignment operation (+=, etc.).\n+  static Statement*\n+  make_assignment_operation(Operator, Expression*, Expression*,\n+\t\t\t    source_location);\n+\n+  // Make a tuple assignment statement.\n+  static Statement*\n+  make_tuple_assignment(Expression_list*, Expression_list*, source_location);\n+\n+  // Make an assignment from a map index to a pair of variables.\n+  static Statement*\n+  make_tuple_map_assignment(Expression* val, Expression* present,\n+\t\t\t    Expression*, source_location);\n+\n+  // Make a statement which assigns a pair of values to a map.\n+  static Statement*\n+  make_map_assignment(Expression*, Expression* val,\n+\t\t      Expression* should_set, source_location);\n+\n+  // Make an assignment from a nonblocking receive to a pair of\n+  // variables.  FOR_SELECT is true is this is being created for a\n+  // case x, ok := <-c in a select statement.\n+  static Statement*\n+  make_tuple_receive_assignment(Expression* val, Expression* closed,\n+\t\t\t\tExpression* channel, bool for_select,\n+\t\t\t\tsource_location);\n+\n+  // Make an assignment from a type guard to a pair of variables.\n+  static Statement*\n+  make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n+\t\t\t\t   Expression* expr, Type* type,\n+\t\t\t\t   source_location);\n+\n+  // Make an expression statement from an Expression.\n+  static Statement*\n+  make_statement(Expression*);\n+\n+  // Make a block statement from a Block.  This is an embedded list of\n+  // statements which may also include variable definitions.\n+  static Statement*\n+  make_block_statement(Block*, source_location);\n+\n+  // Make an increment statement.\n+  static Statement*\n+  make_inc_statement(Expression*);\n+\n+  // Make a decrement statement.\n+  static Statement*\n+  make_dec_statement(Expression*);\n+\n+  // Make a go statement.\n+  static Statement*\n+  make_go_statement(Call_expression* call, source_location);\n+\n+  // Make a defer statement.\n+  static Statement*\n+  make_defer_statement(Call_expression* call, source_location);\n+\n+  // Make a return statement.\n+  static Statement*\n+  make_return_statement(Expression_list*, source_location);\n+\n+  // Make a break statement.\n+  static Statement*\n+  make_break_statement(Unnamed_label* label, source_location);\n+\n+  // Make a continue statement.\n+  static Statement*\n+  make_continue_statement(Unnamed_label* label, source_location);\n+\n+  // Make a goto statement.\n+  static Statement*\n+  make_goto_statement(Label* label, source_location);\n+\n+  // Make a goto statement to an unnamed label.\n+  static Statement*\n+  make_goto_unnamed_statement(Unnamed_label* label, source_location);\n+\n+  // Make a label statement--where the label is defined.\n+  static Statement*\n+  make_label_statement(Label* label, source_location);\n+\n+  // Make an unnamed label statement--where the label is defined.\n+  static Statement*\n+  make_unnamed_label_statement(Unnamed_label* label);\n+\n+  // Make an if statement.\n+  static Statement*\n+  make_if_statement(Expression* cond, Block* then_block, Block* else_block,\n+\t\t    source_location);\n+\n+  // Make a switch statement.\n+  static Switch_statement*\n+  make_switch_statement(Expression* switch_val, source_location);\n+\n+  // Make a type switch statement.\n+  static Type_switch_statement*\n+  make_type_switch_statement(Named_object* var, Expression*, source_location);\n+\n+  // Make a send statement.\n+  static Send_statement*\n+  make_send_statement(Expression* channel, Expression* val, source_location);\n+\n+  // Make a select statement.\n+  static Select_statement*\n+  make_select_statement(source_location);\n+\n+  // Make a for statement.\n+  static For_statement*\n+  make_for_statement(Block* init, Expression* cond, Block* post,\n+\t\t     source_location location);\n+\n+  // Make a for statement with a range clause.\n+  static For_range_statement*\n+  make_for_range_statement(Expression* index_var, Expression* value_var,\n+\t\t\t   Expression* range, source_location);\n+\n+  // Return the statement classification.\n+  Statement_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Get the statement location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Block*, size_t* index, Traverse*);\n+\n+  // Traverse the contents of this statement--the expressions and\n+  // statements which it contains.\n+  int\n+  traverse_contents(Traverse*);\n+\n+  // If this statement assigns some values, it calls a function for\n+  // each value to which this statement assigns a value, and returns\n+  // true.  If this statement does not assign any values, it returns\n+  // false.\n+  bool\n+  traverse_assignments(Traverse_assignments* tassign);\n+\n+  // Lower a statement.  This is called immediately after parsing to\n+  // simplify statements for further processing.  It returns the same\n+  // Statement or a new one.  FUNCTION is the function containing this\n+  // statement.  BLOCK is the block containing this statement.\n+  Statement*\n+  lower(Gogo* gogo, Named_object* function, Block* block)\n+  { return this->do_lower(gogo, function, block); }\n+\n+  // Set type information for unnamed constants.\n+  void\n+  determine_types();\n+\n+  // Check types in a statement.  This simply checks that any\n+  // expressions used by the statement have the right type.\n+  void\n+  check_types(Gogo* gogo)\n+  { this->do_check_types(gogo); }\n+\n+  // Return whether this is a block statement.\n+  bool\n+  is_block_statement() const\n+  { return this->classification_ == STATEMENT_BLOCK; }\n+\n+  // If this is a variable declaration statement, return it.\n+  // Otherwise return NULL.\n+  Variable_declaration_statement*\n+  variable_declaration_statement()\n+  {\n+    return this->convert<Variable_declaration_statement,\n+\t\t\t STATEMENT_VARIABLE_DECLARATION>();\n+  }\n+\n+  // If this is a return statement, return it.  Otherwise return NULL.\n+  Return_statement*\n+  return_statement()\n+  { return this->convert<Return_statement, STATEMENT_RETURN>(); }\n+\n+  // If this is a thunk statement (a go or defer statement), return\n+  // it.  Otherwise return NULL.\n+  Thunk_statement*\n+  thunk_statement();\n+\n+  // If this is a label statement, return it.  Otherwise return NULL.\n+  Label_statement*\n+  label_statement()\n+  { return this->convert<Label_statement, STATEMENT_LABEL>(); }\n+\n+  // If this is a for statement, return it.  Otherwise return NULL.\n+  For_statement*\n+  for_statement()\n+  { return this->convert<For_statement, STATEMENT_FOR>(); }\n+\n+  // If this is a for statement over a range clause, return it.\n+  // Otherwise return NULL.\n+  For_range_statement*\n+  for_range_statement()\n+  { return this->convert<For_range_statement, STATEMENT_FOR_RANGE>(); }\n+\n+  // If this is a switch statement, return it.  Otherwise return NULL.\n+  Switch_statement*\n+  switch_statement()\n+  { return this->convert<Switch_statement, STATEMENT_SWITCH>(); }\n+\n+  // If this is a type switch statement, return it.  Otherwise return\n+  // NULL.\n+  Type_switch_statement*\n+  type_switch_statement()\n+  { return this->convert<Type_switch_statement, STATEMENT_TYPE_SWITCH>(); }\n+\n+  // If this is a select statement, return it.  Otherwise return NULL.\n+  Select_statement*\n+  select_statement()\n+  { return this->convert<Select_statement, STATEMENT_SELECT>(); }\n+\n+  // Return true if this statement may fall through--if after\n+  // executing this statement we may go on to execute the following\n+  // statement, if any.\n+  bool\n+  may_fall_through() const\n+  { return this->do_may_fall_through(); }\n+\n+  // Convert the statement to the backend representation.\n+  Bstatement*\n+  get_backend(Translate_context*);\n+\n+ protected:\n+  // Implemented by child class: traverse the tree.\n+  virtual int\n+  do_traverse(Traverse*) = 0;\n+\n+  // Implemented by child class: traverse assignments.  Any statement\n+  // which includes an assignment should implement this.\n+  virtual bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { return false; }\n+\n+  // Implemented by the child class: lower this statement to a simpler\n+  // one.\n+  virtual Statement*\n+  do_lower(Gogo*, Named_object*, Block*)\n+  { return this; }\n+\n+  // Implemented by child class: set type information for unnamed\n+  // constants.  Any statement which includes an expression needs to\n+  // implement this.\n+  virtual void\n+  do_determine_types()\n+  { }\n+\n+  // Implemented by child class: check types of expressions used in a\n+  // statement.\n+  virtual void\n+  do_check_types(Gogo*)\n+  { }\n+\n+  // Implemented by child class: return true if this statement may\n+  // fall through.\n+  virtual bool\n+  do_may_fall_through() const\n+  { return true; }\n+\n+  // Implemented by child class: convert to backend representation.\n+  virtual Bstatement*\n+  do_get_backend(Translate_context*) = 0;\n+\n+  // Traverse an expression in a statement.\n+  int\n+  traverse_expression(Traverse*, Expression**);\n+\n+  // Traverse an expression list in a statement.  The Expression_list\n+  // may be NULL.\n+  int\n+  traverse_expression_list(Traverse*, Expression_list*);\n+\n+  // Traverse a type in a statement.\n+  int\n+  traverse_type(Traverse*, Type*);\n+\n+  // For children to call when they detect that they are in error.\n+  void\n+  set_is_error();\n+\n+  // For children to call to report an error conveniently.\n+  void\n+  report_error(const char*);\n+\n+  // For children to return an error statement from lower().\n+  static Statement*\n+  make_error_statement(source_location);\n+\n+ private:\n+  // Convert to the desired statement classification, or return NULL.\n+  // This is a controlled dynamic cast.\n+  template<typename Statement_class, Statement_classification sc>\n+  Statement_class*\n+  convert()\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Statement_class, Statement_classification sc>\n+  const Statement_class*\n+  convert() const\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<const Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  // The statement classification.\n+  Statement_classification classification_;\n+  // The location in the input file of the start of this statement.\n+  source_location location_;\n+};\n+\n+// A statement which creates and initializes a temporary variable.\n+\n+class Temporary_statement : public Statement\n+{\n+ public:\n+  Temporary_statement(Type* type, Expression* init, source_location location)\n+    : Statement(STATEMENT_TEMPORARY, location),\n+      type_(type), init_(init), bvariable_(NULL), is_address_taken_(false)\n+  { }\n+\n+  // Return the type of the temporary variable.\n+  Type*\n+  type() const;\n+\n+  // Record that something takes the address of this temporary\n+  // variable.\n+  void\n+  set_is_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Return the temporary variable.  This should not be called until\n+  // after the statement itself has been converted.\n+  Bvariable*\n+  get_backend_variable(Translate_context*) const;\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  // The type of the temporary variable.\n+  Type* type_;\n+  // The initial value of the temporary variable.  This may be NULL.\n+  Expression* init_;\n+  // The backend representation of the temporary variable.\n+  Bvariable* bvariable_;\n+  // True if something takes the address of this temporary variable.\n+  bool is_address_taken_;\n+};\n+\n+// A variable declaration.  This marks the point in the code where a\n+// variable is declared.  The Variable is also attached to a Block.\n+\n+class Variable_declaration_statement : public Statement\n+{\n+ public:\n+  Variable_declaration_statement(Named_object* var);\n+\n+  // The variable being declared.\n+  Named_object*\n+  var()\n+  { return this->var_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  Named_object* var_;\n+};\n+\n+// A return statement.\n+\n+class Return_statement : public Statement\n+{\n+ public:\n+  Return_statement(Expression_list* vals, source_location location)\n+    : Statement(STATEMENT_RETURN, location),\n+      vals_(vals), is_lowered_(false)\n+  { }\n+\n+  // The list of values being returned.  This may be NULL.\n+  const Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->traverse_expression_list(traverse, this->vals_); }\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  bool\n+  do_may_fall_through() const\n+  { return false; }\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  // Return values.  This may be NULL.\n+  Expression_list* vals_;\n+  // True if this statement has been lowered.\n+  bool is_lowered_;\n+};\n+\n+// A send statement.\n+\n+class Send_statement : public Statement\n+{\n+ public:\n+  Send_statement(Expression* channel, Expression* val,\n+\t\t source_location location)\n+    : Statement(STATEMENT_SEND, location),\n+      channel_(channel), val_(val), for_select_(false)\n+  { }\n+\n+  // Note that this is for a select statement.\n+  void\n+  set_for_select()\n+  { this->for_select_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  // The channel on which to send the value.\n+  Expression* channel_;\n+  // The value to send.\n+  Expression* val_;\n+  // Whether this is for a select statement.\n+  bool for_select_;\n+};\n+\n+// Select_clauses holds the clauses of a select statement.  This is\n+// built by the parser.\n+\n+class Select_clauses\n+{\n+ public:\n+  Select_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  IS_SEND is true if this is a send clause,\n+  // false for a receive clause.  For a send clause CHANNEL is the\n+  // channel and VAL is the value to send.  For a receive clause\n+  // CHANNEL is the channel, VAL is either NULL or a Var_expression\n+  // for the variable to set, and CLOSED is either NULL or a\n+  // Var_expression to set to whether the channel is closed.  If VAL\n+  // is NULL, VAR may be a variable to be initialized with the\n+  // received value, and CLOSEDVAR ma be a variable to be initialized\n+  // with whether the channel is closed.  IS_DEFAULT is true if this\n+  // is the default clause.  STATEMENTS is the list of statements to\n+  // execute.\n+  void\n+  add(bool is_send, Expression* channel, Expression* val, Expression* closed,\n+      Named_object* var, Named_object* closedvar, bool is_default,\n+      Block* statements, source_location location)\n+  {\n+    this->clauses_.push_back(Select_clause(is_send, channel, val, closed, var,\n+\t\t\t\t\t   closedvar, is_default, statements,\n+\t\t\t\t\t   location));\n+  }\n+\n+  // Traverse the select clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower statements.\n+  void\n+  lower(Gogo*, Named_object*, Block*);\n+\n+  // Determine types.\n+  void\n+  determine_types();\n+\n+  // Whether the select clauses may fall through to the statement\n+  // which follows the overall select statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Convert to the backend representation.\n+  Bstatement*\n+  get_backend(Translate_context*, Unnamed_label* break_label, source_location);\n+\n+ private:\n+  // A single clause.\n+  class Select_clause\n+  {\n+   public:\n+    Select_clause()\n+      : channel_(NULL), val_(NULL), closed_(NULL), var_(NULL),\n+\tclosedvar_(NULL), statements_(NULL), is_send_(false),\n+\tis_default_(false)\n+    { }\n+\n+    Select_clause(bool is_send, Expression* channel, Expression* val,\n+\t\t  Expression* closed, Named_object* var,\n+\t\t  Named_object* closedvar, bool is_default, Block* statements,\n+\t\t  source_location location)\n+      : channel_(channel), val_(val), closed_(closed), var_(var),\n+\tclosedvar_(closedvar), statements_(statements), location_(location),\n+\tis_send_(is_send), is_default_(is_default), is_lowered_(false)\n+    { go_assert(is_default ? channel == NULL : channel != NULL); }\n+\n+    // Traverse the select clause.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower statements.\n+    void\n+    lower(Gogo*, Named_object*, Block*);\n+\n+    // Determine types.\n+    void\n+    determine_types();\n+\n+    // Return true if this is the default clause.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // Return the channel.  This will return NULL for the default\n+    // clause.\n+    Expression*\n+    channel() const\n+    { return this->channel_; }\n+\n+    // Return true for a send, false for a receive.\n+    bool\n+    is_send() const\n+    {\n+      go_assert(!this->is_default_);\n+      return this->is_send_;\n+    }\n+\n+    // Return the statements.\n+    const Block*\n+    statements() const\n+    { return this->statements_; }\n+\n+    // Return the location.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Whether this clause may fall through to the statement which\n+    // follows the overall select statement.\n+    bool\n+    may_fall_through() const;\n+\n+    // Convert the statements to the backend representation.\n+    Bstatement*\n+    get_statements_backend(Translate_context*);\n+\n+   private:\n+    // The channel.\n+    Expression* channel_;\n+    // The value to send or the lvalue to receive into.\n+    Expression* val_;\n+    // The lvalue to set to whether the channel is closed on a\n+    // receive.\n+    Expression* closed_;\n+    // The variable to initialize, for \"case a := <-ch\".\n+    Named_object* var_;\n+    // The variable to initialize to whether the channel is closed,\n+    // for \"case a, c := <-ch\".\n+    Named_object* closedvar_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // The location of this clause.\n+    source_location location_;\n+    // Whether this is a send or a receive.\n+    bool is_send_;\n+    // Whether this is the default.\n+    bool is_default_;\n+    // Whether this has been lowered.\n+    bool is_lowered_;\n+  };\n+\n+  void\n+  add_clause_backend(Translate_context*, source_location, int index,\n+\t\t     int case_value, Select_clause*, Unnamed_label*,\n+\t\t     std::vector<std::vector<Bexpression*> >* cases,\n+\t\t     std::vector<Bstatement*>* clauses);\n+\n+  typedef std::vector<Select_clause> Clauses;\n+\n+  Clauses clauses_;\n+};\n+\n+// A select statement.\n+\n+class Select_statement : public Statement\n+{\n+ public:\n+  Select_statement(source_location location)\n+    : Statement(STATEMENT_SELECT, location),\n+      clauses_(NULL), break_label_(NULL), is_lowered_(false)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Select_clauses* clauses)\n+  {\n+    go_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this select statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->clauses_->traverse(traverse); }\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  void\n+  do_determine_types()\n+  { this->clauses_->determine_types(); }\n+\n+  bool\n+  do_may_fall_through() const\n+  { return this->clauses_->may_fall_through(); }\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  // The select clauses.\n+  Select_clauses* clauses_;\n+  // The break label.\n+  Unnamed_label* break_label_;\n+  // Whether this statement has been lowered.\n+  bool is_lowered_;\n+};\n+\n+// A statement which requires a thunk: go or defer.\n+\n+class Thunk_statement : public Statement\n+{\n+ public:\n+  Thunk_statement(Statement_classification, Call_expression*,\n+\t\t  source_location);\n+\n+  // Return the call expression.\n+  Expression*\n+  call()\n+  { return this->call_; }\n+\n+  // Simplify a go or defer statement so that it only uses a single\n+  // parameter.\n+  bool\n+  simplify_statement(Gogo*, Named_object*, Block*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  // Return the function and argument for the call.\n+  bool\n+  get_fn_and_arg(Expression** pfn, Expression** parg);\n+\n+ private:\n+  // Return whether this is a simple go statement.\n+  bool\n+  is_simple(Function_type*) const;\n+\n+  // Build the struct to use for a complex case.\n+  Struct_type*\n+  build_struct(Function_type* fntype);\n+\n+  // Build the thunk.\n+  void\n+  build_thunk(Gogo*, const std::string&, Function_type* fntype);\n+\n+  // The field name used in the thunk structure for the function\n+  // pointer.\n+  static const char* const thunk_field_fn;\n+\n+  // The field name used in the thunk structure for the receiver, if\n+  // there is one.\n+  static const char* const thunk_field_receiver;\n+\n+  // Set the name to use for thunk field N.\n+  void\n+  thunk_field_param(int n, char* buf, size_t buflen);\n+\n+  // The function call to be executed in a separate thread (go) or\n+  // later (defer).\n+  Expression* call_;\n+  // The type used for a struct to pass to a thunk, if this is not a\n+  // simple call.\n+  Struct_type* struct_type_;\n+};\n+\n+// A go statement.\n+\n+class Go_statement : public Thunk_statement\n+{\n+ public:\n+  Go_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_GO, call, location)\n+  { }\n+\n+ protected:\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+};\n+\n+// A defer statement.\n+\n+class Defer_statement : public Thunk_statement\n+{\n+ public:\n+  Defer_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_DEFER, call, location)\n+  { }\n+\n+ protected:\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+};\n+\n+// A label statement.\n+\n+class Label_statement : public Statement\n+{\n+ public:\n+  Label_statement(Label* label, source_location location)\n+    : Statement(STATEMENT_LABEL, location),\n+      label_(label)\n+  { }\n+\n+  // Return the label itself.\n+  const Label*\n+  label() const\n+  { return this->label_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+ private:\n+  // The label.\n+  Label* label_;\n+};\n+\n+// A for statement.\n+\n+class For_statement : public Statement\n+{\n+ public:\n+  For_statement(Block* init, Expression* cond, Block* post,\n+\t\tsource_location location)\n+    : Statement(STATEMENT_FOR, location),\n+      init_(init), cond_(cond), post_(post), statements_(NULL),\n+      break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    go_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+  // Set the break and continue labels for this statement.\n+  void\n+  set_break_continue_labels(Unnamed_label* break_label,\n+\t\t\t    Unnamed_label* continue_label);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { go_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*)\n+  { go_unreachable(); }\n+\n+ private:\n+  // The initialization statements.  This may be NULL.\n+  Block* init_;\n+  // The condition.  This may be NULL.\n+  Expression* cond_;\n+  // The statements to run after each iteration.  This may be NULL.\n+  Block* post_;\n+  // The statements in the loop itself.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// A for statement over a range clause.\n+\n+class For_range_statement : public Statement\n+{\n+ public:\n+  For_range_statement(Expression* index_var, Expression* value_var,\n+\t\t      Expression* range, source_location location)\n+    : Statement(STATEMENT_FOR_RANGE, location),\n+      index_var_(index_var), value_var_(value_var), range_(range),\n+      statements_(NULL), break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    go_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { go_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*)\n+  { go_unreachable(); }\n+\n+ private:\n+  Expression*\n+  make_range_ref(Named_object*, Temporary_statement*, source_location);\n+\n+  Expression*\n+  call_builtin(Gogo*, const char* funcname, Expression* arg, source_location);\n+\n+  void\n+  lower_range_array(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t    Temporary_statement*, Temporary_statement*,\n+\t\t    Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_string(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t     Temporary_statement*, Temporary_statement*,\n+\t\t     Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_map(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t  Temporary_statement*, Temporary_statement*,\n+\t\t  Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_channel(Gogo*, Block*, Block*, Named_object*,\n+\t\t      Temporary_statement*, Temporary_statement*,\n+\t\t      Temporary_statement*, Block**, Expression**, Block**,\n+\t\t      Block**);\n+\n+  // The variable which is set to the index value.\n+  Expression* index_var_;\n+  // The variable which is set to the element value.  This may be\n+  // NULL.\n+  Expression* value_var_;\n+  // The expression we are ranging over.\n+  Expression* range_;\n+  // The statements in the block.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// Class Case_clauses holds the clauses of a switch statement.  This\n+// is built by the parser.\n+\n+class Case_clauses\n+{\n+ public:\n+  Case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  CASES is a list of case expressions; it may be\n+  // NULL.  IS_DEFAULT is true if this is the default case.\n+  // STATEMENTS is a block of statements.  IS_FALLTHROUGH is true if\n+  // after the statements the case clause should fall through to the\n+  // next clause.\n+  void\n+  add(Expression_list* cases, bool is_default, Block* statements,\n+      bool is_fallthrough, source_location location)\n+  {\n+    this->clauses_.push_back(Case_clause(cases, is_default, statements,\n+\t\t\t\t\t is_fallthrough, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower for a nonconstant switch.\n+  void\n+  lower(Block*, Temporary_statement*, Unnamed_label*) const;\n+\n+  // Determine types of expressions.  The Type parameter is the type\n+  // of the switch value.\n+  void\n+  determine_types(Type*);\n+\n+  // Check types.  The Type parameter is the type of the switch value.\n+  bool\n+  check_types(Type*);\n+\n+  // Return true if all the clauses are constant values.\n+  bool\n+  is_constant() const;\n+\n+  // Return true if these clauses may fall through to the statements\n+  // following the switch statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return the body of a SWITCH_EXPR when all the clauses are\n+  // constants.\n+  void\n+  get_backend(Translate_context*, Unnamed_label* break_label,\n+\t      std::vector<std::vector<Bexpression*> >* all_cases,\n+\t      std::vector<Bstatement*>* all_statements) const;\n+\n+ private:\n+  // For a constant switch we need to keep a record of constants we\n+  // have already seen.\n+  class Hash_integer_value;\n+  class Eq_integer_value;\n+  typedef Unordered_set_hash(Expression*, Hash_integer_value,\n+\t\t\t     Eq_integer_value) Case_constants;\n+\n+  // One case clause.\n+  class Case_clause\n+  {\n+   public:\n+    Case_clause()\n+      : cases_(NULL), statements_(NULL), is_default_(false),\n+\tis_fallthrough_(false), location_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Case_clause(Expression_list* cases, bool is_default, Block* statements,\n+\t\tbool is_fallthrough, source_location location)\n+      : cases_(cases), statements_(statements), is_default_(is_default),\n+\tis_fallthrough_(is_fallthrough), location_(location)\n+    { }\n+\n+    // Whether this clause falls through to the next clause.\n+    bool\n+    is_fallthrough() const\n+    { return this->is_fallthrough_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower for a nonconstant switch.\n+    void\n+    lower(Block*, Temporary_statement*, Unnamed_label*, Unnamed_label*) const;\n+\n+    // Determine types.\n+    void\n+    determine_types(Type*);\n+\n+    // Check types.\n+    bool\n+    check_types(Type*);\n+\n+    // Return true if all the case expressions are constant.\n+    bool\n+    is_constant() const;\n+\n+    // Return true if this clause may fall through to execute the\n+    // statements following the switch statement.  This is not the\n+    // same as whether this clause falls through to the next clause.\n+    bool\n+    may_fall_through() const;\n+\n+    // Convert the case values and statements to the backend\n+    // representation.\n+    Bstatement*\n+    get_backend(Translate_context*, Unnamed_label* break_label,\n+\t\tCase_constants*, std::vector<Bexpression*>* cases) const;\n+\n+   private:\n+    // The list of case expressions.\n+    Expression_list* cases_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // Whether this falls through after the statements.\n+    bool is_fallthrough_;\n+    // The location of this case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Case_clause;\n+\n+  // The type of the list of clauses.\n+  typedef std::vector<Case_clause> Clauses;\n+\n+  // All the case clauses.\n+  Clauses clauses_;\n+};\n+\n+// A switch statement.\n+\n+class Switch_statement : public Statement\n+{\n+ public:\n+  Switch_statement(Expression* val, source_location location)\n+    : Statement(STATEMENT_SWITCH, location),\n+      val_(val), clauses_(NULL), break_label_(NULL)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Case_clauses* clauses)\n+  {\n+    go_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*)\n+  { go_unreachable(); }\n+\n+ private:\n+  // The value to switch on.  This may be NULL.\n+  Expression* val_;\n+  // The case clauses.\n+  Case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+// Class Type_case_clauses holds the clauses of a type switch\n+// statement.  This is built by the parser.\n+\n+class Type_case_clauses\n+{\n+ public:\n+  Type_case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  TYPE is the type for this clause; it may be\n+  // NULL.  IS_FALLTHROUGH is true if this falls through to the next\n+  // clause; in this case STATEMENTS will be NULL.  IS_DEFAULT is true\n+  // if this is the default case.  STATEMENTS is a block of\n+  // statements; it may be NULL.\n+  void\n+  add(Type* type, bool is_fallthrough, bool is_default, Block* statements,\n+      source_location location)\n+  {\n+    this->clauses_.push_back(Type_case_clause(type, is_fallthrough, is_default,\n+\t\t\t\t\t      statements, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the type case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Check for duplicates.\n+  void\n+  check_duplicates() const;\n+\n+  // Lower to if and goto statements.\n+  void\n+  lower(Block*, Temporary_statement* descriptor_temp,\n+\tUnnamed_label* break_label) const;\n+\n+ private:\n+  // One type case clause.\n+  class Type_case_clause\n+  {\n+   public:\n+    Type_case_clause()\n+      : type_(NULL), statements_(NULL), is_default_(false),\n+\tlocation_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Type_case_clause(Type* type, bool is_fallthrough, bool is_default,\n+\t\t     Block* statements, source_location location)\n+      : type_(type), statements_(statements), is_fallthrough_(is_fallthrough),\n+\tis_default_(is_default), location_(location)\n+    { }\n+\n+    // The type.\n+    Type*\n+    type() const\n+    { return this->type_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this type clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower to if and goto statements.\n+    void\n+    lower(Block*, Temporary_statement* descriptor_temp,\n+\t  Unnamed_label* break_label, Unnamed_label** stmts_label) const;\n+\n+   private:\n+    // The type for this type clause.\n+    Type* type_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this falls through--this is true for \"case T1, T2\".\n+    bool is_fallthrough_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // The location of this type case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Type_case_clause;\n+\n+  // The type of the list of type clauses.\n+  typedef std::vector<Type_case_clause> Type_clauses;\n+\n+  // All the type case clauses.\n+  Type_clauses clauses_;\n+};\n+\n+// A type switch statement.\n+\n+class Type_switch_statement : public Statement\n+{\n+ public:\n+  Type_switch_statement(Named_object* var, Expression* expr,\n+\t\t\tsource_location location)\n+    : Statement(STATEMENT_TYPE_SWITCH, location),\n+      var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n+  { go_assert(var == NULL || expr == NULL); }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Type_case_clauses* clauses)\n+  {\n+    go_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this type switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*)\n+  { go_unreachable(); }\n+\n+ private:\n+  // The variable holding the value we are switching on.\n+  Named_object* var_;\n+  // The expression we are switching on if there is no variable.\n+  Expression* expr_;\n+  // The type case clauses.\n+  Type_case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+#endif // !defined(GO_STATEMENTS_H)"}, {"sha": "5199981ea64e937036dab7f6f593737c9d6f60c2", "filename": "gcc/go/gofrontend/statements.h.working", "status": "added", "additions": 1461, "deletions": 0, "changes": 1461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.h.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Fstatements.h.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,1461 @@\n+// statements.h -- Go frontend statements.     -*- C++ -*-\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef GO_STATEMENTS_H\n+#define GO_STATEMENTS_H\n+\n+#include \"operator.h\"\n+\n+class Gogo;\n+class Traverse;\n+class Block;\n+class Function;\n+class Unnamed_label;\n+class Temporary_statement;\n+class Variable_declaration_statement;\n+class Return_statement;\n+class Thunk_statement;\n+class Label_statement;\n+class For_statement;\n+class For_range_statement;\n+class Switch_statement;\n+class Type_switch_statement;\n+class Send_statement;\n+class Select_statement;\n+class Variable;\n+class Named_object;\n+class Label;\n+class Translate_context;\n+class Expression;\n+class Expression_list;\n+class Struct_type;\n+class Call_expression;\n+class Map_index_expression;\n+class Receive_expression;\n+class Case_clauses;\n+class Type_case_clauses;\n+class Select_clauses;\n+class Typed_identifier_list;\n+\n+// This class is used to traverse assignments made by a statement\n+// which makes assignments.\n+\n+class Traverse_assignments\n+{\n+ public:\n+  Traverse_assignments()\n+  { }\n+\n+  virtual ~Traverse_assignments()\n+  { }\n+\n+  // This is called for a variable initialization.\n+  virtual void\n+  initialize_variable(Named_object*) = 0;\n+\n+  // This is called for each assignment made by the statement.  PLHS\n+  // points to the left hand side, and PRHS points to the right hand\n+  // side.  PRHS may be NULL if there is no associated expression, as\n+  // in the bool set by a non-blocking receive.\n+  virtual void\n+  assignment(Expression** plhs, Expression** prhs) = 0;\n+\n+  // This is called for each expression which is not passed to the\n+  // assignment function.  This is used for some of the statements\n+  // which assign two values, for which there is no expression which\n+  // describes the value.  For ++ and -- the value is passed to both\n+  // the assignment method and the rhs method.  IS_STORED is true if\n+  // this value is being stored directly.  It is false if the value is\n+  // computed but not stored.  IS_LOCAL is true if the value is being\n+  // stored in a local variable or this is being called by a return\n+  // statement.\n+  virtual void\n+  value(Expression**, bool is_stored, bool is_local) = 0;\n+};\n+\n+// A single statement.\n+\n+class Statement\n+{\n+ public:\n+  // The types of statements.\n+  enum Statement_classification\n+  {\n+    STATEMENT_ERROR,\n+    STATEMENT_VARIABLE_DECLARATION,\n+    STATEMENT_TEMPORARY,\n+    STATEMENT_ASSIGNMENT,\n+    STATEMENT_EXPRESSION,\n+    STATEMENT_BLOCK,\n+    STATEMENT_GO,\n+    STATEMENT_DEFER,\n+    STATEMENT_RETURN,\n+    STATEMENT_BREAK_OR_CONTINUE,\n+    STATEMENT_GOTO,\n+    STATEMENT_GOTO_UNNAMED,\n+    STATEMENT_LABEL,\n+    STATEMENT_UNNAMED_LABEL,\n+    STATEMENT_IF,\n+    STATEMENT_CONSTANT_SWITCH,\n+    STATEMENT_SEND,\n+    STATEMENT_SELECT,\n+\n+    // These statements types are created by the parser, but they\n+    // disappear during the lowering pass.\n+    STATEMENT_ASSIGNMENT_OPERATION,\n+    STATEMENT_TUPLE_ASSIGNMENT,\n+    STATEMENT_TUPLE_MAP_ASSIGNMENT,\n+    STATEMENT_MAP_ASSIGNMENT,\n+    STATEMENT_TUPLE_RECEIVE_ASSIGNMENT,\n+    STATEMENT_TUPLE_TYPE_GUARD_ASSIGNMENT,\n+    STATEMENT_INCDEC,\n+    STATEMENT_FOR,\n+    STATEMENT_FOR_RANGE,\n+    STATEMENT_SWITCH,\n+    STATEMENT_TYPE_SWITCH\n+  };\n+\n+  Statement(Statement_classification, source_location);\n+\n+  virtual ~Statement();\n+\n+  // Make a variable declaration.\n+  static Statement*\n+  make_variable_declaration(Named_object*);\n+\n+  // Make a statement which creates a temporary variable and\n+  // initializes it to an expression.  The block is used if the\n+  // temporary variable has to be explicitly destroyed; the variable\n+  // must still be added to the block.  References to the temporary\n+  // variable may be constructed using make_temporary_reference.\n+  // Either the type or the initialization expression may be NULL, but\n+  // not both.\n+  static Temporary_statement*\n+  make_temporary(Type*, Expression*, source_location);\n+\n+  // Make an assignment statement.\n+  static Statement*\n+  make_assignment(Expression*, Expression*, source_location);\n+\n+  // Make an assignment operation (+=, etc.).\n+  static Statement*\n+  make_assignment_operation(Operator, Expression*, Expression*,\n+\t\t\t    source_location);\n+\n+  // Make a tuple assignment statement.\n+  static Statement*\n+  make_tuple_assignment(Expression_list*, Expression_list*, source_location);\n+\n+  // Make an assignment from a map index to a pair of variables.\n+  static Statement*\n+  make_tuple_map_assignment(Expression* val, Expression* present,\n+\t\t\t    Expression*, source_location);\n+\n+  // Make a statement which assigns a pair of values to a map.\n+  static Statement*\n+  make_map_assignment(Expression*, Expression* val,\n+\t\t      Expression* should_set, source_location);\n+\n+  // Make an assignment from a nonblocking receive to a pair of\n+  // variables.  FOR_SELECT is true is this is being created for a\n+  // case x, ok := <-c in a select statement.\n+  static Statement*\n+  make_tuple_receive_assignment(Expression* val, Expression* closed,\n+\t\t\t\tExpression* channel, bool for_select,\n+\t\t\t\tsource_location);\n+\n+  // Make an assignment from a type guard to a pair of variables.\n+  static Statement*\n+  make_tuple_type_guard_assignment(Expression* val, Expression* ok,\n+\t\t\t\t   Expression* expr, Type* type,\n+\t\t\t\t   source_location);\n+\n+  // Make an expression statement from an Expression.\n+  static Statement*\n+  make_statement(Expression*);\n+\n+  // Make a block statement from a Block.  This is an embedded list of\n+  // statements which may also include variable definitions.\n+  static Statement*\n+  make_block_statement(Block*, source_location);\n+\n+  // Make an increment statement.\n+  static Statement*\n+  make_inc_statement(Expression*);\n+\n+  // Make a decrement statement.\n+  static Statement*\n+  make_dec_statement(Expression*);\n+\n+  // Make a go statement.\n+  static Statement*\n+  make_go_statement(Call_expression* call, source_location);\n+\n+  // Make a defer statement.\n+  static Statement*\n+  make_defer_statement(Call_expression* call, source_location);\n+\n+  // Make a return statement.\n+  static Statement*\n+  make_return_statement(const Typed_identifier_list*, Expression_list*,\n+\t\t\tsource_location);\n+\n+  // Make a break statement.\n+  static Statement*\n+  make_break_statement(Unnamed_label* label, source_location);\n+\n+  // Make a continue statement.\n+  static Statement*\n+  make_continue_statement(Unnamed_label* label, source_location);\n+\n+  // Make a goto statement.\n+  static Statement*\n+  make_goto_statement(Label* label, source_location);\n+\n+  // Make a goto statement to an unnamed label.\n+  static Statement*\n+  make_goto_unnamed_statement(Unnamed_label* label, source_location);\n+\n+  // Make a label statement--where the label is defined.\n+  static Statement*\n+  make_label_statement(Label* label, source_location);\n+\n+  // Make an unnamed label statement--where the label is defined.\n+  static Statement*\n+  make_unnamed_label_statement(Unnamed_label* label);\n+\n+  // Make an if statement.\n+  static Statement*\n+  make_if_statement(Expression* cond, Block* then_block, Block* else_block,\n+\t\t    source_location);\n+\n+  // Make a switch statement.\n+  static Switch_statement*\n+  make_switch_statement(Expression* switch_val, source_location);\n+\n+  // Make a type switch statement.\n+  static Type_switch_statement*\n+  make_type_switch_statement(Named_object* var, Expression*, source_location);\n+\n+  // Make a send statement.\n+  static Send_statement*\n+  make_send_statement(Expression* channel, Expression* val, source_location);\n+\n+  // Make a select statement.\n+  static Select_statement*\n+  make_select_statement(source_location);\n+\n+  // Make a for statement.\n+  static For_statement*\n+  make_for_statement(Block* init, Expression* cond, Block* post,\n+\t\t     source_location location);\n+\n+  // Make a for statement with a range clause.\n+  static For_range_statement*\n+  make_for_range_statement(Expression* index_var, Expression* value_var,\n+\t\t\t   Expression* range, source_location);\n+\n+  // Return the statement classification.\n+  Statement_classification\n+  classification() const\n+  { return this->classification_; }\n+\n+  // Get the statement location.\n+  source_location\n+  location() const\n+  { return this->location_; }\n+\n+  // Traverse the tree.\n+  int\n+  traverse(Block*, size_t* index, Traverse*);\n+\n+  // Traverse the contents of this statement--the expressions and\n+  // statements which it contains.\n+  int\n+  traverse_contents(Traverse*);\n+\n+  // If this statement assigns some values, it calls a function for\n+  // each value to which this statement assigns a value, and returns\n+  // true.  If this statement does not assign any values, it returns\n+  // false.\n+  bool\n+  traverse_assignments(Traverse_assignments* tassign);\n+\n+  // Lower a statement.  This is called immediately after parsing to\n+  // simplify statements for further processing.  It returns the same\n+  // Statement or a new one.  FUNCTION is the function containing this\n+  // statement.  BLOCK is the block containing this statement.\n+  Statement*\n+  lower(Gogo* gogo, Named_object* function, Block* block)\n+  { return this->do_lower(gogo, function, block); }\n+\n+  // Set type information for unnamed constants.\n+  void\n+  determine_types();\n+\n+  // Check types in a statement.  This simply checks that any\n+  // expressions used by the statement have the right type.\n+  void\n+  check_types(Gogo* gogo)\n+  { this->do_check_types(gogo); }\n+\n+  // Return whether this is a block statement.\n+  bool\n+  is_block_statement() const\n+  { return this->classification_ == STATEMENT_BLOCK; }\n+\n+  // If this is a variable declaration statement, return it.\n+  // Otherwise return NULL.\n+  Variable_declaration_statement*\n+  variable_declaration_statement()\n+  {\n+    return this->convert<Variable_declaration_statement,\n+\t\t\t STATEMENT_VARIABLE_DECLARATION>();\n+  }\n+\n+  // If this is a return statement, return it.  Otherwise return NULL.\n+  Return_statement*\n+  return_statement()\n+  { return this->convert<Return_statement, STATEMENT_RETURN>(); }\n+\n+  // If this is a thunk statement (a go or defer statement), return\n+  // it.  Otherwise return NULL.\n+  Thunk_statement*\n+  thunk_statement();\n+\n+  // If this is a label statement, return it.  Otherwise return NULL.\n+  Label_statement*\n+  label_statement()\n+  { return this->convert<Label_statement, STATEMENT_LABEL>(); }\n+\n+  // If this is a for statement, return it.  Otherwise return NULL.\n+  For_statement*\n+  for_statement()\n+  { return this->convert<For_statement, STATEMENT_FOR>(); }\n+\n+  // If this is a for statement over a range clause, return it.\n+  // Otherwise return NULL.\n+  For_range_statement*\n+  for_range_statement()\n+  { return this->convert<For_range_statement, STATEMENT_FOR_RANGE>(); }\n+\n+  // If this is a switch statement, return it.  Otherwise return NULL.\n+  Switch_statement*\n+  switch_statement()\n+  { return this->convert<Switch_statement, STATEMENT_SWITCH>(); }\n+\n+  // If this is a type switch statement, return it.  Otherwise return\n+  // NULL.\n+  Type_switch_statement*\n+  type_switch_statement()\n+  { return this->convert<Type_switch_statement, STATEMENT_TYPE_SWITCH>(); }\n+\n+  // If this is a select statement, return it.  Otherwise return NULL.\n+  Select_statement*\n+  select_statement()\n+  { return this->convert<Select_statement, STATEMENT_SELECT>(); }\n+\n+  // Return true if this statement may fall through--if after\n+  // executing this statement we may go on to execute the following\n+  // statement, if any.\n+  bool\n+  may_fall_through() const\n+  { return this->do_may_fall_through(); }\n+\n+  // Return the tree for a statement.  BLOCK is the enclosing block.\n+  tree\n+  get_tree(Translate_context*);\n+\n+ protected:\n+  // Implemented by child class: traverse the tree.\n+  virtual int\n+  do_traverse(Traverse*) = 0;\n+\n+  // Implemented by child class: traverse assignments.  Any statement\n+  // which includes an assignment should implement this.\n+  virtual bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { return false; }\n+\n+  // Implemented by the child class: lower this statement to a simpler\n+  // one.\n+  virtual Statement*\n+  do_lower(Gogo*, Named_object*, Block*)\n+  { return this; }\n+\n+  // Implemented by child class: set type information for unnamed\n+  // constants.  Any statement which includes an expression needs to\n+  // implement this.\n+  virtual void\n+  do_determine_types()\n+  { }\n+\n+  // Implemented by child class: check types of expressions used in a\n+  // statement.\n+  virtual void\n+  do_check_types(Gogo*)\n+  { }\n+\n+  // Implemented by child class: return true if this statement may\n+  // fall through.\n+  virtual bool\n+  do_may_fall_through() const\n+  { return true; }\n+\n+  // Implemented by child class: return a tree.\n+  virtual tree\n+  do_get_tree(Translate_context*) = 0;\n+\n+  // Traverse an expression in a statement.\n+  int\n+  traverse_expression(Traverse*, Expression**);\n+\n+  // Traverse an expression list in a statement.  The Expression_list\n+  // may be NULL.\n+  int\n+  traverse_expression_list(Traverse*, Expression_list*);\n+\n+  // Traverse a type in a statement.\n+  int\n+  traverse_type(Traverse*, Type*);\n+\n+  // Build a tree node with one operand, setting the location.  The\n+  // first operand really has type \"enum tree_code\", but that enum is\n+  // not defined here.\n+  tree\n+  build_stmt_1(int tree_code_value, tree);\n+\n+  // For children to call when they detect that they are in error.\n+  void\n+  set_is_error();\n+\n+  // For children to call to report an error conveniently.\n+  void\n+  report_error(const char*);\n+\n+  // For children to return an error statement from lower().\n+  static Statement*\n+  make_error_statement(source_location);\n+\n+ private:\n+  // Convert to the desired statement classification, or return NULL.\n+  // This is a controlled dynamic cast.\n+  template<typename Statement_class, Statement_classification sc>\n+  Statement_class*\n+  convert()\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  template<typename Statement_class, Statement_classification sc>\n+  const Statement_class*\n+  convert() const\n+  {\n+    return (this->classification_ == sc\n+\t    ? static_cast<const Statement_class*>(this)\n+\t    : NULL);\n+  }\n+\n+  // The statement classification.\n+  Statement_classification classification_;\n+  // The location in the input file of the start of this statement.\n+  source_location location_;\n+};\n+\n+// A statement which creates and initializes a temporary variable.\n+\n+class Temporary_statement : public Statement\n+{\n+ public:\n+  Temporary_statement(Type* type, Expression* init, source_location location)\n+    : Statement(STATEMENT_TEMPORARY, location),\n+      type_(type), init_(init), decl_(NULL), is_address_taken_(false)\n+  { }\n+\n+  // Return the type of the temporary variable.\n+  Type*\n+  type() const;\n+\n+  // Return the initialization expression.\n+  Expression*\n+  init() const\n+  { return this->init_; }\n+\n+  // Record that something takes the address of this temporary\n+  // variable.\n+  void\n+  set_is_address_taken()\n+  { this->is_address_taken_ = true; }\n+\n+  // Return the tree for the temporary variable itself.  This should\n+  // not be called until after the statement itself has been expanded.\n+  tree\n+  get_decl() const;\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The type of the temporary variable.\n+  Type* type_;\n+  // The initial value of the temporary variable.  This may be NULL.\n+  Expression* init_;\n+  // The DECL for the temporary variable.\n+  tree decl_;\n+  // True if something takes the address of this temporary variable.\n+  bool is_address_taken_;\n+};\n+\n+// A variable declaration.  This marks the point in the code where a\n+// variable is declared.  The Variable is also attached to a Block.\n+\n+class Variable_declaration_statement : public Statement\n+{\n+ public:\n+  Variable_declaration_statement(Named_object* var);\n+\n+  // The variable being declared.\n+  Named_object*\n+  var()\n+  { return this->var_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  Named_object* var_;\n+};\n+\n+// A return statement.\n+\n+class Return_statement : public Statement\n+{\n+ public:\n+  Return_statement(const Typed_identifier_list* results, Expression_list* vals,\n+\t\t   source_location location)\n+    : Statement(STATEMENT_RETURN, location),\n+      results_(results), vals_(vals)\n+  { }\n+\n+  // The list of values being returned.  This may be NULL.\n+  const Expression_list*\n+  vals() const\n+  { return this->vals_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->traverse_expression_list(traverse, this->vals_); }\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  bool\n+  do_may_fall_through() const\n+  { return false; }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The result types of the function we are returning from.  This is\n+  // here because in some of the traversals it is inconvenient to get\n+  // it.\n+  const Typed_identifier_list* results_;\n+  // Return values.  This may be NULL.\n+  Expression_list* vals_;\n+};\n+\n+// A send statement.\n+\n+class Send_statement : public Statement\n+{\n+ public:\n+  Send_statement(Expression* channel, Expression* val,\n+\t\t source_location location)\n+    : Statement(STATEMENT_SEND, location),\n+      channel_(channel), val_(val), for_select_(false)\n+  { }\n+\n+  // Note that this is for a select statement.\n+  void\n+  set_for_select()\n+  { this->for_select_ = true; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The channel on which to send the value.\n+  Expression* channel_;\n+  // The value to send.\n+  Expression* val_;\n+  // Whether this is for a select statement.\n+  bool for_select_;\n+};\n+\n+// Select_clauses holds the clauses of a select statement.  This is\n+// built by the parser.\n+\n+class Select_clauses\n+{\n+ public:\n+  Select_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  IS_SEND is true if this is a send clause,\n+  // false for a receive clause.  For a send clause CHANNEL is the\n+  // channel and VAL is the value to send.  For a receive clause\n+  // CHANNEL is the channel, VAL is either NULL or a Var_expression\n+  // for the variable to set, and CLOSED is either NULL or a\n+  // Var_expression to set to whether the channel is closed.  If VAL\n+  // is NULL, VAR may be a variable to be initialized with the\n+  // received value, and CLOSEDVAR ma be a variable to be initialized\n+  // with whether the channel is closed.  IS_DEFAULT is true if this\n+  // is the default clause.  STATEMENTS is the list of statements to\n+  // execute.\n+  void\n+  add(bool is_send, Expression* channel, Expression* val, Expression* closed,\n+      Named_object* var, Named_object* closedvar, bool is_default,\n+      Block* statements, source_location location)\n+  {\n+    this->clauses_.push_back(Select_clause(is_send, channel, val, closed, var,\n+\t\t\t\t\t   closedvar, is_default, statements,\n+\t\t\t\t\t   location));\n+  }\n+\n+  // Traverse the select clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower statements.\n+  void\n+  lower(Gogo*, Named_object*, Block*);\n+\n+  // Determine types.\n+  void\n+  determine_types();\n+\n+  // Whether the select clauses may fall through to the statement\n+  // which follows the overall select statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return a tree implementing the select statement.\n+  tree\n+  get_tree(Translate_context*, Unnamed_label* break_label, source_location);\n+\n+ private:\n+  // A single clause.\n+  class Select_clause\n+  {\n+   public:\n+    Select_clause()\n+      : channel_(NULL), val_(NULL), closed_(NULL), var_(NULL),\n+\tclosedvar_(NULL), statements_(NULL), is_send_(false),\n+\tis_default_(false)\n+    { }\n+\n+    Select_clause(bool is_send, Expression* channel, Expression* val,\n+\t\t  Expression* closed, Named_object* var,\n+\t\t  Named_object* closedvar, bool is_default, Block* statements,\n+\t\t  source_location location)\n+      : channel_(channel), val_(val), closed_(closed), var_(var),\n+\tclosedvar_(closedvar), statements_(statements), location_(location),\n+\tis_send_(is_send), is_default_(is_default), is_lowered_(false)\n+    { gcc_assert(is_default ? channel == NULL : channel != NULL); }\n+\n+    // Traverse the select clause.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower statements.\n+    void\n+    lower(Gogo*, Named_object*, Block*);\n+\n+    // Determine types.\n+    void\n+    determine_types();\n+\n+    // Return true if this is the default clause.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // Return the channel.  This will return NULL for the default\n+    // clause.\n+    Expression*\n+    channel() const\n+    { return this->channel_; }\n+\n+    // Return true for a send, false for a receive.\n+    bool\n+    is_send() const\n+    {\n+      gcc_assert(!this->is_default_);\n+      return this->is_send_;\n+    }\n+\n+    // Return the statements.\n+    const Block*\n+    statements() const\n+    { return this->statements_; }\n+\n+    // Return the location.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Whether this clause may fall through to the statement which\n+    // follows the overall select statement.\n+    bool\n+    may_fall_through() const;\n+\n+    // Return a tree for the statements to execute.\n+    tree\n+    get_statements_tree(Translate_context*);\n+\n+   private:\n+    // The channel.\n+    Expression* channel_;\n+    // The value to send or the lvalue to receive into.\n+    Expression* val_;\n+    // The lvalue to set to whether the channel is closed on a\n+    // receive.\n+    Expression* closed_;\n+    // The variable to initialize, for \"case a := <-ch\".\n+    Named_object* var_;\n+    // The variable to initialize to whether the channel is closed,\n+    // for \"case a, c := <-ch\".\n+    Named_object* closedvar_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // The location of this clause.\n+    source_location location_;\n+    // Whether this is a send or a receive.\n+    bool is_send_;\n+    // Whether this is the default.\n+    bool is_default_;\n+    // Whether this has been lowered.\n+    bool is_lowered_;\n+  };\n+\n+  void\n+  add_clause_tree(Translate_context*, int, Select_clause*, Unnamed_label*,\n+\t\t  tree*);\n+\n+  typedef std::vector<Select_clause> Clauses;\n+\n+  Clauses clauses_;\n+};\n+\n+// A select statement.\n+\n+class Select_statement : public Statement\n+{\n+ public:\n+  Select_statement(source_location location)\n+    : Statement(STATEMENT_SELECT, location),\n+      clauses_(NULL), break_label_(NULL), is_lowered_(false)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Select_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this select statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->clauses_->traverse(traverse); }\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  void\n+  do_determine_types()\n+  { this->clauses_->determine_types(); }\n+\n+  bool\n+  do_may_fall_through() const\n+  { return this->clauses_->may_fall_through(); }\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The select clauses.\n+  Select_clauses* clauses_;\n+  // The break label.\n+  Unnamed_label* break_label_;\n+  // Whether this statement has been lowered.\n+  bool is_lowered_;\n+};\n+\n+// A statement which requires a thunk: go or defer.\n+\n+class Thunk_statement : public Statement\n+{\n+ public:\n+  Thunk_statement(Statement_classification, Call_expression*,\n+\t\t  source_location);\n+\n+  // Return the call expression.\n+  Expression*\n+  call()\n+  { return this->call_; }\n+\n+  // Simplify a go or defer statement so that it only uses a single\n+  // parameter.\n+  bool\n+  simplify_statement(Gogo*, Block*);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*);\n+\n+  void\n+  do_determine_types();\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  // Return the function and argument trees for the call.\n+  void\n+  get_fn_and_arg(Translate_context*, tree* pfn, tree* parg);\n+\n+ private:\n+  // Return whether this is a simple go statement.\n+  bool\n+  is_simple(Function_type*) const;\n+\n+  // Build the struct to use for a complex case.\n+  Struct_type*\n+  build_struct(Function_type* fntype);\n+\n+  // Build the thunk.\n+  void\n+  build_thunk(Gogo*, const std::string&, Function_type* fntype);\n+\n+  // The field name used in the thunk structure for the function\n+  // pointer.\n+  static const char* const thunk_field_fn;\n+\n+  // The field name used in the thunk structure for the receiver, if\n+  // there is one.\n+  static const char* const thunk_field_receiver;\n+\n+  // Set the name to use for thunk field N.\n+  void\n+  thunk_field_param(int n, char* buf, size_t buflen);\n+\n+  // The function call to be executed in a separate thread (go) or\n+  // later (defer).\n+  Expression* call_;\n+  // The type used for a struct to pass to a thunk, if this is not a\n+  // simple call.\n+  Struct_type* struct_type_;\n+};\n+\n+// A go statement.\n+\n+class Go_statement : public Thunk_statement\n+{\n+ public:\n+  Go_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_GO, call, location)\n+  { }\n+\n+ protected:\n+  tree\n+  do_get_tree(Translate_context*);\n+};\n+\n+// A defer statement.\n+\n+class Defer_statement : public Thunk_statement\n+{\n+ public:\n+  Defer_statement(Call_expression* call, source_location location)\n+    : Thunk_statement(STATEMENT_DEFER, call, location)\n+  { }\n+\n+ protected:\n+  tree\n+  do_get_tree(Translate_context*);\n+};\n+\n+// A label statement.\n+\n+class Label_statement : public Statement\n+{\n+ public:\n+  Label_statement(Label* label, source_location location)\n+    : Statement(STATEMENT_LABEL, location),\n+      label_(label)\n+  { }\n+\n+  // Return the label itself.\n+  const Label*\n+  label() const\n+  { return this->label_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  tree\n+  do_get_tree(Translate_context*);\n+\n+ private:\n+  // The label.\n+  Label* label_;\n+};\n+\n+// A for statement.\n+\n+class For_statement : public Statement\n+{\n+ public:\n+  For_statement(Block* init, Expression* cond, Block* post,\n+\t\tsource_location location)\n+    : Statement(STATEMENT_FOR, location),\n+      init_(init), cond_(cond), post_(post), statements_(NULL),\n+      break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    gcc_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+  // Set the break and continue labels for this statement.\n+  void\n+  set_break_continue_labels(Unnamed_label* break_label,\n+\t\t\t    Unnamed_label* continue_label);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { gcc_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // The initialization statements.  This may be NULL.\n+  Block* init_;\n+  // The condition.  This may be NULL.\n+  Expression* cond_;\n+  // The statements to run after each iteration.  This may be NULL.\n+  Block* post_;\n+  // The statements in the loop itself.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// A for statement over a range clause.\n+\n+class For_range_statement : public Statement\n+{\n+ public:\n+  For_range_statement(Expression* index_var, Expression* value_var,\n+\t\t      Expression* range, source_location location)\n+    : Statement(STATEMENT_FOR_RANGE, location),\n+      index_var_(index_var), value_var_(value_var), range_(range),\n+      statements_(NULL), break_label_(NULL), continue_label_(NULL)\n+  { }\n+\n+  // Add the statements.\n+  void\n+  add_statements(Block* statements)\n+  {\n+    gcc_assert(this->statements_ == NULL);\n+    this->statements_ = statements;\n+  }\n+\n+  // Return the break label for this for statement.\n+  Unnamed_label*\n+  break_label();\n+\n+  // Return the continue label for this for statement.\n+  Unnamed_label*\n+  continue_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_traverse_assignments(Traverse_assignments*)\n+  { gcc_unreachable(); }\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  Expression*\n+  make_range_ref(Named_object*, Temporary_statement*, source_location);\n+\n+  Expression*\n+  call_builtin(Gogo*, const char* funcname, Expression* arg, source_location);\n+\n+  void\n+  lower_range_array(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t    Temporary_statement*, Temporary_statement*,\n+\t\t    Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_string(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t     Temporary_statement*, Temporary_statement*,\n+\t\t     Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_map(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+\t\t  Temporary_statement*, Temporary_statement*,\n+\t\t  Block**, Expression**, Block**, Block**);\n+\n+  void\n+  lower_range_channel(Gogo*, Block*, Block*, Named_object*,\n+\t\t      Temporary_statement*, Temporary_statement*,\n+\t\t      Temporary_statement*, Block**, Expression**, Block**,\n+\t\t      Block**);\n+\n+  // The variable which is set to the index value.\n+  Expression* index_var_;\n+  // The variable which is set to the element value.  This may be\n+  // NULL.\n+  Expression* value_var_;\n+  // The expression we are ranging over.\n+  Expression* range_;\n+  // The statements in the block.\n+  Block* statements_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+  // The continue label, if needed.\n+  Unnamed_label* continue_label_;\n+};\n+\n+// Class Case_clauses holds the clauses of a switch statement.  This\n+// is built by the parser.\n+\n+class Case_clauses\n+{\n+ public:\n+  Case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  CASES is a list of case expressions; it may be\n+  // NULL.  IS_DEFAULT is true if this is the default case.\n+  // STATEMENTS is a block of statements.  IS_FALLTHROUGH is true if\n+  // after the statements the case clause should fall through to the\n+  // next clause.\n+  void\n+  add(Expression_list* cases, bool is_default, Block* statements,\n+      bool is_fallthrough, source_location location)\n+  {\n+    this->clauses_.push_back(Case_clause(cases, is_default, statements,\n+\t\t\t\t\t is_fallthrough, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Lower for a nonconstant switch.\n+  void\n+  lower(Block*, Temporary_statement*, Unnamed_label*) const;\n+\n+  // Determine types of expressions.  The Type parameter is the type\n+  // of the switch value.\n+  void\n+  determine_types(Type*);\n+\n+  // Check types.  The Type parameter is the type of the switch value.\n+  bool\n+  check_types(Type*);\n+\n+  // Return true if all the clauses are constant values.\n+  bool\n+  is_constant() const;\n+\n+  // Return true if these clauses may fall through to the statements\n+  // following the switch statement.\n+  bool\n+  may_fall_through() const;\n+\n+  // Return the body of a SWITCH_EXPR when all the clauses are\n+  // constants.\n+  tree\n+  get_constant_tree(Translate_context*, Unnamed_label* break_label) const;\n+\n+ private:\n+  // For a constant tree we need to keep a record of constants we have\n+  // already seen.  Note that INTEGER_CST trees are interned.\n+  typedef Unordered_set(tree) Case_constants;\n+\n+  // One case clause.\n+  class Case_clause\n+  {\n+   public:\n+    Case_clause()\n+      : cases_(NULL), statements_(NULL), is_default_(false),\n+\tis_fallthrough_(false), location_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Case_clause(Expression_list* cases, bool is_default, Block* statements,\n+\t\tbool is_fallthrough, source_location location)\n+      : cases_(cases), statements_(statements), is_default_(is_default),\n+\tis_fallthrough_(is_fallthrough), location_(location)\n+    { }\n+\n+    // Whether this clause falls through to the next clause.\n+    bool\n+    is_fallthrough() const\n+    { return this->is_fallthrough_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower for a nonconstant switch.\n+    void\n+    lower(Block*, Temporary_statement*, Unnamed_label*, Unnamed_label*) const;\n+\n+    // Determine types.\n+    void\n+    determine_types(Type*);\n+\n+    // Check types.\n+    bool\n+    check_types(Type*);\n+\n+    // Return true if all the case expressions are constant.\n+    bool\n+    is_constant() const;\n+\n+    // Return true if this clause may fall through to execute the\n+    // statements following the switch statement.  This is not the\n+    // same as whether this clause falls through to the next clause.\n+    bool\n+    may_fall_through() const;\n+\n+    // Build up the body of a SWITCH_EXPR when the case expressions\n+    // are constant.\n+    void\n+    get_constant_tree(Translate_context*, Unnamed_label* break_label,\n+\t\t      Case_constants* case_constants, tree* stmt_list) const;\n+\n+   private:\n+    // The list of case expressions.\n+    Expression_list* cases_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // Whether this falls through after the statements.\n+    bool is_fallthrough_;\n+    // The location of this case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Case_clause;\n+\n+  // The type of the list of clauses.\n+  typedef std::vector<Case_clause> Clauses;\n+\n+  // All the case clauses.\n+  Clauses clauses_;\n+};\n+\n+// A switch statement.\n+\n+class Switch_statement : public Statement\n+{\n+ public:\n+  Switch_statement(Expression* val, source_location location)\n+    : Statement(STATEMENT_SWITCH, location),\n+      val_(val), clauses_(NULL), break_label_(NULL)\n+  { }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Case_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // The value to switch on.  This may be NULL.\n+  Expression* val_;\n+  // The case clauses.\n+  Case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+// Class Type_case_clauses holds the clauses of a type switch\n+// statement.  This is built by the parser.\n+\n+class Type_case_clauses\n+{\n+ public:\n+  Type_case_clauses()\n+    : clauses_()\n+  { }\n+\n+  // Add a new clause.  TYPE is the type for this clause; it may be\n+  // NULL.  IS_FALLTHROUGH is true if this falls through to the next\n+  // clause; in this case STATEMENTS will be NULL.  IS_DEFAULT is true\n+  // if this is the default case.  STATEMENTS is a block of\n+  // statements; it may be NULL.\n+  void\n+  add(Type* type, bool is_fallthrough, bool is_default, Block* statements,\n+      source_location location)\n+  {\n+    this->clauses_.push_back(Type_case_clause(type, is_fallthrough, is_default,\n+\t\t\t\t\t      statements, location));\n+  }\n+\n+  // Return whether there are no clauses.\n+  bool\n+  empty() const\n+  { return this->clauses_.empty(); }\n+\n+  // Traverse the type case clauses.\n+  int\n+  traverse(Traverse*);\n+\n+  // Check for duplicates.\n+  void\n+  check_duplicates() const;\n+\n+  // Lower to if and goto statements.\n+  void\n+  lower(Block*, Temporary_statement* descriptor_temp,\n+\tUnnamed_label* break_label) const;\n+\n+ private:\n+  // One type case clause.\n+  class Type_case_clause\n+  {\n+   public:\n+    Type_case_clause()\n+      : type_(NULL), statements_(NULL), is_default_(false),\n+\tlocation_(UNKNOWN_LOCATION)\n+    { }\n+\n+    Type_case_clause(Type* type, bool is_fallthrough, bool is_default,\n+\t\t     Block* statements, source_location location)\n+      : type_(type), statements_(statements), is_fallthrough_(is_fallthrough),\n+\tis_default_(is_default), location_(location)\n+    { }\n+\n+    // The type.\n+    Type*\n+    type() const\n+    { return this->type_; }\n+\n+    // Whether this is the default.\n+    bool\n+    is_default() const\n+    { return this->is_default_; }\n+\n+    // The location of this type clause.\n+    source_location\n+    location() const\n+    { return this->location_; }\n+\n+    // Traversal.\n+    int\n+    traverse(Traverse*);\n+\n+    // Lower to if and goto statements.\n+    void\n+    lower(Block*, Temporary_statement* descriptor_temp,\n+\t  Unnamed_label* break_label, Unnamed_label** stmts_label) const;\n+\n+   private:\n+    // The type for this type clause.\n+    Type* type_;\n+    // The statements to execute.\n+    Block* statements_;\n+    // Whether this falls through--this is true for \"case T1, T2\".\n+    bool is_fallthrough_;\n+    // Whether this is the default case.\n+    bool is_default_;\n+    // The location of this type case clause.\n+    source_location location_;\n+  };\n+\n+  friend class Type_case_clause;\n+\n+  // The type of the list of type clauses.\n+  typedef std::vector<Type_case_clause> Type_clauses;\n+\n+  // All the type case clauses.\n+  Type_clauses clauses_;\n+};\n+\n+// A type switch statement.\n+\n+class Type_switch_statement : public Statement\n+{\n+ public:\n+  Type_switch_statement(Named_object* var, Expression* expr,\n+\t\t\tsource_location location)\n+    : Statement(STATEMENT_TYPE_SWITCH, location),\n+      var_(var), expr_(expr), clauses_(NULL), break_label_(NULL)\n+  { gcc_assert(var == NULL || expr == NULL); }\n+\n+  // Add the clauses.\n+  void\n+  add_clauses(Type_case_clauses* clauses)\n+  {\n+    gcc_assert(this->clauses_ == NULL);\n+    this->clauses_ = clauses;\n+  }\n+\n+  // Return the break label for this type switch statement.\n+  Unnamed_label*\n+  break_label();\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Statement*\n+  do_lower(Gogo*, Named_object*, Block*);\n+\n+  tree\n+  do_get_tree(Translate_context*)\n+  { gcc_unreachable(); }\n+\n+ private:\n+  // Get the type descriptor.\n+  tree\n+  get_type_descriptor(Translate_context*, Type*, tree);\n+\n+  // The variable holding the value we are switching on.\n+  Named_object* var_;\n+  // The expression we are switching on if there is no variable.\n+  Expression* expr_;\n+  // The type case clauses.\n+  Type_case_clauses* clauses_;\n+  // The break label, if needed.\n+  Unnamed_label* break_label_;\n+};\n+\n+#endif // !defined(GO_STATEMENTS_H)"}, {"sha": "b030a420fe04ca8ae6d2f348fcfe6f9d14786418", "filename": "gcc/go/gofrontend/types.cc.merge-left.r167407", "status": "added", "additions": 8078, "deletions": 0, "changes": 8078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "86d65c1a0480f72a5e4fee788d3df2d475b2dfb3", "filename": "gcc/go/gofrontend/types.cc.merge-right.r172891", "status": "added", "additions": 8676, "deletions": 0, "changes": 8676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "2eecafd89d6d2e579b21a7f2a1b373ca30ad8ad4", "filename": "gcc/go/gofrontend/types.cc.working", "status": "added", "additions": 8656, "deletions": 0, "changes": 8656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf"}, {"sha": "51d812b3d8f3967ec94086a57a8874d346b2bf99", "filename": "gcc/go/gofrontend/unsafe.cc.merge-left.r167407", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.merge-left.r167407", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.merge-left.r167407", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.merge-left.r167407?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,134 @@\n+// unsafe.cc -- Go frontend builtin unsafe package.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"types.h\"\n+#include \"gogo.h\"\n+\n+// Set up the builtin unsafe package.  This should probably be driven\n+// by a table.\n+\n+void\n+Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n+\t\t    source_location location)\n+{\n+  location_t bloc = BUILTINS_LOCATION;\n+\n+  bool add_to_globals;\n+  Package* package = this->add_imported_package(\"unsafe\", local_name,\n+\t\t\t\t\t\tis_local_name_exported,\n+\t\t\t\t\t\t\"libgo_unsafe\",\n+\t\t\t\t\t\tlocation, &add_to_globals);\n+  package->set_is_imported();\n+\n+  Bindings* bindings = package->bindings();\n+\n+  // The type may have already been created by an import.\n+  Named_object* no = package->bindings()->lookup(\"Pointer\");\n+  if (no == NULL)\n+    {\n+      Type* type = Type::make_pointer_type(Type::make_void_type());\n+      no = bindings->add_type(\"Pointer\", package, type, UNKNOWN_LOCATION);\n+    }\n+  else\n+    {\n+      gcc_assert(no->package() == package);\n+      gcc_assert(no->is_type());\n+      gcc_assert(no->type_value()->is_unsafe_pointer_type());\n+      no->type_value()->set_is_visible();\n+    }\n+  Named_type* pointer_type = no->type_value();\n+  if (add_to_globals)\n+    this->add_named_type(pointer_type);\n+\n+  Type* int_type = this->lookup_global(\"int\")->type_value();\n+\n+  // Sizeof.\n+  Typed_identifier_list* results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  Function_type* fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Sizeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Offsetof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Offsetof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Alignof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Alignof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Typeof.\n+  Type* empty_interface = Type::make_interface_type(NULL, bloc);\n+  Typed_identifier_list* parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"i\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Typeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Reflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"it\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Reflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Unreflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"addr\", pointer_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Unreflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // New.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"New\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // NewArray.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"n\", int_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"NewArray\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  this->imported_unsafe_ = true;\n+}"}, {"sha": "80b367cc46d4b6fc03cfc44236e00a99a642bf8d", "filename": "gcc/go/gofrontend/unsafe.cc.merge-right.r172891", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.merge-right.r172891", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.merge-right.r172891", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.merge-right.r172891?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,146 @@\n+// unsafe.cc -- Go frontend builtin unsafe package.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+#include \"types.h\"\n+#include \"gogo.h\"\n+\n+// Set up the builtin unsafe package.  This should probably be driven\n+// by a table.\n+\n+void\n+Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n+\t\t    source_location location)\n+{\n+  location_t bloc = BUILTINS_LOCATION;\n+\n+  bool add_to_globals;\n+  Package* package = this->add_imported_package(\"unsafe\", local_name,\n+\t\t\t\t\t\tis_local_name_exported,\n+\t\t\t\t\t\t\"libgo_unsafe\",\n+\t\t\t\t\t\tlocation, &add_to_globals);\n+\n+  if (package == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return;\n+    }\n+\n+  package->set_is_imported();\n+\n+  Bindings* bindings = package->bindings();\n+\n+  // The type may have already been created by an import.\n+  Named_object* no = package->bindings()->lookup(\"Pointer\");\n+  if (no == NULL)\n+    {\n+      Type* type = Type::make_pointer_type(Type::make_void_type());\n+      no = bindings->add_type(\"Pointer\", package, type, UNKNOWN_LOCATION);\n+    }\n+  else\n+    {\n+      go_assert(no->package() == package);\n+      go_assert(no->is_type());\n+      go_assert(no->type_value()->is_unsafe_pointer_type());\n+      no->type_value()->set_is_visible();\n+    }\n+  Named_type* pointer_type = no->type_value();\n+  if (add_to_globals)\n+    this->add_named_type(pointer_type);\n+\n+  Type* int_type = this->lookup_global(\"int\")->type_value();\n+\n+  // Sizeof.\n+  Typed_identifier_list* results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  Function_type* fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Sizeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Offsetof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Offsetof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Alignof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Alignof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Typeof.\n+  Type* empty_interface = Type::make_interface_type(NULL, bloc);\n+  Typed_identifier_list* parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"i\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Typeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Reflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"it\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Reflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Unreflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"addr\", pointer_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Unreflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // New.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"New\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // NewArray.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"n\", int_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"NewArray\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  if (!this->imported_unsafe_)\n+    {\n+      go_imported_unsafe();\n+      this->imported_unsafe_ = true;\n+    }\n+}"}, {"sha": "9d51b4d94244729e705d37fd42523c790b2160f7", "filename": "gcc/go/gofrontend/unsafe.cc.working", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.working", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67f8f44952324f3eb6ae564a696b8ee04efccccf/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.working", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Funsafe.cc.working?ref=67f8f44952324f3eb6ae564a696b8ee04efccccf", "patch": "@@ -0,0 +1,146 @@\n+// unsafe.cc -- Go frontend builtin unsafe package.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"go-system.h\"\n+\n+#include \"go-c.h\"\n+#include \"types.h\"\n+#include \"gogo.h\"\n+\n+// Set up the builtin unsafe package.  This should probably be driven\n+// by a table.\n+\n+void\n+Gogo::import_unsafe(const std::string& local_name, bool is_local_name_exported,\n+\t\t    source_location location)\n+{\n+  location_t bloc = BUILTINS_LOCATION;\n+\n+  bool add_to_globals;\n+  Package* package = this->add_imported_package(\"unsafe\", local_name,\n+\t\t\t\t\t\tis_local_name_exported,\n+\t\t\t\t\t\t\"libgo_unsafe\",\n+\t\t\t\t\t\tlocation, &add_to_globals);\n+\n+  if (package == NULL)\n+    {\n+      gcc_assert(saw_errors());\n+      return;\n+    }\n+\n+  package->set_is_imported();\n+\n+  Bindings* bindings = package->bindings();\n+\n+  // The type may have already been created by an import.\n+  Named_object* no = package->bindings()->lookup(\"Pointer\");\n+  if (no == NULL)\n+    {\n+      Type* type = Type::make_pointer_type(Type::make_void_type());\n+      no = bindings->add_type(\"Pointer\", package, type, UNKNOWN_LOCATION);\n+    }\n+  else\n+    {\n+      gcc_assert(no->package() == package);\n+      gcc_assert(no->is_type());\n+      gcc_assert(no->type_value()->is_unsafe_pointer_type());\n+      no->type_value()->set_is_visible();\n+    }\n+  Named_type* pointer_type = no->type_value();\n+  if (add_to_globals)\n+    this->add_named_type(pointer_type);\n+\n+  Type* int_type = this->lookup_global(\"int\")->type_value();\n+\n+  // Sizeof.\n+  Typed_identifier_list* results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  Function_type* fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Sizeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Offsetof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Offsetof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Alignof.\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", int_type, bloc));\n+  fntype = Type::make_function_type(NULL, NULL, results, bloc);\n+  fntype->set_is_varargs();\n+  fntype->set_is_builtin();\n+  no = bindings->add_function_declaration(\"Alignof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Typeof.\n+  Type* empty_interface = Type::make_interface_type(NULL, bloc);\n+  Typed_identifier_list* parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"i\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Typeof\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Reflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"it\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Reflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // Unreflect.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"addr\", pointer_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", empty_interface, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"Unreflect\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // New.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"New\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  // NewArray.\n+  parameters = new Typed_identifier_list;\n+  parameters->push_back(Typed_identifier(\"typ\", empty_interface, bloc));\n+  parameters->push_back(Typed_identifier(\"n\", int_type, bloc));\n+  results = new Typed_identifier_list;\n+  results->push_back(Typed_identifier(\"\", pointer_type, bloc));\n+  fntype = Type::make_function_type(NULL, parameters, results, bloc);\n+  no = bindings->add_function_declaration(\"NewArray\", package, fntype, bloc);\n+  if (add_to_globals)\n+    this->add_named_object(no);\n+\n+  if (!this->imported_unsafe_)\n+    {\n+      go_imported_unsafe();\n+      this->imported_unsafe_ = true;\n+    }\n+}"}]}