{"sha": "e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwNzk4NGYzMGE5ZDIwYTc1ZDQ2YjJjMzhiYjI2YmI0ZmRhYTlmZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-08-27T17:33:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-08-27T17:33:35Z"}, "message": "search.c: Tear out all mi_matrix and memoize code.\n\n\t* search.c: Tear out all mi_matrix and memoize code.\n\t(lookup_field, lookup_fnfields): Use scratch_tree_cons.\n\t* lang-options.h: Remove documentation for -fhandle-exceptions,\n\t-fmemoize-lookups and -fsave-memoized.\n\t* cp-tree.h: Lose mi_matrix and memoize support.\n\t* decl2.c: Ignore -fmemoize-lookups and -fsave-memoized.\n\t* class.c: Lose struct class_level.\n\t(pushclass, popclass): Lose memoize support.\n\t* init.c (build_offset_ref): Likewise.\n\nFrom-SVN: r22025", "tree": {"sha": "a6b3c3bd33b99a816ee359eee13a8c73796615a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6b3c3bd33b99a816ee359eee13a8c73796615a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/comments", "author": null, "committer": null, "parents": [{"sha": "dfbcd65a0152513db985a552f7e75e24cb2be4d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfbcd65a0152513db985a552f7e75e24cb2be4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfbcd65a0152513db985a552f7e75e24cb2be4d5"}], "stats": {"total": 770, "additions": 35, "deletions": 735}, "files": [{"sha": "c23c4c8591670e446a8c6ea026c8a216f7f88cb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -1,5 +1,15 @@\n 1998-08-27  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* search.c: Tear out all mi_matrix and memoize code.\n+\t(lookup_field, lookup_fnfields): Use scratch_tree_cons.\n+\t* lang-options.h: Remove documentation for -fhandle-exceptions,\n+\t-fmemoize-lookups and -fsave-memoized.\n+\t* cp-tree.h: Lose mi_matrix and memoize support.\n+\t* decl2.c: Ignore -fmemoize-lookups and -fsave-memoized.\n+\t* class.c: Lose struct class_level.\n+\t(pushclass, popclass): Lose memoize support.\n+\t* init.c (build_offset_ref): Likewise.\n+\n \tNever change BINFO_INHERITANCE_CHAIN.\n \t* init.c (emit_base_init): Change modification of\n \tBINFO_INHERITANCE_CHAIN to an assert."}, {"sha": "c8273e5757f88b92e36096d93f78e6cde447bf37", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -48,31 +48,6 @@ static tree *current_class_base, *current_class_stack;\n static int current_class_stacksize;\n int current_class_depth;\n \n-struct class_level\n-{\n-  /* The previous class level.  */\n-  struct class_level *level_chain;\n-\n-  /* The class instance variable, as a PARM_DECL.  */\n-  tree decl;\n-  /* The class instance variable, as an object.  */\n-  tree object;\n-  /* The virtual function table pointer\n-     for the class instance variable.  */\n-  tree vtable_decl;\n-\n-  /* Name of the current class.  */\n-  tree name;\n-  /* Type of the current class.  */\n-  tree type;\n-\n-  /* Flags for this class level.  */\n-  int this_is_variable;\n-  int memoized_lookups;\n-  int save_memoized;\n-  int unused;\n-};\n-\n /* The current_class_ptr is the pointer to the current class.\n    current_class_ref is the actual current class.  */\n tree current_class_ptr, current_class_ref;\n@@ -4627,7 +4602,6 @@ pushclass (type, modify)\n      int modify;\n {\n   type = TYPE_MAIN_VARIANT (type);\n-  push_memoized_context (type, modify);\n \n   current_class_depth++;\n   *current_class_stack++ = current_class_name;\n@@ -4776,8 +4750,6 @@ popclass (modify)\n   current_class_type = *--current_class_stack;\n   current_class_name = *--current_class_stack;\n \n-  pop_memoized_context (modify);\n-\n  ret:\n   ;\n }"}, {"sha": "ac7fead7831c8a456f75f648d4766177ff35c68e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -621,9 +621,6 @@ struct lang_type\n       unsigned dummy : 11;\n     } type_flags;\n \n-#ifdef MI_MATRIX\n-  int cid;\n-#endif\n   int n_ancestors;\n   int n_vancestors;\n   int vsize;\n@@ -635,7 +632,6 @@ struct lang_type\n   union tree_node *vbases;\n \n   union tree_node *tags;\n-  char *memoized_table_entry;\n \n   union tree_node *search_slot;\n \n@@ -651,10 +647,6 @@ struct lang_type\n   union tree_node *binfo_as_list;\n   union tree_node *friend_classes;\n \n-#ifdef MI_MATRIX\n-  char *mi_matrix;\n-#endif\n-\n   union tree_node *rtti;\n \n   union tree_node *methods;\n@@ -867,11 +859,6 @@ struct lang_type\n    which uses this must define what exactly this slot is used for.  */\n #define CLASSTYPE_SEARCH_SLOT(NODE) (TYPE_LANG_SPECIFIC(NODE)->search_slot)\n \n-/* Entry for keeping memoization tables for this type to\n-   hopefully speed up search routines.  Since it is a pointer,\n-   it can mean almost anything.  */\n-#define CLASSTYPE_MTABLE_ENTRY(NODE) (TYPE_LANG_SPECIFIC(NODE)->memoized_table_entry)\n-\n /* These are the size, mode and alignment of the type without its\n    virtual base classes, for when we use this type as a base itself.  */\n #define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n@@ -935,12 +922,6 @@ struct lang_type\n    case of a template friend.  */\n #define CLASSTYPE_FRIEND_CLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->friend_classes)\n \n-#ifdef MI_MATRIX\n-/* Keep an inheritance lattice around so we can quickly tell whether\n-   a type is derived from another or not.  */\n-#define CLASSTYPE_MI_MATRIX(NODE) (TYPE_LANG_SPECIFIC(NODE)->mi_matrix)\n-#endif\n-\n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n #define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n \n@@ -976,14 +957,6 @@ struct lang_type\n    depth-first order via TREE_CHAIN.  Other than that, TREE_CHAIN is\n    unused.  */\n \n-#ifdef MI_MATRIX\n-/* When building a matrix to determine by a single lookup\n-   whether one class is derived from another or not,\n-   this field is the index of the class in the table.  */\n-#define CLASSTYPE_CID(NODE) (TYPE_LANG_SPECIFIC(NODE)->cid)\n-#define BINFO_CID(NODE) CLASSTYPE_CID(BINFO_TYPE(NODE))\n-#endif\n-\n /* Nonzero means marked by DFS or BFS search, including searches\n    by `get_binfo' and `get_base_distance'.  */\n #define BINFO_MARKED(NODE) (TREE_VIA_VIRTUAL(NODE)?CLASSTYPE_MARKED(BINFO_TYPE(NODE)):TREE_LANG_FLAG_0(NODE))\n@@ -2876,8 +2849,6 @@ extern void synthesize_tinfo_fn\t\t\tPROTO((tree));\n \n /* in search.c */\n extern int types_overlap_p\t\t\tPROTO((tree, tree));\n-extern void push_memoized_context\t\tPROTO((tree, int));\n-extern void pop_memoized_context\t\tPROTO((int));\n extern tree get_vbase\t\t\t\tPROTO((tree, tree));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n@@ -2895,16 +2866,10 @@ extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree, tree));\n extern void clear_search_slots\t\t\tPROTO((tree));\n extern tree get_vbase_types\t\t\tPROTO((tree));\n-extern void build_mi_matrix\t\t\tPROTO((tree));\n-extern void free_mi_matrix\t\t\tPROTO((void));\n-extern void build_mi_virtuals\t\t\tPROTO((int, int));\n-extern void add_mi_virtuals\t\t\tPROTO((int, tree));\n-extern void report_ambiguous_mi_virtuals\tPROTO((int, tree));\n extern void note_debug_info_needed\t\tPROTO((tree));\n extern void push_class_decls\t\t\tPROTO((tree));\n extern void pop_class_decls\t\t\tPROTO((void));\n extern void unuse_fields\t\t\tPROTO((tree));\n-extern void unmark_finished_struct\t\tPROTO((tree));\n extern void print_search_statistics\t\tPROTO((void));\n extern void init_search_processing\t\tPROTO((void));\n extern void reinit_search_statistics\t\tPROTO((void));"}, {"sha": "2deeaa80b7ce2067630de091416f8c6ffa7e6cad", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -12478,8 +12478,6 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     }\n   else\n     {\n-      if (!DECL_STATIC_FUNCTION_P (decl1))\n-\tpush_memoized_context (NULL_TREE, 1);\n       current_class_ptr = current_class_ref = NULL_TREE;\n     }\n \n@@ -13225,8 +13223,6 @@ finish_function (lineno, call_poplevel, nested)\n       ctype = current_class_type;\n       pop_nested_class (1);\n     }\n-  else\n-    pop_memoized_context (1);\n \n   /* Must mark the RESULT_DECL as being in this function.  */\n   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;"}, {"sha": "6a1540bb911f00865441d7bcd57799ca0036546c", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -343,10 +343,6 @@ int flag_all_virtual;\n \n int flag_this_is_variable;\n \n-/* Nonzero means memoize our member lookups.  */\n-\n-int flag_memoize_lookups; int flag_save_memoized_contexts;\n-\n /* 3 means write out only virtuals function tables `defined'\n    in this implementation file.\n    2 means write out only specific virtual function tables\n@@ -491,7 +487,6 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"this-is-variable\", &flag_this_is_variable, 1},\n   {\"strict-prototype\", &flag_strict_prototype, 1},\n   {\"all-virtual\", &flag_all_virtual, 1},\n-  {\"memoize-lookups\", &flag_memoize_lookups, 1},\n   {\"elide-constructors\", &flag_elide_constructors, 1},\n   {\"handle-exceptions\", &flag_exceptions, 1},\n   {\"handle-signatures\", &flag_handle_signatures, 1},\n@@ -578,16 +573,12 @@ lang_decode_option (argc, argv)\n \t  || !strcmp (p, \"no-handle-exceptions\"))\n \twarning (\"-fhandle-exceptions has been renamed to -fexceptions (and is now on by default)\");\n \n-      if (!strcmp (p, \"save-memoized\"))\n-\t{\n-\t  flag_memoize_lookups = 1;\n-\t  flag_save_memoized_contexts = 1;\n-\t  found = 1;\n-\t}\n-      else if (!strcmp (p, \"no-save-memoized\"))\n+      if (!strcmp (p, \"memoize-lookups\")\n+\t  || !strcmp (p, \"no-memoize-lookups\")\n+\t  || !strcmp (p, \"save-memoized\")\n+\t  || !strcmp (p, \"no-save-memoized\"))\n \t{\n-\t  flag_memoize_lookups = 0;\n-\t  flag_save_memoized_contexts = 0;\n+\t  /* ignore */\n \t  found = 1;\n \t}\n       else if (! strcmp (p, \"alt-external-templates\"))"}, {"sha": "e96f7e50b12845335cc6f298c53f914fddad4815", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -1614,8 +1614,6 @@ build_offset_ref (type, name)\n      lookup_fnfield.  */\n   if (fnfields)\n     {\n-      extern int flag_save_memoized_contexts;\n-\n       /* Go from the TREE_BASELINK to the member function info.  */\n       t = TREE_VALUE (fnfields);\n \n@@ -1670,15 +1668,13 @@ build_offset_ref (type, name)\n \n       /* FNFIELDS is most likely allocated on the search_obstack,\n \t which will go away after this class scope.  If we need\n-\t to save this value for later (either for memoization\n-\t or for use as an initializer for a static variable), then\n-\t do so here.\n+\t to save this value for later (i.e. for use as an initializer\n+\t for a static variable), then do so here.\n \n \t ??? The smart thing to do for the case of saving initializers\n \t is to resolve them before we're done with this scope.  */\n       if (!TREE_PERMANENT (fnfields)\n-\t  && ((flag_save_memoized_contexts && toplevel_bindings_p ())\n-\t      || ! allocation_temporary_p ()))\n+\t  && ! allocation_temporary_p ())\n \tfnfields = copy_list (fnfields);\n \n       t = build_tree_list (error_mark_node, fnfields);"}, {"sha": "d8f85bd1f20abaace4143ad05a2b58c7d71de8ae", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -56,7 +56,7 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fno-guiding-decls\", \"\" },\n   { \"-fgnu-keywords\", \"\" },\n   { \"-fno-gnu-keywords\", \"Do not recognise GNU defined keywords\" },\n-  { \"-fhandle-exceptions\", \"Enable exception handling\" },\n+  { \"-fhandle-exceptions\", \"\" },\n   { \"-fno-handle-exceptions\", \"\" },\n   { \"-fhandle-signatures\", \"Handle signature language constructs\" },\n   { \"-fno-handle-signatures\", \"\" },\n@@ -72,7 +72,7 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fno-init-priority\", \"\" },\n   { \"-flabels-ok\", \"Labels can be used as first class objects\" },\n   { \"-fno-labels-ok\", \"\" },\n-  { \"-fmemoize-lookups\", \"Enable caching of member function resolutions\" },\n+  { \"-fmemoize-lookups\", \"\" },\n   { \"-fno-memoize-lookups\", \"\" },\n   { \"-fname-mangling-version-\", \"Set the version of name mangling to use\" },\n   { \"-fnew-abi\", \"Enable experimental ABI changes\" },\n@@ -85,7 +85,7 @@ DEFINE_LANG_NAME (\"C++\")\n   { \"-fno-optional-diags\", \"Disable optional diagnostics\" },\n   { \"-frepo\", \"Enable automatic template instantiation\" },\n   { \"-fno-repo\", \"\" },\n-  { \"-fsave-memoized\", \"Save cache of member function resolutions\" },\n+  { \"-fsave-memoized\", \"\" },\n   { \"-fno-save-memoized\", \"\" },\n   { \"-fsquangle\", \"Enable squashed name mangling\" },\n   { \"-fno-squangle\", \"\" },"}, {"sha": "ed378c0e9cda21ed62c93f0e066f5946687fceaa", "filename": "gcc/cp/search.c", "status": "modified", "additions": 14, "deletions": 644, "changes": 658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=e907984f30a9d20a75d46b2c38bb26bb4fdaa9fe", "patch": "@@ -76,8 +76,6 @@ pop_stack_level (stack)\n #define search_level stack_level\n static struct search_level *search_stack;\n \n-static void clear_memoized_cache PROTO((void));\n-static tree make_memoized_table_entry PROTO((tree, tree, int));\n static tree get_abstract_virtuals_1 PROTO((tree, int, tree));\n static tree get_vbase_1 PROTO((tree, tree, unsigned int *));\n static tree convert_pointer_to_vbase PROTO((tree, tree));\n@@ -104,20 +102,11 @@ static void fixup_virtual_upcast_offsets\n \t       tree *));\n static int markedp PROTO((tree));\n static int unmarkedp PROTO((tree));\n-#ifdef MI_MATRIX\n-static int numberedp PROTO((tree));\n-static int unnumberedp PROTO((tree));\n-#endif\n static int marked_vtable_pathp PROTO((tree));\n static int unmarked_vtable_pathp PROTO((tree));\n static int marked_new_vtablep PROTO((tree));\n static int unmarked_new_vtablep PROTO((tree));\n static int dfs_debug_unmarkedp PROTO((tree));\n-#ifdef MI_MATRIX\n-static void dfs_number PROTO((tree));\n-static void dfs_unnumber PROTO((tree));\n-static void dfs_record_inheritance PROTO((tree));\n-#endif\n static void dfs_debug_mark PROTO((tree));\n static void dfs_find_vbases PROTO((tree));\n static void dfs_clear_vbase_slots PROTO((tree));\n@@ -136,14 +125,6 @@ static struct search_level *push_search_level\n \tPROTO((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n \tPROTO((struct stack_level *));\n-static struct type_level *push_type_level\n-\tPROTO((struct stack_level *, struct obstack *));\n-static struct type_level *pop_type_level\n-\tPROTO((struct type_level *));\n-static tree my_tree_cons PROTO((tree, tree, tree));\n-static tree my_build_string PROTO((char *));\n-static struct memoized_entry * my_new_memoized_entry\n-\tPROTO((struct memoized_entry *));\n static HOST_WIDE_INT breadth_first_search\n \tPROTO((tree, int (*) (tree, int), int (*) (tree, int)));\n \n@@ -175,39 +156,11 @@ pop_search_level (obstack)\n   return stack;\n }\n \f\n-/* Search memoization.  */\n-\n-struct type_level\n-{\n-  struct stack_level base;\n-\n-  /* First object allocated in obstack of entries.  */\n-  char *entries;\n-\n-  /* Number of types memoized in this context.  */\n-  int len;\n-\n-  /* Type being memoized; save this if we are saving\n-     memoized contexts.  */\n-  tree type;\n-};\n-\n /* Obstack used for memoizing member and member function lookup.  */\n \n-static struct obstack type_obstack, type_obstack_entries;\n-static struct type_level *type_stack;\n static tree _vptr_name;\n \n-/* Make things that look like tree nodes, but allocate them\n-   on type_obstack_entries.  */\n-static int my_tree_node_counter;\n-\n-extern int flag_memoize_lookups, flag_save_memoized_contexts;\n-\n /* Variables for gathering statistics.  */\n-static int my_memoized_entry_counter;\n-static int memoized_fast_finds[2], memoized_adds[2], memoized_fast_rejects[2];\n-static int memoized_fields_searched[2];\n #ifdef GATHER_STATISTICS\n static int n_fields_searched;\n static int n_calls_lookup_field, n_calls_lookup_field_1;\n@@ -217,259 +170,9 @@ static int n_outer_fields_searched;\n static int n_contexts_saved;\n #endif /* GATHER_STATISTICS */\n \n-/* Local variables to help save memoization contexts.  */\n-static tree prev_type_memoized;\n-static struct type_level *prev_type_stack;\n-\n /* This list is used by push_class_decls to know what decls need to\n    be pushed into class scope.  */\n static tree closed_envelopes = NULL_TREE;\n-\n-/* Allocate a level of type memoization context.  */\n-\n-static struct type_level *\n-push_type_level (stack, obstack)\n-     struct stack_level *stack;\n-     struct obstack *obstack;\n-{\n-  struct type_level tem;\n-\n-  tem.base.prev = stack;\n-\n-  obstack_finish (&type_obstack_entries);\n-  tem.entries = (char *) obstack_base (&type_obstack_entries);\n-  tem.len = 0;\n-  tem.type = NULL_TREE;\n-\n-  return (struct type_level *)push_stack_level (obstack, (char *)&tem, sizeof (tem));\n-}\n-\n-/* Discard a level of type memoization context.  */\n-\n-static struct type_level *\n-pop_type_level (stack)\n-     struct type_level *stack;\n-{\n-  obstack_free (&type_obstack_entries, stack->entries);\n-  return (struct type_level *)pop_stack_level ((struct stack_level *)stack);\n-}\n-\n-/* Make something that looks like a TREE_LIST, but\n-   do it on the type_obstack_entries obstack.  */\n-\n-static tree\n-my_tree_cons (purpose, value, chain)\n-     tree purpose, value, chain;\n-{\n-  tree p;\n-  struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = &type_obstack_entries;\n-  p = tree_cons (purpose, value, chain);\n-  current_obstack = ambient_obstack;\n-  ++my_tree_node_counter;\n-  return p;\n-}\n-\n-static tree\n-my_build_string (str)\n-     char *str;\n-{\n-  tree p = (tree)obstack_alloc (&type_obstack_entries, sizeof (struct tree_string));\n-  ++my_tree_node_counter;\n-  TREE_TYPE (p) = 0;\n-  ((int *)p)[3] = 0;\n-  TREE_SET_CODE (p, STRING_CST);\n-  TREE_STRING_POINTER (p) = str;\n-  TREE_STRING_LENGTH (p) = strlen (str);\n-  return p;\n-}\n-\f\n-/* Memoizing machinery to make searches for multiple inheritance\n-   reasonably efficient.  */\n-\n-#define MEMOIZE_HASHSIZE 8\n-typedef struct memoized_entry\n-{\n-  struct memoized_entry *chain;\n-  int uid;\n-  tree data_members[MEMOIZE_HASHSIZE];\n-  tree function_members[MEMOIZE_HASHSIZE];\n-} *ME;\n-\n-#define MEMOIZED_CHAIN(ENTRY) (((ME)ENTRY)->chain)\n-#define MEMOIZED_UID(ENTRY) (((ME)ENTRY)->uid)\n-#define MEMOIZED_FIELDS(ENTRY,INDEX) (((ME)ENTRY)->data_members[INDEX])\n-#define MEMOIZED_FNFIELDS(ENTRY,INDEX) (((ME)ENTRY)->function_members[INDEX])\n-/* The following is probably a lousy hash function.  */\n-#define MEMOIZED_HASH_FN(NODE) (((long)(NODE)>>4)&(MEMOIZE_HASHSIZE - 1))\n-\n-static struct memoized_entry *\n-my_new_memoized_entry (chain)\n-     struct memoized_entry *chain;\n-{\n-  struct memoized_entry *p\n-    = (struct memoized_entry *)obstack_alloc (&type_obstack_entries,\n-\t\t\t\t\t      sizeof (struct memoized_entry));\n-  bzero ((char *) p, sizeof (struct memoized_entry));\n-  MEMOIZED_CHAIN (p) = chain;\n-  MEMOIZED_UID (p) = ++my_memoized_entry_counter;\n-  return p;\n-}\n-\n-/* Clears the deferred pop from pop_memoized_context, if any.  */\n-\n-static void\n-clear_memoized_cache ()\n-{\n-  if (prev_type_stack)\n-    {\n-      type_stack = pop_type_level (prev_type_stack);\n-      prev_type_memoized = 0;\n-      prev_type_stack = 0;\n-    }\n-}\n-\n-/* Make an entry in the memoized table for type TYPE\n-   that the entry for NAME is FIELD.  */\n-\n-static tree\n-make_memoized_table_entry (type, name, function_p)\n-     tree type, name;\n-     int function_p;\n-{\n-  int idx = MEMOIZED_HASH_FN (name);\n-  tree entry, *prev_entry;\n-\n-  /* Since we allocate from the type_obstack, we must pop any deferred\n-     levels.  */\n-   clear_memoized_cache ();\n-\n-  memoized_adds[function_p] += 1;\n-  if (CLASSTYPE_MTABLE_ENTRY (type) == 0)\n-    {\n-      obstack_ptr_grow (&type_obstack, type);\n-      obstack_blank (&type_obstack, sizeof (struct memoized_entry *));\n-      CLASSTYPE_MTABLE_ENTRY (type) = (char *)my_new_memoized_entry ((struct memoized_entry *)0);\n-      type_stack->len++;\n-      if (type_stack->len * 2 >= type_stack->base.limit)\n-\tmy_friendly_abort (88);\n-    }\n-  if (function_p)\n-    prev_entry = &MEMOIZED_FNFIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n-  else\n-    prev_entry = &MEMOIZED_FIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n-\n-  entry = my_tree_cons (name, NULL_TREE, *prev_entry);\n-  *prev_entry = entry;\n-\n-  /* Don't know the error message to give yet.  */\n-  TREE_TYPE (entry) = error_mark_node;\n-\n-  return entry;\n-}\n-\n-/* When a new function or class context is entered, we build\n-   a table of types which have been searched for members.\n-   The table is an array (obstack) of types.  When a type is\n-   entered into the obstack, its CLASSTYPE_MTABLE_ENTRY\n-   field is set to point to a new record, of type struct memoized_entry.\n-\n-   A non-NULL TREE_TYPE of the entry contains an access control error message.\n-\n-   The slots for the data members are arrays of tree nodes.\n-   These tree nodes are lists, with the TREE_PURPOSE\n-   of this list the known member name, and the TREE_VALUE\n-   as the FIELD_DECL for the member.\n-\n-   For member functions, the TREE_PURPOSE is again the\n-   name of the member functions for that class,\n-   and the TREE_VALUE of the list is a pairs\n-   whose TREE_PURPOSE is a member functions of this name,\n-   and whose TREE_VALUE is a list of known argument lists this\n-   member function has been called with.  The TREE_TYPE of the pair,\n-   if non-NULL, is an error message to print.  */\n-\n-/* Tell search machinery that we are entering a new context, and\n-   to update tables appropriately.\n-\n-   TYPE is the type of the context we are entering, which can\n-   be NULL_TREE if we are not in a class's scope.\n-\n-   USE_OLD, if nonzero tries to use previous context.  */\n-\n-void\n-push_memoized_context (type, use_old)\n-     tree type;\n-     int use_old;\n-{\n-  int len;\n-  tree *tem;\n-\n-  if (prev_type_stack)\n-    {\n-      if (use_old && prev_type_memoized == type)\n-\t{\n-#ifdef GATHER_STATISTICS\n-\t  n_contexts_saved++;\n-#endif /* GATHER_STATISTICS */\n-\t  type_stack = prev_type_stack;\n-\t  prev_type_stack = 0;\n-\n-\t  tem = &type_stack->base.first[0];\n-\t  len = type_stack->len;\n-\t  while (len--)\n-\t    CLASSTYPE_MTABLE_ENTRY (tem[len*2]) = (char *)tem[len*2+1];\n-\t  return;\n-\t}\n-      /* Otherwise, need to pop old stack here.  */\n-      clear_memoized_cache ();\n-    }\n-\n-  type_stack = push_type_level ((struct stack_level *)type_stack,\n-\t\t\t\t&type_obstack);\n-  type_stack->type = type;\n-}\n-\n-/* Tell search machinery that we have left a context.\n-   We do not currently save these contexts for later use.\n-   If we wanted to, we could not use pop_search_level, since\n-   poping that level allows the data we have collected to\n-   be clobbered; a stack of obstacks would be needed.  */\n-\n-void\n-pop_memoized_context (use_old)\n-     int use_old;\n-{\n-  int len;\n-  tree *tem = &type_stack->base.first[0];\n-\n-  if (! flag_save_memoized_contexts)\n-    use_old = 0;\n-  else if (use_old)\n-    {\n-      len = type_stack->len;\n-      while (len--)\n-\ttem[len*2+1] = (tree)CLASSTYPE_MTABLE_ENTRY (tem[len*2]);\n-\n-      /* If there was a deferred pop, we need to pop it now.  */\n-      clear_memoized_cache ();\n-\n-      prev_type_stack = type_stack;\n-      prev_type_memoized = type_stack->type;\n-    }\n-\n-  if (flag_memoize_lookups)\n-    {\n-      len = type_stack->len;\n-      while (len--)\n-\tCLASSTYPE_MTABLE_ENTRY (tem[len*2])\n-\t  = (char *)MEMOIZED_CHAIN (CLASSTYPE_MTABLE_ENTRY (tem[len*2]));\n-    }\n-  if (! use_old)\n-    type_stack = pop_type_level (type_stack);\n-  else\n-    type_stack = (struct type_level *)type_stack->base.prev;\n-}\n \f\n /* Get a virtual binfo that is found inside BINFO's hierarchy that is\n    the same type as the type given in PARENT.  To be optimal, we want\n@@ -1193,10 +896,6 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   char *errstr = 0;\n \n-  /* Set this to nonzero if we don't know how to compute\n-     accurate error messages for access control.  */\n-  int idx = MEMOIZED_HASH_FN (name);\n-\n #if 0\n   /* We cannot search for constructor/destructor names like this.  */\n   /* This can't go here, but where should it go?  */\n@@ -1232,47 +931,14 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   complete_type (type);\n \n-  if (CLASSTYPE_MTABLE_ENTRY (type))\n-    {\n-      tree tem = MEMOIZED_FIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n-\n-      while (tem && TREE_PURPOSE (tem) != name)\n-\t{\n-\t  memoized_fields_searched[0]++;\n-\t  tem = TREE_CHAIN (tem);\n-\t}\n-      if (tem)\n-\t{\n-\t  if (protect && TREE_TYPE (tem))\n-\t    {\n-\t      error (TREE_STRING_POINTER (TREE_TYPE (tem)),\n-\t\t     IDENTIFIER_POINTER (name),\n-\t\t     TYPE_NAME_STRING (DECL_FIELD_CONTEXT (TREE_VALUE (tem))));\n-\t      return error_mark_node;\n-\t    }\n-\t  if (TREE_VALUE (tem) == NULL_TREE)\n-\t    memoized_fast_rejects[0] += 1;\n-\t  else\n-\t    memoized_fast_finds[0] += 1;\n-\t  return TREE_VALUE (tem);\n-\t}\n-    }\n-\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_field++;\n #endif /* GATHER_STATISTICS */\n-  if (protect && flag_memoize_lookups && ! toplevel_bindings_p ())\n-    entry = make_memoized_table_entry (type, name, 0);\n-  else\n-    entry = 0;\n \n   rval = lookup_field_1 (type, name);\n \n   if (rval || lookup_fnfields_here (type, name) >= 0)\n     {\n-      if (entry)\n-\tTREE_VALUE (entry) = rval;\n-\n       if (rval)\n \t{\n \t  if (want_type)\n@@ -1339,13 +1005,13 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      tree btypes;\n \n \t      SET_BINFO_FIELDS_MARKED (base_binfo);\n-\t      btypes = my_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n+\t      btypes = scratch_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\tbtypes = my_tree_cons (NULL_TREE,\n+\t\tbtypes = scratch_tree_cons (NULL_TREE,\n \t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n \t\t\t\t    btypes);\n \t      else\n-\t\tbtypes = my_tree_cons (NULL_TREE,\n+\t\tbtypes = scratch_tree_cons (NULL_TREE,\n \t\t\t\t    TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i),\n \t\t\t\t    btypes);\n \t      obstack_ptr_grow (&search_obstack, btypes);\n@@ -1398,7 +1064,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \t      if (nval)\n \t\t{\n \t\t  rval = nval;\n-\t\t  if (entry || protect)\n+\t\t  if (protect)\n \t\t    this_v = compute_access (basetype_path, rval);\n \t\t  /* These may look ambiguous, but they really are not.  */\n \t\t  if (vbase_name_p)\n@@ -1425,9 +1091,6 @@ lookup_field (xbasetype, name, protect, want_type)\n     tree *tp = search_stack->first;\n     tree *search_tail = tp + tail;\n \n-    if (entry)\n-      TREE_VALUE (entry) = rval;\n-\n     if (rval_binfo)\n       {\n \ttype = BINFO_TYPE (rval_binfo);\n@@ -1457,7 +1120,7 @@ lookup_field (xbasetype, name, protect, want_type)\n \n     /* If this FIELD_DECL defines its own access level, deal with that.  */\n     if (rval && errstr == 0\n-\t&& ((protect&1) || entry)\n+\t&& (protect & 1)\n \t&& DECL_LANG_SPECIFIC (rval)\n \t&& DECL_ACCESS (rval))\n       {\n@@ -1508,21 +1171,6 @@ lookup_field (xbasetype, name, protect, want_type)\n     }\n \n  out:\n-  if (entry)\n-    {\n-      if (errstr)\n-\t{\n-\t  tree error_string = my_build_string (errstr);\n-\t  /* Save error message with entry.  */\n-\t  TREE_TYPE (entry) = error_string;\n-\t}\n-      else\n-\t{\n-\t  /* Mark entry as having no error string.  */\n-\t  TREE_TYPE (entry) = NULL_TREE;\n-\t}\n-    }\n-\n   if (protect == 2)\n     {\n       /* If we are not interested in ambiguities, don't report them,\n@@ -1707,8 +1355,8 @@ lookup_fnfields (basetype_path, name, complain)\n {\n   int head = 0, tail = 0;\n   tree type, rval, rval_binfo = NULL_TREE, rvals = NULL_TREE;\n-  tree rval_binfo_h = NULL_TREE, entry, binfo, basetype_chain, binfo_h;\n-  int find_all = 0;\n+  tree rval_binfo_h = NULL_TREE, binfo, basetype_chain, binfo_h;\n+  int idx, find_all = 0;\n \n   /* rval_binfo is the binfo associated with the found member, note,\n      this can be set with useful information, even when rval is not\n@@ -1729,10 +1377,6 @@ lookup_fnfields (basetype_path, name, complain)\n \n   char *errstr = 0;\n \n-  /* Set this to nonzero if we don't know how to compute\n-     accurate error messages for access control.  */\n-  int idx = MEMOIZED_HASH_FN (name);\n-\n   if (complain == -1)\n     {\n       find_all = 1;\n@@ -1752,65 +1396,9 @@ lookup_fnfields (basetype_path, name, complain)\n   binfo_h = binfo;\n   type = complete_type (BINFO_TYPE (basetype_path));\n \n-  /* The memoization code is in need of maintenance.  */\n-  if (!find_all && CLASSTYPE_MTABLE_ENTRY (type))\n-    {\n-      tree tem = MEMOIZED_FNFIELDS (CLASSTYPE_MTABLE_ENTRY (type), idx);\n-\n-      while (tem && TREE_PURPOSE (tem) != name)\n-\t{\n-\t  memoized_fields_searched[1]++;\n-\t  tem = TREE_CHAIN (tem);\n-\t}\n-      if (tem)\n-\t{\n-\t  if (protect && TREE_TYPE (tem))\n-\t    {\n-\t      error (TREE_STRING_POINTER (TREE_TYPE (tem)),\n-\t\t     IDENTIFIER_POINTER (name),\n-\t\t     TYPE_NAME_STRING (DECL_CLASS_CONTEXT (TREE_VALUE (TREE_VALUE (tem)))));\n-\t      return error_mark_node;\n-\t    }\n-\t  if (TREE_VALUE (tem) == NULL_TREE)\n-\t    {\n-\t      memoized_fast_rejects[1] += 1;\n-\t      return NULL_TREE;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Want to return this, but we must make sure\n-\t\t that access information is consistent.  */\n-\t      tree baselink = TREE_VALUE (tem);\n-\t      tree memoized_basetypes = TREE_PURPOSE (baselink);\n-\t      tree these_basetypes = basetype_path;\n-\t      while (memoized_basetypes && these_basetypes)\n-\t\t{\n-\t\t  memoized_fields_searched[1]++;\n-\t\t  if (TREE_VALUE (memoized_basetypes) != these_basetypes)\n-\t\t    break;\n-\t\t  memoized_basetypes = TREE_CHAIN (memoized_basetypes);\n-\t\t  these_basetypes = BINFO_INHERITANCE_CHAIN (these_basetypes);\n-\t\t}\n-\t      /* The following statement is true only when both are NULL.  */\n-\t      if (memoized_basetypes == these_basetypes)\n-\t\t{\n-\t\t  memoized_fast_finds[1] += 1;\n-\t\t  return TREE_VALUE (tem);\n-\t\t}\n-\t      /* else, we must re-find this field by hand.  */\n-\t      baselink = tree_cons (basetype_path, TREE_VALUE (baselink), TREE_CHAIN (baselink));\n-\t      return baselink;\n-\t    }\n-\t}\n-    }\n-\n #ifdef GATHER_STATISTICS\n   n_calls_lookup_fnfields++;\n #endif /* GATHER_STATISTICS */\n-  if (protect && flag_memoize_lookups && ! toplevel_bindings_p ())\n-    entry = make_memoized_table_entry (type, name, 1);\n-  else\n-    entry = 0;\n \n   idx = lookup_fnfields_here (type, name);\n   if (idx >= 0 || lookup_field_1 (type, name))\n@@ -1822,16 +1410,10 @@ lookup_fnfields (basetype_path, name, complain)\n   if (idx >= 0)\n     {\n       rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n-      rvals = my_tree_cons (basetype_path, rval, rvals);\n+      rvals = scratch_tree_cons (basetype_path, rval, rvals);\n       if (BINFO_BASETYPES (binfo) && CLASSTYPE_BASELINK_VEC (type))\n \tTREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n \n-      if (entry)\n-\t{\n-\t  TREE_VALUE (entry) = rvals;\n-\t  TREE_TYPE (entry) = NULL_TREE;\n-\t}\n-\n       return rvals;\n     }\n   rval = NULL_TREE;\n@@ -1840,9 +1422,6 @@ lookup_fnfields (basetype_path, name, complain)\n     {\n       /* Don't allow lookups of constructors and destructors to go\n  \t deeper than the first place we look.  */\n-      if (entry)\n- \tTREE_TYPE (entry) = TREE_VALUE (entry) = NULL_TREE;\n-\n       return NULL_TREE;\n     }\n \n@@ -1876,13 +1455,13 @@ lookup_fnfields (basetype_path, name, complain)\n \t      tree btypes;\n \n \t      SET_BINFO_FIELDS_MARKED (base_binfo);\n-\t      btypes = my_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n+\t      btypes = scratch_tree_cons (NULL_TREE, base_binfo, basetype_chain);\n \t      if (TREE_VIA_VIRTUAL (base_binfo))\n-\t\tbtypes = my_tree_cons (NULL_TREE,\n+\t\tbtypes = scratch_tree_cons (NULL_TREE,\n \t\t\t\t    TYPE_BINFO (BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i))),\n \t\t\t\t    btypes);\n \t      else\n-\t\tbtypes = my_tree_cons (NULL_TREE,\n+\t\tbtypes = scratch_tree_cons (NULL_TREE,\n \t\t\t\t    TREE_VEC_ELT (BINFO_BASETYPES (binfo_h), i),\n \t\t\t\t    btypes);\n \t      obstack_ptr_grow (&search_obstack, btypes);\n@@ -1933,7 +1512,7 @@ lookup_fnfields (basetype_path, name, complain)\n \t\t  rval = TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), idx);\n \t\t  /* Note, rvals can only be previously set if find_all is\n \t\t     true.  */\n-\t\t  rvals = my_tree_cons (basetype_path, rval, rvals);\n+\t\t  rvals = scratch_tree_cons (basetype_path, rval, rvals);\n \t\t  if (TYPE_BINFO_BASETYPES (type)\n \t\t      && CLASSTYPE_BASELINK_VEC (type))\n \t\t    TREE_TYPE (rvals) = TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), idx);\n@@ -1968,22 +1547,6 @@ lookup_fnfields (basetype_path, name, complain)\n   }\n   search_stack = pop_search_level (search_stack);\n \n-  if (entry)\n-    {\n-      if (errstr)\n-\t{\n-\t  tree error_string = my_build_string (errstr);\n-\t  /* Save error message with entry.  */\n-\t  TREE_TYPE (entry) = error_string;\n-\t}\n-      else\n-\t{\n-\t  /* Mark entry as having no error string.  */\n-\t  TREE_TYPE (entry) = NULL_TREE;\n-\t  TREE_VALUE (entry) = rvals;\n-\t}\n-    }\n-\n   if (errstr && protect)\n     {\n       cp_error (errstr, name);\n@@ -2492,33 +2055,6 @@ next_baselink (baselink)\n \f\n /* DEPTH-FIRST SEARCH ROUTINES.  */\n \n-#ifdef MI_MATRIX\n-/* Assign unique numbers to _CLASSTYPE members of the lattice\n-   specified by TYPE.  The root nodes are marked first; the nodes\n-   are marked depth-fisrt, left-right.  */\n-\n-static int cid;\n-\n-/* Matrix implementing a relation from CLASSTYPE X CLASSTYPE => INT.\n-   Relation yields 1 if C1 <= C2, 0 otherwise.  */\n-typedef char mi_boolean;\n-static mi_boolean *mi_matrix;\n-\n-/* Type for which this matrix is defined.  */\n-static tree mi_type;\n-\n-/* Size of the matrix for indexing purposes.  */\n-static int mi_size;\n-\n-/* Return nonzero if class C2 derives from class C1.  */\n-#define BINFO_DERIVES_FROM(C1, C2)\t\\\n-  ((mi_matrix+mi_size*(BINFO_CID (C1)-1))[BINFO_CID (C2)-1])\n-#define TYPE_DERIVES_FROM(C1, C2)\t\\\n-  ((mi_matrix+mi_size*(CLASSTYPE_CID (C1)-1))[CLASSTYPE_CID (C2)-1])\n-#define BINFO_DERIVES_FROM_STAR(C)\t\\\n-  (mi_matrix+(BINFO_CID (C)-1))\n-#endif\n-\n /* This routine converts a pointer to be a pointer of an immediate\n    base class.  The normal convert_pointer_to routine would diagnose\n    the conversion as ambiguous, under MI code that has the base class\n@@ -2611,14 +2147,6 @@ dfs_walk (binfo, fn, qfn)\n   fn (binfo);\n }\n \n-#ifdef MI_MATRIX\n-/* Predicate functions which serve for dfs_walk.  */\n-static int numberedp (binfo) tree binfo;\n-{ return BINFO_CID (binfo); }\n-static int unnumberedp (binfo) tree binfo;\n-{ return BINFO_CID (binfo) == 0; }\n-#endif\n-\n static int markedp (binfo) tree binfo;\n { return BINFO_MARKED (binfo); }\n static int unmarkedp (binfo) tree binfo;\n@@ -2664,25 +2192,6 @@ static int dfs_debug_unmarkedp (binfo) tree binfo;\n    test anything (vis a vis marking) if they are paired with\n    a predicate function (above).  */\n \n-#ifdef MI_MATRIX\n-/* Assign each type within the lattice a number which is unique\n-   in the lattice.  The first number assigned is 1.  */\n-\n-static void\n-dfs_number (binfo)\n-     tree binfo;\n-{\n-  BINFO_CID (binfo) = ++cid;\n-}\n-\n-static void\n-dfs_unnumber (binfo)\n-     tree binfo;\n-{\n-  BINFO_CID (binfo) = 0;\n-}\n-#endif\n-\n #if 0\n static void\n dfs_mark (binfo) tree binfo;\n@@ -3229,95 +2738,6 @@ get_vbase_types (type)\n   return vbase_types;\n }\n \f\n-#ifdef MI_MATRIX\n-static void\n-dfs_record_inheritance (binfo)\n-     tree binfo;\n-{\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  mi_boolean *derived_row = BINFO_DERIVES_FROM_STAR (binfo);\n-\n-  for (i = n_baselinks-1; i >= 0; i--)\n-    {\n-      int j;\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      tree baseclass = BINFO_TYPE (base_binfo);\n-      mi_boolean *base_row = BINFO_DERIVES_FROM_STAR (base_binfo);\n-\n-      if (TREE_CODE (baseclass) == TEMPLATE_TYPE_PARM\n-          || TREE_CODE (baseclass) == TEMPLATE_TEMPLATE_PARM)\n-\tcontinue;\n-      my_friendly_assert (CLASSTYPE_CID (baseclass) != 0, 2365);\n-\n-      /* Don't search if there's nothing there!  MI_SIZE can be\n-\t zero as a result of parse errors.  */\n-      if (TYPE_BINFO_BASETYPES (baseclass) && mi_size > 0)\n-\tfor (j = mi_size*(CLASSTYPE_CID (baseclass)-1); j >= 0; j -= mi_size)\n-\t  derived_row[j] |= base_row[j];\n-      TYPE_DERIVES_FROM (baseclass, BINFO_TYPE (binfo)) = 1;\n-    }\n-\n-  SET_BINFO_MARKED (binfo);\n-}\n-\n-/* Given a _CLASSTYPE node in a multiple inheritance lattice,\n-   convert the lattice into a simple relation such that,\n-   given to CIDs, C1 and C2, one can determine if C1 <= C2\n-   or C2 <= C1 or C1 <> C2.\n-\n-   Once constructed, we walk the lattice depth fisrt,\n-   applying various functions to elements as they are encountered.\n-\n-   We use xmalloc here, in case we want to randomly free these tables.  */\n-\n-#define SAVE_MI_MATRIX\n-\n-void\n-build_mi_matrix (type)\n-     tree type;\n-{\n-  tree binfo = TYPE_BINFO (type);\n-  cid = 0;\n-\n-#ifdef SAVE_MI_MATRIX\n-  if (CLASSTYPE_MI_MATRIX (type))\n-    {\n-      mi_size = CLASSTYPE_N_SUPERCLASSES (type) + CLASSTYPE_N_VBASECLASSES (type);\n-      mi_matrix = CLASSTYPE_MI_MATRIX (type);\n-      mi_type = type;\n-      dfs_walk (binfo, dfs_number, unnumberedp);\n-      return;\n-    }\n-#endif\n-\n-  dfs_walk (binfo, dfs_number, unnumberedp);\n-\n-  mi_size = CLASSTYPE_N_SUPERCLASSES (type) + CLASSTYPE_N_VBASECLASSES (type);\n-  if (mi_size < (cid-1))\n-    mi_size = cid-1;\n-  mi_matrix = (char *)xmalloc ((mi_size + 1) * (mi_size + 1));\n-  mi_type = type;\n-  bzero (mi_matrix, (mi_size + 1) * (mi_size + 1));\n-  dfs_walk (binfo, dfs_record_inheritance, unmarkedp);\n-  dfs_walk (binfo, dfs_unmark, markedp);\n-}\n-\n-void\n-free_mi_matrix ()\n-{\n-  dfs_walk (TYPE_BINFO (mi_type), dfs_unnumber, numberedp);\n-\n-#ifdef SAVE_MI_MATRIX\n-  CLASSTYPE_MI_MATRIX (mi_type) = mi_matrix;\n-#else\n-  free (mi_matrix);\n-  mi_size = 0;\n-  cid = 0;\n-#endif\n-}\n-#endif\n-\f\n /* If we want debug info for a type TYPE, make sure all its base types\n    are also marked as being potentially interesting.  This avoids\n    the problem of not writing any debug info for intermediate basetypes\n@@ -3404,16 +2824,7 @@ envelope_add_decl (type, decl, values)\n \t    dont_add = 1;\n \t}\n       else if (type == current_class_type\n-#ifdef MI_MATRIX\n-\t       /* If we don't check CLASSTYPE_CID on CONTEXT right now,\n-\t\t  we'll end up subtracting from the address of MI_MATRIX,\n-\t\t  putting us off in la la land.  */\n-\t       || (CLASSTYPE_CID (type)\n-\t\t   && TYPE_DERIVES_FROM (context, type))\n-#else\n-\t       || DERIVED_FROM_P (context, type)\n-#endif\n-\t       )\n+\t       || DERIVED_FROM_P (context, type))\n \t{\n \t  /* Don't add in *values to list */\n \t  *values = NULL_TREE;\n@@ -3432,16 +2843,7 @@ envelope_add_decl (type, decl, values)\n \t    : DECL_CONTEXT (value);\n \n \tif (type == current_class_type\n-#ifdef MI_MATRIX\n-\t    /* If we don't check CLASSTYPE_CID on CONTEXT right now,\n-\t       we'll end up subtracting from the address of MI_MATRIX,\n-\t       putting us off in la la land.  */\n-\t    || (CLASSTYPE_CID (type)\n-\t\t&& TYPE_DERIVES_FROM (context, type))\n-#else\n-\t    || DERIVED_FROM_P (context, type)\n-#endif\n-\t    )\n+\t    || DERIVED_FROM_P (context, type))\n \t  {\n \t    /* remove *tmp from list */\n \t    *tmp = TREE_CHAIN (*tmp);\n@@ -3781,23 +3183,6 @@ void\n print_search_statistics ()\n {\n #ifdef GATHER_STATISTICS\n-  if (flag_memoize_lookups)\n-    {\n-      fprintf (stderr, \"%d memoized contexts saved\\n\",\n-\t       n_contexts_saved);\n-      fprintf (stderr, \"%d local tree nodes made\\n\", my_tree_node_counter);\n-      fprintf (stderr, \"%d local hash nodes made\\n\", my_memoized_entry_counter);\n-      fprintf (stderr, \"fields statistics:\\n\");\n-      fprintf (stderr, \"  memoized finds = %d; rejects = %d; (searches = %d)\\n\",\n-\t       memoized_fast_finds[0], memoized_fast_rejects[0],\n-\t       memoized_fields_searched[0]);\n-      fprintf (stderr, \"  memoized_adds = %d\\n\", memoized_adds[0]);\n-      fprintf (stderr, \"fnfields statistics:\\n\");\n-      fprintf (stderr, \"  memoized finds = %d; rejects = %d; (searches = %d)\\n\",\n-\t       memoized_fast_finds[1], memoized_fast_rejects[1],\n-\t       memoized_fields_searched[1]);\n-      fprintf (stderr, \"  memoized_adds = %d\\n\", memoized_adds[1]);\n-    }\n   fprintf (stderr, \"%d fields searched in %d[%d] calls to lookup_field[_1]\\n\",\n \t   n_fields_searched, n_calls_lookup_field, n_calls_lookup_field_1);\n   fprintf (stderr, \"%d fnfields searched in %d calls to lookup_fnfields\\n\",\n@@ -3812,27 +3197,12 @@ void\n init_search_processing ()\n {\n   gcc_obstack_init (&search_obstack);\n-  gcc_obstack_init (&type_obstack);\n-  gcc_obstack_init (&type_obstack_entries);\n-\n-  /* This gives us room to build our chains of basetypes,\n-     whether or not we decide to memoize them.  */\n-  type_stack = push_type_level ((struct stack_level *)0, &type_obstack);\n   _vptr_name = get_identifier (\"_vptr\");\n }\n \n void\n reinit_search_statistics ()\n {\n-  my_memoized_entry_counter = 0;\n-  memoized_fast_finds[0] = 0;\n-  memoized_fast_finds[1] = 0;\n-  memoized_adds[0] = 0;\n-  memoized_adds[1] = 0;\n-  memoized_fast_rejects[0] = 0;\n-  memoized_fast_rejects[1] = 0;\n-  memoized_fields_searched[0] = 0;\n-  memoized_fields_searched[1] = 0;\n #ifdef GATHER_STATISTICS\n   n_fields_searched = 0;\n   n_calls_lookup_field = 0, n_calls_lookup_field_1 = 0;"}]}